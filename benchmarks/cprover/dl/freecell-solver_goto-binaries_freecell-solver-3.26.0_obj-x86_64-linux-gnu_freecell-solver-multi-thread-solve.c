// #anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 209
enum anonymous_22 { FCS_NO_SHUFFLING=0, FCS_RAND=1, FCS_WEIGHTING=2 };

// #anon_enum_FLARES_PLAN_RUN_INDEFINITELY=0_FLARES_PLAN_RUN_COUNT_ITERS=1_FLARES_PLAN_CHECKPOINT=2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 78
enum anonymous_23 { FLARES_PLAN_RUN_INDEFINITELY=0, FLARES_PLAN_RUN_COUNT_ITERS=1, FLARES_PLAN_CHECKPOINT=2 };

// tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 693
struct anonymous_17;

// tag-#anon#ST[*{S8}_S8_'befs_positions_by_rank'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests_list'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests_list_end'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'recycle_bin'|]#'brfs'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#_'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#'befs'|]#'meth'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 813
struct anonymous_34;

// tag-#anon#ST[*{S8}_S8_'buffer'||*{S8}_S8_'end_of_buffer'||S32'max_size'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 43
struct anonymous_51;

// tag-#anon#ST[*{S8}_S8_'old_list'||*{S8}_S8_'max_ptr'||*{S8}_S8_'ptr'||*{S8}_S8_'rollback_ptr'||*{SYM#tag-#anon#ST[*{S8}_S8_'recycle_bin'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'recycle_bin'|]#_'meta'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 48
struct anonymous_5;

// tag-#anon#ST[*{S8}_S8_'recycle_bin'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 43
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_hash_symlink_item_struct#}_SYM#tag-fc_solve_hash_symlink_item_struct#_'first_item'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fc_solve_hash_symlink_item_struct#}_SYM#tag-fc_solve_hash_symlink_item_struct#_'first_item'|]#_'entries'||*{SYM#tag-fc_solve_hash_symlink_item_struct#}_SYM#tag-fc_solve_hash_symlink_item_struct#_'list_of_vacant_items'||ENtag-FCS_INLINED_HASH_DATA_TYPE#{U32}_U32_'hash_type'||S32'size'||S32'size_bitmask'||U32'_pad0'||S64'num_elems'||S64'max_num_elems_before_resize'||SYM#tag-#anon#ST[*{S8}_S8_'old_list'||*{S8}_S8_'max_ptr'||*{S8}_S8_'ptr'||*{S8}_S8_'rollback_ptr'||*{SYM#tag-#anon#ST[*{S8}_S8_'recycle_bin'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'recycle_bin'|]#_'meta'|]#'allocator'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 81
struct anonymous_38;

// tag-#anon#ST[*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'||U16'num_moves'||U48'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/internal_move_struct.h line 97
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-#anon#ST[S32'num_flares'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#_'flares'||*{SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#}_SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#_'plan'||S32'num_plan_items'||S32'current_plan_item_idx'||S32'minimal_solution_flare_idx'||S32'all_plan_items_finished_so_far'||*{S8}_S8_'flares_plan_string'||B'flares_plan_compiled'||U24'_pad1'||S32'limit'|]#}_SYM#tag-#anon#ST[S32'num_flares'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#_'flares'||*{SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#}_SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#_'plan'||S32'num_plan_items'||S32'current_plan_item_idx'||S32'minimal_solution_flare_idx'||S32'all_plan_items_finished_so_far'||*{S8}_S8_'flares_plan_string'||B'flares_plan_compiled'||U24'_pad1'||S32'limit'|]#_'instances_list'||S32'num_instances'||S32'current_instance_idx'||S64'current_iterations_limit'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'iterations_board_started_at'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'init_num_checked_states'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#_'active_flare'||SYM#tag-fcs_state_keyval_pair_struct#'state'||SYM#tag-fcs_state_keyval_pair_struct#'running_state'||SYM#tag-fcs_state_keyval_pair_struct#'initial_non_canonized_state'||SYM#tag-#anon#ST[ARR10{S8}_S8_'stack_locs'||ARR8{S8}_S8_'fc_locs'|]#'state_locs'||SYM#tag-#anon#ST[ARR10{S8}_S8_'stack_locs'||ARR8{S8}_S8_'fc_locs'|]#'trace_solution_state_locs'||SYM#tag-#anon#ST[ARR10{S8}_S8_'stack_locs'||ARR8{S8}_S8_'fc_locs'|]#'initial_state_locs'||U16'_pad0'||S32'ret_code'||B'all_instances_were_suspended'||U24'_pad1'||S32'state_validity_ret'||S8'state_validity_card'||U24'_pad2'||*{V(*{V}_V_|S32|S32|*{V}_V_|S32|*{V}_V_)->V}_V(*{V}_V_|S32|S32|*{V}_V_|S32|*{V}_V_)->V_'iter_handler'||*{V(*{V}_V_|S64|S32|*{V}_V_|S64|*{V}_V_)->V}_V(*{V}_V_|S64|S32|*{V}_V_|S64|*{V}_V_)->V_'long_iter_handler'||*{V}_V_'iter_handler_context'||ENtag-FLARES_CHOICE_TYPE#{U32}_U32_'flares_choice'||U32'_pad3'||F64'flares_iters_factor'||*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_'soft_thread'||ARR1280{S8}_S8_'indirect_stacks_buffer'||*{S8}_S8_'state_string_copy'||SYM#tag-#anon#ST[S32'preset_id'||SYM#tag-#anon#ST[U8'freecells_num'||U8'stacks_num'||U8'decks_num'||U8'game_flags'|]#'game_params'||ARR73{S8}_S8_'tests_order'||ARR73{S8}_S8_'allowed_tests'||U16'_pad0'|]#'common_preset'||U32'_pad4'||*{S8}_S8_'error_string'||SYM#tag-#anon#ST[*{S8}_S8_'recycle_bin'|]#'meta_alloc'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 122
struct anonymous;

// tag-#anon#ST[*{SYM#tag-fc_solve_hash_symlink_item_struct#}_SYM#tag-fc_solve_hash_symlink_item_struct#_'first_item'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 74
struct anonymous_53;

// tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 63
struct anonymous_2;

// tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state'||SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}_SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#_'derived_states_random_indexes'||*{S8}_S8_'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 656
struct anonymous_50;

// tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 316
struct anonymous_43;

// tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 62
struct anonymous_19;

// tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'recycle_bin'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 819
struct anonymous_30;

// tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 524
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'||*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'s'||SYM#tag-#anon#ST[ARR10{S8}_S8_'stack_locs'||ARR8{S8}_S8_'fc_locs'|]#'locs'||U48'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 612
struct anonymous_13;

// tag-#anon#ST[*{cS8}_cS8_'alias'||S32'test_num'||U32'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.h line 17
struct anonymous_47;

// tag-#anon#ST[ARR10{S8}_S8_'stack_locs'||ARR8{S8}_S8_'fc_locs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 483
struct anonymous_7;

// tag-#anon#ST[ARR32{cS8}_cS8_'name'||S32'preset_id'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 308
struct anonymous_48;

// tag-#anon#ST[ARR4{U8}_U8_'c'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_move.h line 57
struct anonymous_4;

// tag-#anon#ST[B'debug_iter_state_output'||B'parseable_output'||B'canonized_order_output'||B'display_10_as_t'||B'display_parent_iter_num'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 53
struct anonymous_28;

// tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 192
struct anonymous_15;

// tag-#anon#ST[S32'argc'||U32'_pad0'||*{*{S8}_S8_}_*{S8}_S8__'argv'||*{S8}_S8_'last_arg'||*{S8}_S8_'last_arg_ptr'||*{S8}_S8_'last_arg_end'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 32
struct anonymous_36;

// tag-#anon#ST[S32'argc'||U32'_pad0'||*{*{S8}_S8_}_*{S8}_S8__'argv'||S32'arg'||S32'stop_at'||S32'end_board'||S32'board_num_step'||S32'update_total_num_iters_threshold'||U32'_pad1'||S64'total_iterations_limit_per_board'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 194
struct anonymous_26;

// tag-#anon#ST[S32'dfs_max_depth'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state'||SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}_SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#_'derived_states_random_indexes'||*{S8}_S8_'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state'||SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}_SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#_'derived_states_random_indexes'||*{S8}_S8_'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'_pad0'|]#_'soft_dfs_info'||S32'depth'||U32'_pad1'||S64'rand_gen'||S32'rand_seed'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_units'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]#}_SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]#_'by_depth_units'|]#'tests_by_depth_array'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 759
struct anonymous_49;

// tag-#anon#ST[S32'ds'||S32'dc'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 1003
struct anonymous_46;

// tag-#anon#ST[S32'idx'||S32'rating'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 651
struct anonymous_25;

// tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_groups'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'groups'|]#'tests_order'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 230
struct anonymous_21;

// tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 705
struct anonymous_52;

// tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#_'Elements'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 68
struct anonymous_31;

// tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 49
struct anonymous_40;

// tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 216
struct anonymous_20;

// tag-#anon#ST[S32'num'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_groups'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'groups'|]#'tests_order'|]#}_SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_groups'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'groups'|]#'tests_order'|]#_'by_depth_tests'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 236
struct anonymous_24;

// tag-#anon#ST[S32'num_flares'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fc_solve_instance_struct#}_SYM#tag-fc_solve_instance_struct#_'obj'||S32'ret_code'||B'instance_is_ready'||U24'_pad0'||S32'limit'||U32'_pad1'||*{S8}_S8_'name'||S32'next_move'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]#'moves_seq'||SYM#tag-#anon#ST[S32'next_move_idx'||S32'num_moves'||*{SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#}_SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]#_'moves'|]#'fc_pro_moves'||SYM#tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]#'obj_stats'|]#_'flares'||*{SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#}_SYM#tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]#_'plan'||S32'num_plan_items'||S32'current_plan_item_idx'||S32'minimal_solution_flare_idx'||S32'all_plan_items_finished_so_far'||*{S8}_S8_'flares_plan_string'||B'flares_plan_compiled'||U24'_pad1'||S32'limit'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 98
struct anonymous_1;

// tag-#anon#ST[S32'num_groups'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[S32'num'||U32'_pad0'||*{S32}_S32_'tests'||EN#anon_enum_FCS_NO_SHUFFLING=0_FCS_RAND=1_FCS_WEIGHTING=2#{U32}_U32_'shuffling_type'||U32'_pad1'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'groups'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 224
struct anonymous_9;

// tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 700
struct anonymous_16;

// tag-#anon#ST[S32'num_moves'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#}_SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#_'moves'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_move.h line 85
struct anonymous_11;

// tag-#anon#ST[S32'num_separate_false_seqs'||ARR20{S32}_S32_'seq_points'||ARR10{S32}_S32_'junk_move_to_stacks'||S32'after_junk_num_freestacks'||ARR20{S32}_S32_'above_num_true_seqs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 198
struct anonymous_45;

// tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 326
struct anonymous_12;

// tag-#anon#ST[S32'num_units'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]#}_SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]#_'by_depth_units'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 710
struct anonymous_18;

// tag-#anon#ST[S32'preset_id'||SYM#tag-#anon#ST[U8'freecells_num'||U8'stacks_num'||U8'decks_num'||U8'game_flags'|]#'game_params'||ARR73{S8}_S8_'tests_order'||ARR73{S8}_S8_'allowed_tests'||U16'_pad0'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 43
struct anonymous_35;

// tag-#anon#ST[S32'scan_idx'||S32'quota'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 562
struct anonymous_39;

// tag-#anon#ST[S32'type'||S32'flare_idx'||S32'count_iters'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 91
struct anonymous_0;

// tag-#anon#ST[S64'num_checked_states'||S64'num_states_in_collection'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 53
struct anonymous_44;

// tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'recycle_bin'|]#'brfs'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#_'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#'befs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 817
struct anonymous_33;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR4{U8}_U8_'c'|]#'move'||B'to_empty_stack'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 43
struct anonymous_54;

// tag-#anon#ST[SYM#tag-#anon#ST[B'debug_iter_state_output'||B'parseable_output'||B'canonized_order_output'||B'display_10_as_t'||B'display_parent_iter_num'|]#'display_context'||U24'_pad0'||*{V}_V_'instance'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 99
struct anonymous_29;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'dfs_max_depth'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state'||SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}_SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#_'derived_states_random_indexes'||*{S8}_S8_'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state'||SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#'derived_states_list'||S32'current_state_index'||S32'tests_list_index'||S32'test_index'||S32'derived_states_random_indexes_max_size'||*{SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#}_SYM#tag-#anon#ST[S32'idx'||S32'rating'|]#_'derived_states_random_indexes'||*{S8}_S8_'positions_by_rank'||U8'num_vacant_stacks'||U8'num_vacant_freecells'||U48'_pad0'|]#_'soft_dfs_info'||S32'depth'||U32'_pad1'||S64'rand_gen'||S32'rand_seed'||U32'_pad2'||SYM#tag-#anon#ST[S32'num_units'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]#}_SYM#tag-#anon#ST[S32'max_depth'||U32'_pad0'||SYM#tag-#anon#ST[S32'num_lists'||U32'_pad0'||*{SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#}_SYM#tag-#anon#ST[*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests'||S32'num_tests'||S32'shuffling_type'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#_'lists'|]#'tests'|]#_'by_depth_units'|]#'tests_by_depth_array'|]#'soft_dfs'||SYM#tag-#anon#ST[*{S8}_S8_'befs_positions_by_rank'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests_list'||*{*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V_}_*{V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V}_V(*{SYM#tag-fc_solve_soft_thread_struct#}_SYM#tag-fc_solve_soft_thread_struct#_|*{SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_struct_state_t#}_SYM#tag-fcs_struct_state_t#_'key'||*{SYM#tag-fcs_state_extra_info_struct#}_SYM#tag-fcs_state_extra_info_struct#_'val'|]#_|*{SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#}_SYM#tag-#anon#ST[S32'num_states'||U32'_pad0'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'state_ptr'||SYM#tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]#'context'|]#_'states'|]#_)->V__'tests_list_end'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'bfs_queue_last_item'||*{SYM#tag-fcs_states_linked_list_item_struct#}_SYM#tag-fcs_states_linked_list_item_struct#_'recycle_bin'|]#'brfs'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#_'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]#'befs'|]#'meth'|]#'befs'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 757
struct anonymous_41;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'max_size'||S32'CurrentSize'||*{SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'val'||S32'rating'||U32'_pad0'|]#_'Elements'|]#'pqueue'||SYM#tag-#anon#ST[B'should_go_over_stacks'||U56'_pad0'||F64'max_sequence_move_factor'||F64'cards_under_sequences_factor'||F64'seqs_over_renegade_cards_factor'||F64'depth_factor'||F64'num_cards_not_on_parents_factor'||ARR14{F64}_F64_'num_cards_out_lookup_table'||ARR6{F64}_F64_'befs_weights'|]#'weighting'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 837
struct anonymous_32;

// tag-#anon#ST[SYM#tag-fcs_struct_state_t#'s'||SYM#tag-fcs_state_extra_info_struct#'info'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 513
struct anonymous_55;

// tag-#anon#ST[SYM#tag-timeval#'tv'||SYM#tag-timezone#'tz'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/portable_time.h line 44
struct anonymous_27;

// tag-#anon#ST[U8'freecells_num'||U8'stacks_num'||U8'decks_num'||U8'game_flags'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/game_type_params.h line 33
struct anonymous_14;

// tag-#anon#UN[*{V}_V_'ptr'||S32'i'||ARR8{S8}_S8_'c'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 318
union anonymous_8;

// tag-#anon#UN[SYM#tag-#anon#ST[SYM#tag-fcs_struct_state_t#'s'||SYM#tag-fcs_state_extra_info_struct#'info'|]#'_anon0'||*{SYM#tag-fcs_state_keyval_pair_struct#}_SYM#tag-fcs_state_keyval_pair_struct#_'next'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 511
union anonymous_42;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_37;

// tag-FCS_INLINED_HASH_DATA_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 45
enum FCS_INLINED_HASH_DATA_TYPE { FCS_INLINED_HASH__COLUMNS=0, FCS_INLINED_HASH__STATES=1 };

// tag-FCS_SUPER_METHOD_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 715
enum FCS_SUPER_METHOD_TYPE { FCS_SUPER_METHOD_DFS=0, FCS_SUPER_METHOD_BEFS_BRFS=1 };

// tag-FLARES_CHOICE_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 85
enum FLARES_CHOICE_TYPE { FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN=0, FLARES_CHOICE_FCPRO_SOLUTION_LEN=1 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-fc_solve_hard_thread_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 154
struct fc_solve_hard_thread_struct;

// tag-fc_solve_hash_symlink_item_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 54
struct fc_solve_hash_symlink_item_struct;

// tag-fc_solve_instance_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 79
struct fc_solve_instance_struct;

// tag-fc_solve_soft_thread_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 155
struct fc_solve_soft_thread_struct;

// tag-fcs_state_extra_info_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 418
struct fcs_state_extra_info_struct;

// tag-fcs_state_keyval_pair_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 405
struct fcs_state_keyval_pair_struct;

// tag-fcs_states_linked_list_item_struct
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 124
struct fcs_states_linked_list_item_struct;

// tag-fcs_struct_state_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 219
struct fcs_struct_state_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// Cvtf89
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 41
static inline signed int Cvtf89(signed int fcn);
// FCS_STATE_keyval_pair_to_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv(struct anonymous_6 *ret, struct fcs_state_keyval_pair_struct *s);
// FCS_STATE_keyval_pair_to_kv_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv_link1(struct anonymous_6 *ret_link1, struct fcs_state_keyval_pair_struct *s_link1);
// FCS_STATE_keyval_pair_to_kv_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv_link2(struct anonymous_6 *ret_link2, struct fcs_state_keyval_pair_struct *s_link2);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// accumulate_tests_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 199
static inline void accumulate_tests_by_ptr(signed int * const tests_order, struct anonymous_9 * const st_tests_order);
// accumulate_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 217
static inline void accumulate_tests_order(struct fc_solve_soft_thread_struct * const soft_thread, void * const context);
// add_checkpoint_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 476
static inline signed int add_checkpoint_to_plan(struct anonymous_1 *instance_item);
// add_count_iters_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 464
static inline signed int add_count_iters_to_plan(struct anonymous_1 *instance_item, signed int flare_idx, signed int count_iters);
// add_run_indef_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 485
static inline signed int add_run_indef_to_plan(struct anonymous_1 *instance_item, signed int flare_idx);
// add_to_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 65
static inline void add_to_last_arg(struct anonymous_36 *manager, char c);
// add_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 443
static inline signed int add_to_plan(struct anonymous_1 *instance_item, signed int mytype, signed int flare_idx, signed int count_iters);
// apply_game_params_for_all_instances
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1494
static void apply_game_params_for_all_instances(struct anonymous * const user);
// assign_dest_stack_and_col_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2059
static inline void assign_dest_stack_and_col_ptr(char * const positions_by_rank, signed int dest_stack, signed int dest_col, char dest_card);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// befs_rate_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 328
static inline signed int befs_rate_state(const struct fc_solve_soft_thread_struct * const soft_thread, const struct anonymous_15 * const weighting, const struct fcs_struct_state_t * const state, const signed int neg_depth);
// bsearch
// file /usr/include/stdlib.h line 755
extern void * bsearch(const void *, const void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 66
static inline signed int calc_depth(struct fcs_state_keyval_pair_struct *ptr_state);
// calc_foundation_to_put_card_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1903
static inline signed int calc_foundation_to_put_card_on(const struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const my_ptr_state, const char card);
// calc_moves_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 869
static signed int calc_moves_seq(const struct anonymous_3 * const solution_moves, struct anonymous_11 * const moves_seq);
// calculate_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 551
static inline void calculate_real_depth(const _Bool calc_real_depth, struct fcs_state_keyval_pair_struct * const ptr_state_orig);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// card_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 92
static inline char * card_to_string(char *s, signed int card, signed int not_append_ws);
// clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 287
static inline void clean_soft_dfs(struct fc_solve_instance_struct * const instance);
// cmd_line_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 106
static signed int cmd_line_callback(void *instance, signed int argc, const char **argv, signed int arg, signed int *num_to_skip, signed int *ret, void *context);
// compare_rating_with_index
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 962
static signed int compare_rating_with_index(const void *void_a, const void *void_b);
// compile_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 491
static inline signed int compile_prelude(struct fc_solve_hard_thread_struct * const hard_thread);
// convert_freecell_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 170
static inline signed int convert_freecell_num(signed int fcn);
// count_num_vacant_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 926
static inline unsigned char count_num_vacant_freecells(const unsigned char freecells_num, const struct fcs_struct_state_t * const state_ptr);
// count_num_vacant_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 943
static inline unsigned char count_num_vacant_stacks(const unsigned char stacks_num, const struct fcs_struct_state_t * const state_ptr);
// determine_scan_completeness
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 225
static inline void determine_scan_completeness(struct fc_solve_soft_thread_struct * const soft_thread, void * const global_tests_order);
// duplicate_string_while_adding_a_trailing_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 722
static inline char * duplicate_string_while_adding_a_trailing_newline(const char *orig_str);
// empty_two_cols_from_new_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 187
static inline signed int empty_two_cols_from_new_state(const struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const kv_ptr_new_state, struct anonymous_3 * const moves, const signed int *cols_indexes, const signed int nc1, const signed int nc2);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 606
static inline const _Bool false_seq_index_loop(const signed int stacks_num, struct anonymous_6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous_45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag);
// fc_solve_PQueueFree
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree(struct anonymous_31 *pq);
// fc_solve_PQueueFree_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree_link1(struct anonymous_31 *pq_link1);
// fc_solve_PQueueFree_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree_link2(struct anonymous_31 *pq_link2);
// fc_solve_PQueueInitialise
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 88
static inline void fc_solve_PQueueInitialise(struct anonymous_31 *pq, signed int MaxElements);
// fc_solve_PQueuePop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 177
static inline void fc_solve_PQueuePop(struct anonymous_31 *pq, struct fcs_state_keyval_pair_struct **val);
// fc_solve_PQueuePush
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 114
static inline void fc_solve_PQueuePush(struct anonymous_31 *pq, struct fcs_state_keyval_pair_struct *val, signed int r);
// fc_solve_alloc_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 394
struct fc_solve_instance_struct * fc_solve_alloc_instance(struct anonymous_10 * const meta_alloc);
// fc_solve_append_string_finalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 62
static inline char * fc_solve_append_string_finalize(struct anonymous_51 *app_str);
// fc_solve_append_string_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 53
static inline void fc_solve_append_string_init(struct anonymous_51 *app_str);
// fc_solve_append_string_sprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.c line 38
extern void fc_solve_append_string_sprintf(struct anonymous_51 *app_str, const char *format, ...);
// fc_solve_apply_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 120
void fc_solve_apply_move(struct anonymous_6 *state, struct anonymous_7 *locs, struct anonymous_4 move, signed int freecells_num, signed int stacks_num, signed int decks_num);
// fc_solve_apply_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 58
extern signed int fc_solve_apply_preset_by_name(struct fc_solve_instance_struct *instance, const char *name);
// fc_solve_apply_preset_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 53
extern signed int fc_solve_apply_preset_by_ptr(struct fc_solve_instance_struct *instance, const struct anonymous_35 *preset_ptr);
// fc_solve_apply_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 74
extern signed int fc_solve_apply_tests_order(struct anonymous_9 *tests_order, const char *string, char **error_string);
// fc_solve_args_man_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 40
extern struct anonymous_36 * fc_solve_args_man_alloc(void);
// fc_solve_args_man_chop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 42
extern signed int fc_solve_args_man_chop(struct anonymous_36 *manager, char *string);
// fc_solve_args_man_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 41
extern void fc_solve_args_man_free(struct anonymous_36 *manager);
// fc_solve_befs_or_bfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 925
extern signed int fc_solve_befs_or_bfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_befs_or_bfs_do_solve::1::6::12::next_test_object_object
//
void next_test_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_befs_or_bfs_do_solve::1::debug_iter_output_func_object
//
void debug_iter_output_func_object(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int);
// fc_solve_befs_or_bfs_do_solve::1::tests_list_object_object
//
void tests_list_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_befs_or_bfs_do_solve::1::tests_list_end_object_object
//
void tests_list_end_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_cache_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 82
static inline void fc_solve_cache_stacks(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous_6 * const new_state);
// fc_solve_calc_positions_by_rank_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2033
static inline char ** fc_solve_calc_positions_by_rank_location(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_canonize_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 634
extern void fc_solve_canonize_state(struct anonymous_6 *state_raw, signed int freecells_num, signed int stacks_num);
// fc_solve_canonize_state_with_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 640
void fc_solve_canonize_state_with_locs(struct anonymous_6 *state, struct anonymous_7 *locs, signed int freecells_num, signed int stacks_num);
// fc_solve_card_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare(const char c1, const char c2);
// fc_solve_card_compare_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare_link1(const char c1_link1, const char c2_link1);
// fc_solve_card_perl2user
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 266
extern char * fc_solve_card_perl2user(char card, char *str, _Bool t);
// fc_solve_card_user2perl
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 140
extern char fc_solve_card_user2perl(const char *str);
// fc_solve_check_and_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 316
_Bool fc_solve_check_and_add_state(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous_6 * const new_state, struct anonymous_6 * const existing_state_raw);
// fc_solve_check_state_validity
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1036
static inline signed int fc_solve_check_state_validity(struct fcs_state_keyval_pair_struct *state_pair, signed int freecells_num, signed int stacks_num, signed int decks_num, char *misplaced_card);
// fc_solve_compact_allocator_extend
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 57
extern void fc_solve_compact_allocator_extend(struct anonymous_5 *allocator);
// fc_solve_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 113
extern void fc_solve_compact_allocator_finish(struct anonymous_5 *allocator);
// fc_solve_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 81
extern void fc_solve_compact_allocator_init(struct anonymous_5 *allocator, struct anonymous_10 *meta_allocator);
// fc_solve_compact_allocator_init_helper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper(struct anonymous_5 *allocator);
// fc_solve_compact_allocator_init_helper_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper_link1(struct anonymous_5 *allocator_link1);
// fc_solve_compact_allocator_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 130
static inline void fc_solve_compact_allocator_recycle(struct anonymous_5 *allocator);
// fc_solve_derived_states_list_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 340
extern void fc_solve_derived_states_list_add_state(struct anonymous_12 *list, struct fcs_state_keyval_pair_struct *state, signed int context);
// fc_solve_finish_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1028
extern void fc_solve_finish_instance(struct fc_solve_instance_struct * const instance);
// fc_solve_foreach_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 240
extern void fc_solve_foreach_soft_thread(struct fc_solve_instance_struct * const instance, const signed int callback_choice, void * const context);
// fc_solve_free_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1830
static inline void fc_solve_free_instance(struct fc_solve_instance_struct *instance);
// fc_solve_free_soft_thread_by_depth_test_array
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 160
extern void fc_solve_free_soft_thread_by_depth_test_array(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_free_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order(struct anonymous_9 *tests_order);
// fc_solve_free_tests_order_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order_link1(struct anonymous_9 *tests_order_link1);
// fc_solve_free_tests_order_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order_link2(struct anonymous_9 *tests_order_link2);
// fc_solve_get_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 63
extern signed int fc_solve_get_preset_by_name(const char *name, const struct anonymous_35 **preset_ptr);
// fc_solve_get_the_positions_by_rank_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 54
extern char * fc_solve_get_the_positions_by_rank_data(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key, char * (*generator)(struct fc_solve_soft_thread_struct *, const struct fcs_struct_state_t *));
// fc_solve_get_the_positions_by_rank_data::generator_object
//
char * generator_object(struct fc_solve_soft_thread_struct *, const struct fcs_struct_state_t *);
// fc_solve_get_the_positions_by_rank_data__freecell_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 49
extern char * fc_solve_get_the_positions_by_rank_data__freecell_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key);
// fc_solve_hash_foreach
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 195
static inline void fc_solve_hash_foreach(struct anonymous_38 * const hash, _Bool (*should_delete_ptr)(void *, void *), void * const context);
// fc_solve_hash_foreach::should_delete_ptr_object
//
_Bool should_delete_ptr_object(void *, void *);
// fc_solve_hash_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 185
static inline void fc_solve_hash_free(struct anonymous_38 * const hash);
// fc_solve_hash_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 118
static inline void fc_solve_hash_init(struct anonymous_10 * const meta_alloc, struct anonymous_38 * const hash, const enum FCS_INLINED_HASH_DATA_TYPE hash_type);
// fc_solve_hash_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 170
extern _Bool fc_solve_hash_insert(struct anonymous_38 * const hash, void * const key, void ** const existing_key, const signed int hash_value);
// fc_solve_hash_rehash
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.c line 192
static inline void fc_solve_hash_rehash(struct anonymous_38 * const hash);
// fc_solve_increase_dfs_max_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 929
extern void fc_solve_increase_dfs_max_depth(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_init_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 557
extern void fc_solve_init_instance(struct fc_solve_instance_struct *instance);
// fc_solve_init_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 494
static inline void fc_solve_init_locs(struct anonymous_7 *locs);
// fc_solve_initial_user_state_to_c_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 793
static inline signed int fc_solve_initial_user_state_to_c_proto(const char *string, struct fcs_state_keyval_pair_struct *out_state, signed int freecells_num, signed int stacks_num, signed int decks_num, char *indirect_stacks_buffer);
// fc_solve_initialize_befs_rater
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_15 *weighting);
// fc_solve_initialize_befs_rater_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater_link1(struct fc_solve_soft_thread_struct * const soft_thread_link1, struct anonymous_15 *weighting_link1);
// fc_solve_initialize_bfs_queue
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 1540
static inline void fc_solve_initialize_bfs_queue(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_instance__init_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 357
extern void fc_solve_instance__init_hard_thread(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_instance__recycle_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1730
static inline void fc_solve_instance__recycle_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_instance_get_first_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1630
static inline struct fc_solve_soft_thread_struct * fc_solve_instance_get_first_soft_thread(struct fc_solve_instance_struct *instance);
// fc_solve_meta_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 77
extern void fc_solve_meta_compact_allocator_finish(struct anonymous_10 *meta_allocator);
// fc_solve_meta_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 70
static inline void fc_solve_meta_compact_allocator_init(struct anonymous_10 *meta);
// fc_solve_move_sequence_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function(struct anonymous_6 * const new_state_kv_ptr, struct anonymous_3 * const moves, const signed int dest_idx, const signed int source_idx, const signed int start, const signed int end);
// fc_solve_move_sequence_function_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function_link1(struct anonymous_6 * const new_state_kv_ptr_link1, struct anonymous_3 * const moves_link1, const signed int dest_idx_link1, const signed int source_idx_link1, const signed int start_link1, const signed int end_link1);
// fc_solve_move_stack_compact_allocate
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous_3 * fc_solve_move_stack_compact_allocate(struct fc_solve_hard_thread_struct *hard_thread, struct anonymous_3 *old_move_stack_to_parent);
// fc_solve_move_stack_compact_allocate_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous_3 * fc_solve_move_stack_compact_allocate_link1(struct fc_solve_hard_thread_struct *hard_thread_link1, struct anonymous_3 *old_move_stack_to_parent_link1);
// fc_solve_move_stack_normalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 156
static inline void fc_solve_move_stack_normalize(struct anonymous_3 *moves, struct anonymous_6 *init_state, struct anonymous_7 *locs, signed int freecells_num, signed int stacks_num, signed int decks_num);
// fc_solve_move_stack_pop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 97
static inline _Bool fc_solve_move_stack_pop(struct anonymous_3 *stack, struct anonymous_4 *move);
// fc_solve_move_stack_swallow_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 144
static inline void fc_solve_move_stack_swallow_stack(struct anonymous_3 *stack, struct anonymous_3 *src_stack);
// fc_solve_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 305
static inline char * fc_solve_move_to_string(struct anonymous_4 move, signed int standard_notation);
// fc_solve_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 296
extern char * fc_solve_move_to_string_w_state(struct fcs_state_keyval_pair_struct *state, signed int freecells_num, signed int stacks_num, signed int decks_num, struct anonymous_4 move, signed int standard_notation);
// fc_solve_moves_processed_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 80
static inline void fc_solve_moves_processed_free(struct anonymous_40 *moves);
// fc_solve_moves_processed_gen
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 123
extern void fc_solve_moves_processed_gen(struct anonymous_40 * const ret, struct fcs_state_keyval_pair_struct * const orig, const signed int num_freecells, const struct anonymous_11 * const moves_seq);
// fc_solve_moves_processed_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 65
static inline signed int fc_solve_moves_processed_get_moves_left(struct anonymous_40 *moves);
// fc_solve_moves_processed_render_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 46
char * fc_solve_moves_processed_render_move(struct anonymous_54 move, char *string);
// fc_solve_new_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread(struct fc_solve_instance_struct * const instance);
// fc_solve_new_hard_thread_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread_link1(struct fc_solve_instance_struct * const instance_link1);
// fc_solve_new_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1118
extern struct fc_solve_soft_thread_struct * fc_solve_new_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_optimize_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1430
static inline signed int fc_solve_optimize_solution(struct fc_solve_instance_struct *instance);
// fc_solve_p2u_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 181
extern char * fc_solve_p2u_rank(signed int rank_idx, char *str, _Bool *rank_is_null, _Bool t);
// fc_solve_p2u_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 224
static inline char * fc_solve_p2u_suit(signed int suit, char *str, _Bool rank_is_null);
// fc_solve_rand_get_random_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 55
static inline signed int fc_solve_rand_get_random_number(signed long int *my_rand);
// fc_solve_rand_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 38
static inline void fc_solve_rand_init(signed long int *my_rand, unsigned int seed);
// fc_solve_rand_rand15
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 43
static inline signed int fc_solve_rand_rand15(signed long int *my_rand);
// fc_solve_recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1747
static inline void fc_solve_recycle_instance(struct fc_solve_instance_struct * const instance);
// fc_solve_release_tests_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1696
static inline void fc_solve_release_tests_list(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_reset_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread);
// fc_solve_reset_hard_thread_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread_link1(struct fc_solve_hard_thread_struct * const hard_thread_link1);
// fc_solve_reset_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_reset_soft_thread_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread_link1(struct fc_solve_soft_thread_struct * const soft_thread_link1);
// fc_solve_resume_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1499
static inline signed int fc_solve_resume_instance(struct fc_solve_instance_struct *instance);
// fc_solve_set_weights
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights(const char *start_num, double * const befs_weights);
// fc_solve_set_weights_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights_link1(const char *start_num_link1, double * const befs_weights_link1);
// fc_solve_sfs_atomic_move_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1582
extern void fc_solve_sfs_atomic_move_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_atomic_move_card_to_freecell
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1719
extern void fc_solve_sfs_atomic_move_card_to_freecell(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_atomic_move_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1656
extern void fc_solve_sfs_atomic_move_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_atomic_move_freecell_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1827
extern void fc_solve_sfs_atomic_move_freecell_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_atomic_move_freecell_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1777
extern void fc_solve_sfs_atomic_move_freecell_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_check_state_begin
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 63
extern signed int fc_solve_sfs_check_state_begin(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous_6 * const out_new_state_out, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_3 * const moves);
// fc_solve_sfs_check_state_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 70
extern void fc_solve_sfs_check_state_end(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_6 * const raw_ptr_new_state_raw, const signed int state_context_value, struct anonymous_3 * const moves, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_empty_stack_into_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1361
extern void fc_solve_sfs_empty_stack_into_freecells(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_cards_to_a_different_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1178
extern void fc_solve_sfs_move_cards_to_a_different_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_freecell_cards_on_top_of_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 345
extern void fc_solve_sfs_move_freecell_cards_on_top_of_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_freecell_cards_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1118
extern void fc_solve_sfs_move_freecell_cards_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_freecell_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 141
extern void fc_solve_sfs_move_freecell_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_non_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 529
extern void fc_solve_sfs_move_non_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_sequences_to_free_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 921
extern void fc_solve_sfs_move_sequences_to_free_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 617
extern void fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_stack_cards_to_different_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 775
extern void fc_solve_sfs_move_stack_cards_to_different_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_move_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 66
extern void fc_solve_sfs_move_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_raymond_prune
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1953
extern signed int fc_solve_sfs_raymond_prune(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct fcs_state_keyval_pair_struct ** const ptr_next_state_val);
// fc_solve_sfs_simple_simon_move_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 61
extern void fc_solve_sfs_simple_simon_move_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 45
extern void fc_solve_sfs_simple_simon_move_sequence_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 59
extern void fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 47
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 51
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 55
extern void fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 53
extern void fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 49
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 57
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_sfs_yukon_do_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1429
extern void fc_solve_sfs_yukon_do_nothing(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list);
// fc_solve_soft_dfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1210
extern signed int fc_solve_soft_dfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread);
// fc_solve_soft_dfs_do_solve::1::debug_iter_output_func_object
//
void debug_iter_output_func_object(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int);
// fc_solve_soft_thread_init_befs_or_bfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1212
extern void fc_solve_soft_thread_init_befs_or_bfs(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_soft_thread_init_befs_or_bfs::1::3::tests_list_object_object
//
void tests_list_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_soft_thread_init_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1098
static inline void fc_solve_soft_thread_init_soft_dfs(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_soft_thread_init_soft_dfs::_tmp::tmp_post_4_object_object
//
void tmp_post_4_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_soft_thread_init_soft_dfs::1::1::next_test_object_object
//
void next_test_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_soft_thread_init_soft_dfs::1::1::tests_list_object_object
//
void tests_list_object_object(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_soft_thread_update_initial_cards_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val(struct fc_solve_soft_thread_struct *soft_thread);
// fc_solve_soft_thread_update_initial_cards_val_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val_link1(struct fc_solve_soft_thread_struct *soft_thread_link1);
// fc_solve_stack_compare_for_comparison
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison(const void * const v_s1, const void * const v_s2);
// fc_solve_stack_compare_for_comparison_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison_link1(const void * const v_s1_link1, const void * const v_s2_link1);
// fc_solve_start_instance_process_with_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 808
extern void fc_solve_start_instance_process_with_board(struct fc_solve_instance_struct * const instance, struct fcs_state_keyval_pair_struct * const init_state);
// fc_solve_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1016
extern char * fc_solve_state_as_string(struct fcs_struct_state_t *state, struct anonymous_7 *state_locs, signed int freecells_num, signed int stacks_num, signed int decks_num, _Bool parseable_output, _Bool canonized_order_output, _Bool display_10_as_t);
// fc_solve_state_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 655
static inline signed int fc_solve_state_compare(const void *s1, const void *s2);
// fc_solve_state_compare_with_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.c line 216
extern signed int fc_solve_state_compare_with_context(const void *s1, const void *s2, void *context);
// fc_solve_state_init_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 736
static inline void fc_solve_state_init_proto(struct fcs_state_keyval_pair_struct *state, signed int stacks_num, char *indirect_stacks_buffer);
// fc_solve_string_to_test_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num(const char *s);
// fc_solve_string_to_test_num_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num_link1(const char *s_link1);
// fc_solve_string_to_test_num_compare_func
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func(const void *a, const void *b);
// fc_solve_string_to_test_num_compare_func_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func_link1(const void *a_link1, const void *b_link1);
// fc_solve_trace_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 716
extern void fc_solve_trace_solution(struct fc_solve_instance_struct * const instance);
// fc_solve_u2p_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 46
extern signed int fc_solve_u2p_rank(const char *string);
// fc_solve_u2p_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 99
extern signed int fc_solve_u2p_suit(const char *suit);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcs_compact_alloc_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr(struct anonymous_5 *allocator, signed int how_much);
// fcs_compact_alloc_ptr_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr_link1(struct anonymous_5 *allocator_link1, signed int how_much_link1);
// fcs_compact_alloc_ptr_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr_link2(struct anonymous_5 *allocator_link2, signed int how_much_link2);
// fcs_compact_alloc_ptr_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr_link3(struct anonymous_5 *allocator_link3, signed int how_much_link3);
// fcs_get_preset_by_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 531
static inline signed int fcs_get_preset_by_id(signed int preset_id, const struct anonymous_35 **preset_ptr);
// fcs_get_preset_id_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 412
static inline signed int fcs_get_preset_id_by_name(const char *name);
// fcs_is_ss_suit_true
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 58
static inline const _Bool fcs_is_ss_suit_true(const char parent, const char child);
// fcs_is_ss_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 65
static inline const _Bool fcs_is_ss_true_parent(const char parent, const char child);
// fcs_make_card
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card(const signed int rank, const signed int suit);
// fcs_make_card_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card_link1(const signed int rank_link1, const signed int suit_link1);
// fcs_move_stack_non_seq_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push(struct anonymous_3 * const stack, const signed int type, const signed int src, const signed int dest);
// fcs_move_stack_non_seq_push_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push_link1(struct anonymous_3 * const stack_link1, const signed int type_link1, const signed int src_link1, const signed int dest_link1);
// fcs_move_stack_params_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push(struct anonymous_3 * const stack, const signed int type, const signed int src, const signed int dest, const signed int num_cards_in_seq);
// fcs_move_stack_params_push_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push_link1(struct anonymous_3 * const stack_link1, const signed int type_link1, const signed int src_link1, const signed int dest_link1, const signed int num_cards_in_seq_link1);
// fcs_move_stack_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push(struct anonymous_3 * const stack, const struct anonymous_4 move);
// fcs_move_stack_push_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push_link1(struct anonymous_3 * const stack_link1, const struct anonymous_4 move_link1);
// fcs_move_stack_push_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push_link2(struct anonymous_3 * const stack_link2, const struct anonymous_4 move_link2);
// fcs_move_stack_push_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push_link3(struct anonymous_3 * const stack_link3, const struct anonymous_4 move_link3);
// fcs_push_1card_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 89
static inline void fcs_push_1card_seq(struct anonymous_3 * const stack, const signed int src, const signed int dest);
// fcs_state_ia_alloc_into_var
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 115
static inline struct fcs_state_keyval_pair_struct * fcs_state_ia_alloc_into_var(struct anonymous_5 *allocator);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_instance_hard_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1797
static inline void free_instance_hard_thread_callback(struct fc_solve_hard_thread_struct *hard_thread);
// free_instance_soft_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 181
static inline void free_instance_soft_thread_callback(struct fc_solve_soft_thread_struct * const soft_thread);
// free_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 233
static inline void free_states(struct fc_solve_instance_struct *instance);
// free_states_handle_soft_dfs_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 146
static inline void free_states_handle_soft_dfs_soft_thread(struct fc_solve_soft_thread_struct *soft_thread);
// free_states_should_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 125
static _Bool free_states_should_delete(void *key, void *context);
// freecell_solver_set_stored_states_trimming_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 265
extern void freecell_solver_set_stored_states_trimming_limit(void *api_instance, signed long int max_num_states);
// freecell_solver_user_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 46
extern void * freecell_solver_user_alloc(void);
// freecell_solver_user_apply_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 48
extern signed int freecell_solver_user_apply_preset(void *api_instance, const char *preset_name);
// freecell_solver_user_cmd_line_parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_cl.h line 62
extern signed int freecell_solver_user_cmd_line_parse_args(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg);
// freecell_solver_user_cmd_line_parse_args::callback_object
//
signed int callback_object(void *, signed int, const char **, signed int, signed int *, signed int *, void *);
// freecell_solver_user_cmd_line_parse_args_with_file_nesting_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 309
extern signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg, signed int file_nesting_count, const char *opened_files_dir);
// freecell_solver_user_cmd_line_parse_args_with_file_nesting_count::callback_object
//
signed int callback_object(void *, signed int, const char **, signed int, signed int *, signed int *, void *);
// freecell_solver_user_cmd_line_read_cmd_line_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 260
extern signed int freecell_solver_user_cmd_line_read_cmd_line_preset(void *instance, const char * const preset_name, const char **known_parameters, char **error_string, signed int file_nesting_count, const char *opened_files_dir);
// freecell_solver_user_current_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1349
extern char * freecell_solver_user_current_state_as_string(void *api_instance, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t);
// freecell_solver_user_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 90
extern void freecell_solver_user_free(void *api_instance);
// freecell_solver_user_get_current_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1455
extern signed int freecell_solver_user_get_current_depth(void *api_instance);
// freecell_solver_user_get_current_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2432
const char * freecell_solver_user_get_current_soft_thread_name(void *api_instance);
// freecell_solver_user_get_invalid_state_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1741
extern char * freecell_solver_user_get_invalid_state_error_string(void *api_instance, signed int print_ts);
// freecell_solver_user_get_last_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 366
const char * freecell_solver_user_get_last_error_string(void *api_instance);
// freecell_solver_user_get_lib_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2425
const char * freecell_solver_user_get_lib_version(void *api_instance);
// freecell_solver_user_get_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1653
extern signed int freecell_solver_user_get_limit_iterations(void *api_instance);
// freecell_solver_user_get_max_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 174
extern signed int freecell_solver_user_get_max_num_decks(void);
// freecell_solver_user_get_max_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 160
extern signed int freecell_solver_user_get_max_num_freecells(void);
// freecell_solver_user_get_max_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 167
extern signed int freecell_solver_user_get_max_num_stacks(void);
// freecell_solver_user_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1660
extern signed int freecell_solver_user_get_moves_left(void *api_instance);
// freecell_solver_user_get_moves_sequence
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2477
extern signed int freecell_solver_user_get_moves_sequence(void *api_instance, struct anonymous_11 * const moves_seq);
// freecell_solver_user_get_next_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1296
extern signed int freecell_solver_user_get_next_move(void *api_instance, struct anonymous_4 *user_move);
// freecell_solver_user_get_num_soft_threads_in_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2132
extern signed int freecell_solver_user_get_num_soft_threads_in_instance(void *api_instance);
// freecell_solver_user_get_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2027
extern signed int freecell_solver_user_get_num_states_in_collection(void *api_instance);
// freecell_solver_user_get_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2020
signed long int freecell_solver_user_get_num_states_in_collection_long(void *api_instance);
// freecell_solver_user_get_num_times
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1648
extern signed int freecell_solver_user_get_num_times(void *api_instance);
// freecell_solver_user_get_num_times_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 103
extern signed long int freecell_solver_user_get_num_times_long(void *api_instance);
// freecell_solver_user_iter_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 236
extern char * freecell_solver_user_iter_state_as_string(void *api_instance, void *ptr_state_void, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t);
// freecell_solver_user_limit_current_instance_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 316
extern void freecell_solver_user_limit_current_instance_iterations(void *api_instance, signed int max_iters);
// freecell_solver_user_limit_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 150
extern void freecell_solver_user_limit_depth(void *api_instance, signed int max_depth);
// freecell_solver_user_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 308
extern void freecell_solver_user_limit_iterations(void *api_instance, signed int max_iters);
// freecell_solver_user_limit_iterations_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 53
extern void freecell_solver_user_limit_iterations_long(void *api_instance, signed long int max_iters);
// freecell_solver_user_limit_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2055
extern void freecell_solver_user_limit_num_states_in_collection(void *api_instance, signed int max_num_states);
// freecell_solver_user_limit_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 255
extern void freecell_solver_user_limit_num_states_in_collection_long(void *api_instance, signed long int max_num_states);
// freecell_solver_user_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1680
extern char * freecell_solver_user_move_to_string(struct anonymous_4 move, signed int standard_notation);
// freecell_solver_user_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1688
extern char * freecell_solver_user_move_to_string_w_state(void *api_instance, struct anonymous_4 move, signed int standard_notation);
// freecell_solver_user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 341
extern signed int freecell_solver_user_next_flare(void *api_instance);
// freecell_solver_user_next_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 279
extern signed int freecell_solver_user_next_hard_thread(void *api_instance);
// freecell_solver_user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 337
extern signed int freecell_solver_user_next_instance(void *api_instance);
// freecell_solver_user_next_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 270
extern signed int freecell_solver_user_next_soft_thread(void *api_instance);
// freecell_solver_user_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 312
extern void freecell_solver_user_recycle(void *api_instance);
// freecell_solver_user_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 349
extern signed int freecell_solver_user_reset(void *api_instance);
// freecell_solver_user_resume_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 943
extern signed int freecell_solver_user_resume_solution(void *api_instance);
// freecell_solver_user_set_a_star_weight
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 197
extern signed int freecell_solver_user_set_a_star_weight(void *api_instance, signed int my_index, double weight);
// freecell_solver_user_set_cache_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 386
extern signed int freecell_solver_user_set_cache_limit(void *api_instance, signed long int limit);
// freecell_solver_user_set_calc_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 287
extern void freecell_solver_user_set_calc_real_depth(void *api_instance, signed int calc_real_depth);
// freecell_solver_user_set_depth_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 373
extern signed int freecell_solver_user_set_depth_tests_order(void *api_instance, signed int min_depth, const char *tests_order, char **error_string);
// freecell_solver_user_set_empty_stacks_filled_by
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 187
extern signed int freecell_solver_user_set_empty_stacks_filled_by(void *api_instance, signed int empty_stacks_fill);
// freecell_solver_user_set_flare_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 297
extern void freecell_solver_user_set_flare_name(void *api_instance, const char *name);
// freecell_solver_user_set_flares_choice
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 396
extern signed int freecell_solver_user_set_flares_choice(void *api_instance, const char * const new_flares_choice_string);
// freecell_solver_user_set_flares_iters_factor
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 401
extern void freecell_solver_user_set_flares_iters_factor(void *api_instance, double new_factor);
// freecell_solver_user_set_flares_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 307
extern signed int freecell_solver_user_set_flares_plan(void *api_instance, const char *flares_plan_string);
// freecell_solver_user_set_game
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1601
extern signed int freecell_solver_user_set_game(void *api_instance, signed int freecells_num, signed int stacks_num, signed int decks_num, signed int sequences_are_built_by, signed int unlimited_sequence_move, signed int empty_stacks_fill);
// freecell_solver_user_set_hard_thread_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 302
extern signed int freecell_solver_user_set_hard_thread_prelude(void *api_instance, const char *prelude);
// freecell_solver_user_set_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1965
extern void freecell_solver_user_set_iter_handler(void *api_instance, void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context);
// freecell_solver_user_set_iter_handler::iter_handler_object
//
void iter_handler_object(void *, signed int, signed int, void *, signed int, void *);
// freecell_solver_user_set_iter_handler_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 229
extern void freecell_solver_user_set_iter_handler_long(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void *iter_handler_context);
// freecell_solver_user_set_iter_handler_long::long_iter_handler_object
//
void long_iter_handler_object(void *, signed long int, signed int, void *, signed long int, void *);
// freecell_solver_user_set_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 169
extern signed int freecell_solver_user_set_num_decks(void *api_instance, signed int decks_num);
// freecell_solver_user_set_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 155
extern signed int freecell_solver_user_set_num_freecells(void *api_instance, signed int freecells_num);
// freecell_solver_user_set_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 162
extern signed int freecell_solver_user_set_num_stacks(void *api_instance, signed int stacks_num);
// freecell_solver_user_set_optimization_scan_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 316
extern signed int freecell_solver_user_set_optimization_scan_tests_order(void *api_instance, const char *tests_order, char **error_string);
// freecell_solver_user_set_pruning
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 380
extern signed int freecell_solver_user_set_pruning(void *api_instance, const char *pruning, char **error_string);
// freecell_solver_user_set_random_seed
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 244
extern void freecell_solver_user_set_random_seed(void *api_instance, signed int seed);
// freecell_solver_user_set_reparent_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 322
extern void freecell_solver_user_set_reparent_states(void *api_instance, signed int to_reparent_states);
// freecell_solver_user_set_scans_synergy
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 327
extern void freecell_solver_user_set_scans_synergy(void *api_instance, signed int synergy);
// freecell_solver_user_set_sequence_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 192
extern signed int freecell_solver_user_set_sequence_move(void *api_instance, signed int unlimited_sequence_move);
// freecell_solver_user_set_sequences_are_built_by_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 182
extern signed int freecell_solver_user_set_sequences_are_built_by_type(void *api_instance, signed int sequences_are_built_by);
// freecell_solver_user_set_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 292
extern void freecell_solver_user_set_soft_thread_name(void *api_instance, const char *name);
// freecell_solver_user_set_soft_thread_step
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 274
extern void freecell_solver_user_set_soft_thread_step(void *api_instance, signed int num_checked_states_step);
// freecell_solver_user_set_solution_optimization
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 134
extern void freecell_solver_user_set_solution_optimization(void *api_instance, signed int optimize);
// freecell_solver_user_set_solving_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 98
extern void freecell_solver_user_set_solving_method(void *api_instance, signed int method);
// freecell_solver_user_set_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 63
extern signed int freecell_solver_user_set_tests_order(void *api_instance, const char *tests_order, char **error_string);
// freecell_solver_user_solve_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 69
extern signed int freecell_solver_user_solve_board(void *api_instance, const char *state_as_string);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// generic_false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 501
static inline const _Bool generic_false_seq_index_loop(const signed int stacks_num, struct anonymous_6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous_45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag, const _Bool should_src_col, const char src_card, const signed int num_src_junk_true_seqs);
// generic_populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 460
static inline void generic_populate_seq_points(char * const dest_col, const signed int dc, struct anonymous_45 * const seqs, const signed int dest_cards_num);
// get_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 186
static inline void get_board(signed long int gamenumber, char *ret);
// get_board_l
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 123
static inline void get_board_l(const signed long long int gamenumber, char * const ret);
// get_current_instance_item
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 927
static inline struct anonymous_1 * get_current_instance_item(const struct anonymous *user);
// get_flare_move_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 898
static signed int get_flare_move_count(struct anonymous * const user, struct anonymous_2 * const flare);
// get_seq_h
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 370
static inline signed int get_seq_h(char * const col, signed int *num_true_seqs_out_ptr);
// get_the_positions_by_rank_data__ss_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 143
static char * get_the_positions_by_rank_data__ss_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const the_state);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// init_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 297
static inline void init_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread, struct fc_solve_soft_thread_struct * const soft_thread);
// init_stacks_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 189
static inline void init_stacks_map(_Bool * const stacks_map, const signed int stack_idx, const signed int ds);
// init_stats
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 775
static inline void init_stats(struct anonymous_44 * const s);
// is_whitespace
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 110
static inline _Bool is_whitespace(char c);
// iter_handler_wrapper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1882
static void iter_handler_wrapper(void *api_instance, signed long int iter_num, signed int depth, void *lp_instance, struct anonymous_6 *ptr_state, signed long int parent_iter_num);
// kv_calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 84
static inline signed int kv_calc_depth(struct anonymous_6 *ptr_state);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mark_as_dead_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 589
static inline void mark_as_dead_end(const _Bool scans_synergy, struct fcs_state_keyval_pair_struct * const ptr_state_input);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup(void *src, unsigned long int mysize);
// memdup_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup_link1(void *src_link1, unsigned long int mysize_link1);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// meta_request_new_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.c line 57
static inline char * meta_request_new_buffer(struct anonymous_10 *meta_allocator);
// microsoft_rand__game_num_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 59
static inline unsigned int microsoft_rand__game_num_rand(signed long long int *seedx_ptr, signed long long int gnGameNumber);
// microsoft_rand_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 47
static inline unsigned int microsoft_rand_rand(signed long long int *my_rand);
// microsoft_rand_randp
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 53
static inline unsigned int microsoft_rand_randp(signed long long int *my_rand);
// moves_processed_add_new_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 113
static inline void moves_processed_add_new_move(struct anonymous_40 * const moves, const struct anonymous_54 new_move);
// my_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 62
static void my_iter_handler(void *user_instance, signed long int iter_num, signed int depth, void *ptr_state, signed long int parent_iter_num, void *lp_context);
// normalize_iters_quota
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 936
static inline signed int normalize_iters_quota(signed int i);
// nullify_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 50
static inline void nullify_newline(char * const line);
// on_state_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 291
static inline void on_state_new(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread, struct fcs_state_extra_info_struct * const new_state_info);
// perl_hash_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 53
static inline unsigned long int perl_hash_function(const unsigned char *s_ptr, const unsigned long int length);
// populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 491
static inline void populate_seq_points(char * const dest_col, const signed int dc, struct anonymous_45 * const seqs);
// print_help
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 169
static void print_help(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 261
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous_37 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous_37 *);
// push_args_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 82
static inline void push_args_last_arg(struct anonymous_36 *manager);
// qsort
// file /usr/include/stdlib.h line 765
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// read_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 60
static inline signed int read_preset(const char *preset_name, struct anonymous_36 **args_man, char **opened_files_dir_to_assign, const char *user_preset_dir);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 782
static void recycle_instance(struct anonymous * const user, const signed int i);
// run_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1217
static inline signed int run_hard_thread(struct fc_solve_hard_thread_struct *hard_thread);
// set_any_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1931
static void set_any_iter_handler(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context);
// set_any_iter_handler::iter_handler_object
//
void iter_handler_object(void *, signed int, signed int, void *, signed int, void *);
// set_any_iter_handler::long_iter_handler_object
//
void long_iter_handler_object(void *, signed long int, signed int, void *, signed long int, void *);
// set_debug_iter_output_func_to_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1920
static void set_debug_iter_output_func_to_val(struct anonymous * const user, void (* const value)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int));
// set_debug_iter_output_func_to_val::value_object
//
void value_object(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int);
// soft_thread_clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 119
static inline void soft_thread_clean_soft_dfs(struct fc_solve_soft_thread_struct * const soft_thread);
// sort_derived_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 116
static inline void sort_derived_states(struct anonymous_12 *derived_states_list, signed int initial_derived_states_num_states);
// sort_ds_dcs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 1008
static inline void sort_ds_dcs(struct anonymous_46 *ds_dcs, const signed int len);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strchr
// file /usr/include/string.h line 236
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 176
extern char * strdup(const char *);
// string_starts_with
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with(const char * const str, const char * const prefix, const char * const end);
// string_starts_with_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with_link1(const char * const str_link1, const char * const prefix_link1, const char * const end_link1);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 538
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strndup
// file /usr/include/string.h line 184
extern char * strndup(const char *, unsigned long int);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// tests_order_dup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous_9 tests_order_dup(struct anonymous_9 *orig);
// tests_order_dup_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous_9 tests_order_dup_link1(struct anonymous_9 *orig_link1);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// update_col_cards_under_sequences
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences(const signed int sequences_are_built_by, const char * const col, signed int d);
// update_col_cards_under_sequences_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences_link1(const signed int sequences_are_built_by_link1, const char * const col_link1, signed int d_link1);
// user_compile_all_flares_plans
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 495
static signed int user_compile_all_flares_plans(struct anonymous * const user, signed int * const instance_list_index, char ** const error_string);
// user_free_resources
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1377
static void user_free_resources(struct anonymous * const user);
// user_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 212
static void user_initialize(struct anonymous * const user);
// user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2335
static signed int user_next_flare(struct anonymous *user);
// user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2379
static signed int user_next_instance(struct anonymous * const user);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// worker_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 209
static void * worker_thread(void *void_context);

struct anonymous_15
{
  // should_go_over_stacks
  _Bool should_go_over_stacks;
  // max_sequence_move_factor
  double max_sequence_move_factor;
  // cards_under_sequences_factor
  double cards_under_sequences_factor;
  // seqs_over_renegade_cards_factor
  double seqs_over_renegade_cards_factor;
  // depth_factor
  double depth_factor;
  // num_cards_not_on_parents_factor
  double num_cards_not_on_parents_factor;
  // num_cards_out_lookup_table
  double num_cards_out_lookup_table[14l];
  // befs_weights
  double befs_weights[6l];
};

struct anonymous_17
{
  // tests
  void (**tests)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
  // num_tests
  signed int num_tests;
  // shuffling_type
  signed int shuffling_type;
  // weighting
  struct anonymous_15 weighting;
};

struct anonymous_30
{
  // bfs_queue
  struct fcs_states_linked_list_item_struct *bfs_queue;
  // bfs_queue_last_item
  struct fcs_states_linked_list_item_struct *bfs_queue_last_item;
  // recycle_bin
  struct fcs_states_linked_list_item_struct *recycle_bin;
};

struct anonymous_31
{
  // max_size
  signed int max_size;
  // CurrentSize
  signed int CurrentSize;
  // Elements
  struct anonymous_19 *Elements;
};

struct anonymous_32
{
  // pqueue
  struct anonymous_31 pqueue;
  // weighting
  struct anonymous_15 weighting;
};

struct anonymous_33
{
  // brfs
  struct anonymous_30 brfs;
  // befs
  struct anonymous_32 befs;
};

struct anonymous_34
{
  // befs_positions_by_rank
  char *befs_positions_by_rank;
  // tests_list
  void (**tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
  // tests_list_end
  void (**tests_list_end)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
  // meth
  struct anonymous_33 meth;
};

struct anonymous_51
{
  // buffer
  char *buffer;
  // end_of_buffer
  char *end_of_buffer;
  // max_size
  signed int max_size;
};

struct anonymous_5
{
  // old_list
  char *old_list;
  // max_ptr
  char *max_ptr;
  // ptr
  char *ptr;
  // rollback_ptr
  char *rollback_ptr;
  // meta
  struct anonymous_10 *meta;
};

struct anonymous_10
{
  // recycle_bin
  char *recycle_bin;
};

struct anonymous_38
{
  // entries
  struct anonymous_53 *entries;
  // list_of_vacant_items
  struct fc_solve_hash_symlink_item_struct *list_of_vacant_items;
  // hash_type
  enum FCS_INLINED_HASH_DATA_TYPE hash_type;
  // size
  signed int size;
  // size_bitmask
  signed int size_bitmask;
  // num_elems
  signed long int num_elems;
  // max_num_elems_before_resize
  signed long int max_num_elems_before_resize;
  // allocator
  struct anonymous_5 allocator;
};

struct anonymous_3
{
  // moves
  struct anonymous_4 *moves;
  // num_moves
  unsigned short int num_moves;
};

struct anonymous_44
{
  // num_checked_states
  signed long int num_checked_states;
  // num_states_in_collection
  signed long int num_states_in_collection;
};

struct fcs_struct_state_t
{
  // stacks
  char *stacks[10l];
  // freecells
  char freecells[8l];
  // foundations
  char foundations[8l];
};

struct fcs_state_extra_info_struct
{
  // parent
  struct fcs_state_keyval_pair_struct *parent;
  // moves_to_parent
  struct anonymous_3 *moves_to_parent;
  // depth
  signed int depth;
  // visited_iter
  signed long int visited_iter;
  // num_active_children
  unsigned short int num_active_children;
  // visited
  unsigned char visited;
  // scan_visited
  unsigned char scan_visited[4l];
  // stacks_copy_on_write_flags
  signed int stacks_copy_on_write_flags;
};

struct anonymous_55
{
  // s
  struct fcs_struct_state_t s;
  // info
  struct fcs_state_extra_info_struct info;
};

union anonymous_42
{
  // _anon0
  struct anonymous_55 _anon0;
  // next
  struct fcs_state_keyval_pair_struct *next;
};

struct fcs_state_keyval_pair_struct
{
  // _anon0
  union anonymous_42 _anon0;
};

struct anonymous_7
{
  // stack_locs
  char stack_locs[10l];
  // fc_locs
  char fc_locs[8l];
};

struct anonymous_14
{
  // freecells_num
  unsigned char freecells_num;
  // stacks_num
  unsigned char stacks_num;
  // decks_num
  unsigned char decks_num;
  // game_flags
  unsigned char game_flags;
};

struct anonymous_35
{
  // preset_id
  signed int preset_id;
  // game_params
  struct anonymous_14 game_params;
  // tests_order
  char tests_order[73l];
  // allowed_tests
  char allowed_tests[73l];
};

struct anonymous
{
  // instances_list
  struct anonymous_1 *instances_list;
  // num_instances
  signed int num_instances;
  // current_instance_idx
  signed int current_instance_idx;
  // current_iterations_limit
  signed long int current_iterations_limit;
  // iterations_board_started_at
  struct anonymous_44 iterations_board_started_at;
  // init_num_checked_states
  struct anonymous_44 init_num_checked_states;
  // active_flare
  struct anonymous_2 *active_flare;
  // state
  struct fcs_state_keyval_pair_struct state;
  // running_state
  struct fcs_state_keyval_pair_struct running_state;
  // initial_non_canonized_state
  struct fcs_state_keyval_pair_struct initial_non_canonized_state;
  // state_locs
  struct anonymous_7 state_locs;
  // trace_solution_state_locs
  struct anonymous_7 trace_solution_state_locs;
  // initial_state_locs
  struct anonymous_7 initial_state_locs;
  // ret_code
  signed int ret_code;
  // all_instances_were_suspended
  _Bool all_instances_were_suspended;
  // state_validity_ret
  signed int state_validity_ret;
  // state_validity_card
  char state_validity_card;
  // iter_handler
  void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *);
  // long_iter_handler
  void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *);
  // iter_handler_context
  void *iter_handler_context;
  // flares_choice
  enum FLARES_CHOICE_TYPE flares_choice;
  // flares_iters_factor
  double flares_iters_factor;
  // soft_thread
  struct fc_solve_soft_thread_struct *soft_thread;
  // indirect_stacks_buffer
  char indirect_stacks_buffer[1280l];
  // state_string_copy
  char *state_string_copy;
  // common_preset
  struct anonymous_35 common_preset;
  // error_string
  char *error_string;
  // meta_alloc
  struct anonymous_10 meta_alloc;
};

struct anonymous_53
{
  // first_item
  struct fc_solve_hash_symlink_item_struct *first_item;
};

struct anonymous_11
{
  // num_moves
  signed int num_moves;
  // moves
  struct anonymous_4 *moves;
};

struct anonymous_40
{
  // next_move_idx
  signed int next_move_idx;
  // num_moves
  signed int num_moves;
  // moves
  struct anonymous_54 *moves;
};

struct anonymous_2
{
  // obj
  struct fc_solve_instance_struct *obj;
  // ret_code
  signed int ret_code;
  // instance_is_ready
  _Bool instance_is_ready;
  // limit
  signed int limit;
  // name
  char *name;
  // next_move
  signed int next_move;
  // moves_seq
  struct anonymous_11 moves_seq;
  // fc_pro_moves
  struct anonymous_40 fc_pro_moves;
  // obj_stats
  struct anonymous_44 obj_stats;
};

struct anonymous_12
{
  // num_states
  signed int num_states;
  // states
  struct anonymous_43 *states;
};

struct anonymous_50
{
  // state
  struct fcs_state_keyval_pair_struct *state;
  // derived_states_list
  struct anonymous_12 derived_states_list;
  // current_state_index
  signed int current_state_index;
  // tests_list_index
  signed int tests_list_index;
  // test_index
  signed int test_index;
  // derived_states_random_indexes_max_size
  signed int derived_states_random_indexes_max_size;
  // derived_states_random_indexes
  struct anonymous_25 *derived_states_random_indexes;
  // positions_by_rank
  char *positions_by_rank;
  // num_vacant_stacks
  unsigned char num_vacant_stacks;
  // num_vacant_freecells
  unsigned char num_vacant_freecells;
};

union anonymous_8
{
  // ptr
  void *ptr;
  // i
  signed int i;
  // c
  char c[(signed long int)sizeof(void *) /*8l*/ ];
};

struct anonymous_43
{
  // state_ptr
  struct fcs_state_keyval_pair_struct *state_ptr;
  // context
  union anonymous_8 context;
};

struct anonymous_19
{
  // val
  struct fcs_state_keyval_pair_struct *val;
  // rating
  signed int rating;
};

struct anonymous_6
{
  // key
  struct fcs_struct_state_t *key;
  // val
  struct fcs_state_extra_info_struct *val;
};

struct anonymous_13
{
  // key
  struct fcs_struct_state_t *key;
  // val
  struct fcs_state_extra_info_struct *val;
  // s
  struct fcs_state_keyval_pair_struct *s;
  // locs
  struct anonymous_7 locs;
};

struct anonymous_47
{
  // alias
  const char *alias;
  // test_num
  signed int test_num;
};

struct anonymous_48
{
  // name
  const char name[32l];
  // preset_id
  signed int preset_id;
};

struct anonymous_4
{
  // c
  unsigned char c[4l];
};

struct anonymous_28
{
  // debug_iter_state_output
  _Bool debug_iter_state_output;
  // parseable_output
  _Bool parseable_output;
  // canonized_order_output
  _Bool canonized_order_output;
  // display_10_as_t
  _Bool display_10_as_t;
  // display_parent_iter_num
  _Bool display_parent_iter_num;
};

struct anonymous_36
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // last_arg
  char *last_arg;
  // last_arg_ptr
  char *last_arg_ptr;
  // last_arg_end
  char *last_arg_end;
};

struct anonymous_26
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // arg
  signed int arg;
  // stop_at
  signed int stop_at;
  // end_board
  signed int end_board;
  // board_num_step
  signed int board_num_step;
  // update_total_num_iters_threshold
  signed int update_total_num_iters_threshold;
  // total_iterations_limit_per_board
  signed long int total_iterations_limit_per_board;
};

struct anonymous_18
{
  // num_units
  signed int num_units;
  // by_depth_units
  struct anonymous_52 *by_depth_units;
};

struct anonymous_49
{
  // dfs_max_depth
  signed int dfs_max_depth;
  // soft_dfs_info
  struct anonymous_50 *soft_dfs_info;
  // depth
  signed int depth;
  // rand_gen
  signed long int rand_gen;
  // rand_seed
  signed int rand_seed;
  // tests_by_depth_array
  struct anonymous_18 tests_by_depth_array;
};

struct anonymous_46
{
  // ds
  signed int ds;
  // dc
  signed int dc;
};

struct anonymous_25
{
  // idx
  signed int idx;
  // rating
  signed int rating;
};

struct anonymous_9
{
  // num_groups
  signed int num_groups;
  // groups
  struct anonymous_20 *groups;
};

struct anonymous_21
{
  // max_depth
  signed int max_depth;
  // tests_order
  struct anonymous_9 tests_order;
};

struct anonymous_16
{
  // num_lists
  signed int num_lists;
  // lists
  struct anonymous_17 *lists;
};

struct anonymous_52
{
  // max_depth
  signed int max_depth;
  // tests
  struct anonymous_16 tests;
};

struct anonymous_20
{
  // num
  signed int num;
  // tests
  signed int *tests;
  // shuffling_type
  enum anonymous_22 shuffling_type;
  // weighting
  struct anonymous_15 weighting;
};

struct anonymous_24
{
  // num
  signed int num;
  // by_depth_tests
  struct anonymous_21 *by_depth_tests;
};

struct anonymous_1
{
  // num_flares
  signed int num_flares;
  // flares
  struct anonymous_2 *flares;
  // plan
  struct anonymous_0 *plan;
  // num_plan_items
  signed int num_plan_items;
  // current_plan_item_idx
  signed int current_plan_item_idx;
  // minimal_solution_flare_idx
  signed int minimal_solution_flare_idx;
  // all_plan_items_finished_so_far
  signed int all_plan_items_finished_so_far;
  // flares_plan_string
  char *flares_plan_string;
  // flares_plan_compiled
  _Bool flares_plan_compiled;
  // limit
  signed int limit;
};

struct anonymous_45
{
  // num_separate_false_seqs
  signed int num_separate_false_seqs;
  // seq_points
  signed int seq_points[20l];
  // junk_move_to_stacks
  signed int junk_move_to_stacks[10l];
  // after_junk_num_freestacks
  signed int after_junk_num_freestacks;
  // above_num_true_seqs
  signed int above_num_true_seqs[20l];
};

struct anonymous_39
{
  // scan_idx
  signed int scan_idx;
  // quota
  signed int quota;
};

struct anonymous_0
{
  // type
  signed int type;
  // flare_idx
  signed int flare_idx;
  // count_iters
  signed int count_iters;
};

struct anonymous_54
{
  // move
  struct anonymous_4 move;
  // to_empty_stack
  _Bool to_empty_stack;
};

struct anonymous_29
{
  // display_context
  struct anonymous_28 display_context;
  // instance
  void *instance;
};

struct anonymous_41
{
  // soft_dfs
  struct anonymous_49 soft_dfs;
  // befs
  struct anonymous_34 befs;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct anonymous_27
{
  // tv
  struct timeval tv;
  // tz
  struct timezone tz;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_37
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct fc_solve_hard_thread_struct
{
  // instance
  struct fc_solve_instance_struct *instance;
  // soft_threads
  struct fc_solve_soft_thread_struct *soft_threads;
  // num_checked_states
  signed long int num_checked_states;
  // max_num_checked_states
  signed long int max_num_checked_states;
  // num_checked_states_step
  signed long int num_checked_states_step;
  // num_checked_states_left_for_soft_thread
  signed long int num_checked_states_left_for_soft_thread;
  // st_idx
  signed int st_idx;
  // allocator
  struct anonymous_5 allocator;
  // reusable_move_stack
  struct anonymous_3 reusable_move_stack;
  // indirect_stacks_buffer
  char indirect_stacks_buffer[1280l];
  // prelude_num_items
  signed long int prelude_num_items;
  // prelude_idx
  signed int prelude_idx;
  // prelude
  struct anonymous_39 *prelude;
  // allocated_from_list
  _Bool allocated_from_list;
  // num_soft_threads
  signed int num_soft_threads;
  // num_soft_threads_finished
  signed int num_soft_threads_finished;
  // prelude_as_string
  char *prelude_as_string;
};

struct fc_solve_hash_symlink_item_struct
{
  // key
  void *key;
  // hash_value
  signed int hash_value;
  // next
  struct fc_solve_hash_symlink_item_struct *next;
};

struct fc_solve_instance_struct
{
  // game_params
  struct anonymous_14 game_params;
  // num_checked_states
  signed long int num_checked_states;
  // effective_max_num_checked_states
  signed long int effective_max_num_checked_states;
  // effective_max_num_states_in_collection
  signed long int effective_max_num_states_in_collection;
  // effective_trim_states_in_collection_from
  signed long int effective_trim_states_in_collection_from;
  // hash
  struct anonymous_38 hash;
  // stacks_hash
  struct anonymous_38 stacks_hash;
  // list_of_vacant_states
  struct fcs_state_keyval_pair_struct *list_of_vacant_states;
  // runtime_flags
  unsigned char runtime_flags;
  // active_num_states_in_collection
  signed long int active_num_states_in_collection;
  // num_states_in_collection
  signed long int num_states_in_collection;
  // max_num_states_in_collection
  signed long int max_num_states_in_collection;
  // num_hard_threads
  signed int num_hard_threads;
  // hard_threads
  struct fc_solve_hard_thread_struct *hard_threads;
  // current_hard_thread
  struct fc_solve_hard_thread_struct *current_hard_thread;
  // instance_tests_order
  struct anonymous_9 instance_tests_order;
  // optimization_thread
  struct fc_solve_hard_thread_struct *optimization_thread;
  // num_hard_threads_finished
  signed int num_hard_threads_finished;
  // opt_tests_order
  struct anonymous_9 opt_tests_order;
  // max_depth
  signed int max_depth;
  // max_num_checked_states
  signed long int max_num_checked_states;
  // trim_states_in_collection_from
  signed long int trim_states_in_collection_from;
  // debug_iter_output_func
  void (*debug_iter_output_func)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int);
  // debug_iter_output_context
  void *debug_iter_output_context;
  // next_soft_thread_id
  signed int next_soft_thread_id;
  // state_copy_ptr
  struct fcs_state_keyval_pair_struct *state_copy_ptr;
  // final_state
  struct fcs_state_keyval_pair_struct *final_state;
  // solution_moves
  struct anonymous_3 solution_moves;
  // meta_alloc
  struct anonymous_10 *meta_alloc;
};

struct fc_solve_soft_thread_struct
{
  // hard_thread
  struct fc_solve_hard_thread_struct *hard_thread;
  // id
  signed int id;
  // by_depth_tests_order
  struct anonymous_24 by_depth_tests_order;
  // method
  signed int method;
  // super_method_type
  enum FCS_SUPER_METHOD_TYPE super_method_type;
  // initial_cards_under_sequences_value
  double initial_cards_under_sequences_value;
  // method_specific
  struct anonymous_41 method_specific;
  // first_state_to_check
  struct fcs_state_keyval_pair_struct *first_state_to_check;
  // runtime_flags
  unsigned char runtime_flags;
  // num_vacant_stacks
  unsigned char num_vacant_stacks;
  // num_vacant_freecells
  unsigned char num_vacant_freecells;
  // num_checked_states_step
  signed int num_checked_states_step;
  // name
  char *name;
  // enable_pruning
  _Bool enable_pruning;
};

struct fcs_states_linked_list_item_struct
{
  // s
  struct fcs_state_keyval_pair_struct *s;
  // next
  struct fcs_states_linked_list_item_struct *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};


// FLARES_PLAN_TYPE
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 83
enum anonymous_23 FLARES_PLAN_TYPE;
// card_map_3_10
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 165
static char card_map_3_10[14l][4l] = { { ' ', 0, 0, 0 }, { 'A', 0, 0, 0 }, { '2', 0, 0, 0 }, { '3', 0, 0, 0 }, { '4', 0, 0, 0 }, { '5', 0, 0, 0 }, { '6', 0, 0, 0 }, { '7', 0, 0, 0 }, { '8', 0, 0, 0 }, { '9', 0, 0, 0 }, { '1', '0', 0, 0 }, { 'J', 0, 0, 0 }, { 'Q', 0, 0, 0 }, { 'K', 0, 0, 0 } };
// card_map_3_T
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 167
static char card_map_3_T[14l][4l] = { { ' ', 0, 0, 0 }, { 'A', 0, 0, 0 }, { '2', 0, 0, 0 }, { '3', 0, 0, 0 }, { '4', 0, 0, 0 }, { '5', 0, 0, 0 }, { '6', 0, 0, 0 }, { '7', 0, 0, 0 }, { '8', 0, 0, 0 }, { '9', 0, 0, 0 }, { 'T', 0, 0, 0 }, { 'J', 0, 0, 0 }, { 'Q', 0, 0, 0 }, { 'K', 0, 0, 0 } };
// card_to_string_suits
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 90
static const char *card_to_string_suits = "CDHS";
// card_to_string_values
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 89
static const char *card_to_string_values = "A23456789TJQK";
// fc_solve_default_befs_weights
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 84
const double fc_solve_default_befs_weights[6l] = { 0.5, (const double)0, 0.3, (const double)0, 0.2, (const double)0 };
// fc_solve_empty_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 44
const struct anonymous_4 fc_solve_empty_move = { .c={ 0, 0, 0, 0 } };
// fc_solve_foundations_prefixes
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 778
static const char * const fc_solve_foundations_prefixes[7l] = { "Decks:", "Deck:", "Founds:", "Foundations:", "Foundation:", "Found:", (const char *)(void *)0 };
// fc_solve_freecells_prefixes
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 776
static const char * const fc_solve_freecells_prefixes[4l] = { "FC:", "Freecells:", "Freecell:", (const char *)(void *)0 };
// fc_solve_seqs_over_cards_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rate_state.c line 13
const double fc_solve_seqs_over_cards_lookup[105l] = { (const double)0, (const double)1, 2.46228882668983, 4.17116751094773, 6.06286626604159, 8.10328298346381, 10.2706191564582, 12.549529737647, 14.9285278645889, 17.3986384043859, 19.9526231496888, 22.5845005502473, 25.2892307921337, 28.0624999774805, 30.9005668532199, 33.8001507126398, 36.7583473599051, 39.7725647725847, 42.8404729427359, 45.9599641482642, 49.1291210446316, 52.3461907193455, 55.6095633612443, 58.9177545493537, 62.2693904150512, 65.6631951100942, 69.097980143534, 72.5726352471017, 76.0861205010657, 79.6374595075119, 83.2257334401654, 86.8500758325527, 90.5096679918781, 94.2037349461726, 97.9315418483329, 101.692390773548, 105.485617857007, 109.310590727238, 113.166706197336, 117.053388182038, 120.970085813289, 124.916271730883, 128.891440528019, 132.895107334358, 136.926806521492, 140.9860905177, 145.072528720528, 149.185706497159, 153.325224263767, 157.490696636086, 161.681751644339, 165.898030006469, 170.13918445426, 174.404879107567, 178.694788892375, 183.008598998848, 187.34600437595, 191.706709259562, 196.090426731311, 200.49687830563, 204.925793542786, 209.376909685835, 213.849971319659, 218.344730050407, 222.860944203808, 227.398378540972, 231.956803990411, 236.535997395121, 241.135741273658, 245.755823594257, 250.396037561083, 255.056181411812, 259.736058225781, 264.435475742023, 269.154246186542, 273.892186108247, 278.649116222992, 283.424861265233, 288.21924984682, 293.032114322508, 297.863290661771, 302.712618326571, 307.579940154704, 312.465102248435, 317.367953868099, 322.288347330398, 327.226137911136, 332.181183752149, 337.15334577219, 342.142487581583, 347.148475400414, 352.17117798011, 357.210466528195, 362.26621463609, 367.338298209783, 372.426595403236, 377.530986554387, 382.65135412363, 387.787582634632, 392.939558617406, 398.107170553497, 403.290308823213, 408.488865654784, 413.702735075372, 418.931812863844 };
// fc_solve_sfs_tests
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.c line 17
void (*fc_solve_sfs_tests[24l])(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
// fc_solve_sfs_tests
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.c line 17
void (*fc_solve_sfs_tests[24l])(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *) = { fc_solve_sfs_move_top_stack_cards_to_founds,
    fc_solve_sfs_move_freecell_cards_to_founds,
    fc_solve_sfs_move_freecell_cards_on_top_of_stacks,
    fc_solve_sfs_move_non_top_stack_cards_to_founds,
    fc_solve_sfs_move_stack_cards_to_different_stacks,
    fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack,
    fc_solve_sfs_move_sequences_to_free_stacks,
    fc_solve_sfs_move_freecell_cards_to_empty_stack,
    fc_solve_sfs_move_cards_to_a_different_parent,
    fc_solve_sfs_empty_stack_into_freecells,
    fc_solve_sfs_atomic_move_card_to_empty_stack,
    fc_solve_sfs_atomic_move_card_to_parent,
    fc_solve_sfs_atomic_move_card_to_freecell,
    fc_solve_sfs_atomic_move_freecell_card_to_parent,
    fc_solve_sfs_atomic_move_freecell_card_to_empty_stack,
    fc_solve_sfs_simple_simon_move_sequence_to_founds,
    fc_solve_sfs_simple_simon_move_sequence_to_true_parent,
    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent,
    fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above,
    fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent,
    fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above,
    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above,
    fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack,
    fc_solve_sfs_simple_simon_move_sequence_to_false_parent };
// fc_solve_sfs_tests_aliases
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_maps.c line 46
struct anonymous_47 fc_solve_sfs_tests_aliases[24l] = { { .alias="0", .test_num=0 }, { .alias="1", .test_num=1 }, { .alias="2", .test_num=2 }, { .alias="3", .test_num=3 }, { .alias="4", .test_num=4 }, { .alias="5", .test_num=5 }, { .alias="6", .test_num=6 }, { .alias="7", .test_num=7 }, { .alias="8", .test_num=8 }, { .alias="9", .test_num=9 }, { .alias="A", .test_num=10 }, { .alias="B", .test_num=11 }, { .alias="C", .test_num=12 }, { .alias="D", .test_num=13 }, { .alias="E", .test_num=14 }, { .alias="a", .test_num=15 }, { .alias="b", .test_num=16 }, { .alias="c", .test_num=17 }, { .alias="d", .test_num=18 }, { .alias="e", .test_num=19 }, { .alias="f", .test_num=20 }, { .alias="g", .test_num=21 }, { .alias="h", .test_num=22 }, { .alias="i", .test_num=23 } };
// fcs_preset_names
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 314
static const struct anonymous_48 fcs_preset_names[23l] = { { .name={ 'b', 'a', 'k', 'e', 'r', 's', '_', 'd', 'o', 'z', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=0 },
    { .name={ 'b', 'a', 'k', 'e', 'r', 's', '_', 'g', 'a', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=1 },
    { .name={ 'b', 'e', 'l', 'e', 'a', 'g', 'u', 'e', 'r', 'e', 'd', '_', 'c', 'a', 's', 't', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=16 },
    { .name={ 'c', 'i', 't', 'a', 'd', 'e', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=16 },
    { .name={ 'c', 'r', 'u', 'e', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=2 },
    { .name={ 'd', 'e', 'r', '_', 'k', 'a', 't', 'z', 'e', 'n', 's', 'c', 'h', 'w', 'a', 'n', 'z', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=3 },
    { .name={ 'd', 'e', 'r', '_', 'k', 'a', 't', 'z', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=3 },
    { .name={ 'd', 'i', 'e', '_', 's', 'c', 'h', 'l', 'a', 'n', 'g', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=4 },
    { .name={ 'e', 'i', 'g', 'h', 't', '_', 'o', 'f', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=5 },
    { .name={ 'f', 'a', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=6 },
    { .name={ 'f', 'o', 'r', 'e', 'c', 'e', 'l', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=7 },
    { .name={ 'f', 'r', 'e', 'e', 'c', 'e', 'l', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=8 },
    { .name={ 'g', 'o', 'o', 'd', '_', 'm', 'e', 'a', 's', 'u', 'r', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=9 },
    { .name={ 'k', 'o', '_', 'b', 'a', 'k', 'e', 'r', 's', '_', 'g', 'a', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=10 },
    { .name={ 'k', 'i', 'n', 'g', 's', '_', 'o', 'n', 'l', 'y', '_', 'b', 'a', 'k', 'e', 'r', 's', '_', 'g', 'a', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=10 },
    { .name={ 'r', 'e', 'l', 'a', 'x', 'e', 'd', '_', 'f', 'r', 'e', 'e', 'c', 'e', 'l', 'l', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=11 },
    { .name={ 'r', 'e', 'l', 'a', 'x', 'e', 'd', '_', 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', '_', 't', 'o', 'w', 'e', 'r', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=12 },
    { .name={ 'r', 'e', 'l', 'a', 'x', 'e', 'd', '_', 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=12 },
    { .name={ 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', '_', 't', 'o', 'w', 'e', 'r', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=13 },
    { .name={ 's', 'e', 'a', 'h', 'a', 'v', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=13 },
    { .name={ 's', 'i', 'm', 'p', 'l', 'e', '_', 's', 'i', 'm', 'o', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=14 },
    { .name={ 's', 't', 'r', 'e', 'e', 't', 's', '_', 'a', 'n', 'd', '_', 'a', 'l', 'l', 'e', 'y', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=16 },
    { .name={ 'y', 'u', 'k', 'o', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .preset_id=15 } };
// fcs_presets
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 64
static const struct anonymous_35 fcs_presets[16l] = { { .preset_id=0, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)13, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(2 | 2 << 2 | 0 << 4) }, .tests_order={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=1, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 0 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=16, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(2 | 0 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=2, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)12, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 2 << 2 | 0 << 4) }, .tests_order={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=3, .game_params={ .freecells_num=(unsigned char)8, .stacks_num=(unsigned char)9, .decks_num=(unsigned char)2,
    .game_flags=(unsigned char)(0 | 2 << 2 | 1 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=4, .game_params={ .freecells_num=(unsigned char)8, .stacks_num=(unsigned char)9, .decks_num=(unsigned char)2,
    .game_flags=(unsigned char)(0 | 2 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=5, .game_params={ .freecells_num=(unsigned char)8, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=6, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)18, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=7, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(0 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=8, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(0 | 0 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=9, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(2 | 2 << 2 | 0 << 4) }, .tests_order={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=10, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=11, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)8, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(0 | 0 << 2 | 1 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=12, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 1 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=13, .game_params={ .freecells_num=(unsigned char)4, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 1 << 2 | 0 << 4) }, .tests_order={ '[', '0', '1', ']', '[', '2', '3', '4', '5', '6', '7', '8', '9', ']', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .preset_id=14, .game_params={ .freecells_num=(unsigned char)0, .stacks_num=(unsigned char)10, .decks_num=(unsigned char)1,
    .game_flags=(unsigned char)(1 | 0 << 2 | 0 << 4) }, .tests_order={ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .allowed_tests={ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// initial_mutex_constant
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 187
static const union anonymous_37 initial_mutex_constant = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// known_parameters
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 158
static const char *known_parameters[11l] = { "-i", "--iter-output", "-s", "--state-output", "-p", "--parseable-output", "-t", "--display-10-as-t", "-pi", "--display-parent-iter", (const char *)(void *)0 };
// next_board_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 191
static signed int next_board_num;
// next_board_num_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 192
static union anonymous_37 next_board_num_lock;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// total_num_iters
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 206
signed long long int total_num_iters = (signed long long int)0;
// total_num_iters_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 207
static union anonymous_37 total_num_iters_lock;

// Cvtf89
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 41
static inline signed int Cvtf89(signed int fcn)
{
  return fcn >= 7 ? fcn + 3 : fcn;
}

// FCS_STATE_keyval_pair_to_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv(struct anonymous_6 *ret, struct fcs_state_keyval_pair_struct *s)
{
  ret->key = &s->_anon0._anon0.s;
  ret->val = &s->_anon0._anon0.info;
}

// FCS_STATE_keyval_pair_to_kv_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv_link1(struct anonymous_6 *ret_link1, struct fcs_state_keyval_pair_struct *s_link1)
{
  ret_link1->key = &s_link1->_anon0._anon0.s;
  ret_link1->val = &s_link1->_anon0._anon0.info;
}

// FCS_STATE_keyval_pair_to_kv_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 530
static inline void FCS_STATE_keyval_pair_to_kv_link2(struct anonymous_6 *ret_link2, struct fcs_state_keyval_pair_struct *s_link2)
{
  ret_link2->key = &s_link2->_anon0._anon0.s;
  ret_link2->val = &s_link2->_anon0._anon0.info;
}

// accumulate_tests_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 199
static inline void accumulate_tests_by_ptr(signed int * const tests_order, struct anonymous_9 * const st_tests_order)
{
  const struct anonymous_20 *group_ptr = st_tests_order->groups;
  const struct anonymous_20 * const groups_end = group_ptr + (signed long int)st_tests_order->num_groups;
  for( ; !(group_ptr >= groups_end); group_ptr = group_ptr + 1l)
  {
    const signed int *test_ptr = group_ptr->tests;
    const signed int * const tests_end = test_ptr + (signed long int)group_ptr->num;
    for( ; !(test_ptr >= tests_end); test_ptr = test_ptr + 1l)
      *tests_order = *tests_order | 1 << *test_ptr;
  }
}

// accumulate_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 217
static inline void accumulate_tests_order(struct fc_solve_soft_thread_struct * const soft_thread, void * const context)
{
  accumulate_tests_by_ptr((signed int *)context, &(soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order);
}

// add_checkpoint_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 476
static inline signed int add_checkpoint_to_plan(struct anonymous_1 *instance_item)
{
  signed int return_value_add_to_plan_1;
  return_value_add_to_plan_1=add_to_plan(instance_item, FLARES_PLAN_CHECKPOINT, -1, -1);
  return return_value_add_to_plan_1;
}

// add_count_iters_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 464
static inline signed int add_count_iters_to_plan(struct anonymous_1 *instance_item, signed int flare_idx, signed int count_iters)
{
  signed int return_value_add_to_plan_1;
  return_value_add_to_plan_1=add_to_plan(instance_item, FLARES_PLAN_RUN_COUNT_ITERS, flare_idx, count_iters);
  return return_value_add_to_plan_1;
}

// add_run_indef_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 485
static inline signed int add_run_indef_to_plan(struct anonymous_1 *instance_item, signed int flare_idx)
{
  signed int return_value_add_to_plan_1;
  return_value_add_to_plan_1=add_to_plan(instance_item, FLARES_PLAN_RUN_INDEFINITELY, flare_idx, -1);
  return return_value_add_to_plan_1;
}

// add_to_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 65
static inline void add_to_last_arg(struct anonymous_36 *manager, char c)
{
  char *tmp_post_1 = manager->last_arg_ptr;
  manager->last_arg_ptr = manager->last_arg_ptr + 1l;
  *tmp_post_1 = c;
  if(manager->last_arg_ptr == manager->last_arg_end)
  {
    char *new_last_arg;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)manager->last_arg, sizeof(char) /*1ul*/  * (unsigned long int)((manager->last_arg_end - manager->last_arg) + (signed long int)1024));
    new_last_arg = (char *)return_value_realloc_2;
    manager->last_arg_ptr = manager->last_arg_ptr + (new_last_arg - manager->last_arg);
    manager->last_arg_end = manager->last_arg_end + (new_last_arg - manager->last_arg) + (signed long int)1024;
    manager->last_arg = new_last_arg;
  }

}

// add_to_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 443
static inline signed int add_to_plan(struct anonymous_1 *instance_item, signed int mytype, signed int flare_idx, signed int count_iters)
{
  signed int next_item = instance_item->num_plan_items;
  instance_item->num_plan_items = instance_item->num_plan_items + 1;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)instance_item->plan, sizeof(struct anonymous_0) /*12ul*/  * (unsigned long int)instance_item->num_plan_items);
  instance_item->plan = (struct anonymous_0 *)return_value_realloc_1;
  (instance_item->plan + (signed long int)next_item)->type = mytype;
  (instance_item->plan + (signed long int)next_item)->flare_idx = flare_idx;
  (instance_item->plan + (signed long int)next_item)->count_iters = count_iters;
  return mytype;
}

// apply_game_params_for_all_instances
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1494
static void apply_game_params_for_all_instances(struct anonymous * const user)
{
  signed int user_inst_idx = 0;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous_1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
    signed int flare_idx = 0;
    for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
    {
      struct anonymous_2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      flare->obj->game_params = user->common_preset.game_params;
    }
  }
}

// assign_dest_stack_and_col_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2059
static inline void assign_dest_stack_and_col_ptr(char * const positions_by_rank, signed int dest_stack, signed int dest_col, char dest_card)
{
  char *ptr = &positions_by_rank[(signed long int)((2 << 3) * (((signed int)dest_card >> 2) - 1) + (((signed int)dest_card & 0x03) << 1))];
  for( ; !((signed int)*ptr == -1); ptr = ptr + (signed long int)(4 << 1))
    ;
  char *tmp_post_1 = ptr;
  ptr = ptr + 1l;
  *tmp_post_1 = (char)dest_stack;
  *ptr = (char)dest_col;
}

// befs_rate_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 328
static inline signed int befs_rate_state(const struct fc_solve_soft_thread_struct * const soft_thread, const struct anonymous_15 * const weighting, const struct fcs_struct_state_t * const state, const signed int neg_depth)
{
  const struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  const _Bool int_unlimited_sequence_move = (const _Bool)((signed int)instance->game_params.game_flags & 1 << 4);
  double cards_under_sequences = (double)0;
  double seqs_over_renegade_cards = (double)0;
  double sum = (double)(0 > neg_depth ? 0 : neg_depth) * weighting->depth_factor;
  if(IEEE_FLOAT_NOTEQUAL(weighting->num_cards_out_lookup_table[1l], 0.000000))
  {
    const signed int num_founds = (signed int)game_params.decks_num << 2;
    signed int found_idx = 0;
    for( ; !(found_idx >= num_founds); found_idx = found_idx + 1)
      sum = sum + weighting->num_cards_out_lookup_table[(signed long int)(signed int)state->foundations[(signed long int)found_idx]];
  }

  unsigned char num_vacant_stacks = (unsigned char)0;
  unsigned char num_vacant_freecells = (unsigned char)0;
  double tmp_if_expr_1;
  if(!(weighting->should_go_over_stacks == (_Bool)0))
  {
    signed int a = 0;
    for( ; !(a >= (signed int)game_params.stacks_num); a = a + 1)
    {
      const char * const befs_rate_state__1__2__1__1__col = state->stacks[(signed long int)a];
      const signed int cards_num = (const signed int)befs_rate_state__1__2__1__1__col[(signed long int)0];
      if(!(cards_num >= 2))
      {
        if(cards_num == 0)
          num_vacant_stacks = num_vacant_stacks + 1;

      }

      else
      {
        signed int c;
        c=update_col_cards_under_sequences_link1(sequences_are_built_by, befs_rate_state__1__2__1__1__col, cards_num - 1);
        cards_under_sequences = cards_under_sequences + fc_solve_seqs_over_cards_lookup[(signed long int)c];
        if(c >= 1)
        {
          if(!(int_unlimited_sequence_move == (_Bool)0))
            tmp_if_expr_1 = (double)1;

          else
            tmp_if_expr_1 = fc_solve_seqs_over_cards_lookup[(signed long int)(cards_num - c)];
          seqs_over_renegade_cards = seqs_over_renegade_cards + tmp_if_expr_1;
        }

      }
    }
    signed int freecell_idx = 0;
    for( ; !(freecell_idx >= (signed int)game_params.freecells_num); freecell_idx = freecell_idx + 1)
      if((signed int)state->freecells[(signed long int)freecell_idx] >> 2 == 0)
        num_vacant_freecells = num_vacant_freecells + 1;

    sum = sum + (double)(((signed int)instance->game_params.game_flags >> 2 & 0x3) == 0 ? (int_unlimited_sequence_move != (_Bool)0 ? (signed int)num_vacant_freecells + (signed int)num_vacant_stacks : (signed int)num_vacant_freecells + 1 << (signed int)num_vacant_stacks) : (int_unlimited_sequence_move != (_Bool)0 ? (signed int)num_vacant_freecells : 0)) * weighting->max_sequence_move_factor + (soft_thread->initial_cards_under_sequences_value - cards_under_sequences) * weighting->cards_under_sequences_factor + seqs_over_renegade_cards * weighting->seqs_over_renegade_cards_factor;
  }

  double num_cards_not_on_parents_weight = weighting->num_cards_not_on_parents_factor;
  if(IEEE_FLOAT_NOTEQUAL(num_cards_not_on_parents_weight, 0.000000))
  {
    signed int num_cards_not_on_parents = (signed int)game_params.decks_num * 52;
    signed int stack_idx = 0;
    for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
    {
      const char * const col = state->stacks[(signed long int)stack_idx];
      const signed int col_len = (const signed int)col[(signed long int)0];
      char parent_card = col[(signed long int)(0 + 1)];
      signed int h = 1;
      for( ; !(h >= col_len); h = h + 1)
      {
        const char child_card = col[(signed long int)(h + 1)];
        if(!(((signed int)parent_card >> 2) + 1 == (signed int)child_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)parent_card) == (0x03 & (signed int)child_card) : !((1 & (signed int)parent_card) == (1 & (signed int)child_card))))
          num_cards_not_on_parents = num_cards_not_on_parents - 1;

        parent_card = child_card;
      }
    }
    sum = sum + (double)num_cards_not_on_parents * num_cards_not_on_parents_weight;
  }

  return (signed int)sum;
}

// calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 66
static inline signed int calc_depth(struct fcs_state_keyval_pair_struct *ptr_state)
{
  return ptr_state->_anon0._anon0.info.depth;
}

// calc_foundation_to_put_card_on
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1903
static inline signed int calc_foundation_to_put_card_on(const struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const my_ptr_state, const char card)
{
  const struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  signed int deck = 0;
  for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
    if((signed int)my_ptr_state->foundations[(signed long int)((0x03 & (signed int)card) + (deck << 2))] == ((signed int)card >> 2) + -1)
    {
      signed int ret_val = (deck << 2) + ((signed int)card & 0x03);
      if(sequences_are_built_by == 1)
        return ret_val;

      signed int other_deck_idx = 0;
      for( ; !(other_deck_idx >= (signed int)instance->game_params.decks_num << 2); other_deck_idx = other_deck_idx + 1)
        if(!((signed int)my_ptr_state->foundations[(signed long int)other_deck_idx] >= ((signed int)card >> 2) + -2 + -(sequences_are_built_by == 2 ? 0 : (signed int)((0x1 & other_deck_idx) == (1 & (signed int)card)))))
          break;

      if(other_deck_idx == (signed int)instance->game_params.decks_num << 2)
        return ret_val;

    }

  return -1;
}

// calc_moves_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 869
static signed int calc_moves_seq(const struct anonymous_3 * const solution_moves, struct anonymous_11 * const moves_seq)
{
  moves_seq->num_moves = 0;
  moves_seq->moves = (struct anonymous_4 *)(void *)0;
  signed int num_moves = (signed int)solution_moves->num_moves;
  struct anonymous_4 *next_move_ptr = (solution_moves->moves + (signed long int)num_moves) - (signed long int)1;
  struct anonymous_4 *ret_moves;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)num_moves);
  ret_moves = (struct anonymous_4 *)return_value_malloc_1;
  struct anonymous_4 *tmp_post_2;
  if(ret_moves == ((struct anonymous_4 *)NULL))
    return -1;

  else
  {
    signed int i = 0;
    for( ; !(i >= num_moves); i = i + 1)
    {
      tmp_post_2 = next_move_ptr;
      next_move_ptr = next_move_ptr - 1l;
      ret_moves[(signed long int)i] = *tmp_post_2;
    }
    moves_seq->num_moves = num_moves;
    moves_seq->moves = ret_moves;
    return 0;
  }
}

// calculate_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 551
static inline void calculate_real_depth(const _Bool calc_real_depth, struct fcs_state_keyval_pair_struct * const ptr_state_orig)
{
  if(!(calc_real_depth == (_Bool)0))
  {
    signed int this_real_depth = 0;
    struct fcs_state_keyval_pair_struct *temp_state = ptr_state_orig;
    for( ; !(temp_state == ((struct fcs_state_keyval_pair_struct *)NULL)); this_real_depth = this_real_depth + 1)
      temp_state = temp_state->_anon0._anon0.info.parent;
    this_real_depth = this_real_depth - 1;
    temp_state = ptr_state_orig;
    for( ; !(temp_state->_anon0._anon0.info.depth == this_real_depth); temp_state = temp_state->_anon0._anon0.info.parent)
    {
      temp_state->_anon0._anon0.info.depth = this_real_depth;
      this_real_depth = this_real_depth - 1;
    }
  }

}

// card_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 92
static inline char * card_to_string(char *s, signed int card, signed int not_append_ws)
{
  s[(signed long int)0] = card_to_string_values[(signed long int)(card / 4)];
  s[(signed long int)1] = card_to_string_suits[(signed long int)(card % 4)];
  if(!(not_append_ws == 0))
    return &s[(signed long int)2];

  else
  {
    s[(signed long int)2] = (char)32;
    return &s[(signed long int)3];
  }
}

// clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 287
static inline void clean_soft_dfs(struct fc_solve_instance_struct * const instance)
{
  fc_solve_foreach_soft_thread(instance, 0, (void *)0);
}

// cmd_line_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 106
static signed int cmd_line_callback(void *instance, signed int argc, const char **argv, signed int arg, signed int *num_to_skip, signed int *ret, void *context)
{
  struct anonymous_28 * const dc = &((struct anonymous_29 *)context)->display_context;
  *num_to_skip = 0;
  signed int return_value_strcmp_16;
  return_value_strcmp_16=strcmp(argv[(signed long int)arg], "-i");
  _Bool tmp_if_expr_18;
  signed int return_value_strcmp_17;
  if(return_value_strcmp_16 == 0)
    tmp_if_expr_18 = (_Bool)1;

  else
  {
    return_value_strcmp_17=strcmp(argv[(signed long int)arg], "--iter-output");
    tmp_if_expr_18 = !(return_value_strcmp_17 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_13;
  _Bool tmp_if_expr_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_10;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_7;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_4;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(tmp_if_expr_18)
    freecell_solver_user_set_iter_handler_long(instance, my_iter_handler, (void *)dc);

  else
  {
    return_value_strcmp_13=strcmp(argv[(signed long int)arg], "-s");
    if(return_value_strcmp_13 == 0)
      tmp_if_expr_15 = (_Bool)1;

    else
    {
      return_value_strcmp_14=strcmp(argv[(signed long int)arg], "--state-output");
      tmp_if_expr_15 = !(return_value_strcmp_14 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_15)
      dc->debug_iter_state_output = (_Bool)1;

    else
    {
      return_value_strcmp_10=strcmp(argv[(signed long int)arg], "-p");
      if(return_value_strcmp_10 == 0)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_strcmp_11=strcmp(argv[(signed long int)arg], "--parseable-output");
        tmp_if_expr_12 = !(return_value_strcmp_11 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        dc->parseable_output = (_Bool)1;

      else
      {
        return_value_strcmp_7=strcmp(argv[(signed long int)arg], "-c");
        if(return_value_strcmp_7 == 0)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_strcmp_8=strcmp(argv[(signed long int)arg], "--canonized-order-output");
          tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          dc->canonized_order_output = (_Bool)1;

        else
        {
          return_value_strcmp_4=strcmp(argv[(signed long int)arg], "-t");
          if(return_value_strcmp_4 == 0)
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_strcmp_5=strcmp(argv[(signed long int)arg], "--display-10-as-t");
            tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_6)
            dc->display_10_as_t = (_Bool)1;

          else
          {
            return_value_strcmp_1=strcmp(argv[(signed long int)arg], "-pi");
            if(return_value_strcmp_1 == 0)
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              return_value_strcmp_2=strcmp(argv[(signed long int)arg], "--display-parent-iter");
              tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_3)
              dc->display_parent_iter_num = (_Bool)1;

            else
            {
              fprintf(stderr, "Unknown option %s!\n", argv[(signed long int)arg]);
              exit(-1);
              return 0;
            }
          }
        }
      }
    }
  }
  *num_to_skip = 1;
  return 1;
}

// compare_rating_with_index
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 962
static signed int compare_rating_with_index(const void *void_a, const void *void_b)
{
  const struct anonymous_25 * const a = (const struct anonymous_25 *)void_a;
  const struct anonymous_25 * const b = (const struct anonymous_25 *)void_b;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(!(a->rating >= b->rating))
    tmp_if_expr_2 = -1;

  else
  {
    if(!(b->rating >= a->rating))
      tmp_if_expr_1 = 1;

    else
      tmp_if_expr_1 = a->idx - b->idx;
    tmp_if_expr_2 = tmp_if_expr_1;
  }
  return tmp_if_expr_2;
}

// compile_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 491
static inline signed int compile_prelude(struct fc_solve_hard_thread_struct * const hard_thread)
{
  _Bool last_one = (_Bool)0;
  signed int num_items = 0;
  struct anonymous_39 *prelude = (struct anonymous_39 *)(void *)0;
  const char *p = hard_thread->prelude_as_string;
  const unsigned short int **return_value___ctype_b_loc_1;
  signed int return_value_strcmp_2;
  while(last_one == (_Bool)0)
  {
    signed int p_quota;
    p_quota=atoi(p);
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*p]) == 0)
        break;

    }
    if(!((signed int)*p == 64))
    {
      free((void *)prelude);
      return 1;
    }

    p = p + 1l;
    const char * const p_scan = p;
    for( ; !(*p == 0); p = p + 1l)
      if((signed int)*p == 44)
        break;

    if((signed int)*p == 0)
      last_one = (_Bool)1;

    char *p_scan_copy;
    p_scan_copy=strndup(p_scan, (unsigned long int)(p - p_scan));
    p = p + 1l;
    struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
    struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
    for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
      if(!(soft_thread->name == ((char *)NULL)))
      {
        return_value_strcmp_2=strcmp(soft_thread->name, p_scan_copy);
        if(return_value_strcmp_2 == 0)
          break;

      }

    free((void *)p_scan_copy);
    if(soft_thread == end_soft_thread)
    {
      free((void *)prelude);
      return 2;
    }

    if((16 & num_items) == 0)
    {
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)prelude, sizeof(struct anonymous_39) /*8ul*/  * (unsigned long int)(num_items + 16));
      prelude = (struct anonymous_39 *)return_value_realloc_3;
    }

    (prelude + (signed long int)num_items)->scan_idx = (signed int)(soft_thread - hard_thread->soft_threads);
    (prelude + (signed long int)num_items)->quota = p_quota;
    num_items = num_items + 1;
  }
  void *return_value_realloc_4;
  return_value_realloc_4=realloc((void *)prelude, sizeof(struct anonymous_39) /*8ul*/  * (unsigned long int)num_items);
  hard_thread->prelude = (struct anonymous_39 *)return_value_realloc_4;
  hard_thread->prelude_num_items = (signed long int)num_items;
  hard_thread->prelude_idx = 0;
  return 0;
}

// convert_freecell_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 170
static inline signed int convert_freecell_num(signed int fcn)
{
  if(fcn >= 7)
    return fcn + 3;

  else
    return fcn;
}

// count_num_vacant_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 926
static inline unsigned char count_num_vacant_freecells(const unsigned char freecells_num, const struct fcs_struct_state_t * const state_ptr)
{
  unsigned char num_vacant_freecells = (unsigned char)0;
  signed int i = 0;
  for( ; !(i >= (signed int)freecells_num); i = i + 1)
    if((signed int)state_ptr->freecells[(signed long int)i] >> 2 == 0)
      num_vacant_freecells = num_vacant_freecells + 1;

  return num_vacant_freecells;
}

// count_num_vacant_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 943
static inline unsigned char count_num_vacant_stacks(const unsigned char stacks_num, const struct fcs_struct_state_t * const state_ptr)
{
  unsigned char num_vacant_stacks = (unsigned char)0;
  signed int i = 0;
  for( ; !(i >= (signed int)stacks_num); i = i + 1)
    if((signed int)*state_ptr->stacks[(signed long int)i] == 0)
      num_vacant_stacks = num_vacant_stacks + 1;

  return num_vacant_stacks;
}

// determine_scan_completeness
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 225
static inline void determine_scan_completeness(struct fc_solve_soft_thread_struct * const soft_thread, void * const global_tests_order)
{
  signed int tests_order = 0;
  accumulate_tests_by_ptr(&tests_order, &(soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order);
  soft_thread->runtime_flags = soft_thread->runtime_flags & (unsigned char)~2;
  if(tests_order == *((signed int *)global_tests_order))
    soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)2;

}

// duplicate_string_while_adding_a_trailing_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 722
static inline char * duplicate_string_while_adding_a_trailing_newline(const char *orig_str)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(orig_str);
  len = (signed int)return_value_strlen_1;
  char *s;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len + 2));
  s = (char *)return_value_malloc_2;
  strcpy(s, orig_str);
  char *s_end = (s + (signed long int)len) - (signed long int)1;
  if(!((signed int)*s_end == 10))
  {
    s_end = s_end + 1l;
    *s_end = (char)10;
    s_end = s_end + 1l;
    *s_end = (char)0;
  }

  return s;
}

// empty_two_cols_from_new_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 187
static inline signed int empty_two_cols_from_new_state(const struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const kv_ptr_new_state, struct anonymous_3 * const moves, const signed int *cols_indexes, const signed int nc1, const signed int nc2)
{
  signed int ret = -1;
  signed int num_cards_to_move_from_columns[3l] = { nc1, nc2, -1 };
  const signed int *col_idx = cols_indexes;
  signed int *col_num_cards = num_cards_to_move_from_columns;
  const struct anonymous_14 game_params = soft_thread->hard_thread->instance->game_params;
  char * const indirect_stacks_buffer = soft_thread->hard_thread->indirect_stacks_buffer;
  signed int dest_fc_idx = 0;
  while((_Bool)1)
  {
    while(*col_num_cards == 0)
    {
      col_num_cards = col_num_cards + 1l;
      col_idx = col_idx + 1l;
      if(*col_idx == -1)
        return ret;

    }
    for( ; !(dest_fc_idx >= (signed int)game_params.freecells_num); dest_fc_idx = dest_fc_idx + 1)
      if((signed int)kv_ptr_new_state->key->freecells[(signed long int)dest_fc_idx] >> 2 == 0)
        break;

    if(dest_fc_idx == (signed int)game_params.freecells_num)
      break;

    char * const empty_two_cols_from_new_state__1__1__1__new_from_which_col = kv_ptr_new_state->key->stacks[(signed long int)*col_idx];
    char empty_two_cols_from_new_state__1__1__1__top_card = empty_two_cols_from_new_state__1__1__1__new_from_which_col[(signed long int)(((signed int)empty_two_cols_from_new_state__1__1__1__new_from_which_col[(signed long int)0] - 1) + 1)];
    empty_two_cols_from_new_state__1__1__1__new_from_which_col[(signed long int)0] = empty_two_cols_from_new_state__1__1__1__new_from_which_col[(signed long int)0] - 1;
    empty_two_cols_from_new_state__1__1__1__new_from_which_col[(signed long int)((signed int)empty_two_cols_from_new_state__1__1__1__new_from_which_col[(signed long int)0] + 1)] = (char)0;
    kv_ptr_new_state->key->freecells[(signed long int)dest_fc_idx] = empty_two_cols_from_new_state__1__1__1__top_card;
    fcs_move_stack_non_seq_push(moves, 1, *col_idx, dest_fc_idx);
    ret = dest_fc_idx;
    *col_num_cards = *col_num_cards - 1;
    dest_fc_idx = dest_fc_idx + 1;
  }
  while(*col_num_cards == 0)
  {
    col_num_cards = col_num_cards + 1l;
    col_idx = col_idx + 1l;
    if(*col_idx == -1)
      return ret;

  }
  signed int put_cards_in_col_idx = 0;
  char tmp_post_1;
  while((_Bool)1)
  {
    while(*col_num_cards == 0)
    {
      col_num_cards = col_num_cards + 1l;
      col_idx = col_idx + 1l;
      if(*col_idx == -1)
        return ret;

    }
    for( ; !(put_cards_in_col_idx >= (signed int)game_params.stacks_num); put_cards_in_col_idx = put_cards_in_col_idx + 1)
      if((signed int)*kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx] == 0)
        break;

    /* assertion put_cards_in_col_idx < (game_params.stacks_num) */
    assert(put_cards_in_col_idx < (signed int)game_params.stacks_num);
    if((kv_ptr_new_state->val->stacks_copy_on_write_flags & 1 << put_cards_in_col_idx) == 0)
    {
      char *copy_stack_col;
      kv_ptr_new_state->val->stacks_copy_on_write_flags = kv_ptr_new_state->val->stacks_copy_on_write_flags | 1 << put_cards_in_col_idx;
      copy_stack_col = kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx];
      memcpy((void *)&indirect_stacks_buffer[(signed long int)(put_cards_in_col_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx] = &indirect_stacks_buffer[(signed long int)(put_cards_in_col_idx << 7)];
    }

    char * const new_b_col = kv_ptr_new_state->key->stacks[(signed long int)put_cards_in_col_idx];
    const signed int col_idx_val = *col_idx;
    char * const new_from_which_col = kv_ptr_new_state->key->stacks[(signed long int)col_idx_val];
    char top_card = new_from_which_col[(signed long int)(((signed int)new_from_which_col[(signed long int)0] - 1) + 1)];
    new_from_which_col[(signed long int)0] = new_from_which_col[(signed long int)0] - 1;
    new_from_which_col[(signed long int)((signed int)new_from_which_col[(signed long int)0] + 1)] = (char)0;
    tmp_post_1 = new_b_col[(signed long int)0];
    new_b_col[(signed long int)0] = new_b_col[(signed long int)0] + 1;
    new_b_col[(signed long int)((signed int)tmp_post_1 + 1)] = top_card;
    fcs_push_1card_seq(moves, col_idx_val, put_cards_in_col_idx);
    ret = put_cards_in_col_idx | 1 << 8;
    *col_num_cards = *col_num_cards - 1;
    put_cards_in_col_idx = put_cards_in_col_idx + 1;
  }
}

// false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 606
static inline const _Bool false_seq_index_loop(const signed int stacks_num, struct anonymous_6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous_45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag)
{
  _Bool return_value_generic_false_seq_index_loop_1;
  return_value_generic_false_seq_index_loop_1=generic_false_seq_index_loop(stacks_num, raw_ptr_state_raw, num_vacant_stacks, col, seqs, stack_idx, ds, behaviour_flag, (const _Bool)0, (char)0, 0);
  return return_value_generic_false_seq_index_loop_1;
}

// fc_solve_PQueueFree
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree(struct anonymous_31 *pq)
{
  free((void *)pq->Elements);
  pq->Elements = (struct anonymous_19 *)(void *)0;
}

// fc_solve_PQueueFree_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree_link1(struct anonymous_31 *pq_link1)
{
  free((void *)pq_link1->Elements);
  pq_link1->Elements = (struct anonymous_19 *)(void *)0;
}

// fc_solve_PQueueFree_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 100
static inline void fc_solve_PQueueFree_link2(struct anonymous_31 *pq_link2)
{
  free((void *)pq_link2->Elements);
  pq_link2->Elements = (struct anonymous_19 *)(void *)0;
}

// fc_solve_PQueueInitialise
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 88
static inline void fc_solve_PQueueInitialise(struct anonymous_31 *pq, signed int MaxElements)
{
  pq->max_size = MaxElements;
  pq->CurrentSize = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_19) /*16ul*/  * (unsigned long int)(MaxElements + 1));
  pq->Elements = (struct anonymous_19 *)return_value_malloc_1;
}

// fc_solve_PQueuePop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 177
static inline void fc_solve_PQueuePop(struct anonymous_31 *pq, struct fcs_state_keyval_pair_struct **val)
{
  signed int i;
  signed int child;
  struct anonymous_19 *Elements = pq->Elements;
  signed int CurrentSize = pq->CurrentSize;
  struct anonymous_19 pMaxElement;
  struct anonymous_19 pLastElement;
  signed int tmp_post_1;
  if(pq->CurrentSize == 0)
    *val = (struct fcs_state_keyval_pair_struct *)(void *)0;

  else
  {
    pMaxElement = Elements[(signed long int)1];
    tmp_post_1 = CurrentSize;
    CurrentSize = CurrentSize - 1;
    pLastElement = Elements[(signed long int)tmp_post_1];
    i = 1;
    do
    {
      child = i << 1;
      if(!(CurrentSize >= child))
        break;

      if(!(child == CurrentSize))
      {
        if(!((Elements + (signed long int)child)->rating >= (Elements + (signed long int)(1 + child))->rating))
          child = child + 1;

      }

      if(!(pLastElement.rating >= (Elements + (signed long int)child)->rating))
        Elements[(signed long int)i] = Elements[(signed long int)child];

      else
        break;
      i = child;
    }
    while((_Bool)1);
    Elements[(signed long int)i] = pLastElement;
    pq->CurrentSize = CurrentSize;
    *val = pMaxElement.val;
    goto __CPROVER_DUMP_L7;
  }

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_PQueuePush
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/pqueue.h line 114
static inline void fc_solve_PQueuePush(struct anonymous_31 *pq, struct fcs_state_keyval_pair_struct *val, signed int r)
{
  unsigned int i;
  struct anonymous_19 *Elements = pq->Elements;
  signed int CurrentSize = pq->CurrentSize;
  if(CurrentSize == pq->max_size)
  {
    pq->max_size = pq->max_size + 256;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)Elements, sizeof(struct anonymous_19) /*16ul*/  * (unsigned long int)(pq->max_size + 1));
    Elements = (struct anonymous_19 *)return_value_realloc_1;
    pq->Elements = Elements;
  }

  CurrentSize = CurrentSize + 1;
  i = (unsigned int)CurrentSize;
  signed int tmp_if_expr_2;
  do
  {
    if(i == 1u)
      tmp_if_expr_2 = 0x7fffffff;

    else
      tmp_if_expr_2 = (Elements + (signed long int)(i >> 1))->rating;
    if(tmp_if_expr_2 >= r)
      break;

    Elements[(signed long int)i] = Elements[(signed long int)(i >> 1)];
    i = i >> 1;
  }
  while((_Bool)1);
  (Elements + (signed long int)i)->val = val;
  (Elements + (signed long int)i)->rating = r;
  pq->CurrentSize = CurrentSize;
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// fc_solve_alloc_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 394
struct fc_solve_instance_struct * fc_solve_alloc_instance(struct anonymous_10 * const meta_alloc)
{
  struct fc_solve_instance_struct *instance;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct fc_solve_instance_struct) /*416ul*/  * (unsigned long int)1);
  instance = (struct fc_solve_instance_struct *)return_value_malloc_1;
  instance->meta_alloc = meta_alloc;
  instance->num_checked_states = (signed long int)0;
  instance->num_states_in_collection = (signed long int)0;
  instance->active_num_states_in_collection = (signed long int)0;
  instance->max_num_checked_states = (signed long int)-1;
  instance->effective_max_num_checked_states = (signed long int)0x7fffffff;
  instance->max_depth = -1;
  instance->max_num_states_in_collection = (signed long int)-1;
  instance->effective_max_num_states_in_collection = (signed long int)0x7fffffff;
  instance->trim_states_in_collection_from = (signed long int)-1;
  instance->effective_trim_states_in_collection_from = 0x7fffffffffffffffL;
  instance->instance_tests_order.num_groups = 0;
  instance->instance_tests_order.groups = (struct anonymous_20 *)(void *)0;
  instance->list_of_vacant_states = (struct fcs_state_keyval_pair_struct *)(void *)0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~8;
  instance->opt_tests_order.num_groups = 0;
  instance->opt_tests_order.groups = (struct anonymous_20 *)(void *)0;
  instance->num_hard_threads = 0;
  instance->hard_threads = (struct fc_solve_hard_thread_struct *)(void *)0;
  fc_solve_apply_preset_by_name(instance, "freecell");
  instance->debug_iter_output_func = (void (*)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int))(void *)0;
  instance->next_soft_thread_id = 0;
  fc_solve_new_hard_thread(instance);
  instance->solution_moves.moves = (struct anonymous_4 *)(void *)0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~1;
  instance->optimization_thread = (struct fc_solve_hard_thread_struct *)(void *)0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~2;
  instance->num_hard_threads_finished = 0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~4;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~16;
  instance->runtime_flags = instance->runtime_flags | (unsigned char)64;
  return instance;
}

// fc_solve_append_string_finalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 62
static inline char * fc_solve_append_string_finalize(struct anonymous_51 *app_str)
{
  char *ret;
  ret=strdup(app_str->buffer);
  free((void *)app_str->buffer);
  return ret;
}

// fc_solve_append_string_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.h line 53
static inline void fc_solve_append_string_init(struct anonymous_51 *app_str)
{
  app_str->max_size = 4000;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)app_str->max_size);
  app_str->buffer = (char *)return_value_malloc_1;
  app_str->end_of_buffer = app_str->buffer;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// fc_solve_append_string_sprintf
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/app_str.c line 38
extern void fc_solve_append_string_sprintf(struct anonymous_51 *app_str, const char *format, ...)
{
  void **my_va_list = (void **)&format;
  signed int return_value_vsprintf_1;
  return_value_vsprintf_1=vsprintf(app_str->end_of_buffer, format, my_va_list);
  app_str->end_of_buffer = app_str->end_of_buffer + (signed long int)return_value_vsprintf_1;
  if(!((app_str->buffer + (signed long int)app_str->max_size) - app_str->end_of_buffer >= 500l))
  {
    char *old_buffer = app_str->buffer;
    app_str->max_size = app_str->max_size + 4000;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)app_str->buffer, sizeof(char) /*1ul*/  * (unsigned long int)app_str->max_size);
    app_str->buffer = (char *)return_value_realloc_2;
    app_str->end_of_buffer = app_str->end_of_buffer + (app_str->buffer - old_buffer);
  }

  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// fc_solve_apply_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 120
void fc_solve_apply_move(struct anonymous_6 *state, struct anonymous_7 *locs, struct anonymous_4 move, signed int freecells_num, signed int stacks_num, signed int decks_num)
{
  char card;
  char *col;
  char tmp_post_1;
  char tmp_post_2;
  switch((signed int)move.c[(signed long int)0])
  {
    case 0:
    {
      char *dest_col;
      signed int fc_solve_apply_move__1__1__1__i;
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      dest_col = state->key->stacks[(signed long int)move.c[(signed long int)2]];
      fc_solve_apply_move__1__1__1__i = 0;
      for( ; !(fc_solve_apply_move__1__1__1__i >= (signed int)move.c[3l]); fc_solve_apply_move__1__1__1__i = fc_solve_apply_move__1__1__1__i + 1)
      {
        tmp_post_1 = dest_col[(signed long int)0];
        dest_col[(signed long int)0] = dest_col[(signed long int)0] + 1;
        dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = col[(signed long int)(((signed int)col[(signed long int)0] - (signed int)move.c[(signed long int)3]) + fc_solve_apply_move__1__1__1__i + 1)];
      }
      fc_solve_apply_move__1__1__1__i = 0;
      for( ; !(fc_solve_apply_move__1__1__1__i >= (signed int)move.c[3l]); fc_solve_apply_move__1__1__1__i = fc_solve_apply_move__1__1__1__i + 1)
      {
        col[(signed long int)0] = col[(signed long int)0] - 1;
        col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
      }
      break;
    }
    case 2:
    {
      col = state->key->stacks[(signed long int)move.c[(signed long int)2]];
      tmp_post_2 = col[(signed long int)0];
      col[(signed long int)0] = col[(signed long int)0] + 1;
      col[(signed long int)((signed int)tmp_post_2 + 1)] = state->key->freecells[(signed long int)move.c[(signed long int)1]];
      state->key->freecells[(signed long int)move.c[(signed long int)1]] = (char)0;
      break;
    }
    case 3:
    {
      card = state->key->freecells[(signed long int)move.c[(signed long int)1]];
      state->key->freecells[(signed long int)move.c[(signed long int)2]] = card;
      state->key->freecells[(signed long int)move.c[(signed long int)1]] = (char)0;
      break;
    }
    case 1:
    {
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      card = col[(signed long int)(((signed int)col[(signed long int)0] - 1) + 1)];
      col[(signed long int)0] = col[(signed long int)0] - 1;
      col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
      state->key->freecells[(signed long int)move.c[(signed long int)2]] = card;
      break;
    }
    case 4:
    {
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      col[(signed long int)0] = col[(signed long int)0] - 1;
      col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
      state->key->foundations[(signed long int)move.c[(signed long int)2]] = state->key->foundations[(signed long int)move.c[(signed long int)2]] + 1;
      break;
    }
    case 5:
    {
      state->key->freecells[(signed long int)move.c[(signed long int)1]] = (char)0;
      state->key->foundations[(signed long int)move.c[(signed long int)2]] = state->key->foundations[(signed long int)move.c[(signed long int)2]] + 1;
      break;
    }
    case 11:
    {
      signed int i;
      col = state->key->stacks[(signed long int)move.c[(signed long int)1]];
      i = 0;
      for( ; !(i >= 13); i = i + 1)
      {
        col[(signed long int)0] = col[(signed long int)0] - 1;
        col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
        state->key->foundations[(signed long int)move.c[(signed long int)2]] = state->key->foundations[(signed long int)move.c[(signed long int)2]] + 1;
      }
      break;
    }
    case 12:
      if(!(locs == ((struct anonymous_7 *)NULL)))
        fc_solve_canonize_state_with_locs(state, locs, freecells_num, stacks_num);

      else
        fc_solve_canonize_state(state, freecells_num, stacks_num);
  }
}

// fc_solve_apply_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 58
extern signed int fc_solve_apply_preset_by_name(struct fc_solve_instance_struct *instance, const char *name)
{
  signed int ret;
  const struct anonymous_35 *preset_ptr;
  ret=fc_solve_get_preset_by_name(name, &preset_ptr);
  if(!(ret == 0))
    return ret;

  else
  {
    signed int return_value_fc_solve_apply_preset_by_ptr_1;
    return_value_fc_solve_apply_preset_by_ptr_1=fc_solve_apply_preset_by_ptr(instance, preset_ptr);
    return return_value_fc_solve_apply_preset_by_ptr_1;
  }
}

// fc_solve_apply_preset_by_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 53
extern signed int fc_solve_apply_preset_by_ptr(struct fc_solve_instance_struct *instance, const struct anonymous_35 *preset_ptr)
{
  char *no_use;
  if((signed int)preset_ptr->game_params.freecells_num >= 9)
    return 2;

  else
    if((signed int)preset_ptr->game_params.stacks_num >= 11)
      return 3;

    else
      if((signed int)preset_ptr->game_params.decks_num >= 3)
        return 4;

      else
      {
        instance->game_params = preset_ptr->game_params;
        char test_name[2l] = { (char)0, 0 };
        struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
        struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
        for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
        {
          struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
          struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
          for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
          {
            signed int num_valid_tests;
            const char *s;
            signed int depth_idx;
            struct anonymous_21 *by_depth_tests_order;
            signed int tests_order_num;
            signed int *tests_order_tests;
            by_depth_tests_order = soft_thread->by_depth_tests_order.by_depth_tests;
            depth_idx = 0;
            for( ; !(depth_idx >= soft_thread->by_depth_tests_order.num); depth_idx = depth_idx + 1)
            {
              signed int group_idx = 0;
              for( ; !(group_idx >= (by_depth_tests_order + (signed long int)depth_idx)->tests_order.num_groups); group_idx = group_idx + 1)
              {
                tests_order_tests = ((by_depth_tests_order + (signed long int)depth_idx)->tests_order.groups + (signed long int)group_idx)->tests;
                tests_order_num = ((by_depth_tests_order + (signed long int)depth_idx)->tests_order.groups + (signed long int)group_idx)->num;
                num_valid_tests = 0;
                for( ; !(num_valid_tests >= tests_order_num); num_valid_tests = num_valid_tests + 1)
                {
                  s = preset_ptr->allowed_tests;
                  for( ; !((signed int)*s == 0); s = s + 1l)
                  {
                    test_name[(signed long int)0] = *s;
                    signed int return_value_fc_solve_string_to_test_num_1;
                    return_value_fc_solve_string_to_test_num_1=fc_solve_string_to_test_num_link1(test_name);
                    if((16777215 & tests_order_tests[(signed long int)num_valid_tests]) == return_value_fc_solve_string_to_test_num_1 % 24)
                      break;

                  }
                  if((signed int)*s == 0)
                    break;

                }
                if(!(num_valid_tests >= tests_order_num))
                  fc_solve_apply_tests_order(&(by_depth_tests_order + (signed long int)depth_idx)->tests_order, preset_ptr->tests_order, &no_use);

              }
            }
          }
        }
        fc_solve_apply_tests_order(&instance->instance_tests_order, preset_ptr->tests_order, &no_use);
        return 0;
      }
}

// fc_solve_apply_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 74
extern signed int fc_solve_apply_tests_order(struct anonymous_9 *tests_order, const char *string, char **error_string)
{
  signed int i;
  signed int len;
  _Bool is_group;
  _Bool is_start_group;
  char test_name[2l] = { (char)0, 0 };
  fc_solve_free_tests_order_link2(tests_order);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_20) /*232ul*/  * (unsigned long int)16);
  tests_order->groups = (struct anonymous_20 *)return_value_malloc_1;
  (tests_order->groups + (signed long int)tests_order->num_groups)->num = 0;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)16);
  (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)return_value_malloc_2;
  (tests_order->groups + (signed long int)tests_order->num_groups)->shuffling_type = (enum anonymous_22)FCS_NO_SHUFFLING;
  tests_order->num_groups = tests_order->num_groups + 1;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(string);
  len = (signed int)return_value_strlen_3;
  is_group = (_Bool)0;
  is_start_group = (_Bool)0;
  i = 0;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_11;
  _Bool return_value_string_starts_with_7;
  signed int tmp_post_13;
  for( ; !(i >= len); i = i + 1)
  {
    if((signed int)string[(signed long int)i] == 40)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)string[(signed long int)i] == 91 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      if(!(is_group == (_Bool)0))
      {
        *error_string=strdup("There's a nested random group.");
        return 1;
      }

      is_group = (_Bool)1;
      is_start_group = (_Bool)1;
      if(!((tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num == 0))
      {
        if((16 & tests_order->num_groups) == 0)
        {
          void *return_value_realloc_4;
          return_value_realloc_4=realloc((void *)tests_order->groups, sizeof(struct anonymous_20) /*232ul*/  * (unsigned long int)16);
          tests_order->groups = (struct anonymous_20 *)return_value_realloc_4;
        }

        (tests_order->groups + (signed long int)tests_order->num_groups)->num = 0;
        void *return_value_malloc_5;
        return_value_malloc_5=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)16);
        (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)return_value_malloc_5;
        tests_order->num_groups = tests_order->num_groups + 1;
      }

      (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous_22)FCS_RAND;
    }

    else
    {
      if((signed int)string[(signed long int)i] == 41)
        tmp_if_expr_11 = (_Bool)1;

      else
        tmp_if_expr_11 = (signed int)string[(signed long int)i] == 93 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_11)
      {
        if(!(is_start_group == (_Bool)0))
        {
          *error_string=strdup("There's an empty group.");
          return 2;
        }

        if(is_group == (_Bool)0)
        {
          *error_string=strdup("There's a renegade right parenthesis or bracket.");
          return 3;
        }

        if((signed int)string[(signed long int)(1 + i)] == 61)
        {
          i = i + 2;
          const char *open_paren;
          open_paren=strchr(string + (signed long int)i, 40);
          if(open_paren == ((const char *)NULL))
          {
            *error_string=strdup("A = ordering function is missing its open parenthesis - (");
            return 5;
          }

          _Bool return_value_string_starts_with_8;
          return_value_string_starts_with_8=string_starts_with_link1(string + (signed long int)i, "rand", open_paren);
          if(!(return_value_string_starts_with_8 == (_Bool)0))
            (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous_22)FCS_RAND;

          else
          {
            return_value_string_starts_with_7=string_starts_with_link1(string + (signed long int)i, "asw", open_paren);
            if(!(return_value_string_starts_with_7 == (_Bool)0))
              (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous_22)FCS_WEIGHTING;

            else
            {
              *error_string=strdup("Unknown = ordering function");
              return 6;
            }
          }
          const char * const aft_open_paren = open_paren + (signed long int)1;
          const char *close_paren;
          close_paren=strchr(aft_open_paren, 41);
          if(close_paren == ((const char *)NULL))
          {
            *error_string=strdup("= ordering function not terminated with a ')'");
            return 7;
          }

          if((signed int)(tests_order->groups + (signed long int)(tests_order->num_groups + -1))->shuffling_type == FCS_WEIGHTING)
          {
            char *copy;
            copy=strndup(aft_open_paren, (unsigned long int)(close_paren - aft_open_paren));
            fc_solve_set_weights_link1(copy, (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->weighting.befs_weights);
            free((void *)copy);
          }

          else
            if(!(close_paren == aft_open_paren))
            {
              *error_string=strdup("=rand() arguments are not empty.");
              return 8;
            }

          i = (signed int)(close_paren - string);
        }

        is_group = (_Bool)0;
        is_start_group = (_Bool)0;
        if(!((tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num == 0))
        {
          if((16 & tests_order->num_groups) == 0)
          {
            void *return_value_realloc_9;
            return_value_realloc_9=realloc((void *)tests_order->groups, sizeof(struct anonymous_20) /*232ul*/  * (unsigned long int)(tests_order->num_groups + 16));
            tests_order->groups = (struct anonymous_20 *)return_value_realloc_9;
          }

          (tests_order->groups + (signed long int)tests_order->num_groups)->num = 0;
          void *return_value_malloc_10;
          return_value_malloc_10=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)16);
          (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)return_value_malloc_10;
          tests_order->num_groups = tests_order->num_groups + 1;
        }

        (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->shuffling_type = (enum anonymous_22)FCS_NO_SHUFFLING;
      }

      else
      {
        if((16 & (tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num) == 0)
        {
          void *return_value_realloc_12;
          return_value_realloc_12=realloc((void *)(tests_order->groups + (signed long int)(tests_order->num_groups - 1))->tests, sizeof(signed int) /*4ul*/  * (unsigned long int)16);
          (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->tests = (signed int *)return_value_realloc_12;
        }

        test_name[(signed long int)0] = string[(signed long int)i];
        tmp_post_13 = (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->num;
        (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->num = (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->num + 1;
        signed int return_value_fc_solve_string_to_test_num_14;
        return_value_fc_solve_string_to_test_num_14=fc_solve_string_to_test_num(test_name);
        (tests_order->groups + (signed long int)(tests_order->num_groups - 1))->tests[(signed long int)tmp_post_13] = return_value_fc_solve_string_to_test_num_14 % 24;
        is_start_group = (_Bool)0;
      }
    }
  }
  if(!(i == len))
  {
    *error_string=strdup("The Input string is too long.");
    return 4;
  }

  else
  {
    if((tests_order->groups + (signed long int)(tests_order->num_groups + -1))->num == 0)
    {
      tests_order->num_groups = tests_order->num_groups - 1;
      free((void *)(tests_order->groups + (signed long int)tests_order->num_groups)->tests);
      (tests_order->groups + (signed long int)tests_order->num_groups)->tests = (signed int *)(void *)0;
    }

    *error_string = (char *)(void *)0;
    return 0;
  }
}

// fc_solve_args_man_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 40
extern struct anonymous_36 * fc_solve_args_man_alloc(void)
{
  struct anonymous_36 *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_36) /*40ul*/  * (unsigned long int)1);
  ret = (struct anonymous_36 *)return_value_malloc_1;
  ret->argc = 0;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)32);
  ret->argv = (char **)return_value_malloc_2;
  return ret;
}

// fc_solve_args_man_chop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 42
extern signed int fc_solve_args_man_chop(struct anonymous_36 *manager, char *string)
{
  char *s = string;
  _Bool in_arg;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)1024);
  manager->last_arg = (char *)return_value_malloc_1;
  manager->last_arg_ptr = manager->last_arg;
  manager->last_arg_end = manager->last_arg + (signed long int)1023;
  _Bool return_value_is_whitespace_2;
  while(!((signed int)*s == 0))
  {
    _Bool push_next_arg_flag = (_Bool)0;
    in_arg = (_Bool)0;
    do
    {
      return_value_is_whitespace_2=is_whitespace(*s);
      if(return_value_is_whitespace_2 == (_Bool)0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    if((signed int)*s == 0)
      break;

    if((signed int)*s == 35)
    {
      in_arg = (_Bool)0;
      for( ; !((signed int)*s == 0); s = s + 1l)
        if((signed int)*s == 10)
          break;

    }

    else
    {
      _Bool still_loop = (_Bool)1;
      while(!(still_loop == (_Bool)0))
        switch((signed int)*s)
        {
          case 32:

          case 9:

          case 10:

          case 0:

          case 13:
          {
            push_next_arg_flag = (_Bool)1;
            still_loop = (_Bool)0;
            break;
          }
          case 92:
          {
            char next_char;
            s = s + 1l;
            next_char = *s;
            s = s + 1l;
            if((signed int)next_char == 0)
            {
              s = s - 1l;
              push_next_arg_flag = (_Bool)1;
              still_loop = (_Bool)0;
            }

            else
              if((signed int)next_char == 10 || (signed int)next_char == 13)
              {
                if(in_arg == (_Bool)0)
                  still_loop = (_Bool)0;

              }

              else
                add_to_last_arg(manager, next_char);
            break;
          }
          case 34:
          {
            s = s + 1l;
            in_arg = (_Bool)1;
            for( ; !((signed int)*s == 34); s = s + 1l)
            {
              if((signed int)*s == 0)
                break;

              if((signed int)*s == 92)
              {
                char fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char;
                s = s + 1l;
                fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char = *s;
                if((signed int)fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char == 0)
                {
                  push_args_last_arg(manager);
                  goto END_OF_LOOP;
                }

                else
                  if(!((signed int)fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char == 10) && !((signed int)fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char == 13))
                  {
                    if((signed int)fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char == 34 || (signed int)fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char == 92)
                      add_to_last_arg(manager, fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char);

                    else
                    {
                      add_to_last_arg(manager, (char)92);
                      add_to_last_arg(manager, fc_solve_args_man_chop__1__1__4__1__1__2__1__next_char);
                    }
                  }

              }

              else
                add_to_last_arg(manager, *s);
            }
            s = s + 1l;
            break;
          }
          case 35:
          {
            in_arg = (_Bool)0;
            for( ; !((signed int)*s == 0); s = s + 1l)
              if((signed int)*s == 10)
                break;

            push_next_arg_flag = (_Bool)1;
            still_loop = (_Bool)0;
            break;
          }
          default:
          {
            in_arg = (_Bool)1;
            add_to_last_arg(manager, *s);
            s = s + 1l;
          }
        }
      if(!(push_next_arg_flag == (_Bool)0))
      {
        push_args_last_arg(manager);
        in_arg = (_Bool)0;
        if((signed int)*s == 0)
          break;

      }

    }
  }

END_OF_LOOP:
  ;
  if(!(manager->last_arg_ptr == manager->last_arg))
    push_args_last_arg(manager);

  free((void *)manager->last_arg);
  manager->last_arg_end = (char *)(void *)0;
  manager->last_arg_ptr = manager->last_arg_end;
  manager->last_arg = manager->last_arg_ptr;
  return 0;
}

// fc_solve_args_man_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.h line 41
extern void fc_solve_args_man_free(struct anonymous_36 *manager)
{
  const signed int argc = manager->argc;
  char ** const argv = manager->argv;
  signed int i = 0;
  for( ; !(i >= argc); i = i + 1)
    free((void *)argv[(signed long int)i]);
  free((void *)argv);
  free((void *)manager);
}

// fc_solve_befs_or_bfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 925
extern signed int fc_solve_befs_or_bfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  struct fcs_state_keyval_pair_struct *ptr_new_state;
  struct anonymous_6 new_pass;
  struct fcs_state_keyval_pair_struct *ptr_state_raw;
  struct anonymous_6 pass;
  const unsigned char calc_real_depth = (const unsigned char)((signed int)instance->runtime_flags & 4);
  const unsigned char scans_synergy = (const unsigned char)((signed int)instance->runtime_flags & 64);
  const signed int soft_thread_id = soft_thread->id;
  const unsigned char is_a_complete_scan = (const unsigned char)((signed int)soft_thread->runtime_flags & 2);
  struct fcs_states_linked_list_item_struct *queue = (struct fcs_states_linked_list_item_struct *)(void *)0;
  struct fcs_states_linked_list_item_struct *queue_last_item = (struct fcs_states_linked_list_item_struct *)(void *)0;
  struct anonymous_31 *pqueue = (struct anonymous_31 *)(void *)0;
  signed int error_code;
  signed long int hard_thread_max_num_checked_states;
  struct anonymous_12 derived;
  derived.num_states = 0;
  derived.states = (struct anonymous_43 *)(void *)0;
  void (* const * const tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *) = soft_thread->method_specific.befs.tests_list;
  void (* const * const tests_list_end)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *) = soft_thread->method_specific.befs.tests_list_end;
  ptr_state_raw = soft_thread->first_state_to_check;
  if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    pass.key = &ptr_state_raw->_anon0._anon0.s;
    pass.val = &ptr_state_raw->_anon0._anon0.info;
  }

  const _Bool enable_pruning = soft_thread->enable_pruning;
  const signed int method = soft_thread->method;
  signed long int * const instance_num_checked_states_ptr = &instance->num_checked_states;
  signed long int * const hard_thread_num_checked_states_ptr = &hard_thread->num_checked_states;
  if(method == 3)
    pqueue = &soft_thread->method_specific.befs.meth.befs.pqueue;

  else
  {
    queue = soft_thread->method_specific.befs.meth.brfs.bfs_queue;
    queue_last_item = soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item;
  }
  const struct anonymous_14 game_params = instance->game_params;
  hard_thread_max_num_checked_states = hard_thread->max_num_checked_states;
  signed long int lim = hard_thread->num_checked_states + (instance->effective_max_num_checked_states - *instance_num_checked_states_ptr);
  hard_thread_max_num_checked_states = hard_thread_max_num_checked_states < lim ? hard_thread_max_num_checked_states : lim;
  void (* const debug_iter_output_func)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int) = instance->debug_iter_output_func;
  void * const debug_iter_output_context = instance->debug_iter_output_context;
  struct fcs_states_linked_list_item_struct *save_item;
  signed int tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  unsigned char num_vacant_freecells;
  unsigned char num_vacant_stacks;
  _Bool tmp_if_expr_4;
  signed long int tmp_if_expr_6;
  struct anonymous_43 *derived_iter;
  struct anonymous_43 *derived_end;
  while(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    if(!(enable_pruning == (_Bool)0))
    {
      if((16 & (signed int)ptr_state_raw->_anon0._anon0.info.visited) == 0)
      {
        struct fcs_state_keyval_pair_struct *after_pruning_state;
        signed int return_value_fc_solve_sfs_raymond_prune_1;
        return_value_fc_solve_sfs_raymond_prune_1=fc_solve_sfs_raymond_prune(soft_thread, &pass, &after_pruning_state);
        if(return_value_fc_solve_sfs_raymond_prune_1 == 1)
        {
          ptr_state_raw = after_pruning_state;
          if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
          {
            pass.key = &ptr_state_raw->_anon0._anon0.s;
            pass.val = &ptr_state_raw->_anon0._anon0.info;
          }

        }

      }

    }

    signed int temp_visited = (signed int)ptr_state_raw->_anon0._anon0.info.visited;
    if(method == 4)
      tmp_if_expr_3 = (signed int)(!((temp_visited & 1) != 0) || (temp_visited & 2) != 0);

    else
    {
      if(!((4 & temp_visited) == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = ((signed int)ptr_state_raw->_anon0._anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] & 1 << (soft_thread_id & (1 << 3) - 1)) != 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_3 = (signed int)tmp_if_expr_2;
    }
    if(tmp_if_expr_3 == 0)
    {
      num_vacant_freecells=count_num_vacant_freecells(game_params.freecells_num, &ptr_state_raw->_anon0._anon0.s);
      num_vacant_stacks=count_num_vacant_stacks(game_params.stacks_num, &ptr_state_raw->_anon0._anon0.s);
      if(*hard_thread_num_checked_states_ptr == hard_thread_max_num_checked_states)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        soft_thread->first_state_to_check = ptr_state_raw;
        error_code = 5;
        goto my_return_label;
      }

      if(!(debug_iter_output_func == ((void (*)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int))NULL)))
      {
        signed int return_value_calc_depth_5;
        return_value_calc_depth_5=calc_depth(ptr_state_raw);
        if(ptr_state_raw->_anon0._anon0.info.parent == ((struct fcs_state_keyval_pair_struct *)NULL))
          tmp_if_expr_6 = (signed long int)0;

        else
          tmp_if_expr_6 = ptr_state_raw->_anon0._anon0.info.parent->_anon0._anon0.info.visited_iter;
        debug_iter_output_func(debug_iter_output_context, *instance_num_checked_states_ptr, return_value_calc_depth_5, (void *)instance, &pass, tmp_if_expr_6);
      }

      if(num_vacant_freecells == game_params.freecells_num && num_vacant_stacks == game_params.stacks_num)
      {
        instance->final_state = ptr_state_raw;
        *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
        *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
        error_code = 0;
        goto my_return_label;
      }

      calculate_real_depth((const _Bool)calc_real_depth, ptr_state_raw);
      soft_thread->num_vacant_freecells = num_vacant_freecells;
      soft_thread->num_vacant_stacks = num_vacant_stacks;
      if(!(soft_thread->method_specific.befs.befs_positions_by_rank == ((char *)NULL)))
      {
        free((void *)soft_thread->method_specific.befs.befs_positions_by_rank);
        soft_thread->method_specific.befs.befs_positions_by_rank = (char *)(void *)0;
      }

      derived.num_states = 0;
      void (* const *next_test)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *) = tests_list;
      if(!(next_test >= tests_list_end))
      {
        (*next_test)(soft_thread, &pass, &derived);
        next_test = next_test + 1l;
      }

      if(!(is_a_complete_scan == 0))
        ptr_state_raw->_anon0._anon0.info.visited = ptr_state_raw->_anon0._anon0.info.visited | (unsigned char)8;

      *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
      *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
      derived_iter = derived.states;
      derived_end = derived_iter + (signed long int)derived.num_states;
      for( ; !(derived_iter >= derived_end); derived_iter = derived_iter + 1l)
      {
        ptr_new_state = derived_iter->state_ptr;
        new_pass.key = &ptr_new_state->_anon0._anon0.s;
        new_pass.val = &ptr_new_state->_anon0._anon0.info;
        if(method == 3)
        {
          signed int return_value_kv_calc_depth_7;
          return_value_kv_calc_depth_7=kv_calc_depth(&new_pass);
          signed int return_value_befs_rate_state_8;
          return_value_befs_rate_state_8=befs_rate_state(soft_thread, &soft_thread->method_specific.befs.meth.befs.weighting, new_pass.key, 20000 - return_value_kv_calc_depth_7);
          fc_solve_PQueuePush(pqueue, ptr_new_state, return_value_befs_rate_state_8);
        }

        else
        {
          struct fcs_states_linked_list_item_struct *last_item_next;
          if(!(soft_thread->method_specific.befs.meth.brfs.recycle_bin == ((struct fcs_states_linked_list_item_struct *)NULL)))
          {
            last_item_next = soft_thread->method_specific.befs.meth.brfs.recycle_bin;
            soft_thread->method_specific.befs.meth.brfs.recycle_bin = soft_thread->method_specific.befs.meth.brfs.recycle_bin->next;
          }

          else
          {
            void *return_value_fcs_compact_alloc_ptr_9;
            return_value_fcs_compact_alloc_ptr_9=fcs_compact_alloc_ptr_link2(&hard_thread->allocator, (signed int)sizeof(struct fcs_states_linked_list_item_struct) /*16ul*/ );
            last_item_next = (struct fcs_states_linked_list_item_struct *)return_value_fcs_compact_alloc_ptr_9;
          }
          queue_last_item->next = last_item_next;
          queue_last_item->s = ptr_new_state;
          last_item_next->next = (struct fcs_states_linked_list_item_struct *)(void *)0;
          queue_last_item = last_item_next;
        }
      }
      if(method == 4)
        ptr_state_raw->_anon0._anon0.info.visited = ptr_state_raw->_anon0._anon0.info.visited | (unsigned char)2;

      else
      {
        ptr_state_raw->_anon0._anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] = ptr_state_raw->_anon0._anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] | (unsigned char)(1 << (soft_thread_id & (1 << 3) - 1));
        if(derived.num_states == 0)
        {
          if(!(is_a_complete_scan == 0))
            mark_as_dead_end((const _Bool)scans_synergy, ptr_state_raw);

        }

      }
      ptr_state_raw->_anon0._anon0.info.visited_iter = *instance_num_checked_states_ptr - (signed long int)1;
    }


  label_next_state:
    ;
    if(method == 3)
    {
      struct fcs_state_keyval_pair_struct *new_ptr_state;
      fc_solve_PQueuePop(pqueue, &new_ptr_state);
      ptr_state_raw = new_ptr_state;
      if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
      {
        pass.key = &ptr_state_raw->_anon0._anon0.s;
        pass.val = &ptr_state_raw->_anon0._anon0.info;
      }

    }

    else
    {
      save_item = queue->next;
      if(!(save_item == queue_last_item))
      {
        ptr_state_raw = save_item->s;
        if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
        {
          pass.key = &ptr_state_raw->_anon0._anon0.s;
          pass.val = &ptr_state_raw->_anon0._anon0.info;
        }

        queue->next = save_item->next;
        save_item->next = soft_thread->method_specific.befs.meth.brfs.recycle_bin;
        soft_thread->method_specific.befs.meth.brfs.recycle_bin = save_item;
      }

      else
      {
        ptr_state_raw = (struct fcs_state_keyval_pair_struct *)(void *)0;
        if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
        {
          pass.key = &ptr_state_raw->_anon0._anon0.s;
          pass.val = &ptr_state_raw->_anon0._anon0.info;
        }

      }
    }
  }
  error_code = 1;

my_return_label:
  ;
  if(!(derived.states == ((struct anonymous_43 *)NULL)))
    free((void *)derived.states);

  if(!(method == 3))
    soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item = queue_last_item;

  if(!(soft_thread->method_specific.befs.befs_positions_by_rank == ((char *)NULL)))
  {
    free((void *)soft_thread->method_specific.befs.befs_positions_by_rank);
    soft_thread->method_specific.befs.befs_positions_by_rank = (char *)(void *)0;
  }

  return error_code;
}

// fc_solve_cache_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 82
static inline void fc_solve_cache_stacks(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous_6 * const new_state)
{
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const struct anonymous_14 game_params = instance->game_params;
  struct fcs_struct_state_t * const new_state_key = new_state->key;
  struct fcs_state_extra_info_struct * const new_state_info = new_state->val;
  struct anonymous_5 * const stacks_allocator = &hard_thread->allocator;
  char **current_stack = new_state_key->stacks;
  signed int i = 0;
  for( ; !(i >= (signed int)game_params.stacks_num); current_stack = current_stack + 1l)
  {
    if(!((new_state_info->stacks_copy_on_write_flags & 1 << i) == 0))
    {
      char *column = new_state_key->stacks[(signed long int)i];
      const signed int col_len = (signed int)column[(signed long int)0] + 1;
      char *new_ptr;
      void *return_value_fcs_compact_alloc_ptr_1;
      return_value_fcs_compact_alloc_ptr_1=fcs_compact_alloc_ptr(stacks_allocator, col_len);
      new_ptr = (char *)return_value_fcs_compact_alloc_ptr_1;
      memcpy((void *)new_ptr, (const void *)column, (unsigned long int)col_len);
      *current_stack = new_ptr;
      void *cached_stack;
      column = new_state_key->stacks[(signed long int)i];
      unsigned long int return_value_perl_hash_function_2;
      return_value_perl_hash_function_2=perl_hash_function((unsigned char *)*current_stack, (const unsigned long int)col_len);
      _Bool return_value_fc_solve_hash_insert_3;
      return_value_fc_solve_hash_insert_3=fc_solve_hash_insert(&instance->stacks_hash, (void *)column, &cached_stack, (const signed int)return_value_perl_hash_function_2);
      if(!(return_value_fc_solve_hash_insert_3 == (_Bool)0))
      {
        stacks_allocator->ptr = stacks_allocator->rollback_ptr;
        *current_stack = (char *)cached_stack;
      }

    }

    i = i + 1;
  }
}

// fc_solve_calc_positions_by_rank_location
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 2033
static inline char ** fc_solve_calc_positions_by_rank_location(struct fc_solve_soft_thread_struct *soft_thread)
{
  if(soft_thread->method == 1 || soft_thread->method == 5)
    return &(soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)soft_thread->method_specific.soft_dfs.depth)->positions_by_rank;

  return &soft_thread->method_specific.befs.befs_positions_by_rank;
}

// fc_solve_canonize_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 634
extern void fc_solve_canonize_state(struct anonymous_6 *state_raw, signed int freecells_num, signed int stacks_num)
{
  signed int b;
  signed int c;
  char *temp_stack;
  char temp_freecell;
  b = 1;
  signed int return_value_fc_solve_stack_compare_for_comparison_1;
  for( ; !(b >= stacks_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_stack_compare_for_comparison_1=fc_solve_stack_compare_for_comparison((const void *)state_raw->key->stacks[(signed long int)c], (const void *)state_raw->key->stacks[(signed long int)(c - 1)]);
      if(return_value_fc_solve_stack_compare_for_comparison_1 >= 0)
        break;

      temp_stack = state_raw->key->stacks[(signed long int)c];
      state_raw->key->stacks[(signed long int)c] = state_raw->key->stacks[(signed long int)(c - 1)];
      state_raw->key->stacks[(signed long int)(c - 1)] = temp_stack;
    }
  }
  b = 1;
  signed int return_value_fc_solve_card_compare_2;
  for( ; !(b >= freecells_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_card_compare_2=fc_solve_card_compare(state_raw->key->freecells[(signed long int)c], state_raw->key->freecells[(signed long int)(c - 1)]);
      if(return_value_fc_solve_card_compare_2 >= 0)
        break;

      temp_freecell = state_raw->key->freecells[(signed long int)c];
      state_raw->key->freecells[(signed long int)c] = state_raw->key->freecells[(signed long int)(c - 1)];
      state_raw->key->freecells[(signed long int)(c - 1)] = temp_freecell;
    }
  }
}

// fc_solve_canonize_state_with_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 640
void fc_solve_canonize_state_with_locs(struct anonymous_6 *state, struct anonymous_7 *locs, signed int freecells_num, signed int stacks_num)
{
  signed int b;
  signed int c;
  char *temp_stack;
  char temp_freecell;
  char temp_loc;
  b = 1;
  signed int return_value_fc_solve_stack_compare_for_comparison_1;
  for( ; !(b >= stacks_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_stack_compare_for_comparison_1=fc_solve_stack_compare_for_comparison((const void *)state->key->stacks[(signed long int)c], (const void *)state->key->stacks[(signed long int)(c - 1)]);
      if(return_value_fc_solve_stack_compare_for_comparison_1 >= 0)
        break;

      temp_stack = state->key->stacks[(signed long int)c];
      state->key->stacks[(signed long int)c] = state->key->stacks[(signed long int)(c - 1)];
      state->key->stacks[(signed long int)(c - 1)] = temp_stack;
      temp_loc = locs->stack_locs[(signed long int)c];
      locs->stack_locs[(signed long int)c] = locs->stack_locs[(signed long int)(c - 1)];
      locs->stack_locs[(signed long int)(c - 1)] = temp_loc;
    }
  }
  b = 1;
  signed int return_value_fc_solve_card_compare_2;
  for( ; !(b >= freecells_num); b = b + 1)
  {
    c = b;
    for( ; c >= 1; c = c - 1)
    {
      return_value_fc_solve_card_compare_2=fc_solve_card_compare(state->key->freecells[(signed long int)c], state->key->freecells[(signed long int)(c - 1)]);
      if(return_value_fc_solve_card_compare_2 >= 0)
        break;

      temp_freecell = state->key->freecells[(signed long int)c];
      state->key->freecells[(signed long int)c] = state->key->freecells[(signed long int)(c - 1)];
      state->key->freecells[(signed long int)(c - 1)] = temp_freecell;
      temp_loc = locs->fc_locs[(signed long int)c];
      locs->fc_locs[(signed long int)c] = locs->fc_locs[(signed long int)(c - 1)];
      locs->fc_locs[(signed long int)(c - 1)] = temp_loc;
    }
  }
}

// fc_solve_card_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare(const char c1, const char c2)
{
  return (signed int)c1 - (signed int)c2;
}

// fc_solve_card_compare_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1143
static inline signed int fc_solve_card_compare_link1(const char c1_link1, const char c2_link1)
{
  return (signed int)c1_link1 - (signed int)c2_link1;
}

// fc_solve_card_perl2user
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 266
extern char * fc_solve_card_perl2user(char card, char *str, _Bool t)
{
  _Bool rank_is_null;
  fc_solve_p2u_rank((signed int)card >> 2, str, &rank_is_null, t);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  fc_solve_p2u_suit((signed int)card & 0x03, str + (signed long int)return_value_strlen_1, rank_is_null);
  return str;
}

// fc_solve_card_user2perl
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 140
extern char fc_solve_card_user2perl(const char *str)
{
  signed int rank;
  rank=fc_solve_u2p_rank(str);
  signed int suit;
  suit=fc_solve_u2p_suit(str);
  char return_value_fcs_make_card_1;
  return_value_fcs_make_card_1=fcs_make_card(rank, suit);
  return return_value_fcs_make_card_1;
}

// fc_solve_check_and_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 316
_Bool fc_solve_check_and_add_state(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous_6 * const new_state, struct anonymous_6 * const existing_state_raw)
{
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  fc_solve_cache_stacks(hard_thread, new_state);
  fc_solve_canonize_state(new_state, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num);
  void *existing_void;
  unsigned long int return_value_perl_hash_function_1;
  return_value_perl_hash_function_1=perl_hash_function((unsigned char *)new_state->key, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  _Bool return_value_fc_solve_hash_insert_2;
  return_value_fc_solve_hash_insert_2=fc_solve_hash_insert(&instance->hash, (void *)(struct fcs_state_keyval_pair_struct *)new_state->key, &existing_void, (const signed int)return_value_perl_hash_function_1);
  if(!(return_value_fc_solve_hash_insert_2 == (_Bool)0))
  {
    FCS_STATE_keyval_pair_to_kv(existing_state_raw, (struct fcs_state_keyval_pair_struct *)existing_void);
    return (_Bool)0;
  }

  else
  {
    on_state_new(instance, hard_thread, new_state->val);
    return (_Bool)1;
  }
}

// fc_solve_check_state_validity
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1036
static inline signed int fc_solve_check_state_validity(struct fcs_state_keyval_pair_struct *state_pair, signed int freecells_num, signed int stacks_num, signed int decks_num, char *misplaced_card)
{
  signed int cards[4l][14l];
  signed int c;
  signed int s;
  signed int d;
  signed int f;
  signed int col_len;
  struct fcs_struct_state_t *state;
  char *col;
  char card;
  state = &state_pair->_anon0._anon0.s;
  d = 0;
  for( ; !(d >= 4); d = d + 1)
  {
    c = 1;
    for( ; !(c >= 14); c = c + 1)
      cards[(signed long int)d][(signed long int)c] = 0;
  }
  d = 0;
  for( ; !(d >= 4 * decks_num); d = d + 1)
  {
    c = 1;
    for( ; (signed int)state->foundations[(signed long int)d] >= c; c = c + 1)
      cards[(signed long int)(d % 4)][(signed long int)c] = cards[(signed long int)(d % 4)][(signed long int)c] + 1;
  }
  f = 0;
  for( ; !(f >= freecells_num); f = f + 1)
  {
    card = state->freecells[(signed long int)f];
    if(!((signed int)card >> 2 == 0))
      cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] = cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] + 1;

  }
  s = 0;
  for( ; !(s >= stacks_num); s = s + 1)
  {
    col = state->stacks[(signed long int)s];
    col_len = (signed int)col[(signed long int)0];
    c = 0;
    for( ; !(c >= col_len); c = c + 1)
    {
      card = col[(signed long int)(c + 1)];
      if((signed int)card >> 2 == 0)
      {
        *misplaced_card = (char)0;
        return 3;
      }

      cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] = cards[(signed long int)((signed int)card & 0x03)][(signed long int)((signed int)card >> 2)] + 1;
    }
  }
  signed int suit_idx = 0;
  for( ; !(suit_idx >= 4); suit_idx = suit_idx + 1)
  {
    signed int rank = 1;
    for( ; !(rank >= 14); rank = rank + 1)
      if(!(cards[(signed long int)suit_idx][(signed long int)rank] == decks_num))
      {
        *misplaced_card=fcs_make_card_link1(rank, suit_idx);
        return cards[(signed long int)suit_idx][(signed long int)rank] < decks_num ? 1 : 2;
      }

  }
  return 0;
}

// fc_solve_compact_allocator_extend
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 57
extern void fc_solve_compact_allocator_extend(struct anonymous_5 *allocator)
{
  char *new_data;
  new_data=meta_request_new_buffer(allocator->meta);
  *((char **)new_data) = allocator->old_list;
  allocator->old_list = new_data;
  allocator->rollback_ptr = (char *)&((char **)new_data)[(signed long int)1];
  allocator->ptr = allocator->rollback_ptr;
  allocator->max_ptr = new_data + (signed long int)(64 * 1024 - (256 + 128));
}

// fc_solve_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 113
extern void fc_solve_compact_allocator_finish(struct anonymous_5 *allocator)
{
  char *iter;
  char *iter_next;
  struct anonymous_10 *meta = allocator->meta;
  iter = allocator->old_list;
  iter_next = *((char **)iter);
  for( ; !(iter_next == ((char *)NULL)); iter_next = *((char **)iter))
  {
    *((char **)iter) = meta->recycle_bin;
    meta->recycle_bin = iter;
    iter = iter_next;
  }
  *((char **)iter) = meta->recycle_bin;
  meta->recycle_bin = iter;
}

// fc_solve_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 81
extern void fc_solve_compact_allocator_init(struct anonymous_5 *allocator, struct anonymous_10 *meta_allocator)
{
  allocator->meta = meta_allocator;
  fc_solve_compact_allocator_init_helper_link1(allocator);
}

// fc_solve_compact_allocator_init_helper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper(struct anonymous_5 *allocator)
{
  allocator->old_list = (char *)(void *)0;
  fc_solve_compact_allocator_extend(allocator);
}

// fc_solve_compact_allocator_init_helper_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 62
static inline void fc_solve_compact_allocator_init_helper_link1(struct anonymous_5 *allocator_link1)
{
  allocator_link1->old_list = (char *)(void *)0;
  fc_solve_compact_allocator_extend(allocator_link1);
}

// fc_solve_compact_allocator_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 130
static inline void fc_solve_compact_allocator_recycle(struct anonymous_5 *allocator)
{
  fc_solve_compact_allocator_finish(allocator);
  fc_solve_compact_allocator_init_helper(allocator);
}

// fc_solve_derived_states_list_add_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.c line 340
extern void fc_solve_derived_states_list_add_state(struct anonymous_12 *list, struct fcs_state_keyval_pair_struct *state, signed int context)
{
  if((list->num_states + (signed int)!(list->states == ((struct anonymous_43 *)NULL)) & 16) == 0)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)list->states, sizeof(struct anonymous_43) /*16ul*/  * (unsigned long int)(list->num_states + (signed int)(list->states != (struct anonymous_43 *)(void *)0) + 16));
    list->states = (struct anonymous_43 *)return_value_realloc_1;
  }

  (list->states + (signed long int)list->num_states)->state_ptr = state;
  signed int tmp_post_2 = list->num_states;
  list->num_states = list->num_states + 1;
  (list->states + (signed long int)tmp_post_2)->context.i = context;
}

// fc_solve_finish_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1028
extern void fc_solve_finish_instance(struct fc_solve_instance_struct * const instance)
{
  fc_solve_hash_free(&instance->hash);
  fc_solve_hash_free(&instance->stacks_hash);
  instance->num_states_in_collection = (signed long int)0;
  clean_soft_dfs(instance);
}

// fc_solve_foreach_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 240
extern void fc_solve_foreach_soft_thread(struct fc_solve_instance_struct * const instance, const signed int callback_choice, void * const context)
{
  signed int ht_idx = 0;
  for( ; instance->num_hard_threads >= ht_idx; ht_idx = ht_idx + 1)
  {
    struct fc_solve_hard_thread_struct *hard_thread;
    if(!(ht_idx >= instance->num_hard_threads))
      hard_thread = &instance->hard_threads[(signed long int)ht_idx];

    else
      if(!(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL)))
        hard_thread = instance->optimization_thread;

      else
        break;
    struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
    struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
    for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
      switch(callback_choice)
      {
        case 0:
        {
          soft_thread_clean_soft_dfs(soft_thread);
          break;
        }
        case 1:
        {
          free_instance_soft_thread_callback(soft_thread);
          break;
        }
        case 2:
        {
          accumulate_tests_order(soft_thread, context);
          break;
        }
        case 3:
          determine_scan_completeness(soft_thread, context);
      }
  }
}

// fc_solve_free_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1830
static inline void fc_solve_free_instance(struct fc_solve_instance_struct *instance)
{
  fc_solve_foreach_soft_thread(instance, 1, (void *)0);
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
    free_instance_hard_thread_callback(hard_thread);
  free((void *)instance->hard_threads);
  if(!(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL)))
  {
    free_instance_hard_thread_callback(instance->optimization_thread);
    free((void *)instance->optimization_thread);
  }

  fc_solve_free_tests_order_link1(&instance->instance_tests_order);
  if(!((8 & (signed int)instance->runtime_flags) == 0))
    fc_solve_free_tests_order_link1(&instance->opt_tests_order);

  free((void *)instance);
}

// fc_solve_free_soft_thread_by_depth_test_array
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 160
extern void fc_solve_free_soft_thread_by_depth_test_array(struct fc_solve_soft_thread_struct * const soft_thread)
{
  signed int depth_idx = 0;
  for( ; !(depth_idx >= soft_thread->by_depth_tests_order.num); depth_idx = depth_idx + 1)
    fc_solve_free_tests_order(&(soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order);
  soft_thread->by_depth_tests_order.num = 0;
  free((void *)soft_thread->by_depth_tests_order.by_depth_tests);
  soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous_21 *)(void *)0;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_free_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order(struct anonymous_9 *tests_order)
{
  signed int group_idx = 0;
  for( ; !(group_idx >= tests_order->num_groups); group_idx = group_idx + 1)
    free((void *)(tests_order->groups + (signed long int)group_idx)->tests);
  free((void *)tests_order->groups);
  tests_order->groups = (struct anonymous_20 *)(void *)0;
  tests_order->num_groups = 0;
}

// fc_solve_free_tests_order_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order_link1(struct anonymous_9 *tests_order_link1)
{
  signed int group_idx_link1 = 0;
  for( ; !(group_idx_link1 >= tests_order_link1->num_groups); group_idx_link1 = group_idx_link1 + 1)
    free((void *)(tests_order_link1->groups + (signed long int)group_idx_link1)->tests);
  free((void *)tests_order_link1->groups);
  tests_order_link1->groups = (struct anonymous_20 *)(void *)0;
  tests_order_link1->num_groups = 0;
}

// fc_solve_free_tests_order_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1819
static inline void fc_solve_free_tests_order_link2(struct anonymous_9 *tests_order_link2)
{
  signed int group_idx_link2 = 0;
  for( ; !(group_idx_link2 >= tests_order_link2->num_groups); group_idx_link2 = group_idx_link2 + 1)
    free((void *)(tests_order_link2->groups + (signed long int)group_idx_link2)->tests);
  free((void *)tests_order_link2->groups);
  tests_order_link2->groups = (struct anonymous_20 *)(void *)0;
  tests_order_link2->num_groups = 0;
}

// fc_solve_get_preset_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.h line 63
extern signed int fc_solve_get_preset_by_name(const char *name, const struct anonymous_35 **preset_ptr)
{
  signed int preset_id;
  preset_id=fcs_get_preset_id_by_name(name);
  if(preset_id >= 0)
  {
    signed int return_value_fcs_get_preset_by_id_1;
    return_value_fcs_get_preset_by_id_1=fcs_get_preset_by_id(preset_id, preset_ptr);
    return return_value_fcs_get_preset_by_id_1;
  }

  else
    return 1;
}

// fc_solve_get_the_positions_by_rank_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 54
extern char * fc_solve_get_the_positions_by_rank_data(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key, char * (*generator)(struct fc_solve_soft_thread_struct *, const struct fcs_struct_state_t *))
{
  char **positions_by_rank_location;
  positions_by_rank_location=fc_solve_calc_positions_by_rank_location(soft_thread);
  if(*positions_by_rank_location == ((char *)NULL))
    *positions_by_rank_location=generator(soft_thread, ptr_state_key);

  return *positions_by_rank_location;
}

// fc_solve_get_the_positions_by_rank_data__freecell_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 49
extern char * fc_solve_get_the_positions_by_rank_data__freecell_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const ptr_state_key)
{
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const struct anonymous_14 game_params = instance->game_params;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  char *positions_by_rank;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(13 * (2 << 3)));
  positions_by_rank = (char *)return_value_malloc_1;
  memset((void *)positions_by_rank, -1, sizeof(char) /*1ul*/  * (unsigned long int)(13 * (2 << 3)));
  signed int ds = 0;
  signed int tmp_post_2;
  for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
  {
    const char * const dest_col = ptr_state_key->stacks[(signed long int)ds];
    signed int top_card_idx = (signed int)dest_col[(signed long int)0];
    tmp_post_2 = top_card_idx;
    top_card_idx = top_card_idx - 1;
    if(!(tmp_post_2 == 0))
    {
      char dest_card;
      char dest_below_card;
      dest_card = dest_col[(signed long int)(0 + 1)];
      signed int dc = 0;
      for( ; !(dc >= top_card_idx); dest_card = dest_below_card)
      {
        dest_below_card = dest_col[(signed long int)(dc + 1 + 1)];
        if(!(((signed int)dest_below_card >> 2) + 1 == (signed int)dest_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)dest_below_card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)dest_below_card) == (1 & (signed int)dest_card))))
          assign_dest_stack_and_col_ptr(positions_by_rank, ds, dc, dest_card);

        dc = dc + 1;
      }
      assign_dest_stack_and_col_ptr(positions_by_rank, ds, top_card_idx, dest_card);
    }

  }
  return positions_by_rank;
}

// fc_solve_hash_foreach
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 195
static inline void fc_solve_hash_foreach(struct anonymous_38 * const hash, _Bool (*should_delete_ptr)(void *, void *), void * const context)
{
  const signed int size = hash->size;
  signed int i = 0;
  for( ; !(i >= size); i = i + 1)
  {
    struct fc_solve_hash_symlink_item_struct **item = &(hash->entries + (signed long int)i)->first_item;
    if(!(*item == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
    {
      _Bool return_value;
      return_value=should_delete_ptr((*item)->key, context);
      if(!(return_value == (_Bool)0))
      {
        struct fc_solve_hash_symlink_item_struct *next_item = (*item)->next;
        (*item)->next = hash->list_of_vacant_items;
        hash->list_of_vacant_items = *item;
        *item = next_item;
        hash->num_elems = hash->num_elems - 1l;
      }

      else
        item = &(*item)->next;
    }

  }
}

// fc_solve_hash_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 185
static inline void fc_solve_hash_free(struct anonymous_38 * const hash)
{
  fc_solve_compact_allocator_finish(&hash->allocator);
  free((void *)hash->entries);
  hash->entries = (struct anonymous_53 *)(void *)0;
}

// fc_solve_hash_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 118
static inline void fc_solve_hash_init(struct anonymous_10 * const meta_alloc, struct anonymous_38 * const hash, const enum FCS_INLINED_HASH_DATA_TYPE hash_type)
{
  hash->size = 2048;
  hash->size_bitmask = 2048 - 1;
  hash->max_num_elems_before_resize = (signed long int)(2048 << 1);
  hash->num_elems = (signed long int)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)2048, sizeof(struct anonymous_53) /*8ul*/ );
  hash->entries = (struct anonymous_53 *)return_value_calloc_1;
  hash->list_of_vacant_items = (struct fc_solve_hash_symlink_item_struct *)(void *)0;
  hash->hash_type = hash_type;
  fc_solve_compact_allocator_init(&hash->allocator, meta_alloc);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// fc_solve_hash_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.h line 170
extern _Bool fc_solve_hash_insert(struct anonymous_38 * const hash, void * const key, void ** const existing_key, const signed int hash_value)
{
  const enum FCS_INLINED_HASH_DATA_TYPE hash_type = hash->hash_type;
  struct anonymous_53 * const list = hash->entries + (signed long int)(hash_value & hash->size_bitmask);
  struct fc_solve_hash_symlink_item_struct **item_placeholder;
  signed int tmp_if_expr_3;
  signed int return_value_fc_solve_stack_compare_for_comparison_1;
  signed int return_value_fc_solve_state_compare_2;
  if(list->first_item == ((struct fc_solve_hash_symlink_item_struct *)NULL))
    item_placeholder = &list->first_item;

  else
  {
    struct fc_solve_hash_symlink_item_struct *fc_solve_hash_insert__1__2__item = list->first_item;
    struct fc_solve_hash_symlink_item_struct *last_item = (struct fc_solve_hash_symlink_item_struct *)(void *)0;
    while(!(fc_solve_hash_insert__1__2__item == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
    {
      if(fc_solve_hash_insert__1__2__item->hash_value == hash_value)
      {
        if((signed int)hash_type == FCS_INLINED_HASH__COLUMNS)
        {
          return_value_fc_solve_stack_compare_for_comparison_1=fc_solve_stack_compare_for_comparison_link1(fc_solve_hash_insert__1__2__item->key, key);
          tmp_if_expr_3 = return_value_fc_solve_stack_compare_for_comparison_1;
        }

        else
        {
          return_value_fc_solve_state_compare_2=fc_solve_state_compare(fc_solve_hash_insert__1__2__item->key, key);
          tmp_if_expr_3 = return_value_fc_solve_state_compare_2;
        }
        if(tmp_if_expr_3 == 0)
        {
          *existing_key = fc_solve_hash_insert__1__2__item->key;
          return (_Bool)1;
        }

      }

      last_item = fc_solve_hash_insert__1__2__item;
      fc_solve_hash_insert__1__2__item = fc_solve_hash_insert__1__2__item->next;
    }
    item_placeholder = &last_item->next;
  }
  struct fc_solve_hash_symlink_item_struct *item;
  if(!(hash->list_of_vacant_items == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
  {
    item = hash->list_of_vacant_items;
    hash->list_of_vacant_items = item->next;
  }

  else
  {
    void *return_value_fcs_compact_alloc_ptr_4;
    return_value_fcs_compact_alloc_ptr_4=fcs_compact_alloc_ptr_link3(&hash->allocator, (signed int)sizeof(struct fc_solve_hash_symlink_item_struct) /*24ul*/ );
    item = (struct fc_solve_hash_symlink_item_struct *)return_value_fcs_compact_alloc_ptr_4;
  }
  *item_placeholder = item;
  item->key = key;
  item->hash_value = hash_value;
  item->next = (struct fc_solve_hash_symlink_item_struct *)(void *)0;
  hash->num_elems = hash->num_elems + 1l;
  if(!(hash->max_num_elems_before_resize >= hash->num_elems))
    fc_solve_hash_rehash(hash);

  *existing_key = (void *)0;
  return (_Bool)0;
}

// fc_solve_hash_rehash
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_hash.c line 192
static inline void fc_solve_hash_rehash(struct anonymous_38 * const hash)
{
  const signed int old_size = hash->size;
  const signed int new_size = old_size << 1;
  if(!(new_size >= old_size))
    hash->max_num_elems_before_resize = 9223372036854775807L;

  else
  {
    const signed int new_size_bitmask = new_size - 1;
    struct anonymous_53 *new_entries;
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)new_size, sizeof(struct anonymous_53) /*8ul*/ );
    new_entries = (struct anonymous_53 *)return_value_calloc_1;
    signed int i = 0;
    for( ; !(i >= old_size); i = i + 1)
    {
      struct fc_solve_hash_symlink_item_struct *item = (hash->entries + (signed long int)i)->first_item;
      while(!(item == ((struct fc_solve_hash_symlink_item_struct *)NULL)))
      {
        const signed int place = item->hash_value & new_size_bitmask;
        struct fc_solve_hash_symlink_item_struct * const next_item = item->next;
        item->next = (new_entries + (signed long int)place)->first_item;
        (new_entries + (signed long int)place)->first_item = item;
        item = next_item;
      }
    }
    free((void *)hash->entries);
    hash->entries = new_entries;
    hash->size = new_size;
    hash->size_bitmask = new_size_bitmask;
    hash->max_num_elems_before_resize = (signed long int)(new_size << 1);
  }
}

// fc_solve_increase_dfs_max_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 929
extern void fc_solve_increase_dfs_max_depth(struct fc_solve_soft_thread_struct *soft_thread)
{
  const signed int new_dfs_max_depth = soft_thread->method_specific.soft_dfs.dfs_max_depth + 16;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)soft_thread->method_specific.soft_dfs.soft_dfs_info, sizeof(struct anonymous_50) /*64ul*/  * (unsigned long int)new_dfs_max_depth);
  soft_thread->method_specific.soft_dfs.soft_dfs_info = (struct anonymous_50 *)return_value_realloc_1;
  struct anonymous_50 *soft_dfs_info = soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)soft_thread->method_specific.soft_dfs.dfs_max_depth;
  struct anonymous_50 * const end_soft_dfs_info = soft_dfs_info + (signed long int)16;
  for( ; !(soft_dfs_info >= end_soft_dfs_info); soft_dfs_info = soft_dfs_info + 1l)
  {
    soft_dfs_info->state = (struct fcs_state_keyval_pair_struct *)(void *)0;
    soft_dfs_info->tests_list_index = 0;
    soft_dfs_info->test_index = 0;
    soft_dfs_info->current_state_index = 0;
    soft_dfs_info->derived_states_list.num_states = 0;
    soft_dfs_info->derived_states_list.states = (struct anonymous_43 *)(void *)0;
    soft_dfs_info->derived_states_random_indexes = (struct anonymous_25 *)(void *)0;
    soft_dfs_info->derived_states_random_indexes_max_size = 0;
    soft_dfs_info->positions_by_rank = (char *)(void *)0;
  }
  soft_thread->method_specific.soft_dfs.dfs_max_depth = new_dfs_max_depth;
}

// fc_solve_init_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 557
extern void fc_solve_init_instance(struct fc_solve_instance_struct *instance)
{
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
  {
    if(!(hard_thread->prelude_as_string == ((char *)NULL)))
    {
      if(hard_thread->prelude == ((struct anonymous_39 *)NULL))
        compile_prelude(hard_thread);

    }

    hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->soft_threads + (signed long int)0)->num_checked_states_step;
  }
  signed int total_tests = 0;
  fc_solve_foreach_soft_thread(instance, 2, (void *)&total_tests);
  fc_solve_foreach_soft_thread(instance, 3, (void *)&total_tests);
  signed int tmp_post_2;
  if((8 & (signed int)instance->runtime_flags) == 0)
  {
    signed int num_tests = 0;
    signed int *tests;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(signed int) /*4ul*/  * sizeof(signed int) /*4ul*/  * (unsigned long int)8);
    tests = (signed int *)return_value_malloc_1;
    signed int bit_idx = 0;
    for( ; !(total_tests == 0); total_tests = total_tests >> 1)
    {
      if(!((0x1 & total_tests) == 0))
      {
        tmp_post_2 = num_tests;
        num_tests = num_tests + 1;
        tests[(signed long int)tmp_post_2] = bit_idx;
      }

      bit_idx = bit_idx + 1;
    }
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)tests, sizeof(signed int) /*4ul*/  * (unsigned long int)((num_tests & ~(16 - 1)) + 16));
    tests = (signed int *)return_value_realloc_3;
    instance->opt_tests_order.num_groups = 1;
    void *return_value_malloc_4;
    return_value_malloc_4=malloc(sizeof(struct anonymous_20) /*232ul*/  * (unsigned long int)16);
    instance->opt_tests_order.groups = (struct anonymous_20 *)return_value_malloc_4;
    (instance->opt_tests_order.groups + (signed long int)0)->tests = tests;
    (instance->opt_tests_order.groups + (signed long int)0)->num = num_tests;
    (instance->opt_tests_order.groups + (signed long int)0)->shuffling_type = (enum anonymous_22)FCS_NO_SHUFFLING;
    instance->runtime_flags = instance->runtime_flags | (unsigned char)8;
  }

}

// fc_solve_init_locs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 494
static inline void fc_solve_init_locs(struct anonymous_7 *locs)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    locs->stack_locs[(signed long int)i] = (char)i;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    locs->fc_locs[(signed long int)i] = (char)i;
}

// fc_solve_initial_user_state_to_c_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 793
static inline signed int fc_solve_initial_user_state_to_c_proto(const char *string, struct fcs_state_keyval_pair_struct *out_state, signed int freecells_num, signed int stacks_num, signed int decks_num, char *indirect_stacks_buffer)
{
  signed int s;
  signed int c;
  const char *str;
  char card;
  char *col;
  signed int first_line;
  const char * const *prefix;
  signed int decks_index[4l];
  fc_solve_state_init_proto(out_state, stacks_num, indirect_stacks_buffer);
  str = string;
  first_line = 1;
  s = 0;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_10;
  signed int tmp_if_expr_12;
  signed int return_value_fc_solve_u2p_rank_11;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  char tmp_post_15;
  for( ; !(s >= stacks_num); s = s + 1)
  {
    if(first_line == 0)
    {
      for( ; !((signed int)*str == 10); str = str + 1l)
        if((signed int)*str == 0)
          return 1;

      str = str + 1l;
    }

    first_line = 0;
    prefix = fc_solve_freecells_prefixes;
    for( ; !(*prefix == ((const char *)NULL)); prefix = prefix + 1l)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(*prefix);
      signed int return_value_strncasecmp_3;
      return_value_strncasecmp_3=strncasecmp(str, *prefix, return_value_strlen_2);
      if(return_value_strncasecmp_3 == 0)
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(*prefix);
        str = str + (signed long int)return_value_strlen_1;
        break;
      }

    }
    if(!(*prefix == ((const char *)NULL)))
    {
      c = 0;
      for( ; !(c >= freecells_num); c = c + 1)
        out_state->_anon0._anon0.s.freecells[(signed long int)c] = (char)0;
      c = 0;
      for( ; !(c >= freecells_num); c = c + 1)
      {
        if(!(c == 0))
        {
          for( ; !((signed int)*str == 32); str = str + 1l)
          {
            if((signed int)*str == 9)
              break;

            if((signed int)*str == 10)
              break;

            if((signed int)*str == 13)
              break;

            if((signed int)*str == 0)
              return 1;

          }
          if((signed int)*str == 10)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
            break;

          str = str + 1l;
        }

        for( ; (_Bool)1; str = str + 1l)
          if(!((signed int)*str == 32))
          {
            if(!((signed int)*str == 9))
              goto __CPROVER_DUMP_L19;

          }


      __CPROVER_DUMP_L19:
        ;
        if((signed int)*str == 13)
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (signed int)*str == 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
          break;

        if((signed int)*str == 42)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)*str == 45 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          card = (char)0;

        else
          card=fc_solve_card_user2perl(str);
        out_state->_anon0._anon0.s.freecells[(signed long int)c] = card;
      }
      for( ; !((signed int)*str == 10); str = str + 1l)
        if((signed int)*str == 0)
          return 1;

      s = s - 1;
    }

    else
    {
      prefix = fc_solve_foundations_prefixes;
      for( ; !(*prefix == ((const char *)NULL)); prefix = prefix + 1l)
      {
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(*prefix);
        signed int return_value_strncasecmp_9;
        return_value_strncasecmp_9=strncasecmp(str, *prefix, return_value_strlen_8);
        if(return_value_strncasecmp_9 == 0)
        {
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(*prefix);
          str = str + (signed long int)return_value_strlen_7;
          break;
        }

      }
      if(!(*prefix == ((const char *)NULL)))
      {
        signed int d = 0;
        for( ; !(d >= 4 * decks_num); d = d + 1)
          out_state->_anon0._anon0.s.foundations[(signed long int)d] = (char)0;
        d = 0;
        for( ; !(d >= 4); d = d + 1)
          decks_index[(signed long int)d] = 0;
        while((_Bool)1)
        {
          for( ; (_Bool)1; str = str + 1l)
            if(!((signed int)*str == 32))
            {
              if(!((signed int)*str == 9))
                goto __CPROVER_DUMP_L39;

            }


        __CPROVER_DUMP_L39:
          ;
          if((signed int)*str == 10)
            tmp_if_expr_10 = (_Bool)1;

          else
            tmp_if_expr_10 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_10)
            break;

          d=fc_solve_u2p_suit(str);
          str = str + 1l;
          for( ; (signed int)*str == 45; str = str + 1l)
            ;
          if((signed int)*str == 48)
            tmp_if_expr_12 = 0;

          else
          {
            return_value_fc_solve_u2p_rank_11=fc_solve_u2p_rank(str);
            tmp_if_expr_12 = return_value_fc_solve_u2p_rank_11;
          }
          c = tmp_if_expr_12;
          for( ; !((signed int)*str == 32); str = str + 1l)
          {
            if((signed int)*str == 9)
              break;

            if((signed int)*str == 10)
              break;

            if((signed int)*str == 13)
              break;

            if((signed int)*str == 0)
              return 1;

          }
          out_state->_anon0._anon0.s.foundations[(signed long int)(decks_index[(signed long int)d] * 4 + d)] = (char)c;
          decks_index[(signed long int)d] = decks_index[(signed long int)d] + 1;
          if(decks_index[(signed long int)d] >= decks_num)
            decks_index[(signed long int)d] = 0;

        }
        s = s - 1;
        goto __CPROVER_DUMP_L65;
      }

      if((signed int)*str == 58)
        str = str + 1l;

      col = out_state->_anon0._anon0.s.stacks[(signed long int)s];
      c = 0;
      for( ; !(c >= 8); c = c + 1)
      {
        if(!(c == 0))
        {
          for( ; !((signed int)*str == 32); str = str + 1l)
          {
            if((signed int)*str == 9)
              break;

            if((signed int)*str == 10)
              break;

            if((signed int)*str == 13)
              break;

            if((signed int)*str == 0)
              return 1;

          }
          if((signed int)*str == 10)
            tmp_if_expr_13 = (_Bool)1;

          else
            tmp_if_expr_13 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_13)
            break;

        }

        for( ; (_Bool)1; str = str + 1l)
          if(!((signed int)*str == 32))
          {
            if(!((signed int)*str == 9))
              goto __CPROVER_DUMP_L61;

          }


      __CPROVER_DUMP_L61:
        ;
        if((signed int)*str == 0)
          return 1;

        if((signed int)*str == 10)
          tmp_if_expr_14 = (_Bool)1;

        else
          tmp_if_expr_14 = (signed int)*str == 13 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_14)
          break;

        card=fc_solve_card_user2perl(str);
        tmp_post_15 = col[(signed long int)0];
        col[(signed long int)0] = col[(signed long int)0] + 1;
        col[(signed long int)((signed int)tmp_post_15 + 1)] = card;
      }
    }

  __CPROVER_DUMP_L65:
    ;
  }
  return 0;
}

// fc_solve_initialize_befs_rater
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_15 *weighting)
{
  double * const befs_weights = weighting->befs_weights;
  double normalized_befs_weights[6l];
  double sum = (double)0;
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    if(befs_weights[(signed long int)i] < 0.000000)
      befs_weights[(signed long int)i] = fc_solve_default_befs_weights[(signed long int)i];

    sum = sum + befs_weights[(signed long int)i];
  }
  if(sum < 1e-6)
    sum = (double)1;

  signed int fc_solve_initialize_befs_rater__1__3__i = 0;
  for( ; !(fc_solve_initialize_befs_rater__1__3__i >= 6); fc_solve_initialize_befs_rater__1__3__i = fc_solve_initialize_befs_rater__1__3__i + 1)
  {
    befs_weights[(signed long int)fc_solve_initialize_befs_rater__1__3__i] = befs_weights[(signed long int)fc_solve_initialize_befs_rater__1__3__i] / sum;
    normalized_befs_weights[(signed long int)fc_solve_initialize_befs_rater__1__3__i] = befs_weights[(signed long int)fc_solve_initialize_befs_rater__1__3__i] * (double)0x7fffffff;
  }
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const struct anonymous_14 game_params = instance->game_params;
  _Bool bool_unlimited_sequence_move = (_Bool)((signed int)instance->game_params.game_flags & 1 << 4);
  double num_cards_out_factor = normalized_befs_weights[(signed long int)0] / (double)((signed int)game_params.decks_num * 52);
  double out_sum = 0.0;
  signed int fc_solve_initialize_befs_rater__1__4__i = 0;
  for( ; !(fc_solve_initialize_befs_rater__1__4__i >= 14); out_sum = out_sum + num_cards_out_factor)
  {
    weighting->num_cards_out_lookup_table[(signed long int)fc_solve_initialize_befs_rater__1__4__i] = out_sum;
    fc_solve_initialize_befs_rater__1__4__i = fc_solve_initialize_befs_rater__1__4__i + 1;
  }
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(((signed int)instance->game_params.game_flags >> 2 & 0x3) == 0)
  {
    if(!(bool_unlimited_sequence_move == (_Bool)0))
      tmp_if_expr_1 = (signed int)game_params.freecells_num + (signed int)instance->game_params.stacks_num;

    else
      tmp_if_expr_1 = (signed int)game_params.freecells_num + 1 << (signed int)instance->game_params.stacks_num;
    tmp_if_expr_2 = tmp_if_expr_1;
  }

  else
    tmp_if_expr_2 = bool_unlimited_sequence_move != (_Bool)0 ? (signed int)game_params.freecells_num : 1;
  weighting->max_sequence_move_factor = normalized_befs_weights[(signed long int)1] / (double)tmp_if_expr_2;
  weighting->cards_under_sequences_factor = normalized_befs_weights[(signed long int)2] / soft_thread->initial_cards_under_sequences_value;
  weighting->seqs_over_renegade_cards_factor = normalized_befs_weights[(signed long int)3] / fc_solve_seqs_over_cards_lookup[(signed long int)((signed int)game_params.decks_num * 13 * 4)];
  weighting->depth_factor = normalized_befs_weights[(signed long int)4] / (double)20000;
  weighting->num_cards_not_on_parents_factor = normalized_befs_weights[(signed long int)5] / (double)((signed int)game_params.decks_num * 52);
  _Bool tmp_if_expr_3;
  if(IEEE_FLOAT_NOTEQUAL(weighting->max_sequence_move_factor, 0.000000))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = IEEE_FLOAT_NOTEQUAL(weighting->cards_under_sequences_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = IEEE_FLOAT_NOTEQUAL(weighting->seqs_over_renegade_cards_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  weighting->should_go_over_stacks = tmp_if_expr_4;
}

// fc_solve_initialize_befs_rater_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1004
static inline void fc_solve_initialize_befs_rater_link1(struct fc_solve_soft_thread_struct * const soft_thread_link1, struct anonymous_15 *weighting_link1)
{
  double * const befs_weights_link1 = weighting_link1->befs_weights;
  double normalized_befs_weights_link1[6l];
  double sum_link1 = (double)0;
  signed int fc_solve_initialize_befs_rater__1__1__i_link1 = 0;
  for( ; !(fc_solve_initialize_befs_rater__1__1__i_link1 >= 6); fc_solve_initialize_befs_rater__1__1__i_link1 = fc_solve_initialize_befs_rater__1__1__i_link1 + 1)
  {
    if(befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__1__i_link1] < 0.000000)
      befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__1__i_link1] = fc_solve_default_befs_weights[(signed long int)fc_solve_initialize_befs_rater__1__1__i_link1];

    sum_link1 = sum_link1 + befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__1__i_link1];
  }
  if(sum_link1 < 1e-6)
    sum_link1 = (double)1;

  signed int fc_solve_initialize_befs_rater__1__3__i_link1 = 0;
  for( ; !(fc_solve_initialize_befs_rater__1__3__i_link1 >= 6); fc_solve_initialize_befs_rater__1__3__i_link1 = fc_solve_initialize_befs_rater__1__3__i_link1 + 1)
  {
    befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__3__i_link1] = befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__3__i_link1] / sum_link1;
    normalized_befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__3__i_link1] = befs_weights_link1[(signed long int)fc_solve_initialize_befs_rater__1__3__i_link1] * (double)0x7fffffff;
  }
  struct fc_solve_hard_thread_struct * const hard_thread_link1 = soft_thread_link1->hard_thread;
  struct fc_solve_instance_struct * const instance_link1 = hard_thread_link1->instance;
  const struct anonymous_14 game_params_link1 = instance_link1->game_params;
  _Bool bool_unlimited_sequence_move_link1 = (_Bool)((signed int)instance_link1->game_params.game_flags & 1 << 4);
  double num_cards_out_factor_link1 = normalized_befs_weights_link1[(signed long int)0] / (double)((signed int)game_params_link1.decks_num * 52);
  double out_sum_link1 = 0.0;
  signed int i_link1 = 0;
  for( ; !(i_link1 >= 14); out_sum_link1 = out_sum_link1 + num_cards_out_factor_link1)
  {
    weighting_link1->num_cards_out_lookup_table[(signed long int)i_link1] = out_sum_link1;
    i_link1 = i_link1 + 1;
  }
  signed int tmp_if_expr_2_link1;
  signed int tmp_if_expr_1_link1;
  if(((signed int)instance_link1->game_params.game_flags >> 2 & 0x3) == 0)
  {
    if(!(bool_unlimited_sequence_move_link1 == (_Bool)0))
      tmp_if_expr_1_link1 = (signed int)game_params_link1.freecells_num + (signed int)instance_link1->game_params.stacks_num;

    else
      tmp_if_expr_1_link1 = (signed int)game_params_link1.freecells_num + 1 << (signed int)instance_link1->game_params.stacks_num;
    tmp_if_expr_2_link1 = tmp_if_expr_1_link1;
  }

  else
    tmp_if_expr_2_link1 = bool_unlimited_sequence_move_link1 != (_Bool)0 ? (signed int)game_params_link1.freecells_num : 1;
  weighting_link1->max_sequence_move_factor = normalized_befs_weights_link1[(signed long int)1] / (double)tmp_if_expr_2_link1;
  weighting_link1->cards_under_sequences_factor = normalized_befs_weights_link1[(signed long int)2] / soft_thread_link1->initial_cards_under_sequences_value;
  weighting_link1->seqs_over_renegade_cards_factor = normalized_befs_weights_link1[(signed long int)3] / fc_solve_seqs_over_cards_lookup[(signed long int)((signed int)game_params_link1.decks_num * 13 * 4)];
  weighting_link1->depth_factor = normalized_befs_weights_link1[(signed long int)4] / (double)20000;
  weighting_link1->num_cards_not_on_parents_factor = normalized_befs_weights_link1[(signed long int)5] / (double)((signed int)game_params_link1.decks_num * 52);
  _Bool tmp_if_expr_3_link1;
  if(IEEE_FLOAT_NOTEQUAL(weighting_link1->max_sequence_move_factor, 0.000000))
    tmp_if_expr_3_link1 = (_Bool)1;

  else
    tmp_if_expr_3_link1 = IEEE_FLOAT_NOTEQUAL(weighting_link1->cards_under_sequences_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4_link1;
  if(tmp_if_expr_3_link1)
    tmp_if_expr_4_link1 = (_Bool)1;

  else
    tmp_if_expr_4_link1 = IEEE_FLOAT_NOTEQUAL(weighting_link1->seqs_over_renegade_cards_factor, 0.000000) ? (_Bool)1 : (_Bool)0;
  weighting_link1->should_go_over_stacks = tmp_if_expr_4_link1;
}

// fc_solve_initialize_bfs_queue
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 1540
static inline void fc_solve_initialize_bfs_queue(struct fc_solve_soft_thread_struct *soft_thread)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  void *return_value_fcs_compact_alloc_ptr_1;
  return_value_fcs_compact_alloc_ptr_1=fcs_compact_alloc_ptr_link2(&hard_thread->allocator, (signed int)sizeof(struct fcs_states_linked_list_item_struct) /*16ul*/ );
  soft_thread->method_specific.befs.meth.brfs.bfs_queue = (struct fcs_states_linked_list_item_struct *)return_value_fcs_compact_alloc_ptr_1;
  void *return_value_fcs_compact_alloc_ptr_2;
  return_value_fcs_compact_alloc_ptr_2=fcs_compact_alloc_ptr_link2(&hard_thread->allocator, (signed int)sizeof(struct fcs_states_linked_list_item_struct) /*16ul*/ );
  soft_thread->method_specific.befs.meth.brfs.bfs_queue->next = (struct fcs_states_linked_list_item_struct *)return_value_fcs_compact_alloc_ptr_2;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item = soft_thread->method_specific.befs.meth.brfs.bfs_queue->next;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item->next = (struct fcs_states_linked_list_item_struct *)(void *)0;
  soft_thread->method_specific.befs.meth.brfs.recycle_bin = (struct fcs_states_linked_list_item_struct *)(void *)0;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// fc_solve_instance__init_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 357
extern void fc_solve_instance__init_hard_thread(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread)
{
  hard_thread->instance = instance;
  hard_thread->num_soft_threads = 0;
  hard_thread->soft_threads = (struct fc_solve_soft_thread_struct *)(void *)0;
  fc_solve_new_soft_thread(hard_thread);
  hard_thread->num_checked_states_step = (signed long int)50;
  hard_thread->prelude_as_string = (char *)(void *)0;
  hard_thread->prelude = (struct anonymous_39 *)(void *)0;
  hard_thread->prelude_num_items = (signed long int)0;
  hard_thread->prelude_idx = 0;
  fc_solve_reset_hard_thread(hard_thread);
  fc_solve_compact_allocator_init(&hard_thread->allocator, instance->meta_alloc);
  hard_thread->reusable_move_stack.num_moves = (unsigned short int)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)16);
  hard_thread->reusable_move_stack.moves = (struct anonymous_4 *)return_value_malloc_1;
}

// fc_solve_instance__recycle_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1730
static inline void fc_solve_instance__recycle_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread)
{
  fc_solve_reset_hard_thread_link1(hard_thread);
  fc_solve_compact_allocator_recycle(&hard_thread->allocator);
  struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
  struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
  for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
  {
    fc_solve_PQueueFree_link1(&soft_thread->method_specific.befs.meth.befs.pqueue);
    fc_solve_reset_soft_thread_link1(soft_thread);
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_instance_get_first_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1630
static inline struct fc_solve_soft_thread_struct * fc_solve_instance_get_first_soft_thread(struct fc_solve_instance_struct *instance)
{
  return &(instance->hard_threads + (signed long int)0)->soft_threads[(signed long int)0];
}

// fc_solve_meta_compact_allocator_finish
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 77
extern void fc_solve_meta_compact_allocator_finish(struct anonymous_10 *meta_allocator)
{
  char *iter;
  char *iter_next;
  iter = meta_allocator->recycle_bin;
  char *tmp_if_expr_1;
  if(!(iter == ((char *)NULL)))
    tmp_if_expr_1 = *((char **)iter);

  else
    tmp_if_expr_1 = (char *)(void *)0;
  iter_next = tmp_if_expr_1;
  for( ; !(iter_next == ((char *)NULL)); iter_next = *((char **)iter))
  {
    free((void *)iter);
    iter = iter_next;
  }
  free((void *)iter);
  meta_allocator->recycle_bin = (char *)(void *)0;
}

// fc_solve_meta_compact_allocator_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 70
static inline void fc_solve_meta_compact_allocator_init(struct anonymous_10 *meta)
{
  meta->recycle_bin = (char *)(void *)0;
}

// fc_solve_move_sequence_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function(struct anonymous_6 * const new_state_kv_ptr, struct anonymous_3 * const moves, const signed int dest_idx, const signed int source_idx, const signed int start, const signed int end)
{
  char *new_src_col = new_state_kv_ptr->key->stacks[(signed long int)source_idx];
  char *new_dest_col = new_state_kv_ptr->key->stacks[(signed long int)dest_idx];
  signed int i = start;
  char tmp_post_1;
  for( ; end >= i; i = i + 1)
  {
    tmp_post_1 = new_dest_col[(signed long int)0];
    new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
    new_dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = new_src_col[(signed long int)(i + 1)];
  }
  signed int fc_solve_move_sequence_function__1__2__i = start;
  for( ; end >= fc_solve_move_sequence_function__1__2__i; fc_solve_move_sequence_function__1__2__i = fc_solve_move_sequence_function__1__2__i + 1)
  {
    new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
    new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
  }
  fcs_move_stack_params_push(moves, 0, source_idx, dest_idx, (end - start) + 1);
}

// fc_solve_move_sequence_function_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_move_funcs_helpers.h line 129
static inline void fc_solve_move_sequence_function_link1(struct anonymous_6 * const new_state_kv_ptr_link1, struct anonymous_3 * const moves_link1, const signed int dest_idx_link1, const signed int source_idx_link1, const signed int start_link1, const signed int end_link1)
{
  char *new_src_col_link1 = new_state_kv_ptr_link1->key->stacks[(signed long int)source_idx_link1];
  char *new_dest_col_link1 = new_state_kv_ptr_link1->key->stacks[(signed long int)dest_idx_link1];
  signed int fc_solve_move_sequence_function__1__1__i_link1 = start_link1;
  char tmp_post_1_link1;
  for( ; end_link1 >= fc_solve_move_sequence_function__1__1__i_link1; fc_solve_move_sequence_function__1__1__i_link1 = fc_solve_move_sequence_function__1__1__i_link1 + 1)
  {
    tmp_post_1_link1 = new_dest_col_link1[(signed long int)0];
    new_dest_col_link1[(signed long int)0] = new_dest_col_link1[(signed long int)0] + 1;
    new_dest_col_link1[(signed long int)((signed int)tmp_post_1_link1 + 1)] = new_src_col_link1[(signed long int)(fc_solve_move_sequence_function__1__1__i_link1 + 1)];
  }
  signed int i_link1 = start_link1;
  for( ; end_link1 >= i_link1; i_link1 = i_link1 + 1)
  {
    new_src_col_link1[(signed long int)0] = new_src_col_link1[(signed long int)0] - 1;
    new_src_col_link1[(signed long int)((signed int)new_src_col_link1[(signed long int)0] + 1)] = (char)0;
  }
  fcs_move_stack_params_push_link1(moves_link1, 0, source_idx_link1, dest_idx_link1, (end_link1 - start_link1) + 1);
}

// fc_solve_move_stack_compact_allocate
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous_3 * fc_solve_move_stack_compact_allocate(struct fc_solve_hard_thread_struct *hard_thread, struct anonymous_3 *old_move_stack_to_parent)
{
  char *ptr;
  struct anonymous_3 *new_move_stack_to_parent;
  struct anonymous_4 *new_moves_to_parent;
  void *return_value_fcs_compact_alloc_ptr_1;
  return_value_fcs_compact_alloc_ptr_1=fcs_compact_alloc_ptr(&hard_thread->allocator, (signed int)(sizeof(struct anonymous_3) /*16ul*/  + sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent->num_moves));
  ptr = (char *)return_value_fcs_compact_alloc_ptr_1;
  new_move_stack_to_parent = (struct anonymous_3 *)ptr;
  new_moves_to_parent = (struct anonymous_4 *)(ptr + (signed long int)sizeof(struct anonymous_3) /*16ul*/ );
  new_move_stack_to_parent->moves = new_moves_to_parent;
  new_move_stack_to_parent->num_moves = old_move_stack_to_parent->num_moves;
  memcpy((void *)new_moves_to_parent, (const void *)old_move_stack_to_parent->moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent->num_moves);
  return new_move_stack_to_parent;
}

// fc_solve_move_stack_compact_allocate_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_stack_compact_alloc.h line 37
static inline struct anonymous_3 * fc_solve_move_stack_compact_allocate_link1(struct fc_solve_hard_thread_struct *hard_thread_link1, struct anonymous_3 *old_move_stack_to_parent_link1)
{
  char *ptr_link1;
  struct anonymous_3 *new_move_stack_to_parent_link1;
  struct anonymous_4 *new_moves_to_parent_link1;
  void *return_value_fcs_compact_alloc_ptr_1_link1;
  return_value_fcs_compact_alloc_ptr_1_link1=fcs_compact_alloc_ptr_link2(&hard_thread_link1->allocator, (signed int)(sizeof(struct anonymous_3) /*16ul*/  + sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent_link1->num_moves));
  ptr_link1 = (char *)return_value_fcs_compact_alloc_ptr_1_link1;
  new_move_stack_to_parent_link1 = (struct anonymous_3 *)ptr_link1;
  new_moves_to_parent_link1 = (struct anonymous_4 *)(ptr_link1 + (signed long int)sizeof(struct anonymous_3) /*16ul*/ );
  new_move_stack_to_parent_link1->moves = new_moves_to_parent_link1;
  new_move_stack_to_parent_link1->num_moves = old_move_stack_to_parent_link1->num_moves;
  memcpy((void *)new_moves_to_parent_link1, (const void *)old_move_stack_to_parent_link1->moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)old_move_stack_to_parent_link1->num_moves);
  return new_move_stack_to_parent_link1;
}

// fc_solve_move_stack_normalize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 156
static inline void fc_solve_move_stack_normalize(struct anonymous_3 *moves, struct anonymous_6 *init_state, struct anonymous_7 *locs, signed int freecells_num, signed int stacks_num, signed int decks_num)
{
  struct anonymous_4 in_move;
  struct fcs_state_keyval_pair_struct s_and_info;
  char indirect_stacks_buffer[1280l];
  signed int i;
  struct anonymous_6 dynamic_state;
  FCS_STATE_keyval_pair_to_kv_link1(&dynamic_state, &s_and_info);
  struct anonymous_4 out_move = fc_solve_empty_move;
  *(&dynamic_state)->key = *init_state->key;
  *(&dynamic_state)->val = *init_state->val;
  (&dynamic_state)->val->stacks_copy_on_write_flags = 0;
  i = 0;
  for( ; !(i >= stacks_num); i = i + 1)
    if((dynamic_state.val->stacks_copy_on_write_flags & 1 << i) == 0)
    {
      char *copy_stack_col;
      dynamic_state.val->stacks_copy_on_write_flags = dynamic_state.val->stacks_copy_on_write_flags | 1 << i;
      copy_stack_col = dynamic_state.key->stacks[(signed long int)i];
      memcpy((void *)&indirect_stacks_buffer[(signed long int)(i << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      dynamic_state.key->stacks[(signed long int)i] = &indirect_stacks_buffer[(signed long int)(i << 7)];
    }

  struct anonymous_3 temp_moves;
  temp_moves.num_moves = (unsigned short int)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)16);
  temp_moves.moves = (struct anonymous_4 *)return_value_malloc_1;
  _Bool return_value_fc_solve_move_stack_pop_2;
  do
  {
    return_value_fc_solve_move_stack_pop_2=fc_solve_move_stack_pop(moves, &in_move);
    if(!((signed int)return_value_fc_solve_move_stack_pop_2 == 0))
      break;

    fc_solve_apply_move(&dynamic_state, locs, in_move, freecells_num, stacks_num, decks_num);
    const signed int move_type = (const signed int)in_move.c[(signed long int)0];
    if(!(move_type == 12))
    {
      out_move.c[(signed long int)0] = (unsigned char)move_type;
      if(move_type == 0 || move_type == 1 || move_type == 4 || move_type == 11)
        out_move.c[(signed long int)1] = (unsigned char)locs->stack_locs[(signed long int)(signed int)in_move.c[(signed long int)1]];

      else
        if(move_type == 2 || move_type == 3 || move_type == 5)
          out_move.c[(signed long int)1] = (unsigned char)locs->fc_locs[(signed long int)(signed int)in_move.c[(signed long int)1]];

      if(move_type == 0 || move_type == 2)
        out_move.c[(signed long int)2] = (unsigned char)locs->stack_locs[(signed long int)(signed int)in_move.c[(signed long int)2]];

      else
        if(move_type == 1 || move_type == 3)
          out_move.c[(signed long int)2] = (unsigned char)locs->fc_locs[(signed long int)(signed int)in_move.c[(signed long int)2]];

        else
          if(move_type == 4 || move_type == 5 || move_type == 11)
            out_move.c[(signed long int)2] = (unsigned char)in_move.c[(signed long int)2];

      if(move_type == 0)
        out_move.c[(signed long int)3] = (unsigned char)in_move.c[(signed long int)3];

      fcs_move_stack_push_link2(&temp_moves, out_move);
    }

  }
  while((_Bool)1);
  moves->num_moves = (unsigned short int)0;
  fc_solve_move_stack_swallow_stack(moves, &temp_moves);
  free((void *)temp_moves.moves);
}

// fc_solve_move_stack_pop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 97
static inline _Bool fc_solve_move_stack_pop(struct anonymous_3 *stack, struct anonymous_4 *move)
{
  if((signed int)stack->num_moves >= 1)
  {
    stack->num_moves = stack->num_moves - 1;
    *move = stack->moves[(signed long int)stack->num_moves];
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// fc_solve_move_stack_swallow_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 144
static inline void fc_solve_move_stack_swallow_stack(struct anonymous_3 *stack, struct anonymous_3 *src_stack)
{
  struct anonymous_4 move;
  _Bool return_value_fc_solve_move_stack_pop_1;
  do
  {
    return_value_fc_solve_move_stack_pop_1=fc_solve_move_stack_pop(src_stack, &move);
    if(return_value_fc_solve_move_stack_pop_1 != (_Bool)0)
      break;

    fcs_move_stack_push_link2(stack, move);
  }
  while((_Bool)1);
}

// fc_solve_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 305
static inline char * fc_solve_move_to_string(struct anonymous_4 move, signed int standard_notation)
{
  char *return_value_fc_solve_move_to_string_w_state_1;
  return_value_fc_solve_move_to_string_w_state_1=fc_solve_move_to_string_w_state((struct fcs_state_keyval_pair_struct *)(void *)0, 4, 8, 1, move, standard_notation == 2 ? 1 : standard_notation);
  return return_value_fc_solve_move_to_string_w_state_1;
}

// fc_solve_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 296
extern char * fc_solve_move_to_string_w_state(struct fcs_state_keyval_pair_struct *state, signed int freecells_num, signed int stacks_num, signed int decks_num, struct anonymous_4 move, signed int standard_notation)
{
  char string[256l];
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  switch((signed int)move.c[(signed long int)0])
  {
    case 0:
    {
      if(standard_notation == 2)
        tmp_if_expr_1 = (signed int)move.c[(signed long int)3] > 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (signed int)(&state->_anon0._anon0.s)->stacks[(signed long int)move.c[(signed long int)2]][(signed long int)0] == (signed int)move.c[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        sprintf(string, "%i%iv%x", 1 + (signed int)move.c[(signed long int)1], 1 + (signed int)move.c[(signed long int)2], move.c[(signed long int)3]);

      else
        if(!(standard_notation == 0))
          sprintf(string, "%i%i", 1 + (signed int)move.c[(signed long int)1], 1 + (signed int)move.c[(signed long int)2]);

        else
          sprintf(string, "Move %i cards from stack %i to stack %i", move.c[(signed long int)3], move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 2:
    {
      if(!(standard_notation == 0))
      {
        signed int return_value_convert_freecell_num_3;
        return_value_convert_freecell_num_3=convert_freecell_num((signed int)move.c[(signed long int)1]);
        sprintf(string, "%c%i", 97 + return_value_convert_freecell_num_3, 1 + (signed int)move.c[(signed long int)2]);
      }

      else
        sprintf(string, "Move a card from freecell %i to stack %i", move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 3:
    {
      if(!(standard_notation == 0))
      {
        char src_c;
        signed int return_value_convert_freecell_num_4;
        return_value_convert_freecell_num_4=convert_freecell_num((signed int)move.c[(signed long int)1]);
        src_c = (char)(97 + (signed int)(char)return_value_convert_freecell_num_4);
        char dest_c;
        signed int return_value_convert_freecell_num_5;
        return_value_convert_freecell_num_5=convert_freecell_num((signed int)move.c[(signed long int)2]);
        dest_c = (char)(97 + (signed int)(char)return_value_convert_freecell_num_5);
        sprintf(string, "%c%c", src_c, dest_c);
      }

      else
        sprintf(string, "Move a card from freecell %i to freecell %i", move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 1:
    {
      if(!(standard_notation == 0))
      {
        signed int return_value_convert_freecell_num_6;
        return_value_convert_freecell_num_6=convert_freecell_num((signed int)move.c[(signed long int)2]);
        sprintf(string, "%i%c", 1 + (signed int)move.c[(signed long int)1], 97 + return_value_convert_freecell_num_6);
      }

      else
        sprintf(string, "Move a card from stack %i to freecell %i", move.c[(signed long int)1], move.c[(signed long int)2]);
      break;
    }
    case 4:
    {
      if(!(standard_notation == 0))
        sprintf(string, "%ih", 1 + (signed int)move.c[(signed long int)1]);

      else
        sprintf(string, "Move a card from stack %i to the foundations", move.c[(signed long int)1]);
      break;
    }
    case 5:
    {
      if(!(standard_notation == 0))
      {
        signed int return_value_convert_freecell_num_7;
        return_value_convert_freecell_num_7=convert_freecell_num((signed int)move.c[(signed long int)1]);
        sprintf(string, "%ch", 97 + return_value_convert_freecell_num_7);
      }

      else
        sprintf(string, "Move a card from freecell %i to the foundations", move.c[(signed long int)1]);
      break;
    }
    case 11:
    {
      if(!(standard_notation == 0))
        sprintf(string, "%ih", move.c[(signed long int)1]);

      else
        sprintf(string, "Move the sequence on top of Stack %i to the foundations", move.c[(signed long int)1]);
      break;
    }
    default:
      string[(signed long int)0] = (char)0;
  }
  char *return_value_strdup_8;
  return_value_strdup_8=strdup(string);
  return return_value_strdup_8;
}

// fc_solve_moves_processed_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 80
static inline void fc_solve_moves_processed_free(struct anonymous_40 *moves)
{
  free((void *)moves->moves);
  moves->moves = (struct anonymous_54 *)(void *)0;
}

// fc_solve_moves_processed_gen
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 123
extern void fc_solve_moves_processed_gen(struct anonymous_40 * const ret, struct fcs_state_keyval_pair_struct * const orig, const signed int num_freecells, const struct anonymous_11 * const moves_seq)
{
  struct fcs_state_keyval_pair_struct pos_proto;
  char indirect_stacks_buffer[1280l];
  struct anonymous_6 orig_pass;
  orig_pass.key = &orig->_anon0._anon0.s;
  orig_pass.val = &orig->_anon0._anon0.info;
  struct anonymous_6 pos_pass;
  pos_pass.key = &pos_proto._anon0._anon0.s;
  pos_pass.val = &pos_proto._anon0._anon0.info;
  *(&pos_pass)->key = *(&orig_pass)->key;
  *(&pos_pass)->val = *(&orig_pass)->val;
  (&pos_pass)->val->stacks_copy_on_write_flags = 0;
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    if((pos_proto._anon0._anon0.info.stacks_copy_on_write_flags & 1 << i) == 0)
    {
      char *copy_stack_col;
      pos_proto._anon0._anon0.info.stacks_copy_on_write_flags = pos_proto._anon0._anon0.info.stacks_copy_on_write_flags | 1 << i;
      copy_stack_col = pos_proto._anon0._anon0.s.stacks[(signed long int)i];
      memcpy((void *)&indirect_stacks_buffer[(signed long int)(i << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      pos_proto._anon0._anon0.s.stacks[(signed long int)i] = &indirect_stacks_buffer[(signed long int)(i << 7)];
    }

  signed int virtual_stack_len[8l];
  signed int virtual_freecell_len[12l];
  signed int fc_solve_moves_processed_gen__1__i;
  signed int j;
  signed int move_idx;
  signed int num_back_end_moves;
  struct anonymous_4 move;
  struct anonymous_4 out_move;
  struct anonymous_4 *next_move_ptr;
  num_back_end_moves = moves_seq->num_moves;
  next_move_ptr = moves_seq->moves;
  ret->num_moves = 0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_54) /*5ul*/  * (unsigned long int)32);
  ret->moves = (struct anonymous_54 *)return_value_malloc_1;
  ret->next_move_idx = 0;
  fc_solve_moves_processed_gen__1__i = 0;
  for( ; !(fc_solve_moves_processed_gen__1__i >= 8); fc_solve_moves_processed_gen__1__i = fc_solve_moves_processed_gen__1__i + 1)
  {
    char *fc_solve_moves_processed_gen__1__3__1__col = pos_proto._anon0._anon0.s.stacks[(signed long int)fc_solve_moves_processed_gen__1__i];
    virtual_stack_len[(signed long int)fc_solve_moves_processed_gen__1__i] = (signed int)fc_solve_moves_processed_gen__1__3__1__col[(signed long int)0];
  }
  fc_solve_moves_processed_gen__1__i = 0;
  for( ; !(fc_solve_moves_processed_gen__1__i >= num_freecells); fc_solve_moves_processed_gen__1__i = fc_solve_moves_processed_gen__1__i + 1)
    virtual_freecell_len[(signed long int)fc_solve_moves_processed_gen__1__i] = !((signed int)pos_proto._anon0._anon0.s.freecells[(signed long int)fc_solve_moves_processed_gen__1__i] >> 2 == 0) ? 1 : 0;
  move_idx = 0;
  struct anonymous_4 *tmp_post_2;
  char tmp_post_3;
  signed int tmp_if_expr_4;
  char tmp_post_5;
  for( ; !(move_idx >= num_back_end_moves); move_idx = move_idx + 1)
  {
    while((_Bool)1)
    {
      fc_solve_moves_processed_gen__1__i = 0;
      for( ; !(fc_solve_moves_processed_gen__1__i >= 8); fc_solve_moves_processed_gen__1__i = fc_solve_moves_processed_gen__1__i + 1)
      {
        signed int rank;
        signed int suit;
        char card;
        char *fc_solve_moves_processed_gen__1__5__1__1__1__1__col = pos_proto._anon0._anon0.s.stacks[(signed long int)fc_solve_moves_processed_gen__1__i];
        if((signed int)*fc_solve_moves_processed_gen__1__5__1__1__1__1__col >= 1)
        {
          card = fc_solve_moves_processed_gen__1__5__1__1__1__1__col[(signed long int)(((signed int)fc_solve_moves_processed_gen__1__5__1__1__1__1__col[(signed long int)0] - 1) + 1)];
          rank = (signed int)card >> 2;
          suit = (signed int)card & 0x03;
          if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)(0x1 ^ suit)] >= rank + -2)
          {
            if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)(3 ^ suit)] >= rank + -2)
            {
              if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)(0x2 ^ suit)] >= rank + -3)
              {
                if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)suit] == rank + -1)
                {
                  pos_proto._anon0._anon0.s.foundations[(signed long int)suit] = pos_proto._anon0._anon0.s.foundations[(signed long int)suit] + 1;
                  fc_solve_moves_processed_gen__1__5__1__1__1__1__col[(signed long int)0] = fc_solve_moves_processed_gen__1__5__1__1__1__1__col[(signed long int)0] - 1;
                  fc_solve_moves_processed_gen__1__5__1__1__1__1__col[(signed long int)((signed int)fc_solve_moves_processed_gen__1__5__1__1__1__1__col[(signed long int)0] + 1)] = (char)0;
                  break;
                }

              }

            }

          }

        }

      }
      if(fc_solve_moves_processed_gen__1__i >= 8)
      {
        j = 0;
        for( ; !(j >= num_freecells); j = j + 1)
        {
          signed int fc_solve_moves_processed_gen__1__5__1__1__3__1__rank;
          signed int fc_solve_moves_processed_gen__1__5__1__1__3__1__suit;
          char fc_solve_moves_processed_gen__1__5__1__1__3__1__card;
          if(!((signed int)pos_proto._anon0._anon0.s.freecells[(signed long int)j] >> 2 == 0))
          {
            fc_solve_moves_processed_gen__1__5__1__1__3__1__card = pos_proto._anon0._anon0.s.freecells[(signed long int)j];
            fc_solve_moves_processed_gen__1__5__1__1__3__1__rank = (signed int)fc_solve_moves_processed_gen__1__5__1__1__3__1__card >> 2;
            fc_solve_moves_processed_gen__1__5__1__1__3__1__suit = (signed int)fc_solve_moves_processed_gen__1__5__1__1__3__1__card & 0x03;
            if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)(0x1 ^ fc_solve_moves_processed_gen__1__5__1__1__3__1__suit)] >= fc_solve_moves_processed_gen__1__5__1__1__3__1__rank + -2)
            {
              if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)(3 ^ fc_solve_moves_processed_gen__1__5__1__1__3__1__suit)] >= fc_solve_moves_processed_gen__1__5__1__1__3__1__rank + -2)
              {
                if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)(0x2 ^ fc_solve_moves_processed_gen__1__5__1__1__3__1__suit)] >= fc_solve_moves_processed_gen__1__5__1__1__3__1__rank + -3)
                {
                  if((signed int)pos_proto._anon0._anon0.s.foundations[(signed long int)fc_solve_moves_processed_gen__1__5__1__1__3__1__suit] == fc_solve_moves_processed_gen__1__5__1__1__3__1__rank + -1)
                  {
                    pos_proto._anon0._anon0.s.foundations[(signed long int)fc_solve_moves_processed_gen__1__5__1__1__3__1__suit] = pos_proto._anon0._anon0.s.foundations[(signed long int)fc_solve_moves_processed_gen__1__5__1__1__3__1__suit] + 1;
                    pos_proto._anon0._anon0.s.freecells[(signed long int)j] = (char)0;
                    break;
                  }

                }

              }

            }

          }

        }
        if(fc_solve_moves_processed_gen__1__i == 8 && j == num_freecells)
          break;

      }

    }
    tmp_post_2 = next_move_ptr;
    next_move_ptr = next_move_ptr + 1l;
    move = *tmp_post_2;
    signed int src;
    signed int dest;
    char fc_solve_moves_processed_gen__1__5__1__2__card;
    switch((signed int)move.c[(signed long int)0])
    {
      case 4:
      {
        src = (signed int)move.c[(signed long int)1];
        char *fc_solve_moves_processed_gen__1__5__1__2__1__1__col = pos_proto._anon0._anon0.s.stacks[(signed long int)src];
        /* assertion virtual_stack_len[src] >= ( ((col)[0]) ) */
        assert(virtual_stack_len[(signed long int)src] >= (signed int)fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)0]);
        if(virtual_stack_len[(signed long int)src] == (signed int)*fc_solve_moves_processed_gen__1__5__1__2__1__1__col)
        {
          fc_solve_moves_processed_gen__1__5__1__2__card = fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)(((signed int)fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)0] - 1) + 1)];
          fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)0] = fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)0] - 1;
          fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)((signed int)fc_solve_moves_processed_gen__1__5__1__2__1__1__col[(signed long int)0] + 1)] = (char)0;
          pos_proto._anon0._anon0.s.foundations[(signed long int)((signed int)fc_solve_moves_processed_gen__1__5__1__2__card & 0x03)] = pos_proto._anon0._anon0.s.foundations[(signed long int)((signed int)fc_solve_moves_processed_gen__1__5__1__2__card & 0x03)] + 1;
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - 1;
          struct anonymous_54 fc_solve_moves_processed_gen__1__5__1__2__1__1__1__2__ext_move;
          fc_solve_moves_processed_gen__1__5__1__2__1__1__1__2__ext_move.move = move;
          fc_solve_moves_processed_gen__1__5__1__2__1__1__1__2__ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen__1__5__1__2__1__1__1__2__ext_move);
        }

        else
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - 1;
        break;
      }
      case 5:
      {
        src = (signed int)move.c[(signed long int)1];
        /* assertion (virtual_freecell_len[src] == 1) */
        assert(virtual_freecell_len[(signed long int)src] == 1);
        if(!((signed int)pos_proto._anon0._anon0.s.freecells[(signed long int)src] >> 2 == 0))
        {
          struct anonymous_54 fc_solve_moves_processed_gen__1__5__1__2__1__2__2__1__ext_move;
          fc_solve_moves_processed_gen__1__5__1__2__1__2__2__1__ext_move.move = move;
          fc_solve_moves_processed_gen__1__5__1__2__1__2__2__1__ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen__1__5__1__2__1__2__2__1__ext_move);
          pos_proto._anon0._anon0.s.foundations[(signed long int)((signed int)pos_proto._anon0._anon0.s.freecells[(signed long int)src] & 0x03)] = pos_proto._anon0._anon0.s.foundations[(signed long int)((signed int)pos_proto._anon0._anon0.s.freecells[(signed long int)src] & 0x03)] + 1;
          pos_proto._anon0._anon0.s.freecells[(signed long int)src] = (char)0;
        }

        virtual_freecell_len[(signed long int)src] = 0;
        break;
      }
      case 2:
      {
        src = (signed int)move.c[(signed long int)1];
        dest = (signed int)move.c[(signed long int)2];
        /* assertion virtual_freecell_len[src] == 1 */
        assert(virtual_freecell_len[(signed long int)src] == 1);
        if(!((signed int)pos_proto._anon0._anon0.s.freecells[(signed long int)src] >> 2 == 0))
        {
          struct anonymous_54 fc_solve_moves_processed_gen__1__5__1__2__1__3__2__1__ext_move;
          fc_solve_moves_processed_gen__1__5__1__2__1__3__2__1__ext_move.move = move;
          fc_solve_moves_processed_gen__1__5__1__2__1__3__2__1__ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen__1__5__1__2__1__3__2__1__ext_move);
          char *fc_solve_moves_processed_gen__1__5__1__2__1__3__2__dest_col = pos_proto._anon0._anon0.s.stacks[(signed long int)dest];
          tmp_post_3 = fc_solve_moves_processed_gen__1__5__1__2__1__3__2__dest_col[(signed long int)0];
          fc_solve_moves_processed_gen__1__5__1__2__1__3__2__dest_col[(signed long int)0] = fc_solve_moves_processed_gen__1__5__1__2__1__3__2__dest_col[(signed long int)0] + 1;
          fc_solve_moves_processed_gen__1__5__1__2__1__3__2__dest_col[(signed long int)((signed int)tmp_post_3 + 1)] = pos_proto._anon0._anon0.s.freecells[(signed long int)src];
          pos_proto._anon0._anon0.s.freecells[(signed long int)src] = (char)0;
        }

        virtual_freecell_len[(signed long int)src] = 0;
        virtual_stack_len[(signed long int)dest] = virtual_stack_len[(signed long int)dest] + 1;
        break;
      }
      case 1:
      {
        src = (signed int)move.c[(signed long int)1];
        dest = (signed int)move.c[(signed long int)2];
        /* assertion virtual_stack_len[src] > 0 */
        assert(virtual_stack_len[(signed long int)src] > 0);
        char *col = pos_proto._anon0._anon0.s.stacks[(signed long int)src];
        /* assertion ( ((col)[0]) ) <= virtual_stack_len[src] */
        assert((signed int)col[(signed long int)0] <= virtual_stack_len[(signed long int)src]);
        if((signed int)*col >= virtual_stack_len[(signed long int)src])
        {
          struct anonymous_54 ext_move;
          ext_move.move = move;
          ext_move.to_empty_stack = (_Bool)0;
          moves_processed_add_new_move(ret, ext_move);
          char temp_card = col[(signed long int)(((signed int)col[(signed long int)0] - 1) + 1)];
          col[(signed long int)0] = col[(signed long int)0] - 1;
          col[(signed long int)((signed int)col[(signed long int)0] + 1)] = (char)0;
          pos_proto._anon0._anon0.s.freecells[(signed long int)dest] = temp_card;
        }

        virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - 1;
        virtual_freecell_len[(signed long int)dest] = 1;
        break;
      }
      case 0:
      {
        src = (signed int)move.c[(signed long int)1];
        dest = (signed int)move.c[(signed long int)2];
        signed int num_cards = (signed int)move.c[(signed long int)3];
        char *src_col = pos_proto._anon0._anon0.s.stacks[(signed long int)src];
        char *dest_col = pos_proto._anon0._anon0.s.stacks[(signed long int)dest];
        signed int src_len = (signed int)src_col[(signed long int)0];
        /* assertion virtual_stack_len[src] >= src_len */
        assert(virtual_stack_len[(signed long int)src] >= src_len);
        if(!(src_len >= virtual_stack_len[(signed long int)src]))
        {
          signed int virt_num_cards;
          if(!(virtual_stack_len[(signed long int)src] + -src_len >= num_cards))
            tmp_if_expr_4 = virtual_stack_len[(signed long int)src] - src_len;

          else
            tmp_if_expr_4 = num_cards;
          virt_num_cards = tmp_if_expr_4;
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - virt_num_cards;
          virtual_stack_len[(signed long int)dest] = virtual_stack_len[(signed long int)dest] + virt_num_cards;
          num_cards = num_cards - virt_num_cards;
        }

        if(num_cards >= 1)
        {
          out_move.c[(signed long int)0] = (unsigned char)0;
          out_move.c[(signed long int)1] = (unsigned char)src;
          out_move.c[(signed long int)2] = (unsigned char)dest;
          out_move.c[(signed long int)3] = (unsigned char)num_cards;
          struct anonymous_54 fc_solve_moves_processed_gen__1__5__1__2__1__5__2__1__ext_move;
          fc_solve_moves_processed_gen__1__5__1__2__1__5__2__1__ext_move.move = out_move;
          fc_solve_moves_processed_gen__1__5__1__2__1__5__2__1__ext_move.to_empty_stack = (signed int)dest_col[(signed long int)0] == 0;
          moves_processed_add_new_move(ret, fc_solve_moves_processed_gen__1__5__1__2__1__5__2__1__ext_move);
          fc_solve_moves_processed_gen__1__i = 0;
          for( ; !(fc_solve_moves_processed_gen__1__i >= num_cards); fc_solve_moves_processed_gen__1__i = fc_solve_moves_processed_gen__1__i + 1)
          {
            tmp_post_5 = dest_col[(signed long int)0];
            dest_col[(signed long int)0] = dest_col[(signed long int)0] + 1;
            dest_col[(signed long int)((signed int)tmp_post_5 + 1)] = src_col[(signed long int)(((signed int)src_col[(signed long int)0] - num_cards) + fc_solve_moves_processed_gen__1__i + 1)];
          }
          fc_solve_moves_processed_gen__1__i = 0;
          for( ; !(fc_solve_moves_processed_gen__1__i >= num_cards); fc_solve_moves_processed_gen__1__i = fc_solve_moves_processed_gen__1__i + 1)
          {
            src_col[(signed long int)0] = src_col[(signed long int)0] - 1;
            src_col[(signed long int)((signed int)src_col[(signed long int)0] + 1)] = (char)0;
          }
          virtual_stack_len[(signed long int)dest] = virtual_stack_len[(signed long int)dest] + num_cards;
          virtual_stack_len[(signed long int)src] = virtual_stack_len[(signed long int)src] - num_cards;
        }

      }
    }
  }
}

// fc_solve_moves_processed_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface_pos.h line 65
static inline signed int fc_solve_moves_processed_get_moves_left(struct anonymous_40 *moves)
{
  return moves->num_moves - moves->next_move_idx;
}

// fc_solve_moves_processed_render_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 46
char * fc_solve_moves_processed_render_move(struct anonymous_54 move, char *string)
{
  _Bool tmp_if_expr_1;
  signed int return_value_Cvtf89_2;
  signed int return_value_Cvtf89_5;
  signed int return_value_Cvtf89_6;
  switch((signed int)move.move.c[(signed long int)0])
  {
    case 0:
    {
      if(!(move.to_empty_stack == (_Bool)0))
        tmp_if_expr_1 = (signed int)move.move.c[(signed long int)3] > 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        sprintf(string, "%i%iv%x", 1 + (signed int)move.move.c[(signed long int)1], 1 + (signed int)move.move.c[(signed long int)2], move.move.c[(signed long int)3]);

      else
        sprintf(string, "%i%i", 1 + (signed int)move.move.c[(signed long int)1], 1 + (signed int)move.move.c[(signed long int)2]);
      break;
    }
    case 2:
    {
      return_value_Cvtf89_2=Cvtf89((signed int)move.move.c[(signed long int)1]);
      sprintf(string, "%c%i", 97 + return_value_Cvtf89_2, 1 + (signed int)move.move.c[(signed long int)2]);
      break;
    }
    case 3:
    {
      char c1;
      char c2;
      signed int return_value_Cvtf89_3;
      return_value_Cvtf89_3=Cvtf89((signed int)move.move.c[(signed long int)1]);
      c1 = (char)(97 + return_value_Cvtf89_3);
      signed int return_value_Cvtf89_4;
      return_value_Cvtf89_4=Cvtf89((signed int)move.move.c[(signed long int)2]);
      c2 = (char)(97 + return_value_Cvtf89_4);
      sprintf(string, "%c%c", c1, c2);
      break;
    }
    case 1:
    {
      return_value_Cvtf89_5=Cvtf89((signed int)move.move.c[(signed long int)2]);
      sprintf(string, "%i%c", 1 + (signed int)move.move.c[(signed long int)1], 97 + return_value_Cvtf89_5);
      break;
    }
    case 4:
    {
      sprintf(string, "%ih", 1 + (signed int)move.move.c[(signed long int)1]);
      break;
    }
    case 5:
    {
      return_value_Cvtf89_6=Cvtf89((signed int)move.move.c[(signed long int)1]);
      sprintf(string, "%ch", 97 + return_value_Cvtf89_6);
      break;
    }
    case 11:
    {
      sprintf(string, "%ih", move.move.c[(signed long int)1]);
      break;
    }
    default:
      string[(signed long int)0] = (char)0;
  }
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(string);
  return string + (signed long int)return_value_strlen_7;
}

// fc_solve_new_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread(struct fc_solve_instance_struct * const instance)
{
  struct fc_solve_hard_thread_struct *ret;
  if((unsigned long int)instance->next_soft_thread_id == sizeof(unsigned char) * 32 /*32ul*/ )
    return (struct fc_solve_soft_thread_struct *)(void *)0;

  else
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)instance->hard_threads, sizeof(struct fc_solve_hard_thread_struct) /*1440ul*/  * (unsigned long int)(instance->num_hard_threads + 1));
    instance->hard_threads = (struct fc_solve_hard_thread_struct *)return_value_realloc_1;
    struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
    struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
    for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
    {
      struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
      struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
      for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
        soft_thread->hard_thread = hard_thread;
    }
    ret = &instance->hard_threads[(signed long int)instance->num_hard_threads];
    fc_solve_instance__init_hard_thread(instance, ret);
    instance->num_hard_threads = instance->num_hard_threads + 1;
    return &ret->soft_threads[(signed long int)0];
  }
}

// fc_solve_new_hard_thread_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1641
static inline struct fc_solve_soft_thread_struct * fc_solve_new_hard_thread_link1(struct fc_solve_instance_struct * const instance_link1)
{
  struct fc_solve_hard_thread_struct *ret_link1;
  if((unsigned long int)instance_link1->next_soft_thread_id == sizeof(unsigned char) * 32 /*32ul*/ )
    return (struct fc_solve_soft_thread_struct *)(void *)0;

  else
  {
    void *return_value_realloc_1_link1;
    return_value_realloc_1_link1=realloc((void *)instance_link1->hard_threads, sizeof(struct fc_solve_hard_thread_struct) /*1440ul*/  * (unsigned long int)(instance_link1->num_hard_threads + 1));
    instance_link1->hard_threads = (struct fc_solve_hard_thread_struct *)return_value_realloc_1_link1;
    struct fc_solve_hard_thread_struct *hard_thread_link1 = instance_link1->hard_threads;
    struct fc_solve_hard_thread_struct * const end_hard_thread_link1 = hard_thread_link1 + (signed long int)instance_link1->num_hard_threads;
    for( ; !(hard_thread_link1 >= end_hard_thread_link1); hard_thread_link1 = hard_thread_link1 + 1l)
    {
      struct fc_solve_soft_thread_struct *soft_thread_link1 = hard_thread_link1->soft_threads;
      struct fc_solve_soft_thread_struct * const end_soft_thread_link1 = soft_thread_link1 + (signed long int)hard_thread_link1->num_soft_threads;
      for( ; !(soft_thread_link1 >= end_soft_thread_link1); soft_thread_link1 = soft_thread_link1 + 1l)
        soft_thread_link1->hard_thread = hard_thread_link1;
    }
    ret_link1 = &instance_link1->hard_threads[(signed long int)instance_link1->num_hard_threads];
    fc_solve_instance__init_hard_thread(instance_link1, ret_link1);
    instance_link1->num_hard_threads = instance_link1->num_hard_threads + 1;
    return &ret_link1->soft_threads[(signed long int)0];
  }
}

// fc_solve_new_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 1118
extern struct fc_solve_soft_thread_struct * fc_solve_new_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread)
{
  signed int tmp_post_2;
  if((unsigned long int)hard_thread->instance->next_soft_thread_id == sizeof(unsigned char) * 32 /*32ul*/ )
    return (struct fc_solve_soft_thread_struct *)(void *)0;

  else
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)hard_thread->soft_threads, sizeof(struct fc_solve_soft_thread_struct) /*408ul*/  * (unsigned long int)(hard_thread->num_soft_threads + 1));
    hard_thread->soft_threads = (struct fc_solve_soft_thread_struct *)return_value_realloc_1;
    struct fc_solve_soft_thread_struct *ret;
    tmp_post_2 = hard_thread->num_soft_threads;
    hard_thread->num_soft_threads = hard_thread->num_soft_threads + 1;
    ret = &hard_thread->soft_threads[(signed long int)tmp_post_2];
    init_soft_thread(hard_thread, ret);
    return ret;
  }
}

// fc_solve_optimize_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1430
static inline signed int fc_solve_optimize_solution(struct fc_solve_instance_struct *instance)
{
  struct fc_solve_soft_thread_struct *soft_thread;
  struct fc_solve_hard_thread_struct *old_hard_thread;
  struct fc_solve_hard_thread_struct *optimization_thread;
  instance->runtime_flags = instance->runtime_flags | (unsigned char)32;
  if(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct fc_solve_hard_thread_struct) /*1440ul*/  * (unsigned long int)1);
    optimization_thread = (struct fc_solve_hard_thread_struct *)return_value_malloc_1;
    instance->optimization_thread = optimization_thread;
    fc_solve_instance__init_hard_thread(instance, optimization_thread);
    old_hard_thread = instance->current_hard_thread;
    soft_thread = optimization_thread->soft_threads;
    soft_thread->enable_pruning = (old_hard_thread->soft_threads + (signed long int)old_hard_thread->st_idx)->enable_pruning;
  }

  else
  {
    optimization_thread = instance->optimization_thread;
    soft_thread = optimization_thread->soft_threads;
  }
  if(!((8 & (signed int)instance->runtime_flags) == 0))
  {
    if(!(soft_thread->by_depth_tests_order.by_depth_tests == ((struct anonymous_21 *)NULL)))
      fc_solve_free_soft_thread_by_depth_test_array(soft_thread);

    soft_thread->by_depth_tests_order.num = 1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct anonymous_21) /*24ul*/  * (unsigned long int)1);
    soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous_21 *)return_value_malloc_2;
    (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->max_depth = 0x7fffffff;
    (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order=tests_order_dup_link1(&instance->opt_tests_order);
  }

  soft_thread->method = 4;
  soft_thread->super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_BEFS_BRFS;
  soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)2;
  optimization_thread->num_checked_states_left_for_soft_thread = (signed long int)1000000;
  optimization_thread->max_num_checked_states = (signed long int)0x7fffffff;
  fc_solve_soft_thread_init_befs_or_bfs(soft_thread);
  soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)1;
  instance->runtime_flags = instance->runtime_flags | (unsigned char)2;
  signed int return_value_fc_solve_befs_or_bfs_do_solve_3;
  return_value_fc_solve_befs_or_bfs_do_solve_3=fc_solve_befs_or_bfs_do_solve(soft_thread);
  return return_value_fc_solve_befs_or_bfs_do_solve_3;
}

// fc_solve_p2u_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 181
extern char * fc_solve_p2u_rank(signed int rank_idx, char *str, _Bool *rank_is_null, _Bool t)
{
  char (*card_map_3)[4l] = card_map_3_10;
  if(!(t == (_Bool)0))
    card_map_3 = card_map_3_T;

  if(rank_idx >= 0 && !(rank_idx >= 14))
  {
    strcpy(str, card_map_3[(signed long int)rank_idx]);
    *rank_is_null = rank_idx == 0;
  }

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(card_map_3[(signed long int)0]);
    strncpy(str, card_map_3[(signed long int)0], return_value_strlen_1 + (unsigned long int)1);
    *rank_is_null = (_Bool)1;
  }
  return str;
}

// fc_solve_p2u_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 224
static inline char * fc_solve_p2u_suit(signed int suit, char *str, _Bool rank_is_null)
{
  if(suit == 0)
  {
    if(!(rank_is_null == (_Bool)0))
      strncpy(str, " ", (unsigned long int)2);

    else
      strncpy(str, "H", (unsigned long int)2);
  }

  else
    if(suit == 1)
      strncpy(str, "C", (unsigned long int)2);

    else
      if(suit == 2)
        strncpy(str, "D", (unsigned long int)2);

      else
        if(suit == 3)
          strncpy(str, "S", (unsigned long int)2);

        else
          strncpy(str, " ", (unsigned long int)2);
  return str;
}

// fc_solve_rand_get_random_number
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 55
static inline signed int fc_solve_rand_get_random_number(signed long int *my_rand)
{
  signed int one;
  signed int two;
  one=fc_solve_rand_rand15(my_rand);
  two=fc_solve_rand_rand15(my_rand);
  return one | two << 15;
}

// fc_solve_rand_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 38
static inline void fc_solve_rand_init(signed long int *my_rand, unsigned int seed)
{
  *my_rand = (signed long int)seed;
}

// fc_solve_rand_rand15
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/rand.h line 43
static inline signed int fc_solve_rand_rand15(signed long int *my_rand)
{
  *my_rand = *my_rand * (signed long int)214013 + (signed long int)2531011;
  return (signed int)(*my_rand >> 16 & (signed long int)0x7fff);
}

// fc_solve_recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1747
static inline void fc_solve_recycle_instance(struct fc_solve_instance_struct * const instance)
{
  signed int ht_idx;
  fc_solve_finish_instance(instance);
  instance->num_checked_states = (signed long int)0;
  instance->num_hard_threads_finished = 0;
  ht_idx = 0;
  for( ; !(ht_idx >= instance->num_hard_threads); ht_idx = ht_idx + 1)
    fc_solve_instance__recycle_hard_thread(&instance->hard_threads[(signed long int)ht_idx]);
  if(!(instance->optimization_thread == ((struct fc_solve_hard_thread_struct *)NULL)))
    fc_solve_instance__recycle_hard_thread(instance->optimization_thread);

  instance->runtime_flags = instance->runtime_flags & (unsigned char)~2;
}

// fc_solve_release_tests_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1696
static inline void fc_solve_release_tests_list(struct fc_solve_soft_thread_struct * const soft_thread)
{
  free((void *)soft_thread->method_specific.befs.tests_list);
  soft_thread->method_specific.befs.tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *))(void *)0;
  signed int unit_idx;
  struct anonymous_18 *arr = &soft_thread->method_specific.soft_dfs.tests_by_depth_array;
  unit_idx = 0;
  for( ; !(unit_idx >= arr->num_units); unit_idx = unit_idx + 1)
    if(!((arr->by_depth_units + (signed long int)unit_idx)->tests.lists == ((struct anonymous_17 *)NULL)))
    {
      struct anonymous_17 *lists = (arr->by_depth_units + (signed long int)unit_idx)->tests.lists;
      signed int num_lists = (arr->by_depth_units + (signed long int)unit_idx)->tests.num_lists;
      signed int i = 0;
      for( ; !(i >= num_lists); i = i + 1)
        free((void *)(lists + (signed long int)i)->tests);
      free((void *)lists);
    }

  free((void *)arr->by_depth_units);
  arr->by_depth_units = (struct anonymous_52 *)(void *)0;
}

// fc_solve_reset_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread(struct fc_solve_hard_thread_struct * const hard_thread)
{
  hard_thread->num_checked_states = (signed long int)0;
  hard_thread->max_num_checked_states = (signed long int)0x7fffffff;
  hard_thread->num_soft_threads_finished = 0;
}

// fc_solve_reset_hard_thread_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1679
static inline void fc_solve_reset_hard_thread_link1(struct fc_solve_hard_thread_struct * const hard_thread_link1)
{
  hard_thread_link1->num_checked_states = (signed long int)0;
  hard_thread_link1->max_num_checked_states = (signed long int)0x7fffffff;
  hard_thread_link1->num_soft_threads_finished = 0;
}

// fc_solve_reset_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread(struct fc_solve_soft_thread_struct * const soft_thread)
{
  soft_thread->runtime_flags = soft_thread->runtime_flags & (unsigned char)~4;
  soft_thread->runtime_flags = soft_thread->runtime_flags & (unsigned char)~1;
}

// fc_solve_reset_soft_thread_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1688
static inline void fc_solve_reset_soft_thread_link1(struct fc_solve_soft_thread_struct * const soft_thread_link1)
{
  soft_thread_link1->runtime_flags = soft_thread_link1->runtime_flags & (unsigned char)~4;
  soft_thread_link1->runtime_flags = soft_thread_link1->runtime_flags & (unsigned char)~1;
}

// fc_solve_resume_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1499
static inline signed int fc_solve_resume_instance(struct fc_solve_instance_struct *instance)
{
  signed int ret = 5;
  struct fc_solve_hard_thread_struct *hard_thread;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!((2 & (signed int)instance->runtime_flags) == 0))
    ret=fc_solve_befs_or_bfs_do_solve(&instance->optimization_thread->soft_threads[(signed long int)0]);

  else
  {
    struct fc_solve_hard_thread_struct *end_of_hard_threads = instance->hard_threads + (signed long int)instance->num_hard_threads;
    hard_thread = instance->current_hard_thread;
    for( ; !(instance->num_hard_threads_finished >= instance->num_hard_threads); hard_thread = instance->hard_threads)
      for( ; !(hard_thread >= end_of_hard_threads); hard_thread = hard_thread + 1l)
      {
        ret=run_hard_thread(hard_thread);
        if(ret == 0 || ret == 1)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          if(ret == 5)
          {
            if(instance->num_checked_states >= instance->effective_max_num_checked_states)
              tmp_if_expr_1 = (_Bool)1;

            else
              tmp_if_expr_1 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_2 = (_Bool)0;
          tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          goto end_of_hard_threads_loop;

      }

  end_of_hard_threads_loop:
    ;
    instance->current_hard_thread = hard_thread;
    if(instance->num_hard_threads_finished == instance->num_hard_threads)
      ret = 1;

    if(ret == 0)
      fc_solve_trace_solution(instance);

  }
  if(ret == 0)
  {
    if(!((1 & (signed int)instance->runtime_flags) == 0))
    {
      if((2 & (signed int)instance->runtime_flags) == 0)
        ret=fc_solve_optimize_solution(instance);

      if(ret == 0)
        fc_solve_trace_solution(instance);

    }

  }

  return ret;
}

// fc_solve_set_weights
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights(const char *start_num, double * const befs_weights)
{
  signed int i = 0;
  signed int tmp_post_1;
  for( ; !(i >= 6); i = i + 1)
  {
    for( ; (signed int)*start_num == 44; start_num = start_num + 1l)
      ;
    if(*start_num == 0)
    {
      do
      {
        tmp_post_1 = i;
        i = i + 1;
        befs_weights[(signed long int)tmp_post_1] = 0.0;
      }
      while(!(i >= 6));
      goto __CPROVER_DUMP_L7;
    }

    char *end_num;
    befs_weights[(signed long int)i]=strtod(start_num, &end_num);
    start_num = end_num;
  }

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_set_weights_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/set_weights.h line 42
static inline void fc_solve_set_weights_link1(const char *start_num_link1, double * const befs_weights_link1)
{
  signed int i_link1 = 0;
  signed int tmp_post_1_link1;
  for( ; !(i_link1 >= 6); i_link1 = i_link1 + 1)
  {
    for( ; (signed int)*start_num_link1 == 44; start_num_link1 = start_num_link1 + 1l)
      ;
    if(*start_num_link1 == 0)
    {
      do
      {
        tmp_post_1_link1 = i_link1;
        i_link1 = i_link1 + 1;
        befs_weights_link1[(signed long int)tmp_post_1_link1] = 0.0;
      }
      while(!(i_link1 >= 6));
      goto __CPROVER_DUMP_L7;
    }

    char *end_num_link1;
    befs_weights_link1[(signed long int)i_link1]=strtod(start_num_link1, &end_num_link1);
    start_num_link1 = end_num_link1;
  }

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_sfs_atomic_move_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1582
extern void fc_solve_sfs_atomic_move_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  char tmp_post_1;
  if(!(empty_stacks_fill == 2))
  {
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    if(!((signed int)num_vacant_stacks == 0))
    {
      const struct anonymous_14 game_params = instance->game_params;
      signed int empty_stack_idx = 0;
      for( ; !(empty_stack_idx >= (signed int)game_params.stacks_num); empty_stack_idx = empty_stack_idx + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)empty_stack_idx] == 0)
          break;

      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
      {
        char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
        const signed int cards_num = (const signed int)col[(signed long int)0];
        if(cards_num >= 2)
        {
          const char card = col[(signed long int)((cards_num - 1) + 1)];
          if(empty_stacks_fill == 1 && !((signed int)card >> 2 == 13))
            goto __CPROVER_DUMP_L10;

          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *fc_solve_sfs_atomic_move_card_to_empty_stack__1__5__1__1__2__2__1__copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            fc_solve_sfs_atomic_move_card_to_empty_stack__1__5__1__1__2__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_atomic_move_card_to_empty_stack__1__5__1__1__2__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_atomic_move_card_to_empty_stack__1__5__1__1__2__2__1__copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
          new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << empty_stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << empty_stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)empty_stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(empty_stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)empty_stack_idx] = &indirect_stacks_buffer[(signed long int)(empty_stack_idx << 7)];
          }

          char *empty_stack_col = pass_new_state.key->stacks[(signed long int)empty_stack_idx];
          tmp_post_1 = empty_stack_col[(signed long int)0];
          empty_stack_col[(signed long int)0] = empty_stack_col[(signed long int)0] + 1;
          empty_stack_col[(signed long int)((signed int)tmp_post_1 + 1)] = card;
          fcs_push_1card_seq(moves, stack_idx, empty_stack_idx);
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }


      __CPROVER_DUMP_L10:
        ;
      }
      goto __CPROVER_DUMP_L12;
    }

  }


__CPROVER_DUMP_L12:
  ;
}

// fc_solve_sfs_atomic_move_card_to_freecell
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1719
extern void fc_solve_sfs_atomic_move_card_to_freecell(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  if(!((signed int)num_vacant_freecells == 0))
  {
    const signed int num_cards_in_col_threshold = empty_stacks_fill == 2 ? 1 : 0;
    signed int ds = 0;
    for( ; !(ds >= (signed int)game_params.freecells_num); ds = ds + 1)
      if((signed int)raw_ptr_state_raw->key->freecells[(signed long int)ds] >> 2 == 0)
        break;

    signed int stack_idx = 0;
    for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
    {
      char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
      const signed int cards_num = (const signed int)col[(signed long int)0];
      if(!(num_cards_in_col_threshold >= cards_num))
      {
        const char card = col[(signed long int)((cards_num - 1) + 1)];
        fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
        if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
        {
          char *copy_stack_col;
          pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
          copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
          pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
        }

        char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
        new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
        new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
        pass_new_state.key->freecells[(signed long int)ds] = card;
        fcs_move_stack_non_seq_push(moves, 1, stack_idx, ds);
        fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
      }

    }
    goto __CPROVER_DUMP_L8;
  }


__CPROVER_DUMP_L8:
  ;
}

// fc_solve_sfs_atomic_move_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1656
extern void fc_solve_sfs_atomic_move_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  const signed int num_cards_in_col_threshold = empty_stacks_fill == 2 ? 1 : 0;
  signed int stack_idx = 0;
  char tmp_post_1;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(!(num_cards_in_col_threshold >= cards_num))
    {
      const char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int ds = 0;
      for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
        if(!(ds == stack_idx))
        {
          char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
          if((signed int)*dest_col >= 1)
          {
            char dest_card = dest_col[(signed long int)(((signed int)dest_col[(signed long int)0] - 1) + 1)];
            if(((signed int)card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)card) == (1 & (signed int)dest_card)))))
            {
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
              {
                char *fc_solve_sfs_atomic_move_card_to_parent__1__2__1__1__1__1__2__1__1__2__1__copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                fc_solve_sfs_atomic_move_card_to_parent__1__2__1__1__1__1__2__1__1__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_atomic_move_card_to_parent__1__2__1__1__1__1__2__1__1__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_atomic_move_card_to_parent__1__2__1__1__1__1__2__1__1__2__1__copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
              }

              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
              char *new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
              new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
              new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
              tmp_post_1 = new_dest_col[(signed long int)0];
              new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
              new_dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = card;
              fcs_push_1card_seq(moves, stack_idx, ds);
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }

    }

  }
  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
}

// fc_solve_sfs_atomic_move_freecell_card_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1827
extern void fc_solve_sfs_atomic_move_freecell_card_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  char tmp_post_1;
  if(!(empty_stacks_fill == 2))
  {
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    if(!((signed int)num_vacant_stacks == 0))
    {
      signed int ds = 0;
      for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)ds] == 0)
          break;

      signed int fc = 0;
      for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
      {
        const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
        if(!((signed int)card >> 2 == 0) && (!(empty_stacks_fill == 1) || (signed int)card >> 2 == 13))
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
          }

          char *new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          tmp_post_1 = new_dest_col[(signed long int)0];
          new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
          new_dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = card;
          fcs_move_stack_non_seq_push(moves, 2, fc, ds);
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

      }
      goto __CPROVER_DUMP_L10;
    }

  }


__CPROVER_DUMP_L10:
  ;
}

// fc_solve_sfs_atomic_move_freecell_card_to_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1777
extern void fc_solve_sfs_atomic_move_freecell_card_to_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  signed int fc = 0;
  char tmp_post_1;
  for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
  {
    const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
    if(!((signed int)card >> 2 == 0))
    {
      signed int ds = 0;
      for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
      {
        char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
        if((signed int)*dest_col >= 1)
        {
          char dest_card = dest_col[(signed long int)(((signed int)dest_col[(signed long int)0] - 1) + 1)];
          if(((signed int)card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)card) == (1 & (signed int)dest_card)))))
          {
            fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
            if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
            {
              char *copy_stack_col;
              pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
              copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
              memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
              pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
            }

            char *new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
            pass_new_state.key->freecells[(signed long int)fc] = (char)0;
            tmp_post_1 = new_dest_col[(signed long int)0];
            new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
            new_dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = card;
            fcs_move_stack_non_seq_push(moves, 2, fc, ds);
            fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
          }

        }

      }
    }

  }
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// fc_solve_sfs_check_state_begin
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 63
extern signed int fc_solve_sfs_check_state_begin(struct fc_solve_hard_thread_struct * const hard_thread, struct anonymous_6 * const out_new_state_out, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_3 * const moves)
{
  struct fcs_state_keyval_pair_struct *raw_ptr_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  hard_thread->allocated_from_list = instance->list_of_vacant_states != (struct fcs_state_keyval_pair_struct *)(void *)0;
  if(!(hard_thread->allocated_from_list == (_Bool)0))
  {
    raw_ptr_new_state = instance->list_of_vacant_states;
    instance->list_of_vacant_states = instance->list_of_vacant_states->_anon0._anon0.info.parent;
  }

  else
    raw_ptr_new_state=fcs_state_ia_alloc_into_var(&hard_thread->allocator);
  FCS_STATE_keyval_pair_to_kv_link2(out_new_state_out, raw_ptr_new_state);
  *out_new_state_out->key = *raw_ptr_state_raw->key;
  *out_new_state_out->val = *raw_ptr_state_raw->val;
  out_new_state_out->val->stacks_copy_on_write_flags = 0;
  raw_ptr_new_state->_anon0._anon0.info.parent = (struct fcs_state_keyval_pair_struct *)raw_ptr_state_raw->key;
  raw_ptr_new_state->_anon0._anon0.info.moves_to_parent = moves;
  raw_ptr_new_state->_anon0._anon0.info.depth = raw_ptr_new_state->_anon0._anon0.info.depth + 1;
  raw_ptr_new_state->_anon0._anon0.info.visited = (unsigned char)0;
  raw_ptr_new_state->_anon0._anon0.info.num_active_children = (unsigned short int)0;
  memset((void *)&raw_ptr_new_state->_anon0._anon0.info.scan_visited, 0, sizeof(unsigned char [4l]) /*4ul*/ );
  moves->num_moves = (unsigned short int)0;
  return 0;
}

// fc_solve_sfs_check_state_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.h line 70
extern void fc_solve_sfs_check_state_end(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_6 * const raw_ptr_new_state_raw, const signed int state_context_value, struct anonymous_3 * const moves, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const unsigned char calc_real_depth = (const unsigned char)((signed int)instance->runtime_flags & 4);
  const unsigned char scans_synergy = (const unsigned char)((signed int)instance->runtime_flags & 64);
  struct anonymous_6 existing_state;
  _Bool return_value_fc_solve_check_and_add_state_3;
  return_value_fc_solve_check_and_add_state_3=fc_solve_check_and_add_state(hard_thread, raw_ptr_new_state_raw, &existing_state);
  signed int return_value_kv_calc_depth_1;
  signed int return_value_kv_calc_depth_2;
  if(return_value_fc_solve_check_and_add_state_3 == (_Bool)0)
  {
    if(!(hard_thread->allocated_from_list == (_Bool)0))
    {
      raw_ptr_new_state_raw->val->parent = instance->list_of_vacant_states;
      instance->list_of_vacant_states = (struct fcs_state_keyval_pair_struct *)raw_ptr_new_state_raw->key;
    }

    else
      (&hard_thread->allocator)->ptr = (&hard_thread->allocator)->rollback_ptr;
    calculate_real_depth((const _Bool)calc_real_depth, (struct fcs_state_keyval_pair_struct *)(&existing_state)->key);
    if(!((32 & (signed int)instance->runtime_flags) == 0))
    {
      return_value_kv_calc_depth_1=kv_calc_depth(&existing_state);
      return_value_kv_calc_depth_2=kv_calc_depth(raw_ptr_state_raw);
      if(!(1 + return_value_kv_calc_depth_2 >= return_value_kv_calc_depth_1))
      {
        existing_state.val->moves_to_parent=fc_solve_move_stack_compact_allocate_link1(hard_thread, moves);
        if((4 & (signed int)existing_state.val->visited) == 0)
        {
          existing_state.val->parent->_anon0._anon0.info.num_active_children = existing_state.val->parent->_anon0._anon0.info.num_active_children - 1;
          if((signed int)existing_state.val->parent->_anon0._anon0.info.num_active_children == 0)
            mark_as_dead_end((const _Bool)scans_synergy, existing_state.val->parent);

          raw_ptr_state_raw->val->num_active_children = raw_ptr_state_raw->val->num_active_children + 1;
        }

        existing_state.val->parent = (struct fcs_state_keyval_pair_struct *)raw_ptr_state_raw->key;
        existing_state.val->depth = raw_ptr_state_raw->val->depth + 1;
      }

    }

    fc_solve_derived_states_list_add_state(derived_states_list, (struct fcs_state_keyval_pair_struct *)(&existing_state)->key, state_context_value);
  }

  else
    fc_solve_derived_states_list_add_state(derived_states_list, (struct fcs_state_keyval_pair_struct *)raw_ptr_new_state_raw->key, state_context_value);
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// fc_solve_sfs_empty_stack_into_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1361
extern void fc_solve_sfs_empty_stack_into_freecells(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  if(!(empty_stacks_fill == 2))
  {
    const struct anonymous_14 game_params = instance->game_params;
    const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    if((signed int)num_vacant_stacks == 0)
    {
      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
      {
        char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
        const signed int cards_num = (const signed int)col[(signed long int)0];
        if((signed int)num_vacant_freecells >= cards_num)
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char * const new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          signed int b = 0;
          signed int c = 0;
          for( ; !(c >= cards_num); b = b + 1)
          {
            for( ; !(b >= (signed int)game_params.freecells_num); b = b + 1)
              if((signed int)pass_new_state.key->freecells[(signed long int)b] >> 2 == 0)
                break;

            char top_card = new_src_col[(signed long int)(((signed int)new_src_col[(signed long int)0] - 1) + 1)];
            new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
            new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
            pass_new_state.key->freecells[(signed long int)b] = top_card;
            fcs_move_stack_non_seq_push(moves, 1, stack_idx, b);
            c = c + 1;
          }
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

      }
    }

    goto __CPROVER_DUMP_L11;
  }


__CPROVER_DUMP_L11:
  ;
}

// fc_solve_sfs_move_cards_to_a_different_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1178
extern void fc_solve_sfs_move_cards_to_a_different_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  const signed int initial_derived_states_num_states = derived_states_list->num_states;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, fc_solve_get_the_positions_by_rank_data__freecell_generator);
  signed int stack_idx = 0;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 2)
    {
      char upper_card = col[(signed long int)((cards_num - 1) + 1)];
      signed int min_card_height;
      char lower_card;
      min_card_height = cards_num - 2;
      for( ; min_card_height >= 0; min_card_height = min_card_height - 1)
      {
        lower_card = col[(signed long int)(min_card_height + 1)];
        if(!(((signed int)upper_card >> 2) + 1 == (signed int)lower_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)upper_card) == (0x03 & (signed int)lower_card) : !((1 & (signed int)upper_card) == (1 & (signed int)lower_card))))
          break;

        upper_card = lower_card;
      }
      min_card_height = min_card_height + 2;
      signed int c = min_card_height;
      for( ; !(c >= cards_num); c = c + 1)
      {
        const char card = col[(signed long int)(c + 1)];
        char *pos_idx_to_check = &positions_by_rank[(signed long int)((2 << 3) * ((signed int)card >> 2))];
        char *last_pos_idx = pos_idx_to_check + (signed long int)(2 << 3);
        pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 0 : (sequences_are_built_by == 1 ? (signed int)card & 0x03 : ((signed int)card & 0x03 ^ 0x1) & 0x2 - 1)) << 1);
        for( ; !(pos_idx_to_check >= last_pos_idx); pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? 4 : 2)) << 1))
        {
          const signed int ds = (const signed int)pos_idx_to_check[(signed long int)0];
          if(!(ds == -1) && !(ds == stack_idx))
          {
            const signed int dc = (const signed int)pos_idx_to_check[(signed long int)1];
            char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            signed int dest_cards_num = (signed int)dest_col[(signed long int)0];
            char dest_card = dest_col[(signed long int)(dc + 1)];
            if(!(1 + dc >= dest_cards_num))
            {
              if(!(((signed int)dest_col[(signed long int)(1 + dc)] >> 2) + 1 == (signed int)dest_card >> 2))
                goto __CPROVER_DUMP_L12;

              if(sequences_are_built_by == 2)
                tmp_if_expr_2 = 1;

              else
              {
                if(sequences_are_built_by == 1)
                  tmp_if_expr_1 = (signed int)(((signed int)dest_col[(signed long int)(dc + 1 + 1)] & 0x03) == ((signed int)dest_card & 0x03));

                else
                  tmp_if_expr_1 = (signed int)(((signed int)dest_col[(signed long int)(dc + 1 + 1)] & 0x03 & 0x1) != ((signed int)dest_card & 0x03 & 0x1));
                tmp_if_expr_2 = tmp_if_expr_1;
              }
              if(tmp_if_expr_2 == 0)
                goto __CPROVER_DUMP_L12;

            }

            else
            {

            __CPROVER_DUMP_L12:
              ;
              signed int num_cards_to_relocate = (dest_cards_num - dc) - 1;
              const signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
              num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
              signed int freestacks_to_fill;
              if(empty_stacks_fill == 0)
              {
                freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
                num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
              }

              else
                freestacks_to_fill = 0;
              if(num_cards_to_relocate == 0)
                tmp_if_expr_3 = (((signed int)instance->game_params.game_flags & 1 << 4) != 0 ? 0x7fffffff : (empty_stacks_fill == 0 ? ((signed int)num_vacant_freecells - freecells_to_fill) + 1 << (signed int)num_vacant_stacks - freestacks_to_fill : ((signed int)num_vacant_freecells - freecells_to_fill) + 1)) >= cards_num - c ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
              {
                signed int cols_indexes[3l];
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                cols_indexes[(signed long int)0] = ds;
                cols_indexes[(signed long int)1] = -1;
                cols_indexes[(signed long int)2] = -1;
                empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, freestacks_to_fill + freecells_to_fill, 0);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_move_cards_to_a_different_parent__1__2__1__3__1__1__1__6__3__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_move_cards_to_a_different_parent__1__2__1__3__1__1__1__6__3__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_move_cards_to_a_different_parent__1__2__1__3__1__1__1__6__3__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_cards_to_a_different_parent__1__2__1__3__1__1__1__6__3__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                fc_solve_move_sequence_function(&pass_new_state, moves, ds, stack_idx, c, cards_num - 1);
                state_context_value = ((stack_idx << 8 | c) << 8 | ds) << 8 | dc;
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }
          }

        }
      }
    }

  }
  sort_derived_states(derived_states_list, initial_derived_states_num_states);
  goto __CPROVER_DUMP_L25;

__CPROVER_DUMP_L25:
  ;
}

// fc_solve_sfs_move_freecell_cards_on_top_of_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 345
extern void fc_solve_sfs_move_freecell_cards_on_top_of_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int initial_derived_states_num_states = derived_states_list->num_states;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, fc_solve_get_the_positions_by_rank_data__freecell_generator);
  signed int fc = 0;
  char tmp_post_1;
  for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
  {
    char src_card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
    if(!((signed int)src_card >> 2 == 0) && !((signed int)src_card >> 2 == 13))
    {
      char *pos_idx_to_check = &positions_by_rank[(signed long int)((2 << 3) * ((signed int)src_card >> 2))];
      char *last_pos_idx = pos_idx_to_check + (signed long int)(2 << 3);
      pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 0 : (sequences_are_built_by == 1 ? (signed int)src_card & 0x03 : ((signed int)src_card & 0x03 ^ 0x1) & 0x2 - 1)) << 1);
      for( ; !(pos_idx_to_check >= last_pos_idx); pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? 4 : 2)) << 1))
      {
        signed int ds = (signed int)pos_idx_to_check[(signed long int)0];
        if(!(ds == -1))
        {
          signed int dc = (signed int)pos_idx_to_check[(signed long int)1];
          char *dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
          char dest_card = dest_col[(signed long int)(dc + 1)];
          signed int dest_cards_num = (signed int)dest_col[(signed long int)0];
          _Bool is_seq_in_dest = (_Bool)0;
          if(!(dc >= dest_cards_num + -1))
          {
            char dest_below_card = dest_col[(signed long int)(dc + 1 + 1)];
            if(((signed int)dest_below_card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)dest_below_card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)dest_below_card) == (1 & (signed int)dest_card)))))
              is_seq_in_dest = (_Bool)1;

          }

          if(is_seq_in_dest == (_Bool)0)
          {
            signed int num_cards_to_relocate = (dest_cards_num - dc) - 1;
            signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
            num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
            signed int freestacks_to_fill;
            if(empty_stacks_fill == 0)
            {
              freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
              num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
            }

            else
              freestacks_to_fill = 0;
            if(num_cards_to_relocate == 0)
            {
              signed int cols_indexes[3l];
              char *new_dest_col;
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              cols_indexes[(signed long int)0] = ds;
              cols_indexes[(signed long int)1] = -1;
              cols_indexes[(signed long int)2] = -1;
              empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, (dest_cards_num - dc) - 1, 0);
              new_dest_col = pass_new_state.key->stacks[(signed long int)ds];
              tmp_post_1 = new_dest_col[(signed long int)0];
              new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
              new_dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = src_card;
              pass_new_state.key->freecells[(signed long int)fc] = (char)0;
              fcs_move_stack_non_seq_push(moves, 2, fc, ds);
              state_context_value = ds << 16 | 255 - dc << 8 | fc;
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }

      }
    }

  }
  sort_derived_states(derived_states_list, initial_derived_states_num_states);
  goto __CPROVER_DUMP_L15;

__CPROVER_DUMP_L15:
  ;
}

// fc_solve_sfs_move_freecell_cards_to_empty_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1118
extern void fc_solve_sfs_move_freecell_cards_to_empty_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  char tmp_post_1;
  if(!(empty_stacks_fill == 2))
  {
    const struct anonymous_14 game_params = instance->game_params;
    if(!(soft_thread->num_vacant_stacks == 0))
    {
      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)stack_idx] == 0)
          break;

      signed int fc = 0;
      for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
      {
        const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
        if(empty_stacks_fill == 1 ? (signed int)card >> 2 == 13 : !((signed int)card >> 2 == 0))
        {
          char *new_src_col;
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          tmp_post_1 = new_src_col[(signed long int)0];
          new_src_col[(signed long int)0] = new_src_col[(signed long int)0] + 1;
          new_src_col[(signed long int)((signed int)tmp_post_1 + 1)] = card;
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          fcs_move_stack_non_seq_push(moves, 2, fc, stack_idx);
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

      }
    }

    goto __CPROVER_DUMP_L9;
  }


__CPROVER_DUMP_L9:
  ;
}

// fc_solve_sfs_move_freecell_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 141
extern void fc_solve_sfs_move_freecell_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  const struct anonymous_14 game_params = instance->game_params;
  signed int fc = 0;
  for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
  {
    const char card = raw_ptr_state_raw->key->freecells[(signed long int)fc];
    if(!((signed int)card >> 2 == 0))
    {
      signed int deck = 0;
      for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
        if((signed int)raw_ptr_state_raw->key->foundations[(signed long int)(4 * deck + (0x03 & (signed int)card))] == ((signed int)card >> 2) + -1)
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] = pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] + 1;
          fcs_move_stack_non_seq_push(moves, 5, fc, deck * 4 + ((signed int)card & 0x03));
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
        }

    }

  }
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// fc_solve_sfs_move_non_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 529
extern void fc_solve_sfs_move_non_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    signed int c = cards_num - 2;
    for( ; c >= 0; c = c - 1)
    {
      const char card = col[(signed long int)(c + 1)];
      signed int deck = 0;
      for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
        if((signed int)raw_ptr_state_raw->key->foundations[(signed long int)(4 * deck + (0x03 & (signed int)card))] == ((signed int)card >> 2) + -1)
        {
          if((empty_stacks_fill == 0 ? (signed int)num_vacant_stacks : 0) + (signed int)num_vacant_freecells >= cards_num + -(1 + c))
          {
            signed int cols_indexes[3l];
            char *new_src_col;
            fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
            if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
            {
              char *copy_stack_col;
              pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
              copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
              memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
              pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
            }

            cols_indexes[(signed long int)0] = stack_idx;
            cols_indexes[(signed long int)1] = -1;
            cols_indexes[(signed long int)2] = -1;
            empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, cards_num - (c + 1), 0);
            new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            char top_card = new_src_col[(signed long int)(((signed int)new_src_col[(signed long int)0] - 1) + 1)];
            new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
            new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
            const signed int dest_found = deck * 4 + ((signed int)top_card & 0x03);
            pass_new_state.key->foundations[(signed long int)dest_found] = pass_new_state.key->foundations[(signed long int)dest_found] + 1;
            fcs_move_stack_non_seq_push(moves, 4, stack_idx, dest_found);
            fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
          }

          break;
        }

    }
  }
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// fc_solve_sfs_move_sequences_to_free_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 921
extern void fc_solve_sfs_move_sequences_to_free_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  if(!(empty_stacks_fill == 2))
  {
    const struct anonymous_14 game_params = instance->game_params;
    const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
    const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
    const signed int max_sequence_len = ((signed int)instance->game_params.game_flags & 1 << 4) != 0 ? 0x7fffffff : (empty_stacks_fill == 0 ? (signed int)num_vacant_freecells + 1 << (signed int)num_vacant_stacks - 1 : (signed int)num_vacant_freecells + 1);
    if((signed int)num_vacant_stacks >= 1)
    {
      signed int dest_stack_idx = -1;
      signed int stack_idx = 0;
      for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
      {
        char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
        const signed int cards_num = (const signed int)col[(signed long int)0];
        signed int seq_end;
        signed int c = 0;
        for( ; !(c >= cards_num); c = seq_end + 1)
        {
          seq_end = c;
          for( ; !(seq_end >= cards_num + -1); seq_end = seq_end + 1)
          {
            char this_card = col[(signed long int)(seq_end + 1 + 1)];
            char prev_card = col[(signed long int)(seq_end + 1)];
            if(!(((signed int)this_card >> 2) + 1 == (signed int)prev_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)this_card) == (0x03 & (signed int)prev_card) : !((1 & (signed int)this_card) == (1 & (signed int)prev_card))))
              break;

          }
          if(!((signed int)col[(signed long int)(1 + c)] >> 2 == 13))
          {
            if(empty_stacks_fill == 1)
              goto __CPROVER_DUMP_L30;

          }

          if(seq_end == cards_num + -1)
          {
            for( ; c >= 1 && !(max_sequence_len >= cards_num + -c); c = c - 1)
              ;
            if(c >= 1)
            {
              if(empty_stacks_fill == 1)
                tmp_if_expr_1 = (signed int)((signed int)col[(signed long int)(c + 1)] >> 2 == 13);

              else
                tmp_if_expr_1 = 1;
              if(!(tmp_if_expr_1 == 0))
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if(!(dest_stack_idx >= 0))
                {
                  dest_stack_idx = 0;
                  for( ; !(dest_stack_idx >= (signed int)game_params.stacks_num); dest_stack_idx = dest_stack_idx + 1)
                    if((signed int)*pass_new_state.key->stacks[(signed long int)dest_stack_idx] == 0)
                      break;

                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_stack_idx) == 0)
                {
                  char *fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__3__2__3__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_stack_idx;
                  fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__3__2__3__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)], (const void *)fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__3__2__3__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__3__2__3__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)dest_stack_idx] = &indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                fc_solve_move_sequence_function(&pass_new_state, moves, dest_stack_idx, stack_idx, c, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

          else
          {
            signed int num_cards_to_relocate = (cards_num - seq_end) - 1;
            const signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
            num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
            signed int freestacks_to_fill;
            if(empty_stacks_fill == 0)
            {
              freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
              num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
            }

            else
              freestacks_to_fill = 0;
            if(num_cards_to_relocate == 0 && (signed int)num_vacant_stacks + -freestacks_to_fill >= 1)
            {
              signed int seq_start = c;
              for( ; (16 & (signed int)instance->game_params.game_flags) == 0 && (empty_stacks_fill == 0 ? !(1 + (signed int)num_vacant_freecells + -freecells_to_fill << (signed int)num_vacant_stacks + -freestacks_to_fill + -1 >= 1 + seq_end + -seq_start) : !(1 + (signed int)num_vacant_freecells + -freecells_to_fill >= 1 + seq_end + -seq_start)); seq_start = seq_start + 1)
                if(!(seq_end >= seq_start))
                  break;

              if(seq_end >= seq_start)
              {
                if(empty_stacks_fill == 1)
                  tmp_if_expr_2 = (signed int)((signed int)col[(signed long int)(seq_start + 1)] >> 2 == 13);

                else
                  tmp_if_expr_2 = 1;
                if(!(tmp_if_expr_2 == 0))
                {
                  signed int cols_indexes[3l];
                  signed int empty_ret;
                  fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                  {
                    char *fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__2__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                    fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__2__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                  }

                  cols_indexes[(signed long int)0] = stack_idx;
                  cols_indexes[(signed long int)1] = -1;
                  cols_indexes[(signed long int)2] = -1;
                  empty_ret=empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, freecells_to_fill + freestacks_to_fill, 0);
                  signed int b = (empty_ret >> 8 & 0x1) != 0 ? (empty_ret & 0xFF) + 1 : 0;
                  for( ; !(b >= (signed int)game_params.stacks_num); b = b + 1)
                    if((signed int)*pass_new_state.key->stacks[(signed long int)b] == 0)
                      break;

                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << b) == 0)
                  {
                    char *fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__4__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << b;
                    fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__4__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)b];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(b << 7)], (const void *)fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__4__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_sequences_to_free_stacks__1__3__1__1__1__1__4__3__2__4__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)b] = &indirect_stacks_buffer[(signed long int)(b << 7)];
                  }

                  fc_solve_move_sequence_function(&pass_new_state, moves, b, stack_idx, seq_start, seq_end);
                  fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
                }

              }

            }

          }

        __CPROVER_DUMP_L30:
          ;
        }
      }
    }

    goto __CPROVER_DUMP_L34;
  }


__CPROVER_DUMP_L34:
  ;
}

// fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 617
extern void fc_solve_sfs_move_stack_cards_to_a_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  char tmp_post_1;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    signed int c = 0;
    for( ; !(c >= cards_num); c = c + 1)
    {
      const char card = col[(signed long int)(c + 1)];
      _Bool should_perform_move = (_Bool)1;
      if(!(c == 0))
      {
        char prev_card = col[(signed long int)((c - 1) + 1)];
        if((signed int)prev_card >> 2 == ((signed int)card >> 2) + 1 && !((1 & (signed int)prev_card) == (1 & (signed int)card)))
          should_perform_move = (_Bool)0;

      }

      if(!(should_perform_move == (_Bool)0))
      {
        signed int dc = 0;
        for( ; !(dc >= c + -1); dc = dc + 1)
        {
          char dest_card = col[(signed long int)(dc + 1)];
          if(((signed int)card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)card) == (1 & (signed int)dest_card)))))
          {
            _Bool is_seq_in_dest = (_Bool)0;
            char dest_below_card = col[(signed long int)(dc + 1 + 1)];
            if(((signed int)dest_below_card >> 2) + 1 == (signed int)dest_card >> 2 && (sequences_are_built_by == 2 || (sequences_are_built_by == 1 ? (0x03 & (signed int)dest_below_card) == (0x03 & (signed int)dest_card) : !((1 & (signed int)dest_below_card) == (1 & (signed int)dest_card)))))
              is_seq_in_dest = (_Bool)1;

            if(is_seq_in_dest == (_Bool)0)
            {
              signed int num_cards_to_relocate = (cards_num - dc) - 1;
              signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
              num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
              signed int freestacks_to_fill;
              if(empty_stacks_fill == 0)
              {
                freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
                num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
              }

              else
                freestacks_to_fill = 0;
              if(num_cards_to_relocate == 0)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                char *new_dest_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                signed int cols_indexes[3l];
                cols_indexes[(signed long int)0] = stack_idx;
                cols_indexes[(signed long int)1] = -1;
                cols_indexes[(signed long int)2] = -1;
                signed int last_dest;
                last_dest=empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, cards_num - c, 0);
                signed int source_index = last_dest & 0xFF;
                empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, (c - dc) - 1, 0);
                char moved_card;
                if((last_dest >> 8 & 0x1) == 0)
                {
                  moved_card = pass_new_state.key->freecells[(signed long int)source_index];
                  pass_new_state.key->freecells[(signed long int)source_index] = (char)0;
                  fcs_move_stack_non_seq_push(moves, 2, source_index, stack_idx);
                }

                else
                {
                  char *new_source_col = pass_new_state.key->stacks[(signed long int)source_index];
                  moved_card = new_source_col[(signed long int)(((signed int)new_source_col[(signed long int)0] - 1) + 1)];
                  new_source_col[(signed long int)0] = new_source_col[(signed long int)0] - 1;
                  new_source_col[(signed long int)((signed int)new_source_col[(signed long int)0] + 1)] = (char)0;
                  fcs_push_1card_seq(moves, source_index, stack_idx);
                }
                tmp_post_1 = new_dest_col[(signed long int)0];
                new_dest_col[(signed long int)0] = new_dest_col[(signed long int)0] + 1;
                new_dest_col[(signed long int)((signed int)tmp_post_1 + 1)] = moved_card;
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

        }
      }

    }
  }
  goto __CPROVER_DUMP_L19;

__CPROVER_DUMP_L19:
  ;
}

// fc_solve_sfs_move_stack_cards_to_different_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 775
extern void fc_solve_sfs_move_stack_cards_to_different_stacks(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  const signed int empty_stacks_fill = (signed int)instance->game_params.game_flags >> 2 & 0x3;
  const struct anonymous_14 game_params = instance->game_params;
  const unsigned char num_vacant_freecells = soft_thread->num_vacant_freecells;
  const unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  const signed int initial_derived_states_num_states = derived_states_list->num_states;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, fc_solve_get_the_positions_by_rank_data__freecell_generator);
  signed int stack_idx = 0;
  _Bool tmp_if_expr_1;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    signed int seq_end;
    signed int c = 0;
    for( ; !(c >= (signed int)*col); c = seq_end + 1)
    {
      seq_end = c;
      for( ; !(seq_end >= (signed int)*col + -1); seq_end = seq_end + 1)
      {
        const char this_card = col[(signed long int)(seq_end + 1 + 1)];
        const char prev_card = col[(signed long int)(seq_end + 1)];
        if(!(((signed int)this_card >> 2) + 1 == (signed int)prev_card >> 2) || !(sequences_are_built_by == 2) && !(sequences_are_built_by == 1 ? (0x03 & (signed int)this_card) == (0x03 & (signed int)prev_card) : !((1 & (signed int)this_card) == (1 & (signed int)prev_card))))
          break;

      }
      if(empty_stacks_fill == 2)
      {
        if(c == 0)
          goto __CPROVER_DUMP_L18;

      }

      const char card = col[(signed long int)(c + 1)];
      if(!((signed int)card >> 2 == 13))
      {
        char *pos_idx_to_check = &positions_by_rank[(signed long int)((2 << 3) * ((signed int)card >> 2))];
        char *last_pos_idx = pos_idx_to_check + (signed long int)(2 << 3);
        pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 0 : (sequences_are_built_by == 1 ? (signed int)card & 0x03 : ((signed int)card & 0x03 ^ 0x1) & 0x2 - 1)) << 1);
        for( ; !(pos_idx_to_check >= last_pos_idx); pos_idx_to_check = pos_idx_to_check + (signed long int)((sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? 4 : 2)) << 1))
        {
          const signed int ds = (const signed int)pos_idx_to_check[(signed long int)0];
          if(ds >= 0 && !(ds == stack_idx))
          {
            const signed int dc = (const signed int)pos_idx_to_check[(signed long int)1];
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            signed int num_cards_to_relocate = (((((signed int)dest_col[(signed long int)0] - dc) - 1) + (signed int)col[(signed long int)0]) - seq_end) - 1;
            const signed int freecells_to_fill = num_cards_to_relocate < (signed int)num_vacant_freecells ? num_cards_to_relocate : (signed int)num_vacant_freecells;
            num_cards_to_relocate = num_cards_to_relocate - freecells_to_fill;
            signed int freestacks_to_fill;
            if(empty_stacks_fill == 0)
            {
              freestacks_to_fill = num_cards_to_relocate < (signed int)num_vacant_stacks ? num_cards_to_relocate : (signed int)num_vacant_stacks;
              num_cards_to_relocate = num_cards_to_relocate - freestacks_to_fill;
            }

            else
              freestacks_to_fill = 0;
            if(num_cards_to_relocate == 0)
              tmp_if_expr_1 = (((signed int)instance->game_params.game_flags & 1 << 4) != 0 ? 0x7fffffff : (empty_stacks_fill == 0 ? ((signed int)num_vacant_freecells - freecells_to_fill) + 1 << (signed int)num_vacant_stacks - freestacks_to_fill : ((signed int)num_vacant_freecells - freecells_to_fill) + 1)) >= (seq_end - c) + 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            if(tmp_if_expr_1)
            {
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
              }

              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *fc_solve_sfs_move_stack_cards_to_different_stacks__1__2__1__1__1__4__1__1__3__3__1__copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                fc_solve_sfs_move_stack_cards_to_different_stacks__1__2__1__1__1__4__1__1__3__3__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_move_stack_cards_to_different_stacks__1__2__1__1__1__4__1__1__3__3__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_move_stack_cards_to_different_stacks__1__2__1__1__1__4__1__1__3__3__1__copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              signed int cols_indexes[3l];
              cols_indexes[(signed long int)0] = ds;
              cols_indexes[(signed long int)1] = stack_idx;
              cols_indexes[(signed long int)2] = -1;
              empty_two_cols_from_new_state(soft_thread, &pass_new_state, moves, cols_indexes, ((signed int)dest_col[(signed long int)0] - dc) - 1, ((signed int)col[(signed long int)0] - seq_end) - 1);
              fc_solve_move_sequence_function(&pass_new_state, moves, ds, stack_idx, c, seq_end);
              state_context_value = ((stack_idx << 8 | c) << 8 | ds) << 8 | dc;
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }
      }


    __CPROVER_DUMP_L18:
      ;
    }
  }
  sort_derived_states(derived_states_list, initial_derived_states_num_states);
  goto __CPROVER_DUMP_L21;

__CPROVER_DUMP_L21:
  ;
}

// fc_solve_sfs_move_top_stack_cards_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 66
extern void fc_solve_sfs_move_top_stack_cards_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char *col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(!(cards_num == 0))
    {
      const char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int deck = 0;
      for( ; !(deck >= (signed int)instance->game_params.decks_num); deck = deck + 1)
        if((signed int)raw_ptr_state_raw->key->foundations[(signed long int)(4 * deck + (0x03 & (signed int)card))] == ((signed int)card >> 2) + -1)
        {
          fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char *new_temp_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          new_temp_col[(signed long int)0] = new_temp_col[(signed long int)0] - 1;
          new_temp_col[(signed long int)((signed int)new_temp_col[(signed long int)0] + 1)] = (char)0;
          pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] = pass_new_state.key->foundations[(signed long int)(deck * 4 + ((signed int)card & 0x03))] + 1;
          fcs_move_stack_non_seq_push(moves, 4, stack_idx, deck * 4 + ((signed int)card & 0x03));
          fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
          break;
        }

    }

  }
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// fc_solve_sfs_raymond_prune
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1953
extern signed int fc_solve_sfs_raymond_prune(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct fcs_state_keyval_pair_struct ** const ptr_next_state_val)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  struct anonymous_12 derived_states_list_struct = { .num_states=0, .states=(struct anonymous_43 *)(void *)0 };
  fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
  signed int num_total_cards_moved = 0;
  signed int num_cards_moved;
  do
  {
    num_cards_moved = 0;
    signed int stack_idx = 0;
    for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
    {
      char * const col = pass_new_state.key->stacks[(signed long int)stack_idx];
      const signed int cards_num = (const signed int)col[(signed long int)0];
      if(!(cards_num == 0))
      {
        const char fc_solve_sfs_raymond_prune__1__3__1__1__1__card = col[(signed long int)((cards_num - 1) + 1)];
        signed int fc_solve_sfs_raymond_prune__1__3__1__1__1__dest_foundation;
        fc_solve_sfs_raymond_prune__1__3__1__1__1__dest_foundation=calc_foundation_to_put_card_on(soft_thread, pass_new_state.key, fc_solve_sfs_raymond_prune__1__3__1__1__1__card);
        if(fc_solve_sfs_raymond_prune__1__3__1__1__1__dest_foundation >= 0)
        {
          num_cards_moved = num_cards_moved + 1;
          if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
          {
            char *copy_stack_col;
            pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
            copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
            memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
            pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
          }

          char *new_temp_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          new_temp_col[(signed long int)0] = new_temp_col[(signed long int)0] - 1;
          new_temp_col[(signed long int)((signed int)new_temp_col[(signed long int)0] + 1)] = (char)0;
          pass_new_state.key->foundations[(signed long int)fc_solve_sfs_raymond_prune__1__3__1__1__1__dest_foundation] = pass_new_state.key->foundations[(signed long int)fc_solve_sfs_raymond_prune__1__3__1__1__1__dest_foundation] + 1;
          fcs_move_stack_non_seq_push(moves, 4, stack_idx, fc_solve_sfs_raymond_prune__1__3__1__1__1__dest_foundation);
        }

      }

    }
    signed int fc = 0;
    for( ; !(fc >= (signed int)game_params.freecells_num); fc = fc + 1)
    {
      const char card = pass_new_state.key->freecells[(signed long int)fc];
      if(!((signed int)card >> 2 == 0))
      {
        signed int dest_foundation;
        dest_foundation=calc_foundation_to_put_card_on(soft_thread, pass_new_state.key, card);
        if(dest_foundation >= 0)
        {
          num_cards_moved = num_cards_moved + 1;
          pass_new_state.key->freecells[(signed long int)fc] = (char)0;
          pass_new_state.key->foundations[(signed long int)dest_foundation] = pass_new_state.key->foundations[(signed long int)dest_foundation] + 1;
          fcs_move_stack_non_seq_push(moves, 5, fc, dest_foundation);
        }

      }

    }
    num_total_cards_moved = num_total_cards_moved + num_cards_moved;
  }
  while(!(num_cards_moved == 0));
  fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, &derived_states_list_struct);
  signed int ret_code;
  if(!(num_total_cards_moved == 0))
  {
    struct fcs_state_keyval_pair_struct * const ptr_next_state = (derived_states_list_struct.states + (signed long int)0)->state_ptr;
    *ptr_next_state_val = ptr_next_state;
    ptr_next_state->_anon0._anon0.info.visited = ptr_next_state->_anon0._anon0.info.visited | (unsigned char)16;
    ret_code = 1;
  }

  else
  {
    *ptr_next_state_val = (struct fcs_state_keyval_pair_struct *)(void *)0;
    ret_code = 0;
  }
  free((void *)derived_states_list_struct.states);
  return ret_code;
}

// fc_solve_sfs_simple_simon_move_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 61
extern void fc_solve_sfs_simple_simon_move_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_true_seqs;
      signed int h;
      h=get_seq_h(col, &num_true_seqs);
      if(1 << (signed int)num_vacant_stacks >= num_true_seqs)
      {
        const char card = col[(signed long int)(h + 1)];
        signed int ds = 0;
        for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
          if(!(ds == stack_idx))
          {
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dest_cards_num >= 1)
            {
              if((signed int)dest_col[(signed long int)dest_cards_num] >> 2 == ((signed int)card >> 2) + 1)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  fc_solve_sfs_simple_simon_move_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                fc_solve_move_sequence_function_link1(&pass_new_state, moves, ds, stack_idx, h, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

      }

    }

  }
  goto __CPROVER_DUMP_L13;

__CPROVER_DUMP_L13:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_to_founds
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 45
extern void fc_solve_sfs_simple_simon_move_sequence_to_founds(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 13)
    {
      char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int a = 2;
      for( ; !(a >= 14); a = a + 1)
      {
        const char above_card = col[(signed long int)((cards_num - a) + 1)];
        _Bool return_value_fcs_is_ss_true_parent_1;
        return_value_fcs_is_ss_true_parent_1=fcs_is_ss_true_parent(above_card, card);
        if(return_value_fcs_is_ss_true_parent_1 == (_Bool)0)
          break;

        card = above_card;
      }
      if(a == 14)
      {
        fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
        if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
        {
          char *copy_stack_col;
          pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
          copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
          memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
          pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
        }

        char *new_src_col = pass_new_state.key->stacks[(signed long int)stack_idx];
        a = 0;
        for( ; !(a >= 13); a = a + 1)
        {
          new_src_col[(signed long int)0] = new_src_col[(signed long int)0] - 1;
          new_src_col[(signed long int)((signed int)new_src_col[(signed long int)0] + 1)] = (char)0;
        }
        const signed int suit = (signed int)card & 0x03;
        pass_new_state.key->foundations[(signed long int)suit] = (char)a;
        fcs_move_stack_non_seq_push_link1(moves, 11, stack_idx, suit);
        fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
      }

    }

  }
  goto __CPROVER_DUMP_L12;

__CPROVER_DUMP_L12:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 59
extern void fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  signed int tmp_post_4;
  signed int tmp_if_expr_6;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 3)
    {
      signed int parent_card_height = 0;
      for( ; !(parent_card_height >= cards_num + -2); parent_card_height = parent_card_height + 1)
      {
        const char parent_card = col[(signed long int)(parent_card_height + 1)];
        _Bool return_value_fcs_is_ss_true_parent_1;
        return_value_fcs_is_ss_true_parent_1=fcs_is_ss_true_parent(parent_card, col[(signed long int)(parent_card_height + 1 + 1)]);
        if(return_value_fcs_is_ss_true_parent_1 == (_Bool)0)
        {
          signed int child_card_height = parent_card_height + 2;
          for( ; !(child_card_height >= cards_num); child_card_height = child_card_height + 1)
          {
            _Bool return_value_fcs_is_ss_true_parent_2;
            return_value_fcs_is_ss_true_parent_2=fcs_is_ss_true_parent(parent_card, col[(signed long int)(child_card_height + 1)]);
            if(!(return_value_fcs_is_ss_true_parent_2 == (_Bool)0))
            {
              signed int end_of_child_seq = child_card_height;
              signed int child_num_true_seqs = 1;
              while(!(1 + end_of_child_seq >= cards_num))
              {
                if(!((signed int)col[(signed long int)(1 + end_of_child_seq)] >> 2 == ((signed int)col[(signed long int)(1 + end_of_child_seq)] >> 2) + 1))
                  break;

                _Bool return_value_fcs_is_ss_true_parent_3;
                return_value_fcs_is_ss_true_parent_3=fcs_is_ss_true_parent(col[(signed long int)(end_of_child_seq + 1)], col[(signed long int)(end_of_child_seq + 1 + 1)]);
                child_num_true_seqs = child_num_true_seqs + (signed int)!(return_value_fcs_is_ss_true_parent_3 != (_Bool)0);
                end_of_child_seq = end_of_child_seq + 1;
              }
              struct anonymous_45 seqs;
              populate_seq_points(col, end_of_child_seq, &seqs);
              const signed int child_seq_index = seqs.num_separate_false_seqs;
              seqs.above_num_true_seqs[(signed long int)seqs.num_separate_false_seqs] = child_num_true_seqs;
              tmp_post_4 = seqs.num_separate_false_seqs;
              seqs.num_separate_false_seqs = seqs.num_separate_false_seqs + 1;
              seqs.seq_points[(signed long int)tmp_post_4] = child_card_height;
              generic_populate_seq_points(col, parent_card_height, &seqs, child_card_height);
              _Bool return_value_false_seq_index_loop_5;
              return_value_false_seq_index_loop_5=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, col, &seqs, stack_idx, stack_idx, (const _Bool)0);
              if(!(return_value_false_seq_index_loop_5 == (_Bool)0) && 1 << seqs.after_junk_num_freestacks >= child_num_true_seqs)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                signed int seq_index = 0;
                for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                {
                  const signed int dest_idx = seqs.junk_move_to_stacks[(signed long int)seq_index];
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__6__1__1__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_idx;
                    fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__6__1__1__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__6__1__1__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__6__1__1__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)dest_idx] = &indirect_stacks_buffer[(signed long int)(dest_idx << 7)];
                  }

                  if(seq_index == 0)
                    tmp_if_expr_6 = cards_num - 1;

                  else
                    tmp_if_expr_6 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                  fc_solve_move_sequence_function_link1(&pass_new_state, moves, dest_idx, stack_idx, seqs.seq_points[(signed long int)seq_index], tmp_if_expr_6);
                }
                const signed int source_idx = seqs.junk_move_to_stacks[(signed long int)child_seq_index];
                char * const move_junk_to_col = pass_new_state.key->stacks[(signed long int)source_idx];
                const signed int end = (signed int)move_junk_to_col[(signed long int)0] - 1;
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << source_idx) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__7__1__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << source_idx;
                  fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__7__1__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)source_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(source_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__7__1__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_parent_on_the_same_stack__1__2__1__2__1__2__1__7__1__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)source_idx] = &indirect_stacks_buffer[(signed long int)(source_idx << 7)];
                }

                fc_solve_move_sequence_function_link1(&pass_new_state, moves, stack_idx, source_idx, end - (end_of_child_seq - child_card_height), end);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }
        }

      }
    }

  }
  goto __CPROVER_DUMP_L22;

__CPROVER_DUMP_L22:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 47
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int num_true_seqs = 1;
      signed int h = cards_num - 2;
      for( ; h >= -1; h = h - 1)
      {
        if(!((signed int)card >> 2 >= 13))
        {
          const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
          if(!(ds == stack_idx))
          {
            const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dc == dest_cards_num + -1)
            {
              fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
              {
                char *fc_solve_sfs_simple_simon_move_sequence_to_true_parent__1__2__1__2__1__1__1__1__2__1__copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                fc_solve_sfs_simple_simon_move_sequence_to_true_parent__1__2__1__2__1__1__1__1__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_true_parent__1__2__1__2__1__1__1__1__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_true_parent__1__2__1__2__1__1__1__1__2__1__copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
              }

              if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
              {
                char *copy_stack_col;
                pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
              }

              fc_solve_move_sequence_function_link1(&pass_new_state, moves, ds, stack_idx, h + 1, cards_num - 1);
              fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
            }

          }

        }

        if(h == -1)
          break;

        const char prev_card = card;
        card = col[(signed long int)(h + 1)];
        if(!((signed int)card >> 2 == ((signed int)prev_card >> 2) + 1))
          break;

        _Bool return_value_fcs_is_ss_suit_true_1;
        return_value_fcs_is_ss_suit_true_1=fcs_is_ss_suit_true(card, prev_card);
        if(return_value_fcs_is_ss_suit_true_1 == (_Bool)0)
        {
          num_true_seqs = num_true_seqs + 1;
          if(!(1 << (signed int)num_vacant_stacks >= num_true_seqs))
            break;

        }

      }
    }

  }
}

// fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 51
extern void fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  _Bool return_value_fcs_is_ss_suit_true_1;
  _Bool tmp_statement_expression_3;
  signed int tmp_if_expr_2;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      char card = col[(signed long int)((cards_num - 1) + 1)];
      signed int num_true_seqs = 1;
      signed int h = cards_num - 2;
      for( ; h >= -1; h = h - 1)
      {
        char h_above_card;
        _Bool should_search = (_Bool)1;
        _Bool should_increment_num_true_seqs = (_Bool)0;
        _Bool should_break = (_Bool)0;
        if(h == -1)
          should_break = (_Bool)1;

        else
        {
          h_above_card = col[(signed long int)(h + 1)];
          if(!((signed int)h_above_card >> 2 == ((signed int)card >> 2) + 1))
            should_break = (_Bool)1;

          else
          {
            return_value_fcs_is_ss_suit_true_1=fcs_is_ss_suit_true(h_above_card, card);
            should_search = !(return_value_fcs_is_ss_suit_true_1 != (_Bool)0);
            if(!(should_search == (_Bool)0))
              should_increment_num_true_seqs = (_Bool)1;

          }
        }
        if(!(should_search == (_Bool)0))
        {
          if(!((signed int)card >> 2 >= 13))
          {
            const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
            if(!(ds == stack_idx))
            {
              const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
              char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
              const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
              struct anonymous_45 seqs;
              populate_seq_points(dest_col, dc, &seqs);
              tmp_statement_expression_3=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, dest_col, &seqs, stack_idx, ds, (const _Bool)0);
              if(!(tmp_statement_expression_3 == (_Bool)0))
              {
                if(1 << seqs.after_junk_num_freestacks >= num_true_seqs)
                {
                  fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                    fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                  }

                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                    fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_to_true_parent_with_some_cards_above__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                  }

                  signed int seq_index = 0;
                  for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                  {
                    const signed int dest_index = seqs.junk_move_to_stacks[(signed long int)seq_index];
                    if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_index) == 0)
                    {
                      char *copy_stack_col;
                      pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_index;
                      copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_index];
                      memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_index << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                      pass_new_state.key->stacks[(signed long int)dest_index] = &indirect_stacks_buffer[(signed long int)(dest_index << 7)];
                    }

                    if(seq_index == 0)
                      tmp_if_expr_2 = dest_cards_num - 1;

                    else
                      tmp_if_expr_2 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                    fc_solve_move_sequence_function_link1(&pass_new_state, moves, dest_index, ds, seqs.seq_points[(signed long int)seq_index], tmp_if_expr_2);
                  }
                  fc_solve_move_sequence_function_link1(&pass_new_state, moves, ds, stack_idx, h + 1, cards_num - 1);
                  fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
                }

              }

            }

          }

        }

        if(should_break != (_Bool)0)
          break;

        if(!(should_increment_num_true_seqs == (_Bool)0))
          num_true_seqs = num_true_seqs + 1;

        card = h_above_card;
      }
    }

  }
  goto __CPROVER_DUMP_L22;

__CPROVER_DUMP_L22:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 55
extern void fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  signed int tmp_if_expr_2;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_src_junk_true_seqs = 1;
      signed int h;
      h=get_seq_h(col, &num_src_junk_true_seqs);
      if(!(h == 0))
      {
        char card = col[(signed long int)(h + 1)];
        signed int end_of_junk;
        h = h - 1;
        end_of_junk = h;
        signed int num_true_seqs = 1;
        for( ; h >= 0; h = h - 1)
        {
          const char next_card = col[(signed long int)(h + 1)];
          if(!((signed int)next_card >> 2 == ((signed int)card >> 2) + 1))
          {
            card = next_card;
            break;
          }

          _Bool return_value_fcs_is_ss_suit_true_1;
          return_value_fcs_is_ss_suit_true_1=fcs_is_ss_suit_true(next_card, card);
          if(return_value_fcs_is_ss_suit_true_1 == (_Bool)0)
            num_true_seqs = num_true_seqs + 1;

          card = next_card;
        }
        if(!((signed int)card >> 2 >= 13))
        {
          const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
          if(!(ds == stack_idx))
          {
            const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)card & 0x03) * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dest_cards_num + -2 >= dc)
            {
              struct anonymous_45 seqs;
              populate_seq_points(dest_col, dc, &seqs);
              _Bool verdict;
              verdict=generic_false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, dest_col, &seqs, stack_idx, ds, (const _Bool)0, (const _Bool)1, col[(signed long int)(end_of_junk + 1 + 1)], num_src_junk_true_seqs);
              if(1 << seqs.after_junk_num_freestacks >= num_true_seqs && !(verdict == (_Bool)0))
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__2__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__2__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__3__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__3__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__3__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__3__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                signed int seq_index = 0;
                for( ; !(seq_index >= 1 + seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                {
                  signed int start;
                  signed int end;
                  signed int src_stack;
                  if(seq_index == seqs.num_separate_false_seqs)
                  {
                    start = end_of_junk + 1;
                    end = cards_num - 1;
                    src_stack = stack_idx;
                  }

                  else
                  {
                    start = seqs.seq_points[(signed long int)seq_index];
                    if(seq_index == 0)
                      tmp_if_expr_2 = dest_cards_num - 1;

                    else
                      tmp_if_expr_2 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                    end = tmp_if_expr_2;
                    src_stack = ds;
                  }
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << src_stack) == 0)
                  {
                    char *copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << src_stack;
                    copy_stack_col = pass_new_state.key->stacks[(signed long int)src_stack];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(src_stack << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)src_stack] = &indirect_stacks_buffer[(signed long int)(src_stack << 7)];
                  }

                  const signed int dest_index = seqs.junk_move_to_stacks[(signed long int)seq_index];
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_index) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__4__1__4__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_index;
                    fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__4__1__4__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_index];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_index << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__4__1__4__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_junk_seq_above_to_true_parent_with_some_cards_above__1__2__1__4__1__1__1__4__1__4__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)dest_index] = &indirect_stacks_buffer[(signed long int)(dest_index << 7)];
                  }

                  fc_solve_move_sequence_function_link1(&pass_new_state, moves, dest_index, src_stack, start, end);
                }
                fc_solve_move_sequence_function_link1(&pass_new_state, moves, ds, stack_idx, h, end_of_junk);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

        }

      }

    }

  }
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L24:
  ;
}

// fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 53
extern void fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  _Bool tmp_statement_expression_3;
  signed int tmp_if_expr_2;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int src_card_height = cards_num - 1;
      for( ; src_card_height >= 0; src_card_height = src_card_height - 1)
      {
        signed int end_of_src_seq;
        const char h_card = col[(signed long int)(src_card_height + 1)];
        char card = h_card;
        signed int num_true_seqs = 1;
        end_of_src_seq = src_card_height + 1;
        for( ; !(end_of_src_seq >= cards_num); end_of_src_seq = end_of_src_seq + 1)
        {
          const char above_card = col[(signed long int)(end_of_src_seq + 1)];
          if(!((signed int)card >> 2 == ((signed int)above_card >> 2) + 1))
            break;

          _Bool return_value_fcs_is_ss_suit_true_1;
          return_value_fcs_is_ss_suit_true_1=fcs_is_ss_suit_true(card, above_card);
          if(return_value_fcs_is_ss_suit_true_1 == (_Bool)0)
            num_true_seqs = num_true_seqs + 1;

          card = above_card;
        }
        if(!(end_of_src_seq == cards_num))
        {
          if(!((signed int)h_card >> 2 >= 13))
          {
            const signed int ds = (const signed int)positions_by_rank[(signed long int)((((signed int)h_card & 0x03) * (13 + 1) + ((signed int)h_card >> 2) + 1) * 2)];
            if(!(ds == stack_idx))
            {
              const signed int dc = (const signed int)positions_by_rank[(signed long int)((((signed int)h_card & 0x03) * (13 + 1) + ((signed int)h_card >> 2) + 1) * 2 + 1)];
              char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
              const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
              if(dc == dest_cards_num + -1)
              {
                struct anonymous_45 seqs;
                populate_seq_points(col, end_of_src_seq - 1, &seqs);
                tmp_statement_expression_3=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, col, &seqs, stack_idx, ds, (const _Bool)0);
                if(!(tmp_statement_expression_3 == (_Bool)0))
                {
                  if(!(num_true_seqs >= 1 << seqs.after_junk_num_freestacks))
                  {
                    fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                    if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                    {
                      char *fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col;
                      pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                      fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                      memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__2__1__copy_stack_col[(signed long int)0] + 1));
                      pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                    }

                    if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                    {
                      char *fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col;
                      pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                      fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                      memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_sequence_with_some_cards_above_to_true_parent__1__2__1__2__1__3__1__1__2__3__1__copy_stack_col[(signed long int)0] + 1));
                      pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                    }

                    signed int seq_index = 0;
                    for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                    {
                      const signed int dest_index = seqs.junk_move_to_stacks[(signed long int)seq_index];
                      if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_index) == 0)
                      {
                        char *copy_stack_col;
                        pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_index;
                        copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_index];
                        memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_index << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                        pass_new_state.key->stacks[(signed long int)dest_index] = &indirect_stacks_buffer[(signed long int)(dest_index << 7)];
                      }

                      if(seq_index == 0)
                        tmp_if_expr_2 = cards_num - 1;

                      else
                        tmp_if_expr_2 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                      fc_solve_move_sequence_function_link1(&pass_new_state, moves, dest_index, stack_idx, seqs.seq_points[(signed long int)seq_index], tmp_if_expr_2);
                    }
                    fc_solve_move_sequence_function_link1(&pass_new_state, moves, ds, stack_idx, src_card_height, end_of_src_seq - 1);
                    fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
                  }

                }

              }

            }

          }

        }

      }
    }

  }
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L23:
  ;
}

// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 49
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  signed int stack_idx = 0;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_true_seqs;
      signed int h;
      h=get_seq_h(col, &num_true_seqs);
      if(!(h >= 1) && 1 << (signed int)num_vacant_stacks >= num_true_seqs)
      {
        const char card = col[(signed long int)(h + 1)];
        signed int ds = 0;
        for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
          if(!(ds == stack_idx))
          {
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            if(dest_cards_num >= 1)
            {
              const char dest_card = dest_col[(signed long int)((dest_cards_num - 1) + 1)];
              if((signed int)dest_card >> 2 == ((signed int)card >> 2) + 1)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << ds;
                  fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent__1__2__1__3__1__6__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)ds] = &indirect_stacks_buffer[(signed long int)(ds << 7)];
                }

                fc_solve_move_sequence_function_link1(&pass_new_state, moves, ds, stack_idx, h, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }

      }

    }

  }
  goto __CPROVER_DUMP_L13;

__CPROVER_DUMP_L13:
  ;
}

// fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.h line 57
extern void fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct anonymous_3 * const moves = &hard_thread->reusable_move_stack;
  signed int state_context_value = 0;
  struct anonymous_6 pass_new_state;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  char *indirect_stacks_buffer = hard_thread->indirect_stacks_buffer;
  const struct anonymous_14 game_params = instance->game_params;
  unsigned char num_vacant_stacks = soft_thread->num_vacant_stacks;
  char *positions_by_rank;
  positions_by_rank=fc_solve_get_the_positions_by_rank_data(soft_thread, raw_ptr_state_raw->key, get_the_positions_by_rank_data__ss_generator);
  signed int stack_idx = 0;
  _Bool tmp_statement_expression_2;
  signed int tmp_if_expr_3;
  for( ; !(stack_idx >= (signed int)game_params.stacks_num); stack_idx = stack_idx + 1)
  {
    char * const col = raw_ptr_state_raw->key->stacks[(signed long int)stack_idx];
    const signed int cards_num = (const signed int)col[(signed long int)0];
    if(cards_num >= 1)
    {
      signed int num_true_seqs;
      signed int return_value_get_seq_h_1;
      return_value_get_seq_h_1=get_seq_h(col, &num_true_seqs);
      if(return_value_get_seq_h_1 == 0)
      {
        char card = col[(signed long int)(0 + 1)];
        if(!((signed int)card >> 2 == 13))
        {
          struct anonymous_46 ds_dcs[4l];
          signed int len = 0;
          signed int parent_suit = 0;
          for( ; !(parent_suit >= 4); parent_suit = parent_suit + 1)
          {
            const signed int ds = (const signed int)positions_by_rank[(signed long int)((parent_suit * (13 + 1) + ((signed int)card >> 2) + 1) * 2)];
            if(!(ds == stack_idx) && ds >= 0)
            {
              const signed int dc = (const signed int)positions_by_rank[(signed long int)((parent_suit * (13 + 1) + ((signed int)card >> 2) + 1) * 2 + 1)];
              ds_dcs[(signed long int)len].ds = ds;
              ds_dcs[(signed long int)len].dc = dc;
              len = len + 1;
            }

          }
          sort_ds_dcs(ds_dcs, len);
          signed int i = 0;
          for( ; !(i >= len); i = i + 1)
          {
            const signed int fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds = ds_dcs[(signed long int)i].ds;
            const signed int fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__dc = ds_dcs[(signed long int)i].dc;
            char * const dest_col = raw_ptr_state_raw->key->stacks[(signed long int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds];
            const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
            struct anonymous_45 seqs;
            populate_seq_points(dest_col, fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__dc, &seqs);
            tmp_statement_expression_2=false_seq_index_loop((const signed int)game_params.stacks_num, raw_ptr_state_raw, (signed int)num_vacant_stacks, dest_col, &seqs, stack_idx, fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds, (const _Bool)1);
            if(!(tmp_statement_expression_2 == (_Bool)0))
            {
              if(1 << (signed int)num_vacant_stacks >= num_true_seqs)
              {
                fc_solve_sfs_check_state_begin(hard_thread, &pass_new_state, raw_ptr_state_raw, moves);
                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << stack_idx) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__5__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << stack_idx;
                  fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__5__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)stack_idx];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__5__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__5__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)stack_idx] = &indirect_stacks_buffer[(signed long int)(stack_idx << 7)];
                }

                if((pass_new_state.val->stacks_copy_on_write_flags & 1 << fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds) == 0)
                {
                  char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__6__1__copy_stack_col;
                  pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds;
                  fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__6__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds];
                  memcpy((void *)&indirect_stacks_buffer[(signed long int)(fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__6__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__6__1__copy_stack_col[(signed long int)0] + 1));
                  pass_new_state.key->stacks[(signed long int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds] = &indirect_stacks_buffer[(signed long int)(fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds << 7)];
                }

                signed int seq_index = 0;
                for( ; !(seq_index >= seqs.num_separate_false_seqs); seq_index = seq_index + 1)
                {
                  const signed int src_stack_idx = fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds;
                  const signed int dest_stack_idx = seqs.junk_move_to_stacks[(signed long int)seq_index];
                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << src_stack_idx) == 0)
                  {
                    char *copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << src_stack_idx;
                    copy_stack_col = pass_new_state.key->stacks[(signed long int)src_stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(src_stack_idx << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)src_stack_idx] = &indirect_stacks_buffer[(signed long int)(src_stack_idx << 7)];
                  }

                  if((pass_new_state.val->stacks_copy_on_write_flags & 1 << dest_stack_idx) == 0)
                  {
                    char *fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__7__1__2__1__copy_stack_col;
                    pass_new_state.val->stacks_copy_on_write_flags = pass_new_state.val->stacks_copy_on_write_flags | 1 << dest_stack_idx;
                    fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__7__1__2__1__copy_stack_col = pass_new_state.key->stacks[(signed long int)dest_stack_idx];
                    memcpy((void *)&indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)], (const void *)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__7__1__2__1__copy_stack_col, (unsigned long int)((signed int)fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__7__1__2__1__copy_stack_col[(signed long int)0] + 1));
                    pass_new_state.key->stacks[(signed long int)dest_stack_idx] = &indirect_stacks_buffer[(signed long int)(dest_stack_idx << 7)];
                  }

                  if(seq_index == 0)
                    tmp_if_expr_3 = dest_cards_num - 1;

                  else
                    tmp_if_expr_3 = seqs.seq_points[(signed long int)(seq_index - 1)] - 1;
                  fc_solve_move_sequence_function_link1(&pass_new_state, moves, dest_stack_idx, src_stack_idx, seqs.seq_points[(signed long int)seq_index], tmp_if_expr_3);
                }
                fc_solve_move_sequence_function_link1(&pass_new_state, moves, fc_solve_sfs_simple_simon_move_whole_stack_sequence_to_false_parent_with_some_cards_above__1__2__1__5__1__ds, stack_idx, 0, cards_num - 1);
                fc_solve_sfs_check_state_end(soft_thread, raw_ptr_state_raw, &pass_new_state, state_context_value, moves, derived_states_list);
              }

            }

          }
        }

      }

    }

  }
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L24:
  ;
}

// fc_solve_sfs_yukon_do_nothing
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 1429
extern void fc_solve_sfs_yukon_do_nothing(struct fc_solve_soft_thread_struct * const soft_thread, struct anonymous_6 * const raw_ptr_state_raw, struct anonymous_12 * const derived_states_list)
{
  ;
}

// fc_solve_soft_dfs_do_solve
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1210
extern signed int fc_solve_soft_dfs_do_solve(struct fc_solve_soft_thread_struct * const soft_thread)
{
  struct fc_solve_hard_thread_struct * const hard_thread = soft_thread->hard_thread;
  struct fc_solve_instance_struct * const instance = hard_thread->instance;
  struct fcs_state_keyval_pair_struct *ptr_state_raw;
  struct anonymous_6 pass;
  signed int by_depth_max_depth;
  signed int by_depth_min_depth;
  const unsigned char calc_real_depth = (const unsigned char)((signed int)instance->runtime_flags & 4);
  const unsigned char scans_synergy = (const unsigned char)((signed int)instance->runtime_flags & 64);
  const unsigned char is_a_complete_scan = (const unsigned char)((signed int)soft_thread->runtime_flags & 2);
  const signed int soft_thread_id = soft_thread->id;
  const struct anonymous_16 *the_tests_list_ptr;
  enum anonymous_22 local_shuffling_type = (enum anonymous_22)FCS_NO_SHUFFLING;
  signed long int hard_thread_max_num_checked_states;
  const struct anonymous_14 game_params = instance->game_params;
  signed int * const depth_ptr = &soft_thread->method_specific.soft_dfs.depth;
  struct anonymous_50 *the_soft_dfs_info = &soft_thread->method_specific.soft_dfs.soft_dfs_info[(signed long int)*depth_ptr];
  signed int dfs_max_depth = soft_thread->method_specific.soft_dfs.dfs_max_depth;
  _Bool enable_pruning = soft_thread->enable_pruning;
  ptr_state_raw = the_soft_dfs_info->state;
  if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    pass.key = &ptr_state_raw->_anon0._anon0.s;
    pass.val = &ptr_state_raw->_anon0._anon0.info;
  }

  struct anonymous_12 *derived_states_list = &the_soft_dfs_info->derived_states_list;
  signed long int * const rand_gen = &soft_thread->method_specific.soft_dfs.rand_gen;
  calculate_real_depth((const _Bool)calc_real_depth, ptr_state_raw);
  struct anonymous_52 *by_depth_units = soft_thread->method_specific.soft_dfs.tests_by_depth_array.by_depth_units;
  signed long int * const instance_num_checked_states_ptr = &instance->num_checked_states;
  signed long int * const hard_thread_num_checked_states_ptr = &hard_thread->num_checked_states;
  hard_thread_max_num_checked_states = hard_thread->max_num_checked_states;
  signed long int lim = hard_thread->num_checked_states + (instance->effective_max_num_checked_states - *instance_num_checked_states_ptr);
  hard_thread_max_num_checked_states = hard_thread_max_num_checked_states < lim ? hard_thread_max_num_checked_states : lim;
  void (* const debug_iter_output_func)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int) = instance->debug_iter_output_func;
  void * const debug_iter_output_context = instance->debug_iter_output_context;
  struct anonymous_52 *curr_by_depth_unit = by_depth_units;
  for( ; *depth_ptr >= curr_by_depth_unit->max_depth; curr_by_depth_unit = curr_by_depth_unit + 1l)
    ;
  by_depth_max_depth = curr_by_depth_unit->max_depth;
  signed int tmp_if_expr_1;
  if(curr_by_depth_unit == by_depth_units)
    tmp_if_expr_1 = 0;

  else
    tmp_if_expr_1 = (curr_by_depth_unit - (signed long int)1)->max_depth;
  by_depth_min_depth = tmp_if_expr_1;
  the_tests_list_ptr = &curr_by_depth_unit->tests;
  signed int tmp_if_expr_2;
  signed long int tmp_if_expr_3;
  struct anonymous_25 *tmp_post_7;
  struct anonymous_25 *tmp_post_10;
  signed int tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  while((_Bool)1)
  {
    if(1 + *depth_ptr >= dfs_max_depth)
    {
      fc_solve_increase_dfs_max_depth(soft_thread);
      the_soft_dfs_info = &soft_thread->method_specific.soft_dfs.soft_dfs_info[(signed long int)*depth_ptr];
      dfs_max_depth = soft_thread->method_specific.soft_dfs.dfs_max_depth;
      derived_states_list = &the_soft_dfs_info->derived_states_list;
    }

    if(the_soft_dfs_info->current_state_index == derived_states_list->num_states)
    {
      if(the_soft_dfs_info->tests_list_index == the_tests_list_ptr->num_lists)
      {
        if(!(is_a_complete_scan == 0))
        {
          ptr_state_raw->_anon0._anon0.info.visited = ptr_state_raw->_anon0._anon0.info.visited | (unsigned char)8;
          mark_as_dead_end((const _Bool)scans_synergy, ptr_state_raw);
        }

        free((void *)the_soft_dfs_info->positions_by_rank);
        *depth_ptr = *depth_ptr - 1;
        if(!(*depth_ptr >= 0))
          break;

        else
        {
          the_soft_dfs_info = the_soft_dfs_info - 1l;
          derived_states_list = &the_soft_dfs_info->derived_states_list;
          ptr_state_raw = the_soft_dfs_info->state;
          if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
          {
            pass.key = &ptr_state_raw->_anon0._anon0.s;
            pass.val = &ptr_state_raw->_anon0._anon0.info;
          }

          soft_thread->num_vacant_freecells = the_soft_dfs_info->num_vacant_freecells;
          soft_thread->num_vacant_stacks = the_soft_dfs_info->num_vacant_stacks;
          if(!(*depth_ptr >= by_depth_min_depth))
          {
            curr_by_depth_unit = curr_by_depth_unit - 1l;
            by_depth_max_depth = curr_by_depth_unit->max_depth;
            if(curr_by_depth_unit == by_depth_units)
              tmp_if_expr_2 = 0;

            else
              tmp_if_expr_2 = (curr_by_depth_unit - (signed long int)1)->max_depth;
            by_depth_min_depth = tmp_if_expr_2;
            the_tests_list_ptr = &curr_by_depth_unit->tests;
          }

        }
        continue;
      }

      derived_states_list->num_states = 0;
      if(the_soft_dfs_info->test_index == 0)
      {
        if(the_soft_dfs_info->tests_list_index == 0)
        {
          unsigned char num_vacant_stacks;
          unsigned char num_vacant_freecells;
          if(!(debug_iter_output_func == ((void (*)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int))NULL)))
          {
            if(*depth_ptr == 0)
              tmp_if_expr_3 = (signed long int)0;

            else
              tmp_if_expr_3 = (soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)(*depth_ptr - 1))->state->_anon0._anon0.info.visited_iter;
            debug_iter_output_func(debug_iter_output_context, *instance_num_checked_states_ptr, *depth_ptr, (void *)instance, &pass, tmp_if_expr_3);
          }

          num_vacant_freecells=count_num_vacant_freecells(game_params.freecells_num, &ptr_state_raw->_anon0._anon0.s);
          num_vacant_stacks=count_num_vacant_stacks(game_params.stacks_num, &ptr_state_raw->_anon0._anon0.s);
          if(num_vacant_freecells == game_params.freecells_num && num_vacant_stacks == game_params.stacks_num)
          {
            instance->final_state = ptr_state_raw;
            *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
            *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
            return 0;
          }

          the_soft_dfs_info->num_vacant_freecells = num_vacant_freecells;
          soft_thread->num_vacant_freecells = the_soft_dfs_info->num_vacant_freecells;
          the_soft_dfs_info->num_vacant_stacks = num_vacant_stacks;
          soft_thread->num_vacant_stacks = the_soft_dfs_info->num_vacant_stacks;
          if(!(enable_pruning == (_Bool)0))
          {
            if((16 & (signed int)ptr_state_raw->_anon0._anon0.info.visited) == 0)
            {
              struct fcs_state_keyval_pair_struct *derived;
              signed int return_value_fc_solve_sfs_raymond_prune_5;
              return_value_fc_solve_sfs_raymond_prune_5=fc_solve_sfs_raymond_prune(soft_thread, &pass, &derived);
              if(return_value_fc_solve_sfs_raymond_prune_5 == 1)
              {
                the_soft_dfs_info->tests_list_index = the_tests_list_ptr->num_lists;
                fc_solve_derived_states_list_add_state(derived_states_list, derived, 0);
                if(!(the_soft_dfs_info->derived_states_random_indexes_max_size >= 1))
                {
                  the_soft_dfs_info->derived_states_random_indexes_max_size = 1;
                  void *return_value_realloc_4;
                  return_value_realloc_4=realloc((void *)the_soft_dfs_info->derived_states_random_indexes, sizeof(struct anonymous_25) /*8ul*/  * (unsigned long int)the_soft_dfs_info->derived_states_random_indexes_max_size);
                  the_soft_dfs_info->derived_states_random_indexes = (struct anonymous_25 *)return_value_realloc_4;
                }

                (the_soft_dfs_info->derived_states_random_indexes + (signed long int)0)->idx = 0;
              }

            }

          }

        }

      }

      const signed int orig_tests_list_index = the_soft_dfs_info->tests_list_index;
      const struct anonymous_15 * const weighting = &(the_tests_list_ptr->lists + (signed long int)orig_tests_list_index)->weighting;
      if(!(the_soft_dfs_info->tests_list_index >= the_tests_list_ptr->num_lists))
      {
        local_shuffling_type = (enum anonymous_22)(the_tests_list_ptr->lists + (signed long int)the_soft_dfs_info->tests_list_index)->shuffling_type;
        (the_tests_list_ptr->lists + (signed long int)the_soft_dfs_info->tests_list_index)->tests[(signed long int)the_soft_dfs_info->test_index](soft_thread, &pass, derived_states_list);
        the_soft_dfs_info->test_index = the_soft_dfs_info->test_index + 1;
        if(the_soft_dfs_info->test_index == (the_tests_list_ptr->lists + (signed long int)the_soft_dfs_info->tests_list_index)->num_tests)
        {
          the_soft_dfs_info->tests_list_index = the_soft_dfs_info->tests_list_index + 1;
          the_soft_dfs_info->test_index = 0;
        }

      }

      signed int a;
      signed int j;
      struct anonymous_25 swap_save;
      struct anonymous_25 *rand_array;
      struct anonymous_25 *ra_ptr;
      signed int num_states = derived_states_list->num_states;
      if(!(the_soft_dfs_info->derived_states_random_indexes_max_size >= num_states))
      {
        the_soft_dfs_info->derived_states_random_indexes_max_size = num_states;
        void *return_value_realloc_6;
        return_value_realloc_6=realloc((void *)the_soft_dfs_info->derived_states_random_indexes, sizeof(struct anonymous_25) /*8ul*/  * (unsigned long int)the_soft_dfs_info->derived_states_random_indexes_max_size);
        the_soft_dfs_info->derived_states_random_indexes = (struct anonymous_25 *)return_value_realloc_6;
      }

      rand_array = the_soft_dfs_info->derived_states_random_indexes;
      a = 0;
      ra_ptr = rand_array;
      for( ; !(a >= num_states); a = a + 1)
      {
        tmp_post_7 = ra_ptr;
        ra_ptr = ra_ptr + 1l;
        tmp_post_7->idx = a;
      }
      if(num_states >= 2)
        switch((signed int)local_shuffling_type)
        {
          case FCS_RAND:
          {
            a = num_states - 1;
            while(a >= 1)
            {
              signed int return_value_fc_solve_rand_get_random_number_8;
              return_value_fc_solve_rand_get_random_number_8=fc_solve_rand_get_random_number(rand_gen);
              j = return_value_fc_solve_rand_get_random_number_8 % (a + 1);
              swap_save = rand_array[(signed long int)a];
              rand_array[(signed long int)a] = rand_array[(signed long int)j];
              rand_array[(signed long int)j] = swap_save;
              a = a - 1;
            }
            break;
          }
          case FCS_WEIGHTING:
            if(!(orig_tests_list_index >= the_tests_list_ptr->num_lists))
            {
              struct anonymous_43 *fc_solve_soft_dfs_do_solve__1__6__3__6__4__1__2__1__derived_states = derived_states_list->states;
              a = 0;
              for( ; !(a >= num_states); a = a + 1)
              {
                signed int return_value_calc_depth_9;
                return_value_calc_depth_9=calc_depth((fc_solve_soft_dfs_do_solve__1__6__3__6__4__1__2__1__derived_states + (signed long int)(rand_array + (signed long int)a)->idx)->state_ptr);
                (rand_array + (signed long int)a)->rating=befs_rate_state(soft_thread, weighting, &(fc_solve_soft_dfs_do_solve__1__6__3__6__4__1__2__1__derived_states + (signed long int)(rand_array + (signed long int)a)->idx)->state_ptr->_anon0._anon0.s, 20000 - return_value_calc_depth_9);
              }
              qsort((void *)rand_array, (unsigned long int)num_states, sizeof(struct anonymous_25) /*8ul*/ , compare_rating_with_index);
            }

          case FCS_NO_SHUFFLING:

          default:
            ;
        }

      the_soft_dfs_info->current_state_index = 0;
    }

    signed int fc_solve_soft_dfs_do_solve__1__6__4__num_states = derived_states_list->num_states;
    struct anonymous_43 *derived_states = derived_states_list->states;
    struct anonymous_25 *rand_int_ptr = the_soft_dfs_info->derived_states_random_indexes + (signed long int)the_soft_dfs_info->current_state_index;
    struct fcs_state_keyval_pair_struct *single_derived_state;
    while(!(the_soft_dfs_info->current_state_index >= fc_solve_soft_dfs_do_solve__1__6__4__num_states))
    {
      tmp_post_10 = rand_int_ptr;
      rand_int_ptr = rand_int_ptr + 1l;
      single_derived_state = (derived_states + (signed long int)tmp_post_10->idx)->state_ptr;
      the_soft_dfs_info->current_state_index = the_soft_dfs_info->current_state_index + 1;
      if((4 & (signed int)single_derived_state->_anon0._anon0.info.visited) == 0)
      {
        if((1 << (7 & soft_thread_id) & (signed int)single_derived_state->_anon0._anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)]) == 0)
        {
          *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
          *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
          single_derived_state->_anon0._anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] = single_derived_state->_anon0._anon0.info.scan_visited[(signed long int)(soft_thread_id >> 3)] | (unsigned char)(1 << (soft_thread_id & (1 << 3) - 1));
          single_derived_state->_anon0._anon0.info.visited_iter = instance->num_checked_states;
          *depth_ptr = *depth_ptr + 1;
          if(*depth_ptr >= by_depth_max_depth)
          {
            curr_by_depth_unit = curr_by_depth_unit + 1l;
            by_depth_max_depth = curr_by_depth_unit->max_depth;
            if(curr_by_depth_unit == by_depth_units)
              tmp_if_expr_11 = 0;

            else
              tmp_if_expr_11 = (curr_by_depth_unit - (signed long int)1)->max_depth;
            by_depth_min_depth = tmp_if_expr_11;
            the_tests_list_ptr = &curr_by_depth_unit->tests;
          }

          the_soft_dfs_info = the_soft_dfs_info + 1l;
          ptr_state_raw = single_derived_state;
          if(!(ptr_state_raw == ((struct fcs_state_keyval_pair_struct *)NULL)))
          {
            pass.key = &ptr_state_raw->_anon0._anon0.s;
            pass.val = &ptr_state_raw->_anon0._anon0.info;
          }

          the_soft_dfs_info->state = ptr_state_raw;
          the_soft_dfs_info->tests_list_index = 0;
          the_soft_dfs_info->test_index = 0;
          the_soft_dfs_info->current_state_index = 0;
          the_soft_dfs_info->positions_by_rank = (char *)(void *)0;
          derived_states_list = &the_soft_dfs_info->derived_states_list;
          derived_states_list->num_states = 0;
          calculate_real_depth((const _Bool)calc_real_depth, ptr_state_raw);
          if(instance->active_num_states_in_collection >= instance->effective_trim_states_in_collection_from)
            free_states(instance);

          if(*hard_thread_num_checked_states_ptr == hard_thread_max_num_checked_states)
            tmp_if_expr_12 = (_Bool)1;

          else
            tmp_if_expr_12 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_12)
            return 5;

          break;
        }

      }

    }
  }
  *instance_num_checked_states_ptr = *instance_num_checked_states_ptr + 1l;
  *hard_thread_num_checked_states_ptr = *hard_thread_num_checked_states_ptr + 1l;
  *depth_ptr = -1;
  return 1;
}

// fc_solve_soft_thread_init_befs_or_bfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1212
extern void fc_solve_soft_thread_init_befs_or_bfs(struct fc_solve_soft_thread_struct *soft_thread)
{
  fc_solve_soft_thread_update_initial_cards_val_link1(soft_thread);
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  if(soft_thread->method == 3)
  {
    fc_solve_PQueueInitialise(&soft_thread->method_specific.befs.meth.befs.pqueue, 1024);
    fc_solve_initialize_befs_rater_link1(soft_thread, &soft_thread->method_specific.befs.meth.befs.weighting);
  }

  else
    fc_solve_initialize_bfs_queue(soft_thread);
  if(soft_thread->method_specific.befs.tests_list == ((void (**)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *))NULL))
  {
    signed int num = 0;
    void (**tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(void (*)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *)) /*8ul*/  * (unsigned long int)1);
    tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *))return_value_malloc_1;
    signed int group_idx = 0;
    for( ; !(group_idx >= soft_thread->by_depth_tests_order.by_depth_tests->tests_order.num_groups); group_idx = group_idx + 1)
    {
      signed int * const tests_order_tests = ((soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.groups + (signed long int)group_idx)->tests;
      const signed int tests_order_num = ((soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.groups + (signed long int)group_idx)->num;
      signed int i = 0;
      for( ; !(i >= tests_order_num); i = i + 1)
      {
        num = num + 1;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)tests_list, sizeof(void (*)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *)) /*8ul*/  * (unsigned long int)num);
        tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *))return_value_realloc_2;
        tests_list[(signed long int)(num - 1)] = fc_solve_sfs_tests[(signed long int)tests_order_tests[(signed long int)i]];
      }
    }
    soft_thread->method_specific.befs.tests_list = tests_list;
    soft_thread->method_specific.befs.tests_list_end = tests_list + (signed long int)num;
  }

  soft_thread->first_state_to_check = instance->state_copy_ptr;
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// fc_solve_soft_thread_init_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1098
static inline void fc_solve_soft_thread_init_soft_dfs(struct fc_solve_soft_thread_struct *soft_thread)
{
  fc_solve_soft_thread_update_initial_cards_val(soft_thread);
  struct fc_solve_instance_struct *instance = soft_thread->hard_thread->instance;
  struct fcs_state_keyval_pair_struct *ptr_orig_state = instance->state_copy_ptr;
  soft_thread->method_specific.soft_dfs.depth = 0;
  fc_solve_increase_dfs_max_depth(soft_thread);
  (soft_thread->method_specific.soft_dfs.soft_dfs_info + (signed long int)0)->state = ptr_orig_state;
  fc_solve_rand_init(&soft_thread->method_specific.soft_dfs.rand_gen, (unsigned int)soft_thread->method_specific.soft_dfs.rand_seed);
  void (**tmp_post_4)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
  signed int tmp_post_5;
  signed int tmp_if_expr_6;
  if(soft_thread->method_specific.soft_dfs.tests_by_depth_array.by_depth_units == ((struct anonymous_52 *)NULL))
  {
    struct anonymous_16 *tests_list_of_lists;
    void (**tests_list)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
    void (**next_test)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *);
    struct anonymous_17 *tests_list_struct_ptr;
    struct anonymous_18 *arr_ptr;
    signed int tests_order_num;
    struct anonymous_20 *tests_order_groups;
    _Bool master_to_randomize = soft_thread->method == 5;
    signed int depth_idx;
    struct anonymous_21 *by_depth_tests_order;
    arr_ptr = &soft_thread->method_specific.soft_dfs.tests_by_depth_array;
    arr_ptr->num_units = soft_thread->by_depth_tests_order.num;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_52) /*24ul*/  * (unsigned long int)arr_ptr->num_units);
    arr_ptr->by_depth_units = (struct anonymous_52 *)return_value_malloc_1;
    by_depth_tests_order = soft_thread->by_depth_tests_order.by_depth_tests;
    depth_idx = 0;
    for( ; !(depth_idx >= soft_thread->by_depth_tests_order.num); depth_idx = depth_idx + 1)
    {
      (arr_ptr->by_depth_units + (signed long int)depth_idx)->max_depth = (by_depth_tests_order + (signed long int)depth_idx)->max_depth;
      tests_order_groups = (by_depth_tests_order + (signed long int)depth_idx)->tests_order.groups;
      tests_order_num = (by_depth_tests_order + (signed long int)depth_idx)->tests_order.num_groups;
      tests_list_of_lists = &(arr_ptr->by_depth_units + (signed long int)depth_idx)->tests;
      tests_list_of_lists->num_lists = 0;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_17) /*224ul*/  * (unsigned long int)tests_order_num);
      tests_list_of_lists->lists = (struct anonymous_17 *)return_value_malloc_2;
      signed int group_idx = 0;
      for( ; !(group_idx >= tests_order_num); group_idx = group_idx + 1)
      {
        signed int num = (tests_order_groups + (signed long int)group_idx)->num;
        signed int *tests_order_tests = (tests_order_groups + (signed long int)group_idx)->tests;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc(sizeof(void (*)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *)) /*8ul*/  * (unsigned long int)num);
        tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *))return_value_malloc_3;
        next_test = tests_list;
        signed int i = 0;
        for( ; !(i >= num); i = i + 1)
        {
          tmp_post_4 = next_test;
          next_test = next_test + 1l;
          *tmp_post_4 = fc_solve_sfs_tests[(signed long int)tests_order_tests[(signed long int)i]];
        }
        tmp_post_5 = tests_list_of_lists->num_lists;
        tests_list_of_lists->num_lists = tests_list_of_lists->num_lists + 1;
        tests_list_struct_ptr = &tests_list_of_lists->lists[(signed long int)tmp_post_5];
        tests_list_struct_ptr->tests = tests_list;
        tests_list_struct_ptr->num_tests = num;
        if(!(master_to_randomize == (_Bool)0))
          tmp_if_expr_6 = (signed int)(tests_order_groups + (signed long int)group_idx)->shuffling_type;

        else
          tmp_if_expr_6 = FCS_NO_SHUFFLING;
        tests_list_struct_ptr->shuffling_type = tmp_if_expr_6;
        if(tests_list_struct_ptr->shuffling_type == FCS_WEIGHTING)
        {
          tests_list_struct_ptr->weighting = (tests_order_groups + (signed long int)group_idx)->weighting;
          fc_solve_initialize_befs_rater(soft_thread, &tests_list_struct_ptr->weighting);
        }

      }
      void *return_value_realloc_7;
      return_value_realloc_7=realloc((void *)tests_list_of_lists->lists, sizeof(struct anonymous_17) /*224ul*/  * (unsigned long int)tests_list_of_lists->num_lists);
      tests_list_of_lists->lists = (struct anonymous_17 *)return_value_realloc_7;
    }
  }

  goto __CPROVER_DUMP_L11;

__CPROVER_DUMP_L11:
  ;
}

// fc_solve_soft_thread_update_initial_cards_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val(struct fc_solve_soft_thread_struct *soft_thread)
{
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const signed int sequences_are_built_by = (signed int)instance->game_params.game_flags & 0x3;
  struct anonymous_6 pass;
  pass.key = &instance->state_copy_ptr->_anon0._anon0.s;
  pass.val = &instance->state_copy_ptr->_anon0._anon0.info;
  double cards_under_sequences = (double)0;
  signed int a = 0;
  for( ; !(a >= (signed int)instance->game_params.stacks_num); a = a + 1)
  {
    char * const col = pass.key->stacks[(signed long int)a];
    signed int return_value_update_col_cards_under_sequences_1;
    return_value_update_col_cards_under_sequences_1=update_col_cards_under_sequences(sequences_are_built_by, col, (signed int)col[(signed long int)0] - 1);
    cards_under_sequences = cards_under_sequences + fc_solve_seqs_over_cards_lookup[(signed long int)return_value_update_col_cards_under_sequences_1];
  }
  soft_thread->initial_cards_under_sequences_value = cards_under_sequences;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_soft_thread_update_initial_cards_val_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 964
static inline void fc_solve_soft_thread_update_initial_cards_val_link1(struct fc_solve_soft_thread_struct *soft_thread_link1)
{
  struct fc_solve_instance_struct * const instance_link1 = soft_thread_link1->hard_thread->instance;
  const signed int sequences_are_built_by_link1 = (signed int)instance_link1->game_params.game_flags & 0x3;
  struct anonymous_6 pass_link1;
  pass_link1.key = &instance_link1->state_copy_ptr->_anon0._anon0.s;
  pass_link1.val = &instance_link1->state_copy_ptr->_anon0._anon0.info;
  double cards_under_sequences_link1 = (double)0;
  signed int a_link1 = 0;
  for( ; !(a_link1 >= (signed int)instance_link1->game_params.stacks_num); a_link1 = a_link1 + 1)
  {
    char * const col_link1 = pass_link1.key->stacks[(signed long int)a_link1];
    signed int return_value_update_col_cards_under_sequences_1_link1;
    return_value_update_col_cards_under_sequences_1_link1=update_col_cards_under_sequences_link1(sequences_are_built_by_link1, col_link1, (signed int)col_link1[(signed long int)0] - 1);
    cards_under_sequences_link1 = cards_under_sequences_link1 + fc_solve_seqs_over_cards_lookup[(signed long int)return_value_update_col_cards_under_sequences_1_link1];
  }
  soft_thread_link1->initial_cards_under_sequences_value = cards_under_sequences_link1;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// fc_solve_stack_compare_for_comparison
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison(const void * const v_s1, const void * const v_s2)
{
  const char * const s1 = (const char *)v_s1;
  const char * const s2 = (const char *)v_s2;
  signed int min_len;
  signed int tmp_if_expr_1;
  if(!((signed int)*s1 >= (signed int)*s2))
    tmp_if_expr_1 = (signed int)s1[(signed long int)0];

  else
    tmp_if_expr_1 = (signed int)s2[(signed long int)0];
  min_len = tmp_if_expr_1;
  signed int a = 1;
  for( ; min_len >= a; a = a + 1)
  {
    signed int ret;
    ret=fc_solve_card_compare(s1[(signed long int)a], s2[(signed long int)a]);
    if(!(ret == 0))
      return ret;

  }
  if(!((signed int)*s1 >= (signed int)*s2))
    return -1;

  else
    if(!((signed int)*s2 >= (signed int)*s1))
      return 1;

    else
      return 0;
}

// fc_solve_stack_compare_for_comparison_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1175
static inline signed int fc_solve_stack_compare_for_comparison_link1(const void * const v_s1_link1, const void * const v_s2_link1)
{
  const char * const s1_link1 = (const char *)v_s1_link1;
  const char * const s2_link1 = (const char *)v_s2_link1;
  signed int min_len_link1;
  signed int tmp_if_expr_1_link1;
  if(!((signed int)*s1_link1 >= (signed int)*s2_link1))
    tmp_if_expr_1_link1 = (signed int)s1_link1[(signed long int)0];

  else
    tmp_if_expr_1_link1 = (signed int)s2_link1[(signed long int)0];
  min_len_link1 = tmp_if_expr_1_link1;
  signed int a_link1 = 1;
  for( ; min_len_link1 >= a_link1; a_link1 = a_link1 + 1)
  {
    signed int ret_link1;
    ret_link1=fc_solve_card_compare_link1(s1_link1[(signed long int)a_link1], s2_link1[(signed long int)a_link1]);
    if(!(ret_link1 == 0))
      return ret_link1;

  }
  if(!((signed int)*s1_link1 >= (signed int)*s2_link1))
    return -1;

  else
    if(!((signed int)*s2_link1 >= (signed int)*s1_link1))
      return 1;

    else
      return 0;
}

// fc_solve_start_instance_process_with_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 808
extern void fc_solve_start_instance_process_with_board(struct fc_solve_instance_struct * const instance, struct fcs_state_keyval_pair_struct * const init_state)
{
  struct fcs_state_keyval_pair_struct *state_copy_ptr;
  void *return_value_fcs_compact_alloc_ptr_1;
  return_value_fcs_compact_alloc_ptr_1=fcs_compact_alloc_ptr_link1(&(instance->hard_threads + (signed long int)0)->allocator, (signed int)sizeof(struct fcs_state_keyval_pair_struct) /*144ul*/ );
  state_copy_ptr = (struct fcs_state_keyval_pair_struct *)return_value_fcs_compact_alloc_ptr_1;
  struct anonymous_6 pass_copy;
  struct anonymous_6 pass_init;
  pass_copy.key = &state_copy_ptr->_anon0._anon0.s;
  pass_copy.val = &state_copy_ptr->_anon0._anon0.info;
  pass_init.key = &init_state->_anon0._anon0.s;
  pass_init.val = &init_state->_anon0._anon0.info;
  *(&pass_copy)->key = *(&pass_init)->key;
  *(&pass_copy)->val = *(&pass_init)->val;
  (&pass_copy)->val->stacks_copy_on_write_flags = 0;
  signed int i;
  char *buffer = (instance->hard_threads + (signed long int)0)->indirect_stacks_buffer;
  i = 0;
  for( ; !(i >= (signed int)instance->game_params.stacks_num); i = i + 1)
    if((state_copy_ptr->_anon0._anon0.info.stacks_copy_on_write_flags & 1 << i) == 0)
    {
      char *copy_stack_col;
      state_copy_ptr->_anon0._anon0.info.stacks_copy_on_write_flags = state_copy_ptr->_anon0._anon0.info.stacks_copy_on_write_flags | 1 << i;
      copy_stack_col = state_copy_ptr->_anon0._anon0.s.stacks[(signed long int)i];
      memcpy((void *)&buffer[(signed long int)(i << 7)], (const void *)copy_stack_col, (unsigned long int)((signed int)copy_stack_col[(signed long int)0] + 1));
      state_copy_ptr->_anon0._anon0.s.stacks[(signed long int)i] = &buffer[(signed long int)(i << 7)];
    }

  state_copy_ptr->_anon0._anon0.info.depth = 0;
  state_copy_ptr->_anon0._anon0.info.moves_to_parent = (struct anonymous_3 *)(void *)0;
  state_copy_ptr->_anon0._anon0.info.visited = (unsigned char)0;
  state_copy_ptr->_anon0._anon0.info.parent = (struct fcs_state_keyval_pair_struct *)(void *)0;
  memset((void *)&state_copy_ptr->_anon0._anon0.info.scan_visited, 0, sizeof(unsigned char [4l]) /*4ul*/ );
  instance->state_copy_ptr = state_copy_ptr;
  fc_solve_hash_init(instance->meta_alloc, &instance->hash, (const enum FCS_INLINED_HASH_DATA_TYPE)FCS_INLINED_HASH__STATES);
  fc_solve_hash_init(instance->meta_alloc, &instance->stacks_hash, (const enum FCS_INLINED_HASH_DATA_TYPE)FCS_INLINED_HASH__COLUMNS);
  struct anonymous_6 no_use;
  struct anonymous_6 pass;
  pass.key = &state_copy_ptr->_anon0._anon0.s;
  pass.val = &state_copy_ptr->_anon0._anon0.info;
  fc_solve_check_and_add_state(instance->hard_threads, &pass, &no_use);
  instance->current_hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
    if(!(hard_thread->prelude == ((struct anonymous_39 *)NULL)))
    {
      hard_thread->prelude_idx = 0;
      hard_thread->st_idx = (hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->scan_idx;
      hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->quota;
      hard_thread->prelude_idx = hard_thread->prelude_idx + 1;
    }

    else
      hard_thread->st_idx = 0;
  instance->runtime_flags = instance->runtime_flags & (unsigned char)~32;
  if(!((16 & (signed int)instance->runtime_flags) == 0))
    instance->runtime_flags = instance->runtime_flags | (unsigned char)32;

  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// fc_solve_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 1016
extern char * fc_solve_state_as_string(struct fcs_struct_state_t *state, struct anonymous_7 *state_locs, signed int freecells_num, signed int stacks_num, signed int decks_num, _Bool parseable_output, _Bool canonized_order_output, _Bool display_10_as_t)
{
  char freecell[10l];
  char decks[8l][10l];
  char stack_card_str[10l];
  signed int a;
  signed int b;
  _Bool rank_is_null;
  signed int max_num_cards;
  signed int s;
  signed int card_idx;
  char *col;
  signed int col_len;
  char str2[128l];
  char str3[128l];
  char *str2_ptr;
  char *str3_ptr;
  struct anonymous_51 app_str_struct;
  signed int stack_locs[10l];
  signed int freecell_locs[8l];
  if(!(canonized_order_output == (_Bool)0))
  {
    a = 0;
    for( ; !(a >= stacks_num); a = a + 1)
      stack_locs[(signed long int)a] = a;
    a = 0;
    for( ; !(a >= freecells_num); a = a + 1)
      freecell_locs[(signed long int)a] = a;
  }

  else
  {
    a = 0;
    for( ; !(a >= stacks_num); a = a + 1)
      stack_locs[(signed long int)(signed int)state_locs->stack_locs[(signed long int)a]] = a;
    a = 0;
    for( ; !(a >= freecells_num); a = a + 1)
      freecell_locs[(signed long int)(signed int)state_locs->fc_locs[(signed long int)a]] = a;
  }
  a = 0;
  for( ; !(a >= 4 * decks_num); a = a + 1)
  {
    fc_solve_p2u_rank((signed int)state->foundations[(signed long int)a], decks[(signed long int)a], &rank_is_null, display_10_as_t);
    if((signed int)decks[(signed long int)a][0l] == 32)
      decks[(signed long int)a][(signed long int)0] = (char)48;

  }
  fc_solve_append_string_init(&app_str_struct);
  if(parseable_output == (_Bool)0)
  {
    a = 0;
    for( ; !(a >= freecells_num / 4 + (freecells_num % 4 == 0 ? 0 : 1)); a = a + 1)
    {
      str2_ptr = str2;
      str3_ptr = str3;
      b = 0;
      for( ; !(b >= (freecells_num + -(4 * a) >= 4 ? 4 : freecells_num + -(4 * a))); b = b + 1)
      {
        char *return_value_fc_solve_card_perl2user_1;
        return_value_fc_solve_card_perl2user_1=fc_solve_card_perl2user(state->freecells[(signed long int)freecell_locs[(signed long int)(a * 4 + b)]], freecell, display_10_as_t);
        signed int return_value_sprintf_2;
        return_value_sprintf_2=sprintf(str2_ptr, "%3s ", return_value_fc_solve_card_perl2user_1);
        str2_ptr = str2_ptr + (signed long int)return_value_sprintf_2;
        signed int return_value_sprintf_3;
        return_value_sprintf_3=sprintf(str3_ptr, "--- ");
        str3_ptr = str3_ptr + (signed long int)return_value_sprintf_3;
      }
      if(!(a >= decks_num))
        fc_solve_append_string_sprintf(&app_str_struct, "%-16s        H-%1s C-%1s D-%1s S-%1s\n", (const void *)str2, (const void *)decks[(signed long int)(a * 4)], (const void *)decks[(signed long int)(a * 4 + 1)], (const void *)decks[(signed long int)(a * 4 + 2)], (const void *)decks[(signed long int)(a * 4 + 3)]);

      else
        fc_solve_append_string_sprintf(&app_str_struct, "%s\n", (const void *)str2);
      fc_solve_append_string_sprintf(&app_str_struct, "%s\n", (const void *)str3);
    }
    for( ; !(a >= decks_num); a = a + 1)
      fc_solve_append_string_sprintf(&app_str_struct, "%-16s        H-%1s C-%1s D-%1s S-%1s\n", (const void *)"", (const void *)decks[(signed long int)(a * 4)], (const void *)decks[(signed long int)(a * 4 + 1)], (const void *)decks[(signed long int)(a * 4 + 2)], (const void *)decks[(signed long int)(a * 4 + 3)]);
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n\n");
    s = 0;
    for( ; !(s >= stacks_num); s = s + 1)
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)" -- ");
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    max_num_cards = 0;
    s = 0;
    for( ; !(s >= stacks_num); s = s + 1)
    {
      col = state->stacks[(signed long int)stack_locs[(signed long int)s]];
      col_len = (signed int)col[(signed long int)0];
      if(!(max_num_cards >= col_len))
        max_num_cards = col_len;

    }
    card_idx = 0;
    for( ; !(card_idx >= max_num_cards); card_idx = card_idx + 1)
    {
      s = 0;
      for( ; !(s >= stacks_num); s = s + 1)
      {
        col = state->stacks[(signed long int)stack_locs[(signed long int)s]];
        col_len = (signed int)col[(signed long int)0];
        if(card_idx >= col_len)
          fc_solve_append_string_sprintf(&app_str_struct, "    ");

        else
        {
          char *return_value_fc_solve_card_perl2user_4;
          return_value_fc_solve_card_perl2user_4=fc_solve_card_perl2user(col[(signed long int)(card_idx + 1)], stack_card_str, display_10_as_t);
          fc_solve_append_string_sprintf(&app_str_struct, "%3s ", return_value_fc_solve_card_perl2user_4);
        }
      }
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    }
  }

  else
  {
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"Foundations: ");
    a = 0;
    for( ; !(a >= decks_num); a = a + 1)
      fc_solve_append_string_sprintf(&app_str_struct, "H-%s C-%s D-%s S-%s ", (const void *)decks[(signed long int)(a * 4)], (const void *)decks[(signed long int)(a * 4 + 1)], (const void *)decks[(signed long int)(a * 4 + 2)], (const void *)decks[(signed long int)(a * 4 + 3)]);
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\nFreecells: ");
    a = 0;
    for( ; !(a >= freecells_num); a = a + 1)
    {
      char *return_value_fc_solve_card_perl2user_5;
      return_value_fc_solve_card_perl2user_5=fc_solve_card_perl2user(state->freecells[(signed long int)freecell_locs[(signed long int)a]], freecell, display_10_as_t);
      fc_solve_append_string_sprintf(&app_str_struct, "%3s", return_value_fc_solve_card_perl2user_5);
      if(!(a >= freecells_num + -1))
        fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)" ");

    }
    fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    s = 0;
    for( ; !(s >= stacks_num); s = s + 1)
    {
      col = state->stacks[(signed long int)stack_locs[(signed long int)s]];
      col_len = (signed int)col[(signed long int)0];
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)": ");
      card_idx = 0;
      for( ; !(card_idx >= col_len); card_idx = card_idx + 1)
      {
        fc_solve_card_perl2user(col[(signed long int)(card_idx + 1)], stack_card_str, display_10_as_t);
        fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)stack_card_str);
        if(!(card_idx >= col_len + -1))
          fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)" ");

      }
      fc_solve_append_string_sprintf(&app_str_struct, "%s", (const void *)"\n");
    }
  }
  char *return_value_fc_solve_append_string_finalize_6;
  return_value_fc_solve_append_string_finalize_6=fc_solve_append_string_finalize(&app_str_struct);
  return return_value_fc_solve_append_string_finalize_6;
}

// fc_solve_state_compare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 655
static inline signed int fc_solve_state_compare(const void *s1, const void *s2)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(s1, s2, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  return return_value_memcmp_1;
}

// fc_solve_state_compare_with_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.c line 216
extern signed int fc_solve_state_compare_with_context(const void *s1, const void *s2, void *context)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(s1, s2, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  return return_value_memcmp_1;
}

// fc_solve_state_init_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 736
static inline void fc_solve_state_init_proto(struct fcs_state_keyval_pair_struct *state, signed int stacks_num, char *indirect_stacks_buffer)
{
  signed int i;
  memset((void *)&state->_anon0._anon0.s, 0, sizeof(struct fcs_struct_state_t) /*96ul*/ );
  i = 0;
  for( ; !(i >= stacks_num); i = i + 1)
  {
    state->_anon0._anon0.s.stacks[(signed long int)i] = &indirect_stacks_buffer[(signed long int)(i << 7)];
    memset((void *)state->_anon0._anon0.s.stacks[(signed long int)i], 0, (unsigned long int)(2 * 52 + 1));
  }
  for( ; !(i >= 10); i = i + 1)
    state->_anon0._anon0.s.stacks[(signed long int)i] = (char *)(void *)0;
  state->_anon0._anon0.info.parent = (struct fcs_state_keyval_pair_struct *)(void *)0;
  state->_anon0._anon0.info.moves_to_parent = (struct anonymous_3 *)(void *)0;
  state->_anon0._anon0.info.depth = 0;
  state->_anon0._anon0.info.visited = (unsigned char)0;
  state->_anon0._anon0.info.visited_iter = (signed long int)0;
  state->_anon0._anon0.info.num_active_children = (unsigned short int)0;
  memset((void *)state->_anon0._anon0.info.scan_visited, 0, sizeof(unsigned char [4l]) /*4ul*/ );
  state->_anon0._anon0.info.stacks_copy_on_write_flags = 0;
}

// fc_solve_string_to_test_num
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num(const char *s)
{
  struct anonymous_47 needle;
  struct anonymous_47 *result;
  needle.alias = s;
  void *return_value_bsearch_1;
  return_value_bsearch_1=bsearch((const void *)&needle, (const void *)fc_solve_sfs_tests_aliases, (unsigned long int)24, sizeof(struct anonymous_47) /*16ul*/ , fc_solve_string_to_test_num_compare_func);
  result = (struct anonymous_47 *)return_value_bsearch_1;
  signed int tmp_if_expr_2;
  if(!(result == ((struct anonymous_47 *)NULL)))
    tmp_if_expr_2 = result->test_num;

  else
    tmp_if_expr_2 = 0;
  return tmp_if_expr_2;
}

// fc_solve_string_to_test_num_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 55
static inline signed int fc_solve_string_to_test_num_link1(const char *s_link1)
{
  struct anonymous_47 needle_link1;
  struct anonymous_47 *result_link1;
  needle_link1.alias = s_link1;
  void *return_value_bsearch_1_link1;
  return_value_bsearch_1_link1=bsearch((const void *)&needle_link1, (const void *)fc_solve_sfs_tests_aliases, (unsigned long int)24, sizeof(struct anonymous_47) /*16ul*/ , fc_solve_string_to_test_num_compare_func_link1);
  result_link1 = (struct anonymous_47 *)return_value_bsearch_1_link1;
  signed int tmp_if_expr_2_link1;
  if(!(result_link1 == ((struct anonymous_47 *)NULL)))
    tmp_if_expr_2_link1 = result_link1->test_num;

  else
    tmp_if_expr_2_link1 = 0;
  return tmp_if_expr_2_link1;
}

// fc_solve_string_to_test_num_compare_func
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func(const void *a, const void *b)
{
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(((const struct anonymous_47 *)a)->alias, ((const struct anonymous_47 *)b)->alias);
  return return_value_strcmp_1;
}

// fc_solve_string_to_test_num_compare_func_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move_funcs_order.h line 43
static inline signed int fc_solve_string_to_test_num_compare_func_link1(const void *a_link1, const void *b_link1)
{
  signed int return_value_strcmp_1_link1;
  return_value_strcmp_1_link1=strcmp(((const struct anonymous_47 *)a_link1)->alias, ((const struct anonymous_47 *)b_link1)->alias);
  return return_value_strcmp_1_link1;
}

// fc_solve_trace_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 716
extern void fc_solve_trace_solution(struct fc_solve_instance_struct * const instance)
{
  struct anonymous_4 canonize_move = fc_solve_empty_move;
  canonize_move.c[(signed long int)0] = (unsigned char)12;
  if(!(instance->solution_moves.moves == ((struct anonymous_4 *)NULL)))
  {
    free((void *)instance->solution_moves.moves);
    instance->solution_moves.moves = (struct anonymous_4 *)(void *)0;
  }

  instance->solution_moves.num_moves = (unsigned short int)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)16);
  instance->solution_moves.moves = (struct anonymous_4 *)return_value_malloc_1;
  struct fcs_state_keyval_pair_struct *s1 = instance->final_state;
  struct anonymous_3 * const solution_moves_ptr = &instance->solution_moves;
  for( ; !(s1->_anon0._anon0.info.parent == ((struct fcs_state_keyval_pair_struct *)NULL)); s1 = s1->_anon0._anon0.info.parent)
  {
    s1->_anon0._anon0.info.visited = s1->_anon0._anon0.info.visited | (unsigned char)1;
    fcs_move_stack_push_link1(solution_moves_ptr, canonize_move);
    const struct anonymous_3 * const stack = s1->_anon0._anon0.info.moves_to_parent;
    const struct anonymous_4 * const moves = stack->moves;
    signed int move_idx = (signed int)stack->num_moves - 1;
    for( ; move_idx >= 0; move_idx = move_idx - 1)
      fcs_move_stack_push_link1(solution_moves_ptr, moves[(signed long int)move_idx]);
  }
  s1->_anon0._anon0.info.visited = s1->_anon0._anon0.info.visited | (unsigned char)1;
}

// fc_solve_u2p_rank
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 46
extern signed int fc_solve_u2p_rank(const char *string)
{
  while((_Bool)1)
  {
    signed int return_value_toupper_1;
    return_value_toupper_1=toupper((signed int)*string);
    switch(return_value_toupper_1)
    {
      case 0:

      case 32:

      case 9:
        return 0;
      case 65:
        return 1;
      case 74:
        return 11;
      case 81:
        return 12;
      case 75:
        return 13;
      case 49:
        return (signed int)string[(signed long int)1] == 48 ? 10 : 1;
      case 84:

      case 48:
        return 10;
      case 50:
        return 2;
      case 51:
        return 3;
      case 52:
        return 4;
      case 53:
        return 5;
      case 54:
        return 6;
      case 55:
        return 7;
      case 56:
        return 8;
      case 57:
        return 9;
      default:
        string = string + 1l;
    }
  }
}

// fc_solve_u2p_suit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/card.c line 99
extern signed int fc_solve_u2p_suit(const char *suit)
{
  while((_Bool)1)
  {
    signed int return_value_toupper_1;
    return_value_toupper_1=toupper((signed int)*suit);
    switch(return_value_toupper_1)
    {
      case 72:

      case 32:

      case 0:
        return 0;
      case 67:
        return 1;
      case 68:
        return 2;
      case 83:
        return 3;
      default:
        suit = suit + 1l;
    }
  }
}

// fcs_compact_alloc_ptr
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr(struct anonymous_5 *allocator, signed int how_much)
{
  how_much = how_much + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator->max_ptr - allocator->ptr >= (signed long int)how_much))
    fc_solve_compact_allocator_extend(allocator);

  else
    allocator->rollback_ptr = allocator->ptr;
  allocator->ptr = allocator->ptr + (signed long int)how_much;
  return (void *)allocator->rollback_ptr;
}

// fcs_compact_alloc_ptr_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr_link1(struct anonymous_5 *allocator_link1, signed int how_much_link1)
{
  how_much_link1 = how_much_link1 + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much_link1 & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator_link1->max_ptr - allocator_link1->ptr >= (signed long int)how_much_link1))
    fc_solve_compact_allocator_extend(allocator_link1);

  else
    allocator_link1->rollback_ptr = allocator_link1->ptr;
  allocator_link1->ptr = allocator_link1->ptr + (signed long int)how_much_link1;
  return (void *)allocator_link1->rollback_ptr;
}

// fcs_compact_alloc_ptr_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr_link2(struct anonymous_5 *allocator_link2, signed int how_much_link2)
{
  how_much_link2 = how_much_link2 + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much_link2 & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator_link2->max_ptr - allocator_link2->ptr >= (signed long int)how_much_link2))
    fc_solve_compact_allocator_extend(allocator_link2);

  else
    allocator_link2->rollback_ptr = allocator_link2->ptr;
  allocator_link2->ptr = allocator_link2->ptr + (signed long int)how_much_link2;
  return (void *)allocator_link2->rollback_ptr;
}

// fcs_compact_alloc_ptr_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 87
static inline void * fcs_compact_alloc_ptr_link3(struct anonymous_5 *allocator_link3, signed int how_much_link3)
{
  how_much_link3 = how_much_link3 + (signed int)(sizeof(char *) /*8ul*/  - ((unsigned long int)how_much_link3 & sizeof(char *) /*8ul*/  - (unsigned long int)1) & sizeof(char *) /*8ul*/  - (unsigned long int)1);
  if(!(allocator_link3->max_ptr - allocator_link3->ptr >= (signed long int)how_much_link3))
    fc_solve_compact_allocator_extend(allocator_link3);

  else
    allocator_link3->rollback_ptr = allocator_link3->ptr;
  allocator_link3->ptr = allocator_link3->ptr + (signed long int)how_much_link3;
  return (void *)allocator_link3->rollback_ptr;
}

// fcs_get_preset_by_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 531
static inline signed int fcs_get_preset_by_id(signed int preset_id, const struct anonymous_35 **preset_ptr)
{
  signed int preset_index = 0;
  for( ; !(preset_index >= 23); preset_index = preset_index + 1)
    if(fcs_presets[(signed long int)preset_index].preset_id == preset_id)
    {
      *preset_ptr = &fcs_presets[(signed long int)preset_index];
      return 0;
    }

  return 1;
}

// fcs_get_preset_id_by_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/preset.c line 412
static inline signed int fcs_get_preset_id_by_name(const char *name)
{
  signed int a;
  signed int ret = -1;
  a = 0;
  for( ; !(a >= 23); a = a + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(name, fcs_preset_names[(signed long int)a].name);
    if(return_value_strcmp_1 == 0)
    {
      ret = fcs_preset_names[(signed long int)a].preset_id;
      break;
    }

  }
  return ret;
}

// fcs_is_ss_suit_true
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 58
static inline const _Bool fcs_is_ss_suit_true(const char parent, const char child)
{
  return ((signed int)parent & 0x03) == ((signed int)child & 0x03);
}

// fcs_is_ss_true_parent
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 65
static inline const _Bool fcs_is_ss_true_parent(const char parent, const char child)
{
  _Bool tmp_if_expr_2;
  _Bool return_value_fcs_is_ss_suit_true_1;
  if((signed int)parent >> 2 == ((signed int)child >> 2) + 1)
  {
    return_value_fcs_is_ss_suit_true_1=fcs_is_ss_suit_true(parent, child);
    tmp_if_expr_2 = return_value_fcs_is_ss_suit_true_1 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  return tmp_if_expr_2;
}

// fcs_make_card
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card(const signed int rank, const signed int suit)
{
  return (char)((signed int)(char)rank << 2 | (signed int)(char)suit);
}

// fcs_make_card_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/state.h line 367
static inline char fcs_make_card_link1(const signed int rank_link1, const signed int suit_link1)
{
  return (char)((signed int)(char)rank_link1 << 2 | (signed int)(char)suit_link1);
}

// fcs_move_stack_non_seq_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push(struct anonymous_3 * const stack, const signed int type, const signed int src, const signed int dest)
{
  fcs_move_stack_params_push(stack, type, src, dest, 1);
}

// fcs_move_stack_non_seq_push_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 84
static inline void fcs_move_stack_non_seq_push_link1(struct anonymous_3 * const stack_link1, const signed int type_link1, const signed int src_link1, const signed int dest_link1)
{
  fcs_move_stack_params_push_link1(stack_link1, type_link1, src_link1, dest_link1, 1);
}

// fcs_move_stack_params_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push(struct anonymous_3 * const stack, const signed int type, const signed int src, const signed int dest, const signed int num_cards_in_seq)
{
  struct anonymous_4 temp_move;
  temp_move.c[(signed long int)0] = (unsigned char)type;
  temp_move.c[(signed long int)1] = (unsigned char)src;
  temp_move.c[(signed long int)2] = (unsigned char)dest;
  temp_move.c[(signed long int)3] = (unsigned char)num_cards_in_seq;
  fcs_move_stack_push(stack, temp_move);
}

// fcs_move_stack_params_push_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 72
static inline void fcs_move_stack_params_push_link1(struct anonymous_3 * const stack_link1, const signed int type_link1, const signed int src_link1, const signed int dest_link1, const signed int num_cards_in_seq_link1)
{
  struct anonymous_4 temp_move_link1;
  temp_move_link1.c[(signed long int)0] = (unsigned char)type_link1;
  temp_move_link1.c[(signed long int)1] = (unsigned char)src_link1;
  temp_move_link1.c[(signed long int)2] = (unsigned char)dest_link1;
  temp_move_link1.c[(signed long int)3] = (unsigned char)num_cards_in_seq_link1;
  fcs_move_stack_push_link3(stack_link1, temp_move_link1);
}

// fcs_move_stack_push
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push(struct anonymous_3 * const stack, const struct anonymous_4 move)
{
  signed int pos;
  stack->num_moves = stack->num_moves + 1;
  pos = (const signed int)stack->num_moves;
  if((16 & pos) == 0)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)stack->moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)(pos + 16));
    stack->moves = (struct anonymous_4 *)return_value_realloc_1;
  }

  stack->moves[(signed long int)(pos - 1)] = move;
}

// fcs_move_stack_push_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push_link1(struct anonymous_3 * const stack_link1, const struct anonymous_4 move_link1)
{
  signed int pos_link1;
  stack_link1->num_moves = stack_link1->num_moves + 1;
  pos_link1 = (const signed int)stack_link1->num_moves;
  if((16 & pos_link1) == 0)
  {
    void *return_value_realloc_1_link1;
    return_value_realloc_1_link1=realloc((void *)stack_link1->moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)(pos_link1 + 16));
    stack_link1->moves = (struct anonymous_4 *)return_value_realloc_1_link1;
  }

  stack_link1->moves[(signed long int)(pos_link1 - 1)] = move_link1;
}

// fcs_move_stack_push_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push_link2(struct anonymous_3 * const stack_link2, const struct anonymous_4 move_link2)
{
  signed int pos_link2;
  stack_link2->num_moves = stack_link2->num_moves + 1;
  pos_link2 = (const signed int)stack_link2->num_moves;
  if((16 & pos_link2) == 0)
  {
    void *return_value_realloc_1_link2;
    return_value_realloc_1_link2=realloc((void *)stack_link2->moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)(pos_link2 + 16));
    stack_link2->moves = (struct anonymous_4 *)return_value_realloc_1_link2;
  }

  stack_link2->moves[(signed long int)(pos_link2 - 1)] = move_link2;
}

// fcs_move_stack_push_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 55
static inline void fcs_move_stack_push_link3(struct anonymous_3 * const stack_link3, const struct anonymous_4 move_link3)
{
  signed int pos_link3;
  stack_link3->num_moves = stack_link3->num_moves + 1;
  pos_link3 = (const signed int)stack_link3->num_moves;
  if((16 & pos_link3) == 0)
  {
    void *return_value_realloc_1_link3;
    return_value_realloc_1_link3=realloc((void *)stack_link3->moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)(pos_link3 + 16));
    stack_link3->moves = (struct anonymous_4 *)return_value_realloc_1_link3;
  }

  stack_link3->moves[(signed long int)(pos_link3 - 1)] = move_link3;
}

// fcs_push_1card_seq
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/move.h line 89
static inline void fcs_push_1card_seq(struct anonymous_3 * const stack, const signed int src, const signed int dest)
{
  fcs_move_stack_params_push(stack, 0, src, dest, 1);
}

// fcs_state_ia_alloc_into_var
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.h line 115
static inline struct fcs_state_keyval_pair_struct * fcs_state_ia_alloc_into_var(struct anonymous_5 *allocator)
{
  struct fcs_state_keyval_pair_struct *ret_helper;
  void *return_value_fcs_compact_alloc_ptr_1;
  return_value_fcs_compact_alloc_ptr_1=fcs_compact_alloc_ptr_link2(allocator, (signed int)sizeof(struct fcs_state_keyval_pair_struct) /*144ul*/ );
  ret_helper = (struct fcs_state_keyval_pair_struct *)return_value_fcs_compact_alloc_ptr_1;
  return ret_helper;
}

// free_instance_hard_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1797
static inline void free_instance_hard_thread_callback(struct fc_solve_hard_thread_struct *hard_thread)
{
  if(!(hard_thread->prelude_as_string == ((char *)NULL)))
    free((void *)hard_thread->prelude_as_string);

  if(!(hard_thread->prelude == ((struct anonymous_39 *)NULL)))
    free((void *)hard_thread->prelude);

  free((void *)hard_thread->reusable_move_stack.moves);
  free((void *)hard_thread->soft_threads);
  fc_solve_compact_allocator_finish(&hard_thread->allocator);
}

// free_instance_soft_thread_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 181
static inline void free_instance_soft_thread_callback(struct fc_solve_soft_thread_struct * const soft_thread)
{
  fc_solve_PQueueFree(&soft_thread->method_specific.befs.meth.befs.pqueue);
  fc_solve_release_tests_list(soft_thread);
  fc_solve_free_soft_thread_by_depth_test_array(soft_thread);
  if(!(soft_thread->name == ((char *)NULL)))
    free((void *)soft_thread->name);

}

// free_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 233
static inline void free_states(struct fc_solve_instance_struct *instance)
{
  struct fc_solve_hard_thread_struct *hard_thread = instance->hard_threads;
  struct fc_solve_hard_thread_struct * const end_hard_thread = hard_thread + (signed long int)instance->num_hard_threads;
  for( ; !(hard_thread >= end_hard_thread); hard_thread = hard_thread + 1l)
  {
    struct fc_solve_soft_thread_struct *soft_thread = hard_thread->soft_threads;
    struct fc_solve_soft_thread_struct * const end_soft_thread = soft_thread + (signed long int)hard_thread->num_soft_threads;
    for( ; !(soft_thread >= end_soft_thread); soft_thread = soft_thread + 1l)
      if((signed int)soft_thread->super_method_type == FCS_SUPER_METHOD_DFS)
        free_states_handle_soft_dfs_soft_thread(soft_thread);

      else
        if(soft_thread->method == 3)
        {
          struct anonymous_31 new_pq;
          fc_solve_PQueueInitialise(&new_pq, 1024);
          const signed int CurrentSize = soft_thread->method_specific.befs.meth.befs.pqueue.CurrentSize;
          struct anonymous_19 *next_element = soft_thread->method_specific.befs.meth.befs.pqueue.Elements + (signed long int)1;
          signed int i = 1;
          for( ; CurrentSize >= i; next_element = next_element + 1l)
          {
            if((4 & (signed int)next_element->val->_anon0._anon0.info.visited) == 0)
              fc_solve_PQueuePush(&new_pq, next_element->val, next_element->rating);

            i = i + 1;
          }
          fc_solve_PQueueFree_link2(&soft_thread->method_specific.befs.meth.befs.pqueue);
          soft_thread->method_specific.befs.meth.befs.pqueue = new_pq;
        }

  }
  fc_solve_hash_foreach(&instance->hash, free_states_should_delete, (void *)instance);
}

// free_states_handle_soft_dfs_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 146
static inline void free_states_handle_soft_dfs_soft_thread(struct fc_solve_soft_thread_struct *soft_thread)
{
  struct anonymous_50 *soft_dfs_info = soft_thread->method_specific.soft_dfs.soft_dfs_info;
  struct anonymous_50 * const end_soft_dfs_info = soft_dfs_info + (signed long int)soft_thread->method_specific.soft_dfs.depth;
  struct anonymous_25 *tmp_post_1;
  for( ; !(soft_dfs_info >= end_soft_dfs_info); soft_dfs_info = soft_dfs_info + 1l)
  {
    struct anonymous_25 *rand_index_ptr;
    struct anonymous_25 *dest_rand_index_ptr;
    struct anonymous_43 * const states = soft_dfs_info->derived_states_list.states;
    rand_index_ptr = soft_dfs_info->derived_states_random_indexes + (signed long int)soft_dfs_info->current_state_index;
    dest_rand_index_ptr = rand_index_ptr;
    struct anonymous_25 * const end_rand_index_ptr = soft_dfs_info->derived_states_random_indexes + (signed long int)soft_dfs_info->derived_states_list.num_states;
    for( ; !(rand_index_ptr >= end_rand_index_ptr); rand_index_ptr = rand_index_ptr + 1l)
      if((4 & (signed int)(states + (signed long int)rand_index_ptr->idx)->state_ptr->_anon0._anon0.info.visited) == 0)
      {
        tmp_post_1 = dest_rand_index_ptr;
        dest_rand_index_ptr = dest_rand_index_ptr + 1l;
        *tmp_post_1 = *rand_index_ptr;
      }

    soft_dfs_info->derived_states_list.num_states = (signed int)(dest_rand_index_ptr - soft_dfs_info->derived_states_random_indexes);
  }
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// free_states_should_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 125
static _Bool free_states_should_delete(void *key, void *context)
{
  struct fc_solve_instance_struct * const instance = (struct fc_solve_instance_struct *)context;
  struct fcs_state_keyval_pair_struct * const ptr_state = (struct fcs_state_keyval_pair_struct *)key;
  if(!((4 & (signed int)ptr_state->_anon0._anon0.info.visited) == 0))
  {
    ptr_state->_anon0._anon0.info.parent = instance->list_of_vacant_states;
    instance->list_of_vacant_states = ptr_state;
    instance->active_num_states_in_collection = instance->active_num_states_in_collection - 1l;
    return (_Bool)1;
  }

  else
    return (_Bool)0;
}

// freecell_solver_set_stored_states_trimming_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 265
extern void freecell_solver_set_stored_states_trimming_limit(void *api_instance, signed long int max_num_states)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(!(max_num_states >= 0l))
  {
    user->active_flare->obj->trim_states_in_collection_from = (signed long int)-1;
    user->active_flare->obj->effective_trim_states_in_collection_from = 0x7fffffffffffffffL;
  }

  else
  {
    user->active_flare->obj->trim_states_in_collection_from = max_num_states;
    user->active_flare->obj->effective_trim_states_in_collection_from = user->active_flare->obj->trim_states_in_collection_from;
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// freecell_solver_user_alloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 46
extern void * freecell_solver_user_alloc(void)
{
  struct anonymous *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous) /*2080ul*/  * (unsigned long int)1);
  ret = (struct anonymous *)return_value_malloc_1;
  user_initialize(ret);
  return (void *)ret;
}

// freecell_solver_user_apply_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 48
extern signed int freecell_solver_user_apply_preset(void *api_instance, const char *preset_name)
{
  const struct anonymous_35 *new_preset_ptr;
  signed int status;
  struct anonymous * const user = (struct anonymous *)api_instance;
  status=fc_solve_get_preset_by_name(preset_name, &new_preset_ptr);
  if(!(status == 0))
    return status;

  else
  {
    signed int user_inst_idx = 0;
    for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
    {
      struct anonymous_1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
      signed int flare_idx = 0;
      for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
      {
        struct anonymous_2 * const flare = &instance_item->flares[(signed long int)flare_idx];
        status=fc_solve_apply_preset_by_ptr(flare->obj, new_preset_ptr);
        if(!(status == 0))
          return status;

      }
    }
    user->common_preset = *new_preset_ptr;
    return 0;
  }
}

// freecell_solver_user_cmd_line_parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_cl.h line 62
extern signed int freecell_solver_user_cmd_line_parse_args(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg)
{
  signed int return_value_freecell_solver_user_cmd_line_parse_args_with_file_nesting_count_1;
  return_value_freecell_solver_user_cmd_line_parse_args_with_file_nesting_count_1=freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(instance, argc, argv, start_arg, known_parameters, callback, callback_context, error_string, last_arg, -1, (const char *)(void *)0);
  return return_value_freecell_solver_user_cmd_line_parse_args_with_file_nesting_count_1;
}

// freecell_solver_user_cmd_line_parse_args_with_file_nesting_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 309
extern signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(void *instance, signed int argc, const char **argv, signed int start_arg, const char **known_parameters, signed int (*callback)(void *, signed int, const char **, signed int, signed int *, signed int *, void *), void *callback_context, char **error_string, signed int *last_arg, signed int file_nesting_count, const char *opened_files_dir)
{
  signed int num_to_skip;
  const char *p;
  *error_string = (char *)(void *)0;
  const char **arg_argc = &argv[(signed long int)argc];
  const char **arg;
  const char **known_param;
  arg = &argv[(signed long int)start_arg];
  signed int return_value_strcmp_1;
  const char *tmp_post_83;
  const char *tmp_post_2;
  const char *tmp_post_3;
  const char *tmp_post_8;
  const char *tmp_post_5;
  const char *tmp_post_12;
  const char *tmp_post_9;
  const char *tmp_post_14;
  const char *tmp_post_15;
  const char *tmp_post_21;
  const char *tmp_post_17;
  const char *tmp_post_26;
  const char *tmp_post_27;
  const char *tmp_post_33;
  const char *tmp_post_39;
  const char *tmp_post_43;
  const char *tmp_post_51;
  const char *tmp_post_47;
  const char *tmp_post_52;
  const char *tmp_post_54;
  const char *tmp_post_55;
  const char *tmp_post_61;
  const char *tmp_post_64;
  const char *tmp_post_70;
  const char *tmp_post_72;
  const char *tmp_post_75;
  const char *tmp_post_78;
  const char *tmp_post_81;
  signed int return_value_strcmp_100;
  signed int return_value_strcmp_103;
  _Bool tmp_if_expr_120;
  signed int return_value_strcmp_119;
  signed int return_value_strcmp_117;
  signed int return_value_strcmp_116;
  signed int return_value_strcmp_115;
  signed int tmp_if_expr_126;
  signed int return_value_freecell_solver_user_next_soft_thread_124;
  signed int return_value_freecell_solver_user_next_hard_thread_125;
  signed int return_value_strcmp_133;
  const unsigned short int **return_value___ctype_b_loc_135;
  const unsigned short int **return_value___ctype_b_loc_144;
  while(!(arg >= arg_argc))
  {
    if(!(known_parameters == ((const char **)NULL)))
    {
      known_param = known_parameters;
      for( ; !(*known_param == ((const char *)NULL)); known_param = known_param + 1l)
      {
        return_value_strcmp_1=strcmp(*known_param, *arg);
        if(return_value_strcmp_1 == 0)
          break;

      }
      if(!(*known_param == ((const char *)NULL)))
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__1__2__ret;
        signed int callback_ret;
        callback_ret=callback(instance, argc, argv, (signed int)(arg - &argv[(signed long int)0]), &num_to_skip, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__1__2__ret, callback_context);
        if(callback_ret == 1)
          arg = arg + (signed long int)(num_to_skip - 1);

        else
          if(callback_ret == 2)
          {
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__1__2__ret;
          }

      }

    }

    signed int opt;
    p = *arg;
    opt = 0;
    tmp_post_83 = p;
    p = p + 1l;
    if((signed int)*tmp_post_83 == 45)
    {
      tmp_post_2 = p;
      p = p + 1l;
      switch((signed int)*tmp_post_2)
      {
        case 45:
        {
          tmp_post_3 = p;
          p = p + 1l;
          switch((signed int)*tmp_post_3)
          {
            case 97:
            {
              signed int return_value_strcmp_4;
              return_value_strcmp_4=strcmp(p, "-star-weights");
              if(return_value_strcmp_4 == 0)
                opt = 12;

              break;
            }
            case 99:
            {
              tmp_post_8 = p;
              p = p + 1l;
              if((signed int)*tmp_post_8 == 97)
              {
                tmp_post_5 = p;
                p = p + 1l;
                switch((signed int)*tmp_post_5)
                {
                  case 99:
                  {
                    signed int return_value_strcmp_6;
                    return_value_strcmp_6=strcmp(p, "he-limit");
                    if(return_value_strcmp_6 == 0)
                      opt = 36;

                    break;
                  }
                  case 108:
                  {
                    signed int return_value_strcmp_7;
                    return_value_strcmp_7=strcmp(p, "c-real-depth");
                    if(return_value_strcmp_7 == 0)
                      opt = 23;

                  }
                }
              }

              break;
            }
            case 100:
            {
              tmp_post_12 = p;
              p = p + 1l;
              if((signed int)*tmp_post_12 == 101)
              {
                tmp_post_9 = p;
                p = p + 1l;
                switch((signed int)*tmp_post_9)
                {
                  case 99:
                  {
                    signed int return_value_strcmp_10;
                    return_value_strcmp_10=strcmp(p, "ks-num");
                    if(return_value_strcmp_10 == 0)
                      opt = 6;

                    break;
                  }
                  case 112:
                  {
                    signed int return_value_strcmp_11;
                    return_value_strcmp_11=strcmp(p, "th-tests-order");
                    if(return_value_strcmp_11 == 0)
                      opt = 34;

                  }
                }
              }

              break;
            }
            case 101:
            {
              signed int return_value_strcmp_13;
              return_value_strcmp_13=strcmp(p, "mpty-stacks-filled-by");
              if(return_value_strcmp_13 == 0)
                opt = 9;

              break;
            }
            case 102:
            {
              tmp_post_14 = p;
              p = p + 1l;
              switch((signed int)*tmp_post_14)
              {
                case 108:
                {
                  signed int return_value_strncmp_22;
                  return_value_strncmp_22=strncmp(p, "are", (unsigned long int)3);
                  if(return_value_strncmp_22 == 0)
                  {
                    p = p + (signed long int)3;
                    tmp_post_15 = p;
                    p = p + 1l;
                    switch((signed int)*tmp_post_15)
                    {
                      case 45:
                      {
                        signed int return_value_strcmp_16;
                        return_value_strcmp_16=strcmp(p, "name");
                        if(return_value_strcmp_16 == 0)
                          opt = 25;

                        break;
                      }
                      case 115:
                      {
                        tmp_post_21 = p;
                        p = p + 1l;
                        if((signed int)*tmp_post_21 == 45)
                        {
                          tmp_post_17 = p;
                          p = p + 1l;
                          switch((signed int)*tmp_post_17)
                          {
                            case 99:
                            {
                              signed int return_value_strcmp_18;
                              return_value_strcmp_18=strcmp(p, "hoice");
                              if(return_value_strcmp_18 == 0)
                                opt = 37;

                              break;
                            }
                            case 105:
                            {
                              signed int return_value_strcmp_19;
                              return_value_strcmp_19=strcmp(p, "ters-factor");
                              if(return_value_strcmp_19 == 0)
                                opt = 28;

                              break;
                            }
                            case 112:
                            {
                              signed int return_value_strcmp_20;
                              return_value_strcmp_20=strcmp(p, "lan");
                              if(return_value_strcmp_20 == 0)
                                opt = 27;

                            }
                          }
                        }

                      }
                    }
                  }

                  break;
                }
                case 114:
                {
                  signed int return_value_strcmp_23;
                  return_value_strcmp_23=strcmp(p, "eecells-num");
                  if(return_value_strcmp_23 == 0)
                    opt = 4;

                }
              }
              break;
            }
            case 103:
            {
              signed int return_value_strcmp_24;
              return_value_strcmp_24=strcmp(p, "ame");
              if(return_value_strcmp_24 == 0)
                opt = 10;

              break;
            }
            case 108:
            {
              signed int return_value_strcmp_25;
              return_value_strcmp_25=strcmp(p, "oad-config");
              if(return_value_strcmp_25 == 0)
                opt = 33;

              break;
            }
            case 109:
            {
              tmp_post_26 = p;
              p = p + 1l;
              switch((signed int)*tmp_post_26)
              {
                case 97:
                {
                  signed int return_value_strncmp_31;
                  return_value_strncmp_31=strncmp(p, "x-", (unsigned long int)2);
                  if(return_value_strncmp_31 == 0)
                  {
                    p = p + (signed long int)2;
                    tmp_post_27 = p;
                    p = p + 1l;
                    switch((signed int)*tmp_post_27)
                    {
                      case 100:
                      {
                        signed int return_value_strcmp_28;
                        return_value_strcmp_28=strcmp(p, "epth");
                        if(return_value_strcmp_28 == 0)
                          opt = 1;

                        break;
                      }
                      case 105:
                      {
                        signed int return_value_strcmp_29;
                        return_value_strcmp_29=strcmp(p, "ters");
                        if(return_value_strcmp_29 == 0)
                          opt = 2;

                        break;
                      }
                      case 115:
                      {
                        signed int return_value_strcmp_30;
                        return_value_strcmp_30=strcmp(p, "tored-states");
                        if(return_value_strcmp_30 == 0)
                          opt = 15;

                      }
                    }
                  }

                  break;
                }
                case 101:
                {
                  signed int return_value_strcmp_32;
                  return_value_strcmp_32=strcmp(p, "thod");
                  if(return_value_strcmp_32 == 0)
                    opt = 11;

                }
              }
              break;
            }
            case 110:
            {
              signed int return_value_strncmp_38;
              return_value_strncmp_38=strncmp(p, "ext-", (unsigned long int)4);
              if(return_value_strncmp_38 == 0)
              {
                p = p + (signed long int)4;
                tmp_post_33 = p;
                p = p + 1l;
                switch((signed int)*tmp_post_33)
                {
                  case 102:
                  {
                    signed int return_value_strcmp_34;
                    return_value_strcmp_34=strcmp(p, "lare");
                    if(return_value_strcmp_34 == 0)
                      opt = 18;

                    break;
                  }
                  case 104:
                  {
                    signed int return_value_strcmp_35;
                    return_value_strcmp_35=strcmp(p, "ard-thread");
                    if(return_value_strcmp_35 == 0)
                      opt = 20;

                    break;
                  }
                  case 105:
                  {
                    signed int return_value_strcmp_36;
                    return_value_strcmp_36=strcmp(p, "nstance");
                    if(return_value_strcmp_36 == 0)
                      opt = 17;

                    break;
                  }
                  case 115:
                  {
                    signed int return_value_strcmp_37;
                    return_value_strcmp_37=strcmp(p, "oft-thread");
                    if(return_value_strcmp_37 == 0)
                      opt = 19;

                  }
                }
              }

              break;
            }
            case 111:
            {
              signed int return_value_strncmp_42;
              return_value_strncmp_42=strncmp(p, "ptimiz", (unsigned long int)6);
              if(return_value_strncmp_42 == 0)
              {
                p = p + (signed long int)6;
                tmp_post_39 = p;
                p = p + 1l;
                switch((signed int)*tmp_post_39)
                {
                  case 97:
                  {
                    signed int return_value_strcmp_40;
                    return_value_strcmp_40=strcmp(p, "tion-tests-order");
                    if(return_value_strcmp_40 == 0)
                      opt = 29;

                    break;
                  }
                  case 101:
                  {
                    signed int return_value_strcmp_41;
                    return_value_strcmp_41=strcmp(p, "-solution");
                    if(return_value_strcmp_41 == 0)
                      opt = 13;

                  }
                }
              }

              break;
            }
            case 112:
            {
              signed int return_value_strncmp_46;
              return_value_strncmp_46=strncmp(p, "re", (unsigned long int)2);
              if(return_value_strncmp_46 == 0)
              {
                p = p + (signed long int)2;
                tmp_post_43 = p;
                p = p + 1l;
                switch((signed int)*tmp_post_43)
                {
                  case 108:
                  {
                    signed int return_value_strcmp_44;
                    return_value_strcmp_44=strcmp(p, "ude");
                    if(return_value_strcmp_44 == 0)
                      opt = 26;

                    break;
                  }
                  case 115:
                  {
                    signed int return_value_strcmp_45;
                    return_value_strcmp_45=strcmp(p, "et");
                    if(return_value_strcmp_45 == 0)
                      opt = 10;

                  }
                }
              }

              break;
            }
            case 114:
            {
              tmp_post_51 = p;
              p = p + 1l;
              if((signed int)*tmp_post_51 == 101)
              {
                tmp_post_47 = p;
                p = p + 1l;
                switch((signed int)*tmp_post_47)
                {
                  case 97:
                  {
                    signed int return_value_strcmp_48;
                    return_value_strcmp_48=strcmp(p, "d-from-file");
                    if(return_value_strcmp_48 == 0)
                      opt = 32;

                    break;
                  }
                  case 112:
                  {
                    signed int return_value_strcmp_49;
                    return_value_strcmp_49=strcmp(p, "arent-states");
                    if(return_value_strcmp_49 == 0)
                      opt = 22;

                    break;
                  }
                  case 115:
                  {
                    signed int return_value_strcmp_50;
                    return_value_strcmp_50=strcmp(p, "et");
                    if(return_value_strcmp_50 == 0)
                      opt = 31;

                  }
                }
              }

              break;
            }
            case 115:
            {
              tmp_post_52 = p;
              p = p + 1l;
              switch((signed int)*tmp_post_52)
              {
                case 99:
                {
                  signed int return_value_strcmp_53;
                  return_value_strcmp_53=strcmp(p, "ans-synergy");
                  if(return_value_strcmp_53 == 0)
                    opt = 30;

                  break;
                }
                case 101:
                {
                  tmp_post_54 = p;
                  p = p + 1l;
                  switch((signed int)*tmp_post_54)
                  {
                    case 113:
                    {
                      signed int return_value_strncmp_58;
                      return_value_strncmp_58=strncmp(p, "uence", (unsigned long int)5);
                      if(return_value_strncmp_58 == 0)
                      {
                        p = p + (signed long int)5;
                        tmp_post_55 = p;
                        p = p + 1l;
                        switch((signed int)*tmp_post_55)
                        {
                          case 45:
                          {
                            signed int return_value_strcmp_56;
                            return_value_strcmp_56=strcmp(p, "move");
                            if(return_value_strcmp_56 == 0)
                              opt = 8;

                            break;
                          }
                          case 115:
                          {
                            signed int return_value_strcmp_57;
                            return_value_strcmp_57=strcmp(p, "-are-built-by");
                            if(return_value_strcmp_57 == 0)
                              opt = 7;

                          }
                        }
                      }

                      break;
                    }
                    case 116:
                    {
                      signed int return_value_strcmp_59;
                      return_value_strcmp_59=strcmp(p, "-pruning");
                      if(return_value_strcmp_59 == 0)
                        opt = 35;

                    }
                  }
                  break;
                }
                case 111:
                {
                  signed int return_value_strcmp_60;
                  return_value_strcmp_60=strcmp(p, "ft-thread-step");
                  if(return_value_strcmp_60 == 0)
                    opt = 21;

                  break;
                }
                case 116:
                {
                  tmp_post_61 = p;
                  p = p + 1l;
                  switch((signed int)*tmp_post_61)
                  {
                    case 45:
                    {
                      signed int return_value_strcmp_62;
                      return_value_strcmp_62=strcmp(p, "name");
                      if(return_value_strcmp_62 == 0)
                        opt = 24;

                      break;
                    }
                    case 97:
                    {
                      signed int return_value_strcmp_63;
                      return_value_strcmp_63=strcmp(p, "cks-num");
                      if(return_value_strcmp_63 == 0)
                        opt = 5;

                    }
                  }
                }
              }
              break;
            }
            case 116:
            {
              tmp_post_64 = p;
              p = p + 1l;
              switch((signed int)*tmp_post_64)
              {
                case 101:
                {
                  signed int return_value_strcmp_65;
                  return_value_strcmp_65=strcmp(p, "sts-order");
                  if(return_value_strcmp_65 == 0)
                    opt = 3;

                  break;
                }
                case 114:
                {
                  signed int return_value_strcmp_66;
                  return_value_strcmp_66=strcmp(p, "im-max-stored-states");
                  if(return_value_strcmp_66 == 0)
                    opt = 16;

                }
              }
            }
          }
          break;
        }
        case 97:
        {
          signed int return_value_strcmp_67;
          return_value_strcmp_67=strcmp(p, "sw");
          if(return_value_strcmp_67 == 0)
            opt = 12;

          break;
        }
        case 100:
        {
          signed int return_value_strcmp_68;
          return_value_strcmp_68=strcmp(p, "to");
          if(return_value_strcmp_68 == 0)
            opt = 34;

          break;
        }
        case 102:
        {
          signed int return_value_strcmp_69;
          return_value_strcmp_69=strcmp(p, "if");
          if(return_value_strcmp_69 == 0)
            opt = 28;

          break;
        }
        case 103:
        {
          if((signed int)*p == 0)
            opt = 10;

          break;
        }
        case 108:
        {
          if((signed int)*p == 0)
            opt = 33;

          break;
        }
        case 109:
        {
          tmp_post_70 = p;
          p = p + 1l;
          switch((signed int)*tmp_post_70)
          {
            case 100:
            {
              if((signed int)*p == 0)
                opt = 1;

              break;
            }
            case 101:
            {
              if((signed int)*p == 0)
                opt = 11;

              break;
            }
            case 105:
            {
              if((signed int)*p == 0)
                opt = 2;

              break;
            }
            case 115:
            {
              signed int return_value_strcmp_71;
              return_value_strcmp_71=strcmp(p, "s");
              if(return_value_strcmp_71 == 0)
                opt = 15;

            }
          }
          break;
        }
        case 110:
        {
          tmp_post_72 = p;
          p = p + 1l;
          switch((signed int)*tmp_post_72)
          {
            case 102:
            {
              if((signed int)*p == 0)
                opt = 18;

              break;
            }
            case 104:
            {
              signed int return_value_strcmp_73;
              return_value_strcmp_73=strcmp(p, "t");
              if(return_value_strcmp_73 == 0)
                opt = 20;

              break;
            }
            case 105:
            {
              if((signed int)*p == 0)
                opt = 17;

              break;
            }
            case 115:
            {
              signed int return_value_strcmp_74;
              return_value_strcmp_74=strcmp(p, "t");
              if(return_value_strcmp_74 == 0)
                opt = 19;

            }
          }
          break;
        }
        case 111:
        {
          signed int return_value_strncmp_77;
          return_value_strncmp_77=strncmp(p, "pt", (unsigned long int)2);
          if(return_value_strncmp_77 == 0)
          {
            p = p + (signed long int)2;
            tmp_post_75 = p;
            p = p + 1l;
            switch((signed int)*tmp_post_75)
            {
              case 0:
              {
                opt = 13;
                break;
              }
              case 45:
              {
                signed int return_value_strcmp_76;
                return_value_strcmp_76=strcmp(p, "to");
                if(return_value_strcmp_76 == 0)
                  opt = 29;

              }
            }
          }

          break;
        }
        case 115:
        {
          tmp_post_78 = p;
          p = p + 1l;
          switch((signed int)*tmp_post_78)
          {
            case 101:
            {
              signed int return_value_strcmp_79;
              return_value_strcmp_79=strcmp(p, "ed");
              if(return_value_strcmp_79 == 0)
                opt = 14;

              break;
            }
            case 112:
            {
              if((signed int)*p == 0)
                opt = 35;

              break;
            }
            case 116:
            {
              signed int return_value_strcmp_80;
              return_value_strcmp_80=strcmp(p, "ep");
              if(return_value_strcmp_80 == 0)
                opt = 21;

            }
          }
          break;
        }
        case 116:
        {
          tmp_post_81 = p;
          p = p + 1l;
          switch((signed int)*tmp_post_81)
          {
            case 109:
            {
              signed int return_value_strcmp_82;
              return_value_strcmp_82=strcmp(p, "ss");
              if(return_value_strcmp_82 == 0)
                opt = 16;

              break;
            }
            case 111:
              if((signed int)*p == 0)
                opt = 3;

          }
        }
      }
    }

    switch(opt)
    {
      case 0:
      {
        *last_arg = (signed int)(arg - &argv[(signed long int)0]);
        return 3;
      }
      case 1:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi_84;
        return_value_atoi_84=atoi(*arg);
        freecell_solver_user_limit_depth(instance, return_value_atoi_84);
        goto __CPROVER_DUMP_L276;
      }
      case 2:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol_85;
        return_value_atol_85=atol(*arg);
        freecell_solver_user_limit_iterations_long(instance, return_value_atol_85);
        goto __CPROVER_DUMP_L276;
      }
      case 3:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__4__ret;
        char *fcs_user_errstr;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__4__ret=freecell_solver_user_set_tests_order(instance, *arg, &fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__4__ret == 0))
        {
          char *errstr;
          unsigned long int return_value_strlen_86;
          return_value_strlen_86=strlen(fcs_user_errstr);
          void *return_value_malloc_87;
          return_value_malloc_87=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_86 + (unsigned long int)500));
          errstr = (char *)return_value_malloc_87;
          sprintf(errstr, "Error in tests' order!\n%s\n", fcs_user_errstr);
          free((void *)fcs_user_errstr);
          *error_string = errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 4:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi_90;
        return_value_atoi_90=atoi(*arg);
        signed int return_value_freecell_solver_user_set_num_freecells_91;
        return_value_freecell_solver_user_set_num_freecells_91=freecell_solver_user_set_num_freecells(instance, return_value_atoi_90);
        if(!(return_value_freecell_solver_user_set_num_freecells_91 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__5__2__errstr;
          void *return_value_malloc_88;
          return_value_malloc_88=malloc(sizeof(char) /*1ul*/  * (unsigned long int)500);
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__5__2__errstr = (char *)return_value_malloc_88;
          signed int return_value_freecell_solver_user_get_max_num_freecells_89;
          return_value_freecell_solver_user_get_max_num_freecells_89=freecell_solver_user_get_max_num_freecells();
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__5__2__errstr, "Error! The freecells' number exceeds the maximum of %i.\nRecompile the program if you wish to have more.\n", return_value_freecell_solver_user_get_max_num_freecells_89);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__5__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 5:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi_94;
        return_value_atoi_94=atoi(*arg);
        signed int return_value_freecell_solver_user_set_num_stacks_95;
        return_value_freecell_solver_user_set_num_stacks_95=freecell_solver_user_set_num_stacks(instance, return_value_atoi_94);
        if(!(return_value_freecell_solver_user_set_num_stacks_95 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__6__2__errstr;
          void *return_value_malloc_92;
          return_value_malloc_92=malloc(sizeof(char) /*1ul*/  * (unsigned long int)500);
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__6__2__errstr = (char *)return_value_malloc_92;
          signed int return_value_freecell_solver_user_get_max_num_stacks_93;
          return_value_freecell_solver_user_get_max_num_stacks_93=freecell_solver_user_get_max_num_stacks();
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__6__2__errstr, "Error! The stacks' number exceeds the maximum of %i.\nRecompile the program if you wish to have more.\n", return_value_freecell_solver_user_get_max_num_stacks_93);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__6__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 6:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi_98;
        return_value_atoi_98=atoi(*arg);
        signed int return_value_freecell_solver_user_set_num_decks_99;
        return_value_freecell_solver_user_set_num_decks_99=freecell_solver_user_set_num_decks(instance, return_value_atoi_98);
        if(!(return_value_freecell_solver_user_set_num_decks_99 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__7__2__errstr;
          void *return_value_malloc_96;
          return_value_malloc_96=malloc(sizeof(char) /*1ul*/  * (unsigned long int)500);
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__7__2__errstr = (char *)return_value_malloc_96;
          signed int return_value_freecell_solver_user_get_max_num_decks_97;
          return_value_freecell_solver_user_get_max_num_decks_97=freecell_solver_user_get_max_num_decks();
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__7__2__errstr, "Error! The decks' number exceeds the maximum of %i.\nRecopmile the program if you wish to have more.\n", return_value_freecell_solver_user_get_max_num_decks_97);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__7__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 7:
      {
        signed int sbb;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp_101;
        return_value_strcmp_101=strcmp(*arg, "suit");
        if(return_value_strcmp_101 == 0)
          sbb = 1;

        else
        {
          return_value_strcmp_100=strcmp(*arg, "rank");
          if(return_value_strcmp_100 == 0)
            sbb = 2;

          else
            sbb = 0;
        }
        freecell_solver_user_set_sequences_are_built_by_type(instance, sbb);
        goto __CPROVER_DUMP_L276;
      }
      case 8:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp_102;
        return_value_strcmp_102=strcmp(*arg, "unlimited");
        freecell_solver_user_set_sequence_move(instance, (signed int)!(return_value_strcmp_102 != 0));
        goto __CPROVER_DUMP_L276;
      }
      case 9:
      {
        signed int es_fill;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp_104;
        return_value_strcmp_104=strcmp(*arg, "kings");
        if(return_value_strcmp_104 == 0)
          es_fill = 1;

        else
        {
          return_value_strcmp_103=strcmp(*arg, "none");
          if(return_value_strcmp_103 == 0)
            es_fill = 2;

          else
            es_fill = 0;
        }
        freecell_solver_user_set_empty_stacks_filled_by(instance, es_fill);
        goto __CPROVER_DUMP_L276;
      }
      case 10:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__ret;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__ret=freecell_solver_user_apply_preset(instance, *arg);
        if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__ret == 1)
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__2__errstr;
          unsigned long int return_value_strlen_105;
          return_value_strlen_105=strlen(*arg);
          void *return_value_malloc_106;
          return_value_malloc_106=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_105 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__2__errstr = (char *)return_value_malloc_106;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__2__errstr, "Unknown game \"%s\"!\n\n", *arg);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        else
          if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__ret == 2)
          {
            char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__3__errstr;
            unsigned long int return_value_strlen_107;
            return_value_strlen_107=strlen(*arg);
            void *return_value_malloc_108;
            return_value_malloc_108=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_107 + (unsigned long int)500));
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__3__errstr = (char *)return_value_malloc_108;
            sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__3__errstr, "The game \"%s\" exceeds the maximal number of freecells in the program.\nModify the file \"config.h\" and recompile, if you wish to solve one of its boards.\n", *arg);
            *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__3__errstr;
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          else
            if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__ret == 3)
            {
              char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__4__errstr;
              unsigned long int return_value_strlen_109;
              return_value_strlen_109=strlen(*arg);
              void *return_value_malloc_110;
              return_value_malloc_110=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_109 + (unsigned long int)500));
              freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__4__errstr = (char *)return_value_malloc_110;
              sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__4__errstr, "The game \"%s\" exceeds the maximal number of stacks in the program.\nModify the file \"config.h\" and recompile, if you wish to solve one of its boards.\n", *arg);
              *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__4__errstr;
              *last_arg = (signed int)(arg - &argv[(signed long int)0]);
              return 5;
            }

            else
              if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__ret == 0))
              {
                char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__5__errstr;
                unsigned long int return_value_strlen_111;
                return_value_strlen_111=strlen(*arg);
                void *return_value_malloc_112;
                return_value_malloc_112=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_111 + (unsigned long int)500));
                freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__5__errstr = (char *)return_value_malloc_112;
                sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__5__errstr, "The game \"%s\" exceeds the limits of the program.\nModify the file \"config.h\" and recompile, if you wish to solve one of its boards.\n", *arg);
                *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__11__5__errstr;
                *last_arg = (signed int)(arg - &argv[(signed long int)0]);
                return 5;
              }

        goto __CPROVER_DUMP_L276;
      }
      case 11:
      {
        signed int method;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp_118;
        return_value_strcmp_118=strcmp(*arg, "soft-dfs");
        if(return_value_strcmp_118 == 0)
          tmp_if_expr_120 = (_Bool)1;

        else
        {
          return_value_strcmp_119=strcmp(*arg, "dfs");
          tmp_if_expr_120 = !(return_value_strcmp_119 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_120)
          method = 1;

        else
        {
          return_value_strcmp_117=strcmp(*arg, "bfs");
          if(return_value_strcmp_117 == 0)
            method = 2;

          else
          {
            return_value_strcmp_116=strcmp(*arg, "a-star");
            if(return_value_strcmp_116 == 0)
              method = 3;

            else
            {
              return_value_strcmp_115=strcmp(*arg, "random-dfs");
              if(return_value_strcmp_115 == 0)
                method = 5;

              else
              {
                char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__12__6__errstr;
                unsigned long int return_value_strlen_113;
                return_value_strlen_113=strlen(*arg);
                void *return_value_malloc_114;
                return_value_malloc_114=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_113 + (unsigned long int)500));
                freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__12__6__errstr = (char *)return_value_malloc_114;
                sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__12__6__errstr, "Unknown solving method \"%s\".\n", *arg);
                *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__12__6__errstr;
                *last_arg = (signed int)(arg - &argv[(signed long int)0]);
                return 5;
              }
            }
          }
        }
        freecell_solver_user_set_solving_method(instance, method);
        goto __CPROVER_DUMP_L276;
      }
      case 12:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int i;
        double befs_weights[6l];
        fc_solve_set_weights(*arg, befs_weights);
        i = 0;
        for( ; !(i >= 6); i = i + 1)
          freecell_solver_user_set_a_star_weight(instance, i, befs_weights[(signed long int)i]);
        goto __CPROVER_DUMP_L276;
      }
      case 13:
      {
        freecell_solver_user_set_solution_optimization(instance, 1);
        goto __CPROVER_DUMP_L276;
      }
      case 14:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi_121;
        return_value_atoi_121=atoi(*arg);
        freecell_solver_user_set_random_seed(instance, return_value_atoi_121);
        goto __CPROVER_DUMP_L276;
      }
      case 15:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol_122;
        return_value_atol_122=atol(*arg);
        freecell_solver_user_limit_num_states_in_collection_long(instance, return_value_atol_122);
        goto __CPROVER_DUMP_L276;
      }
      case 16:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol_123;
        return_value_atol_123=atol(*arg);
        freecell_solver_set_stored_states_trimming_limit(instance, return_value_atol_123);
        goto __CPROVER_DUMP_L276;
      }
      case 17:
      {
        freecell_solver_user_next_instance(instance);
        goto __CPROVER_DUMP_L276;
      }
      case 18:
      {
        freecell_solver_user_next_flare(instance);
        goto __CPROVER_DUMP_L276;
      }
      case 19:

      case 20:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__20__ret;
        if(opt == 19)
        {
          return_value_freecell_solver_user_next_soft_thread_124=freecell_solver_user_next_soft_thread(instance);
          tmp_if_expr_126 = return_value_freecell_solver_user_next_soft_thread_124;
        }

        else
        {
          return_value_freecell_solver_user_next_hard_thread_125=freecell_solver_user_next_hard_thread(instance);
          tmp_if_expr_126 = return_value_freecell_solver_user_next_hard_thread_125;
        }
        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__20__ret = tmp_if_expr_126;
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__20__ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__20__1__errstr;
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__20__1__errstr=strdup("The maximal number of soft threads has been exceeded\n");
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__20__1__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 21:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_atoi_127;
        return_value_atoi_127=atoi(*arg);
        freecell_solver_user_set_soft_thread_step(instance, return_value_atoi_127);
        goto __CPROVER_DUMP_L276;
      }
      case 22:
      {
        freecell_solver_user_set_reparent_states(instance, 1);
        goto __CPROVER_DUMP_L276;
      }
      case 23:
      {
        freecell_solver_user_set_calc_real_depth(instance, 1);
        goto __CPROVER_DUMP_L276;
      }
      case 24:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_soft_thread_name(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 25:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_flare_name(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 26:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_hard_thread_prelude(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 27:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_set_flares_plan(instance, *arg);
        goto __CPROVER_DUMP_L276;
      }
      case 28:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        double return_value_atof_128;
        return_value_atof_128=atof(*arg);
        freecell_solver_user_set_flares_iters_factor(instance, return_value_atof_128);
        goto __CPROVER_DUMP_L276;
      }
      case 29:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__ret;
        char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__fcs_user_errstr;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__ret=freecell_solver_user_set_optimization_scan_tests_order(instance, *arg, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__2__errstr;
          unsigned long int return_value_strlen_129;
          return_value_strlen_129=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__fcs_user_errstr);
          void *return_value_malloc_130;
          return_value_malloc_130=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_129 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__2__errstr = (char *)return_value_malloc_130;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__2__errstr, "Error in the optimization scan's tests' order!\n%s\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__fcs_user_errstr);
          free((void *)freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__fcs_user_errstr);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__29__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 30:
      {
        signed int value;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_strcmp_134;
        return_value_strcmp_134=strcmp(*arg, "none");
        if(return_value_strcmp_134 == 0)
          value = 0;

        else
        {
          return_value_strcmp_133=strcmp(*arg, "dead-end-marks");
          if(return_value_strcmp_133 == 0)
            value = 1;

          else
          {
            char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__30__4__errstr;
            unsigned long int return_value_strlen_131;
            return_value_strlen_131=strlen(*arg);
            void *return_value_malloc_132;
            return_value_malloc_132=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_131 + (unsigned long int)500));
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__30__4__errstr = (char *)return_value_malloc_132;
            sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__30__4__errstr, "Unknown scans' synergy type \"%s\"!\n", *arg);
            *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__30__4__errstr;
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }
        }
        freecell_solver_user_set_scans_synergy(instance, value);
        goto __CPROVER_DUMP_L276;
      }
      case 31:
      {
        freecell_solver_user_reset(instance);
        goto __CPROVER_DUMP_L276;
      }
      case 32:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        if(!(file_nesting_count == 0))
        {
          const char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s;
          char *buffer;
          struct _IO_FILE *f;
          signed long int file_len;
          signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret;
          unsigned long int num_read;
          struct anonymous_36 *args_man;
          signed int num_file_args_to_skip = 0;
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s = *arg;
          do
          {
            return_value___ctype_b_loc_135=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_135)[(signed long int)(signed int)*freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s]) == 0)
              break;

            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s + 1l;
          }
          while((_Bool)1);
          if((signed int)*freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s == 44)
          {
            num_file_args_to_skip=atoi(*arg);
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s + 1l;
          }

          if(!(opened_files_dir == ((const char *)NULL)))
          {
            char *complete_path;
            signed int len;
            unsigned long int return_value_strlen_136;
            return_value_strlen_136=strlen(opened_files_dir);
            len = (signed int)return_value_strlen_136;
            unsigned long int return_value_strlen_137;
            return_value_strlen_137=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s);
            len = len + (signed int)return_value_strlen_137;
            len = len + 1;
            void *return_value_malloc_138;
            return_value_malloc_138=malloc(sizeof(char) /*1ul*/  * (unsigned long int)len);
            complete_path = (char *)return_value_malloc_138;
            sprintf(complete_path, "%s%s", opened_files_dir, freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s);
            f=fopen(complete_path, "rt");
            free((void *)complete_path);
          }

          else
            f = (struct _IO_FILE *)(void *)0;
          if(f == ((struct _IO_FILE *)NULL))
            f=fopen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s, "rt");

          if(f == ((struct _IO_FILE *)NULL))
          {
            char *err_str;
            unsigned long int return_value_strlen_139;
            return_value_strlen_139=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s);
            void *return_value_malloc_140;
            return_value_malloc_140=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_139 + (unsigned long int)100));
            err_str = (char *)return_value_malloc_140;
            sprintf(err_str, "Could not open file \"%s\"!\nQuitting.\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__s);
            *error_string = err_str;
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          fseek(f, (signed long int)0, 2);
          file_len=ftell(f);
          void *return_value_malloc_141;
          return_value_malloc_141=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(file_len + (signed long int)1));
          buffer = (char *)return_value_malloc_141;
          if(buffer == ((char *)NULL))
          {
            *error_string=strdup("Could not allocate enough memory to parse the file. Quitting.\n");
            fclose(f);
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          fseek(f, (signed long int)0, 0);
          num_read=fread((void *)buffer, (unsigned long int)1, (unsigned long int)file_len, f);
          fclose(f);
          buffer[(signed long int)num_read] = (char)0;
          args_man=fc_solve_args_man_alloc();
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret=fc_solve_args_man_chop(args_man, buffer);
          free((void *)buffer);
          if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret == 0))
          {
            *error_string=strdup("Could not parse the file. Quitting\n");
            fc_solve_args_man_free(args_man);
            *last_arg = (signed int)(arg - &argv[(signed long int)0]);
            return 5;
          }

          if(!(num_file_args_to_skip >= args_man->argc))
          {
            freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret=freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(instance, args_man->argc - num_file_args_to_skip, (const char **)(void *)(args_man->argv + (signed long int)num_file_args_to_skip), 0, known_parameters, callback, callback_context, error_string, last_arg, file_nesting_count < 0 ? file_nesting_count : file_nesting_count - 1, opened_files_dir);
            if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret == 3))
            {
              if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret == 0))
              {
                fc_solve_args_man_free(args_man);
                return freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__32__3__ret;
              }

            }

          }

          fc_solve_args_man_free(args_man);
        }

        goto __CPROVER_DUMP_L276;
      }
      case 33:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__ret;
        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__ret=freecell_solver_user_cmd_line_read_cmd_line_preset(instance, *arg, known_parameters, error_string, file_nesting_count, opened_files_dir);
        if(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__ret == 5)
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__2__err_str;
          unsigned long int return_value_strlen_142;
          return_value_strlen_142=strlen(*arg);
          void *return_value_malloc_143;
          return_value_malloc_143=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_142 + (unsigned long int)100));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__2__err_str = (char *)return_value_malloc_143;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__2__err_str, "Unable to load the \"%s\" configuration!\n", *arg);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__2__err_str;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        else
          if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__ret == 3))
          {
            if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__ret == 0))
              return freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__33__ret;

          }

        goto __CPROVER_DUMP_L276;
      }
      case 34:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__fcs_user_errstr;
        signed int min_depth;
        signed int ret;
        const char *s;
        min_depth = 0;
        s = *arg;
        do
        {
          return_value___ctype_b_loc_144=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc_144)[(signed long int)(signed int)*s]) == 0)
            break;

          s = s + 1l;
        }
        while((_Bool)1);
        if((signed int)*s == 44)
        {
          min_depth=atoi(*arg);
          s = s + 1l;
        }

        ret=freecell_solver_user_set_depth_tests_order(instance, min_depth, *arg, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__fcs_user_errstr);
        if(!(ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__3__errstr;
          unsigned long int return_value_strlen_145;
          return_value_strlen_145=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__fcs_user_errstr);
          void *return_value_malloc_146;
          return_value_malloc_146=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_145 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__3__errstr = (char *)return_value_malloc_146;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__3__errstr, "Error in depth tests' order!\n%s\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__fcs_user_errstr);
          free((void *)freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__fcs_user_errstr);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__34__2__3__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 35:
      {
        signed int freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__ret;
        char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__fcs_user_errstr;
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__ret=freecell_solver_user_set_pruning(instance, *arg, &freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__fcs_user_errstr);
        if(!(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__ret == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__2__errstr;
          unsigned long int return_value_strlen_147;
          return_value_strlen_147=strlen(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__fcs_user_errstr);
          void *return_value_malloc_148;
          return_value_malloc_148=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_147 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__2__errstr = (char *)return_value_malloc_148;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__2__errstr, "Error in the optimization scan's pruning!\n%s\n", freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__fcs_user_errstr);
          free((void *)freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__fcs_user_errstr);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__35__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

        goto __CPROVER_DUMP_L276;
      }
      case 36:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed long int return_value_atol_149;
        return_value_atol_149=atol(*arg);
        freecell_solver_user_set_cache_limit(instance, return_value_atol_149);
        goto __CPROVER_DUMP_L276;
      }
      case 37:
      {
        arg = arg + 1l;
        if(arg == arg_argc)
        {
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 4;
        }

        signed int return_value_freecell_solver_user_set_flares_choice_152;
        return_value_freecell_solver_user_set_flares_choice_152=freecell_solver_user_set_flares_choice(instance, *arg);
        if(!(return_value_freecell_solver_user_set_flares_choice_152 == 0))
        {
          char *freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__37__2__errstr;
          unsigned long int return_value_strlen_150;
          return_value_strlen_150=strlen(*arg);
          void *return_value_malloc_151;
          return_value_malloc_151=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_150 + (unsigned long int)500));
          freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__37__2__errstr = (char *)return_value_malloc_151;
          sprintf(freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__37__2__errstr, "Unknown flares choice argument '%s'.\n", *arg);
          *error_string = freecell_solver_user_cmd_line_parse_args_with_file_nesting_count__1__1__1__3__37__2__errstr;
          *last_arg = (signed int)(arg - &argv[(signed long int)0]);
          return 5;
        }

      }
      default:
      {

      __CPROVER_DUMP_L276:
        ;
        arg = arg + 1l;
      }
    }
  }
  *last_arg = (signed int)(arg - &argv[(signed long int)0]);
  return 0;
}

// freecell_solver_user_cmd_line_read_cmd_line_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 260
extern signed int freecell_solver_user_cmd_line_read_cmd_line_preset(void *instance, const char * const preset_name, const char **known_parameters, char **error_string, signed int file_nesting_count, const char *opened_files_dir)
{
  signed int status;
  struct anonymous_36 *preset_args;
  char *dir = (char *)(void *)0;
  status=read_preset(preset_name, &preset_args, &dir, (const char *)(void *)0);
  if(!(status == 0))
  {
    *error_string=strdup("Could not read preset.");
    return 5;
  }

  else
  {
    signed int ret;
    signed int last_arg = 0;
    ret=freecell_solver_user_cmd_line_parse_args_with_file_nesting_count(instance, preset_args->argc, (const char **)(void *)preset_args->argv, 0, known_parameters, (signed int (*)(void *, signed int, const char **, signed int, signed int *, signed int *, void *))(void *)0, (void *)0, error_string, &last_arg, file_nesting_count < 0 ? file_nesting_count : file_nesting_count - 1, dir != ((char *)NULL) ? dir : opened_files_dir);
    if(!(dir == ((char *)NULL)))
      free((void *)dir);

    fc_solve_args_man_free(preset_args);
    return ret;
  }
}

// freecell_solver_user_current_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1349
extern char * freecell_solver_user_current_state_as_string(void *api_instance, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_instance_struct *instance = user->active_flare->obj;
  char *return_value_fc_solve_state_as_string_1;
  return_value_fc_solve_state_as_string_1=fc_solve_state_as_string(&user->running_state._anon0._anon0.s, &user->initial_state_locs, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, (_Bool)parseable_output, (_Bool)canonized_order_output, (_Bool)display_10_as_t);
  return return_value_fc_solve_state_as_string_1;
}

// freecell_solver_user_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 90
extern void freecell_solver_user_free(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user_free_resources(user);
  free((void *)user);
}

// freecell_solver_user_get_current_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1455
extern signed int freecell_solver_user_get_current_depth(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return user->soft_thread->method_specific.soft_dfs.depth;
}

// freecell_solver_user_get_current_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2432
const char * freecell_solver_user_get_current_soft_thread_name(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_hard_thread_struct *hard_thread = user->active_flare->obj->current_hard_thread;
  return (hard_thread->soft_threads + (signed long int)hard_thread->st_idx)->name;
}

// freecell_solver_user_get_invalid_state_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1741
extern char * freecell_solver_user_get_invalid_state_error_string(void *api_instance, signed int print_ts)
{
  char string[80l];
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(user->state_validity_ret == 0)
  {
    char *return_value_strdup_1;
    return_value_strdup_1=strdup("");
    return return_value_strdup_1;
  }

  _Bool tmp_if_expr_2;
  if(user->state_validity_ret == 3)
    sprintf(string, "%s", (const void *)"There's an empty slot in one of the stacks.");

  else
  {
    if(user->state_validity_ret == 2)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = user->state_validity_ret == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      char card_str[10l];
      fc_solve_card_perl2user(user->state_validity_card, card_str, (_Bool)print_ts);
      sprintf(string, "%s%s.", user->state_validity_ret == 2 ? "There's an extra card: " : "There's a missing card: ", (const void *)card_str);
    }

    else
      if(user->state_validity_ret == 4)
        sprintf(string, "%s.", (const void *)"Not enough input");

  }
  char *return_value_strdup_3;
  return_value_strdup_3=strdup(string);
  return return_value_strdup_3;
}

// freecell_solver_user_get_last_error_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 366
const char * freecell_solver_user_get_last_error_string(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return user->error_string;
}

// freecell_solver_user_get_lib_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2425
const char * freecell_solver_user_get_lib_version(void *api_instance)
{
  return "3.26.0";
}

// freecell_solver_user_get_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1653
extern signed int freecell_solver_user_get_limit_iterations(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return (signed int)user->active_flare->obj->max_num_checked_states;
}

// freecell_solver_user_get_max_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 174
extern signed int freecell_solver_user_get_max_num_decks(void)
{
  return 2;
}

// freecell_solver_user_get_max_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 160
extern signed int freecell_solver_user_get_max_num_freecells(void)
{
  return 8;
}

// freecell_solver_user_get_max_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 167
extern signed int freecell_solver_user_get_max_num_stacks(void)
{
  return 10;
}

// freecell_solver_user_get_moves_left
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1660
extern signed int freecell_solver_user_get_moves_left(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(user->ret_code == 0)
    return user->active_flare->moves_seq.num_moves - user->active_flare->next_move;

  else
    return 0;
}

// freecell_solver_user_get_moves_sequence
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2477
extern signed int freecell_solver_user_get_moves_sequence(void *api_instance, struct anonymous_11 * const moves_seq)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(!(user->ret_code == 0))
    return -2;

  else
  {
    struct anonymous_1 *instance_item;
    instance_item=get_current_instance_item(user);
    struct anonymous_2 * const flare = &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx];
    moves_seq->num_moves = flare->moves_seq.num_moves;
    void *return_value_memdup_1;
    return_value_memdup_1=memdup_link1((void *)flare->moves_seq.moves, sizeof(struct anonymous_4) /*4ul*/  * (unsigned long int)flare->moves_seq.num_moves);
    moves_seq->moves = (struct anonymous_4 *)return_value_memdup_1;
    return 0;
  }
}

// freecell_solver_user_get_next_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1296
extern signed int freecell_solver_user_get_next_move(void *api_instance, struct anonymous_4 *user_move)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_instance_struct *instance = user->active_flare->obj;
  signed int tmp_post_1;
  if(user->ret_code == 0)
  {
    signed int ret;
    const struct anonymous_1 *instance_item;
    instance_item=get_current_instance_item(user);
    struct anonymous_2 *flare = &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx];
    if(flare->next_move == flare->moves_seq.num_moves)
      ret = 1;

    else
    {
      ret = 0;
      tmp_post_1 = flare->next_move;
      flare->next_move = flare->next_move + 1;
      *user_move = flare->moves_seq.moves[(signed long int)tmp_post_1];
    }
    if(ret == 0)
    {
      struct anonymous_6 pass;
      FCS_STATE_keyval_pair_to_kv_link1(&pass, &user->running_state);
      fc_solve_apply_move(&pass, (struct anonymous_7 *)(void *)0, *user_move, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num);
    }

    return ret;
  }

  else
    return 1;
}

// freecell_solver_user_get_num_soft_threads_in_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2132
extern signed int freecell_solver_user_get_num_soft_threads_in_instance(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return user->active_flare->obj->next_soft_thread_id;
}

// freecell_solver_user_get_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2027
extern signed int freecell_solver_user_get_num_states_in_collection(void *api_instance)
{
  signed long int return_value_freecell_solver_user_get_num_states_in_collection_long_1;
  return_value_freecell_solver_user_get_num_states_in_collection_long_1=freecell_solver_user_get_num_states_in_collection_long(api_instance);
  return (signed int)return_value_freecell_solver_user_get_num_states_in_collection_long_1;
}

// freecell_solver_user_get_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2020
signed long int freecell_solver_user_get_num_states_in_collection_long(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  return (user->iterations_board_started_at.num_states_in_collection + user->active_flare->obj_stats.num_states_in_collection) - user->init_num_checked_states.num_states_in_collection;
}

// freecell_solver_user_get_num_times
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1648
extern signed int freecell_solver_user_get_num_times(void *api_instance)
{
  signed long int return_value_freecell_solver_user_get_num_times_long_1;
  return_value_freecell_solver_user_get_num_times_long_1=freecell_solver_user_get_num_times_long(api_instance);
  return (signed int)return_value_freecell_solver_user_get_num_times_long_1;
}

// freecell_solver_user_get_num_times_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 103
extern signed long int freecell_solver_user_get_num_times_long(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed long int tmp_if_expr_1;
  if(!(user->active_flare->obj->num_checked_states >= user->active_flare->obj_stats.num_checked_states))
    tmp_if_expr_1 = user->active_flare->obj_stats.num_checked_states;

  else
    tmp_if_expr_1 = user->active_flare->obj->num_checked_states;
  return (user->iterations_board_started_at.num_checked_states + tmp_if_expr_1) - user->init_num_checked_states.num_checked_states;
}

// freecell_solver_user_iter_state_as_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 236
extern char * freecell_solver_user_iter_state_as_string(void *api_instance, void *ptr_state_void, signed int parseable_output, signed int canonized_order_output, signed int display_10_as_t)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_instance_struct * const instance = user->active_flare->obj;
  char *return_value_fc_solve_state_as_string_1;
  return_value_fc_solve_state_as_string_1=fc_solve_state_as_string(((struct anonymous_13 *)ptr_state_void)->key, &((struct anonymous_13 *)ptr_state_void)->locs, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, (_Bool)parseable_output, (_Bool)canonized_order_output, (_Bool)display_10_as_t);
  return return_value_fc_solve_state_as_string_1;
}

// freecell_solver_user_limit_current_instance_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 316
extern void freecell_solver_user_limit_current_instance_iterations(void *api_instance, signed int max_iters)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  (user->instances_list + (signed long int)user->current_instance_idx)->limit = max_iters;
}

// freecell_solver_user_limit_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 150
extern void freecell_solver_user_limit_depth(void *api_instance, signed int max_depth)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->max_depth = max_depth;
}

// freecell_solver_user_limit_iterations
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 308
extern void freecell_solver_user_limit_iterations(void *api_instance, signed int max_iters)
{
  freecell_solver_user_limit_iterations_long(api_instance, (signed long int)max_iters);
}

// freecell_solver_user_limit_iterations_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 53
extern void freecell_solver_user_limit_iterations_long(void *api_instance, signed long int max_iters)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->current_iterations_limit = max_iters;
}

// freecell_solver_user_limit_num_states_in_collection
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2055
extern void freecell_solver_user_limit_num_states_in_collection(void *api_instance, signed int max_num_states)
{
  freecell_solver_user_limit_num_states_in_collection_long(api_instance, (signed long int)max_num_states);
}

// freecell_solver_user_limit_num_states_in_collection_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 255
extern void freecell_solver_user_limit_num_states_in_collection_long(void *api_instance, signed long int max_num_states)
{
  struct anonymous *user = (struct anonymous *)api_instance;
  if(!(max_num_states >= 0l))
  {
    user->active_flare->obj->max_num_states_in_collection = (signed long int)-1;
    user->active_flare->obj->effective_max_num_states_in_collection = 9223372036854775807L;
  }

  else
  {
    user->active_flare->obj->max_num_states_in_collection = max_num_states;
    user->active_flare->obj->effective_max_num_states_in_collection = user->active_flare->obj->max_num_states_in_collection;
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// freecell_solver_user_move_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1680
extern char * freecell_solver_user_move_to_string(struct anonymous_4 move, signed int standard_notation)
{
  char *return_value_fc_solve_move_to_string_1;
  return_value_fc_solve_move_to_string_1=fc_solve_move_to_string(move, standard_notation);
  return return_value_fc_solve_move_to_string_1;
}

// freecell_solver_user_move_to_string_w_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1688
extern char * freecell_solver_user_move_to_string_w_state(void *api_instance, struct anonymous_4 move, signed int standard_notation)
{
  struct fc_solve_instance_struct *instance;
  struct anonymous * const user = (struct anonymous *)api_instance;
  instance = user->active_flare->obj;
  char *return_value_fc_solve_move_to_string_w_state_1;
  return_value_fc_solve_move_to_string_w_state_1=fc_solve_move_to_string_w_state(&user->running_state, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num, move, standard_notation);
  return return_value_fc_solve_move_to_string_w_state_1;
}

// freecell_solver_user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 341
extern signed int freecell_solver_user_next_flare(void *api_instance)
{
  signed int return_value_user_next_flare_1;
  return_value_user_next_flare_1=user_next_flare((struct anonymous *)api_instance);
  return return_value_user_next_flare_1;
}

// freecell_solver_user_next_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 279
extern signed int freecell_solver_user_next_hard_thread(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_soft_thread_struct *soft_thread;
  soft_thread=fc_solve_new_hard_thread_link1(user->active_flare->obj);
  if(soft_thread == ((struct fc_solve_soft_thread_struct *)NULL))
    return 1;

  else
  {
    user->soft_thread = soft_thread;
    return 0;
  }
}

// freecell_solver_user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 337
extern signed int freecell_solver_user_next_instance(void *api_instance)
{
  signed int return_value_user_next_instance_1;
  return_value_user_next_instance_1=user_next_instance((struct anonymous *)api_instance);
  return return_value_user_next_instance_1;
}

// freecell_solver_user_next_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 270
extern signed int freecell_solver_user_next_soft_thread(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_soft_thread_struct *soft_thread;
  soft_thread=fc_solve_new_soft_thread(user->soft_thread->hard_thread);
  if(soft_thread == ((struct fc_solve_soft_thread_struct *)NULL))
    return 1;

  else
  {
    user->soft_thread = soft_thread;
    return 0;
  }
}

// freecell_solver_user_recycle
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 312
extern void freecell_solver_user_recycle(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed int i = 0;
  for( ; !(i >= user->num_instances); i = i + 1)
    recycle_instance(user, i);
  user->iterations_board_started_at.num_checked_states = (signed long int)0;
  user->iterations_board_started_at.num_states_in_collection = (signed long int)0;
  if(!(user->state_string_copy == ((char *)NULL)))
  {
    free((void *)user->state_string_copy);
    user->state_string_copy = (char *)(void *)0;
  }

}

// freecell_solver_user_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 349
extern signed int freecell_solver_user_reset(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user_free_resources(user);
  user_initialize(user);
  return 0;
}

// freecell_solver_user_resume_solution
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 943
extern signed int freecell_solver_user_resume_solution(void *api_instance)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct anonymous_44 init_num_checked_states;
  signed int ret = 1;
  signed int tmp_post_1;
  signed int tmp_if_expr_3;
  signed int return_value_normalize_iters_quota_2;
  signed long int tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_9;
  signed int return_value_get_flare_move_count_7;
  signed int return_value_get_flare_move_count_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  do
  {
    struct anonymous_1 *instance_item;
    instance_item=get_current_instance_item(user);
    if(instance_item->current_plan_item_idx == instance_item->num_plan_items)
    {
      if(!(instance_item->all_plan_items_finished_so_far == 0))
      {
        recycle_instance(user, user->current_instance_idx);
        user->current_instance_idx = user->current_instance_idx + 1;
        continue;
      }

      else
      {
        instance_item->all_plan_items_finished_so_far = 1;
        instance_item->current_plan_item_idx = 0;
      }
    }

    const struct anonymous_0 *current_plan_item;
    tmp_post_1 = instance_item->current_plan_item_idx;
    instance_item->current_plan_item_idx = instance_item->current_plan_item_idx + 1;
    current_plan_item = &instance_item->plan[(signed long int)tmp_post_1];
    if(current_plan_item->type == FLARES_PLAN_CHECKPOINT)
    {
      if(instance_item->minimal_solution_flare_idx >= 0)
      {
        user->active_flare = &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx];
        user->init_num_checked_states = user->active_flare->obj_stats;
        user->ret_code = 0;
        ret = user->ret_code;
        break;
      }

    }

    else
    {
      signed int flare_iters_quota;
      if(current_plan_item->type == FLARES_PLAN_RUN_INDEFINITELY)
        tmp_if_expr_3 = -1;

      else
      {
        return_value_normalize_iters_quota_2=normalize_iters_quota((signed int)(user->flares_iters_factor * (double)current_plan_item->count_iters));
        tmp_if_expr_3 = return_value_normalize_iters_quota_2;
      }
      flare_iters_quota = tmp_if_expr_3;
      const signed int flare_idx = current_plan_item->flare_idx;
      struct anonymous_2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      user->active_flare = flare;
      const _Bool is_start_of_flare_solving = flare->ret_code == 9;
      if(!(is_start_of_flare_solving == (_Bool)0))
      {
        struct fc_solve_instance_struct *freecell_solver_user_resume_solution__1__1__3__instance = user->active_flare->obj;
        signed int return_value_fc_solve_initial_user_state_to_c_proto_4;
        return_value_fc_solve_initial_user_state_to_c_proto_4=fc_solve_initial_user_state_to_c_proto(user->state_string_copy, &user->state, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.freecells_num, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.stacks_num, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.decks_num, user->indirect_stacks_buffer);
        if(!(return_value_fc_solve_initial_user_state_to_c_proto_4 == 0))
        {
          user->ret_code = 8;
          user->state_validity_ret = 4;
          return user->ret_code;
        }

        user->state_validity_ret=fc_solve_check_state_validity(&user->state, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.freecells_num, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.stacks_num, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.decks_num, &user->state_validity_card);
        if(!(user->state_validity_ret == 0))
        {
          user->ret_code = 8;
          return user->ret_code;
        }

        fc_solve_init_locs(&user->initial_state_locs);
        user->state_locs = user->initial_state_locs;
        struct anonymous_6 state_pass;
        FCS_STATE_keyval_pair_to_kv_link1(&state_pass, &user->state);
        struct anonymous_6 pass;
        FCS_STATE_keyval_pair_to_kv_link1(&pass, &user->running_state);
        *(&pass)->key = *(&state_pass)->key;
        *(&pass)->val = *(&state_pass)->val;
        (&pass)->val->stacks_copy_on_write_flags = 0;
        struct anonymous_6 initial_pass;
        FCS_STATE_keyval_pair_to_kv_link1(&initial_pass, &user->initial_non_canonized_state);
        *(&initial_pass)->key = *(&state_pass)->key;
        *(&initial_pass)->val = *(&state_pass)->val;
        (&initial_pass)->val->stacks_copy_on_write_flags = 0;
        fc_solve_canonize_state_with_locs(&state_pass, &user->state_locs, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.freecells_num, (signed int)freecell_solver_user_resume_solution__1__1__3__instance->game_params.stacks_num);
        user->trace_solution_state_locs = user->state_locs;
        fc_solve_init_instance(user->active_flare->obj);
      }

      signed long int limits[3l];
      signed int limit_idx;
      signed long int mymin;
      signed long int new_lim;
      limits[(signed long int)0] = (signed long int)instance_item->limit;
      limits[(signed long int)1] = user->current_iterations_limit;
      if(!(flare_iters_quota >= 0))
        tmp_if_expr_5 = (signed long int)-1;

      else
        tmp_if_expr_5 = user->iterations_board_started_at.num_checked_states + (signed long int)flare_iters_quota;
      limits[(signed long int)2] = tmp_if_expr_5;
      mymin = limits[(signed long int)0];
      limit_idx = 1;
      for( ; !(limit_idx >= 3); limit_idx = limit_idx + 1)
      {
        new_lim = limits[(signed long int)limit_idx];
        if(new_lim >= 0l)
          mymin = mymin < (signed long int)0 ? new_lim : (mymin < new_lim ? mymin : new_lim);

      }
      if(!(mymin >= 0l))
      {
        user->active_flare->obj->max_num_checked_states = (signed long int)-1;
        user->active_flare->obj->effective_max_num_checked_states = 9223372036854775807L;
      }

      else
      {
        user->active_flare->obj->effective_max_num_checked_states = (user->active_flare->obj->num_checked_states + mymin) - user->iterations_board_started_at.num_checked_states;
        user->active_flare->obj->max_num_checked_states = user->active_flare->obj->effective_max_num_checked_states;
      }
      init_num_checked_states.num_checked_states = user->active_flare->obj->num_checked_states;
      user->init_num_checked_states.num_checked_states = init_num_checked_states.num_checked_states;
      init_num_checked_states.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
      user->init_num_checked_states.num_states_in_collection = init_num_checked_states.num_states_in_collection;
      if(!(is_start_of_flare_solving == (_Bool)0))
        fc_solve_start_instance_process_with_board(user->active_flare->obj, &user->state);

      _Bool was_run_now;
      if(flare->ret_code == 5)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = flare->ret_code == 9 ? (_Bool)1 : (_Bool)0;
      was_run_now = tmp_if_expr_6;
      if(!(was_run_now == (_Bool)0))
      {
        flare->ret_code=fc_solve_resume_instance(user->active_flare->obj);
        user->ret_code = flare->ret_code;
        ret = user->ret_code;
        flare->instance_is_ready = (_Bool)0;
      }

      if(!(ret == 5))
        user->all_instances_were_suspended = (_Bool)0;

      user->active_flare->obj_stats.num_checked_states = user->active_flare->obj->num_checked_states;
      user->active_flare->obj_stats.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
      user->iterations_board_started_at.num_checked_states = user->iterations_board_started_at.num_checked_states + (user->active_flare->obj_stats.num_checked_states - init_num_checked_states.num_checked_states);
      user->iterations_board_started_at.num_states_in_collection = user->iterations_board_started_at.num_states_in_collection + (user->active_flare->obj_stats.num_states_in_collection - init_num_checked_states.num_states_in_collection);
      user->init_num_checked_states = user->active_flare->obj_stats;
      if(user->ret_code == 0)
      {
        struct fc_solve_instance_struct *instance = user->active_flare->obj;
        struct anonymous_6 freecell_solver_user_resume_solution__1__1__8__pass;
        FCS_STATE_keyval_pair_to_kv_link1(&freecell_solver_user_resume_solution__1__1__8__pass, &user->state);
        fc_solve_move_stack_normalize(&user->active_flare->obj->solution_moves, &freecell_solver_user_resume_solution__1__1__8__pass, &user->trace_solution_state_locs, (signed int)instance->game_params.freecells_num, (signed int)instance->game_params.stacks_num, (signed int)instance->game_params.decks_num);
        calc_moves_seq(&user->active_flare->obj->solution_moves, &flare->moves_seq);
        flare->next_move = 0;
        if(!(flare->obj->solution_moves.moves == ((struct anonymous_4 *)NULL)))
        {
          free((void *)flare->obj->solution_moves.moves);
          flare->obj->solution_moves.moves = (struct anonymous_4 *)(void *)0;
        }

        user->active_flare->obj_stats.num_checked_states = user->active_flare->obj->num_checked_states;
        user->active_flare->obj_stats.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
        fc_solve_recycle_instance(flare->obj);
        flare->instance_is_ready = (_Bool)1;
        user->trace_solution_state_locs = user->state_locs;
        if(!(instance_item->minimal_solution_flare_idx >= 0))
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_get_flare_move_count_7=get_flare_move_count(user, &instance_item->flares[(signed long int)instance_item->minimal_solution_flare_idx]);
          return_value_get_flare_move_count_8=get_flare_move_count(user, &instance_item->flares[(signed long int)flare_idx]);
          tmp_if_expr_9 = return_value_get_flare_move_count_7 > return_value_get_flare_move_count_8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          instance_item->minimal_solution_flare_idx = flare_idx;

        user->ret_code = 1;
        ret = user->ret_code;
      }

      else
        if(user->ret_code == 1)
        {
          if(!(was_run_now == (_Bool)0))
          {
            fc_solve_recycle_instance(user->active_flare->obj);
            user->active_flare->instance_is_ready = (_Bool)1;
          }

        }

        else
          if(user->ret_code == 5)
          {
            if(user->current_iterations_limit >= 0l)
              tmp_if_expr_10 = user->iterations_board_started_at.num_checked_states >= user->current_iterations_limit ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_10 = (_Bool)0;
            if(tmp_if_expr_10)
              tmp_if_expr_11 = (_Bool)1;

            else
              tmp_if_expr_11 = user->active_flare->obj->num_states_in_collection >= user->active_flare->obj->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_11)
            {
              instance_item->current_plan_item_idx = instance_item->current_plan_item_idx - 1;
              break;
            }

            ret = 1;
            if(instance_item->limit >= 0)
            {
              if(user->active_flare->obj->num_checked_states >= (signed long int)instance_item->limit)
              {
                user->active_flare->obj_stats.num_checked_states = user->active_flare->obj->num_checked_states;
                user->active_flare->obj_stats.num_states_in_collection = user->active_flare->obj->num_states_in_collection;
                recycle_instance(user, user->current_instance_idx);
                user->current_instance_idx = user->current_instance_idx + 1;
                continue;
              }

            }

            instance_item->all_plan_items_finished_so_far = 0;
          }

    }
  }
  while(ret == 1 && !(user->current_instance_idx >= user->num_instances));
  return user->all_instances_were_suspended != (_Bool)0 ? 5 : ret;
}

// freecell_solver_user_set_a_star_weight
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 197
extern signed int freecell_solver_user_set_a_star_weight(void *api_instance, signed int my_index, double weight)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if((unsigned long int)my_index >= 6ul || !(my_index >= 0))
    return 1;

  else
    if(weight < 0.000000)
      return 2;

    else
    {
      user->soft_thread->method_specific.befs.meth.befs.weighting.befs_weights[(signed long int)my_index] = weight;
      return 0;
    }
}

// freecell_solver_user_set_cache_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 386
extern signed int freecell_solver_user_set_cache_limit(void *api_instance, signed long int limit)
{
  return 0;
}

// freecell_solver_user_set_calc_real_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 287
extern void freecell_solver_user_set_calc_real_depth(void *api_instance, signed int calc_real_depth)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~4;
  if(!(calc_real_depth == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)4;

}

// freecell_solver_user_set_depth_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 373
extern signed int freecell_solver_user_set_depth_tests_order(void *api_instance, signed int min_depth, const char *tests_order, char **error_string)
{
  signed int depth_idx;
  signed int ret_code;
  struct anonymous * const user = (struct anonymous *)api_instance;
  *error_string = (char *)(void *)0;
  if(!(min_depth >= 0))
  {
    *error_string=strdup("Depth is negative.");
    return 1;
  }

  else
  {
    if(min_depth == 0)
      depth_idx = 0;

    else
    {
      depth_idx = 0;
      for( ; (_Bool)1; depth_idx = depth_idx + 1)
        if(depth_idx == user->soft_thread->by_depth_tests_order.num + -1)
          goto __CPROVER_DUMP_L6;

        else
          if(!(min_depth >= (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->max_depth))
            goto __CPROVER_DUMP_L6;


    __CPROVER_DUMP_L6:
      ;
      depth_idx = depth_idx + 1;
    }
    if(depth_idx == user->soft_thread->by_depth_tests_order.num)
    {
      user->soft_thread->by_depth_tests_order.num = user->soft_thread->by_depth_tests_order.num + 1;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)user->soft_thread->by_depth_tests_order.by_depth_tests, sizeof(struct anonymous_21) /*24ul*/  * (unsigned long int)user->soft_thread->by_depth_tests_order.num);
      user->soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous_21 *)return_value_realloc_1;
      (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order.num_groups = 0;
      (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order.groups = (struct anonymous_20 *)(void *)0;
    }

    if(depth_idx >= 1)
      (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)(depth_idx - 1))->max_depth = min_depth;

    (user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->max_depth = 0x7fffffff;
    ret_code=fc_solve_apply_tests_order(&(user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)depth_idx)->tests_order, tests_order, error_string);
    signed int further_depth_idx = depth_idx + 1;
    for( ; !(further_depth_idx >= user->soft_thread->by_depth_tests_order.num); further_depth_idx = further_depth_idx + 1)
      fc_solve_free_tests_order_link1(&(user->soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)further_depth_idx)->tests_order);
    user->soft_thread->by_depth_tests_order.num = depth_idx + 1;
    void *return_value_realloc_2;
    return_value_realloc_2=realloc((void *)user->soft_thread->by_depth_tests_order.by_depth_tests, sizeof(struct anonymous_21) /*24ul*/  * (unsigned long int)user->soft_thread->by_depth_tests_order.num);
    user->soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous_21 *)return_value_realloc_2;
    return ret_code;
  }
}

// freecell_solver_user_set_empty_stacks_filled_by
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 187
extern signed int freecell_solver_user_set_empty_stacks_filled_by(void *api_instance, signed int empty_stacks_fill)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(empty_stacks_fill >= 3 || !(empty_stacks_fill >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags & (unsigned char)~(0x3 << 2);
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags | (unsigned char)(empty_stacks_fill << 2);
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_flare_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 297
extern void freecell_solver_user_set_flare_name(void *api_instance, const char *name)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct anonymous_1 *instance_item;
  instance_item=get_current_instance_item(user);
  struct anonymous_2 *flare = &instance_item->flares[(signed long int)(instance_item->num_flares - 1)];
  if(!(flare->name == ((char *)NULL)))
    free((void *)flare->name);

  flare->name=strdup(name);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// freecell_solver_user_set_flares_choice
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 396
extern signed int freecell_solver_user_set_flares_choice(void *api_instance, const char * const new_flares_choice_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(new_flares_choice_string, "fc_solve");
  signed int return_value_strcmp_1;
  if(return_value_strcmp_2 == 0)
    user->flares_choice = (enum FLARES_CHOICE_TYPE)FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN;

  else
  {
    return_value_strcmp_1=strcmp(new_flares_choice_string, "fcpro");
    if(return_value_strcmp_1 == 0)
      user->flares_choice = (enum FLARES_CHOICE_TYPE)FLARES_CHOICE_FCPRO_SOLUTION_LEN;

    else
      return -1;
  }
  return 0;
}

// freecell_solver_user_set_flares_iters_factor
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 401
extern void freecell_solver_user_set_flares_iters_factor(void *api_instance, double new_factor)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->flares_iters_factor = new_factor;
}

// freecell_solver_user_set_flares_plan
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 307
extern signed int freecell_solver_user_set_flares_plan(void *api_instance, const char *flares_plan_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct anonymous_1 *instance_item;
  instance_item=get_current_instance_item(user);
  if(!(instance_item->flares_plan_string == ((char *)NULL)))
    free((void *)instance_item->flares_plan_string);

  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(flares_plan_string == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(flares_plan_string);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = (char *)(void *)0;
  instance_item->flares_plan_string = tmp_if_expr_2;
  instance_item->flares_plan_compiled = (_Bool)0;
  return 0;
}

// freecell_solver_user_set_game
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1601
extern signed int freecell_solver_user_set_game(void *api_instance, signed int freecells_num, signed int stacks_num, signed int decks_num, signed int sequences_are_built_by, signed int unlimited_sequence_move, signed int empty_stacks_fill)
{
  signed int return_value_freecell_solver_user_set_num_freecells_1;
  return_value_freecell_solver_user_set_num_freecells_1=freecell_solver_user_set_num_freecells(api_instance, freecells_num);
  if(!(return_value_freecell_solver_user_set_num_freecells_1 == 0))
    return 1;

  else
  {
    signed int return_value_freecell_solver_user_set_num_stacks_2;
    return_value_freecell_solver_user_set_num_stacks_2=freecell_solver_user_set_num_stacks(api_instance, stacks_num);
    if(!(return_value_freecell_solver_user_set_num_stacks_2 == 0))
      return 2;

    else
    {
      signed int return_value_freecell_solver_user_set_num_decks_3;
      return_value_freecell_solver_user_set_num_decks_3=freecell_solver_user_set_num_decks(api_instance, decks_num);
      if(!(return_value_freecell_solver_user_set_num_decks_3 == 0))
        return 3;

      else
      {
        signed int return_value_freecell_solver_user_set_sequences_are_built_by_type_4;
        return_value_freecell_solver_user_set_sequences_are_built_by_type_4=freecell_solver_user_set_sequences_are_built_by_type(api_instance, sequences_are_built_by);
        if(!(return_value_freecell_solver_user_set_sequences_are_built_by_type_4 == 0))
          return 4;

        else
        {
          signed int return_value_freecell_solver_user_set_sequence_move_5;
          return_value_freecell_solver_user_set_sequence_move_5=freecell_solver_user_set_sequence_move(api_instance, unlimited_sequence_move);
          if(!(return_value_freecell_solver_user_set_sequence_move_5 == 0))
            return 5;

          else
          {
            signed int return_value_freecell_solver_user_set_empty_stacks_filled_by_6;
            return_value_freecell_solver_user_set_empty_stacks_filled_by_6=freecell_solver_user_set_empty_stacks_filled_by(api_instance, empty_stacks_fill);
            if(!(return_value_freecell_solver_user_set_empty_stacks_filled_by_6 == 0))
              return 6;

            else
              return 0;
          }
        }
      }
    }
  }
}

// freecell_solver_user_set_hard_thread_prelude
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 302
extern signed int freecell_solver_user_set_hard_thread_prelude(void *api_instance, const char *prelude)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_hard_thread_struct *hard_thread = user->soft_thread->hard_thread;
  if(!(hard_thread->prelude_as_string == ((char *)NULL)))
  {
    free((void *)hard_thread->prelude_as_string);
    hard_thread->prelude_as_string = (char *)(void *)0;
  }

  hard_thread->prelude_as_string=strdup(prelude);
  return 0;
}

// freecell_solver_user_set_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1965
extern void freecell_solver_user_set_iter_handler(void *api_instance, void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context)
{
  set_any_iter_handler(api_instance, (void (*)(void *, signed long int, signed int, void *, signed long int, void *))(void *)0, iter_handler, iter_handler_context);
}

// freecell_solver_user_set_iter_handler_long
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 229
extern void freecell_solver_user_set_iter_handler_long(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void *iter_handler_context)
{
  set_any_iter_handler(api_instance, long_iter_handler, (void (*)(void *, signed int, signed int, void *, signed int, void *))(void *)0, iter_handler_context);
}

// freecell_solver_user_set_num_decks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 169
extern signed int freecell_solver_user_set_num_decks(void *api_instance, signed int decks_num)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(decks_num >= 3 || !(decks_num >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.decks_num = (unsigned char)decks_num;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_num_freecells
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 155
extern signed int freecell_solver_user_set_num_freecells(void *api_instance, signed int freecells_num)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(freecells_num >= 9 || !(freecells_num >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.freecells_num = (unsigned char)freecells_num;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_num_stacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 162
extern signed int freecell_solver_user_set_num_stacks(void *api_instance, signed int stacks_num)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(stacks_num >= 11 || !(stacks_num >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.stacks_num = (unsigned char)stacks_num;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_optimization_scan_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 316
extern signed int freecell_solver_user_set_optimization_scan_tests_order(void *api_instance, const char *tests_order, char **error_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  fc_solve_free_tests_order_link1(&user->active_flare->obj->opt_tests_order);
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~8;
  signed int ret;
  ret=fc_solve_apply_tests_order(&user->active_flare->obj->opt_tests_order, tests_order, error_string);
  if(ret == 0)
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)8;

  return ret;
}

// freecell_solver_user_set_pruning
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 380
extern signed int freecell_solver_user_set_pruning(void *api_instance, const char *pruning, char **error_string)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(pruning, "r:tf");
  if(return_value_strcmp_1 == 0)
    user->soft_thread->enable_pruning = (_Bool)1;

  else
    if((signed int)*pruning == 0)
      user->soft_thread->enable_pruning = (_Bool)0;

    else
    {
      *error_string=strdup("Unknown pruning value - must be \"r:tf\" or empty.");
      return 1;
    }
  return 0;
}

// freecell_solver_user_set_random_seed
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 244
extern void freecell_solver_user_set_random_seed(void *api_instance, signed int seed)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->soft_thread->method_specific.soft_dfs.rand_seed = seed;
  fc_solve_rand_init(&user->soft_thread->method_specific.soft_dfs.rand_gen, (unsigned int)user->soft_thread->method_specific.soft_dfs.rand_seed);
}

// freecell_solver_user_set_reparent_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 322
extern void freecell_solver_user_set_reparent_states(void *api_instance, signed int to_reparent_states)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~16;
  if(!(to_reparent_states == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)16;

}

// freecell_solver_user_set_scans_synergy
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 327
extern void freecell_solver_user_set_scans_synergy(void *api_instance, signed int synergy)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~64;
  if(!(synergy == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)64;

}

// freecell_solver_user_set_sequence_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 192
extern signed int freecell_solver_user_set_sequence_move(void *api_instance, signed int unlimited_sequence_move)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags & (unsigned char)~(1 << 4);
  user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags | (unsigned char)((signed int)(unlimited_sequence_move != 0) << 4);
  apply_game_params_for_all_instances(user);
  return 0;
}

// freecell_solver_user_set_sequences_are_built_by_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 182
extern signed int freecell_solver_user_set_sequences_are_built_by_type(void *api_instance, signed int sequences_are_built_by)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(sequences_are_built_by >= 3 || !(sequences_are_built_by >= 0))
    return 1;

  else
  {
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags & (unsigned char)~0x3;
    user->common_preset.game_params.game_flags = user->common_preset.game_params.game_flags | (unsigned char)sequences_are_built_by;
    apply_game_params_for_all_instances(user);
    return 0;
  }
}

// freecell_solver_user_set_soft_thread_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 292
extern void freecell_solver_user_set_soft_thread_name(void *api_instance, const char *name)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  if(!(user->soft_thread->name == ((char *)NULL)))
    free((void *)user->soft_thread->name);

  user->soft_thread->name=strdup(name);
}

// freecell_solver_user_set_soft_thread_step
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 274
extern void freecell_solver_user_set_soft_thread_step(void *api_instance, signed int num_checked_states_step)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->soft_thread->num_checked_states_step = num_checked_states_step;
}

// freecell_solver_user_set_solution_optimization
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 134
extern void freecell_solver_user_set_solution_optimization(void *api_instance, signed int optimize)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags & (unsigned char)~1;
  if(!(optimize == 0))
    user->active_flare->obj->runtime_flags = user->active_flare->obj->runtime_flags | (unsigned char)1;

}

// freecell_solver_user_set_solving_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 98
extern void freecell_solver_user_set_solving_method(void *api_instance, signed int method)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  struct fc_solve_soft_thread_struct * const soft_thread = user->soft_thread;
  enum FCS_SUPER_METHOD_TYPE super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_BEFS_BRFS;
  if(method == 0)
    method = 1;

  soft_thread->method = method;
  if(soft_thread->method == 1 || soft_thread->method == 5)
    super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_DFS;

  soft_thread->super_method_type = super_method_type;
}

// freecell_solver_user_set_tests_order
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 63
extern signed int freecell_solver_user_set_tests_order(void *api_instance, const char *tests_order, char **error_string)
{
  signed int return_value_freecell_solver_user_set_depth_tests_order_1;
  return_value_freecell_solver_user_set_depth_tests_order_1=freecell_solver_user_set_depth_tests_order(api_instance, 0, tests_order, error_string);
  return return_value_freecell_solver_user_set_depth_tests_order_1;
}

// freecell_solver_user_solve_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fcs_user.h line 69
extern signed int freecell_solver_user_solve_board(void *api_instance, const char *state_as_string)
{
  signed int ret_code;
  char *error_string;
  signed int instance_list_index;
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->state_string_copy=duplicate_string_while_adding_a_trailing_newline(state_as_string);
  user->current_instance_idx = 0;
  ret_code=user_compile_all_flares_plans(user, &instance_list_index, &error_string);
  if(!(ret_code == 0))
  {
    user->error_string = error_string;
    return 12;
  }

  else
  {
    signed int return_value_freecell_solver_user_resume_solution_1;
    return_value_freecell_solver_user_resume_solution_1=freecell_solver_user_resume_solution(api_instance);
    return return_value_freecell_solver_user_resume_solution_1;
  }
}

// generic_false_seq_index_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 501
static inline const _Bool generic_false_seq_index_loop(const signed int stacks_num, struct anonymous_6 * const raw_ptr_state_raw, signed int num_vacant_stacks, char * const col, struct anonymous_45 * const seqs, const signed int stack_idx, const signed int ds, const _Bool behaviour_flag, const _Bool should_src_col, const char src_card, const signed int num_src_junk_true_seqs)
{
  const signed int num_separate_false_seqs = seqs->num_separate_false_seqs;
  _Bool stacks_map[10l];
  init_stacks_map(stacks_map, stack_idx, ds);
  signed int after_junk_num_freestacks = num_vacant_stacks;
  const signed int false_seq_index_limit = num_separate_false_seqs + (should_src_col != (_Bool)0 ? 1 : 0);
  signed int false_seq_index = 0;
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  for( ; !(false_seq_index >= false_seq_index_limit); false_seq_index = false_seq_index + 1)
  {
    const _Bool is_ultimate_iter = false_seq_index == num_separate_false_seqs;
    char the_card;
    if(!(is_ultimate_iter == (_Bool)0))
      tmp_if_expr_1 = (signed int)src_card;

    else
      tmp_if_expr_1 = (signed int)col[(signed long int)(seqs->seq_points[(signed long int)false_seq_index] + 1)];
    the_card = (const char)tmp_if_expr_1;
    signed int the_num_true_seqs;
    if(!(is_ultimate_iter == (_Bool)0))
      tmp_if_expr_2 = num_src_junk_true_seqs;

    else
      tmp_if_expr_2 = seqs->above_num_true_seqs[(signed long int)false_seq_index];
    the_num_true_seqs = tmp_if_expr_2;
    signed int clear_junk_dest_stack = 0;
    for( ; !(clear_junk_dest_stack >= stacks_num); clear_junk_dest_stack = clear_junk_dest_stack + 1)
    {
      char * const clear_junk_dest_col = raw_ptr_state_raw->key->stacks[(signed long int)clear_junk_dest_stack];
      const signed int clear_junk_stack_len = (const signed int)clear_junk_dest_col[(signed long int)0];
      if(clear_junk_stack_len >= 1)
        tmp_if_expr_3 = !(stacks_map[(signed long int)clear_junk_dest_stack] != (_Bool)0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        const char clear_junk_dest_card = clear_junk_dest_col[(signed long int)((clear_junk_stack_len - 1) + 1)];
        if((signed int)clear_junk_dest_card >> 2 == ((signed int)the_card >> 2) + 1)
        {
          if(1 << after_junk_num_freestacks >= the_num_true_seqs)
          {
            stacks_map[(signed long int)clear_junk_dest_stack] = (_Bool)1;
            break;
          }

        }

      }

    }
    if(clear_junk_dest_stack == stacks_num)
    {
      if(!(1 << after_junk_num_freestacks + -1 >= the_num_true_seqs) || !(num_vacant_stacks >= 1) || behaviour_flag != (_Bool)0)
        break;

      clear_junk_dest_stack = 0;
      for( ; !(clear_junk_dest_stack >= stacks_num); clear_junk_dest_stack = clear_junk_dest_stack + 1)
        if((signed int)*raw_ptr_state_raw->key->stacks[(signed long int)clear_junk_dest_stack] == 0)
        {
          if(stacks_map[(signed long int)clear_junk_dest_stack] == (_Bool)0)
          {
            stacks_map[(signed long int)clear_junk_dest_stack] = (_Bool)1;
            break;
          }

        }

      after_junk_num_freestacks = after_junk_num_freestacks - 1;
    }

    seqs->junk_move_to_stacks[(signed long int)false_seq_index] = clear_junk_dest_stack;
  }
  seqs->after_junk_num_freestacks = after_junk_num_freestacks;
  return false_seq_index == false_seq_index_limit;
}

// generic_populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 460
static inline void generic_populate_seq_points(char * const dest_col, const signed int dc, struct anonymous_45 * const seqs, const signed int dest_cards_num)
{
  signed int num_separate_false_seqs = seqs->num_separate_false_seqs;
  seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] = 1;
  char above_card = dest_col[(signed long int)((dest_cards_num - 1) + 1)];
  signed int above_c = dest_cards_num - 2;
  signed int tmp_post_1;
  for( ; !(dc >= above_c); above_c = above_c - 1)
  {
    const char up_above_card = dest_col[(signed long int)(above_c + 1)];
    if(!((signed int)up_above_card >> 2 == ((signed int)above_card >> 2) + 1))
    {
      tmp_post_1 = num_separate_false_seqs;
      num_separate_false_seqs = num_separate_false_seqs + 1;
      seqs->seq_points[(signed long int)tmp_post_1] = above_c + 1;
      seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] = 1;
    }

    _Bool return_value_fcs_is_ss_suit_true_2;
    return_value_fcs_is_ss_suit_true_2=fcs_is_ss_suit_true(up_above_card, above_card);
    seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] = seqs->above_num_true_seqs[(signed long int)num_separate_false_seqs] + (signed int)!(return_value_fcs_is_ss_suit_true_2 != (_Bool)0);
    above_card = up_above_card;
  }
  signed int tmp_post_3;
  if(dest_cards_num + -2 >= dc)
  {
    tmp_post_3 = num_separate_false_seqs;
    num_separate_false_seqs = num_separate_false_seqs + 1;
    seqs->seq_points[(signed long int)tmp_post_3] = dc + 1;
  }

  seqs->num_separate_false_seqs = num_separate_false_seqs;
}

// get_board
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 186
static inline void get_board(signed long int gamenumber, char *ret)
{
  get_board_l((signed long long int)gamenumber, ret);
}

// get_board_l
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 123
static inline void get_board_l(const signed long long int gamenumber, char * const ret)
{
  signed long long int seedx = (signed long long int)(unsigned int)(gamenumber < 0x100000000LL ? gamenumber : gamenumber - 0x100000000LL);
  signed int card[8l][7l];
  signed int i;
  signed int j;
  signed int wLeft = 52;
  signed int deck[52l];
  i = 0;
  for( ; !(i >= 52); i = i + 1)
    deck[(signed long int)i] = i;
  i = 0;
  for( ; !(i >= 52); i = i + 1)
  {
    unsigned int return_value_microsoft_rand__game_num_rand_1;
    return_value_microsoft_rand__game_num_rand_1=microsoft_rand__game_num_rand(&seedx, gamenumber);
    j = (signed int)(return_value_microsoft_rand__game_num_rand_1 % (unsigned int)wLeft);
    card[(signed long int)(i % 8)][(signed long int)(i / 8)] = deck[(signed long int)j];
    wLeft = wLeft - 1;
    deck[(signed long int)j] = deck[(signed long int)wLeft];
  }
  char *append_to = ret;
  signed int stack;
  signed int c;
  stack = 0;
  char *tmp_post_2;
  for( ; !(stack >= 8); stack = stack + 1)
  {
    c = 0;
    for( ; !(c >= 6 + (signed int)!(stack >= 4)); c = c + 1)
      append_to=card_to_string(append_to, card[(signed long int)stack][(signed long int)c], (signed int)(c == (6 - 1) + (signed int)(stack < 4)));
    tmp_post_2 = append_to;
    append_to = append_to + 1l;
    *tmp_post_2 = (char)10;
  }
  *append_to = (char)0;
}

// get_current_instance_item
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 927
static inline struct anonymous_1 * get_current_instance_item(const struct anonymous *user)
{
  return &user->instances_list[(signed long int)user->current_instance_idx];
}

// get_flare_move_count
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 898
static signed int get_flare_move_count(struct anonymous * const user, struct anonymous_2 * const flare)
{
  if((signed int)user->flares_choice == FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN)
    return flare->moves_seq.num_moves;

  else
  {
    if(flare->fc_pro_moves.moves == ((struct anonymous_54 *)NULL))
      fc_solve_moves_processed_gen(&flare->fc_pro_moves, &user->initial_non_canonized_state, (const signed int)user->common_preset.game_params.freecells_num, &flare->moves_seq);

    signed int return_value_fc_solve_moves_processed_get_moves_left_1;
    return_value_fc_solve_moves_processed_get_moves_left_1=fc_solve_moves_processed_get_moves_left(&flare->fc_pro_moves);
    return return_value_fc_solve_moves_processed_get_moves_left_1;
  }
}

// get_seq_h
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 370
static inline signed int get_seq_h(char * const col, signed int *num_true_seqs_out_ptr)
{
  const signed int cards_num = (const signed int)col[(signed long int)0];
  char card = col[(signed long int)((cards_num - 1) + 1)];
  signed int num_true_seqs = 1;
  signed int h = cards_num - 2;
  for( ; h >= 0; h = h - 1)
  {
    const char next_card = col[(signed long int)(h + 1)];
    if(!((signed int)next_card >> 2 == ((signed int)card >> 2) + 1))
      break;

    _Bool return_value_fcs_is_ss_suit_true_1;
    return_value_fcs_is_ss_suit_true_1=fcs_is_ss_suit_true(next_card, card);
    if(return_value_fcs_is_ss_suit_true_1 == (_Bool)0)
      num_true_seqs = num_true_seqs + 1;

    card = next_card;
  }
  *num_true_seqs_out_ptr = num_true_seqs;
  return h + 1;
}

// get_the_positions_by_rank_data__ss_generator
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 143
static char * get_the_positions_by_rank_data__ss_generator(struct fc_solve_soft_thread_struct * const soft_thread, const struct fcs_struct_state_t * const the_state)
{
  struct fc_solve_instance_struct * const instance = soft_thread->hard_thread->instance;
  const struct anonymous_14 game_params = instance->game_params;
  char *positions_by_rank;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)((13 + 1) * 2 * 4));
  positions_by_rank = (char *)return_value_malloc_1;
  memset((void *)positions_by_rank, -1, sizeof(char) /*1ul*/  * (unsigned long int)((13 + 1) * 2 * 4));
  signed int ds = 0;
  for( ; !(ds >= (signed int)game_params.stacks_num); ds = ds + 1)
  {
    const char * const dest_col = the_state->stacks[(signed long int)ds];
    const signed int dest_cards_num = (const signed int)dest_col[(signed long int)0];
    signed int dc = 0;
    for( ; !(dc >= dest_cards_num); dc = dc + 1)
    {
      const char card = dest_col[(signed long int)(dc + 1)];
      const signed int suit = (signed int)card & 0x03;
      const signed int rank = (signed int)card >> 2;
      positions_by_rank[(signed long int)((suit * (13 + 1) + rank) * 2)] = (char)ds;
      positions_by_rank[(signed long int)((suit * (13 + 1) + rank) * 2 + 1)] = (char)dc;
    }
  }
  return positions_by_rank;
}

// init_soft_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 297
static inline void init_soft_thread(struct fc_solve_hard_thread_struct * const hard_thread, struct fc_solve_soft_thread_struct * const soft_thread)
{
  soft_thread->hard_thread = hard_thread;
  signed int tmp_post_1 = hard_thread->instance->next_soft_thread_id;
  hard_thread->instance->next_soft_thread_id = hard_thread->instance->next_soft_thread_id + 1;
  soft_thread->id = tmp_post_1;
  soft_thread->method_specific.soft_dfs.dfs_max_depth = 0;
  soft_thread->by_depth_tests_order.num = 1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct anonymous_21) /*24ul*/  * (unsigned long int)1);
  soft_thread->by_depth_tests_order.by_depth_tests = (struct anonymous_21 *)return_value_malloc_2;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->max_depth = 0x7fffffff;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.num_groups = 0;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order.groups = (struct anonymous_20 *)(void *)0;
  soft_thread->method_specific.soft_dfs.soft_dfs_info = (struct anonymous_50 *)(void *)0;
  soft_thread->method_specific.soft_dfs.depth = 0;
  soft_thread->method_specific.soft_dfs.tests_by_depth_array.num_units = 0;
  soft_thread->method_specific.soft_dfs.tests_by_depth_array.by_depth_units = (struct anonymous_52 *)(void *)0;
  soft_thread->method_specific.soft_dfs.rand_seed = 24;
  soft_thread->method_specific.befs.tests_list = (void (**)(struct fc_solve_soft_thread_struct *, struct anonymous_6 *, struct anonymous_12 *))(void *)0;
  soft_thread->method = 1;
  soft_thread->super_method_type = (enum FCS_SUPER_METHOD_TYPE)FCS_SUPER_METHOD_DFS;
  soft_thread->method_specific.befs.befs_positions_by_rank = (char *)(void *)0;
  memcpy((void *)soft_thread->method_specific.befs.meth.befs.weighting.befs_weights, (const void *)fc_solve_default_befs_weights, sizeof(const double [6l]) /*48ul*/ );
  soft_thread->method_specific.befs.meth.befs.pqueue.Elements = (struct anonymous_19 *)(void *)0;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item = (struct fcs_states_linked_list_item_struct *)(void *)0;
  soft_thread->method_specific.befs.meth.brfs.bfs_queue = soft_thread->method_specific.befs.meth.brfs.bfs_queue_last_item;
  soft_thread->num_checked_states_step = 50;
  (soft_thread->by_depth_tests_order.by_depth_tests + (signed long int)0)->tests_order=tests_order_dup(&soft_thread->hard_thread->instance->instance_tests_order);
  fc_solve_reset_soft_thread(soft_thread);
  soft_thread->name = (char *)(void *)0;
  soft_thread->enable_pruning = (_Bool)0;
}

// init_stacks_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 189
static inline void init_stacks_map(_Bool * const stacks_map, const signed int stack_idx, const signed int ds)
{
  signed int i = 0;
  for( ; !(i >= 10); i = i + 1)
    stacks_map[(signed long int)i] = (_Bool)0;
  stacks_map[(signed long int)ds] = (_Bool)1;
  stacks_map[(signed long int)stack_idx] = stacks_map[(signed long int)ds];
}

// init_stats
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 775
static inline void init_stats(struct anonymous_44 * const s)
{
  s->num_states_in_collection = (signed long int)0;
  s->num_checked_states = s->num_states_in_collection;
}

// is_whitespace
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 110
static inline _Bool is_whitespace(char c)
{
  return (signed int)c == 32 || (signed int)c == 9 || (signed int)c == 10 || (signed int)c == 13;
}

// iter_handler_wrapper
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1882
static void iter_handler_wrapper(void *api_instance, signed long int iter_num, signed int depth, void *lp_instance, struct anonymous_6 *ptr_state, signed long int parent_iter_num)
{
  struct anonymous_13 state_raw;
  struct anonymous * const user = (struct anonymous *)api_instance;
  state_raw.key = ptr_state->key;
  state_raw.val = ptr_state->val;
  fc_solve_init_locs(&state_raw.locs);
  if(!(user->long_iter_handler == ((void (*)(void *, signed long int, signed int, void *, signed long int, void *))NULL)))
    user->long_iter_handler(api_instance, iter_num, depth, (void *)&state_raw, parent_iter_num, user->iter_handler_context);

  else
    user->iter_handler(api_instance, (signed int)iter_num, depth, (void *)&state_raw, (signed int)parent_iter_num, user->iter_handler_context);
}

// kv_calc_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 84
static inline signed int kv_calc_depth(struct anonymous_6 *ptr_state)
{
  signed int return_value_calc_depth_1;
  return_value_calc_depth_1=calc_depth((struct fcs_state_keyval_pair_struct *)ptr_state->key);
  return return_value_calc_depth_1;
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 361
signed int main(signed int argc, char **argv)
{
  signed int arg = 1;
  next_board_num_lock = initial_mutex_constant;
  total_num_iters_lock = initial_mutex_constant;
  if(!(argc >= 4))
  {
    fprintf(stderr, "Not Enough Arguments!\n");
    print_help();
    exit(-1);
  }

  signed int tmp_post_1 = arg;
  arg = arg + 1;
  next_board_num=atoi(argv[(signed long int)tmp_post_1]);
  signed int end_board;
  signed int tmp_post_2 = arg;
  arg = arg + 1;
  end_board=atoi(argv[(signed long int)tmp_post_2]);
  signed int stop_at;
  signed int tmp_post_3 = arg;
  arg = arg + 1;
  stop_at=atoi(argv[(signed long int)tmp_post_3]);
  if(!(stop_at >= 1))
  {
    fprintf(stderr, "print_step (the third argument) must be greater than 0.\n");
    print_help();
    exit(-1);
  }

  signed int num_workers = 3;
  signed int board_num_step = 1;
  signed int update_total_num_iters_threshold = 1000000;
  signed int total_iterations_limit_per_board = -1;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  for( ; !(arg >= argc); arg = arg + 1)
  {
    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(argv[(signed long int)arg], "--total-iterations-limit");
    if(return_value_strcmp_8 == 0)
    {
      arg = arg + 1;
      if(arg == argc)
      {
        fprintf(stderr, "--total-iterations-limit came without an argument!\n");
        print_help();
        exit(-1);
      }

      signed long int return_value_atol_4;
      return_value_atol_4=atol(argv[(signed long int)arg]);
      total_iterations_limit_per_board = (signed int)return_value_atol_4;
    }

    else
    {
      return_value_strcmp_7=strcmp(argv[(signed long int)arg], "--num-workers");
      if(return_value_strcmp_7 == 0)
      {
        arg = arg + 1;
        if(arg == argc)
        {
          fprintf(stderr, "--num-workers came without an argument!\n");
          print_help();
          exit(-1);
        }

        num_workers=atoi(argv[(signed long int)arg]);
      }

      else
      {
        return_value_strcmp_6=strcmp(argv[(signed long int)arg], "--worker-step");
        if(return_value_strcmp_6 == 0)
        {
          arg = arg + 1;
          if(arg == argc)
          {
            fprintf(stderr, "--worker-step came without an argument!\n");
            print_help();
            exit(-1);
          }

          board_num_step=atoi(argv[(signed long int)arg]);
        }

        else
        {
          return_value_strcmp_5=strcmp(argv[(signed long int)arg], "--iters-update-on");
          if(return_value_strcmp_5 == 0)
          {
            arg = arg + 1;
            if(arg == argc)
            {
              fprintf(stderr, "--iters-update-on came without an argument!\n");
              print_help();
              exit(-1);
            }

            update_total_num_iters_threshold=atoi(argv[(signed long int)arg]);
          }

          else
            break;
        }
      }
    }
  }
  struct anonymous_27 mytime;
  gettimeofday(&mytime.tv, &mytime.tz);
  printf("Started at %li.%.6li\n", mytime.tv.tv_sec, mytime.tv.tv_usec);
  fflush(stdout);
  struct anonymous_26 context = { .argc=argc, .argv=argv, .arg=arg, .stop_at=stop_at, .end_board=end_board,
    .board_num_step=board_num_step, .update_total_num_iters_threshold=update_total_num_iters_threshold,
    .total_iterations_limit_per_board=(signed long int)total_iterations_limit_per_board };
  unsigned long int *workers;
  void *return_value_malloc_9;
  return_value_malloc_9=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)num_workers);
  workers = (unsigned long int *)return_value_malloc_9;
  signed int idx = 0;
  for( ; !(idx >= num_workers); idx = idx + 1)
  {
    signed int check;
    check=pthread_create(&workers[(signed long int)idx], (const union pthread_attr_t *)(void *)0, worker_thread, (void *)&context);
    if(!(check == 0))
    {
      fprintf(stderr, "Worker Thread No. %d Initialization failed with error %d!\n", idx, check);
      exit(-1);
    }

  }
  signed int main__1__6__idx = 0;
  for( ; !(main__1__6__idx >= num_workers); main__1__6__idx = main__1__6__idx + 1)
    pthread_join(workers[(signed long int)main__1__6__idx], (void **)(void *)0);
  gettimeofday(&mytime.tv, &mytime.tz);
  printf("Finished at %li.%.6li (total_num_iters=%lli)\n", mytime.tv.tv_sec, mytime.tv.tv_usec, total_num_iters);
  free((void *)workers);
  return 0;
}

// mark_as_dead_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/scans.c line 589
static inline void mark_as_dead_end(const _Bool scans_synergy, struct fcs_state_keyval_pair_struct * const ptr_state_input)
{
  if(!(scans_synergy == (_Bool)0))
  {
    struct fcs_state_keyval_pair_struct *temp_state = ptr_state_input;
    temp_state->_anon0._anon0.info.visited = temp_state->_anon0._anon0.info.visited | (unsigned char)4;
    temp_state = temp_state->_anon0._anon0.info.parent;
    if(!(temp_state == ((struct fcs_state_keyval_pair_struct *)NULL)))
    {
      temp_state->_anon0._anon0.info.num_active_children = temp_state->_anon0._anon0.info.num_active_children - 1;
      for( ; (signed int)temp_state->_anon0._anon0.info.num_active_children == 0; temp_state->_anon0._anon0.info.num_active_children = temp_state->_anon0._anon0.info.num_active_children - 1)
      {
        if((8 & (signed int)temp_state->_anon0._anon0.info.visited) == 0)
          break;

        temp_state->_anon0._anon0.info.visited = temp_state->_anon0._anon0.info.visited | (unsigned char)4;
        temp_state = temp_state->_anon0._anon0.info.parent;
        if(temp_state == ((struct fcs_state_keyval_pair_struct *)NULL))
          break;

      }
    }

  }

}

// memdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup(void *src, unsigned long int mysize)
{
  void *dest;
  dest=malloc(mysize);
  if(dest == NULL)
    return (void *)0;

  else
  {
    memcpy(dest, src, mysize);
    return dest;
  }
}

// memdup_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 933
static inline void * memdup_link1(void *src_link1, unsigned long int mysize_link1)
{
  void *dest_link1;
  dest_link1=malloc(mysize_link1);
  if(dest_link1 == NULL)
    return (void *)0;

  else
  {
    memcpy(dest_link1, src_link1, mysize_link1);
    return dest_link1;
  }
}

// meta_request_new_buffer
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/meta_alloc.c line 57
static inline char * meta_request_new_buffer(struct anonymous_10 *meta_allocator)
{
  if(!(meta_allocator->recycle_bin == ((char *)NULL)))
  {
    char *ret = meta_allocator->recycle_bin;
    meta_allocator->recycle_bin = *((char **)ret);
    return ret;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(64 * 1024 - (256 + 128)));
    return (char *)return_value_malloc_1;
  }
}

// microsoft_rand__game_num_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 59
static inline unsigned int microsoft_rand__game_num_rand(signed long long int *seedx_ptr, signed long long int gnGameNumber)
{
  if(!(gnGameNumber >= 0x100000000LL))
  {
    unsigned int ret;
    ret=microsoft_rand_rand(seedx_ptr);
    if(!(gnGameNumber >= 2147483648l))
      return ret;

    else
      return ret | (unsigned int)0x8000;
  }

  else
  {
    unsigned int return_value_microsoft_rand_randp_1;
    return_value_microsoft_rand_randp_1=microsoft_rand_randp(seedx_ptr);
    return return_value_microsoft_rand_randp_1 + (unsigned int)1;
  }
}

// microsoft_rand_rand
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 47
static inline unsigned int microsoft_rand_rand(signed long long int *my_rand)
{
  *my_rand = *my_rand * (signed long int)214013 + (signed long int)2531011;
  return (unsigned int)(*my_rand >> 16 & (signed long int)0x7fff);
}

// microsoft_rand_randp
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/range_solvers_gen_ms_boards.h line 53
static inline unsigned int microsoft_rand_randp(signed long long int *my_rand)
{
  *my_rand = *my_rand * (signed long int)214013 + (signed long int)2531011;
  return (unsigned int)(*my_rand >> 16 & (signed long int)0xffff);
}

// moves_processed_add_new_move
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/fc_pro_iface.c line 113
static inline void moves_processed_add_new_move(struct anonymous_40 * const moves, const struct anonymous_54 new_move)
{
  moves->num_moves = moves->num_moves + 1;
  if((32 & moves->num_moves) == 0)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)moves->moves, sizeof(struct anonymous_54) /*5ul*/  * (unsigned long int)(moves->num_moves + 32));
    moves->moves = (struct anonymous_54 *)return_value_realloc_1;
  }

  moves->moves[(signed long int)(moves->num_moves - 1)] = new_move;
}

// my_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 62
static void my_iter_handler(void *user_instance, signed long int iter_num, signed int depth, void *ptr_state, signed long int parent_iter_num, void *lp_context)
{
  fprintf(stdout, "Iteration: %li\n", (signed long int)iter_num);
  fprintf(stdout, "Depth: %i\n", depth);
  const struct anonymous_28 * const context = (const struct anonymous_28 *)lp_context;
  if(!(context->display_parent_iter_num == (_Bool)0))
    fprintf(stdout, "Parent Iteration: %li\n", (signed long int)parent_iter_num);

  fprintf(stdout, "\n");
  if(!(context->debug_iter_state_output == (_Bool)0))
  {
    char *state_string;
    state_string=freecell_solver_user_iter_state_as_string(user_instance, ptr_state, (signed int)context->parseable_output, (signed int)context->canonized_order_output, (signed int)context->display_10_as_t);
    printf("%s\n---------------\n\n\n", state_string);
    free((void *)state_string);
  }

}

// normalize_iters_quota
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 936
static inline signed int normalize_iters_quota(signed int i)
{
  return i > 0 ? i : 0;
}

// nullify_newline
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 50
static inline void nullify_newline(char * const line)
{
  char *s;
  s=strchr(line, 10);
  if(!(s == ((char *)NULL)))
    *s = (char)0;

}

// on_state_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 291
static inline void on_state_new(struct fc_solve_instance_struct * const instance, struct fc_solve_hard_thread_struct * const hard_thread, struct fcs_state_extra_info_struct * const new_state_info)
{
  struct fcs_state_keyval_pair_struct * const parent_state = new_state_info->parent;
  if(!(parent_state == ((struct fcs_state_keyval_pair_struct *)NULL)))
  {
    parent_state->_anon0._anon0.info.num_active_children = parent_state->_anon0._anon0.info.num_active_children + 1;
    new_state_info->moves_to_parent=fc_solve_move_stack_compact_allocate(hard_thread, new_state_info->moves_to_parent);
  }

  instance->active_num_states_in_collection = instance->active_num_states_in_collection + 1l;
  instance->num_states_in_collection = instance->num_states_in_collection + 1l;
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// perl_hash_function
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/check_and_add_state.c line 53
static inline unsigned long int perl_hash_function(const unsigned char *s_ptr, const unsigned long int length)
{
  unsigned long int hash_value_int = (unsigned long int)0;
  const unsigned char * const s_end = s_ptr + (signed long int)length;
  const unsigned char *tmp_post_1;
  for( ; !(s_ptr >= s_end); hash_value_int = hash_value_int + (hash_value_int << 5) + (unsigned long int)*tmp_post_1)
  {
    tmp_post_1 = s_ptr;
    s_ptr = s_ptr + 1l;
  }
  hash_value_int = hash_value_int + (hash_value_int >> 5);
  return hash_value_int;
}

// populate_seq_points
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 491
static inline void populate_seq_points(char * const dest_col, const signed int dc, struct anonymous_45 * const seqs)
{
  seqs->num_separate_false_seqs = 0;
  generic_populate_seq_points(dest_col, dc, seqs, (const signed int)dest_col[(signed long int)0]);
}

// print_help
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 169
static void print_help(void)
{
  printf("\n%s", (const void *)"freecell-solver-range-parallel-solve start end print_step\n   [--binary-output-to filename] [--total-iterations-limit limit]\n   [fc-solve Arguments...]\n\nSolves a sequence of boards from the Microsoft/Freecell Pro Deals\n\nstart - the first board in the sequence\nend - the last board in the sequence (inclusive)\nprint_step - at which division to print a status line\n\n--total-iterations-limit  limit\n     Limits each board for up to 'limit' iterations.\n");
}

// push_args_last_arg
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/split_cmd_line.c line 82
static inline void push_args_last_arg(struct anonymous_36 *manager)
{
  const signed int length = (const signed int)(manager->last_arg_ptr - manager->last_arg);
  char *new_arg;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(length + 1));
  new_arg = (char *)return_value_malloc_1;
  strncpy(new_arg, manager->last_arg, (unsigned long int)length);
  new_arg[(signed long int)length] = (char)0;
  signed int tmp_post_2 = manager->argc;
  manager->argc = manager->argc + 1;
  manager->argv[(signed long int)tmp_post_2] = new_arg;
  if((32 & manager->argc) == 0)
  {
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)manager->argv, sizeof(char *) /*8ul*/  * (unsigned long int)(manager->argc + 32));
    manager->argv = (char **)return_value_realloc_3;
  }

  manager->last_arg_ptr = manager->last_arg;
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// read_preset
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/cmd_line.c line 60
static inline signed int read_preset(const char *preset_name, struct anonymous_36 **args_man, char **opened_files_dir_to_assign, const char *user_preset_dir)
{
  signed int ret_code = 1;
  char *home_dir_presetrc = (char *)(void *)0;
  char *env_var_presetrc = (char *)(void *)0;
  const char *global_presetrc = (const char *)(void *)0;
  const char **presetrc_pathes[5l];
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  char *opened_files_dir = (char *)(void *)0;
  signed int idx = 0;
  signed int tmp_post_1 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post_1] = (const char **)(void *)&env_var_presetrc;
  signed int tmp_post_2 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post_2] = (const char **)(void *)&home_dir_presetrc;
  signed int tmp_post_3 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post_3] = (const char **)&global_presetrc;
  signed int tmp_post_4 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post_4] = &user_preset_dir;
  signed int tmp_post_5 = idx;
  idx = idx + 1;
  presetrc_pathes[(signed long int)tmp_post_5] = (const char **)(void *)0;
  char *home_dir;
  home_dir=getenv("HOME");
  if(!(home_dir == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(home_dir);
    void *return_value_malloc_7;
    return_value_malloc_7=malloc(sizeof(char) /*1ul*/  * (return_value_strlen_6 + (unsigned long int)50));
    home_dir_presetrc = (char *)return_value_malloc_7;
    sprintf(home_dir_presetrc, "%s/.freecell-solver/presetrc", home_dir);
  }

  env_var_presetrc=getenv("FREECELL_SOLVER_PRESETRC");
  global_presetrc = "/usr/share/freecell-solver/presetrc";
  const char *path;
  _Bool read_next_preset = (_Bool)0;
  signed int path_idx = 0;
  signed int return_value_strncmp_11;
  signed int return_value_strncmp_10;
  for( ; !(presetrc_pathes[(signed long int)path_idx] == ((const char **)NULL)); path_idx = path_idx + 1)
  {
    path = *presetrc_pathes[(signed long int)path_idx];
    if(!(path == ((const char *)NULL)))
    {
      f=fopen(path, "rt");
      if(!(f == ((struct _IO_FILE *)NULL)))
      {
        while((_Bool)1)
        {
          char line[8192l];
          char *return_value_fgets_8;
          return_value_fgets_8=fgets(line, (signed int)sizeof(char [8192l]) /*8192ul*/ , f);
          if(return_value_fgets_8 == ((char *)NULL))
            break;

          signed int return_value_strncmp_12;
          return_value_strncmp_12=strncmp(line, "dir=", (unsigned long int)4);
          if(return_value_strncmp_12 == 0)
          {
            nullify_newline(line);
            if(!(opened_files_dir == ((char *)NULL)))
              free((void *)opened_files_dir);

            opened_files_dir=strdup(line + (signed long int)4);
          }

          else
          {
            return_value_strncmp_11=strncmp(line, "name=", (unsigned long int)5);
            if(return_value_strncmp_11 == 0)
            {
              nullify_newline(line);
              signed int return_value_strcmp_9;
              return_value_strcmp_9=strcmp(line + (signed long int)5, preset_name);
              if(return_value_strcmp_9 == 0)
                read_next_preset = (_Bool)1;

            }

            else
            {
              return_value_strncmp_10=strncmp(line, "command=", (unsigned long int)8);
              if(return_value_strncmp_10 == 0)
              {
                if(!(read_next_preset == (_Bool)0))
                {
                  *args_man=fc_solve_args_man_alloc();
                  fc_solve_args_man_chop(*args_man, line + (signed long int)8);
                  ret_code = 0;
                  goto have_preset;
                }

              }

            }
          }
        }
        fclose(f);
        f = (struct _IO_FILE *)(void *)0;
      }

    }

  }

have_preset:
  ;
  if(!(f == ((struct _IO_FILE *)NULL)))
    fclose(f);

  if(!(home_dir_presetrc == ((char *)NULL)))
    free((void *)home_dir_presetrc);

  if(ret_code == 0)
    *opened_files_dir_to_assign = opened_files_dir;

  else
    if(!(opened_files_dir == ((char *)NULL)))
      free((void *)opened_files_dir);

  return ret_code;
}

// recycle_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 782
static void recycle_instance(struct anonymous * const user, const signed int i)
{
  struct anonymous_1 * const instance_item = &user->instances_list[(signed long int)i];
  signed int flare_idx = 0;
  for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
  {
    struct anonymous_2 *flare = &instance_item->flares[(signed long int)flare_idx];
    if(!(flare->fc_pro_moves.moves == ((struct anonymous_54 *)NULL)))
      fc_solve_moves_processed_free(&flare->fc_pro_moves);

    if(!(flare->ret_code == 9))
    {
      if(flare->instance_is_ready == (_Bool)0)
      {
        fc_solve_recycle_instance(flare->obj);
        flare->instance_is_ready = (_Bool)1;
      }

      user->init_num_checked_states.num_checked_states = (signed long int)0;
      user->init_num_checked_states.num_states_in_collection = (signed long int)0;
      flare->ret_code = 9;
    }

    if(!(flare->moves_seq.moves == ((struct anonymous_4 *)NULL)))
    {
      free((void *)flare->moves_seq.moves);
      flare->moves_seq.moves = (struct anonymous_4 *)(void *)0;
      flare->moves_seq.num_moves = 0;
      flare->next_move = 0;
    }

    init_stats(&flare->obj_stats);
  }
  instance_item->current_plan_item_idx = 0;
  instance_item->minimal_solution_flare_idx = -1;
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// run_hard_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1217
static inline signed int run_hard_thread(struct fc_solve_hard_thread_struct *hard_thread)
{
  struct fc_solve_soft_thread_struct *soft_thread;
  signed long int num_checked_states_started_at;
  signed int ret;
  struct fc_solve_instance_struct *instance = hard_thread->instance;
  signed int *st_idx_ptr = &hard_thread->st_idx;
  ret = 5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  while(!(hard_thread->num_soft_threads_finished >= hard_thread->num_soft_threads))
  {
    soft_thread = &hard_thread->soft_threads[(signed long int)*st_idx_ptr];
    if(!((4 & (signed int)soft_thread->runtime_flags) == 0))
    {
      if(!(hard_thread->prelude == ((struct anonymous_39 *)NULL)))
        tmp_if_expr_1 = (signed long int)hard_thread->prelude_idx < hard_thread->prelude_num_items ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        *st_idx_ptr = (hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->scan_idx;
        hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->quota;
        hard_thread->prelude_idx = hard_thread->prelude_idx + 1;
      }

      else
      {
        *st_idx_ptr = *st_idx_ptr + 1;
        if(*st_idx_ptr == hard_thread->num_soft_threads)
          *st_idx_ptr = 0;

        hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->soft_threads + (signed long int)*st_idx_ptr)->num_checked_states_step;
      }
    }

    else
    {
      num_checked_states_started_at = hard_thread->num_checked_states;
      hard_thread->max_num_checked_states = hard_thread->num_checked_states + hard_thread->num_checked_states_left_for_soft_thread;
      if((1 & (signed int)soft_thread->runtime_flags) == 0)
      {
        fc_solve_soft_thread_init_soft_dfs(soft_thread);
        fc_solve_soft_thread_init_befs_or_bfs(soft_thread);
        soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)1;
      }

      switch((signed int)soft_thread->super_method_type)
      {
        case FCS_SUPER_METHOD_DFS:
        {
          ret=fc_solve_soft_dfs_do_solve(soft_thread);
          break;
        }
        case FCS_SUPER_METHOD_BEFS_BRFS:
        {
          ret=fc_solve_befs_or_bfs_do_solve(soft_thread);
          break;
        }
        default:
          ret = 1;
      }
      hard_thread->num_checked_states_left_for_soft_thread = hard_thread->num_checked_states_left_for_soft_thread - (hard_thread->num_checked_states - num_checked_states_started_at);
      if(!(hard_thread->num_checked_states_left_for_soft_thread >= 1l))
      {
        if(!(hard_thread->prelude == ((struct anonymous_39 *)NULL)))
          tmp_if_expr_2 = (signed long int)hard_thread->prelude_idx < hard_thread->prelude_num_items ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
        {
          *st_idx_ptr = (hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->scan_idx;
          hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->prelude + (signed long int)hard_thread->prelude_idx)->quota;
          hard_thread->prelude_idx = hard_thread->prelude_idx + 1;
        }

        else
        {
          *st_idx_ptr = *st_idx_ptr + 1;
          if(*st_idx_ptr == hard_thread->num_soft_threads)
            *st_idx_ptr = 0;

          hard_thread->num_checked_states_left_for_soft_thread = (signed long int)(hard_thread->soft_threads + (signed long int)*st_idx_ptr)->num_checked_states_step;
        }
      }

      if(ret == 1)
      {
        soft_thread->runtime_flags = soft_thread->runtime_flags | (unsigned char)4;
        hard_thread->num_soft_threads_finished = hard_thread->num_soft_threads_finished + 1;
        if(hard_thread->num_soft_threads_finished == hard_thread->num_soft_threads)
          instance->num_hard_threads_finished = instance->num_hard_threads_finished + 1;

        if(!((2 & (signed int)soft_thread->runtime_flags) == 0))
          tmp_if_expr_3 = !(((signed int)instance->runtime_flags & 64) != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          return 1;

        else
          ret = 5;
      }

      if(ret == 0)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if(ret == 5)
        {
          if(instance->num_checked_states >= instance->effective_max_num_checked_states)
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = instance->num_states_in_collection >= instance->effective_max_num_states_in_collection ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        return ret;

    }
  }
  return ret;
}

// set_any_iter_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1931
static void set_any_iter_handler(void *api_instance, void (*long_iter_handler)(void *, signed long int, signed int, void *, signed long int, void *), void (*iter_handler)(void *, signed int, signed int, void *, signed int, void *), void *iter_handler_context)
{
  struct anonymous * const user = (struct anonymous *)api_instance;
  user->long_iter_handler = long_iter_handler;
  user->iter_handler = iter_handler;
  if(!(iter_handler == ((void (*)(void *, signed int, signed int, void *, signed int, void *))NULL)) || !(long_iter_handler == ((void (*)(void *, signed long int, signed int, void *, signed long int, void *))NULL)))
  {
    user->iter_handler_context = iter_handler_context;
    set_debug_iter_output_func_to_val(user, iter_handler_wrapper);
  }

  else
    set_debug_iter_output_func_to_val(user, (void (*)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int))(void *)0);
}

// set_debug_iter_output_func_to_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1920
static void set_debug_iter_output_func_to_val(struct anonymous * const user, void (* const value)(void *, signed long int, signed int, void *, struct anonymous_6 *, signed long int))
{
  signed int user_inst_idx = 0;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous_1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
    signed int flare_idx = 0;
    for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
    {
      struct anonymous_2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      flare->obj->debug_iter_output_func = value;
    }
  }
}

// soft_thread_clean_soft_dfs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.c line 119
static inline void soft_thread_clean_soft_dfs(struct fc_solve_soft_thread_struct * const soft_thread)
{
  struct anonymous_50 * const soft_dfs_info = soft_thread->method_specific.soft_dfs.soft_dfs_info;
  if(!(soft_dfs_info == ((struct anonymous_50 *)NULL)))
  {
    const struct anonymous_50 *info_ptr = soft_dfs_info;
    const struct anonymous_50 * const max_info_ptr = info_ptr + (signed long int)soft_thread->method_specific.soft_dfs.depth;
    const struct anonymous_50 * const dfs_max_info_ptr = info_ptr + (signed long int)soft_thread->method_specific.soft_dfs.dfs_max_depth;
    for( ; !(info_ptr >= max_info_ptr); info_ptr = info_ptr + 1l)
    {
      free((void *)info_ptr->derived_states_list.states);
      free((void *)info_ptr->derived_states_random_indexes);
      free((void *)info_ptr->positions_by_rank);
    }
    for( ; !(info_ptr >= dfs_max_info_ptr); info_ptr = info_ptr + 1l)
      if(!(info_ptr->derived_states_list.states == ((struct anonymous_43 *)NULL)))
      {
        free((void *)info_ptr->derived_states_list.states);
        free((void *)info_ptr->derived_states_random_indexes);
      }

    free((void *)soft_dfs_info);
    soft_thread->method_specific.soft_dfs.soft_dfs_info = (struct anonymous_50 *)(void *)0;
    soft_thread->method_specific.soft_dfs.dfs_max_depth = 0;
  }

}

// sort_derived_states
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/freecell.c line 116
static inline void sort_derived_states(struct anonymous_12 *derived_states_list, signed int initial_derived_states_num_states)
{
  struct anonymous_43 *start = derived_states_list->states + (signed long int)initial_derived_states_num_states;
  struct anonymous_43 *limit = derived_states_list->states + (signed long int)derived_states_list->num_states;
  struct anonymous_43 *b = start + (signed long int)1;
  _Bool tmp_if_expr_1;
  for( ; !(b >= limit); b = b + 1l)
  {
    struct anonymous_43 *c = b;
    do
    {
      if(!(start >= c))
        tmp_if_expr_1 = (c + (signed long int)0)->context.i < (c + (signed long int)-1)->context.i ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      struct anonymous_43 temp = c[(signed long int)-1];
      c[(signed long int)-1] = c[(signed long int)0];
      c[(signed long int)0] = temp;
      c = c - 1l;
    }
    while((_Bool)1);
  }
}

// sort_ds_dcs
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/simpsim.c line 1008
static inline void sort_ds_dcs(struct anonymous_46 *ds_dcs, const signed int len)
{
  struct anonymous_46 *start = ds_dcs;
  struct anonymous_46 *limit = start + (signed long int)len;
  struct anonymous_46 *b = start + (signed long int)1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  for( ; !(b >= limit); b = b + 1l)
  {
    struct anonymous_46 *c = b;
    do
    {
      if(!(start >= c))
      {
        if(!(c->ds >= (c + -1l)->ds))
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          if(c->ds == (c + -1l)->ds)
            tmp_if_expr_1 = (c + (signed long int)0)->dc > (c + (signed long int)-1)->dc ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      struct anonymous_46 temp = c[(signed long int)-1];
      c[(signed long int)-1] = c[(signed long int)0];
      c[(signed long int)0] = temp;
      c = c - 1l;
    }
    while((_Bool)1);
  }
}

// string_starts_with
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with(const char * const str, const char * const prefix, const char * const end)
{
  const signed int check_len = (const signed int)(end - str);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(prefix);
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  if((unsigned long int)check_len == return_value_strlen_1)
  {
    return_value_strncmp_2=strncmp(str, prefix, (unsigned long int)check_len);
    tmp_if_expr_3 = !(return_value_strncmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return tmp_if_expr_3;
}

// string_starts_with_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/str_utils.h line 39
static inline _Bool string_starts_with_link1(const char * const str_link1, const char * const prefix_link1, const char * const end_link1)
{
  const signed int check_len_link1 = (const signed int)(end_link1 - str_link1);
  unsigned long int return_value_strlen_1_link1;
  return_value_strlen_1_link1=strlen(prefix_link1);
  _Bool tmp_if_expr_3_link1;
  signed int return_value_strncmp_2_link1;
  if((unsigned long int)check_len_link1 == return_value_strlen_1_link1)
  {
    return_value_strncmp_2_link1=strncmp(str_link1, prefix_link1, (unsigned long int)check_len_link1);
    tmp_if_expr_3_link1 = !(return_value_strncmp_2_link1 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3_link1 = (_Bool)0;
  return tmp_if_expr_3_link1;
}

// tests_order_dup
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous_9 tests_order_dup(struct anonymous_9 *orig)
{
  struct anonymous_9 ret;
  ret.num_groups = orig->num_groups;
  void *return_value_memdup_1;
  return_value_memdup_1=memdup((void *)orig->groups, sizeof(struct anonymous_20) /*232ul*/  * (unsigned long int)((ret.num_groups & ~(16 - 1)) + 16));
  ret.groups = (struct anonymous_20 *)return_value_memdup_1;
  signed int i = 0;
  for( ; !(i >= ret.num_groups); i = i + 1)
  {
    void *return_value_memdup_2;
    return_value_memdup_2=memdup((void *)(ret.groups + (signed long int)i)->tests, sizeof(signed int) /*4ul*/  * (unsigned long int)(((ret.groups + (signed long int)i)->num & ~(16 - 1)) + 16));
    (ret.groups + (signed long int)i)->tests = (signed int *)return_value_memdup_2;
  }
  return ret;
}

// tests_order_dup_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 1404
static inline struct anonymous_9 tests_order_dup_link1(struct anonymous_9 *orig_link1)
{
  struct anonymous_9 ret_link1;
  ret_link1.num_groups = orig_link1->num_groups;
  void *return_value_memdup_1_link1;
  return_value_memdup_1_link1=memdup_link1((void *)orig_link1->groups, sizeof(struct anonymous_20) /*232ul*/  * (unsigned long int)((ret_link1.num_groups & ~(16 - 1)) + 16));
  ret_link1.groups = (struct anonymous_20 *)return_value_memdup_1_link1;
  signed int i_link1 = 0;
  for( ; !(i_link1 >= ret_link1.num_groups); i_link1 = i_link1 + 1)
  {
    void *return_value_memdup_2_link1;
    return_value_memdup_2_link1=memdup_link1((void *)(ret_link1.groups + (signed long int)i_link1)->tests, sizeof(signed int) /*4ul*/  * (unsigned long int)(((ret_link1.groups + (signed long int)i_link1)->num & ~(16 - 1)) + 16));
    (ret_link1.groups + (signed long int)i_link1)->tests = (signed int *)return_value_memdup_2_link1;
  }
  return ret_link1;
}

// update_col_cards_under_sequences
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences(const signed int sequences_are_built_by, const char * const col, signed int d)
{
  char this_card = col[(signed long int)(d + 1)];
  char prev_card = col[(signed long int)((d - 1) + 1)];
  _Bool tmp_if_expr_2;
  _Bool tmp_statement_expression_1;
  do
  {
    if(d >= 1)
    {
      prev_card = col[(signed long int)((d - 1) + 1)];
      tmp_statement_expression_1 = ((signed int)this_card >> 2) + 1 == (signed int)prev_card >> 2 && (sequences_are_built_by == 2 ? 1 : (sequences_are_built_by == 1 ? (signed int)(((signed int)this_card & 0x03) == ((signed int)prev_card & 0x03)) : (signed int)(((signed int)this_card & 0x03 & 0x1) != ((signed int)prev_card & 0x03 & 0x1)))) != 0;
      tmp_if_expr_2 = tmp_statement_expression_1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    d = d - 1;
    this_card = prev_card;
  }
  while((_Bool)1);
  return d;
}

// update_col_cards_under_sequences_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/instance.h line 948
static inline signed int update_col_cards_under_sequences_link1(const signed int sequences_are_built_by_link1, const char * const col_link1, signed int d_link1)
{
  char this_card_link1 = col_link1[(signed long int)(d_link1 + 1)];
  char prev_card_link1 = col_link1[(signed long int)((d_link1 - 1) + 1)];
  _Bool tmp_if_expr_2_link1;
  _Bool tmp_statement_expression_1_link1;
  do
  {
    if(d_link1 >= 1)
    {
      prev_card_link1 = col_link1[(signed long int)((d_link1 - 1) + 1)];
      tmp_statement_expression_1_link1 = ((signed int)this_card_link1 >> 2) + 1 == (signed int)prev_card_link1 >> 2 && (sequences_are_built_by_link1 == 2 ? 1 : (sequences_are_built_by_link1 == 1 ? (signed int)(((signed int)this_card_link1 & 0x03) == ((signed int)prev_card_link1 & 0x03)) : (signed int)(((signed int)this_card_link1 & 0x03 & 0x1) != ((signed int)prev_card_link1 & 0x03 & 0x1)))) != 0;
      tmp_if_expr_2_link1 = tmp_statement_expression_1_link1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2_link1 = (_Bool)0;
    if(!tmp_if_expr_2_link1)
      break;

    d_link1 = d_link1 - 1;
    this_card_link1 = prev_card_link1;
  }
  while((_Bool)1);
  return d_link1;
}

// user_compile_all_flares_plans
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 495
static signed int user_compile_all_flares_plans(struct anonymous * const user, signed int * const instance_list_index, char ** const error_string)
{
  signed int user_inst_idx = 0;
  _Bool tmp_if_expr_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  _Bool return_value_string_starts_with_10;
  _Bool tmp_if_expr_6;
  _Bool return_value_string_starts_with_9;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous_1 *instance_item;
    *instance_list_index = user_inst_idx;
    instance_item = &user->instances_list[(signed long int)user_inst_idx];
    if(instance_item->flares_plan_compiled == (_Bool)0)
    {
      if(instance_item->flares_plan_string == ((char *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = !(instance_item->flares_plan_string[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(!(instance_item->plan == ((struct anonymous_0 *)NULL)))
          free((void *)instance_item->plan);

        instance_item->num_plan_items = 2;
        void *return_value_malloc_1;
        return_value_malloc_1=malloc(sizeof(struct anonymous_0) /*12ul*/  * (unsigned long int)instance_item->num_plan_items);
        instance_item->plan = (struct anonymous_0 *)return_value_malloc_1;
        (instance_item->plan + (signed long int)0)->type = FLARES_PLAN_RUN_INDEFINITELY;
        (instance_item->plan + (signed long int)0)->flare_idx = 0;
        (instance_item->plan + (signed long int)0)->count_iters = -1;
        (instance_item->plan + (signed long int)1)->type = FLARES_PLAN_CHECKPOINT;
        (instance_item->plan + (signed long int)1)->flare_idx = -1;
        (instance_item->plan + (signed long int)1)->count_iters = -1;
        instance_item->flares_plan_compiled = (_Bool)1;
        goto __CPROVER_DUMP_L35;
      }

      char *item_start;
      char *item_end;
      char *cmd_end;
      signed int last_item_type = -1;
      if(!(instance_item->plan == ((struct anonymous_0 *)NULL)))
      {
        free((void *)instance_item->plan);
        instance_item->plan = (struct anonymous_0 *)(void *)0;
        instance_item->num_plan_items = 0;
      }

      item_start = instance_item->flares_plan_string;
      do
      {
        cmd_end=strchr(item_start, 58);
        if(cmd_end == ((char *)NULL))
        {
          *error_string=strdup("Could not find a \":\" for a command.");
          *instance_list_index = user_inst_idx;
          return 1;
        }

        _Bool return_value_string_starts_with_11;
        return_value_string_starts_with_11=string_starts_with(item_start, "Run", cmd_end);
        if(!(return_value_string_starts_with_11 == (_Bool)0))
        {
          char *at_sign;
          char *after_at_sign;
          signed int count_iters;
          _Bool found_flare;
          signed int flare_idx;
          cmd_end = cmd_end + 1l;
          count_iters=atoi(cmd_end);
          at_sign = cmd_end;
          for( ; !(*at_sign == 0); at_sign = at_sign + 1l)
          {
            return_value___ctype_b_loc_3=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*at_sign]) == 0)
              break;

          }
          if(!((signed int)*at_sign == 64))
          {
            *error_string=strdup("Could not find a \"@\" directly after the digits after the 'Run:' command.");
            *instance_list_index = user_inst_idx;
            return 2;
          }

          after_at_sign = at_sign + (signed long int)1;
          item_end=strchr(after_at_sign, 44);
          if(item_end == ((char *)NULL))
          {
            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(after_at_sign);
            item_end = after_at_sign + (signed long int)return_value_strlen_4;
          }

          found_flare = (_Bool)0;
          flare_idx = 0;
          for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
          {
            struct anonymous_2 *user_compile_all_flares_plans__1__1__1__3__2__2__4__1__flare = &instance_item->flares[(signed long int)flare_idx];
            if(!(user_compile_all_flares_plans__1__1__1__3__2__2__4__1__flare->name == ((char *)NULL)))
            {
              signed int return_value_strncmp_5;
              return_value_strncmp_5=strncmp(user_compile_all_flares_plans__1__1__1__3__2__2__4__1__flare->name, after_at_sign, (unsigned long int)(item_end - after_at_sign));
              if(return_value_strncmp_5 == 0)
              {
                found_flare = (_Bool)1;
                break;
              }

            }

          }
          if(found_flare == (_Bool)0)
          {
            *error_string=strdup("Unknown flare name.");
            *instance_list_index = user_inst_idx;
            return 3;
          }

          last_item_type=add_count_iters_to_plan(instance_item, flare_idx, count_iters);
        }

        else
        {
          return_value_string_starts_with_10=string_starts_with(item_start, "CP", cmd_end);
          if(!(return_value_string_starts_with_10 == (_Bool)0))
          {
            item_end = cmd_end + (signed long int)1;
            if((signed int)*item_end == 44)
              tmp_if_expr_6 = (_Bool)1;

            else
              tmp_if_expr_6 = !(*item_end != 0) ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr_6)
            {
              *error_string=strdup("Junk after CP (Checkpoint) command.");
              *instance_list_index = user_inst_idx;
              return 4;
            }

            last_item_type=add_checkpoint_to_plan(instance_item);
          }

          else
          {
            return_value_string_starts_with_9=string_starts_with(item_start, "RunIndef", cmd_end);
            if(!(return_value_string_starts_with_9 == (_Bool)0))
            {
              _Bool user_compile_all_flares_plans__1__1__1__3__2__4__found_flare;
              signed int user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx;
              cmd_end = cmd_end + 1l;
              item_end=strchr(cmd_end, 44);
              if(!(item_end == ((char *)NULL)))
              {
                *error_string=strdup("Junk after last RunIndef command. Must be the final command.");
                *instance_list_index = user_inst_idx;
                return 6;
              }

              unsigned long int return_value_strlen_7;
              return_value_strlen_7=strlen(cmd_end);
              item_end = cmd_end + (signed long int)return_value_strlen_7;
              user_compile_all_flares_plans__1__1__1__3__2__4__found_flare = (_Bool)0;
              user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx = 0;
              for( ; !(user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx >= instance_item->num_flares); user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx = user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx + 1)
              {
                struct anonymous_2 *flare = &instance_item->flares[(signed long int)user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx];
                if(!(flare->name == ((char *)NULL)))
                {
                  signed int return_value_strncmp_8;
                  return_value_strncmp_8=strncmp(flare->name, cmd_end, (unsigned long int)(item_end - cmd_end));
                  if(return_value_strncmp_8 == 0)
                  {
                    user_compile_all_flares_plans__1__1__1__3__2__4__found_flare = (_Bool)1;
                    break;
                  }

                }

              }
              if(user_compile_all_flares_plans__1__1__1__3__2__4__found_flare == (_Bool)0)
              {
                *error_string=strdup("Unknown flare name in RunIndef command.");
                *instance_list_index = user_inst_idx;
                return 3;
              }

              last_item_type=add_run_indef_to_plan(instance_item, user_compile_all_flares_plans__1__1__1__3__2__4__flare_idx);
            }

            else
            {
              *error_string=strdup("Unknown command.");
              *instance_list_index = user_inst_idx;
              return 5;
            }
          }
        }
        item_start = item_end + (signed long int)1;
      }
      while(!(*item_end == 0));
      /* assertion last_item_type != -1 */
      assert(last_item_type != -1);
      if(!(last_item_type == FLARES_PLAN_CHECKPOINT))
        last_item_type=add_checkpoint_to_plan(instance_item);

      instance_item->flares_plan_compiled = (_Bool)1;
    }


  __CPROVER_DUMP_L35:
    ;
  }
  *instance_list_index = -1;
  *error_string = (char *)(void *)0;
  return 0;
}

// user_free_resources
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 1377
static void user_free_resources(struct anonymous * const user)
{
  signed int user_inst_idx = 0;
  for( ; !(user_inst_idx >= user->num_instances); user_inst_idx = user_inst_idx + 1)
  {
    struct anonymous_1 * const instance_item = &user->instances_list[(signed long int)user_inst_idx];
    signed int flare_idx = 0;
    for( ; !(flare_idx >= instance_item->num_flares); flare_idx = flare_idx + 1)
    {
      struct anonymous_2 * const flare = &instance_item->flares[(signed long int)flare_idx];
      const signed int ret_code = flare->ret_code;
      if(!(ret_code == 8) && !(ret_code == 9))
      {
        if(flare->instance_is_ready == (_Bool)0)
          fc_solve_finish_instance(flare->obj);

      }

      fc_solve_free_instance(flare->obj);
      if(!(flare->name == ((char *)NULL)))
      {
        free((void *)flare->name);
        flare->name = (char *)(void *)0;
      }

      if(!(flare->fc_pro_moves.moves == ((struct anonymous_54 *)NULL)))
        fc_solve_moves_processed_free(&flare->fc_pro_moves);

      if(!(flare->moves_seq.moves == ((struct anonymous_4 *)NULL)))
      {
        free((void *)flare->moves_seq.moves);
        flare->moves_seq.moves = (struct anonymous_4 *)(void *)0;
        flare->moves_seq.num_moves = 0;
      }

    }
    free((void *)instance_item->flares);
    if(!(instance_item->flares_plan_string == ((char *)NULL)))
      free((void *)instance_item->flares_plan_string);

    if(!(instance_item->plan == ((struct anonymous_0 *)NULL)))
      free((void *)instance_item->plan);

  }
  free((void *)user->instances_list);
  if(!(user->state_string_copy == ((char *)NULL)))
  {
    free((void *)user->state_string_copy);
    user->state_string_copy = (char *)(void *)0;
  }

  if(!(user->error_string == ((char *)NULL)))
  {
    free((void *)user->error_string);
    user->error_string = (char *)(void *)0;
  }

  fc_solve_meta_compact_allocator_finish(&user->meta_alloc);
}

// user_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 212
static void user_initialize(struct anonymous * const user)
{
  const struct anonymous_35 *freecell_preset;
  fc_solve_get_preset_by_name("freecell", &freecell_preset);
  user->common_preset = *freecell_preset;
  fc_solve_meta_compact_allocator_init(&user->meta_alloc);
  user->instances_list = (struct anonymous_1 *)(void *)0;
  user->num_instances = 0;
  user->long_iter_handler = (void (*)(void *, signed long int, signed int, void *, signed long int, void *))(void *)0;
  user->iter_handler = (void (*)(void *, signed int, signed int, void *, signed int, void *))(void *)0;
  user->current_iterations_limit = (signed long int)-1;
  user->state_string_copy = (char *)(void *)0;
  user->iterations_board_started_at.num_checked_states = (signed long int)0;
  user->iterations_board_started_at.num_states_in_collection = (signed long int)0;
  user->all_instances_were_suspended = (_Bool)1;
  user->flares_choice = (enum FLARES_CHOICE_TYPE)FLARES_CHOICE_FC_SOLVE_SOLUTION_LEN;
  user->flares_iters_factor = 1.0;
  user->error_string = (char *)(void *)0;
  user_next_instance(user);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// user_next_flare
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2335
static signed int user_next_flare(struct anonymous *user)
{
  struct anonymous_1 *instance_item;
  instance_item=get_current_instance_item(user);
  instance_item->num_flares = instance_item->num_flares + 1;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)instance_item->flares, sizeof(struct anonymous_2) /*88ul*/  * (unsigned long int)instance_item->num_flares);
  instance_item->flares = (struct anonymous_2 *)return_value_realloc_1;
  struct anonymous_2 * const flare = &instance_item->flares[(signed long int)(instance_item->num_flares - 1)];
  flare->limit = -1;
  instance_item->limit = flare->limit;
  user->active_flare = flare;
  flare->obj=fc_solve_alloc_instance(&user->meta_alloc);
  user->soft_thread=fc_solve_instance_get_first_soft_thread(user->active_flare->obj);
  fc_solve_apply_preset_by_ptr(flare->obj, &user->common_preset);
  flare->ret_code = 9;
  user->ret_code = flare->ret_code;
  _Bool tmp_if_expr_2;
  if(!(user->iter_handler == ((void (*)(void *, signed int, signed int, void *, signed int, void *))NULL)))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = user->long_iter_handler != ((void (*)(void *, signed long int, signed int, void *, signed long int, void *))NULL) ? (_Bool)1 : (_Bool)0;
  flare->obj->debug_iter_output_func = tmp_if_expr_2 ? iter_handler_wrapper : (void (*)(void *api_instance, signed long int iter_num, signed int depth, void *lp_instance, struct anonymous_6 *ptr_state, signed long int parent_iter_num))(void *)0;
  flare->obj->debug_iter_output_context = (void *)user;
  flare->moves_seq.num_moves = 0;
  flare->moves_seq.moves = (struct anonymous_4 *)(void *)0;
  flare->name = (char *)(void *)0;
  flare->fc_pro_moves.moves = (struct anonymous_54 *)(void *)0;
  flare->instance_is_ready = (_Bool)1;
  init_stats(&flare->obj_stats);
  return 0;
}

// user_next_instance
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/lib.c line 2379
static signed int user_next_instance(struct anonymous * const user)
{
  user->num_instances = user->num_instances + 1;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)user->instances_list, sizeof(struct anonymous_1) /*56ul*/  * (unsigned long int)user->num_instances);
  user->instances_list = (struct anonymous_1 *)return_value_realloc_1;
  user->current_instance_idx = user->num_instances - 1;
  struct anonymous_1 *instance_item;
  instance_item=get_current_instance_item(user);
  instance_item->num_flares = 0;
  instance_item->flares = (struct anonymous_2 *)(void *)0;
  instance_item->plan = (struct anonymous_0 *)(void *)0;
  instance_item->num_plan_items = 0;
  instance_item->flares_plan_string = (char *)(void *)0;
  instance_item->flares_plan_compiled = (_Bool)0;
  instance_item->current_plan_item_idx = 0;
  instance_item->minimal_solution_flare_idx = -1;
  instance_item->all_plan_items_finished_so_far = 1;
  signed int return_value_user_next_flare_2;
  return_value_user_next_flare_2=user_next_flare(user);
  return return_value_user_next_flare_2;
}

// worker_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-freecell-solver/freecell-solver-3.26.0/threaded_range_solver.c line 209
static void * worker_thread(void *void_context)
{
  const struct anonymous_26 * const context = (const struct anonymous_26 *)void_context;
  struct anonymous_29 user;
  void *return_value_freecell_solver_user_alloc_1;
  return_value_freecell_solver_user_alloc_1=freecell_solver_user_alloc();
  user = (struct anonymous_29){ .display_context={ .debug_iter_state_output=(_Bool)0, .parseable_output=(_Bool)0, .canonized_order_output=(_Bool)0,
    .display_10_as_t=(_Bool)0, .display_parent_iter_num=(_Bool)0 }, .instance=return_value_freecell_solver_user_alloc_1 };
  signed int arg = context->arg;
  char *error_string;
  char **argv = context->argv;
  signed int parser_ret;
  parser_ret=freecell_solver_user_cmd_line_parse_args(user.instance, context->argc, (const char **)(void *)argv, arg, known_parameters, cmd_line_callback, (void *)&user, &error_string, &arg);
  if(parser_ret == 3)
  {
    fprintf(stderr, "Unknown option: %s", argv[(signed long int)arg]);
    goto ret_label;
  }

  else
    if(parser_ret == 4)
    {
      fprintf(stderr, "The command line parameter \"%s\" requires an argument and was not supplied with one.\n", argv[(signed long int)arg]);
      goto ret_label;
    }

    else
      if(parser_ret == 5)
      {
        if(!(error_string == ((char *)NULL)))
        {
          fprintf(stderr, "%s", error_string);
          free((void *)error_string);
        }

        goto ret_label;
      }

  signed int board_num;
  const signed int end_board = context->end_board;
  const signed int board_num_step = context->board_num_step;
  const signed int update_total_num_iters_threshold = context->update_total_num_iters_threshold;
  const signed int past_end_board = end_board + 1;
  struct anonymous_27 mytime;
  signed long int total_num_iters_temp = (signed long int)0;
  const signed long int total_iterations_limit_per_board = context->total_iterations_limit_per_board;
  const signed int stop_at = context->stop_at;
  do
  {
    pthread_mutex_lock(&next_board_num_lock);
    pthread_mutex_lock(&total_num_iters_lock); // added mutex
    board_num = next_board_num;
    signed int proposed_quota_end;
    next_board_num = next_board_num + board_num_step;
    proposed_quota_end = next_board_num;
    pthread_mutex_unlock(&total_num_iters_lock); // added mutex
    pthread_mutex_unlock(&next_board_num_lock);
    const signed int quota_end = proposed_quota_end < past_end_board ? proposed_quota_end : past_end_board;
    for( ; !(board_num >= quota_end); board_num = board_num + 1)
    {
      char state_string[165l];
      get_board((signed long int)board_num, state_string);
      freecell_solver_user_limit_iterations_long(user.instance, total_iterations_limit_per_board);
      signed int ret;
      ret=freecell_solver_user_solve_board(user.instance, state_string);
      if(ret == 5)
      {
        gettimeofday(&mytime.tv, &mytime.tz);
        printf("Intractable Board No. %i at %li.%.6li\n", board_num, mytime.tv.tv_sec, mytime.tv.tv_usec);
        fflush(stdout);
      }

      else
        if(ret == 12)
        {
          const char *flares_error_string;
          flares_error_string=freecell_solver_user_get_last_error_string(user.instance);
          fprintf(stderr, "Flares Plan: %s\n", flares_error_string);
          goto theme_error;
        }

        else
          if(ret == 1)
          {
            gettimeofday(&mytime.tv, &mytime.tz);
            printf("Unsolved Board No. %i at %li.%.6li\n", board_num, mytime.tv.tv_sec, mytime.tv.tv_usec);
          }

      signed long int return_value_freecell_solver_user_get_num_times_long_2;
      return_value_freecell_solver_user_get_num_times_long_2=freecell_solver_user_get_num_times_long(user.instance);
      total_num_iters_temp = total_num_iters_temp + return_value_freecell_solver_user_get_num_times_long_2;
      if(total_num_iters_temp >= (signed long int)update_total_num_iters_threshold)
      {
        pthread_mutex_lock(&total_num_iters_lock);
        total_num_iters = total_num_iters + total_num_iters_temp;
        pthread_mutex_unlock(&total_num_iters_lock);
        total_num_iters_temp = (signed long int)0;
      }

      if(board_num % stop_at == 0)
      {
        signed long long int total_num_iters_copy;
        pthread_mutex_lock(&total_num_iters_lock);
	pthread_mutex_lock(&next_board_num_lock); //added mutex
        total_num_iters = total_num_iters + total_num_iters_temp;
        total_num_iters_copy = total_num_iters;
	pthread_mutex_unlock(&next_board_num_lock); //added mutex
        pthread_mutex_unlock(&total_num_iters_lock);
        total_num_iters_temp = (signed long int)0;
        gettimeofday(&mytime.tv, &mytime.tz);
        printf("Reached Board No. %i at %li.%.6li (total_num_iters=%lli)\n", board_num, mytime.tv.tv_sec, mytime.tv.tv_usec, total_num_iters_copy);
        fflush(stdout);
      }

      freecell_solver_user_recycle(user.instance);
    }
  }
  while(end_board >= board_num);
  pthread_mutex_lock(&total_num_iters_lock);
  total_num_iters = total_num_iters + total_num_iters_temp;
  pthread_mutex_unlock(&total_num_iters_lock);

theme_error:
  ;
  freecell_solver_user_free(user.instance);

ret_label:
  ;
  return (void *)0;
}

