// #anon_enum_BR_INIT_ERROR_NOMEM=0_BR_INIT_ERROR_OPEN_MAPS=1_BR_INIT_ERROR_READ_MAPS=2_BR_INIT_ERROR_INVALID_MAPS=3_BR_INIT_ERROR_DISABLED=4
// file binreloc.h line 22
enum anonymous_26 { BR_INIT_ERROR_NOMEM=0, BR_INIT_ERROR_OPEN_MAPS=1, BR_INIT_ERROR_READ_MAPS=2, BR_INIT_ERROR_INVALID_MAPS=3, BR_INIT_ERROR_DISABLED=4 };

// #anon_enum_CAP_CLEAR=0_CAP_SET=1
// file /usr/include/sys/capability.h line 63
enum anonymous_28 { CAP_CLEAR=0, CAP_SET=1 };

// #anon_enum_CAP_EFFECTIVE=0_CAP_PERMITTED=1_CAP_INHERITABLE=2
// file /usr/include/sys/capability.h line 54
enum anonymous_27 { CAP_EFFECTIVE=0, CAP_PERMITTED=1, CAP_INHERITABLE=2 };

// #anon_enum_JU_ERRNO_NONE=0_JU_ERRNO_FULL=1_JU_ERRNO_NFMAX=1_JU_ERRNO_NOMEM=2_JU_ERRNO_NULLPPARRAY=3_JU_ERRNO_NONNULLPARRAY=10_JU_ERRNO_NULLPINDEX=4_JU_ERRNO_NULLPVALUE=11_JU_ERRNO_NOTJUDY1=5_JU_ERRNO_NOTJUDYL=6_JU_ERRNO_NOTJUDYSL=7_JU_ERRNO_UNSORTED=12_JU_ERRNO_OVERRUN=8_JU_ERRNO_CORRUPT=9
// file /usr/include/Judy.h line 110
enum anonymous_8 { JU_ERRNO_NONE=0, JU_ERRNO_FULL=1, JU_ERRNO_NFMAX=1, JU_ERRNO_NOMEM=2, JU_ERRNO_NULLPPARRAY=3, JU_ERRNO_NONNULLPARRAY=10, JU_ERRNO_NULLPINDEX=4, JU_ERRNO_NULLPVALUE=11, JU_ERRNO_NOTJUDY1=5, JU_ERRNO_NOTJUDYL=6, JU_ERRNO_NOTJUDYSL=7, JU_ERRNO_UNSORTED=12, JU_ERRNO_OVERRUN=8, JU_ERRNO_CORRUPT=9 };

// tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 327
struct anonymous_11;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_41;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_29;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_19;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_18;

// tag-#anon#ST[BF{U32}_U32_'__w_stopval'||BF{U32}_U32_'__w_stopsig'||BF{U32}_U32_'_anon0'|]
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 84
struct anonymous_40;

// tag-#anon#ST[BF{U32}_U32_'__w_termsig'||BF{U32}_U32_'__w_coredump'||BF{U32}_U32_'__w_retcode'||BF{U32}_U32_'_anon0'|]
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 69
struct anonymous_39;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_16;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_1;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||S32'count'||U32'_pad0'||U64'last'|]
// file relay.c line 79
struct anonymous_32;

// tag-#anon#ST[SYM#tag-teredo_state#'state'||*{V(*{SYM#tag-teredo_state#}_SYM#tag-teredo_state#_|*{V}_V_)->V}_V(*{SYM#tag-teredo_state#}_SYM#tag-teredo_state#_|*{V}_V_)->V_'cb'||*{V}_V_'opaque'|]
// file maintain.c line 87
struct anonymous_14;

// tag-#anon#ST[U16'flags'||U16'proto'|]
// file tun6.c line 70
struct anonymous;

// tag-#anon#ST[U32'prefix'||U32'server_ip'||U16'flags'||U16'client_port'||U32'client_ip'|]
// file ../libteredo/teredo.h line 53
struct anonymous_38;

// tag-#anon#ST[U64'thread'||B'running'||U56'_pad0'|]
// file relay.c line 87
struct anonymous_33;

// tag-#anon#UN[*{SYM#tag-wait#}_SYM#tag-wait#_'__uptr'||*{S32}_S32_'__iptr'|]
// file /usr/include/stdlib.h line 67
union anonymous_23;

// tag-#anon#UN[*{SYM#tag-wait#}_SYM#tag-wait#_'__uptr'||*{S32}_S32_'__iptr'|]_transparent
// file /usr/include/stdlib.h line 67
union anonymous_34;

// tag-#anon#UN[ARR12{S32}_S32_'_pad'||S32'_tid'||SYM#tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]#'_sigev_thread'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 319
union anonymous_12;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous_42;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_25;

// tag-#anon#UN[ARR16{U8}_U8_'key'||ARR64{U8}_U8_'ipad'|]
// file security.c line 57
union anonymous_4;

// tag-#anon#UN[ARR16{U8}_U8_'key'||ARR64{U8}_U8_'opad'|]
// file security.c line 63
union anonymous_5;

// tag-#anon#UN[ARR1{U32}_U32_'icmp6_un_data32'||ARR2{U16}_U16_'icmp6_un_data16'||ARR4{U8}_U8_'icmp6_un_data8'|]
// file /usr/include/netinet/icmp6.h line 43
union anonymous_0;

// tag-#anon#UN[ARR1{U64}_U64_'align'||ARR65507{U8}_U8_'fill'||U524096'_pad'|]
// file teredo-udp.h line 71
union anonymous_20;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_13;

// tag-#anon#UN[ARR8{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous_2;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_17;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_31;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_9;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'||U8'ip6_un2_vfc'|]
// file /usr/include/netinet/ip6.h line 26
union anonymous_37;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_43;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_21;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_35;

// tag-J_UDY_ERROR_STRUCT
// file /usr/include/Judy.h line 181
struct J_UDY_ERROR_STRUCT;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_cap_struct
// file /usr/include/sys/capability.h line 41
struct _cap_struct;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-clock_data_t
// file clock.c line 41
struct clock_data_t;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-icmp6_filter
// file /usr/include/netinet/icmp6.h line 33
struct icmp6_filter;

// tag-icmp6_hdr
// file /usr/include/netinet/icmp6.h line 38
struct icmp6_hdr;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in6_ifreq
// file tun6.c line 61
struct in6_ifreq;

// tag-in6_rtmsg
// file /usr/include/net/route.h line 57
struct in6_rtmsg;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-in_pktinfo
// file /usr/include/x86_64-linux-gnu/bits/in.h line 153
struct in_pktinfo;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip6_hdr
// file /usr/include/netinet/ip6.h line 24
struct ip6_hdr;

// tag-ip6_hdrctl
// file /usr/include/netinet/ip6.h line 28
struct ip6_hdrctl;

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-md5_state_s
// file md5.h line 67
struct md5_state_s;

// tag-miredo_conf
// file miredo.h line 34
struct miredo_conf;

// tag-miredo_conf_syslog_facility
// file conf.c line 494
struct miredo_conf_syslog_facility;

// tag-miredo_tunnel
// file relayd.c line 86
struct miredo_tunnel;

// tag-miredo_tunnel_settings
// file privproc.h line 25
struct miredo_tunnel_settings;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-nd_opt_hdr
// file /usr/include/netinet/icmp6.h line 186
struct nd_opt_hdr;

// tag-nd_opt_mtu
// file /usr/include/netinet/icmp6.h line 226
struct nd_opt_mtu;

// tag-nd_opt_prefix_info
// file /usr/include/netinet/icmp6.h line 201
struct nd_opt_prefix_info;

// tag-nd_router_advert
// file /usr/include/netinet/icmp6.h line 122
struct nd_router_advert;

// tag-nd_router_solicit
// file /usr/include/netinet/icmp6.h line 111
struct nd_router_solicit;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-setting
// file conf.c line 48
struct setting;

// tag-sigevent
// file /usr/include/time.h line 168
struct sigevent;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-teredo_addr
// file ../libteredo/teredo.h line 50
union teredo_addr;

// tag-teredo_listitem
// file peerlist.c line 159
struct teredo_listitem;

// tag-teredo_maintenance
// file maintain.h line 52
struct teredo_maintenance;

// tag-teredo_packet
// file teredo-udp.h line 41
struct teredo_packet;

// tag-teredo_peer
// file peerlist.h line 31
struct teredo_peer;

// tag-teredo_peerlist
// file peerlist.h line 89
struct teredo_peerlist;

// tag-teredo_queue
// file peerlist.h line 29
struct teredo_queue;

// tag-teredo_state
// file maintain.h line 30
struct teredo_state;

// tag-teredo_tunnel
// file tunnel.h line 83
struct teredo_tunnel;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tun6
// file ../libtun6/tun6.h line 61
struct tun6;

// tag-wait
// file /usr/include/x86_64-linux-gnu/bits/waitstatus.h line 66
union wait;

#ifndef NULL
#define NULL ((void*)0)
#endif

// BuildICMPv6Error
// file packets.h line 145
signed int BuildICMPv6Error(struct icmp6_hdr * restrict out, unsigned char type, unsigned char code, struct ip6_hdr * restrict in, unsigned long int inlen);
// CheckBubble
// file packets.h line 41
signed int CheckBubble(const struct teredo_packet *packet);
// CheckPing
// file packets.h line 40
signed int CheckPing(const struct teredo_packet *packet);
// CountBubble
// file relay.c line 257
static signed int CountBubble(struct teredo_peer *peer, unsigned long int now);
// CountPing
// file relay.c line 220
static signed int CountPing(struct teredo_peer *peer, unsigned long int now);
// GetIPv4ByName
// file conf.c line 393
signed int GetIPv4ByName(const char *hostname, unsigned int *ipv4);
// IsBubble
// file packets.h line 48
static inline _Bool IsBubble(struct ip6_hdr *hdr);
// IsClient
// file relay.c line 246
static inline _Bool IsClient(const struct teredo_tunnel *tunnel);
// IsValid
// file peerlist.h line 83
static inline _Bool IsValid(const struct teredo_peer *peer, unsigned long int now);
// JudyHSDel
// file /usr/include/Judy.h line 288
extern signed int JudyHSDel(void **, void *, unsigned long int, struct J_UDY_ERROR_STRUCT *);
// JudyHSFreeArray
// file /usr/include/Judy.h line 289
extern unsigned long int JudyHSFreeArray(void **, struct J_UDY_ERROR_STRUCT *);
// JudyHSGet
// file /usr/include/Judy.h line 286
extern void ** JudyHSGet(const void *, void *, unsigned long int);
// JudyHSIns
// file /usr/include/Judy.h line 287
extern void ** JudyHSIns(void **, void *, unsigned long int, struct J_UDY_ERROR_STRUCT *);
// LogError
// file conf.c line 91
static void LogError(struct miredo_conf *conf, const char *fmt, ...);
// LogWarning
// file conf.c line 111
static void LogWarning(struct miredo_conf *conf, const char *fmt, ...);
// ParseRelayType
// file relayd.c line 168
static _Bool ParseRelayType(struct miredo_conf *conf, const char *name, signed int *type);
// Pryt4897810065911_br_build_path
// file binreloc.c line 690
char * Pryt4897810065911_br_build_path(const char *dir, const char *file);
// Pryt4897810065911_br_dirname
// file binreloc.c line 746
char * Pryt4897810065911_br_dirname(const char *path);
// Pryt4897810065911_br_find_bin_dir
// file binreloc.c line 438
char * Pryt4897810065911_br_find_bin_dir(const char *default_bin_dir);
// Pryt4897810065911_br_find_data_dir
// file binreloc.c line 505
char * Pryt4897810065911_br_find_data_dir(const char *default_data_dir);
// Pryt4897810065911_br_find_etc_dir
// file binreloc.h line 68
char * Pryt4897810065911_br_find_etc_dir(const char *default_etc_dir);
// Pryt4897810065911_br_find_exe
// file binreloc.c line 349
char * Pryt4897810065911_br_find_exe(const char *default_exe);
// Pryt4897810065911_br_find_exe_dir
// file binreloc.c line 377
char * Pryt4897810065911_br_find_exe_dir(const char *default_dir);
// Pryt4897810065911_br_find_lib_dir
// file binreloc.c line 571
char * Pryt4897810065911_br_find_lib_dir(const char *default_lib_dir);
// Pryt4897810065911_br_find_libexec_dir
// file binreloc.c line 604
char * Pryt4897810065911_br_find_libexec_dir(const char *default_libexec_dir);
// Pryt4897810065911_br_find_locale_dir
// file binreloc.h line 65
char * Pryt4897810065911_br_find_locale_dir(const char *default_locale_dir);
// Pryt4897810065911_br_find_prefix
// file binreloc.c line 405
char * Pryt4897810065911_br_find_prefix(const char *default_prefix);
// Pryt4897810065911_br_find_sbin_dir
// file binreloc.c line 471
char * Pryt4897810065911_br_find_sbin_dir(const char *default_sbin_dir);
// Pryt4897810065911_br_init
// file binreloc.h line 56
signed int Pryt4897810065911_br_init(enum anonymous_26 *error);
// Pryt4897810065911_br_init_lib
// file binreloc.c line 332
signed int Pryt4897810065911_br_init_lib(enum anonymous_26 *error);
// Pryt4897810065911_br_strcat
// file binreloc.c line 667
char * Pryt4897810065911_br_strcat(const char *str1, const char *str2);
// SendBubbleFromDst
// file packets.h line 63
signed int SendBubbleFromDst(signed int fd, struct in6_addr *dst, _Bool indirect);
// SendPing
// file packets.h line 127
signed int SendPing(signed int fd, union teredo_addr *src, struct in6_addr *dst);
// SetMapping
// file peerlist.h line 65
static inline void SetMapping(struct teredo_peer *peer, unsigned int ip, unsigned short int port);
// SetMappingFromPacket
// file relay.c line 296
static inline void SetMappingFromPacket(struct teredo_peer *peer, struct teredo_packet *p);
// TouchReceive
// file peerlist.h line 71
static inline void TouchReceive(struct teredo_peer *peer, unsigned long int now);
// TouchTransmit
// file peerlist.h line 76
static inline void TouchTransmit(struct teredo_peer *peer, unsigned long int now);
// __cmsg_nxthdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 272
extern struct cmsghdr * __cmsg_nxthdr(struct msghdr *, struct cmsghdr *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_19 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_19 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_19 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// _br_find_exe
// file binreloc.c line 43
static char * _br_find_exe(enum anonymous_26 *error);
// _br_find_exe_for_symbol
// file binreloc.c line 182
static char * _br_find_exe_for_symbol(const void *symbol, enum anonymous_26 *error);
// _iface_addr
// file tun6.c line 507
static signed int _iface_addr(signed int reqfd, signed int id, _Bool add, struct in6_addr *addr, unsigned int prefix_len);
// _iface_route
// file tun6.c line 586
static signed int _iface_route(signed int reqfd, signed int id, _Bool add, struct in6_addr *addr, unsigned int prefix_len, signed int rel_metric);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// br_strndup
// file binreloc.c line 712
static char * br_strndup(const char *str, unsigned long int size);
// cap_free
// file /usr/include/sys/capability.h line 74
extern signed int cap_free(void *);
// cap_init
// file /usr/include/sys/capability.h line 75
extern struct _cap_struct * cap_init(void);
// cap_set_flag
// file /usr/include/sys/capability.h line 79
extern signed int cap_set_flag(struct _cap_struct *, enum anonymous_27, signed int, const signed int *, enum anonymous_28);
// cap_set_proc
// file /usr/include/sys/capability.h line 93
extern signed int cap_set_proc(struct _cap_struct *);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// checkTimeDrift
// file maintain.c line 200
static _Bool checkTimeDrift(struct timespec *ts);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// cleanup_unlock
// file maintain.c line 218
static void cleanup_unlock(void *o);
// clearenv
// file /usr/include/stdlib.h line 595
extern signed int clearenv(void);
// clock_getres
// file /usr/include/time.h line 339
extern signed int clock_getres(signed int, struct timespec *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// clock_nanosleep
// file /usr/include/time.h line 353
extern signed int clock_nanosleep(signed int, signed int, struct timespec *, struct timespec *);
// clock_tick
// file clock.c line 49
static void clock_tick(union sigval val);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closefrom
// file closefrom.c line 39
signed int closefrom(signed int fd);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// configure_tunnel
// file relayd.c line 245
static signed int configure_tunnel(signed int fd, struct in6_addr *addr, unsigned int mtu);
// create_dynamic_tunnel
// file relayd.c line 204
static struct tun6 * create_dynamic_tunnel(const char *ifname, signed int *pfd);
// create_pidfile
// file main.c line 156
static signed int create_pidfile(const char *path);
// create_static_tunnel
// file relayd.c line 327
static struct tun6 * create_static_tunnel(const char * restrict ifname, struct in6_addr * restrict prefix, unsigned short int mtu);
// destroy_dynamic_tunnel
// file relayd.c line 269
static void destroy_dynamic_tunnel(struct tun6 *tunnel, signed int fd);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// do_maintenance
// file maintain.c line 403
static void * do_maintenance(void *opaque);
// drop_privileges
// file miredo.h line 44
signed int drop_privileges(void);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// error_dup
// file main.c line 112
static signed int error_dup(signed int opt, const char *already, const char *additionnal);
// error_errno
// file main.c line 142
static signed int error_errno(const char *str);
// error_extra
// file main.c line 134
static signed int error_extra(const char *extra);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdatasync
// file /usr/include/unistd.h line 1112
extern signed int fdatasync(signed int);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freopen
// file /usr/include/stdio.h line 278
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// garbage_collector
// file peerlist.c line 228
static void * garbage_collector(void *data);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getipv4byname
// file maintain.c line 107
static signed int getipv4byname(const char * restrict name, unsigned int * restrict ipv4);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// gettime
// file maintain.c line 60
static inline void gettime(struct timespec *now);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icmp6_checksum
// file checksum.h line 34
static inline unsigned short int icmp6_checksum(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6);
// if_indextoname
// file /usr/include/net/if.h line 194
extern char * if_indextoname(unsigned int, char *);
// if_nametoindex
// file /usr/include/net/if.h line 193
extern unsigned int if_nametoindex(const char *);
// in6_matches_teredo_client
// file teredo.h line 95
static inline signed int in6_matches_teredo_client(struct in6_addr *ip6, unsigned int ip, unsigned short int port);
// in_cksum
// file teredo.c line 338
static unsigned short int in_cksum(struct iovec *iov, unsigned long int n);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// init_locale
// file main.c line 313
static void init_locale(void);
// init_security
// file main.c line 207
static signed int init_security(const char *username);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_ipv4_global_unicast
// file v4global.h line 34
signed int is_ipv4_global_unicast(unsigned int ip);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listitem_create
// file peerlist.c line 181
static inline struct teredo_listitem * listitem_create(void);
// listitem_destroy
// file peerlist.c line 190
static inline void listitem_destroy(struct teredo_listitem *entry);
// listitem_recdestroy
// file peerlist.c line 197
static void listitem_recdestroy(struct teredo_listitem *entry);
// lockf
// file /usr/include/unistd.h line 1081
extern signed int lockf(signed int, signed int, signed long int);
// logger
// file miredo.c line 96
static void logger(void *dummy, _Bool error, const char *fmt, void **ap);
// maintenance_recv
// file maintain.c line 132
static signed int maintenance_recv(const struct teredo_packet * restrict packet, unsigned int server_ip, const unsigned char * restrict nonce, _Bool cone, struct teredo_state * restrict state);
// maintenance_thread
// file maintain.c line 242
static inline void maintenance_thread(struct teredo_maintenance *m);
// maintenance_thread::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes);
// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest);
// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms);
// md5_process
// file md5.c line 147
static void md5_process(struct md5_state_s *pms, const unsigned char *data);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// miredo
// file miredo.h line 43
signed int miredo(const char *confpath, const char *server_name, signed int pidfd);
// miredo_conf_clear
// file conf.h line 38
void miredo_conf_clear(struct miredo_conf *conf, signed int show);
// miredo_conf_create
// file conf.h line 33
struct miredo_conf * miredo_conf_create(void (*logger)(void *, _Bool, const char *, void **), void *opaque);

//
void logger_object(void *, _Bool, const char *, void **);
// miredo_conf_destroy
// file conf.h line 34
void miredo_conf_destroy(struct miredo_conf *conf);
// miredo_conf_get
// file conf.h line 39
char * miredo_conf_get(struct miredo_conf *conf, const char *name, unsigned int *line);
// miredo_conf_get_int16
// file conf.h line 41
_Bool miredo_conf_get_int16(struct miredo_conf *conf, const char *name, unsigned short int *value, unsigned int *line);
// miredo_conf_parse_IPv4
// file conf.h line 48
_Bool miredo_conf_parse_IPv4(struct miredo_conf *conf, const char *name, unsigned int *ipv4);
// miredo_conf_parse_IPv6
// file conf.c line 436
_Bool miredo_conf_parse_IPv6(struct miredo_conf *conf, const char *name, struct in6_addr *value);
// miredo_conf_parse_syslog_facility
// file conf.h line 55
_Bool miredo_conf_parse_syslog_facility(struct miredo_conf *conf, const char *name, signed int *facility);
// miredo_conf_parse_teredo_prefix
// file conf.h line 52
_Bool miredo_conf_parse_teredo_prefix(struct miredo_conf *conf, const char *name, unsigned int *value);
// miredo_conf_read_FILE
// file conf.c line 233
static _Bool miredo_conf_read_FILE(struct miredo_conf *conf, struct _IO_FILE *stream);
// miredo_conf_read_file
// file conf.h line 36
_Bool miredo_conf_read_file(struct miredo_conf *conf, const char *path);
// miredo_conf_set
// file conf.c line 157
static _Bool miredo_conf_set(struct miredo_conf *conf, const char *name, const char *value, unsigned int line);
// miredo_deinit
// file relayd.c line 118
static void miredo_deinit(_Bool client);
// miredo_diagnose_object
//
signed int miredo_diagnose_object(void);
// miredo_down_callback
// file relayd.c line 303
static void miredo_down_callback(void *data);
// miredo_encap_thread
// file relayd.c line 385
static void * miredo_encap_thread(void *d);
// miredo_icmp6_callback
// file relayd.c line 142
static void miredo_icmp6_callback(void *data, const void *packet, unsigned long int length, struct in6_addr *dst);
// miredo_init
// file relayd.c line 95
static signed int miredo_init(_Bool client);
// miredo_main
// file miredo.h line 41
signed int miredo_main(signed int argc, char **argv);
// miredo_recv_callback
// file relayd.c line 130
static void miredo_recv_callback(void *data, const void *packet, unsigned long int length);
// miredo_run_object
//
signed int miredo_run_object(struct miredo_conf *, const char *);
// miredo_setup_fd
// file relayd.c line 600
static void miredo_setup_fd(signed int fd);
// miredo_setup_nonblock_fd
// file relayd.c line 606
static void miredo_setup_nonblock_fd(signed int fd);
// miredo_up_callback
// file relayd.c line 284
static void miredo_up_callback(void *data, struct in6_addr *addr, unsigned short int mtu);
// miredo_version
// file main.c line 90
signed int miredo_version(void);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// proc_write_zero
// file tun6.c line 417
static signed int proc_write_zero(const char *path);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_17 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_17 *, const union anonymous_13 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_17 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_17 *, union anonymous_9 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_17 *, union anonymous_9 *);
// pthread_condattr_destroy
// file /usr/include/pthread.h line 1014
extern signed int pthread_condattr_destroy(union anonymous_13 *);
// pthread_condattr_init
// file /usr/include/pthread.h line 1010
extern signed int pthread_condattr_init(union anonymous_13 *);
// pthread_condattr_setclock
// file /usr/include/pthread.h line 1035
extern signed int pthread_condattr_setclock(union anonymous_13 *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_9 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_9 *, const union anonymous_13 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_9 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_9 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 895
extern signed int pthread_rwlock_destroy(union anonymous_31 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous_31 *, const union anonymous_2 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_31 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_31 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_31 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_29 *, struct anonymous_29 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// quick_usage
// file main.c line 64
static signed int quick_usage(const char *path);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readv
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 39
extern signed long int readv(signed int, struct iovec *, signed int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// relay_diagnose
// file relayd.c line 73
static signed int relay_diagnose(void);
// relay_run
// file relayd.c line 438
static signed int relay_run(struct miredo_conf *conf, const char *server_name);
// run_tunnel
// file relayd.c line 419
static signed int run_tunnel(struct miredo_tunnel *tunnel);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// setuid_notice
// file main.c line 193
static void setuid_notice(void);
// setup_client
// file relayd.c line 314
static signed int setup_client(struct teredo_tunnel *client, const char *server, const char *server2);
// setup_relay
// file relayd.c line 373
static signed int setup_relay(struct teredo_tunnel *relay, unsigned int prefix, _Bool cone);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_29 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_29 *);
// sigismember
// file /usr/include/signal.h line 227
extern signed int sigismember(const struct anonymous_29 *, signed int);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous_29 *, signed int *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 437
extern char * strerror_r(signed int, char *, unsigned long int);
// strlcpy
// file ../compat/fixups.h line 50
unsigned long int strlcpy(char *tgt, const char *src, unsigned long int bufsize);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// teredo_cksum
// file teredo-udp.h line 152
unsigned short int teredo_cksum(const void *src, const void *dst, unsigned char protocol, struct iovec *data, unsigned long int n);
// teredo_cleanup
// file ../libteredo/tunnel.h line 75
void teredo_cleanup(_Bool use_client);
// teredo_clock
// file clock.h line 46
unsigned long int teredo_clock(void);
// teredo_close
// file teredo-udp.h line 163
void teredo_close(signed int fd);
// teredo_create
// file ../libteredo/tunnel.h line 103
struct teredo_tunnel * teredo_create(unsigned int ipv4, unsigned short int port);
// teredo_deinit_HMAC
// file security.h line 35
void teredo_deinit_HMAC(void);
// teredo_destroy
// file ../libteredo/tunnel.h line 117
void teredo_destroy(struct teredo_tunnel *t);
// teredo_dummy_icmpv6_cb
// file relay.c line 852
static void teredo_dummy_icmpv6_cb(void *o, const void *p, unsigned long int l, struct in6_addr *d);
// teredo_dummy_recv_cb
// file relay.c line 844
static void teredo_dummy_recv_cb(void *o, const void *p, unsigned long int l);
// teredo_dummy_state_down_cb
// file relay.c line 872
static void teredo_dummy_state_down_cb(void *o);
// teredo_dummy_state_up_cb
// file relay.c line 863
static void teredo_dummy_state_up_cb(void *o, struct in6_addr *a, unsigned short int m);
// teredo_encap
// file relay.c line 311
static signed int teredo_encap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned long int now);
// teredo_enqueue_in
// file peerlist.h line 52
void teredo_enqueue_in(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port);
// teredo_enqueue_out
// file peerlist.h line 55
void teredo_enqueue_out(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len);
// teredo_get_flbits
// file security.c line 226
unsigned short int teredo_get_flbits(unsigned int timestamp);
// teredo_get_nonce
// file security.c line 241
void teredo_get_nonce(unsigned int timestamp, unsigned int ipv4, unsigned short int port, unsigned char * restrict nonce);
// teredo_get_pinghash
// file security.c line 181
void teredo_get_pinghash(unsigned int timestamp, struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash);
// teredo_get_privdata
// file relay.c line 1105
void * teredo_get_privdata(const struct teredo_tunnel *t);
// teredo_hash
// file security.c line 126
static void teredo_hash(const void *src, unsigned long int slen, const void *dst, unsigned long int dlen, unsigned char * restrict hash, unsigned int timestamp);
// teredo_init_HMAC
// file security.h line 34
signed int teredo_init_HMAC(void);
// teredo_list_create
// file peerlist.h line 106
struct teredo_peerlist * teredo_list_create(unsigned int max, unsigned int expiration);
// teredo_list_destroy
// file peerlist.h line 113
void teredo_list_destroy(struct teredo_peerlist *l);
// teredo_list_lookup
// file peerlist.h line 141
struct teredo_peer * teredo_list_lookup(struct teredo_peerlist * restrict list, struct in6_addr * restrict addr, _Bool * restrict create);
// teredo_list_release
// file peerlist.h line 149
void teredo_list_release(struct teredo_peerlist *l);
// teredo_list_reset
// file peerlist.h line 122
void teredo_list_reset(struct teredo_peerlist *l, unsigned int max);
// teredo_maintenance_process
// file maintain.h line 98
signed int teredo_maintenance_process(struct teredo_maintenance * restrict m, const struct teredo_packet * restrict packet);
// teredo_maintenance_start
// file maintain.h line 78
struct teredo_maintenance * teredo_maintenance_start(signed int fd, void (*cb)(struct teredo_state *, void *), void *opaque, const char *s1, const char *s2, unsigned int q_sec, unsigned int q_retries, unsigned int refresh_sec, unsigned int restart_sec);

//

// teredo_maintenance_stop
// file maintain.h line 89
void teredo_maintenance_stop(struct teredo_maintenance *m);
// teredo_parse_ra
// file packets.c line 158
signed int teredo_parse_ra(const struct teredo_packet * restrict packet, union teredo_addr * restrict newaddr, _Bool cone, unsigned short int * restrict mtu);
// teredo_peer_destroy
// file peerlist.c line 77
static inline void teredo_peer_destroy(struct teredo_peer *peer);
// teredo_peer_init
// file peerlist.c line 70
static inline void teredo_peer_init(struct teredo_peer *peer);
// teredo_peer_queue
// file peerlist.c line 92
static void teredo_peer_queue(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port, _Bool incoming);
// teredo_peer_queue_yield
// file peerlist.h line 57
struct teredo_queue * teredo_peer_queue_yield(struct teredo_peer *peer);
// teredo_pinghash
// file security.c line 158
static inline void teredo_pinghash(struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash, unsigned int timestamp);
// teredo_predecap
// file relay.c line 528
static void teredo_predecap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, unsigned long int now);
// teredo_queue_emit
// file peerlist.h line 58
void teredo_queue_emit(struct teredo_queue *q, signed int fd, unsigned int ipv4, unsigned short int port, void (*cb)(void *, const void *, unsigned long int), void *opaque);

//

// teredo_recv
// file teredo-udp.h line 129
signed int teredo_recv(signed int fd, struct teredo_packet *p);
// teredo_recv_inner
// file teredo.c line 173
static signed int teredo_recv_inner(signed int fd, struct teredo_packet *p, signed int flags);
// teredo_recv_thread
// file relay.c line 952
static void * teredo_recv_thread(void *t);
// teredo_recverr
// file teredo.c line 118
static signed long int teredo_recverr(signed int fd);
// teredo_reply_bubble
// file packets.h line 79
static inline signed int teredo_reply_bubble(signed int fd, unsigned int ip, unsigned short int port, struct ip6_hdr *req);
// teredo_run
// file relay.c line 986
void teredo_run(struct teredo_tunnel *tunnel);
// teredo_run_async
// file ../libteredo/tunnel.h line 151
signed int teredo_run_async(struct teredo_tunnel *t);
// teredo_run_inner
// file relay.c line 553
static void teredo_run_inner(struct teredo_tunnel * restrict tunnel, struct teredo_packet * restrict packet);
// teredo_send
// file teredo-udp.h line 98
signed int teredo_send(signed int fd, const void *packet, unsigned long int plen, unsigned int dest_ip, unsigned short int dest_port);
// teredo_send_bubble
// file packets.h line 75
signed int teredo_send_bubble(signed int fd, unsigned int ip, unsigned short int port, struct in6_addr *src, struct in6_addr *dst);
// teredo_send_rs
// file packets.c line 119
signed int teredo_send_rs(signed int fd, unsigned int server_ip, const unsigned char *nonce, _Bool cone);
// teredo_send_unreach
// file relay.c line 122
static void teredo_send_unreach(struct teredo_tunnel * restrict tunnel, unsigned char code, struct ip6_hdr * restrict in, unsigned long int len);
// teredo_sendv
// file teredo-udp.h line 113
signed int teredo_sendv(signed int fd, struct iovec *iov, unsigned long int count, unsigned int dest_ip, unsigned short int dest_port);
// teredo_set_client_mode
// file ../libteredo/tunnel.h line 212
signed int teredo_set_client_mode(struct teredo_tunnel * restrict t, const char *s, const char *s2);
// teredo_set_cone_flag
// file ../libteredo/tunnel.h line 181
signed int teredo_set_cone_flag(struct teredo_tunnel *t, _Bool cone);
// teredo_set_icmpv6_callback
// file ../libteredo/tunnel.h line 294
void teredo_set_icmpv6_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int, struct in6_addr *));

//

// teredo_set_prefix
// file ../libteredo/tunnel.h line 166
signed int teredo_set_prefix(struct teredo_tunnel *t, unsigned int prefix);
// teredo_set_privdata
// file ../libteredo/tunnel.h line 224
void * teredo_set_privdata(struct teredo_tunnel *t, void *opaque);
// teredo_set_recv_callback
// file ../libteredo/tunnel.h line 252
void teredo_set_recv_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int));

//

// teredo_set_relay_mode
// file ../libteredo/tunnel.h line 192
signed int teredo_set_relay_mode(struct teredo_tunnel *t);
// teredo_set_state_cb
// file ../libteredo/tunnel.h line 327
void teredo_set_state_cb(struct teredo_tunnel * restrict t, void (*u)(void *, struct in6_addr *, unsigned short int), void (*d)(void *));
// teredo_set_state_cb::d_object
//
void d_object(void *);
// teredo_set_state_cb::u_object
//
void u_object(void *, struct in6_addr *, unsigned short int);
// teredo_socket
// file teredo-udp.h line 90
signed int teredo_socket(unsigned int bind_ip, unsigned short int port);
// teredo_startup
// file ../libteredo/tunnel.h line 65
signed int teredo_startup(_Bool use_client);
// teredo_state_change
// file relay.c line 178
static void teredo_state_change(const struct teredo_state *state, void *self);
// teredo_transmit
// file ../libteredo/tunnel.h line 272
signed int teredo_transmit(struct teredo_tunnel * restrict tunnel, struct ip6_hdr * restrict packet, unsigned long int length);
// teredo_verify_pinghash
// file security.c line 199
signed int teredo_verify_pinghash(unsigned int now, struct in6_addr *src, struct in6_addr *dst, const unsigned char * restrict hash);
// teredo_wait_recv
// file teredo-udp.h line 145
signed int teredo_wait_recv(signed int fd, struct teredo_packet *p);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timer_create
// file /usr/include/time.h line 363
extern signed int timer_create(signed int, struct sigevent *, void ** restrict );
// timer_getoverrun
// file /usr/include/time.h line 380
extern signed int timer_getoverrun(void *);
// timer_settime
// file /usr/include/time.h line 371
extern signed int timer_settime(void *, signed int, struct itimerspec *, struct itimerspec *);
// tun6_addAddress
// file ../libtun6/tun6.h line 91
signed int tun6_addAddress(struct tun6 *t, struct in6_addr *addr, unsigned int prefixlen);
// tun6_addRoute
// file ../libtun6/tun6.h line 98
signed int tun6_addRoute(struct tun6 *t, struct in6_addr *addr, unsigned int prefix_len, signed int rel_metric);
// tun6_bringUp
// file ../libtun6/tun6.h line 81
static inline signed int tun6_bringUp(struct tun6 *t);
// tun6_create
// file ../libtun6/tun6.h line 75
struct tun6 * tun6_create(const char *req_name);
// tun6_delAddress
// file tun6.c line 762
signed int tun6_delAddress(struct tun6 *t, struct in6_addr *addr, unsigned int prefixlen);
// tun6_delRoute
// file tun6.c line 797
signed int tun6_delRoute(struct tun6 *t, struct in6_addr *addr, unsigned int prefix_len, signed int rel_metric);
// tun6_destroy
// file ../libtun6/tun6.h line 76
void tun6_destroy(struct tun6 *t);
// tun6_driver_diagnose
// file ../libtun6/tun6.h line 66
signed int tun6_driver_diagnose(char *errbuf);
// tun6_getId
// file ../libtun6/tun6.h line 78
signed int tun6_getId(const struct tun6 *t);
// tun6_recv
// file tun6.c line 896
signed int tun6_recv(struct tun6 *t, const struct anonymous_41 *readset, void *buffer, unsigned long int maxlen);
// tun6_recv_inner
// file tun6.c line 866
static inline signed int tun6_recv_inner(signed int fd, void *buffer, unsigned long int maxlen);
// tun6_registerReadSet
// file tun6.c line 844
signed int tun6_registerReadSet(const struct tun6 *t, struct anonymous_41 *readset);
// tun6_send
// file ../libtun6/tun6.h line 109
signed int tun6_send(struct tun6 *t, const void *packet, unsigned long int len);
// tun6_setMTU
// file ../libtun6/tun6.h line 96
signed int tun6_setMTU(struct tun6 *t, unsigned int mtu);
// tun6_setState
// file ../libtun6/tun6.h line 80
signed int tun6_setState(struct tun6 *t, _Bool up);
// tun6_wait_recv
// file ../libtun6/tun6.h line 108
signed int tun6_wait_recv(struct tun6 *t, void *buffer, unsigned long int maxlen);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file main.c line 73
static signed int usage(const char *path);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// wait
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 102
extern signed int wait(union anonymous_34);
// wait_reply
// file maintain.c line 163
static signed int wait_reply(struct teredo_maintenance * restrict m, struct timespec * restrict deadline);
// wait_reply_ignore
// file maintain.c line 184
static void wait_reply_ignore(struct teredo_maintenance * restrict m, struct timespec * restrict deadline);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);

struct anonymous_11
{
  // _function
  void (*_function)(union sigval);
  // _attribute
  union pthread_attr_t *_attribute;
};

struct anonymous_41
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_29
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_18
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_19
{
  // __cancel_jmp_buf
  struct anonymous_18 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_40
{
  // __w_stopval
  unsigned int __w_stopval : 8;
  // __w_stopsig
  unsigned int __w_stopsig : 8;
  // _anon0
  unsigned int _anon0 : 16;
};

struct anonymous_39
{
  // __w_termsig
  unsigned int __w_termsig : 7;
  // __w_coredump
  unsigned int __w_coredump : 1;
  // __w_retcode
  unsigned int __w_retcode : 8;
  // _anon0
  unsigned int _anon0 : 16;
};

struct anonymous_16
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_1
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_9
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_32
{
  // lock
  union anonymous_9 lock;
  // count
  signed int count;
  // last
  unsigned long int last;
};

union anonymous_25
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_25 __in6_u;
};

struct anonymous_38
{
  // prefix
  unsigned int prefix;
  // server_ip
  unsigned int server_ip;
  // flags
  unsigned short int flags;
  // client_port
  unsigned short int client_port;
  // client_ip
  unsigned int client_ip;
};

union teredo_addr
{
  // ip6
  struct in6_addr ip6;
  // teredo
  struct anonymous_38 teredo;
  // t6_addr32
  unsigned int t6_addr32[4l];
};

struct teredo_state
{
  // addr
  union teredo_addr addr;
  // ipv4
  unsigned int ipv4;
  // mtu
  unsigned short int mtu;
  // up
  _Bool up;
};

struct anonymous_14
{
  // state
  struct teredo_state state;
  // cb
  void (*cb)(struct teredo_state *, void *);
  // opaque
  void *opaque;
};

struct anonymous
{
  // flags
  unsigned short int flags;
  // proto
  unsigned short int proto;
};

struct anonymous_33
{
  // thread
  unsigned long int thread;
  // running
  _Bool running;
};

union anonymous_23
{
  // __uptr
  union wait *__uptr;
  // __iptr
  signed int *__iptr;
};

union anonymous_34
{
  // __uptr
  union wait *__uptr;
  // __iptr
  signed int *__iptr;
} __attribute__ ((__transparent_union__));

union anonymous_12
{
  // _pad
  signed int _pad[12l];
  // _tid
  signed int _tid;
  // _sigev_thread
  struct anonymous_11 _sigev_thread;
};

union anonymous_42
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_4
{
  // key
  unsigned char key[16l];
  // ipad
  unsigned char ipad[64l];
};

union anonymous_5
{
  // key
  unsigned char key[16l];
  // opad
  unsigned char opad[64l];
};

union anonymous_0
{
  // icmp6_un_data32
  unsigned int icmp6_un_data32[1l];
  // icmp6_un_data16
  unsigned short int icmp6_un_data16[2l];
  // icmp6_un_data8
  unsigned char icmp6_un_data8[4l];
};

union anonymous_20
{
  // align
  unsigned long int align[1l];
  // fill
  unsigned char fill[65507l];
};

union anonymous_13
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_2
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous_17
{
  // __data
  struct anonymous_16 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_31
{
  // __data
  struct anonymous_1 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous_37
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_43
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

union anonymous_21
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_35
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct J_UDY_ERROR_STRUCT
{
  // je_Errno
  enum anonymous_8 je_Errno;
  // je_ErrID
  signed int je_ErrID;
  // je_reserved
  unsigned long int je_reserved[4l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct clock_data_t
{
  // handle
  void *handle;
  // value
  unsigned long int value;
  // active
  _Bool active;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct icmp6_filter
{
  // icmp6_filt
  unsigned int icmp6_filt[8l];
};

struct icmp6_hdr
{
  // icmp6_type
  unsigned char icmp6_type;
  // icmp6_code
  unsigned char icmp6_code;
  // icmp6_cksum
  unsigned short int icmp6_cksum;
  // icmp6_dataun
  union anonymous_0 icmp6_dataun;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_42 ifr_ifrn;
  // ifr_ifru
  union anonymous_43 ifr_ifru;
};

struct in6_ifreq
{
  // ifr6_addr
  struct in6_addr ifr6_addr;
  // ifr6_prefixlen
  unsigned int ifr6_prefixlen;
  // ifr6_ifindex
  signed int ifr6_ifindex;
};

struct in6_rtmsg
{
  // rtmsg_dst
  struct in6_addr rtmsg_dst;
  // rtmsg_src
  struct in6_addr rtmsg_src;
  // rtmsg_gateway
  struct in6_addr rtmsg_gateway;
  // rtmsg_type
  unsigned int rtmsg_type;
  // rtmsg_dst_len
  unsigned short int rtmsg_dst_len;
  // rtmsg_src_len
  unsigned short int rtmsg_src_len;
  // rtmsg_metric
  unsigned int rtmsg_metric;
  // rtmsg_info
  unsigned long int rtmsg_info;
  // rtmsg_flags
  unsigned int rtmsg_flags;
  // rtmsg_ifindex
  signed int rtmsg_ifindex;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct in_pktinfo
{
  // ipi_ifindex
  signed int ipi_ifindex;
  // ipi_spec_dst
  struct in_addr ipi_spec_dst;
  // ipi_addr
  struct in_addr ipi_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip6_hdr
{
  // ip6_ctlun
  union anonymous_37 ip6_ctlun;
  // ip6_src
  struct in6_addr ip6_src;
  // ip6_dst
  struct in6_addr ip6_dst;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

struct md5_state_s
{
  // count
  unsigned int count[2l];
  // abcd
  unsigned int abcd[4l];
  // buf
  unsigned char buf[64l];
};

struct miredo_conf
{
  // head
  struct setting *head;
  // tail
  struct setting *tail;
  // logger
  void (*logger)(void *, _Bool, const char *, void **);
  // logger_data
  void *logger_data;
};

struct miredo_conf_syslog_facility
{
  // str
  const char *str;
  // facility
  signed int facility;
};

struct miredo_tunnel
{
  // tunnel
  struct tun6 *tunnel;
  // priv_fd
  signed int priv_fd;
  // relay
  struct teredo_tunnel *relay;
};

struct miredo_tunnel_settings
{
  // addr
  struct in6_addr addr;
  // mtu
  unsigned short int mtu;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct nd_opt_hdr
{
  // nd_opt_type
  unsigned char nd_opt_type;
  // nd_opt_len
  unsigned char nd_opt_len;
};

struct nd_opt_mtu
{
  // nd_opt_mtu_type
  unsigned char nd_opt_mtu_type;
  // nd_opt_mtu_len
  unsigned char nd_opt_mtu_len;
  // nd_opt_mtu_reserved
  unsigned short int nd_opt_mtu_reserved;
  // nd_opt_mtu_mtu
  unsigned int nd_opt_mtu_mtu;
};

struct nd_opt_prefix_info
{
  // nd_opt_pi_type
  unsigned char nd_opt_pi_type;
  // nd_opt_pi_len
  unsigned char nd_opt_pi_len;
  // nd_opt_pi_prefix_len
  unsigned char nd_opt_pi_prefix_len;
  // nd_opt_pi_flags_reserved
  unsigned char nd_opt_pi_flags_reserved;
  // nd_opt_pi_valid_time
  unsigned int nd_opt_pi_valid_time;
  // nd_opt_pi_preferred_time
  unsigned int nd_opt_pi_preferred_time;
  // nd_opt_pi_reserved2
  unsigned int nd_opt_pi_reserved2;
  // nd_opt_pi_prefix
  struct in6_addr nd_opt_pi_prefix;
};

struct nd_router_advert
{
  // nd_ra_hdr
  struct icmp6_hdr nd_ra_hdr;
  // nd_ra_reachable
  unsigned int nd_ra_reachable;
  // nd_ra_retransmit
  unsigned int nd_ra_retransmit;
};

struct nd_router_solicit
{
  // nd_rs_hdr
  struct icmp6_hdr nd_rs_hdr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct setting
{
  // name
  char *name;
  // value
  char *value;
  // line
  unsigned int line;
  // next
  struct setting *next;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct sigevent
{
  // sigev_value
  union sigval sigev_value;
  // sigev_signo
  signed int sigev_signo;
  // sigev_notify
  signed int sigev_notify;
  // _sigev_un
  union anonymous_12 _sigev_un;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct teredo_peer
{
  // queue
  struct teredo_queue *queue;
  // queue_left
  unsigned long int queue_left;
  // last_rx
  unsigned long int last_rx;
  // last_tx
  unsigned long int last_tx;
  // mapped_addr
  unsigned int mapped_addr;
  // mapped_port
  unsigned short int mapped_port;
  // trusted
  unsigned int trusted : 1;
  // bubbles
  unsigned int bubbles : 3;
  // pings
  unsigned int pings : 3;
  // last_ping
  unsigned int last_ping : 9;
};

struct teredo_listitem
{
  // key
  union teredo_addr key;
  // pprev
  struct teredo_listitem **pprev;
  // next
  struct teredo_listitem *next;
  // peer
  struct teredo_peer peer;
};

struct teredo_maintenance
{
  // thread
  unsigned long int thread;
  // outer
  union anonymous_9 outer;
  // inner
  union anonymous_9 inner;
  // received
  union anonymous_17 received;
  // processed
  union anonymous_17 processed;
  // incoming
  const struct teredo_packet *incoming;
  // fd
  signed int fd;
  // state
  struct anonymous_14 state;
  // server
  char *server;
  // qualification_delay
  unsigned int qualification_delay;
  // qualification_retries
  unsigned int qualification_retries;
  // refresh_delay
  unsigned int refresh_delay;
  // restart_delay
  unsigned int restart_delay;
};

struct teredo_packet
{
  // ip6
  struct ip6_hdr *ip6;
  // ip6_len
  unsigned long int ip6_len;
  // source_ipv4
  unsigned int source_ipv4;
  // source_port
  unsigned short int source_port;
  // orig_port
  unsigned short int orig_port;
  // orig_ipv4
  unsigned int orig_ipv4;
  // dest_ipv4
  unsigned int dest_ipv4;
  // auth_present
  _Bool auth_present;
  // auth_fail
  _Bool auth_fail;
  // auth_nonce
  unsigned char auth_nonce[8l];
  // buf
  union anonymous_20 buf;
};

struct teredo_peerlist
{
  // recent
  struct teredo_listitem *recent;
  // old
  struct teredo_listitem *old;
  // left
  unsigned int left;
  // expiration
  unsigned int expiration;
  // gc
  unsigned long int gc;
  // lock
  union anonymous_9 lock;
  // PJHSArray
  void *PJHSArray;
};

struct teredo_queue
{
  // next
  struct teredo_queue *next;
  // length
  unsigned long int length;
  // ipv4
  unsigned int ipv4;
  // port
  unsigned short int port;
  // incoming
  _Bool incoming;
  // data
  unsigned char data[0l];
};

struct teredo_tunnel
{
  // list
  struct teredo_peerlist *list;
  // opaque
  void *opaque;
  // maintenance
  struct teredo_maintenance *maintenance;
  // up_cb
  void (*up_cb)(void *, struct in6_addr *, unsigned short int);
  // down_cb
  void (*down_cb)(void *);
  // recv_cb
  void (*recv_cb)(void *, const void *, unsigned long int);
  // icmpv6_cb
  void (*icmpv6_cb)(void *, const void *, unsigned long int, struct in6_addr *);
  // state
  struct teredo_state state;
  // state_lock
  union anonymous_31 state_lock;
  // ratelimit
  struct anonymous_32 ratelimit;
  // recv
  struct anonymous_33 recv;
  // fd
  signed int fd;
};

struct tun6
{
  // id
  signed int id;
  // fd
  signed int fd;
  // reqfd
  signed int reqfd;
};

union wait
{
  // w_status
  signed int w_status;
  // __wait_terminated
  struct anonymous_39 __wait_terminated;
  // __wait_stopped
  struct anonymous_40 __wait_stopped;
};


// QualificationDelay
// file maintain.c line 409
static const unsigned int QualificationDelay = (const unsigned int)4;
// QualificationRetries
// file maintain.c line 410
static const unsigned int QualificationRetries = (const unsigned int)3;
// RefreshDelay
// file maintain.c line 412
static const unsigned int RefreshDelay = (const unsigned int)30;
// RestartDelay
// file maintain.c line 413
static const unsigned int RestartDelay = (const unsigned int)100;
// exe
// file binreloc.c line 292
static char *exe = (char *)(void *)0;
// facilities
// file conf.c line 498
static struct miredo_conf_syslog_facility facilities[21l] = { { .str="auth", .facility=4 << 3 }, { .str="authpriv", .facility=10 << 3 }, { .str="cron", .facility=9 << 3 }, { .str="daemon", .facility=3 << 3 }, { .str="ftp", .facility=11 << 3 }, { .str="kern", .facility=0 << 3 }, { .str="local0", .facility=16 << 3 }, { .str="local1", .facility=17 << 3 }, { .str="local2", .facility=18 << 3 }, { .str="local3", .facility=19 << 3 }, { .str="local4", .facility=20 << 3 }, { .str="local5", .facility=21 << 3 }, { .str="local6", .facility=22 << 3 }, { .str="local7", .facility=23 << 3 }, { .str="lpr", .facility=6 << 3 }, { .str="mail", .facility=2 << 3 }, { .str="news", .facility=7 << 3 }, { .str="syslog", .facility=5 << 3 }, { .str="user", .facility=1 << 3 }, { .str="uucp", .facility=8 << 3 }, { .str=(const char *)(void *)0, .facility=0 } };
// hmac_pid
// file security.c line 70
static unsigned short int hmac_pid = (unsigned short int)0;
// icmp6_fd
// file relayd.c line 93
static signed int icmp6_fd = -1;
// in6addr_allrouters
// file packets.c line 115
static struct in6_addr in6addr_allrouters = { .__in6_u={ .__u6_addr8={ (unsigned char)0xff, (unsigned char)0x02, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0x2 } } };
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// inner_key
// file security.c line 61
static union anonymous_4 inner_key;
// miredo_capc
// file miredo.c line 243
signed int miredo_capc;
// miredo_capv
// file miredo.c line 242
const signed int *miredo_capv;
// miredo_chrootdir
// file miredo.c line 57
const char *miredo_chrootdir = (const char *)(void *)0;
// miredo_diagnose
// file miredo.c line 236
signed int (*miredo_diagnose)(void);
// miredo_name
// file miredo.c line 239
const char *miredo_name;
// miredo_run
// file miredo.c line 237
signed int (*miredo_run)(struct miredo_conf *, const char *);
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// os_driver
// file tun6.c line 53
const char os_driver[6l] = { 'L', 'i', 'n', 'u', 'x', 0 };
// outer_key
// file security.c line 67
static union anonymous_5 outer_key;
// randfile
// file security.c line 46
static const char randfile[12l] = { '/', 'd', 'e', 'v', '/', 'r', 'a', 'n', 'd', 'o', 'm', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// teredo_MaxQueueBytes
// file peerlist.c line 67
static const unsigned int teredo_MaxQueueBytes = (const unsigned int)1280;
// teredo_cone
// file teredo.c line 63
struct in6_addr teredo_cone = { .__in6_u={ .__u6_addr8={ (unsigned char)0xfe, (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0x80, (unsigned char)0, (unsigned char)84, (unsigned char)69, (unsigned char)82, (unsigned char)69, (unsigned char)68, (unsigned char)79 } } };
// teredo_restrict
// file teredo.c line 54
struct in6_addr teredo_restrict = { .__in6_u={ .__u6_addr8={ (unsigned char)0xfe, (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff } } };
// unpriv_uid
// file miredo.c line 56
unsigned int unpriv_uid = (unsigned int)0;

// BuildICMPv6Error
// file packets.h line 145
signed int BuildICMPv6Error(struct icmp6_hdr * restrict out, unsigned char type, unsigned char code, struct ip6_hdr * restrict in, unsigned long int inlen)
{
  struct in6_addr *p;
  _Bool tmp_if_expr_5;
  _Bool tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(inlen >= sizeof(struct ip6_hdr) /*40ul*/ ))
    return 0;

  else
    if((signed int)in->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
    {
      if(!((0x80 & (signed int)((struct icmp6_hdr *)(in + 1l))->icmp6_type) == 0))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if((signed int)*((const unsigned char *)&in->ip6_dst) == 0xff)
        return 0;

      else
      {
        p = &in->ip6_src;
        if((signed int)*((const unsigned char *)p) == 0xff)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          struct in6_addr *__a = (struct in6_addr *)p;
          if(__a->__in6_u.__u6_addr32[0l] == 0u)
            tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
            tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          tmp_statement_expression_1 = tmp_if_expr_4;
          tmp_if_expr_5 = tmp_statement_expression_1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          return 0;

        else
        {
          out->icmp6_type = type;
          out->icmp6_code = code;
          out->icmp6_cksum = (unsigned short int)0;
          out->icmp6_dataun.icmp6_un_data32[(signed long int)0] = (unsigned int)0;
          if(inlen >= 1233ul)
            inlen = (unsigned long int)1280 - (sizeof(struct ip6_hdr) /*40ul*/  + sizeof(struct icmp6_hdr) /*8ul*/ );

          memcpy((void *)(out + (signed long int)1), (const void *)in, inlen);
          return (signed int)(sizeof(struct icmp6_hdr) /*8ul*/  + inlen);
        }
      }
    }
}

// CheckBubble
// file packets.h line 41
signed int CheckBubble(const struct teredo_packet *packet)
{
  struct ip6_hdr *ip6 = packet->ip6;
  struct in6_addr *me = &ip6->ip6_dst;
  struct in6_addr *it = &ip6->ip6_src;
  unsigned char hash[8l];
  teredo_get_nonce((unsigned int)0, (&((union teredo_addr *)it)->teredo)->client_ip ^ 0xffffffff, (unsigned short int)((signed int)(&((union teredo_addr *)it)->teredo)->client_port ^ 0xffff), hash);
  hash[(signed long int)0] = hash[(signed long int)0] & (unsigned char)0xfc;
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)hash, (const void *)(me->__in6_u.__u6_addr8 + (signed long int)8), (unsigned long int)8);
  return return_value_memcmp_1 != 0 ? -1 : 0;
}

// CheckPing
// file packets.h line 40
signed int CheckPing(const struct teredo_packet *packet)
{
  struct ip6_hdr *ip6 = packet->ip6;
  unsigned long int length;
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
  length = (unsigned long int)return_value_ntohs_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_statement_expression_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_statement_expression_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  if(!((signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) || !(length >= sizeof(struct icmp6_hdr) * 3 + 2 /*26ul*/ ))
    return -1;

  else
  {
    struct icmp6_hdr *icmp6 = (struct icmp6_hdr *)(ip6 + (signed long int)1);
    struct in6_addr *me = &ip6->ip6_dst;
    struct in6_addr *it = &ip6->ip6_src;
    if((signed int)icmp6->icmp6_type == 1)
    {
      length = length - sizeof(struct icmp6_hdr) /*8ul*/ ;
      ip6 = (struct ip6_hdr *)(icmp6 + (signed long int)1);
      if(!(length >= 66ul))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return -1;

      unsigned short int return_value_ntohs_3;
      return_value_ntohs_3=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
      length = (unsigned long int)return_value_ntohs_3;
      if(!(length == sizeof(struct icmp6_hdr) * 3 + 2 /*26ul*/ ))
        return -1;

      icmp6 = (struct icmp6_hdr *)(ip6 + (signed long int)1);
      struct in6_addr *__a = (struct in6_addr *)&ip6->ip6_src;
      struct in6_addr *__b = (struct in6_addr *)me;
      if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
        tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      tmp_statement_expression_4 = tmp_if_expr_7;
      if(!tmp_statement_expression_4)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = (signed int)icmp6->icmp6_type != 128 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        return -1;

      struct in6_addr *CheckPing__1__1__2____a = (struct in6_addr *)&ip6->ip6_dst;
      struct in6_addr *CheckPing__1__1__2____b = (struct in6_addr *)it;
      if(CheckPing__1__1__2____a->__in6_u.__u6_addr32[0l] == CheckPing__1__1__2____b->__in6_u.__u6_addr32[0l])
        tmp_if_expr_10 = CheckPing__1__1__2____a->__in6_u.__u6_addr32[(signed long int)1] == CheckPing__1__1__2____b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
        tmp_if_expr_11 = CheckPing__1__1__2____a->__in6_u.__u6_addr32[(signed long int)2] == CheckPing__1__1__2____b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
        tmp_if_expr_12 = CheckPing__1__1__2____a->__in6_u.__u6_addr32[(signed long int)3] == CheckPing__1__1__2____b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_12 = (_Bool)0;
      tmp_statement_expression_9 = tmp_if_expr_12;
      if(!tmp_statement_expression_9)
        return -1;

      me = &ip6->ip6_src;
      it = &ip6->ip6_dst;
    }

    else
      if(!((signed int)icmp6->icmp6_type == 129))
        return -1;

    if(!((signed int)icmp6->icmp6_code == 0))
      return -1;

    else
    {
      signed long int return_value_time_13;
      return_value_time_13=time((signed long int *)(void *)0);
      signed int return_value_teredo_verify_pinghash_14;
      return_value_teredo_verify_pinghash_14=teredo_verify_pinghash((unsigned int)return_value_time_13, me, it, (const unsigned char *)&icmp6->icmp6_dataun.icmp6_un_data16[(signed long int)0]);
      return return_value_teredo_verify_pinghash_14;
    }
  }
}

// CountBubble
// file relay.c line 257
static signed int CountBubble(struct teredo_peer *peer, unsigned long int now)
{
  signed int res;
  if((signed int)peer->bubbles >= 1)
  {
    if((signed int)peer->bubbles >= 4)
    {
      if(!(now + -peer->last_tx >= 301ul))
        res = -1;

      else
      {
        peer->bubbles = (unsigned int)0;
        res = 0;
      }
    }

    else
      if(!(now + -peer->last_tx >= 3ul))
        res = 1;

      else
        res = 0;
  }

  else
    res = 0;
  if(res == 0)
  {
    peer->last_tx = now;
    peer->bubbles = (unsigned int)peer->bubbles + 1u;
  }

  return res;
}

// CountPing
// file relay.c line 220
static signed int CountPing(struct teredo_peer *peer, unsigned long int now)
{
  signed int res;
  if((signed int)peer->pings == 0)
    res = 0;

  else
    if((signed int)peer->pings >= 4)
      res = -1;

    else
      if(!((now + -((unsigned long int)peer->last_ping) & 511ul) >= 3ul))
        res = 1;

      else
        res = 0;
  if(res == 0)
  {
    peer->last_ping = (unsigned int)now;
    peer->pings = (unsigned int)peer->pings + 1u;
  }

  return res;
}

// GetIPv4ByName
// file conf.c line 393
signed int GetIPv4ByName(const char *hostname, unsigned int *ipv4)
{
  struct addrinfo help = { .ai_flags=0, .ai_family=2, .ai_socktype=2, .ai_protocol=17,
    .ai_addrlen=0u, .ai_addr=((struct sockaddr *)NULL), .ai_canonname=((char *)NULL),
    .ai_next=((struct addrinfo *)NULL) };
  struct addrinfo *res;
  signed int check;
  check=getaddrinfo(hostname, (const char *)(void *)0, &help, &res);
  if(!(check == 0))
    return check;

  else
  {
    *ipv4 = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;
    freeaddrinfo(res);
    return 0;
  }
}

// IsBubble
// file packets.h line 48
static inline _Bool IsBubble(struct ip6_hdr *hdr)
{
  _Bool tmp_if_expr_1;
  if((signed int)hdr->ip6_ctlun.ip6_un1.ip6_un1_plen == 0)
    tmp_if_expr_1 = (signed int)hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return tmp_if_expr_1;
}

// IsClient
// file relay.c line 246
static inline _Bool IsClient(const struct teredo_tunnel *tunnel)
{
  return tunnel->maintenance != (struct teredo_maintenance *)(void *)0;
}

// IsValid
// file peerlist.h line 83
static inline _Bool IsValid(const struct teredo_peer *peer, unsigned long int now)
{
  return now - peer->last_rx <= (unsigned long int)30;
}

// LogError
// file conf.c line 91
static void LogError(struct miredo_conf *conf, const char *fmt, ...)
{
  if(!(conf->logger == ((void (*)(void *, _Bool, const char *, void **))NULL)))
  {
    void **ap = (void **)&fmt;
    conf->logger(conf->logger_data, (_Bool)1, fmt, ap);
    ap = ((void **)NULL);
  }

}

// LogWarning
// file conf.c line 111
static void LogWarning(struct miredo_conf *conf, const char *fmt, ...)
{
  if(!(conf->logger == ((void (*)(void *, _Bool, const char *, void **))NULL)))
  {
    void **ap = (void **)&fmt;
    conf->logger(conf->logger_data, (_Bool)0, fmt, ap);
    ap = ((void **)NULL);
  }

}

// ParseRelayType
// file relayd.c line 168
static _Bool ParseRelayType(struct miredo_conf *conf, const char *name, signed int *type)
{
  unsigned int line;
  char *val;
  val=miredo_conf_get(conf, name, &line);
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  signed int return_value_strcasecmp_6;
  signed int return_value_strcasecmp_3;
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmp_4;
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    signed int return_value_strcasecmp_7;
    return_value_strcasecmp_7=strcasecmp(val, "client");
    if(return_value_strcasecmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcasecmp_8=strcasecmp(val, "autoclient");
      tmp_if_expr_9 = return_value_strcasecmp_8 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      *type = 2;

    else
    {
      return_value_strcasecmp_6=strcasecmp(val, "restricted");
      if(return_value_strcasecmp_6 == 0)
      {
        char *return_value_dgettext_1;
        return_value_dgettext_1=dgettext("miredo", "Using deprecated \"restricted\" relay type which is STRONGLY DISCOURAGED (at line %u).");
        syslog(4, return_value_dgettext_1, line);
        *type = 1;
      }

      else
      {
        return_value_strcasecmp_3=strcasecmp(val, "relay");
        if(return_value_strcasecmp_3 == 0)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_strcasecmp_4=strcasecmp(val, "cone");
          tmp_if_expr_5 = return_value_strcasecmp_4 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          *type = 0;

        else
        {
          char *return_value_dgettext_2;
          return_value_dgettext_2=dgettext("miredo", "Invalid relay type \"%s\" at line %u");
          syslog(3, return_value_dgettext_2, val, line);
          free((void *)val);
          return (_Bool)0;
        }
      }
    }
    free((void *)val);
    return (_Bool)1;
  }
}

// Pryt4897810065911_br_build_path
// file binreloc.c line 690
char * Pryt4897810065911_br_build_path(const char *dir, const char *file)
{
  char *dir2;
  char *result;
  unsigned long int len;
  signed int must_free = 0;
  len=strlen(dir);
  _Bool tmp_if_expr_1;
  if(len >= 1ul)
    tmp_if_expr_1 = (signed int)dir[(signed long int)(len - (unsigned long int)1)] != 47 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    dir2=Pryt4897810065911_br_strcat(dir, "/");
    must_free = 1;
  }

  else
    dir2 = (char *)dir;
  result=Pryt4897810065911_br_strcat(dir2, file);
  if(!(must_free == 0))
    free((void *)dir2);

  return result;
}

// Pryt4897810065911_br_dirname
// file binreloc.c line 746
char * Pryt4897810065911_br_dirname(const char *path)
{
  char *end;
  char *result;
  char *return_value_strdup_1;
  if(path == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    end=strrchr(path, 47);
    if(end == ((const char *)NULL))
    {
      return_value_strdup_1=strdup(".");
      return return_value_strdup_1;
    }

    else
    {
      for( ; !(path >= end); end = end - 1l)
        if(!((signed int)*end == 47))
          break;

      result=br_strndup(path, (unsigned long int)((end - path) + (signed long int)1));
      if((signed int)*result == 0)
      {
        free((void *)result);
        char *return_value_strdup_2;
        return_value_strdup_2=strdup("/");
        return return_value_strdup_2;
      }

      else
        return result;
    }
  }
}

// Pryt4897810065911_br_find_bin_dir
// file binreloc.c line 438
char * Pryt4897810065911_br_find_bin_dir(const char *default_bin_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_bin_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_bin_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "bin");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_data_dir
// file binreloc.c line 505
char * Pryt4897810065911_br_find_data_dir(const char *default_data_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_data_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_data_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "share");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_etc_dir
// file binreloc.h line 68
char * Pryt4897810065911_br_find_etc_dir(const char *default_etc_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_etc_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_etc_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "etc");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_exe
// file binreloc.c line 349
char * Pryt4897810065911_br_find_exe(const char *default_exe)
{
  char *return_value_strdup_1;
  if(exe == ((char *)NULL))
  {
    if(!(default_exe == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_exe);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  char *return_value_strdup_2;
  return_value_strdup_2=strdup(exe);
  return return_value_strdup_2;
}

// Pryt4897810065911_br_find_exe_dir
// file binreloc.c line 377
char * Pryt4897810065911_br_find_exe_dir(const char *default_dir)
{
  char *return_value_strdup_1;
  if(exe == ((char *)NULL))
  {
    if(!(default_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  char *return_value_Pryt4897810065911_br_dirname_2;
  return_value_Pryt4897810065911_br_dirname_2=Pryt4897810065911_br_dirname(exe);
  return return_value_Pryt4897810065911_br_dirname_2;
}

// Pryt4897810065911_br_find_lib_dir
// file binreloc.c line 571
char * Pryt4897810065911_br_find_lib_dir(const char *default_lib_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_lib_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_lib_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "lib");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_libexec_dir
// file binreloc.c line 604
char * Pryt4897810065911_br_find_libexec_dir(const char *default_libexec_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_libexec_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_libexec_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "libexec");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_locale_dir
// file binreloc.h line 65
char * Pryt4897810065911_br_find_locale_dir(const char *default_locale_dir)
{
  char *data_dir;
  char *dir;
  data_dir=Pryt4897810065911_br_find_data_dir((const char *)(void *)0);
  char *return_value_strdup_1;
  if(data_dir == ((char *)NULL))
  {
    if(!(default_locale_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_locale_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(data_dir, "locale");
  free((void *)data_dir);
  return dir;
}

// Pryt4897810065911_br_find_prefix
// file binreloc.c line 405
char * Pryt4897810065911_br_find_prefix(const char *default_prefix)
{
  char *dir1;
  char *dir2;
  char *return_value_strdup_1;
  if(exe == ((char *)NULL))
  {
    if(!(default_prefix == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_prefix);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir1=Pryt4897810065911_br_dirname(exe);
  dir2=Pryt4897810065911_br_dirname(dir1);
  free((void *)dir1);
  return dir2;
}

// Pryt4897810065911_br_find_sbin_dir
// file binreloc.c line 471
char * Pryt4897810065911_br_find_sbin_dir(const char *default_sbin_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_sbin_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_sbin_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "sbin");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_init
// file binreloc.h line 56
signed int Pryt4897810065911_br_init(enum anonymous_26 *error)
{
  exe=_br_find_exe(error);
  return (signed int)(exe != (char *)(void *)0);
}

// Pryt4897810065911_br_init_lib
// file binreloc.c line 332
signed int Pryt4897810065911_br_init_lib(enum anonymous_26 *error)
{
  exe=_br_find_exe_for_symbol((const void *)"", error);
  return (signed int)(exe != (char *)(void *)0);
}

// Pryt4897810065911_br_strcat
// file binreloc.c line 667
char * Pryt4897810065911_br_strcat(const char *str1, const char *str2)
{
  char *result;
  unsigned long int len1;
  unsigned long int len2;
  if(str1 == ((const char *)NULL))
    str1 = "";

  if(str2 == ((const char *)NULL))
    str2 = "";

  len1=strlen(str1);
  len2=strlen(str2);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(len1 + len2 + (unsigned long int)1);
  result = (char *)return_value_malloc_1;
  memcpy((void *)result, (const void *)str1, len1);
  memcpy((void *)(result + (signed long int)len1), (const void *)str2, len2);
  result[(signed long int)(len1 + len2)] = (char)0;
  return result;
}

// SendBubbleFromDst
// file packets.h line 63
signed int SendBubbleFromDst(signed int fd, struct in6_addr *dst, _Bool indirect)
{
  unsigned int ip = (&((union teredo_addr *)dst)->teredo)->client_ip ^ 0xffffffff;
  unsigned short int port = (unsigned short int)((signed int)(&((union teredo_addr *)dst)->teredo)->client_port ^ 0xffff);
  struct in6_addr src;
  memcpy((void *)src.__in6_u.__u6_addr8, (const void *)"\0\0\0\0\0\0", (unsigned long int)8);
  teredo_get_nonce((unsigned int)0, ip, port, src.__in6_u.__u6_addr8 + (signed long int)8);
  src.__in6_u.__u6_addr8[(signed long int)8] = src.__in6_u.__u6_addr8[(signed long int)8] & (unsigned char)0xfc;
  if(!(indirect == (_Bool)0))
  {
    ip = (&((union teredo_addr *)dst)->teredo)->server_ip;
    port=htons((unsigned short int)3544);
  }

  signed int return_value_teredo_send_bubble_1;
  return_value_teredo_send_bubble_1=teredo_send_bubble(fd, ip, port, &src, dst);
  return return_value_teredo_send_bubble_1;
}

// SendPing
// file packets.h line 127
signed int SendPing(signed int fd, union teredo_addr *src, struct in6_addr *dst)
{
  /* tag-#anon#lST[lSYM#tag-ip6_hdr#'ip6'||lSYM#tag-icmp6_hdr#'icmp6'||lARR18{U8}_U8_'payload'||U16'_pad0'|] */
struct anonymous_6
{
  // ip6
  struct ip6_hdr ip6;
  // icmp6
  struct icmp6_hdr icmp6;
  // payload
  unsigned char payload[18l];
};

/* */
  ;
  struct anonymous_6 ping;
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow=htonl((unsigned int)0x60000000);
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(sizeof(struct icmp6_hdr) /*8ul*/  + (unsigned long int)(22 - 4)));
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)128;
  ping.ip6.ip6_src = src->ip6;
  ping.ip6.ip6_dst = *dst;
  ping.icmp6.icmp6_type = (unsigned char)128;
  ping.icmp6.icmp6_code = (unsigned char)0;
  ping.icmp6.icmp6_cksum = (unsigned short int)0;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  teredo_get_pinghash((unsigned int)return_value_time_1, &ping.ip6.ip6_src, &ping.ip6.ip6_dst, (unsigned char *)&ping.icmp6.icmp6_dataun.icmp6_un_data16[(signed long int)0]);
  ping.icmp6.icmp6_cksum=icmp6_checksum(&ping.ip6, &ping.icmp6);
  unsigned short int return_value_htons_2;
  return_value_htons_2=htons((unsigned short int)3544);
  signed int return_value_teredo_send_3;
  return_value_teredo_send_3=teredo_send(fd, (const void *)&ping, sizeof(struct ip6_hdr) /*40ul*/  + sizeof(struct icmp6_hdr) /*8ul*/  + (unsigned long int)(22 - 4), (&((union teredo_addr *)src)->teredo)->server_ip, return_value_htons_2);
  return return_value_teredo_send_3 > 0 ? 0 : -1;
}

// SetMapping
// file peerlist.h line 65
static inline void SetMapping(struct teredo_peer *peer, unsigned int ip, unsigned short int port)
{
  peer->mapped_addr = ip;
  peer->mapped_port = port;
}

// SetMappingFromPacket
// file relay.c line 296
static inline void SetMappingFromPacket(struct teredo_peer *peer, struct teredo_packet *p)
{
  SetMapping(peer, p->source_ipv4, p->source_port);
}

// TouchReceive
// file peerlist.h line 71
static inline void TouchReceive(struct teredo_peer *peer, unsigned long int now)
{
  peer->last_rx = now;
}

// TouchTransmit
// file peerlist.h line 76
static inline void TouchTransmit(struct teredo_peer *peer, unsigned long int now)
{
  peer->last_tx = now;
}

// _br_find_exe
// file binreloc.c line 43
static char * _br_find_exe(enum anonymous_26 *error)
{
  if(!(error == ((enum anonymous_26 *)NULL)))
    *error = (enum anonymous_26)BR_INIT_ERROR_DISABLED;

  return (char *)(void *)0;
}

// _br_find_exe_for_symbol
// file binreloc.c line 182
static char * _br_find_exe_for_symbol(const void *symbol, enum anonymous_26 *error)
{
  (void)symbol;
  if(!(error == ((enum anonymous_26 *)NULL)))
    *error = (enum anonymous_26)BR_INIT_ERROR_DISABLED;

  return (char *)(void *)0;
}

// _iface_addr
// file tun6.c line 507
static signed int _iface_addr(signed int reqfd, signed int id, _Bool add, struct in6_addr *addr, unsigned int prefix_len)
{
  void *req = (void *)0;
  signed long int cmd = (signed long int)0;
  if(addr == ((struct in6_addr *)NULL) || prefix_len >= 129u)
    return -1;

  else
  {
    /* tag-#anon#lUN[lSYM#tag-in6_ifreq#'req6'||lSYM#tag-ifreq#'req'|] */
union anonymous_44
{
  // req6
  struct in6_ifreq req6;
  // req
  struct ifreq req;
};

/* */
    ;
    union anonymous_44 r;
    memset((void *)&r, 0, sizeof(union anonymous_44) /*40ul*/ );
    r.req6.ifr6_ifindex = id;
    memcpy((void *)&r.req6.ifr6_addr, (const void *)addr, sizeof(struct in6_addr) /*16ul*/ );
    r.req6.ifr6_prefixlen = prefix_len;
    cmd = (signed long int)(add != (_Bool)0 ? 0x8916 : 0x8936);
    req = (void *)&r;
    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(reqfd, (unsigned long int)cmd, req);
    return return_value_ioctl_1 >= 0 ? 0 : -1;
  }
}

// _iface_route
// file tun6.c line 586
static signed int _iface_route(signed int reqfd, signed int id, _Bool add, struct in6_addr *addr, unsigned int prefix_len, signed int rel_metric)
{
  if(addr == ((struct in6_addr *)NULL) || prefix_len >= 129u)
    return -1;

  else
  {
    signed int retval = -1;
    struct in6_rtmsg req6 = { .rtmsg_dst={ .__in6_u={ .__u6_addr8={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } }, .rtmsg_src={ .__in6_u={ .__u6_addr8={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } },
    .rtmsg_gateway={ .__in6_u={ .__u6_addr8={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } },
    .rtmsg_type=0u,
    .rtmsg_dst_len=(unsigned short int)prefix_len, .rtmsg_src_len=0,
    .rtmsg_metric=(unsigned int)(1024 + rel_metric), .rtmsg_info=0ul,
    .rtmsg_flags=(unsigned int)0x0001, .rtmsg_ifindex=id };
    memcpy((void *)&req6.rtmsg_dst, (const void *)addr, sizeof(struct in6_addr) /*16ul*/ );
    if(prefix_len == 128u)
      req6.rtmsg_flags = req6.rtmsg_flags | (unsigned int)0x0004;

    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(reqfd, (unsigned long int)(add != (_Bool)0 ? 0x890B : 0x890C), &req6);
    if(return_value_ioctl_1 == 0)
      retval = 0;

    return retval;
  }
}

// br_strndup
// file binreloc.c line 712
static char * br_strndup(const char *str, unsigned long int size)
{
  char *result = (char *)(void *)0;
  unsigned long int len;
  char *return_value_strdup_1;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    len=strlen(str);
    if(len == 0ul)
    {
      return_value_strdup_1=strdup("");
      return return_value_strdup_1;
    }

    else
    {
      if(!(len >= size))
        size = len;

      void *return_value_malloc_2;
      return_value_malloc_2=malloc(len + (unsigned long int)1);
      result = (char *)return_value_malloc_2;
      memcpy((void *)result, (const void *)str, size);
      result[(signed long int)size] = (char)0;
      return result;
    }
  }
}

// checkTimeDrift
// file maintain.c line 200
static _Bool checkTimeDrift(struct timespec *ts)
{
  struct timespec now;
  gettime(&now);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(!(ts->tv_sec >= now.tv_sec))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(now.tv_sec == ts->tv_sec)
      tmp_if_expr_2 = now.tv_nsec > ts->tv_nsec ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    char *return_value_dgettext_1;
    return_value_dgettext_1=dgettext("miredo", "Too much time drift. Resynchronizing.");
    syslog(4, return_value_dgettext_1);
    *ts = now;
    return (_Bool)0;
  }

  return (_Bool)1;
}

// cleanup_unlock
// file maintain.c line 218
static void cleanup_unlock(void *o)
{
  pthread_mutex_unlock((union anonymous_9 *)o);
}

// clock_tick
// file clock.c line 49
static void clock_tick(union sigval val)
{
  struct clock_data_t *context = (struct clock_data_t *)val.sival_ptr;
  signed int orun;
  orun=timer_getoverrun(context->handle);
  context->value = context->value + (unsigned long int)(1 + orun);
  if(orun == 2147483647)
    context->active = (_Bool)0;

  if(context->active == (_Bool)0)
  {
    struct itimerspec it = { .it_interval={ .tv_sec=0l, .tv_nsec=0l }, .it_value={ .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 } };
    timer_settime(context->handle, 0, &it, (struct itimerspec *)(void *)0);
  }

  context->active = (_Bool)0;
}

// closefrom
// file closefrom.c line 39
signed int closefrom(signed int fd)
{
  struct rlimit lim;
  unsigned int found = (unsigned int)0;
  signed int saved_errno;
  signed int return_value_getrlimit_1;
  return_value_getrlimit_1=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
  signed int tmp_post_3;
  signed int return_value_close_4;
  if(!(return_value_getrlimit_1 == 0))
    return -1;

  else
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    saved_errno = *return_value___errno_location_2;
    if(lim.rlim_max >= 1025ul)
    {
      if(lim.rlim_cur >= 1025ul)
        lim.rlim_cur = (unsigned long int)1024;

      lim.rlim_max = (unsigned long int)1024;
      setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
    }

    while(!((unsigned long int)(unsigned int)fd >= lim.rlim_max))
    {
      tmp_post_3 = fd;
      fd = fd + 1;
      return_value_close_4=close(tmp_post_3);
      if(return_value_close_4 == 0)
        found = found + 1u;

    }
    if(found == 0u)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 9;
      return -1;
    }

    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6 = saved_errno;
    return 0;
  }
}

// configure_tunnel
// file relayd.c line 245
static signed int configure_tunnel(signed int fd, struct in6_addr *addr, unsigned int mtu)
{
  struct miredo_tunnel_settings s;
  signed int res;
  if(mtu >= 65536u)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  memset((void *)&s, 0, sizeof(struct miredo_tunnel_settings) /*20ul*/ );
  memcpy((void *)&s.addr, (const void *)addr, sizeof(struct in6_addr) /*16ul*/ );
  s.mtu = (unsigned short int)mtu;
  signed long int return_value_send_2;
  return_value_send_2=send(fd, (const void *)&s, sizeof(struct miredo_tunnel_settings) /*20ul*/ , 16384);
  _Bool tmp_if_expr_4;
  signed long int return_value_recv_3;
  if(!((unsigned long int)return_value_send_2 == sizeof(struct miredo_tunnel_settings) /*20ul*/ ))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_recv_3=recv(fd, (void *)&res, sizeof(signed int) /*4ul*/ , 256);
    tmp_if_expr_4 = (unsigned long int)return_value_recv_3 != sizeof(signed int) /*4ul*/  ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
    return -1;

  else
    return res;
}

// create_dynamic_tunnel
// file relayd.c line 204
static struct tun6 * create_dynamic_tunnel(const char *ifname, signed int *pfd)
{
  struct tun6 *tunnel;
  tunnel=tun6_create(ifname);
  char ifindex[9l];
  signed int return_value_tun6_getId_2;
  signed int return_value_fork_3;
  signed int return_value_dup2_4;
  if(tunnel == ((struct tun6 *)NULL))
    return (struct tun6 *)(void *)0;

  else
  {
    signed int fd[2l];
    signed int return_value_socketpair_1;
    return_value_socketpair_1=socketpair(1, 1, 0, fd);
    if(return_value_socketpair_1 == 0)
    {
      miredo_setup_fd(fd[(signed long int)0]);
      miredo_setup_fd(fd[(signed long int)1]);
      return_value_tun6_getId_2=tun6_getId(tunnel);
      snprintf(ifindex, sizeof(char [9l]) /*9ul*/ , "%X", return_value_tun6_getId_2);
      return_value_fork_3=fork();
      if(!(return_value_fork_3 == -1))
      {
        if(return_value_fork_3 == 0)
          goto __CPROVER_DUMP_L3;

      }

      else
      {
        close(fd[(signed long int)0]);
        close(fd[(signed long int)1]);
        goto error;

      __CPROVER_DUMP_L3:
        ;
        signed int return_value_dup2_5;
        return_value_dup2_5=dup2(fd[(signed long int)0], 0);
        static const char path[49l] = { '/', 'u', 's', 'r', '/', 'l', 'i', 'b', '/', 'x', '8', '6', '_', '6', '4', '-', 'l', 'i', 'n', 'u', 'x', '-', 'g', 'n', 'u', '/', 'm', 'i', 'r', 'e', 'd', 'o', '/', 'm', 'i', 'r', 'e', 'd', 'o', '-', 'p', 'r', 'i', 'v', 'p', 'r', 'o', 'c', 0 };
        if(return_value_dup2_5 == 0)
        {
          return_value_dup2_4=dup2(fd[(signed long int)0], 1);
          if(return_value_dup2_4 == 1)
            execl(path, path, (const void *)ifindex, (char *)(void *)0);

        }

        char *return_value_dgettext_6;
        return_value_dgettext_6=dgettext("miredo", "Could not execute %s: %m");
        syslog(3, return_value_dgettext_6, (const void *)path);
        exit(1);
      }
      close(fd[(signed long int)0]);
      *pfd = fd[(signed long int)1];
      return tunnel;
    }

    else
    {

    error:
      ;
      tun6_destroy(tunnel);
      return (struct tun6 *)(void *)0;
    }
  }
}

// create_pidfile
// file main.c line 156
static signed int create_pidfile(const char *path)
{
  signed int fd;
  fd=open(path, 01 | 0100 | 0400000, 0644);
  signed int return_value_lockf_9;
  signed int return_value_ftruncate_8;
  unsigned long int return_value_strlen_5;
  signed long int return_value_write_6;
  unsigned long int return_value_strlen_7;
  signed int return_value_fdatasync_4;
  signed int *return_value___errno_location_11;
  if(!(fd == -1))
  {
    char buf[20l];
    struct stat s;
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    snprintf(buf, sizeof(char [20l]) /*20ul*/ , "%d", (signed int)return_value_getpid_1);
    buf[(signed long int)(sizeof(char [20l]) /*20ul*/  - (unsigned long int)1)] = (char)0;
    signed int return_value_fcntl_2;
    return_value_fcntl_2=fcntl(fd, 1);
    fcntl(fd, 2, return_value_fcntl_2 | 1);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 0;
    signed int return_value_fstat_10;
    return_value_fstat_10=fstat(fd, &s);
    if(return_value_fstat_10 == 0)
    {
      if((61440u & s.st_mode) == 32768u)
      {
        return_value_lockf_9=lockf(fd, 2, (signed long int)0);
        if(return_value_lockf_9 == 0)
        {
          return_value_ftruncate_8=ftruncate(fd, (signed long int)0);
          if(return_value_ftruncate_8 == 0)
          {
            return_value_strlen_5=strlen(buf);
            return_value_write_6=write(fd, (const void *)buf, return_value_strlen_5);
            return_value_strlen_7=strlen(buf);
            if(return_value_write_6 == (signed long int)return_value_strlen_7)
            {
              return_value_fdatasync_4=fdatasync(fd);
              if(return_value_fdatasync_4 == 0)
                return fd;

            }

          }

        }

      }

    }

    signed int *return_value___errno_location_12;
    return_value___errno_location_12=__errno_location();
    if(*return_value___errno_location_12 == 0)
    {
      return_value___errno_location_11=__errno_location();
      *return_value___errno_location_11 = 13;
    }

    close(fd);
  }

  return -1;
}

// create_static_tunnel
// file relayd.c line 327
static struct tun6 * create_static_tunnel(const char * restrict ifname, struct in6_addr * restrict prefix, unsigned short int mtu)
{
  struct tun6 *tunnel;
  tunnel=tun6_create(ifname);
  signed int *return_value___errno_location_1;
  if(tunnel == ((struct tun6 *)NULL) && !(ifname == ((const char *)NULL)))
  {
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 38)
      tunnel=tun6_create((const char *)(void *)0);

  }

  _Bool tmp_if_expr_4;
  signed int return_value_tun6_bringUp_3;
  _Bool tmp_if_expr_6;
  signed int return_value_tun6_addAddress_5;
  _Bool tmp_if_expr_8;
  signed int return_value_tun6_addRoute_7;
  if(tunnel == ((struct tun6 *)NULL))
    return (struct tun6 *)(void *)0;

  else
  {
    signed int return_value_tun6_setMTU_2;
    return_value_tun6_setMTU_2=tun6_setMTU(tunnel, (unsigned int)mtu);
    if(!(return_value_tun6_setMTU_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_tun6_bringUp_3=tun6_bringUp(tunnel);
      tmp_if_expr_4 = return_value_tun6_bringUp_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_tun6_addAddress_5=tun6_addAddress(tunnel, &teredo_restrict, (unsigned int)64);
      tmp_if_expr_6 = return_value_tun6_addAddress_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_tun6_addRoute_7=tun6_addRoute(tunnel, prefix, (unsigned int)32, 0);
      tmp_if_expr_8 = return_value_tun6_addRoute_7 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      tun6_destroy(tunnel);
      return (struct tun6 *)(void *)0;
    }

    else
      return tunnel;
  }
}

// destroy_dynamic_tunnel
// file relayd.c line 269
static void destroy_dynamic_tunnel(struct tun6 *tunnel, signed int fd)
{
  close(fd);
  wait((void *)0);
  tun6_destroy(tunnel);
}

// do_maintenance
// file maintain.c line 403
static void * do_maintenance(void *opaque)
{
  maintenance_thread((struct teredo_maintenance *)opaque);
}

// drop_privileges
// file miredo.h line 44
signed int drop_privileges(void)
{
  signed int return_value_chroot_2;
  _Bool tmp_if_expr_4;
  signed int return_value_chdir_3;
  if(!(miredo_chrootdir == ((const char *)NULL)))
  {
    return_value_chroot_2=chroot(miredo_chrootdir);
    if(!(return_value_chroot_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_chdir_3=chdir("/");
      tmp_if_expr_4 = return_value_chdir_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Error (%s): %m");
      syslog(1, return_value_dgettext_1, (const void *)"chroot");
      return -1;
    }

  }

  signed int return_value_setuid_6;
  return_value_setuid_6=setuid(unpriv_uid);
  if(!(return_value_setuid_6 == 0))
  {
    char *return_value_dgettext_5;
    return_value_dgettext_5=dgettext("miredo", "Error (%s): %m");
    syslog(1, return_value_dgettext_5, (const void *)"setuid");
    return -1;
  }

  struct _cap_struct *s;
  s=cap_init();
  if(!(s == ((struct _cap_struct *)NULL)))
  {
    cap_set_proc(s);
    cap_free((void *)s);
  }

  return 0;
}

// error_dup
// file main.c line 112
static signed int error_dup(signed int opt, const char *already, const char *additionnal)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Duplicate parameter \"%s\" for option -%c\nwould override previous value \"%s\".\n");
  fprintf(stderr, return_value_dgettext_1, additionnal, opt, already);
  return 2;
}

// error_errno
// file main.c line 142
static signed int error_errno(const char *str)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Error (%s): %s\n");
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  char *return_value_strerror_3;
  return_value_strerror_3=strerror(*return_value___errno_location_2);
  fprintf(stderr, return_value_dgettext_1, str, return_value_strerror_3);
  return -1;
}

// error_extra
// file main.c line 134
static signed int error_extra(const char *extra)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "%s: unexpected extra parameter\n");
  fprintf(stderr, return_value_dgettext_1, extra);
  return 2;
}

// garbage_collector
// file peerlist.c line 228
static void * garbage_collector(void *data)
{
  struct teredo_peerlist *l = (struct teredo_peerlist *)data;
  signed int return_value_clock_nanosleep_1;
  do
  {
    struct timespec delay = { .tv_sec=(signed long int)l->expiration, .tv_nsec=0l };
    do
    {
      return_value_clock_nanosleep_1=clock_nanosleep(0, 0, &delay, &delay);
      if(return_value_clock_nanosleep_1 == 0)
        break;

    }
    while((_Bool)1);
    signed int state;
    pthread_setcancelstate(1, &state);
    pthread_mutex_lock(&l->lock);
    struct teredo_listitem *p = l->old;
    for( ; !(p == ((struct teredo_listitem *)NULL)); p = p->next)
    {
      signed int Rc_int;
      struct J_UDY_ERROR_STRUCT J_Error;
      Rc_int=JudyHSDel(&l->PJHSArray, (void *)(unsigned char *)&p->key, (unsigned long int)16, &J_Error);
      if(Rc_int == -1)
      {
        fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 248, (const void *)"JudyHSDel", (&J_Error)->je_Errno, (&J_Error)->je_ErrID);
        exit(1);
      }

      l->left = l->left + 1u;
    }
    struct teredo_listitem *old = l->old;
    l->old = l->recent;
    l->recent = (struct teredo_listitem *)(void *)0;
    if(!(l->old == ((struct teredo_listitem *)NULL)))
      l->old->pprev = &l->old;

    pthread_mutex_unlock(&l->lock);
    sched_yield();
    listitem_recdestroy(old);
    pthread_setcancelstate(state, (signed int *)(void *)0);
    sched_yield();
  }
  while((_Bool)1);
}

// getipv4byname
// file maintain.c line 107
static signed int getipv4byname(const char * restrict name, unsigned int * restrict ipv4)
{
  struct addrinfo hints = { .ai_flags=0, .ai_family=2, .ai_socktype=2, .ai_protocol=0,
    .ai_addrlen=0u, .ai_addr=((struct sockaddr *)NULL), .ai_canonname=((char *)NULL),
    .ai_next=((struct addrinfo *)NULL) };
  struct addrinfo *res;
  signed int val;
  val=getaddrinfo(name, (const char *)(void *)0, &hints, &res);
  if(!(val == 0))
    return val;

  else
  {
    *ipv4 = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;
    freeaddrinfo(res);
    return 0;
  }
}

// gettime
// file maintain.c line 60
static inline void gettime(struct timespec *now)
{
  signed int return_value_clock_gettime_1;
  return_value_clock_gettime_1=clock_gettime(1, now);
  if(!(return_value_clock_gettime_1 == 0))
    clock_gettime(0, now);

}

// icmp6_checksum
// file checksum.h line 34
static inline unsigned short int icmp6_checksum(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6)
{
  struct iovec iov;
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
  iov = (struct iovec){ .iov_base=(void *)icmp6, .iov_len=(unsigned long int)return_value_ntohs_1 };
  unsigned short int return_value_teredo_cksum_2;
  return_value_teredo_cksum_2=teredo_cksum((const void *)&ip6->ip6_src, (const void *)&ip6->ip6_dst, (unsigned char)58, &iov, (unsigned long int)1);
  return return_value_teredo_cksum_2;
}

// in6_matches_teredo_client
// file teredo.h line 95
static inline signed int in6_matches_teredo_client(struct in6_addr *ip6, unsigned int ip, unsigned short int port)
{
  _Bool tmp_if_expr_1;
  if(!((0xffffffff ^ ((union teredo_addr *)ip6)->teredo.client_ip ^ ip) == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ((signed int)port ^ (signed int)(&((union teredo_addr *)ip6)->teredo)->client_port ^ 0xffff) != 0 ? (_Bool)1 : (_Bool)0;
  return (signed int)!tmp_if_expr_1;
}

// in_cksum
// file teredo.c line 338
static unsigned short int in_cksum(struct iovec *iov, unsigned long int n)
{
  unsigned int sum = (unsigned int)0;
  /* tag-#anon#lUN[U16'word'||lARR2{U8}_U8_'bytes'|] */
union anonymous_22
{
  // word
  unsigned short int word;
  // bytes
  unsigned char bytes[2l];
};

/* */
  ;
  union anonymous_22 w;
  _Bool odd = (_Bool)0;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  while(n >= 1ul)
  {
    const unsigned char *ptr = (const unsigned char *)iov->iov_base;
    unsigned long int len = iov->iov_len;
    for( ; len >= 1ul; len = len - 1ul)
    {
      if(!(odd == (_Bool)0))
      {
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        w.bytes[(signed long int)1] = *tmp_post_1;
        sum = sum + (unsigned int)w.word;
        if(sum >= 65536u)
          sum = sum - (unsigned int)0xffff;

      }

      else
      {
        tmp_post_2 = ptr;
        ptr = ptr + 1l;
        w.bytes[(signed long int)0] = *tmp_post_2;
      }
      odd = !(odd != (_Bool)0);
    }
    iov = iov + 1l;
    n = n - 1ul;
  }
  if(!(odd == (_Bool)0))
  {
    w.bytes[(signed long int)1] = (unsigned char)0;
    sum = sum + (unsigned int)w.word;
    if(sum >= 65536u)
      sum = sum - (unsigned int)0xffff;

  }

  return (unsigned short int)(sum ^ (unsigned int)0xffff);
}

// init_locale
// file main.c line 313
static void init_locale(void)
{
  Pryt4897810065911_br_init((enum anonymous_26 *)(void *)0);
  setlocale(6, "");
  char *path;
  path=Pryt4897810065911_br_find_locale_dir("/usr/share/locale");
  bindtextdomain("miredo", path);
  free((void *)path);
  textdomain("miredo");
}

// init_security
// file main.c line 207
static signed int init_security(const char *username)
{
  signed int val;
  umask((unsigned int)022);
  signed int return_value_chdir_1;
  return_value_chdir_1=chdir("/");
  char *tmp_if_expr_8;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  char *return_value_dgettext_7;
  _Bool tmp_if_expr_15;
  signed int return_value_setgid_14;
  _Bool tmp_if_expr_17;
  signed int return_value_initgroups_16;
  signed int return_value_error_errno_18;
  if(!(return_value_chdir_1 == 0))
    return -1;

  else
  {
    closefrom(3);
    val=dup(2);
    if(!(val == 3))
      return -1;

    else
    {
      close(val);
      clearenv();
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      struct passwd *pw;
      pw=getpwnam(username);
      if(pw == ((struct passwd *)NULL))
      {
        char *return_value_dgettext_3;
        return_value_dgettext_3=dgettext("miredo", "User \"%s\": %s\n");
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 0))
        {
          return_value___errno_location_5=__errno_location();
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          tmp_if_expr_8 = return_value_strerror_6;
        }

        else
        {
          return_value_dgettext_7=dgettext("miredo", "User not found");
          tmp_if_expr_8 = return_value_dgettext_7;
        }
        fprintf(stderr, return_value_dgettext_3, username, tmp_if_expr_8);
        return -1;
      }

      if(pw->pw_uid == 0u)
      {
        char *return_value_dgettext_9;
        return_value_dgettext_9=dgettext("miredo", "Error: This program is not supposed to keep root\nprivileges. That is potentially very dangerous\n(all the more as it has never been externally audited).\n");
        fputs(return_value_dgettext_9, stderr);
        return -1;
      }

      unpriv_uid = pw->pw_uid;
      signed int return_value_seteuid_13;
      return_value_seteuid_13=seteuid((unsigned int)0);
      if(!(return_value_seteuid_13 == 0))
        tmp_if_expr_15 = (_Bool)1;

      else
      {
        return_value_setgid_14=setgid(pw->pw_gid);
        tmp_if_expr_15 = return_value_setgid_14 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_15)
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        return_value_initgroups_16=initgroups(username, pw->pw_gid);
        tmp_if_expr_17 = return_value_initgroups_16 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_17)
      {
        char *return_value_dgettext_10;
        return_value_dgettext_10=dgettext("miredo", "SetUID to root: %s\n");
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        char *return_value_strerror_12;
        return_value_strerror_12=strerror(*return_value___errno_location_11);
        fprintf(stderr, return_value_dgettext_10, return_value_strerror_12);
        setuid_notice();
        return -1;
      }

      struct _cap_struct *s;
      s=cap_init();
      if(s == ((struct _cap_struct *)NULL))
      {
        return_value_error_errno_18=error_errno("cap_init");
        return return_value_error_errno_18;
      }

      else
      {
        static signed int caps[2l] = { 5, 7 };
        cap_set_flag(s, (enum anonymous_27)CAP_PERMITTED, 3, caps, (enum anonymous_28)CAP_SET);
        cap_set_flag(s, (enum anonymous_27)CAP_EFFECTIVE, 3, caps, (enum anonymous_28)CAP_SET);
        if(!(miredo_chrootdir == ((const char *)NULL)))
        {
          static signed int chroot_cap[1l] = { 18 };
          cap_set_flag(s, (enum anonymous_27)CAP_PERMITTED, 1, chroot_cap, (enum anonymous_28)CAP_SET);
          cap_set_flag(s, (enum anonymous_27)CAP_EFFECTIVE, 1, chroot_cap, (enum anonymous_28)CAP_SET);
        }

        cap_set_flag(s, (enum anonymous_27)CAP_PERMITTED, miredo_capc, (signed int *)miredo_capv, (enum anonymous_28)CAP_SET);
        cap_set_flag(s, (enum anonymous_27)CAP_EFFECTIVE, miredo_capc, (signed int *)miredo_capv, (enum anonymous_28)CAP_SET);
        val=cap_set_proc(s);
        cap_free((void *)s);
        if(!(val == 0))
        {
          error_errno("cap_set_proc");
          setuid_notice();
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// is_ipv4_global_unicast
// file v4global.h line 34
signed int is_ipv4_global_unicast(unsigned int ip)
{
  unsigned int return_value_htonl_7;
  return_value_htonl_7=htonl(0x80000000);
  _Bool tmp_if_expr_4;
  unsigned int return_value_htonl_3;
  _Bool tmp_if_expr_6;
  unsigned int return_value_htonl_5;
  if((return_value_htonl_7 & ip) == 0u)
  {
    unsigned int return_value_htonl_1;
    return_value_htonl_1=htonl(0xff000000);
    ip = ip & return_value_htonl_1;
    unsigned int return_value_htonl_2;
    return_value_htonl_2=htonl((unsigned int)0x0a000000);
    if(!(ip == return_value_htonl_2))
    {
      return_value_htonl_3=htonl((unsigned int)0x7f000000);
      tmp_if_expr_4 = ip != return_value_htonl_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_htonl_5=htonl((unsigned int)0x00000000);
      tmp_if_expr_6 = ip != return_value_htonl_5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    return (signed int)tmp_if_expr_6;
  }

  unsigned int return_value_htonl_13;
  return_value_htonl_13=htonl((unsigned int)0x40000000);
  _Bool tmp_if_expr_12;
  unsigned int return_value_htonl_10;
  unsigned int return_value_htonl_11;
  if((return_value_htonl_13 & ip) == 0u)
  {
    unsigned int return_value_htonl_8;
    return_value_htonl_8=htonl(0xffff0000);
    unsigned int return_value_htonl_9;
    return_value_htonl_9=htonl(0xa9fe0000);
    if(!((return_value_htonl_8 & ip) == return_value_htonl_9))
    {
      return_value_htonl_10=htonl(0xfff00000);
      return_value_htonl_11=htonl(0xac100000);
      tmp_if_expr_12 = (ip & return_value_htonl_10) != return_value_htonl_11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_12 = (_Bool)0;
    return (signed int)tmp_if_expr_12;
  }

  unsigned int return_value_htonl_19;
  return_value_htonl_19=htonl((unsigned int)0x20000000);
  _Bool tmp_if_expr_18;
  unsigned int return_value_htonl_16;
  unsigned int return_value_htonl_17;
  if((return_value_htonl_19 & ip) == 0u)
  {
    unsigned int return_value_htonl_14;
    return_value_htonl_14=htonl(0xffff0000);
    unsigned int return_value_htonl_15;
    return_value_htonl_15=htonl(0xc0a80000);
    if(!((return_value_htonl_14 & ip) == return_value_htonl_15))
    {
      return_value_htonl_16=htonl(0xffffff00);
      return_value_htonl_17=htonl(0xc0586200);
      tmp_if_expr_18 = (ip & return_value_htonl_16) != return_value_htonl_17 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_18 = (_Bool)0;
    return (signed int)tmp_if_expr_18;
  }

  unsigned int return_value_htonl_20;
  return_value_htonl_20=htonl((unsigned int)0x10000000);
  if((return_value_htonl_20 & ip) == 0u)
    return 0;

  else
  {
    unsigned int return_value_htonl_21;
    return_value_htonl_21=htonl(0xffffffff);
    return (signed int)(ip != return_value_htonl_21);
  }
}

// listitem_create
// file peerlist.c line 181
static inline struct teredo_listitem * listitem_create(void)
{
  struct teredo_listitem *entry;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_listitem) /*72ul*/ );
  entry = (struct teredo_listitem *)return_value_malloc_1;
  if(!(entry == ((struct teredo_listitem *)NULL)))
    teredo_peer_init(&entry->peer);

  return entry;
}

// listitem_destroy
// file peerlist.c line 190
static inline void listitem_destroy(struct teredo_listitem *entry)
{
  teredo_peer_destroy(&entry->peer);
  free((void *)entry);
}

// listitem_recdestroy
// file peerlist.c line 197
static void listitem_recdestroy(struct teredo_listitem *entry)
{
  while(!(entry == ((struct teredo_listitem *)NULL)))
  {
    struct teredo_listitem *buf = entry->next;
    listitem_destroy(entry);
    entry = buf;
  }
}

// logger
// file miredo.c line 96
static void logger(void *dummy, _Bool error, const char *fmt, void **ap)
{
  (void)dummy;
  vsyslog(error != (_Bool)0 ? 3 : 4, fmt, ap);
}

// main
// file relayd.c line 616
signed int main(signed int argc, char **argv)
{
  static const signed int capv[2l] = { 12, 13 };
  miredo_capv = capv;
  miredo_capc = (signed int)(sizeof(const signed int [2l]) /*8ul*/  / sizeof(const signed int) /*4ul*/ );
  miredo_name = "miredo";
  miredo_diagnose = relay_diagnose;
  miredo_run = relay_run;
  signed int return_value_miredo_main_1;
  return_value_miredo_main_1=miredo_main(argc, argv);
  return return_value_miredo_main_1;
}

// maintenance_recv
// file maintain.c line 132
static signed int maintenance_recv(const struct teredo_packet * restrict packet, unsigned int server_ip, const unsigned char * restrict nonce, _Bool cone, struct teredo_state * restrict state)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)packet->auth_nonce, (const void *)nonce, (unsigned long int)8);
  _Bool tmp_if_expr_4;
  if(!(return_value_memcmp_1 == 0))
    return 1;

  else
  {
    if(!(packet->auth_fail == (_Bool)0))
    {
      char *return_value_dgettext_2;
      return_value_dgettext_2=dgettext("miredo", "Authentication with server failed.");
      syslog(3, return_value_dgettext_2);
      return 13;
    }

    signed int return_value_teredo_parse_ra_3;
    return_value_teredo_parse_ra_3=teredo_parse_ra(packet, &state->addr, cone, &state->mtu);
    if(!(return_value_teredo_parse_ra_3 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = state->addr.teredo.server_ip != server_ip ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      return 22;

    else
    {
      state->ipv4 = packet->dest_ipv4;
      return 0;
    }
  }
}

// maintenance_thread
// file maintain.c line 242
static inline void maintenance_thread(struct teredo_maintenance *m)
{
  struct timespec deadline = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  struct teredo_state *c_state = &m->state.state;
  unsigned int server_ip = (unsigned int)0;
  unsigned int count = (unsigned int)0;
  /* #anon_enum_TERR_NONE=0_TERR_BLACKHOLE=1 */
enum anonymous_15 { TERR_NONE=0, TERR_BLACKHOLE=1 };

/* */
  ;
  enum anonymous_15 last_error = (enum anonymous_15)TERR_NONE;
  pthread_mutex_lock(&m->inner);
  struct anonymous_19 __cancel_buf;
  void (*__cancel_routine)(void *) = cleanup_unlock;
  void *__cancel_arg = (void *)&m->inner;
  signed int __not_first_call;
  __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
  if(!((signed long int)__not_first_call == 0l))
  {
    __cancel_routine(__cancel_arg);
    __pthread_unwind_next(&__cancel_buf);
  }

  __pthread_register_cancel(&__cancel_buf);

__CPROVER_DUMP_L3:
  ;
  signed int return_value_is_ipv4_global_unicast_4;
  _Bool return_value_checkTimeDrift_5;
  _Bool tmp_statement_expression_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_19;
  _Bool tmp_statement_expression_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_20;
  while((_Bool)1)
  {
    if(server_ip == 0u)
    {
      signed int val;
      val=getipv4byname(m->server, &server_ip);
      gettime(&deadline);
      if(!(val == 0))
      {
        char *return_value_dgettext_1;
        return_value_dgettext_1=dgettext("miredo", "Cannot resolve Teredo server address \"%s\": %s");
        const char *return_value_gai_strerror_2;
        return_value_gai_strerror_2=gai_strerror(val);
        syslog(3, return_value_dgettext_1, m->server, return_value_gai_strerror_2);
      }

      else
      {
        return_value_is_ipv4_global_unicast_4=is_ipv4_global_unicast(server_ip);
        if(return_value_is_ipv4_global_unicast_4 == 0)
        {
          char *return_value_dgettext_3;
          return_value_dgettext_3=dgettext("miredo", "Teredo server has a non global IPv4 address.");
          syslog(3, return_value_dgettext_3);
        }

        else
        {
          c_state->addr.teredo.server_ip = server_ip;
          m->state.cb(c_state, m->state.opaque);
        }
      }
      deadline.tv_sec = deadline.tv_sec + (signed long int)m->restart_delay;
      server_ip = (unsigned int)0;
      wait_reply_ignore(m, &deadline);
      goto __CPROVER_DUMP_L3;
    }

    do
    {
      deadline.tv_sec = deadline.tv_sec + (signed long int)m->qualification_delay;
      return_value_checkTimeDrift_5=checkTimeDrift(&deadline);
    }
    while(return_value_checkTimeDrift_5 == (_Bool)0);
    unsigned char nonce[8l];
    unsigned short int return_value_htons_6;
    return_value_htons_6=htons((unsigned short int)3544);
    teredo_get_nonce((unsigned int)deadline.tv_sec, server_ip, return_value_htons_6, nonce);
    teredo_send_rs(m->fd, server_ip, nonce, (_Bool)0);
    signed int maintenance_thread__1__1__2__1__1__val = 0;
    struct teredo_state newst;
    newst.mtu = (unsigned short int)1280;
    newst.up = (_Bool)1;
    do
    {
      maintenance_thread__1__1__2__1__1__val=wait_reply(m, &deadline);
      if(maintenance_thread__1__1__2__1__1__val == 0)
      {
        maintenance_thread__1__1__2__1__1__val=maintenance_recv(m->incoming, server_ip, nonce, (_Bool)0, &newst);
        m->incoming = (const struct teredo_packet *)(void *)0;
        pthread_cond_signal(&m->processed);
      }

    }
    while(!(maintenance_thread__1__1__2__1__1__val == 0) && !(maintenance_thread__1__1__2__1__1__val == 110));
    unsigned int delay = (unsigned int)0;
    if(!(maintenance_thread__1__1__2__1__1__val == 0))
    {
      count = count + 1u;
      if(count >= m->qualification_retries)
      {
        count = (unsigned int)0;
        if(!((signed int)last_error == TERR_BLACKHOLE))
        {
          char *return_value_dgettext_7;
          return_value_dgettext_7=dgettext("miredo", "No reply from Teredo server");
          syslog(6, return_value_dgettext_7);
          last_error = (enum anonymous_15)TERR_BLACKHOLE;
        }

        if(!(c_state->up == (_Bool)0))
        {
          char *return_value_dgettext_8;
          return_value_dgettext_8=dgettext("miredo", "Lost Teredo connectivity");
          syslog(5, return_value_dgettext_8);
          c_state->up = (_Bool)0;
          m->state.cb(c_state, m->state.opaque);
          server_ip = (unsigned int)0;
        }

        delay = m->restart_delay;
      }

    }

    else
    {
      count = (unsigned int)0;
      newst.addr.teredo.flags = c_state->addr.teredo.flags;
      struct in6_addr *__a = (struct in6_addr *)&c_state->addr.ip6;
      struct in6_addr *__b = (struct in6_addr *)&newst.addr.ip6;
      if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
        tmp_if_expr_11 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
        tmp_if_expr_12 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_12 = (_Bool)0;
      if(tmp_if_expr_12)
        tmp_if_expr_13 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_13 = (_Bool)0;
      tmp_statement_expression_10 = tmp_if_expr_13;
      if(!tmp_statement_expression_10)
      {
        unsigned short int f;
        f=teredo_get_flbits((unsigned int)deadline.tv_sec);
        unsigned short int return_value_htons_9;
        return_value_htons_9=htons((unsigned short int)0x3cff);
        newst.addr.teredo.flags = (unsigned short int)((signed int)f & (signed int)return_value_htons_9);
      }

      if(c_state->up == (_Bool)0)
        tmp_if_expr_19 = (_Bool)1;

      else
      {
        struct in6_addr *maintenance_thread__1__1__2__1__1__4__3____a = (struct in6_addr *)&c_state->addr.ip6;
        struct in6_addr *maintenance_thread__1__1__2__1__1__4__3____b = (struct in6_addr *)&newst.addr.ip6;
        if(maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[0l] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[0l])
          tmp_if_expr_16 = maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[(signed long int)1] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
          tmp_if_expr_17 = maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[(signed long int)2] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_17 = (_Bool)0;
        if(tmp_if_expr_17)
          tmp_if_expr_18 = maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[(signed long int)3] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_18 = (_Bool)0;
        tmp_statement_expression_15 = tmp_if_expr_18;
        tmp_if_expr_19 = !tmp_statement_expression_15 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_19)
        tmp_if_expr_20 = (_Bool)1;

      else
        tmp_if_expr_20 = c_state->mtu != newst.mtu ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_20)
      {
        memcpy((void *)c_state, (const void *)&newst, sizeof(struct teredo_state) /*24ul*/ );
        char *return_value_dgettext_14;
        return_value_dgettext_14=dgettext("miredo", "New Teredo address/MTU");
        syslog(5, return_value_dgettext_14);
        m->state.cb(c_state, m->state.opaque);
      }

      last_error = (enum anonymous_15)TERR_NONE;
      delay = m->refresh_delay;
    }
    if(!(delay == 0u))
    {
      deadline.tv_sec = deadline.tv_sec - (signed long int)m->qualification_delay;
      deadline.tv_sec = deadline.tv_sec + (signed long int)delay;
      wait_reply_ignore(m, &deadline);
    }

  }
  __pthread_unregister_cancel(&__cancel_buf);
  __cancel_routine(__cancel_arg);
}

// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes)
{
  const unsigned char *p = data;
  signed int left = nbytes;
  signed int offset = (signed int)(pms->count[(signed long int)0] >> 3 & (unsigned int)63);
  unsigned int nbits = (unsigned int)(nbytes << 3);
  if(nbytes >= 1)
  {
    pms->count[(signed long int)1] = pms->count[(signed long int)1] + (unsigned int)(nbytes >> 29);
    pms->count[(signed long int)0] = pms->count[(signed long int)0] + nbits;
    if(!(pms->count[0l] >= nbits))
      pms->count[(signed long int)1] = pms->count[(signed long int)1] + 1u;

    if(!(offset == 0))
    {
      signed int copy = offset + nbytes > 64 ? 64 - offset : nbytes;
      memcpy((void *)(pms->buf + (signed long int)offset), (const void *)p, (unsigned long int)copy);
      if(!(copy + offset >= 64))
        goto __CPROVER_DUMP_L7;

      p = p + (signed long int)copy;
      left = left - copy;
      md5_process(pms, pms->buf);
    }

    for( ; left >= 64; left = left - 64)
    {
      md5_process(pms, p);
      p = p + (signed long int)64;
    }
    if(!(left == 0))
      memcpy((void *)pms->buf, (const void *)p, (unsigned long int)left);

  }


__CPROVER_DUMP_L7:
  ;
}

// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest)
{
  unsigned char data[8l];
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    data[(signed long int)i] = (unsigned char)(pms->count[(signed long int)(i >> 2)] >> ((i & 3) << 3));
  static const unsigned char pad[64l] = { (const unsigned char)0x80, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  md5_append(pms, pad, (signed int)(((unsigned int)55 - (pms->count[(signed long int)0] >> 3) & (unsigned int)63) + (unsigned int)1));
  md5_append(pms, data, 8);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    digest[(signed long int)i] = (unsigned char)(pms->abcd[(signed long int)(i >> 2)] >> ((i & 3) << 3));
}

// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms)
{
  pms->count[(signed long int)1] = (unsigned int)0;
  pms->count[(signed long int)0] = pms->count[(signed long int)1];
  pms->abcd[(signed long int)0] = (unsigned int)0x67452301;
  pms->abcd[(signed long int)1] = (unsigned int)~0 ^ (unsigned int)0x10325476;
  pms->abcd[(signed long int)2] = (unsigned int)~0 ^ (unsigned int)0x67452301;
  pms->abcd[(signed long int)3] = (unsigned int)0x10325476;
}

// md5_process
// file md5.c line 147
static void md5_process(struct md5_state_s *pms, const unsigned char *data)
{
  unsigned int a = pms->abcd[(signed long int)0];
  unsigned int b = pms->abcd[(signed long int)1];
  unsigned int c = pms->abcd[(signed long int)2];
  unsigned int d = pms->abcd[(signed long int)3];
  unsigned int t;
  unsigned int xbuf[16l];
  const unsigned int *X;
  if((data - ((const unsigned char *)NULL) & 3l) == 0l)
    X = (const unsigned int *)data;

  else
  {
    memcpy((void *)xbuf, (const void *)data, (unsigned long int)64);
    X = xbuf;
  }
  t = a + (b & c | ~b & d) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x28955b87);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x173848a9);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)2] + (unsigned int)0x242070db;
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x3e423111);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x0a83f050);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)5] + (unsigned int)0x4787c62a;
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x57cfb9ec);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x02b96afe);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)8] + (unsigned int)0x698098d8;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x74bb0850);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x0000a44e);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x76a32841);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)12] + (unsigned int)0x6b901122;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x02678e6c);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x5986bc71);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)15] + (unsigned int)0x49b40821;
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x09e1da9d);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x3fbf4cbf);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)11] + (unsigned int)0x265e5a51;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x16493855);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x29d0efa2);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)10] + (unsigned int)0x02441453;
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x275e197e);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x182c0437);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x3cc8f829);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x0b2af278);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)8] + (unsigned int)0x455a14ed;
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x561c16fa);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x03105c07);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)7] + (unsigned int)0x676f02d9;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x72d5b375);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x0005c6bd);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)8] + ((unsigned int)~0 ^ (unsigned int)0x788e097e);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x021ac7f3);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x5b4115bb);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x0944b49f);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x4140438f);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x155ed805);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x2b10cf7a);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)6] + (unsigned int)0x04881d05;
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x262b2fc6);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x1924661a);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x3b53a99a);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x0bd6ddbb);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)7] + (unsigned int)0x432aff97;
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x546bdc58);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x036c5fc6);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)12] + (unsigned int)0x655b59c3;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x70f3336d);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x00100b82);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x7a7ba22e);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x01d3191f);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x5cfebceb);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x08ac817d);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x42c50dca);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x14792c6e);
  b = (t << 21 | t >> 32 - 21) + c;
  pms->abcd[(signed long int)0] = pms->abcd[(signed long int)0] + a;
  pms->abcd[(signed long int)1] = pms->abcd[(signed long int)1] + b;
  pms->abcd[(signed long int)2] = pms->abcd[(signed long int)2] + c;
  pms->abcd[(signed long int)3] = pms->abcd[(signed long int)3] + d;
}

// miredo
// file miredo.h line 43
signed int miredo(const char *confpath, const char *server_name, signed int pidfd)
{
  struct anonymous_29 set;
  struct anonymous_29 exit_set;
  struct anonymous_29 reload_set;
  signed int retval;
  struct miredo_conf *cnf;
  cnf=miredo_conf_create(logger, (void *)0);
  char *return_value_dgettext_1;
  char *return_value_dgettext_4;
  signed int return_value_waitpid_6;
  signed int return_value_sigismember_11;
  signed int return_value_waitpid_13;
  if(cnf == ((struct miredo_conf *)NULL))
    return -1;

  else
  {
    sigemptyset(&set);
    sigaddset(&set, 2);
    sigaddset(&set, 3);
    sigaddset(&set, 15);
    exit_set = set;
    sigaddset(&set, 1);
    reload_set = set;
    sigaddset(&set, 17);
    pthread_sigmask(0, &set, (struct anonymous_29 *)(void *)0);
    openlog(miredo_name, 0x01 | 0x20, 3 << 3);
    do
    {
      signed int facility = 3 << 3;
      retval = 1;
      _Bool return_value_miredo_conf_read_file_2;
      return_value_miredo_conf_read_file_2=miredo_conf_read_file(cnf, confpath);
      if(return_value_miredo_conf_read_file_2 == (_Bool)0)
      {
        return_value_dgettext_1=dgettext("miredo", "Loading configuration from %s failed");
        syslog(4, return_value_dgettext_1, confpath);
      }

      miredo_conf_parse_syslog_facility(cnf, "SyslogFacility", &facility);
      closelog();
      openlog(miredo_name, 0x01 | 0x20, facility);
      char *return_value_dgettext_3;
      return_value_dgettext_3=dgettext("miredo", "Starting...");
      syslog(6, return_value_dgettext_3);
      signed int pid;
      pid=fork();
      if(!(pid == -1))
      {
        if(pid == 0)
          goto __CPROVER_DUMP_L5;

      }

      else
      {
        return_value_dgettext_4=dgettext("miredo", "Error (%s): %m");
        syslog(1, return_value_dgettext_4, (const void *)"fork");
        continue;

      __CPROVER_DUMP_L5:
        ;
        close(pidfd);
        retval=miredo_run(cnf, server_name);
        miredo_conf_destroy(cnf);
        closelog();
        exit(-retval);
      }
      miredo_conf_clear(cnf, 0);
      signed int status;
      signed int signum;
      do
      {

      __CPROVER_DUMP_L8:
        ;
        signed int return_value_sigwait_5;
        return_value_sigwait_5=sigwait(&set, &signum);
        if(!(return_value_sigwait_5 == 0))
          goto __CPROVER_DUMP_L8;

        if(signum == 17)
        {
          return_value_waitpid_6=waitpid(pid, &status, 1);
          if(return_value_waitpid_6 == pid)
            break;

        }

        signed int return_value_sigismember_12;
        return_value_sigismember_12=sigismember(&exit_set, signum);
        if(!(return_value_sigismember_12 == 0))
        {
          char *return_value_dgettext_7;
          return_value_dgettext_7=dgettext("miredo", "Exiting on signal %d (%s)");
          char *return_value_strsignal_8;
          return_value_strsignal_8=strsignal(signum);
          syslog(5, return_value_dgettext_7, signum, return_value_strsignal_8);
          retval = 0;
        }

        else
        {
          return_value_sigismember_11=sigismember(&reload_set, signum);
          if(!(return_value_sigismember_11 == 0))
          {
            char *return_value_dgettext_9;
            return_value_dgettext_9=dgettext("miredo", "Reloading configuration on signal %d (%s)");
            char *return_value_strsignal_10;
            return_value_strsignal_10=strsignal(signum);
            syslog(5, return_value_dgettext_9, signum, return_value_strsignal_10);
            retval = 2;
          }

          else
            continue;
        }
        kill(pid, 15);
        do
        {
          return_value_waitpid_13=waitpid(pid, &status, 0);
          if(return_value_waitpid_13 == pid)
            break;

        }
        while((_Bool)1);
        break;
      }
      while((_Bool)1);
      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_30
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      if((0x7f & status) == 0)
      {
        status = (((union anonymous_30){ .__in=status }).__i & 0xff00) >> 8;
        char *return_value_dgettext_14;
        return_value_dgettext_14=dgettext("miredo", "Child %d exited (code: %d)");
        syslog(5, return_value_dgettext_14, (signed int)pid, status);
        if(!(status == 0))
          retval = 1;

      }

      else
        if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
        {
          status = ((union anonymous_30){ .__in=status }).__i & 0x7f;
          char *return_value_dgettext_15;
          return_value_dgettext_15=dgettext("miredo", "Child %d killed by signal %d (%s)");
          char *return_value_strsignal_16;
          return_value_strsignal_16=strsignal(status);
          syslog(6, return_value_dgettext_15, (signed int)pid, status, return_value_strsignal_16);
          retval = 2;
          sleep((unsigned int)1);
        }

    }
    while(retval == 2);
    miredo_conf_destroy(cnf);
    char *return_value_gettext_17;
    return_value_gettext_17=gettext(retval != 0 ? "Terminated with error(s)." : "Terminated with no error.");
    syslog(6, return_value_gettext_17);
    closelog();
    return -retval;
  }
}

// miredo_conf_clear
// file conf.h line 38
void miredo_conf_clear(struct miredo_conf *conf, signed int show)
{
  struct setting *ptr = conf->head;
  conf->head = (struct setting *)(void *)0;
  while(!(ptr == ((struct setting *)NULL)))
  {
    struct setting *buf = ptr->next;
    if(show >= 1)
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Superfluous directive %s at line %u");
      LogWarning(conf, return_value_dgettext_1, ptr->name, ptr->line);
      show = show - 1;
    }

    free((void *)ptr->name);
    free((void *)ptr->value);
    free((void *)ptr);
    ptr = buf;
  }
}

// miredo_conf_create
// file conf.h line 33
struct miredo_conf * miredo_conf_create(void (*logger)(void *, _Bool, const char *, void **), void *opaque)
{
  struct miredo_conf *conf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct miredo_conf) /*32ul*/ );
  conf = (struct miredo_conf *)return_value_malloc_1;
  if(conf == ((struct miredo_conf *)NULL))
    return (struct miredo_conf *)(void *)0;

  else
  {
    conf->tail = (struct setting *)(void *)0;
    conf->head = conf->tail;
    conf->logger = logger;
    conf->logger_data = opaque;
    return conf;
  }
}

// miredo_conf_destroy
// file conf.h line 34
void miredo_conf_destroy(struct miredo_conf *conf)
{
  miredo_conf_clear(conf, 0);
  free((void *)conf);
}

// miredo_conf_get
// file conf.h line 39
char * miredo_conf_get(struct miredo_conf *conf, const char *name, unsigned int *line)
{
  struct setting *p = conf->head;
  struct setting *prev = (struct setting *)(void *)0;
  for( ; !(p == ((struct setting *)NULL)); p = p->next)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(p->name, name);
    if(return_value_strcasecmp_1 == 0)
    {
      char *buf = p->value;
      if(!(line == ((unsigned int *)NULL)))
        *line = p->line;

      if(!(prev == ((struct setting *)NULL)))
        prev->next = p->next;

      else
        conf->head = p->next;
      free((void *)p->name);
      free((void *)p);
      return buf;
    }

    prev = p;
  }
  return (char *)(void *)0;
}

// miredo_conf_get_int16
// file conf.h line 41
_Bool miredo_conf_get_int16(struct miredo_conf *conf, const char *name, unsigned short int *value, unsigned int *line)
{
  char *val;
  val=miredo_conf_get(conf, name, line);
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    char *end;
    unsigned long int l;
    l=strtoul(val, &end, 0);
    if(l >= 65536ul || !(*end == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid integer value \"%s\" for %s: %s");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      LogError(conf, return_value_dgettext_1, val, name, return_value_strerror_3);
      free((void *)val);
      return (_Bool)0;
    }

    *value = (unsigned short int)l;
    free((void *)val);
    return (_Bool)1;
  }
}

// miredo_conf_parse_IPv4
// file conf.h line 48
_Bool miredo_conf_parse_IPv4(struct miredo_conf *conf, const char *name, unsigned int *ipv4)
{
  unsigned int line;
  char *val;
  val=miredo_conf_get(conf, name, &line);
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    signed int check;
    check=GetIPv4ByName(val, ipv4);
    if(!(check == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid hostname \"%s\" at line %u: %s");
      const char *return_value_gai_strerror_2;
      return_value_gai_strerror_2=gai_strerror(check);
      LogError(conf, return_value_dgettext_1, val, line, return_value_gai_strerror_2);
      free((void *)val);
      return (_Bool)0;
    }

    free((void *)val);
    return (_Bool)1;
  }
}

// miredo_conf_parse_IPv6
// file conf.c line 436
_Bool miredo_conf_parse_IPv6(struct miredo_conf *conf, const char *name, struct in6_addr *value)
{
  unsigned int line;
  char *val;
  val=miredo_conf_get(conf, name, &line);
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    struct addrinfo help = { .ai_flags=0, .ai_family=10, .ai_socktype=2, .ai_protocol=17,
    .ai_addrlen=0u, .ai_addr=((struct sockaddr *)NULL), .ai_canonname=((char *)NULL),
    .ai_next=((struct addrinfo *)NULL) };
    struct addrinfo *res;
    signed int check;
    check=getaddrinfo(val, (const char *)(void *)0, &help, &res);
    if(!(check == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid hostname \"%s\" at line %u: %s");
      const char *return_value_gai_strerror_2;
      return_value_gai_strerror_2=gai_strerror(check);
      LogError(conf, return_value_dgettext_1, val, line, return_value_gai_strerror_2);
      free((void *)val);
      return (_Bool)0;
    }

    memcpy((void *)value, (const void *)&((struct sockaddr_in6 *)res->ai_addr)->sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
    freeaddrinfo(res);
    free((void *)val);
    return (_Bool)1;
  }
}

// miredo_conf_parse_syslog_facility
// file conf.h line 55
_Bool miredo_conf_parse_syslog_facility(struct miredo_conf *conf, const char *name, signed int *facility)
{
  unsigned int line;
  char *str;
  str=miredo_conf_get(conf, name, &line);
  if(str == ((char *)NULL))
    return (_Bool)1;

  else
  {
    struct miredo_conf_syslog_facility *ptr = facilities;
    for( ; !(ptr->str == ((const char *)NULL)); ptr = ptr + 1l)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(str, ptr->str);
      if(return_value_strcasecmp_1 == 0)
      {
        *facility = ptr->facility;
        free((void *)str);
        return (_Bool)1;
      }

    }
    char *return_value_dgettext_2;
    return_value_dgettext_2=dgettext("miredo", "Unknown syslog facility \"%s\" at line %u");
    LogError(conf, return_value_dgettext_2, str, line);
    free((void *)str);
    return (_Bool)0;
  }
}

// miredo_conf_parse_teredo_prefix
// file conf.h line 52
_Bool miredo_conf_parse_teredo_prefix(struct miredo_conf *conf, const char *name, unsigned int *value)
{
  union teredo_addr addr;
  memset((void *)&addr, 0, sizeof(union teredo_addr) /*16ul*/ );
  addr.teredo.prefix = *value;
  _Bool return_value_miredo_conf_parse_IPv6_2;
  return_value_miredo_conf_parse_IPv6_2=miredo_conf_parse_IPv6(conf, name, &addr.ip6);
  if(!(return_value_miredo_conf_parse_IPv6_2 == (_Bool)0))
  {
    if((0xff000000 & addr.teredo.prefix) == 0xff000000)
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid Teredo IPv6 prefix: %x::/32");
      LogError(conf, return_value_dgettext_1, addr.teredo.prefix);
      return (_Bool)0;
    }

    *value = addr.teredo.prefix;
    return (_Bool)1;
  }

  else
    return (_Bool)0;
}

// miredo_conf_read_FILE
// file conf.c line 233
static _Bool miredo_conf_read_FILE(struct miredo_conf *conf, struct _IO_FILE *stream)
{
  char lbuf[1056l];
  unsigned int line = (unsigned int)0;
  char *return_value_fgets_1;
  signed int return_value_fgetc_3;
  signed int return_value_feof_4;
  _Bool tmp_if_expr_6;
  signed int return_value_ferror_5;
  _Bool return_value_miredo_conf_set_9;
  char *return_value_dgettext_10;
  do
  {
    return_value_fgets_1=fgets(lbuf, (signed int)sizeof(char [1056l]) /*1056ul*/ , stream);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    unsigned long int len;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(lbuf);
    len = return_value_strlen_2 - (unsigned long int)1;
    line = line + 1u;
    if(!((signed int)lbuf[(signed long int)len] == 10))
    {
      do
      {
        return_value_fgetc_3=fgetc(stream);
        if(return_value_fgetc_3 == 10)
          break;

        return_value_feof_4=feof(stream);
        if(!(return_value_feof_4 == 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_ferror_5=ferror(stream);
          tmp_if_expr_6 = return_value_ferror_5 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          break;

      }
      while((_Bool)1);
      char *return_value_dgettext_7;
      return_value_dgettext_7=dgettext("miredo", "Skipped overly long line %u");
      LogWarning(conf, return_value_dgettext_7, line);
      continue;
    }

    lbuf[(signed long int)len] = (char)0;
    char nbuf[32l];
    char vbuf[1024l];
    signed int return_value_sscanf_8;
    return_value_sscanf_8=sscanf(lbuf, " %31s %1023s", (const void *)nbuf, (const void *)vbuf);
    switch(return_value_sscanf_8)
    {
      case 2:
      {
        if(!((signed int)nbuf[0l] == 35))
        {
          return_value_miredo_conf_set_9=miredo_conf_set(conf, nbuf, vbuf, line);
          if(return_value_miredo_conf_set_9 == (_Bool)0)
            return (_Bool)0;

        }

        break;
      }
      case 1:
        if(!((signed int)nbuf[0l] == 35))
        {
          return_value_dgettext_10=dgettext("miredo", "Ignoring line %u: %s");
          LogWarning(conf, return_value_dgettext_10, line, (const void *)nbuf);
        }

    }
  }
  while((_Bool)1);
  signed int return_value_ferror_14;
  return_value_ferror_14=ferror(stream);
  if(!(return_value_ferror_14 == 0))
  {
    char *return_value_dgettext_11;
    return_value_dgettext_11=dgettext("miredo", "Error reading configuration file: %s");
    signed int *return_value___errno_location_12;
    return_value___errno_location_12=__errno_location();
    char *return_value_strerror_13;
    return_value_strerror_13=strerror(*return_value___errno_location_12);
    LogError(conf, return_value_dgettext_11, return_value_strerror_13);
    return (_Bool)0;
  }

  return (_Bool)1;
}

// miredo_conf_read_file
// file conf.h line 36
_Bool miredo_conf_read_file(struct miredo_conf *conf, const char *path)
{
  struct _IO_FILE *stream;
  stream=fopen(path, "r");
  if(!(stream == ((struct _IO_FILE *)NULL)))
  {
    _Bool ret;
    ret=miredo_conf_read_FILE(conf, stream);
    fclose(stream);
    return ret;
  }

  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Error opening configuration file %s: %s");
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  char *return_value_strerror_3;
  return_value_strerror_3=strerror(*return_value___errno_location_2);
  LogError(conf, return_value_dgettext_1, path, return_value_strerror_3);
  return (_Bool)0;
}

// miredo_conf_set
// file conf.c line 157
static _Bool miredo_conf_set(struct miredo_conf *conf, const char *name, const char *value, unsigned int line)
{
  struct setting *parm;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct setting) /*32ul*/ );
  parm = (struct setting *)return_value_malloc_1;
  if(!(parm == ((struct setting *)NULL)))
  {
    parm->name=strdup(name);
    if(!(parm->name == ((char *)NULL)))
    {
      parm->value=strdup(value);
      if(!(parm->value == ((char *)NULL)))
      {
        parm->line = line;
        parm->next = (struct setting *)(void *)0;
        if(conf->head == ((struct setting *)NULL))
          conf->head = parm;

        else
          conf->tail->next = parm;
        conf->tail = parm;
        return (_Bool)1;
      }

      free((void *)parm->name);
    }

    free((void *)parm);
  }

  char *return_value_dgettext_2;
  return_value_dgettext_2=dgettext("miredo", "Error (%s): %s");
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  char *return_value_strerror_4;
  return_value_strerror_4=strerror(*return_value___errno_location_3);
  LogError(conf, return_value_dgettext_2, (const void *)"strdup", return_value_strerror_4);
  return (_Bool)0;
}

// miredo_deinit
// file relayd.c line 118
static void miredo_deinit(_Bool client)
{
  close(icmp6_fd);
  teredo_cleanup(client);
}

// miredo_down_callback
// file relayd.c line 303
static void miredo_down_callback(void *data)
{
  configure_tunnel(((struct miredo_tunnel *)data)->priv_fd, &in6addr_any, (unsigned int)1280);
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Teredo pseudo-tunnel stopped");
  syslog(5, return_value_dgettext_1);
}

// miredo_encap_thread
// file relayd.c line 385
static void * miredo_encap_thread(void *d)
{
  struct teredo_tunnel *relay = ((struct miredo_tunnel *)d)->relay;
  struct tun6 *tunnel = ((struct miredo_tunnel *)d)->tunnel;
  do
  {
    /* tag-#anon#lST[lSYM#tag-ip6_hdr#'ip6'||lARR65467{U8}_U8_'fill'||U8'_pad0'|] */
struct anonymous_36
{
  // ip6
  struct ip6_hdr ip6;
  // fill
  unsigned char fill[65467l];
};

/* */
    ;
    struct anonymous_36 pbuf;
    signed int val;
    val=tun6_wait_recv(tunnel, (void *)&pbuf.ip6, sizeof(struct anonymous_36) /*65508ul*/ );
    if(val >= 40)
    {
      pthread_setcancelstate(1, (signed int *)(void *)0);
      teredo_transmit(relay, &pbuf.ip6, (unsigned long int)val);
      pthread_setcancelstate(0, (signed int *)(void *)0);
    }

    else
      pthread_testcancel();
  }
  while((_Bool)1);
}

// miredo_icmp6_callback
// file relayd.c line 142
static void miredo_icmp6_callback(void *data, const void *packet, unsigned long int length, struct in6_addr *dst)
{
  (void)data;
  struct sockaddr_in6 addr = { .sin6_family=(unsigned short int)10, .sin6_port=0, .sin6_flowinfo=0u,
    .sin6_addr=*dst, .sin6_scope_id=0u };
  sendto(icmp6_fd, packet, length, 0, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ );
}

// miredo_init
// file relayd.c line 95
static signed int miredo_init(_Bool client)
{
  signed int return_value_teredo_startup_1;
  return_value_teredo_startup_1=teredo_startup(client);
  if(!(return_value_teredo_startup_1 == 0))
    return -1;

  else
  {
    icmp6_fd=socket(10, 3, 58);
    if(icmp6_fd == -1)
      return -1;

    else
    {
      miredo_setup_nonblock_fd(icmp6_fd);
      signed int literal_2 = 2;
      setsockopt(icmp6_fd, 41, 7, (const void *)&literal_2, (unsigned int)sizeof(signed int) /*4ul*/ );
      struct icmp6_filter filt;
      memset((void *)&filt, 0xFF, sizeof(struct icmp6_filter) /*32ul*/ );
      setsockopt(icmp6_fd, 58, 1, (const void *)&filt, (unsigned int)sizeof(struct icmp6_filter) /*32ul*/ );
      return 0;
    }
  }
}

// miredo_main
// file miredo.h line 41
signed int miredo_main(signed int argc, char **argv)
{
  const char *username = (const char *)(void *)0;
  const char *conffile = (const char *)(void *)0;
  const char *servername = (const char *)(void *)0;
  const char *pidfile = (const char *)(void *)0;
  const char *chrootdir = (const char *)(void *)0;
  /* tag-#anon#lST[lBF{U32}_U32_'foreground'||BF{U7}_U7_'_bit_field_pad0'||U24'_pad0'|] */
struct anonymous_24
{
  // foreground
  unsigned int foreground : 1;
};

/* */
  ;
  struct anonymous_24 flags;
  init_locale();
  memset((void *)&flags, 0, sizeof(struct anonymous_24) /*4ul*/ );
  signed int c;
  signed int return_value_error_dup_1;
  signed int return_value_usage_2;
  signed int return_value_error_dup_3;
  signed int return_value_error_dup_4;
  signed int return_value_error_dup_5;
  signed int return_value_miredo_version_6;
  signed int return_value_quick_usage_7;
  do
  {
    static struct option opts[11l] = { { .name="conf", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="config", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="foreground", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="pidfile", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="chroot", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="chrootdir", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="user", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="username", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    c=getopt_long(argc, argv, "c:fhp:t:u:V", opts, (signed int *)(void *)0);
    if(c == -1)
      break;

    switch(c)
    {
      case 99:
      {
        if(!(conffile == ((const char *)NULL)))
        {
          return_value_error_dup_1=error_dup(c, optarg, conffile);
          return return_value_error_dup_1;
        }

        else
          conffile = optarg;
        break;
      }
      case 102:
      {
        flags.foreground = (unsigned int)1;
        break;
      }
      case 104:
      {
        return_value_usage_2=usage(argv[(signed long int)0]);
        return return_value_usage_2;
      }
      case 112:
      {
        if(!(pidfile == ((const char *)NULL)))
        {
          return_value_error_dup_3=error_dup(c, optarg, pidfile);
          return return_value_error_dup_3;
        }

        else
          pidfile = optarg;
        break;
      }
      case 117:
      {
        if(!(username == ((const char *)NULL)))
        {
          return_value_error_dup_4=error_dup(c, optarg, username);
          return return_value_error_dup_4;
        }

        else
          username = optarg;
        break;
      }
      case 116:
      {
        if(!(chrootdir == ((const char *)NULL)))
        {
          return_value_error_dup_5=error_dup(c, optarg, chrootdir);
          return return_value_error_dup_5;
        }

        else
          chrootdir = optarg;
        break;
      }
      case 86:
      {
        return_value_miredo_version_6=miredo_version();
        return return_value_miredo_version_6;
      }
      case 63:

      default:
      {
        return_value_quick_usage_7=quick_usage(argv[(signed long int)0]);
        return return_value_quick_usage_7;
      }
    }
  }
  while((_Bool)1);
  signed int tmp_post_8;
  if(!(optind >= argc))
  {
    tmp_post_8 = optind;
    optind = optind + 1;
    servername = argv[(signed long int)tmp_post_8];
  }

  signed int return_value_error_extra_9;
  signed int return_value_access_15;
  _Bool tmp_if_expr_21;
  signed int return_value_access_20;
  signed int *return_value___errno_location_17;
  unsigned long int return_value_strlen_22;
  char *return_value_dgettext_25;
  signed int *return_value___errno_location_26;
  char *return_value_strerror_27;
  _Bool tmp_if_expr_35;
  signed int *return_value___errno_location_34;
  char *return_value_dgettext_32;
  _Bool tmp_if_expr_38;
  struct _IO_FILE *return_value_freopen_37;
  _Bool tmp_if_expr_40;
  struct _IO_FILE *return_value_freopen_39;
  _Bool tmp_if_expr_42;
  signed long int return_value_write_41;
  if(!(optind >= argc))
  {
    return_value_error_extra_9=error_extra(argv[(signed long int)optind]);
    return return_value_error_extra_9;
  }

  else
  {
    if(username == ((const char *)NULL))
      username = "miredo";

    unsigned long int str_len = (unsigned long int)0;
    char *path = (char *)(void *)0;
    if(conffile == ((const char *)NULL))
    {
      path=Pryt4897810065911_br_find_etc_dir("/etc");
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(path);
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(miredo_name);
      str_len = return_value_strlen_10 + return_value_strlen_11 + sizeof(char [14l]) /*14ul*/ ;
    }

    const signed long int path_array_size0 = (signed long int)str_len;
    char conffile_buf[path_array_size0];
    if(conffile == ((const char *)NULL))
    {
      snprintf(conffile_buf, str_len, "%s/miredo/%s.conf", path, miredo_name);
      free((void *)path);
      conffile = conffile_buf;
    }

    if(servername == ((const char *)NULL))
    {
      return_value_access_15=access(conffile, 4);
      if(!(return_value_access_15 == 0))
      {
        char *return_value_dgettext_12;
        return_value_dgettext_12=dgettext("miredo", "Reading configuration from %s: %s\n");
        signed int *return_value___errno_location_13;
        return_value___errno_location_13=__errno_location();
        char *return_value_strerror_14;
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        fprintf(stderr, return_value_dgettext_12, conffile, return_value_strerror_14);
        return 1;
      }

    }

    if(!(chrootdir == ((const char *)NULL)))
    {
      struct stat s;
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      *return_value___errno_location_16 = 0;
      signed int return_value_stat_19;
      return_value_stat_19=stat(chrootdir, &s);
      if(!((61440u & s.st_mode) == 16384u) || !(return_value_stat_19 == 0))
        tmp_if_expr_21 = (_Bool)1;

      else
      {
        return_value_access_20=access(chrootdir, 1);
        tmp_if_expr_21 = return_value_access_20 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_21)
      {
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        if(*return_value___errno_location_18 == 0)
        {
          return_value___errno_location_17=__errno_location();
          *return_value___errno_location_17 = 20;
        }

        error_errno(chrootdir);
        return 1;
      }

    }

    miredo_chrootdir = chrootdir;
    if(pidfile == ((const char *)NULL))
    {
      return_value_strlen_22=strlen(miredo_name);
      str_len = sizeof(char [14l]) /*14ul*/  + return_value_strlen_22;
    }

    else
      str_len = (unsigned long int)0;
    const signed long int s_array_size0 = (signed long int)str_len;
    char pidfile_buf[s_array_size0];
    if(pidfile == ((const char *)NULL))
    {
      snprintf(pidfile_buf, str_len, "/var/run/%s.pid", miredo_name);
      pidfile = pidfile_buf;
    }

    signed int return_value_init_security_23;
    return_value_init_security_23=init_security(username);
    if(!(return_value_init_security_23 == 0))
      return 1;

    else
    {
      signed int return_value;
      return_value=miredo_diagnose();
      if(!(return_value == 0))
        return 1;

      else
      {
        signed int pipes[2l];
        signed int return_value_pipe_24;
        return_value_pipe_24=pipe(pipes);
        if(!(return_value_pipe_24 == 0))
        {
          pipes[(signed long int)1] = -1;
          pipes[(signed long int)0] = pipes[(signed long int)1];
        }

        if(flags.foreground == 0u)
        {
          signed int pid;
          pid=fork();
          if(pid == -1)
          {
            return_value_dgettext_25=dgettext("miredo", "Error (%s): %s\n");
            return_value___errno_location_26=__errno_location();
            return_value_strerror_27=strerror(*return_value___errno_location_26);
            fprintf(stderr, return_value_dgettext_25, (const void *)"fork", return_value_strerror_27);
            return 1;
          }

          close(pipes[(signed long int)1]);
          signed long int return_value_read_28;
          return_value_read_28=read(pipes[(signed long int)0], (void *)&c, sizeof(signed int) /*4ul*/ );
          if(!((unsigned long int)return_value_read_28 == sizeof(signed int) /*4ul*/ ))
            c = 1;

          close(pipes[(signed long int)0]);
          return c;
        }

        close(pipes[(signed long int)0]);
        signed int fd;
        fd=create_pidfile(pidfile);
        if(fd == -1)
        {
          char *return_value_dgettext_29;
          return_value_dgettext_29=dgettext("miredo", "Cannot create PID file %s:\n %s\n");
          signed int *return_value___errno_location_30;
          return_value___errno_location_30=__errno_location();
          char *return_value_strerror_31;
          return_value_strerror_31=strerror(*return_value___errno_location_30);
          fprintf(stderr, return_value_dgettext_29, pidfile, return_value_strerror_31);
          signed int *return_value___errno_location_33;
          return_value___errno_location_33=__errno_location();
          if(*return_value___errno_location_33 == 11)
            tmp_if_expr_35 = (_Bool)1;

          else
          {
            return_value___errno_location_34=__errno_location();
            tmp_if_expr_35 = *return_value___errno_location_34 == 13 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_35)
          {
            return_value_dgettext_32=dgettext("miredo", "Please make sure another instance of the program is not already running.");
            fprintf(stderr, "%s\n", return_value_dgettext_32);
          }

          exit(1);
        }

        if(flags.foreground == 0u)
        {
          c = 0;
          setsid();
          struct _IO_FILE *return_value_freopen_36;
          return_value_freopen_36=freopen("/dev/null", "r", stdin);
          if(return_value_freopen_36 == ((struct _IO_FILE *)NULL))
            tmp_if_expr_38 = (_Bool)1;

          else
          {
            return_value_freopen_37=freopen("/dev/null", "w", stdout);
            tmp_if_expr_38 = return_value_freopen_37 == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_38)
            tmp_if_expr_40 = (_Bool)1;

          else
          {
            return_value_freopen_39=freopen("/dev/null", "w", stderr);
            tmp_if_expr_40 = return_value_freopen_39 == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_40)
            tmp_if_expr_42 = (_Bool)1;

          else
          {
            return_value_write_41=write(pipes[(signed long int)1], (const void *)&c, sizeof(signed int) /*4ul*/ );
            tmp_if_expr_42 = return_value_write_41 <= (signed long int)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_42)
            exit(1);

        }

        close(pipes[(signed long int)1]);
        c=miredo(conffile, servername, fd);
        unlink(pidfile);
        close(fd);
        exit(c != 0 ? 1 : 0);
      }
    }
  }
}

// miredo_recv_callback
// file relayd.c line 130
static void miredo_recv_callback(void *data, const void *packet, unsigned long int length)
{
  tun6_send(((struct miredo_tunnel *)data)->tunnel, packet, length);
}

// miredo_setup_fd
// file relayd.c line 600
static void miredo_setup_fd(signed int fd)
{
  fcntl(fd, 2, 1);
}

// miredo_setup_nonblock_fd
// file relayd.c line 606
static void miredo_setup_nonblock_fd(signed int fd)
{
  signed int flags;
  flags=fcntl(fd, 3);
  if(flags == -1)
    flags = 0;

  fcntl(fd, 4, 04000 | flags);
  miredo_setup_fd(fd);
}

// miredo_up_callback
// file relayd.c line 284
static void miredo_up_callback(void *data, struct in6_addr *addr, unsigned short int mtu)
{
  char str[46l];
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Teredo pseudo-tunnel started");
  syslog(5, return_value_dgettext_1);
  const char *return_value_inet_ntop_3;
  return_value_inet_ntop_3=inet_ntop(10, (const void *)addr, str, (unsigned int)sizeof(char [46l]) /*46ul*/ );
  char *return_value_dgettext_2;
  if(!(return_value_inet_ntop_3 == ((const char *)NULL)))
  {
    return_value_dgettext_2=dgettext("miredo", " (address: %s, MTU: %u)");
    syslog(6, return_value_dgettext_2, (const void *)str, mtu);
  }

  configure_tunnel(((struct miredo_tunnel *)data)->priv_fd, addr, (unsigned int)mtu);
}

// miredo_version
// file main.c line 90
signed int miredo_version(void)
{
  const char *UNKNOWN = "N/A";
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Miredo: Teredo IPv6 tunneling software %s (%s)\n built %s on %s (%s)\n");
  printf(return_value_dgettext_1, (const void *)"1.2.6", UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN);
  char *return_value_dgettext_2;
  return_value_dgettext_2=dgettext("miredo", "Configured with: %s\n");
  printf(return_value_dgettext_2, (const void *)"./configure  '--build=x86_64-linux-gnu' '--prefix=/usr' '--includedir=_{prefix}/include' '--mandir=_{prefix}/share/man' '--infodir=_{prefix}/share/info' '--sysconfdir=/etc' '--localstatedir=/var' '--disable-silent-rules' '--libdir=_{prefix}/lib/x86_64-linux-gnu' '--libexecdir=_{prefix}/lib/x86_64-linux-gnu' '--disable-maintainer-mode' '--disable-dependency-tracking' '--enable-static' '--disable-shared' '--disable-binreloc' '--enable-miredo-user' '--disable-sample-conf' '--with-Judy' '--disable-assert' 'build_alias=x86_64-linux-gnu' 'CFLAGS=-g -O0 -fstack-protector-strong -Wformat -Werror=format-security' 'LDFLAGS=-Wl,-z,relro' 'CPPFLAGS=-Wdate-time'");
  char *return_value_dgettext_3;
  return_value_dgettext_3=dgettext("miredo", "Written by Remi Denis-Courmont.\n");
  puts(return_value_dgettext_3);
  char *return_value_dgettext_4;
  return_value_dgettext_4=dgettext("miredo", "Copyright (C) 2004-%u Remi Denis-Courmont\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n");
  printf(return_value_dgettext_4, 2006);
  return 0;
}

// proc_write_zero
// file tun6.c line 417
static signed int proc_write_zero(const char *path)
{
  signed int fd;
  fd=open(path, 01);
  if(fd == -1)
    return -1;

  else
  {
    signed int retval = 0;
    signed long int return_value_write_1;
    return_value_write_1=write(fd, (const void *)"0", (unsigned long int)1);
    if(!(return_value_write_1 == 1l))
      retval = -1;

    signed int return_value_close_2;
    return_value_close_2=close(fd);
    if(!(return_value_close_2 == 0))
      retval = -1;

    return retval;
  }
}

// quick_usage
// file main.c line 64
static signed int quick_usage(const char *path)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Try \"%s -h | more\" for more information.\n");
  fprintf(stderr, return_value_dgettext_1, path);
  return 2;
}

// relay_diagnose
// file relayd.c line 73
static signed int relay_diagnose(void)
{
  char errbuf[4096l];
  signed int return_value_tun6_driver_diagnose_1;
  return_value_tun6_driver_diagnose_1=tun6_driver_diagnose(errbuf);
  if(!(return_value_tun6_driver_diagnose_1 == 0))
  {
    fputs(errbuf, stderr);
    return -1;
  }

  else
    return 0;
}

// relay_run
// file relayd.c line 438
static signed int relay_run(struct miredo_conf *conf, const char *server_name)
{
  union teredo_addr prefix;
  memset((void *)&prefix, 0, sizeof(union teredo_addr) /*16ul*/ );
  prefix.teredo.prefix=htonl((unsigned int)0x20010000);
  signed int mode = 2;
  _Bool return_value_ParseRelayType_2;
  return_value_ParseRelayType_2=ParseRelayType(conf, "RelayType", &mode);
  if(return_value_ParseRelayType_2 == (_Bool)0)
  {
    char *return_value_dgettext_1;
    return_value_dgettext_1=dgettext("miredo", "Fatal configuration error");
    syslog(1, return_value_dgettext_1);
    return -2;
  }

  const char *server_name2 = (const char *)(void *)0;
  char namebuf[1025l];
  char namebuf2[1025l];
  unsigned short int mtu = (unsigned short int)1280;
  _Bool cone = (_Bool)0;
  _Bool tmp_if_expr_8;
  _Bool return_value_miredo_conf_get_int16_7;
  if(!((2 & mode) == 0))
  {
    if(server_name == ((const char *)NULL))
    {
      char *name;
      name=miredo_conf_get(conf, "ServerAddress", (unsigned int *)(void *)0);
      if(name == ((char *)NULL))
      {
        char *return_value_dgettext_3;
        return_value_dgettext_3=dgettext("miredo", "Server address not specified");
        syslog(1, return_value_dgettext_3);
        char *return_value_dgettext_4;
        return_value_dgettext_4=dgettext("miredo", "Fatal configuration error");
        syslog(1, return_value_dgettext_4);
        return -2;
      }

      strlcpy(namebuf, name, sizeof(char [1025l]) /*1025ul*/ );
      free((void *)name);
      server_name = namebuf;
      name=miredo_conf_get(conf, "ServerAddress2", (unsigned int *)(void *)0);
      if(!(name == ((char *)NULL)))
      {
        strlcpy(namebuf2, name, sizeof(char [1025l]) /*1025ul*/ );
        free((void *)name);
        server_name2 = namebuf2;
      }

    }

  }

  else
  {
    server_name = (const char *)(void *)0;
    mtu = (unsigned short int)1280;
    cone = mode == 0;
    _Bool return_value_miredo_conf_parse_teredo_prefix_6;
    return_value_miredo_conf_parse_teredo_prefix_6=miredo_conf_parse_teredo_prefix(conf, "Prefix", &prefix.teredo.prefix);
    if(return_value_miredo_conf_parse_teredo_prefix_6 == (_Bool)0)
      tmp_if_expr_8 = (_Bool)1;

    else
    {
      return_value_miredo_conf_get_int16_7=miredo_conf_get_int16(conf, "InterfaceMTU", &mtu, (unsigned int *)(void *)0);
      tmp_if_expr_8 = !(return_value_miredo_conf_get_int16_7 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_8)
    {
      char *return_value_dgettext_5;
      return_value_dgettext_5=dgettext("miredo", "Fatal configuration error");
      syslog(1, return_value_dgettext_5);
      return -2;
    }

  }
  unsigned int bind_ip = (unsigned int)0x00000000;
  unsigned short int bind_port = (unsigned short int)0;
  _Bool return_value_miredo_conf_parse_IPv4_10;
  return_value_miredo_conf_parse_IPv4_10=miredo_conf_parse_IPv4(conf, "BindAddress", &bind_ip);
  _Bool tmp_if_expr_12;
  _Bool return_value_miredo_conf_get_int16_11;
  if(return_value_miredo_conf_parse_IPv4_10 == (_Bool)0)
    tmp_if_expr_12 = (_Bool)1;

  else
  {
    return_value_miredo_conf_get_int16_11=miredo_conf_get_int16(conf, "BindPort", &bind_port, (unsigned int *)(void *)0);
    tmp_if_expr_12 = !(return_value_miredo_conf_get_int16_11 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_12)
  {
    char *return_value_dgettext_9;
    return_value_dgettext_9=dgettext("miredo", "Fatal configuration error");
    syslog(1, return_value_dgettext_9);
    return -2;
  }

  bind_port=htons(bind_port);
  char *ifname;
  ifname=miredo_conf_get(conf, "InterfaceName", (unsigned int *)(void *)0);
  miredo_conf_clear(conf, 5);
  signed int privfd = -1;
  struct tun6 *tunnel;
  struct tun6 *tmp_if_expr_15;
  struct tun6 *return_value_create_dynamic_tunnel_13;
  struct tun6 *return_value_create_static_tunnel_14;
  if(!((2 & mode) == 0))
  {
    return_value_create_dynamic_tunnel_13=create_dynamic_tunnel(ifname, &privfd);
    tmp_if_expr_15 = return_value_create_dynamic_tunnel_13;
  }

  else
  {
    return_value_create_static_tunnel_14=create_static_tunnel(ifname, &prefix.ip6, mtu);
    tmp_if_expr_15 = return_value_create_static_tunnel_14;
  }
  tunnel = tmp_if_expr_15;
  if(!(ifname == ((char *)NULL)))
    free((void *)ifname);

  signed int retval = -1;
  if(tunnel == ((struct tun6 *)NULL))
  {
    char *return_value_dgettext_16;
    return_value_dgettext_16=dgettext("miredo", "Miredo setup failure: %s");
    char *return_value_dgettext_17;
    return_value_dgettext_17=dgettext("miredo", "Cannot create IPv6 tunnel");
    syslog(1, return_value_dgettext_16, return_value_dgettext_17);
    return -1;
  }

  signed int return_value_miredo_init_26;
  return_value_miredo_init_26=miredo_init((mode & 2) != 0);
  char *return_value_dgettext_18;
  char *return_value_dgettext_19;
  signed int tmp_if_expr_22;
  signed int return_value_setup_client_20;
  signed int return_value_setup_relay_21;
  char *return_value_dgettext_23;
  char *return_value_dgettext_24;
  if(!(return_value_miredo_init_26 == 0))
  {
    return_value_dgettext_18=dgettext("miredo", "Miredo setup failure: %s");
    return_value_dgettext_19=dgettext("miredo", "libteredo cannot be initialized");
    syslog(1, return_value_dgettext_18, return_value_dgettext_19);
  }

  else
  {
    signed int return_value_drop_privileges_25;
    return_value_drop_privileges_25=drop_privileges();
    if(return_value_drop_privileges_25 == 0)
    {
      struct teredo_tunnel *relay;
      relay=teredo_create(bind_ip, bind_port);
      if(!(relay == ((struct teredo_tunnel *)NULL)))
      {
        struct miredo_tunnel data = { .tunnel=tunnel, .priv_fd=privfd, .relay=relay };
        teredo_set_privdata(relay, (void *)&data);
        teredo_set_recv_callback(relay, miredo_recv_callback);
        teredo_set_icmpv6_callback(relay, miredo_icmp6_callback);
        if(!((2 & mode) == 0))
        {
          return_value_setup_client_20=setup_client(relay, server_name, server_name2);
          tmp_if_expr_22 = return_value_setup_client_20;
        }

        else
        {
          return_value_setup_relay_21=setup_relay(relay, prefix.teredo.prefix, cone);
          tmp_if_expr_22 = return_value_setup_relay_21;
        }
        retval = tmp_if_expr_22;
        if(retval == 0)
          retval=run_tunnel(&data);

        teredo_destroy(relay);
      }

      if(!(retval == 0))
      {
        return_value_dgettext_23=dgettext("miredo", "Miredo setup failure: %s");
        return_value_dgettext_24=dgettext("miredo", "libteredo cannot be initialized");
        syslog(1, return_value_dgettext_23, return_value_dgettext_24);
      }

    }

    miredo_deinit((mode & 2) != 0);
  }
  if(!((2 & mode) == 0))
    destroy_dynamic_tunnel(tunnel, privfd);

  else
    tun6_destroy(tunnel);
  return retval;
}

// run_tunnel
// file relayd.c line 419
static signed int run_tunnel(struct miredo_tunnel *tunnel)
{
  unsigned long int encap_th;
  signed int return_value_teredo_run_async_1;
  return_value_teredo_run_async_1=teredo_run_async(tunnel->relay);
  _Bool tmp_if_expr_3;
  signed int return_value_pthread_create_2;
  if(!(return_value_teredo_run_async_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_pthread_create_2=pthread_create(&encap_th, (const union pthread_attr_t *)(void *)0, miredo_encap_thread, (void *)tunnel);
    tmp_if_expr_3 = return_value_pthread_create_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int literal_4;
  signed int return_value_sigwait_5;
  if(tmp_if_expr_3)
    return -1;

  else
  {
    struct anonymous_29 dummyset;
    struct anonymous_29 set;
    sigemptyset(&dummyset);
    pthread_sigmask(0, &dummyset, &set);
    do
    {
      literal_4 = 0;
      return_value_sigwait_5=sigwait(&set, &literal_4);
      if(return_value_sigwait_5 == 0)
        break;

    }
    while((_Bool)1);
    pthread_cancel(encap_th);
    pthread_join(encap_th, (void **)(void *)0);
    return 0;
  }
}

// setuid_notice
// file main.c line 193
static void setuid_notice(void)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "That is usually an indication that you are trying to start\nthe program as an user with insufficient system privileges.\nThis program should normally be started by root.\n");
  fputs(return_value_dgettext_1, stderr);
}

// setup_client
// file relayd.c line 314
static signed int setup_client(struct teredo_tunnel *client, const char *server, const char *server2)
{
  teredo_set_state_cb(client, miredo_up_callback, miredo_down_callback);
  signed int return_value_teredo_set_client_mode_1;
  return_value_teredo_set_client_mode_1=teredo_set_client_mode(client, server, server2);
  return return_value_teredo_set_client_mode_1;
}

// setup_relay
// file relayd.c line 373
static signed int setup_relay(struct teredo_tunnel *relay, unsigned int prefix, _Bool cone)
{
  teredo_set_prefix(relay, prefix);
  teredo_set_cone_flag(relay, cone);
  signed int return_value_teredo_set_relay_mode_1;
  return_value_teredo_set_relay_mode_1=teredo_set_relay_mode(relay);
  return return_value_teredo_set_relay_mode_1;
}

// strlcpy
// file ../compat/fixups.h line 50
unsigned long int strlcpy(char *tgt, const char *src, unsigned long int bufsize)
{
  unsigned long int length = (unsigned long int)1;
  _Bool tmp_if_expr_1;
  char *tmp_post_2;
  const char *tmp_post_3;
  do
  {
    if(!(length >= bufsize))
      tmp_if_expr_1 = *src != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    tmp_post_2 = tgt;
    tgt = tgt + 1l;
    tmp_post_3 = src;
    src = src + 1l;
    *tmp_post_2 = *tmp_post_3;
    length = length + 1ul;
  }
  while((_Bool)1);
  if(!(bufsize == 0ul))
    *tgt = (char)0;

  const char *tmp_post_4;
  do
  {
    tmp_post_4 = src;
    src = src + 1l;
    if(*tmp_post_4 == 0)
      break;

    length = length + 1ul;
  }
  while((_Bool)1);
  return length - (unsigned long int)1;
}

// teredo_cksum
// file teredo-udp.h line 152
unsigned short int teredo_cksum(const void *src, const void *dst, unsigned char protocol, struct iovec *data, unsigned long int n)
{
  const signed long int teredo_cksum_array_size0 = (signed long int)((unsigned long int)3 + n);
  struct iovec iov[teredo_cksum_array_size0];
  unsigned long int plen = (unsigned long int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= n); i = i + 1ul)
  {
    iov[(signed long int)((unsigned long int)3 + i)].iov_base = (data + (signed long int)i)->iov_base;
    iov[(signed long int)((unsigned long int)3 + i)].iov_len = (data + (signed long int)i)->iov_len;
    plen = plen + iov[(signed long int)((unsigned long int)3 + i)].iov_len;
  }
  unsigned int pseudo[4l];
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)plen);
  unsigned int return_value_htonl_2;
  return_value_htonl_2=htonl((unsigned int)protocol);
  pseudo[0] = return_value_htonl_1;
  pseudo[1] = return_value_htonl_2;
  pseudo[2] = 0u;
  pseudo[3] = 0u;
  iov[(signed long int)0].iov_base = (void *)src;
  iov[(signed long int)0].iov_len = (unsigned long int)16;
  iov[(signed long int)1].iov_base = (void *)dst;
  iov[(signed long int)1].iov_len = (unsigned long int)16;
  iov[(signed long int)2].iov_base = (void *)pseudo;
  iov[(signed long int)2].iov_len = (unsigned long int)8;
  unsigned short int return_value_in_cksum_3;
  return_value_in_cksum_3=in_cksum(iov, (unsigned long int)3 + n);
  return return_value_in_cksum_3;
}

// teredo_cleanup
// file ../libteredo/tunnel.h line 75
void teredo_cleanup(_Bool use_client)
{
  (void)use_client;
  teredo_deinit_HMAC();
}

// teredo_clock
// file clock.h line 46
unsigned long int teredo_clock(void)
{
  unsigned long int value;
  /* tag-#anon#lST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||S32'id'||B'present'||U24'_pad0'|] */
struct anonymous_10
{
  // lock
  union anonymous_9 lock;
  // id
  signed int id;
  // present
  _Bool present;
};

/* */
  ;
  static struct anonymous_10 priv = { .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .id=0,
    .present=(_Bool)0 };
  pthread_mutex_lock(&priv.lock);
  static struct clock_data_t clk = { .handle=NULL, .value=(unsigned long int)0, .active=(_Bool)0 };
  if(priv.present == (_Bool)0)
  {
    struct sigevent ev;
    memset((void *)&ev, 0, sizeof(struct sigevent) /*64ul*/ );
    ev.sigev_notify = 2;
    ev.sigev_value.sival_ptr = (void *)&clk;
    ev._sigev_un._sigev_thread._function = clock_tick;
    struct timespec res;
    signed int return_value_clock_getres_1;
    return_value_clock_getres_1=clock_getres(1, &res);
    if(return_value_clock_getres_1 == 0)
      priv.id = 1;

    signed int return_value_timer_create_2;
    return_value_timer_create_2=timer_create(priv.id, &ev, &clk.handle);
    if(return_value_timer_create_2 == 0)
      priv.present = (_Bool)1;

  }

  if(clk.active == (_Bool)0)
  {
    struct itimerspec it;
    clock_gettime(priv.id, &it.it_value);
    clk.value = (unsigned long int)it.it_value.tv_sec;
    if(!(priv.present == (_Bool)0))
    {
      it.it_value.tv_sec = it.it_value.tv_sec + 1l;
      it.it_value.tv_nsec = (signed long int)0;
      it.it_interval.tv_sec = (signed long int)1;
      it.it_interval.tv_nsec = (signed long int)0;
      clk.active = (_Bool)1;
      timer_settime(clk.handle, 1, &it, (struct itimerspec *)(void *)0);
    }

  }

  value = clk.value;
  pthread_mutex_unlock(&priv.lock);
  return value;
}

// teredo_close
// file teredo-udp.h line 163
void teredo_close(signed int fd)
{
  close(fd);
}

// teredo_create
// file ../libteredo/tunnel.h line 103
struct teredo_tunnel * teredo_create(unsigned int ipv4, unsigned short int port)
{
  struct teredo_tunnel *tunnel;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_tunnel) /*216ul*/ );
  tunnel = (struct teredo_tunnel *)return_value_malloc_1;
  if(tunnel == ((struct teredo_tunnel *)NULL))
    return (struct teredo_tunnel *)(void *)0;

  else
  {
    memset((void *)tunnel, 0, sizeof(struct teredo_tunnel) /*216ul*/ );
    tunnel->state.addr.teredo.prefix=htonl((unsigned int)0x20010000);
    tunnel->state.addr.teredo.client_port = (unsigned short int)~((signed int)port);
    tunnel->state.addr.teredo.client_ip = ~ipv4;
    tunnel->state.up = (_Bool)0;
    tunnel->ratelimit.count = 1;
    tunnel->recv_cb = teredo_dummy_recv_cb;
    tunnel->icmpv6_cb = teredo_dummy_icmpv6_cb;
    tunnel->up_cb = teredo_dummy_state_up_cb;
    tunnel->down_cb = teredo_dummy_state_down_cb;
    tunnel->fd=teredo_socket(ipv4, port);
    if(!(tunnel->fd == -1))
    {
      tunnel->list=teredo_list_create((unsigned int)1048576, (unsigned int)30);
      if(!(tunnel->list == ((struct teredo_peerlist *)NULL)))
      {
        pthread_rwlock_init(&tunnel->state_lock, (const union anonymous_2 *)(void *)0);
        pthread_mutex_init(&tunnel->ratelimit.lock, (const union anonymous_13 *)(void *)0);
        return tunnel;
      }

      teredo_close(tunnel->fd);
    }

    free((void *)tunnel);
    return (struct teredo_tunnel *)(void *)0;
  }
}

// teredo_deinit_HMAC
// file security.h line 35
void teredo_deinit_HMAC(void)
{
  ;
}

// teredo_destroy
// file ../libteredo/tunnel.h line 117
void teredo_destroy(struct teredo_tunnel *t)
{
  if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
    teredo_maintenance_stop(t->maintenance);

  if(!(t->recv.running == (_Bool)0))
  {
    pthread_cancel(t->recv.thread);
    pthread_join(t->recv.thread, (void **)(void *)0);
  }

  teredo_list_destroy(t->list);
  pthread_rwlock_destroy(&t->state_lock);
  pthread_mutex_destroy(&t->ratelimit.lock);
  teredo_close(t->fd);
  free((void *)t);
}

// teredo_dummy_icmpv6_cb
// file relay.c line 852
static void teredo_dummy_icmpv6_cb(void *o, const void *p, unsigned long int l, struct in6_addr *d)
{
  (void)o;
  (void)p;
  (void)l;
  (void)d;
}

// teredo_dummy_recv_cb
// file relay.c line 844
static void teredo_dummy_recv_cb(void *o, const void *p, unsigned long int l)
{
  (void)o;
  (void)p;
  (void)l;
}

// teredo_dummy_state_down_cb
// file relay.c line 872
static void teredo_dummy_state_down_cb(void *o)
{
  (void)o;
}

// teredo_dummy_state_up_cb
// file relay.c line 863
static void teredo_dummy_state_up_cb(void *o, struct in6_addr *a, unsigned short int m)
{
  (void)o;
  (void)a;
  (void)m;
}

// teredo_encap
// file relay.c line 311
static signed int teredo_encap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned long int now)
{
  unsigned int ipv4 = peer->mapped_addr;
  unsigned short int port = peer->mapped_port;
  TouchTransmit(peer, now);
  teredo_list_release(tunnel->list);
  signed int return_value_teredo_send_1;
  return_value_teredo_send_1=teredo_send(tunnel->fd, data, len, ipv4, port);
  return return_value_teredo_send_1 == (signed int)len ? 0 : -1;
}

// teredo_enqueue_in
// file peerlist.h line 52
void teredo_enqueue_in(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port)
{
  teredo_peer_queue(peer, data, len, ip, port, (_Bool)1);
}

// teredo_enqueue_out
// file peerlist.h line 55
void teredo_enqueue_out(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len)
{
  teredo_peer_queue(peer, data, len, (unsigned int)0, (unsigned short int)0, (_Bool)0);
}

// teredo_get_flbits
// file security.c line 226
unsigned short int teredo_get_flbits(unsigned int timestamp)
{
  unsigned char buf[16l];
  teredo_hash((void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, buf, timestamp);
  return (unsigned short int)((signed int)buf[(signed long int)0] << 8 | (signed int)buf[(signed long int)1]);
}

// teredo_get_nonce
// file security.c line 241
void teredo_get_nonce(unsigned int timestamp, unsigned int ipv4, unsigned short int port, unsigned char * restrict nonce)
{
  unsigned char buf[16l];
  teredo_hash((const void *)&ipv4, (unsigned long int)4, (const void *)&port, (unsigned long int)2, buf, timestamp);
  memcpy((void *)nonce, (const void *)buf, (unsigned long int)8);
}

// teredo_get_pinghash
// file security.c line 181
void teredo_get_pinghash(unsigned int timestamp, struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash)
{
  memcpy((void *)hash, (const void *)&hmac_pid, sizeof(unsigned short int) /*2ul*/ );
  hash = hash + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
  timestamp=htonl(timestamp);
  memcpy((void *)hash, (const void *)((unsigned char *)&timestamp + (signed long int)2), (unsigned long int)2);
  hash = hash + (signed long int)2;
  memcpy((void *)hash, (const void *)&timestamp, (unsigned long int)2);
  hash = hash + (signed long int)2;
  teredo_pinghash(src, dst, hash, timestamp);
}

// teredo_get_privdata
// file relay.c line 1105
void * teredo_get_privdata(const struct teredo_tunnel *t)
{
  return t->opaque;
}

// teredo_hash
// file security.c line 126
static void teredo_hash(const void *src, unsigned long int slen, const void *dst, unsigned long int dlen, unsigned char * restrict hash, unsigned int timestamp)
{
  struct md5_state_s ctx;
  md5_init(&ctx);
  md5_append(&ctx, inner_key.ipad, (signed int)sizeof(unsigned char [64l]) /*64ul*/ );
  md5_append(&ctx, (const unsigned char *)src, (signed int)slen);
  md5_append(&ctx, (const unsigned char *)dst, (signed int)dlen);
  md5_append(&ctx, (const unsigned char *)&hmac_pid, (signed int)sizeof(unsigned short int) /*2ul*/ );
  md5_append(&ctx, (const unsigned char *)&timestamp, (signed int)sizeof(unsigned int) /*4ul*/ );
  md5_finish(&ctx, hash);
  md5_init(&ctx);
  md5_append(&ctx, outer_key.opad, (signed int)sizeof(unsigned char [64l]) /*64ul*/ );
  md5_append(&ctx, hash, 16);
  md5_finish(&ctx, hash);
}

// teredo_init_HMAC
// file security.h line 34
signed int teredo_init_HMAC(void)
{
  signed int retval = -1;
  static union anonymous_9 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  pthread_mutex_lock(&mutex);
  signed int return_value_getpid_3;
  return_value_getpid_3=getpid();
  unsigned short int return_value_htons_4;
  return_value_htons_4=htons((unsigned short int)return_value_getpid_3);
  if(!(hmac_pid == return_value_htons_4))
  {
    signed int fd;
    fd=open(randfile, 00);
    if(fd == -1)
      goto error;

    memset((void *)&inner_key, 0, sizeof(union anonymous_4) /*64ul*/ );
    unsigned int len = (unsigned int)0;
    while(!(len >= 16u))
    {
      signed int val;
      signed long int return_value_read_1;
      return_value_read_1=read(fd, (void *)(inner_key.key + (signed long int)len), (unsigned long int)((unsigned int)16 - len));
      val = (signed int)return_value_read_1;
      if(val >= 1)
        len = len - (unsigned int)val;

    }
    close(fd);
    memcpy((void *)&outer_key, (const void *)&inner_key, sizeof(union anonymous_5) /*64ul*/ );
    unsigned int i = (unsigned int)0;
    for( ; !((unsigned long int)i >= sizeof(union anonymous_4) /*64ul*/ ); i = i + 1u)
    {
      inner_key.ipad[(signed long int)i] = inner_key.ipad[(signed long int)i] ^ (unsigned char)0x36;
      outer_key.opad[(signed long int)i] = outer_key.opad[(signed long int)i] ^ (unsigned char)0x5c;
    }
    signed int return_value_getpid_2;
    return_value_getpid_2=getpid();
    hmac_pid=htons((unsigned short int)return_value_getpid_2);
  }

  retval = 0;

error:
  ;
  pthread_mutex_unlock(&mutex);
  return retval;
}

// teredo_list_create
// file peerlist.h line 106
struct teredo_peerlist * teredo_list_create(unsigned int max, unsigned int expiration)
{
  struct teredo_peerlist *l;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_peerlist) /*80ul*/ );
  l = (struct teredo_peerlist *)return_value_malloc_1;
  if(l == ((struct teredo_peerlist *)NULL))
    return (struct teredo_peerlist *)(void *)0;

  else
  {
    memset((void *)l, 0, sizeof(struct teredo_peerlist *) /*8ul*/ );
    pthread_mutex_init(&l->lock, (const union anonymous_13 *)(void *)0);
    l->old = (struct teredo_listitem *)(void *)0;
    l->recent = l->old;
    l->left = max;
    l->expiration = expiration;
    l->PJHSArray = (void *)0;
    signed int return_value_pthread_create_2;
    return_value_pthread_create_2=pthread_create(&l->gc, (const union pthread_attr_t *)(void *)0, garbage_collector, (void *)l);
    if(!(return_value_pthread_create_2 == 0))
    {
      pthread_mutex_destroy(&l->lock);
      free((void *)l);
      return (struct teredo_peerlist *)(void *)0;
    }

    else
      return l;
  }
}

// teredo_list_destroy
// file peerlist.h line 113
void teredo_list_destroy(struct teredo_peerlist *l)
{
  teredo_list_reset(l, (unsigned int)0);
  pthread_cancel(l->gc);
  pthread_join(l->gc, (void **)(void *)0);
  pthread_mutex_destroy(&l->lock);
  free((void *)l);
}

// teredo_list_lookup
// file peerlist.h line 141
struct teredo_peer * teredo_list_lookup(struct teredo_peerlist * restrict list, struct in6_addr * restrict addr, _Bool * restrict create)
{
  struct teredo_listitem *p;
  pthread_mutex_lock(&list->lock);
  struct teredo_listitem **pp = (struct teredo_listitem **)(void *)0;
  void *PValue;
  struct teredo_listitem *tmp_if_expr_3;
  if(!(create == ((_Bool *)NULL)))
  {
    struct J_UDY_ERROR_STRUCT J_Error;
    void **return_value_JudyHSIns_1;
    return_value_JudyHSIns_1=JudyHSIns(&list->PJHSArray, (void *)(unsigned char *)addr, (unsigned long int)16, &J_Error);
    PValue = (void *)return_value_JudyHSIns_1;
    if(PValue == (void *)18446744073709551615ul)
    {
      fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 376, (const void *)"JudyHSIns", (&J_Error)->je_Errno, (&J_Error)->je_ErrID);
      exit(1);
    }

    if(PValue == (void *)18446744073709551615ul)
      goto error;

    pp = (struct teredo_listitem **)PValue;
    p = *pp;
  }

  else
  {
    void **return_value_JudyHSGet_2;
    return_value_JudyHSGet_2=JudyHSGet(list->PJHSArray, (void *)(unsigned char *)addr, (unsigned long int)16);
    PValue = (void *)return_value_JudyHSGet_2;
    pp = (struct teredo_listitem **)PValue;
    if(!(pp == ((struct teredo_listitem **)NULL)))
      tmp_if_expr_3 = *pp;

    else
      tmp_if_expr_3 = (struct teredo_listitem *)(void *)0;
    p = tmp_if_expr_3;
  }
  if(!(p == ((struct teredo_listitem *)NULL)))
  {
    if(!(create == ((_Bool *)NULL)))
      *create = (_Bool)0;

    if(!(list->recent == p))
    {
      if(!(p->next == ((struct teredo_listitem *)NULL)))
        p->next->pprev = p->pprev;

      *p->pprev = p->next;
      p->next = list->recent;
      if(!(p->next == ((struct teredo_listitem *)NULL)))
        p->next->pprev = &p->next;

      list->recent = p;
      p->pprev = &list->recent;
    }

    return &p->peer;
  }

  else
    if(!(create == ((_Bool *)NULL)))
    {
      *create = (_Bool)1;
      if(list->left >= 1u)
        p=listitem_create();

      if(p == ((struct teredo_listitem *)NULL))
      {
        signed int Rc_int;
        struct J_UDY_ERROR_STRUCT teredo_list_lookup__1__3__1__J_Error;
        Rc_int=JudyHSDel(&list->PJHSArray, (void *)(unsigned char *)addr, sizeof(struct in6_addr) /*16ul*/ , &teredo_list_lookup__1__3__1__J_Error);
        if(Rc_int == -1)
        {
          fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 453, (const void *)"JudyHSDel", (&teredo_list_lookup__1__3__1__J_Error)->je_Errno, (&teredo_list_lookup__1__3__1__J_Error)->je_ErrID);
          exit(1);
        }

        goto error;
      }

      p->next = list->recent;
      if(!(p->next == ((struct teredo_listitem *)NULL)))
        p->next->pprev = &p->next;

      p->pprev = &list->recent;
      list->recent = p;
      p->pprev = &list->recent;
      list->left = list->left - 1u;
      *pp = p;
      p->key.ip6 = *addr;
      return &p->peer;
    }

    else
    {

    error:
      ;
      pthread_mutex_unlock(&list->lock);
      return (struct teredo_peer *)(void *)0;
    }
}

// teredo_list_release
// file peerlist.h line 149
void teredo_list_release(struct teredo_peerlist *l)
{
  pthread_mutex_unlock(&l->lock);
}

// teredo_list_reset
// file peerlist.h line 122
void teredo_list_reset(struct teredo_peerlist *l, unsigned int max)
{
  pthread_mutex_lock(&l->lock);
  void *array = l->PJHSArray;
  l->PJHSArray = (void *)0;
  struct teredo_listitem *recent = l->recent;
  struct teredo_listitem *old = l->old;
  l->old = (struct teredo_listitem *)(void *)0;
  l->recent = l->old;
  l->left = max;
  pthread_mutex_unlock(&l->lock);
  listitem_recdestroy(old);
  listitem_recdestroy(recent);
  signed long int Rc_word;
  struct J_UDY_ERROR_STRUCT J_Error;
  unsigned long int return_value_JudyHSFreeArray_1;
  return_value_JudyHSFreeArray_1=JudyHSFreeArray(&array, &J_Error);
  Rc_word = (signed long int)return_value_JudyHSFreeArray_1;
  if(Rc_word == -1l)
  {
    fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 340, (const void *)"JudyHSFreeArray", (&J_Error)->je_Errno, (&J_Error)->je_ErrID);
    exit(1);
  }

}

// teredo_maintenance_process
// file maintain.h line 98
signed int teredo_maintenance_process(struct teredo_maintenance * restrict m, const struct teredo_packet * restrict packet)
{
  unsigned short int return_value_htons_1;
  return_value_htons_1=htons((unsigned short int)3544);
  _Bool tmp_if_expr_2;
  if(!(packet->source_port == return_value_htons_1))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(packet->auth_present != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  _Bool tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_2)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    struct in6_addr *__a = (struct in6_addr *)&packet->ip6->ip6_dst;
    struct in6_addr *__b = (struct in6_addr *)&teredo_restrict;
    if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
      tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    tmp_statement_expression_3 = tmp_if_expr_6;
    tmp_if_expr_7 = !tmp_statement_expression_3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
    return -1;

  else
  {
    pthread_mutex_lock(&m->outer);
    pthread_mutex_lock(&m->inner);
    m->incoming = packet;
    pthread_cond_signal(&m->received);
    do
      pthread_cond_wait(&m->processed, &m->inner);
    while(!(m->incoming == ((const struct teredo_packet *)NULL)));
    pthread_mutex_unlock(&m->inner);
    pthread_mutex_unlock(&m->outer);
    return 0;
  }
}

// teredo_maintenance_start
// file maintain.h line 78
struct teredo_maintenance * teredo_maintenance_start(signed int fd, void (*cb)(struct teredo_state *, void *), void *opaque, const char *s1, const char *s2, unsigned int q_sec, unsigned int q_retries, unsigned int refresh_sec, unsigned int restart_sec)
{
  struct teredo_maintenance *m;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_maintenance) /*264ul*/ );
  m = (struct teredo_maintenance *)return_value_malloc_1;
  if(m == ((struct teredo_maintenance *)NULL))
    return (struct teredo_maintenance *)(void *)0;

  else
  {
    memset((void *)m, 0, sizeof(struct teredo_maintenance) /*264ul*/ );
    m->fd = fd;
    m->state.cb = cb;
    m->state.opaque = opaque;
    m->server=strdup(s1);
    (void)s2;
    m->qualification_delay = (_Bool)q_sec ? q_sec : QualificationDelay;
    m->qualification_retries = (_Bool)q_retries ? q_retries : QualificationRetries;
    m->refresh_delay = (_Bool)refresh_sec ? refresh_sec : RefreshDelay;
    m->restart_delay = (_Bool)restart_sec ? restart_sec : RestartDelay;
    if(m->server == ((char *)NULL))
    {
      free((void *)m);
      return (struct teredo_maintenance *)(void *)0;
    }

    else
    {
      union anonymous_13 attr;
      pthread_condattr_init(&attr);
      pthread_condattr_setclock(&attr, 1);
      pthread_cond_init(&m->received, &attr);
      pthread_condattr_destroy(&attr);
    }
    pthread_cond_init(&m->processed, (const union anonymous_13 *)(void *)0);
    pthread_mutex_init(&m->outer, (const union anonymous_13 *)(void *)0);
    pthread_mutex_init(&m->inner, (const union anonymous_13 *)(void *)0);
    signed int err;
    err=pthread_create(&m->thread, (const union pthread_attr_t *)(void *)0, do_maintenance, (void *)m);
    if(err == 0)
      return m;

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = err;
      char *return_value_dgettext_3;
      return_value_dgettext_3=dgettext("miredo", "Error (%s): %m");
      syslog(1, return_value_dgettext_3, (const void *)"pthread_create");
      pthread_cond_destroy(&m->processed);
      pthread_cond_destroy(&m->received);
      pthread_mutex_destroy(&m->outer);
      pthread_mutex_destroy(&m->inner);
      free((void *)m->server);
      free((void *)m);
      return (struct teredo_maintenance *)(void *)0;
    }
  }
}

// teredo_maintenance_stop
// file maintain.h line 89
void teredo_maintenance_stop(struct teredo_maintenance *m)
{
  pthread_cancel(m->thread);
  pthread_join(m->thread, (void **)(void *)0);
  pthread_cond_destroy(&m->processed);
  pthread_cond_destroy(&m->received);
  pthread_mutex_destroy(&m->inner);
  pthread_mutex_destroy(&m->outer);
  free((void *)m->server);
  free((void *)m);
}

// teredo_parse_ra
// file packets.c line 158
signed int teredo_parse_ra(const struct teredo_packet * restrict packet, union teredo_addr * restrict newaddr, _Bool cone, unsigned short int * restrict mtu)
{
  _Bool tmp_statement_expression_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  struct nd_opt_prefix_info *pi;
  _Bool tmp_if_expr_8;
  struct nd_opt_mtu *mo;
  signed int tmp_if_expr_12;
  unsigned short int return_value_htons_11;
  if(packet->orig_ipv4 == 0u)
    return -1;

  else
  {
    struct ip6_hdr *ip6 = packet->ip6;
    unsigned long int length;
    unsigned short int return_value_ntohs_1;
    return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
    length = (unsigned long int)return_value_ntohs_1;
    struct in6_addr *__a = (struct in6_addr *)&ip6->ip6_dst;
    struct in6_addr *__b = (struct in6_addr *)(cone != (_Bool)0 ? &teredo_cone : &teredo_restrict);
    if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
      tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_statement_expression_2 = tmp_if_expr_5;
    if(!tmp_statement_expression_2)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58 ? (_Bool)1 : (_Bool)0;
    if(!(length >= sizeof(struct nd_router_advert) /*16ul*/ ) || tmp_if_expr_6)
      return -1;

    else
    {
      struct nd_router_advert *ra = (struct nd_router_advert *)(ip6 + (signed long int)1);
      length = length - sizeof(struct nd_router_advert) /*16ul*/ ;
      if(!((signed int)ra->nd_ra_hdr.icmp6_type == 134))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)ra->nd_ra_hdr.icmp6_code != 0 ? (_Bool)1 : (_Bool)0;
      if(!(length >= sizeof(struct nd_opt_prefix_info) /*32ul*/ ) || tmp_if_expr_7)
        return -1;

      else
      {
        unsigned int net_mtu = (unsigned int)0;
        newaddr->teredo.server_ip = (unsigned int)0;
        struct nd_opt_hdr *hdr = (struct nd_opt_hdr *)(ra + (signed long int)1);
        for( ; length >= 8ul; hdr = (struct nd_opt_hdr *)((const unsigned char *)hdr + (signed long int)((signed int)hdr->nd_opt_len << 3)))
        {
          unsigned long int optlen = (unsigned long int)((signed int)hdr->nd_opt_len << 3);
          if(optlen == 0ul || !(length >= optlen))
            return -1;

          switch((signed int)hdr->nd_opt_type)
          {
            case 3:
            {
              pi = (struct nd_opt_prefix_info *)hdr;
              if(!(optlen >= sizeof(struct nd_opt_prefix_info) /*32ul*/ ))
                tmp_if_expr_8 = (_Bool)1;

              else
                tmp_if_expr_8 = (signed int)pi->nd_opt_pi_prefix_len != 64 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_8)
                return -1;

              if(!(newaddr->teredo.server_ip == 0u))
              {
                char *return_value_dgettext_9;
                return_value_dgettext_9=dgettext("miredo", "Multiple Teredo prefixes received");
                syslog(3, return_value_dgettext_9);
                return -1;
              }

              memcpy((void *)newaddr, (const void *)&pi->nd_opt_pi_prefix, (unsigned long int)8);
              break;
            }
            case 5:
            {
              mo = (struct nd_opt_mtu *)hdr;
              net_mtu=ntohl(mo->nd_opt_mtu_mtu);
              if(net_mtu >= 65536u || !(net_mtu >= 1280u))
                return -1;

            }
          }
          length = length - optlen;
        }
        unsigned int return_value_htonl_10;
        return_value_htonl_10=htonl((unsigned int)0x3ffe831f);
        if(newaddr->teredo.prefix == return_value_htonl_10)
          newaddr->teredo.prefix=htonl((unsigned int)0x20010000);

        if((0xff000000 & newaddr->teredo.prefix) == 0xff000000)
          return -1;

        else
        {
          if(!(cone == (_Bool)0))
          {
            return_value_htons_11=htons((unsigned short int)0x8000);
            tmp_if_expr_12 = (signed int)return_value_htons_11;
          }

          else
            tmp_if_expr_12 = 0;
          newaddr->teredo.flags = (unsigned short int)tmp_if_expr_12;
          newaddr->teredo.client_port = (unsigned short int)~((signed int)packet->orig_port);
          newaddr->teredo.client_ip = ~packet->orig_ipv4;
          if(!(net_mtu == 0u))
            *mtu = (unsigned short int)net_mtu;

          return 0;
        }
      }
    }
  }
}

// teredo_peer_destroy
// file peerlist.c line 77
static inline void teredo_peer_destroy(struct teredo_peer *peer)
{
  struct teredo_queue *p = peer->queue;
  while(!(p == ((struct teredo_queue *)NULL)))
  {
    struct teredo_queue *buf = p->next;
    free((void *)p);
    p = buf;
  }
}

// teredo_peer_init
// file peerlist.c line 70
static inline void teredo_peer_init(struct teredo_peer *peer)
{
  peer->queue = (struct teredo_queue *)(void *)0;
  peer->queue_left = (unsigned long int)teredo_MaxQueueBytes;
}

// teredo_peer_queue
// file peerlist.c line 92
static void teredo_peer_queue(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port, _Bool incoming)
{
  struct teredo_queue *p;
  if(peer->queue_left >= len)
  {
    peer->queue_left = peer->queue_left - len;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct teredo_queue) /*24ul*/  + len);
    p = (struct teredo_queue *)return_value_malloc_1;
    p->length = len;
    memcpy((void *)p->data, data, len);
    p->ipv4 = ip;
    p->port = port;
    p->incoming = incoming;
    p->next = peer->queue;
    peer->queue = p;
  }

}

// teredo_peer_queue_yield
// file peerlist.h line 57
struct teredo_queue * teredo_peer_queue_yield(struct teredo_peer *peer)
{
  struct teredo_queue *q = peer->queue;
  peer->queue = (struct teredo_queue *)(void *)0;
  peer->queue_left = (unsigned long int)teredo_MaxQueueBytes;
  return q;
}

// teredo_pinghash
// file security.c line 158
static inline void teredo_pinghash(struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash, unsigned int timestamp)
{
  teredo_hash((const void *)src, sizeof(struct in6_addr) /*16ul*/ , (const void *)dst, sizeof(struct in6_addr) /*16ul*/ , hash, timestamp);
}

// teredo_predecap
// file relay.c line 528
static void teredo_predecap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, unsigned long int now)
{
  TouchReceive(peer, now);
  peer->pings = (unsigned int)0;
  peer->bubbles = (unsigned int)peer->pings;
  struct teredo_queue *q;
  q=teredo_peer_queue_yield(peer);
  teredo_list_release(tunnel->list);
  if(!(q == ((struct teredo_queue *)NULL)))
    teredo_queue_emit(q, tunnel->fd, peer->mapped_addr, peer->mapped_port, tunnel->recv_cb, tunnel->opaque);

}

// teredo_queue_emit
// file peerlist.h line 58
void teredo_queue_emit(struct teredo_queue *q, signed int fd, unsigned int ipv4, unsigned short int port, void (*cb)(void *, const void *, unsigned long int), void *opaque)
{
  while(!(q == ((struct teredo_queue *)NULL)))
  {
    struct teredo_queue *buf = q->next;
    if(!(q->incoming == (_Bool)0))
    {
      if(ipv4 == q->ipv4)
      {
        if(port == q->port)
          cb(opaque, (const void *)q->data, q->length);

      }

    }

    else
      teredo_send(fd, (const void *)q->data, q->length, ipv4, port);
    free((void *)q);
    q = buf;
  }
}

// teredo_recv
// file teredo-udp.h line 129
signed int teredo_recv(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_recv_inner_1;
  return_value_teredo_recv_inner_1=teredo_recv_inner(fd, p, 64);
  return return_value_teredo_recv_inner_1;
}

// teredo_recv_inner
// file teredo.c line 173
static signed int teredo_recv_inner(signed int fd, struct teredo_packet *p, signed int flags)
{
  struct sockaddr_in ad;
  char cbuf[32l];
  struct iovec iov = { .iov_base=(void *)p->buf.fill, .iov_len=(unsigned long int)65507 };
  struct msghdr msg = { .msg_name=(void *)&ad, .msg_namelen=(unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , .msg_iov=&iov,
    .msg_iovlen=(unsigned long int)1, .msg_control=(void *)cbuf,
    .msg_controllen=sizeof(char [32l]) /*32ul*/ , .msg_flags=0 };
  signed long int length;
  length=recvmsg(fd, &msg, flags);
  if(length == -1l)
    teredo_recverr(fd);

  struct cmsghdr *tmp_if_expr_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  if(!(length >= 2l))
    return -1;

  else
  {
    p->source_ipv4 = ad.sin_addr.s_addr;
    p->source_port = ad.sin_port;
    p->dest_ipv4 = (unsigned int)0;
    struct cmsghdr *cmsg;
    if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
      tmp_if_expr_1 = (struct cmsghdr *)(&msg)->msg_control;

    else
      tmp_if_expr_1 = (struct cmsghdr *)0;
    cmsg = tmp_if_expr_1;
    while(!(cmsg == ((struct cmsghdr *)NULL)))
    {
      if(cmsg->cmsg_level == 0)
      {
        if(cmsg->cmsg_type == 8)
        {
          struct in_pktinfo *nfo = (struct in_pktinfo *)cmsg->__cmsg_data;
          p->dest_ipv4 = nfo->ipi_addr.s_addr;
        }

      }

      cmsg=__cmsg_nxthdr(&msg, cmsg);
    }
    unsigned char *ptr = p->buf.fill;
    p->auth_present = (_Bool)0;
    p->orig_ipv4 = (unsigned int)0;
    p->orig_port = (unsigned short int)0;
    if((signed int)*ptr == 0)
    {
      if((signed int)ptr[1l] == 1)
      {
        unsigned char id_len;
        unsigned char au_len;
        p->auth_present = (_Bool)1;
        length = length - (signed long int)13;
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)2;
        tmp_post_2 = ptr;
        ptr = ptr + 1l;
        id_len = *tmp_post_2;
        tmp_post_3 = ptr;
        ptr = ptr + 1l;
        au_len = *tmp_post_3;
        length = length - (signed long int)((signed int)id_len + (signed int)au_len);
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)((signed int)id_len + (signed int)au_len);
        memcpy((void *)p->auth_nonce, (const void *)ptr, (unsigned long int)8);
        ptr = ptr + (signed long int)8;
        p->auth_fail = !(!(*ptr != 0));
        ptr = ptr + 1l;
        memmove((void *)p->buf.align, (const void *)ptr, (unsigned long int)length);
        ptr = p->buf.fill;
      }

    }

    if((signed int)*ptr == 0)
    {
      if((signed int)ptr[1l] == 0)
      {
        unsigned int addr;
        unsigned short int port;
        length = length - (signed long int)8;
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)2;
        memcpy((void *)&port, (const void *)ptr, (unsigned long int)2);
        ptr = ptr + (signed long int)2;
        p->orig_port = (unsigned short int)~((signed int)port);
        memcpy((void *)&addr, (const void *)ptr, (unsigned long int)4);
        ptr = ptr + (signed long int)4;
        p->orig_ipv4 = ~addr;
      }

    }

    p->ip6_len = (unsigned long int)length;
    p->ip6 = (struct ip6_hdr *)ptr;
    return 0;
  }
}

// teredo_recv_thread
// file relay.c line 952
static void * teredo_recv_thread(void *t)
{
  struct teredo_tunnel *tunnel = (struct teredo_tunnel *)t;
  do
  {
    struct teredo_packet packet;
    signed int return_value_teredo_wait_recv_1;
    return_value_teredo_wait_recv_1=teredo_wait_recv(tunnel->fd, &packet);
    if(return_value_teredo_wait_recv_1 == 0)
    {
      pthread_setcancelstate(1, (signed int *)(void *)0);
      teredo_run_inner(tunnel, &packet);
      pthread_setcancelstate(0, (signed int *)(void *)0);
    }

  }
  while((_Bool)1);
}

// teredo_recverr
// file teredo.c line 118
static signed long int teredo_recverr(signed int fd)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(fd, &msg, 8192);
  return return_value_recvmsg_1;
}

// teredo_reply_bubble
// file packets.h line 79
static inline signed int teredo_reply_bubble(signed int fd, unsigned int ip, unsigned short int port, struct ip6_hdr *req)
{
  signed int return_value_teredo_send_bubble_1;
  return_value_teredo_send_bubble_1=teredo_send_bubble(fd, ip, port, &req->ip6_dst, &req->ip6_src);
  return return_value_teredo_send_bubble_1;
}

// teredo_run
// file relay.c line 986
void teredo_run(struct teredo_tunnel *tunnel)
{
  struct teredo_packet packet;
  signed int return_value_teredo_recv_1;
  return_value_teredo_recv_1=teredo_recv(tunnel->fd, &packet);
  if(return_value_teredo_recv_1 == 0)
    teredo_run_inner(tunnel, &packet);

}

// teredo_run_async
// file ../libteredo/tunnel.h line 151
signed int teredo_run_async(struct teredo_tunnel *t)
{
  if(!(t->recv.running == (_Bool)0))
    return -1;

  else
  {
    signed int return_value_pthread_create_1;
    return_value_pthread_create_1=pthread_create(&t->recv.thread, (const union pthread_attr_t *)(void *)0, teredo_recv_thread, (void *)t);
    if(!(return_value_pthread_create_1 == 0))
      return -1;

    else
    {
      t->recv.running = (_Bool)1;
      return 0;
    }
  }
}

// teredo_run_inner
// file relay.c line 553
static void teredo_run_inner(struct teredo_tunnel * restrict tunnel, struct teredo_packet * restrict packet)
{
  struct ip6_hdr *ip6 = packet->ip6;
  _Bool tmp_if_expr_2;
  unsigned short int return_value_htons_6;
  _Bool return_value_IsBubble_4;
  signed int return_value_CheckPing_8;
  _Bool tmp_if_expr_17;
  _Bool return_value_IsBubble_14;
  _Bool tmp_if_expr_16;
  signed int return_value_CheckBubble_15;
  _Bool literal_10;
  if(packet->ip6_len >= sizeof(struct ip6_hdr) /*40ul*/ )
  {
    unsigned long int length;
    unsigned short int return_value_ntohs_1;
    return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
    length = sizeof(struct ip6_hdr) /*40ul*/  + (unsigned long int)return_value_ntohs_1;
    if(!((signed int)ip6->ip6_ctlun.ip6_un2_vfc >> 4 == 6))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = length > packet->ip6_len ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      struct teredo_state s;
      pthread_rwlock_rdlock(&tunnel->state_lock);
      s = tunnel->state;
      pthread_rwlock_unlock(&tunnel->state_lock);
      _Bool return_value_IsClient_7;
      return_value_IsClient_7=IsClient(tunnel);
      if(!(return_value_IsClient_7 == (_Bool)0))
      {
        signed int return_value_teredo_maintenance_process_3;
        return_value_teredo_maintenance_process_3=teredo_maintenance_process(tunnel->maintenance, packet);
        if(return_value_teredo_maintenance_process_3 == 0)
          goto __CPROVER_DUMP_L33;

        if(s.up == (_Bool)0)
          goto __CPROVER_DUMP_L33;

        if(packet->source_ipv4 == s.addr.teredo.server_ip)
        {
          return_value_htons_6=htons((unsigned short int)3544);
          if(packet->source_port == return_value_htons_6)
          {
            unsigned int ipv4 = packet->orig_ipv4;
            unsigned short int port = packet->orig_port;
            if(ipv4 == 0u)
            {
              return_value_IsBubble_4=IsBubble(ip6);
              if(!(return_value_IsBubble_4 == (_Bool)0))
              {
                if(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == s.addr.teredo.prefix)
                {
                  ipv4 = (&((union teredo_addr *)&ip6->ip6_src)->teredo)->client_ip ^ 0xffffffff;
                  port = (unsigned short int)((signed int)(&((union teredo_addr *)&ip6->ip6_src)->teredo)->client_port ^ 0xffff);
                }

              }

            }

            if(!(ipv4 == 0u))
            {
              teredo_reply_bubble(tunnel->fd, ipv4, port, ip6);
              _Bool return_value_IsBubble_5;
              return_value_IsBubble_5=IsBubble(ip6);
              if(!(return_value_IsBubble_5 == (_Bool)0))
                goto __CPROVER_DUMP_L33;

            }

          }

        }

        if((0xff & (signed int)ip6->ip6_src.__in6_u.__u6_addr8[0l]) == 0xfe)
        {
          if((0xc0 & (signed int)ip6->ip6_src.__in6_u.__u6_addr8[1l]) == 0x80)
            goto __CPROVER_DUMP_L33;

        }

      }

      else
        if(!(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == s.addr.teredo.prefix))
          goto __CPROVER_DUMP_L33;

      if(!((signed int)ip6->ip6_dst.__in6_u.__u6_addr8[0l] == 0xff))
      {
        unsigned long int now;
        now=teredo_clock();
        struct teredo_peerlist *list = tunnel->list;
        struct teredo_peer *p;
        p=teredo_list_lookup(list, &ip6->ip6_src, (_Bool *)(void *)0);
        if(!(p == ((struct teredo_peer *)NULL)))
        {
          if(!(p->trusted == 0u))
          {
            if(packet->source_ipv4 == p->mapped_addr)
            {
              if(packet->source_port == p->mapped_port)
              {
                teredo_predecap(tunnel, p, now);
                tunnel->recv_cb(tunnel->opaque, (const void *)ip6, length);
              }

            }

          }

          _Bool return_value_IsClient_9;
          return_value_IsClient_9=IsClient(tunnel);
          if(!(return_value_IsClient_9 == (_Bool)0))
          {
            return_value_CheckPing_8=CheckPing(packet);
            if(return_value_CheckPing_8 == 0)
            {
              p->trusted = (unsigned int)1;
              SetMappingFromPacket(p, packet);
              teredo_predecap(tunnel, p, now);
              goto __CPROVER_DUMP_L33;
            }

          }

        }

        if(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == s.addr.teredo.prefix)
        {
          signed int return_value_in6_matches_teredo_client_13;
          return_value_in6_matches_teredo_client_13=in6_matches_teredo_client(&ip6->ip6_src, packet->source_ipv4, packet->source_port);
          if(!(return_value_in6_matches_teredo_client_13 == 0))
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            return_value_IsBubble_14=IsBubble(ip6);
            if(!(return_value_IsBubble_14 == (_Bool)0))
            {
              return_value_CheckBubble_15=CheckBubble(packet);
              tmp_if_expr_16 = return_value_CheckBubble_15 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_16 = (_Bool)0;
            tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_17)
          {
            _Bool return_value_IsClient_11;
            return_value_IsClient_11=IsClient(tunnel);
            if(!(return_value_IsClient_11 == (_Bool)0))
            {
              if(p == ((struct teredo_peer *)NULL))
              {
                literal_10 = (_Bool)0;
                p=teredo_list_lookup(list, &ip6->ip6_src, &literal_10);
              }

            }

            if(p == ((struct teredo_peer *)NULL))
              goto __CPROVER_DUMP_L33;

            SetMappingFromPacket(p, packet);
            p->trusted = (unsigned int)1;
            teredo_predecap(tunnel, p, now);
            _Bool return_value_IsBubble_12;
            return_value_IsBubble_12=IsBubble(ip6);
            if(return_value_IsBubble_12 == (_Bool)0)
              tunnel->recv_cb(tunnel->opaque, (const void *)ip6, length);

            goto __CPROVER_DUMP_L33;
          }

        }

        else
        {
          if(p == ((struct teredo_peer *)NULL))
          {
            _Bool create;
            p=teredo_list_lookup(list, &ip6->ip6_src, &create);
            if(p == ((struct teredo_peer *)NULL))
              goto __CPROVER_DUMP_L33;

            if(!(create == (_Bool)0))
            {
              p->mapped_port = (unsigned short int)0;
              p->mapped_addr = (unsigned int)0;
              p->pings = (unsigned int)0;
              p->bubbles = (unsigned int)p->pings;
              p->trusted = (unsigned int)p->bubbles;
            }

          }

          teredo_enqueue_in(p, (const void *)ip6, length, packet->source_ipv4, packet->source_port);
          TouchReceive(p, now);
          signed int res;
          res=CountPing(p, now);
          teredo_list_release(list);
          if(res == 0)
            SendPing(tunnel->fd, &s.addr, &ip6->ip6_src);

          goto __CPROVER_DUMP_L33;
        }
        if(!(p == ((struct teredo_peer *)NULL)))
          teredo_list_release(list);

      }

    }

  }


__CPROVER_DUMP_L33:
  ;
}

// teredo_send
// file teredo-udp.h line 98
signed int teredo_send(signed int fd, const void *packet, unsigned long int plen, unsigned int dest_ip, unsigned short int dest_port)
{
  struct iovec iov = { .iov_base=(void *)packet, .iov_len=plen };
  signed int return_value_teredo_sendv_1;
  return_value_teredo_sendv_1=teredo_sendv(fd, &iov, (unsigned long int)1, dest_ip, dest_port);
  return return_value_teredo_sendv_1;
}

// teredo_send_bubble
// file packets.h line 75
signed int teredo_send_bubble(signed int fd, unsigned int ip, unsigned short int port, struct in6_addr *src, struct in6_addr *dst)
{
  signed int return_value_is_ipv4_global_unicast_2;
  return_value_is_ipv4_global_unicast_2=is_ipv4_global_unicast(ip);
  if(!(return_value_is_ipv4_global_unicast_2 == 0))
  {
    static const unsigned char head[9l] = { '`', 0, 0, 0, 0, 0, ';', 0, 0 };
    struct iovec iov[3l] = { { .iov_base=(void *)head, .iov_len=(unsigned long int)8 },
    { .iov_base=(void *)src, .iov_len=(unsigned long int)16 },
    { .iov_base=(void *)dst, .iov_len=(unsigned long int)16 } };
    signed int return_value_teredo_sendv_1;
    return_value_teredo_sendv_1=teredo_sendv(fd, iov, (unsigned long int)3, ip, port);
    return return_value_teredo_sendv_1 == 40 ? 0 : -1;
  }

  return 0;
}

// teredo_send_rs
// file packets.c line 119
signed int teredo_send_rs(signed int fd, unsigned int server_ip, const unsigned char *nonce, _Bool cone)
{
  unsigned char auth[13l] = { (unsigned char)0, (unsigned char)1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  /* tag-#anon#lST[lSYM#tag-ip6_hdr#'ip6'||lSYM#tag-nd_router_solicit#'rs'|] */
struct anonymous_7
{
  // ip6
  struct ip6_hdr ip6;
  // rs
  struct nd_router_solicit rs;
};

/* */
  ;
  struct anonymous_7 rs;
  struct iovec iov[2l] = { { .iov_base=(void *)auth, .iov_len=(unsigned long int)13 },
    { .iov_base=(void *)&rs, .iov_len=sizeof(struct anonymous_7) /*48ul*/  } };
  memcpy((void *)(auth + (signed long int)4), (const void *)nonce, (unsigned long int)8);
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow=htonl((unsigned int)0x60000000);
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(sizeof(struct anonymous_7) /*48ul*/  - sizeof(struct ip6_hdr) /*40ul*/ ));
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
  rs.ip6.ip6_src = cone != (_Bool)0 ? teredo_cone : teredo_restrict;
  rs.ip6.ip6_dst = in6addr_allrouters;
  rs.rs.nd_rs_hdr.icmp6_type = (unsigned char)133;
  rs.rs.nd_rs_hdr.icmp6_code = (unsigned char)0;
  signed int tmp_if_expr_3;
  unsigned short int return_value_htons_1;
  unsigned short int return_value_htons_2;
  if(!(cone == (_Bool)0))
  {
    return_value_htons_1=htons((unsigned short int)0x125d);
    tmp_if_expr_3 = (signed int)return_value_htons_1;
  }

  else
  {
    return_value_htons_2=htons((unsigned short int)0x7d37);
    tmp_if_expr_3 = (signed int)return_value_htons_2;
  }
  rs.rs.nd_rs_hdr.icmp6_cksum = (unsigned short int)tmp_if_expr_3;
  rs.rs.nd_rs_hdr.icmp6_dataun.icmp6_un_data32[(signed long int)0] = (unsigned int)0;
  unsigned short int return_value_htons_4;
  return_value_htons_4=htons((unsigned short int)3544);
  signed int return_value_teredo_sendv_5;
  return_value_teredo_sendv_5=teredo_sendv(fd, iov, sizeof(struct iovec [2l]) /*32ul*/  / sizeof(struct iovec) /*16ul*/ , server_ip, return_value_htons_4);
  return return_value_teredo_sendv_5 > 0 ? 0 : -1;
}

// teredo_send_unreach
// file relay.c line 122
static void teredo_send_unreach(struct teredo_tunnel * restrict tunnel, unsigned char code, struct ip6_hdr * restrict in, unsigned long int len)
{
  /* tag-#anon#lST[lSYM#tag-icmp6_hdr#'hdr'||lARR1232{S8}_S8_'fill'|] */
struct anonymous_3
{
  // hdr
  struct icmp6_hdr hdr;
  // fill
  char fill[1232l];
};

/* */
  ;
  struct anonymous_3 buf;
  unsigned long int now;
  now=teredo_clock();
  pthread_mutex_lock(&tunnel->ratelimit.lock);
  if(!(now == tunnel->ratelimit.last))
  {
    tunnel->ratelimit.last = now;
    tunnel->ratelimit.count = 100 != 0 ? (signed int)(1000 / 100) : -1;
  }

  if(tunnel->ratelimit.count == 0)
    pthread_mutex_unlock(&tunnel->ratelimit.lock);

  else
  {
    if(tunnel->ratelimit.count >= 1)
      tunnel->ratelimit.count = tunnel->ratelimit.count - 1;

    pthread_mutex_unlock(&tunnel->ratelimit.lock);
    signed int return_value_BuildICMPv6Error_1;
    return_value_BuildICMPv6Error_1=BuildICMPv6Error(&buf.hdr, (unsigned char)1, code, in, len);
    len = (unsigned long int)return_value_BuildICMPv6Error_1;
    tunnel->icmpv6_cb(tunnel->opaque, (const void *)&buf.hdr, len, &in->ip6_src);
  }
}

// teredo_sendv
// file teredo-udp.h line 113
signed int teredo_sendv(signed int fd, struct iovec *iov, unsigned long int count, unsigned int dest_ip, unsigned short int dest_port)
{
  struct sockaddr_in addr = { .sin_family=(unsigned short int)2, .sin_port=dest_port, .sin_addr={ .s_addr=dest_ip },
    .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } };
  struct msghdr msg = { .msg_name=(void *)&addr, .msg_namelen=(unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , .msg_iov=(struct iovec *)iov,
    .msg_iovlen=count, .msg_control=NULL,
    .msg_controllen=0ul, .msg_flags=0 };
  signed long int res;
  _Bool tmp_if_expr_2;
  signed long int return_value_teredo_recverr_1;
  do
  {
    res=sendmsg(fd, &msg, 0);
    if(res == -1l)
    {
      return_value_teredo_recverr_1=teredo_recverr(fd);
      tmp_if_expr_2 = return_value_teredo_recverr_1 != (signed long int)-1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return (signed int)res;
}

// teredo_set_client_mode
// file ../libteredo/tunnel.h line 212
signed int teredo_set_client_mode(struct teredo_tunnel * restrict t, const char *s, const char *s2)
{
  pthread_rwlock_wrlock(&t->state_lock);
  if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
  {
    pthread_rwlock_unlock(&t->state_lock);
    return -1;
  }

  else
  {
    struct teredo_maintenance *m;
    m=teredo_maintenance_start(t->fd, teredo_state_change, (void *)t, s, s2, (unsigned int)0, (unsigned int)0, (unsigned int)0, (unsigned int)0);
    t->maintenance = m;
    pthread_rwlock_unlock(&t->state_lock);
    if(!(m == ((struct teredo_maintenance *)NULL)))
      return 0;

    else
      return -1;
  }
}

// teredo_set_cone_flag
// file ../libteredo/tunnel.h line 181
signed int teredo_set_cone_flag(struct teredo_tunnel *t, _Bool cone)
{
  signed int retval = 0;
  pthread_rwlock_wrlock(&t->state_lock);
  unsigned short int return_value_htons_1;
  unsigned short int return_value_htons_2;
  if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
    retval = -1;

  else
    if(!(cone == (_Bool)0))
    {
      return_value_htons_1=htons((unsigned short int)0x8000);
      t->state.addr.teredo.flags = t->state.addr.teredo.flags | return_value_htons_1;
    }

    else
    {
      return_value_htons_2=htons((unsigned short int)0x8000);
      t->state.addr.teredo.flags = t->state.addr.teredo.flags & (unsigned short int)~((signed int)return_value_htons_2);
    }
  pthread_rwlock_unlock(&t->state_lock);
  return retval;
}

// teredo_set_icmpv6_callback
// file ../libteredo/tunnel.h line 294
void teredo_set_icmpv6_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int, struct in6_addr *))
{
  t->icmpv6_cb = cb != (void (*)(void *, const void *, unsigned long int, struct in6_addr *))(void *)0 ? cb : teredo_dummy_icmpv6_cb;
}

// teredo_set_prefix
// file ../libteredo/tunnel.h line 166
signed int teredo_set_prefix(struct teredo_tunnel *t, unsigned int prefix)
{
  if((0xff000000 & prefix) == 0xff000000)
    return -1;

  else
  {
    signed int retval = 0;
    pthread_rwlock_wrlock(&t->state_lock);
    if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
      retval = -1;

    else
      t->state.addr.teredo.prefix = prefix;
    pthread_rwlock_unlock(&t->state_lock);
    return retval;
  }
}

// teredo_set_privdata
// file ../libteredo/tunnel.h line 224
void * teredo_set_privdata(struct teredo_tunnel *t, void *opaque)
{
  void *prev = t->opaque;
  t->opaque = opaque;
  return prev;
}

// teredo_set_recv_callback
// file ../libteredo/tunnel.h line 252
void teredo_set_recv_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int))
{
  t->recv_cb = cb != (void (*)(void *, const void *, unsigned long int))(void *)0 ? cb : teredo_dummy_recv_cb;
}

// teredo_set_relay_mode
// file ../libteredo/tunnel.h line 192
signed int teredo_set_relay_mode(struct teredo_tunnel *t)
{
  signed int retval;
  pthread_rwlock_wrlock(&t->state_lock);
  retval = t->maintenance != (struct teredo_maintenance *)(void *)0 ? -1 : 0;
  pthread_rwlock_unlock(&t->state_lock);
  return retval;
}

// teredo_set_state_cb
// file ../libteredo/tunnel.h line 327
void teredo_set_state_cb(struct teredo_tunnel * restrict t, void (*u)(void *, struct in6_addr *, unsigned short int), void (*d)(void *))
{
  pthread_rwlock_wrlock(&t->state_lock);
  t->up_cb = u != (void (*)(void *, struct in6_addr *, unsigned short int))(void *)0 ? u : teredo_dummy_state_up_cb;
  t->down_cb = d != (void (*)(void *))(void *)0 ? d : teredo_dummy_state_down_cb;
  pthread_rwlock_unlock(&t->state_lock);
}

// teredo_socket
// file teredo-udp.h line 90
signed int teredo_socket(unsigned int bind_ip, unsigned short int port)
{
  struct sockaddr_in myaddr = { .sin_family=(unsigned short int)2, .sin_port=port, .sin_addr={ .s_addr=bind_ip },
    .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int fd;
  fd=socket(2, 2, 17);
  if(fd == -1)
    return -1;

  else
  {
    fcntl(fd, 2, 1);
    signed int return_value_bind_1;
    return_value_bind_1=bind(fd, (struct sockaddr *)&myaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind_1 == 0))
    {
      close(fd);
      return -1;
    }

    else
    {
      signed int literal_2 = 0;
      setsockopt(fd, 0, 10, (const void *)&literal_2, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_3 = 1;
      setsockopt(fd, 0, 11, (const void *)&literal_3, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_4 = 1;
      setsockopt(fd, 0, 8, (const void *)&literal_4, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_5 = 1;
      setsockopt(fd, 0, 33, (const void *)&literal_5, (unsigned int)sizeof(signed int) /*4ul*/ );
      return fd;
    }
  }
}

// teredo_startup
// file ../libteredo/tunnel.h line 65
signed int teredo_startup(_Bool use_client)
{
  bindtextdomain("miredo", "/usr/share/locale");
  (void)use_client;
  signed int return_value_teredo_init_HMAC_1;
  return_value_teredo_init_HMAC_1=teredo_init_HMAC();
  if(return_value_teredo_init_HMAC_1 == 0)
    return 0;

  else
    return -1;
}

// teredo_state_change
// file relay.c line 178
static void teredo_state_change(const struct teredo_state *state, void *self)
{
  struct teredo_tunnel *tunnel = (struct teredo_tunnel *)self;
  pthread_rwlock_wrlock(&tunnel->state_lock);
  _Bool previously_up = tunnel->state.up;
  tunnel->state = *state;
  if(!(tunnel->state.up == (_Bool)0))
  {
    teredo_list_reset(tunnel->list, (unsigned int)1048576);
    tunnel->up_cb(tunnel->opaque, &tunnel->state.addr.ip6, tunnel->state.mtu);
  }

  else
    if(!(previously_up == (_Bool)0))
      tunnel->down_cb(tunnel->opaque);

  pthread_rwlock_unlock(&tunnel->state_lock);
}

// teredo_transmit
// file ../libteredo/tunnel.h line 272
signed int teredo_transmit(struct teredo_tunnel * restrict tunnel, struct ip6_hdr * restrict packet, unsigned long int length)
{
  union teredo_addr *dst = (union teredo_addr *)&packet->ip6_dst;
  _Bool return_value_IsValid_5;
  signed int return_value_teredo_encap_4;
  signed int return_value_SendBubbleFromDst_6;
  if((signed int)dst->ip6.__in6_u.__u6_addr8[0l] == 0xff)
    return 0;

  else
  {
    struct teredo_state s;
    pthread_rwlock_rdlock(&tunnel->state_lock);
    s = tunnel->state;
    pthread_rwlock_unlock(&tunnel->state_lock);
    _Bool return_value_IsClient_1;
    return_value_IsClient_1=IsClient(tunnel);
    if(!(return_value_IsClient_1 == (_Bool)0))
    {
      if(s.up != (_Bool)0)
        goto __CPROVER_DUMP_L2;

      teredo_send_unreach(tunnel, (unsigned char)3, packet, length);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(dst->teredo.prefix == s.addr.teredo.prefix))
      {
        _Bool return_value_IsClient_2;
        return_value_IsClient_2=IsClient(tunnel);
        if(!(return_value_IsClient_2 == (_Bool)0))
        {
          union teredo_addr *src = (union teredo_addr *)&packet->ip6_src;
          if(!(src->teredo.prefix == s.addr.teredo.prefix))
          {
            teredo_send_unreach(tunnel, (unsigned char)1, packet, length);
            return 0;
          }

        }

        else
        {
          teredo_send_unreach(tunnel, (unsigned char)3, packet, length);
          return 0;
        }
      }

      else
      {
        unsigned int peer_server = (&((union teredo_addr *)dst)->teredo)->server_ip;
        signed int return_value_is_ipv4_global_unicast_3;
        return_value_is_ipv4_global_unicast_3=is_ipv4_global_unicast(peer_server);
        if(return_value_is_ipv4_global_unicast_3 == 0 || peer_server == 0u)
          return 0;

      }
      _Bool created;
      unsigned long int now;
      now=teredo_clock();
      struct teredo_peerlist *list = tunnel->list;
      struct teredo_peer *p;
      p=teredo_list_lookup(list, &dst->ip6, &created);
      if(p == ((struct teredo_peer *)NULL))
        return -1;

      else
      {
        if(created == (_Bool)0)
        {
          if(!(p->trusted == 0u))
          {
            return_value_IsValid_5=IsValid(p, now);
            if(!(return_value_IsValid_5 == (_Bool)0))
            {
              return_value_teredo_encap_4=teredo_encap(tunnel, p, (const void *)packet, length, now);
              return return_value_teredo_encap_4;
            }

          }

        }

        else
        {
          p->pings = (unsigned int)0;
          p->bubbles = (unsigned int)p->pings;
          p->trusted = (unsigned int)p->bubbles;
        }
        if(!(dst->teredo.prefix == s.addr.teredo.prefix))
        {
          signed int res;
          if(!(created == (_Bool)0))
          {
            p->mapped_port = (unsigned short int)0;
            p->mapped_addr = (unsigned int)0;
          }

          teredo_enqueue_out(p, (const void *)packet, length);
          res=CountPing(p, now);
          teredo_list_release(list);
          if(res == 0)
            res=SendPing(tunnel->fd, &s.addr, &dst->ip6);

          if(res == -1)
            teredo_send_unreach(tunnel, (unsigned char)3, packet, length);

          return 0;
        }

        if(!(created == (_Bool)0))
          SetMapping(p, (&((union teredo_addr *)dst)->teredo)->client_ip ^ 0xffffffff, (unsigned short int)((signed int)(&((union teredo_addr *)dst)->teredo)->client_port ^ 0xffff));

        teredo_enqueue_out(p, (const void *)packet, length);
        signed int teredo_transmit__1__res;
        teredo_transmit__1__res=CountBubble(p, now);
        teredo_list_release(list);
        if(!(teredo_transmit__1__res == 0))
        {
          if(teredo_transmit__1__res == -1)
            goto __CPROVER_DUMP_L20;

        }

        else
        {
          unsigned short int return_value_htons_7;
          return_value_htons_7=htons((unsigned short int)0x8000);
          if(((signed int)s.addr.teredo.flags & (signed int)return_value_htons_7) == 0)
          {
            return_value_SendBubbleFromDst_6=SendBubbleFromDst(tunnel->fd, &dst->ip6, (_Bool)0);
            if(!(return_value_SendBubbleFromDst_6 == 0))
              return -1;

          }

          signed int return_value_SendBubbleFromDst_8;
          return_value_SendBubbleFromDst_8=SendBubbleFromDst(tunnel->fd, &dst->ip6, (_Bool)1);
          return return_value_SendBubbleFromDst_8;

        __CPROVER_DUMP_L20:
          ;
          teredo_send_unreach(tunnel, (unsigned char)3, packet, length);
        }
        return 0;
      }
    }
  }
}

// teredo_verify_pinghash
// file security.c line 199
signed int teredo_verify_pinghash(unsigned int now, struct in6_addr *src, struct in6_addr *dst, const unsigned char * restrict hash)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)hash, (const void *)&hmac_pid, sizeof(unsigned short int) /*2ul*/ );
  if(!(return_value_memcmp_1 == 0))
    return -1;

  else
  {
    hash = hash + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
    unsigned int timestamp;
    memcpy((void *)((unsigned char *)&timestamp + (signed long int)2), (const void *)hash, (unsigned long int)2);
    hash = hash + (signed long int)2;
    memcpy((void *)&timestamp, (const void *)hash, (unsigned long int)2);
    hash = hash + (signed long int)2;
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(timestamp);
    if((now + -return_value_ntohl_2 & 0xffffffff) >= 30u)
      return -1;

    else
    {
      unsigned char h1[16l];
      teredo_pinghash(src, dst, h1, timestamp);
      signed int return_value_memcmp_3;
      return_value_memcmp_3=memcmp((const void *)h1, (const void *)hash, (unsigned long int)16);
      return return_value_memcmp_3 != 0 ? -1 : 0;
    }
  }
}

// teredo_wait_recv
// file teredo-udp.h line 145
signed int teredo_wait_recv(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_recv_inner_1;
  return_value_teredo_recv_inner_1=teredo_recv_inner(fd, p, 0);
  return return_value_teredo_recv_inner_1;
}

// tun6_addAddress
// file ../libtun6/tun6.h line 91
signed int tun6_addAddress(struct tun6 *t, struct in6_addr *addr, unsigned int prefixlen)
{
  signed int res;
  res=_iface_addr(t->reqfd, t->id, (_Bool)1, addr, prefixlen);
  char ifname[16l];
  char *return_value_if_indextoname_1;
  if(res == 0)
  {
    return_value_if_indextoname_1=if_indextoname((unsigned int)t->id, ifname);
    if(!(return_value_if_indextoname_1 == ((char *)NULL)))
    {
      char proc_path[57l] = { '/', 'p', 'r', 'o', 'c', '/', 's', 'y', 's', '/', 'n', 'e', 't', '/', 'i', 'p', 'v', '6', '/', 'c', 'o', 'n', 'f', '/', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      snprintf(proc_path + (signed long int)24, sizeof(char [57l]) /*57ul*/  - (unsigned long int)24, "%s/accept_redirects", (const void *)ifname);
      proc_write_zero(proc_path);
    }

  }

  return res;
}

// tun6_addRoute
// file ../libtun6/tun6.h line 98
signed int tun6_addRoute(struct tun6 *t, struct in6_addr *addr, unsigned int prefix_len, signed int rel_metric)
{
  signed int return_value__iface_route_1;
  return_value__iface_route_1=_iface_route(t->reqfd, t->id, (_Bool)1, addr, prefix_len, rel_metric);
  return return_value__iface_route_1;
}

// tun6_bringUp
// file ../libtun6/tun6.h line 81
static inline signed int tun6_bringUp(struct tun6 *t)
{
  signed int return_value_tun6_setState_1;
  return_value_tun6_setState_1=tun6_setState(t, (_Bool)1);
  return return_value_tun6_setState_1;
}

// tun6_create
// file ../libtun6/tun6.h line 75
struct tun6 * tun6_create(const char *req_name)
{
  bindtextdomain("miredo", "/usr/share/locale");
  struct tun6 *t;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct tun6) /*12ul*/ );
  t = (struct tun6 *)return_value_malloc_1;
  unsigned long int return_value_strlcpy_2;
  char *return_value_dgettext_5;
  if(t == ((struct tun6 *)NULL))
    return (struct tun6 *)(void *)0;

  else
  {
    memset((void *)t, 0, sizeof(struct tun6) /*12ul*/ );
    signed int reqfd;
    t->reqfd=socket(10, 2, 0);
    reqfd = t->reqfd;
    if(reqfd == -1)
    {
      free((void *)t);
      return (struct tun6 *)(void *)0;
    }

    else
    {
      fcntl(reqfd, 2, 1);
      struct ifreq req = { .ifr_ifrn={ .ifrn_name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, .ifr_ifru={ .ifru_flags=(signed short int)0x0001 } };
      if(!(req_name == ((const char *)NULL)))
      {
        return_value_strlcpy_2=strlcpy(req.ifr_ifrn.ifrn_name, req_name, sizeof(char [16l]) /*16ul*/ );
        if(!(return_value_strlcpy_2 >= sizeof(char [16l]) /*16ul*/ ))
          goto __CPROVER_DUMP_L3;

        free((void *)t);
        return (struct tun6 *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        signed int fd;
        static const char tundev[13l] = { '/', 'd', 'e', 'v', '/', 'n', 'e', 't', '/', 't', 'u', 'n', 0 };
        fd=open(tundev, 02);
        if(fd == -1)
        {
          char *return_value_dgettext_3;
          return_value_dgettext_3=dgettext("miredo", "Tunneling driver error (%s): %m");
          syslog(3, return_value_dgettext_3, (const void *)tundev);
          close(reqfd);
          free((void *)t);
          return (struct tun6 *)(void *)0;
        }

        signed int return_value_ioctl_7;
        return_value_ioctl_7=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(84 << 0 + 8) | (unsigned int)(202 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)&req);
        if(!(return_value_ioctl_7 == 0))
        {
          char *return_value_dgettext_4;
          return_value_dgettext_4=dgettext("miredo", "Tunneling driver error (%s): %m");
          syslog(3, return_value_dgettext_4, (const void *)"TUNSETIFF");
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          if(*return_value___errno_location_6 == 16)
          {
            return_value_dgettext_5=dgettext("miredo", "Please make sure another instance of the program is not already running.");
            syslog(6, return_value_dgettext_5);
          }

          goto error;
        }

        signed int id;
        unsigned int return_value_if_nametoindex_8;
        return_value_if_nametoindex_8=if_nametoindex(req.ifr_ifrn.ifrn_name);
        id = (signed int)return_value_if_nametoindex_8;
        if(!(id == 0))
        {
          fcntl(fd, 2, 1);
          t->id = id;
          t->fd = fd;
          return t;
        }

        else
        {

        error:
          ;
          close(reqfd);
          if(!(fd == -1))
            close(fd);

          char *return_value_dgettext_9;
          return_value_dgettext_9=dgettext("miredo", "%s tunneling interface creation failure");
          syslog(3, return_value_dgettext_9, (const void *)os_driver);
          free((void *)t);
          return (struct tun6 *)(void *)0;
        }
      }
    }
  }
}

// tun6_delAddress
// file tun6.c line 762
signed int tun6_delAddress(struct tun6 *t, struct in6_addr *addr, unsigned int prefixlen)
{
  signed int return_value__iface_addr_1;
  return_value__iface_addr_1=_iface_addr(t->reqfd, t->id, (_Bool)0, addr, prefixlen);
  return return_value__iface_addr_1;
}

// tun6_delRoute
// file tun6.c line 797
signed int tun6_delRoute(struct tun6 *t, struct in6_addr *addr, unsigned int prefix_len, signed int rel_metric)
{
  signed int return_value__iface_route_1;
  return_value__iface_route_1=_iface_route(t->reqfd, t->id, (_Bool)0, addr, prefix_len, rel_metric);
  return return_value__iface_route_1;
}

// tun6_destroy
// file ../libtun6/tun6.h line 76
void tun6_destroy(struct tun6 *t)
{
  tun6_setState(t, (_Bool)0);
  close(t->fd);
  close(t->reqfd);
  free((void *)t);
}

// tun6_driver_diagnose
// file ../libtun6/tun6.h line 66
signed int tun6_driver_diagnose(char *errbuf)
{
  bindtextdomain("miredo", "/usr/share/locale");
  signed int fd;
  fd=socket(10, 2, 0);
  char *return_value_dgettext_2;
  char *return_value_dgettext_3;
  char *return_value_dgettext_4;
  char *return_value_dgettext_5;
  char buf[256l];
  signed int *return_value___errno_location_6;
  char *return_value_dgettext_7;
  if(fd == -1)
  {
    strlcpy(errbuf, "Error: IPv6 stack not available.\n", (unsigned long int)(4096 - 1));
    errbuf[(signed long int)(4096 - 1)] = (char)0;
    return -1;
  }

  else
  {
    close(fd);
    const char tundev[13l] = { '/', 'd', 'e', 'v', '/', 'n', 'e', 't', '/', 't', 'u', 'n', 0 };
    fd=open(tundev, 02);
    if(!(fd == -1))
    {
      close(fd);
      snprintf(errbuf, (unsigned long int)4096, "%s tunneling driver found.", (const void *)os_driver);
      return 0;
    }

    else
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      switch(*return_value___errno_location_1)
      {
        case 2:
        {
          return_value_dgettext_2=dgettext("miredo", "Error: %s character device not found or unavailable.\n%s");
          return_value_dgettext_3=dgettext("miredo", "You might try to run this command to load it:\n_ modprobe tun\n(you must be root to do that).\n");
          snprintf(errbuf, (unsigned long int)4096, return_value_dgettext_2, (const void *)tundev, return_value_dgettext_3);
          return -1;
        }
        case 6:

        case 19:
        {
          return_value_dgettext_4=dgettext("miredo", "Error: your operating system does not seem to provide a network tunneling\ndevice driver, which is required.\n%s");
          return_value_dgettext_5=dgettext("miredo", "Make sure your Linux kernel includes the \"Universal TUNTAP driver\"\n(CONFIG_TUN option), possibly as a module.\n");
          snprintf(errbuf, (unsigned long int)4096, return_value_dgettext_4, return_value_dgettext_5);
          return -1;
        }
        default:
        {
          return_value___errno_location_6=__errno_location();
          strerror_r(*return_value___errno_location_6, buf, sizeof(char [256l]) /*256ul*/ );
          return_value_dgettext_7=dgettext("miredo", "Error: cannot open device file %s (%s)\nIPv6 tunneling will not work.\n");
          snprintf(errbuf, (unsigned long int)4096, return_value_dgettext_7, (const void *)tundev, (const void *)buf);
          return -1;
        }
      }
    }
  }
}

// tun6_getId
// file ../libtun6/tun6.h line 78
signed int tun6_getId(const struct tun6 *t)
{
  return t->id;
}

// tun6_recv
// file tun6.c line 896
signed int tun6_recv(struct tun6 *t, const struct anonymous_41 *readset, void *buffer, unsigned long int maxlen)
{
  signed int fd = t->fd;
  if(!(fd >= 1024))
  {
    if((readset->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 11;
      return -1;
    }

  }

  signed int return_value_tun6_recv_inner_2;
  return_value_tun6_recv_inner_2=tun6_recv_inner(fd, buffer, maxlen);
  return return_value_tun6_recv_inner_2;
}

// tun6_recv_inner
// file tun6.c line 866
static inline signed int tun6_recv_inner(signed int fd, void *buffer, unsigned long int maxlen)
{
  struct iovec vect[2l];
  struct anonymous head;
  vect[(signed long int)0].iov_base = (void *)(char *)&head;
  vect[(signed long int)0].iov_len = sizeof(struct anonymous) /*4ul*/ ;
  vect[(signed long int)1].iov_base = (void *)(char *)buffer;
  vect[(signed long int)1].iov_len = maxlen;
  signed int len;
  signed long int return_value_readv_1;
  return_value_readv_1=readv(fd, vect, 2);
  len = (signed int)return_value_readv_1;
  _Bool tmp_if_expr_3;
  unsigned short int return_value_htons_2;
  if(!(len >= (signed int)sizeof(struct anonymous) /*4*/ ))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_htons_2=htons((unsigned short int)0x86DD);
    tmp_if_expr_3 = !(head.proto == return_value_htons_2) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return -1;

  else
    return (signed int)((unsigned long int)len - sizeof(struct anonymous) /*4ul*/ );
}

// tun6_registerReadSet
// file tun6.c line 844
signed int tun6_registerReadSet(const struct tun6 *t, struct anonymous_41 *readset)
{
  if(t->fd >= 1024)
    return -1;

  else
  {
    readset->fds_bits[(signed long int)(t->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = readset->fds_bits[(signed long int)(t->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << t->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    return t->fd;
  }
}

// tun6_send
// file ../libtun6/tun6.h line 109
signed int tun6_send(struct tun6 *t, const void *packet, unsigned long int len)
{
  if(len >= 65536ul)
    return -1;

  else
  {
    struct anonymous head;
    unsigned short int return_value_htons_1;
    return_value_htons_1=htons((unsigned short int)0x86DD);
    head = (struct anonymous){ .flags=(unsigned short int)0, .proto=return_value_htons_1 };
    struct iovec vect[2l];
    vect[(signed long int)0].iov_base = (void *)(char *)&head;
    vect[(signed long int)0].iov_len = sizeof(struct anonymous) /*4ul*/ ;
    vect[(signed long int)1].iov_base = (void *)(char *)packet;
    vect[(signed long int)1].iov_len = len;
    signed int val;
    signed long int return_value_writev_2;
    return_value_writev_2=writev(t->fd, vect, 2);
    val = (signed int)return_value_writev_2;
    if(val == -1)
      return -1;

    else
    {
      val = val - (signed int)sizeof(struct anonymous) /*4ul*/ ;
      if(!(val >= 0))
        return -1;

      else
        return val;
    }
  }
}

// tun6_setMTU
// file ../libtun6/tun6.h line 96
signed int tun6_setMTU(struct tun6 *t, unsigned int mtu)
{
  if(mtu >= 65536u || !(mtu >= 1280u))
    return -1;

  else
  {
    struct ifreq req = { .ifr_ifrn={ .ifrn_name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, .ifr_ifru={ .ifru_mtu=(signed int)mtu } };
    char *return_value_if_indextoname_1;
    return_value_if_indextoname_1=if_indextoname((unsigned int)t->id, req.ifr_ifrn.ifrn_name);
    if(return_value_if_indextoname_1 == ((char *)NULL))
      return -1;

    else
    {
      signed int return_value_ioctl_2;
      return_value_ioctl_2=ioctl(t->reqfd, (unsigned long int)0x8922, &req);
      return return_value_ioctl_2 != 0 ? -1 : 0;
    }
  }
}

// tun6_setState
// file ../libtun6/tun6.h line 80
signed int tun6_setState(struct tun6 *t, _Bool up)
{
  struct ifreq req;
  memset((void *)&req, 0, sizeof(struct ifreq) /*40ul*/ );
  char *return_value_if_indextoname_1;
  return_value_if_indextoname_1=if_indextoname((unsigned int)t->id, req.ifr_ifrn.ifrn_name);
  _Bool tmp_if_expr_3;
  signed int return_value_ioctl_2;
  if(return_value_if_indextoname_1 == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_ioctl_2=ioctl(t->reqfd, (unsigned long int)0x8913, &req);
    tmp_if_expr_3 = return_value_ioctl_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_6;
  signed int return_value_ioctl_5;
  if(tmp_if_expr_3)
    return -1;

  else
  {
    req.ifr_ifru.ifru_flags = req.ifr_ifru.ifru_flags | (signed short int)128;
    req.ifr_ifru.ifru_flags = req.ifr_ifru.ifru_flags & (signed short int)~(4096 | 2);
    if(!(up == (_Bool)0))
      req.ifr_ifru.ifru_flags = req.ifr_ifru.ifru_flags | (signed short int)(1 | 64);

    else
      req.ifr_ifru.ifru_flags = req.ifr_ifru.ifru_flags & (signed short int)~(1 | 64);
    char *return_value_if_indextoname_4;
    return_value_if_indextoname_4=if_indextoname((unsigned int)t->id, req.ifr_ifrn.ifrn_name);
    if(return_value_if_indextoname_4 == ((char *)NULL))
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_ioctl_5=ioctl(t->reqfd, (unsigned long int)0x8914, &req);
      tmp_if_expr_6 = return_value_ioctl_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return -1;

    else
      return 0;
  }
}

// tun6_wait_recv
// file ../libtun6/tun6.h line 108
signed int tun6_wait_recv(struct tun6 *t, void *buffer, unsigned long int maxlen)
{
  signed int return_value_tun6_recv_inner_1;
  return_value_tun6_recv_inner_1=tun6_recv_inner(t->fd, buffer, maxlen);
  return return_value_tun6_recv_inner_1;
}

// usage
// file main.c line 73
static signed int usage(const char *path)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Usage: %s [OPTIONS] [SERVER_NAME]\nCreates a Teredo tunneling interface for encapsulation of IPv6 over UDP.\n\n  -c, --config     specify an configuration file\n  -f, --foreground run in the foreground\n  -h, --help       display this help and exit\n  -p, --pidfile    override the location of the PID file\n  -u, --user       override the user to set UID to\n  -V, --version    display program version and exit\n");
  printf(return_value_dgettext_1, path);
  return 0;
}

// wait_reply
// file maintain.c line 163
static signed int wait_reply(struct teredo_maintenance * restrict m, struct timespec * restrict deadline)
{
  while(m->incoming == ((const struct teredo_packet *)NULL))
  {
    signed int return_value_pthread_cond_timedwait_1;
    return_value_pthread_cond_timedwait_1=pthread_cond_timedwait(&m->received, &m->inner, deadline);
    switch(return_value_pthread_cond_timedwait_1)
    {
      case 0:
        goto __CPROVER_DUMP_L4;
      case 110:
        return 110;
      default:

        __CPROVER_DUMP_L4:
          ;
    }
  }
  return 0;
}

// wait_reply_ignore
// file maintain.c line 184
static void wait_reply_ignore(struct teredo_maintenance * restrict m, struct timespec * restrict deadline)
{
  signed int return_value_wait_reply_1;
  do
  {
    return_value_wait_reply_1=wait_reply(m, deadline);
    if(!(return_value_wait_reply_1 == 0))
      break;

    m->incoming = (const struct teredo_packet *)(void *)0;
    pthread_cond_signal(&m->processed);
  }
  while((_Bool)1);
}

