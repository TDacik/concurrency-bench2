// #anon_enum$GDK_ACTION_DEFAULT=1$GDK_ACTION_COPY=2$GDK_ACTION_MOVE=4$GDK_ACTION_LINK=8$GDK_ACTION_PRIVATE=16$GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous$26 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum$GDK_AXIS_IGNORE=0$GDK_AXIS_X=1$GDK_AXIS_Y=2$GDK_AXIS_PRESSURE=3$GDK_AXIS_XTILT=4$GDK_AXIS_YTILT=5$GDK_AXIS_WHEEL=6$GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous$36 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum$GDK_CROSSING_NORMAL=0$GDK_CROSSING_GRAB=1$GDK_CROSSING_UNGRAB=2$GDK_CROSSING_GTK_GRAB=3$GDK_CROSSING_GTK_UNGRAB=4$GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous$43 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum$GDK_DRAG_PROTO_MOTIF=0$GDK_DRAG_PROTO_XDND=1$GDK_DRAG_PROTO_ROOTWIN=2$GDK_DRAG_PROTO_NONE=3$GDK_DRAG_PROTO_WIN32_DROPFILES=4$GDK_DRAG_PROTO_OLE2=5$GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous$27 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum$GDK_FONT_FONT=0$GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous$38 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum$GDK_LSB_FIRST=0$GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous$32 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum$GDK_MODE_DISABLED=0$GDK_MODE_SCREEN=1$GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous$34 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_NO_EXPOSE=30$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous$4 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum$GDK_NOTIFY_ANCESTOR=0$GDK_NOTIFY_VIRTUAL=1$GDK_NOTIFY_INFERIOR=2$GDK_NOTIFY_NONLINEAR=3$GDK_NOTIFY_NONLINEAR_VIRTUAL=4$GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous$44 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum$GDK_OWNER_CHANGE_NEW_OWNER=0$GDK_OWNER_CHANGE_DESTROY=1$GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous$45 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum$GDK_RGB_DITHER_NONE=0$GDK_RGB_DITHER_NORMAL=1$GDK_RGB_DITHER_MAX=2
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 40
enum anonymous$48 { GDK_RGB_DITHER_NONE=0, GDK_RGB_DITHER_NORMAL=1, GDK_RGB_DITHER_MAX=2 };

// #anon_enum$GDK_SCROLL_UP=0$GDK_SCROLL_DOWN=1$GDK_SCROLL_LEFT=2$GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous$40 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum$GDK_SETTING_ACTION_NEW=0$GDK_SETTING_ACTION_CHANGED=1$GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous$54 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum$GDK_SHIFT_MASK=1$GDK_LOCK_MASK=2$GDK_CONTROL_MASK=4$GDK_MOD1_MASK=8$GDK_MOD2_MASK=16$GDK_MOD3_MASK=32$GDK_MOD4_MASK=64$GDK_MOD5_MASK=128$GDK_BUTTON1_MASK=256$GDK_BUTTON2_MASK=512$GDK_BUTTON3_MASK=1024$GDK_BUTTON4_MASK=2048$GDK_BUTTON5_MASK=4096$GDK_SUPER_MASK=67108864$GDK_HYPER_MASK=134217728$GDK_META_MASK=268435456$GDK_RELEASE_MASK=1073741824$GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous$1 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum$GDK_SOURCE_MOUSE=0$GDK_SOURCE_PEN=1$GDK_SOURCE_ERASER=2$GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous$33 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum$GDK_VISIBILITY_UNOBSCURED=0$GDK_VISIBILITY_PARTIAL=1$GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous$37 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum$GDK_VISUAL_STATIC_GRAY=0$GDK_VISUAL_GRAYSCALE=1$GDK_VISUAL_STATIC_COLOR=2$GDK_VISUAL_PSEUDO_COLOR=3$GDK_VISUAL_TRUE_COLOR=4$GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous$31 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum$GDK_WINDOW_STATE_WITHDRAWN=1$GDK_WINDOW_STATE_ICONIFIED=2$GDK_WINDOW_STATE_MAXIMIZED=4$GDK_WINDOW_STATE_STICKY=8$GDK_WINDOW_STATE_FULLSCREEN=16$GDK_WINDOW_STATE_ABOVE=32$GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous$53 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous$17 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_WINDOW_TOPLEVEL=0$GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous$56 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$42 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_IO_FLAG_APPEND=1$G_IO_FLAG_NONBLOCK=2$G_IO_FLAG_IS_READABLE=4$G_IO_FLAG_IS_WRITABLE=8$G_IO_FLAG_IS_WRITEABLE=8$G_IO_FLAG_IS_SEEKABLE=16$G_IO_FLAG_MASK=31$G_IO_FLAG_GET_MASK=31$G_IO_FLAG_SET_MASK=3
// file /usr/include/glib-2.0/glib/giochannel.h line 84
enum anonymous$63 { G_IO_FLAG_APPEND=1, G_IO_FLAG_NONBLOCK=2, G_IO_FLAG_IS_READABLE=4, G_IO_FLAG_IS_WRITABLE=8, G_IO_FLAG_IS_WRITEABLE=8, G_IO_FLAG_IS_SEEKABLE=16, G_IO_FLAG_MASK=31, G_IO_FLAG_GET_MASK=31, G_IO_FLAG_SET_MASK=3 };

// #anon_enum$G_IO_IN=1$G_IO_OUT=4$G_IO_PRI=2$G_IO_ERR=8$G_IO_HUP=16$G_IO_NVAL=32
// file /usr/include/glib-2.0/glib/gmain.h line 31
enum anonymous$62 { G_IO_IN=1, G_IO_OUT=4, G_IO_PRI=2, G_IO_ERR=8, G_IO_HUP=16, G_IO_NVAL=32 };

// #anon_enum$G_IO_STATUS_ERROR=0$G_IO_STATUS_NORMAL=1$G_IO_STATUS_EOF=2$G_IO_STATUS_AGAIN=3
// file /usr/include/glib-2.0/glib/giochannel.h line 69
enum anonymous$60 { G_IO_STATUS_ERROR=0, G_IO_STATUS_NORMAL=1, G_IO_STATUS_EOF=2, G_IO_STATUS_AGAIN=3 };

// #anon_enum$G_SEEK_CUR=0$G_SEEK_SET=1$G_SEEK_END=2
// file /usr/include/glib-2.0/glib/giochannel.h line 77
enum anonymous$61 { G_SEEK_CUR=0, G_SEEK_SET=1, G_SEEK_END=2 };

// #anon_enum$IE_OK=0$IE_SYSERROR=1$IE_NOSTREAM=2$IE_UNKNOWNTYPE=3$IE_HDRFORMAT=4$IE_IMGFORMAT=5
// file img.h line 50
enum anonymous$59 { IE_OK=0, IE_SYSERROR=1, IE_NOSTREAM=2, IE_UNKNOWNTYPE=3, IE_HDRFORMAT=4, IE_IMGFORMAT=5 };

// #anon_enum$JCS_UNKNOWN=0$JCS_GRAYSCALE=1$JCS_RGB=2$JCS_YCbCr=3$JCS_CMYK=4$JCS_YCCK=5$JCS_EXT_RGB=6$JCS_EXT_RGBX=7$JCS_EXT_BGR=8$JCS_EXT_BGRX=9$JCS_EXT_XBGR=10$JCS_EXT_XRGB=11$JCS_EXT_RGBA=12$JCS_EXT_BGRA=13$JCS_EXT_ABGR=14$JCS_EXT_ARGB=15$JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous$18 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum$JDCT_ISLOW=0$JDCT_IFAST=1$JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous$19 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum$JDITHER_NONE=0$JDITHER_ORDERED=1$JDITHER_FS=2
// file /usr/include/jpeglib.h line 259
enum anonymous$20 { JDITHER_NONE=0, JDITHER_ORDERED=1, JDITHER_FS=2 };

// #anon_enum$LOG_ERROR=0$LOG_WARNING=1$LOG_INFO=2
// file log.h line 17
enum anonymous$25 { LOG_ERROR=0, LOG_WARNING=1, LOG_INFO=2 };

// #anon_enum$TMPDIR_APP_OWNED=0$TMPDIR_USER_OWNED=1
// file tmpdir.h line 20
enum anonymous$51 { TMPDIR_APP_OWNED=0, TMPDIR_USER_OWNED=1 };

// #anon_enum$m_chan_stereo=0$m_chan_joint=1$m_chan_dual=2$m_chan_mono=3
// file mpeghdr.h line 38
enum anonymous$50 { m_chan_stereo=0, m_chan_joint=1, m_chan_dual=2, m_chan_mono=3 };

// #anon_enum$m_layer_unknown=0$m_layer_1=1$m_layer_2=2$m_layer_3=3
// file mpeghdr.h line 26
enum anonymous$47 { m_layer_unknown=0, m_layer_1=1, m_layer_2=2, m_layer_3=3 };

// #anon_enum$m_vers_unknown=0$m_vers_1=1$m_vers_2=2$m_vers_2_5=3
// file mpeghdr.h line 25
enum anonymous$46 { m_vers_unknown=0, m_vers_1=1, m_vers_2=2, m_vers_2_5=3 };

// #anon_enum$none=0$header=1$full=2
// file img.h line 48
enum anonymous$58 { none=0, header=1, full=2 };

// #anon_enum$unknown=0$pnm=1$gif=2$jpeg=3$png=4$raw=5
// file img.h line 47
enum anonymous$57 { unknown=0, pnm=1, gif=2, jpeg=3, png=4, raw=5 };

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$13;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$11;

// tag-#anon#ST[*{cS8}$cS8$'path'||EN#anon_enum$TMPDIR_APP_OWNED=0$TMPDIR_USER_OWNED=1#{U32}$U32$'type'||S32'max_files'||S32'preserve_files'||U32'$pad0'|]
// file tmpdir.c line 50
struct anonymous$55;

// tag-#anon#ST[*{cS8}$cS8$'tmpdir'||S32'tmpdir_especified'||S32'max_tmpfiles'||S32'extract_images'||S32'verbose'||S32'adjunct'||S32'beep'||S32'promisc'||U32'$pad0'||*{S8}$S8$'dumpfile'||*{S8}$S8$'interface'||*{S8}$S8$'filterexpr'||ENtag-mediatype#{U32}$U32$'extract_type'||U32'$pad1'||*{S8}$S8$'audio_mpeg_player'||S32'mpeg_player_specified'||S32'newpfx'||*{S8}$S8$'savedimgpfx'|]
// file options.h line 19
struct anonymous$2;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$28;

// tag-#anon#ST[ARR17{U8}$U8$'bits'||ARR256{U8}$U8$'huffval'||U24'$pad0'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 101
struct anonymous$23;

// tag-#anon#ST[ARR64{U16}$U16$'quantval'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 84
struct anonymous$21;

// tag-#anon#ST[S32'component_id'||S32'component_index'||S32'h_samp_factor'||S32'v_samp_factor'||S32'quant_tbl_no'||S32'dc_tbl_no'||S32'ac_tbl_no'||U32'width_in_blocks'||U32'height_in_blocks'||S32'DCT_scaled_size'||U32'downsampled_width'||U32'downsampled_height'||S32'component_needed'||S32'MCU_width'||S32'MCU_height'||S32'MCU_blocks'||S32'MCU_sample_width'||S32'last_col_width'||S32'last_row_height'||U32'$pad0'||*{SYM#tag-#anon#ST[ARR64{U16}$U16$'quantval'||S32'sent_table'|]#}$SYM#tag-#anon#ST[ARR64{U16}$U16$'quantval'||S32'sent_table'|]#$'quant_table'||*{V}$V$'dct_table'|]
// file /usr/include/jpeglib.h line 117
struct anonymous$24;

// tag-#anon#ST[S32'comps_in_scan'||ARR4{S32}$S32$'component_index'||S32'Ss'||S32'Se'||S32'Ah'||S32'Al'|]
// file /usr/include/jpeglib.h line 190
struct anonymous$35;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$5;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$7;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$15;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$6;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{cS8}$cS8$'name'|]
// file packetcapture.h line 16
struct anonymous$16;

// tag-#anon#ST[S32'x'||S32'y'|]
// file /usr/include/X11/Xutil.h line 88
struct anonymous$8;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$12;

// tag-#anon#ST[U16'source'||U16'dest'||U32'seq'||U32'ack_seq'||BF{U16}$U16$'res1'||BF{U16}$U16$'doff'||BF{U16}$U16$'fin'||BF{U16}$U16$'syn'||BF{U16}$U16$'rst'||BF{U16}$U16$'psh'||BF{U16}$U16$'ack'||BF{U16}$U16$'urg'||BF{U16}$U16$'res2'||U16'window'||U16'check'||U16'urg_ptr'|]
// file /usr/include/netinet/tcp.h line 103
struct anonymous$30;

// tag-#anon#ST[U16'th_sport'||U16'th_dport'||U32'th_seq'||U32'th_ack'||BF{U8}$U8$'th_x2'||BF{U8}$U8$'th_off'||U8'th_flags'||U16'th_win'||U16'th_sum'||U16'th_urp'|]
// file /usr/include/netinet/tcp.h line 78
struct anonymous$29;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$41;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous$49;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$14;

// tag-#anon#UN[ARR8{S32}$S32$'i'||ARR80{S8}$S8$'s'|]
// file /usr/include/jpeglib.h line 736
union anonymous$52;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$39;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'th_sport'||U16'th_dport'||U32'th_seq'||U32'th_ack'||BF{U8}$U8$'th_x2'||BF{U8}$U8$'th_off'||U8'th_flags'||U16'th_win'||U16'th_sum'||U16'th_urp'|]#'$anon0'||SYM#tag-#anon#ST[U16'source'||U16'dest'||U32'seq'||U32'ack_seq'||BF{U16}$U16$'res1'||BF{U16}$U16$'doff'||BF{U16}$U16$'fin'||BF{U16}$U16$'syn'||BF{U16}$U16$'rst'||BF{U16}$U16$'psh'||BF{U16}$U16$'ack'||BF{U16}$U16$'urg'||BF{U16}$U16$'res2'||U16'window'||U16'check'||U16'urg_ptr'|]#'$anon1'|]
// file /usr/include/netinet/tcp.h line 76
union anonymous$22;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$0;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'||U8'ip6_un2_vfc'|]
// file /usr/include/netinet/ip6.h line 26
union anonymous$9;

// tag-ColorMapObject
// file /usr/include/gif_lib.h line 40
struct ColorMapObject;

// tag-ExtensionBlock
// file /usr/include/gif_lib.h line 53
struct ExtensionBlock;

// tag-GifColorType
// file /usr/include/gif_lib.h line 36
struct GifColorType;

// tag-GifFileType
// file /usr/include/gif_lib.h line 71
struct GifFileType;

// tag-GifImageDesc
// file /usr/include/gif_lib.h line 47
struct GifImageDesc;

// tag-SavedImage
// file /usr/include/gif_lib.h line 64
struct SavedImage;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GIConv
// file /usr/include/glib-2.0/glib/gconvert.h line 77
struct _GIConv;

// tag-_GIOChannel
// file /usr/include/glib-2.0/glib/giochannel.h line 41
struct _GIOChannel;

// tag-_GIOFuncs
// file /usr/include/glib-2.0/glib/giochannel.h line 42
struct _GIOFuncs;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GSource
// file /usr/include/glib-2.0/glib/gmain.h line 64
struct _GSource;

// tag-_GSourceCallbackFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 77
struct _GSourceCallbackFuncs;

// tag-_GSourceFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 130
struct _GSourceFuncs;

// tag-_GSourcePrivate
// file /usr/include/glib-2.0/glib/gmain.h line 65
struct _GSourcePrivate;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_audiochunk
// file playaudio.c line 51
struct _audiochunk;

// tag-_connection
// file ./connection.h line 45
struct _connection;

// tag-_img
// file img.h line 59
struct _img;

// tag-bpf_insn
// file /usr/include/pcap/bpf.h line 108
struct bpf_insn;

// tag-bpf_program
// file /usr/include/pcap/bpf.h line 106
struct bpf_program;

// tag-datablock
// file ./connection.h line 65
struct datablock;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-ethhdr
// file /usr/include/linux/if_ether.h line 138
struct ethhdr;

// tag-filedrv
// file img.c line 58
struct filedrv;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-frame_control
// file layer2.c line 46
struct frame_control;

// tag-ieee80211_frame
// file layer2.c line 34
struct ieee80211_frame;

// tag-ieee80211_radiotap_header
// file layer2.c line 27
struct ieee80211_radiotap_header;

// tag-imgrect
// file display.c line 53
struct imgrect;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-ip
// file /usr/include/netinet/ip.h line 107
struct ip;

// tag-ip6_ext
// file /usr/include/netinet/ip6.h line 50
struct ip6_ext;

// tag-ip6_hdr
// file /usr/include/netinet/ip6.h line 24
struct ip6_hdr;

// tag-ip6_hdrctl
// file /usr/include/netinet/ip6.h line 28
struct ip6_hdrctl;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_color_deconverter
// file /usr/include/jpeglib.h line 703
struct jpeg_color_deconverter;

// tag-jpeg_color_quantizer
// file /usr/include/jpeglib.h line 704
struct jpeg_color_quantizer;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_d_coef_controller
// file /usr/include/jpeglib.h line 696
struct jpeg_d_coef_controller;

// tag-jpeg_d_main_controller
// file /usr/include/jpeglib.h line 695
struct jpeg_d_main_controller;

// tag-jpeg_d_post_controller
// file /usr/include/jpeglib.h line 697
struct jpeg_d_post_controller;

// tag-jpeg_decomp_master
// file /usr/include/jpeglib.h line 694
struct jpeg_decomp_master;

// tag-jpeg_decompress_struct
// file /usr/include/jpeglib.h line 290
struct jpeg_decompress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_decoder
// file /usr/include/jpeglib.h line 700
struct jpeg_entropy_decoder;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_input_controller
// file /usr/include/jpeglib.h line 698
struct jpeg_input_controller;

// tag-jpeg_inverse_dct
// file /usr/include/jpeglib.h line 701
struct jpeg_inverse_dct;

// tag-jpeg_marker_reader
// file /usr/include/jpeglib.h line 699
struct jpeg_marker_reader;

// tag-jpeg_marker_struct
// file /usr/include/jpeglib.h line 199
struct jpeg_marker_struct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jpeg_source_mgr
// file /usr/include/jpeglib.h line 474
struct jpeg_source_mgr;

// tag-jpeg_upsampler
// file /usr/include/jpeglib.h line 702
struct jpeg_upsampler;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-mediadrv
// file media.c line 67
struct mediadrv;

// tag-mediatype
// file ./media/media.h line 30
enum mediatype { m_image=1, m_audio=2, m_text=4 };

// tag-mpeg_audio_hdr
// file mpeghdr.h line 24
struct mpeg_audio_hdr;

// tag-my_error_mgr
// file jpeg.c line 29
struct my_error_mgr;

// tag-pcap
// file /usr/include/pcap/pcap.h line 79
struct pcap;

// tag-pcap_pkthdr
// file /usr/include/pcap/pcap.h line 160
struct pcap_pkthdr;

// tag-png_chunk
// file pngformat.h line 22
struct png_chunk;

// tag-png_color_16_struct
// file /usr/include/libpng12/png.h line 436
struct png_color_16_struct;

// tag-png_color_8_struct
// file /usr/include/libpng12/png.h line 447
struct png_color_8_struct;

// tag-png_color_struct
// file /usr/include/libpng12/png.h line 427
struct png_color_struct;

// tag-png_info_struct
// file /usr/include/libpng12/png.h line 610
struct png_info_struct;

// tag-png_row_info_struct
// file /usr/include/libpng12/png.h line 953
struct png_row_info_struct;

// tag-png_sPLT_entry_struct
// file /usr/include/libpng12/png.h line 462
struct png_sPLT_entry_struct;

// tag-png_sPLT_struct
// file /usr/include/libpng12/png.h line 478
struct png_sPLT_struct;

// tag-png_struct_def
// file /usr/include/libpng12/png.h line 972
struct png_struct_def;

// tag-png_text_struct
// file /usr/include/libpng12/png.h line 497
struct png_text_struct;

// tag-png_time_struct
// file /usr/include/libpng12/png.h line 537
struct png_time_struct;

// tag-png_unknown_chunk_t
// file /usr/include/libpng12/png.h line 557
struct png_unknown_chunk_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-snap_header
// file layer2.c line 61
struct snap_header;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-tcphdr
// file /usr/include/netinet/tcp.h line 74
struct tcphdr;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// DGifCloseFile
// file /usr/include/gif_lib.h line 183
signed int DGifCloseFile(struct GifFileType *, signed int *);
// DGifOpenFileHandle
// file /usr/include/gif_lib.h line 180
struct GifFileType * DGifOpenFileHandle(signed int, signed int *);
// DGifSlurp
// file /usr/include/gif_lib.h line 181
signed int DGifSlurp(struct GifFileType *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_image_rectangle
// file display.c line 193
void add_image_rectangle(const char *filename, const signed int x, const signed int y, const signed int w, const signed int h);
// alloc_connection
// file connection.c line 54
struct _connection ** alloc_connection(void);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// audiochunk_delete
// file playaudio.c line 74
static void audiochunk_delete(struct _audiochunk *A);
// audiochunk_new
// file playaudio.c line 61
static struct _audiochunk * audiochunk_new(const unsigned char *data, const unsigned long int len);
// audiochunk_write
// file playaudio.c line 83
static signed int audiochunk_write(struct _audiochunk * const A, signed int fd);
// button_press_event
// file display.c line 297
void button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event);
// button_release_event
// file display.c line 302
void button_release_event(struct _GtkWidget *widget, struct _GdkEventButton *event);
// bzero
// file /usr/include/string.h line 458
extern void bzero(void *, unsigned long int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// capture_thread
// file driftnet.c line 98
static void * capture_thread(void *v);
// check_dir_is_rw
// file tmpdir.h line 27
signed int check_dir_is_rw(const char *dir);
// clean_tmpdir
// file tmpdir.h line 24
void clean_tmpdir(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_pidfile
// file pid.h line 15
void close_pidfile(void);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// configure_event
// file display.c line 236
void configure_event(struct _GtkWidget *widget, union _GdkEvent *event, void *data);
// connection_alloc_slots
// file connection.c line 33
void connection_alloc_slots(void);
// connection_delete
// file connection.c line 207
void connection_delete(struct _connection *c);
// connection_free_slots
// file connection.c line 40
void connection_free_slots(void);
// connection_new
// file connection.c line 187
struct _connection * connection_new(struct sockaddr *src, struct sockaddr *dst);
// connection_push
// file connection.c line 224
void connection_push(struct _connection *c, const unsigned char *data, unsigned int off, unsigned int len);
// connection_string
// file connection.c line 94
char * connection_string(struct sockaddr *src, struct sockaddr *dst);
// count_tmpfiles
// file tmpdir.c line 234
static signed int count_tmpfiles(void);
// create_pidfile
// file pid.h line 14
void create_pidfile(void);
// delete_event
// file display.c line 101
signed int delete_event(struct _GtkWidget *widget, union _GdkEvent *event, void *data);
// destroy
// file display.c line 316
void destroy(struct _GtkWidget *widget, void *data);
// dispatch_http_req
// file http.h line 23
void dispatch_http_req(const char *mname, const unsigned char *data, const unsigned long int len);
// dispatch_image
// file media.c line 40
void dispatch_image(const char *mname, const unsigned char *data, const unsigned long int len);
// dispatch_mpeg_audio
// file media.c line 62
void dispatch_mpeg_audio(const char *mname, const unsigned char *data, const unsigned long int len);
// display_send_img
// file ../../src/display/display.h line 22
void display_send_img(const char *name, unsigned long int len);
// do_gtkdisplay
// file display.c line 419
static void do_gtkdisplay(void);
// do_image_display
// file ./display/display.h line 20
void do_image_display(char *img_prefix, signed int beep);
// do_mpeg_player
// file ./media/playaudio.h line 16
void do_mpeg_player(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expose_event
// file display.c line 225
void expose_event(struct _GtkWidget *widget, union _GdkEvent *event, void *data);
// extract_media
// file ./media/media.h line 33
void extract_media(struct _connection *c);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_connection
// file connection.c line 75
struct _connection ** find_connection(struct sockaddr *src, struct sockaddr *dst);
// find_gif_image
// file image.h line 16
unsigned char * find_gif_image(const unsigned char *data, const unsigned long int len, unsigned char **gifdata, unsigned long int *giflen);
// find_http_req
// file http.h line 20
unsigned char * find_http_req(const unsigned char *data, const unsigned long int len, unsigned char **http, unsigned long int *httplen);
// find_image_rectangle
// file display.c line 215
struct imgrect * find_image_rectangle(const signed int x, const signed int y);
// find_jpeg_image
// file image.h line 19
unsigned char * find_jpeg_image(const unsigned char *data, const unsigned long int len, unsigned char **jpegdata, unsigned long int *jpeglen);
// find_mpeg_stream
// file audio.h line 16
unsigned char * find_mpeg_stream(const unsigned char *data, const unsigned long int len, unsigned char **mpegdata, unsigned long int *mpeglen);
// find_png_eoi
// file image.c line 213
unsigned char * find_png_eoi(unsigned char *buffer, const unsigned long int len);
// find_png_image
// file image.h line 22
unsigned char * find_png_image(const unsigned char *data, const unsigned long int len, unsigned char **pngdata, unsigned long int *pnglen);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// g_io_add_watch
// file /usr/include/glib-2.0/glib/giochannel.h line 200
extern unsigned int g_io_add_watch(struct _GIOChannel *, enum anonymous$62, signed int (*)(struct _GIOChannel *, enum anonymous$62, void *), void *);
// g_io_channel_unix_new
// file /usr/include/glib-2.0/glib/giochannel.h line 321
extern struct _GIOChannel * g_io_channel_unix_new(signed int);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$42);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// gdk_draw_rectangle
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 285
void gdk_draw_rectangle(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, signed int);
// gdk_draw_rgb_32_image
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 89
void gdk_draw_rgb_32_image(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, enum anonymous$48, const unsigned char *, signed int);
// gdk_drawable_get_size
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 259
void gdk_drawable_get_size(struct _GdkDrawable *, signed int *, signed int *);
// gdk_drawable_get_type
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 239
unsigned long int gdk_drawable_get_type(void);
// gdk_flush
// file /usr/include/gtk-2.0/gdk/gdk.h line 143
void gdk_flush(void);
// gdk_gc_new
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 225
struct _GdkGC * gdk_gc_new(struct _GdkDrawable *);
// gdk_rgb_get_colormap
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 139
struct _GdkColormap * gdk_rgb_get_colormap(void);
// get_datalink_info
// file packetcapture.c line 232
static struct anonymous$16 get_datalink_info(struct pcap *pcap);
// get_default_interface
// file packetcapture.h line 28
char * get_default_interface(void);
// get_levelstring
// file log.c line 97
static char * get_levelstring(enum anonymous$25 level);
// get_loglevel
// file log.c line 34
enum anonymous$25 get_loglevel(void);
// get_timestring
// file log.c line 83
char * get_timestring(void);
// get_tmpdir
// file tmpdir.c line 75
const char * get_tmpdir(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gif_abort_load
// file img.c line 35
signed int gif_abort_load(struct _img *I);
// gif_load_hdr
// file img.c line 34
signed int gif_load_hdr(struct _img *I);
// gif_load_img
// file img.c line 36
signed int gif_load_img(struct _img *I);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_drawing_area_new
// file /usr/include/gtk-2.0/gtk/gtkdrawingarea.h line 71
struct _GtkWidget * gtk_drawing_area_new(void);
// gtk_exit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 131
void gtk_exit(signed int);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_widget_push_colormap
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1211
void gtk_widget_push_colormap(struct _GdkColormap *);
// gtk_widget_set_events
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1042
void gtk_widget_set_events(struct _GtkWidget *, signed int);
// gtk_widget_set_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1027
void gtk_widget_set_size_request(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 854
void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous$56);
// handle_link_layer
// file layer2.h line 36
signed int handle_link_layer(struct anonymous$16 *info, const unsigned char *pkt, unsigned int caplen, unsigned char *nextproto, signed int *offsetnext);
// img_alloc
// file img.h line 72
void img_alloc(struct _img *I);
// img_clip
// file img.c line 222
inline void img_clip(struct _img * const I, signed int *x, signed int *y);
// img_clip_adj_x
// file img.c line 208
inline signed int img_clip_adj_x(struct _img * const I, const signed int x);
// img_clip_adj_y
// file img.c line 214
inline signed int img_clip_adj_y(struct _img * const I, const signed int y);
// img_delete
// file img.h line 82
void img_delete(struct _img *I);
// img_load
// file img.h line 74
signed int img_load(struct _img *I, const enum anonymous$58 howmuch, const enum anonymous$57 type);
// img_load_file
// file img.h line 76
signed int img_load_file(struct _img *I, const char *name, const enum anonymous$58 howmuch, const enum anonymous$57 type);
// img_load_stream
// file img.c line 155
signed int img_load_stream(struct _img *I, struct _IO_FILE *fp, const enum anonymous$58 howmuch, const enum anonymous$57 type);
// img_new
// file img.h line 70
struct _img * img_new(void);
// img_new_blank
// file img.h line 71
struct _img * img_new_blank(const unsigned int width, const unsigned int height);
// img_save
// file img.c line 191
signed int img_save(struct _img * const I, struct _IO_FILE *fp, const enum anonymous$57 type);
// img_simple_blt
// file img.h line 84
inline void img_simple_blt(struct _img *dest, const signed int dx, const signed int dy, struct _img *src, const signed int sx, const signed int sy, const signed int w, const signed int h);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// init_mediadrv
// file ./media/media.h line 32
void init_mediadrv(enum mediatype media_type, signed int play);
// is_tempfile
// file tmpdir.c line 255
static signed int is_tempfile(const char *file);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_CreateDecompress
// file /usr/include/jpeglib.h line 906
extern void jpeg_CreateDecompress(struct jpeg_decompress_struct *, signed int, unsigned long int);
// jpeg_abort_load
// file img.c line 40
signed int jpeg_abort_load(struct _img *I);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_destroy_decompress
// file /usr/include/jpeglib.h line 910
extern void jpeg_destroy_decompress(struct jpeg_decompress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_finish_decompress
// file /usr/include/jpeglib.h line 993
extern signed int jpeg_finish_decompress(struct jpeg_decompress_struct *);
// jpeg_load_hdr
// file img.c line 39
signed int jpeg_load_hdr(struct _img *I);
// jpeg_load_img
// file img.c line 41
signed int jpeg_load_img(struct _img *I);
// jpeg_next_marker
// file image.c line 152
unsigned char * jpeg_next_marker(unsigned char *d, unsigned long int len);
// jpeg_read_header
// file /usr/include/jpeglib.h line 977
extern signed int jpeg_read_header(struct jpeg_decompress_struct *, signed int);
// jpeg_read_scanlines
// file /usr/include/jpeglib.h line 990
extern unsigned int jpeg_read_scanlines(struct jpeg_decompress_struct *, unsigned char **, unsigned int);
// jpeg_save_img
// file img.c line 42
signed int jpeg_save_img(struct _img * const I, struct _IO_FILE *fp);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_skip_block
// file image.c line 162
unsigned char * jpeg_skip_block(unsigned char *d, unsigned long int len);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_start_decompress
// file /usr/include/jpeglib.h line 989
extern signed int jpeg_start_decompress(struct jpeg_decompress_struct *);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_stdio_src
// file /usr/include/jpeglib.h line 915
extern void jpeg_stdio_src(struct jpeg_decompress_struct *, struct _IO_FILE *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// layer3_find_tcp
// file layer3.h line 35
signed int layer3_find_tcp(const unsigned char *pkt, unsigned char nextproto, signed int *offset, struct sockaddr *src, struct sockaddr *dst, struct tcphdr *tcp);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// log_msg
// file log.h line 22
void log_msg(enum anonymous$25 level, const char *fmt, ...);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// make_backing_image
// file display.c line 108
void make_backing_image();
// make_tmpdir
// file tmpdir.h line 26
const char * make_tmpdir(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// memstr
// file util.c line 80
unsigned char * memstr(const unsigned char *haystack, const unsigned long int hlen, const unsigned char *needle, const unsigned long int nlen);
// mkdtemp
// file /usr/include/stdlib.h line 662
extern char * mkdtemp(char *);
// mpeg_hdr_nextframe_offset
// file mpeghdr.h line 49
signed int mpeg_hdr_nextframe_offset(struct mpeg_audio_hdr *h);
// mpeg_hdr_parse
// file mpeghdr.h line 48
signed int mpeg_hdr_parse(const unsigned char *data, struct mpeg_audio_hdr *h);
// mpeg_hdr_print
// file mpeghdr.c line 138
void mpeg_hdr_print(struct _IO_FILE *fp, struct mpeg_audio_hdr *h);
// mpeg_play
// file playaudio.c line 134
static void * mpeg_play(void *a);
// mpeg_player_manager
// file playaudio.c line 167
static void mpeg_player_manager(void);
// mpeg_submit_chunk
// file playaudio.h line 18
void mpeg_submit_chunk(const unsigned char *data, const unsigned long int len);
// my_error_exit
// file jpeg.c line 36
static void my_error_exit(struct jpeg_common_struct *cinfo);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// packetcapture_close
// file packetcapture.h line 24
void packetcapture_close(void);
// packetcapture_dispatch
// file packetcapture.h line 26
void packetcapture_dispatch(void);
// packetcapture_open_live
// file packetcapture.h line 22
void packetcapture_open_live(char *interface, char *filterexpr, signed int promisc);
// packetcapture_open_offline
// file packetcapture.h line 23
void packetcapture_open_offline(char *dumpfile);
// parse_ieee80211
// file layer2.c line 77
static signed int parse_ieee80211(const unsigned char *pkt, unsigned int caplen, unsigned short int *llnextproto, signed int *offsetnext);
// parse_options
// file options.h line 40
struct anonymous$2 * parse_options(signed int argc, char **argv);
// pcap_close
// file /usr/include/pcap/pcap.h line 371
void pcap_close(struct pcap *);
// pcap_compile
// file /usr/include/pcap/pcap.h line 389
signed int pcap_compile(struct pcap *, struct bpf_program *, const char *, signed int, unsigned int);
// pcap_datalink
// file /usr/include/pcap/pcap.h line 396
signed int pcap_datalink(struct pcap *);
// pcap_datalink_val_to_name
// file /usr/include/pcap/pcap.h line 402
const char * pcap_datalink_val_to_name(signed int);
// pcap_dispatch
// file /usr/include/pcap/pcap.h line 373
signed int pcap_dispatch(struct pcap *, signed int, void (*)(unsigned char *, struct pcap_pkthdr *, const unsigned char *), unsigned char *);
// pcap_geterr
// file /usr/include/pcap/pcap.h line 387
char * pcap_geterr(struct pcap *);
// pcap_lookupdev
// file /usr/include/pcap/pcap.h line 274
char * pcap_lookupdev(char *);
// pcap_open_live
// file /usr/include/pcap/pcap.h line 349
struct pcap * pcap_open_live(const char *, signed int, signed int, signed int, char *);
// pcap_open_offline
// file /usr/include/pcap/pcap.h line 353
struct pcap * pcap_open_offline(const char *, char *);
// pcap_setfilter
// file /usr/include/pcap/pcap.h line 379
signed int pcap_setfilter(struct pcap *, struct bpf_program *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// pipe_event
// file display.c line 337
signed int pipe_event(struct _GIOChannel chan, enum anonymous$62 cond, void *data);
// png_abort_load
// file png.c line 91
signed int png_abort_load(struct _img *I);
// png_catch_error
// file png.c line 29
void png_catch_error(struct png_struct_def *png_ptr, const char *error_msg);
// png_create_info_struct
// file /usr/include/libpng12/png.h line 1426
extern struct png_info_struct * png_create_info_struct(struct png_struct_def *);
// png_create_read_struct
// file /usr/include/libpng12/png.h line 1376
extern struct png_struct_def * png_create_read_struct(const char *, void *, void (*)(struct png_struct_def *, const char *), void (*)(struct png_struct_def *, const char *));
// png_destroy_read_struct
// file /usr/include/libpng12/png.h line 1672
extern void png_destroy_read_struct(struct png_struct_def **, struct png_info_struct **, struct png_info_struct **);
// png_free
// file /usr/include/libpng12/png.h line 1908
extern void png_free(struct png_struct_def *, void *);
// png_get_IHDR
// file /usr/include/libpng12/png.h line 2156
extern unsigned long int png_get_IHDR(struct png_struct_def *, struct png_info_struct *, unsigned long int *, unsigned long int *, signed int *, signed int *, signed int *, signed int *, signed int *);
// png_get_image_height
// file /usr/include/libpng12/png.h line 2034
extern unsigned long int png_get_image_height(struct png_struct_def *, struct png_info_struct *);
// png_get_image_width
// file /usr/include/libpng12/png.h line 2030
extern unsigned long int png_get_image_width(struct png_struct_def *, struct png_info_struct *);
// png_get_rowbytes
// file /usr/include/libpng12/png.h line 2008
extern unsigned long int png_get_rowbytes(struct png_struct_def *, struct png_info_struct *);
// png_init_io
// file /usr/include/libpng12/png.h line 1791
extern void png_init_io(struct png_struct_def *, struct _IO_FILE *);
// png_load_hdr
// file img.c line 45
signed int png_load_hdr(struct _img *I);
// png_load_img
// file img.c line 47
signed int png_load_img(struct _img *I);
// png_malloc
// file /usr/include/libpng12/png.h line 1896
extern void * png_malloc(struct png_struct_def *, unsigned long int);
// png_read_end
// file /usr/include/libpng12/png.h line 1663
extern void png_read_end(struct png_struct_def *, struct png_info_struct *);
// png_read_image
// file /usr/include/libpng12/png.h line 1641
extern void png_read_image(struct png_struct_def *, unsigned char **);
// png_read_info
// file /usr/include/libpng12/png.h line 1449
extern void png_read_info(struct png_struct_def *, struct png_info_struct *);
// png_read_update_info
// file /usr/include/libpng12/png.h line 1623
extern void png_read_update_info(struct png_struct_def *, struct png_info_struct *);
// png_save_img
// file png.c line 190
signed int png_save_img(struct _img * const I, struct _IO_FILE *fp);
// png_set_expand
// file /usr/include/libpng12/png.h line 1470
extern void png_set_expand(struct png_struct_def *);
// png_set_expand_gray_1_2_4_to_8
// file /usr/include/libpng12/png.h line 1472
extern void png_set_expand_gray_1_2_4_to_8(struct png_struct_def *);
// png_set_filler
// file /usr/include/libpng12/png.h line 1525
extern void png_set_filler(struct png_struct_def *, unsigned long int, signed int);
// png_set_gray_to_rgb
// file /usr/include/libpng12/png.h line 1491
extern void png_set_gray_to_rgb(struct png_struct_def *);
// png_set_strip_16
// file /usr/include/libpng12/png.h line 1584
extern void png_set_strip_16(struct png_struct_def *);
// png_sig_cmp
// file /usr/include/libpng12/png.h line 1367
extern signed int png_sig_cmp(unsigned char *, unsigned long int, unsigned long int);
// print_exit_reason
// file driftnet.c line 106
static void print_exit_reason(void);
// print_ipport_pair
// file connection.c line 120
static char * print_ipport_pair(struct sockaddr *addr, char *buf, unsigned long int buf_len);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_packet
// file packetcapture.c line 134
static void process_packet(unsigned char *user, struct pcap_pkthdr *hdr, const unsigned char *pkt);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$0 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// save_image
// file display.c line 247
void save_image(struct imgrect *ir);
// scroll_backing_image
// file display.c line 165
void scroll_backing_image(const signed int dy);
// set_loglevel
// file log.h line 20
void set_loglevel(enum anonymous$25 level);
// set_tmpdir
// file tmpdir.h line 22
void set_tmpdir(const char *dir, enum anonymous$51 type, signed int max_files, signed int preserve_files);
// setup_signals
// file driftnet.c line 71
static void setup_signals(void);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// stat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link1(const char *__path$link1, struct stat *__statbuf$link1);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sweep_connections
// file connection.c line 159
void sweep_connections(void);
// terminate_on_signal
// file driftnet.c line 57
static void terminate_on_signal(signed int s);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tmpfile_write
// file tmpdir.c line 208
const char * tmpfile_write(const char *mname, const unsigned char *data, const unsigned long int len);
// tmpfiles_limit_reached
// file tmpdir.c line 274
signed int tmpfiles_limit_reached(void);
// unexpected_exit
// file driftnet.c line 42
void unexpected_exit(signed int ret);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_window
// file display.c line 154
void update_window();
// usage
// file options.c line 209
static void usage(struct _IO_FILE *fp);
// validate_options
// file options.c line 164
static void validate_options(struct anonymous$2 *options);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xcalloc
// file util.h line 21
void * xcalloc(unsigned long int n, unsigned long int m);
// xfree
// file util.h line 23
void xfree(void *v);
// xmalloc
// file util.h line 20
void * xmalloc(unsigned long int n);
// xnanosleep
// file util.c line 93
void xnanosleep(signed long int nanosecs);
// xread
// file display.c line 322
static signed long int xread(signed int fd, void *buf, unsigned long int len);
// xrealloc
// file util.h line 22
void * xrealloc(void *w, unsigned long int n);
// xstrdup
// file util.c line 70
char * xstrdup(const char *s);

struct anonymous$13
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$11
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$55
{
  // path
  const char *path;
  // type
  enum anonymous$51 type;
  // max_files
  signed int max_files;
  // preserve_files
  signed int preserve_files;
};

struct anonymous$2
{
  // tmpdir
  const char *tmpdir;
  // tmpdir_especified
  signed int tmpdir_especified;
  // max_tmpfiles
  signed int max_tmpfiles;
  // extract_images
  signed int extract_images;
  // verbose
  signed int verbose;
  // adjunct
  signed int adjunct;
  // beep
  signed int beep;
  // promisc
  signed int promisc;
  // dumpfile
  char *dumpfile;
  // interface
  char *interface;
  // filterexpr
  char *filterexpr;
  // extract_type
  enum mediatype extract_type;
  // audio_mpeg_player
  char *audio_mpeg_player;
  // mpeg_player_specified
  signed int mpeg_player_specified;
  // newpfx
  signed int newpfx;
  // savedimgpfx
  char *savedimgpfx;
};

struct anonymous$28
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$23
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous$21
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous$24
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous$21 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous$35
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous$5
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$7
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$6
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$12
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$14
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$5 _kill;
  // _timer
  struct anonymous$6 _timer;
  // _rt
  struct anonymous$7 _rt;
  // _sigchld
  struct anonymous$10 _sigchld;
  // _sigfault
  struct anonymous$11 _sigfault;
  // _sigpoll
  struct anonymous$12 _sigpoll;
  // _sigsys
  struct anonymous$13 _sigsys;
};

struct anonymous$15
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$14 _sifields;
};

struct anonymous$16
{
  // type
  signed int type;
  // name
  const char *name;
};

struct anonymous$8
{
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$30
{
  // source
  unsigned short int source;
  // dest
  unsigned short int dest;
  // seq
  unsigned int seq;
  // ack_seq
  unsigned int ack_seq;
  // res1
  unsigned short int res1 : 4;
  // doff
  unsigned short int doff : 4;
  // fin
  unsigned short int fin : 1;
  // syn
  unsigned short int syn : 1;
  // rst
  unsigned short int rst : 1;
  // psh
  unsigned short int psh : 1;
  // ack
  unsigned short int ack : 1;
  // urg
  unsigned short int urg : 1;
  // res2
  unsigned short int res2 : 2;
  // window
  unsigned short int window;
  // check
  unsigned short int check;
  // urg_ptr
  unsigned short int urg_ptr;
};

struct anonymous$29
{
  // th_sport
  unsigned short int th_sport;
  // th_dport
  unsigned short int th_dport;
  // th_seq
  unsigned int th_seq;
  // th_ack
  unsigned int th_ack;
  // th_x2
  unsigned char th_x2 : 4;
  // th_off
  unsigned char th_off : 4;
  // th_flags
  unsigned char th_flags;
  // th_win
  unsigned short int th_win;
  // th_sum
  unsigned short int th_sum;
  // th_urp
  unsigned short int th_urp;
};

union anonymous
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$15 *, void *);
};

union anonymous$41
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$49
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous$52
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

union anonymous$39
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

union anonymous$22
{
  // $anon0
  struct anonymous$29 $anon0;
  // $anon1
  struct anonymous$30 $anon1;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous$9
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

struct ColorMapObject
{
  // ColorCount
  signed int ColorCount;
  // BitsPerPixel
  signed int BitsPerPixel;
  // SortFlag
  _Bool SortFlag;
  // Colors
  struct GifColorType *Colors;
};

struct ExtensionBlock
{
  // ByteCount
  signed int ByteCount;
  // Bytes
  unsigned char *Bytes;
  // Function
  signed int Function;
};

struct GifColorType
{
  // Red
  unsigned char Red;
  // Green
  unsigned char Green;
  // Blue
  unsigned char Blue;
};

struct GifImageDesc
{
  // Left
  signed int Left;
  // Top
  signed int Top;
  // Width
  signed int Width;
  // Height
  signed int Height;
  // Interlace
  _Bool Interlace;
  // ColorMap
  struct ColorMapObject *ColorMap;
};

struct GifFileType
{
  // SWidth
  signed int SWidth;
  // SHeight
  signed int SHeight;
  // SColorResolution
  signed int SColorResolution;
  // SBackGroundColor
  signed int SBackGroundColor;
  // AspectByte
  unsigned char AspectByte;
  // SColorMap
  struct ColorMapObject *SColorMap;
  // ImageCount
  signed int ImageCount;
  // Image
  struct GifImageDesc Image;
  // SavedImages
  struct SavedImage *SavedImages;
  // ExtensionBlockCount
  signed int ExtensionBlockCount;
  // ExtensionBlocks
  struct ExtensionBlock *ExtensionBlocks;
  // Error
  signed int Error;
  // UserData
  void *UserData;
  // Private
  void *Private;
};

struct SavedImage
{
  // ImageDesc
  struct GifImageDesc ImageDesc;
  // RasterBits
  unsigned char *RasterBits;
  // ExtensionBlockCount
  signed int ExtensionBlockCount;
  // ExtensionBlocks
  struct ExtensionBlock *ExtensionBlocks;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GIOChannel
{
  // ref_count
  signed int ref_count;
  // funcs
  struct _GIOFuncs *funcs;
  // encoding
  char *encoding;
  // read_cd
  struct _GIConv *read_cd;
  // write_cd
  struct _GIConv *write_cd;
  // line_term
  char *line_term;
  // line_term_len
  unsigned int line_term_len;
  // buf_size
  unsigned long int buf_size;
  // read_buf
  struct _GString *read_buf;
  // encoded_read_buf
  struct _GString *encoded_read_buf;
  // write_buf
  struct _GString *write_buf;
  // partial_write_buf
  char partial_write_buf[6l];
  // use_buffer
  unsigned int use_buffer : 1;
  // do_encode
  unsigned int do_encode : 1;
  // close_on_unref
  unsigned int close_on_unref : 1;
  // is_readable
  unsigned int is_readable : 1;
  // is_writeable
  unsigned int is_writeable : 1;
  // is_seekable
  unsigned int is_seekable : 1;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
};

struct _GIOFuncs
{
  // io_read
  enum anonymous$60 (*io_read)(struct _GIOChannel *, char *, unsigned long int, unsigned long int *, struct _GError **);
  // io_write
  enum anonymous$60 (*io_write)(struct _GIOChannel *, const char *, unsigned long int, unsigned long int *, struct _GError **);
  // io_seek
  enum anonymous$60 (*io_seek)(struct _GIOChannel *, signed long int, enum anonymous$61, struct _GError **);
  // io_close
  enum anonymous$60 (*io_close)(struct _GIOChannel *, struct _GError **);
  // io_create_watch
  struct _GSource * (*io_create_watch)(struct _GIOChannel *, enum anonymous$62);
  // io_free
  void (*io_free)(struct _GIOChannel *);
  // io_set_flags
  enum anonymous$60 (*io_set_flags)(struct _GIOChannel *, enum anonymous$63, struct _GError **);
  // io_get_flags
  enum anonymous$63 (*io_get_flags)(struct _GIOChannel *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GSource
{
  // callback_data
  void *callback_data;
  // callback_funcs
  struct _GSourceCallbackFuncs *callback_funcs;
  // source_funcs
  const struct _GSourceFuncs *source_funcs;
  // ref_count
  unsigned int ref_count;
  // context
  struct _GMainContext *context;
  // priority
  signed int priority;
  // flags
  unsigned int flags;
  // source_id
  unsigned int source_id;
  // poll_fds
  struct _GSList *poll_fds;
  // prev
  struct _GSource *prev;
  // next
  struct _GSource *next;
  // name
  char *name;
  // priv
  struct _GSourcePrivate *priv;
};

struct _GSourceCallbackFuncs
{
  // ref
  void (*ref)(void *);
  // unref
  void (*unref)(void *);
  // get
  void (*get)(void *, struct _GSource *, signed int (**)(void *), void **);
};

struct _GSourceFuncs
{
  // prepare
  signed int (*prepare)(struct _GSource *, signed int *);
  // check
  signed int (*check)(struct _GSource *);
  // dispatch
  signed int (*dispatch)(struct _GSource *, signed int (*)(void *), void *);
  // finalize
  void (*finalize)(struct _GSource *);
  // closure_callback
  signed int (*closure_callback)(void *);
  // closure_marshal
  void (*closure_marshal)(void);
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$39 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous$33 source;
  // mode
  enum anonymous$34 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous$36 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous$1 modifiers;
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous$27 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous$26 actions;
  // suggested_action
  enum anonymous$26 suggested_action;
  // action
  enum anonymous$26 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkEventAny
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous$37 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous$40 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous$43 mode;
  // detail
  enum anonymous$44 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous$45 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous$49 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous$53 changed_mask;
  // new_window_state
  enum anonymous$53 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous$54 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous$4 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous$4 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous$38 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$31 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous$32 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$17 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$28 __saved_mask;
};

struct _audiochunk
{
  // data
  unsigned char *data;
  // len
  unsigned long int len;
  // next
  struct _audiochunk *next;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct _connection
{
  // src
  struct sockaddr_storage src;
  // dst
  struct sockaddr_storage dst;
  // isn
  unsigned int isn;
  // len
  unsigned int len;
  // alloc
  unsigned int alloc;
  // data
  unsigned char *data;
  // fin
  signed int fin;
  // last
  signed long int last;
  // blocks
  struct datablock *blocks;
};

struct _img
{
  // type
  enum anonymous$57 type;
  // load
  enum anonymous$58 load;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // data
  unsigned int **data;
  // flat
  unsigned int *flat;
  // fp
  struct _IO_FILE *fp;
  // us
  void *us;
  // err
  enum anonymous$59 err;
};

struct bpf_insn
{
  // code
  unsigned short int code;
  // jt
  unsigned char jt;
  // jf
  unsigned char jf;
  // k
  unsigned int k;
};

struct bpf_program
{
  // bf_len
  unsigned int bf_len;
  // bf_insns
  struct bpf_insn *bf_insns;
};

struct datablock
{
  // off
  signed int off;
  // len
  signed int len;
  // moff
  signed int moff[5l];
  // dirty
  signed int dirty;
  // next
  struct datablock *next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct ethhdr
{
  // h_dest
  unsigned char h_dest[6l];
  // h_source
  unsigned char h_source[6l];
  // h_proto
  unsigned short int h_proto;
} __attribute__ ((__packed__));

struct filedrv
{
  // type
  enum anonymous$57 type;
  // suffices
  char *suffices;
  // loadhdr
  signed int (*loadhdr)(struct _img *);
  // abortload
  signed int (*abortload)(struct _img *);
  // loadimg
  signed int (*loadimg)(struct _img *);
  // saveimg
  signed int (*saveimg)(struct _img *, struct _IO_FILE *);
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct frame_control
{
  // protocol
  unsigned int protocol : 2;
  // type
  unsigned int type : 2;
  // subtype
  unsigned int subtype : 4;
  // to_ds
  unsigned int to_ds : 1;
  // from_ds
  unsigned int from_ds : 1;
  // more_frag
  unsigned int more_frag : 1;
  // retry
  unsigned int retry : 1;
  // pwr_mgt
  unsigned int pwr_mgt : 1;
  // more_data
  unsigned int more_data : 1;
  // wep
  unsigned int wep : 1;
  // order
  unsigned int order : 1;
};

struct ieee80211_frame
{
  // fc
  unsigned short int fc;
  // wi_duration
  unsigned short int wi_duration;
  // wi_add1
  unsigned char wi_add1[6l];
  // wi_add2
  unsigned char wi_add2[6l];
  // wi_add3
  unsigned char wi_add3[6l];
  // wi_sequenceControl
  unsigned short int wi_sequenceControl;
};

struct ieee80211_radiotap_header
{
  // it_version
  unsigned char it_version;
  // it_pad
  unsigned char it_pad;
  // it_len
  unsigned short int it_len;
  // it_present
  unsigned int it_present;
};

struct imgrect
{
  // filename
  char *filename;
  // x
  signed int x;
  // y
  signed int y;
  // w
  signed int w;
  // h
  signed int h;
};

struct in6_addr
{
  // __in6_u
  union anonymous$41 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct ip
{
  // ip_hl
  unsigned int ip_hl : 4;
  // ip_v
  unsigned int ip_v : 4;
  // ip_tos
  unsigned char ip_tos;
  // ip_len
  unsigned short int ip_len;
  // ip_id
  unsigned short int ip_id;
  // ip_off
  unsigned short int ip_off;
  // ip_ttl
  unsigned char ip_ttl;
  // ip_p
  unsigned char ip_p;
  // ip_sum
  unsigned short int ip_sum;
  // ip_src
  struct in_addr ip_src;
  // ip_dst
  struct in_addr ip_dst;
};

struct ip6_ext
{
  // ip6e_nxt
  unsigned char ip6e_nxt;
  // ip6e_len
  unsigned char ip6e_len;
};

struct ip6_hdr
{
  // ip6_ctlun
  union anonymous$9 ip6_ctlun;
  // ip6_src
  struct in6_addr ip6_src;
  // ip6_dst
  struct in6_addr ip6_dst;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous$18 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous$18 jpeg_color_space;
  // comp_info
  struct anonymous$24 *comp_info;
  // quant_tbl_ptrs
  struct anonymous$21 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous$23 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous$23 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous$35 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous$19 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous$24 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous$35 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_decompress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // src
  struct jpeg_source_mgr *src;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous$18 jpeg_color_space;
  // out_color_space
  enum anonymous$18 out_color_space;
  // scale_num
  unsigned int scale_num;
  // scale_denom
  unsigned int scale_denom;
  // output_gamma
  double output_gamma;
  // buffered_image
  signed int buffered_image;
  // raw_data_out
  signed int raw_data_out;
  // dct_method
  enum anonymous$19 dct_method;
  // do_fancy_upsampling
  signed int do_fancy_upsampling;
  // do_block_smoothing
  signed int do_block_smoothing;
  // quantize_colors
  signed int quantize_colors;
  // dither_mode
  enum anonymous$20 dither_mode;
  // two_pass_quantize
  signed int two_pass_quantize;
  // desired_number_of_colors
  signed int desired_number_of_colors;
  // enable_1pass_quant
  signed int enable_1pass_quant;
  // enable_external_quant
  signed int enable_external_quant;
  // enable_2pass_quant
  signed int enable_2pass_quant;
  // output_width
  unsigned int output_width;
  // output_height
  unsigned int output_height;
  // out_color_components
  signed int out_color_components;
  // output_components
  signed int output_components;
  // rec_outbuf_height
  signed int rec_outbuf_height;
  // actual_number_of_colors
  signed int actual_number_of_colors;
  // colormap
  unsigned char **colormap;
  // output_scanline
  unsigned int output_scanline;
  // input_scan_number
  signed int input_scan_number;
  // input_iMCU_row
  unsigned int input_iMCU_row;
  // output_scan_number
  signed int output_scan_number;
  // output_iMCU_row
  unsigned int output_iMCU_row;
  // coef_bits
  signed int (*coef_bits)[64l];
  // quant_tbl_ptrs
  struct anonymous$21 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous$23 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous$23 *ac_huff_tbl_ptrs[4l];
  // data_precision
  signed int data_precision;
  // comp_info
  struct anonymous$24 *comp_info;
  // progressive_mode
  signed int progressive_mode;
  // arith_code
  signed int arith_code;
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // restart_interval
  unsigned int restart_interval;
  // saw_JFIF_marker
  signed int saw_JFIF_marker;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // saw_Adobe_marker
  signed int saw_Adobe_marker;
  // Adobe_transform
  unsigned char Adobe_transform;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // marker_list
  struct jpeg_marker_struct *marker_list;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // min_DCT_scaled_size
  signed int min_DCT_scaled_size;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // sample_range_limit
  unsigned char *sample_range_limit;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous$24 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // unread_marker
  signed int unread_marker;
  // master
  struct jpeg_decomp_master *master;
  // main
  struct jpeg_d_main_controller *main;
  // coef
  struct jpeg_d_coef_controller *coef;
  // post
  struct jpeg_d_post_controller *post;
  // inputctl
  struct jpeg_input_controller *inputctl;
  // marker
  struct jpeg_marker_reader *marker;
  // entropy
  struct jpeg_entropy_decoder *entropy;
  // idct
  struct jpeg_inverse_dct *idct;
  // upsample
  struct jpeg_upsampler *upsample;
  // cconvert
  struct jpeg_color_deconverter *cconvert;
  // cquantize
  struct jpeg_color_quantizer *cquantize;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous$52 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_marker_struct
{
  // next
  struct jpeg_marker_struct *next;
  // marker
  unsigned char marker;
  // original_length
  unsigned int original_length;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct jpeg_source_mgr
{
  // next_input_byte
  const unsigned char *next_input_byte;
  // bytes_in_buffer
  unsigned long int bytes_in_buffer;
  // init_source
  void (*init_source)(struct jpeg_decompress_struct *);
  // fill_input_buffer
  signed int (*fill_input_buffer)(struct jpeg_decompress_struct *);
  // skip_input_data
  void (*skip_input_data)(struct jpeg_decompress_struct *, signed long int);
  // resync_to_restart
  signed int (*resync_to_restart)(struct jpeg_decompress_struct *, signed int);
  // term_source
  void (*term_source)(struct jpeg_decompress_struct *);
};

struct mediadrv
{
  // name
  char *name;
  // type
  enum mediatype type;
  // find_data
  unsigned char * (*find_data)(const unsigned char *, const unsigned long int, unsigned char **, unsigned long int *);
  // dispatch_data
  void (*dispatch_data)(const char *, const unsigned char *, const unsigned long int);
};

struct mpeg_audio_hdr
{
  // version
  enum anonymous$46 version;
  // layer
  enum anonymous$47 layer;
  // has_crc
  signed int has_crc;
  // crc
  unsigned short int crc;
  // bitrate
  signed int bitrate;
  // samplerate
  signed int samplerate;
  // padded
  signed int padded;
  // priv
  signed int priv;
  // channels
  enum anonymous$50 channels;
  // mode_extn
  unsigned char mode_extn;
  // copyr
  signed int copyr;
  // original
  signed int original;
  // emph
  unsigned char emph;
};

struct my_error_mgr
{
  // pub
  struct jpeg_error_mgr pub;
  // jb
  struct __jmp_buf_tag jb[1l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct pcap_pkthdr
{
  // ts
  struct timeval ts;
  // caplen
  unsigned int caplen;
  // len
  unsigned int len;
};

struct png_chunk
{
  // datalen
  unsigned int datalen;
  // code
  unsigned char code[4l];
};

struct png_color_16_struct
{
  // index
  unsigned char index;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // gray
  unsigned short int gray;
};

struct png_color_8_struct
{
  // red
  unsigned char red;
  // green
  unsigned char green;
  // blue
  unsigned char blue;
  // gray
  unsigned char gray;
  // alpha
  unsigned char alpha;
};

struct png_color_struct
{
  // red
  unsigned char red;
  // green
  unsigned char green;
  // blue
  unsigned char blue;
};

struct png_time_struct
{
  // year
  unsigned short int year;
  // month
  unsigned char month;
  // day
  unsigned char day;
  // hour
  unsigned char hour;
  // minute
  unsigned char minute;
  // second
  unsigned char second;
};

struct png_info_struct
{
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // valid
  unsigned long int valid;
  // rowbytes
  unsigned long int rowbytes;
  // palette
  struct png_color_struct *palette;
  // num_palette
  unsigned short int num_palette;
  // num_trans
  unsigned short int num_trans;
  // bit_depth
  unsigned char bit_depth;
  // color_type
  unsigned char color_type;
  // compression_type
  unsigned char compression_type;
  // filter_type
  unsigned char filter_type;
  // interlace_type
  unsigned char interlace_type;
  // channels
  unsigned char channels;
  // pixel_depth
  unsigned char pixel_depth;
  // spare_byte
  unsigned char spare_byte;
  // signature
  unsigned char signature[8l];
  // gamma
  float gamma;
  // srgb_intent
  unsigned char srgb_intent;
  // num_text
  signed int num_text;
  // max_text
  signed int max_text;
  // text
  struct png_text_struct *text;
  // mod_time
  struct png_time_struct mod_time;
  // sig_bit
  struct png_color_8_struct sig_bit;
  // trans
  unsigned char *trans;
  // trans_values
  struct png_color_16_struct trans_values;
  // background
  struct png_color_16_struct background;
  // x_offset
  signed long int x_offset;
  // y_offset
  signed long int y_offset;
  // offset_unit_type
  unsigned char offset_unit_type;
  // x_pixels_per_unit
  unsigned long int x_pixels_per_unit;
  // y_pixels_per_unit
  unsigned long int y_pixels_per_unit;
  // phys_unit_type
  unsigned char phys_unit_type;
  // hist
  unsigned short int *hist;
  // x_white
  float x_white;
  // y_white
  float y_white;
  // x_red
  float x_red;
  // y_red
  float y_red;
  // x_green
  float x_green;
  // y_green
  float y_green;
  // x_blue
  float x_blue;
  // y_blue
  float y_blue;
  // pcal_purpose
  char *pcal_purpose;
  // pcal_X0
  signed long int pcal_X0;
  // pcal_X1
  signed long int pcal_X1;
  // pcal_units
  char *pcal_units;
  // pcal_params
  char **pcal_params;
  // pcal_type
  unsigned char pcal_type;
  // pcal_nparams
  unsigned char pcal_nparams;
  // free_me
  unsigned long int free_me;
  // unknown_chunks
  struct png_unknown_chunk_t *unknown_chunks;
  // unknown_chunks_num
  unsigned long int unknown_chunks_num;
  // iccp_name
  char *iccp_name;
  // iccp_profile
  char *iccp_profile;
  // iccp_proflen
  unsigned long int iccp_proflen;
  // iccp_compression
  unsigned char iccp_compression;
  // splt_palettes
  struct png_sPLT_struct *splt_palettes;
  // splt_palettes_num
  unsigned long int splt_palettes_num;
  // scal_unit
  unsigned char scal_unit;
  // scal_pixel_width
  double scal_pixel_width;
  // scal_pixel_height
  double scal_pixel_height;
  // scal_s_width
  char *scal_s_width;
  // scal_s_height
  char *scal_s_height;
  // row_pointers
  unsigned char **row_pointers;
  // int_gamma
  signed long int int_gamma;
  // int_x_white
  signed long int int_x_white;
  // int_y_white
  signed long int int_y_white;
  // int_x_red
  signed long int int_x_red;
  // int_y_red
  signed long int int_y_red;
  // int_x_green
  signed long int int_x_green;
  // int_y_green
  signed long int int_y_green;
  // int_x_blue
  signed long int int_x_blue;
  // int_y_blue
  signed long int int_y_blue;
};

struct png_row_info_struct
{
  // width
  unsigned long int width;
  // rowbytes
  unsigned long int rowbytes;
  // color_type
  unsigned char color_type;
  // bit_depth
  unsigned char bit_depth;
  // channels
  unsigned char channels;
  // pixel_depth
  unsigned char pixel_depth;
};

struct png_sPLT_entry_struct
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
  // frequency
  unsigned short int frequency;
};

struct png_sPLT_struct
{
  // name
  char *name;
  // depth
  unsigned char depth;
  // entries
  struct png_sPLT_entry_struct *entries;
  // nentries
  signed long int nentries;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};

struct png_unknown_chunk_t
{
  // name
  unsigned char name[5l];
  // data
  unsigned char *data;
  // size
  unsigned long int size;
  // location
  unsigned char location;
};

struct png_struct_def
{
  // jmpbuf
  struct __jmp_buf_tag jmpbuf[1l];
  // error_fn
  void (*error_fn)(struct png_struct_def *, const char *);
  // warning_fn
  void (*warning_fn)(struct png_struct_def *, const char *);
  // error_ptr
  void *error_ptr;
  // write_data_fn
  void (*write_data_fn)(struct png_struct_def *, unsigned char *, unsigned long int);
  // read_data_fn
  void (*read_data_fn)(struct png_struct_def *, unsigned char *, unsigned long int);
  // io_ptr
  void *io_ptr;
  // read_user_transform_fn
  void (*read_user_transform_fn)(struct png_struct_def *, struct png_row_info_struct *, unsigned char *);
  // write_user_transform_fn
  void (*write_user_transform_fn)(struct png_struct_def *, struct png_row_info_struct *, unsigned char *);
  // user_transform_ptr
  void *user_transform_ptr;
  // user_transform_depth
  unsigned char user_transform_depth;
  // user_transform_channels
  unsigned char user_transform_channels;
  // mode
  unsigned long int mode;
  // flags
  unsigned long int flags;
  // transformations
  unsigned long int transformations;
  // zstream
  struct z_stream_s zstream;
  // zbuf
  unsigned char *zbuf;
  // zbuf_size
  unsigned long int zbuf_size;
  // zlib_level
  signed int zlib_level;
  // zlib_method
  signed int zlib_method;
  // zlib_window_bits
  signed int zlib_window_bits;
  // zlib_mem_level
  signed int zlib_mem_level;
  // zlib_strategy
  signed int zlib_strategy;
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // num_rows
  unsigned long int num_rows;
  // usr_width
  unsigned long int usr_width;
  // rowbytes
  unsigned long int rowbytes;
  // user_chunk_cache_max
  unsigned long int user_chunk_cache_max;
  // iwidth
  unsigned long int iwidth;
  // row_number
  unsigned long int row_number;
  // prev_row
  unsigned char *prev_row;
  // row_buf
  unsigned char *row_buf;
  // sub_row
  unsigned char *sub_row;
  // up_row
  unsigned char *up_row;
  // avg_row
  unsigned char *avg_row;
  // paeth_row
  unsigned char *paeth_row;
  // row_info
  struct png_row_info_struct row_info;
  // idat_size
  unsigned long int idat_size;
  // crc
  unsigned long int crc;
  // palette
  struct png_color_struct *palette;
  // num_palette
  unsigned short int num_palette;
  // num_trans
  unsigned short int num_trans;
  // chunk_name
  unsigned char chunk_name[5l];
  // compression
  unsigned char compression;
  // filter
  unsigned char filter;
  // interlaced
  unsigned char interlaced;
  // pass
  unsigned char pass;
  // do_filter
  unsigned char do_filter;
  // color_type
  unsigned char color_type;
  // bit_depth
  unsigned char bit_depth;
  // usr_bit_depth
  unsigned char usr_bit_depth;
  // pixel_depth
  unsigned char pixel_depth;
  // channels
  unsigned char channels;
  // usr_channels
  unsigned char usr_channels;
  // sig_bytes
  unsigned char sig_bytes;
  // filler
  unsigned short int filler;
  // background_gamma_type
  unsigned char background_gamma_type;
  // background_gamma
  float background_gamma;
  // background
  struct png_color_16_struct background;
  // background_1
  struct png_color_16_struct background_1;
  // output_flush_fn
  void (*output_flush_fn)(struct png_struct_def *);
  // flush_dist
  unsigned long int flush_dist;
  // flush_rows
  unsigned long int flush_rows;
  // gamma_shift
  signed int gamma_shift;
  // gamma
  float gamma;
  // screen_gamma
  float screen_gamma;
  // gamma_table
  unsigned char *gamma_table;
  // gamma_from_1
  unsigned char *gamma_from_1;
  // gamma_to_1
  unsigned char *gamma_to_1;
  // gamma_16_table
  unsigned short int **gamma_16_table;
  // gamma_16_from_1
  unsigned short int **gamma_16_from_1;
  // gamma_16_to_1
  unsigned short int **gamma_16_to_1;
  // sig_bit
  struct png_color_8_struct sig_bit;
  // shift
  struct png_color_8_struct shift;
  // trans
  unsigned char *trans;
  // trans_values
  struct png_color_16_struct trans_values;
  // read_row_fn
  void (*read_row_fn)(struct png_struct_def *, unsigned long int, signed int);
  // write_row_fn
  void (*write_row_fn)(struct png_struct_def *, unsigned long int, signed int);
  // info_fn
  void (*info_fn)(struct png_struct_def *, struct png_info_struct *);
  // row_fn
  void (*row_fn)(struct png_struct_def *, unsigned char *, unsigned long int, signed int);
  // end_fn
  void (*end_fn)(struct png_struct_def *, struct png_info_struct *);
  // save_buffer_ptr
  unsigned char *save_buffer_ptr;
  // save_buffer
  unsigned char *save_buffer;
  // current_buffer_ptr
  unsigned char *current_buffer_ptr;
  // current_buffer
  unsigned char *current_buffer;
  // push_length
  unsigned long int push_length;
  // skip_length
  unsigned long int skip_length;
  // save_buffer_size
  unsigned long int save_buffer_size;
  // save_buffer_max
  unsigned long int save_buffer_max;
  // buffer_size
  unsigned long int buffer_size;
  // current_buffer_size
  unsigned long int current_buffer_size;
  // process_mode
  signed int process_mode;
  // cur_palette
  signed int cur_palette;
  // current_text_size
  unsigned long int current_text_size;
  // current_text_left
  unsigned long int current_text_left;
  // current_text
  char *current_text;
  // current_text_ptr
  char *current_text_ptr;
  // palette_lookup
  unsigned char *palette_lookup;
  // dither_index
  unsigned char *dither_index;
  // hist
  unsigned short int *hist;
  // time_buffer
  char *time_buffer;
  // free_me
  unsigned long int free_me;
  // user_chunk_ptr
  void *user_chunk_ptr;
  // read_user_chunk_fn
  signed int (*read_user_chunk_fn)(struct png_struct_def *, struct png_unknown_chunk_t *);
  // num_chunk_list
  signed int num_chunk_list;
  // chunk_list
  unsigned char *chunk_list;
  // rgb_to_gray_status
  unsigned char rgb_to_gray_status;
  // rgb_to_gray_red_coeff
  unsigned short int rgb_to_gray_red_coeff;
  // rgb_to_gray_green_coeff
  unsigned short int rgb_to_gray_green_coeff;
  // rgb_to_gray_blue_coeff
  unsigned short int rgb_to_gray_blue_coeff;
  // mng_features_permitted
  unsigned long int mng_features_permitted;
  // int_gamma
  signed long int int_gamma;
  // filter_type
  unsigned char filter_type;
  // mmx_bitdepth_threshold
  unsigned char mmx_bitdepth_threshold;
  // mmx_rowbytes_threshold
  unsigned long int mmx_rowbytes_threshold;
  // asm_flags
  unsigned long int asm_flags;
  // mem_ptr
  void *mem_ptr;
  // malloc_fn
  void * (*malloc_fn)(struct png_struct_def *, unsigned long int);
  // free_fn
  void (*free_fn)(struct png_struct_def *, void *);
  // big_row_buf
  unsigned char *big_row_buf;
  // dither_sort
  unsigned char *dither_sort;
  // index_to_palette
  unsigned char *index_to_palette;
  // palette_to_index
  unsigned char *palette_to_index;
  // compression_type
  unsigned char compression_type;
  // user_width_max
  unsigned long int user_width_max;
  // user_height_max
  unsigned long int user_height_max;
  // unknown_chunk
  struct png_unknown_chunk_t unknown_chunk;
  // old_big_row_buf_size
  unsigned long int old_big_row_buf_size;
  // old_prev_row_size
  unsigned long int old_prev_row_size;
  // chunkdata
  char *chunkdata;
};

struct png_text_struct
{
  // compression
  signed int compression;
  // key
  char *key;
  // text
  char *text;
  // text_length
  unsigned long int text_length;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous __sigaction_handler;
  // sa_mask
  struct anonymous$28 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct snap_header
{
  // dsap
  unsigned char dsap;
  // ssap
  unsigned char ssap;
  // ctl
  unsigned char ctl;
  // org1
  unsigned char org1;
  // org2
  unsigned char org2;
  // org3
  unsigned char org3;
  // ether_type
  unsigned short int ether_type;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct tcphdr
{
  // $anon0
  union anonymous$22 $anon0;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// audio_mpeg_player
// file playaudio.c line 39
char *audio_mpeg_player = "mpg123 -";
// backing_image
// file display.c line 51
static struct _img *backing_image;
// beep_on_image
// file display.c line 44
static signed int beep_on_image;
// bitrate_tbl
// file mpeghdr.c line 23
static signed int bitrate_tbl[16l][5l] = { { 0, 0, 0, 0, 0 }, { 32, 32, 32, 32, 8 }, { 64, 48, 40, 48, 16 }, { 96, 56, 48, 56, 24 }, { 128, 64, 56, 64, 32 }, { 160, 80, 64, 80, 40 }, { 192, 96, 80, 96, 48 }, { 224, 112, 96, 112, 56 }, { 256, 128, 112, 128, 64 }, { 288, 160, 128, 144, 80 }, { 320, 192, 160, 160, 96 }, { 352, 224, 192, 176, 112 }, { 384, 256, 224, 192, 128 }, { 416, 320, 256, 224, 144 }, { 448, 384, 320, 256, 160 }, { -1, -1, -1, -1, -1 } };
// buffered
// file playaudio.c line 105
static unsigned long int buffered;
// channel_tbl
// file mpeghdr.c line 136
static char *channel_tbl[4l] = { "stereo", "joint stereo", "dual stereo", "mono" };
// click
// file display.c line 295
static struct anonymous$8 click;
// darea
// file display.c line 47
static struct _GtkWidget *darea;
// datalink_info
// file packetcapture.c line 54
static struct anonymous$16 datalink_info;
// drawable
// file display.c line 48
static struct _GdkDrawable *drawable;
// driver
// file media.c line 72
static struct mediadrv driver[5l];
// driver
// file media.c line 72
static struct mediadrv driver[5l] = { { .name="gif", .type=(enum mediatype)1, .find_data=find_gif_image, .dispatch_data=dispatch_image },
    { .name="jpeg", .type=(enum mediatype)1, .find_data=find_jpeg_image,
    .dispatch_data=dispatch_image },
    { .name="png", .type=(enum mediatype)1, .find_data=find_png_image, .dispatch_data=dispatch_image },
    { .name="mpeg", .type=(enum mediatype)2, .find_data=find_mpeg_stream,
    .dispatch_data=dispatch_mpeg_audio },
    { .name="HTTP", .type=(enum mediatype)4, .find_data=find_http_req,
    .dispatch_data=dispatch_http_req } };
// extract_type
// file media.c line 33
static enum mediatype extract_type;
// filedrvs
// file img.c line 65
struct filedrv filedrvs[3l];
// filedrvs
// file img.c line 65
struct filedrv filedrvs[3l] = { { .type=(enum anonymous$57)gif, .suffices=".gif\0", .loadhdr=gif_load_hdr,
    .abortload=gif_abort_load, .loadimg=gif_load_img,
    .saveimg=(signed int (*)(struct _img *, struct _IO_FILE *))(void *)0 },
    { .type=(enum anonymous$57)jpeg, .suffices=".jpg\0.jpeg\0", .loadhdr=jpeg_load_hdr,
    .abortload=jpeg_abort_load, .loadimg=jpeg_load_img,
    .saveimg=jpeg_save_img },
    { .type=(enum anonymous$57)png, .suffices=".png\0", .loadhdr=png_load_hdr,
    .abortload=(signed int (*)(struct _img *))(void *)0, .loadimg=png_load_img,
    .saveimg=(signed int (*)(struct _img *, struct _IO_FILE *))(void *)0 } };
// foad
// file driftnet.c line 55
signed int foad;
// height
// file display.c line 50
static signed int height;
// imgpipe_readfd
// file display.c line 42
static signed int imgpipe_readfd;
// imgpipe_writefd
// file display.c line 43
static signed int imgpipe_writefd;
// imgrects
// file display.c line 59
static struct imgrect *imgrects;
// list
// file playaudio.c line 57
static struct _audiochunk *list;
// loglevel
// file log.c line 29
static enum anonymous$25 loglevel = (enum anonymous$25)LOG_WARNING;
// mpeg_fd
// file playaudio.c line 132
signed int mpeg_fd;
// mpeg_mgr_pid
// file playaudio.c line 224
signed int mpeg_mgr_pid;
// mpeg_mtx
// file playaudio.c line 41
static union anonymous$0 mpeg_mtx = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// nimgrects
// file display.c line 58
static signed int nimgrects;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// options
// file options.c line 30
struct anonymous$2 options = { .tmpdir=(const char *)(void *)0, .tmpdir_especified=0, .max_tmpfiles=0,
    .extract_images=1, .verbose=0, .adjunct=0,
    .beep=0, .promisc=1, .dumpfile=(char *)(void *)0, .interface=(char *)(void *)0,
    .filterexpr=(char *)(void *)0, .extract_type=(enum mediatype)1,
    .audio_mpeg_player=(char *)(void *)0, .mpeg_player_specified=0,
    .newpfx=0, .savedimgpfx="driftnet-" };
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// pc
// file packetcapture.c line 53
static struct pcap *pc = (struct pcap *)(void *)0;
// pidfile_fd
// file pid.c line 33
static signed int pidfile_fd = -1;
// play_media
// file media.c line 34
static signed int play_media;
// rd
// file playaudio.c line 57
static struct _audiochunk *rd;
// rowheight
// file display.c line 50
static signed int rowheight;
// samplerate_tbl
// file mpeghdr.c line 44
static signed int samplerate_tbl[4l][3l] = { { 44100, 22050, 11025 }, { 48000, 24000, 12000 }, { 32000, 16000, 8000 }, { -1, -1, -1 } };
// savedimg_prefix
// file display.c line 45
static char *savedimg_prefix;
// slots
// file connection.c line 28
static struct _connection **slots = (struct _connection **)(void *)0;
// slotsalloc
// file connection.c line 29
static unsigned int slotsalloc = (unsigned int)0;
// slotsused
// file connection.c line 29
static unsigned int slotsused;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tmpdir
// file tmpdir.c line 57
static struct anonymous$55 tmpdir = { .path=(const char *)(void *)0, .type=(enum anonymous$51)TMPDIR_USER_OWNED, .max_files=0,
    .preserve_files=1 };
// vers_tbl
// file mpeghdr.c line 135
static char *vers_tbl[4l] = { "unknown", "1", "2", "2.5" };
// width
// file display.c line 50
static signed int width;
// window
// file display.c line 47
static struct _GtkWidget *window;
// wr
// file playaudio.c line 57
static struct _audiochunk *wr;
// wrx
// file display.c line 50
static signed int wrx;
// wry
// file display.c line 50
static signed int wry;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1)
{
  signed long int return_value___builtin_bswap32$1$link1;
  return_value___builtin_bswap32$1$link1=__builtin_bswap32((signed long int)__bsx$link1);
  return (unsigned int)return_value___builtin_bswap32$1$link1;
}

// add_image_rectangle
// file display.c line 193
void add_image_rectangle(const char *filename, const signed int x, const signed int y, const signed int w, const signed int h)
{
  struct imgrect *ir = imgrects;
  for( ; !(ir >= imgrects + (signed long int)nimgrects); ir = ir + 1l)
    if(ir->filename == ((char *)NULL))
      break;

  if(ir == imgrects + (signed long int)nimgrects)
  {
    void *return_value_xrealloc$1;
    return_value_xrealloc$1=xrealloc((void *)imgrects, (unsigned long int)(2 * nimgrects) * sizeof(struct imgrect) /*24ul*/ );
    imgrects = (struct imgrect *)return_value_xrealloc$1;
    memset((void *)(imgrects + (signed long int)nimgrects), 0, (unsigned long int)nimgrects * sizeof(struct imgrect) /*24ul*/ );
    ir = imgrects + (signed long int)nimgrects;
    nimgrects = nimgrects * 2;
  }

  char *return_value___strdup$2;
  return_value___strdup$2=__strdup(filename);
  ir->filename = return_value___strdup$2;
  ir->x = x;
  ir->y = y;
  ir->w = w;
  ir->h = h;
}

// alloc_connection
// file connection.c line 54
struct _connection ** alloc_connection(void)
{
  struct _connection **C = slots;
  for( ; !(C >= slots + (signed long int)slotsalloc); C = C + 1l)
    if(*C == ((struct _connection *)NULL))
      return C;

  void *return_value_xrealloc$1;
  return_value_xrealloc$1=xrealloc((void *)slots, (unsigned long int)(slotsalloc * (unsigned int)2) * sizeof(struct _connection *) /*8ul*/ );
  slots = (struct _connection **)return_value_xrealloc$1;
  memset((void *)(slots + (signed long int)slotsalloc), 0, (unsigned long int)slotsalloc * sizeof(struct _connection *) /*8ul*/ );
  C = slots + (signed long int)slotsalloc;
  slotsalloc = slotsalloc * (unsigned int)2;
  return C;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// audiochunk_delete
// file playaudio.c line 74
static void audiochunk_delete(struct _audiochunk *A)
{
  xfree((void *)A->data);
  xfree((void *)A);
}

// audiochunk_new
// file playaudio.c line 61
static struct _audiochunk * audiochunk_new(const unsigned char *data, const unsigned long int len)
{
  struct _audiochunk *A;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct _audiochunk) /*24ul*/ );
  A = (struct _audiochunk *)return_value_xmalloc$1;
  memset((void *)A, 0, sizeof(struct _audiochunk) /*24ul*/ );
  A->len = len;
  if(!(data == ((const unsigned char *)NULL)))
  {
    void *return_value_xmalloc$2;
    return_value_xmalloc$2=xmalloc(len);
    A->data = (unsigned char *)return_value_xmalloc$2;
    memcpy((void *)A->data, (const void *)data, len);
  }

  return A;
}

// audiochunk_write
// file playaudio.c line 83
static signed int audiochunk_write(struct _audiochunk * const A, signed int fd)
{
  const unsigned char *p;
  signed long int n;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  if(A->len == 0ul)
    return 0;

  else
  {
    p = A->data;
    do
    {
      unsigned long int d = (unsigned long int)1024;
      if(!(A->data + (signed long int)A->len >= p + (signed long int)d))
        d = (unsigned long int)((A->data + (signed long int)A->len) - p);

      n=write(fd, (const void *)p, d);
      if(n == -1l)
      {
        return_value___errno_location$1=__errno_location();
        tmp_if_expr$2 = *return_value___errno_location$1 != 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        return -1;

      else
        p = p + (signed long int)d;
    }
    while(!(p >= A->data + (signed long int)A->len));
    return 0;
  }
}

// button_press_event
// file display.c line 297
void button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event)
{
  click.x = (signed int)event->x;
  click.y = (signed int)event->y;
}

// button_release_event
// file display.c line 302
void button_release_event(struct _GtkWidget *widget, struct _GdkEventButton *event)
{
  struct imgrect *ir;
  ir=find_image_rectangle(click.x, click.y);
  struct imgrect *return_value_find_image_rectangle$1;
  if(!(ir == ((struct imgrect *)NULL)))
  {
    return_value_find_image_rectangle$1=find_image_rectangle((signed int)event->x, (signed int)event->y);
    if(ir == return_value_find_image_rectangle$1)
    {
      gdk_draw_rectangle(drawable, darea->style->white_gc, 0, ir->x - 2, ir->y - 2, ir->w + 3, ir->h + 3);
      gdk_flush();
      save_image(ir);
      xnanosleep((signed long int)100000000);
      gdk_draw_rectangle(drawable, darea->style->black_gc, 0, ir->x - 2, ir->y - 2, ir->w + 3, ir->h + 3);
    }

  }

}

// capture_thread
// file driftnet.c line 98
static void * capture_thread(void *v)
{
  while(foad == 0)
    packetcapture_dispatch();
  return (void *)0;
}

// check_dir_is_rw
// file tmpdir.h line 27
signed int check_dir_is_rw(const char *dir)
{
  struct stat st;
  signed int return_value_stat$6;
  return_value_stat$6=stat(dir, &st);
  signed int return_value_access$5;
  if(return_value_stat$6 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_msg((enum anonymous$25)LOG_ERROR, "stat(%s): %s", dir, return_value_strerror$2);
    unexpected_exit(-1);
  }

  else
    if(!((61440u & st.st_mode) == 16384u))
    {
      log_msg((enum anonymous$25)LOG_ERROR, "%s: not a directory", dir);
      unexpected_exit(-1);
    }

    else
    {
      return_value_access$5=access(dir, 4 | 2);
      if(!(return_value_access$5 == 0))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        log_msg((enum anonymous$25)LOG_ERROR, "%s: %s", dir, return_value_strerror$4);
        unexpected_exit(-1);
      }

    }
  return 0;
}

// clean_tmpdir
// file tmpdir.h line 24
void clean_tmpdir(void)
{
  struct __dirstream *d;
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strlen$4;
  void *return_value_xrealloc$5;
  signed int *return_value___errno_location$11;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if(!(tmpdir.path == ((const char *)NULL)))
  {
    if(tmpdir.preserve_files == 0)
    {
      d=opendir(tmpdir.path);
      if(!(d == ((struct __dirstream *)NULL)))
      {
        struct dirent *de;
        char *buf;
        unsigned long int buflen;
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(tmpdir.path);
        buflen = return_value_strlen$1 + (unsigned long int)64;
        void *return_value_xmalloc$2;
        return_value_xmalloc$2=xmalloc(buflen);
        buf = (char *)return_value_xmalloc$2;
        do
        {
          de=readdir(d);
          if(de == ((struct dirent *)NULL))
            break;

          signed int return_value_is_tempfile$8;
          return_value_is_tempfile$8=is_tempfile(de->d_name);
          if(!(return_value_is_tempfile$8 == 0))
          {
            unsigned long int return_value_strlen$6;
            return_value_strlen$6=strlen(tmpdir.path);
            unsigned long int return_value_strlen$7;
            return_value_strlen$7=strlen(de->d_name);
            if(!(buflen >= 1ul + return_value_strlen$6 + return_value_strlen$7))
            {
              return_value_strlen$3=strlen(tmpdir.path);
              return_value_strlen$4=strlen(de->d_name);
              buflen = return_value_strlen$3 + return_value_strlen$4 + (unsigned long int)64;
              return_value_xrealloc$5=xrealloc((void *)buf, buflen);
              buf = (char *)return_value_xrealloc$5;
            }

            sprintf(buf, "%s/%s", tmpdir.path, (const void *)de->d_name);
            unlink(buf);
          }

        }
        while((_Bool)1);
        closedir(d);
        xfree((void *)buf);
      }

      if((signed int)tmpdir.type == TMPDIR_APP_OWNED)
      {
        signed int return_value_rmdir$12;
        return_value_rmdir$12=rmdir(tmpdir.path);
        if(return_value_rmdir$12 == -1)
        {
          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 2))
          {
            return_value___errno_location$9=__errno_location();
            return_value_strerror$10=strerror(*return_value___errno_location$9);
            log_msg((enum anonymous$25)LOG_ERROR, "rmdir(%s): %s", tmpdir.path, return_value_strerror$10);
          }

        }

      }

    }

    xfree((void *)tmpdir.path);
    tmpdir.path = (const char *)(void *)0;
  }

}

// close_pidfile
// file pid.h line 15
void close_pidfile(void)
{
  if(pidfile_fd >= 1)
  {
    close(pidfile_fd);
    pidfile_fd = -1;
  }

}

// configure_event
// file display.c line 236
void configure_event(struct _GtkWidget *widget, union _GdkEvent *event, void *data)
{
  if(!(darea == ((struct _GtkWidget *)NULL)))
    drawable = darea->window;

  unsigned long int return_value_gdk_drawable_get_type$1;
  return_value_gdk_drawable_get_type$1=gdk_drawable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)drawable, return_value_gdk_drawable_get_type$1);
  gdk_drawable_get_size((struct _GdkDrawable *)return_value_g_type_check_instance_cast$2, &width, &height);
  _Bool tmp_if_expr$3;
  if(backing_image == ((struct _img *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = backing_image->width != (unsigned int)width ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = backing_image->height != (unsigned int)height ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
    make_backing_image();

  update_window();
}

// connection_alloc_slots
// file connection.c line 33
void connection_alloc_slots(void)
{
  slotsused = (unsigned int)0;
  slotsalloc = (unsigned int)64;
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc((unsigned long int)slotsalloc, sizeof(struct _connection *) /*8ul*/ );
  slots = (struct _connection **)return_value_xcalloc$1;
}

// connection_delete
// file connection.c line 207
void connection_delete(struct _connection *c)
{
  struct datablock *b = c->blocks;
  while(!(b == ((struct datablock *)NULL)))
  {
    struct datablock *b2 = b->next;
    free((void *)b);
    b = b2;
  }
  free((void *)c->data);
  free((void *)c);
}

// connection_free_slots
// file connection.c line 40
void connection_free_slots(void)
{
  struct _connection **C = slots;
  for( ; !(C >= slots + (signed long int)slotsalloc); C = C + 1l)
    if(!(*C == ((struct _connection *)NULL)))
      connection_delete(*C);

  xfree((void *)slots);
}

// connection_new
// file connection.c line 187
struct _connection * connection_new(struct sockaddr *src, struct sockaddr *dst)
{
  struct _connection *c;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct _connection) /*304ul*/ );
  c = (struct _connection *)return_value_xmalloc$1;
  memset((void *)c, 0, sizeof(struct _connection) /*304ul*/ );
  memcpy((void *)&c->src, (const void *)src, sizeof(struct sockaddr_storage) /*128ul*/ );
  memcpy((void *)&c->dst, (const void *)dst, sizeof(struct sockaddr_storage) /*128ul*/ );
  c->alloc = (unsigned int)16384;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc((unsigned long int)c->alloc);
  c->data = (unsigned char *)return_value_xmalloc$2;
  c->last=time((signed long int *)(void *)0);
  c->blocks = (struct datablock *)(void *)0;
  return c;
}

// connection_push
// file connection.c line 224
void connection_push(struct _connection *c, const unsigned char *data, unsigned int off, unsigned int len)
{
  struct datablock *B;
  struct datablock *b;
  struct datablock *bl;
  struct datablock BZ = { .off=0, .len=0, .moff={ 0, 0, 0, 0, 0 }, .dirty=0,
    .next=((struct datablock *)NULL) };
  signed int a;
  /* assertion c->alloc > 0 */
  assert(c->alloc > (unsigned int)0);
  if(!(c->alloc >= len + off))
  {
    do
      c->alloc = c->alloc * (unsigned int)2;
    while(!(c->alloc >= len + off));
    void *return_value_xrealloc$1;
    return_value_xrealloc$1=xrealloc((void *)c->data, (unsigned long int)c->alloc);
    c->data = (unsigned char *)return_value_xrealloc$1;
  }

  memcpy((void *)(c->data + (signed long int)off), (const void *)data, (unsigned long int)len);
  if(!(c->len >= len + off))
    c->len = off + len;

  c->last=time((signed long int *)(void *)0);
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc(sizeof(struct datablock) /*40ul*/ );
  B = (struct datablock *)return_value_xmalloc$2;
  *B = BZ;
  B->off = (signed int)off;
  B->len = (signed int)len;
  B->dirty = 1;
  B->next = (struct datablock *)(void *)0;
  b = c->blocks;
  bl = (struct datablock *)(void *)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  do
  {
    if(b == ((struct datablock *)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = off <= (unsigned int)b->off ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      if(bl == ((struct datablock *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = off > (unsigned int)bl->off ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        B->next = b;
        if(!(bl == ((struct datablock *)NULL)))
          bl->next = B;

        else
          c->blocks = B;
        break;
      }

    }

    bl = b;
    b = b->next;
  }
  while((_Bool)1);
  do
  {
    a = 0;
    b = c->blocks;
    for( ; !(b == ((struct datablock *)NULL)); b = b->next)
      if(!(b->next == ((struct datablock *)NULL)))
      {
        if(b->len + b->off >= b->next->off)
        {
          struct datablock *bb = b->next;
          b->len = (bb->off + bb->len) - b->off;
          b->next = bb->next;
          b->dirty = 1;
          free((void *)bb);
          a = a + 1;
        }

      }

  }
  while(!(a == 0));
}

// connection_string
// file connection.c line 94
char * connection_string(struct sockaddr *src, struct sockaddr *dst)
{
  unsigned long int len = (unsigned long int)272;
  static char buf[272l];
  char *p = buf;
  print_ipport_pair(src, p, len);
  len=strlen(buf);
  p = buf + (signed long int)len;
  snprintf(p, (unsigned long int)5, " -> ");
  len=strlen(buf);
  p = buf + (signed long int)len;
  print_ipport_pair(dst, p, (unsigned long int)272 - len);
  return buf;
}

// count_tmpfiles
// file tmpdir.c line 234
static signed int count_tmpfiles(void)
{
  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  static signed int num;
  static signed long int last_counted;
  if(!(last_counted >= return_value_time$2 + -5l))
  {
    struct __dirstream *d;
    struct dirent *de;
    num = 0;
    d=opendir(tmpdir.path);
    if(!(d == ((struct __dirstream *)NULL)))
    {
      do
      {
        de=readdir(d);
        if(de == ((struct dirent *)NULL))
          break;

        signed int return_value_is_tempfile$1;
        return_value_is_tempfile$1=is_tempfile(de->d_name);
        if(!(return_value_is_tempfile$1 == 0))
          num = num + 1;

      }
      while((_Bool)1);
      closedir(d);
      last_counted=time((signed long int *)(void *)0);
    }

  }

  return num;
}

// create_pidfile
// file pid.h line 14
void create_pidfile(void)
{
  signed int flags;
  char buf[64l];
  struct flock fl;
  pidfile_fd=open("/tmp/driftnet.pid", 02 | 0100, 0400 | 0200);
  if(pidfile_fd == -1)
  {
    log_msg((enum anonymous$25)LOG_ERROR, "Could not open/create PID file %s", (const void *)"/tmp/driftnet.pid");
    exit(-1);
  }

  flags=fcntl(pidfile_fd, 1);
  if(flags == -1)
  {
    log_msg((enum anonymous$25)LOG_ERROR, "Could not get flags for PID file %s", (const void *)"/tmp/driftnet.pid");
    exit(-1);
  }

  flags = flags | 1;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(pidfile_fd, 2, flags);
  if(return_value_fcntl$1 == -1)
  {
    log_msg((enum anonymous$25)LOG_ERROR, "Could not set flags for PID file %s", (const void *)"/tmp/driftnet.pid");
    exit(-1);
  }

  fl.l_type = (signed short int)1;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl$5;
  return_value_fcntl$5=fcntl(pidfile_fd, 6, &fl);
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(return_value_fcntl$5 == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 11)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value___errno_location$3=__errno_location();
      tmp_if_expr$4 = *return_value___errno_location$3 == 13 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      log_msg((enum anonymous$25)LOG_WARNING, "PID file '%s' is locked; probably the program is already running", (const void *)"/tmp/driftnet.pid");
      log_msg((enum anonymous$25)LOG_WARNING, "if not, try to remove the file %s", (const void *)"/tmp/driftnet.pid");
      exit(0);
    }

    else
    {
      log_msg((enum anonymous$25)LOG_ERROR, "Unable to lock PID file '%s'", (const void *)"/tmp/driftnet.pid");
      exit(-1);
    }
  }

  signed int return_value_ftruncate$6;
  return_value_ftruncate$6=ftruncate(pidfile_fd, (signed long int)0);
  if(return_value_ftruncate$6 == -1)
  {
    log_msg((enum anonymous$25)LOG_ERROR, "Could not truncate PID file '%s'", (const void *)"/tmp/driftnet.pid");
    close(pidfile_fd);
    exit(-1);
  }

  signed int return_value_getpid$7;
  return_value_getpid$7=getpid();
  snprintf(buf, (unsigned long int)64, "%ld\n", (signed long int)return_value_getpid$7);
  unsigned long int return_value_strlen$8;
  return_value_strlen$8=strlen(buf);
  signed long int return_value_write$9;
  return_value_write$9=write(pidfile_fd, (const void *)buf, return_value_strlen$8);
  unsigned long int return_value_strlen$10;
  return_value_strlen$10=strlen(buf);
  if(!((unsigned long int)return_value_write$9 == return_value_strlen$10))
  {
    log_msg((enum anonymous$25)LOG_ERROR, "writing to PID file '%s'", (const void *)"/tmp/driftnet.pid");
    close(pidfile_fd);
    exit(-1);
  }

}

// delete_event
// file display.c line 101
signed int delete_event(struct _GtkWidget *widget, union _GdkEvent *event, void *data)
{
  log_msg((enum anonymous$25)LOG_INFO, "display child shutting down\n");
  return 0;
}

// destroy
// file display.c line 316
void destroy(struct _GtkWidget *widget, void *data)
{
  gtk_main_quit();
}

// dispatch_http_req
// file http.h line 23
void dispatch_http_req(const char *mname, const unsigned char *data, const unsigned long int len)
{
  char *url;
  const char *path;
  const char *host;
  signed int pathlen;
  signed int hostlen;
  const unsigned char *p;
  p=memstr(data, len, (unsigned char *)"\r\n", (const unsigned long int)2);
  if(!(p == ((const unsigned char *)NULL)))
  {
    path = (const char *)(data + (signed long int)4);
    pathlen = (signed int)((p - (signed long int)9) - (unsigned char *)path);
    signed int return_value_memcmp$3;
    return_value_memcmp$3=memcmp((const void *)path, (const void *)"http://", (unsigned long int)7);
    if(return_value_memcmp$3 == 0)
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)(pathlen + 1));
      url = (char *)return_value_malloc$1;
      sprintf(url, "%.*s", pathlen, path);
    }

    else
    {
      p=memstr(p, len - (unsigned long int)(p - data), (unsigned char *)"\r\nHost: ", (const unsigned long int)8);
      if(p == ((const unsigned char *)NULL))
        goto __CPROVER_DUMP_L7;

      host = (const char *)(p + (signed long int)8);
      p=memstr(p + (signed long int)8, len - (unsigned long int)((p + (signed long int)8) - data), (unsigned char *)"\r\n", (const unsigned long int)2);
      if(p == ((const unsigned char *)NULL))
        goto __CPROVER_DUMP_L7;

      hostlen = (signed int)(p - (const unsigned char *)host);
      if(hostlen == 0)
        goto __CPROVER_DUMP_L7;

      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)(hostlen + pathlen + 9));
      url = (char *)return_value_malloc$2;
      sprintf(url, "http://%.*s%.*s", hostlen, host, pathlen, path);
    }
    fprintf(stderr, "\n\n  %s\n\n", url);
    free((void *)url);
  }


__CPROVER_DUMP_L7:
  ;
}

// dispatch_image
// file media.c line 40
void dispatch_image(const char *mname, const unsigned char *data, const unsigned long int len)
{
  const char *name;
  name=tmpfile_write(mname, data, len);
  const char *return_value_get_tmpdir$1;
  if(!(name == ((const char *)NULL)))
  {
    if(play_media == 0)
    {
      return_value_get_tmpdir$1=get_tmpdir();
      printf("%s/%s\n", return_value_get_tmpdir$1, name);
    }

    else
      display_send_img(name, (unsigned long int)64);
  }

}

// dispatch_mpeg_audio
// file media.c line 62
void dispatch_mpeg_audio(const char *mname, const unsigned char *data, const unsigned long int len)
{
  mpeg_submit_chunk(data, len);
}

// display_send_img
// file ../../src/display/display.h line 22
void display_send_img(const char *name, unsigned long int len)
{
  write(imgpipe_writefd, (const void *)name, len);
}

// do_gtkdisplay
// file display.c line 419
static void do_gtkdisplay(void)
{
  struct _GIOChannel *chan;
  struct imgrect *ir;
  chan=g_io_channel_unix_new(imgpipe_readfd);
  g_io_add_watch(chan, (enum anonymous$62)(G_IO_IN | G_IO_ERR | G_IO_HUP), (signed int (*)(struct _GIOChannel *, enum anonymous$62, void *))pipe_event, (void *)0);
  fcntl(imgpipe_readfd, 4, 04000);
  nimgrects = 16;
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc((unsigned long int)nimgrects, sizeof(struct imgrect) /*24ul*/ );
  imgrects = (struct imgrect *)return_value_xcalloc$1;
  gtk_init(((signed int *)NULL), (char ***)(void *)0);
  struct _GdkColormap *return_value_gdk_rgb_get_colormap$2;
  return_value_gdk_rgb_get_colormap$2=gdk_rgb_get_colormap();
  gtk_widget_push_colormap(return_value_gdk_rgb_get_colormap$2);
  window=gtk_window_new((enum anonymous$56)GTK_WINDOW_TOPLEVEL);
  gtk_widget_set_size_request(window, 320 + 2 * 6, 240 + 2 * 6);
  darea=gtk_drawing_area_new();
  unsigned long int return_value_gtk_container_get_type$3;
  return_value_gtk_container_get_type$3=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_container_get_type$3);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$4, darea);
  gtk_widget_set_events(darea, 2 | 256 | 512);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$5, "delete_event", (void (*)(void))delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$42)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6, "destroy", (void (*)(void))destroy, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$42)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)darea, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$7, "expose-event", (void (*)(void))expose_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$42)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)darea, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$8, "configure_event", (void (*)(void))expose_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$42)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)darea, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$9, "button_press_event", (void (*)(void))button_press_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$42)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)darea, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$10, "button_release_event", (void (*)(void))button_release_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$42)0);
  gtk_widget_show_all(window);
  gtk_main();
  ir = imgrects;
  for( ; !(ir >= imgrects + (signed long int)nimgrects); ir = ir + 1l)
    if(!(ir->filename == ((char *)NULL)))
      unlink(ir->filename);

  img_delete(backing_image);
  gtk_exit(0);
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// do_image_display
// file ./display/display.h line 20
void do_image_display(char *img_prefix, signed int beep)
{
  signed int dpychld;
  signed int pfd[2l];
  pipe(pfd);
  dpychld=fork();
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(dpychld == 0))
  {
    if(dpychld == -1)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    close(pfd[(signed long int)1]);
    imgpipe_readfd = pfd[(signed long int)0];
    beep_on_image = beep;
    savedimg_prefix = img_prefix;
    do_gtkdisplay();
    unexpected_exit(-1);

  __CPROVER_DUMP_L2:
    ;
    return_value___errno_location$1=__errno_location();
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    log_msg((enum anonymous$25)LOG_ERROR, "fork failed, reason: %s", return_value_strerror$2);
    unexpected_exit(-1);
  }
  close(pfd[(signed long int)0]);
  imgpipe_writefd = pfd[(signed long int)1];
  log_msg((enum anonymous$25)LOG_INFO, "started display child, pid %d", (signed int)dpychld);
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// do_mpeg_player
// file ./media/playaudio.h line 16
void do_mpeg_player(void)
{
  signed int pp[2l];
  unsigned long int thr;
  list=audiochunk_new((const unsigned char *)(void *)0, (const unsigned long int)0);
  wr = list;
  rd = wr;
  pipe(pp);
  mpeg_mgr_pid=fork();
  if(mpeg_mgr_pid == 0)
  {
    close(pp[(signed long int)1]);
    dup2(pp[(signed long int)0], 0);
    mpeg_player_manager();
    unexpected_exit(-1);
  }

  else
  {
    close(pp[(signed long int)0]);
    mpeg_fd = pp[(signed long int)1];
    pthread_create(&thr, (const union pthread_attr_t *)(void *)0, mpeg_play, (void *)rd);
  }
}

// expose_event
// file display.c line 225
void expose_event(struct _GtkWidget *widget, union _GdkEvent *event, void *data)
{
  if(!(darea == ((struct _GtkWidget *)NULL)))
    drawable = darea->window;

  unsigned long int return_value_gdk_drawable_get_type$1;
  return_value_gdk_drawable_get_type$1=gdk_drawable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)drawable, return_value_gdk_drawable_get_type$1);
  gdk_drawable_get_size((struct _GdkDrawable *)return_value_g_type_check_instance_cast$2, &width, &height);
  _Bool tmp_if_expr$3;
  if(backing_image == ((struct _img *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = backing_image->width != (unsigned int)width ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = backing_image->height != (unsigned int)height ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
    make_backing_image();

  update_window();
}

// extract_media
// file ./media/media.h line 33
void extract_media(struct _connection *c)
{
  struct datablock *b = c->blocks;
  signed int return_value_tmpfiles_limit_reached$1;
  for( ; !(b == ((struct datablock *)NULL)); b = b->next)
    if(b->len >= 1)
    {
      if(!(b->dirty == 0))
      {
        signed int i = 0;
        for( ; !(i >= 5); i = i + 1)
          if(!(((signed int)driver[(signed long int)i].type & (signed int)extract_type) == 0))
          {
            unsigned char *ptr;
            unsigned char *oldptr;
            unsigned char *media;
            unsigned long int mlen;
            ptr = c->data + (signed long int)b->off + (signed long int)b->moff[(signed long int)i];
            oldptr = (unsigned char *)(void *)0;
            if(!(ptr == oldptr))
            {
              if(!(ptr >= c->data + (signed long int)b->off + (signed long int)b->len))
              {
                oldptr = ptr;
                ptr=driver[(signed long int)i].find_data(ptr, (const unsigned long int)((signed long int)(b->off + b->len) - (ptr - c->data)), &media, &mlen);
                if(!(media == ((unsigned char *)NULL)))
                {
                  return_value_tmpfiles_limit_reached$1=tmpfiles_limit_reached();
                  if(return_value_tmpfiles_limit_reached$1 == 0)
                    driver[(signed long int)i].dispatch_data(driver[(signed long int)i].name, media, mlen);

                }

              }

            }

            b->moff[(signed long int)i] = (signed int)((ptr - c->data) - (signed long int)b->off);
          }

        b->dirty = 0;
      }

    }

}

// find_connection
// file connection.c line 75
struct _connection ** find_connection(struct sockaddr *src, struct sockaddr *dst)
{
  struct _connection **C = slots;
  signed int return_value_memcmp$2;
  signed int return_value_memcmp$1;
  for( ; !(C >= slots + (signed long int)slotsalloc); C = C + 1l)
  {
    struct _connection *c = *C;
    if(!(c == ((struct _connection *)NULL)))
    {
      return_value_memcmp$2=memcmp((const void *)&c->src, (const void *)src, sizeof(struct sockaddr_storage) /*128ul*/ );
      if(return_value_memcmp$2 == 0)
      {
        return_value_memcmp$1=memcmp((const void *)&c->dst, (const void *)dst, sizeof(struct sockaddr_storage) /*128ul*/ );
        if(return_value_memcmp$1 == 0)
          return C;

      }

    }

  }
  return (struct _connection **)(void *)0;
}

// find_gif_image
// file image.h line 16
unsigned char * find_gif_image(const unsigned char *data, const unsigned long int len, unsigned char **gifdata, unsigned long int *giflen)
{
  unsigned char *gifhdr;
  unsigned char *block;
  signed int ncolours;
  *gifdata = (unsigned char *)(void *)0;
  if(!(len >= 6ul))
    return (unsigned char *)data;

  else
  {
    gifhdr=memstr(data, len, (unsigned char *)"GIF89a", (const unsigned long int)6);
    if(gifhdr == ((unsigned char *)NULL))
      gifhdr=memstr(data, len, (unsigned char *)"GIF87a", (const unsigned long int)6);

    if(gifhdr == ((unsigned char *)NULL))
      return (unsigned char *)((data + (signed long int)len) - (signed long int)6);

    else
      if(!((data + (signed long int)len) - gifhdr >= 14l))
        return gifhdr;

      else
      {
        ncolours = 1 << ((signed int)gifhdr[(signed long int)10] & 0x7) + 1;
        block = gifhdr + (signed long int)13;
        if(block >= data + (signed long int)len)
          return gifhdr;

        else
        {
          if(!((0x80 & (signed int)gifhdr[10l]) == 0))
            block = block + (signed long int)(3 * ncolours);

          if(block >= data + (signed long int)len)
            return gifhdr;

          else
            while((_Bool)1)
              switch((signed int)*block)
              {
                case 0x2c:
                {
                  if(!(data + (signed long int)len >= block + 9l))
                    return gifhdr;

                  if(!((0x80 & (signed int)block[9l]) == 0))
                  {
                    block = block + (signed long int)(3 * (1 << ((signed int)gifhdr[(signed long int)9] & 0x7) + 1));
                    if(block >= data + (signed long int)len)
                      return gifhdr;

                  }

                  block = block + (signed long int)10;
                  block = block + 1l;
                  while((_Bool)1)
                  {
                    if(block >= data + (signed long int)len)
                      return gifhdr;

                    block = block + (signed long int)((signed int)*block + 1);
                    if(block >= data + (signed long int)len)
                      return gifhdr;

                    if(*block == 0)
                      break;

                  }
                  block = block + 1l;
                  if(block >= data + (signed long int)len)
                    return gifhdr;

                  break;
                }
                case 0x21:
                {
                  block = block + 1l;
                  if(block >= data + (signed long int)len)
                    return gifhdr;

                  if((signed int)*block == 0xf9)
                  {
                    block = block + 1l;
                    if(block >= data + (signed long int)len)
                      return gifhdr;

                    block = block + (signed long int)((signed int)*block + 2);
                    if(block >= data + (signed long int)len)
                      return gifhdr;

                    break;
                  }

                  else
                    if((signed int)*block == 0xfe)
                    {
                      block = block + 1l;
                      while((_Bool)1)
                      {
                        if(block >= data + (signed long int)len)
                          return gifhdr;

                        block = block + (signed long int)((signed int)*block + 1);
                        if(block >= data + (signed long int)len)
                          return gifhdr;

                        if(*block == 0)
                          break;

                      }
                      block = block + 1l;
                      if(block >= data + (signed long int)len)
                        return gifhdr;

                    }

                    else
                      if((signed int)*block == 0x01)
                      {
                        block = block + 1l;
                        if(block >= data + (signed long int)len)
                          return gifhdr;

                        if(!((signed int)*block == 12))
                          return gifhdr + (signed long int)6;

                        block = block + (signed long int)13;
                        while((_Bool)1)
                        {
                          if(block >= data + (signed long int)len)
                            return gifhdr;

                          block = block + (signed long int)((signed int)*block + 1);
                          if(block >= data + (signed long int)len)
                            return gifhdr;

                          if(*block == 0)
                            break;

                        }
                        block = block + 1l;
                        if(block >= data + (signed long int)len)
                          return gifhdr;

                      }

                      else
                        if((signed int)*block == 0xff)
                        {
                          block = block + 1l;
                          if(block >= data + (signed long int)len)
                            return gifhdr;

                          if(!((signed int)*block == 11))
                            return gifhdr + (signed long int)6;

                          block = block + (signed long int)12;
                          while((_Bool)1)
                          {
                            if(block >= data + (signed long int)len)
                              return gifhdr;

                            block = block + (signed long int)((signed int)*block + 1);
                            if(block >= data + (signed long int)len)
                              return gifhdr;

                            if(*block == 0)
                              break;

                          }
                          block = block + 1l;
                          if(block >= data + (signed long int)len)
                            return gifhdr;

                        }

                        else
                          return gifhdr + (signed long int)6;
                  break;
                }
                case 0x3b:
                {
                  *gifdata = gifhdr;
                  *giflen = (unsigned long int)((block - gifhdr) + (signed long int)1);
                  return block + (signed long int)1;
                }
                default:
                  return gifhdr + (signed long int)6;
              }
        }
      }
  }
}

// find_http_req
// file http.h line 20
unsigned char * find_http_req(const unsigned char *data, const unsigned long int len, unsigned char **http, unsigned long int *httplen)
{
  unsigned char *req;
  unsigned char *le;
  unsigned char *blankline;
  unsigned char *hosthdr;
  _Bool tmp_if_expr$3;
  char *return_value___builtin_strchr$2;
  _Bool tmp_if_expr$6;
  signed int return_value_memcmp$5;
  if(!(len >= 40ul))
    return (unsigned char *)data;

  else
  {
    req=memstr(data, len, (unsigned char *)"GET ", (const unsigned long int)4);
    if(req == ((unsigned char *)NULL))
    {
      req=memstr(data, len, (unsigned char *)"POST ", (const unsigned long int)5);
      if(!(req == ((unsigned char *)NULL)))
        goto __CPROVER_DUMP_L2;

      return (unsigned char *)((data + (signed long int)len) - (signed long int)4);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      le=memstr(req + (signed long int)4, len - (unsigned long int)((req + (signed long int)4) - data), (unsigned char *)"\r\n", (const unsigned long int)2);
      if(le == ((unsigned char *)NULL))
      {
        if(len + -((unsigned long int)((req + 4l) - data)) >= 16385ul)
          return (unsigned char *)(req + (signed long int)4);

        return (unsigned char *)req;
      }

      else
        if(!(le >= req + 5l))
          return le + (signed long int)2;

        else
        {
          signed int return_value_memcmp$1;
          return_value_memcmp$1=memcmp((const void *)(le - (signed long int)9), (const void *)" HTTP/1.", (unsigned long int)8);
          if(!(return_value_memcmp$1 == 0))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value___builtin_strchr$2=__builtin_strchr("01", (signed int)*(le - (signed long int)1));
            tmp_if_expr$3 = !(return_value___builtin_strchr$2 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
            return le + (signed long int)2;

          else
          {
            blankline=memstr(le + (signed long int)2, len - (unsigned long int)((le + (signed long int)2) - data), (unsigned char *)"\r\n\r\n", (const unsigned long int)4);
            if(blankline == ((unsigned char *)NULL))
            {
              if(len + -((unsigned long int)((le + 2l) - data)) >= 16385ul)
                return (unsigned char *)((data + (signed long int)len) - (signed long int)4);

              return req;
            }

            else
            {
              signed int return_value_memcmp$4;
              return_value_memcmp$4=memcmp((const void *)(req + (signed long int)4), (const void *)"http://", (unsigned long int)7);
              if(return_value_memcmp$4 == 0)
                tmp_if_expr$6 = (_Bool)1;

              else
              {
                return_value_memcmp$5=memcmp((const void *)(req + (signed long int)5), (const void *)"http://", (unsigned long int)7);
                tmp_if_expr$6 = return_value_memcmp$5 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(!tmp_if_expr$6)
              {
                hosthdr=memstr(le, (const unsigned long int)((blankline - le) + (signed long int)2), (unsigned char *)"\r\nHost: ", (const unsigned long int)8);
                if(!(hosthdr == ((unsigned char *)NULL)))
                  goto found;

                return blankline + (signed long int)4;
              }

              else
              {

              found:
                ;
                *http = req;
                *httplen = (unsigned long int)(blankline - req);
                return blankline + (signed long int)4;
              }
            }
          }
        }
    }
  }
}

// find_image_rectangle
// file display.c line 215
struct imgrect * find_image_rectangle(const signed int x, const signed int y)
{
  struct imgrect *ir = imgrects;
  for( ; !(ir >= imgrects + (signed long int)nimgrects); ir = ir + 1l)
    if(!(ir->filename == ((char *)NULL)))
    {
      if(x >= ir->x)
      {
        if(!(x >= ir->w + ir->x))
        {
          if(y >= ir->y)
          {
            if(!(y >= ir->h + ir->y))
              return ir;

          }

        }

      }

    }

  return (struct imgrect *)(void *)0;
}

// find_jpeg_image
// file image.h line 19
unsigned char * find_jpeg_image(const unsigned char *data, const unsigned long int len, unsigned char **jpegdata, unsigned long int *jpeglen)
{
  unsigned char *jpeghdr;
  unsigned char *block;
  *jpegdata = (unsigned char *)(void *)0;
  jpeghdr=memstr(data, len, (unsigned char *)"", (const unsigned long int)2);
  if(jpeghdr == ((unsigned char *)NULL))
    return (unsigned char *)((data + (signed long int)len) - (signed long int)1);

  else
    if(!(data + (signed long int)len >= jpeghdr + 2l))
      return jpeghdr;

    else
    {
      block=jpeg_next_marker(jpeghdr + (signed long int)2, (len - (unsigned long int)2) - (unsigned long int)(jpeghdr - data));
      if(block == ((unsigned char *)NULL) || (unsigned long int)(block - data) >= len)
        return jpeghdr;

      else
      {
        do
        {
          block=jpeg_skip_block(block + (signed long int)1, len - (unsigned long int)((block + (signed long int)1) - data));
          if(block == ((unsigned char *)NULL))
            break;

          block=jpeg_next_marker(block, len - (unsigned long int)(block - data));
          if(block == ((unsigned char *)NULL) || (unsigned long int)(block - data) >= len)
            return jpeghdr;

          if((signed int)*block == 0xda)
          {
            block=memstr(block, len - (unsigned long int)(block - data), (unsigned char *)"", (const unsigned long int)2);
            if(!(block == ((unsigned char *)NULL)))
            {
              *jpegdata = jpeghdr;
              *jpeglen = (unsigned long int)((block + (signed long int)2) - jpeghdr);
              return block + (signed long int)2;
            }

            else
              break;
          }

        }
        while((_Bool)1);
        return jpeghdr;
      }
    }
}

// find_mpeg_stream
// file audio.h line 16
unsigned char * find_mpeg_stream(const unsigned char *data, const unsigned long int len, unsigned char **mpegdata, unsigned long int *mpeglen)
{
  unsigned char *stream_start;
  unsigned char *p;
  struct mpeg_audio_hdr H;
  *mpegdata = (unsigned char *)(void *)0;
  _Bool tmp_if_expr$4;
  signed int return_value_mpeg_hdr_parse$3;
  if(!(len >= 4ul))
    return (unsigned char *)data;

  else
  {
    p = (unsigned char *)data;
    while(!(p >= data + (signed long int)len + -4l))
    {
      signed int nframes;
      unsigned char *q;
      void *return_value_memchr$1;
      return_value_memchr$1=memchr((const void *)p, 0xff, (len - (unsigned long int)4) - (unsigned long int)(p - data));
      stream_start = (unsigned char *)return_value_memchr$1;
      if(stream_start == ((unsigned char *)NULL))
        return (unsigned char *)((data + (signed long int)len) - (signed long int)4);

      if(!((0xe0 & (signed int)stream_start[1l]) == 0xe0))
        p = stream_start + (signed long int)1;

      else
      {
        signed int return_value_mpeg_hdr_parse$2;
        return_value_mpeg_hdr_parse$2=mpeg_hdr_parse(stream_start, &H);
        if(return_value_mpeg_hdr_parse$2 == 0)
          p = stream_start + (signed long int)1;

        else
        {
          nframes = 0;
          q = stream_start;
          do
          {
            signed int delta;
            nframes = nframes + 1;
            delta=mpeg_hdr_nextframe_offset(&H);
            if(delta == 0)
              return q + (signed long int)1;

            q = q + (signed long int)delta;
            if(!(q >= data + (signed long int)len + -4l) && !(nframes >= 100))
            {
              return_value_mpeg_hdr_parse$3=mpeg_hdr_parse(q, &H);
              tmp_if_expr$4 = return_value_mpeg_hdr_parse$3 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$4 = (_Bool)0;
          }
          while(tmp_if_expr$4);
          if(nframes >= 100)
          {
            *mpegdata = stream_start;
            *mpeglen = (unsigned long int)(q - stream_start);
            return q;
          }

          else
            return stream_start;
        }
      }
    }
    return p;
  }
}

// find_png_eoi
// file image.c line 213
unsigned char * find_png_eoi(unsigned char *buffer, const unsigned long int len)
{
  unsigned char *end_data;
  unsigned char *data;
  unsigned char chunk_code[5l];
  struct png_chunk chunk;
  unsigned int datalen;
  data = buffer + (signed long int)8;
  end_data = (buffer + (signed long int)len) - (signed long int)(sizeof(struct png_chunk) /*8ul*/  + (unsigned long int)4);
  while(end_data >= data)
  {
    memcpy((void *)&chunk, (const void *)data, sizeof(struct png_chunk) /*8ul*/ );
    memset((void *)chunk_code, 0, (unsigned long int)(4 + 1));
    memcpy((void *)chunk_code, (const void *)chunk.code, (unsigned long int)4);
    datalen=__bswap_32$link1(chunk.datalen);
    signed int return_value_strncasecmp$1;
    return_value_strncasecmp$1=strncasecmp((char *)chunk_code, "iend", (unsigned long int)4);
    if(return_value_strncasecmp$1 == 0)
      return (unsigned char *)(data + (signed long int)sizeof(struct png_chunk) /*8ul*/  + (signed long int)4);

    if(!(len + -((unsigned long int)(data - buffer)) >= (unsigned long int)datalen))
      return (unsigned char *)(void *)0;

    data = data + (signed long int)(sizeof(struct png_chunk) /*8ul*/  + (unsigned long int)datalen + (unsigned long int)4);
  }
  return (unsigned char *)(void *)0;
}

// find_png_image
// file image.h line 22
unsigned char * find_png_image(const unsigned char *data, const unsigned long int len, unsigned char **pngdata, unsigned long int *pnglen)
{
  unsigned char *pnghdr;
  unsigned char *data_end;
  unsigned char *png_eoi;
  *pngdata = (unsigned char *)(void *)0;
  if(!(len >= 8ul))
    return (unsigned char *)data;

  else
  {
    pnghdr=memstr(data, len, (unsigned char *)"PNG\r\n\032\n", (const unsigned long int)8);
    if(pnghdr == ((unsigned char *)NULL))
      return (unsigned char *)((data + (signed long int)len) - (signed long int)8);

    else
    {
      data_end = (unsigned char *)(data + (signed long int)len);
      png_eoi=find_png_eoi(pnghdr, (const unsigned long int)(data_end - pnghdr));
      if(png_eoi == ((unsigned char *)NULL))
        return pnghdr;

      else
      {
        *pngdata = pnghdr;
        *pnglen = (unsigned long int)(png_eoi - pnghdr);
        return png_eoi;
      }
    }
  }
}

// get_datalink_info
// file packetcapture.c line 232
static struct anonymous$16 get_datalink_info(struct pcap *pcap)
{
  struct anonymous$16 info;
  info.type=pcap_datalink(pcap);
  signed int return_value_pcap_datalink$1;
  return_value_pcap_datalink$1=pcap_datalink(pcap);
  info.name=pcap_datalink_val_to_name(return_value_pcap_datalink$1);
  return info;
}

// get_default_interface
// file packetcapture.h line 28
char * get_default_interface(void)
{
  char ebuf[256l];
  char *interface;
  interface=pcap_lookupdev(ebuf);
  if(interface == ((char *)NULL))
  {
    log_msg((enum anonymous$25)LOG_ERROR, "pcap_lookupdev: %s", (const void *)ebuf);
    log_msg((enum anonymous$25)LOG_ERROR, "try specifying an interface with -i");
    log_msg((enum anonymous$25)LOG_ERROR, "or a pcap capture file with -f");
    unexpected_exit(-1);
  }

  return interface;
}

// get_levelstring
// file log.c line 97
static char * get_levelstring(enum anonymous$25 level)
{
  switch((signed int)level)
  {
    case LOG_INFO:
      return "info";
    case LOG_WARNING:
      return "warning";
    case LOG_ERROR:
      return "error";
    default:
    {
      fprintf(stderr, "driftnet: get_level_string(): internal error");
      unexpected_exit(-1);
      return (char *)(void *)0;
    }
  }
}

// get_loglevel
// file log.c line 34
enum anonymous$25 get_loglevel(void)
{
  return loglevel;
}

// get_timestring
// file log.c line 83
char * get_timestring(void)
{
  signed long int timee;
  struct tm *timeinfo;
  time(&timee);
  timeinfo=localtime(&timee);
  static char time_s[80l];
  strftime(time_s, (unsigned long int)80, "%a %b %d %H:%M:%S %Y", timeinfo);
  return time_s;
}

// get_tmpdir
// file tmpdir.c line 75
const char * get_tmpdir(void)
{
  /* assertion tmpdir.path != ((void *)0) */
  assert(tmpdir.path != (const char *)(void *)0);
  return tmpdir.path;
}

// gif_abort_load
// file img.c line 35
signed int gif_abort_load(struct _img *I)
{
  DGifCloseFile((struct GifFileType *)I->us, (signed int *)(void *)0);
  return 1;
}

// gif_load_hdr
// file img.c line 34
signed int gif_load_hdr(struct _img *I)
{
  struct GifFileType *g;
  signed int return_value_fileno$1;
  return_value_fileno$1=fileno(I->fp);
  struct GifFileType *return_value_DGifOpenFileHandle$2;
  return_value_DGifOpenFileHandle$2=DGifOpenFileHandle(return_value_fileno$1, (signed int *)(void *)0);
  I->us = (void *)return_value_DGifOpenFileHandle$2;
  g = (struct GifFileType *)I->us;
  if(I->us == NULL)
  {
    I->err = (enum anonymous$59)IE_HDRFORMAT;
    return 0;
  }

  else
  {
    I->width = (unsigned int)g->SWidth;
    I->height = (unsigned int)g->SHeight;
    return 1;
  }
}

// gif_load_img
// file img.c line 36
signed int gif_load_img(struct _img *I)
{
  struct GifFileType *g = (struct GifFileType *)I->us;
  struct SavedImage *si;
  signed int ret = 0;
  unsigned char *p;
  unsigned char *end;
  struct GifColorType *pal;
  unsigned int *q;
  signed int return_value_DGifSlurp$1;
  return_value_DGifSlurp$1=DGifSlurp(g);
  _Bool tmp_if_expr$2;
  if(return_value_DGifSlurp$1 == 0)
  {
    I->err = (enum anonymous$59)IE_IMGFORMAT;
    return 0;
  }

  else
  {
    img_alloc(I);
    if(!(g->ImageCount >= 1))
      I->err = (enum anonymous$59)IE_IMGFORMAT;

    else
    {
      si = g->SavedImages;
      if(!((unsigned int)si->ImageDesc.Width == I->width))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (unsigned int)si->ImageDesc.Height != I->height ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        I->err = (enum anonymous$59)IE_IMGFORMAT;

      else
      {
        if(!(si->ImageDesc.ColorMap == ((struct ColorMapObject *)NULL)))
          pal = si->ImageDesc.ColorMap->Colors;

        else
          pal = g->SColorMap->Colors;
        if(!(si->ImageDesc.Interlace == (_Bool)0))
        {
          signed int i;
          unsigned char *gifsrc = si->RasterBits;
          i = 0;
          for( ; !((unsigned int)i >= I->height); i = i + 8)
          {
            p = gifsrc;
            q = I->data[(signed long int)i];
            for( ; !(p >= gifsrc + (signed long int)I->width); q = q + 1l)
            {
              *q = (unsigned int)((signed int)(unsigned char)(pal + (signed long int)*p)->Red | (signed int)(unsigned char)(pal + (signed long int)*p)->Green << 8 | (signed int)(unsigned char)(pal + (signed long int)*p)->Blue << 16 | (signed int)(unsigned char)((signed int)*p == g->SBackGroundColor ? 255 : 0) << 24);
              p = p + 1l;
            }
            gifsrc = gifsrc + (signed long int)I->width;
          }
          i = 4;
          for( ; !((unsigned int)i >= I->height); i = i + 8)
          {
            p = gifsrc;
            q = I->data[(signed long int)i];
            for( ; !(p >= gifsrc + (signed long int)I->width); q = q + 1l)
            {
              *q = (unsigned int)((signed int)(unsigned char)(pal + (signed long int)*p)->Red | (signed int)(unsigned char)(pal + (signed long int)*p)->Green << 8 | (signed int)(unsigned char)(pal + (signed long int)*p)->Blue << 16 | (signed int)(unsigned char)((signed int)*p == g->SBackGroundColor ? 255 : 0) << 24);
              p = p + 1l;
            }
            gifsrc = gifsrc + (signed long int)I->width;
          }
          i = 2;
          for( ; !((unsigned int)i >= I->height); i = i + 4)
          {
            p = gifsrc;
            q = I->data[(signed long int)i];
            for( ; !(p >= gifsrc + (signed long int)I->width); q = q + 1l)
            {
              *q = (unsigned int)((signed int)(unsigned char)(pal + (signed long int)*p)->Red | (signed int)(unsigned char)(pal + (signed long int)*p)->Green << 8 | (signed int)(unsigned char)(pal + (signed long int)*p)->Blue << 16 | (signed int)(unsigned char)((signed int)*p == g->SBackGroundColor ? 255 : 0) << 24);
              p = p + 1l;
            }
            gifsrc = gifsrc + (signed long int)I->width;
          }
          i = 1;
          for( ; !((unsigned int)i >= I->height); i = i + 2)
          {
            p = gifsrc;
            q = I->data[(signed long int)i];
            for( ; !(p >= gifsrc + (signed long int)I->width); q = q + 1l)
            {
              *q = (unsigned int)((signed int)(unsigned char)(pal + (signed long int)*p)->Red | (signed int)(unsigned char)(pal + (signed long int)*p)->Green << 8 | (signed int)(unsigned char)(pal + (signed long int)*p)->Blue << 16 | (signed int)(unsigned char)((signed int)*p == g->SBackGroundColor ? 255 : 0) << 24);
              p = p + 1l;
            }
            gifsrc = gifsrc + (signed long int)I->width;
          }
        }

        else
        {
          p = (unsigned char *)si->RasterBits;
          end = p + (signed long int)(I->width * I->height);
          q = I->flat;
          for( ; !(p >= end); q = q + 1l)
          {
            *q = (unsigned int)((signed int)(unsigned char)(pal + (signed long int)*p)->Red | (signed int)(unsigned char)(pal + (signed long int)*p)->Green << 8 | (signed int)(unsigned char)(pal + (signed long int)*p)->Blue << 16 | (signed int)(unsigned char)((signed int)*p == g->SBackGroundColor ? 255 : 0) << 24);
            p = p + 1l;
          }
        }
        ret = 1;
      }
    }

  fail:
    ;
    DGifCloseFile(g, (signed int *)(void *)0);
    return ret;
  }
}

// handle_link_layer
// file layer2.h line 36
signed int handle_link_layer(struct anonymous$16 *info, const unsigned char *pkt, unsigned int caplen, unsigned char *nextproto, signed int *offsetnext)
{
  unsigned short int llnextproto = (unsigned short int)0;
  struct ieee80211_radiotap_header *radiotap_header;
  const unsigned char *next_header;
  struct ethhdr *eptr;
  unsigned long int remaining_len;
  unsigned short int tmp_statement_expression$1;
  signed int return_value_parse_ieee80211$2;
  signed int return_value_parse_ieee80211$3;
  switch(info->type)
  {
    case 1:
    {
      eptr = (struct ethhdr *)pkt;
      *offsetnext = (signed int)sizeof(struct ethhdr) /*14ul*/ ;
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)eptr->h_proto;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$1 = __v;
      llnextproto = tmp_statement_expression$1;
      break;
    }
    case 127:
    {
      radiotap_header = (struct ieee80211_radiotap_header *)pkt;
      next_header = pkt + (signed long int)radiotap_header->it_len;
      remaining_len = (unsigned long int)(caplen - (unsigned int)radiotap_header->it_len);
      return_value_parse_ieee80211$2=parse_ieee80211(next_header, (unsigned int)remaining_len, &llnextproto, offsetnext);
      if(!(return_value_parse_ieee80211$2 == 0))
        return -1;

      *offsetnext = *offsetnext + (signed int)radiotap_header->it_len;
      break;
    }
    case 105:
    {
      return_value_parse_ieee80211$3=parse_ieee80211(pkt, caplen, &llnextproto, offsetnext);
      if(!(return_value_parse_ieee80211$3 == 0))
        return -1;

      break;
    }
    default:
    {
      log_msg((enum anonymous$25)LOG_WARNING, "link-level (%s) header is not supported", info->name);
      return -1;
    }
  }
  switch((signed int)llnextproto)
  {
    case 0x0800:
    {
      *nextproto = (unsigned char)0;
      break;
    }
    case 0x86DD:
    {
      *nextproto = (unsigned char)41;
      break;
    }
    case 0x0806:

    case 0x888E:
      return -1;
    default:
    {
      log_msg((enum anonymous$25)LOG_WARNING, "link-level next protocol (%hd) is not supported", llnextproto);
      return -1;
    }
  }
  return 0;
}

// img_alloc
// file img.h line 72
void img_alloc(struct _img *I)
{
  unsigned int **p;
  unsigned int *q;
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc((unsigned long int)I->height * sizeof(unsigned int *) /*8ul*/  + (unsigned long int)(I->width * I->height) * sizeof(unsigned int) /*4ul*/ , (unsigned long int)1);
  I->data = (unsigned int **)return_value_xcalloc$1;
  I->flat = (unsigned int *)(I->data + (signed long int)I->height);
  p = I->data;
  q = I->flat;
  for( ; !(p >= I->data + (signed long int)I->height); q = q + (signed long int)I->width)
  {
    *p = q;
    p = p + 1l;
  }
}

// img_clip
// file img.c line 222
inline void img_clip(struct _img * const I, signed int *x, signed int *y)
{
  signed int return_value_img_clip_adj_x$1;
  return_value_img_clip_adj_x$1=img_clip_adj_x(I, *x);
  *x = *x + return_value_img_clip_adj_x$1;
  signed int return_value_img_clip_adj_y$2;
  return_value_img_clip_adj_y$2=img_clip_adj_y(I, *y);
  *y = *y + return_value_img_clip_adj_y$2;
}

// img_clip_adj_x
// file img.c line 208
inline signed int img_clip_adj_x(struct _img * const I, const signed int x)
{
  if(!(x >= 0))
    return -x;

  else
    if((unsigned int)x >= I->width)
      return (signed int)(I->width - (unsigned int)x);

    else
      return 0;
}

// img_clip_adj_y
// file img.c line 214
inline signed int img_clip_adj_y(struct _img * const I, const signed int y)
{
  if(!(y >= 0))
    return -y;

  else
    if((unsigned int)y >= I->height)
      return (signed int)(I->height - (unsigned int)y);

    else
      return 0;
}

// img_delete
// file img.h line 82
void img_delete(struct _img *I)
{
  if(!(I->data == ((unsigned int **)NULL)))
    xfree((void *)I->data);

  if(!(I->fp == ((struct _IO_FILE *)NULL)))
    fclose(I->fp);

  xfree((void *)I);
}

// img_load
// file img.h line 74
signed int img_load(struct _img *I, const enum anonymous$58 howmuch, const enum anonymous$57 type)
{
  signed int i;
  _Bool tmp_if_expr$1;
  signed int return_value;
  if((signed int)type == unknown)
  {
    I->err = (enum anonymous$59)IE_UNKNOWNTYPE;
    return 0;
  }

  else
    if(I->fp == ((struct _IO_FILE *)NULL))
    {
      I->err = (enum anonymous$59)IE_NOSTREAM;
      return 0;
    }

    else
      if((signed int)howmuch == none)
        return 1;

      else
      {
        i = 0;
        for( ; !((unsigned long int)i >= 3ul); i = i + 1)
          if(filedrvs[(signed long int)i].type == type)
          {
            signed int r;
            if((signed int)howmuch == header)
              tmp_if_expr$1 = filedrvs[(signed long int)i].loadhdr != ((signed int (*)(struct _img *))NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            if(tmp_if_expr$1)
            {
              r=filedrvs[(signed long int)i].loadhdr(I);
              if(!(r == 0))
                I->load = howmuch;

              return r;
            }

            else
              if(!(filedrvs[(signed long int)i].loadimg == ((signed int (*)(struct _img *))NULL)))
              {
                if(!((signed int)I->load == header))
                {
                  if(!(filedrvs[(signed long int)i].loadhdr == ((signed int (*)(struct _img *))NULL)))
                  {
                    return_value=filedrvs[(signed long int)i].loadhdr(I);
                    if(return_value == 0)
                      return 0;

                  }

                }

                I->load = (enum anonymous$58)header;
                r=filedrvs[(signed long int)i].loadimg(I);
                if(!(r == 0))
                  I->load = (enum anonymous$58)full;

                return r;
              }

          }

      }
  I->err = (enum anonymous$59)IE_UNKNOWNTYPE;
  return 0;
}

// img_load_file
// file img.h line 76
signed int img_load_file(struct _img *I, const char *name, const enum anonymous$58 howmuch, const enum anonymous$57 type)
{
  signed int return_value_strcasecmp$3;
  unsigned long int return_value_strlen$1;
  signed int return_value_img_load$4;
  if((signed int)howmuch == none)
    return 1;

  else
  {
    I->fp=fopen(name, "rb");
    if(I->fp == ((struct _IO_FILE *)NULL))
    {
      I->err = (enum anonymous$59)IE_SYSERROR;
      return 0;
    }

    else
    {
      if((signed int)type == unknown)
      {
        char *p;
        signed int i;
        p=strrchr(name, 46);
        i = 0;
        for( ; !((unsigned long int)i >= 3ul); i = i + 1)
        {
          char *q = filedrvs[(signed long int)i].suffices;
          for( ; !(*q == 0); q = q + (signed long int)(return_value_strlen$1 + (unsigned long int)1))
          {
            return_value_strcasecmp$3=strcasecmp(p, q);
            if(return_value_strcasecmp$3 == 0)
            {
              I->type = filedrvs[(signed long int)i].type;
              signed int return_value_img_load$2;
              return_value_img_load$2=img_load(I, howmuch, I->type);
              return return_value_img_load$2;
            }

            return_value_strlen$1=strlen(q);
          }
        }
      }

      else
      {
        return_value_img_load$4=img_load(I, howmuch, type);
        return return_value_img_load$4;
      }
      I->err = (enum anonymous$59)IE_UNKNOWNTYPE;
      return 0;
    }
  }
}

// img_load_stream
// file img.c line 155
signed int img_load_stream(struct _img *I, struct _IO_FILE *fp, const enum anonymous$58 howmuch, const enum anonymous$57 type)
{
  I->fp = fp;
  signed int return_value_img_load$1;
  return_value_img_load$1=img_load(I, howmuch, type);
  return return_value_img_load$1;
}

// img_new
// file img.h line 70
struct _img * img_new(void)
{
  struct _img *I;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct _img) /*56ul*/ );
  I = (struct _img *)return_value_xmalloc$1;
  memset((void *)I, 0, sizeof(struct _img) /*56ul*/ );
  return I;
}

// img_new_blank
// file img.h line 71
struct _img * img_new_blank(const unsigned int width, const unsigned int height)
{
  struct _img *I;
  I=img_new();
  I->width = width;
  I->height = height;
  I->load = (enum anonymous$58)header;
  return I;
}

// img_save
// file img.c line 191
signed int img_save(struct _img * const I, struct _IO_FILE *fp, const enum anonymous$57 type)
{
  signed int i;
  signed int return_value;
  if((signed int)type == unknown)
  {
    I->err = (enum anonymous$59)IE_UNKNOWNTYPE;
    return 0;
  }

  else
  {
    i = 0;
    for( ; !((unsigned long int)i >= 3ul); i = i + 1)
      if(filedrvs[(signed long int)i].type == type)
      {
        if(!(filedrvs[(signed long int)i].saveimg == ((signed int (*)(struct _img *, struct _IO_FILE *))NULL)))
        {
          return_value=filedrvs[(signed long int)i].saveimg(I, fp);
          return return_value;
        }

      }

  }
  I->err = (enum anonymous$59)IE_UNKNOWNTYPE;
  return 0;
}

// img_simple_blt
// file img.h line 84
inline void img_simple_blt(struct _img *dest, const signed int dx, const signed int dy, struct _img *src, const signed int sx, const signed int sy, const signed int w, const signed int h)
{
  signed int y;
  signed int y2;
  y = sy;
  y2 = dy;
  for( ; !(y >= h + sy); y2 = y2 + 1)
  {
    memcpy((void *)(dest->data[(signed long int)y2] + (signed long int)dx), (const void *)(src->data[(signed long int)y] + (signed long int)sx), (unsigned long int)w * sizeof(unsigned int) /*4ul*/ );
    y = y + 1;
  }
}

// init_mediadrv
// file ./media/media.h line 32
void init_mediadrv(enum mediatype media_type, signed int play)
{
  extract_type = media_type;
  play_media = play;
}

// is_tempfile
// file tmpdir.c line 255
static signed int is_tempfile(const char *file)
{
  /* assertion file != ((void *)0) */
  assert(file != (const char *)(void *)0);
  char *p;
  p=strrchr(file, 46);
  signed int return_value_strncmp$12;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$5;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$8;
  signed int tmp_statement_expression$6;
  _Bool tmp_if_expr$11;
  signed int tmp_statement_expression$9;
  if(!(p == ((char *)NULL)))
  {
    return_value_strncmp$12=strncmp(file, "driftnet-", (unsigned long int)9);
    if(!(return_value_strncmp$12 == 0))
      goto __CPROVER_DUMP_L7;

    unsigned long int is_tempfile$$1$$2$$__s1_len;
    unsigned long int is_tempfile$$1$$2$$__s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(p, ".jpeg");
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(p, ".gif");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      tmp_if_expr$5 = tmp_statement_expression$3 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      unsigned long int is_tempfile$$1$$4$$__s1_len;
      unsigned long int is_tempfile$$1$$4$$__s2_len;
      signed int return_value___builtin_strcmp$7;
      return_value___builtin_strcmp$7=__builtin_strcmp(p, ".mp3");
      tmp_statement_expression$6 = return_value___builtin_strcmp$7;
      tmp_if_expr$8 = tmp_statement_expression$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
      tmp_if_expr$11 = (_Bool)1;

    else
    {
      unsigned long int is_tempfile$$1$$5$$__s1_len;
      unsigned long int is_tempfile$$1$$5$$__s2_len;
      signed int return_value___builtin_strcmp$10;
      return_value___builtin_strcmp$10=__builtin_strcmp(p, ".png");
      tmp_statement_expression$9 = return_value___builtin_strcmp$10;
      tmp_if_expr$11 = tmp_statement_expression$9 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$11)
      goto __CPROVER_DUMP_L7;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    return 0;
  }
}

// jpeg_abort_load
// file img.c line 40
signed int jpeg_abort_load(struct _img *I)
{
  jpeg_finish_decompress((struct jpeg_decompress_struct *)I->us);
  jpeg_destroy_decompress((struct jpeg_decompress_struct *)I->us);
  return 1;
}

// jpeg_load_hdr
// file img.c line 39
signed int jpeg_load_hdr(struct _img *I)
{
  struct jpeg_decompress_struct *cinfo;
  struct my_error_mgr *jerr;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct jpeg_decompress_struct) /*632ul*/ );
  cinfo = (struct jpeg_decompress_struct *)return_value_xmalloc$1;
  memset((void *)cinfo, 0, sizeof(struct jpeg_decompress_struct) /*632ul*/ );
  I->us = (void *)cinfo;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc(sizeof(struct my_error_mgr) /*368ul*/ );
  jerr = (struct my_error_mgr *)return_value_xmalloc$2;
  memset((void *)jerr, 0, sizeof(struct my_error_mgr) /*368ul*/ );
  cinfo->err=jpeg_std_error(&jerr->pub);
  jerr->pub.error_exit = my_error_exit;
  signed int return_value__setjmp$3;
  return_value__setjmp$3=_setjmp(jerr->jb);
  if(!(return_value__setjmp$3 == 0))
  {
    I->err = (enum anonymous$59)IE_HDRFORMAT;
    jpeg_destroy_decompress(cinfo);
    return 0;
  }

  else
  {
    jpeg_CreateDecompress(cinfo, 62, (unsigned long int)sizeof(struct jpeg_decompress_struct) /*632ul*/ );
    jpeg_stdio_src(cinfo, I->fp);
    jpeg_read_header(cinfo, 1);
    jpeg_start_decompress(cinfo);
    I->width = cinfo->output_width;
    I->height = cinfo->output_height;
    return 1;
  }
}

// jpeg_load_img
// file img.c line 41
signed int jpeg_load_img(struct _img *I)
{
  struct jpeg_decompress_struct *cinfo = (struct jpeg_decompress_struct *)I->us;
  struct my_error_mgr *jerr;
  unsigned char **buffer;
  img_alloc(I);
  jerr = (struct my_error_mgr *)cinfo->err;
  signed int return_value__setjmp$1;
  return_value__setjmp$1=_setjmp(jerr->jb);
  if(!(return_value__setjmp$1 == 0))
  {
    I->err = (enum anonymous$59)IE_IMGFORMAT;
    jpeg_destroy_decompress(cinfo);
    return 0;
  }

  else
  {
    cinfo->out_color_space = (enum anonymous$18)JCS_RGB;
    cinfo->output_components = 3;
    cinfo->out_color_components = cinfo->output_components;
    buffer=cinfo->mem->alloc_sarray((struct jpeg_common_struct *)cinfo, 1, cinfo->output_width * (unsigned int)cinfo->output_components, (unsigned int)1);
    if(!(cinfo->output_scanline >= cinfo->output_height))
    {
      unsigned int *p;
      unsigned int *end;
      unsigned char *q;
      jpeg_read_scanlines(cinfo, buffer, (unsigned int)1);
      p = I->data[(signed long int)(cinfo->output_scanline - (unsigned int)1)];
      end = p + (signed long int)I->width;
      q = (unsigned char *)buffer[(signed long int)0];
      if(!(p >= end))
      {
        *p = (unsigned int)((signed int)(unsigned char)*q | (signed int)(unsigned char)q[(signed long int)1] << 8 | (signed int)(unsigned char)q[(signed long int)2] << 16);
        p = p + 1l;
        q = q + (signed long int)3;
      }

    }

    jpeg_finish_decompress(cinfo);
    jpeg_destroy_decompress(cinfo);
    return 1;
  }
}

// jpeg_next_marker
// file image.c line 152
unsigned char * jpeg_next_marker(unsigned char *d, unsigned long int len)
{
  unsigned char *end = d + (signed long int)len;
  for( ; !(d >= end); d = d + 1l)
    if((signed int)*d == 0xff)
      break;

  if(d == end)
    return (unsigned char *)(void *)0;

  else
  {
    for( ; !(d >= end); d = d + 1l)
      if(!((signed int)*d == 0xff))
        break;

    if(d == end)
      return (unsigned char *)(void *)0;

    else
      return d;
  }
}

// jpeg_save_img
// file img.c line 42
signed int jpeg_save_img(struct _img * const I, struct _IO_FILE *fp)
{
  struct jpeg_compress_struct cinfo;
  struct my_error_mgr jerr;
  unsigned char **buffer;
  cinfo.err=jpeg_std_error(&jerr.pub);
  jerr.pub.error_exit = my_error_exit;
  signed int return_value__setjmp$1;
  return_value__setjmp$1=_setjmp(jerr.jb);
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  if(!(return_value__setjmp$1 == 0))
  {
    I->err = (enum anonymous$59)IE_SYSERROR;
    jpeg_destroy_compress(&cinfo);
    return 0;
  }

  else
  {
    jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
    jpeg_stdio_dest(&cinfo, fp);
    cinfo.image_width = I->width;
    cinfo.image_height = I->height;
    cinfo.input_components = 3;
    cinfo.in_color_space = (enum anonymous$18)JCS_RGB;
    jpeg_set_defaults(&cinfo);
    jpeg_start_compress(&cinfo, 1);
    buffer=cinfo.mem->alloc_sarray((struct jpeg_common_struct *)&cinfo, 1, I->width * (unsigned int)3, (unsigned int)1);
    if(!(cinfo.next_scanline >= cinfo.image_height))
    {
      unsigned int *p;
      unsigned int *end;
      unsigned char *q;
      p = I->data[(signed long int)cinfo.next_scanline];
      end = p + (signed long int)I->width;
      q = (unsigned char *)buffer[(signed long int)0];
      if(!(p >= end))
      {
        tmp_post$2 = q;
        q = q + 1l;
        *tmp_post$2 = (unsigned char)(*p & (unsigned int)0x000000ff);
        tmp_post$3 = q;
        q = q + 1l;
        *tmp_post$3 = (unsigned char)((*p & (unsigned int)0x0000ff00) >> 8);
        tmp_post$4 = q;
        q = q + 1l;
        *tmp_post$4 = (unsigned char)((*p & (unsigned int)0x00ff0000) >> 16);
        p = p + 1l;
      }

      jpeg_write_scanlines(&cinfo, buffer, (unsigned int)1);
    }

    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    return 1;
  }
}

// jpeg_skip_block
// file image.c line 162
unsigned char * jpeg_skip_block(unsigned char *d, unsigned long int len)
{
  signed int l;
  if(!(len >= 2ul))
    return (unsigned char *)(void *)0;

  else
  {
    l = (signed int)*d << 8 | (signed int)d[(signed long int)1];
    if(!(len >= (unsigned long int)l))
      return (unsigned char *)(void *)0;

    else
      return d + (signed long int)l;
  }
}

// layer3_find_tcp
// file layer3.h line 35
signed int layer3_find_tcp(const unsigned char *pkt, unsigned char nextproto, signed int *offset, struct sockaddr *src, struct sockaddr *dst, struct tcphdr *tcp)
{
  unsigned short int *sport = (unsigned short int *)(void *)0;
  unsigned short int *dport = (unsigned short int *)(void *)0;
  while((_Bool)1)
    switch((signed int)nextproto)
    {
      case 6:
      {
        memcpy((void *)tcp, (const void *)(pkt + (signed long int)*offset), sizeof(struct tcphdr) /*20ul*/ );
        /* assertion sport && dport */
        assert(sport != ((unsigned short int *)NULL) && dport != ((unsigned short int *)NULL));
        *sport = tcp->$anon0.$anon0.th_sport;
        *dport = tcp->$anon0.$anon0.th_dport;
        *offset = *offset + ((signed int)tcp->$anon0.$anon0.th_off << 2);
        return 0;
      }
      case 4:

      case 0:
      {
        struct ip *ip;
        struct sockaddr_in *layer3_find_tcp$$1$$1$$1$$1$$ps;
        struct sockaddr_in *pd;
        ip = (struct ip *)(pkt + (signed long int)*offset);
        nextproto = ip->ip_p;
        *offset = *offset + ((signed int)ip->ip_hl << 2);
        bzero((void *)src, sizeof(struct sockaddr_storage) /*128ul*/ );
        bzero((void *)dst, sizeof(struct sockaddr_storage) /*128ul*/ );
        layer3_find_tcp$$1$$1$$1$$1$$ps = (struct sockaddr_in *)src;
        pd = (struct sockaddr_in *)dst;
        layer3_find_tcp$$1$$1$$1$$1$$ps->sin_family = (unsigned short int)2;
        memcpy((void *)&layer3_find_tcp$$1$$1$$1$$1$$ps->sin_addr.s_addr, (const void *)&ip->ip_src, sizeof(struct in_addr) /*4ul*/ );
        sport = &layer3_find_tcp$$1$$1$$1$$1$$ps->sin_port;
        pd->sin_family = (unsigned short int)2;
        memcpy((void *)&pd->sin_addr.s_addr, (const void *)&ip->ip_dst, sizeof(struct in_addr) /*4ul*/ );
        dport = &pd->sin_port;
        break;
      }
      case 41:
      {
        struct ip6_hdr *ip6;
        struct sockaddr_in6 *ps;
        struct sockaddr_in6 *layer3_find_tcp$$1$$1$$1$$2$$pd;
        ip6 = (struct ip6_hdr *)(pkt + (signed long int)*offset);
        nextproto = ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt;
        *offset = *offset + (signed int)sizeof(struct ip6_hdr) /*40ul*/ ;
        bzero((void *)src, sizeof(struct sockaddr_storage) /*128ul*/ );
        bzero((void *)dst, sizeof(struct sockaddr_storage) /*128ul*/ );
        ps = (struct sockaddr_in6 *)src;
        layer3_find_tcp$$1$$1$$1$$2$$pd = (struct sockaddr_in6 *)dst;
        ps->sin6_family = (unsigned short int)10;
        memcpy((void *)&ps->sin6_addr, (const void *)&ip6->ip6_src, sizeof(struct in6_addr) /*16ul*/ );
        sport = &ps->sin6_port;
        layer3_find_tcp$$1$$1$$1$$2$$pd->sin6_family = (unsigned short int)10;
        memcpy((void *)&layer3_find_tcp$$1$$1$$1$$2$$pd->sin6_addr, (const void *)&ip6->ip6_dst, sizeof(struct in6_addr) /*16ul*/ );
        dport = &layer3_find_tcp$$1$$1$$1$$2$$pd->sin6_port;
        break;
      }
      case 60:

      case 43:
      {
        struct ip6_ext *ip6ext = (struct ip6_ext *)(pkt + (signed long int)*offset);
        nextproto = ip6ext->ip6e_nxt;
        *offset = *offset + ((signed int)ip6ext->ip6e_len << 3);
        break;
      }
      case 1:

      case 58:

      case 2:

      case 17:
        return -1;
      default:
        goto end;
    }

end:
  ;
  log_msg((enum anonymous$25)LOG_WARNING, "unsupported protocol dataframe (%d)", nextproto);
  return -1;
}

// log_msg
// file log.h line 22
void log_msg(enum anonymous$25 level, const char *fmt, ...)
{
  signed int n;
  unsigned long int size = (unsigned long int)100;
  char *msg;
  void **ap;
  char *levelstring;
  char *timestring;
  enum anonymous$25 return_value_get_loglevel$1;
  return_value_get_loglevel$1=get_loglevel();
  if((signed int)return_value_get_loglevel$1 >= (signed int)level)
  {
    void *return_value_xmalloc$2;
    return_value_xmalloc$2=xmalloc(size);
    msg = (char *)return_value_xmalloc$2;
    while((_Bool)1)
    {
      ap = (void **)&fmt;
      n=vsnprintf(msg, size, fmt, ap);
      ap = ((void **)NULL);
      if(n >= 0 && !((unsigned long int)n >= size))
        break;

      if(n >= 0)
        size = (unsigned long int)(n + 1);

      else
        size = size * (unsigned long int)2;
      void *return_value_xrealloc$3;
      return_value_xrealloc$3=xrealloc((void *)msg, size);
      msg = (char *)return_value_xrealloc$3;
    }
    levelstring=get_levelstring(level);
    timestring=get_timestring();
    fprintf(stderr, "%s [%s] %s: %s\n", timestring, (const void *)"driftnet", levelstring, msg);
    xfree((void *)msg);
  }

}

// main
// file driftnet.c line 129
signed int main(signed int argc, char **argv)
{
  unsigned long int packetth;
  struct anonymous$2 *main$$1$$options;
  main$$1$$options=parse_options(argc, argv);
  if(!(main$$1$$options->verbose == 0))
    set_loglevel((enum anonymous$25)LOG_INFO);

  if(!(main$$1$$options->adjunct == 0))
    create_pidfile();

  if(!(main$$1$$options->adjunct == 0))
    setvbuf(stdout, (char *)(void *)0, 1, (unsigned long int)0);

  if(!(main$$1$$options->tmpdir == ((const char *)NULL)))
  {
    check_dir_is_rw(main$$1$$options->tmpdir);
    set_tmpdir(main$$1$$options->tmpdir, (enum anonymous$51)TMPDIR_USER_OWNED, main$$1$$options->max_tmpfiles, main$$1$$options->adjunct);
  }

  else
  {
    const char *return_value_make_tmpdir$1;
    return_value_make_tmpdir$1=make_tmpdir();
    set_tmpdir(return_value_make_tmpdir$1, (enum anonymous$51)TMPDIR_APP_OWNED, main$$1$$options->max_tmpfiles, main$$1$$options->adjunct);
  }
  setup_signals();
  if(main$$1$$options->adjunct == 0)
  {
    if(!((m_audio & (signed int)main$$1$$options->extract_type) == 0))
      do_mpeg_player();

  }

  _Bool tmp_if_expr$2;
  if(main$$1$$options->adjunct == 0)
    tmp_if_expr$2 = ((signed int)main$$1$$options->extract_type & m_image) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    do_image_display(main$$1$$options->savedimgpfx, main$$1$$options->beep);

  else
    log_msg((enum anonymous$25)LOG_INFO, "operating in adjunct mode");
  init_mediadrv(main$$1$$options->extract_type, (signed int)!(main$$1$$options->adjunct != 0));
  if(!(main$$1$$options->dumpfile == ((char *)NULL)))
    packetcapture_open_offline(main$$1$$options->dumpfile);

  else
    packetcapture_open_live(main$$1$$options->interface, main$$1$$options->filterexpr, main$$1$$options->promisc);
  connection_alloc_slots();
  pthread_create(&packetth, (const union pthread_attr_t *)(void *)0, capture_thread, (void *)0);
  while(foad == 0)
    sleep((unsigned int)1);
  if(!(main$$1$$options->verbose == 0))
    print_exit_reason();

  pthread_cancel(packetth);
  pthread_join(packetth, (void **)(void *)0);
  packetcapture_close();
  connection_free_slots();
  clean_tmpdir();
  if(!(main$$1$$options->adjunct == 0))
    close_pidfile();

  return 0;
}

// make_backing_image
// file display.c line 108
void make_backing_image()
{
  struct _img *I;
  I=img_new_blank((const unsigned int)width, (const unsigned int)height);
  img_alloc(I);
  _Bool tmp_if_expr$1;
  if(!(backing_image == ((struct _img *)NULL)))
  {
    signed int w2;
    signed int h2;
    struct imgrect *ir;
    w2 = (signed int)backing_image->width;
    if(!(width >= w2))
      w2 = width;

    h2 = (signed int)backing_image->height;
    if(!(height >= h2))
      h2 = height;

    img_simple_blt(I, 0, height - h2, backing_image, 0, (const signed int)(backing_image->height - (unsigned int)h2), w2, h2);
    ir = imgrects;
    for( ; !(ir >= imgrects + (signed long int)nimgrects); ir = ir + 1l)
      if(!(ir->filename == ((char *)NULL)))
      {
        ir->y = ir->y + (signed int)((unsigned int)height - backing_image->height);
        if(!(width >= ir->x))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = ir->y + ir->h < 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          unlink(ir->filename);
          xfree((void *)ir->filename);
          memset((void *)ir, 0, sizeof(struct imgrect) /*24ul*/ );
        }

      }

    if(wrx >= w2)
      wrx = w2;

    img_delete(backing_image);
  }

  backing_image = I;
  wrx = 6;
  wry = height - 6;
  rowheight = 2 * 6;
}

// make_tmpdir
// file tmpdir.h line 26
const char * make_tmpdir(void)
{
  char *systmp;
  char *template;
  signed int len;
  signed int n;
  systmp=getenv("TMPDIR");
  if(systmp == ((char *)NULL))
  {
    systmp=getenv("TEMP");
    if(systmp == ((char *)NULL))
    {
      systmp=getenv("TMP");
      if(systmp == ((char *)NULL))
        systmp = "/tmp";

    }

  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(systmp);
  len = (signed int)return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("/drifnet-XXXXXX");
  len = len + (signed int)return_value_strlen$2;
  len = len + 1;
  void *return_value_xmalloc$3;
  return_value_xmalloc$3=xmalloc((unsigned long int)len);
  template = (char *)return_value_xmalloc$3;
  n=snprintf(template, (unsigned long int)len, "%s/drifnet-XXXXXX", systmp);
  if(n >= 0 && !(n >= len))
  {
    char *tmp;
    tmp=mkdtemp(template);
    if(tmp == ((char *)NULL))
    {
      xfree((void *)template);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      log_msg((enum anonymous$25)LOG_ERROR, "make_tmpdir(), mkdtemp: %s", return_value_strerror$5);
      unexpected_exit(-1);
    }

    return tmp;
  }

  if(!(n >= 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    log_msg((enum anonymous$25)LOG_ERROR, "make_tmpdir(), snprintf: %s", return_value_strerror$7);
  }

  else
    log_msg((enum anonymous$25)LOG_ERROR, "make_tmpdir(), internal error");
  unexpected_exit(-1);
  return (const char *)(void *)0;
}

// memstr
// file util.c line 80
unsigned char * memstr(const unsigned char *haystack, const unsigned long int hlen, const unsigned char *needle, const unsigned long int nlen)
{
  const unsigned char *p = haystack;
  for( ; haystack + -((signed long int)nlen) + (signed long int)hlen >= p; p = p + 1l)
  {
    signed int return_value_memcmp$1;
    return_value_memcmp$1=memcmp((const void *)p, (const void *)needle, nlen);
    if(return_value_memcmp$1 == 0)
      return (unsigned char *)p;

  }
  return (unsigned char *)(void *)0;
}

// mpeg_hdr_nextframe_offset
// file mpeghdr.h line 49
signed int mpeg_hdr_nextframe_offset(struct mpeg_audio_hdr *h)
{
  signed int off = 0;
  if((signed int)h->layer == m_layer_1)
    off = off + ((12 * h->bitrate * 1000) / h->samplerate + h->padded) * 4;

  else
    off = off + (144 * h->bitrate * 1000) / h->samplerate + h->padded;
  return off;
}

// mpeg_hdr_parse
// file mpeghdr.h line 48
signed int mpeg_hdr_parse(const unsigned char *data, struct mpeg_audio_hdr *h)
{
  struct mpeg_audio_hdr hz = { .version=(enum anonymous$46)0, .layer=(enum anonymous$47)0, .has_crc=0,
    .crc=0, .bitrate=0, .samplerate=0, .padded=0,
    .priv=0, .channels=(enum anonymous$50)0, .mode_extn=0,
    .copyr=0, .original=0, .emph=0 };
  unsigned int hh;
  signed int i;
  *h = hz;
  _Bool tmp_if_expr$1;
  if(!((signed int)*data == 0xff))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ((signed int)data[(signed long int)1] & 0xe0) != 0xe0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    hh = (unsigned int)((signed int)data[(signed long int)1] << 16 | (signed int)data[(signed long int)2] << 8 | (signed int)data[(signed long int)3]);
    switch((hh & (unsigned int)((2 << 20 - 19) - 1 << 19)) >> 19)
    {
      case (unsigned int)0:
      {
        h->version = (enum anonymous$46)m_vers_2_5;
        break;
      }
      case (unsigned int)2:
      {
        h->version = (enum anonymous$46)m_vers_2;
        break;
      }
      case (unsigned int)3:
      {
        h->version = (enum anonymous$46)m_vers_1;
        break;
      }
      default:
        return 0;
    }
    switch((hh & (unsigned int)((2 << 18 - 17) - 1 << 17)) >> 17)
    {
      case (unsigned int)1:
      {
        h->layer = (enum anonymous$47)m_layer_3;
        break;
      }
      case (unsigned int)2:
      {
        h->layer = (enum anonymous$47)m_layer_2;
        break;
      }
      case (unsigned int)3:
      {
        h->layer = (enum anonymous$47)m_layer_1;
        break;
      }
      default:
        return 0;
    }
    h->has_crc = (signed int)((hh & (unsigned int)((2 << 16 - 16) - 1 << 16)) >> 16);
    if(!(h->has_crc == 0))
      h->crc = (unsigned short int)((signed int)data[(signed long int)5] << 8 | (signed int)data[(signed long int)6]);

    i = (signed int)h->version == m_vers_1 ? 0 : 3;
    i = i + ((signed int)h->layer - 1);
    if(i == 5)
      i = 4;

    h->bitrate = bitrate_tbl[(signed long int)((hh & (unsigned int)((2 << 15 - 12) - 1 << 12)) >> 12)][(signed long int)i];
    if(h->bitrate == -1)
      return 0;

    else
    {
      i = (signed int)h->version - 1;
      h->samplerate = samplerate_tbl[(signed long int)((hh & (unsigned int)((2 << 11 - 10) - 1 << 10)) >> 10)][(signed long int)i];
      if(h->samplerate == -1)
        return 0;

      else
      {
        h->padded = (signed int)((hh & (unsigned int)((2 << 9 - 9) - 1 << 9)) >> 9);
        h->channels = (enum anonymous$50)((hh & (unsigned int)((2 << 7 - 6) - 1 << 6)) >> 6);
        h->mode_extn = (unsigned char)((hh & (unsigned int)((2 << 5 - 4) - 1 << 4)) >> 4);
        h->copyr = (signed int)((hh & (unsigned int)((2 << 3 - 3) - 1 << 3)) >> 3);
        h->original = (signed int)((hh & (unsigned int)((2 << 2 - 2) - 1 << 2)) >> 2);
        h->emph = (unsigned char)((hh & (unsigned int)((2 << 1 - 0) - 1 << 0)) >> 0);
        return 1;
      }
    }
  }
}

// mpeg_hdr_print
// file mpeghdr.c line 138
void mpeg_hdr_print(struct _IO_FILE *fp, struct mpeg_audio_hdr *h)
{
  fprintf(fp, "version %s layer %d\n", vers_tbl[(signed long int)h->version], h->layer);
  if(!(h->has_crc == 0))
    fprintf(fp, "  has CRC %04x\n", h->crc);

  fprintf(fp, "bit rate %d kbps\nsample rate %dHz\n", h->bitrate, h->samplerate);
  fprintf(fp, "%s padded\n", h->padded != 0 ? "is" : "is not");
  fprintf(fp, "%s\n", channel_tbl[(signed long int)h->channels]);
  if((signed int)h->channels == m_chan_joint)
    fprintf(fp, "mode extension %d\n", h->mode_extn);

  fprintf(fp, "%s copyright\n%s original\n", h->copyr != 0 ? "is" : "is not", h->original != 0 ? "is" : "is not");
  if(!(h->emph == 0))
    fprintf(fp, "emphasis %d\n", h->emph);

}

// mpeg_play
// file playaudio.c line 134
static void * mpeg_play(void *a)
{
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  while((_Bool)1)
  {
    struct _audiochunk *A;
    pthread_mutex_lock(&mpeg_mtx);
    A = rd->next;
    pthread_mutex_unlock(&mpeg_mtx);
    if(!(A == ((struct _audiochunk *)NULL)))
    {
      signed int return_value_audiochunk_write$3;
      return_value_audiochunk_write$3=audiochunk_write(A, mpeg_fd);
      if(return_value_audiochunk_write$3 == -1)
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        log_msg((enum anonymous$25)LOG_ERROR, "write to MPEG player: %s", return_value_strerror$2);
      }

      pthread_mutex_lock(&mpeg_mtx);
      buffered = buffered - A->len;
      audiochunk_delete(rd);
      rd = A;
      pthread_mutex_unlock(&mpeg_mtx);
    }

    else
      xnanosleep((signed long int)100000000);
  }
  return (void *)0;
}

// mpeg_player_manager
// file playaudio.c line 167
static void mpeg_player_manager(void)
{
  struct sigaction sa = { .__sigaction_handler={ .sa_handler=((void (*)(signed int))NULL) }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  signed int mpeg_pid;
  sa.__sigaction_handler.sa_handler = (void (*)(signed int))0;
  sigaction(17, &sa, (struct sigaction *)(void *)0);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed long int return_value_time$6;
  while(foad == 0)
  {
    signed long int whenstarted;
    signed int st;
    log_msg((enum anonymous$25)LOG_INFO, "starting MPEG player `%s'", audio_mpeg_player);
    whenstarted=time((signed long int *)(void *)0);
    mpeg_pid=fork();
    if(!(mpeg_pid == 0))
    {
      if(mpeg_pid == -1)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      execl("/bin/sh", "/bin/sh", (const void *)"-c", audio_mpeg_player, (void *)0);
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      log_msg((enum anonymous$25)LOG_ERROR, "exec: %s", return_value_strerror$2);
      unexpected_exit(-1);
      goto __CPROVER_DUMP_L5;

    __CPROVER_DUMP_L3:
      ;
      return_value___errno_location$3=__errno_location();
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log_msg((enum anonymous$25)LOG_ERROR, "fork: %s", return_value_strerror$4);
      unexpected_exit(-1);
      goto __CPROVER_DUMP_L5;
    }
    log_msg((enum anonymous$25)LOG_INFO, " MPEG player has PID %d", (signed int)mpeg_pid);

  __CPROVER_DUMP_L5:
    ;
    waitpid(mpeg_pid, &st, 0);
    mpeg_pid = 0;
    /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$3
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
    ;
    if((0x7f & st) == 0)
      log_msg((enum anonymous$25)LOG_INFO, "MPEG player exited with status %d", (((union anonymous$3){ .__in=st }).__i & 0xff00) >> 8);

    else
      if((signed int)((127 & (signed char)st) + 1) >> 1 >= 1)
        log_msg((enum anonymous$25)LOG_INFO, "MPEG player killed by signal %d", ((union anonymous$3){ .__in=st }).__i & 0x7f);

    if(foad == 0)
    {
      return_value_time$6=time((signed long int *)(void *)0);
      if(!(return_value_time$6 + -whenstarted >= 5l))
      {
        signed long int return_value_time$5;
        return_value_time$5=time((signed long int *)(void *)0);
        log_msg((enum anonymous$25)LOG_WARNING, "MPEG player expired after %d seconds, sleeping for a bit", (signed int)(return_value_time$5 - whenstarted));
        sleep((unsigned int)5);
      }

    }

  }
  if(!(mpeg_pid == 0))
    kill(mpeg_pid, 15);

}

// mpeg_submit_chunk
// file playaudio.h line 18
void mpeg_submit_chunk(const unsigned char *data, const unsigned long int len)
{
  struct _audiochunk *A;
  pthread_mutex_lock(&mpeg_mtx);
  if(buffered >= 8388609ul)
    log_msg((enum anonymous$25)LOG_INFO, "MPEG buffer full with %d bytes", buffered);

  else
  {
    A=audiochunk_new(data, len);
    wr->next = A;
    wr = wr->next;
    buffered = buffered + len;
  }

finish:
  ;
  pthread_mutex_unlock(&mpeg_mtx);
}

// my_error_exit
// file jpeg.c line 36
static void my_error_exit(struct jpeg_common_struct *cinfo)
{
  struct my_error_mgr *e = (struct my_error_mgr *)cinfo->err;
  cinfo->err->output_message(cinfo);
  longjmp(e->jb, 1);
}

// packetcapture_close
// file packetcapture.h line 24
void packetcapture_close(void)
{
  if(!(pc == ((struct pcap *)NULL)))
    pcap_close(pc);

}

// packetcapture_dispatch
// file packetcapture.h line 26
void packetcapture_dispatch(void)
{
  pcap_dispatch(pc, -1, process_packet, (unsigned char *)(void *)0);
}

// packetcapture_open_live
// file packetcapture.h line 22
void packetcapture_open_live(char *interface, char *filterexpr, signed int promisc)
{
  char ebuf[256l];
  struct bpf_program filter;
  pc=pcap_open_live(interface, 262144, promisc, 1000, ebuf);
  if(pc == ((struct pcap *)NULL))
  {
    log_msg((enum anonymous$25)LOG_ERROR, "pcap_open_live: %s", (const void *)ebuf);
    unsigned int return_value_getuid$1;
    return_value_getuid$1=getuid();
    if(!(return_value_getuid$1 == 0u))
      log_msg((enum anonymous$25)LOG_ERROR, "perhaps you need to be root?");

    else
      if(interface == ((char *)NULL))
        log_msg((enum anonymous$25)LOG_ERROR, "perhaps try selecting an interface with the -i option?");

    unexpected_exit(-1);
  }

  signed int return_value_pcap_compile$3;
  return_value_pcap_compile$3=pcap_compile(pc, &filter, filterexpr, 1, (unsigned int)0);
  if(return_value_pcap_compile$3 == -1)
  {
    char *return_value_pcap_geterr$2;
    return_value_pcap_geterr$2=pcap_geterr(pc);
    log_msg((enum anonymous$25)LOG_ERROR, "pcap_compile: %s", return_value_pcap_geterr$2);
    unexpected_exit(-1);
  }

  signed int return_value_pcap_setfilter$5;
  return_value_pcap_setfilter$5=pcap_setfilter(pc, &filter);
  if(return_value_pcap_setfilter$5 == -1)
  {
    char *return_value_pcap_geterr$4;
    return_value_pcap_geterr$4=pcap_geterr(pc);
    log_msg((enum anonymous$25)LOG_ERROR, "pcap_setfilter: %s", return_value_pcap_geterr$4);
    unexpected_exit(-1);
  }

  log_msg((enum anonymous$25)LOG_INFO, "listening on %s%s", interface != ((char *)NULL) ? interface : "all interfaces", promisc != 0 ? " in promiscuous mode" : "");
  datalink_info=get_datalink_info(pc);
}

// packetcapture_open_offline
// file packetcapture.h line 23
void packetcapture_open_offline(char *dumpfile)
{
  char ebuf[256l];
  pc=pcap_open_offline(dumpfile, ebuf);
  if(pc == ((struct pcap *)NULL))
  {
    log_msg((enum anonymous$25)LOG_ERROR, "pcap_open_offline: %s", (const void *)ebuf);
    unexpected_exit(-1);
  }

  log_msg((enum anonymous$25)LOG_INFO, "reading packets from %s", dumpfile);
  datalink_info=get_datalink_info(pc);
}

// parse_ieee80211
// file layer2.c line 77
static signed int parse_ieee80211(const unsigned char *pkt, unsigned int caplen, unsigned short int *llnextproto, signed int *offsetnext)
{
  struct ieee80211_frame *_80211_header;
  struct frame_control *control;
  _80211_header = (struct ieee80211_frame *)pkt;
  control = (struct frame_control *)&_80211_header->fc;
  _Bool tmp_if_expr$1;
  unsigned short int tmp_statement_expression$2;
  if(!((signed int)control->protocol == 0))
    return -1;

  else
    if(!((signed int)control->type == 2))
      return -1;

    else
      if(!((signed int)control->subtype == 0))
      {
        if((signed int)control->subtype == 8)
          goto __CPROVER_DUMP_L3;

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if((signed int)control->wep == 1)
          return -1;

        else
        {
          unsigned long int header_len = sizeof(struct ieee80211_frame) /*24ul*/ ;
          if((signed int)control->subtype == 8)
            header_len = header_len + (unsigned long int)2;

          if((signed int)control->to_ds == 1)
          {
            if((signed int)control->from_ds == 1)
              header_len = header_len + (unsigned long int)6;

          }

          struct snap_header *llc_header = (struct snap_header *)(pkt + (signed long int)header_len);
          if(!((signed int)llc_header->dsap == 0xAA))
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (signed int)llc_header->ssap != 0xAA ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            return -1;

          else
          {
            *offsetnext = (signed int)(header_len + sizeof(struct snap_header) /*8ul*/ );
            unsigned short int __v;
            unsigned short int __x = (unsigned short int)llc_header->ether_type;
            asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
            tmp_statement_expression$2 = __v;
            *llnextproto = tmp_statement_expression$2;
            return 0;
          }
        }
      }
}

// parse_options
// file options.h line 40
struct anonymous$2 * parse_options(signed int argc, char **argv)
{
  char optstring[20l] = { 'a', 'b', 'd', ':', 'f', ':', 'h', 'i', ':', 'M', ':', 'm', ':', 'p', 'S', 's', 'v', 'x', ':', 0 };
  signed int c;
  opterr = 0;
  signed int return_value_isatty$1;
  char *return_value___strdup$2;
  do
  {
    c=getopt(argc, argv, optstring);
    if(c == -1)
      break;

    switch(c)
    {
      case 104:
      {
        usage(stdout);
        exit(0);
      }
      case 105:
      {
        if(!(options.dumpfile == ((char *)NULL)))
        {
          log_msg((enum anonymous$25)LOG_ERROR, "can't specify -i and -f");
          unexpected_exit(-1);
        }

        options.interface = optarg;
        break;
      }
      case 118:
      {
        options.verbose = 1;
        break;
      }
      case 98:
      {
        return_value_isatty$1=isatty(1);
        if(return_value_isatty$1 == 0)
          log_msg((enum anonymous$25)LOG_WARNING, "can't beep unless standard output is a terminal");

        else
          options.beep = 1;
        break;
      }
      case 112:
      {
        options.promisc = 0;
        break;
      }
      case 115:
      {
        options.extract_type = options.extract_type | (enum mediatype)m_audio;
        break;
      }
      case 83:
      {
        options.extract_type = (enum mediatype)m_audio;
        break;
      }
      case 77:
      {
        options.audio_mpeg_player = optarg;
        options.mpeg_player_specified = 1;
        break;
      }
      case 97:
      {
        options.adjunct = 1;
        break;
      }
      case 109:
      {
        options.max_tmpfiles=atoi(optarg);
        if(!(options.max_tmpfiles >= 1))
        {
          log_msg((enum anonymous$25)LOG_ERROR, "`%s' does not make sense for -m", optarg);
          unexpected_exit(-1);
        }

        break;
      }
      case 100:
      {
        return_value___strdup$2=__strdup(optarg);
        options.tmpdir = return_value___strdup$2;
        options.tmpdir_especified = 1;
        break;
      }
      case 102:
      {
        if(!(options.interface == ((char *)NULL)))
        {
          log_msg((enum anonymous$25)LOG_ERROR, "can't specify -i and -f");
          unexpected_exit(-1);
        }

        options.dumpfile = optarg;
        break;
      }
      case 120:
      {
        options.savedimgpfx = optarg;
        options.newpfx = 1;
        break;
      }
      case 63:

      default:
      {
        char *return_value___builtin_strchr$3;
        return_value___builtin_strchr$3=__builtin_strchr(optstring, optopt);
        if(!(return_value___builtin_strchr$3 == ((char *)NULL)))
          log_msg((enum anonymous$25)LOG_ERROR, "option -%c requires an argument", optopt);

        else
          log_msg((enum anonymous$25)LOG_ERROR, "unrecognised option -%c", optopt);
        usage(stderr);
        unexpected_exit(1);
      }
    }
  }
  while((_Bool)1);
  unsigned long int return_value_strlen$4;
  if(!(optind >= argc))
  {
    if(!(options.dumpfile == ((char *)NULL)))
      log_msg((enum anonymous$25)LOG_WARNING, "filter code ignored with dump file");

    else
    {
      char **a;
      signed int l;
      a = argv + (signed long int)optind;
      l = (signed int)sizeof(char [11l]) /*11ul*/ ;
      for( ; !(*a == ((char *)NULL)); a = a + 1l)
      {
        return_value_strlen$4=strlen(*a);
        l = l + (signed int)(return_value_strlen$4 + (unsigned long int)1);
      }
      void *return_value_calloc$5;
      return_value_calloc$5=calloc((unsigned long int)l, (unsigned long int)1);
      options.filterexpr = (char *)return_value_calloc$5;
      strcpy(options.filterexpr, "tcp and (");
      a = argv + (signed long int)optind;
      for( ; !(*a == ((char *)NULL)); a = a + 1l)
      {
        strcat(options.filterexpr, *a);
        if(!(a[1l] == ((char *)NULL)))
          strcat(options.filterexpr, " ");

      }
      strcat(options.filterexpr, ")");
    }
  }

  else
    options.filterexpr = "tcp";
  log_msg((enum anonymous$25)LOG_INFO, "using filter expression `%s'", options.filterexpr);
  if(options.adjunct == 0 && !(options.newpfx == 0))
    log_msg((enum anonymous$25)LOG_INFO, "using saved image prefix `%s'", options.savedimgpfx);

  validate_options(&options);
  return &options;
}

// pipe_event
// file display.c line 337
signed int pipe_event(struct _GIOChannel chan, enum anonymous$62 cond, void *data)
{
  char name[64l];
  signed long int rr;
  signed int nimgs = 0;
  const char *return_value_get_tmpdir$1;
  unsigned long int return_value_strlen$2;
  void *return_value_xmalloc$3;
  static char *path;
  if(path == ((char *)NULL))
  {
    return_value_get_tmpdir$1=get_tmpdir();
    return_value_strlen$2=strlen(return_value_get_tmpdir$1);
    return_value_xmalloc$3=xmalloc(return_value_strlen$2 + (unsigned long int)64);
    path = (char *)return_value_xmalloc$3;
  }

  _Bool tmp_if_expr$7;
  while(!(nimgs >= 4))
  {
    rr=xread(imgpipe_readfd, (void *)name, sizeof(char [64l]) /*64ul*/ );
    if(!((unsigned long int)rr == sizeof(char [64l]) /*64ul*/ ))
      break;

    signed int saveimg = 0;
    struct stat st;
    nimgs = nimgs + 1;
    const char *return_value_get_tmpdir$4;
    return_value_get_tmpdir$4=get_tmpdir();
    sprintf(path, "%s/%s", return_value_get_tmpdir$4, (const void *)name);
    signed int return_value_stat$5;
    return_value_stat$5=stat$link1(path, &st);
    if(!(return_value_stat$5 == -1))
    {
      log_msg((enum anonymous$25)LOG_INFO, "received image %s of size %d", (const void *)name, (signed int)st.st_size);
      if(st.st_size >= 101l)
      {
        struct _img *i;
        i=img_new();
        signed int return_value_img_load_file$8;
        return_value_img_load_file$8=img_load_file(i, path, (const enum anonymous$58)header, (const enum anonymous$57)unknown);
        if(return_value_img_load_file$8 == 0)
          log_msg((enum anonymous$25)LOG_WARNING, "%s: bogus image (err = %d)", (const void *)name, i->err);

        else
        {
          if(i->width >= 9u)
            tmp_if_expr$7 = i->height > (unsigned int)8 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          if(tmp_if_expr$7)
          {
            signed int return_value_img_load$6;
            return_value_img_load$6=img_load(i, (const enum anonymous$58)full, i->type);
            if(!(return_value_img_load$6 == 0))
            {
              signed int w;
              signed int h;
              if(!(4294967284u + (unsigned int)width >= i->width))
                w = width - 2 * 6;

              else
                w = (signed int)i->width;
              if(!(4294967284u + (unsigned int)height >= i->height))
                h = height - 2 * 6;

              else
                h = (signed int)i->height;
              if(!(width + -wrx >= w))
              {
                scroll_backing_image(h + 6);
                wrx = 6;
                rowheight = h + 6;
              }

              if(!(rowheight >= 6 + h))
              {
                scroll_backing_image((h + 6) - rowheight);
                rowheight = h + 6;
              }

              img_simple_blt(backing_image, wrx, wry - h, i, 0, 0, w, h);
              add_image_rectangle(path, wrx, wry - h, w, h);
              saveimg = 1;
              if(!(beep_on_image == 0))
                write(1, (const void *)"\a", (unsigned long int)1);

              update_window();
              wrx = wrx + w + 6;
            }

            else
              log_msg((enum anonymous$25)LOG_WARNING, "%s: bogus image (err = %d)", (const void *)name, i->err);
          }

          else
            log_msg((enum anonymous$25)LOG_WARNING, "%s: image dimensions (%d x %d) too small to bother with", (const void *)name, i->width, i->height);
        }
        img_delete(i);
      }

      else
        log_msg((enum anonymous$25)LOG_WARNING, "image data too small (%d bytes) to bother with", (signed int)st.st_size);
      if(saveimg == 0)
        unlink(name);

    }

  }
  _Bool tmp_if_expr$12;
  signed int *return_value___errno_location$11;
  if(rr == -1l)
  {
    return_value___errno_location$11=__errno_location();
    tmp_if_expr$12 = *return_value___errno_location$11 != 4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$12 = (_Bool)0;
  _Bool tmp_if_expr$14;
  signed int *return_value___errno_location$13;
  if(tmp_if_expr$12)
  {
    return_value___errno_location$13=__errno_location();
    tmp_if_expr$14 = *return_value___errno_location$13 != 11 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$14 = (_Bool)0;
  if(tmp_if_expr$14)
  {
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    char *return_value_strerror$10;
    return_value_strerror$10=strerror(*return_value___errno_location$9);
    log_msg((enum anonymous$25)LOG_ERROR, "display pipe read() failed, reason: %s", return_value_strerror$10);
    gtk_main_quit();
  }

  else
    if(rr == 0l)
      gtk_main_quit();

  return 1;
}

// png_abort_load
// file png.c line 91
signed int png_abort_load(struct _img *I)
{
  return 1;
}

// png_catch_error
// file png.c line 29
void png_catch_error(struct png_struct_def *png_ptr, const char *error_msg)
{
  log_msg((enum anonymous$25)LOG_WARNING, "libpng, %s (skipping image).", error_msg);
  signed int return_value__setjmp$1;
  return_value__setjmp$1=_setjmp(png_ptr->jmpbuf);
  if(!(return_value__setjmp$1 == 0))
  {
    log_msg((enum anonymous$25)LOG_ERROR, "libpng, unrecoverable error, terminating.");
    unexpected_exit(-1);
  }

}

// png_load_hdr
// file img.c line 45
signed int png_load_hdr(struct _img *I)
{
  unsigned char sig[8l];
  struct png_struct_def *png_ptr;
  struct png_info_struct *info_ptr;
  rewind(I->fp);
  unsigned long int return_value_fread$1;
  return_value_fread$1=fread((void *)sig, sizeof(unsigned char) /*1ul*/ , (unsigned long int)8, I->fp);
  if(!(return_value_fread$1 == 8ul))
    return 0;

  else
  {
    signed int return_value_png_sig_cmp$2;
    return_value_png_sig_cmp$2=png_sig_cmp(sig, (unsigned long int)0, (unsigned long int)8);
    if(!(return_value_png_sig_cmp$2 == 0))
    {
      I->err = (enum anonymous$59)IE_HDRFORMAT;
      return 0;
    }

    else
    {
      png_ptr=png_create_read_struct("1.2.54", (void *)0, png_catch_error, (void (*)(struct png_struct_def *, const char *))(void *)0);
      if(png_ptr == ((struct png_struct_def *)NULL))
      {
        I->err = (enum anonymous$59)IE_HDRFORMAT;
        return 0;
      }

      else
      {
        signed int return_value__setjmp$3;
        return_value__setjmp$3=_setjmp(png_ptr->jmpbuf);
        if(!(return_value__setjmp$3 == 0))
        {
          png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
          I->err = (enum anonymous$59)IE_HDRFORMAT;
          return 0;
        }

        else
        {
          info_ptr=png_create_info_struct(png_ptr);
          if(info_ptr == ((struct png_info_struct *)NULL))
          {
            png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
            I->err = (enum anonymous$59)IE_HDRFORMAT;
            return 0;
          }

          else
          {
            rewind(I->fp);
            png_init_io(png_ptr, I->fp);
            png_read_info(png_ptr, info_ptr);
            unsigned long int return_value_png_get_image_width$4;
            return_value_png_get_image_width$4=png_get_image_width(png_ptr, info_ptr);
            I->width = (unsigned int)return_value_png_get_image_width$4;
            unsigned long int return_value_png_get_image_height$5;
            return_value_png_get_image_height$5=png_get_image_height(png_ptr, info_ptr);
            I->height = (unsigned int)return_value_png_get_image_height$5;
            png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
            return 1;
          }
        }
      }
    }
  }
}

// png_load_img
// file img.c line 47
signed int png_load_img(struct _img *I)
{
  unsigned char **p;
  unsigned char **q;
  struct png_struct_def *png_ptr;
  struct png_info_struct *info_ptr;
  unsigned long int png_load_img$$1$$width;
  unsigned long int png_load_img$$1$$height;
  signed int i;
  signed int j;
  signed int bit_depth;
  signed int color_type;
  signed int interlace_type;
  unsigned char **row_pointers;
  img_alloc(I);
  png_ptr=png_create_read_struct("1.2.54", (void *)0, png_catch_error, (void (*)(struct png_struct_def *, const char *))(void *)0);
  unsigned long int return_value_png_get_rowbytes$5;
  if(png_ptr == ((struct png_struct_def *)NULL))
  {
    I->err = (enum anonymous$59)IE_HDRFORMAT;
    return 0;
  }

  else
  {
    signed int return_value__setjmp$1;
    return_value__setjmp$1=_setjmp(png_ptr->jmpbuf);
    if(!(return_value__setjmp$1 == 0))
    {
      png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
      I->err = (enum anonymous$59)IE_HDRFORMAT;
      return 0;
    }

    else
    {
      info_ptr=png_create_info_struct(png_ptr);
      if(info_ptr == ((struct png_info_struct *)NULL))
      {
        png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
        I->err = (enum anonymous$59)IE_HDRFORMAT;
        return 0;
      }

      else
      {
        rewind(I->fp);
        png_init_io(png_ptr, I->fp);
        png_read_info(png_ptr, info_ptr);
        png_get_IHDR(png_ptr, info_ptr, &png_load_img$$1$$width, &png_load_img$$1$$height, &bit_depth, &color_type, &interlace_type, (signed int *)(void *)0, (signed int *)(void *)0);
        if(color_type == 0 || color_type == 4)
        {
          if(!(bit_depth >= 8))
            png_set_expand_gray_1_2_4_to_8(png_ptr);

          png_set_gray_to_rgb(png_ptr);
        }

        if(color_type == 3)
          png_set_expand(png_ptr);

        if(!(bit_depth >= 8))
          png_set_expand(png_ptr);

        if(bit_depth == 16)
          png_set_strip_16(png_ptr);

        png_set_filler(png_ptr, (unsigned long int)0, 1);
        png_read_update_info(png_ptr, info_ptr);
        void *return_value_png_malloc$2;
        return_value_png_malloc$2=png_malloc(png_ptr, png_load_img$$1$$height * sizeof(unsigned char *) /*8ul*/ );
        row_pointers = (unsigned char **)return_value_png_malloc$2;
        i = 0;
        for( ; !((unsigned long int)i >= png_load_img$$1$$height); i = i + 1)
        {
          unsigned long int return_value_png_get_rowbytes$3;
          return_value_png_get_rowbytes$3=png_get_rowbytes(png_ptr, info_ptr);
          void *return_value_png_malloc$4;
          return_value_png_malloc$4=png_malloc(png_ptr, return_value_png_get_rowbytes$3);
          row_pointers[(signed long int)i] = (unsigned char *)return_value_png_malloc$4;
        }
        png_read_image(png_ptr, row_pointers);
        p = (unsigned char **)I->data;
        q = (unsigned char **)row_pointers;
        i = 0;
        for( ; !((unsigned long int)i >= png_load_img$$1$$height); i = i + 1)
        {
          j = 0;
          do
          {
            return_value_png_get_rowbytes$5=png_get_rowbytes(png_ptr, info_ptr);
            if((unsigned long int)j >= return_value_png_get_rowbytes$5)
              break;

            p[(signed long int)i][(signed long int)j] = q[(signed long int)i][(signed long int)j];
            j = j + 1;
          }
          while((_Bool)1);
        }
        png_read_end(png_ptr, info_ptr);
        png_free(png_ptr, (void *)row_pointers);
        png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
        return 1;
      }
    }
  }
}

// png_save_img
// file png.c line 190
signed int png_save_img(struct _img * const I, struct _IO_FILE *fp)
{
  return 1;
}

// print_exit_reason
// file driftnet.c line 106
static void print_exit_reason(void)
{
  if(foad == 17)
  {
    signed int pp;
    signed int st;
    do
    {
      pp=waitpid(-1, &st, 1);
      if(!(pp >= 1))
        break;

      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$3
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      if((0x7f & st) == 0)
        log_msg((enum anonymous$25)LOG_INFO, "child process %d exited with status %d", (signed int)pp, (((union anonymous$3){ .__in=st }).__i & 0xff00) >> 8);

      else
        if((signed int)((127 & (signed char)st) + 1) >> 1 >= 1)
          log_msg((enum anonymous$25)LOG_INFO, "child process %d killed by signal %d", (signed int)pp, ((union anonymous$3){ .__in=st }).__i & 0x7f);

        else
          log_msg((enum anonymous$25)LOG_INFO, "child process %d died, not sure why", (signed int)pp);
    }
    while((_Bool)1);
  }

  else
    log_msg((enum anonymous$25)LOG_INFO, "caught signal %d", foad);
}

// print_ipport_pair
// file connection.c line 120
static char * print_ipport_pair(struct sockaddr *addr, char *buf, unsigned long int buf_len)
{
  struct sockaddr_in *v4;
  struct sockaddr_in6 *v6;
  signed int port;
  unsigned long int plen;
  char *p = buf;
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  switch((signed int)addr->sa_family)
  {
    case 2:
    {
      v4 = (struct sockaddr_in *)addr;
      inet_ntop((signed int)v4->sin_family, (const void *)&v4->sin_addr.s_addr, buf, (unsigned int)buf_len);
      unsigned short int __v;
      unsigned short int print_ipport_pair$$1$$1$$1$$__x = (unsigned short int)v4->sin_port;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(print_ipport_pair$$1$$1$$1$$__x) : "cc");
      tmp_statement_expression$1 = __v;
      port = (signed int)tmp_statement_expression$1;
      break;
    }
    case 10:
    {
      v6 = (struct sockaddr_in6 *)addr;
      inet_ntop((signed int)v6->sin6_family, (const void *)&v6->sin6_addr.__in6_u.__u6_addr8, buf, (unsigned int)buf_len);
      unsigned short int print_ipport_pair$$1$$1$$2$$__v;
      unsigned short int __x = (unsigned short int)v6->sin6_port;
      asm("rorw $8, %w0" : "=r"(print_ipport_pair$$1$$1$$2$$__v) : "0"(__x) : "cc");
      tmp_statement_expression$2 = print_ipport_pair$$1$$1$$2$$__v;
      port = (signed int)tmp_statement_expression$2;
      break;
    }
    default:
    {
      snprintf(buf, buf_len, "(unknown family)");
      port = 0;
    }
  }
  plen=strlen(buf);
  p = p + (signed long int)plen;
  snprintf(p, buf_len - plen, ":%d", port);
  return buf;
}

// process_packet
// file packetcapture.c line 134
static void process_packet(unsigned char *user, struct pcap_pkthdr *hdr, const unsigned char *pkt)
{
  struct tcphdr tcp;
  signed int off;
  signed int len;
  signed int delta;
  struct _connection **C;
  struct _connection *c;
  struct sockaddr_storage src;
  struct sockaddr_storage dst;
  struct sockaddr *s;
  struct sockaddr *d;
  unsigned char proto;
  s = (struct sockaddr *)&src;
  d = (struct sockaddr *)&dst;
  signed int return_value_handle_link_layer$1;
  return_value_handle_link_layer$1=handle_link_layer(&datalink_info, pkt, hdr->caplen, &proto, &off);
  if(return_value_handle_link_layer$1 == 0)
  {
    signed int return_value_layer3_find_tcp$2;
    return_value_layer3_find_tcp$2=layer3_find_tcp(pkt, proto, &off, s, d, &tcp);
    if(return_value_layer3_find_tcp$2 == 0)
    {
      len = (signed int)(hdr->caplen - (unsigned int)off);
      C=find_connection(s, d);
      if(C == ((struct _connection **)NULL))
      {
        char *return_value_connection_string$3;
        return_value_connection_string$3=connection_string(s, d);
        log_msg((enum anonymous$25)LOG_INFO, "new connection: %s", return_value_connection_string$3);
        C=alloc_connection();
        *C=connection_new(s, d);
        (*C)->isn=__bswap_32(tcp.$anon0.$anon0.th_seq);
      }

      c = *C;
      delta = 0;
      if(!((0x04 & (signed int)tcp.$anon0.$anon0.th_flags) == 0))
      {
        char *return_value_connection_string$4;
        return_value_connection_string$4=connection_string(s, d);
        log_msg((enum anonymous$25)LOG_INFO, "connection reset: %s", return_value_connection_string$4);
        connection_delete(c);
        *C = (struct _connection *)(void *)0;
        C=find_connection(d, s);
        if(!(C == ((struct _connection **)NULL)))
        {
          connection_delete(*C);
          *C = (struct _connection *)(void *)0;
        }

        goto __CPROVER_DUMP_L12;
      }

      if(len >= 1)
      {
        unsigned int offset;
        offset=__bswap_32(tcp.$anon0.$anon0.th_seq);
        if(!(offset >= c->isn + (unsigned int)delta))
          offset = 0xffffffff - ((c->isn + (unsigned int)delta) - offset);

        else
          offset = offset - (c->isn + (unsigned int)delta);
        if(!(262144u + c->len >= offset))
        {
          char *return_value_connection_string$5;
          return_value_connection_string$5=connection_string(s, d);
          log_msg((enum anonymous$25)LOG_INFO, "out of order packet: %s", return_value_connection_string$5);
        }

        else
        {
          connection_push(c, pkt + (signed long int)off, offset, (unsigned int)len);
          extract_media(c);
        }
      }

      if(!((0x01 & (signed int)tcp.$anon0.$anon0.th_flags) == 0))
      {
        char *return_value_connection_string$6;
        return_value_connection_string$6=connection_string(s, d);
        log_msg((enum anonymous$25)LOG_INFO, "connection closing: %s, %d bytes transferred", return_value_connection_string$6, c->len);
        c->fin = 1;
      }

      sweep_connections();
    }

  }


__CPROVER_DUMP_L12:
  ;
}

// save_image
// file display.c line 247
void save_image(struct imgrect *ir)
{
  signed int fd1;
  signed int fd2;
  char buf[8192l];
  signed long int l;
  struct stat st;
  unsigned long int return_value_strlen$1;
  void *return_value_xcalloc$2;
  static char *name;
  if(name == ((char *)NULL))
  {
    return_value_strlen$1=strlen(savedimg_prefix);
    return_value_xcalloc$2=xcalloc(return_value_strlen$1 + (unsigned long int)16, (unsigned long int)1);
    name = (char *)return_value_xcalloc$2;
  }

  signed int tmp_post$4;
  char *return_value_strrchr$5;
  signed int return_value_stat$3;
  do
  {
    static signed int num;
    tmp_post$4 = num;
    num = num + 1;
    return_value_strrchr$5=strrchr(ir->filename, 46);
    sprintf(name, "%s%d%s", savedimg_prefix, tmp_post$4, return_value_strrchr$5);
    return_value_stat$3=stat$link1(name, &st);
  }
  while(return_value_stat$3 == 0);
  log_msg((enum anonymous$25)LOG_INFO, "saving `%s' as `%s'", ir->filename, name);
  fd1=open(ir->filename, 00);
  if(fd1 == -1)
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    log_msg((enum anonymous$25)LOG_ERROR, "%s: %s", ir->filename, return_value_strerror$7);
    goto __CPROVER_DUMP_L7;
  }

  fd2=open(name, 01 | 0100 | 01000, 0666);
  if(fd2 == -1)
  {
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    char *return_value_strerror$9;
    return_value_strerror$9=strerror(*return_value___errno_location$8);
    log_msg((enum anonymous$25)LOG_ERROR, "%s: %s", name, return_value_strerror$9);
    close(fd1);
    goto __CPROVER_DUMP_L7;
  }

  do
  {
    l=read(fd1, (void *)buf, sizeof(char [8192l]) /*8192ul*/ );
    if(!(l >= 1l))
      break;

    signed long int return_value_write$12;
    return_value_write$12=write(fd2, (const void *)buf, (unsigned long int)l);
    if(return_value_write$12 == -1l)
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      log_msg((enum anonymous$25)LOG_ERROR, "%s: %s", name, return_value_strerror$11);
      close(fd1);
      close(fd2);
      goto __CPROVER_DUMP_L7;
    }

  }
  while((_Bool)1);
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  if(l == -1l)
  {
    return_value___errno_location$13=__errno_location();
    return_value_strerror$14=strerror(*return_value___errno_location$13);
    log_msg((enum anonymous$25)LOG_ERROR, "%s: %s", ir->filename, return_value_strerror$14);
  }

  close(fd1);
  close(fd2);

__CPROVER_DUMP_L7:
  ;
}

// scroll_backing_image
// file display.c line 165
void scroll_backing_image(const signed int dy)
{
  unsigned int **row1;
  unsigned int **row2;
  struct imgrect *ir;
  row1 = backing_image->data;
  row2 = backing_image->data + (signed long int)dy;
  for( ; !(row2 >= backing_image->data + (signed long int)height); row2 = row2 + 1l)
  {
    memcpy((void *)*row1, (const void *)*row2, (unsigned long int)width * sizeof(unsigned int) /*4ul*/ );
    row1 = row1 + 1l;
  }
  row2 = row1;
  for( ; !(row2 >= backing_image->data + (signed long int)height); row2 = row2 + 1l)
    memset((void *)*row2, 0, (unsigned long int)width * sizeof(unsigned int) /*4ul*/ );
  ir = imgrects;
  for( ; !(ir >= imgrects + (signed long int)nimgrects); ir = ir + 1l)
    if(!(ir->filename == ((char *)NULL)))
    {
      ir->y = ir->y - dy;
      if(!(ir->h + ir->y >= 0))
      {
        unlink(ir->filename);
        xfree((void *)ir->filename);
        memset((void *)ir, 0, sizeof(struct imgrect) /*24ul*/ );
      }

    }

}

// set_loglevel
// file log.h line 20
void set_loglevel(enum anonymous$25 level)
{
  loglevel = level;
}

// set_tmpdir
// file tmpdir.h line 22
void set_tmpdir(const char *dir, enum anonymous$51 type, signed int max_files, signed int preserve_files)
{
  /* assertion tmpdir.path == ((void *)0) */
  assert(tmpdir.path == (const char *)(void *)0);
  /* assertion dir != ((void *)0) */
  assert(dir != (const char *)(void *)0);
  tmpdir.path = dir;
  tmpdir.type = type;
  tmpdir.max_files = max_files;
  tmpdir.preserve_files = preserve_files;
  log_msg((enum anonymous$25)LOG_INFO, "using temporary file directory %s", tmpdir.path);
}

// setup_signals
// file driftnet.c line 71
static void setup_signals(void)
{
  signed int *p;
  signed int ignore_signals[2l] = { 13, 0 };
  signed int terminate_signals[5l] = { 15, 2, 7, 17, 0 };
  struct sigaction sa;
  sa.sa_flags = 0x10000000 | 1;
  p = ignore_signals;
  for( ; !(*p == 0); p = p + 1l)
  {
    memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
    sa.__sigaction_handler.sa_handler = (void (*)(signed int))1;
    sigaction(*p, &sa, (struct sigaction *)(void *)0);
  }
  p = terminate_signals;
  for( ; !(*p == 0); p = p + 1l)
  {
    memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
    sa.__sigaction_handler.sa_handler = terminate_on_signal;
    sigaction(*p, &sa, (struct sigaction *)(void *)0);
  }
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// stat$link1
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat$link1(const char *__path$link1, struct stat *__statbuf$link1)
{
  signed int return_value___xstat$1$link1;
  return_value___xstat$1$link1=__xstat(1, __path$link1, __statbuf$link1);
  return return_value___xstat$1$link1;
}

// sweep_connections
// file connection.c line 159
void sweep_connections(void)
{
  signed long int now;
  struct _connection **C;
  now=time((signed long int *)(void *)0);
  C = slots;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  for( ; !(C >= slots + (signed long int)slotsalloc); C = C + 1l)
    if(!(*C == ((struct _connection *)NULL)))
    {
      struct _connection *c = *C;
      if(now + -c->last >= 6l)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        if(!(c->fin == 0))
        {
          if(c->blocks == ((struct datablock *)NULL))
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = !(c->blocks->next != ((struct datablock *)NULL)) ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = c->len > (unsigned int)(8 * 1024 * 1024) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        extract_media(c);
        connection_delete(c);
        *C = (struct _connection *)(void *)0;
      }

    }

}

// terminate_on_signal
// file driftnet.c line 57
static void terminate_on_signal(signed int s)
{
  if(!(mpeg_mgr_pid == 0))
    kill(mpeg_mgr_pid, s);

  foad = s;
}

// tmpfile_write
// file tmpdir.c line 208
const char * tmpfile_write(const char *mname, const unsigned char *data, const unsigned long int len)
{
  char *buf;
  signed int fd;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(tmpdir.path);
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc(return_value_strlen$1 + (unsigned long int)64);
  buf = (char *)return_value_xmalloc$2;
  signed long int return_value_time$3;
  return_value_time$3=time((signed long int *)(void *)0);
  signed int return_value_rand$4;
  return_value_rand$4=rand();
  static char name[64l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  sprintf(name, "driftnet-%08x%08x.%s", (unsigned int)return_value_time$3, return_value_rand$4, mname);
  sprintf(buf, "%s/%s", tmpdir.path, (const void *)name);
  fd=open(buf, 01 | 0100 | 0200, 0644);
  if(fd == -1)
  {
    log_msg((enum anonymous$25)LOG_WARNING, "can't open %s for writing", buf);
    return (const char *)(void *)0;
  }

  else
  {
    write(fd, (const void *)data, len);
    close(fd);
    xfree((void *)buf);
    return name;
  }
}

// tmpfiles_limit_reached
// file tmpdir.c line 274
signed int tmpfiles_limit_reached(void)
{
  _Bool tmp_if_expr$2;
  signed int return_value_count_tmpfiles$1;
  if(tmpdir.max_files == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_count_tmpfiles$1=count_tmpfiles();
    tmp_if_expr$2 = return_value_count_tmpfiles$1 < tmpdir.max_files ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return 0;

  else
    return 1;
}

// unexpected_exit
// file driftnet.c line 42
void unexpected_exit(signed int ret)
{
  packetcapture_close();
  connection_free_slots();
  clean_tmpdir();
  close_pidfile();
  exit(ret);
}

// update_window
// file display.c line 154
void update_window()
{
  if(!(backing_image == ((struct _img *)NULL)))
  {
    struct _GdkGC *gc;
    gc=gdk_gc_new(drawable);
    gdk_draw_rgb_32_image(drawable, gc, 0, 0, width, height, (enum anonymous$48)GDK_RGB_DITHER_NORMAL, (unsigned char *)backing_image->flat, (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)width));
    g_object_unref((void *)gc);
  }

}

// usage
// file options.c line 209
static void usage(struct _IO_FILE *fp)
{
  fprintf(fp, "driftnet, version %s\nCapture images from network traffic and display them in an X window.\n\nSynopsis: driftnet [options] [filter code]\n\nOptions:\n\n  -h               Display this help message.\n  -v               Verbose operation.\n  -b               Beep when a new image is captured.\n  -i interface     Select the interface on which to listen (default: all\n                   interfaces).\n  -f file          Instead of listening on an interface, read captured\n                   packets from a pcap dump file; file can be a named pipe\n                   for use with Kismet or similar.\n  -p               Do not put the listening interface into promiscuous mode.\n  -a               Adjunct mode: do not display images on screen, but save\n                   them to a temporary directory and announce their names on\n                   standard output.\n  -m number        Maximum number of images to keep in temporary directory\n                   in adjunct mode.\n  -d directory     Use the named temporary directory.\n  -x prefix        Prefix to use when saving images.\n  -s               Attempt to extract streamed audio data from the network,\n                   in addition to images. At present this supports MPEG data\n                   only.\n  -S               Extract streamed audio but not images.\n  -M command       Use the given command to play MPEG audio data extracted\n                   with the -s option; this should process MPEG frames\n                   supplied on standard input. Default: `mpg123 -'.\n\nFilter code can be specified after any options in the manner of tcpdump(8).\nThe filter code will be evaluated as `tcp and (user filter code)'\n\nYou can save images to the current directory by clicking on them.\n\nAdjunct mode is designed to be used by other programs which want to use\ndriftnet to gather images from the network. With the -m option, driftnet will\nsilently drop images if more than the specified number of images are saved\nin its temporary directory. It is assumed that some other process is\ncollecting and deleting the image files.\n\ndriftnet, copyright (c) 2001-2 Chris Lightfoot <chris@ex-parrot.com>\nhome page: http://www.ex-parrot.com/~chris/driftnet/\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\n", (const void *)"1.1.5");
}

// validate_options
// file options.c line 164
static void validate_options(struct anonymous$2 *options)
{
  if(options->dumpfile == ((char *)NULL))
  {
    if(options->interface == ((char *)NULL))
      options->interface=get_default_interface();

  }

  if(!(options->max_tmpfiles == 0))
  {
    if(options->adjunct == 0)
    {
      log_msg((enum anonymous$25)LOG_WARNING, "-m only makes sense with -a");
      options->max_tmpfiles = 0;
    }

  }

  if(!(options->adjunct == 0))
  {
    if(!(options->newpfx == 0))
      log_msg((enum anonymous$25)LOG_WARNING, "-x ignored -a");

  }

  if(!(options->mpeg_player_specified == 0))
  {
    if((m_audio & (signed int)options->extract_type) == 0)
      log_msg((enum anonymous$25)LOG_WARNING, "-M only makes sense with -s");

  }

  if(!(options->mpeg_player_specified == 0))
  {
    if(!(options->adjunct == 0))
      log_msg((enum anonymous$25)LOG_WARNING, "-M ignored with -a");

  }

  if(!(options->max_tmpfiles == 0))
  {
    if(!(options->adjunct == 0))
      log_msg((enum anonymous$25)LOG_INFO, "a maximum of %d images will be buffered", options->max_tmpfiles);

  }

  if(!(options->beep == 0))
  {
    if(!(options->adjunct == 0))
      log_msg((enum anonymous$25)LOG_WARNING, "can't beep in adjunct mode");

  }

}

// xcalloc
// file util.h line 21
void * xcalloc(unsigned long int n, unsigned long int m)
{
  void *v;
  v=calloc(n, m);
  if(v == NULL)
    abort();

  return v;
}

// xfree
// file util.h line 23
void xfree(void *v)
{
  if(!(v == NULL))
    free(v);

}

// xmalloc
// file util.h line 20
void * xmalloc(unsigned long int n)
{
  void *v;
  v=malloc(n);
  if(v == NULL)
    abort();

  return v;
}

// xnanosleep
// file util.c line 93
void xnanosleep(signed long int nanosecs)
{
  struct timespec tm = { .tv_sec=(signed long int)0, .tv_nsec=nanosecs };
  nanosleep(&tm, (struct timespec *)(void *)0);
}

// xread
// file display.c line 322
static signed long int xread(signed int fd, void *buf, unsigned long int len)
{
  char *p = (char *)buf;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  while(!(p >= (char *)buf + (signed long int)len))
  {
    signed long int l;
    l=read(fd, (void *)p, (unsigned long int)(((char *)buf + (signed long int)len) - p));
    if(l == -1l)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 != 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      return (signed long int)-1;

    else
      if(l == 0l)
        return (signed long int)0;

      else
        p = p + l;
  }
  return (signed long int)len;
}

// xrealloc
// file util.h line 22
void * xrealloc(void *w, unsigned long int n)
{
  void *v;
  v=realloc(w, n);
  if(v == NULL && !(n == 0ul))
    abort();

  return v;
}

// xstrdup
// file util.c line 70
char * xstrdup(const char *s)
{
  char *t;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc(return_value_strlen$1 + (unsigned long int)1);
  t = (char *)return_value_xmalloc$2;
  strcpy(t, s);
  return t;
}

