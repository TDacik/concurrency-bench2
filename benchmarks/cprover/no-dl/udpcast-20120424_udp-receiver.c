// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_1;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_5;

// tag-#anon#UN[*{S8}_S8_'ifcu_buf'||*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous_2;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous_7;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_4;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_3;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_8;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addr_type_t
// file socklib.h line 120
enum addr_type_t { ADDR_TYPE_UCAST=0, ADDR_TYPE_MCAST=1, ADDR_TYPE_BCAST=2 };

// tag-clientState
// file receivedata.c line 71
struct clientState;

// tag-client_config
// file udp-receiver.h line 15
struct client_config;

// tag-connectReply
// file udpc-protoc.h line 82
struct connectReply;

// tag-connectReq
// file udpc-protoc.h line 62
struct connectReq;

// tag-console_t
// file console.h line 15
struct console_t;

// tag-dataBlock
// file udpc-protoc.h line 108
struct dataBlock;

// tag-disconnect
// file udpc-protoc.h line 74
struct disconnect;

// tag-discovery
// file udpcast.h line 61
enum discovery { DSC_DOUBLING=0, DSC_REDUCING=1 };

// tag-disk_config
// file udpcast.h line 33
struct disk_config;

// tag-ethtool_cmd
// file /usr/include/linux/ethtool.h line 93
struct ethtool_cmd;

// tag-ethtool_value
// file /usr/include/linux/ethtool.h line 209
struct ethtool_value;

// tag-fecBlock
// file udpc-protoc.h line 117
struct fecBlock;

// tag-fec_desc
// file receivedata.c line 38
struct fec_desc;

// tag-fec_parms
// file fec.h line 9
struct fec_parms;

// tag-fifo
// file fifo.h line 7
struct fifo;

// tag-go
// file udpc-protoc.h line 69
struct go;

// tag-hello
// file udpc-protoc.h line 91
struct hello;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip_mreqn
// file /usr/include/x86_64-linux-gnu/bits/in.h line 145
struct ip_mreqn;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-net_config
// file udpcast.h line 44
struct net_config;

// tag-net_if
// file socklib.h line 110
struct net_if_0;

// tag-net_if_link1
// file socklib.h line 110
struct net_if;

// tag-ok
// file udpc-protoc.h line 48
struct ok;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-produconsum
// file produconsum.h line 4
struct produconsum;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rateGovernor_t
// file udpcast.h line 55
struct rateGovernor_t;

// tag-receiver_stats
// file statistics.h line 5
struct receiver_stats;

// tag-reqack
// file udpc-protoc.h line 126
struct reqack;

// tag-retransmit
// file udpc-protoc.h line 54
struct retransmit;

// tag-sender_stats
// file statistics.h line 6
struct sender_stats;

// tag-serverControlMsg
// file udpc-protoc.h line 99
union serverControlMsg;

// tag-serverDataMsg
// file udpc-protoc.h line 134
union serverDataMsg;

// tag-slice
// file receivedata.c line 45
struct slice;

// tag-slice_state
// file receivedata.c line 26
enum slice_state { SLICE_FREE=0, SLICE_RECEIVING=1, SLICE_DONE=2, SLICE_FEC=3, SLICE_FEC_DONE=4 };

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat_config
// file udpcast.h line 107
struct stat_config;

// tag-stats
// file statistics.c line 28
struct stats;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// INET_ATON
// file socklib.c line 209
static inline signed int INET_ATON(const char *a, struct in_addr *i);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1);
// __bswap_32_link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link2(unsigned int __bsx_link2);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2);
// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// _consumeAny
// file produconsum.c line 104
static signed int _consumeAny(struct produconsum *pc, unsigned int minAmount, struct timespec *ts);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// addmul
// file fec.c line 406
static void addmul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz);
// advanceReceivedPointer
// file receivedata.c line 409
static void advanceReceivedPointer(struct clientState *clst);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// checkSliceComplete
// file receivedata.c line 474
static void checkSliceComplete(struct clientState *clst, struct slice *slice);
// cleanupSlices
// file receivedata.c line 433
static void cleanupSlices(struct clientState *clst, unsigned int doneState);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closeAllExcept
// file receivedata.c line 922
static void closeAllExcept(struct clientState *clst, signed int fd);
// dispatchMessage
// file receivedata.c line 939
static signed int dispatchMessage(struct clientState *clst);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// dupFd
// file process.c line 10
static void dupFd(signed int src, signed int target);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fakeSliceComplete
// file receivedata.c line 323
static void fakeSliceComplete(struct clientState *clst);
// fecMain
// file receivedata.c line 589
static void * fecMain(void *args0);
// fec_decode
// file fec.h line 25
void fec_decode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks);
// fec_decode_one_stripe
// file receivedata.c line 534
static void fec_decode_one_stripe(struct clientState *clst, struct slice *slice, signed int stripe, signed int bytes, signed int stripes, signed short int nr_fec_blocks, struct fec_desc *fec_descs);
// fec_encode
// file fec.c line 776
void fec_encode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nrDataBlocks, unsigned char **fec_blocks, unsigned int nrFecBlocks);
// fec_init
// file fec.h line 17
void fec_init(void);
// fec_license
// file fec.h line 35
void fec_license(void);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fillMreq
// file socklib.c line 371
static signed int fillMreq(struct net_if *net_if, struct in_addr addr, struct ip_mreqn *mreq);
// findSlice
// file receivedata.c line 337
static struct slice * findSlice(struct clientState *clst, signed int sliceNo);
// fixConsole
// file udpr-negotiate.c line 55
static void fixConsole(void);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeBlockSpace
// file receivedata.c line 227
static void freeBlockSpace(struct clientState *clst, unsigned char *block);
// fsync
// file /usr/include/unistd.h line 956
extern signed int fsync(signed int);
// generate_gf
// file fec.c line 217
static void generate_gf(void);
// getBlockSpace
// file receivedata.c line 211
static unsigned char * getBlockSpace(struct clientState *clst);
// getProducedAmount
// file produconsum.c line 88
static signed int getProducedAmount(struct produconsum *pc);
// getSliceBlocks
// file receivedata.c line 528
static signed int getSliceBlocks(struct slice *slice, struct net_config *net_config);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hasLink
// file socklib.c line 494
static signed int hasLink(signed int s, const char *ifname);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// initClstForFec
// file receivedata.c line 649
static void initClstForFec(struct clientState *clst);
// initMsgHdr
// file socklib.h line 218
static inline void initMsgHdr(struct msghdr *hdr);
// initSlice
// file receivedata.c line 245
static struct slice * initSlice(struct clientState *clst, struct slice *slice, signed int sliceNo);
// initSliceForFec
// file receivedata.c line 656
static void initSliceForFec(struct clientState *clst, struct slice *slice);
// initSockAddress
// file socklib.c line 219
static signed int initSockAddress(enum addr_type_t addr_type, struct net_if *net_if, unsigned int ip, unsigned short int port, struct sockaddr_in *addr);
// initStats
// file statistics.c line 60
static void initStats(struct stats *s, signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress);
// init_mul_table
// file fec.c line 189
static void init_mul_table(void);
// intHandler
// file udp-receiver.c line 102
static void intHandler(signed int nr);
// invert_mat
// file fec.c line 545
static signed int invert_mat(unsigned char *src, signed int k);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isMcastAddress
// file socklib.c line 1111
signed int isMcastAddress(struct sockaddr_in *addr);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lseek64
// file /usr/include/unistd.h line 345
extern signed long int lseek64(signed int, signed long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mcastListen
// file socklib.c line 418
static signed int mcastListen(signed int sock, struct net_if *net_if, struct sockaddr_in *addr);
// mcastOp
// file socklib.c line 387
static signed int mcastOp(signed int sock, struct net_if *net_if, struct in_addr addr, signed int code, const char *message);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// modnn
// file fec.c line 152
static inline unsigned char modnn(signed int x);
// mul
// file fec.c line 532
static inline void mul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz);
// netReceiverMain
// file receivedata.c line 1151
static void * netReceiverMain(void *args0);
// newSlice
// file receivedata.c line 284
static struct slice * newSlice(struct clientState *clst, signed int sliceNo);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// open2
// file udpc_process.h line 17
signed int open2(signed int in, signed int out, char **arg, signed int closeFd);
// openOutFile
// file udpr-negotiate.c line 83
static signed int openOutFile(struct disk_config *disk_config);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pc_consume
// file produconsum.h line 30
signed int pc_consume(struct produconsum *pc, signed int amount);
// pc_consumeAny
// file produconsum.c line 165
signed int pc_consumeAny(struct produconsum *pc);
// pc_consumeAnyContiguous
// file produconsum.c line 177
signed int pc_consumeAnyContiguous(struct produconsum *pc);
// pc_consumeAnyWithTimeout
// file produconsum.c line 170
signed int pc_consumeAnyWithTimeout(struct produconsum *pc, struct timespec *ts);
// pc_consumeContiguousMinAmount
// file produconsum.h line 21
signed int pc_consumeContiguousMinAmount(struct produconsum *pc, signed int amount);
// pc_consumed
// file produconsum.h line 58
signed int pc_consumed(struct produconsum *pc, signed int amount);
// pc_getConsumerPosition
// file produconsum.h line 35
unsigned int pc_getConsumerPosition(struct produconsum *pc);
// pc_getProducerPosition
// file produconsum.h line 40
unsigned int pc_getProducerPosition(struct produconsum *pc);
// pc_getSize
// file produconsum.h line 45
unsigned int pc_getSize(struct produconsum *pc);
// pc_getWaiting
// file produconsum.c line 98
unsigned int pc_getWaiting(struct produconsum *pc);
// pc_makeProduconsum
// file produconsum.h line 6
struct produconsum * pc_makeProduconsum(signed int size, const char *name);
// pc_produce
// file produconsum.h line 7
void pc_produce(struct produconsum *pc, unsigned int amount);
// pc_produceEnd
// file produconsum.h line 8
void pc_produceEnd(struct produconsum *pc);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printFilePosition
// file statistics.c line 94
static void printFilePosition(signed int fd);
// printMissedBlockMap
// file receivedata.c line 138
static void printMissedBlockMap(struct clientState *clst, struct slice *slice);
// printNewlineIfNeeded
// file log.c line 13
static void printNewlineIfNeeded(void);
// printProcessStatus
// file udpcast.c line 30
static signed int printProcessStatus(const char *message, signed int status);
// processDataBlock
// file receivedata.c line 776
static signed int processDataBlock(struct clientState *clst, signed int sliceNo, signed int blockNo, signed int bytes);
// processFecBlock
// file receivedata.c line 692
static signed int processFecBlock(struct clientState *clst, signed int stripes, signed int sliceNo, signed int blockNo, signed int bytes);
// processReqAck
// file receivedata.c line 857
static signed int processReqAck(struct clientState *clst, signed int sliceNo, signed int bytes, signed int rxmit);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_6 *, const union anonymous_4 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_6 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_6 *, union anonymous_3 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_6 *, union anonymous_3 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_3 *, const union anonymous_4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_3 *);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int,  struct sockaddr *, unsigned int *);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// reduce
// file fec.c line 810
static inline void reduce(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks);
// resolve
// file fec.c line 856
static inline void resolve(signed int blockSize, unsigned char **data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, signed short int nr_fec_blocks);
// safe_inet_aton
// file socklib.c line 266
static signed int safe_inet_aton(const char *address, struct in_addr *ip);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_1 *, struct anonymous_1 *, struct anonymous_1 *, struct timeval *);
// selectWithConsole
// file console.h line 26
signed int selectWithConsole(struct console_t *con, signed int maxFd, struct anonymous_1 *read_set, struct timeval *tv, signed int *keyPressed);
// sendConnectReq
// file udpr-negotiate.c line 28
static signed int sendConnectReq(struct client_config *client_config, struct net_config *net_config, signed int haveServerAddress);
// sendDisconnectWrapper
// file udpr-negotiate.c line 60
static void sendDisconnectWrapper(void);
// sendOk
// file receivedata.c line 188
static signed int sendOk(struct client_config *client_config, unsigned int sliceNo);
// sendRetransmit
// file receivedata.c line 197
static signed int sendRetransmit(struct clientState *clst, struct slice *slice, signed int rxmit);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// setNextBlock
// file receivedata.c line 236
static void setNextBlock(struct clientState *clst);
// setSliceBytes
// file receivedata.c line 382
static void setSliceBytes(struct slice *slice, struct clientState *clst, signed int bytes);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setupMessages
// file receivedata.c line 1138
static signed int setupMessages(struct clientState *clst);
// shouldPrint
// file statistics.c line 47
static signed int shouldPrint(struct stats *s, struct timeval *now, signed int isFinal);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_0 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_0 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signalForward
// file udp-receiver.c line 89
static void signalForward(void);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_0 *, struct anonymous_0 *);
// slow_addmul1
// file fec.c line 301
static void slow_addmul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz);
// slow_mul1
// file fec.c line 427
static void slow_mul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// udpc_allocReadStats
// file statistics.h line 13
struct receiver_stats * udpc_allocReadStats(signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress);
// udpc_allocSenderStats
// file statistics.c line 196
struct sender_stats * udpc_allocSenderStats(signed int fd, struct _IO_FILE *logfile, signed long int bwPeriod, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress);
// udpc_clearIp
// file socklib.c line 990
void udpc_clearIp(struct sockaddr_in *addr);
// udpc_closeSock
// file socklib.c line 1100
void udpc_closeSock(signed int *socks, signed int nr, signed int target);
// udpc_copyFromMessage
// file socklib.c line 1018
void udpc_copyFromMessage(struct sockaddr_in *dst, unsigned char *src);
// udpc_copyIpFrom
// file socklib.c line 1000
void udpc_copyIpFrom(struct sockaddr_in *dst, struct sockaddr_in *src);
// udpc_copyToMessage
// file socklib.c line 1012
void udpc_copyToMessage(unsigned char *dst, struct sockaddr_in *src);
// udpc_displayReceiverStats
// file statistics.h line 18
void udpc_displayReceiverStats(struct receiver_stats *rs, signed int isFinal);
// udpc_displaySenderStats
// file statistics.c line 240
void udpc_displaySenderStats(struct sender_stats *ss, signed int blockSize, signed int sliceSize, signed int isFinal);
// udpc_doReceive
// file socklib.c line 296
signed int udpc_doReceive(signed int s, void *message, unsigned long int len, struct sockaddr_in *from, signed int portBase);
// udpc_doSend
// file socklib.c line 288
signed int udpc_doSend(signed int s, void *message, unsigned long int len, struct sockaddr_in *to);
// udpc_fatal
// file log.h line 19
signed int udpc_fatal(signed int code, const char *fmt, ...);
// udpc_flprintf
// file log.h line 17
signed int udpc_flprintf(const char *fmt, ...);
// udpc_getBroadCastAddress
// file socklib.c line 250
signed int udpc_getBroadCastAddress(struct net_if *net_if, struct sockaddr_in *addr, signed short int port);
// udpc_getDefaultMcastAddress
// file socklib.c line 1005
void udpc_getDefaultMcastAddress(struct net_if *net_if, struct sockaddr_in *mcast);
// udpc_getIpString
// file socklib.c line 963
char * udpc_getIpString(struct sockaddr_in *addr, char *buffer);
// udpc_getMcastAllAddress
// file socklib.c line 273
signed int udpc_getMcastAllAddress(struct sockaddr_in *addr, const char *address, signed short int port);
// udpc_getMyAddress
// file socklib.c line 245
signed int udpc_getMyAddress(struct net_if *net_if, struct sockaddr_in *addr);
// udpc_getNetIf
// file socklib.c line 557
struct net_if * udpc_getNetIf(const char *wanted);
// udpc_getPort
// file socklib.c line 981
unsigned short int udpc_getPort(struct sockaddr_in *addr);
// udpc_getRcvBuf
// file socklib.c line 334
unsigned int udpc_getRcvBuf(signed int sock);
// udpc_getSelectedSock
// file socklib.c line 1089
signed int udpc_getSelectedSock(signed int *socks, signed int nr, struct anonymous_1 *read_set);
// udpc_getSendBuf
// file socklib.c line 321
signed int udpc_getSendBuf(signed int sock);
// udpc_initFifo
// file fifo.h line 20
void udpc_initFifo(struct fifo *fifo, signed int blockSize);
// udpc_ipIsEqual
// file socklib.c line 973
signed int udpc_ipIsEqual(struct sockaddr_in *left, struct sockaddr_in *right);
// udpc_ipIsZero
// file socklib.c line 977
signed int udpc_ipIsZero(struct sockaddr_in *ip);
// udpc_isAddressEqual
// file socklib.c line 1022
signed int udpc_isAddressEqual(struct sockaddr_in *a, struct sockaddr_in *b);
// udpc_isFullDuplex
// file socklib.c line 523
signed int udpc_isFullDuplex(signed int s, const char *ifname);
// udpc_logprintf
// file log.c line 25
signed int udpc_logprintf(struct _IO_FILE *logfile, const char *fmt, ...);
// udpc_makeSockAddr
// file socklib.c line 174
signed int udpc_makeSockAddr(char *hostname, signed short int port, struct sockaddr_in *addr);
// udpc_makeSocket
// file socklib.c line 899
signed int udpc_makeSocket(enum addr_type_t addr_type, struct net_if *net_if, struct sockaddr_in *tmpl, signed int port);
// udpc_parseCommand
// file udpcast.c line 7
signed int udpc_parseCommand(char *pipeName, char **arg);
// udpc_parseSize
// file socklib.h line 185
unsigned long int udpc_parseSize(char *sizeString);
// udpc_prepareConsole
// file console.h line 20
struct console_t * udpc_prepareConsole(signed int fd);
// udpc_prepareForSelect
// file socklib.c line 1074
signed int udpc_prepareForSelect(signed int *socks, signed int nr, struct anonymous_1 *read_set);
// udpc_printLongNum
// file log.c line 96
signed int udpc_printLongNum(unsigned long long int x);
// udpc_printMyIp
// file socklib.c line 954
void udpc_printMyIp(struct net_if *net_if);
// udpc_receiverStatsAddBytes
// file statistics.h line 17
void udpc_receiverStatsAddBytes(struct receiver_stats *rs, signed long int bytes);
// udpc_receiverStatsStartTimer
// file statistics.h line 16
void udpc_receiverStatsStartTimer(struct receiver_stats *rs);
// udpc_restoreConsole
// file console.h line 34
void udpc_restoreConsole(struct console_t **cp, signed int doConsume);
// udpc_selectSock
// file socklib.c line 1055
signed int udpc_selectSock(signed int *socks, signed int nr, signed int startTimeout);
// udpc_sendDisconnect
// file udpr-negotiate.c line 65
void udpc_sendDisconnect(signed int exitStatus, struct client_config *client_config);
// udpc_sendGo
// file udp-receiver.h line 42
signed int udpc_sendGo(struct client_config *client_config);
// udpc_senderSetAnswered
// file statistics.c line 268
void udpc_senderSetAnswered(struct sender_stats *ss, signed int clNo);
// udpc_senderStatsAddBytes
// file statistics.c line 207
void udpc_senderStatsAddBytes(struct sender_stats *ss, signed long int bytes);
// udpc_senderStatsAddRetransmissions
// file statistics.c line 231
void udpc_senderStatsAddRetransmissions(struct sender_stats *ss, signed int retransmissions);
// udpc_setIpFromString
// file socklib.c line 995
void udpc_setIpFromString(struct sockaddr_in *addr, char *ip);
// udpc_setMcastDestination
// file socklib.c line 424
signed int udpc_setMcastDestination(signed int sock, struct net_if *net_if, struct sockaddr_in *addr);
// udpc_setPort
// file socklib.c line 985
void udpc_setPort(struct sockaddr_in *addr, unsigned short int port);
// udpc_setRcvBuf
// file socklib.c line 342
void udpc_setRcvBuf(signed int sock, unsigned int bufsize);
// udpc_setSendBuf
// file socklib.c line 329
void udpc_setSendBuf(signed int sock, unsigned int bufsize);
// udpc_setSocketToBroadcast
// file socklib.c line 348
signed int udpc_setSocketToBroadcast(signed int sock);
// udpc_setTtl
// file socklib.c line 354
signed int udpc_setTtl(signed int sock, signed int ttl);
// udpc_shouldPrintUncompressedPos
// file udpcast.h line 125
signed int udpc_shouldPrintUncompressedPos(signed int deflt, signed int fd, signed int ref);
// udpc_spawnNetReceiver
// file receivedata.c line 1178
signed int udpc_spawnNetReceiver(struct fifo *fifo, struct client_config *client_config, struct net_config *net_config, struct receiver_stats *stats);
// udpc_startReceiver
// file udp-receiver.h line 44
signed int udpc_startReceiver(signed int doWarn, struct disk_config *disk_config, struct net_config *net_config, struct stat_config *stat_config, const char *ifName);
// udpc_waitForProcess
// file udpcast.c line 59
signed int udpc_waitForProcess(signed int pid, const char *message);
// udpc_writer
// file receiver-diskio.c line 20
signed int udpc_writer(struct fifo *fifo, signed int outFile);
// udpc_zeroSockArray
// file socklib.c line 1048
void udpc_zeroSockArray(signed int *socks, signed int nr);
// udpcr_openPipe
// file receiver-diskio.c line 60
signed int udpcr_openPipe(signed int outFile, struct disk_config *disk_config, signed int *pipePid);
// usage
// file udp-receiver.c line 108
static void usage(char *progname);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vlogprintf
// file log.c line 34
static signed int vlogprintf(struct _IO_FILE *logfile, const char *fmt, void **ap);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wakeConsumer
// file produconsum.c line 39
static void wakeConsumer(struct produconsum *pc);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_1
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_5
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_2
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_7
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_6
{
  // __data
  struct anonymous_5 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_8
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct reqack
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
  // bytes
  signed int bytes;
  // rxmit
  signed int rxmit;
};

struct dataBlock
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
  // blockNo
  unsigned short int blockNo;
  // reserved2
  unsigned short int reserved2;
  // bytes
  signed int bytes;
};

struct fecBlock
{
  // opCode
  unsigned short int opCode;
  // stripes
  signed short int stripes;
  // sliceNo
  signed int sliceNo;
  // blockNo
  unsigned short int blockNo;
  // reserved2
  unsigned short int reserved2;
  // bytes
  signed int bytes;
};

union serverDataMsg
{
  // opCode
  unsigned short int opCode;
  // reqack
  struct reqack reqack;
  // dataBlock
  struct dataBlock dataBlock;
  // fecBlock
  struct fecBlock fecBlock;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct retransmit
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
  // rxmit
  signed int rxmit;
  // map
  unsigned char map[128l];
};

struct fec_desc
{
  // adr
  unsigned char *adr;
  // fecBlockNo
  signed int fecBlockNo;
  // erasedBlockNo
  signed int erasedBlockNo;
};

struct slice
{
  // magic
  signed int magic;
  // state
  volatile enum slice_state state;
  // base
  signed int base;
  // sliceNo
  signed int sliceNo;
  // blocksTransferred
  signed int blocksTransferred;
  // dataBlocksTransferred
  signed int dataBlocksTransferred;
  // bytes
  signed int bytes;
  // bytesKnown
  signed int bytesKnown;
  // freePos
  signed int freePos;
  // retransmit
  struct retransmit retransmit;
  // missing_data_blocks
  signed short int missing_data_blocks[256l];
  // fec_stripes
  signed int fec_stripes;
  // fec_blocks
  signed short int fec_blocks[256l];
  // fec_descs
  struct fec_desc fec_descs[1024l];
};

struct clientState
{
  // fifo
  struct fifo *fifo;
  // client_config
  struct client_config *client_config;
  // net_config
  struct net_config *net_config;
  // Msg
  union serverDataMsg Msg;
  // data_hdr
  struct msghdr data_hdr;
  // data_iov
  struct iovec data_iov[2l];
  // currentSlice
  struct slice *currentSlice;
  // currentSliceNo
  signed int currentSliceNo;
  // stats
  struct receiver_stats *stats;
  // free_slices_pc
  struct produconsum *free_slices_pc;
  // slices
  struct slice slices[4l];
  // receivedPtr
  signed int receivedPtr;
  // receivedSliceNo
  signed int receivedSliceNo;
  // use_fec
  signed int use_fec;
  // fec_data_pc
  struct produconsum *fec_data_pc;
  // fec_slices
  struct slice *fec_slices[4l];
  // fec_thread
  unsigned long int fec_thread;
  // freeBlocks_pc
  struct produconsum *freeBlocks_pc;
  // blockAddresses
  unsigned char **blockAddresses;
  // localBlockAddresses
  unsigned char **localBlockAddresses;
  // localPos
  signed int localPos;
  // blockData
  unsigned char *blockData;
  // nextBlock
  unsigned char *nextBlock;
  // endReached
  signed int endReached;
  // netEndReached
  signed int netEndReached;
  // selectedFd
  signed int selectedFd;
  // promptPrinted
  signed int promptPrinted;
  // fec_code
  struct fec_parms *fec_code;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct client_config
{
  // socks
  signed int socks[4l];
  // serverAddr
  struct sockaddr_in serverAddr;
  // clientNumber
  signed int clientNumber;
  // isStarted
  signed int isStarted;
  // thread
  unsigned long int thread;
  // sender_is_newgen
  signed int sender_is_newgen;
  // console
  struct console_t *console;
};

struct connectReply
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // clNr
  signed int clNr;
  // blockSize
  signed int blockSize;
  // capabilities
  signed int capabilities;
  // mcastAddr
  unsigned char mcastAddr[16l];
};

struct connectReq
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // capabilities
  signed int capabilities;
  // rcvbuf
  unsigned int rcvbuf;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct console_t
{
  // fd
  signed int fd;
  // oldtio
  struct termios oldtio;
  // needClose
  signed int needClose;
  // needRestore
  signed int needRestore;
};

struct disconnect
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct disk_config
{
  // origOutFile
  signed int origOutFile;
  // fileName
  const char *fileName;
  // pipeName
  char *pipeName;
  // flags
  signed int flags;
  // stats_last_printed
  struct timeval stats_last_printed;
};

struct ethtool_cmd
{
  // cmd
  unsigned int cmd;
  // supported
  unsigned int supported;
  // advertising
  unsigned int advertising;
  // speed
  unsigned short int speed;
  // duplex
  unsigned char duplex;
  // port
  unsigned char port;
  // phy_address
  unsigned char phy_address;
  // transceiver
  unsigned char transceiver;
  // autoneg
  unsigned char autoneg;
  // mdio_support
  unsigned char mdio_support;
  // maxtxpkt
  unsigned int maxtxpkt;
  // maxrxpkt
  unsigned int maxrxpkt;
  // speed_hi
  unsigned short int speed_hi;
  // eth_tp_mdix
  unsigned char eth_tp_mdix;
  // eth_tp_mdix_ctrl
  unsigned char eth_tp_mdix_ctrl;
  // lp_advertising
  unsigned int lp_advertising;
  // reserved
  unsigned int reserved[2l];
};

struct ethtool_value
{
  // cmd
  unsigned int cmd;
  // data
  unsigned int data;
};

struct fifo
{
  // dataBuffer
  unsigned char *dataBuffer;
  // dataBufSize
  unsigned int dataBufSize;
  // freeMemQueue
  struct produconsum *freeMemQueue;
  // data
  struct produconsum *data;
  // thread
  unsigned long int thread;
};

struct go
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
};

struct hello
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // capabilities
  signed int capabilities;
  // mcastAddr
  unsigned char mcastAddr[16l];
  // blockSize
  signed short int blockSize;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous_2 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_7 ifr_ifrn;
  // ifr_ifru
  union anonymous_8 ifr_ifru;
};

struct ip_mreqn
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_address
  struct in_addr imr_address;
  // imr_ifindex
  signed int imr_ifindex;
};

struct net_config
{
  // net_if
  struct net_if_0 *net_if;
  // portBase
  signed int portBase;
  // blockSize
  signed int blockSize;
  // sliceSize
  signed int sliceSize;
  // controlMcastAddr
  struct sockaddr_in controlMcastAddr;
  // dataMcastAddr
  struct sockaddr_in dataMcastAddr;
  // mcastRdv
  const char *mcastRdv;
  // ttl
  signed int ttl;
  // nrGovernors
  signed int nrGovernors;
  // rateGovernor
  struct rateGovernor_t *rateGovernor[10l];
  // rateGovernorData
  void *rateGovernorData[10l];
  // ref_tv
  struct timeval ref_tv;
  // discovery
  enum discovery discovery;
  // flags
  signed int flags;
  // capabilities
  signed int capabilities;
  // min_slice_size
  signed int min_slice_size;
  // default_slice_size
  signed int default_slice_size;
  // max_slice_size
  signed int max_slice_size;
  // rcvbuf
  unsigned int rcvbuf;
  // rexmit_hello_interval
  signed int rexmit_hello_interval;
  // autostart
  signed int autostart;
  // requestedBufSize
  signed int requestedBufSize;
  // min_receivers
  signed int min_receivers;
  // max_receivers_wait
  signed int max_receivers_wait;
  // min_receivers_wait
  signed int min_receivers_wait;
  // retriesUntilDrop
  signed int retriesUntilDrop;
  // exitWait
  signed int exitWait;
  // startTimeout
  signed int startTimeout;
  // receiveTimeout
  signed int receiveTimeout;
  // fec_redundancy
  signed int fec_redundancy;
  // fec_stripesize
  signed int fec_stripesize;
  // fec_stripes
  signed int fec_stripes;
  // rehelloOffset
  signed int rehelloOffset;
};

struct net_if_0
{
  // addr
  struct in_addr addr;
  // bcast
  struct in_addr bcast;
  // name
  const char *name;
};

struct net_if
{
  // addr
  struct in_addr addr;
  // bcast
  struct in_addr bcast;
  // name
  const char *name;
  // index
  signed int index;
};

struct ok
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // sliceNo
  signed int sliceNo;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct produconsum
{
  // size
  unsigned int size;
  // produced
  volatile unsigned int produced;
  // consumed
  unsigned int consumed;
  // atEnd
  volatile signed int atEnd;
  // mutex
  union anonymous_3 mutex;
  // consumerIsWaiting
  volatile signed int consumerIsWaiting;
  // cond
  union anonymous_6 cond;
  // name
  const char *name;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct stats
{
  // fd
  signed int fd;
  // lastPrinted
  struct timeval lastPrinted;
  // statPeriod
  signed long int statPeriod;
  // printUncompressedPos
  signed int printUncompressedPos;
  // noProgress
  signed int noProgress;
};

struct receiver_stats
{
  // tv_start
  struct timeval tv_start;
  // bytesOrig
  signed int bytesOrig;
  // totalBytes
  signed long long int totalBytes;
  // timerStarted
  signed int timerStarted;
  // s
  struct stats s;
};

struct sender_stats
{
  // log
  struct _IO_FILE *log;
  // totalBytes
  unsigned long long int totalBytes;
  // retransmissions
  unsigned long long int retransmissions;
  // clNo
  signed int clNo;
  // periodBytes
  unsigned long int periodBytes;
  // periodStart
  struct timeval periodStart;
  // bwPeriod
  signed long int bwPeriod;
  // s
  struct stats s;
};

union serverControlMsg
{
  // opCode
  unsigned short int opCode;
  // reserved
  signed short int reserved;
  // hello
  struct hello hello;
  // connectReply
  struct connectReply connectReply;
};

struct stat_config
{
  // log
  struct _IO_FILE *log;
  // bwPeriod
  signed long int bwPeriod;
  // statPeriod
  signed int statPeriod;
  // printUncompressedPos
  signed int printUncompressedPos;
  // noProgress
  signed int noProgress;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// allPp
// file fec.c line 112
static char *allPp[17l] = { (char *)(void *)0, (char *)(void *)0, "111", "1101", "11001", "101001", "1100001", "10010001", "101110001", "1000100001", "10010000001", "101000000001", "1100101000001", "11011000000001", "110000100010001", "1100000000000001", "11010000000010001" };
// fec_initialized
// file fec.c line 665
static signed int fec_initialized = 0;
// gf_exp
// file fec.c line 142
static unsigned char gf_exp[510l];
// gf_log
// file fec.c line 143
static signed int gf_log[256l];
// gf_mul_table
// file fec.c line 173
static unsigned char gf_mul_table[65536l];
// global_client_config
// file udpr-negotiate.c line 53
struct client_config *global_client_config = (struct client_config *)(void *)0;
// inverse
// file fec.c line 144
static unsigned char inverse[256l];
// needNewline
// file log.c line 11
static signed int needNewline = 0;
// newlineSeen
// file log.c line 32
static signed int newlineSeen = 1;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// options
// file udp-receiver.c line 27
static struct option options[27l] = { { .name="file", .has_arg=1, .flag=(signed int *)(void *)0, .val=102 },
    { .name="pipe", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="portbase", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 },
    { .name="interface", .has_arg=1, .flag=(signed int *)(void *)0, .val=105 },
    { .name="ttl", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="mcast_all_address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="mcast-all-address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="mcast_rdv_address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="mcast-rdv-address", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=77 },
    { .name="passive", .has_arg=0, .flag=(signed int *)(void *)0, .val=100 },
    { .name="nosync", .has_arg=0, .flag=(signed int *)(void *)0, .val=110 },
    { .name="sync", .has_arg=0, .flag=(signed int *)(void *)0, .val=121 },
    { .name="rcvbuf", .has_arg=1, .flag=(signed int *)(void *)0, .val=98 },
    { .name="nokbd", .has_arg=0, .flag=(signed int *)(void *)0, .val=107 },
    { .name="exitWait", .has_arg=1, .flag=(signed int *)(void *)0, .val=119 },
    { .name="exit-wait", .has_arg=1, .flag=(signed int *)(void *)0, .val=119 },
    { .name="start-timeout", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="receive-timeout", .has_arg=1, .flag=(signed int *)(void *)0, .val=0x801 },
    { .name="license", .has_arg=0, .flag=(signed int *)(void *)0, .val=76 },
    { .name="log", .has_arg=1, .flag=(signed int *)(void *)0, .val=108 },
    { .name="no-progress", .has_arg=0, .flag=(signed int *)(void *)0, .val=0x701 },
    { .name="print-uncompressed-position", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=120 },
    { .name="statistics-period", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=122 },
    { .name="stat-period", .has_arg=1, .flag=(signed int *)(void *)0, .val=122 },
    { .name="ignore-lost-data", .has_arg=0, .flag=(signed int *)(void *)0, .val=90 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// quitting
// file log.c line 71
volatile signed int quitting = 0;
// signalNumber
// file udp-receiver.c line 86
static signed int signalNumber = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// udpc_log
// file udpcast.c line 5
struct _IO_FILE *udpc_log;
// version
// file udpc_version.c line 3
const char *version = "20120424";

// INET_ATON
// file socklib.c line 209
static inline signed int INET_ATON(const char *a, struct in_addr *i)
{
  i->s_addr=inet_addr(a);
  signed int tmp_statement_expression_1;
  if(i->s_addr == 0xffffffff)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(a, "255.255.255.255");
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// __bswap_32_link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link1(unsigned int __bsx_link1)
{
  signed long int return_value___builtin_bswap32_1_link1;
  return_value___builtin_bswap32_1_link1=__builtin_bswap32((signed long int)__bsx_link1);
  return (unsigned int)return_value___builtin_bswap32_1_link1;
}

// __bswap_32_link2
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32_link2(unsigned int __bsx_link2)
{
  signed long int return_value___builtin_bswap32_1_link2;
  return_value___builtin_bswap32_1_link2=__builtin_bswap32((signed long int)__bsx_link2);
  return (unsigned int)return_value___builtin_bswap32_1_link2;
}

// __strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1100
static inline char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// __strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1111
static inline char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  for( ; !((signed int)*__s == 0); __s = __s + 1l)
  {
    if((signed int)*__s == __accept1)
      break;

    if((signed int)*__s == __accept2)
      break;

    if((signed int)*__s == __accept3)
      break;

  }
  return (signed int)*__s == 0 ? (char *)(void *)0 : (char *)(unsigned long int)__s;
}

// _consumeAny
// file produconsum.c line 104
static signed int _consumeAny(struct produconsum *pc, unsigned int minAmount, struct timespec *ts)
{
  unsigned int amount;
  pc->consumerIsWaiting = 1;
  signed int return_value_getProducedAmount_1;
  return_value_getProducedAmount_1=getProducedAmount(pc);
  amount = (unsigned int)return_value_getProducedAmount_1;
  _Bool tmp_if_expr_2;
  if(amount >= minAmount)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = pc->atEnd != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_getProducedAmount_3;
  if(tmp_if_expr_2)
  {
    pc->consumerIsWaiting = 0;
    return (signed int)amount;
  }

  else
  {
    pthread_mutex_lock(&pc->mutex);
    do
    {
      return_value_getProducedAmount_3=getProducedAmount(pc);
      amount = (unsigned int)return_value_getProducedAmount_3;
      if(amount >= minAmount)
        break;

      if(!(pc->atEnd == 0))
        break;

      if(ts == ((struct timespec *)NULL))
        pthread_cond_wait(&pc->cond, &pc->mutex);

      else
      {
        signed int r;
        r=pthread_cond_timedwait(&pc->cond, &pc->mutex, ts);
        if(r == 110)
        {
          signed int return_value_getProducedAmount_4;
          return_value_getProducedAmount_4=getProducedAmount(pc);
          amount = (unsigned int)return_value_getProducedAmount_4;
          break;
        }

      }
    }
    while((_Bool)1);
    pthread_mutex_unlock(&pc->mutex);
    pc->consumerIsWaiting = 0;
    return (signed int)amount;
  }
}

// addmul
// file fec.c line 406
static void addmul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz)
{
  if(!((signed int)c == 0))
    slow_addmul1(dst, src, c, sz);

}

// advanceReceivedPointer
// file receivedata.c line 409
static void advanceReceivedPointer(struct clientState *clst)
{
  signed int pos = clst->receivedPtr;
  while((_Bool)1)
  {
    struct slice *slice = &clst->slices[(signed long int)pos];
    if(!((signed int)slice->state == SLICE_FEC))
    {
      if(!((signed int)slice->state == SLICE_FEC_DONE))
      {
        if(!((signed int)slice->state == SLICE_DONE))
          break;

      }

    }

    pos = pos + 1;
    clst->receivedSliceNo = slice->sliceNo;
    if(pos >= 4)
      pos = pos - 4;

  }
  clst->receivedPtr = pos;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// checkSliceComplete
// file receivedata.c line 474
static void checkSliceComplete(struct clientState *clst, struct slice *slice)
{
  signed int blocksInSlice;
  /* assertion slice->magic == 0x41424344 */
  assert(slice->magic == 0x41424344);
  _Bool tmp_if_expr_2;
  if((signed int)slice->state == SLICE_RECEIVING)
  {
    /* assertion clst->net_config->blockSize != 0 */
    assert(clst->net_config->blockSize != 0);
    blocksInSlice = ((slice->bytes + clst->net_config->blockSize) - 1) / clst->net_config->blockSize;
    if(blocksInSlice == slice->blocksTransferred)
    {
      if(!((0x200 & clst->net_config->flags) == 0))
      {
        pc_consumed(clst->fifo->freeMemQueue, slice->bytes);
        clst->net_config->flags = clst->net_config->flags & ~0x200;
      }

      if(blocksInSlice == slice->dataBlocksTransferred)
        slice->state = (volatile enum slice_state)SLICE_DONE;

      else
      {
        /* assertion clst->use_fec == 1 */
        assert(clst->use_fec == 1);
        slice->state = (volatile enum slice_state)SLICE_FEC;
      }
      advanceReceivedPointer(clst);
      if(!(clst->use_fec == 0))
      {
        signed int n;
        unsigned int return_value_pc_getProducerPosition_1;
        return_value_pc_getProducerPosition_1=pc_getProducerPosition(clst->fec_data_pc);
        n = (signed int)return_value_pc_getProducerPosition_1;
        if((signed int)slice->state == SLICE_DONE)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)slice->state == SLICE_FEC ? (_Bool)1 : (_Bool)0;
        /* assertion slice->state == SLICE_DONE || slice->state == SLICE_FEC */
        assert(tmp_if_expr_2);
        clst->fec_slices[(signed long int)n] = slice;
        pc_produce(clst->fec_data_pc, (unsigned int)1);
      }

      else
        cleanupSlices(clst, (unsigned int)SLICE_DONE);
    }

  }

}

// cleanupSlices
// file receivedata.c line 433
static void cleanupSlices(struct clientState *clst, unsigned int doneState)
{
  while((_Bool)1)
  {
    signed int pos;
    unsigned int return_value_pc_getProducerPosition_1;
    return_value_pc_getProducerPosition_1=pc_getProducerPosition(clst->free_slices_pc);
    pos = (signed int)return_value_pc_getProducerPosition_1;
    signed int bytes;
    struct slice *slice = &clst->slices[(signed long int)pos];
    if(!((unsigned int)slice->state == doneState))
      break;

    udpc_receiverStatsAddBytes(clst->stats, (signed long int)slice->bytes);
    udpc_displayReceiverStats(clst->stats, 0);
    bytes = slice->bytes;
    if(bytes == 0)
      pc_produceEnd(clst->fifo->data);

    else
      pc_produce(clst->fifo->data, (unsigned int)slice->bytes);
    clst->slices[(signed long int)pos].state = (volatile enum slice_state)SLICE_FREE;
    pc_produce(clst->free_slices_pc, (unsigned int)1);
    if(bytes == 0)
      clst->endReached = 2;

  }
}

// closeAllExcept
// file receivedata.c line 922
static void closeAllExcept(struct clientState *clst, signed int fd)
{
  signed int i;
  signed int *socks = clst->client_config->socks;
  if(!(clst->selectedFd >= 0))
  {
    udpc_restoreConsole(&clst->client_config->console, 0);
    clst->selectedFd = fd;
    i = 1;
    for( ; !(i >= 4); i = i + 1)
      if(!(socks[(signed long int)i] == -1))
      {
        if(!(socks[(signed long int)i] == fd))
          udpc_closeSock(socks, 4, i);

      }

  }

}

// dispatchMessage
// file receivedata.c line 939
static signed int dispatchMessage(struct clientState *clst)
{
  signed int ret;
  struct sockaddr_in lserver;
  struct fifo *fifo = clst->fifo;
  signed int fd = -1;
  struct client_config *client_config = clst->client_config;
  _Bool tmp_if_expr_2;
  if(!(clst->currentSlice == ((struct slice *)NULL)))
    tmp_if_expr_2 = clst->currentSlice->freePos < 1024 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_1;
  if(tmp_if_expr_2)
  {
    struct slice *slice = clst->currentSlice;
    if(slice == ((struct slice *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = slice->magic == 0x41424344 ? (_Bool)1 : (_Bool)0;
    /* assertion slice == ((void *)0) || slice->magic == 0x41424344 */
    assert(tmp_if_expr_1);
    clst->data_iov[(signed long int)1].iov_base = (void *)(fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + slice->freePos * clst->net_config->blockSize) % fifo->dataBufSize));
  }

  else
    clst->data_iov[(signed long int)1].iov_base = (void *)clst->nextBlock;
  clst->data_iov[(signed long int)1].iov_len = (unsigned long int)clst->net_config->blockSize;
  clst->data_hdr.msg_iovlen = (unsigned long int)2;
  clst->data_hdr.msg_name = (void *)&lserver;
  clst->data_hdr.msg_namelen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  while((_Bool)1)
  {
    if(clst->endReached == 0)
    {
      if(clst->netEndReached == 0)
        goto __CPROVER_DUMP_L12;

    }

    signed int oldEndReached = clst->endReached;
    signed int nr_desc;
    struct timeval tv;
    struct anonymous_1 read_set;
    signed int maxFd;
    maxFd=udpc_prepareForSelect(client_config->socks, 4, &read_set);
    tv.tv_sec = (signed long int)(clst->net_config->exitWait / 1000);
    tv.tv_usec = (signed long int)((clst->net_config->exitWait % 1000) * 1000);
    nr_desc=select(maxFd, &read_set, ((struct anonymous_1 *)NULL), ((struct anonymous_1 *)NULL), &tv);
    if(!(nr_desc >= 0))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      udpc_flprintf("Select error: %s\n", return_value_strerror_4);
      break;
    }

    fd=udpc_getSelectedSock(client_config->socks, 4, &read_set);
    if(fd >= 0)
      break;

    if(oldEndReached >= 2)
    {
      clst->endReached = 3;
      return 0;
    }

  }

__CPROVER_DUMP_L12:
  ;
  if(!(fd >= 0))
    fd = clst->selectedFd;

  if(!(fd >= 0))
  {
    struct timeval dispatchMessage__1__4__tv;
    struct timeval *tvp;
    struct anonymous_1 dispatchMessage__1__4__read_set;
    signed int keyPressed = 0;
    signed int dispatchMessage__1__4__maxFd;
    dispatchMessage__1__4__maxFd=udpc_prepareForSelect(client_config->socks, 4, &dispatchMessage__1__4__read_set);
    if(!(client_config->console == ((struct console_t *)NULL)))
    {
      if(clst->promptPrinted == 0)
        fprintf(stderr, "Press any key to start receiving data!\n");

    }

    clst->promptPrinted = 1;
    if(clst->net_config->startTimeout == 0)
      tvp = (struct timeval *)(void *)0;

    else
    {
      dispatchMessage__1__4__tv.tv_sec = (signed long int)clst->net_config->startTimeout;
      dispatchMessage__1__4__tv.tv_usec = (signed long int)0;
      tvp = &dispatchMessage__1__4__tv;
    }
    ret=selectWithConsole(client_config->console, dispatchMessage__1__4__maxFd + 1, &dispatchMessage__1__4__read_set, tvp, &keyPressed);
    if(!(ret >= 0))
    {
      perror("Select");
      return 0;
    }

    if(ret == 0)
    {
      clst->endReached = 3;
      clst->netEndReached = 3;
      pc_produceEnd(clst->fifo->data);
      return 1;
    }

    if(!(keyPressed == 0))
    {
      udpc_restoreConsole(&client_config->console, 1);
      udpc_flprintf("Sending go signal\n");
      signed int return_value_udpc_sendGo_5;
      return_value_udpc_sendGo_5=udpc_sendGo(client_config);
      if(!(return_value_udpc_sendGo_5 >= 0))
        perror("Send go");

      return 0;
    }

    fd=udpc_getSelectedSock(clst->client_config->socks, 4, &dispatchMessage__1__4__read_set);
  }

  signed long int return_value_recvmsg_6;
  return_value_recvmsg_6=recvmsg(fd, &clst->data_hdr, clst->net_config->receiveTimeout != 0 ? 64 : 0);
  ret = (signed int)return_value_recvmsg_6;
  signed int *return_value___errno_location_8;
  _Bool tmp_if_expr_10;
  signed int *return_value___errno_location_9;
  if(!(ret >= 0))
  {
    return_value___errno_location_8=__errno_location();
    if(*return_value___errno_location_8 == 11)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value___errno_location_9=__errno_location();
      tmp_if_expr_10 = *return_value___errno_location_9 == 11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
    {
      struct timeval dispatchMessage__1__5__tv;
      struct anonymous_1 dispatchMessage__1__5__read_set;
      signed int dispatchMessage__1__5__nr_desc;
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&dispatchMessage__1__5__read_set)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&dispatchMessage__1__5__read_set)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&dispatchMessage__1__5__read_set)->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      dispatchMessage__1__5__tv.tv_sec = (signed long int)clst->net_config->receiveTimeout;
      dispatchMessage__1__5__tv.tv_usec = (signed long int)0;
      dispatchMessage__1__5__nr_desc=select(fd + 1, &dispatchMessage__1__5__read_set, ((struct anonymous_1 *)NULL), ((struct anonymous_1 *)NULL), &dispatchMessage__1__5__tv);
      if(dispatchMessage__1__5__nr_desc == 0)
      {
        udpc_flprintf("Receiver timeout\n");
        exit(1);
      }

      signed long int return_value_recvmsg_7;
      return_value_recvmsg_7=recvmsg(fd, &clst->data_hdr, 64);
      ret = (signed int)return_value_recvmsg_7;
    }

  }

  unsigned short int tmp_statement_expression_16;
  unsigned int return_value___bswap_32_17;
  unsigned short int tmp_statement_expression_18;
  unsigned int return_value___bswap_32_19;
  signed int return_value_processDataBlock_20;
  unsigned short int tmp_statement_expression_21;
  unsigned int return_value___bswap_32_22;
  unsigned short int tmp_statement_expression_23;
  unsigned int return_value___bswap_32_24;
  signed int return_value_processFecBlock_25;
  unsigned int return_value___bswap_32_26;
  unsigned int return_value___bswap_32_27;
  unsigned int return_value___bswap_32_28;
  signed int return_value_processReqAck_29;
  if(!(ret >= 0))
    return -1;

  else
  {
    signed int return_value_udpc_isAddressEqual_15;
    return_value_udpc_isAddressEqual_15=udpc_isAddressEqual(&lserver, &clst->client_config->serverAddr);
    if(return_value_udpc_isAddressEqual_15 == 0)
    {
      char buffer1[16l];
      char buffer2[16l];
      char *return_value_udpc_getIpString_11;
      return_value_udpc_getIpString_11=udpc_getIpString(&lserver, buffer1);
      unsigned short int return_value_udpc_getPort_12;
      return_value_udpc_getPort_12=udpc_getPort(&lserver);
      char *return_value_udpc_getIpString_13;
      return_value_udpc_getIpString_13=udpc_getIpString(&clst->client_config->serverAddr, buffer2);
      unsigned short int return_value_udpc_getPort_14;
      return_value_udpc_getPort_14=udpc_getPort(&clst->client_config->serverAddr);
      udpc_flprintf("Rogue packet received %s:%d, expecting %s:%d\n", return_value_udpc_getIpString_11, return_value_udpc_getPort_12, return_value_udpc_getIpString_13, return_value_udpc_getPort_14);
      return -1;
    }

    unsigned short int __v;
    unsigned short int __x = (unsigned short int)clst->Msg.opCode;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_16 = __v;
    switch((signed int)tmp_statement_expression_16)
    {
      case 8:
      {
        closeAllExcept(clst, fd);
        udpc_receiverStatsStartTimer(clst->stats);
        clst->client_config->isStarted = 1;
        return_value___bswap_32_17=__bswap_32_link1((unsigned int)clst->Msg.dataBlock.sliceNo);
        unsigned short int dispatchMessage__1__9__1____v;
        unsigned short int dispatchMessage__1__9__1____x = (unsigned short int)clst->Msg.dataBlock.blockNo;
        asm("rorw _8, %w0" : "=r"(dispatchMessage__1__9__1____v) : "0"(dispatchMessage__1__9__1____x) : "cc");
        tmp_statement_expression_18 = dispatchMessage__1__9__1____v;
        return_value___bswap_32_19=__bswap_32_link1((unsigned int)clst->Msg.dataBlock.bytes);
        return_value_processDataBlock_20=processDataBlock(clst, (signed int)return_value___bswap_32_17, (signed int)tmp_statement_expression_18, (signed int)return_value___bswap_32_19);
        return return_value_processDataBlock_20;
      }
      case 9:
      {
        closeAllExcept(clst, fd);
        udpc_receiverStatsStartTimer(clst->stats);
        clst->client_config->isStarted = 1;
        unsigned short int dispatchMessage__1__9__2____v;
        unsigned short int dispatchMessage__1__9__2____x = (unsigned short int)clst->Msg.fecBlock.stripes;
        asm("rorw _8, %w0" : "=r"(dispatchMessage__1__9__2____v) : "0"(dispatchMessage__1__9__2____x) : "cc");
        tmp_statement_expression_21 = dispatchMessage__1__9__2____v;
        return_value___bswap_32_22=__bswap_32_link1((unsigned int)clst->Msg.fecBlock.sliceNo);
        unsigned short int dispatchMessage__1__9__3____v;
        unsigned short int dispatchMessage__1__9__3____x = (unsigned short int)clst->Msg.fecBlock.blockNo;
        asm("rorw _8, %w0" : "=r"(dispatchMessage__1__9__3____v) : "0"(dispatchMessage__1__9__3____x) : "cc");
        tmp_statement_expression_23 = dispatchMessage__1__9__3____v;
        return_value___bswap_32_24=__bswap_32_link1((unsigned int)clst->Msg.fecBlock.bytes);
        return_value_processFecBlock_25=processFecBlock(clst, (signed int)tmp_statement_expression_21, (signed int)return_value___bswap_32_22, (signed int)tmp_statement_expression_23, (signed int)return_value___bswap_32_24);
        return return_value_processFecBlock_25;
      }
      case 6:
      {
        closeAllExcept(clst, fd);
        udpc_receiverStatsStartTimer(clst->stats);
        clst->client_config->isStarted = 1;
        return_value___bswap_32_26=__bswap_32_link1((unsigned int)clst->Msg.reqack.sliceNo);
        return_value___bswap_32_27=__bswap_32_link1((unsigned int)clst->Msg.reqack.bytes);
        return_value___bswap_32_28=__bswap_32_link1((unsigned int)clst->Msg.reqack.rxmit);
        return_value_processReqAck_29=processReqAck(clst, (signed int)return_value___bswap_32_26, (signed int)return_value___bswap_32_27, (signed int)return_value___bswap_32_28);
        return return_value_processReqAck_29;
      }
      case 11:

      case 10:

      case 0x0500:
        return 0;
      default:
      {
        udpc_flprintf("Unexpected opcode %04x\n", (unsigned short int)clst->Msg.opCode);
        return -1;
      }
    }
  }
}

// dupFd
// file process.c line 10
static void dupFd(signed int src, signed int target)
{
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(src == target))
  {
    close(target);
    signed int return_value_dup2_3;
    return_value_dup2_3=dup2(src, target);
    if(!(return_value_dup2_3 >= 0))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      udpc_fatal(1, "dup2 %d->%d: %s\n", src, target, return_value_strerror_2);
    }

    close(src);
  }

}

// fakeSliceComplete
// file receivedata.c line 323
static void fakeSliceComplete(struct clientState *clst)
{
  struct slice *slice = (struct slice *)(void *)0;
  slice=findSlice(clst, clst->receivedSliceNo + 1);
  /* assertion slice != ((void *)0) */
  assert(slice != (struct slice *)(void *)0);
  /* assertion slice->state != SLICE_DONE */
  assert((signed int)slice->state != SLICE_DONE);
  if(slice->bytesKnown == 0)
    setSliceBytes(slice, clst, slice->bytes);

  slice->dataBlocksTransferred = ((slice->bytes + clst->net_config->blockSize) - 1) / clst->net_config->blockSize;
  slice->blocksTransferred = slice->dataBlocksTransferred;
  checkSliceComplete(clst, slice);
}

// fecMain
// file receivedata.c line 589
static void * fecMain(void *args0)
{
  struct clientState *clst = (struct clientState *)args0;
  signed int pos;
  struct fifo *fifo = clst->fifo;
  struct net_config *config = clst->net_config;
  /* assertion fifo->dataBufSize % config->blockSize == 0 */
  assert(fifo->dataBufSize % (unsigned int)config->blockSize == (unsigned int)0);
  /* assertion config->blockSize != 0 */
  assert(config->blockSize != 0);
  while(!(clst->endReached >= 2))
  {
    struct slice *slice;
    pc_consume(clst->fec_data_pc, 1);
    unsigned int return_value_pc_getConsumerPosition_1;
    return_value_pc_getConsumerPosition_1=pc_getConsumerPosition(clst->fec_data_pc);
    pos = (signed int)return_value_pc_getConsumerPosition_1;
    slice = clst->fec_slices[(signed long int)pos];
    pc_consumed(clst->fec_data_pc, 1);
    if(!((signed int)slice->state == SLICE_FEC))
    {
      if((signed int)slice->state == SLICE_DONE)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if((signed int)slice->state == SLICE_FEC)
      {
        signed int stripes = slice->fec_stripes;
        struct fec_desc *fec_descs = slice->fec_descs;
        signed int stripe = 0;
        for( ; !(stripe >= stripes); stripe = stripe + 1)
        {
          /* assertion config->blockSize != 0 */
          assert(config->blockSize != 0);
          fec_decode_one_stripe(clst, slice, stripe, slice->bytes, slice->fec_stripes, slice->fec_blocks[(signed long int)stripe], fec_descs);
        }
        slice->state = (volatile enum slice_state)SLICE_FEC_DONE;
        stripe = 0;
        for( ; !(stripe >= stripes); stripe = stripe + 1)
        {
          signed int i;
          /* assertion slice->missing_data_blocks[stripe] >= slice->fec_blocks[stripe] */
          assert((signed int)slice->missing_data_blocks[(signed long int)stripe] >= (signed int)slice->fec_blocks[(signed long int)stripe]);
          i = 0;
          for( ; !(i >= (signed int)slice->fec_blocks[(signed long int)stripe]); i = i + 1)
          {
            freeBlockSpace(clst, (fec_descs + (signed long int)(stripe + i * stripes))->adr);
            (fec_descs + (signed long int)(stripe + i * stripes))->adr = ((unsigned char *)NULL);
          }
        }
      }

      else
        if((signed int)slice->state == SLICE_DONE)
          slice->state = (volatile enum slice_state)SLICE_FEC_DONE;

      /* assertion slice->state == SLICE_FEC_DONE */
      assert((signed int)slice->state == SLICE_FEC_DONE);
      cleanupSlices(clst, (unsigned int)SLICE_FEC_DONE);
    }
  }
  return NULL;
}

// fec_decode
// file fec.h line 25
void fec_decode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks)
{
  reduce(blockSize, data_blocks, nr_data_blocks, fec_blocks, fec_block_nos, erased_blocks, nr_fec_blocks);
  resolve((signed int)blockSize, data_blocks, fec_blocks, fec_block_nos, erased_blocks, (signed short int)nr_fec_blocks);
}

// fec_decode_one_stripe
// file receivedata.c line 534
static void fec_decode_one_stripe(struct clientState *clst, struct slice *slice, signed int stripe, signed int bytes, signed int stripes, signed short int nr_fec_blocks, struct fec_desc *fec_descs)
{
  struct fifo *fifo = clst->fifo;
  struct net_config *config = clst->net_config;
  unsigned char *map = slice->retransmit.map;
  signed int nrBlocks;
  nrBlocks=getSliceBlocks(slice, config);
  signed int leftOver = bytes % config->blockSize;
  signed int j;
  const signed long int j_array_size0 = (signed long int)nr_fec_blocks;
  unsigned char *fec_blocks[j_array_size0];
  const signed long int fec_blocks_array_size0 = (signed long int)nr_fec_blocks;
  unsigned int fec_block_nos[fec_blocks_array_size0];
  const signed long int fec_block_nos_array_size0 = (signed long int)nr_fec_blocks;
  unsigned int erased_blocks[fec_block_nos_array_size0];
  unsigned char *data_blocks[128l];
  signed int erasedIdx = stripe;
  signed int i = stripe;
  j = 0;
  signed int tmp_post_1;
  for( ; !(i >= nrBlocks); i = i + stripes)
    if((1 << (unsigned long int)i % sizeof(unsigned char) * 8 /*8ul*/  & (signed int)map[(signed long int)((unsigned long int)i / sizeof(unsigned char) * 8 /*8ul*/ )]) == 0)
    {
      (fec_descs + (signed long int)erasedIdx)->erasedBlockNo = i;
      tmp_post_1 = j;
      j = j + 1;
      erased_blocks[(signed long int)tmp_post_1] = (unsigned int)(i / stripes);
      erasedIdx = erasedIdx + stripes;
    }

  /* assertion erasedIdx == stripe+nr_fec_blocks*stripes */
  assert(erasedIdx == stripe + (signed int)nr_fec_blocks * stripes);
  i = stripe;
  j = 0;
  for( ; !(j >= (signed int)nr_fec_blocks); j = j + 1)
  {
    fec_block_nos[(signed long int)j] = (unsigned int)((fec_descs + (signed long int)i)->fecBlockNo / stripes);
    fec_blocks[(signed long int)j] = (fec_descs + (signed long int)i)->adr;
    i = i + stripes;
  }
  if(!(leftOver == 0))
  {
    unsigned char *lastBlock = fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + (nrBlocks - 1) * config->blockSize) % fifo->dataBufSize);
    memset((void *)(lastBlock + (signed long int)leftOver), 0, (unsigned long int)(config->blockSize - leftOver));
  }

  i = stripe;
  j = 0;
  for( ; !(i >= nrBlocks); j = j + 1)
  {
    data_blocks[(signed long int)j] = fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + i * config->blockSize) % fifo->dataBufSize);
    i = i + stripes;
  }
  fec_decode((unsigned int)config->blockSize, data_blocks, (unsigned int)j, fec_blocks, fec_block_nos, erased_blocks, (unsigned short int)nr_fec_blocks);
}

// fec_encode
// file fec.c line 776
void fec_encode(unsigned int blockSize, unsigned char **data_blocks, unsigned int nrDataBlocks, unsigned char **fec_blocks, unsigned int nrFecBlocks)
{
  unsigned int blockNo;
  unsigned int row;
  unsigned int col;
  /* assertion fec_initialized */
  assert(fec_initialized != 0);
  /* assertion nrDataBlocks <= 128 */
  assert(nrDataBlocks <= (unsigned int)128);
  /* assertion nrFecBlocks <= 128 */
  assert(nrFecBlocks <= (unsigned int)128);
  if(!(nrDataBlocks == 0u))
  {
    row = (unsigned int)0;
    for( ; !(row >= nrFecBlocks); row = row + 1u)
      mul(fec_blocks[(signed long int)row], data_blocks[(signed long int)0], inverse[(signed long int)((unsigned int)128 ^ row)], (signed int)blockSize);
    col = (unsigned int)129;
    blockNo = (unsigned int)1;
    for( ; !(blockNo >= nrDataBlocks); blockNo = blockNo + 1u)
    {
      row = (unsigned int)0;
      for( ; !(row >= nrFecBlocks); row = row + 1u)
        addmul(fec_blocks[(signed long int)row], data_blocks[(signed long int)blockNo], inverse[(signed long int)(row ^ col)], (signed int)blockSize);
      col = col + 1u;
    }
  }

}

// fec_init
// file fec.h line 17
void fec_init(void)
{
  generate_gf();
  init_mul_table();
  fec_initialized = 1;
}

// fec_license
// file fec.h line 35
void fec_license(void)
{
  fprintf(stderr, "   udpcast and its FEC code are free software\n\n   you can redistribute udpcast core functionality and/or\n   it them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Alain Knaff\n   <alain@knaff.lu>\n   http://udpcast.linux.lu/\n\nthe FEC code is covered by the following license:\nfec.c -- forward error correction based on Vandermonde matrices\n980624\n(C) 1997-98 Luigi Rizzo (luigi@iet.unipi.it)\n(C) 2001 Alain Knaff (alain@knaff.lu)\n\nPortions derived from code by Phil Karn (karn@ka9q.ampr.org),\nRobert Morelos-Zaragoza (robert@spectra.eng.hawaii.edu) and Hari\nThirumoorthy (harit@spectra.eng.hawaii.edu), Aug 1995\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above\n   copyright notice, this list of conditions and the following\n   disclaimer in the documentation and/or other materials\n   provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\nOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\nOR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\nTORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\nOF SUCH DAMAGE.\n");
  exit(0);
}

// fillMreq
// file socklib.c line 371
static signed int fillMreq(struct net_if *net_if, struct in_addr addr, struct ip_mreqn *mreq)
{
  mreq->imr_ifindex = net_if->index;
  mreq->imr_address.s_addr = (unsigned int)0;
  mreq->imr_multiaddr = addr;
  return 0;
}

// findSlice
// file receivedata.c line 337
static struct slice * findSlice(struct clientState *clst, signed int sliceNo)
{
  if(clst->currentSlice == ((struct slice *)NULL))
  {
    clst->currentSliceNo = sliceNo - 1;
    struct slice *return_value_newSlice_1;
    return_value_newSlice_1=newSlice(clst, sliceNo);
    return return_value_newSlice_1;
  }

  _Bool tmp_if_expr_2;
  if(clst->currentSliceNo >= sliceNo)
  {
    struct slice *findSlice__1__2__slice = clst->currentSlice;
    signed int pos = (signed int)(findSlice__1__2__slice - clst->slices);
    if(findSlice__1__2__slice == ((struct slice *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = findSlice__1__2__slice->magic == 0x41424344 ? (_Bool)1 : (_Bool)0;
    /* assertion slice == ((void *)0) || slice->magic == 0x41424344 */
    assert(tmp_if_expr_2);
    for( ; !(findSlice__1__2__slice->sliceNo == sliceNo); findSlice__1__2__slice = &clst->slices[(signed long int)pos])
    {
      if((signed int)findSlice__1__2__slice->state == SLICE_FREE)
        return (struct slice *)(void *)0;

      /* assertion slice->magic == 0x41424344 */
      assert(findSlice__1__2__slice->magic == 0x41424344);
      pos = pos - 1;
      if(!(pos >= 0))
        pos = pos + 4;

    }
    return findSlice__1__2__slice;
  }

  if(!((0x200 & clst->net_config->flags) == 0))
  {
    if(!(sliceNo == clst->currentSliceNo))
    {
      clst->currentSlice = &clst->slices[(signed long int)0];
      /* assertion clst->currentSlice = &clst->slices[0] */
      assert(clst->currentSlice != ((struct slice *)NULL));
      struct slice *return_value_initSlice_3;
      return_value_initSlice_3=initSlice(clst, clst->currentSlice, sliceNo);
      return return_value_initSlice_3;
    }

  }

  while((_Bool)1)
  {
    if(2 + clst->receivedSliceNo >= sliceNo)
    {
      if(sliceNo == 1 + clst->currentSliceNo)
        goto __CPROVER_DUMP_L14;

    }

    struct slice *slice;
    slice=findSlice(clst, clst->receivedSliceNo + 1);
    if(!((0x400 & clst->net_config->flags) == 0))
      fakeSliceComplete(clst);

    else
    {
      udpc_flprintf("Dropped by server now=%d last=%d\n", sliceNo, clst->receivedSliceNo);
      if(!(slice == ((struct slice *)NULL)))
        printMissedBlockMap(clst, slice);

      exit(1);
    }
  }

__CPROVER_DUMP_L14:
  ;
  struct slice *return_value_newSlice_4;
  return_value_newSlice_4=newSlice(clst, sliceNo);
  return return_value_newSlice_4;
}

// fixConsole
// file udpr-negotiate.c line 55
static void fixConsole(void)
{
  if(!(global_client_config == ((struct client_config *)NULL)))
    udpc_restoreConsole(&global_client_config->console, 0);

}

// freeBlockSpace
// file receivedata.c line 227
static void freeBlockSpace(struct clientState *clst, unsigned char *block)
{
  signed int pos;
  unsigned int return_value_pc_getProducerPosition_1;
  return_value_pc_getProducerPosition_1=pc_getProducerPosition(clst->freeBlocks_pc);
  pos = (signed int)return_value_pc_getProducerPosition_1;
  /* assertion block != 0 */
  assert(block != ((unsigned char *)NULL));
  clst->blockAddresses[(signed long int)pos] = block;
  pc_produce(clst->freeBlocks_pc, (unsigned int)1);
}

// generate_gf
// file fec.c line 217
static void generate_gf(void)
{
  signed int i;
  unsigned char mask;
  char *Pp = allPp[(signed long int)8];
  mask = (unsigned char)1;
  gf_exp[(signed long int)8] = (unsigned char)0;
  i = 0;
  for( ; !(i >= 8); mask = mask << 1)
  {
    gf_exp[(signed long int)i] = mask;
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
    if((signed int)Pp[(signed long int)i] == 49)
      gf_exp[(signed long int)8] = gf_exp[(signed long int)8] ^ mask;

    i = i + 1;
  }
  gf_log[(signed long int)gf_exp[(signed long int)8]] = 8;
  mask = (unsigned char)(1 << 8 - 1);
  i = 8 + 1;
  for( ; !(i >= 255); i = i + 1)
  {
    if((signed int)gf_exp[(signed long int)(i + -1)] >= (signed int)mask)
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)8] ^ ((signed int)gf_exp[(signed long int)(i - 1)] ^ (signed int)mask) << 1);

    else
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)(i - 1)] << 1);
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
  }
  gf_log[(signed long int)0] = (1 << 8) - 1;
  i = 0;
  for( ; !(i >= 255); i = i + 1)
    gf_exp[(signed long int)(i + ((1 << 8) - 1))] = gf_exp[(signed long int)i];
  inverse[(signed long int)0] = (unsigned char)0;
  inverse[(signed long int)1] = (unsigned char)1;
  i = 2;
  for( ; !(i >= 256); i = i + 1)
    inverse[(signed long int)i] = gf_exp[(signed long int)(((1 << 8) - 1) - gf_log[(signed long int)i])];
}

// getBlockSpace
// file receivedata.c line 211
static unsigned char * getBlockSpace(struct clientState *clst)
{
  signed int pos;
  if(!(clst->localPos == 0))
  {
    clst->localPos = clst->localPos - 1;
    return clst->localBlockAddresses[(signed long int)clst->localPos];
  }

  else
  {
    pc_consume(clst->freeBlocks_pc, 1);
    unsigned int return_value_pc_getConsumerPosition_1;
    return_value_pc_getConsumerPosition_1=pc_getConsumerPosition(clst->freeBlocks_pc);
    pos = (signed int)return_value_pc_getConsumerPosition_1;
    pc_consumed(clst->freeBlocks_pc, 1);
    return clst->blockAddresses[(signed long int)pos];
  }
}

// getProducedAmount
// file produconsum.c line 88
static signed int getProducedAmount(struct produconsum *pc)
{
  unsigned int produced = pc->produced;
  unsigned int consumed = pc->consumed;
  if(!(produced >= consumed))
    return (signed int)((produced + (unsigned int)2 * pc->size) - consumed);

  else
    return (signed int)(produced - consumed);
}

// getSliceBlocks
// file receivedata.c line 528
static signed int getSliceBlocks(struct slice *slice, struct net_config *net_config)
{
  /* assertion net_config->blockSize != 0 */
  assert(net_config->blockSize != 0);
  return ((slice->bytes + net_config->blockSize) - 1) / net_config->blockSize;
}

// hasLink
// file socklib.c line 494
static signed int hasLink(signed int s, const char *ifname)
{
  struct ifreq ifr;
  struct ethtool_value edata;
  edata.cmd = (unsigned int)0x0000000a;
  __builtin_strncpy(ifr.ifr_ifrn.ifrn_name, ifname, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  ifr.ifr_ifru.ifru_data = (char *)&edata;
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(s, (unsigned long int)0x8946, &ifr);
  if(return_value_ioctl_1 == -1)
    return -1;

  else
    return (signed int)edata.data;
}

// initClstForFec
// file receivedata.c line 649
static void initClstForFec(struct clientState *clst)
{
  clst->use_fec = 1;
  pthread_create(&clst->fec_thread, (const union pthread_attr_t *)(void *)0, fecMain, (void *)clst);
}

// initMsgHdr
// file socklib.h line 218
static inline void initMsgHdr(struct msghdr *hdr)
{
  hdr->msg_control = NULL;
  hdr->msg_controllen = (unsigned long int)0;
  hdr->msg_flags = 0;
}

// initSlice
// file receivedata.c line 245
static struct slice * initSlice(struct clientState *clst, struct slice *slice, signed int sliceNo)
{
  _Bool tmp_if_expr_1;
  if((signed int)slice->state == SLICE_FREE)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)slice->state == SLICE_RECEIVING ? (_Bool)1 : (_Bool)0;
  /* assertion slice->state == SLICE_FREE || slice->state == SLICE_RECEIVING */
  assert(tmp_if_expr_1);
  slice->magic = 0x41424344;
  slice->state = (volatile enum slice_state)SLICE_RECEIVING;
  slice->blocksTransferred = 0;
  slice->dataBlocksTransferred = 0;
  memset((void *)&slice->retransmit, 0, sizeof(struct retransmit) /*140ul*/ );
  slice->freePos = 0;
  slice->bytes = 0;
  if(!(clst->currentSlice == ((struct slice *)NULL)))
  {
    if(clst->currentSlice->bytesKnown == 0)
      udpc_fatal(1, "Previous slice size not known\n");

    if(!((0x400 & clst->net_config->flags) == 0))
      slice->bytes = clst->currentSlice->bytes;

  }

  if((0x200 & clst->net_config->flags) == 0)
  {
    if(!(clst->currentSliceNo == sliceNo + -1))
      udpc_fatal(1, "Slice no mismatch %d <-> %d\n", sliceNo, clst->currentSliceNo);

  }

  slice->bytesKnown = 0;
  slice->sliceNo = sliceNo;
  memset((void *)&slice->missing_data_blocks, 0, sizeof(signed short int [256l]) /*512ul*/ );
  memset((void *)&slice->fec_stripes, 0, sizeof(signed int) /*4ul*/ );
  memset((void *)&slice->fec_blocks, 0, sizeof(signed short int [256l]) /*512ul*/ );
  memset((void *)&slice->fec_descs, 0, sizeof(struct fec_desc [1024l]) /*16384ul*/ );
  clst->currentSlice = slice;
  clst->currentSliceNo = sliceNo;
  return slice;
}

// initSliceForFec
// file receivedata.c line 656
static void initSliceForFec(struct clientState *clst, struct slice *slice)
{
  signed int i;
  signed int j;
  signed int blocksInSlice;
  /* assertion slice->magic == 0x41424344 */
  assert(slice->magic == 0x41424344);
  if(clst->use_fec == 0)
    initClstForFec(clst);

  /* assertion clst->net_config->blockSize != 0 */
  assert(clst->net_config->blockSize != 0);
  blocksInSlice = ((slice->bytes + clst->net_config->blockSize) - 1) / clst->net_config->blockSize;
  i = 0;
  for( ; !(i >= slice->fec_stripes); i = i + 1)
  {
    slice->missing_data_blocks[(signed long int)i] = (signed short int)0;
    slice->fec_blocks[(signed long int)i] = (signed short int)0;
  }
  i = 0;
  for( ; !(i >= (7 + blocksInSlice) / 8); i = i + 1)
    if(!((signed int)slice->retransmit.map[(signed long int)i] == 0xff))
    {
      signed int max = i * 8 + 8;
      if(!(blocksInSlice >= max))
        max = blocksInSlice;

      j = i * 8;
      for( ; !(j >= max); j = j + 1)
        if((1 << (unsigned long int)j % sizeof(unsigned char) * 8 /*8ul*/  & (signed int)slice->retransmit.map[(signed long int)((unsigned long int)j / sizeof(unsigned char) * 8 /*8ul*/ )]) == 0)
          slice->missing_data_blocks[(signed long int)(j % slice->fec_stripes)] = slice->missing_data_blocks[(signed long int)(j % slice->fec_stripes)] + 1;

    }

}

// initSockAddress
// file socklib.c line 219
static signed int initSockAddress(enum addr_type_t addr_type, struct net_if *net_if, unsigned int ip, unsigned short int port, struct sockaddr_in *addr)
{
  memset((void *)(char *)addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr->sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  addr->sin_port = tmp_statement_expression_1;
  if(net_if == ((struct net_if *)NULL) && !((signed int)addr_type == ADDR_TYPE_MCAST))
    udpc_fatal(1, "initSockAddr without ifname\n");

  switch((signed int)addr_type)
  {
    case ADDR_TYPE_UCAST:
    {
      addr->sin_addr = net_if->addr;
      break;
    }
    case ADDR_TYPE_BCAST:
    {
      addr->sin_addr = net_if->bcast;
      break;
    }
    case ADDR_TYPE_MCAST:
      addr->sin_addr.s_addr = ip;
  }
  return 0;
}

// initStats
// file statistics.c line 60
static void initStats(struct stats *s, signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress)
{
  struct timeval now;
  gettimeofday(&now, ((struct timezone *)NULL));
  s->fd = fd;
  s->statPeriod = statPeriod;
  s->printUncompressedPos = printUncompressedPos;
  s->lastPrinted = now;
  s->noProgress = noProgress;
}

// init_mul_table
// file fec.c line 189
static void init_mul_table(void)
{
  signed int i;
  signed int j;
  i = 0;
  unsigned char return_value_modnn_1;
  for( ; !(i >= 1); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 1); j = j + 1)
    {
      return_value_modnn_1=modnn(gf_log[(signed long int)i] + gf_log[(signed long int)j]);
      gf_mul_table[(signed long int)((i << 8) + j)] = gf_exp[(signed long int)return_value_modnn_1];
    }
  }
  j = 0;
  for( ; !(j >= 1); j = j + 1)
  {
    gf_mul_table[(signed long int)(j << 8)] = (unsigned char)0;
    gf_mul_table[(signed long int)j] = gf_mul_table[(signed long int)(j << 8)];
  }
}

// intHandler
// file udp-receiver.c line 102
static void intHandler(signed int nr)
{
  signalNumber = nr;
  udpc_fatal(1, "Signal %d: Cancelled by user\n", nr);
}

// invert_mat
// file fec.c line 545
static signed int invert_mat(unsigned char *src, signed int k)
{
  unsigned char c;
  unsigned char *p;
  signed int irow;
  signed int icol;
  signed int row;
  signed int col;
  signed int i;
  signed int ix;
  signed int error = 1;
  const signed long int error_array_size0 = (signed long int)k;
  signed int indxc[error_array_size0];
  const signed long int indxc_array_size0 = (signed long int)k;
  signed int indxr[indxc_array_size0];
  const signed long int indxr_array_size0 = (signed long int)k;
  signed int ipiv[indxr_array_size0];
  const signed long int ipiv_array_size0 = (signed long int)k;
  unsigned char id_row[ipiv_array_size0];
  memset((void *)id_row, 0, (unsigned long int)k * sizeof(unsigned char) /*1ul*/ );
  i = 0;
  for( ; !(i >= k); i = i + 1)
    ipiv[(signed long int)i] = 0;
  col = 0;
  for( ; !(col >= k); col = col + 1)
  {
    unsigned char *pivot_row;
    icol = -1;
    irow = icol;
    if(!(ipiv[(signed long int)col] == 1))
    {
      if((signed int)src[(signed long int)(col * k + col)] == 0)
        goto __CPROVER_DUMP_L4;

      irow = col;
      icol = col;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      row = 0;
      for( ; !(row >= k); row = row + 1)
        if(!(ipiv[(signed long int)row] == 1))
        {
          ix = 0;
          for( ; !(ix >= k); ix = ix + 1)
            if(ipiv[(signed long int)ix] == 0)
            {
              if(!((signed int)src[(signed long int)(row * k + ix)] == 0))
              {
                irow = row;
                icol = ix;
                goto found_piv;
              }

            }

            else
              if(ipiv[(signed long int)ix] >= 2)
              {
                fprintf(stderr, "singular matrix\n");
                goto fail;
              }

        }

      if(icol == -1)
      {
        fprintf(stderr, "XXX pivot not found!\n");
        goto fail;
      }

    }

  found_piv:
    ;
    ipiv[(signed long int)icol] = ipiv[(signed long int)icol] + 1;
    if(!(irow == icol))
    {
      ix = 0;
      for( ; !(ix >= k); ix = ix + 1)
      {
        unsigned char tmp = src[(signed long int)(irow * k + ix)];
        src[(signed long int)(irow * k + ix)] = src[(signed long int)(icol * k + ix)];
        src[(signed long int)(icol * k + ix)] = tmp;
      }
    }

    indxr[(signed long int)col] = irow;
    indxc[(signed long int)col] = icol;
    pivot_row = &src[(signed long int)(icol * k)];
    c = pivot_row[(signed long int)icol];
    if((signed int)c == 0)
    {
      fprintf(stderr, "singular matrix 2\n");
      goto fail;
    }

    if(!((signed int)c == 1))
    {
      c = inverse[(signed long int)c];
      pivot_row[(signed long int)icol] = (unsigned char)1;
      ix = 0;
      for( ; !(ix >= k); ix = ix + 1)
        pivot_row[(signed long int)ix] = gf_mul_table[(signed long int)(((signed int)c << 8) + (signed int)pivot_row[(signed long int)ix])];
    }

    id_row[(signed long int)icol] = (unsigned char)1;
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)pivot_row, (const void *)id_row, (unsigned long int)k * sizeof(unsigned char) /*1ul*/ );
    if(!(return_value_memcmp_1 == 0))
    {
      p = src;
      ix = 0;
      for( ; !(ix >= k); p = p + (signed long int)k)
      {
        if(!(ix == icol))
        {
          c = p[(signed long int)icol];
          p[(signed long int)icol] = (unsigned char)0;
          addmul(p, pivot_row, c, k);
        }

        ix = ix + 1;
      }
    }

    id_row[(signed long int)icol] = (unsigned char)0;
  }
  col = k - 1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  for( ; col >= 0; col = col - 1)
  {
    if(!(indxr[(signed long int)col] >= 0))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = indxr[(signed long int)col] >= k ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      fprintf(stderr, "AARGH, indxr[col] %d\n", indxr[(signed long int)col]);

    else
    {
      if(!(indxc[(signed long int)col] >= 0))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = indxc[(signed long int)col] >= k ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        fprintf(stderr, "AARGH, indxc[col] %d\n", indxc[(signed long int)col]);

      else
        if(!(indxr[(signed long int)col] == indxc[(signed long int)col]))
        {
          row = 0;
          for( ; !(row >= k); row = row + 1)
          {
            unsigned char invert_mat__1__3__1__1__1__1__1__tmp = src[(signed long int)(row * k + indxr[(signed long int)col])];
            src[(signed long int)(row * k + indxr[(signed long int)col])] = src[(signed long int)(row * k + indxc[(signed long int)col])];
            src[(signed long int)(row * k + indxc[(signed long int)col])] = invert_mat__1__3__1__1__1__1__1__tmp;
          }
        }

    }
  }
  error = 0;

fail:
  ;
  return error;
}

// isMcastAddress
// file socklib.c line 1111
signed int isMcastAddress(struct sockaddr_in *addr)
{
  signed int ip;
  unsigned int return_value___bswap_32_1;
  return_value___bswap_32_1=__bswap_32(addr->sin_addr.s_addr);
  ip = (signed int)(return_value___bswap_32_1 >> 24);
  return (signed int)(ip >= 0xe0 && ip < 0xf0);
}

// main
// file udp-receiver.c line 124
signed int main(signed int argc, char **argv)
{
  signed int ret;
  char *ptr;
  struct net_config net_config;
  struct disk_config disk_config;
  struct stat_config stat_config;
  signed int c;
  signed int doWarn = 0;
  char *ifName = (char *)(void *)0;
  atexit(signalForward);
  disk_config.fileName = (const char *)(void *)0;
  disk_config.pipeName = (char *)(void *)0;
  disk_config.flags = 0;
  net_config.portBase = 9000;
  net_config.ttl = 1;
  net_config.flags = 0;
  net_config.mcastRdv = (const char *)(void *)0;
  net_config.exitWait = 500;
  net_config.startTimeout = 0;
  net_config.receiveTimeout = 0;
  stat_config.statPeriod = 500000;
  stat_config.printUncompressedPos = -1;
  stat_config.noProgress = 0;
  net_config.requestedBufSize = 0;
  ptr=strrchr(argv[(signed long int)0], 47);
  if(ptr == ((char *)NULL))
    ptr = argv[(signed long int)0];

  else
    ptr = ptr + 1l;
  net_config.net_if = (struct net_if_0 *)(void *)0;
  signed int tmp_statement_expression_2;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_3;
  return_value___builtin_strcmp_3=__builtin_strcmp(ptr, "init");
  tmp_statement_expression_2 = return_value___builtin_strcmp_3;
  if(tmp_statement_expression_2 == 0)
  {
    doWarn = 1;
    char *return_value___strdup_1;
    return_value___strdup_1=__strdup("/bin/gzip -dc");
    disk_config.pipeName = return_value___strdup_1;
    disk_config.fileName = "/dev/hda";
  }

  char *return_value___strdup_4;
  unsigned long int return_value_udpc_parseSize_5;
  signed int return_value_atoi_6;
  do
  {
    c=getopt_long(argc, argv, "b:f:p:P:i:l:M:s:t:w:x:z:dkLnyZ", options, (signed int *)(void *)0);
    if(c == -1)
      break;

    switch(c)
    {
      case 102:
      {
        disk_config.fileName = optarg;
        break;
      }
      case 105:
      {
        ifName = optarg;
        break;
      }
      case 112:
      {
        disk_config.pipeName = optarg;
        break;
      }
      case 80:
      {
        net_config.portBase=atoi(optarg);
        break;
      }
      case 108:
      {
        udpc_log=fopen(optarg, "a");
        break;
      }
      case 0x701:
      {
        stat_config.noProgress = 1;
        break;
      }
      case 116:
      {
        net_config.ttl=atoi(optarg);
        break;
      }
      case 77:
      {
        return_value___strdup_4=__strdup(optarg);
        net_config.mcastRdv = return_value___strdup_4;
        break;
      }
      case 76:
      {
        fec_license();
        break;
      }
      case 100:
      {
        net_config.flags = net_config.flags | 0x0010;
        break;
      }
      case 110:
      {
        disk_config.flags = disk_config.flags | 0x0040;
        break;
      }
      case 121:
      {
        disk_config.flags = disk_config.flags | 0x0100;
        break;
      }
      case 98:
      {
        return_value_udpc_parseSize_5=udpc_parseSize(optarg);
        net_config.requestedBufSize = (signed int)return_value_udpc_parseSize_5;
        break;
      }
      case 107:
      {
        net_config.flags = net_config.flags | 0x0080;
        break;
      }
      case 119:
      {
        net_config.exitWait=atoi(optarg);
        break;
      }
      case 115:
      {
        net_config.startTimeout=atoi(optarg);
        break;
      }
      case 0x801:
      {
        net_config.receiveTimeout=atoi(optarg);
        break;
      }
      case 122:
      {
        return_value_atoi_6=atoi(optarg);
        stat_config.statPeriod = return_value_atoi_6 * 1000;
        break;
      }
      case 120:
      {
        stat_config.printUncompressedPos=atoi(optarg);
        break;
      }
      case 90:
      {
        net_config.flags = net_config.flags | 0x400;
        break;
      }
      case 63:
        usage(argv[(signed long int)0]);
    }
  }
  while((_Bool)1);
  fprintf(stderr, "Udp-receiver %s\n", version);
  signal(2, intHandler);
  openlog((const char *)"udpcast", 0x08 | 0x01, 5 << 3);
  ret=udpc_startReceiver(doWarn, &disk_config, &net_config, &stat_config, ifName);
  if(!(ret >= 0))
    fprintf(stderr, "Receiver error\n");

  return ret;
}

// mcastListen
// file socklib.c line 418
static signed int mcastListen(signed int sock, struct net_if *net_if, struct sockaddr_in *addr)
{
  signed int return_value_mcastOp_1;
  return_value_mcastOp_1=mcastOp(sock, net_if, ((struct sockaddr_in *)addr)->sin_addr, 35, "Subscribe to multicast group");
  return return_value_mcastOp_1;
}

// mcastOp
// file socklib.c line 387
static signed int mcastOp(signed int sock, struct net_if *net_if, struct in_addr addr, signed int code, const char *message)
{
  struct ip_mreqn mreq;
  signed int r;
  fillMreq(net_if, addr, &mreq);
  r=setsockopt(sock, 0, code, (const void *)(char *)&mreq, (unsigned int)sizeof(struct ip_mreqn) /*12ul*/ );
  if(!(r >= 0))
  {
    perror(message);
    exit(1);
  }

  return 0;
}

// modnn
// file fec.c line 152
static inline unsigned char modnn(signed int x)
{
  for( ; x >= 255; x = (x >> 8) + (x & (1 << 8) - 1))
    x = x - ((1 << 8) - 1);
  return (unsigned char)x;
}

// mul
// file fec.c line 532
static inline void mul(unsigned char *dst, unsigned char *src, unsigned char c, signed int sz)
{
  if(!((signed int)c == 0))
    slow_mul1(dst, src, c, sz);

  else
    memset((void *)dst, 0, (unsigned long int)sz);
}

// netReceiverMain
// file receivedata.c line 1151
static void * netReceiverMain(void *args0)
{
  struct clientState *clst = (struct clientState *)args0;
  clst->currentSliceNo = 0;
  setupMessages(clst);
  clst->currentSliceNo = -1;
  clst->currentSlice = (struct slice *)(void *)0;
  clst->promptPrinted = 0;
  if((0x200 & clst->net_config->flags) == 0)
    newSlice(clst, 0);

  else
  {
    clst->currentSlice = (struct slice *)(void *)0;
    clst->currentSliceNo = 0;
  }
  while(!(clst->endReached >= 3))
    dispatchMessage(clst);
  if(!(clst->use_fec == 0))
    pthread_join(clst->fec_thread, (void **)(void *)0);

  return NULL;
}

// newSlice
// file receivedata.c line 284
static struct slice * newSlice(struct clientState *clst, signed int sliceNo)
{
  struct slice *slice = (struct slice *)(void *)0;
  signed int i;
  pc_consume(clst->free_slices_pc, 1);
  unsigned int return_value_pc_getConsumerPosition_1;
  return_value_pc_getConsumerPosition_1=pc_getConsumerPosition(clst->free_slices_pc);
  i = (signed int)return_value_pc_getConsumerPosition_1;
  pc_consumed(clst->free_slices_pc, 1);
  slice = &clst->slices[(signed long int)i];
  /* assertion slice->state == SLICE_FREE */
  assert((signed int)slice->state == SLICE_FREE);
  unsigned int return_value_pc_getConsumerPosition_2;
  return_value_pc_getConsumerPosition_2=pc_getConsumerPosition(clst->fifo->freeMemQueue);
  slice->base = (signed int)return_value_pc_getConsumerPosition_2;
  pc_consume(clst->fifo->freeMemQueue, clst->net_config->blockSize * 1024);
  initSlice(clst, slice, sliceNo);
  return slice;
}

// open2
// file udpc_process.h line 17
signed int open2(signed int in, signed int out, char **arg, signed int closeFd)
{
  signed int pid;
  pid=fork();
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(pid == 0))
  {
    if(pid == -1)
      goto __CPROVER_DUMP_L3;

  }

  else
  {
    dupFd(in, 0);
    dupFd(out, 1);
    if(!(closeFd == -1))
      close(closeFd);

    execvp(arg[(signed long int)0], arg);
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    udpc_fatal(1, "exec %s: %s\n", arg[(signed long int)0], return_value_strerror_2);

  __CPROVER_DUMP_L3:
    ;
    perror("fork");
    return -1;
  }
  return pid;
}

// openOutFile
// file udpr-negotiate.c line 83
static signed int openOutFile(struct disk_config *disk_config)
{
  signed int outFile = 1;
  if(!(disk_config->fileName == ((const char *)NULL)))
  {
    signed int oflags = 0100 | 01 | 01000;
    if(!((0x0100 & disk_config->flags) == 0))
      oflags = oflags | 04010000;

    outFile=open(disk_config->fileName, oflags | 0, 0644);
    if(!(outFile >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      udpc_fatal(1, "open outfile %s: %s\n", disk_config->fileName, return_value_strerror_2);
    }

  }

  return outFile;
}

// pc_consume
// file produconsum.h line 30
signed int pc_consume(struct produconsum *pc, signed int amount)
{
  signed int return_value__consumeAny_1;
  return_value__consumeAny_1=_consumeAny(pc, (unsigned int)amount, ((struct timespec *)NULL));
  return return_value__consumeAny_1;
}

// pc_consumeAny
// file produconsum.c line 165
signed int pc_consumeAny(struct produconsum *pc)
{
  signed int return_value__consumeAny_1;
  return_value__consumeAny_1=_consumeAny(pc, (unsigned int)1, ((struct timespec *)NULL));
  return return_value__consumeAny_1;
}

// pc_consumeAnyContiguous
// file produconsum.c line 177
signed int pc_consumeAnyContiguous(struct produconsum *pc)
{
  signed int return_value_pc_consumeContiguousMinAmount_1;
  return_value_pc_consumeContiguousMinAmount_1=pc_consumeContiguousMinAmount(pc, 1);
  return return_value_pc_consumeContiguousMinAmount_1;
}

// pc_consumeAnyWithTimeout
// file produconsum.c line 170
signed int pc_consumeAnyWithTimeout(struct produconsum *pc, struct timespec *ts)
{
  signed int return_value__consumeAny_1;
  return_value__consumeAny_1=_consumeAny(pc, (unsigned int)1, ts);
  return return_value__consumeAny_1;
}

// pc_consumeContiguousMinAmount
// file produconsum.h line 21
signed int pc_consumeContiguousMinAmount(struct produconsum *pc, signed int amount)
{
  signed int n;
  n=_consumeAny(pc, (unsigned int)amount, ((struct timespec *)NULL));
  signed int l = (signed int)(pc->size - pc->consumed % pc->size);
  if(!(l >= n))
    n = l;

  return n;
}

// pc_consumed
// file produconsum.h line 58
signed int pc_consumed(struct produconsum *pc, signed int amount)
{
  unsigned int consumed = pc->consumed;
  if(consumed >= 2u * pc->size + -((unsigned int)amount))
    consumed = consumed + ((unsigned int)amount - (unsigned int)2 * pc->size);

  else
    consumed = consumed + (unsigned int)amount;
  pc->consumed = consumed;
  return amount;
}

// pc_getConsumerPosition
// file produconsum.h line 35
unsigned int pc_getConsumerPosition(struct produconsum *pc)
{
  return pc->consumed % pc->size;
}

// pc_getProducerPosition
// file produconsum.h line 40
unsigned int pc_getProducerPosition(struct produconsum *pc)
{
  return pc->produced % pc->size;
}

// pc_getSize
// file produconsum.h line 45
unsigned int pc_getSize(struct produconsum *pc)
{
  return pc->size;
}

// pc_getWaiting
// file produconsum.c line 98
unsigned int pc_getWaiting(struct produconsum *pc)
{
  signed int return_value_getProducedAmount_1;
  return_value_getProducedAmount_1=getProducedAmount(pc);
  return (unsigned int)return_value_getProducedAmount_1;
}

// pc_makeProduconsum
// file produconsum.h line 6
struct produconsum * pc_makeProduconsum(signed int size, const char *name)
{
  struct produconsum *pc;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct produconsum) /*120ul*/ );
  pc = (struct produconsum *)return_value_calloc_1;
  pc->size = (unsigned int)size;
  pc->produced = (volatile unsigned int)0;
  pc->consumed = (unsigned int)0;
  pc->atEnd = 0;
  pthread_mutex_init(&pc->mutex, (const union anonymous_4 *)(void *)0);
  pc->consumerIsWaiting = 0;
  pthread_cond_init(&pc->cond, (const union anonymous_4 *)(void *)0);
  pc->name = name;
  return pc;
}

// pc_produce
// file produconsum.h line 7
void pc_produce(struct produconsum *pc, unsigned int amount)
{
  unsigned int produced = pc->produced;
  unsigned int consumed = pc->consumed;
  if(!(pc->size >= amount))
    udpc_fatal(1, "Buffer overflow in produce %s: %d > %d \n", pc->name, amount, pc->size);

  produced = produced + amount;
  if(produced >= 2u * pc->size)
    produced = produced - (unsigned int)2 * pc->size;

  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(pc->size + consumed >= produced))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(produced >= consumed))
      tmp_if_expr_1 = produced > consumed - pc->size ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    udpc_fatal(1, "Buffer overflow in produce %s: %d > %d [%d] \n", pc->name, produced, consumed, pc->size);

  pc->produced = produced;
  wakeConsumer(pc);
}

// pc_produceEnd
// file produconsum.h line 8
void pc_produceEnd(struct produconsum *pc)
{
  pc->atEnd = 1;
  wakeConsumer(pc);
}

// printFilePosition
// file statistics.c line 94
static void printFilePosition(signed int fd)
{
  char *tmp_statement_expression_2;
  if(!(fd == -1))
  {
    char fn[80l];
    signed int pfd;
    sprintf(fn, "/proc/self/fdinfo/%d", fd);
    pfd=open(fn, 00);
    if(!(pfd == -1))
    {
      char buf[161l];
      signed int n;
      signed long int return_value_read_1;
      return_value_read_1=read(pfd, (void *)buf, (unsigned long int)160);
      n = (signed int)return_value_read_1;
      if(n >= 0)
      {
        char *num;
        signed long long int offset;
        buf[(signed long int)n] = (char)0;
        char __a0;
        char __a1;
        char __a2;
        char *return_value___builtin_strpbrk_3;
        return_value___builtin_strpbrk_3=__builtin_strpbrk(buf, "0123456789");
        tmp_statement_expression_2 = return_value___builtin_strpbrk_3;
        num = tmp_statement_expression_2;
        unsigned long long int return_value_strtoull_4;
        return_value_strtoull_4=strtoull(num, ((char ** restrict )NULL), 10);
        offset = (signed long long int)return_value_strtoull_4;
        if(offset >= 0l)
          udpc_printLongNum((unsigned long long int)offset);

      }

      close(pfd);
    }

    else
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(*return_value___errno_location_5);
      fprintf(stderr, "%s --> %s\n", (const void *)fn, return_value_strerror_6);
    }
  }

}

// printMissedBlockMap
// file receivedata.c line 138
static void printMissedBlockMap(struct clientState *clst, struct slice *slice)
{
  signed int i;
  signed int first = 1;
  signed int blocksInSlice = ((slice->bytes + clst->net_config->blockSize) - 1) / clst->net_config->blockSize;
  i = 0;
  for( ; !(i >= blocksInSlice); i = i + 1)
    if((1 << (unsigned long int)i % sizeof(unsigned char) * 8 /*8ul*/  & (signed int)slice->retransmit.map[(signed long int)((unsigned long int)i / sizeof(unsigned char) * 8 /*8ul*/ )]) == 0)
    {
      if(!(first == 0))
        fprintf(stderr, "Missed blocks: ");

      else
        fprintf(stderr, ",");
      fprintf(stderr, "%d", i);
      first = 0;
    }

  if(first == 0)
    fprintf(stderr, "\n");

  first = 1;
  if(!(slice->fec_stripes == 0))
  {
    i = 0;
    for( ; !(i >= 1024); i = i + 1)
      if(!(i / slice->fec_stripes >= (signed int)slice->fec_blocks[(signed long int)(i % slice->fec_stripes)]))
      {
        if(!(first == 0))
          fprintf(stderr, "FEC blocks: ");

        else
          fprintf(stderr, ",");
        fprintf(stderr, "%d", slice->fec_descs[(signed long int)i].fecBlockNo);
        first = 0;
      }

  }

  if(first == 0)
    fprintf(stderr, "\n");

  fprintf(stderr, "Blocks received: %d/%d/%d\n", slice->dataBlocksTransferred, slice->blocksTransferred, blocksInSlice);
  i = 0;
  for( ; !(i >= slice->fec_stripes); i = i + 1)
    fprintf(stderr, "Stripe %2d: %3d/%3d %s\n", i, slice->missing_data_blocks[(signed long int)i], slice->fec_blocks[(signed long int)i], (signed int)slice->missing_data_blocks[(signed long int)i] > (signed int)slice->fec_blocks[(signed long int)i] ? "**************" : "");
}

// printNewlineIfNeeded
// file log.c line 13
static void printNewlineIfNeeded(void)
{
  if(!(needNewline == 0))
    fprintf(stderr, "\n");

  needNewline = 0;
}

// printProcessStatus
// file udpcast.c line 30
static signed int printProcessStatus(const char *message, signed int status)
{
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  if((0x7f & status) == 0)
  {
    if(!((0xff00 & status) >> 8 == 0))
    {
      udpc_flprintf("%s process died with code %d\n", message, (((union anonymous){ .__in=status }).__i & 0xff00) >> 8);
      return (((union anonymous){ .__in=status }).__i & 0xff00) >> 8;
    }

  }

  else
  {
    if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
    {
      udpc_flprintf("%s process caught signal %d\n", message, ((union anonymous){ .__in=status }).__i & 0x7f);
      return 1;
    }

    udpc_flprintf("%s process did not cleanly exit\n", message);
    return 1;
  }
  return 0;
}

// processDataBlock
// file receivedata.c line 776
static signed int processDataBlock(struct clientState *clst, signed int sliceNo, signed int blockNo, signed int bytes)
{
  struct fifo *fifo = clst->fifo;
  struct slice *slice;
  slice=findSlice(clst, sliceNo);
  unsigned char *shouldAddress;
  unsigned char *isAddress;
  _Bool tmp_if_expr_1;
  if(slice == ((struct slice *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = slice->magic == 0x41424344 ? (_Bool)1 : (_Bool)0;
  /* assertion slice == ((void *)0) || slice->magic == 0x41424344 */
  assert(tmp_if_expr_1);
  _Bool tmp_if_expr_2;
  if(slice == ((struct slice *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)slice->state == SLICE_FREE ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)slice->state == SLICE_DONE ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)slice->state == SLICE_FEC ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = (signed int)slice->state == SLICE_FEC_DONE ? (_Bool)1 : (_Bool)0;
  signed int tmp_post_6;
  if(tmp_if_expr_5)
    return 0;

  else
  {
    if(!(2 + clst->currentSliceNo >= sliceNo))
      udpc_fatal(1, "We have been dropped by sender\n");

    if(!((1 << (unsigned long int)blockNo % sizeof(unsigned char) * 8 /*8ul*/  & (signed int)slice->retransmit.map[(signed long int)((unsigned long int)blockNo / sizeof(unsigned char) * 8 /*8ul*/ )]) == 0))
      return 0;

    else
    {
      if(!(slice->base % clst->net_config->blockSize == 0))
        udpc_fatal(1, "Bad base %d, not multiple of block size %d\n", slice->base, clst->net_config->blockSize);

      shouldAddress = fifo->dataBuffer + (signed long int)((unsigned int)(slice->base + blockNo * clst->net_config->blockSize) % fifo->dataBufSize);
      isAddress = (unsigned char *)(clst->data_hdr.msg_iov + (signed long int)1)->iov_base;
      if(!(shouldAddress == isAddress))
        memcpy((void *)shouldAddress, (const void *)isAddress, (unsigned long int)clst->net_config->blockSize);

      if(!(clst->client_config->sender_is_newgen == 0))
      {
        if(!(bytes == 0))
          setSliceBytes(slice, clst, bytes);

      }

      if(!(clst->client_config->sender_is_newgen == 0))
      {
        if(bytes == 0)
          clst->netEndReached = 0;

      }

      slice->retransmit.map[(signed long int)((unsigned long int)blockNo / (sizeof(unsigned char) /*1ul*/  * (unsigned long int)8))] = slice->retransmit.map[(signed long int)((unsigned long int)blockNo / (sizeof(unsigned char) /*1ul*/  * (unsigned long int)8))] | (unsigned char)(1 << (unsigned long int)blockNo % (sizeof(unsigned char) /*1ul*/  * (unsigned long int)8));
      if(!(slice->fec_stripes == 0))
      {
        signed int stripe = blockNo % slice->fec_stripes;
        slice->missing_data_blocks[(signed long int)stripe] = slice->missing_data_blocks[(signed long int)stripe] - 1;
        /* assertion slice->missing_data_blocks[stripe] >= 0 */
        assert((signed int)slice->missing_data_blocks[(signed long int)stripe] >= 0);
        if(!((signed int)slice->missing_data_blocks[(signed long int)stripe] >= (signed int)slice->fec_blocks[(signed long int)stripe]))
        {
          signed int blockIdx;
          slice->fec_blocks[(signed long int)stripe] = slice->fec_blocks[(signed long int)stripe] - 1;
          blockIdx = stripe + (signed int)slice->fec_blocks[(signed long int)stripe] * slice->fec_stripes;
          /* assertion slice->fec_descs[blockIdx].adr != 0 */
          assert(slice->fec_descs[(signed long int)blockIdx].adr != ((unsigned char *)NULL));
          tmp_post_6 = clst->localPos;
          clst->localPos = clst->localPos + 1;
          clst->localBlockAddresses[(signed long int)tmp_post_6] = slice->fec_descs[(signed long int)blockIdx].adr;
          slice->fec_descs[(signed long int)blockIdx].adr = ((unsigned char *)NULL);
          slice->blocksTransferred = slice->blocksTransferred - 1;
        }

      }

      slice->dataBlocksTransferred = slice->dataBlocksTransferred + 1;
      slice->blocksTransferred = slice->blocksTransferred + 1;
      for( ; !(slice->freePos >= 1024); slice->freePos = slice->freePos + 1)
        if((1 << (unsigned long int)slice->freePos % sizeof(unsigned char) * 8 /*8ul*/  & (signed int)slice->retransmit.map[(signed long int)((unsigned long int)slice->freePos / sizeof(unsigned char) * 8 /*8ul*/ )]) == 0)
          break;

      checkSliceComplete(clst, slice);
      return 0;
    }
  }
}

// processFecBlock
// file receivedata.c line 692
static signed int processFecBlock(struct clientState *clst, signed int stripes, signed int sliceNo, signed int blockNo, signed int bytes)
{
  struct slice *slice;
  slice=findSlice(clst, sliceNo);
  unsigned char *shouldAddress;
  unsigned char *isAddress;
  signed int stripe;
  struct fec_desc *desc;
  signed int adr;
  _Bool tmp_if_expr_1;
  if(slice == ((struct slice *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = slice->magic == 0x41424344 ? (_Bool)1 : (_Bool)0;
  /* assertion slice == ((void *)0) || slice->magic == 0x41424344 */
  assert(tmp_if_expr_1);
  _Bool tmp_if_expr_2;
  if(slice == ((struct slice *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)slice->state == SLICE_FREE ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)slice->state == SLICE_DONE ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (signed int)slice->state == SLICE_FEC ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
    return 0;

  else
  {
    shouldAddress = clst->nextBlock;
    isAddress = (unsigned char *)(clst->data_hdr.msg_iov + (signed long int)1)->iov_base;
    setSliceBytes(slice, clst, bytes);
    if(slice->fec_stripes == 0)
    {
      slice->fec_stripes = stripes;
      initSliceForFec(clst, slice);
    }

    else
      if(!(slice->fec_stripes == stripes))
      {
        udpc_flprintf("Interleave mismatch %d <-> %d", slice->fec_stripes, stripes);
        return 0;
      }

    stripe = blockNo % slice->fec_stripes;
    if((signed int)slice->fec_blocks[(signed long int)stripe] >= (signed int)slice->missing_data_blocks[(signed long int)stripe])
    {
      checkSliceComplete(clst, slice);
      advanceReceivedPointer(clst);
      if(clst->use_fec == 0)
        cleanupSlices(clst, (unsigned int)SLICE_DONE);

      return 0;
    }

    else
    {
      adr = (signed int)slice->fec_blocks[(signed long int)stripe] * stripes + stripe;
      signed int i = stripe;
      for( ; !(i >= adr); i = i + stripes)
      {
        desc = &slice->fec_descs[(signed long int)i];
        if(desc->fecBlockNo == blockNo)
        {
          udpc_flprintf("**** duplicate block...\n");
          return 0;
        }

      }
      if(!(shouldAddress == isAddress))
        memcpy((void *)shouldAddress, (const void *)isAddress, (unsigned long int)clst->net_config->blockSize);

      desc = &slice->fec_descs[(signed long int)adr];
      desc->adr = shouldAddress;
      desc->fecBlockNo = blockNo;
      slice->fec_blocks[(signed long int)stripe] = slice->fec_blocks[(signed long int)stripe] + 1;
      slice->blocksTransferred = slice->blocksTransferred + 1;
      setNextBlock(clst);
      slice->freePos = 1024;
      checkSliceComplete(clst, slice);
      advanceReceivedPointer(clst);
      return 0;
    }
  }
}

// processReqAck
// file receivedata.c line 857
static signed int processReqAck(struct clientState *clst, signed int sliceNo, signed int bytes, signed int rxmit)
{
  struct slice *slice;
  slice=findSlice(clst, sliceNo);
  signed int blocksInSlice;
  char *readySet = (char *)(clst->data_hdr.msg_iov + (signed long int)1)->iov_base;
  _Bool tmp_if_expr_1;
  if(slice == ((struct slice *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = slice->magic == 0x41424344 ? (_Bool)1 : (_Bool)0;
  /* assertion slice == ((void *)0) || slice->magic == 0x41424344 */
  assert(tmp_if_expr_1);
  struct timeval tv;
  gettimeofday(&tv, ((struct timezone *)NULL));
  if(!((1 << (unsigned long int)clst->client_config->clientNumber % sizeof(char) * 8 /*8ul*/  & (signed int)readySet[(signed long int)((unsigned long int)clst->client_config->clientNumber / sizeof(char) * 8 /*8ul*/ )]) == 0))
    return 0;

  else
  {
    if(slice == ((struct slice *)NULL))
    {
      signed int return_value_sendOk_2;
      return_value_sendOk_2=sendOk(clst->client_config, (unsigned int)sliceNo);
      return return_value_sendOk_2;
    }

    setSliceBytes(slice, clst, bytes);
    /* assertion clst->net_config->blockSize != 0 */
    assert(clst->net_config->blockSize != 0);
    blocksInSlice = ((slice->bytes + clst->net_config->blockSize) - 1) / clst->net_config->blockSize;
    if(blocksInSlice == slice->blocksTransferred)
      sendOk(clst->client_config, (unsigned int)slice->sliceNo);

    else
      sendRetransmit(clst, slice, rxmit);
    checkSliceComplete(clst, slice);
    advanceReceivedPointer(clst);
    if(clst->use_fec == 0)
      cleanupSlices(clst, (unsigned int)SLICE_DONE);

    return 0;
  }
}

// reduce
// file fec.c line 810
static inline void reduce(unsigned int blockSize, unsigned char **data_blocks, unsigned int nr_data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, unsigned short int nr_fec_blocks)
{
  signed int erasedIdx = 0;
  unsigned int col = (unsigned int)0;
  _Bool tmp_if_expr_1;
  for( ; !(col >= nr_data_blocks); col = col + 1u)
  {
    if(!(erasedIdx >= (signed int)nr_fec_blocks))
      tmp_if_expr_1 = erased_blocks[(signed long int)erasedIdx] == col ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      erasedIdx = erasedIdx + 1;

    else
    {
      unsigned char *src = data_blocks[(signed long int)col];
      signed int j = 0;
      for( ; !(j >= (signed int)nr_fec_blocks); j = j + 1)
      {
        signed int blno = (signed int)fec_block_nos[(signed long int)j];
        addmul(fec_blocks[(signed long int)j], src, inverse[(signed long int)((unsigned int)blno ^ col ^ (unsigned int)128)], (signed int)blockSize);
      }
    }
  }
  /* assertion nr_fec_blocks == erasedIdx */
  assert((signed int)nr_fec_blocks == erasedIdx);
}

// resolve
// file fec.c line 856
static inline void resolve(signed int blockSize, unsigned char **data_blocks, unsigned char **fec_blocks, unsigned int *fec_block_nos, unsigned int *erased_blocks, signed short int nr_fec_blocks)
{
  signed int row;
  const signed long int row_array_size0 = (signed long int)((signed int)nr_fec_blocks * (signed int)nr_fec_blocks);
  unsigned char matrix[row_array_size0];
  signed int ptr;
  signed int r;
  row = 0;
  ptr = 0;
  for( ; !(row >= (signed int)nr_fec_blocks); row = row + 1)
  {
    signed int resolve__1__1__1__col;
    signed int irow = (signed int)((unsigned int)128 + fec_block_nos[(signed long int)row]);
    resolve__1__1__1__col = 0;
    for( ; !(resolve__1__1__1__col >= (signed int)nr_fec_blocks); ptr = ptr + 1)
    {
      signed int icol = (signed int)erased_blocks[(signed long int)resolve__1__1__1__col];
      matrix[(signed long int)ptr] = inverse[(signed long int)(irow ^ icol)];
      resolve__1__1__1__col = resolve__1__1__1__col + 1;
    }
  }
  r=invert_mat(matrix, (signed int)nr_fec_blocks);
  if(!(r == 0))
  {
    signed int col;
    fprintf(stderr, "Pivot not found\n");
    fprintf(stderr, "Rows: ");
    row = 0;
    for( ; !(row >= (signed int)nr_fec_blocks); row = row + 1)
      fprintf(stderr, "%d ", (unsigned int)128 + fec_block_nos[(signed long int)row]);
    fprintf(stderr, "\n");
    fprintf(stderr, "Columns: ");
    col = 0;
    for( ; !(col >= (signed int)nr_fec_blocks); ptr = ptr + 1)
    {
      fprintf(stderr, "%d ", erased_blocks[(signed long int)col]);
      col = col + 1;
    }
    fprintf(stderr, "\n");
    /* assertion 0 */
    assert(0 != 0);
  }

  row = 0;
  ptr = 0;
  signed int tmp_post_1;
  for( ; !(row >= (signed int)nr_fec_blocks); row = row + 1)
  {
    signed int resolve__1__3__1__col;
    unsigned char *target = data_blocks[(signed long int)erased_blocks[(signed long int)row]];
    tmp_post_1 = ptr;
    ptr = ptr + 1;
    mul(target, fec_blocks[(signed long int)0], matrix[(signed long int)tmp_post_1], blockSize);
    resolve__1__3__1__col = 1;
    for( ; !(resolve__1__3__1__col >= (signed int)nr_fec_blocks); ptr = ptr + 1)
    {
      addmul(target, fec_blocks[(signed long int)resolve__1__3__1__col], matrix[(signed long int)ptr], blockSize);
      resolve__1__3__1__col = resolve__1__3__1__col + 1;
    }
  }
}

// safe_inet_aton
// file socklib.c line 266
static signed int safe_inet_aton(const char *address, struct in_addr *ip)
{
  signed int return_value_INET_ATON_1;
  return_value_INET_ATON_1=INET_ATON(address, ip);
  if(return_value_INET_ATON_1 == 0)
    udpc_fatal(-1, "Bad address %s", address);

  return 0;
}

// selectWithConsole
// file console.h line 26
signed int selectWithConsole(struct console_t *con, signed int maxFd, struct anonymous_1 *read_set, struct timeval *tv, signed int *keyPressed)
{
  signed int ret;
  if(!(con == ((struct console_t *)NULL)))
  {
    signed int fd = con->fd;
    read_set->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = read_set->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(fd >= maxFd)
      maxFd = fd + 1;

  }

  ret=select(maxFd, read_set, (struct anonymous_1 *)(void *)0, (struct anonymous_1 *)(void *)0, tv);
  if(!(ret >= 0))
    return -1;

  else
  {
    if(!(con == ((struct console_t *)NULL)))
    {
      if(!((read_set->__fds_bits[(signed long int)(con->fd / 8)] & (signed long int)(1UL << con->fd % 8)) == 0l))
        *keyPressed = 1;

    }

    return ret;
  }
}

// sendConnectReq
// file udpr-negotiate.c line 28
static signed int sendConnectReq(struct client_config *client_config, struct net_config *net_config, signed int haveServerAddress)
{
  struct connectReq connectReq;
  unsigned short int tmp_statement_expression_1;
  signed int return_value_udpc_doSend_4;
  signed int return_value_udpc_doSend_5;
  if(!((0x0010 & net_config->flags) == 0))
    return 0;

  else
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)3;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_1 = __v;
    connectReq.opCode = tmp_statement_expression_1;
    connectReq.reserved = (signed short int)0;
    unsigned int return_value___bswap_32_2;
    return_value___bswap_32_2=__bswap_32_link2((unsigned int)(0x0001 | 0x0008));
    connectReq.capabilities = (signed int)return_value___bswap_32_2;
    unsigned int return_value_udpc_getRcvBuf_3;
    return_value_udpc_getRcvBuf_3=udpc_getRcvBuf(client_config->socks[(signed long int)0]);
    connectReq.rcvbuf=__bswap_32_link2(return_value_udpc_getRcvBuf_3);
    if(!(haveServerAddress == 0))
    {
      return_value_udpc_doSend_4=udpc_doSend(client_config->socks[(signed long int)0], (void *)&connectReq, sizeof(struct connectReq) /*12ul*/ , &client_config->serverAddr);
      return return_value_udpc_doSend_4;
    }

    else
    {
      return_value_udpc_doSend_5=udpc_doSend(client_config->socks[(signed long int)0], (void *)&connectReq, sizeof(struct connectReq) /*12ul*/ , &net_config->controlMcastAddr);
      return return_value_udpc_doSend_5;
    }
  }
}

// sendDisconnectWrapper
// file udpr-negotiate.c line 60
static void sendDisconnectWrapper(void)
{
  if(!(global_client_config == ((struct client_config *)NULL)))
    udpc_sendDisconnect(0, global_client_config);

}

// sendOk
// file receivedata.c line 188
static signed int sendOk(struct client_config *client_config, unsigned int sliceNo)
{
  struct ok ok;
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)0;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  ok.opCode = tmp_statement_expression_1;
  ok.reserved = (signed short int)0;
  unsigned int return_value___bswap_32_2;
  return_value___bswap_32_2=__bswap_32_link1(sliceNo);
  ok.sliceNo = (signed int)return_value___bswap_32_2;
  signed int return_value_udpc_doSend_3;
  return_value_udpc_doSend_3=udpc_doSend(client_config->socks[(signed long int)0], (void *)&ok, sizeof(struct ok) /*8ul*/ , &client_config->serverAddr);
  return return_value_udpc_doSend_3;
}

// sendRetransmit
// file receivedata.c line 197
static signed int sendRetransmit(struct clientState *clst, struct slice *slice, signed int rxmit)
{
  struct client_config *client_config = clst->client_config;
  /* assertion slice->magic == 0x41424344 */
  assert(slice->magic == 0x41424344);
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)1;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  slice->retransmit.opCode = tmp_statement_expression_1;
  slice->retransmit.reserved = (signed short int)0;
  unsigned int return_value___bswap_32_2;
  return_value___bswap_32_2=__bswap_32_link1((unsigned int)slice->sliceNo);
  slice->retransmit.sliceNo = (signed int)return_value___bswap_32_2;
  unsigned int return_value___bswap_32_3;
  return_value___bswap_32_3=__bswap_32_link1((unsigned int)rxmit);
  slice->retransmit.rxmit = (signed int)return_value___bswap_32_3;
  signed int return_value_udpc_doSend_4;
  return_value_udpc_doSend_4=udpc_doSend(client_config->socks[(signed long int)0], (void *)&slice->retransmit, sizeof(struct retransmit) /*140ul*/ , &client_config->serverAddr);
  return return_value_udpc_doSend_4;
}

// setNextBlock
// file receivedata.c line 236
static void setNextBlock(struct clientState *clst)
{
  clst->nextBlock=getBlockSpace(clst);
}

// setSliceBytes
// file receivedata.c line 382
static void setSliceBytes(struct slice *slice, struct clientState *clst, signed int bytes)
{
  /* assertion slice->magic == 0x41424344 */
  assert(slice->magic == 0x41424344);
  if(!(slice->bytesKnown == 0))
  {
    if(!(slice->bytes == bytes))
      udpc_fatal(1, "Byte number mismatch %d <-> %d\n", bytes, slice->bytes);

  }

  else
  {
    slice->bytesKnown = 1;
    slice->bytes = bytes;
    if(bytes == 0)
      clst->netEndReached = 1;

    if((0x200 & clst->net_config->flags) == 0)
      pc_consumed(clst->fifo->freeMemQueue, bytes);

  }
}

// setupMessages
// file receivedata.c line 1138
static signed int setupMessages(struct clientState *clst)
{
  clst->data_iov[(signed long int)0].iov_base = (void *)&clst->Msg;
  clst->data_iov[(signed long int)0].iov_len = sizeof(union serverDataMsg) /*16ul*/ ;
  clst->data_hdr.msg_iov = clst->data_iov;
  initMsgHdr(&clst->data_hdr);
  return 0;
}

// shouldPrint
// file statistics.c line 47
static signed int shouldPrint(struct stats *s, struct timeval *now, signed int isFinal)
{
  signed long long int sinceLastPrint;
  if(!(isFinal == 0))
    return 1;

  else
  {
    sinceLastPrint = (now->tv_sec - s->lastPrinted.tv_sec) * (signed long int)1000000 + (now->tv_usec - s->lastPrinted.tv_usec);
    if(!(sinceLastPrint >= s->statPeriod))
      return 0;

    else
    {
      s->lastPrinted = *now;
      return 1;
    }
  }
}

// signalForward
// file udp-receiver.c line 89
static void signalForward(void)
{
  if(!(signalNumber == 0))
  {
    struct anonymous_0 sig;
    signal(signalNumber, (void (*)(signed int))0);
    sigemptyset(&sig);
    sigaddset(&sig, signalNumber);
    sigprocmask(1, &sig, (struct anonymous_0 *)(void *)0);
    raise(signalNumber);
    perror("raise");
  }

}

// slow_addmul1
// file fec.c line 301
static void slow_addmul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz)
{
  unsigned char *__gf_mulc_;
  unsigned char *dst = dst1;
  unsigned char *src = src1;
  unsigned char *lim = &dst[(signed long int)((sz - 16) + 1)];
  __gf_mulc_ = &gf_mul_table[(signed long int)((signed int)c << 8)];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = dst[(signed long int)0] ^ __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = dst[(signed long int)1] ^ __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = dst[(signed long int)2] ^ __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = dst[(signed long int)3] ^ __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = dst[(signed long int)4] ^ __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = dst[(signed long int)5] ^ __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = dst[(signed long int)6] ^ __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = dst[(signed long int)7] ^ __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = dst[(signed long int)8] ^ __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = dst[(signed long int)9] ^ __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = dst[(signed long int)10] ^ __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = dst[(signed long int)11] ^ __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = dst[(signed long int)12] ^ __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = dst[(signed long int)13] ^ __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = dst[(signed long int)14] ^ __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = dst[(signed long int)15] ^ __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = *dst ^ __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// slow_mul1
// file fec.c line 427
static void slow_mul1(unsigned char *dst1, unsigned char *src1, unsigned char c, signed int sz)
{
  unsigned char *__gf_mulc_;
  unsigned char *dst = dst1;
  unsigned char *src = src1;
  unsigned char *lim = &dst[(signed long int)((sz - 16) + 1)];
  __gf_mulc_ = &gf_mul_table[(signed long int)((signed int)c << 8)];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// udpc_allocReadStats
// file statistics.h line 13
struct receiver_stats * udpc_allocReadStats(signed int fd, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress)
{
  struct receiver_stats *rs;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct receiver_stats) /*80ul*/ );
  rs = (struct receiver_stats *)return_value_calloc_1;
  initStats(&rs->s, fd, statPeriod, printUncompressedPos, noProgress);
  return rs;
}

// udpc_allocSenderStats
// file statistics.c line 196
struct sender_stats * udpc_allocSenderStats(signed int fd, struct _IO_FILE *logfile, signed long int bwPeriod, signed long int statPeriod, signed int printUncompressedPos, signed int noProgress)
{
  struct sender_stats *ss;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct sender_stats) /*104ul*/ );
  ss = (struct sender_stats *)return_value_calloc_1;
  ss->log = logfile;
  ss->bwPeriod = bwPeriod;
  gettimeofday(&ss->periodStart, ((struct timezone *)NULL));
  initStats(&ss->s, fd, statPeriod, printUncompressedPos, noProgress);
  return ss;
}

// udpc_clearIp
// file socklib.c line 990
void udpc_clearIp(struct sockaddr_in *addr)
{
  addr->sin_addr.s_addr = (unsigned int)0;
  addr->sin_family = (unsigned short int)2;
}

// udpc_closeSock
// file socklib.c line 1100
void udpc_closeSock(signed int *socks, signed int nr, signed int target)
{
  signed int i;
  signed int sock = socks[(signed long int)target];
  socks[(signed long int)target] = -1;
  i = 0;
  for( ; !(i >= nr); i = i + 1)
    if(socks[(signed long int)i] == sock)
      goto __CPROVER_DUMP_L4;

  close(sock);

__CPROVER_DUMP_L4:
  ;
}

// udpc_copyFromMessage
// file socklib.c line 1018
void udpc_copyFromMessage(struct sockaddr_in *dst, unsigned char *src)
{
  memcpy((void *)(char *)&dst->sin_addr, (const void *)src, sizeof(struct in_addr) /*4ul*/ );
}

// udpc_copyIpFrom
// file socklib.c line 1000
void udpc_copyIpFrom(struct sockaddr_in *dst, struct sockaddr_in *src)
{
  dst->sin_addr = src->sin_addr;
  dst->sin_family = src->sin_family;
}

// udpc_copyToMessage
// file socklib.c line 1012
void udpc_copyToMessage(unsigned char *dst, struct sockaddr_in *src)
{
  memcpy((void *)dst, (const void *)(char *)&((struct sockaddr_in *)src)->sin_addr, sizeof(struct in_addr) /*4ul*/ );
}

// udpc_displayReceiverStats
// file statistics.h line 18
void udpc_displayReceiverStats(struct receiver_stats *rs, signed int isFinal)
{
  signed long long int timePassed;
  struct timeval tv_now;
  _Bool tmp_if_expr_1;
  if(rs == ((struct receiver_stats *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = rs->s.noProgress != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    gettimeofday(&tv_now, ((struct timezone *)NULL));
    signed int return_value_shouldPrint_2;
    return_value_shouldPrint_2=shouldPrint(&rs->s, &tv_now, isFinal);
    if(!(return_value_shouldPrint_2 == 0))
    {
      fprintf(stderr, "bytes=");
      udpc_printLongNum((unsigned long long int)rs->totalBytes);
      fprintf(stderr, " (");
      timePassed = tv_now.tv_sec - rs->tv_start.tv_sec;
      timePassed = timePassed * (signed long long int)1000000;
      timePassed = timePassed + (tv_now.tv_usec - rs->tv_start.tv_usec);
      if(!(timePassed == 0l))
      {
        signed int mbps = (signed int)((rs->totalBytes * (signed long int)800) / timePassed);
        fprintf(stderr, "%3d.%02d", mbps / 100, mbps % 100);
      }

      else
        fprintf(stderr, "***.**");
      fprintf(stderr, " Mbps)");
      if(!(rs->s.printUncompressedPos == 0))
        printFilePosition(rs->s.fd);

      fprintf(stderr, "\r");
      fflush(stderr);
    }

  }

}

// udpc_displaySenderStats
// file statistics.c line 240
void udpc_displaySenderStats(struct sender_stats *ss, signed int blockSize, signed int sliceSize, signed int isFinal)
{
  unsigned int blocks;
  unsigned int percent;
  struct timeval tv_now;
  _Bool tmp_if_expr_1;
  if(ss == ((struct sender_stats *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ss->s.noProgress != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    gettimeofday(&tv_now, ((struct timezone *)NULL));
    signed int return_value_shouldPrint_2;
    return_value_shouldPrint_2=shouldPrint(&ss->s, &tv_now, isFinal);
    if(!(return_value_shouldPrint_2 == 0))
    {
      blocks = (unsigned int)(((ss->totalBytes + (unsigned long int)blockSize) - (unsigned long int)1) / (unsigned long int)blockSize);
      if(blocks == 0u)
        percent = (unsigned int)0;

      else
        percent = (unsigned int)(((unsigned long int)1000L * ss->retransmissions) / (unsigned long int)blocks);
      fprintf(stderr, "bytes=");
      udpc_printLongNum(ss->totalBytes);
      fprintf(stderr, " re-xmits=%07llu (%3u.%01u%%) slice=%04d ", ss->retransmissions, percent / (unsigned int)10, percent % (unsigned int)10, sliceSize);
      if(!(ss->s.printUncompressedPos == 0))
        printFilePosition(ss->s.fd);

      fprintf(stderr, "- %3d\r", ss->clNo);
      fflush(stderr);
    }

  }

}

// udpc_doReceive
// file socklib.c line 296
signed int udpc_doReceive(signed int s, void *message, unsigned long int len, struct sockaddr_in *from, signed int portBase)
{
  unsigned int slen;
  signed int r;
  unsigned short int port;
  char ipBuffer[16l];
  slen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed long int return_value_recvfrom_1;
  return_value_recvfrom_1=recvfrom(s, message, len, 0, (struct sockaddr *)from, &slen);
  r = (signed int)return_value_recvfrom_1;
  unsigned short int tmp_statement_expression_2;
  unsigned short int tmp_statement_expression_4;
  if(!(r >= 0))
    return r;

  else
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)from->sin_port;
    asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression_2 = __v;
    port = tmp_statement_expression_2;
    if(!((signed int)port == 1 + portBase) && !((signed int)port == portBase))
    {
      char *return_value_udpc_getIpString_3;
      return_value_udpc_getIpString_3=udpc_getIpString(from, ipBuffer);
      unsigned short int udpc_doReceive__1__2__1____v;
      unsigned short int udpc_doReceive__1__2__1____x = (unsigned short int)((struct sockaddr_in *)from)->sin_port;
      asm("rorw _8, %w0" : "=r"(udpc_doReceive__1__2__1____v) : "0"(udpc_doReceive__1__2__1____x) : "cc");
      tmp_statement_expression_4 = udpc_doReceive__1__2__1____v;
      udpc_flprintf("Bad message from port %s.%d\n", return_value_udpc_getIpString_3, tmp_statement_expression_4);
      return -1;
    }

    return r;
  }
}

// udpc_doSend
// file socklib.c line 288
signed int udpc_doSend(signed int s, void *message, unsigned long int len, struct sockaddr_in *to)
{
  signed long int return_value_sendto_1;
  return_value_sendto_1=sendto(s, message, len, 0, (struct sockaddr *)to, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  return (signed int)return_value_sendto_1;
}

// udpc_fatal
// file log.h line 19
signed int udpc_fatal(signed int code, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  if(!(quitting == 0))
    _exit(code);

  quitting = 1;
  printNewlineIfNeeded();
  vfprintf(stderr, fmt, ap);
  exit(code);
}

// udpc_flprintf
// file log.h line 17
signed int udpc_flprintf(const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  signed int return_value_vlogprintf_1;
  if(!(udpc_log == ((struct _IO_FILE *)NULL)))
  {
    return_value_vlogprintf_1=vlogprintf(udpc_log, fmt, ap);
    return return_value_vlogprintf_1;
  }

  else
  {
    printNewlineIfNeeded();
    signed int return_value_vfprintf_2;
    return_value_vfprintf_2=vfprintf(stderr, fmt, ap);
    return return_value_vfprintf_2;
  }
}

// udpc_getBroadCastAddress
// file socklib.c line 250
signed int udpc_getBroadCastAddress(struct net_if *net_if, struct sockaddr_in *addr, signed short int port)
{
  signed int r;
  r=initSockAddress((enum addr_type_t)ADDR_TYPE_BCAST, net_if, (unsigned int)0x00000000, (unsigned short int)port, addr);
  if(addr->sin_addr.s_addr == 0u)
  {
    struct sockaddr_in ucast;
    initSockAddress((enum addr_type_t)ADDR_TYPE_UCAST, net_if, (unsigned int)0x00000000, (unsigned short int)port, &ucast);
    unsigned int return_value___bswap_32_1;
    return_value___bswap_32_1=__bswap_32(ucast.sin_addr.s_addr);
    if((0xff000000 & return_value___bswap_32_1) == 2130706432u)
      addr->sin_addr.s_addr = ucast.sin_addr.s_addr;

  }

  return r;
}

// udpc_getDefaultMcastAddress
// file socklib.c line 1005
void udpc_getDefaultMcastAddress(struct net_if *net_if, struct sockaddr_in *mcast)
{
  udpc_getMyAddress(net_if, mcast);
  unsigned int return_value___bswap_32_1;
  return_value___bswap_32_1=__bswap_32((unsigned int)0x07ffffff);
  mcast->sin_addr.s_addr = mcast->sin_addr.s_addr & return_value___bswap_32_1;
  unsigned int return_value___bswap_32_2;
  return_value___bswap_32_2=__bswap_32(0xe8000000);
  mcast->sin_addr.s_addr = mcast->sin_addr.s_addr | return_value___bswap_32_2;
}

// udpc_getIpString
// file socklib.c line 963
char * udpc_getIpString(struct sockaddr_in *addr, char *buffer)
{
  signed long int iaddr;
  unsigned int return_value___bswap_32_1;
  return_value___bswap_32_1=__bswap_32(((struct sockaddr_in *)addr)->sin_addr.s_addr);
  iaddr = (signed long int)return_value___bswap_32_1;
  sprintf(buffer, "%ld.%ld.%ld.%ld", iaddr >> 24 & (signed long int)0xff, iaddr >> 16 & (signed long int)0xff, iaddr >> 8 & (signed long int)0xff, iaddr & (signed long int)0xff);
  return buffer;
}

// udpc_getMcastAllAddress
// file socklib.c line 273
signed int udpc_getMcastAllAddress(struct sockaddr_in *addr, const char *address, signed short int port)
{
  struct in_addr ip;
  signed int ret;
  _Bool tmp_if_expr_1;
  if(address == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)address[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    safe_inet_aton("224.0.0.1", &ip);

  else
  {
    ret=safe_inet_aton(address, &ip);
    if(!(ret >= 0))
      return ret;

  }
  signed int return_value_initSockAddress_2;
  return_value_initSockAddress_2=initSockAddress((enum addr_type_t)ADDR_TYPE_MCAST, (struct net_if *)(void *)0, ip.s_addr, (unsigned short int)port, addr);
  return return_value_initSockAddress_2;
}

// udpc_getMyAddress
// file socklib.c line 245
signed int udpc_getMyAddress(struct net_if *net_if, struct sockaddr_in *addr)
{
  signed int return_value_initSockAddress_1;
  return_value_initSockAddress_1=initSockAddress((enum addr_type_t)ADDR_TYPE_UCAST, net_if, (unsigned int)0x00000000, (unsigned short int)0, addr);
  return return_value_initSockAddress_1;
}

// udpc_getNetIf
// file socklib.c line 557
struct net_if * udpc_getNetIf(const char *wanted)
{
  struct ifreq *ifrp;
  struct ifreq *ifend;
  struct ifreq *chosen;
  struct ifconf ifc;
  signed int s;
  signed int lastGoodness = 0;
  struct in_addr wantedAddress;
  signed int isAddress = 0;
  signed int wantedLen = 0;
  struct net_if *net_if;
  if(wanted == ((const char *)NULL))
    wanted=getenv("IFNAME");

  _Bool tmp_if_expr_2;
  signed int return_value_INET_ATON_1;
  if(!(wanted == ((const char *)NULL)))
  {
    return_value_INET_ATON_1=INET_ATON(wanted, &wantedAddress);
    tmp_if_expr_2 = return_value_INET_ATON_1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    isAddress = 1;

  else
    wantedAddress.s_addr = (unsigned int)0;
  unsigned long int return_value_strlen_3;
  if(!(wanted == ((const char *)NULL)))
  {
    return_value_strlen_3=strlen(wanted);
    wantedLen = (signed int)return_value_strlen_3;
  }

  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct net_if) /*24ul*/ );
  net_if = (struct net_if *)return_value_calloc_4;
  if(net_if == ((struct net_if *)NULL))
    udpc_fatal(1, "Out of memory error");

  s=socket(2, 2, 0);
  if(!(s >= 0))
  {
    perror("make socket");
    exit(1);
  }

  ifc.ifc_len = (signed int)(sizeof(struct ifreq) /*40ul*/  * (unsigned long int)10);
  while((_Bool)1)
  {
    signed int len = ifc.ifc_len;
    void *return_value_malloc_5;
    return_value_malloc_5=malloc((unsigned long int)ifc.ifc_len);
    ifc.ifc_ifcu.ifcu_buf = (char *)return_value_malloc_5;
    if(ifc.ifc_ifcu.ifcu_buf == ((char *)NULL))
      udpc_fatal(1, "Out of memory error");

    signed int return_value_ioctl_6;
    return_value_ioctl_6=ioctl(s, (unsigned long int)0x8912, (char *)&ifc);
    if(!(ifc.ifc_len >= (signed int)sizeof(struct ifreq) /*40*/ ) || !(return_value_ioctl_6 >= 0))
    {
      perror("udpcast: SIOCGIFCONF: ");
      exit(1);
    }

    if(len == ifc.ifc_len)
    {
      ifc.ifc_len = ifc.ifc_len + (signed int)(sizeof(struct ifreq) /*40ul*/  * (unsigned long int)10);
      free((void *)ifc.ifc_ifcu.ifcu_buf);
    }

    else
      break;
  }
  ifend = (struct ifreq *)((char *)ifc.ifc_ifcu.ifcu_buf + (signed long int)ifc.ifc_len);
  chosen = (struct ifreq *)(void *)0;
  ifrp = (struct ifreq *)ifc.ifc_ifcu.ifcu_buf;
  signed int tmp_statement_expression_9;
  _Bool tmp_if_expr_8;
  signed int return_value_strncmp_7;
  unsigned int return_value___bswap_32_20;
  signed int tmp_statement_expression_15;
  _Bool tmp_if_expr_19;
  signed int tmp_statement_expression_17;
  signed int return_value_strncmp_14;
  signed int return_value_strncmp_11;
  _Bool tmp_if_expr_13;
  signed int return_value_strncmp_12;
  signed int *return_value___errno_location_22;
  char *return_value_strerror_23;
  for( ; !(ifrp >= ifend); ifrp = ifrp + 1l)
  {
    unsigned long int iaddr = (unsigned long int)((struct sockaddr_in *)&ifrp->ifr_ifru.ifru_addr)->sin_addr.s_addr;
    signed int goodness;
    if((signed int)ifrp->ifr_ifru.ifru_addr.sa_family == 2)
    {
      if(!(wanted == ((const char *)NULL)))
      {
        if(iaddr == (unsigned long int)wantedAddress.s_addr && !(isAddress == 0))
          goodness = 8;

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp_10;
          return_value___builtin_strcmp_10=__builtin_strcmp(wanted, ifrp->ifr_ifrn.ifrn_name);
          tmp_statement_expression_9 = return_value___builtin_strcmp_10;
          if(tmp_statement_expression_9 == 0)
            goodness = 12;

          else
          {
            if(!(wanted == ((const char *)NULL)))
            {
              return_value_strncmp_7=strncmp(wanted, ifrp->ifr_ifrn.ifrn_name, (unsigned long int)wantedLen);
              tmp_if_expr_8 = return_value_strncmp_7 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_8 = (_Bool)0;
            if(tmp_if_expr_8)
              goodness = 7;

            else
              goto __CPROVER_DUMP_L40;
          }
        }
      }

      else
        if(iaddr == 0ul)
          goodness = 1;

        else
        {
          return_value___bswap_32_20=__bswap_32((unsigned int)0x7f000001);
          if(iaddr == (unsigned long int)return_value___bswap_32_20)
            goodness = 2;

          else
          {
            unsigned long int udpc_getNetIf__1__4__1__2__3____s1_len;
            unsigned long int udpc_getNetIf__1__4__1__2__3____s2_len;
            signed int return_value___builtin_strcmp_16;
            return_value___builtin_strcmp_16=__builtin_strcmp("eth0", ifrp->ifr_ifrn.ifrn_name);
            tmp_statement_expression_15 = return_value___builtin_strcmp_16;
            if(tmp_statement_expression_15 == 0)
              tmp_if_expr_19 = (_Bool)1;

            else
            {
              unsigned long int udpc_getNetIf__1__4__1__2__4____s1_len;
              unsigned long int udpc_getNetIf__1__4__1__2__4____s2_len;
              signed int return_value___builtin_strcmp_18;
              return_value___builtin_strcmp_18=__builtin_strcmp("en0", ifrp->ifr_ifrn.ifrn_name);
              tmp_statement_expression_17 = return_value___builtin_strcmp_18;
              tmp_if_expr_19 = tmp_statement_expression_17 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_19)
              goodness = 6;

            else
            {
              return_value_strncmp_14=strncmp("eth0:", ifrp->ifr_ifrn.ifrn_name, (unsigned long int)5);
              if(return_value_strncmp_14 == 0)
                goodness = 5;

              else
              {
                return_value_strncmp_11=strncmp("eth", ifrp->ifr_ifrn.ifrn_name, (unsigned long int)3);
                if(return_value_strncmp_11 == 0)
                  tmp_if_expr_13 = (_Bool)1;

                else
                {
                  return_value_strncmp_12=strncmp("en", ifrp->ifr_ifrn.ifrn_name, (unsigned long int)2);
                  tmp_if_expr_13 = return_value_strncmp_12 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_13)
                  goodness = 4;

                else
                  goodness = 3;
              }
            }
          }
        }
      signed int return_value_hasLink_21;
      return_value_hasLink_21=hasLink(s, ifrp->ifr_ifrn.ifrn_name);
      if(!(return_value_hasLink_21 == 0))
        goodness = goodness + 3;

      goodness = goodness * 2;
      if(goodness >= lastGoodness)
      {
        signed int return_value_ioctl_24;
        return_value_ioctl_24=ioctl(s, (unsigned long int)0x8919, ifrp);
        if(!(return_value_ioctl_24 >= 0))
        {
          return_value___errno_location_22=__errno_location();
          return_value_strerror_23=strerror(*return_value___errno_location_22);
          udpc_fatal(-1, "Error getting broadcast address for %s: %s", (const void *)ifrp->ifr_ifrn.ifrn_name, return_value_strerror_23);
        }

        if(!(((struct sockaddr_in *)&ifrp->ifr_ifru.ifru_broadaddr)->sin_addr.s_addr == 0u))
          goodness = goodness + 1;

      }

      if(!(lastGoodness >= goodness))
      {
        chosen = ifrp;
        lastGoodness = goodness;
        net_if->addr.s_addr = (unsigned int)iaddr;
      }

    }


  __CPROVER_DUMP_L40:
    ;
  }
  if(chosen == ((struct ifreq *)NULL))
  {
    fprintf(stderr, "No suitable network interface found\n");
    fprintf(stderr, "The following interfaces are available:\n");
    ifrp = (struct ifreq *)ifc.ifc_ifcu.ifcu_buf;
    for( ; !(ifrp >= ifend); ifrp = ifrp + 1l)
    {
      char buffer[16l];
      if((signed int)ifrp->ifr_ifru.ifru_addr.sa_family == 2)
      {
        char *return_value_udpc_getIpString_25;
        return_value_udpc_getIpString_25=udpc_getIpString((struct sockaddr_in *)&ifrp->ifr_ifru.ifru_addr, buffer);
        fprintf(stderr, "\t%s\t%s\n", (const void *)ifrp->ifr_ifrn.ifrn_name, return_value_udpc_getIpString_25);
      }

    }
    exit(1);
  }

  char *return_value___strdup_26;
  return_value___strdup_26=__strdup(chosen->ifr_ifrn.ifrn_name);
  net_if->name = return_value___strdup_26;
  signed int return_value_ioctl_29;
  return_value_ioctl_29=ioctl(s, (unsigned long int)0x8933, chosen);
  signed int *return_value___errno_location_27;
  char *return_value_strerror_28;
  if(!(return_value_ioctl_29 >= 0))
  {
    return_value___errno_location_27=__errno_location();
    return_value_strerror_28=strerror(*return_value___errno_location_27);
    udpc_fatal(-1, "Error getting index for %s: %s", net_if->name, return_value_strerror_28);
  }

  net_if->index = chosen->ifr_ifru.ifru_ivalue;
  signed int return_value_ioctl_32;
  return_value_ioctl_32=ioctl(s, (unsigned long int)0x8919, chosen);
  signed int *return_value___errno_location_30;
  char *return_value_strerror_31;
  if(!(return_value_ioctl_32 >= 0))
  {
    return_value___errno_location_30=__errno_location();
    return_value_strerror_31=strerror(*return_value___errno_location_30);
    udpc_fatal(-1, "Error getting broadcast address for %s: %s", net_if->name, return_value_strerror_31);
  }

  net_if->bcast = ((struct sockaddr_in *)&chosen->ifr_ifru.ifru_broadaddr)->sin_addr;
  close(s);
  free((void *)ifc.ifc_ifcu.ifcu_buf);
  return net_if;
}

// udpc_getPort
// file socklib.c line 981
unsigned short int udpc_getPort(struct sockaddr_in *addr)
{
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)((struct sockaddr_in *)addr)->sin_port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  return tmp_statement_expression_1;
}

// udpc_getRcvBuf
// file socklib.c line 334
unsigned int udpc_getRcvBuf(signed int sock)
{
  unsigned int bufsize;
  unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(sock, 1, 8, (void *)(char *)&bufsize, &len);
  if(!(return_value_getsockopt_1 >= 0))
    return (unsigned int)-1;

  else
    return bufsize;
}

// udpc_getSelectedSock
// file socklib.c line 1089
signed int udpc_getSelectedSock(signed int *socks, signed int nr, struct anonymous_1 *read_set)
{
  signed int i = 0;
  for( ; !(i >= nr); i = i + 1)
    if(!(socks[(signed long int)i] == -1))
    {
      if(!((read_set->__fds_bits[(signed long int)(socks[(signed long int)i] / 8)] & (signed long int)(1UL << socks[(signed long int)i] % 8)) == 0l))
        return socks[(signed long int)i];

    }

  return -1;
}

// udpc_getSendBuf
// file socklib.c line 321
signed int udpc_getSendBuf(signed int sock)
{
  signed int bufsize;
  unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  signed int return_value_getsockopt_1;
  return_value_getsockopt_1=getsockopt(sock, 1, 7, (void *)(char *)&bufsize, &len);
  if(!(return_value_getsockopt_1 >= 0))
    return -1;

  else
    return bufsize;
}

// udpc_initFifo
// file fifo.h line 20
void udpc_initFifo(struct fifo *fifo, signed int blockSize)
{
  fifo->dataBufSize = (unsigned int)(blockSize * 4096);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(fifo->dataBufSize + (unsigned int)4096));
  fifo->dataBuffer = (unsigned char *)return_value_malloc_1;
  fifo->dataBuffer = fifo->dataBuffer + (signed long int)((unsigned long int)4096 - (unsigned long int)fifo->dataBuffer % (unsigned long int)4096);
  fifo->freeMemQueue=pc_makeProduconsum((signed int)fifo->dataBufSize, "free mem");
  pc_produce(fifo->freeMemQueue, fifo->dataBufSize);
  fifo->data=pc_makeProduconsum((signed int)fifo->dataBufSize, "receive");
}

// udpc_ipIsEqual
// file socklib.c line 973
signed int udpc_ipIsEqual(struct sockaddr_in *left, struct sockaddr_in *right)
{
  return (signed int)(((struct sockaddr_in *)left)->sin_addr.s_addr == ((struct sockaddr_in *)right)->sin_addr.s_addr);
}

// udpc_ipIsZero
// file socklib.c line 977
signed int udpc_ipIsZero(struct sockaddr_in *ip)
{
  return (signed int)(((struct sockaddr_in *)ip)->sin_addr.s_addr == (unsigned int)0);
}

// udpc_isAddressEqual
// file socklib.c line 1022
signed int udpc_isAddressEqual(struct sockaddr_in *a, struct sockaddr_in *b)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)(char *)a, (const void *)(char *)b, (unsigned long int)8);
  return (signed int)!(return_value_memcmp_1 != 0);
}

// udpc_isFullDuplex
// file socklib.c line 523
signed int udpc_isFullDuplex(signed int s, const char *ifname)
{
  struct ifreq ifr;
  struct ethtool_cmd ecmd;
  ecmd.cmd = (unsigned int)0x00000001;
  __builtin_strncpy(ifr.ifr_ifrn.ifrn_name, ifname, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  ifr.ifr_ifru.ifru_data = (char *)&ecmd;
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(s, (unsigned long int)0x8946, &ifr);
  if(return_value_ioctl_1 == -1)
    return -1;

  else
    return (signed int)ecmd.duplex;
}

// udpc_logprintf
// file log.c line 25
signed int udpc_logprintf(struct _IO_FILE *logfile, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  signed int return_value_vlogprintf_1;
  return_value_vlogprintf_1=vlogprintf(logfile, fmt, ap);
  return return_value_vlogprintf_1;
}

// udpc_makeSockAddr
// file socklib.c line 174
signed int udpc_makeSockAddr(char *hostname, signed short int port, struct sockaddr_in *addr)
{
  struct hostent *host;
  memset((void *)(char *)addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  if(!(hostname == ((char *)NULL)))
  {
    if(!(*hostname == 0))
    {
      char *inaddr;
      signed int len;
      host=gethostbyname(hostname);
      if(host == ((struct hostent *)NULL))
        udpc_fatal(1, "Unknown host %s\n", hostname);

      inaddr = host->h_addr_list[(signed long int)0];
      len = host->h_length;
      memcpy((void *)&((struct sockaddr_in *)addr)->sin_addr, (const void *)inaddr, (unsigned long int)len);
    }

  }

  ((struct sockaddr_in *)addr)->sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  ((struct sockaddr_in *)addr)->sin_port = tmp_statement_expression_1;
  return 0;
}

// udpc_makeSocket
// file socklib.c line 899
signed int udpc_makeSocket(enum addr_type_t addr_type, struct net_if *net_if, struct sockaddr_in *tmpl, signed int port)
{
  signed int ret;
  signed int s;
  struct sockaddr_in myaddr;
  unsigned int ip = (unsigned int)0;
  s=socket(2, 2, 0);
  if(!(s >= 0))
  {
    perror("make socket");
    exit(1);
  }

  if((signed int)addr_type == ADDR_TYPE_MCAST && !(tmpl == ((struct sockaddr_in *)NULL)))
    ip = tmpl->sin_addr.s_addr;

  ret=initSockAddress(addr_type, net_if, ip, (unsigned short int)port, &myaddr);
  if(!(ret >= 0))
    udpc_fatal(1, "Could not get socket address fot %d/%s", addr_type, net_if->name);

  if(myaddr.sin_addr.s_addr == 0u && (signed int)addr_type == ADDR_TYPE_BCAST)
  {
    close(s);
    return -1;
  }

  else
  {
    ret=bind(s, (struct sockaddr *)&myaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(ret >= 0))
    {
      char buffer[16l];
      char *return_value_udpc_getIpString_1;
      return_value_udpc_getIpString_1=udpc_getIpString(&myaddr, buffer);
      unsigned short int return_value_udpc_getPort_2;
      return_value_udpc_getPort_2=udpc_getPort(&myaddr);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(*return_value___errno_location_3);
      udpc_fatal(1, "bind socket to %s:%d (%s)\n", return_value_udpc_getIpString_1, return_value_udpc_getPort_2, return_value_strerror_4);
    }

    if((signed int)addr_type == ADDR_TYPE_MCAST)
      mcastListen(s, net_if, &myaddr);

    return s;
  }
}

// udpc_parseCommand
// file udpcast.c line 7
signed int udpc_parseCommand(char *pipeName, char **arg)
{
  char *ptr;
  signed int i;
  signed int haveSpace = 1;
  i = 0;
  ptr = pipeName;
  signed int tmp_post_1;
  for( ; !(*ptr == 0); ptr = ptr + 1l)
  {
    if((signed int)*ptr == 32)
    {
      haveSpace = 1;
      *ptr = (char)0;
    }

    else
      if(!(haveSpace == 0))
      {
        tmp_post_1 = i;
        i = i + 1;
        arg[(signed long int)tmp_post_1] = ptr;
        haveSpace = 0;
      }

    if(i == 256)
      udpc_fatal(1, "Too many arguments for pipe command\n");

  }
  arg[(signed long int)i] = ((char *)NULL);
  return 0;
}

// udpc_parseSize
// file socklib.h line 185
unsigned long int udpc_parseSize(char *sizeString)
{
  char *eptr;
  unsigned long int size;
  size=strtoul(sizeString, &eptr, 10);
  if(!(eptr == ((char *)NULL)))
  {
    if(!(*eptr == 0))
      switch((signed int)*eptr)
      {
        case 109:

        case 77:
        {
          size = size * (unsigned long int)(1024 * 1024);
          break;
        }
        case 107:

        case 75:
        {
          size = size * (unsigned long int)1024;
          break;
        }
        case 0:
          break;
        default:
          udpc_fatal(1, "Unit %c unsupported\n", *eptr);
      }

  }

  return size;
}

// udpc_prepareConsole
// file console.h line 20
struct console_t * udpc_prepareConsole(signed int fd)
{
  struct termios newtio;
  signed int needClose = 0;
  struct console_t *c;
  if(!(fd >= 0))
  {
    fd=open("/dev/tty", 02);
    if(!(fd >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      fprintf(stderr, "Could not open keyboard: %s\n", return_value_strerror_2);
      return (struct console_t *)(void *)0;
    }

    needClose = 1;
  }

  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct console_t) /*72ul*/ );
  c = (struct console_t *)return_value_calloc_3;
  if(c == ((struct console_t *)NULL))
    return c;

  else
  {
    c->fd = fd;
    c->needClose = needClose;
    c->needRestore = 0;
    signed int return_value_tcgetattr_5;
    return_value_tcgetattr_5=tcgetattr(c->fd, &c->oldtio);
    if(return_value_tcgetattr_5 >= 0)
    {
      newtio = c->oldtio;
      newtio.c_lflag = newtio.c_lflag & (unsigned int)~0000010;
      newtio.c_lflag = newtio.c_lflag & (unsigned int)~0000002;
      newtio.c_cc[(signed long int)6] = (unsigned char)1;
      newtio.c_cc[(signed long int)5] = (unsigned char)0;
      signed int return_value_tcsetattr_4;
      return_value_tcsetattr_4=tcsetattr(c->fd, 2, &newtio);
      if(!(return_value_tcsetattr_4 >= 0))
        perror("Set terminal to raw");

      else
        c->needRestore = 1;
    }

    return c;
  }
}

// udpc_prepareForSelect
// file socklib.c line 1074
signed int udpc_prepareForSelect(signed int *socks, signed int nr, struct anonymous_1 *read_set)
{
  signed int i;
  signed int maxFd;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&read_set->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  maxFd = -1;
  i = 0;
  for( ; !(i >= nr); i = i + 1)
    if(!(socks[(signed long int)i] == -1))
    {
      read_set->__fds_bits[(signed long int)(socks[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = read_set->__fds_bits[(signed long int)(socks[(signed long int)i] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << socks[(signed long int)i] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(maxFd >= socks[(signed long int)i]))
        maxFd = socks[(signed long int)i];

    }

  return maxFd;
}

// udpc_printLongNum
// file log.c line 96
signed int udpc_printLongNum(unsigned long long int x)
{
  signed long long int divisor;
  signed long long int minDivisor;
  signed int nonzero;
  char suffix = (char)32;
  if(x >= 1000000000001ul)
  {
    minDivisor = 1048576L;
    suffix = (char)77;
  }

  else
    if(x >= 1000000000ul)
    {
      minDivisor = 1024L;
      suffix = (char)75;
    }

    else
    {
      minDivisor = (signed long long int)1;
      suffix = (char)32;
    }
  divisor = minDivisor * 1000000LL;
  nonzero = 0;
  while(divisor >= minDivisor)
  {
    signed int digits;
    const char *format;
    digits = (signed int)((x / (unsigned long int)divisor) % (unsigned long int)1000);
    if(!(nonzero == 0))
      format = "%03d";

    else
      format = "%3d";
    if(!(digits == 0) || !(nonzero == 0))
      fprintf(stderr, format, digits);

    else
      fprintf(stderr, "    ");
    if(!(digits == 0))
      nonzero = 1;

    divisor = divisor / (signed long int)1000;
    if(divisor >= minDivisor)
      fprintf(stderr, " ");

    else
      fprintf(stderr, "%c", suffix);
  }
  needNewline = 1;
  return 0;
}

// udpc_printMyIp
// file socklib.c line 954
void udpc_printMyIp(struct net_if *net_if)
{
  char buffer[16l];
  struct sockaddr_in myaddr;
  udpc_getMyAddress(net_if, &myaddr);
  char *return_value_udpc_getIpString_1;
  return_value_udpc_getIpString_1=udpc_getIpString(&myaddr, buffer);
  udpc_flprintf("%s", return_value_udpc_getIpString_1);
}

// udpc_receiverStatsAddBytes
// file statistics.h line 17
void udpc_receiverStatsAddBytes(struct receiver_stats *rs, signed long int bytes)
{
  if(!(rs == ((struct receiver_stats *)NULL)))
    rs->totalBytes = rs->totalBytes + bytes;

}

// udpc_receiverStatsStartTimer
// file statistics.h line 16
void udpc_receiverStatsStartTimer(struct receiver_stats *rs)
{
  if(!(rs == ((struct receiver_stats *)NULL)))
  {
    if(rs->timerStarted == 0)
    {
      gettimeofday(&rs->tv_start, ((struct timezone *)NULL));
      rs->timerStarted = 1;
    }

  }

}

// udpc_restoreConsole
// file console.h line 34
void udpc_restoreConsole(struct console_t **cp, signed int doConsume)
{
  struct console_t *c = *cp;
  signed int ch = 0;
  signed int r;
  signed int return_value_tcsetattr_2;
  if(!(c == ((struct console_t *)NULL)))
  {
    if(!(doConsume == 0))
    {
      signed long int return_value_read_1;
      return_value_read_1=read(c->fd, (void *)&ch, (unsigned long int)1);
      r = (signed int)return_value_read_1;
    }

    if(!(c->needRestore == 0))
    {
      return_value_tcsetattr_2=tcsetattr(c->fd, 2, &c->oldtio);
      if(!(return_value_tcsetattr_2 >= 0))
        perror("Restore terminal settings");

    }

    *cp = (struct console_t *)(void *)0;
    if(!(c->needClose == 0))
      close(c->fd);

    free((void *)c);
    if(ch == 113)
      exit(1);

  }

}

// udpc_selectSock
// file socklib.c line 1055
signed int udpc_selectSock(signed int *socks, signed int nr, signed int startTimeout)
{
  struct anonymous_1 read_set;
  signed int r;
  signed int maxFd;
  struct timeval tv;
  struct timeval *tvp;
  if(!(startTimeout == 0))
  {
    tv.tv_sec = (signed long int)startTimeout;
    tv.tv_usec = (signed long int)0;
    tvp = &tv;
  }

  else
    tvp = (struct timeval *)(void *)0;
  maxFd=udpc_prepareForSelect(socks, nr, &read_set);
  r=select(maxFd + 1, &read_set, (struct anonymous_1 *)(void *)0, (struct anonymous_1 *)(void *)0, tvp);
  if(!(r >= 0))
    return r;

  else
  {
    signed int return_value_udpc_getSelectedSock_1;
    return_value_udpc_getSelectedSock_1=udpc_getSelectedSock(socks, nr, &read_set);
    return return_value_udpc_getSelectedSock_1;
  }
}

// udpc_sendDisconnect
// file udpr-negotiate.c line 65
void udpc_sendDisconnect(signed int exitStatus, struct client_config *client_config)
{
  struct disconnect disconnect;
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)4;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  disconnect.opCode = tmp_statement_expression_1;
  disconnect.reserved = (signed short int)0;
  udpc_doSend(client_config->socks[(signed long int)0], (void *)&disconnect, sizeof(struct disconnect) /*4ul*/ , &client_config->serverAddr);
  if(exitStatus == 0)
    udpc_flprintf("Transfer complete.\a\n");

}

// udpc_sendGo
// file udp-receiver.h line 42
signed int udpc_sendGo(struct client_config *client_config)
{
  struct go go;
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)2;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  go.opCode = tmp_statement_expression_1;
  go.reserved = (signed short int)0;
  signed int return_value_udpc_doSend_2;
  return_value_udpc_doSend_2=udpc_doSend(client_config->socks[(signed long int)0], (void *)&go, sizeof(struct go) /*4ul*/ , &client_config->serverAddr);
  return return_value_udpc_doSend_2;
}

// udpc_senderSetAnswered
// file statistics.c line 268
void udpc_senderSetAnswered(struct sender_stats *ss, signed int clNo)
{
  if(!(ss == ((struct sender_stats *)NULL)))
    ss->clNo = clNo;

}

// udpc_senderStatsAddBytes
// file statistics.c line 207
void udpc_senderStatsAddBytes(struct sender_stats *ss, signed long int bytes)
{
  if(!(ss == ((struct sender_stats *)NULL)))
  {
    ss->totalBytes = ss->totalBytes + (unsigned long long int)bytes;
    if(!(ss->bwPeriod == 0l))
    {
      double tdiff;
      double bw;
      struct timeval tv;
      gettimeofday(&tv, ((struct timezone *)NULL));
      ss->periodBytes = ss->periodBytes + (unsigned long int)bytes;
      if(tv.tv_sec + -ss->periodStart.tv_sec >= -1l + ss->bwPeriod)
      {
        tdiff = ((double)(tv.tv_sec - ss->periodStart.tv_sec) * 1000000.0 + (double)tv.tv_usec) - (double)ss->periodStart.tv_usec;
        if(!(tdiff < (double)ss->bwPeriod * 1000000.0))
        {
          bw = ((double)ss->periodBytes * 8.0) / tdiff;
          ss->periodBytes = (unsigned long int)0;
          ss->periodStart = tv;
          udpc_logprintf(ss->log, "Inst BW=%f\n", bw);
          fflush(ss->log);
        }

      }

    }

  }

}

// udpc_senderStatsAddRetransmissions
// file statistics.c line 231
void udpc_senderStatsAddRetransmissions(struct sender_stats *ss, signed int retransmissions)
{
  if(!(ss == ((struct sender_stats *)NULL)))
  {
    ss->retransmissions = ss->retransmissions + (unsigned long long int)retransmissions;
    udpc_logprintf(ss->log, "RETX %9lld %4d\n", ss->retransmissions, retransmissions);
  }

}

// udpc_setIpFromString
// file socklib.c line 995
void udpc_setIpFromString(struct sockaddr_in *addr, char *ip)
{
  safe_inet_aton(ip, &addr->sin_addr);
  addr->sin_family = (unsigned short int)2;
}

// udpc_setMcastDestination
// file socklib.c line 424
signed int udpc_setMcastDestination(signed int sock, struct net_if *net_if, struct sockaddr_in *addr)
{
  signed int return_value_mcastOp_1;
  return_value_mcastOp_1=mcastOp(sock, net_if, ((struct sockaddr_in *)addr)->sin_addr, 32, "Set multicast send interface");
  return return_value_mcastOp_1;
}

// udpc_setPort
// file socklib.c line 985
void udpc_setPort(struct sockaddr_in *addr, unsigned short int port)
{
  unsigned short int tmp_statement_expression_1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)port;
  asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression_1 = __v;
  ((struct sockaddr_in *)addr)->sin_port = tmp_statement_expression_1;
}

// udpc_setRcvBuf
// file socklib.c line 342
void udpc_setRcvBuf(signed int sock, unsigned int bufsize)
{
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 1, 8, (const void *)(char *)&bufsize, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_setsockopt_1 >= 0))
    perror("Set receiver buffer");

}

// udpc_setSendBuf
// file socklib.c line 329
void udpc_setSendBuf(signed int sock, unsigned int bufsize)
{
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 1, 7, (const void *)(char *)&bufsize, (unsigned int)sizeof(unsigned int) /*4ul*/ );
  if(!(return_value_setsockopt_1 >= 0))
    perror("Set send buffer");

}

// udpc_setSocketToBroadcast
// file socklib.c line 348
signed int udpc_setSocketToBroadcast(signed int sock)
{
  signed int p = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 1, 6, (const void *)(char *)&p, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// udpc_setTtl
// file socklib.c line 354
signed int udpc_setTtl(signed int sock, signed int ttl)
{
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(sock, 0, 33, (const void *)(char *)&ttl, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// udpc_shouldPrintUncompressedPos
// file udpcast.h line 125
signed int udpc_shouldPrintUncompressedPos(signed int deflt, signed int fd, signed int ref)
{
  if(!(deflt == -1))
    return deflt;

  else
    if(ref == fd)
      return 0;

    else
    {
      signed long int offset;
      offset=lseek64(fd, (signed long int)0, 1);
      if(!(offset == -1l))
        return 1;

      else
        return 0;
    }
}

// udpc_spawnNetReceiver
// file receivedata.c line 1178
signed int udpc_spawnNetReceiver(struct fifo *fifo, struct client_config *client_config, struct net_config *net_config, struct receiver_stats *stats)
{
  signed int i;
  struct clientState *clst;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct clientState) /*70664ul*/ );
  clst = (struct clientState *)return_value_calloc_1;
  clst->fifo = fifo;
  clst->client_config = client_config;
  clst->net_config = net_config;
  clst->stats = stats;
  clst->endReached = 0;
  clst->netEndReached = 0;
  clst->selectedFd = -1;
  clst->free_slices_pc=pc_makeProduconsum(4, "free slices");
  pc_produce(clst->free_slices_pc, (unsigned int)4);
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    clst->slices[(signed long int)i].state = (volatile enum slice_state)SLICE_FREE;
    clst->slices[(signed long int)i].sliceNo = -1;
  }
  clst->receivedPtr = 0;
  clst->receivedSliceNo = -1;
  fec_init();
  clst->use_fec = 0;
  clst->fec_data_pc=pc_makeProduconsum(4, "fec data");
  clst->freeBlocks_pc=pc_makeProduconsum(4096, "free blocks");
  pc_produce(clst->freeBlocks_pc, (unsigned int)4096);
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)4096, sizeof(char *) /*8ul*/ );
  clst->blockAddresses = (unsigned char **)return_value_calloc_2;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)4096, sizeof(char *) /*8ul*/ );
  clst->localBlockAddresses = (unsigned char **)return_value_calloc_3;
  void *return_value_malloc_4;
  return_value_malloc_4=malloc((unsigned long int)(4096 * net_config->blockSize));
  clst->blockData = (unsigned char *)return_value_malloc_4;
  i = 0;
  for( ; !(i >= 4096); i = i + 1)
    clst->blockAddresses[(signed long int)i] = clst->blockData + (signed long int)(i * net_config->blockSize);
  clst->localPos = 0;
  setNextBlock(clst);
  signed int return_value_pthread_create_5;
  return_value_pthread_create_5=pthread_create(&client_config->thread, (const union pthread_attr_t *)(void *)0, netReceiverMain, (void *)clst);
  return return_value_pthread_create_5;
}

// udpc_startReceiver
// file udp-receiver.h line 44
signed int udpc_startReceiver(signed int doWarn, struct disk_config *disk_config, struct net_config *net_config, struct stat_config *stat_config, const char *ifName)
{
  char ipBuffer[16l];
  union serverControlMsg Msg;
  signed int connectReqSent = 0;
  struct client_config client_config;
  signed int outFile = 1;
  signed int pipedOutFile;
  struct sockaddr_in myIp;
  signed int pipePid = 0;
  signed int origOutFile;
  signed int haveServerAddress;
  signed int ret = 0;
  client_config.sender_is_newgen = 0;
  net_config->net_if=udpc_getNetIf(ifName);
  udpc_zeroSockArray(client_config.socks, 4);
  client_config.socks[(signed long int)0]=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_UCAST, net_config->net_if, ((struct sockaddr_in *)NULL), net_config->portBase);
  client_config.socks[(signed long int)1]=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_BCAST, net_config->net_if, ((struct sockaddr_in *)NULL), net_config->portBase);
  _Bool tmp_if_expr_2;
  if(net_config->ttl == 1)
    tmp_if_expr_2 = net_config->mcastRdv == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    udpc_getBroadCastAddress(net_config->net_if, &net_config->controlMcastAddr, (signed short int)(net_config->portBase + 1));
    udpc_setSocketToBroadcast(client_config.socks[(signed long int)0]);
  }

  else
  {
    udpc_getMcastAllAddress(&net_config->controlMcastAddr, net_config->mcastRdv, (signed short int)(net_config->portBase + 1));
    signed int return_value_isMcastAddress_1;
    return_value_isMcastAddress_1=isMcastAddress(&net_config->controlMcastAddr);
    if(!(return_value_isMcastAddress_1 == 0))
    {
      udpc_setMcastDestination(client_config.socks[(signed long int)0], net_config->net_if, &net_config->controlMcastAddr);
      udpc_setTtl(client_config.socks[(signed long int)0], net_config->ttl);
      client_config.socks[(signed long int)2]=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_MCAST, net_config->net_if, &net_config->controlMcastAddr, net_config->portBase);
    }

  }
  udpc_clearIp(&net_config->dataMcastAddr);
  char *tmp_if_expr_3;
  if(disk_config->fileName == ((const char *)NULL))
    tmp_if_expr_3 = "(stdout)";

  else
    tmp_if_expr_3 = disk_config->fileName;
  udpc_flprintf("%sUDP receiver for %s at ", disk_config->pipeName == (char *)(void *)0 ? "" : "Compressed ", tmp_if_expr_3);
  udpc_printMyIp(net_config->net_if);
  udpc_flprintf(" on %s\n", net_config->net_if->name);
  connectReqSent = 0;
  haveServerAddress = 0;
  client_config.clientNumber = 0;
  unsigned short int tmp_statement_expression_6;
  unsigned int return_value___bswap_32_7;
  unsigned int return_value___bswap_32_8;
  unsigned int return_value___bswap_32_9;
  unsigned int return_value___bswap_32_10;
  unsigned short int tmp_statement_expression_11;
  unsigned int return_value___bswap_32_14;
  unsigned short int tmp_statement_expression_12;
  unsigned short int tmp_statement_expression_15;
  while((_Bool)1)
  {
    signed int msglen;
    signed int sock;
    if(connectReqSent == 0)
    {
      signed int return_value_sendConnectReq_4;
      return_value_sendConnectReq_4=sendConnectReq(&client_config, net_config, haveServerAddress);
      if(!(return_value_sendConnectReq_4 >= 0))
        perror("sendto to locate server");

      connectReqSent = 1;
    }

    haveServerAddress = 0;
    sock=udpc_selectSock(client_config.socks, 4, net_config->startTimeout);
    if(!(sock >= 0))
      return -1;

    msglen=udpc_doReceive(sock, (void *)&Msg, sizeof(union serverControlMsg) /*32ul*/ , &client_config.serverAddr, net_config->portBase);
    if(!(msglen >= 0))
    {
      perror("recvfrom to locate server");
      exit(1);
    }

    unsigned short int return_value_udpc_getPort_5;
    return_value_udpc_getPort_5=udpc_getPort(&client_config.serverAddr);
    if((signed int)return_value_udpc_getPort_5 == 1 + net_config->portBase)
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)Msg.opCode;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_6 = __v;
      switch((signed int)tmp_statement_expression_6)
      {
        case 7:
        {
          return_value___bswap_32_7=__bswap_32_link2((unsigned int)Msg.connectReply.clNr);
          client_config.clientNumber = (signed int)return_value___bswap_32_7;
          return_value___bswap_32_8=__bswap_32_link2((unsigned int)Msg.connectReply.blockSize);
          net_config->blockSize = (signed int)return_value___bswap_32_8;
          return_value___bswap_32_9=__bswap_32_link2((unsigned int)Msg.connectReply.capabilities);
          udpc_flprintf("received message, cap=%08lx\n", (signed long int)return_value___bswap_32_9);
          return_value___bswap_32_10=__bswap_32_link2((unsigned int)Msg.connectReply.capabilities);
          if(!((1u & return_value___bswap_32_10) == 0u))
          {
            client_config.sender_is_newgen = 1;
            udpc_copyFromMessage(&net_config->dataMcastAddr, Msg.connectReply.mcastAddr);
          }

          if(client_config.clientNumber == -1)
            udpc_fatal(1, "Too many clients already connected\n");

          goto break_loop;
        }
        case 11:

        case 10:

        case 0x0500:
        {
          connectReqSent = 0;
          unsigned short int udpc_startReceiver__1__3__5__3____v;
          unsigned short int udpc_startReceiver__1__3__5__3____x = (unsigned short int)Msg.opCode;
          asm("rorw _8, %w0" : "=r"(udpc_startReceiver__1__3__5__3____v) : "0"(udpc_startReceiver__1__3__5__3____x) : "cc");
          tmp_statement_expression_11 = udpc_startReceiver__1__3__5__3____v;
          if((signed int)tmp_statement_expression_11 == 11)
            net_config->flags = net_config->flags | 0x200;

          return_value___bswap_32_14=__bswap_32_link2((unsigned int)Msg.hello.capabilities);
          if(!((1u & return_value___bswap_32_14) == 0u))
          {
            client_config.sender_is_newgen = 1;
            udpc_copyFromMessage(&net_config->dataMcastAddr, Msg.hello.mcastAddr);
            unsigned short int udpc_startReceiver__1__3__5__4__1____v;
            unsigned short int udpc_startReceiver__1__3__5__4__1____x = (unsigned short int)Msg.hello.blockSize;
            asm("rorw _8, %w0" : "=r"(udpc_startReceiver__1__3__5__4__1____v) : "0"(udpc_startReceiver__1__3__5__4__1____x) : "cc");
            tmp_statement_expression_12 = udpc_startReceiver__1__3__5__4__1____v;
            net_config->blockSize = (signed int)tmp_statement_expression_12;
            unsigned int return_value___bswap_32_13;
            return_value___bswap_32_13=__bswap_32_link2((unsigned int)Msg.hello.capabilities);
            if(!((32u & return_value___bswap_32_13) == 0u))
              net_config->flags = net_config->flags | 0x0010;

            if(!((0x0010 & net_config->flags) == 0))
              goto break_loop;

          }

          haveServerAddress = 1;
          break;
        }
        case 3:

        case 8:

        case 9:
          break;
        default:
        {
          unsigned short int udpc_startReceiver__1__3__6____v;
          unsigned short int udpc_startReceiver__1__3__6____x = (unsigned short int)Msg.opCode;
          asm("rorw _8, %w0" : "=r"(udpc_startReceiver__1__3__6____v) : "0"(udpc_startReceiver__1__3__6____x) : "cc");
          tmp_statement_expression_15 = udpc_startReceiver__1__3__6____v;
          udpc_fatal(1, "Bad server reply %04x. Other transfer in progress?\n", (unsigned short int)tmp_statement_expression_15);
        }
      }
    }

  }

break_loop:
  ;
  char *return_value_udpc_getIpString_16;
  return_value_udpc_getIpString_16=udpc_getIpString(&client_config.serverAddr, ipBuffer);
  udpc_flprintf("Connected as #%d to %s\n", client_config.clientNumber, return_value_udpc_getIpString_16);
  udpc_getMyAddress(net_config->net_if, &myIp);
  signed int return_value_udpc_ipIsZero_22;
  return_value_udpc_ipIsZero_22=udpc_ipIsZero(&net_config->dataMcastAddr);
  signed int return_value_udpc_ipIsEqual_21;
  signed int return_value_udpc_ipIsZero_18;
  _Bool tmp_if_expr_20;
  signed int return_value_udpc_ipIsEqual_19;
  if(return_value_udpc_ipIsZero_22 == 0)
  {
    return_value_udpc_ipIsEqual_21=udpc_ipIsEqual(&net_config->dataMcastAddr, &myIp);
    if(return_value_udpc_ipIsEqual_21 == 0)
    {
      return_value_udpc_ipIsZero_18=udpc_ipIsZero(&net_config->controlMcastAddr);
      if(!(return_value_udpc_ipIsZero_18 == 0))
        tmp_if_expr_20 = (_Bool)1;

      else
      {
        return_value_udpc_ipIsEqual_19=udpc_ipIsEqual(&net_config->dataMcastAddr, &net_config->controlMcastAddr);
        tmp_if_expr_20 = !(return_value_udpc_ipIsEqual_19 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_20)
      {
        char *return_value_udpc_getIpString_17;
        return_value_udpc_getIpString_17=udpc_getIpString(&net_config->dataMcastAddr, ipBuffer);
        udpc_flprintf("Listening to multicast on %s\n", return_value_udpc_getIpString_17);
        client_config.socks[(signed long int)3]=udpc_makeSocket((enum addr_type_t)ADDR_TYPE_MCAST, net_config->net_if, &net_config->dataMcastAddr, net_config->portBase);
      }

    }

  }

  if(!(net_config->requestedBufSize == 0))
  {
    signed int i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(!(client_config.socks[(signed long int)i] == -1))
        udpc_setRcvBuf(client_config.socks[(signed long int)i], (unsigned int)net_config->requestedBufSize);

  }

  outFile=openOutFile(disk_config);
  origOutFile = outFile;
  pipedOutFile=udpcr_openPipe(outFile, disk_config, &pipePid);
  global_client_config = &client_config;
  atexit(sendDisconnectWrapper);
  struct fifo fifo;
  signed int printUncompressedPos;
  printUncompressedPos=udpc_shouldPrintUncompressedPos(stat_config->printUncompressedPos, origOutFile, pipedOutFile);
  struct receiver_stats *stats;
  stats=udpc_allocReadStats(origOutFile, (signed long int)stat_config->statPeriod, printUncompressedPos, stat_config->noProgress);
  udpc_initFifo(&fifo, net_config->blockSize);
  fifo.data=pc_makeProduconsum((signed int)fifo.dataBufSize, "receive");
  client_config.isStarted = 0;
  if(!((144 & net_config->flags) == 0))
    client_config.console = (struct console_t *)(void *)0;

  else
  {
    if(!(doWarn == 0))
      udpc_flprintf("WARNING: This will overwrite the hard disk of this machine\n");

    client_config.console=udpc_prepareConsole(0);
    atexit(fixConsole);
  }
  udpc_spawnNetReceiver(&fifo, &client_config, net_config, stats);
  udpc_writer(&fifo, pipedOutFile);
  if(!(pipePid == 0))
    close(pipedOutFile);

  pthread_join(client_config.thread, (void **)(void *)0);
  if(!(pipePid == 0))
    ret=udpc_waitForProcess(pipePid, "Pipe");

  fsync(origOutFile);
  udpc_displayReceiverStats(stats, 1);
  fixConsole();
  sendDisconnectWrapper();
  global_client_config = (struct client_config *)(void *)0;
  return ret;
}

// udpc_waitForProcess
// file udpcast.c line 59
signed int udpc_waitForProcess(signed int pid, const char *message)
{
  signed int status;
  signed int return_value_waitpid_1;
  return_value_waitpid_1=waitpid(pid, &status, 0);
  if(!(return_value_waitpid_1 >= 0))
    return 0;

  else
  {
    signed int return_value_printProcessStatus_2;
    return_value_printProcessStatus_2=printProcessStatus(message, status);
    return return_value_printProcessStatus_2;
  }
}

// udpc_writer
// file receiver-diskio.c line 20
signed int udpc_writer(struct fifo *fifo, signed int outFile)
{
  signed int fifoSize;
  unsigned int return_value_pc_getSize_1;
  return_value_pc_getSize_1=pc_getSize(fifo->data);
  fifoSize = (signed int)return_value_pc_getSize_1;
  if(!(fifoSize % 4096 == 0))
    udpc_fatal(1, "Fifo size not a multiple of block size\n");

  while((_Bool)1)
  {
    signed int pos;
    unsigned int return_value_pc_getConsumerPosition_2;
    return_value_pc_getConsumerPosition_2=pc_getConsumerPosition(fifo->data);
    pos = (signed int)return_value_pc_getConsumerPosition_2;
    signed int bytes;
    bytes=pc_consumeContiguousMinAmount(fifo->data, 4096);
    if(bytes == 0)
      return 0;

    if(!(bytes + pos == fifoSize) && !((bytes + pos) % 4096 >= bytes))
      bytes = bytes - (pos + bytes) % 4096;

    if(bytes >= 131073)
      bytes = 64 * 1024;

    signed long int return_value_write_3;
    return_value_write_3=write(outFile, (const void *)(fifo->dataBuffer + (signed long int)pos), (unsigned long int)bytes);
    bytes = (signed int)return_value_write_3;
    if(!(bytes >= 0))
    {
      perror("write");
      exit(1);
    }

    pc_consumed(fifo->data, bytes);
    pc_produce(fifo->freeMemQueue, (unsigned int)bytes);
  }
}

// udpc_zeroSockArray
// file socklib.c line 1048
void udpc_zeroSockArray(signed int *socks, signed int nr)
{
  signed int i = 0;
  for( ; !(i >= nr); i = i + 1)
    socks[(signed long int)i] = -1;
}

// udpcr_openPipe
// file receiver-diskio.c line 60
signed int udpcr_openPipe(signed int outFile, struct disk_config *disk_config, signed int *pipePid)
{
  if(!(disk_config->pipeName == ((char *)NULL)))
  {
    char *arg[256l];
    signed int filedes[2l];
    udpc_parseCommand(disk_config->pipeName, arg);
    signed int return_value_pipe_1;
    return_value_pipe_1=pipe(filedes);
    if(!(return_value_pipe_1 >= 0))
    {
      perror("pipe");
      exit(1);
    }

    *pipePid=open2(filedes[(signed long int)0], outFile, arg, filedes[(signed long int)1]);
    close(filedes[(signed long int)0]);
    outFile = filedes[(signed long int)1];
  }

  return outFile;
}

// usage
// file udp-receiver.c line 108
static void usage(char *progname)
{
  fprintf(stderr, "%s [--file file] [--pipe pipe] [--portbase portbase] [--interface net-interface] [--log file] [--no-progress] [--ttl time-to-live] [--mcast-rdv-address mcast-rdv-address] [--rcvbuf buf] [--nokbd] [--exit-wait milliseconds] [--nosync] [--sync] [--start-timeout sto] [--receive-timeout rct] [--license] [-x uncomprStatPrint] [-z statPeriod] [--print-uncompressed-position flag] [--stat-period millis] [--ignore-lost-data]\n", progname);
  exit(1);
}

// vlogprintf
// file log.c line 34
static signed int vlogprintf(struct _IO_FILE *logfile, const char *fmt, void **ap)
{
  if(!(logfile == ((struct _IO_FILE *)NULL)))
  {
    char buf[9l];
    struct timeval tv;
    signed int r;
    if(!(newlineSeen == 0))
    {
      gettimeofday(&tv, (struct timezone *)(void *)0);
      struct tm *return_value_localtime_1;
      return_value_localtime_1=localtime(&tv.tv_sec);
      strftime(buf, sizeof(char [9l]) /*9ul*/ , "%H:%M:%S", return_value_localtime_1);
      fprintf(logfile, "%s.%06ld ", (const void *)buf, tv.tv_usec);
    }

    char *return_value___builtin_strchr_2;
    return_value___builtin_strchr_2=__builtin_strchr(fmt, 10);
    newlineSeen = (signed int)(return_value___builtin_strchr_2 != (char *)(void *)0);
    r=vfprintf(logfile, fmt, ap);
    if(!(newlineSeen == 0))
      fflush(logfile);

    return r;
  }

  else
    return -1;
}

// wakeConsumer
// file produconsum.c line 39
static void wakeConsumer(struct produconsum *pc)
{
  if(!(pc->consumerIsWaiting == 0))
  {
    pthread_mutex_lock(&pc->mutex);
    pthread_cond_signal(&pc->cond);
    pthread_mutex_unlock(&pc->mutex);
  }

}

