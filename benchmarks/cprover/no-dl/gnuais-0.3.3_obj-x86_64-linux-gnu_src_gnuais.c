// #anon_enum_CURLE_OK=0_CURLE_UNSUPPORTED_PROTOCOL=1_CURLE_FAILED_INIT=2_CURLE_URL_MALFORMAT=3_CURLE_NOT_BUILT_IN=4_CURLE_COULDNT_RESOLVE_PROXY=5_CURLE_COULDNT_RESOLVE_HOST=6_CURLE_COULDNT_CONNECT=7_CURLE_FTP_WEIRD_SERVER_REPLY=8_CURLE_REMOTE_ACCESS_DENIED=9_CURLE_FTP_ACCEPT_FAILED=10_CURLE_FTP_WEIRD_PASS_REPLY=11_CURLE_FTP_ACCEPT_TIMEOUT=12_CURLE_FTP_WEIRD_PASV_REPLY=13_CURLE_FTP_WEIRD_227_FORMAT=14_CURLE_FTP_CANT_GET_HOST=15_CURLE_HTTP2=16_CURLE_FTP_COULDNT_SET_TYPE=17_CURLE_PARTIAL_FILE=18_CURLE_FTP_COULDNT_RETR_FILE=19_CURLE_OBSOLETE20=20_CURLE_QUOTE_ERROR=21_CURLE_HTTP_RETURNED_ERROR=22_CURLE_WRITE_ERROR=23_CURLE_OBSOLETE24=24_CURLE_UPLOAD_FAILED=25_CURLE_READ_ERROR=26_CURLE_OUT_OF_MEMORY=27_CURLE_OPERATION_TIMEDOUT=28_CURLE_OBSOLETE29=29_CURLE_FTP_PORT_FAILED=30_CURLE_FTP_COULDNT_USE_REST=31_CURLE_OBSOLETE32=32_CURLE_RANGE_ERROR=33_CURLE_HTTP_POST_ERROR=34_CURLE_SSL_CONNECT_ERROR=35_CURLE_BAD_DOWNLOAD_RESUME=36_CURLE_FILE_COULDNT_READ_FILE=37_CURLE_LDAP_CANNOT_BIND=38_CURLE_LDAP_SEARCH_FAILED=39_CURLE_OBSOLETE40=40_CURLE_FUNCTION_NOT_FOUND=41_CURLE_ABORTED_BY_CALLBACK=42_CURLE_BAD_FUNCTION_ARGUMENT=43_CURLE_OBSOLETE44=44_CURLE_INTERFACE_FAILED=45_CURLE_OBSOLETE46=46_CURLE_TOO_MANY_REDIRECTS=47_CURLE_UNKNOWN_OPTION=48_CURLE_TELNET_OPTION_SYNTAX=49_CURLE_OBSOLETE50=50_CURLE_PEER_FAILED_VERIFICATION=51_CURLE_GOT_NOTHING=52_CURLE_SSL_ENGINE_NOTFOUND=53_CURLE_SSL_ENGINE_SETFAILED=54_CURLE_SEND_ERROR=55_CURLE_RECV_ERROR=56_CURLE_OBSOLETE57=57_CURLE_SSL_CERTPROBLEM=58_CURLE_SSL_CIPHER=59_CURLE_SSL_CACERT=60_CURLE_BAD_CONTENT_ENCODING=61_CURLE_LDAP_INVALID_URL=62_CURLE_FILESIZE_EXCEEDED=63_CURLE_USE_SSL_FAILED=64_CURLE_SEND_FAIL_REWIND=65_CURLE_SSL_ENGINE_INITFAILED=66_CURLE_LOGIN_DENIED=67_CURLE_TFTP_NOTFOUND=68_CURLE_TFTP_PERM=69_CURLE_REMOTE_DISK_FULL=70_CURLE_TFTP_ILLEGAL=71_CURLE_TFTP_UNKNOWNID=72_CURLE_REMOTE_FILE_EXISTS=73_CURLE_TFTP_NOSUCHUSER=74_CURLE_CONV_FAILED=75_CURLE_CONV_REQD=76_CURLE_SSL_CACERT_BADFILE=77_CURLE_REMOTE_FILE_NOT_FOUND=78_CURLE_SSH=79_CURLE_SSL_SHUTDOWN_FAILED=80_CURLE_AGAIN=81_CURLE_SSL_CRL_BADFILE=82_CURLE_SSL_ISSUER_ERROR=83_CURLE_FTP_PRET_FAILED=84_CURLE_RTSP_CSEQ_ERROR=85_CURLE_RTSP_SESSION_ERROR=86_CURLE_FTP_BAD_FILE_LIST=87_CURLE_CHUNK_FAILED=88_CURLE_NO_CONNECTION_AVAILABLE=89_CURLE_SSL_PINNEDPUBKEYNOTMATCH=90_CURLE_SSL_INVALIDCERTSTATUS=91_CURL_LAST=92
// file /usr/include/curl/curl.h line 413
enum anonymous { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum_CURLINFO_NONE=0_CURLINFO_EFFECTIVE_URL=1048577_CURLINFO_RESPONSE_CODE=2097154_CURLINFO_TOTAL_TIME=3145731_CURLINFO_NAMELOOKUP_TIME=3145732_CURLINFO_CONNECT_TIME=3145733_CURLINFO_PRETRANSFER_TIME=3145734_CURLINFO_SIZE_UPLOAD=3145735_CURLINFO_SIZE_DOWNLOAD=3145736_CURLINFO_SPEED_DOWNLOAD=3145737_CURLINFO_SPEED_UPLOAD=3145738_CURLINFO_HEADER_SIZE=2097163_CURLINFO_REQUEST_SIZE=2097164_CURLINFO_SSL_VERIFYRESULT=2097165_CURLINFO_FILETIME=2097166_CURLINFO_CONTENT_LENGTH_DOWNLOAD=3145743_CURLINFO_CONTENT_LENGTH_UPLOAD=3145744_CURLINFO_STARTTRANSFER_TIME=3145745_CURLINFO_CONTENT_TYPE=1048594_CURLINFO_REDIRECT_TIME=3145747_CURLINFO_REDIRECT_COUNT=2097172_CURLINFO_PRIVATE=1048597_CURLINFO_HTTP_CONNECTCODE=2097174_CURLINFO_HTTPAUTH_AVAIL=2097175_CURLINFO_PROXYAUTH_AVAIL=2097176_CURLINFO_OS_ERRNO=2097177_CURLINFO_NUM_CONNECTS=2097178_CURLINFO_SSL_ENGINES=4194331_CURLINFO_COOKIELIST=4194332_CURLINFO_LASTSOCKET=2097181_CURLINFO_FTP_ENTRY_PATH=1048606_CURLINFO_REDIRECT_URL=1048607_CURLINFO_PRIMARY_IP=1048608_CURLINFO_APPCONNECT_TIME=3145761_CURLINFO_CERTINFO=4194338_CURLINFO_CONDITION_UNMET=2097187_CURLINFO_RTSP_SESSION_ID=1048612_CURLINFO_RTSP_CLIENT_CSEQ=2097189_CURLINFO_RTSP_SERVER_CSEQ=2097190_CURLINFO_RTSP_CSEQ_RECV=2097191_CURLINFO_PRIMARY_PORT=2097192_CURLINFO_LOCAL_IP=1048617_CURLINFO_LOCAL_PORT=2097194_CURLINFO_TLS_SESSION=4194347_CURLINFO_ACTIVESOCKET=5242924_CURLINFO_LASTONE=44
// file /usr/include/curl/curl.h line 2124
enum anonymous_0 { CURLINFO_NONE=0, CURLINFO_EFFECTIVE_URL=1048577, CURLINFO_RESPONSE_CODE=2097154, CURLINFO_TOTAL_TIME=3145731, CURLINFO_NAMELOOKUP_TIME=3145732, CURLINFO_CONNECT_TIME=3145733, CURLINFO_PRETRANSFER_TIME=3145734, CURLINFO_SIZE_UPLOAD=3145735, CURLINFO_SIZE_DOWNLOAD=3145736, CURLINFO_SPEED_DOWNLOAD=3145737, CURLINFO_SPEED_UPLOAD=3145738, CURLINFO_HEADER_SIZE=2097163, CURLINFO_REQUEST_SIZE=2097164, CURLINFO_SSL_VERIFYRESULT=2097165, CURLINFO_FILETIME=2097166, CURLINFO_CONTENT_LENGTH_DOWNLOAD=3145743, CURLINFO_CONTENT_LENGTH_UPLOAD=3145744, CURLINFO_STARTTRANSFER_TIME=3145745, CURLINFO_CONTENT_TYPE=1048594, CURLINFO_REDIRECT_TIME=3145747, CURLINFO_REDIRECT_COUNT=2097172, CURLINFO_PRIVATE=1048597, CURLINFO_HTTP_CONNECTCODE=2097174, CURLINFO_HTTPAUTH_AVAIL=2097175, CURLINFO_PROXYAUTH_AVAIL=2097176, CURLINFO_OS_ERRNO=2097177, CURLINFO_NUM_CONNECTS=2097178, CURLINFO_SSL_ENGINES=4194331, CURLINFO_COOKIELIST=4194332, CURLINFO_LASTSOCKET=2097181, CURLINFO_FTP_ENTRY_PATH=1048606, CURLINFO_REDIRECT_URL=1048607, CURLINFO_PRIMARY_IP=1048608, CURLINFO_APPCONNECT_TIME=3145761, CURLINFO_CERTINFO=4194338, CURLINFO_CONDITION_UNMET=2097187, CURLINFO_RTSP_SESSION_ID=1048612, CURLINFO_RTSP_CLIENT_CSEQ=2097189, CURLINFO_RTSP_SERVER_CSEQ=2097190, CURLINFO_RTSP_CSEQ_RECV=2097191, CURLINFO_PRIMARY_PORT=2097192, CURLINFO_LOCAL_IP=1048617, CURLINFO_LOCAL_PORT=2097194, CURLINFO_TLS_SESSION=4194347, CURLINFO_ACTIVESOCKET=5242924, CURLINFO_LASTONE=44 };

// #anon_enum_CURLOPT_WRITEDATA=10001_CURLOPT_URL=10002_CURLOPT_PORT=3_CURLOPT_PROXY=10004_CURLOPT_USERPWD=10005_CURLOPT_PROXYUSERPWD=10006_CURLOPT_RANGE=10007_CURLOPT_READDATA=10009_CURLOPT_ERRORBUFFER=10010_CURLOPT_WRITEFUNCTION=20011_CURLOPT_READFUNCTION=20012_CURLOPT_TIMEOUT=13_CURLOPT_INFILESIZE=14_CURLOPT_POSTFIELDS=10015_CURLOPT_REFERER=10016_CURLOPT_FTPPORT=10017_CURLOPT_USERAGENT=10018_CURLOPT_LOW_SPEED_LIMIT=19_CURLOPT_LOW_SPEED_TIME=20_CURLOPT_RESUME_FROM=21_CURLOPT_COOKIE=10022_CURLOPT_HTTPHEADER=10023_CURLOPT_HTTPPOST=10024_CURLOPT_SSLCERT=10025_CURLOPT_KEYPASSWD=10026_CURLOPT_CRLF=27_CURLOPT_QUOTE=10028_CURLOPT_HEADERDATA=10029_CURLOPT_COOKIEFILE=10031_CURLOPT_SSLVERSION=32_CURLOPT_TIMECONDITION=33_CURLOPT_TIMEVALUE=34_CURLOPT_CUSTOMREQUEST=10036_CURLOPT_STDERR=10037_CURLOPT_POSTQUOTE=10039_CURLOPT_OBSOLETE40=10040_CURLOPT_VERBOSE=41_CURLOPT_HEADER=42_CURLOPT_NOPROGRESS=43_CURLOPT_NOBODY=44_CURLOPT_FAILONERROR=45_CURLOPT_UPLOAD=46_CURLOPT_POST=47_CURLOPT_DIRLISTONLY=48_CURLOPT_APPEND=50_CURLOPT_NETRC=51_CURLOPT_FOLLOWLOCATION=52_CURLOPT_TRANSFERTEXT=53_CURLOPT_PUT=54_CURLOPT_PROGRESSFUNCTION=20056_CURLOPT_PROGRESSDATA=10057_CURLOPT_AUTOREFERER=58_CURLOPT_PROXYPORT=59_CURLOPT_POSTFIELDSIZE=60_CURLOPT_HTTPPROXYTUNNEL=61_CURLOPT_INTERFACE=10062_CURLOPT_KRBLEVEL=10063_CURLOPT_SSL_VERIFYPEER=64_CURLOPT_CAINFO=10065_CURLOPT_MAXREDIRS=68_CURLOPT_FILETIME=69_CURLOPT_TELNETOPTIONS=10070_CURLOPT_MAXCONNECTS=71_CURLOPT_OBSOLETE72=72_CURLOPT_FRESH_CONNECT=74_CURLOPT_FORBID_REUSE=75_CURLOPT_RANDOM_FILE=10076_CURLOPT_EGDSOCKET=10077_CURLOPT_CONNECTTIMEOUT=78_CURLOPT_HEADERFUNCTION=20079_CURLOPT_HTTPGET=80_CURLOPT_SSL_VERIFYHOST=81_CURLOPT_COOKIEJAR=10082_CURLOPT_SSL_CIPHER_LIST=10083_CURLOPT_HTTP_VERSION=84_CURLOPT_FTP_USE_EPSV=85_CURLOPT_SSLCERTTYPE=10086_CURLOPT_SSLKEY=10087_CURLOPT_SSLKEYTYPE=10088_CURLOPT_SSLENGINE=10089_CURLOPT_SSLENGINE_DEFAULT=90_CURLOPT_DNS_USE_GLOBAL_CACHE=91_CURLOPT_DNS_CACHE_TIMEOUT=92_CURLOPT_PREQUOTE=10093_CURLOPT_DEBUGFUNCTION=20094_CURLOPT_DEBUGDATA=10095_CURLOPT_COOKIESESSION=96_CURLOPT_CAPATH=10097_CURLOPT_BUFFERSIZE=98_CURLOPT_NOSIGNAL=99_CURLOPT_SHARE=10100_CURLOPT_PROXYTYPE=101_CURLOPT_ACCEPT_ENCODING=10102_CURLOPT_PRIVATE=10103_CURLOPT_HTTP200ALIASES=10104_CURLOPT_UNRESTRICTED_AUTH=105_CURLOPT_FTP_USE_EPRT=106_CURLOPT_HTTPAUTH=107_CURLOPT_SSL_CTX_FUNCTION=20108_CURLOPT_SSL_CTX_DATA=10109_CURLOPT_FTP_CREATE_MISSING_DIRS=110_CURLOPT_PROXYAUTH=111_CURLOPT_FTP_RESPONSE_TIMEOUT=112_CURLOPT_IPRESOLVE=113_CURLOPT_MAXFILESIZE=114_CURLOPT_INFILESIZE_LARGE=30115_CURLOPT_RESUME_FROM_LARGE=30116_CURLOPT_MAXFILESIZE_LARGE=30117_CURLOPT_NETRC_FILE=10118_CURLOPT_USE_SSL=119_CURLOPT_POSTFIELDSIZE_LARGE=30120_CURLOPT_TCP_NODELAY=121_CURLOPT_FTPSSLAUTH=129_CURLOPT_IOCTLFUNCTION=20130_CURLOPT_IOCTLDATA=10131_CURLOPT_FTP_ACCOUNT=10134_CURLOPT_COOKIELIST=10135_CURLOPT_IGNORE_CONTENT_LENGTH=136_CURLOPT_FTP_SKIP_PASV_IP=137_CURLOPT_FTP_FILEMETHOD=138_CURLOPT_LOCALPORT=139_CURLOPT_LOCALPORTRANGE=140_CURLOPT_CONNECT_ONLY=141_CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142_CURLOPT_CONV_TO_NETWORK_FUNCTION=20143_CURLOPT_CONV_FROM_UTF8_FUNCTION=20144_CURLOPT_MAX_SEND_SPEED_LARGE=30145_CURLOPT_MAX_RECV_SPEED_LARGE=30146_CURLOPT_FTP_ALTERNATIVE_TO_USER=10147_CURLOPT_SOCKOPTFUNCTION=20148_CURLOPT_SOCKOPTDATA=10149_CURLOPT_SSL_SESSIONID_CACHE=150_CURLOPT_SSH_AUTH_TYPES=151_CURLOPT_SSH_PUBLIC_KEYFILE=10152_CURLOPT_SSH_PRIVATE_KEYFILE=10153_CURLOPT_FTP_SSL_CCC=154_CURLOPT_TIMEOUT_MS=155_CURLOPT_CONNECTTIMEOUT_MS=156_CURLOPT_HTTP_TRANSFER_DECODING=157_CURLOPT_HTTP_CONTENT_DECODING=158_CURLOPT_NEW_FILE_PERMS=159_CURLOPT_NEW_DIRECTORY_PERMS=160_CURLOPT_POSTREDIR=161_CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162_CURLOPT_OPENSOCKETFUNCTION=20163_CURLOPT_OPENSOCKETDATA=10164_CURLOPT_COPYPOSTFIELDS=10165_CURLOPT_PROXY_TRANSFER_MODE=166_CURLOPT_SEEKFUNCTION=20167_CURLOPT_SEEKDATA=10168_CURLOPT_CRLFILE=10169_CURLOPT_ISSUERCERT=10170_CURLOPT_ADDRESS_SCOPE=171_CURLOPT_CERTINFO=172_CURLOPT_USERNAME=10173_CURLOPT_PASSWORD=10174_CURLOPT_PROXYUSERNAME=10175_CURLOPT_PROXYPASSWORD=10176_CURLOPT_NOPROXY=10177_CURLOPT_TFTP_BLKSIZE=178_CURLOPT_SOCKS5_GSSAPI_SERVICE=10179_CURLOPT_SOCKS5_GSSAPI_NEC=180_CURLOPT_PROTOCOLS=181_CURLOPT_REDIR_PROTOCOLS=182_CURLOPT_SSH_KNOWNHOSTS=10183_CURLOPT_SSH_KEYFUNCTION=20184_CURLOPT_SSH_KEYDATA=10185_CURLOPT_MAIL_FROM=10186_CURLOPT_MAIL_RCPT=10187_CURLOPT_FTP_USE_PRET=188_CURLOPT_RTSP_REQUEST=189_CURLOPT_RTSP_SESSION_ID=10190_CURLOPT_RTSP_STREAM_URI=10191_CURLOPT_RTSP_TRANSPORT=10192_CURLOPT_RTSP_CLIENT_CSEQ=193_CURLOPT_RTSP_SERVER_CSEQ=194_CURLOPT_INTERLEAVEDATA=10195_CURLOPT_INTERLEAVEFUNCTION=20196_CURLOPT_WILDCARDMATCH=197_CURLOPT_CHUNK_BGN_FUNCTION=20198_CURLOPT_CHUNK_END_FUNCTION=20199_CURLOPT_FNMATCH_FUNCTION=20200_CURLOPT_CHUNK_DATA=10201_CURLOPT_FNMATCH_DATA=10202_CURLOPT_RESOLVE=10203_CURLOPT_TLSAUTH_USERNAME=10204_CURLOPT_TLSAUTH_PASSWORD=10205_CURLOPT_TLSAUTH_TYPE=10206_CURLOPT_TRANSFER_ENCODING=207_CURLOPT_CLOSESOCKETFUNCTION=20208_CURLOPT_CLOSESOCKETDATA=10209_CURLOPT_GSSAPI_DELEGATION=210_CURLOPT_DNS_SERVERS=10211_CURLOPT_ACCEPTTIMEOUT_MS=212_CURLOPT_TCP_KEEPALIVE=213_CURLOPT_TCP_KEEPIDLE=214_CURLOPT_TCP_KEEPINTVL=215_CURLOPT_SSL_OPTIONS=216_CURLOPT_MAIL_AUTH=10217_CURLOPT_SASL_IR=218_CURLOPT_XFERINFOFUNCTION=20219_CURLOPT_XOAUTH2_BEARER=10220_CURLOPT_DNS_INTERFACE=10221_CURLOPT_DNS_LOCAL_IP4=10222_CURLOPT_DNS_LOCAL_IP6=10223_CURLOPT_LOGIN_OPTIONS=10224_CURLOPT_SSL_ENABLE_NPN=225_CURLOPT_SSL_ENABLE_ALPN=226_CURLOPT_EXPECT_100_TIMEOUT_MS=227_CURLOPT_PROXYHEADER=10228_CURLOPT_HEADEROPT=229_CURLOPT_PINNEDPUBLICKEY=10230_CURLOPT_UNIX_SOCKET_PATH=10231_CURLOPT_SSL_VERIFYSTATUS=232_CURLOPT_SSL_FALSESTART=233_CURLOPT_PATH_AS_IS=234_CURLOPT_PROXY_SERVICE_NAME=10235_CURLOPT_SERVICE_NAME=10236_CURLOPT_PIPEWAIT=237_CURLOPT_DEFAULT_PROTOCOL=10238_CURLOPT_STREAM_WEIGHT=239_CURLOPT_STREAM_DEPENDS=10240_CURLOPT_STREAM_DEPENDS_E=10241_CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 863
enum anonymous_3 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// #anon_enum_CURL_FORMADD_OK=0_CURL_FORMADD_MEMORY=1_CURL_FORMADD_OPTION_TWICE=2_CURL_FORMADD_NULL=3_CURL_FORMADD_UNKNOWN_OPTION=4_CURL_FORMADD_INCOMPLETE=5_CURL_FORMADD_ILLEGAL_ARRAY=6_CURL_FORMADD_DISABLED=7_CURL_FORMADD_LAST=8
// file /usr/include/curl/curl.h line 1878
enum anonymous_2 { CURL_FORMADD_OK=0, CURL_FORMADD_MEMORY=1, CURL_FORMADD_OPTION_TWICE=2, CURL_FORMADD_NULL=3, CURL_FORMADD_UNKNOWN_OPTION=4, CURL_FORMADD_INCOMPLETE=5, CURL_FORMADD_ILLEGAL_ARRAY=6, CURL_FORMADD_DISABLED=7, CURL_FORMADD_LAST=8 };

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_4;

// tag-#anon#UN[*{S8}_S8_'client_ip'||*{S8}_S8_'bind_address'|]
// file /usr/include/mysql/mysql.h line 208
union anonymous_6;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_1;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_snd_pcm
// file /usr/include/alsa/pcm.h line 354
struct _snd_pcm;

// tag-_snd_pcm_access
// file /usr/include/alsa/pcm.h line 108
enum _snd_pcm_access { SND_PCM_ACCESS_MMAP_INTERLEAVED=0, SND_PCM_ACCESS_MMAP_NONINTERLEAVED=1, SND_PCM_ACCESS_MMAP_COMPLEX=2, SND_PCM_ACCESS_RW_INTERLEAVED=3, SND_PCM_ACCESS_RW_NONINTERLEAVED=4, SND_PCM_ACCESS_LAST=4 };

// tag-_snd_pcm_format
// file /usr/include/alsa/pcm.h line 123
enum _snd_pcm_format { SND_PCM_FORMAT_UNKNOWN=-1, SND_PCM_FORMAT_S8=0, SND_PCM_FORMAT_U8=1, SND_PCM_FORMAT_S16_LE=2, SND_PCM_FORMAT_S16_BE=3, SND_PCM_FORMAT_U16_LE=4, SND_PCM_FORMAT_U16_BE=5, SND_PCM_FORMAT_S24_LE=6, SND_PCM_FORMAT_S24_BE=7, SND_PCM_FORMAT_U24_LE=8, SND_PCM_FORMAT_U24_BE=9, SND_PCM_FORMAT_S32_LE=10, SND_PCM_FORMAT_S32_BE=11, SND_PCM_FORMAT_U32_LE=12, SND_PCM_FORMAT_U32_BE=13, SND_PCM_FORMAT_FLOAT_LE=14, SND_PCM_FORMAT_FLOAT_BE=15, SND_PCM_FORMAT_FLOAT64_LE=16, SND_PCM_FORMAT_FLOAT64_BE=17, SND_PCM_FORMAT_IEC958_SUBFRAME_LE=18, SND_PCM_FORMAT_IEC958_SUBFRAME_BE=19, SND_PCM_FORMAT_MU_LAW=20, SND_PCM_FORMAT_A_LAW=21, SND_PCM_FORMAT_IMA_ADPCM=22, SND_PCM_FORMAT_MPEG=23, SND_PCM_FORMAT_GSM=24, SND_PCM_FORMAT_SPECIAL=31, SND_PCM_FORMAT_S24_3LE=32, SND_PCM_FORMAT_S24_3BE=33, SND_PCM_FORMAT_U24_3LE=34, SND_PCM_FORMAT_U24_3BE=35, SND_PCM_FORMAT_S20_3LE=36, SND_PCM_FORMAT_S20_3BE=37, SND_PCM_FORMAT_U20_3LE=38, SND_PCM_FORMAT_U20_3BE=39, SND_PCM_FORMAT_S18_3LE=40, SND_PCM_FORMAT_S18_3BE=41, SND_PCM_FORMAT_U18_3LE=42, SND_PCM_FORMAT_U18_3BE=43, SND_PCM_FORMAT_G723_24=44, SND_PCM_FORMAT_G723_24_1B=45, SND_PCM_FORMAT_G723_40=46, SND_PCM_FORMAT_G723_40_1B=47, SND_PCM_FORMAT_DSD_U8=48, SND_PCM_FORMAT_DSD_U16_LE=49, SND_PCM_FORMAT_DSD_U32_LE=50, SND_PCM_FORMAT_DSD_U16_BE=51, SND_PCM_FORMAT_DSD_U32_BE=52, SND_PCM_FORMAT_LAST=52, SND_PCM_FORMAT_S16=2, SND_PCM_FORMAT_U16=4, SND_PCM_FORMAT_S24=6, SND_PCM_FORMAT_U24=8, SND_PCM_FORMAT_S32=10, SND_PCM_FORMAT_U32=12, SND_PCM_FORMAT_FLOAT=14, SND_PCM_FORMAT_FLOAT64=16, SND_PCM_FORMAT_IEC958_SUBFRAME=18 };

// tag-_snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 62
struct _snd_pcm_hw_params;

// tag-_snd_pcm_stream
// file /usr/include/alsa/pcm.h line 99
enum _snd_pcm_stream { SND_PCM_STREAM_PLAYBACK=0, SND_PCM_STREAM_CAPTURE=1, SND_PCM_STREAM_LAST=1 };

// tag-cache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.h line 29
struct cache_ent;

// tag-cfgcmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 25
struct cfgcmd;

// tag-charset_info_st
// file /usr/include/mysql/mysql.h line 269
struct charset_info_st;

// tag-curl_httppost
// file /usr/include/curl/curl.h line 125
struct curl_httppost;

// tag-curl_slist
// file /usr/include/curl/curl.h line 135
struct curl_slist;

// tag-demod_state_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.h line 44
struct demod_state_t;

// tag-enum_field_types
// file /usr/include/mysql/mysql_com.h line 369
enum enum_field_types { MYSQL_TYPE_DECIMAL=0, MYSQL_TYPE_TINY=1, MYSQL_TYPE_SHORT=2, MYSQL_TYPE_LONG=3, MYSQL_TYPE_FLOAT=4, MYSQL_TYPE_DOUBLE=5, MYSQL_TYPE_NULL=6, MYSQL_TYPE_TIMESTAMP=7, MYSQL_TYPE_LONGLONG=8, MYSQL_TYPE_INT24=9, MYSQL_TYPE_DATE=10, MYSQL_TYPE_TIME=11, MYSQL_TYPE_DATETIME=12, MYSQL_TYPE_YEAR=13, MYSQL_TYPE_NEWDATE=14, MYSQL_TYPE_VARCHAR=15, MYSQL_TYPE_BIT=16, MYSQL_TYPE_TIMESTAMP2=17, MYSQL_TYPE_DATETIME2=18, MYSQL_TYPE_TIME2=19, MYSQL_TYPE_NEWDECIMAL=246, MYSQL_TYPE_ENUM=247, MYSQL_TYPE_SET=248, MYSQL_TYPE_TINY_BLOB=249, MYSQL_TYPE_MEDIUM_BLOB=250, MYSQL_TYPE_LONG_BLOB=251, MYSQL_TYPE_BLOB=252, MYSQL_TYPE_VAR_STRING=253, MYSQL_TYPE_STRING=254, MYSQL_TYPE_GEOMETRY=255 };

// tag-filter
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 36
struct filter;

// tag-ipc_state_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.h line 66
struct ipc_state_t;

// tag-mysql_option
// file /usr/include/mysql/mysql.h line 159
enum mysql_option { MYSQL_OPT_CONNECT_TIMEOUT=0, MYSQL_OPT_COMPRESS=1, MYSQL_OPT_NAMED_PIPE=2, MYSQL_INIT_COMMAND=3, MYSQL_READ_DEFAULT_FILE=4, MYSQL_READ_DEFAULT_GROUP=5, MYSQL_SET_CHARSET_DIR=6, MYSQL_SET_CHARSET_NAME=7, MYSQL_OPT_LOCAL_INFILE=8, MYSQL_OPT_PROTOCOL=9, MYSQL_SHARED_MEMORY_BASE_NAME=10, MYSQL_OPT_READ_TIMEOUT=11, MYSQL_OPT_WRITE_TIMEOUT=12, MYSQL_OPT_USE_RESULT=13, MYSQL_OPT_USE_REMOTE_CONNECTION=14, MYSQL_OPT_USE_EMBEDDED_CONNECTION=15, MYSQL_OPT_GUESS_CONNECTION=16, MYSQL_SET_CLIENT_IP=17, MYSQL_SECURE_AUTH=18, MYSQL_REPORT_DATA_TRUNCATION=19, MYSQL_OPT_RECONNECT=20, MYSQL_OPT_SSL_VERIFY_SERVER_CERT=21, MYSQL_PLUGIN_DIR=22, MYSQL_DEFAULT_AUTH=23, MYSQL_OPT_BIND=24, MYSQL_OPT_SSL_KEY=25, MYSQL_OPT_SSL_CERT=26, MYSQL_OPT_SSL_CA=27, MYSQL_OPT_SSL_CAPATH=28, MYSQL_OPT_SSL_CIPHER=29, MYSQL_OPT_SSL_CRL=30, MYSQL_OPT_SSL_CRLPATH=31, MYSQL_OPT_CONNECT_ATTR_RESET=32, MYSQL_OPT_CONNECT_ATTR_ADD=33, MYSQL_OPT_CONNECT_ATTR_DELETE=34, MYSQL_SERVER_PUBLIC_KEY=35, MYSQL_ENABLE_CLEARTEXT_PLUGIN=36, MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS=37 };

// tag-mysql_state_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.h line 29
struct mysql_state_t_0;

// tag-mysql_state_t_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.h line 29
struct mysql_state_t;

// tag-mysql_status
// file /usr/include/mysql/mysql.h line 236
enum mysql_status { MYSQL_STATUS_READY=0, MYSQL_STATUS_GET_RESULT=1, MYSQL_STATUS_USE_RESULT=2, MYSQL_STATUS_STATEMENT_GET_RESULT=3 };

// tag-pa_buffer_attr
// file /usr/include/pulse/def.h line 387
struct pa_buffer_attr;

// tag-pa_channel_map
// file /usr/include/pulse/channelmap.h line 262
struct pa_channel_map;

// tag-pa_channel_position
// file /usr/include/pulse/channelmap.h line 74
enum pa_channel_position { PA_CHANNEL_POSITION_INVALID=-1, PA_CHANNEL_POSITION_MONO=0, PA_CHANNEL_POSITION_FRONT_LEFT=1, PA_CHANNEL_POSITION_FRONT_RIGHT=2, PA_CHANNEL_POSITION_FRONT_CENTER=3, PA_CHANNEL_POSITION_LEFT=1, PA_CHANNEL_POSITION_RIGHT=2, PA_CHANNEL_POSITION_CENTER=3, PA_CHANNEL_POSITION_REAR_CENTER=4, PA_CHANNEL_POSITION_REAR_LEFT=5, PA_CHANNEL_POSITION_REAR_RIGHT=6, PA_CHANNEL_POSITION_LFE=7, PA_CHANNEL_POSITION_SUBWOOFER=7, PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER=8, PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER=9, PA_CHANNEL_POSITION_SIDE_LEFT=10, PA_CHANNEL_POSITION_SIDE_RIGHT=11, PA_CHANNEL_POSITION_AUX0=12, PA_CHANNEL_POSITION_AUX1=13, PA_CHANNEL_POSITION_AUX2=14, PA_CHANNEL_POSITION_AUX3=15, PA_CHANNEL_POSITION_AUX4=16, PA_CHANNEL_POSITION_AUX5=17, PA_CHANNEL_POSITION_AUX6=18, PA_CHANNEL_POSITION_AUX7=19, PA_CHANNEL_POSITION_AUX8=20, PA_CHANNEL_POSITION_AUX9=21, PA_CHANNEL_POSITION_AUX10=22, PA_CHANNEL_POSITION_AUX11=23, PA_CHANNEL_POSITION_AUX12=24, PA_CHANNEL_POSITION_AUX13=25, PA_CHANNEL_POSITION_AUX14=26, PA_CHANNEL_POSITION_AUX15=27, PA_CHANNEL_POSITION_AUX16=28, PA_CHANNEL_POSITION_AUX17=29, PA_CHANNEL_POSITION_AUX18=30, PA_CHANNEL_POSITION_AUX19=31, PA_CHANNEL_POSITION_AUX20=32, PA_CHANNEL_POSITION_AUX21=33, PA_CHANNEL_POSITION_AUX22=34, PA_CHANNEL_POSITION_AUX23=35, PA_CHANNEL_POSITION_AUX24=36, PA_CHANNEL_POSITION_AUX25=37, PA_CHANNEL_POSITION_AUX26=38, PA_CHANNEL_POSITION_AUX27=39, PA_CHANNEL_POSITION_AUX28=40, PA_CHANNEL_POSITION_AUX29=41, PA_CHANNEL_POSITION_AUX30=42, PA_CHANNEL_POSITION_AUX31=43, PA_CHANNEL_POSITION_TOP_CENTER=44, PA_CHANNEL_POSITION_TOP_FRONT_LEFT=45, PA_CHANNEL_POSITION_TOP_FRONT_RIGHT=46, PA_CHANNEL_POSITION_TOP_FRONT_CENTER=47, PA_CHANNEL_POSITION_TOP_REAR_LEFT=48, PA_CHANNEL_POSITION_TOP_REAR_RIGHT=49, PA_CHANNEL_POSITION_TOP_REAR_CENTER=50, PA_CHANNEL_POSITION_MAX=51 };

// tag-pa_sample_format
// file /usr/include/pulse/sample.h line 134
enum pa_sample_format { PA_SAMPLE_U8=0, PA_SAMPLE_ALAW=1, PA_SAMPLE_ULAW=2, PA_SAMPLE_S16LE=3, PA_SAMPLE_S16BE=4, PA_SAMPLE_FLOAT32LE=5, PA_SAMPLE_FLOAT32BE=6, PA_SAMPLE_S32LE=7, PA_SAMPLE_S32BE=8, PA_SAMPLE_S24LE=9, PA_SAMPLE_S24BE=10, PA_SAMPLE_S24_32LE=11, PA_SAMPLE_S24_32BE=12, PA_SAMPLE_MAX=13, PA_SAMPLE_INVALID=-1 };

// tag-pa_sample_spec
// file /usr/include/pulse/sample.h line 248
struct pa_sample_spec;

// tag-pa_simple
// file /usr/include/pulse/simple.h line 115
struct pa_simple;

// tag-pa_stream_direction
// file /usr/include/pulse/def.h line 156
enum pa_stream_direction { PA_STREAM_NODIRECTION=0, PA_STREAM_PLAYBACK=1, PA_STREAM_RECORD=2, PA_STREAM_UPLOAD=3 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-receiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 35
struct receiver;

// tag-serial_state_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 24
struct serial_state_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/un.h line 29
struct sockaddr_un;

// tag-spblk
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.h line 27
struct spblk;

// tag-sptree
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.h line 35
struct sptree;

// tag-st_dynamic_array
// file /usr/include/mysql/mysql.h line 192
struct st_dynamic_array;

// tag-st_list
// file /usr/include/mysql/my_list.h line 23
struct st_list;

// tag-st_mem_root
// file /usr/include/mysql/my_alloc.h line 38
struct st_mem_root;

// tag-st_mysql
// file /usr/include/mysql/mysql.h line 263
struct st_mysql;

// tag-st_mysql_field
// file /usr/include/mysql/mysql.h line 94
struct st_mysql_field;

// tag-st_mysql_methods
// file /usr/include/mysql/mysql.h line 260
struct st_mysql_methods;

// tag-st_mysql_options
// file /usr/include/mysql/mysql.h line 187
struct st_mysql_options;

// tag-st_mysql_options_extention
// file /usr/include/mysql/mysql.h line 185
struct st_mysql_options_extention;

// tag-st_net
// file /usr/include/mysql/mysql_com.h line 316
struct st_net;

// tag-st_used_mem
// file /usr/include/mysql/my_alloc.h line 30
struct st_used_mem;

// tag-st_vio
// file /usr/include/mysql/mysql_com.h line 305
struct st_vio;

// tag-syment
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 33
struct syment;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-uplink_config_t
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 85
struct uplink_config_t;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _curl_easy_getinfo_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 201
static void _curl_easy_getinfo_err_curl_slist(void);
// _curl_easy_getinfo_err_double
// file /usr/include/curl/typecheck-gcc.h line 199
static void _curl_easy_getinfo_err_double(void);
// _curl_easy_getinfo_err_long
// file /usr/include/curl/typecheck-gcc.h line 197
static void _curl_easy_getinfo_err_long(void);
// _curl_easy_getinfo_err_string
// file /usr/include/curl/typecheck-gcc.h line 195
static void _curl_easy_getinfo_err_string(void);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// _sp_chop
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 209
static void _sp_chop(struct spblk *n);
// _sp_deq
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 609
extern struct spblk * _sp_deq(struct spblk **np);
// _sp_enq
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 481
extern struct spblk * _sp_enq(struct spblk *n, struct sptree *q);
// _splay
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 684
extern void _splay(struct spblk *n, struct sptree *q);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// accesslog
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 323
extern signed int accesslog(const char *fmt, ...);
// accesslog_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 298
extern signed int accesslog_close(char *reopenpath);
// accesslog_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 270
extern signed int accesslog_open(char *logd, signed int reopen);
// appid_ifm
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 220
const char * appid_ifm(signed int i);
// argstr
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 294
extern char * argstr(signed int arg, signed int argc, char **argv);
// atan2f
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 60
extern float atan2f(float, float);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// brokenconnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ais.c line 58
void brokenconnection(signed int sig);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// cache_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.h line 62
extern signed int cache_deinit(void);
// cache_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 99
extern signed int cache_free(struct sptree *sp);
// cache_free_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 84
extern void cache_free_entry(struct cache_ent *e);
// cache_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 163
static struct cache_ent * cache_get(signed int mmsi);
// cache_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.h line 61
extern signed int cache_init(void);
// cache_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 204
extern signed int cache_position(signed int received_t, signed int mmsi, signed int navstat, float lat, float lon, signed int hdg, float course, signed int rateofturn, float sog);
// cache_rotate
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 143
extern struct sptree * cache_rotate(void);
// cache_vessel_persons
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 366
extern signed int cache_vessel_persons(signed int received_t, signed int mmsi, signed int persons_on_board);
// cache_vesseldata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 235
extern signed int cache_vesseldata(signed int received_t, signed int mmsi, signed int imo, char *callsign, char *name, char *destination, signed int shiptype, signed int A, signed int B, signed int C, signed int D, float draught);
// cache_vesseldatab
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 277
extern signed int cache_vesseldatab(signed int received_t, signed int mmsi, char *callsign, signed int shiptype, signed int A, signed int B, signed int C, signed int D);
// cache_vesseldatabb
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 310
extern signed int cache_vesseldatabb(signed int received_t, signed int mmsi, signed int shiptype, signed int A, signed int B, signed int C, signed int D);
// cache_vesselname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 336
extern signed int cache_vesselname(signed int received_t, signed int mmsi, char *name, const char *destination);
// cfsetispeed
// file /usr/include/termios.h line 57
extern signed int cfsetispeed(struct termios *, unsigned int);
// cfsetospeed
// file /usr/include/termios.h line 54
extern signed int cfsetospeed(struct termios *, unsigned int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 47
extern signed int close_log(signed int reopen);
// closedown
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ais.c line 54
void closedown(signed int sig);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// cmdparse
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 316
signed int cmdparse(struct cfgcmd *cmds, char *cmdline);
// cosf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern float cosf(float);
// cpfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 42
signed int cpfile(const char *to, const char *from);
// crc32
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 93
extern unsigned long int crc32(const unsigned char *s);
// crc32n
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 75
extern unsigned long int crc32n(const unsigned char *s, signed int slen);
// crcinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 56
extern void crcinit(void);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_getinfo
// file /usr/include/curl/easy.h line 46
enum anonymous curl_easy_getinfo(void *, enum anonymous_0, ...);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous curl_easy_perform(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous curl_easy_setopt(void *, enum anonymous_3, ...);
// curl_easy_strerror
// file /usr/include/curl/curl.h line 2352
const char * curl_easy_strerror(enum anonymous);
// curl_formadd
// file /usr/include/curl/curl.h line 1901
enum anonymous_2 curl_formadd(struct curl_httppost **, struct curl_httppost **, ...);
// curl_formfree
// file /usr/include/curl/curl.h line 1935
void curl_formfree(struct curl_httppost *);
// curl_global_cleanup
// file /usr/include/curl/curl.h line 2044
void curl_global_cleanup(void);
// curl_global_init
// file /usr/include/curl/curl.h line 2014
enum anonymous curl_global_init(signed long int);
// curl_slist_append
// file /usr/include/curl/curl.h line 2060
struct curl_slist * curl_slist_append(struct curl_slist *, const char *);
// curl_slist_free_all
// file /usr/include/curl/curl.h line 2070
void curl_slist_free_all(struct curl_slist *);
// curl_wdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 61
unsigned long int curl_wdata(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// do_float
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 38
extern signed int do_float(float *dest, signed int argc, char **argv);
// do_int
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 37
extern signed int do_int(signed int *dest, signed int argc, char **argv);
// do_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 190
signed int do_interval(signed int *dest, signed int argc, char **argv);
// do_skip_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 203
signed int do_skip_type(signed int *dest, signed int argc, char **argv);
// do_sound_ch
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 226
signed int do_sound_ch(signed int *dest, signed int argc, char **argv);
// do_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 36
extern signed int do_string(char **dest, signed int argc, char **argv);
// do_toggle
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 39
extern signed int do_toggle(signed int *dest, signed int argc, char **argv);
// do_uplink
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 254
signed int do_uplink(struct uplink_config_t **lq, signed int argc, char **argv);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.h line 65
extern void filter_free(struct filter *f);
// filter_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.h line 64
extern struct filter * filter_init(signed int len, float *taps);
// filter_mac
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.c line 43
float filter_mac(const float *a, const float *b, signed int size);
// filter_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.c line 83
extern void filter_run(struct filter *f, float in, float *out);
// filter_run_buf
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.h line 68
extern signed short int filter_run_buf(struct filter *f, signed short int *in, float *out, signed int step, signed int len);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 97
extern void free_config(void);
// free_receiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 49
extern void free_receiver(struct receiver *rx);
// free_uplink_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 135
void free_uplink_config(struct uplink_config_t **lc);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// gnuais_ipc_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.h line 35
void gnuais_ipc_deinit(struct ipc_state_t *ipc);
// gnuais_ipc_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.h line 34
struct ipc_state_t * gnuais_ipc_init();
// gnuais_ipc_socketlistener
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 44
static void gnuais_ipc_socketlistener(void *asdf);
// gnuais_ipc_startthread
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 61
signed int gnuais_ipc_startthread(struct ipc_state_t *ipc);
// hatoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 107
extern signed long long int hatoll(char *s);
// hfree
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 33
extern void hfree(void *ptr);
// hlog
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 48
extern signed int hlog(signed int priority, const char *fmt, ...);
// hmalloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 31
extern void * hmalloc(unsigned long int size);
// hrealloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 32
extern void * hrealloc(void *ptr, unsigned long int size);
// hstrdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 35
extern char * hstrdup(const char *s);
// init_receiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 48
extern struct receiver * init_receiver(char name, signed int num_ch, signed int ch_ofs, struct serial_state_t *serial, struct ipc_state_t *ipc);
// input_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/input.h line 33
void input_cleanup(struct _snd_pcm *handle);
// input_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/input.h line 31
signed int input_initialize(struct _snd_pcm *handle, signed short int **buffer, signed int *buffer_l);
// input_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/input.h line 32
signed int input_read(struct _snd_pcm *handle, signed short int *buffer, signed int count);
// ipc_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.h line 36
signed int ipc_write(struct ipc_state_t *ipc, char *buffer, signed int buflength);
// jsonout_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.h line 26
extern signed int jsonout_deinit(void);
// jsonout_export
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 211
static void jsonout_export(void);
// jsonout_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.h line 25
extern signed int jsonout_init(void);
// jsonout_post_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 187
static void jsonout_post_all(char *json);
// jsonout_post_single
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 71
static signed int jsonout_post_single(struct curl_httppost *post, const char *url);
// jsonout_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 360
static void jsonout_thread(void *asdf);
// lat2rad
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.h line 27
extern float lat2rad(float lat);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// log_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.h line 31
extern void log_range(struct demod_state_t *rx);
// lon2rad
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.h line 28
extern float lon2rad(float lon);
// maidenhead_km_distance
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.c line 18
static float maidenhead_km_distance(float lat1, float lon1, float lat2, float lon2);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// myout_ais_basestation
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 198
extern signed int myout_ais_basestation(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, float lat, float lon);
// myout_ais_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 174
extern signed int myout_ais_position(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, float lat, float lon, float hdg, float course, float sog);
// myout_ais_vesseldata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 216
extern signed int myout_ais_vesseldata(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, char *name, char *destination, float draught, signed int A, signed int B, signed int C, signed int D);
// myout_ais_vesseldatab
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 237
extern signed int myout_ais_vesseldatab(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, signed int A, signed int B, signed int C, signed int D);
// myout_ais_vesselname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 257
extern signed int myout_ais_vesselname(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, const char *name, const char *destination);
// myout_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 45
static signed int myout_connect(struct mysql_state_t_0 *my);
// myout_delete_from
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 98
static signed int myout_delete_from(struct mysql_state_t_0 *my, signed long int now, char *table);
// myout_delete_old
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 120
static signed int myout_delete_old(struct mysql_state_t_0 *my, signed long int now);
// myout_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.h line 37
extern struct mysql_state_t_0 * myout_init();
// myout_nmea
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 278
extern signed int myout_nmea(struct mysql_state_t_0 *my, signed long int tid, char *nmea);
// myout_reconnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 88
static signed int myout_reconnect(struct mysql_state_t_0 *my);
// myout_update_or_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 134
static signed int myout_update_or_insert(struct mysql_state_t_0 *my, char *upd, char *ins);
// mysql_affected_rows
// file /usr/include/mysql/mysql.h line 390
unsigned long long int mysql_affected_rows(struct st_mysql *);
// mysql_close
// file /usr/include/mysql/mysql.h line 718
void mysql_close(struct st_mysql *);
// mysql_errno
// file /usr/include/mysql/mysql.h line 392
unsigned int mysql_errno(struct st_mysql *);
// mysql_error
// file /usr/include/mysql/mysql.h line 393
const char * mysql_error(struct st_mysql *);
// mysql_init
// file /usr/include/mysql/mysql.h line 401
struct st_mysql * mysql_init(struct st_mysql *);
// mysql_query
// file /usr/include/mysql/mysql.h line 416
signed int mysql_query(struct st_mysql *, const char *);
// mysql_real_connect
// file /usr/include/mysql/mysql.h line 408
struct st_mysql * mysql_real_connect(struct st_mysql *, const char *, const char *, const char *, const char *, unsigned int, const char *, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 46
extern signed int open_log(char *name, signed int reopen);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pa_simple_free
// file /usr/include/pulse/simple.h line 131
void pa_simple_free(struct pa_simple *);
// pa_simple_new
// file /usr/include/pulse/simple.h line 118
struct pa_simple * pa_simple_new(const char *, const char *, enum pa_stream_direction, const char *, const char *, const struct pa_sample_spec *, const struct pa_channel_map *, const struct pa_buffer_attr *, signed int *);
// pa_simple_read
// file /usr/include/pulse/simple.h line 142
signed int pa_simple_read(struct pa_simple *, void *, unsigned long int, signed int *);
// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 259
extern signed int parse_args(char **argv, char *cmd);
// parse_cmdline
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 99
extern void parse_cmdline(signed int argc, char **argv);
// parse_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 152
signed long int parse_interval(char *origs);
// parse_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 186
static char * parse_string(char *str);
// pick_loglevel
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 45
extern signed int pick_loglevel(char *s, char **names);
// pname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 209
extern const char * pname(unsigned int id);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// protodec_18
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 585
void protodec_18(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_19
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 632
void protodec_19(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_20
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 682
void protodec_20(struct demod_state_t *d, signed int bufferlen);
// protodec_24
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 702
void protodec_24(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_4
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 403
void protodec_4(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_5
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 445
void protodec_5(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_6
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 525
void protodec_6(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_7_13
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 548
void protodec_7_13(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_8
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 572
void protodec_8(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_calculate_crc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 120
signed int protodec_calculate_crc(signed int length_bits, struct demod_state_t *d);
// protodec_decode
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.h line 76
void protodec_decode(char *in, signed int count, struct demod_state_t *d);
// protodec_decode_sixbit_ascii
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 190
void protodec_decode_sixbit_ascii(char sixbit, char *name, signed int pos);
// protodec_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 78
void protodec_deinit(struct demod_state_t *d);
// protodec_generate_nmea
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 780
void protodec_generate_nmea(struct demod_state_t *d, signed int bufferlen, signed int fillbits, signed long int received_t);
// protodec_getdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 896
void protodec_getdata(signed int bufferlen, struct demod_state_t *d);
// protodec_henten
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 205
unsigned long int protodec_henten(signed int from, signed int size, unsigned char *frame);
// protodec_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.h line 73
void protodec_initialize(struct demod_state_t *d, struct serial_state_t *serial, struct ipc_state_t *ipc, char chanid);
// protodec_msg_11
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 286
void protodec_msg_11(unsigned char *buffer, signed int bufferlen, signed int msg_start, signed long int received_t, unsigned long int mmsi);
// protodec_msg_40
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 278
void protodec_msg_40(unsigned char *buffer, signed int bufferlen, signed int msg_start, signed long int received_t, unsigned long int mmsi);
// protodec_msg_bin
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 338
void protodec_msg_bin(unsigned char *buffer, signed int bufferlen, signed int appid_fi, signed int msg_start, signed long int received_t, unsigned long int mmsi);
// protodec_pos
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 357
void protodec_pos(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi);
// protodec_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 87
void protodec_reset(struct demod_state_t *d);
// protodec_sdlc_crc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 106
unsigned short int protodec_sdlc_crc(const unsigned char *data, unsigned int len);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_1 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_1 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_5 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_5 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_5 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pulseaudio_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/pulseaudio.h line 29
void pulseaudio_cleanup(struct pa_simple *s);
// pulseaudio_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/pulseaudio.h line 27
struct pa_simple * pulseaudio_initialize();
// pulseaudio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/pulseaudio.h line 31
signed int pulseaudio_read(struct pa_simple *s, signed short int *buffer, signed int count);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_cfgfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 34
extern signed int read_cfgfile(char *f, struct cfgcmd *cmds);
// read_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 96
extern signed int read_config(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// receiver_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 51
extern void receiver_run(struct receiver *rx, signed short int *buf, signed int len);
// remove_trailing_spaces
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 173
static void remove_trailing_spaces(char *s, signed int len);
// serial_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 30
extern signed int serial_close(struct serial_state_t *state);
// serial_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 28
extern struct serial_state_t * serial_init();
// serial_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 29
extern signed int serial_write(struct serial_state_t *state, char *s, signed int len);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sinf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern float sinf(float);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snd_pcm_close
// file /usr/include/alsa/pcm.h line 459
signed int snd_pcm_close(struct _snd_pcm *);
// snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 473
signed int snd_pcm_hw_params(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_any
// file /usr/include/alsa/pcm.h line 657
signed int snd_pcm_hw_params_any(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_get_period_size
// file /usr/include/alsa/pcm.h line 782
signed int snd_pcm_hw_params_get_period_size(const struct _snd_pcm_hw_params *, unsigned long int *, signed int *);
// snd_pcm_hw_params_set_access
// file /usr/include/alsa/pcm.h line 718
signed int snd_pcm_hw_params_set_access(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_access);
// snd_pcm_hw_params_set_channels
// file /usr/include/alsa/pcm.h line 744
signed int snd_pcm_hw_params_set_channels(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int);
// snd_pcm_hw_params_set_format
// file /usr/include/alsa/pcm.h line 726
signed int snd_pcm_hw_params_set_format(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_format);
// snd_pcm_hw_params_set_period_size_near
// file /usr/include/alsa/pcm.h line 790
signed int snd_pcm_hw_params_set_period_size_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned long int *, signed int *);
// snd_pcm_hw_params_set_rate_near
// file /usr/include/alsa/pcm.h line 760
signed int snd_pcm_hw_params_set_rate_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_hw_params_sizeof
// file /usr/include/alsa/pcm.h line 704
unsigned long int snd_pcm_hw_params_sizeof(void);
// snd_pcm_open
// file /usr/include/alsa/pcm.h line 450
signed int snd_pcm_open(struct _snd_pcm **, const char *, enum _snd_pcm_stream, signed int);
// snd_pcm_prepare
// file /usr/include/alsa/pcm.h line 477
signed int snd_pcm_prepare(struct _snd_pcm *);
// snd_pcm_readi
// file /usr/include/alsa/pcm.h line 497
signed long int snd_pcm_readi(struct _snd_pcm *, void *, unsigned long int);
// snd_strerror
// file /usr/include/alsa/error.h line 45
const char * snd_strerror(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sp_alloc_blk
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 77
struct spblk * sp_alloc_blk(void);
// sp_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 379
extern void sp_delete(struct spblk *n, struct sptree *q);
// sp_fhead
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 177
extern struct spblk * sp_fhead(struct sptree *q);
// sp_fnext
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 247
extern struct spblk * sp_fnext(struct spblk *n);
// sp_free_blk
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 66
void sp_free_blk(struct spblk *n);
// sp_free_freelist
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 103
extern void sp_free_freelist(void);
// sp_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 451
extern struct sptree * sp_init(void);
// sp_install
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 151
extern struct spblk * sp_install(unsigned int key, struct sptree *q);
// sp_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 121
extern struct spblk * sp_lookup(unsigned int key, struct sptree *q);
// sp_null
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 224
extern void sp_null(struct sptree *q);
// sp_scan
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 198
extern void sp_scan(signed int (*f)(struct spblk *), struct spblk *n, struct sptree *q);

//

// sp_stats
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 282
extern const char * sp_stats(struct sptree *q);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrtf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern float sqrtf(float);
// str_append
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 90
extern char * str_append(char *s, const char *fmt, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strlwr
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 123
extern char * strlwr(char *s);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strupr
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 302
char * strupr(char *s);
// symbol
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 41
extern unsigned int symbol(const void *s);
// symbol_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 230
extern unsigned int symbol_db(const void *s, struct sptree *spt);
// symbol_db_mem
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 81
extern unsigned int symbol_db_mem(const void *s, signed int slen, struct sptree *spt);
// symbol_free_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 196
extern void symbol_free_db(const void *s, struct sptree *spt);
// symbol_free_db_mem
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 155
void symbol_free_db_mem(const void *s, signed int slen, struct sptree *spt);
// symbol_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 222
extern unsigned int symbol_lookup(const void *s);
// symbol_lookup_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 214
extern unsigned int symbol_lookup_db(const void *s, struct sptree *spt);
// symbol_lookup_db_mem
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 49
extern unsigned int symbol_lookup_db_mem(const void *s, const signed int slen, struct sptree *spt);
// symbol_null
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 129
static signed int symbol_null(struct spblk *spl);
// symbol_null_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 140
extern void symbol_null_db(struct sptree *spt);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time_jsonais
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 150
signed int time_jsonais(signed long int *t, char *buf, signed int buflen);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.c line 32
extern void update_range(struct demod_state_t *d, float lat, float lon);
// valid_aprsis_call
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 288
signed int valid_aprsis_call(char *s);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writepid
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 54
extern signed int writepid(char *name);

struct anonymous_4
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

union anonymous_6
{
  // client_ip
  char *client_ip;
  // bind_address
  char *bind_address;
};

union anonymous_5
{
  // __data
  struct anonymous_4 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_1
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct cache_ent
{
  // mmsi
  signed int mmsi;
  // received_pos
  signed long int received_pos;
  // lat
  float lat;
  // lon
  float lon;
  // hdg
  signed int hdg;
  // course
  float course;
  // sog
  float sog;
  // navstat
  signed int navstat;
  // received_data
  signed long int received_data;
  // imo
  signed int imo;
  // callsign
  char *callsign;
  // name
  char *name;
  // destination
  char *destination;
  // shiptype
  signed int shiptype;
  // A
  signed int A;
  // B
  signed int B;
  // C
  signed int C;
  // D
  signed int D;
  // draught
  float draught;
  // received_persons_on_board
  signed long int received_persons_on_board;
  // persons_on_board
  signed int persons_on_board;
};

struct cfgcmd
{
  // name
  char *name;
  // function
  signed int (*function)(void *, signed int, char **);
  // dest
  void *dest;
};

struct curl_httppost
{
  // next
  struct curl_httppost *next;
  // name
  char *name;
  // namelength
  signed long int namelength;
  // contents
  char *contents;
  // contentslength
  signed long int contentslength;
  // buffer
  char *buffer;
  // bufferlength
  signed long int bufferlength;
  // contenttype
  char *contenttype;
  // contentheader
  struct curl_slist *contentheader;
  // more
  struct curl_httppost *more;
  // flags
  signed long int flags;
  // showfilename
  char *showfilename;
  // userp
  void *userp;
  // contentlen
  signed long int contentlen;
};

struct curl_slist
{
  // data
  char *data;
  // next
  struct curl_slist *next;
};

struct demod_state_t
{
  // chanid
  char chanid;
  // state
  signed int state;
  // offset
  unsigned int offset;
  // nskurr
  signed int nskurr;
  // npreamble
  signed int npreamble;
  // nstartsign
  signed int nstartsign;
  // ndata
  signed int ndata;
  // nstopsign
  signed int nstopsign;
  // antallenner
  signed int antallenner;
  // buffer
  unsigned char *buffer;
  // rbuffer
  unsigned char *rbuffer;
  // tbuffer
  char *tbuffer;
  // bufferpos
  signed int bufferpos;
  // last
  char last;
  // antallpreamble
  signed int antallpreamble;
  // bitstuff
  signed int bitstuff;
  // receivedframes
  signed int receivedframes;
  // lostframes
  signed int lostframes;
  // lostframes2
  signed int lostframes2;
  // seqnr
  unsigned char seqnr;
  // best_range
  float best_range;
  // serial
  struct serial_state_t *serial;
  // ipc
  struct ipc_state_t *ipc;
  // serbuffer
  char *serbuffer;
  // ipcbuffer
  char *ipcbuffer;
  // nmea
  char *nmea;
};

struct filter
{
  // length
  signed int length;
  // taps
  float *taps;
  // buffer
  float buffer[1024l];
  // pointer
  signed int pointer;
};

struct ipc_state_t
{
  // numclientsockets
  signed int numclientsockets;
  // clientsocket
  signed int clientsocket[20l];
};

struct st_net
{
  // vio
  struct st_vio *vio;
  // buff
  unsigned char *buff;
  // buff_end
  unsigned char *buff_end;
  // write_pos
  unsigned char *write_pos;
  // read_pos
  unsigned char *read_pos;
  // fd
  signed int fd;
  // remain_in_buf
  unsigned long int remain_in_buf;
  // length
  unsigned long int length;
  // buf_length
  unsigned long int buf_length;
  // where_b
  unsigned long int where_b;
  // max_packet
  unsigned long int max_packet;
  // max_packet_size
  unsigned long int max_packet_size;
  // pkt_nr
  unsigned int pkt_nr;
  // compress_pkt_nr
  unsigned int compress_pkt_nr;
  // write_timeout
  unsigned int write_timeout;
  // read_timeout
  unsigned int read_timeout;
  // retry_count
  unsigned int retry_count;
  // fcntl
  signed int fcntl;
  // return_status
  unsigned int *return_status;
  // reading_or_writing
  unsigned char reading_or_writing;
  // save_char
  char save_char;
  // unused1
  char unused1;
  // unused2
  char unused2;
  // compress
  char compress;
  // unused3
  char unused3;
  // unused
  unsigned char *unused;
  // last_errno
  unsigned int last_errno;
  // error
  unsigned char error;
  // unused4
  char unused4;
  // unused5
  char unused5;
  // last_error
  char last_error[512l];
  // sqlstate
  char sqlstate[6l];
  // extension
  void *extension;
};

struct st_mem_root
{
  // free
  struct st_used_mem *free;
  // used
  struct st_used_mem *used;
  // pre_alloc
  struct st_used_mem *pre_alloc;
  // min_malloc
  unsigned long int min_malloc;
  // block_size
  unsigned long int block_size;
  // block_num
  unsigned int block_num;
  // first_block_usage
  unsigned int first_block_usage;
  // error_handler
  void (*error_handler)(void);
};

struct st_mysql_options
{
  // connect_timeout
  unsigned int connect_timeout;
  // read_timeout
  unsigned int read_timeout;
  // write_timeout
  unsigned int write_timeout;
  // port
  unsigned int port;
  // protocol
  unsigned int protocol;
  // client_flag
  unsigned long int client_flag;
  // host
  char *host;
  // user
  char *user;
  // password
  char *password;
  // unix_socket
  char *unix_socket;
  // db
  char *db;
  // init_commands
  struct st_dynamic_array *init_commands;
  // my_cnf_file
  char *my_cnf_file;
  // my_cnf_group
  char *my_cnf_group;
  // charset_dir
  char *charset_dir;
  // charset_name
  char *charset_name;
  // ssl_key
  char *ssl_key;
  // ssl_cert
  char *ssl_cert;
  // ssl_ca
  char *ssl_ca;
  // ssl_capath
  char *ssl_capath;
  // ssl_cipher
  char *ssl_cipher;
  // shared_memory_base_name
  char *shared_memory_base_name;
  // max_allowed_packet
  unsigned long int max_allowed_packet;
  // use_ssl
  char use_ssl;
  // compress
  char compress;
  // named_pipe
  char named_pipe;
  // unused1
  char unused1;
  // unused2
  char unused2;
  // unused3
  char unused3;
  // unused4
  char unused4;
  // methods_to_use
  enum mysql_option methods_to_use;
  // ci
  union anonymous_6 ci;
  // secure_auth
  char secure_auth;
  // report_data_truncation
  char report_data_truncation;
  // local_infile_init
  signed int (*local_infile_init)(void **, const char *, void *);
  // local_infile_read
  signed int (*local_infile_read)(void *, char *, unsigned int);
  // local_infile_end
  void (*local_infile_end)(void *);
  // local_infile_error
  signed int (*local_infile_error)(void *, char *, unsigned int);
  // local_infile_userdata
  void *local_infile_userdata;
  // extension
  struct st_mysql_options_extention *extension;
};

struct st_mysql
{
  // net
  struct st_net net;
  // connector_fd
  unsigned char *connector_fd;
  // host
  char *host;
  // user
  char *user;
  // passwd
  char *passwd;
  // unix_socket
  char *unix_socket;
  // server_version
  char *server_version;
  // host_info
  char *host_info;
  // info
  char *info;
  // db
  char *db;
  // charset
  struct charset_info_st *charset;
  // fields
  struct st_mysql_field *fields;
  // field_alloc
  struct st_mem_root field_alloc;
  // affected_rows
  unsigned long long int affected_rows;
  // insert_id
  unsigned long long int insert_id;
  // extra_info
  unsigned long long int extra_info;
  // thread_id
  unsigned long int thread_id;
  // packet_length
  unsigned long int packet_length;
  // port
  unsigned int port;
  // client_flag
  unsigned long int client_flag;
  // server_capabilities
  unsigned long int server_capabilities;
  // protocol_version
  unsigned int protocol_version;
  // field_count
  unsigned int field_count;
  // server_status
  unsigned int server_status;
  // server_language
  unsigned int server_language;
  // warning_count
  unsigned int warning_count;
  // options
  struct st_mysql_options options;
  // status
  enum mysql_status status;
  // free_me
  char free_me;
  // reconnect
  char reconnect;
  // scramble
  char scramble[21l];
  // unused1
  char unused1;
  // unused2
  void *unused2;
  // unused3
  void *unused3;
  // unused4
  void *unused4;
  // unused5
  void *unused5;
  // stmts
  struct st_list *stmts;
  // methods
  struct st_mysql_methods *methods;
  // thd
  void *thd;
  // unbuffered_fetch_owner
  char *unbuffered_fetch_owner;
  // info_buffer
  char *info_buffer;
  // extension
  void *extension;
};

struct mysql_state_t_0
{
  // conn
  struct st_mysql conn;
  // connected
  signed int connected;
  // inserts
  signed int inserts;
};

struct mysql_state_t
{
};

struct pa_buffer_attr
{
  // maxlength
  unsigned int maxlength;
  // tlength
  unsigned int tlength;
  // prebuf
  unsigned int prebuf;
  // minreq
  unsigned int minreq;
  // fragsize
  unsigned int fragsize;
};

struct pa_channel_map
{
  // channels
  unsigned char channels;
  // map
  enum pa_channel_position map[32l];
};

struct pa_sample_spec
{
  // format
  enum pa_sample_format format;
  // rate
  unsigned int rate;
  // channels
  unsigned char channels;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct receiver
{
  // filter
  struct filter *filter;
  // name
  char name;
  // lastbit
  signed int lastbit;
  // num_ch
  signed int num_ch;
  // ch_ofs
  signed int ch_ofs;
  // pll
  unsigned int pll;
  // pllinc
  unsigned int pllinc;
  // decoder
  struct demod_state_t *decoder;
  // prev
  signed int prev;
  // last_levellog
  signed long int last_levellog;
};

struct serial_state_t
{
  // fd
  signed int fd;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct spblk
{
  // leftlink
  struct spblk *leftlink;
  // rightlink
  struct spblk *rightlink;
  // uplink
  struct spblk *uplink;
  // key
  unsigned int key;
  // data
  void *data;
};

struct sptree
{
  // root
  struct spblk *root;
  // symbols
  struct sptree *symbols;
  // eltscnt
  signed long long int eltscnt;
  // lookups
  signed long long int lookups;
  // lkpcmps
  signed long long int lkpcmps;
  // enqs
  signed long long int enqs;
  // enqcmps
  signed long long int enqcmps;
  // splays
  signed long long int splays;
  // splayloops
  signed long long int splayloops;
};

struct st_list
{
  // prev
  struct st_list *prev;
  // next
  struct st_list *next;
  // data
  void *data;
};

struct st_mysql_field
{
  // name
  char *name;
  // org_name
  char *org_name;
  // table
  char *table;
  // org_table
  char *org_table;
  // db
  char *db;
  // catalog
  char *catalog;
  // def
  char *def;
  // length
  unsigned long int length;
  // max_length
  unsigned long int max_length;
  // name_length
  unsigned int name_length;
  // org_name_length
  unsigned int org_name_length;
  // table_length
  unsigned int table_length;
  // org_table_length
  unsigned int org_table_length;
  // db_length
  unsigned int db_length;
  // catalog_length
  unsigned int catalog_length;
  // def_length
  unsigned int def_length;
  // flags
  unsigned int flags;
  // decimals
  unsigned int decimals;
  // charsetnr
  unsigned int charsetnr;
  // type
  enum enum_field_types type;
  // extension
  void *extension;
};

struct st_used_mem
{
  // next
  struct st_used_mem *next;
  // left
  unsigned int left;
  // size
  unsigned int size;
};

struct syment
{
  // next
  struct syment *next;
  // namelen
  signed int namelen;
  // name
  const char name[1l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct uplink_config_t
{
  // next
  struct uplink_config_t *next;
  // prevp
  struct uplink_config_t **prevp;
  // proto
  signed int proto;
  // name
  const char *name;
  // url
  const char *url;
};


// CrcTable
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 53
static signed long int CrcTable[128l];
// accesslog_basename
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 59
char accesslog_basename[18l] = { 'g', 'n', 'u', 'a', 'i', 's', '.', 'a', 'c', 'c', 'e', 's', 's', '.', 'l', 'o', 'g', 0 };
// accesslog_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 60
char *accesslog_dir = (char *)(void *)0;
// accesslog_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 62
signed int accesslog_file = -1;
// accesslog_fname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 61
char *accesslog_fname = (char *)(void *)0;
// accesslog_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 63
union anonymous_5 accesslog_lock = { .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } };
// address
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 39
struct sockaddr_un address;
// cache_positions
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 49
signed int cache_positions = 0;
// cache_spt
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 52
struct sptree *cache_spt;
// cache_spt_mut
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 53
union anonymous_1 cache_spt_mut = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// cfg_cmds
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 101
static struct cfgcmd cfg_cmds[23l];
// expiry_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 84
signed int expiry_interval;
// logdir
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 53
char *logdir;
// mycall
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 57
char *mycall;
// myemail
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 58
char *myemail;
// mylat
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 60
float mylat = (float)-200.0;
// mylng
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 61
float mylng = (float)-200.0;
// mysql_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 71
char *mysql_db;
// mysql_host
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 70
char *mysql_host;
// mysql_keepsmall
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 74
signed int mysql_keepsmall;
// mysql_oldlimit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 75
signed int mysql_oldlimit;
// mysql_password
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 73
char *mysql_password;
// mysql_user
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 72
char *mysql_user;
// new_uplink_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 80
struct uplink_config_t *new_uplink_config;
// serial_port
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 77
char *serial_port;
// skip_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 86
signed int skip_type[25l];
// sound_channels
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 67
signed int sound_channels = 1;
// sound_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 64
char *sound_device;
// sound_in_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 65
char *sound_in_file;
// sound_levellog
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 68
signed int sound_levellog = 0;
// sound_out_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 66
char *sound_out_file;
// stats_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 83
signed int stats_interval;
// cfg_cmds
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 101
static struct cfgcmd cfg_cmds[23l] = { { .name="logdir", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&logdir },
    { .name="mycall", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&mycall },
    { .name="myemail", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&myemail },
    { .name="latitude", .function=(signed int (*)(void *, signed int, char **))do_float, .dest=(void *)&mylat },
    { .name="longitude", .function=(signed int (*)(void *, signed int, char **))do_float, .dest=(void *)&mylng },
    { .name="statsinterval", .function=(signed int (*)(void *, signed int, char **))do_interval, .dest=(void *)&stats_interval },
    { .name="expiryinterval", .function=(signed int (*)(void *, signed int, char **))do_interval, .dest=(void *)&expiry_interval },
    { .name="uplink", .function=(signed int (*)(void *, signed int, char **))do_uplink, .dest=(void *)&new_uplink_config },
    { .name="mysql_host", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&mysql_host },
    { .name="mysql_db", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&mysql_db },
    { .name="mysql_user", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&mysql_user },
    { .name="mysql_password", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&mysql_password },
    { .name="mysql_keepsmall", .function=(signed int (*)(void *, signed int, char **))do_toggle, .dest=(void *)&mysql_keepsmall },
    { .name="mysql_oldlimit", .function=(signed int (*)(void *, signed int, char **))do_int, .dest=(void *)&mysql_oldlimit },
    { .name="sounddevice", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&sound_device },
    { .name="soundinfile", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&sound_in_file },
    { .name="soundoutfile", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&sound_out_file },
    { .name="soundchannels", .function=(signed int (*)(void *, signed int, char **))do_sound_ch, .dest=(void *)&sound_channels },
    { .name="soundlevellog", .function=(signed int (*)(void *, signed int, char **))do_int, .dest=(void *)&sound_levellog },
    { .name="serialport", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&serial_port },
    { .name="serial_port", .function=(signed int (*)(void *, signed int, char **))do_string, .dest=(void *)&serial_port },
    { .name="skip_type", .function=(signed int (*)(void *, signed int, char **))do_skip_type, .dest=(void *)&skip_type },
    { .name=(char *)(void *)0, .function=(signed int (*)(void *, signed int, char **))(void *)0, .dest=(void *)0 } };
// cfgfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 51
char *cfgfile;
// def_cfgfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 47
char def_cfgfile[12l] = { 'g', 'n', 'u', 'a', 'i', 's', '.', 'c', 'o', 'n', 'f', 0 };
// cfgfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 51
char *cfgfile = def_cfgfile;
// coeffs
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.c line 39
static float coeffs[36l] = { (float)2.5959e-55, (float)2.9479e-49, (float)1.4741e-43, (float)3.2462e-38, (float)3.1480e-33, (float)1.3443e-28, (float)2.5280e-24, (float)2.0934e-20, (float)7.6339e-17, (float)1.2259e-13, (float)8.6690e-11, (float)2.6996e-08, (float)3.7020e-06, (float)2.2355e-04, (float)5.9448e-03, (float)6.9616e-02, (float)3.5899e-01, (float)8.1522e-01, (float)8.1522e-01, (float)3.5899e-01, (float)6.9616e-02, (float)5.9448e-03, (float)2.2355e-04, (float)3.7020e-06, (float)2.6996e-08, (float)8.6690e-11, (float)1.2259e-13, (float)7.6339e-17, (float)2.0934e-20, (float)2.5280e-24, (float)1.3443e-28, (float)3.1480e-33, (float)3.2462e-38, (float)1.4741e-43, (float)2.9479e-49, (float)2.5959e-55 };
// crcinit_done
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 54
static signed int crcinit_done = 0;
// def_logname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 48
char def_logname[7l] = { 'g', 'n', 'u', 'a', 'i', 's', 0 };
// def_sound_device
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 49
char def_sound_device[8l] = { 'd', 'e', 'f', 'a', 'u', 'l', 't', 0 };
// done
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ais.c line 52
signed int done;
// dump_splay
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 45
signed int dump_splay = 0;
// fork_a_daemon
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 82
signed int fork_a_daemon;
// have_my_loc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 62
signed int have_my_loc;
// ipc_mut
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 42
union anonymous_1 ipc_mut = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ipc_th
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 40
static unsigned long int ipc_th;
// jsonout_die
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 51
static signed int jsonout_die = 0;
// jsonout_th
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 50
static unsigned long int jsonout_th;
// log_basename
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 53
char log_basename[11l] = { 'g', 'n', 'u', 'a', 'i', 's', '.', 'l', 'o', 'g', 0 };
// log_dest
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 48
signed int log_dest = 1;
// log_destnames
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 77
char *log_destnames[5l] = { "none", "stderr", "syslog", "file", (char *)(void *)0 };
// log_dir
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 54
char *log_dir = (char *)(void *)0;
// log_facility
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 50
signed int log_facility = 17 << 3;
// log_file
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 56
signed int log_file = -1;
// log_file_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 57
union anonymous_5 log_file_lock = { .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } };
// log_fname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 55
char *log_fname = (char *)(void *)0;
// log_level
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 49
signed int log_level = 6;
// log_levelnames
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 65
char *log_levelnames[9l] = { "EMERG", "ALERT", "CRIT", "ERR", "WARNING", "NOTICE", "INFO", "DEBUG", (char *)(void *)0 };
// log_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 51
char *log_name = (char *)(void *)0;
// logname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 55
char *logname;
// logname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 55
char *logname = def_logname;
// mem_panic
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.c line 38
signed int mem_panic = 0;
// my
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.h line 35
struct mysql_state_t_0 *my;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// pidfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 52
char *pidfile;
// socket_fd
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 38
signed int socket_fd;
// sp_allocated
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 59
signed long int sp_allocated = (signed long int)0;
// sp_entries
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 60
signed long int sp_entries = (signed long int)0;
// sp_free_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 58
struct spblk *sp_free_list = (struct spblk *)(void *)0;
// spt_symtab
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 39
struct sptree *spt_symtab = (struct sptree *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// uplink_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 79
struct uplink_config_t *uplink_config;
// verbose
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 88
signed int verbose;

// _curl_easy_getinfo_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 201
static void _curl_easy_getinfo_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_getinfo_err_double
// file /usr/include/curl/typecheck-gcc.h line 199
static void _curl_easy_getinfo_err_double(void)
{
  asm("");
}

// _curl_easy_getinfo_err_long
// file /usr/include/curl/typecheck-gcc.h line 197
static void _curl_easy_getinfo_err_long(void)
{
  asm("");
}

// _curl_easy_getinfo_err_string
// file /usr/include/curl/typecheck-gcc.h line 195
static void _curl_easy_getinfo_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// _sp_chop
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 209
static void _sp_chop(struct spblk *n)
{
  if(!(n->rightlink == ((struct spblk *)NULL)))
    _sp_chop(n->rightlink);

  if(!(n->leftlink == ((struct spblk *)NULL)))
    _sp_chop(n->leftlink);

  sp_free_blk(n);
}

// _sp_deq
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 609
extern struct spblk * _sp_deq(struct spblk **np)
{
  struct spblk *deq;
  struct spblk *next;
  struct spblk *left;
  struct spblk *farleft;
  struct spblk *farfarleft;
  _Bool tmp_if_expr_1;
  if(np == ((struct spblk **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *np == (struct spblk *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (struct spblk *)(void *)0;

  else
  {
    next = *np;
    left = next->leftlink;
    if(left == ((struct spblk *)NULL))
    {
      deq = next;
      *np = next->rightlink;
      if(!(*np == ((struct spblk *)NULL)))
        (*np)->uplink = (struct spblk *)(void *)0;

      return deq;
    }

    else
    {
      do
      {
        farleft = left->leftlink;
        if(farleft == ((struct spblk *)NULL))
        {
          deq = left;
          next->leftlink = left->rightlink;
          if(!(left->rightlink == ((struct spblk *)NULL)))
            left->rightlink->uplink = next;

          break;
        }

        farfarleft = farleft->leftlink;
        if(farfarleft == ((struct spblk *)NULL))
        {
          deq = farleft;
          left->leftlink = farleft->rightlink;
          if(!(farleft->rightlink == ((struct spblk *)NULL)))
            farleft->rightlink->uplink = left;

          break;
        }

        next->leftlink = farleft;
        farleft->uplink = next;
        left->leftlink = farleft->rightlink;
        if(!(farleft->rightlink == ((struct spblk *)NULL)))
          farleft->rightlink->uplink = left;

        farleft->rightlink = left;
        left->uplink = farleft;
        next = farleft;
        left = farfarleft;
      }
      while((_Bool)1);
      return deq;
    }
  }
}

// _sp_enq
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 481
extern struct spblk * _sp_enq(struct spblk *n, struct sptree *q)
{
  struct spblk *left;
  struct spblk *right;
  struct spblk *next;
  struct spblk *temp;
  unsigned int key;
  q->enqs = q->enqs + 1ll;
  n->uplink = (struct spblk *)(void *)0;
  next = q->root;
  q->root = n;
  if(next == ((struct spblk *)NULL))
  {
    n->leftlink = (struct spblk *)(void *)0;
    n->rightlink = (struct spblk *)(void *)0;
  }

  else
  {
    key = n->key;
    left = n;
    right = n;
    q->enqcmps = q->enqcmps + 1ll;
    if(!(next->key >= key))
      do
      {

      one:
        ;
        temp = next->rightlink;
        if(temp == ((struct spblk *)NULL))
        {
          left->rightlink = next;
          next->uplink = left;
          right->leftlink = (struct spblk *)(void *)0;
          goto done;
        }

        q->enqcmps = q->enqcmps + 1ll;
        if(temp->key >= key)
        {
          left->rightlink = next;
          next->uplink = left;
          left = next;
          next = temp;
          break;
        }

        next->rightlink = temp->leftlink;
        if(!(temp->leftlink == ((struct spblk *)NULL)))
          temp->leftlink->uplink = next;

        left->rightlink = temp;
        temp->uplink = left;
        temp->leftlink = next;
        next->uplink = temp;
        left = temp;
        next = temp->rightlink;
        if(next == ((struct spblk *)NULL))
        {
          right->leftlink = (struct spblk *)(void *)0;
          goto done;
        }

        q->enqcmps = q->enqcmps + 1ll;
      }
      while(!(next->key >= key));

    do
    {

    two:
      ;
      temp = next->leftlink;
      if(temp == ((struct spblk *)NULL))
      {
        right->leftlink = next;
        next->uplink = right;
        left->rightlink = (struct spblk *)(void *)0;
        goto done;
      }

      q->enqcmps = q->enqcmps + 1ll;
      if(!(temp->key >= key))
      {
        right->leftlink = next;
        next->uplink = right;
        right = next;
        next = temp;
        goto one;
      }

      next->leftlink = temp->rightlink;
      if(!(temp->rightlink == ((struct spblk *)NULL)))
        temp->rightlink->uplink = next;

      right->leftlink = temp;
      temp->uplink = right;
      temp->rightlink = next;
      next->uplink = temp;
      right = temp;
      next = temp->leftlink;
      if(next == ((struct spblk *)NULL))
      {
        left->rightlink = (struct spblk *)(void *)0;
        goto done;
      }

      q->enqcmps = q->enqcmps + 1ll;
    }
    while(next->key >= key);
    goto one;

  done:
    ;
    temp = n->leftlink;
    n->leftlink = n->rightlink;
    n->rightlink = temp;
  }
  return n;
}

// _splay
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 684
extern void _splay(struct spblk *n, struct sptree *q)
{
  struct spblk *up;
  struct spblk *prev;
  struct spblk *upup;
  struct spblk *upupup;
  struct spblk *left;
  struct spblk *right;
  left = n->leftlink;
  right = n->rightlink;
  prev = n;
  up = prev->uplink;
  q->splays = q->splays + 1ll;
  for( ; !(up == ((struct spblk *)NULL)); up = upup)
  {
    q->splayloops = q->splayloops + 1ll;
    upup = up->uplink;
    if(up->leftlink == prev)
    {
      if(!(upup == ((struct spblk *)NULL)))
      {
        if(upup->leftlink == up)
        {
          upupup = upup->uplink;
          upup->leftlink = up->rightlink;
          if(!(upup->leftlink == ((struct spblk *)NULL)))
            upup->leftlink->uplink = upup;

          up->rightlink = upup;
          upup->uplink = up;
          if(upupup == ((struct spblk *)NULL))
            q->root = up;

          else
            if(upupup->leftlink == upup)
              upupup->leftlink = up;

            else
              upupup->rightlink = up;
          up->uplink = upupup;
          upup = upupup;
        }

      }

      up->leftlink = right;
      if(!(right == ((struct spblk *)NULL)))
        right->uplink = up;

      right = up;
    }

    else
    {
      if(!(upup == ((struct spblk *)NULL)))
      {
        if(upup->rightlink == up)
        {
          upupup = upup->uplink;
          upup->rightlink = up->leftlink;
          if(!(upup->rightlink == ((struct spblk *)NULL)))
            upup->rightlink->uplink = upup;

          up->leftlink = upup;
          upup->uplink = up;
          if(upupup == ((struct spblk *)NULL))
            q->root = up;

          else
            if(upupup->rightlink == upup)
              upupup->rightlink = up;

            else
              upupup->leftlink = up;
          up->uplink = upupup;
          upup = upupup;
        }

      }

      up->rightlink = left;
      if(!(left == ((struct spblk *)NULL)))
        left->uplink = up;

      left = up;
    }
    prev = up;
  }
  n->leftlink = left;
  n->rightlink = right;
  if(!(left == ((struct spblk *)NULL)))
    left->uplink = n;

  if(!(right == ((struct spblk *)NULL)))
    right->uplink = n;

  q->root = n;
  n->uplink = (struct spblk *)(void *)0;
}

// accesslog
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 323
extern signed int accesslog(const char *fmt, ...)
{
  void **args;
  char s[8192l];
  char wb[8192l];
  signed long int t;
  struct tm lt;
  signed int len;
  signed long int w;
  args = (void **)&fmt;
  vsnprintf(s, (unsigned long int)8192, fmt, args);
  args = ((void **)NULL);
  s[(signed long int)(8192 - 1)] = (char)0;
  time(&t);
  gmtime_r(&t, &lt);
  len=snprintf(wb, (unsigned long int)8192, "[%4.4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d] %s\n", lt.tm_year + 1900, lt.tm_mon + 1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec, (const void *)s);
  wb[(signed long int)(8192 - 1)] = (char)0;
  pthread_rwlock_rdlock(&accesslog_lock);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(accesslog_file >= 0)
  {
    w=write(accesslog_file, (const void *)wb, (unsigned long int)len);
    if(!(w == (signed long int)len))
    {
      return_value___errno_location_1=__errno_location();
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      hlog(2, "Could not write to %s (fd %d): %s", accesslog_fname, accesslog_file, return_value_strerror_2);
    }

  }

  else
    if(!(accesslog_file == -666))
    {
      hlog(3, "Access log not open, log lines are lost!");
      accesslog_file = -666;
    }

  pthread_rwlock_unlock(&accesslog_lock);
  return 1;
}

// accesslog_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 298
extern signed int accesslog_close(char *reopenpath)
{
  hlog(7, "Closing access log...");
  pthread_rwlock_wrlock(&accesslog_lock);
  hlog(7, "Closing access log, got lock");
  signed int return_value_close_3;
  return_value_close_3=close(accesslog_file);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!(return_value_close_3 == 0))
  {
    return_value___errno_location_1=__errno_location();
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    hlog(2, "Could not close %s: %s", accesslog_fname, return_value_strerror_2);
  }

  hfree((void *)accesslog_fname);
  hfree((void *)accesslog_dir);
  accesslog_dir = (char *)(void *)0;
  accesslog_fname = accesslog_dir;
  accesslog_file = -1;
  if(!(reopenpath == ((char *)NULL)))
  {
    signed int return_value_accesslog_open_4;
    return_value_accesslog_open_4=accesslog_open(reopenpath, 1);
    return return_value_accesslog_open_4;
  }

  else
  {
    pthread_rwlock_unlock(&accesslog_lock);
    return 0;
  }
}

// accesslog_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 270
extern signed int accesslog_open(char *logd, signed int reopen)
{
  if(reopen == 0)
    pthread_rwlock_wrlock(&accesslog_lock);

  if(!(accesslog_fname == ((char *)NULL)))
    hfree((void *)accesslog_fname);

  if(!(accesslog_dir == ((char *)NULL)))
    hfree((void *)accesslog_dir);

  accesslog_dir=hstrdup(logd);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(accesslog_dir);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(accesslog_basename);
  void *return_value_hmalloc_3;
  return_value_hmalloc_3=hmalloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
  accesslog_fname = (char *)return_value_hmalloc_3;
  sprintf(accesslog_fname, "%s/%s", accesslog_dir, (const void *)accesslog_basename);
  accesslog_file=open(accesslog_fname, 01 | 0100 | 02000, 0400 | 0200 | 0400 >> 3);
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(!(accesslog_file >= 0))
  {
    return_value___errno_location_4=__errno_location();
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    hlog(2, "Could not open %s: %s", accesslog_fname, return_value_strerror_5);
  }

  pthread_rwlock_unlock(&accesslog_lock);
  return accesslog_file;
}

// appid_ifm
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 220
const char * appid_ifm(signed int i)
{
  switch(i)
  {
    case 0:
      return "text-telegram";
    case 1:
      return "application-ack";
    case 2:
      return "iai-fi-capab-interrogation";
    case 3:
      return "iai-capabi-interrogation";
    case 4:
      return "capability-reply";
    case 11:
      return "tide-weather";
    case 16:
      return "vts-targets";
    case 17:
      return "ship-waypoints";
    case 18:
      return "advice-of-waypoints";
    case 19:
      return "extended-ship-data";
    case 20:
      return "berthing-data";
    case 21:
      return "weather-obs-report";
    case 22:
      return "area-notice-bc";
    case 23:
      return "area-notice-addr";
    case 24:
      return "extended-ship-static";
    case 25:
      return "dangerous-cargo-info";
    case 26:
      return "environmental";
    case 27:
      return "route-info-bc";
    case 28:
      return "route-info-addr";
    case 29:
      return "text-description-bc";
    case 30:
      return "text-description-addr";
    case 40:
      return "persons-on-board";
    default:
      return "unknown";
  }
  return "unknown";
}

// argstr
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 294
extern char * argstr(signed int arg, signed int argc, char **argv)
{
  signed int i;
  static char s[102400l];
  s[(signed long int)0] = (char)0;
  i = arg;
  for( ; !(i >= argc); i = i + 1)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    strncat(s, argv[(signed long int)i], (sizeof(char [102400l]) /*102400ul*/  - return_value_strlen_1) - (unsigned long int)1);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(s);
    strncat(s, " ", (sizeof(char [102400l]) /*102400ul*/  - return_value_strlen_2) - (unsigned long int)1);
  }
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(s);
  i = (signed int)return_value_strlen_3;
  if(i >= 1)
    s[(signed long int)(i - 1)] = (char)0;

  return s;
}

// brokenconnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ais.c line 58
void brokenconnection(signed int sig)
{
  hlog(7, "There is a broken connection\n");
}

// cache_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.h line 62
extern signed int cache_deinit(void)
{
  signed int ret;
  pthread_mutex_lock(&cache_spt_mut);
  ret=cache_free(cache_spt);
  hfree((void *)cache_spt);
  sp_free_freelist();
  pthread_mutex_unlock(&cache_spt_mut);
  return ret;
}

// cache_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 99
extern signed int cache_free(struct sptree *sp)
{
  struct spblk *x;
  struct spblk *nextx;
  struct cache_ent *e;
  signed int freed = 0;
  x=sp_fhead(sp);
  for( ; !(x == ((struct spblk *)NULL)); x = nextx)
  {
    nextx=sp_fnext(x);
    e = (struct cache_ent *)x->data;
    cache_free_entry(e);
    sp_delete(x, sp);
    freed = freed + 1;
  }
  hlog(7, "cache_free: %d ship entries freed", freed);
  return 0;
}

// cache_free_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 84
extern void cache_free_entry(struct cache_ent *e)
{
  if(!(e->name == ((char *)NULL)))
    hfree((void *)e->name);

  if(!(e->destination == ((char *)NULL)))
    hfree((void *)e->destination);

  if(!(e->callsign == ((char *)NULL)))
    hfree((void *)e->callsign);

  hfree((void *)e);
}

// cache_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 163
static struct cache_ent * cache_get(signed int mmsi)
{
  struct spblk *spl;
  struct cache_ent *e;
  spl=sp_lookup((unsigned int)mmsi, cache_spt);
  if(!(spl == ((struct spblk *)NULL)))
    e = (struct cache_ent *)spl->data;

  else
  {
    spl=sp_install((unsigned int)mmsi, cache_spt);
    void *return_value_hmalloc_1;
    return_value_hmalloc_1=hmalloc(sizeof(struct cache_ent) /*120ul*/ );
    e = (struct cache_ent *)return_value_hmalloc_1;
    spl->data = (void *)e;
    memset((void *)e, 0, sizeof(struct cache_ent) /*120ul*/ );
    e->lat = (float)0;
    e->lon = (float)0;
    e->hdg = -1;
    e->course = (float)-1;
    e->sog = (float)-1;
    e->shiptype = -1;
    e->imo = -1;
    e->navstat = -1;
    e->D = -1;
    e->C = e->D;
    e->B = e->C;
    e->A = e->B;
    e->persons_on_board = -1;
  }
  return e;
}

// cache_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.h line 61
extern signed int cache_init(void)
{
  crcinit();
  pthread_mutex_lock(&cache_spt_mut);
  cache_spt=sp_init();
  cache_spt->symbols = (struct sptree *)(void *)0;
  pthread_mutex_unlock(&cache_spt_mut);
  cache_positions = 1;
  return 0;
}

// cache_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 204
extern signed int cache_position(signed int received_t, signed int mmsi, signed int navstat, float lat, float lon, signed int hdg, float course, signed int rateofturn, float sog)
{
  struct cache_ent *e;
  pthread_mutex_lock(&cache_spt_mut);
  e=cache_get(mmsi);
  e->mmsi = mmsi;
  e->received_pos = (signed long int)received_t;
  e->mmsi = mmsi;
  e->lat = lat;
  e->lon = lon;
  e->hdg = hdg;
  e->course = course;
  e->sog = sog;
  e->navstat = navstat;
  pthread_mutex_unlock(&cache_spt_mut);
  return 0;
}

// cache_rotate
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 143
extern struct sptree * cache_rotate(void)
{
  struct sptree *got_spt;
  pthread_mutex_lock(&cache_spt_mut);
  got_spt = cache_spt;
  cache_spt=sp_init();
  cache_spt->symbols = (struct sptree *)(void *)0;
  pthread_mutex_unlock(&cache_spt_mut);
  return got_spt;
}

// cache_vessel_persons
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 366
extern signed int cache_vessel_persons(signed int received_t, signed int mmsi, signed int persons_on_board)
{
  struct cache_ent *e;
  pthread_mutex_lock(&cache_spt_mut);
  e=cache_get(mmsi);
  e->mmsi = mmsi;
  e->received_persons_on_board = (signed long int)received_t;
  e->persons_on_board = persons_on_board;
  pthread_mutex_unlock(&cache_spt_mut);
  return 0;
}

// cache_vesseldata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 235
extern signed int cache_vesseldata(signed int received_t, signed int mmsi, signed int imo, char *callsign, char *name, char *destination, signed int shiptype, signed int A, signed int B, signed int C, signed int D, float draught)
{
  struct cache_ent *e;
  pthread_mutex_lock(&cache_spt_mut);
  e=cache_get(mmsi);
  e->mmsi = mmsi;
  e->imo = imo;
  e->received_data = (signed long int)received_t;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(e->callsign == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(e->callsign, callsign);
    tmp_if_expr_2 = return_value_strcmp_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(!(e->callsign == ((char *)NULL)))
      hfree((void *)e->callsign);

    e->callsign=hstrdup(callsign);
  }

  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(e->name == ((char *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strcmp_3=strcmp(e->name, name);
    tmp_if_expr_4 = return_value_strcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    if(!(e->name == ((char *)NULL)))
      hfree((void *)e->name);

    e->name=hstrdup(name);
  }

  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  if(e->destination == ((char *)NULL))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_strcmp_5=strcmp(e->destination, destination);
    tmp_if_expr_6 = return_value_strcmp_5 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
  {
    if(!(e->destination == ((char *)NULL)))
      hfree((void *)e->destination);

    e->destination=hstrdup(destination);
  }

  e->shiptype = shiptype;
  e->A = A;
  e->B = B;
  e->C = C;
  e->D = D;
  e->draught = draught;
  pthread_mutex_unlock(&cache_spt_mut);
  return 0;
}

// cache_vesseldatab
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 277
extern signed int cache_vesseldatab(signed int received_t, signed int mmsi, char *callsign, signed int shiptype, signed int A, signed int B, signed int C, signed int D)
{
  struct cache_ent *e;
  pthread_mutex_lock(&cache_spt_mut);
  e=cache_get(mmsi);
  e->mmsi = mmsi;
  e->imo = 0;
  e->received_data = (signed long int)received_t;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(e->callsign == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(e->callsign, callsign);
    tmp_if_expr_2 = return_value_strcmp_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(!(e->callsign == ((char *)NULL)))
      hfree((void *)e->callsign);

    e->callsign=hstrdup(callsign);
  }

  e->shiptype = shiptype;
  e->A = A;
  e->B = B;
  e->C = C;
  e->D = D;
  e->draught = (float)0;
  pthread_mutex_unlock(&cache_spt_mut);
  return 0;
}

// cache_vesseldatabb
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 310
extern signed int cache_vesseldatabb(signed int received_t, signed int mmsi, signed int shiptype, signed int A, signed int B, signed int C, signed int D)
{
  struct cache_ent *e;
  pthread_mutex_lock(&cache_spt_mut);
  e=cache_get(mmsi);
  e->mmsi = mmsi;
  e->imo = 0;
  e->received_data = (signed long int)received_t;
  e->shiptype = shiptype;
  e->A = A;
  e->B = B;
  e->C = C;
  e->D = D;
  e->draught = (float)0;
  pthread_mutex_unlock(&cache_spt_mut);
  return 0;
}

// cache_vesselname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cache.c line 336
extern signed int cache_vesselname(signed int received_t, signed int mmsi, char *name, const char *destination)
{
  struct cache_ent *e;
  pthread_mutex_lock(&cache_spt_mut);
  e=cache_get(mmsi);
  e->mmsi = mmsi;
  e->received_data = (signed long int)received_t;
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(e->name == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(e->name, name);
    tmp_if_expr_2 = return_value_strcmp_1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(!(e->name == ((char *)NULL)))
      hfree((void *)e->name);

    e->name=hstrdup(name);
  }

  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(e->destination == ((char *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strcmp_3=strcmp(e->destination, destination);
    tmp_if_expr_4 = return_value_strcmp_3 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    if(!(e->destination == ((char *)NULL)))
      hfree((void *)e->destination);

    e->destination=hstrdup(destination);
  }

  pthread_mutex_unlock(&cache_spt_mut);
  return 0;
}

// close_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 47
extern signed int close_log(signed int reopen)
{
  char *s;
  s=hstrdup(log_name);
  pthread_rwlock_wrlock(&log_file_lock);
  if(!(log_name == ((char *)NULL)))
  {
    hfree((void *)log_name);
    log_name = (char *)(void *)0;
  }

  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(log_dest == 2)
    closelog();

  else
    if(log_dest == 3)
    {
      signed int return_value_close_3;
      return_value_close_3=close(log_file);
      if(!(return_value_close_3 == 0))
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fprintf(stderr, "hemserv logger: Could not close log file %s: %s\n", log_fname, return_value_strerror_2);
      }

      log_file = -1;
      hfree((void *)log_fname);
      log_fname = (char *)(void *)0;
    }

  if(!(reopen == 0))
    open_log(s, 1);

  if(reopen == 0)
    pthread_rwlock_unlock(&log_file_lock);

  hfree((void *)s);
  return 0;
}

// closedown
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ais.c line 54
void closedown(signed int sig)
{
  done = 1;
}

// cmdparse
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 316
signed int cmdparse(struct cfgcmd *cmds, char *cmdline)
{
  struct cfgcmd *cmdp;
  signed int argc;
  char *argv[256l];
  argc=parse_args(argv, cmdline);
  _Bool tmp_if_expr_1;
  if(argc == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*argv[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
  unsigned long int return_value_strlen_2;
  signed int return_value_strncasecmp_3;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    strlwr(argv[(signed long int)0]);
    cmdp = cmds;
    for( ; !(cmdp->function == ((signed int (*)(void *, signed int, char **))NULL)); cmdp = cmdp + 1l)
    {
      return_value_strlen_2=strlen(argv[(signed long int)0]);
      return_value_strncasecmp_3=strncasecmp(cmdp->name, argv[(signed long int)0], return_value_strlen_2);
      if(return_value_strncasecmp_3 == 0)
        break;

    }
    if(cmdp->function == ((signed int (*)(void *, signed int, char **))NULL))
    {
      fprintf(stderr, "No such configuration file directive: %s\n", argv[(signed long int)0]);
      return -1;
    }

    else
    {
      signed int return_value;
      return_value=cmdp->function(cmdp->dest, argc, argv);
      return return_value;
    }
  }
}

// cpfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 42
signed int cpfile(const char *to, const char *from)
{
  signed int fd_to;
  signed int fd_from;
  char buf[4096l];
  signed long int nread;
  signed int saved_errno;
  fd_from=open(from, 00);
  signed int *return_value___errno_location_1;
  if(!(fd_from >= 0))
    return -1;

  else
  {
    fd_to=open(to, 01 | 0100 | 0200, 0666);
    if(fd_to >= 0)
    {
      do
      {
        nread=read(fd_from, (void *)buf, sizeof(char [4096l]) /*4096ul*/ );
        if(!(nread >= 1l))
          break;

        char *out_ptr = buf;
        signed long int nwritten;
        do
        {
          nwritten=write(fd_to, (const void *)out_ptr, (unsigned long int)nread);
          if(nwritten >= 0l)
          {
            nread = nread - nwritten;
            out_ptr = out_ptr + nwritten;
          }

          else
          {
            return_value___errno_location_1=__errno_location();
            if(!(*return_value___errno_location_1 == 4))
              goto out_error;

          }
        }
        while(nread >= 1l);
      }
      while((_Bool)1);
      if(nread == 0l)
      {
        signed int return_value_close_2;
        return_value_close_2=close(fd_to);
        if(!(return_value_close_2 >= 0))
          fd_to = -1;

        else
        {
          close(fd_from);
          return 0;
        }
      }

    }


  out_error:
    ;
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    saved_errno = *return_value___errno_location_3;
    close(fd_from);
    if(fd_to >= 0)
      close(fd_to);

    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = saved_errno;
    return -1;
  }
}

// crc32
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 93
extern unsigned long int crc32(const unsigned char *s)
{
  unsigned long int key;
  if(crcinit_done == 0)
    crcinit();

  key = (unsigned long int)0;
  for( ; !(*s == 0); s = s + 1l)
    key = key >> 7 ^ (unsigned long int)CrcTable[(signed long int)((key ^ (unsigned long int)*s) & (unsigned long int)0x7f)];
  key = key & 0xFFFFFFFFUL;
  return key;
}

// crc32n
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 75
extern unsigned long int crc32n(const unsigned char *s, signed int slen)
{
  unsigned long int key;
  if(crcinit_done == 0)
    crcinit();

  key = (unsigned long int)0;
  for( ; slen >= 1; slen = slen - 1)
  {
    key = key >> 7 ^ (unsigned long int)CrcTable[(signed long int)((key ^ (unsigned long int)*s) & (unsigned long int)0x7f)];
    s = s + 1l;
  }
  key = key & 0xFFFFFFFFUL;
  return key;
}

// crcinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/crc32.c line 56
extern void crcinit(void)
{
  signed int i;
  signed int j;
  signed long int sum;
  if(crcinit_done == 0)
  {
    i = 0;
    for( ; !(i >= 128); i = i + 1)
    {
      sum = (signed long int)0;
      j = 7 - 1;
      for( ; j >= 0; j = j - 1)
        if(!((1 << j & i) == 0))
          sum = sum ^ (signed long int)(0x48000000 >> j);

      CrcTable[(signed long int)i] = sum;
    }
    crcinit_done = 1;
  }

}

// curl_wdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 61
unsigned long int curl_wdata(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  return size * nmemb;
}

// do_float
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 38
extern signed int do_float(float *dest, signed int argc, char **argv)
{
  if(!(argc >= 2))
    return -1;

  else
  {
    double return_value_atof_1;
    return_value_atof_1=atof(argv[(signed long int)1]);
    *dest = (float)return_value_atof_1;
    return 0;
  }
}

// do_int
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 37
extern signed int do_int(signed int *dest, signed int argc, char **argv)
{
  if(!(argc >= 2))
    return -1;

  else
  {
    *dest=atoi(argv[(signed long int)1]);
    return 0;
  }
}

// do_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 190
signed int do_interval(signed int *dest, signed int argc, char **argv)
{
  if(!(argc >= 2))
    return -1;

  else
  {
    signed long int return_value_parse_interval_1;
    return_value_parse_interval_1=parse_interval(argv[(signed long int)1]);
    *dest = (signed int)return_value_parse_interval_1;
    return 0;
  }
}

// do_skip_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 203
signed int do_skip_type(signed int *dest, signed int argc, char **argv)
{
  signed int i;
  if(!(argc >= 2))
    return -1;

  else
  {
    i=atoi(argv[(signed long int)1]);
    if(i >= 1 && !(i >= 25))
      skip_type[(signed long int)i] = 1;

    else
    {
      hlog(2, "skip_type value out of range: %d", i);
      return -1;
    }
    return 0;
  }
}

// do_sound_ch
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 226
signed int do_sound_ch(signed int *dest, signed int argc, char **argv)
{
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(!(argc >= 2))
    return -1;

  else
  {
    signed int return_value_strcasecmp_4;
    return_value_strcasecmp_4=strcasecmp(argv[(signed long int)1], "mono");
    if(return_value_strcasecmp_4 == 0)
      *dest = 1;

    else
    {
      return_value_strcasecmp_3=strcasecmp(argv[(signed long int)1], "both");
      if(return_value_strcasecmp_3 == 0)
        *dest = 2;

      else
      {
        return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "left");
        if(return_value_strcasecmp_2 == 0)
          *dest = 3;

        else
        {
          return_value_strcasecmp_1=strcasecmp(argv[(signed long int)1], "right");
          if(return_value_strcasecmp_1 == 0)
            *dest = 4;

          else
          {
            hlog(2, "SoundChannels value unknown: %s", argv[(signed long int)1]);
            return -1;
          }
        }
      }
    }
    return 0;
  }
}

// do_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 36
extern signed int do_string(char **dest, signed int argc, char **argv)
{
  if(!(argc >= 2))
    return -1;

  else
  {
    if(!(*dest == ((char *)NULL)))
      hfree((void *)*dest);

    *dest=hstrdup(argv[(signed long int)1]);
    return 0;
  }
}

// do_toggle
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 39
extern signed int do_toggle(signed int *dest, signed int argc, char **argv)
{
  _Bool tmp_if_expr_3;
  signed int return_value_strcasecmp_2;
  _Bool tmp_if_expr_5;
  signed int return_value_strcasecmp_4;
  _Bool tmp_if_expr_7;
  signed int return_value_strcasecmp_6;
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  _Bool tmp_if_expr_11;
  signed int return_value_strcasecmp_10;
  if(!(argc >= 2))
    return -1;

  else
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(argv[(signed long int)1], "true");
    if(return_value_strcasecmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcasecmp_2=strcasecmp(argv[(signed long int)1], "on");
      tmp_if_expr_3 = return_value_strcasecmp_2 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcasecmp_4=strcasecmp(argv[(signed long int)1], "1");
      tmp_if_expr_5 = return_value_strcasecmp_4 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strcasecmp_6=strcasecmp(argv[(signed long int)1], "enable");
      tmp_if_expr_7 = return_value_strcasecmp_6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcasecmp_8=strcasecmp(argv[(signed long int)1], "enabled");
      tmp_if_expr_9 = return_value_strcasecmp_8 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_strcasecmp_10=strcasecmp(argv[(signed long int)1], "yes");
      tmp_if_expr_11 = return_value_strcasecmp_10 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
    {
      *dest = 1;
      return 1;
    }

    else
    {
      *dest = 0;
      return 0;
    }
  }
}

// do_uplink
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 254
signed int do_uplink(struct uplink_config_t **lq, signed int argc, char **argv)
{
  struct uplink_config_t *l;
  signed int uplink_proto = 0;
  if(!(argc >= 3))
    return -1;

  else
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(argv[(signed long int)2], "json");
    if(return_value_strcasecmp_1 == 0)
      uplink_proto = 1;

    else
    {
      hlog(3, "Uplink: Unsupported uplink protocol '%s'\n", argv[(signed long int)2]);
      return -2;
    }
    void *return_value_hmalloc_2;
    return_value_hmalloc_2=hmalloc(sizeof(struct uplink_config_t) /*40ul*/ );
    l = (struct uplink_config_t *)return_value_hmalloc_2;
    l->proto = uplink_proto;
    l->name=hstrdup(argv[(signed long int)1]);
    l->url=hstrdup(argv[(signed long int)3]);
    l->next = *lq;
    if(!(l->next == ((struct uplink_config_t *)NULL)))
      l->next->prevp = &l->next;

    *lq = l;
    return 0;
  }
}

// filter_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.h line 65
extern void filter_free(struct filter *f)
{
  if(!(f == ((struct filter *)NULL)))
  {
    hfree((void *)f->taps);
    hfree((void *)f);
  }

}

// filter_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.h line 64
extern struct filter * filter_init(signed int len, float *taps)
{
  struct filter *f;
  void *return_value_hmalloc_1;
  return_value_hmalloc_1=hmalloc(sizeof(struct filter) /*4120ul*/ );
  f = (struct filter *)return_value_hmalloc_1;
  memset((void *)f, 0, sizeof(struct filter) /*4120ul*/ );
  void *return_value_hmalloc_2;
  return_value_hmalloc_2=hmalloc((unsigned long int)len * sizeof(float) /*4ul*/ );
  f->taps = (float *)return_value_hmalloc_2;
  memcpy((void *)f->taps, (const void *)taps, (unsigned long int)len * sizeof(float) /*4ul*/ );
  f->length = len;
  f->pointer = f->length;
  return f;
}

// filter_mac
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.c line 43
float filter_mac(const float *a, const float *b, signed int size)
{
  float sum = (float)0;
  signed int i = 0;
  for( ; !(i >= size); i = i + 1)
    sum = sum + a[(signed long int)i] * b[(signed long int)i];
  return sum;
}

// filter_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.c line 83
extern void filter_run(struct filter *f, float in, float *out)
{
  float *ptr;
  signed int tmp_post_1 = f->pointer;
  f->pointer = f->pointer + 1;
  ptr = f->buffer + (signed long int)tmp_post_1;
  *ptr = in;
  *out=filter_mac(ptr - (signed long int)f->length, f->taps, f->length);
  if(f->pointer == 1024)
  {
    memcpy((void *)f->buffer, (const void *)((f->buffer + (signed long int)1024) - (signed long int)f->length), (unsigned long int)f->length * sizeof(float) /*4ul*/ );
    f->pointer = f->length;
  }

}

// filter_run_buf
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/filter.h line 68
extern signed short int filter_run_buf(struct filter *f, signed short int *in, float *out, signed int step, signed int len)
{
  signed int id = 0;
  signed int od = 0;
  signed short int maxval = (signed short int)0;
  signed int pointer = f->pointer;
  float *buffer = f->buffer;
  for( ; !(od >= len); od = od + 1)
  {
    buffer[(signed long int)pointer] = (float)in[(signed long int)id];
    if(!((signed int)maxval >= (signed int)in[(signed long int)id]))
      maxval = in[(signed long int)id];

    out[(signed long int)od]=filter_mac(&buffer[(signed long int)(pointer - f->length)], f->taps, f->length);
    pointer = pointer + 1;
    if(pointer == 1024)
    {
      memcpy((void *)buffer, (const void *)((buffer + (signed long int)1024) - (signed long int)f->length), (unsigned long int)f->length * sizeof(float) /*4ul*/ );
      pointer = f->length;
    }

    id = id + step;
  }
  f->pointer = pointer;
  return maxval;
}

// free_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 97
extern void free_config(void)
{
  hfree((void *)logdir);
  hfree((void *)pidfile);
  if(!(cfgfile == def_cfgfile))
    hfree((void *)cfgfile);

  if(!(logname == def_logname))
    hfree((void *)logname);

  if(!(sound_device == def_sound_device))
    hfree((void *)sound_device);

  hfree((void *)sound_in_file);
  hfree((void *)sound_out_file);
  hfree((void *)mysql_host);
  hfree((void *)mysql_db);
  hfree((void *)mysql_user);
  hfree((void *)mysql_password);
  hfree((void *)serial_port);
  hfree((void *)mycall);
  hfree((void *)myemail);
  free_uplink_config(&uplink_config);
}

// free_receiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 49
extern void free_receiver(struct receiver *rx)
{
  if(!(rx == ((struct receiver *)NULL)))
  {
    filter_free(rx->filter);
    hfree((void *)rx);
  }

}

// free_uplink_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 135
void free_uplink_config(struct uplink_config_t **lc)
{
  struct uplink_config_t *this;
  while(!(*lc == ((struct uplink_config_t *)NULL)))
  {
    this = *lc;
    *lc = this->next;
    hfree((void *)this->name);
    hfree((void *)this->url);
    hfree((void *)this);
  }
}

// gnuais_ipc_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.h line 35
void gnuais_ipc_deinit(struct ipc_state_t *ipc)
{
  signed int ret;
  shutdown(socket_fd, 2);
  ret=pthread_join(ipc_th, (void **)(void *)0);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    hlog(2, "pthread_join of gnuais_ipc_socketlistener failed: %s", return_value_strerror_1);
    goto __CPROVER_DUMP_L2;
  }

  unlink("/tmp/gnuais.socket");
  hfree((void *)ipc);

__CPROVER_DUMP_L2:
  ;
}

// gnuais_ipc_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.h line 34
struct ipc_state_t * gnuais_ipc_init()
{
  struct ipc_state_t *s;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ipc_state_t) /*84ul*/ );
  s = (struct ipc_state_t *)return_value_malloc_1;
  signed int returnvalue = 0;
  s->numclientsockets = 0;
  socket_fd=socket(1, 1, 0);
  signed int return_value_bind_2;
  signed int return_value_listen_3;
  signed int return_value_gnuais_ipc_startthread_4;
  if(!(socket_fd >= 0))
  {
    hlog(3, "socket() failed");
    returnvalue = -1;
  }

  else
  {
    unlink("/tmp/gnuais.socket");
    memset((void *)&address, 0, sizeof(struct sockaddr_un) /*110ul*/ );
    address.sun_family = (unsigned short int)1;
    snprintf(address.sun_path, (unsigned long int)100, "/tmp/gnuais.socket");
    return_value_bind_2=bind(socket_fd, (struct sockaddr *)&address, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(return_value_bind_2 == 0))
    {
      hlog(3, "bind() failed");
      returnvalue = -1;
    }

    else
    {
      return_value_listen_3=listen(socket_fd, 1);
      if(!(return_value_listen_3 == 0))
      {
        hlog(3, "listen() failed");
        returnvalue = -1;
      }

      else
      {
        return_value_gnuais_ipc_startthread_4=gnuais_ipc_startthread(s);
        if(!(return_value_gnuais_ipc_startthread_4 == 0))
          returnvalue = -1;

      }
    }
  }

failed:
  ;
  if(returnvalue == -1)
  {
    free((void *)s);
    s = ((struct ipc_state_t *)NULL);
  }

  return s;
}

// gnuais_ipc_socketlistener
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 44
static void gnuais_ipc_socketlistener(void *asdf)
{
  signed int connection_fd;
  struct ipc_state_t *ipc = (struct ipc_state_t *)asdf;
  unsigned int address_length;
  hlog(5, "Listening for connections from gnuais GUI");
  do
  {
    connection_fd=accept(socket_fd, (struct sockaddr *)&address, &address_length);
    if(!(connection_fd >= 0))
      break;

    if(ipc->numclientsockets >= 20)
      break;

    pthread_mutex_lock(&ipc_mut);
    ipc->clientsocket[(signed long int)ipc->numclientsockets] = connection_fd;
    ipc->numclientsockets = ipc->numclientsockets + 1;
    pthread_mutex_unlock(&ipc_mut);
    hlog(5, "Gnuais GUI has connected (%d)\n", ipc->numclientsockets);
  }
  while((_Bool)1);
  hlog(5, "Stopped listening for connections from gnuais GUI");
}

// gnuais_ipc_startthread
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.c line 61
signed int gnuais_ipc_startthread(struct ipc_state_t *ipc)
{
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&ipc_th, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)gnuais_ipc_socketlistener, (void *)ipc);
  if(!(return_value_pthread_create_1 == 0))
  {
    hlog(2, "pthread_create failed for gnuais_ipc_socketlistener");
    return -1;
  }

  else
    return 0;
}

// hatoll
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 107
extern signed long long int hatoll(char *s)
{
  signed long long int res = 0LL;
  const unsigned short int **return_value___ctype_b_loc_1;
  char *tmp_post_2;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*s]) == 0)
      break;

    tmp_post_2 = s;
    s = s + 1l;
    res = res * (signed long int)10 + (signed long int)((signed int)*tmp_post_2 - 48);
  }
  while((_Bool)1);
  return res;
}

// hfree
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 33
extern void hfree(void *ptr)
{
  if(!(ptr == NULL))
    free(ptr);

}

// hlog
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 48
extern signed int hlog(signed int priority, const char *fmt, ...)
{
  void **args;
  char s[8192l];
  char wb[8192l];
  signed int len;
  signed int w;
  struct tm lt;
  struct timeval tv;
  if(priority >= 8)
    priority = 7;

  else
    if(!(priority >= 0))
      priority = 0;

  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(!(log_level >= priority))
    return 0;

  else
  {
    args = (void **)&fmt;
    vsnprintf(s, (unsigned long int)8192, fmt, args);
    args = ((void **)NULL);
    gettimeofday(&tv, (struct timezone *)(void *)0);
    gmtime_r(&tv.tv_sec, &lt);
    if(log_dest == 1)
    {
      pthread_rwlock_rdlock(&log_file_lock);
      signed int return_value_getpid_1;
      return_value_getpid_1=getpid();
      unsigned long int return_value_pthread_self_2;
      return_value_pthread_self_2=pthread_self();
      fprintf(stderr, "%4d/%02d/%02d %02d:%02d:%02d.%06d %s[%d:%lu] %s: %s\n", lt.tm_year + 1900, lt.tm_mon + 1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec, (signed int)tv.tv_usec, log_name != ((char *)NULL) ? log_name : "gnuais", (signed int)return_value_getpid_1, (unsigned long int)return_value_pthread_self_2, log_levelnames[(signed long int)priority], (const void *)s);
      pthread_rwlock_unlock(&log_file_lock);
    }

    else
      if(log_dest == 3 && log_file >= 0)
      {
        signed int return_value_getpid_3;
        return_value_getpid_3=getpid();
        unsigned long int return_value_pthread_self_4;
        return_value_pthread_self_4=pthread_self();
        len=snprintf(wb, (unsigned long int)8192, "%4d/%02d/%02d %02d:%02d:%02d.%06d %s[%d:%ld] %s: %s\n", lt.tm_year + 1900, lt.tm_mon + 1, lt.tm_mday, lt.tm_hour, lt.tm_min, lt.tm_sec, (signed int)tv.tv_usec, log_name != ((char *)NULL) ? log_name : "gnuais", (signed int)return_value_getpid_3, (unsigned long int)return_value_pthread_self_4, log_levelnames[(signed long int)priority], (const void *)s);
        wb[(signed long int)(8192 - 1)] = (char)0;
        pthread_rwlock_rdlock(&log_file_lock);
        signed long int return_value_write_7;
        return_value_write_7=write(log_file, (const void *)wb, (unsigned long int)len);
        w = (signed int)return_value_write_7;
        if(!(w == len))
        {
          return_value___errno_location_5=__errno_location();
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          fprintf(stderr, "logger: Could not write to %s (fd %d): %s\n", log_fname, log_file, return_value_strerror_6);
        }

        pthread_rwlock_unlock(&log_file_lock);
      }

      else
        if(log_dest == 2)
        {
          pthread_rwlock_rdlock(&log_file_lock);
          syslog(priority, "%s: %s", log_levelnames[(signed long int)priority], (const void *)s);
          pthread_rwlock_unlock(&log_file_lock);
        }

    return 1;
  }
}

// hmalloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 31
extern void * hmalloc(unsigned long int size)
{
  void *p;
  p=malloc(size);
  if(p == NULL)
  {
    if(!(mem_panic == 0))
      exit(1);

    mem_panic = 1;
    fprintf(stderr, "hmalloc: Out of memory! Could not allocate %d bytes.", (signed int)size);
    exit(1);
  }

  return p;
}

// hrealloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 32
extern void * hrealloc(void *ptr, unsigned long int size)
{
  void *p;
  p=realloc(ptr, size);
  if(p == NULL)
  {
    if(!(mem_panic == 0))
      exit(1);

    mem_panic = 1;
    fprintf(stderr, "hrealloc: Out of memory! Could not reallocate %d bytes.", (signed int)size);
    exit(1);
  }

  return p;
}

// hstrdup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hmalloc.h line 35
extern char * hstrdup(const char *s)
{
  char *p;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  void *return_value_hmalloc_2;
  return_value_hmalloc_2=hmalloc(return_value_strlen_1 + (unsigned long int)1);
  p = (char *)return_value_hmalloc_2;
  strcpy(p, s);
  return p;
}

// init_receiver
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 48
extern struct receiver * init_receiver(char name, signed int num_ch, signed int ch_ofs, struct serial_state_t *serial, struct ipc_state_t *ipc)
{
  struct receiver *rx;
  void *return_value_hmalloc_1;
  return_value_hmalloc_1=hmalloc(sizeof(struct receiver) /*56ul*/ );
  rx = (struct receiver *)return_value_hmalloc_1;
  memset((void *)rx, 0, sizeof(struct receiver) /*56ul*/ );
  rx->filter=filter_init(36, coeffs);
  void *return_value_hmalloc_2;
  return_value_hmalloc_2=hmalloc(sizeof(struct demod_state_t) /*144ul*/ );
  rx->decoder = (struct demod_state_t *)return_value_hmalloc_2;
  protodec_initialize(rx->decoder, serial, ipc, name);
  rx->name = name;
  rx->lastbit = 0;
  rx->num_ch = num_ch;
  rx->ch_ofs = ch_ofs;
  rx->pll = (unsigned int)0;
  rx->pllinc = (unsigned int)(0x10000 / 5);
  rx->prev = 0;
  rx->last_levellog = (signed long int)0;
  return rx;
}

// input_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/input.h line 33
void input_cleanup(struct _snd_pcm *handle)
{
  snd_pcm_close(handle);
}

// input_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/input.h line 31
signed int input_initialize(struct _snd_pcm *handle, signed short int **buffer, signed int *buffer_l)
{
  signed int err;
  signed int channels;
  signed int dir;
  struct _snd_pcm_hw_params *hwparams = (struct _snd_pcm_hw_params *)(void *)0;
  do
  {
    unsigned long int return_value_snd_pcm_hw_params_sizeof_1;
    return_value_snd_pcm_hw_params_sizeof_1=snd_pcm_hw_params_sizeof();
    void *return_value___builtin_alloca_2;
    return_value___builtin_alloca_2=__builtin_alloca(return_value_snd_pcm_hw_params_sizeof_1);
    *(&hwparams) = (struct _snd_pcm_hw_params *)return_value___builtin_alloca_2;
    unsigned long int return_value_snd_pcm_hw_params_sizeof_3;
    return_value_snd_pcm_hw_params_sizeof_3=snd_pcm_hw_params_sizeof();
    memset((void *)*(&hwparams), 0, return_value_snd_pcm_hw_params_sizeof_3);
  }
  while((_Bool)0);
  err=snd_pcm_hw_params_any(handle, hwparams);
  if(!(err >= 0))
  {
    hlog(2, "Sound device: Error initializing hwparams");
    return -1;
  }

  else
  {
    err=snd_pcm_hw_params_set_access(handle, hwparams, (enum _snd_pcm_access)SND_PCM_ACCESS_RW_INTERLEAVED);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror_4;
      return_value_snd_strerror_4=snd_strerror(err);
      hlog(2, "Sound device: Error setting acecss mode (SND_PCM_ACCESS_RW_INTERLEAVED): %s", return_value_snd_strerror_4);
      return -1;
    }

    err=snd_pcm_hw_params_set_format(handle, hwparams, (enum _snd_pcm_format)SND_PCM_FORMAT_S16_LE);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror_5;
      return_value_snd_strerror_5=snd_strerror(err);
      hlog(2, "Sound device: Error setting format (SND_PCM_FORMAT_S16_LE): %s", return_value_snd_strerror_5);
      return -1;
    }

    if(sound_channels == 1)
      channels = 1;

    else
      channels = 2;
    err=snd_pcm_hw_params_set_channels(handle, hwparams, (unsigned int)channels);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror_6;
      return_value_snd_strerror_6=snd_strerror(err);
      hlog(2, "Sound device: Error setting channels %d: %s", channels, return_value_snd_strerror_6);
      hlog(2, "Sound device: Maybe your sound card does not support this SoundChannels setting (mono-only or stereo-only card).");
      return -1;
    }

    unsigned int rate = (unsigned int)48000;
    err=snd_pcm_hw_params_set_rate_near(handle, hwparams, &rate, ((signed int *)NULL));
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror_7;
      return_value_snd_strerror_7=snd_strerror(err);
      hlog(2, "Sound device: Error setting sample rate (%d): %s", rate, return_value_snd_strerror_7);
      return -1;
    }

    unsigned long int size = (unsigned long int)4096;
    dir = 0;
    err=snd_pcm_hw_params_set_period_size_near(handle, hwparams, &size, &dir);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror_8;
      return_value_snd_strerror_8=snd_strerror(err);
      hlog(2, "Sound device: Error setting buffer size (%d): %s", size, return_value_snd_strerror_8);
      return -1;
    }

    err=snd_pcm_hw_params(handle, hwparams);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror_9;
      return_value_snd_strerror_9=snd_strerror(err);
      hlog(2, "Sound device: Error writing hwparams: %s", return_value_snd_strerror_9);
      return -1;
    }

    snd_pcm_hw_params_get_period_size(hwparams, &size, &dir);
    *buffer_l = (signed int)size;
    signed int buffer_len_in_bytes = (signed int)((unsigned long int)*buffer_l * sizeof(signed short int) /*2ul*/  * (unsigned long int)channels);
    hlog(7, "Sound device: Using sound buffer size: %d frames of %d channels: %d bytes", *buffer_l, channels, buffer_len_in_bytes);
    void *return_value_hmalloc_10;
    return_value_hmalloc_10=hmalloc((unsigned long int)buffer_len_in_bytes);
    *buffer = (signed short int *)return_value_hmalloc_10;
    bzero((void *)*buffer, (unsigned long int)buffer_len_in_bytes);
    return 0;
  }
}

// input_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/input.h line 32
signed int input_read(struct _snd_pcm *handle, signed short int *buffer, signed int count)
{
  signed int err;
  signed long int return_value_snd_pcm_readi_1;
  return_value_snd_pcm_readi_1=snd_pcm_readi(handle, (void *)buffer, (unsigned long int)count);
  err = (signed int)return_value_snd_pcm_readi_1;
  if(err == -32)
  {
    hlog(3, "Sound device: Overrun");
    snd_pcm_prepare(handle);
  }

  else
    if(!(err >= 0))
      hlog(3, "Sound device: Read error");

    else
      if(!(err == count))
        hlog(6, "Sound device: Short read, read %d frames", err);

  return err;
}

// ipc_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ipc.h line 36
signed int ipc_write(struct ipc_state_t *ipc, char *buffer, signed int buflength)
{
  hlog(7, "IPC buffer: %s\n", buffer);
  signed int nbytes = 0;
  signed int i;
  pthread_mutex_lock(&ipc_mut);
  i = 0;
  for( ; !(i >= ipc->numclientsockets); i = i + 1)
  {
    signed long int return_value_write_1;
    return_value_write_1=write(ipc->clientsocket[(signed long int)i], (const void *)buffer, (unsigned long int)buflength);
    nbytes = (signed int)return_value_write_1;
    if(nbytes == 0)
      hlog(6, "One gnuaisgui client is disconnected\n");

  }
  pthread_mutex_unlock(&ipc_mut);
  return 0;
}

// jsonout_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.h line 26
extern signed int jsonout_deinit(void)
{
  signed int ret;
  jsonout_die = 1;
  ret=pthread_join(jsonout_th, (void **)(void *)0);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    hlog(2, "pthread_join of jsonout_thread failed: %s", return_value_strerror_1);
    return -1;
  }

  curl_global_cleanup();
  return 0;
}

// jsonout_export
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 211
static void jsonout_export(void)
{
  unsigned int entries = (unsigned int)0;
  unsigned int exported = (unsigned int)0;
  struct spblk *x;
  struct spblk *nextx;
  struct sptree *sp;
  struct cache_ent *e;
  char *json = (char *)(void *)0;
  signed int got_pos;
  char tbuf[15l];
  signed long int now;
  time(&now);
  time_jsonais(&now, tbuf, 15);
  json=str_append(json, "{\n\t\"protocol\": \"jsonais\",\n\t\"encodetime\": \"%s\",\n\t\"groups\": [\n\t\t{\n\t\t\t\"path\": [ { \"name\": \"%s\" } ],\n\t\t\t\"msgs\": [\n", (const void *)tbuf, mycall);
  sp=cache_rotate();
  x=sp_fhead(sp);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  for( ; !(x == ((struct spblk *)NULL)); x = nextx)
  {
    entries = entries + 1u;
    nextx=sp_fnext(x);
    e = (struct cache_ent *)x->data;
    if((double)e->lat > 0.0001)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (double)e->lat < -0.0001 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if((double)e->lon > 0.0001)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (double)e->lon < -0.0001 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    got_pos = (signed int)tmp_if_expr_3;
    if(!(e->mmsi == 0))
    {
      if(!(got_pos == 0))
      {
        hlog(7, "jsonout: exporting MMSI %d position", e->mmsi);
        time_jsonais(&e->received_pos, tbuf, 15);
        json=str_append(json, "%s{\"msgtype\": 3, \"mmsi\": %d, \"rxtime\": \"%s\"", exported == (unsigned int)0 ? "" : ",\n", e->mmsi, (const void *)tbuf);
        json=str_append(json, ", \"lat\": %.7f, \"lon\": %.7f", e->lat, e->lon);
        if(e->course >= 0.000000f)
          json=str_append(json, ", \"course\": %.1f", e->course);

        if(e->hdg >= 0)
          json=str_append(json, ", \"heading\": %d", e->hdg);

        if(e->sog >= 0.000000f)
          json=str_append(json, ", \"speed\": %.1f", e->sog);

        if(e->navstat >= 0)
          json=str_append(json, ", \"status\": %d", e->navstat);

        json=str_append(json, "}");
        exported = exported + 1u;
      }

    }

    if(!(e->mmsi == 0))
    {
      if(!(e->name == ((char *)NULL)))
      {
        hlog(7, "jsonout: exporting MMSI %d data", e->mmsi);
        time_jsonais(&e->received_data, tbuf, 15);
        json=str_append(json, "%s{\"msgtype\": 5, \"mmsi\": %d, \"rxtime\": \"%s\"", exported == (unsigned int)0 ? "" : ",\n", e->mmsi, (const void *)tbuf);
        if(e->imo >= 0)
          json=str_append(json, ", \"imo\": %d", e->imo);

        if(e->shiptype >= 0)
          json=str_append(json, ", \"shiptype\": %d", e->shiptype);

        if(!(e->callsign == ((char *)NULL)))
          json=str_append(json, ", \"callsign\": \"%s\"", e->callsign);

        if(!(e->name == ((char *)NULL)))
          json=str_append(json, ", \"shipname\": \"%s\"", e->name);

        if(!(e->destination == ((char *)NULL)))
          json=str_append(json, ", \"destination\": \"%s\"", e->destination);

        if(e->A >= 0)
        {
          if(e->B >= 0)
          {
            json=str_append(json, ", \"length\": %d", e->A + e->B);
            json=str_append(json, ", \"ref_front\": %d", e->A);
          }

        }

        if(e->draught >= 0.000000f)
          json=str_append(json, ", \"draught\": %.1f", e->draught);

        if(e->C >= 0)
        {
          if(e->D >= 0)
          {
            json=str_append(json, ", \"width\": %d", e->C + e->D);
            json=str_append(json, ", \"ref_left\": %d", e->C);
          }

        }

        json=str_append(json, "}");
        exported = exported + 1u;
      }

    }

    if(e->persons_on_board >= 0)
    {
      hlog(7, "jsonout: exporting MMSI %d persons_on_board %d", e->mmsi, e->persons_on_board);
      time_jsonais(&e->received_persons_on_board, tbuf, 15);
      json=str_append(json, "%s{\"msgtype\": 8, \"mmsi\": %d, \"persons_on_board\": %d, \"rxtime\": \"%s\"}", exported == (unsigned int)0 ? "" : ",\n", e->mmsi, e->persons_on_board, (const void *)tbuf);
      exported = exported + 1u;
    }

    cache_free_entry(e);
    sp_delete(x, sp);
  }
  json=str_append(json, "\n\n\t\t\t]\n\t\t}\n\t]\n}\n");
  if(!(sp == ((struct sptree *)NULL)))
  {
    sp_null(sp);
    hfree((void *)sp);
  }

  hlog(7, "jsonout: %s", json);
  if(!(exported == 0u))
    jsonout_post_all(json);

  hfree((void *)json);
}

// jsonout_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.h line 25
extern signed int jsonout_init(void)
{
  curl_global_init((signed long int)(1 << 0 | 1 << 1));
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&jsonout_th, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)jsonout_thread, (void *)0);
  if(!(return_value_pthread_create_1 == 0))
  {
    hlog(2, "pthread_create failed for jsonout_thread");
    return -1;
  }

  else
    return 0;
}

// jsonout_post_all
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 187
static void jsonout_post_all(char *json)
{
  struct uplink_config_t *up;
  struct curl_httppost *cpost = (struct curl_httppost *)(void *)0;
  struct curl_httppost *last = (struct curl_httppost *)(void *)0;
  curl_formadd(&cpost, &last, 1, (const void *)"jsonais", 14, (const void *)"application/json", 5, json, 17);
  up = uplink_config;
  for( ; !(up == ((struct uplink_config_t *)NULL)); up = up->next)
    if(up->proto == 1)
      jsonout_post_single(cpost, up->url);

  curl_formfree(cpost);
}

// jsonout_post_single
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 71
static signed int jsonout_post_single(struct curl_httppost *post, const char *url)
{
  void *ch;
  enum anonymous r;
  struct curl_slist *headers = (struct curl_slist *)(void *)0;
  signed long int retcode = (signed long int)200;
  ch=curl_easy_init();
  enum anonymous tmp_statement_expression_2;
  enum anonymous tmp_statement_expression_4;
  enum anonymous tmp_statement_expression_6;
  enum anonymous tmp_statement_expression_8;
  enum anonymous tmp_statement_expression_10;
  enum anonymous tmp_statement_expression_12;
  enum anonymous tmp_statement_expression_15;
  if(ch == NULL)
  {
    hlog(3, "curl_easy_init() returned NULL");
    return 1;
  }

  else
  {
    do
    {
      headers=curl_slist_append((struct curl_slist *)(void *)0, "Expect:");
      if(headers == ((struct curl_slist *)NULL))
      {
        hlog(3, "curl_slist_append for Expect header failed");
        break;
      }

      signed int _curl_opt = CURLOPT_HTTPPOST;
      tmp_statement_expression_2=curl_easy_setopt(ch, (enum anonymous_3)_curl_opt, post);
      r = tmp_statement_expression_2;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_1;
        return_value_curl_easy_strerror_1=curl_easy_strerror(r);
        hlog(3, "curl_easy_setopt(CURLOPT_HTTPPOST) failed: %s", return_value_curl_easy_strerror_1);
        break;
      }

      signed int jsonout_post_single__1__2__4___curl_opt = CURLOPT_URL;
      tmp_statement_expression_4=curl_easy_setopt(ch, (enum anonymous_3)jsonout_post_single__1__2__4___curl_opt, url);
      r = tmp_statement_expression_4;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_3;
        return_value_curl_easy_strerror_3=curl_easy_strerror(r);
        hlog(3, "curl_easy_setopt(CURLOPT_URL) failed: %s (%s)", return_value_curl_easy_strerror_3, url);
        break;
      }

      signed int jsonout_post_single__1__2__6___curl_opt = CURLOPT_HTTPHEADER;
      tmp_statement_expression_6=curl_easy_setopt(ch, (enum anonymous_3)jsonout_post_single__1__2__6___curl_opt, headers);
      r = tmp_statement_expression_6;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_5;
        return_value_curl_easy_strerror_5=curl_easy_strerror(r);
        hlog(3, "curl_easy_setopt(CURLOPT_HEADER) failed: %s (%s)", return_value_curl_easy_strerror_5, url);
        break;
      }

      signed int jsonout_post_single__1__2__8___curl_opt = CURLOPT_WRITEFUNCTION;
      tmp_statement_expression_8=curl_easy_setopt(ch, (enum anonymous_3)jsonout_post_single__1__2__8___curl_opt, curl_wdata);
      r = tmp_statement_expression_8;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_7;
        return_value_curl_easy_strerror_7=curl_easy_strerror(r);
        hlog(3, "curl_easy_setopt(CURLOPT_WRITEFUNCTION) failed: %s", return_value_curl_easy_strerror_7);
        break;
      }

      signed int jsonout_post_single__1__2__10___curl_opt = CURLOPT_NOPROGRESS;
      tmp_statement_expression_10=curl_easy_setopt(ch, (enum anonymous_3)jsonout_post_single__1__2__10___curl_opt, 1);
      r = tmp_statement_expression_10;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_9;
        return_value_curl_easy_strerror_9=curl_easy_strerror(r);
        hlog(3, "curl_easy_setopt(CURLOPT_NOPROGRESS) failed: %s", return_value_curl_easy_strerror_9);
        break;
      }

      signed int jsonout_post_single__1__2__12___curl_opt = CURLOPT_VERBOSE;
      tmp_statement_expression_12=curl_easy_setopt(ch, (enum anonymous_3)jsonout_post_single__1__2__12___curl_opt, 0);
      r = tmp_statement_expression_12;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_11;
        return_value_curl_easy_strerror_11=curl_easy_strerror(r);
        hlog(3, "curl_easy_setopt(CURLOPT_VERBOSE) failed: %s", return_value_curl_easy_strerror_11);
        break;
      }

      r=curl_easy_perform(ch);
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_13;
        return_value_curl_easy_strerror_13=curl_easy_strerror(r);
        hlog(3, "curl_easy_perform() failed: %s (%s)", return_value_curl_easy_strerror_13, url);
        break;
      }

      signed int _curl_info = CURLINFO_RESPONSE_CODE;
      tmp_statement_expression_15=curl_easy_getinfo(ch, (enum anonymous_0)_curl_info, &retcode);
      r = tmp_statement_expression_15;
      if(!(r == /*enum*/CURLE_OK))
      {
        const char *return_value_curl_easy_strerror_14;
        return_value_curl_easy_strerror_14=curl_easy_strerror(r);
        hlog(3, "curl_easy_getinfo(CURLINFO_RESPONSE_CODE) failed: %s (%s)", return_value_curl_easy_strerror_14, url);
        break;
      }

    }
    while((_Bool)0);
    curl_easy_cleanup(ch);
    if(!(headers == ((struct curl_slist *)NULL)))
      curl_slist_free_all(headers);

    if(!(retcode == 200l))
    {
      hlog(3, "JSON AIS export: server for %s returned %ld\n", url, retcode);
      r = (enum anonymous)-1;
    }

    return (signed int)r;
  }
}

// jsonout_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 360
static void jsonout_thread(void *asdf)
{
  signed int i;
  hlog(7, "jsonout: thread started");
  while((_Bool)1)
  {
    i = 0;
    for( ; !(i >= 60); i = i + 1)
    {
      if(!(jsonout_die == 0))
        goto __CPROVER_DUMP_L6;

      sleep((unsigned int)1);
    }
    hlog(7, "jsonout: exporting");
    jsonout_export();
  }

__CPROVER_DUMP_L6:
  ;
}

// lat2rad
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.h line 27
extern float lat2rad(float lat)
{
  return (float)((double)lat * (3.14159265358979323846 / 180.0));
}

// log_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.h line 31
extern void log_range(struct demod_state_t *rx)
{
  if((double)rx->best_range > 0.1)
    hlog(6, "Best range ch %c: %.1f km", rx->chanid, rx->best_range);

  rx->best_range = (float)0.0;
}

// lon2rad
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.h line 28
extern float lon2rad(float lon)
{
  return (float)((double)lon * (3.14159265358979323846 / 180.0));
}

// maidenhead_km_distance
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.c line 18
static float maidenhead_km_distance(float lat1, float lon1, float lat2, float lon2)
{
  float sindlat2;
  sindlat2=sinf((float)((double)(lat1 - lat2) * 0.5));
  float sindlon2;
  sindlon2=sinf((float)((double)(lon1 - lon2) * 0.5));
  float coslat1;
  coslat1=cosf(lat1);
  float coslat2;
  coslat2=cosf(lat2);
  float a = sindlat2 * sindlat2 + coslat1 * coslat2 * sindlon2 * sindlon2;
  float c;
  float return_value_sqrtf_1;
  return_value_sqrtf_1=sqrtf(a);
  float return_value_sqrtf_2;
  return_value_sqrtf_2=sqrtf((float)(1.0 - (double)a));
  float return_value_atan2f_3;
  return_value_atan2f_3=atan2f(return_value_sqrtf_1, return_value_sqrtf_2);
  c = (float)(2.0 * (double)return_value_atan2f_3);
  return (float)(((111.2 * 180.0) / 3.14159265358979323846) * (double)c);
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/ais.c line 63
signed int main(signed int argc, char **argv)
{
  signed int err;
  done = 0;
  struct _snd_pcm *handle;
  struct _IO_FILE *sound_in_fd = (struct _IO_FILE *)(void *)0;
  struct _IO_FILE *sound_out_fd = (struct _IO_FILE *)(void *)0;
  signed int channels;
  signed short int *buffer = (signed short int *)(void *)0;
  signed int buffer_l;
  signed int buffer_read;
  struct serial_state_t *serial = (struct serial_state_t *)(void *)0;
  struct ipc_state_t *ipc = (struct ipc_state_t *)(void *)0;
  struct receiver *rx_a = (struct receiver *)(void *)0;
  struct receiver *rx_b = (struct receiver *)(void *)0;
  struct pa_simple *pa_dev = (struct pa_simple *)(void *)0;
  signed long int last_stats;
  last_stats=time((signed long int *)(void *)0);
  parse_cmdline(argc, argv);
  open_log(logname, 0);
  hlog(5, "Starting up...");
  signed int return_value_read_config_1;
  return_value_read_config_1=read_config();
  if(!(return_value_read_config_1 == 0))
  {
    hlog(2, "Initial configuration failed.");
    exit(1);
  }

  if(!(fork_a_daemon == 0))
  {
    signed int i;
    i=fork();
    if(!(i >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      hlog(2, "Fork to background failed: %s", return_value_strerror_3);
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      fprintf(stderr, "Fork to background failed: %s\n", return_value_strerror_5);
      exit(1);
    }

    else
      if(i == 0)
      {
        hlog(7, "Writing pid...");
        signed int return_value_writepid_6;
        return_value_writepid_6=writepid(pidfile);
        if(return_value_writepid_6 == 0)
          exit(1);

      }

      else
      {
        hlog(7, "Forked daemon process %d, parent quitting", i);
        exit(0);
      }
  }

  signal(2, closedown);
  signal(13, brokenconnection);
  if(!(uplink_config == ((struct uplink_config_t *)NULL)))
  {
    hlog(7, "Initializing cache...");
    signed int return_value_cache_init_7;
    return_value_cache_init_7=cache_init();
    if(!(return_value_cache_init_7 == 0))
      exit(1);

    hlog(7, "Initializing jsonout...");
    signed int return_value_jsonout_init_8;
    return_value_jsonout_init_8=jsonout_init();
    if(!(return_value_jsonout_init_8 == 0))
      exit(1);

  }

  if(!(serial_port == ((char *)NULL)))
    serial=serial_init();

  ipc=gnuais_ipc_init();
  if(ipc == ((struct ipc_state_t *)NULL))
    hlog(3, "Could not open Unix Domain Socket");

  if(!(sound_channels == 1))
  {
    hlog(7, "Initializing demodulator A");
    rx_a=init_receiver((char)65, 2, 0, serial, ipc);
    hlog(7, "Initializing demodulator B");
    rx_b=init_receiver((char)66, 2, 1, serial, ipc);
    channels = 2;
  }

  else
  {
    hlog(7, "Initializing demodulator A");
    rx_a=init_receiver((char)65, 1, 0, serial, ipc);
    channels = 1;
  }
  _Bool tmp_if_expr_17;
  signed int return_value_strcmp_14;
  _Bool tmp_if_expr_16;
  signed int return_value_strcmp_15;
  if(!(sound_device == ((char *)NULL)))
  {
    return_value_strcmp_14=strcmp("pulse", sound_device);
    if(return_value_strcmp_14 == 0)
      tmp_if_expr_16 = (_Bool)1;

    else
    {
      return_value_strcmp_15=strcmp("pulseaudio", sound_device);
      tmp_if_expr_16 = return_value_strcmp_15 == 0 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_17 = (_Bool)0;
  if(tmp_if_expr_17)
  {
    pa_dev=pulseaudio_initialize();
    if(pa_dev == ((struct pa_simple *)NULL))
    {
      hlog(2, "Error opening pulseaudio device");
      return -1;
    }

    buffer_l = 1024;
    signed int extra = buffer_l % 5;
    buffer_l = buffer_l - extra;
    void *return_value_hmalloc_9;
    return_value_hmalloc_9=hmalloc((unsigned long int)buffer_l * sizeof(signed short int) /*2ul*/  * (unsigned long int)channels);
    buffer = (signed short int *)return_value_hmalloc_9;
  }

  else
    if(!(sound_device == ((char *)NULL)))
    {
      err=snd_pcm_open(&handle, sound_device, (enum _snd_pcm_stream)SND_PCM_STREAM_CAPTURE, 0);
      if(!(err >= 0))
      {
        hlog(2, "Error opening sound device (%s)", sound_device);
        return -1;
      }

      signed int return_value_input_initialize_10;
      return_value_input_initialize_10=input_initialize(handle, &buffer, &buffer_l);
      if(!(return_value_input_initialize_10 >= 0))
        return -1;

    }

    else
      if(!(sound_in_file == ((char *)NULL)))
      {
        sound_in_fd=fopen(sound_in_file, "r");
        if(sound_in_fd == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          char *return_value_strerror_12;
          return_value_strerror_12=strerror(*return_value___errno_location_11);
          hlog(2, "Could not open sound file %s: %s", sound_in_file, return_value_strerror_12);
          return -1;
        }

        hlog(5, "Reading audio from file: %s", sound_in_file);
        buffer_l = 1024;
        signed int main__1__9__extra = buffer_l % 5;
        buffer_l = buffer_l - main__1__9__extra;
        void *return_value_hmalloc_13;
        return_value_hmalloc_13=hmalloc((unsigned long int)buffer_l * sizeof(signed short int) /*2ul*/  * (unsigned long int)channels);
        buffer = (signed short int *)return_value_hmalloc_13;
      }

      else
      {
        hlog(2, "Neither sound device or sound file configured.");
        return -1;
      }
  if(!(sound_out_file == ((char *)NULL)))
  {
    sound_out_fd=fopen(sound_out_file, "w");
    if(sound_out_fd == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location_18;
      return_value___errno_location_18=__errno_location();
      char *return_value_strerror_19;
      return_value_strerror_19=strerror(*return_value___errno_location_18);
      hlog(2, "Could not open sound output file %s: %s", sound_out_file, return_value_strerror_19);
      return -1;
    }

    hlog(5, "Recording audio to file: %s", sound_out_file);
  }

  if(!(mysql_db == ((char *)NULL)))
  {
    hlog(7, "Saving to MySQL database \"%s\"", mysql_db);
    my=myout_init();
    if(my == ((struct mysql_state_t_0 *)NULL))
      return -1;

    if(!(mysql_keepsmall == 0))
      hlog(7, "Updating database rows only.");

    else
      hlog(7, "Inserting data to database.");
    if(!(mysql_oldlimit == 0))
      hlog(7, "Deleting data older than %d seconds", mysql_oldlimit);

  }

  hlog(5, "Started");
  while(done == 0)
  {
    if(!(sound_in_fd == ((struct _IO_FILE *)NULL)))
    {
      unsigned long int return_value_fread_20;
      return_value_fread_20=fread((void *)buffer, (unsigned long int)channels * sizeof(signed short int) /*2ul*/ , (unsigned long int)buffer_l, sound_in_fd);
      buffer_read = (signed int)return_value_fread_20;
      if(!(buffer_read >= 1))
        done = 1;

    }

    else
      if(!(pa_dev == ((struct pa_simple *)NULL)))
        buffer_read=pulseaudio_read(pa_dev, buffer, buffer_l);

      else
        buffer_read=input_read(handle, buffer, buffer_l);
    if(buffer_read >= 1)
    {
      if(!(sound_out_fd == ((struct _IO_FILE *)NULL)))
        fwrite((const void *)buffer, (unsigned long int)channels * sizeof(signed short int) /*2ul*/ , (unsigned long int)buffer_read, sound_out_fd);

      if(sound_channels == 1)
        receiver_run(rx_a, buffer, buffer_read);

      if(sound_channels == 2 || sound_channels == 4)
        receiver_run(rx_a, buffer, buffer_read);

      if(sound_channels == 2 || sound_channels == 3)
        receiver_run(rx_b, buffer, buffer_read);

      if(!(stats_interval == 0))
      {
        signed long int now;
        now=time((signed long int *)(void *)0);
        if(!(now >= last_stats))
          last_stats = now;

        else
          if(now + -last_stats >= (signed long int)stats_interval)
          {
            last_stats = now;
            if(!(rx_a == ((struct receiver *)NULL)))
              log_range(rx_a->decoder);

            if(!(rx_b == ((struct receiver *)NULL)))
              log_range(rx_b->decoder);

          }

      }

    }

  }
  hlog(5, "Closing down...");
  if(!(sound_in_fd == ((struct _IO_FILE *)NULL)))
    fclose(sound_in_fd);

  else
    if(!(pa_dev == ((struct pa_simple *)NULL)))
      pulseaudio_cleanup(pa_dev);

    else
    {
      input_cleanup(handle);
      handle = (struct _snd_pcm *)(void *)0;
    }
  if(!(sound_out_fd == ((struct _IO_FILE *)NULL)))
    fclose(sound_out_fd);

  hfree((void *)buffer);
  gnuais_ipc_deinit(ipc);
  if(!(serial == ((struct serial_state_t *)NULL)))
    serial_close(serial);

  if(!(uplink_config == ((struct uplink_config_t *)NULL)))
    jsonout_deinit();

  if(!(cache_positions == 0))
    cache_deinit();

  if(!(rx_a == ((struct receiver *)NULL)))
  {
    struct demod_state_t *d = rx_a->decoder;
    hlog(6, "A: Received correctly: %d packets, wrong CRC: %d packets, wrong size: %d packets", d->receivedframes, d->lostframes, d->lostframes2);
  }

  if(!(rx_b == ((struct receiver *)NULL)))
  {
    struct demod_state_t *main__1__18__d = rx_b->decoder;
    hlog(6, "B: Received correctly: %d packets, wrong CRC: %d packets, wrong size: %d packets", main__1__18__d->receivedframes, main__1__18__d->lostframes, main__1__18__d->lostframes2);
  }

  free_receiver(rx_a);
  free_receiver(rx_b);
  free_config();
  close_log(0);
  return 0;
}

// myout_ais_basestation
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 198
extern signed int myout_ais_basestation(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, float lat, float lon)
{
  char ins[2000l];
  char upd[2000l];
  snprintf(ins, (unsigned long int)2000, "INSERT INTO ais_basestation (time,mmsi,latitude,longitude) VALUES (%ld,%d,%.7f,%.7f)", tid, mmsi, lat, lon);
  snprintf(upd, (unsigned long int)2000, "UPDATE ais_basestation SET time=%ld, latitude=%.7f, longitude=%.7f WHERE mmsi=%d", tid, lat, lon, mmsi);
  signed int return_value_myout_update_or_insert_1;
  return_value_myout_update_or_insert_1=myout_update_or_insert(my, upd, ins);
  return return_value_myout_update_or_insert_1;
}

// myout_ais_position
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 174
extern signed int myout_ais_position(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, float lat, float lon, float hdg, float course, float sog)
{
  char ins[2000l];
  char upd[2000l];
  my->inserts = my->inserts + 1;
  if(my->inserts % 10 == 0)
  {
    myout_delete_old(my, tid);
    my->inserts = 0;
  }

  snprintf(ins, (unsigned long int)2000, "INSERT INTO ais_position (time,mmsi,latitude,longitude,heading,course,speed) VALUES (%ld,%d,%.7f,%.7f,%.5f,%f,%f)", tid, mmsi, lat, lon, hdg, course, sog);
  snprintf(upd, (unsigned long int)2000, "UPDATE ais_position SET time=%ld, latitude=%.7f, longitude=%.7f, heading=%f, course=%.5f, speed=%f WHERE mmsi=%d", tid, lat, lon, hdg, course, sog, mmsi);
  signed int return_value_myout_update_or_insert_1;
  return_value_myout_update_or_insert_1=myout_update_or_insert(my, upd, ins);
  return return_value_myout_update_or_insert_1;
}

// myout_ais_vesseldata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 216
extern signed int myout_ais_vesseldata(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, char *name, char *destination, float draught, signed int A, signed int B, signed int C, signed int D)
{
  char ins[2000l];
  char upd[2000l];
  snprintf(ins, (unsigned long int)2000, "INSERT INTO ais_vesseldata (time,mmsi,name,destination,draught,A,B,C,D) VALUES (%ld,%d,\"%s\",\"%s\",%f,%d,%d,%d,%d)", tid, mmsi, name, destination, draught, A, B, C, D);
  snprintf(upd, (unsigned long int)2000, "UPDATE ais_vesseldata SET time=%ld, name=\"%s\", destination=\"%s\", A=%d, B=%d, C=%d, D=%d, draught=%f WHERE mmsi=%d", tid, name, destination, A, B, C, D, draught, mmsi);
  signed int return_value_myout_update_or_insert_1;
  return_value_myout_update_or_insert_1=myout_update_or_insert(my, upd, ins);
  return return_value_myout_update_or_insert_1;
}

// myout_ais_vesseldatab
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 237
extern signed int myout_ais_vesseldatab(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, signed int A, signed int B, signed int C, signed int D)
{
  char ins[2000l];
  char upd[2000l];
  snprintf(ins, (unsigned long int)2000, "INSERT INTO ais_vesseldata (time,mmsi,A,B,C,D) VALUES (%ld,%d,%d,%d,%d,%d)", tid, mmsi, A, B, C, D);
  snprintf(upd, (unsigned long int)2000, "UPDATE ais_vesseldata SET time=%ld, A=%d, B=%d, C=%d, D=%d WHERE mmsi=%d", tid, A, B, C, D, mmsi);
  signed int return_value_myout_update_or_insert_1;
  return_value_myout_update_or_insert_1=myout_update_or_insert(my, upd, ins);
  return return_value_myout_update_or_insert_1;
}

// myout_ais_vesselname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 257
extern signed int myout_ais_vesselname(struct mysql_state_t_0 *my, signed long int tid, signed int mmsi, const char *name, const char *destination)
{
  char ins[2000l];
  char upd[2000l];
  snprintf(ins, (unsigned long int)2000, "INSERT INTO ais_vesseldata (time,mmsi,name,destination) VALUES (%ld,%d,\"%s\",\"%s\")", tid, mmsi, name, destination);
  snprintf(upd, (unsigned long int)2000, "UPDATE ais_vesseldata SET time=%ld, name=\"%s\", destination=\"%s\" WHERE mmsi=%d", tid, name, destination, mmsi);
  signed int return_value_myout_update_or_insert_1;
  return_value_myout_update_or_insert_1=myout_update_or_insert(my, upd, ins);
  return return_value_myout_update_or_insert_1;
}

// myout_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 45
static signed int myout_connect(struct mysql_state_t_0 *my)
{
  struct st_mysql *return_value_mysql_real_connect_1;
  return_value_mysql_real_connect_1=mysql_real_connect(&my->conn, mysql_host, mysql_user, mysql_password, mysql_db, (unsigned int)0, (const char *)(void *)0, (unsigned long int)0);
  if(return_value_mysql_real_connect_1 == ((struct st_mysql *)NULL))
  {
    hlog(2, "Could not connect to MySQL!");
    my->connected = 0;
    return 0;
  }

  else
  {
    hlog(6, "Reconnected to MySQL server successfully");
    my->connected = 1;
    return 1;
  }
}

// myout_delete_from
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 98
static signed int myout_delete_from(struct mysql_state_t_0 *my, signed long int now, char *table)
{
  char q[2000l];
  signed int qrows;
  const char *e;
  snprintf(q, (unsigned long int)2000, "DELETE FROM %s WHERE time < %ld", table, now - (signed long int)mysql_oldlimit);
  signed int return_value_mysql_query_1;
  return_value_mysql_query_1=mysql_query(&my->conn, q);
  if(!(return_value_mysql_query_1 == 0))
  {
    e=mysql_error(&my->conn);
    hlog(3, "MySQL: Could not delete old data from %s: %s", table, e);
    return 0;
  }

  else
  {
    unsigned long long int return_value_mysql_affected_rows_2;
    return_value_mysql_affected_rows_2=mysql_affected_rows(&my->conn);
    qrows = (signed int)return_value_mysql_affected_rows_2;
    if(qrows >= 1)
      hlog(7, "MySQL: Deleted %d rows from %s.", qrows, table);

    return qrows;
  }
}

// myout_delete_old
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 120
static signed int myout_delete_old(struct mysql_state_t_0 *my, signed long int now)
{
  signed int rows;
  if(mysql_oldlimit >= 1)
  {
    rows=myout_delete_from(my, now, "ais_position");
    signed int return_value_myout_delete_from_1;
    return_value_myout_delete_from_1=myout_delete_from(my, now, "ais_vesseldata");
    rows = rows + return_value_myout_delete_from_1;
    signed int return_value_myout_delete_from_2;
    return_value_myout_delete_from_2=myout_delete_from(my, now, "ais_basestation");
    rows = rows + return_value_myout_delete_from_2;
    signed int return_value_myout_delete_from_3;
    return_value_myout_delete_from_3=myout_delete_from(my, now, "ais_nmea");
    rows = rows + return_value_myout_delete_from_3;
  }

  return 0;
}

// myout_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.h line 37
extern struct mysql_state_t_0 * myout_init()
{
  struct mysql_state_t_0 *myout_init__1__my;
  void *return_value_hmalloc_1;
  return_value_hmalloc_1=hmalloc(sizeof(struct mysql_state_t_0) /*1280ul*/ );
  myout_init__1__my = (struct mysql_state_t_0 *)return_value_hmalloc_1;
  myout_init__1__my->connected = 0;
  myout_init__1__my->inserts = 0;
  struct st_mysql *return_value_mysql_init_2;
  return_value_mysql_init_2=mysql_init(&myout_init__1__my->conn);
  if(return_value_mysql_init_2 == ((struct st_mysql *)NULL))
  {
    hlog(2, "Could not initialize MySQL library!");
    return (struct mysql_state_t_0 *)(void *)0;
  }

  else
  {
    signed int return_value_myout_connect_3;
    return_value_myout_connect_3=myout_connect(myout_init__1__my);
    if(return_value_myout_connect_3 == 0)
      return (struct mysql_state_t_0 *)(void *)0;

    else
    {
      myout_init__1__my->connected = 1;
      return myout_init__1__my;
    }
  }
}

// myout_nmea
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 278
extern signed int myout_nmea(struct mysql_state_t_0 *my, signed long int tid, char *nmea)
{
  char q[2000l];
  unsigned int en;
  const char *e;
  snprintf(q, (unsigned long int)2000, "INSERT INTO ais_nmea (time, message) VALUES (%ld,\"!%s\")", tid, nmea);
  signed int return_value_mysql_query_1;
  return_value_mysql_query_1=mysql_query(&my->conn, q);
  if(!(return_value_mysql_query_1 == 0))
  {
    en=mysql_errno(&my->conn);
    e=mysql_error(&my->conn);
    hlog(3, "MySQL: Could not insert into ais_nmea: %s (%u)", e, en);
    if(en == 2006u)
      myout_reconnect(my);

    return -1;
  }

  else
    return 0;
}

// myout_reconnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 88
static signed int myout_reconnect(struct mysql_state_t_0 *my)
{
  hlog(7, "MySQL: Reconnecting...");
  mysql_close(&my->conn);
  my->connected = 0;
  signed int return_value_myout_connect_1;
  return_value_myout_connect_1=myout_connect(my);
  return return_value_myout_connect_1;
}

// myout_update_or_insert
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_mysql.c line 134
static signed int myout_update_or_insert(struct mysql_state_t_0 *my, char *upd, char *ins)
{
  signed int qrows;
  unsigned int en;
  const char *e;
  if(!(mysql_keepsmall == 0))
  {
    signed int return_value_mysql_query_1;
    return_value_mysql_query_1=mysql_query(&my->conn, upd);
    if(!(return_value_mysql_query_1 == 0))
    {
      en=mysql_errno(&my->conn);
      e=mysql_error(&my->conn);
      hlog(3, "MySQL: Could not update data in MySQL database: %s (%u)", e, en);
      if(en == 2006u)
        myout_reconnect(my);

      return -1;
    }

    unsigned long long int return_value_mysql_affected_rows_2;
    return_value_mysql_affected_rows_2=mysql_affected_rows(&my->conn);
    qrows = (signed int)return_value_mysql_affected_rows_2;
    if(qrows >= 1)
      return 0;

  }

  signed int return_value_mysql_query_3;
  return_value_mysql_query_3=mysql_query(&my->conn, ins);
  if(!(return_value_mysql_query_3 == 0))
  {
    en=mysql_errno(&my->conn);
    e=mysql_error(&my->conn);
    hlog(3, "MySQL: Could not insert data in MySQL database: %s (%u)", e, en);
    if(en == 2006u)
      myout_reconnect(my);

    return -1;
  }

  else
    return 0;
}

// open_log
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 46
extern signed int open_log(char *name, signed int reopen)
{
  if(reopen == 0)
    pthread_rwlock_wrlock(&log_file_lock);

  if(!(log_name == ((char *)NULL)))
    hfree((void *)log_name);

  log_name=hstrdup(name);
  if(log_name == ((char *)NULL))
  {
    fprintf(stderr, "logger: out of memory!\n");
    exit(1);
  }

  if(log_dest == 2)
    openlog(name, 0x08 | 0x01, log_facility);

  if(log_dest == 3)
  {
    if(!(log_fname == ((char *)NULL)))
      hfree((void *)log_fname);

    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(log_dir);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(log_basename);
    void *return_value_hmalloc_3;
    return_value_hmalloc_3=hmalloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2);
    log_fname = (char *)return_value_hmalloc_3;
    sprintf(log_fname, "%s/%s", log_dir, (const void *)log_basename);
    log_file=open(log_fname, 01 | 0100 | 02000, 0400 | 0200 | 0400 >> 3);
    if(!(log_file >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      fprintf(stderr, "logger: Could not open %s: %s\n", log_fname, return_value_strerror_5);
      exit(1);
    }

  }

  pthread_rwlock_unlock(&log_file_lock);
  if(log_dest == 3)
    hlog(7, "Log file %s %sopened on fd %d", log_fname, reopen != 0 ? "re" : "", log_file);

  return 0;
}

// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 259
extern signed int parse_args(char **argv, char *cmd)
{
  signed int ct = 0;
  signed int quoted;
  const unsigned short int **return_value___ctype_b_loc_1;
  signed int tmp_post_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  char *tmp_post_4;
  while(!(ct >= 255))
  {
    quoted = 0;
    for( ; !(*cmd == 0); cmd = cmd + 1l)
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*cmd]) == 0)
        break;

    }
    if((signed int)*cmd == 0)
      break;

    if((signed int)*cmd == 34)
    {
      quoted = quoted + 1;
      cmd = cmd + 1l;
    }

    tmp_post_2 = ct;
    ct = ct + 1;
    argv[(signed long int)tmp_post_2] = cmd;
    if(!(quoted == 0))
    {
      cmd=parse_string(cmd);
      if(cmd == ((char *)NULL))
        return 0;

    }

    else
      for( ; !(*cmd == 0); cmd = cmd + 1l)
      {
        return_value___ctype_b_loc_3=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*cmd]) == 0))
          break;

      }
    if(!(*cmd == 0))
    {
      tmp_post_4 = cmd;
      cmd = cmd + 1l;
      *tmp_post_4 = (char)0;
    }

  }
  argv[(signed long int)ct] = (char *)(void *)0;
  return ct;
}

// parse_cmdline
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 99
extern void parse_cmdline(signed int argc, char **argv)
{
  signed int s;
  signed int i;
  signed int failed = 0;
  do
  {
    s=getopt(argc, argv, "c:fn:r:e:o:l:s:?h");
    if(s == -1)
      break;

    switch(s)
    {
      case 99:
      {
        cfgfile=hstrdup(optarg);
        break;
      }
      case 102:
      {
        fork_a_daemon = 1;
        break;
      }
      case 110:
      {
        logname=hstrdup(optarg);
        break;
      }
      case 114:
      {
        log_dir=hstrdup(optarg);
        break;
      }
      case 101:
      {
        i=pick_loglevel(optarg, log_levelnames);
        if(i >= 0)
          log_level = i;

        else
        {
          fprintf(stderr, "Log level unknown: \"%s\"\n", optarg);
          failed = 1;
        }
        break;
      }
      case 111:
      {
        i=pick_loglevel(optarg, log_destnames);
        if(i >= 0)
          log_dest = i;

        else
        {
          fprintf(stderr, "Log destination unknown: \"%s\"\n", optarg);
          failed = 1;
        }
        break;
      }
      case 108:
      {
        sound_in_file=hstrdup(optarg);
        break;
      }
      case 115:
      {
        sound_out_file=hstrdup(optarg);
        break;
      }
      case 63:

      case 104:
      {
        fprintf(stderr, "%s\n", (const void *)"gnuais v0.3.3");
        failed = 1;
      }
      default:
        ;
    }
  }
  while((_Bool)1);
  if(log_dir == ((char *)NULL) && log_dest == 3)
  {
    fprintf(stderr, "Log destination set to 'file' but no log directory specified!\n");
    failed = 1;
  }

  if(!(failed == 0))
  {
    fprintf(stderr, " %s", (const void *)"Usage: gnuais [-c cfgfile] [-f (fork)] [-n <logname>] [-e <loglevel>] [-o <logdest>] [-r <logdir>] [-l <inputsoundfile>] [-s <recordsoundfile>] [-h (help)]\n");
    exit(failed);
  }

}

// parse_interval
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 152
signed long int parse_interval(char *origs)
{
  signed long int t = (signed long int)0;
  signed int i;
  char *s;
  char *np;
  char *p;
  char c;
  s=hstrdup(origs);
  p = s;
  np = p;
  while(!(*p == 0))
  {
    const unsigned short int **return_value___ctype_b_loc_2;
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
    {
      signed int return_value_tolower_1;
      return_value_tolower_1=tolower((signed int)*p);
      c = (char)return_value_tolower_1;
      *p = (char)0;
      i=atoi(np);
      if((signed int)c == 115)
        t = t + (signed long int)i;

      else
        if((signed int)c == 109)
          t = t + (signed long int)(60 * i);

        else
          if((signed int)c == 104)
            t = t + (signed long int)(60 * 60 * i);

          else
            if((signed int)c == 100)
              t = t + (signed long int)(24 * 60 * 60 * i);

      np = p + (signed long int)1;
    }

    p = p + 1l;
  }
  signed int return_value_atoi_3;
  if(!(*np == 0))
  {
    return_value_atoi_3=atoi(np);
    t = t + (signed long int)return_value_atoi_3;
  }

  hfree((void *)s);
  return t;
}

// parse_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 186
static char * parse_string(char *str)
{
  char *cp = str;
  unsigned long int num;
  char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  char *tmp_post_6;
  char *tmp_post_7;
  char *tmp_post_8;
  char *tmp_post_9;
  char *tmp_post_10;
  char *tmp_post_11;
  char *tmp_post_12;
  char *tmp_post_13;
  char *tmp_post_14;
  char *tmp_post_15;
  while(!((signed int)*str == 0))
  {
    if((signed int)*str == 34)
      break;

    if((signed int)*str == 92)
    {
      str = str + 1l;
      tmp_post_1 = str;
      str = str + 1l;
      switch((signed int)*tmp_post_1)
      {
        case 110:
        {
          tmp_post_2 = cp;
          cp = cp + 1l;
          *tmp_post_2 = (char)10;
          break;
        }
        case 116:
        {
          tmp_post_3 = cp;
          cp = cp + 1l;
          *tmp_post_3 = (char)9;
          break;
        }
        case 118:
        {
          tmp_post_4 = cp;
          cp = cp + 1l;
          *tmp_post_4 = (char)11;
          break;
        }
        case 98:
        {
          tmp_post_5 = cp;
          cp = cp + 1l;
          *tmp_post_5 = (char)8;
          break;
        }
        case 114:
        {
          tmp_post_6 = cp;
          cp = cp + 1l;
          *tmp_post_6 = (char)13;
          break;
        }
        case 102:
        {
          tmp_post_7 = cp;
          cp = cp + 1l;
          *tmp_post_7 = (char)12;
          break;
        }
        case 97:
        {
          tmp_post_8 = cp;
          cp = cp + 1l;
          *tmp_post_8 = (char)7;
          break;
        }
        case 92:
        {
          tmp_post_9 = cp;
          cp = cp + 1l;
          *tmp_post_9 = (char)92;
          break;
        }
        case 34:
        {
          tmp_post_10 = cp;
          cp = cp + 1l;
          *tmp_post_10 = (char)34;
          break;
        }
        case 120:
        {
          str = str - 1l;
          num=strtoul(str, &str, 16);
          tmp_post_11 = cp;
          cp = cp + 1l;
          *tmp_post_11 = (char)num;
          break;
        }
        case 48:

        case 49:

        case 50:

        case 51:

        case 52:

        case 53:

        case 54:

        case 55:
        {
          str = str - 1l;
          num=strtoul(str, &str, 8);
          tmp_post_12 = cp;
          cp = cp + 1l;
          *tmp_post_12 = (char)num;
          break;
        }
        case 0:
          return (char *)(void *)0;
        default:
        {
          tmp_post_13 = cp;
          cp = cp + 1l;
          *tmp_post_13 = *(str - (signed long int)1);
        }
      }
    }

    else
    {
      tmp_post_14 = cp;
      cp = cp + 1l;
      tmp_post_15 = str;
      str = str + 1l;
      *tmp_post_14 = *tmp_post_15;
    }
  }
  if((signed int)*str == 34)
    str = str + 1l;

  *cp = (char)0;
  return str;
}

// pick_loglevel
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 45
extern signed int pick_loglevel(char *s, char **names)
{
  signed int i = 0;
  signed int return_value_strcasecmp_1;
  for( ; !(names[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    return_value_strcasecmp_1=strcasecmp(s, names[(signed long int)i]);
    if(return_value_strcasecmp_1 == 0)
      return i;

  }
  return -1;
}

// pname
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 209
extern const char * pname(unsigned int id)
{
  return (const char *)((struct syment *)id)->name;
}

// protodec_18
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 585
void protodec_18(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int longitude;
  signed int latitude;
  unsigned short int course;
  unsigned short int sog;
  unsigned short int heading;
  char rateofturn;
  char navstat;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(57, 28, d->rbuffer);
  longitude = (signed int)return_value_protodec_henten_1;
  if((longitude >> 27 & 1) == 1)
    longitude = longitude | (signed int)0xF0000000;

  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(85, 27, d->rbuffer);
  latitude = (signed int)return_value_protodec_henten_2;
  if((latitude >> 26 & 1) == 1)
    latitude = latitude | (signed int)0xf8000000;

  unsigned long int return_value_protodec_henten_3;
  return_value_protodec_henten_3=protodec_henten(112, 12, d->rbuffer);
  course = (unsigned short int)return_value_protodec_henten_3;
  unsigned long int return_value_protodec_henten_4;
  return_value_protodec_henten_4=protodec_henten(46, 10, d->rbuffer);
  sog = (unsigned short int)return_value_protodec_henten_4;
  rateofturn = (char)0;
  navstat = (char)15;
  unsigned long int return_value_protodec_henten_5;
  return_value_protodec_henten_5=protodec_henten(124, 9, d->rbuffer);
  heading = (unsigned short int)return_value_protodec_henten_5;
  printf(" lat %.6f lon %.6f course %.0f speed %.1f rateofturn %d navstat %d heading %d", (double)(float)latitude / 600000.0, (double)(float)longitude / 600000.0, (double)(float)course / 10.0, (double)(float)sog / 10.0, rateofturn, navstat, heading);
  if(!(my == ((struct mysql_state_t *)NULL)))
    myout_ais_position(my, received_t, (signed int)mmsi, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0), (float)heading, (float)((double)(float)course / 10.0), (float)((double)(float)sog / 10.0));

  if(!(cache_positions == 0))
    cache_position((signed int)received_t, (signed int)mmsi, (signed int)navstat, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0), (signed int)heading, (float)((double)(float)course / 10.0), (signed int)rateofturn, (float)((double)(float)sog / 10.0));

  if(!(have_my_loc == 0))
    update_range(d, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0));

}

// protodec_19
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 632
void protodec_19(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int pos;
  signed int k;
  unsigned int A;
  unsigned int B;
  unsigned char C;
  unsigned char D;
  unsigned int shiptype;
  signed int letter;
  char name[21l];
  char destination[21l] = { 'C', 'L', 'A', 'S', 'S', ' ', 'B', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  pos = 143;
  k = 0;
  for( ; !(k >= 20); k = k + 1)
  {
    unsigned long int return_value_protodec_henten_1;
    return_value_protodec_henten_1=protodec_henten(pos, 6, d->rbuffer);
    letter = (signed int)return_value_protodec_henten_1;
    protodec_decode_sixbit_ascii((char)letter, name, k);
    pos = pos + 6;
  }
  name[(signed long int)20] = (char)0;
  remove_trailing_spaces(name, 20);
  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(263, 8, d->rbuffer);
  shiptype = (unsigned int)return_value_protodec_henten_2;
  unsigned long int return_value_protodec_henten_3;
  return_value_protodec_henten_3=protodec_henten(271, 9, d->rbuffer);
  A = (unsigned int)return_value_protodec_henten_3;
  unsigned long int return_value_protodec_henten_4;
  return_value_protodec_henten_4=protodec_henten(271 + 9, 9, d->rbuffer);
  B = (unsigned int)return_value_protodec_henten_4;
  unsigned long int return_value_protodec_henten_5;
  return_value_protodec_henten_5=protodec_henten(271 + 9 + 9, 6, d->rbuffer);
  C = (unsigned char)return_value_protodec_henten_5;
  unsigned long int return_value_protodec_henten_6;
  return_value_protodec_henten_6=protodec_henten(271 + 9 + 9 + 6, 6, d->rbuffer);
  D = (unsigned char)return_value_protodec_henten_6;
  printf(" name \"%s\" type %d length %d  width %d", (const void *)name, shiptype, A + B, (signed int)C + (signed int)D);
  if(!(my == ((struct mysql_state_t *)NULL)))
  {
    myout_ais_vesselname(my, received_t, (signed int)mmsi, name, destination);
    myout_ais_vesseldatab(my, received_t, (signed int)mmsi, (signed int)A, (signed int)B, (signed int)C, (signed int)D);
  }

  if(!(cache_positions == 0))
  {
    cache_vesselname((signed int)received_t, (signed int)mmsi, name, destination);
    cache_vesseldatabb((signed int)received_t, (signed int)mmsi, (signed int)shiptype, (signed int)A, (signed int)B, (signed int)C, (signed int)D);
  }

}

// protodec_20
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 682
void protodec_20(struct demod_state_t *d, signed int bufferlen)
{
  signed int ofs;
  signed int slots;
  signed int timeout;
  signed int incr;
  signed int i;
  signed int pos = 40;
  i = 0;
  for( ; !(30 + pos >= bufferlen) && !(i >= 4); pos = pos + 30)
  {
    unsigned long int return_value_protodec_henten_1;
    return_value_protodec_henten_1=protodec_henten(pos, 12, d->rbuffer);
    ofs = (signed int)return_value_protodec_henten_1;
    unsigned long int return_value_protodec_henten_2;
    return_value_protodec_henten_2=protodec_henten(pos + 12, 4, d->rbuffer);
    slots = (signed int)return_value_protodec_henten_2;
    unsigned long int return_value_protodec_henten_3;
    return_value_protodec_henten_3=protodec_henten(pos + 12 + 4, 3, d->rbuffer);
    timeout = (signed int)return_value_protodec_henten_3;
    unsigned long int return_value_protodec_henten_4;
    return_value_protodec_henten_4=protodec_henten(pos + 12 + 4 + 3, 11, d->rbuffer);
    incr = (signed int)return_value_protodec_henten_4;
    printf(" reserve %d (ofs %d slots %d timeout %d incr %d)", i + 1, ofs, slots, timeout, incr);
    i = i + 1;
  }
}

// protodec_24
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 702
void protodec_24(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int partnr;
  signed int pos;
  signed int k;
  signed int letter;
  unsigned int A;
  unsigned int B;
  unsigned char C;
  unsigned char D;
  unsigned int shiptype;
  char name[21l];
  char callsign[7l];
  const char destination[21l] = { 'C', 'L', 'A', 'S', 'S', ' ', 'B', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(38, 2, d->rbuffer);
  partnr = (signed int)return_value_protodec_henten_1;
  if(partnr == 0)
  {
    pos = 40;
    k = 0;
    for( ; !(k >= 20); k = k + 1)
    {
      unsigned long int return_value_protodec_henten_2;
      return_value_protodec_henten_2=protodec_henten(pos, 6, d->rbuffer);
      letter = (signed int)return_value_protodec_henten_2;
      protodec_decode_sixbit_ascii((char)letter, name, k);
      pos = pos + 6;
    }
    name[(signed long int)20] = (char)0;
    remove_trailing_spaces(name, 20);
    printf(" name \"%s\"", (const void *)name);
    if(!(my == ((struct mysql_state_t *)NULL)))
      myout_ais_vesselname(my, received_t, (signed int)mmsi, name, destination);

    if(!(cache_positions == 0))
      cache_vesselname((signed int)received_t, (signed int)mmsi, name, destination);

  }

  if(partnr == 1)
  {
    pos = 90;
    k = 0;
    for( ; !(k >= 6); k = k + 1)
    {
      unsigned long int return_value_protodec_henten_3;
      return_value_protodec_henten_3=protodec_henten(pos, 6, d->rbuffer);
      letter = (signed int)return_value_protodec_henten_3;
      protodec_decode_sixbit_ascii((char)letter, callsign, k);
      pos = pos + 6;
    }
    callsign[(signed long int)6] = (char)0;
    remove_trailing_spaces(callsign, 6);
    unsigned long int return_value_protodec_henten_4;
    return_value_protodec_henten_4=protodec_henten(40, 8, d->rbuffer);
    shiptype = (unsigned int)return_value_protodec_henten_4;
    unsigned long int return_value_protodec_henten_5;
    return_value_protodec_henten_5=protodec_henten(132, 9, d->rbuffer);
    A = (unsigned int)return_value_protodec_henten_5;
    unsigned long int return_value_protodec_henten_6;
    return_value_protodec_henten_6=protodec_henten(132 + 9, 9, d->rbuffer);
    B = (unsigned int)return_value_protodec_henten_6;
    unsigned long int return_value_protodec_henten_7;
    return_value_protodec_henten_7=protodec_henten(132 + 9 + 9, 6, d->rbuffer);
    C = (unsigned char)return_value_protodec_henten_7;
    unsigned long int return_value_protodec_henten_8;
    return_value_protodec_henten_8=protodec_henten(132 + 9 + 9 + 6, 6, d->rbuffer);
    D = (unsigned char)return_value_protodec_henten_8;
    printf(" callsign \"%s\" type %d length %d width %d", (const void *)callsign, shiptype, A + B, (signed int)C + (signed int)D);
    if(!(my == ((struct mysql_state_t *)NULL)))
      myout_ais_vesseldatab(my, received_t, (signed int)mmsi, (signed int)A, (signed int)B, (signed int)C, (signed int)D);

    if(!(cache_positions == 0))
      cache_vesseldatab((signed int)received_t, (signed int)mmsi, callsign, (signed int)shiptype, (signed int)A, (signed int)B, (signed int)C, (signed int)D);

  }

}

// protodec_4
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 403
void protodec_4(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  unsigned long int day;
  unsigned long int hour;
  unsigned long int minute;
  unsigned long int second;
  unsigned long int year;
  unsigned long int month;
  signed int longitude;
  signed int latitude;
  float longit;
  float latit;
  year=protodec_henten(40, 12, d->rbuffer);
  month=protodec_henten(52, 4, d->rbuffer);
  day=protodec_henten(56, 5, d->rbuffer);
  hour=protodec_henten(61, 5, d->rbuffer);
  minute=protodec_henten(66, 6, d->rbuffer);
  second=protodec_henten(72, 6, d->rbuffer);
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(79, 28, d->rbuffer);
  longitude = (signed int)return_value_protodec_henten_1;
  if((longitude >> 27 & 1) == 1)
    longitude = longitude | (signed int)0xF0000000;

  longit = (float)(((double)(float)longitude / 10000.0) / 60.0);
  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(107, 27, d->rbuffer);
  latitude = (signed int)return_value_protodec_henten_2;
  if((latitude >> 26 & 1) == 1)
    latitude = latitude | (signed int)0xf8000000;

  latit = (float)(((double)(float)latitude / 10000.0) / 60.0);
  printf(" date %ld-%ld-%ld time %02ld:%02ld:%02ld lat %.6f lon %.6f", year, month, day, hour, minute, second, latit, longit);
  if(!(my == ((struct mysql_state_t *)NULL)))
    myout_ais_basestation(my, received_t, (signed int)mmsi, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0));

  if(!(cache_positions == 0))
    cache_position((signed int)received_t, (signed int)mmsi, 0, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0), 0, (float)0.0, 0, (float)0.0);

  if(!(have_my_loc == 0))
    update_range(d, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0));

}

// protodec_5
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 445
void protodec_5(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int pos;
  unsigned long int imo;
  char callsign[7l];
  char name[21l];
  char destination[21l];
  unsigned int A;
  unsigned int B;
  unsigned char C;
  unsigned char D;
  unsigned char draught;
  signed int k;
  signed int letter;
  unsigned int shiptype;
  imo=protodec_henten(40, 30, d->rbuffer);
  pos = 70;
  k = 0;
  for( ; !(k >= 6); k = k + 1)
  {
    unsigned long int return_value_protodec_henten_1;
    return_value_protodec_henten_1=protodec_henten(pos, 6, d->rbuffer);
    letter = (signed int)return_value_protodec_henten_1;
    protodec_decode_sixbit_ascii((char)letter, callsign, k);
    pos = pos + 6;
  }
  callsign[(signed long int)6] = (char)0;
  remove_trailing_spaces(callsign, 6);
  pos = 112;
  k = 0;
  for( ; !(k >= 20); k = k + 1)
  {
    unsigned long int return_value_protodec_henten_2;
    return_value_protodec_henten_2=protodec_henten(pos, 6, d->rbuffer);
    letter = (signed int)return_value_protodec_henten_2;
    protodec_decode_sixbit_ascii((char)letter, name, k);
    pos = pos + 6;
  }
  name[(signed long int)20] = (char)0;
  remove_trailing_spaces(name, 20);
  pos = 120 + 106 + 68 + 8;
  k = 0;
  for( ; !(k >= 20); k = k + 1)
  {
    unsigned long int return_value_protodec_henten_3;
    return_value_protodec_henten_3=protodec_henten(pos, 6, d->rbuffer);
    letter = (signed int)return_value_protodec_henten_3;
    protodec_decode_sixbit_ascii((char)letter, destination, k);
    pos = pos + 6;
  }
  destination[(signed long int)20] = (char)0;
  remove_trailing_spaces(destination, 20);
  unsigned long int return_value_protodec_henten_4;
  return_value_protodec_henten_4=protodec_henten(232, 8, d->rbuffer);
  shiptype = (unsigned int)return_value_protodec_henten_4;
  unsigned long int return_value_protodec_henten_5;
  return_value_protodec_henten_5=protodec_henten(240, 9, d->rbuffer);
  A = (unsigned int)return_value_protodec_henten_5;
  unsigned long int return_value_protodec_henten_6;
  return_value_protodec_henten_6=protodec_henten(240 + 9, 9, d->rbuffer);
  B = (unsigned int)return_value_protodec_henten_6;
  unsigned long int return_value_protodec_henten_7;
  return_value_protodec_henten_7=protodec_henten(240 + 9 + 9, 6, d->rbuffer);
  C = (unsigned char)return_value_protodec_henten_7;
  unsigned long int return_value_protodec_henten_8;
  return_value_protodec_henten_8=protodec_henten(240 + 9 + 9 + 6, 6, d->rbuffer);
  D = (unsigned char)return_value_protodec_henten_8;
  unsigned long int return_value_protodec_henten_9;
  return_value_protodec_henten_9=protodec_henten(294, 8, d->rbuffer);
  draught = (unsigned char)return_value_protodec_henten_9;
  printf(" name \"%s\" destination \"%s\" type %d length %d width %d draught %.1f", (const void *)name, (const void *)destination, shiptype, A + B, (signed int)C + (signed int)D, (double)(float)draught / 10.0);
  if(!(my == ((struct mysql_state_t *)NULL)))
    myout_ais_vesseldata(my, received_t, (signed int)mmsi, name, destination, (float)((double)(float)draught / 10.0), (signed int)A, (signed int)B, (signed int)C, (signed int)D);

  if(!(cache_positions == 0))
    cache_vesseldata((signed int)received_t, (signed int)mmsi, (signed int)imo, callsign, name, destination, (signed int)shiptype, (signed int)A, (signed int)B, (signed int)C, (signed int)D, (float)((double)draught / 10.0));

}

// protodec_6
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 525
void protodec_6(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int sequence;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(38, 2, d->rbuffer);
  sequence = (signed int)return_value_protodec_henten_1;
  unsigned long int dst_mmsi;
  dst_mmsi=protodec_henten(40, 30, d->rbuffer);
  signed int retransmitted;
  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(70, 1, d->rbuffer);
  retransmitted = (signed int)return_value_protodec_henten_2;
  signed int appid;
  unsigned long int return_value_protodec_henten_3;
  return_value_protodec_henten_3=protodec_henten(72, 16, d->rbuffer);
  appid = (signed int)return_value_protodec_henten_3;
  signed int appid_dac;
  unsigned long int return_value_protodec_henten_4;
  return_value_protodec_henten_4=protodec_henten(72, 10, d->rbuffer);
  appid_dac = (signed int)return_value_protodec_henten_4;
  signed int appid_fi;
  unsigned long int return_value_protodec_henten_5;
  return_value_protodec_henten_5=protodec_henten(82, 6, d->rbuffer);
  appid_fi = (signed int)return_value_protodec_henten_5;
  printf(" dst_mmsi %09ld seq %d retransmitted %d appid %d app_dac %d app_fi %d", dst_mmsi, sequence, retransmitted, appid, appid_dac, appid_fi);
  if(appid_dac == 1)
  {
    const char *return_value_appid_ifm_6;
    return_value_appid_ifm_6=appid_ifm(appid_fi);
    printf("(%s)", return_value_appid_ifm_6);
    protodec_msg_bin(d->rbuffer, bufferlen, appid_fi, 88, received_t, mmsi);
  }

}

// protodec_7_13
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 548
void protodec_7_13(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  unsigned long int dst_mmsi;
  signed int sequence;
  signed int i;
  signed int pos = 40;
  printf(" buflen %d pos+32 %d", bufferlen, pos + 32);
  i = 0;
  for( ; bufferlen >= 32 + pos && !(i >= 4); pos = pos + 32)
  {
    dst_mmsi=protodec_henten(pos, 30, d->rbuffer);
    unsigned long int return_value_protodec_henten_1;
    return_value_protodec_henten_1=protodec_henten(pos + 30, 2, d->rbuffer);
    sequence = (signed int)return_value_protodec_henten_1;
    printf(" ack %d (to %09ld seq %d)", i + 1, dst_mmsi, sequence);
    i = i + 1;
  }
}

// protodec_8
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 572
void protodec_8(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int appid;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(40, 16, d->rbuffer);
  appid = (signed int)return_value_protodec_henten_1;
  signed int appid_dac;
  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(40, 10, d->rbuffer);
  appid_dac = (signed int)return_value_protodec_henten_2;
  signed int appid_fi;
  unsigned long int return_value_protodec_henten_3;
  return_value_protodec_henten_3=protodec_henten(50, 6, d->rbuffer);
  appid_fi = (signed int)return_value_protodec_henten_3;
  printf(" appid %d app_dac %d app_fi %d", appid, appid_dac, appid_fi);
  if(appid_dac == 1)
  {
    const char *return_value_appid_ifm_4;
    return_value_appid_ifm_4=appid_ifm(appid_fi);
    printf("(%s)", return_value_appid_ifm_4);
    protodec_msg_bin(d->rbuffer, bufferlen, appid_fi, 56, received_t, mmsi);
  }

}

// protodec_calculate_crc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 120
signed int protodec_calculate_crc(signed int length_bits, struct demod_state_t *d)
{
  signed int length_bytes;
  unsigned char *buf;
  signed int buflen;
  signed int i;
  signed int j;
  signed int x;
  unsigned char tmp;
  if(!(length_bits >= 1))
  {
    hlog(3, "protodec_calculate_crc: length_bits <= 0!");
    return 0;
  }

  else
  {
    length_bytes = length_bits / 8;
    buflen = length_bytes + 2;
    void *return_value_hmalloc_1;
    return_value_hmalloc_1=hmalloc(sizeof(unsigned char) /*1ul*/  * (unsigned long int)buflen);
    buf = (unsigned char *)return_value_hmalloc_1;
    j = 0;
    for( ; !(j >= buflen); j = j + 1)
    {
      tmp = (unsigned char)0;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        tmp = tmp | (unsigned char)((signed int)d->buffer[(signed long int)(i + 8 * j)] << i);
      buf[(signed long int)j] = tmp;
    }
    unsigned short int crc;
    crc=protodec_sdlc_crc(buf, (unsigned int)buflen);
    memset((void *)d->rbuffer, 0, (unsigned long int)450);
    j = 0;
    for( ; !(j >= length_bytes); j = j + 1)
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        x = j * 8 + i;
        if(x >= 450)
        {
          hlog(3, "protodec_calculate_crc: would run over rbuffer length");
          hfree((void *)buf);
          return 0;
        }

        else
          d->rbuffer[(signed long int)x] = (unsigned char)((signed int)buf[(signed long int)j] >> 7 - i & 1);
      }
    }
    hfree((void *)buf);
    return (signed int)((signed int)crc == 0x0f47);
  }
}

// protodec_decode
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.h line 76
void protodec_decode(char *in, signed int count, struct demod_state_t *d)
{
  signed int i = 0;
  signed int bufferlength;
  signed int correct;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !(i >= count); i = i + 1)
  {
    switch(d->state)
    {
      case 4:
      {
        if(!(d->bitstuff == 0))
        {
          if((signed int)in[(signed long int)i] == 1)
          {
            d->state = 5;
            d->ndata = 0;
            d->bitstuff = 0;
          }

          else
          {
            d->ndata = d->ndata + 1;
            d->last = in[(signed long int)i];
            d->bitstuff = 0;
          }
        }

        else
        {
          if(in[(signed long int)i] == d->last)
            tmp_if_expr_1 = (signed int)in[(signed long int)i] == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(tmp_if_expr_1)
          {
            d->antallenner = d->antallenner + 1;
            if(d->antallenner == 4)
            {
              d->bitstuff = 1;
              d->antallenner = 0;
            }

          }

          else
            d->antallenner = 0;
          d->buffer[(signed long int)d->bufferpos] = (unsigned char)in[(signed long int)i];
          d->bufferpos = d->bufferpos + 1;
          d->ndata = d->ndata + 1;
          if(d->bufferpos >= 449)
            protodec_reset(d);

        }
        break;
      }
      case 1:
      {
        if(!(in[(signed long int)i] == d->last))
          d->antallpreamble = d->antallpreamble + 1;

        else
          d->antallpreamble = 0;
        d->last = in[(signed long int)i];
        if(d->antallpreamble >= 15)
        {
          if((signed int)in[(signed long int)i] == 0)
          {
            d->state = 2;
            d->nskurr = 0;
            d->antallpreamble = 0;
          }

        }

        d->nskurr = d->nskurr + 1;
        break;
      }
      case 2:
      {
        if(!(in[(signed long int)i] == d->last))
          tmp_if_expr_2 = d->nstartsign == 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          d->antallpreamble = d->antallpreamble + 1;

        else
          if((signed int)in[(signed long int)i] == 1)
          {
            if(d->nstartsign == 0)
            {
              d->nstartsign = 3;
              d->last = in[(signed long int)i];
            }

            else
              if(d->nstartsign == 5)
              {
                d->nstartsign = d->nstartsign + 1;
                d->npreamble = 0;
                d->antallpreamble = 0;
                d->state = 3;
              }

              else
                d->nstartsign = d->nstartsign + 1;
          }

          else
            if(d->nstartsign == 0)
              d->nstartsign = 1;

            else
              protodec_reset(d);
        d->npreamble = d->npreamble + 1;
        break;
      }
      case 3:
      {
        if(d->nstartsign >= 7)
        {
          if((signed int)in[(signed long int)i] == 0)
          {
            d->state = 4;
            d->nstartsign = 0;
            d->antallenner = 0;
            memset((void *)d->buffer, 0, (unsigned long int)450);
            d->bufferpos = 0;
          }

          else
            protodec_reset(d);
        }

        else
          if((signed int)in[(signed long int)i] == 0)
            protodec_reset(d);

        d->nstartsign = d->nstartsign + 1;
        break;
      }
      case 5:
      {
        bufferlength = (d->bufferpos - 6) - 16;
        if((signed int)in[(signed long int)i] == 0 && bufferlength >= 1)
        {
          correct=protodec_calculate_crc(bufferlength, d);
          if(!(correct == 0))
          {
            d->receivedframes = d->receivedframes + 1;
            protodec_getdata(bufferlength, d);
          }

          else
            d->lostframes = d->lostframes + 1;
        }

        else
          d->lostframes2 = d->lostframes2 + 1;
        protodec_reset(d);
      }
    }
    d->last = in[(signed long int)i];
  }
}

// protodec_decode_sixbit_ascii
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 190
void protodec_decode_sixbit_ascii(char sixbit, char *name, signed int pos)
{
  if((signed int)sixbit >= 1 && !((signed int)sixbit >= 32))
    name[(signed long int)pos] = (char)((signed int)sixbit + 64);

  else
    if((signed int)sixbit >= 32 && !((signed int)sixbit >= 64))
      name[(signed long int)pos] = sixbit;

    else
      name[(signed long int)pos] = (char)32;
}

// protodec_deinit
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 78
void protodec_deinit(struct demod_state_t *d)
{
  hfree((void *)d->buffer);
  hfree((void *)d->rbuffer);
  hfree((void *)d->serbuffer);
  hfree((void *)d->ipcbuffer);
  hfree((void *)d->nmea);
}

// protodec_generate_nmea
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 780
void protodec_generate_nmea(struct demod_state_t *d, signed int bufferlen, signed int fillbits, signed long int received_t)
{
  signed int senlen;
  signed int pos;
  signed int k;
  signed int letter;
  signed int m;
  unsigned char sentences;
  unsigned char sentencenum;
  unsigned char nmeachk;
  char nchk[3l];
  signed int serbuffer_l;
  signed int ipcbuffer_l;
  senlen = 61;
  if(6 * senlen >= bufferlen)
    sentences = (unsigned char)1;

  else
  {
    sentences = (unsigned char)(bufferlen / (senlen * 6));
    if(!(bufferlen % (6 * senlen) == 0))
      sentences = sentences + 1;

  }
  sentencenum = (unsigned char)0;
  pos = 0;
  do
  {
    k = 13;
    while(!(k >= 13 + senlen) && !(pos >= bufferlen))
    {
      unsigned long int return_value_protodec_henten_1;
      return_value_protodec_henten_1=protodec_henten(pos, 6, d->rbuffer);
      letter = (signed int)return_value_protodec_henten_1;
      if(!(letter >= 40))
        letter = letter + 48;

      else
        letter = letter + 56;
      d->nmea[(signed long int)k] = (char)letter;
      pos = pos + 6;
      k = k + 1;
    }
    d->nmea[(signed long int)k] = (char)44;
    d->nmea[(signed long int)(k + 1)] = (char)48;
    d->nmea[(signed long int)(k + 2)] = (char)42;
    d->nmea[(signed long int)(k + 3)] = (char)48;
    d->nmea[(signed long int)(k + 4)] = (char)48;
    d->nmea[(signed long int)(k + 5)] = (char)0;
    sentencenum = sentencenum + 1;
    d->nmea[(signed long int)0] = (char)65;
    d->nmea[(signed long int)1] = (char)73;
    d->nmea[(signed long int)2] = (char)86;
    d->nmea[(signed long int)3] = (char)68;
    d->nmea[(signed long int)4] = (char)77;
    d->nmea[(signed long int)5] = (char)44;
    d->nmea[(signed long int)6] = (char)(48 + (signed int)sentences);
    d->nmea[(signed long int)7] = (char)44;
    d->nmea[(signed long int)8] = (char)(48 + (signed int)sentencenum);
    d->nmea[(signed long int)9] = (char)44;
    if((signed int)sentences >= 2)
    {
      d->nmea[(signed long int)10] = (char)((signed int)d->seqnr + 48);
      d->nmea[(signed long int)11] = (char)44;
      d->nmea[(signed long int)12] = (char)44;
      if(sentencenum == sentences)
        d->nmea[(signed long int)(k + 1)] = (char)(48 + fillbits);

    }

    else
    {
      d->nmea[(signed long int)10] = (char)44;
      d->nmea[(signed long int)11] = (char)65;
      d->nmea[(signed long int)12] = (char)44;
    }
    nmeachk = (unsigned char)d->nmea[(signed long int)0];
    m = 1;
    for( ; !((signed int)d->nmea[(signed long int)m] == 42); m = m + 1)
      nmeachk = (unsigned char)((signed int)nmeachk ^ (signed int)d->nmea[(signed long int)m]);
    nchk[(signed long int)0] = (char)0;
    nchk[(signed long int)1] = (char)0;
    snprintf(nchk, (unsigned long int)3, "%X", nmeachk);
    if((signed int)nchk[1l] == 0)
      d->nmea[(signed long int)(k + 4)] = nchk[(signed long int)0];

    else
    {
      d->nmea[(signed long int)(k + 3)] = nchk[(signed long int)0];
      d->nmea[(signed long int)(k + 4)] = nchk[(signed long int)1];
    }
    serbuffer_l=snprintf(d->serbuffer, (unsigned long int)100, "!%s\r\n", d->nmea);
    if(!(d->serial == ((struct serial_state_t *)NULL)))
      serial_write(d->serial, d->serbuffer, serbuffer_l);

    ipcbuffer_l=snprintf(d->ipcbuffer, (unsigned long int)255, "!%s", d->nmea);
    if(!(d->ipc == ((struct ipc_state_t *)NULL)))
      ipc_write(d->ipc, d->ipcbuffer, ipcbuffer_l);

    if(!(my == ((struct mysql_state_t *)NULL)))
      myout_nmea(my, received_t, d->nmea);

  }
  while(!((signed int)sentencenum >= (signed int)sentences));
}

// protodec_getdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 896
void protodec_getdata(signed int bufferlen, struct demod_state_t *d)
{
  unsigned char type;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(0, 6, d->rbuffer);
  type = (unsigned char)return_value_protodec_henten_1;
  if(!((signed int)type >= 25) && (signed int)type >= 1)
  {
    unsigned long int mmsi;
    mmsi=protodec_henten(8, 30, d->rbuffer);
    signed int fillbits = 0;
    signed int k;
    signed long int received_t;
    time(&received_t);
    if(bufferlen % 6 >= 1)
    {
      fillbits = 6 - bufferlen % 6;
      k = bufferlen;
      for( ; !(k >= fillbits + bufferlen); k = k + 1)
        d->rbuffer[(signed long int)k] = (unsigned char)0;
      bufferlen = bufferlen + fillbits;
    }

    protodec_generate_nmea(d, bufferlen, fillbits, received_t);
    d->seqnr = d->seqnr + 1;
    if((signed int)d->seqnr >= 10)
      d->seqnr = (unsigned char)0;

    if(!((signed int)type >= 25) && (signed int)type >= 1)
    {
      if(skip_type[(signed long int)type] == 0)
      {
        printf("ch %c type %d mmsi %09ld:", d->chanid, type, mmsi);
        switch((signed int)type)
        {
          case 1:

          case 2:

          case 3:
          {
            protodec_pos(d, bufferlen, received_t, mmsi);
            break;
          }
          case 4:
          {
            protodec_4(d, bufferlen, received_t, mmsi);
            break;
          }
          case 5:
          {
            protodec_5(d, bufferlen, received_t, mmsi);
            break;
          }
          case 6:
          {
            protodec_6(d, bufferlen, received_t, mmsi);
            break;
          }
          case 7:

          case 13:
          {
            protodec_7_13(d, bufferlen, received_t, mmsi);
            break;
          }
          case 8:
          {
            protodec_8(d, bufferlen, received_t, mmsi);
            break;
          }
          case 18:
          {
            protodec_18(d, bufferlen, received_t, mmsi);
            break;
          }
          case 19:
          {
            protodec_19(d, bufferlen, received_t, mmsi);
            break;
          }
          case 24:
          {
            protodec_24(d, bufferlen, received_t, mmsi);
            break;
          }
          case 20:
            protodec_20(d, bufferlen);
        }
        printf(" (!%s)\n", d->nmea);
        fflush(stdout);
      }

    }

  }

}

// protodec_henten
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 205
unsigned long int protodec_henten(signed int from, signed int size, unsigned char *frame)
{
  signed int i = 0;
  unsigned long int tmp = (unsigned long int)0;
  i = 0;
  for( ; !(i >= size); i = i + 1)
    tmp = tmp | (unsigned long int)((signed int)frame[(signed long int)(from + i)] << (size - 1) - i);
  return tmp;
}

// protodec_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.h line 73
void protodec_initialize(struct demod_state_t *d, struct serial_state_t *serial, struct ipc_state_t *ipc, char chanid)
{
  memset((void *)d, 0, sizeof(struct demod_state_t) /*144ul*/ );
  d->chanid = chanid;
  d->serial = serial;
  d->ipc = ipc;
  d->receivedframes = 0;
  d->lostframes = 0;
  d->lostframes2 = 0;
  protodec_reset(d);
  d->seqnr = (unsigned char)0;
  void *return_value_hmalloc_1;
  return_value_hmalloc_1=hmalloc((unsigned long int)450);
  d->buffer = (unsigned char *)return_value_hmalloc_1;
  void *return_value_hmalloc_2;
  return_value_hmalloc_2=hmalloc((unsigned long int)450);
  d->rbuffer = (unsigned char *)return_value_hmalloc_2;
  void *return_value_hmalloc_3;
  return_value_hmalloc_3=hmalloc((unsigned long int)100);
  d->serbuffer = (char *)return_value_hmalloc_3;
  void *return_value_hmalloc_4;
  return_value_hmalloc_4=hmalloc((unsigned long int)255);
  d->ipcbuffer = (char *)return_value_hmalloc_4;
  void *return_value_hmalloc_5;
  return_value_hmalloc_5=hmalloc((unsigned long int)100);
  d->nmea = (char *)return_value_hmalloc_5;
}

// protodec_msg_11
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 286
void protodec_msg_11(unsigned char *buffer, signed int bufferlen, signed int msg_start, signed long int received_t, unsigned long int mmsi)
{
  signed int latitude;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(msg_start, 24, buffer);
  latitude = (signed int)return_value_protodec_henten_1;
  signed int longitude;
  msg_start = msg_start + 24;
  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(msg_start, 25, buffer);
  longitude = (signed int)return_value_protodec_henten_2;
  signed int wind_speed;
  msg_start = msg_start + 16;
  unsigned long int return_value_protodec_henten_3;
  return_value_protodec_henten_3=protodec_henten(msg_start, 7, buffer);
  wind_speed = (signed int)return_value_protodec_henten_3;
  signed int wind_gust;
  msg_start = msg_start + 7;
  unsigned long int return_value_protodec_henten_4;
  return_value_protodec_henten_4=protodec_henten(msg_start, 7, buffer);
  wind_gust = (signed int)return_value_protodec_henten_4;
  signed int wind_dir;
  msg_start = msg_start + 7;
  unsigned long int return_value_protodec_henten_5;
  return_value_protodec_henten_5=protodec_henten(msg_start, 9, buffer);
  wind_dir = (signed int)return_value_protodec_henten_5;
  signed int wind_gust_dir;
  msg_start = msg_start + 9;
  unsigned long int return_value_protodec_henten_6;
  return_value_protodec_henten_6=protodec_henten(msg_start, 9, buffer);
  wind_gust_dir = (signed int)return_value_protodec_henten_6;
  signed int air_temp;
  msg_start = msg_start + 9;
  unsigned long int return_value_protodec_henten_7;
  return_value_protodec_henten_7=protodec_henten(msg_start, 11, buffer);
  air_temp = (signed int)return_value_protodec_henten_7;
  signed int rel_humid;
  msg_start = msg_start + 11;
  unsigned long int return_value_protodec_henten_8;
  return_value_protodec_henten_8=protodec_henten(msg_start, 7, buffer);
  rel_humid = (signed int)return_value_protodec_henten_8;
  signed int dew_point;
  msg_start = msg_start + 7;
  unsigned long int return_value_protodec_henten_9;
  return_value_protodec_henten_9=protodec_henten(msg_start, 10, buffer);
  dew_point = (signed int)return_value_protodec_henten_9;
  signed int air_press;
  msg_start = msg_start + 10;
  unsigned long int return_value_protodec_henten_10;
  return_value_protodec_henten_10=protodec_henten(msg_start, 9, buffer);
  air_press = (signed int)(return_value_protodec_henten_10 + (unsigned long int)800);
  signed int air_press_tend;
  msg_start = msg_start + 9;
  unsigned long int return_value_protodec_henten_11;
  return_value_protodec_henten_11=protodec_henten(msg_start, 2, buffer);
  air_press_tend = (signed int)return_value_protodec_henten_11;
  signed int horiz_visib_nm;
  msg_start = msg_start + 2;
  unsigned long int return_value_protodec_henten_12;
  return_value_protodec_henten_12=protodec_henten(msg_start, 8, buffer);
  horiz_visib_nm = (signed int)return_value_protodec_henten_12;
  signed int water_level;
  msg_start = msg_start + 8;
  unsigned long int return_value_protodec_henten_13;
  return_value_protodec_henten_13=protodec_henten(msg_start, 9, buffer);
  water_level = (signed int)return_value_protodec_henten_13;
  signed int wave_height_significant;
  msg_start = msg_start + 5;
  unsigned long int return_value_protodec_henten_14;
  return_value_protodec_henten_14=protodec_henten(msg_start, 8, buffer);
  wave_height_significant = (signed int)return_value_protodec_henten_14;
  signed int water_temp;
  msg_start = msg_start + 4;
  unsigned long int return_value_protodec_henten_15;
  return_value_protodec_henten_15=protodec_henten(msg_start, 10, buffer);
  water_temp = (signed int)return_value_protodec_henten_15;
  printf(" lat %.6f lon %.6f wind_speed %dkt wind_gust %dkt wind_dir %d wind_gust_dir %d air_temp %.1fC rel_humid %d%% dew_point %.1fC pressure %d pressure_tend %d visib %.1fNM water_level %.1fm wave_height %.1fm water_temp %.1fC", (double)(float)latitude / 60000.0, (double)(float)longitude / 60000.0, wind_speed, wind_gust, wind_dir, wind_gust_dir, (double)(float)air_temp / 10.0 - 60.0, rel_humid, (double)(float)dew_point / 10.0 - 20.0, air_press, air_press_tend, (double)(float)horiz_visib_nm / 10.0, (double)(float)water_level / 10.0 - 10.0, (double)(float)wave_height_significant / 10.0, (double)(float)water_temp / 10.0 - 10.0);
}

// protodec_msg_40
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 278
void protodec_msg_40(unsigned char *buffer, signed int bufferlen, signed int msg_start, signed long int received_t, unsigned long int mmsi)
{
  signed int people_on_board;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(msg_start, 13, buffer);
  people_on_board = (signed int)return_value_protodec_henten_1;
  printf(" persons-on-board %d", people_on_board);
  if(!(cache_positions == 0))
    cache_vessel_persons((signed int)received_t, (signed int)mmsi, people_on_board);

}

// protodec_msg_bin
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 338
void protodec_msg_bin(unsigned char *buffer, signed int bufferlen, signed int appid_fi, signed int msg_start, signed long int received_t, unsigned long int mmsi)
{
  switch(appid_fi)
  {
    case 11:
    {
      protodec_msg_11(buffer, bufferlen, msg_start, received_t, mmsi);
      break;
    }
    case 40:
      protodec_msg_40(buffer, bufferlen, msg_start, received_t, mmsi);
  }
}

// protodec_pos
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 357
void protodec_pos(struct demod_state_t *d, signed int bufferlen, signed long int received_t, unsigned long int mmsi)
{
  signed int longitude;
  signed int latitude;
  unsigned short int course;
  unsigned short int sog;
  unsigned short int heading;
  char rateofturn;
  char navstat;
  unsigned long int return_value_protodec_henten_1;
  return_value_protodec_henten_1=protodec_henten(61, 28, d->rbuffer);
  longitude = (signed int)return_value_protodec_henten_1;
  if((longitude >> 27 & 1) == 1)
    longitude = longitude | (signed int)0xF0000000;

  unsigned long int return_value_protodec_henten_2;
  return_value_protodec_henten_2=protodec_henten(38 + 22 + 29, 27, d->rbuffer);
  latitude = (signed int)return_value_protodec_henten_2;
  if((latitude >> 26 & 1) == 1)
    latitude = latitude | (signed int)0xf8000000;

  unsigned long int return_value_protodec_henten_3;
  return_value_protodec_henten_3=protodec_henten(38 + 22 + 28 + 28, 12, d->rbuffer);
  course = (unsigned short int)return_value_protodec_henten_3;
  unsigned long int return_value_protodec_henten_4;
  return_value_protodec_henten_4=protodec_henten(50, 10, d->rbuffer);
  sog = (unsigned short int)return_value_protodec_henten_4;
  unsigned long int return_value_protodec_henten_5;
  return_value_protodec_henten_5=protodec_henten(38 + 2, 8, d->rbuffer);
  rateofturn = (char)return_value_protodec_henten_5;
  unsigned long int return_value_protodec_henten_6;
  return_value_protodec_henten_6=protodec_henten(38, 2, d->rbuffer);
  navstat = (char)return_value_protodec_henten_6;
  unsigned long int return_value_protodec_henten_7;
  return_value_protodec_henten_7=protodec_henten(38 + 22 + 28 + 28 + 12, 9, d->rbuffer);
  heading = (unsigned short int)return_value_protodec_henten_7;
  printf(" lat %.6f lon %.6f course %.0f speed %.1f rateofturn %d navstat %d heading %d", (double)(float)latitude / 600000.0, (double)(float)longitude / 600000.0, (double)(float)course / 10.0, (double)(float)sog / 10.0, rateofturn, navstat, heading);
  if(!(my == ((struct mysql_state_t *)NULL)))
    myout_ais_position(my, received_t, (signed int)mmsi, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0), (float)heading, (float)((double)(float)course / 10.0), (float)((double)(float)sog / 10.0));

  if(!(cache_positions == 0))
    cache_position((signed int)received_t, (signed int)mmsi, (signed int)navstat, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0), (signed int)heading, (float)((double)(float)course / 10.0), (signed int)rateofturn, (float)((double)(float)sog / 10.0));

  if(!(have_my_loc == 0))
    update_range(d, (float)((double)(float)latitude / 600000.0), (float)((double)(float)longitude / 600000.0));

}

// protodec_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 87
void protodec_reset(struct demod_state_t *d)
{
  d->state = 1;
  d->nskurr = 0;
  d->ndata = 0;
  d->npreamble = 0;
  d->nstartsign = 0;
  d->nstopsign = 0;
  d->antallpreamble = 0;
  d->antallenner = 0;
  d->last = (char)0;
  d->bitstuff = 0;
  d->bufferpos = 0;
}

// protodec_sdlc_crc
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 106
unsigned short int protodec_sdlc_crc(const unsigned char *data, unsigned int len)
{
  unsigned short int c;
  unsigned short int crc = (unsigned short int)0xffff;
  unsigned int tmp_post_1;
  const unsigned char *tmp_post_2;
  do
  {
    tmp_post_1 = len;
    len = len - 1u;
    if(tmp_post_1 == 0u)
      break;

    tmp_post_2 = data;
    data = data + 1l;
    c = (unsigned short int)(0x100 + (signed int)*tmp_post_2);
    for( ; (signed int)c >= 2; c = c >> 1)
      if(!((((signed int)c ^ (signed int)crc) & 1) == 0))
        crc = (unsigned short int)((signed int)crc >> 1 ^ 0x8408);

      else
        crc = crc >> 1;
  }
  while((_Bool)1);
  return (unsigned short int)~((signed int)crc);
}

// pulseaudio_cleanup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/pulseaudio.h line 29
void pulseaudio_cleanup(struct pa_simple *s)
{
  pa_simple_free(s);
}

// pulseaudio_initialize
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/pulseaudio.h line 27
struct pa_simple * pulseaudio_initialize()
{
  struct pa_simple *s;
  struct pa_sample_spec ss;
  ss.format = (enum pa_sample_format)PA_SAMPLE_S16LE;
  if(sound_channels == 1)
    ss.channels = (unsigned char)1;

  else
    ss.channels = (unsigned char)2;
  ss.rate = (unsigned int)48000;
  s=pa_simple_new((const char *)(void *)0, "gnuais", (enum pa_stream_direction)PA_STREAM_RECORD, (const char *)(void *)0, "AIS data", &ss, (const struct pa_channel_map *)(void *)0, (const struct pa_buffer_attr *)(void *)0, (signed int *)(void *)0);
  return s;
}

// pulseaudio_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/pulseaudio.h line 31
signed int pulseaudio_read(struct pa_simple *s, signed short int *buffer, signed int count)
{
  signed int number_read;
  signed int channels;
  if(sound_channels == 1)
    channels = 1;

  else
    channels = 2;
  number_read=pa_simple_read(s, (void *)buffer, (unsigned long int)((unsigned long int)count * sizeof(signed short int) /*2ul*/  * (unsigned long int)channels), (signed int *)(void *)0);
  if(!(number_read >= 0))
    return -1;

  else
    return count;
}

// read_cfgfile
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.h line 34
extern signed int read_cfgfile(char *f, struct cfgcmd *cmds)
{
  struct _IO_FILE *fp;
  struct _IO_FILE *tmp_file;
  char line[102400l];
  signed int ret;
  signed int n = 0;
  char *conf_home_folder;
  char *conf_home_folder_name;
  fp=fopen(f, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    char *return_value_getenv_1;
    return_value_getenv_1=getenv("HOME");
    conf_home_folder_name=hstrdup(return_value_getenv_1);
    conf_home_folder_name=str_append(conf_home_folder_name, "/.config");
    ret=mkdir(conf_home_folder_name, (unsigned int)0777);
    conf_home_folder_name=str_append(conf_home_folder_name, "/gnuais");
    conf_home_folder=hstrdup(conf_home_folder_name);
    conf_home_folder=str_append(conf_home_folder, "/config");
    fp=fopen(conf_home_folder, "r");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      hlog(6, "Creating directory: ~/.config/gnuais/");
      ret=mkdir(conf_home_folder_name, (unsigned int)0777);
      if(!(ret == 0))
        hlog(6, "~/.config/gnuais/ already exists");

      tmp_file=fopen("/etc/gnuais.conf", "r");
      ret = 0;
      if(tmp_file == ((struct _IO_FILE *)NULL))
      {
        tmp_file=fopen("/usr/local/share/doc/gnuais/gnuais.conf-example", "r");
        if(tmp_file == ((struct _IO_FILE *)NULL))
        {
          tmp_file=fopen("/usr/share/doc/gnuais/examples/gnuais.conf-example", "r");
          if(tmp_file == ((struct _IO_FILE *)NULL))
            hlog(3, "No gnuais.conf-example found to be copied to ~/.config/gnuais/config");

          else
          {
            hlog(5, "Using gnuais.conf-example as a starting point for ~/.config/gnuais/config...");
            ret=cpfile(conf_home_folder, "/usr/share/doc/gnuais/examples/gnuais.conf-example");
            if(ret == -1)
              hlog(3, "Could not copy configuration file to the home folder");

            else
              hlog(5, "DONE creating configuration file (~/.config/gnuais/config). You should edit this file manually!");
          }
        }

        else
        {
          hlog(5, "Using gnuais.conf-example as a starting point for ~/.config/gnuais/config...");
          ret=cpfile(conf_home_folder, "/usr/local/share/doc/gnuais/gnuais.conf-example");
          if(ret == -1)
            hlog(3, "Could not copy configuration file to the home folder");

          else
            hlog(5, "DONE creating configuration file (~/.config/gnuais/config). You should edit this file manually!");
        }
      }

      else
      {
        hlog(4, "/etc/gnuais.conf found, but no ~/.config/gnuais/config found.");
        hlog(4, "It will be copied to your home directory (~/.config/gnuais/config)...");
        ret=cpfile(conf_home_folder, "/etc/gnuais.conf");
        if(ret == -1)
          hlog(3, "Could not copy configuration file from /etc/gnuais.conf to your home directory");

        else
          hlog(5, "DONE");
      }
      if(!(ret == -1))
      {
        fp=fopen(conf_home_folder, "r");
        if(fp == ((struct _IO_FILE *)NULL))
          hlog(3, "Could not open configuration file after copying it to the home directory");

      }

    }

    hfree((void *)conf_home_folder_name);
    hfree((void *)conf_home_folder);
  }

  char *return_value_fgets_2;
  if(fp == ((struct _IO_FILE *)NULL))
    hlog(3, "No configuration file found! Running with the default configuration. You should create a file ~/.config/gnuais/config. There should be an example to use in the source archive called gnuais.conf-example");

  else
  {
    do
    {
      return_value_fgets_2=fgets(line, 102400, fp);
      if(return_value_fgets_2 == ((char *)NULL))
        break;

      n = n + 1;
      ret=cmdparse(cmds, line);
      if(!(ret >= 0))
      {
        fprintf(stderr, "Problem in %s at line %d: %s\n", f, n, (const void *)line);
        fclose(fp);
        return 2;
      }

    }
    while((_Bool)1);
    fclose(fp);
  }
  return 0;
}

// read_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.h line 96
extern signed int read_config(void)
{
  signed int failed = 0;
  char *s;
  signed int return_value_read_cfgfile_1;
  return_value_read_cfgfile_1=read_cfgfile(cfgfile, cfg_cmds);
  signed int return_value_valid_aprsis_call_2;
  if(!(return_value_read_cfgfile_1 == 0))
    return -1;

  else
  {
    if(!(log_dir == ((char *)NULL)))
      logdir=hstrdup(log_dir);

    else
      if(logdir == ((char *)NULL))
      {
        if(log_dest == 3)
          hlog(4, "Config: logdir not defined. Using . as log directory");

        logdir=hstrdup(".");
      }

    if(mycall == ((char *)NULL))
    {
      mycall=hstrdup("NOCALLDEFINED");
      hlog(4, "Config: mycall is not defined - using: %s.", mycall);
    }

    else
    {
      return_value_valid_aprsis_call_2=valid_aprsis_call(mycall);
      if(return_value_valid_aprsis_call_2 == 0)
      {
        hlog(2, "Config: mycall '%s' is not valid.", mycall);
        failed = 1;
      }

    }
    if(myemail == ((char *)NULL))
    {
      myemail=hstrdup("notdefined@notdefined");
      hlog(4, "Config: myemail is not defined - using: %s.", myemail);
    }

    if(sound_device == ((char *)NULL) && sound_in_file == ((char *)NULL))
    {
      sound_device = def_sound_device;
      hlog(4, "Config: SoundDevice is not defined - using: %s", sound_device);
    }

    if(!(sound_device == ((char *)NULL)) && !(sound_in_file == ((char *)NULL)))
    {
      if(!(sound_device == def_sound_device))
        hfree((void *)sound_device);

      sound_device = (char *)(void *)0;
    }

    have_my_loc = (signed int)(mylat > (float)-90 && mylat < (float)90 && mylng > (float)-180 && mylng < (float)180);
    if(!(have_my_loc == 0))
    {
      mylat=lat2rad(mylat);
      mylng=lon2rad(mylng);
    }

    free_uplink_config(&uplink_config);
    uplink_config = new_uplink_config;
    if(!(uplink_config == ((struct uplink_config_t *)NULL)))
      uplink_config->prevp = &uplink_config;

    new_uplink_config = (struct uplink_config_t *)(void *)0;
    if(!(failed == 0))
      return -1;

    else
    {
      if(pidfile == ((char *)NULL))
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(logdir);
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(logname);
        void *return_value_hmalloc_5;
        return_value_hmalloc_5=hmalloc(return_value_strlen_3 + (unsigned long int)1 + return_value_strlen_4 + (unsigned long int)3 + (unsigned long int)2);
        s = (char *)return_value_hmalloc_5;
        sprintf(s, "%s/%s.pid", logdir, logname);
        pidfile = s;
      }

      return 0;
    }
  }
}

// receiver_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/receiver.h line 51
extern void receiver_run(struct receiver *rx, signed short int *buf, signed int len)
{
  float out;
  signed int curr;
  signed int bit;
  char b;
  signed short int maxval = (signed short int)0;
  signed int level_distance;
  float level;
  signed int rx_num_ch = rx->num_ch;
  float filtered[4096l];
  signed int i;
  buf = buf + (signed long int)rx->ch_ofs;
  if(len >= 4097)
    abort();

  maxval=filter_run_buf(rx->filter, buf, filtered, rx_num_ch, len);
  i = 0;
  for( ; !(i >= len); i = i + 1)
  {
    out = filtered[(signed long int)i];
    curr = (signed int)(out > (float)0);
    if((rx->prev ^ curr) == 1)
    {
      if(!(rx->pll >= 32768u))
        rx->pll = rx->pll + rx->pllinc / (unsigned int)16;

      else
        rx->pll = rx->pll - rx->pllinc / (unsigned int)16;
    }

    rx->prev = curr;
    rx->pll = rx->pll + rx->pllinc;
    if(rx->pll >= 65536u)
    {
      bit = (signed int)(out > (float)0);
      b = (char)!((bit ^ rx->lastbit) != 0);
      protodec_decode(&b, 1, rx->decoder);
      rx->lastbit = bit;
      rx->pll = rx->pll & (unsigned int)0xffff;
    }

  }
  level = ((float)maxval / (float)32768) * (float)100;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  level_distance = (signed int)(return_value_time_1 - rx->last_levellog);
  if(level > 95.000000f && (level_distance >= 30 || level_distance >= sound_levellog))
  {
    hlog(5, "Level on ch %c too high: %.0f %%", rx->decoder->chanid, level);
    time(&rx->last_levellog);
  }

  else
    if(level_distance >= sound_levellog && !(sound_levellog == 0))
    {
      hlog(6, "Level on ch %c: %.0f %%", rx->decoder->chanid, level);
      time(&rx->last_levellog);
    }

}

// remove_trailing_spaces
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/protodec.c line 173
static void remove_trailing_spaces(char *s, signed int len)
{
  signed int i;
  s[(signed long int)len] = (char)0;
  i = len - 1;
  _Bool tmp_if_expr_1;
  for( ; i >= 0; i = i - 1)
  {
    if((signed int)s[(signed long int)i] == 32)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)s[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      s[(signed long int)i] = (char)0;

    else
      i = -1;
  }
}

// serial_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 30
extern signed int serial_close(struct serial_state_t *state)
{
  signed int ret = 0;
  if(state->fd >= 0)
  {
    signed int return_value_close_3;
    return_value_close_3=close(state->fd);
    if(!(return_value_close_3 == 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      hlog(3, "Could not close serial port %s: %s", serial_port, return_value_strerror_2);
      ret = -1;
    }

    state->fd = -1;
  }

  hfree((void *)state);
  return ret;
}

// serial_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 28
extern struct serial_state_t * serial_init()
{
  struct serial_state_t *state = (struct serial_state_t *)(void *)0;
  void *return_value_hmalloc_1;
  return_value_hmalloc_1=hmalloc(sizeof(struct serial_state_t) /*4ul*/ );
  state = (struct serial_state_t *)return_value_hmalloc_1;
  state->fd=open(serial_port, 02 | 0400 | 04000);
  if(state->fd == -1)
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    hlog(2, "Could not open serial port %s: %s", serial_port, return_value_strerror_3);
    return (struct serial_state_t *)(void *)0;
  }

  hlog(6, "Opened serial port %s for NMEA output", serial_port);
  fcntl(state->fd, 4, 0);
  struct termios options;
  signed int return_value_tcgetattr_6;
  return_value_tcgetattr_6=tcgetattr(state->fd, &options);
  signed int *return_value___errno_location_4;
  char *return_value_strerror_5;
  if(!(return_value_tcgetattr_6 == 0))
  {
    return_value___errno_location_4=__errno_location();
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    hlog(3, "Could not read serial port parameters on port %s: %s", serial_port, return_value_strerror_5);
  }

  cfsetispeed(&options, (unsigned int)0000014);
  cfsetospeed(&options, (unsigned int)0000014);
  options.c_cflag = options.c_cflag | (unsigned int)(0004000 | 0000200);
  options.c_lflag = options.c_lflag & (unsigned int)~(0000002 | 0000010 | 0000020 | 0000001);
  options.c_oflag = options.c_oflag & (unsigned int)~0000001;
  options.c_cc[(signed long int)6] = (unsigned char)0;
  options.c_cc[(signed long int)5] = (unsigned char)10;
  options.c_cflag = options.c_cflag & (unsigned int)~0000400;
  options.c_cflag = options.c_cflag & (unsigned int)~0000100;
  options.c_cflag = options.c_cflag & (unsigned int)~0000060;
  options.c_cflag = options.c_cflag | (unsigned int)0000060;
  signed int return_value_tcsetattr_9;
  return_value_tcsetattr_9=tcsetattr(state->fd, 0, &options);
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  if(!(return_value_tcsetattr_9 == 0))
  {
    return_value___errno_location_7=__errno_location();
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    hlog(3, "Could not configure serial port parameters on port %s: %s", serial_port, return_value_strerror_8);
  }

  return state;
}

// serial_write
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/serial.h line 29
extern signed int serial_write(struct serial_state_t *state, char *s, signed int len)
{
  signed int n;
  signed long int return_value_write_1;
  return_value_write_1=write(state->fd, (const void *)s, (unsigned long int)len);
  n = (signed int)return_value_write_1;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(!(n >= 0))
  {
    return_value___errno_location_2=__errno_location();
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    hlog(3, "Could not write to serial port %s: %s", serial_port, return_value_strerror_3);
  }

  return n;
}

// sp_alloc_blk
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 77
struct spblk * sp_alloc_blk(void)
{
  struct spblk *p;
  signed int i;
  if(sp_free_list == ((struct spblk *)NULL))
  {
    if(!(dump_splay == 0))
      fprintf(stderr, "splay: allocating %d entries for a total of %ld\n", 200, sp_allocated + (signed long int)200);

    i = 0;
    for( ; !(i >= 200); i = i + 1)
    {
      void *return_value_hmalloc_1;
      return_value_hmalloc_1=hmalloc(sizeof(struct spblk) /*40ul*/ );
      p = (struct spblk *)return_value_hmalloc_1;
      p->uplink = sp_free_list;
      sp_free_list = p;
      sp_allocated = sp_allocated + 1l;
    }
  }

  p = sp_free_list;
  sp_free_list = p->uplink;
  sp_entries = sp_entries + 1l;
  return p;
}

// sp_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 379
extern void sp_delete(struct spblk *n, struct sptree *q)
{
  struct spblk *x;
  _splay(n, q);
  x=_sp_deq(&q->root->rightlink);
  if(x == ((struct spblk *)NULL))
  {
    q->root = q->root->leftlink;
    if(!(q->root == ((struct spblk *)NULL)))
      q->root->uplink = (struct spblk *)(void *)0;

  }

  else
  {
    x->uplink = (struct spblk *)(void *)0;
    x->leftlink = q->root->leftlink;
    x->rightlink = q->root->rightlink;
    if(!(x->leftlink == ((struct spblk *)NULL)))
      x->leftlink->uplink = x;

    if(!(x->rightlink == ((struct spblk *)NULL)))
      x->rightlink->uplink = x;

    q->root = x;
  }
  sp_free_blk(n);
  q->eltscnt = q->eltscnt - (signed long long int)1;
}

// sp_fhead
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 177
extern struct spblk * sp_fhead(struct sptree *q)
{
  struct spblk *x;
  if(q == ((struct sptree *)NULL))
    return (struct spblk *)(void *)0;

  else
  {
    x = q->root;
    if(!(x == ((struct spblk *)NULL)))
      for( ; !(x->leftlink == ((struct spblk *)NULL)); x = x->leftlink)
        ;

    return x;
  }
}

// sp_fnext
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 247
extern struct spblk * sp_fnext(struct spblk *n)
{
  struct spblk *next;
  struct spblk *x;
  if(n == ((struct spblk *)NULL))
    return n;

  else
  {
    x = n->rightlink;
    if(!(x == ((struct spblk *)NULL)))
    {
      for( ; !(x->leftlink == ((struct spblk *)NULL)); x = x->leftlink)
        ;
      next = x;
    }

    else
    {
      x = n->uplink;
      next = (struct spblk *)(void *)0;
      while(!(x == ((struct spblk *)NULL)))
        if(x->leftlink == n)
        {
          next = x;
          x = (struct spblk *)(void *)0;
        }

        else
        {
          n = x;
          x = n->uplink;
        }
    }
    return next;
  }
}

// sp_free_blk
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 66
void sp_free_blk(struct spblk *n)
{
  n->uplink = sp_free_list;
  sp_free_list = n;
  sp_entries = sp_entries - 1l;
}

// sp_free_freelist
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 103
extern void sp_free_freelist(void)
{
  struct spblk *p;
  struct spblk *next = sp_free_list;
  for( ; !(next == ((struct spblk *)NULL)); sp_entries = sp_entries - 1l)
  {
    p = next;
    next = p->uplink;
    hfree((void *)p);
  }
}

// sp_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 451
extern struct sptree * sp_init(void)
{
  struct sptree *q;
  void *return_value_hmalloc_1;
  return_value_hmalloc_1=hmalloc(sizeof(struct sptree) /*72ul*/ );
  q = (struct sptree *)return_value_hmalloc_1;
  q->symbols = (struct sptree *)(void *)0;
  q->eltscnt = (signed long long int)0;
  q->lookups = (signed long long int)0;
  q->lkpcmps = (signed long long int)0;
  q->enqs = (signed long long int)0;
  q->enqcmps = (signed long long int)0;
  q->splays = (signed long long int)0;
  q->splayloops = (signed long long int)0;
  q->root = (struct spblk *)(void *)0;
  return q;
}

// sp_install
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 151
extern struct spblk * sp_install(unsigned int key, struct sptree *q)
{
  struct spblk *n;
  n=sp_lookup(key, q);
  if(n == ((struct spblk *)NULL))
  {
    n=sp_alloc_blk();
    n->key = key;
    n->leftlink = (struct spblk *)(void *)0;
    n->rightlink = (struct spblk *)(void *)0;
    n->uplink = (struct spblk *)(void *)0;
    q->eltscnt = q->eltscnt + (signed long long int)1;
    _sp_enq(n, q);
  }

  return n;
}

// sp_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 121
extern struct spblk * sp_lookup(unsigned int key, struct sptree *q)
{
  struct spblk *n;
  signed int c;
  n = q->root;
  q->lkpcmps = q->lkpcmps + 1ll;
  c = (signed int)q->lkpcmps;
  q->lookups = q->lookups + 1ll;
  struct spblk *tmp_if_expr_1;
  for( ; !(n == ((struct spblk *)NULL)); n = tmp_if_expr_1)
  {
    if(key == n->key)
      break;

    c = c + 1;
    if(!(key >= n->key))
      tmp_if_expr_1 = n->leftlink;

    else
      tmp_if_expr_1 = n->rightlink;
  }
  q->lkpcmps = (signed long long int)c;
  if(!(n == ((struct spblk *)NULL)))
    _splay(n, q);

  return n;
}

// sp_null
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 224
extern void sp_null(struct sptree *q)
{
  if(!(q->root == ((struct spblk *)NULL)))
  {
    _sp_chop(q->root);
    q->eltscnt = (signed long long int)0;
    q->lookups = (signed long long int)0;
    q->lkpcmps = (signed long long int)0;
    q->enqs = (signed long long int)0;
    q->enqcmps = (signed long long int)0;
    q->splays = (signed long long int)0;
    q->splayloops = (signed long long int)0;
    q->root = (struct spblk *)(void *)0;
  }

}

// sp_scan
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 198
extern void sp_scan(signed int (*f)(struct spblk *), struct spblk *n, struct sptree *q)
{
  struct spblk *x;
  struct spblk *nextx;
  struct spblk *tmp_if_expr_2;
  struct spblk *return_value_sp_fhead_1;
  if(!(n == ((struct spblk *)NULL)))
    tmp_if_expr_2 = n;

  else
  {
    return_value_sp_fhead_1=sp_fhead(q);
    tmp_if_expr_2 = return_value_sp_fhead_1;
  }
  x = tmp_if_expr_2;
  if(!(x == ((struct spblk *)NULL)))
  {
    nextx=sp_fnext(x);
    f(x);
    x = nextx;
  }

}

// sp_stats
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/splay.c line 282
extern const char * sp_stats(struct sptree *q)
{
  float llen;
  float elen;
  float sloops;
  float tmp_if_expr_1;
  float tmp_if_expr_2;
  float tmp_if_expr_3;
  if(q == ((struct sptree *)NULL))
    return "";

  else
  {
    if(!(q->lookups == 0ll))
      tmp_if_expr_1 = (float)q->lkpcmps / (float)q->lookups;

    else
      tmp_if_expr_1 = (float)0;
    llen = tmp_if_expr_1;
    if(!(q->enqs == 0ll))
      tmp_if_expr_2 = (float)q->enqcmps / (float)q->enqs;

    else
      tmp_if_expr_2 = (float)0;
    elen = tmp_if_expr_2;
    if(!(q->splays == 0ll))
      tmp_if_expr_3 = (float)q->splayloops / (float)q->splays;

    else
      tmp_if_expr_3 = (float)0;
    sloops = tmp_if_expr_3;
    static char buf[128l];
    sprintf(buf, "f(%lld %4.2f) i(%lld %4.2f) s(%lld %4.2f)", q->lookups, llen, q->enqs, elen, q->splays, sloops);
    return buf;
  }
}

// str_append
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.c line 90
extern char * str_append(char *s, const char *fmt, ...)
{
  void **args;
  char buf[8192l];
  signed int len;
  char *ret;
  args = (void **)&fmt;
  vsnprintf(buf, (unsigned long int)8192, fmt, args);
  args = ((void **)NULL);
  buf[(signed long int)(8192 - 1)] = (char)0;
  unsigned long int return_value_strlen_1;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    len = (signed int)return_value_strlen_1;
  }

  else
    len = 0;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(buf);
  void *return_value_hrealloc_3;
  return_value_hrealloc_3=hrealloc((void *)s, (unsigned long int)len + return_value_strlen_2 + (unsigned long int)1);
  ret = (char *)return_value_hrealloc_3;
  strcpy(ret + (signed long int)len, buf);
  return ret;
}

// strlwr
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfgfile.c line 123
extern char * strlwr(char *s)
{
  char *c = s;
  for( ; !(*c == 0); c = c + 1l)
  {
    signed int return_value_tolower_1;
    return_value_tolower_1=tolower((signed int)*c);
    *c = (char)return_value_tolower_1;
  }
  return s;
}

// strupr
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 302
char * strupr(char *s)
{
  char *p = s;
  signed int return_value_toupper_1;
  for( ; !(*p == 0); p = p + 1l)
  {
    return_value_toupper_1=toupper((signed int)*p);
    *p = (char)return_value_toupper_1;
  }
  return s;
}

// symbol
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 41
extern unsigned int symbol(const void *s)
{
  if(spt_symtab == ((struct sptree *)NULL))
    spt_symtab=sp_init();

  unsigned int return_value_symbol_db_1;
  return_value_symbol_db_1=symbol_db(s, spt_symtab);
  return return_value_symbol_db_1;
}

// symbol_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 230
extern unsigned int symbol_db(const void *s, struct sptree *spt)
{
  if(s == NULL)
    return (unsigned int)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((const char *)s);
    unsigned int return_value_symbol_db_mem_2;
    return_value_symbol_db_mem_2=symbol_db_mem(s, (signed int)return_value_strlen_1, spt);
    return return_value_symbol_db_mem_2;
  }
}

// symbol_db_mem
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 81
extern unsigned int symbol_db_mem(const void *s, signed int slen, struct sptree *spt)
{
  unsigned int key;
  struct syment *se;
  struct syment *pe;
  struct spblk *spl;
  signed int return_value_memcmp_2;
  if(s == NULL)
    return (unsigned int)0;

  else
  {
    unsigned long int return_value_crc32n_1;
    return_value_crc32n_1=crc32n((const unsigned char *)s, slen);
    key = (unsigned int)return_value_crc32n_1;
    pe = (struct syment *)(void *)0;
    spl=sp_lookup(key, spt);
    if(!(spl == ((struct spblk *)NULL)))
    {
      se = (struct syment *)spl->data;
      while((_Bool)1)
      {
        if(se->namelen == slen)
        {
          return_value_memcmp_2=memcmp((const void *)se->name, s, (unsigned long int)slen);
          if(return_value_memcmp_2 == 0)
            return (unsigned int)se;

        }

        pe = se;
        se = se->next;
        if(se == ((struct syment *)NULL))
          break;

      }
    }

    void *return_value_hmalloc_3;
    return_value_hmalloc_3=hmalloc(sizeof(struct syment) /*16ul*/  + (unsigned long int)slen);
    se = (struct syment *)return_value_hmalloc_3;
    memcpy((void *)se->name, s, (unsigned long int)slen);
    ((char *)se->name)[(signed long int)slen] = (char)0;
    se->namelen = slen;
    se->next = (struct syment *)(void *)0;
    if(!(pe == ((struct syment *)NULL)))
      pe->next = se;

    else
    {
      spl=sp_install(key, spt);
      spl->data = (void *)se;
    }
    return (unsigned int)se;
  }
}

// symbol_free_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 196
extern void symbol_free_db(const void *s, struct sptree *spt)
{
  if(!(s == NULL) && !(spt == ((struct sptree *)NULL)))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((const char *)s);
    symbol_free_db_mem(s, (signed int)return_value_strlen_1, spt);
  }

}

// symbol_free_db_mem
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 155
void symbol_free_db_mem(const void *s, signed int slen, struct sptree *spt)
{
  unsigned int key;
  struct syment *se;
  struct syment *pe;
  struct spblk *spl;
  signed int return_value_memcmp_2;
  if(!(s == NULL) && !(spt == ((struct sptree *)NULL)))
  {
    unsigned long int return_value_crc32n_1;
    return_value_crc32n_1=crc32n((const unsigned char *)s, slen);
    key = (unsigned int)return_value_crc32n_1;
    pe = (struct syment *)(void *)0;
    spl=sp_lookup(key, spt);
    if(!(spl == ((struct spblk *)NULL)))
    {
      se = (struct syment *)spl->data;
      while((_Bool)1)
      {
        if(se->namelen == slen)
        {
          return_value_memcmp_2=memcmp((const void *)se->name, s, (unsigned long int)slen);
          if(return_value_memcmp_2 == 0)
          {
            if(!(pe == ((struct syment *)NULL)))
              pe->next = se->next;

            else
              spl->data = (void *)se->next;
            hfree((void *)se);
            goto __CPROVER_DUMP_L6;
          }

        }

        pe = se;
        se = se->next;
        if(se == ((struct syment *)NULL))
          break;

      }
    }


  __CPROVER_DUMP_L6:
    ;
    if(!(spl == ((struct spblk *)NULL)))
    {
      if(spl->data == NULL)
        sp_delete(spl, spt);

    }

  }

}

// symbol_lookup
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 222
extern unsigned int symbol_lookup(const void *s)
{
  if(spt_symtab == ((struct sptree *)NULL))
    spt_symtab=sp_init();

  unsigned int return_value_symbol_lookup_db_1;
  return_value_symbol_lookup_db_1=symbol_lookup_db(s, spt_symtab);
  return return_value_symbol_lookup_db_1;
}

// symbol_lookup_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 214
extern unsigned int symbol_lookup_db(const void *s, struct sptree *spt)
{
  if(s == NULL)
    return (unsigned int)0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((const char *)s);
    unsigned int return_value_symbol_lookup_db_mem_2;
    return_value_symbol_lookup_db_mem_2=symbol_lookup_db_mem(s, (const signed int)return_value_strlen_1, spt);
    return return_value_symbol_lookup_db_mem_2;
  }
}

// symbol_lookup_db_mem
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 49
extern unsigned int symbol_lookup_db_mem(const void *s, const signed int slen, struct sptree *spt)
{
  unsigned int key;
  struct syment *se;
  struct spblk *spl;
  signed int return_value_memcmp_2;
  if(s == NULL)
    return (unsigned int)0;

  else
  {
    unsigned long int return_value_crc32n_1;
    return_value_crc32n_1=crc32n((const unsigned char *)s, slen);
    key = (unsigned int)return_value_crc32n_1;
    spl=sp_lookup(key, spt);
    if(!(spl == ((struct spblk *)NULL)))
    {
      se = (struct syment *)spl->data;
      while((_Bool)1)
      {
        if(se->namelen == slen)
        {
          return_value_memcmp_2=memcmp((const void *)se->name, s, (unsigned long int)slen);
          if(return_value_memcmp_2 == 0)
            return (unsigned int)se;

        }

        se = se->next;
        if(se == ((struct syment *)NULL))
          break;

      }
    }

    return (unsigned int)0;
  }
}

// symbol_null
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 129
static signed int symbol_null(struct spblk *spl)
{
  struct syment *se;
  struct syment *sn;
  se = (struct syment *)spl->data;
  struct syment *tmp_if_expr_1;
  if(!(se == ((struct syment *)NULL)))
    tmp_if_expr_1 = se->next;

  else
    tmp_if_expr_1 = (struct syment *)(void *)0;
  sn = tmp_if_expr_1;
  for( ; !(se == ((struct syment *)NULL)); se = sn)
  {
    sn = se->next;
    hfree((void *)se);
  }
  return 0;
}

// symbol_null_db
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/spsymbol.c line 140
extern void symbol_null_db(struct sptree *spt)
{
  sp_scan(symbol_null, (struct spblk *)(void *)0, spt);
  sp_null(spt);
}

// time_jsonais
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/out_json.c line 150
signed int time_jsonais(signed long int *t, char *buf, signed int buflen)
{
  signed int i;
  struct tm dt;
  if(!(buflen >= 15))
  {
    hlog(3, "time_jsonais: not enough space to produce JSON AIS timestamp");
    return -1;
  }

  else
  {
    struct tm *return_value_gmtime_r_1;
    return_value_gmtime_r_1=gmtime_r(t, &dt);
    if(return_value_gmtime_r_1 == ((struct tm *)NULL))
    {
      hlog(3, "time_jsonais: gmtime_r failed");
      return -1;
    }

    else
    {
      i=snprintf(buf, (unsigned long int)buflen, "%04d%02d%02d%02d%02d%02d", dt.tm_year + 1900, dt.tm_mon + 1, dt.tm_mday, dt.tm_hour, dt.tm_min, dt.tm_sec);
      return i;
    }
  }
}

// update_range
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/range.c line 32
extern void update_range(struct demod_state_t *d, float lat, float lon)
{
  if(!(lat < -89.000000f) && !((double)lon < -1.800100e+2) && !(lat > 89.000000f) && !((double)lon > 180.01))
  {
    if(!((double)lat < 0.001) || !((double)lon < 0.001) || !((double)lat > -1.000000e-3) || !((double)lon > -1.000000e-3))
    {
      float distance;
      float return_value_lat2rad_1;
      return_value_lat2rad_1=lat2rad(lat);
      float return_value_lon2rad_2;
      return_value_lon2rad_2=lon2rad(lon);
      distance=maidenhead_km_distance(mylat, mylng, return_value_lat2rad_1, return_value_lon2rad_2);
      if(distance > d->best_range)
        d->best_range = distance;

    }

  }

}

// valid_aprsis_call
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/cfg.c line 288
signed int valid_aprsis_call(char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  if(return_value_strlen_1 >= 13ul)
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(s);
    if(!(return_value_strlen_2 >= 3ul))
      return 0;

    else
      return 1;
  }
}

// writepid
// file /srv/jenkins-slave/workspace/sid-goto-cc-gnuais/gnuais-0.3.3/src/hlog.h line 54
extern signed int writepid(char *name)
{
  struct _IO_FILE *f;
  f=fopen(name, "w");
  if(f == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    hlog(2, "Could not open %s for writing: %s", name, return_value_strerror_2);
    return 0;
  }

  signed int return_value_getpid_5;
  return_value_getpid_5=getpid();
  signed int return_value_fprintf_6;
  return_value_fprintf_6=fprintf(f, "%ld\n", (signed long int)return_value_getpid_5);
  if(!(return_value_fprintf_6 >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    hlog(2, "Could not write to %s: %s", name, return_value_strerror_4);
    return 0;
  }

  signed int return_value_fclose_9;
  return_value_fclose_9=fclose(f);
  if(!(return_value_fclose_9 == 0))
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    char *return_value_strerror_8;
    return_value_strerror_8=strerror(*return_value___errno_location_7);
    hlog(2, "Could not close %s: %s", name, return_value_strerror_8);
    return 0;
  }

  return 1;
}

