// tag-#anon#ST[*{*{V}_V_(*{V}_V_|*{cV}_cV_)->*{V}_V_}_*{V}_V_(*{V}_V_|*{cV}_cV_)->*{V}_V__'dup'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{SYM#tag-coucal_hashkeys#(*{V}_V_|*{cV}_cV_)->SYM#tag-coucal_hashkeys#}_SYM#tag-coucal_hashkeys#(*{V}_V_|*{cV}_cV_)->SYM#tag-coucal_hashkeys#_'hash'||*{S32(*{V}_V_|*{cV}_cV_|*{cV}_cV_)->S32}_S32(*{V}_V_|*{cV}_cV_|*{cV}_cV_)->S32_'equals'||*{V}_V_'arg'|]
// file coucal.c line 185
struct anonymous_17;

// tag-#anon#ST[*{*{cS8}_cS8_(*{V}_V_|*{cV}_cV_)->*{cS8}_cS8_}_*{cS8}_cS8_(*{V}_V_|*{cV}_cV_)->*{cS8}_cS8__'key'||*{*{cS8}_cS8_(*{V}_V_|cSYM#tag-coucal_value#)->*{cS8}_cS8_}_*{cS8}_cS8_(*{V}_V_|cSYM#tag-coucal_value#)->*{cS8}_cS8__'value'||*{V}_V_'arg'|]
// file coucal.c line 211
struct anonymous_19;

// tag-#anon#ST[*{S8}_S8_'buffer'||U64'size'||U64'capacity'||U64'used'|]
// file coucal.c line 143
struct anonymous_5;

// tag-#anon#ST[*{S8}_S8_'read_buffer'||SYM#tag-z_stream_s#'stream'||U64'pos_in_zipfile'||U64'stream_initialised'||U64'offset_local_extrafield'||U32'size_local_extrafield'||U32'_pad0'||U64'pos_local_extrafield'||U64'total_out_64'||U64'crc32'||U64'crc32_wait'||U64'rest_read_compressed'||U64'rest_read_uncompressed'||SYM#tag-zlib_filefunc64_32_def_s#'z_filefunc'||*{V}_V_'filestream'||U64'compression_method'||U64'byte_before_the_zipfile'||S32'raw'||U32'_pad1'|]
// file minizip/unzip.c line 134
struct anonymous;

// tag-#anon#ST[*{V(*{V}_V_|ENtag-coucal_loglevel#{U32}_U32_|*{cS8}_cS8_|*{*{V}_V_}_*{V}_V__)->V}_V(*{V}_V_|ENtag-coucal_loglevel#{U32}_U32_|*{cS8}_cS8_|*{*{V}_V_}_*{V}_V__)->V_'log'||*{V(*{V}_V_|*{cS8}_cS8_|*{cS8}_cS8_|S32)->V}_V(*{V}_V_|*{cS8}_cS8_|*{cS8}_cS8_|S32)->V_'fatal'||*{V}_V_'arg'||*{cV}_cV_'name'|]
// file coucal.c line 199
struct anonymous_18;

// tag-#anon#ST[*{V(*{V}_V_|SYM#tag-coucal_value#)->V}_V(*{V}_V_|SYM#tag-coucal_value#)->V_'free'||*{V}_V_'arg'|]
// file coucal.c line 177
struct anonymous_16;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_12;

// tag-#anon#ST[ARR16{SYM#tag-coucal_item#}_SYM#tag-coucal_item#_'items'||U64'size'|]
// file coucal.c line 134
struct anonymous_4;

// tag-#anon#ST[S64'timestamp'||*{SYM#tag-struct_coucal#}_SYM#tag-struct_coucal#_'hash'||ARR1024{S8}_S8_'startUrl'|]
// file proxy/store.c line 212
struct anonymous_2;

// tag-#anon#ST[SYM#tag-#anon#ST[*{V(*{V}_V_|SYM#tag-coucal_value#)->V}_V(*{V}_V_|SYM#tag-coucal_value#)->V_'free'||*{V}_V_'arg'|]#'value'||SYM#tag-#anon#ST[*{*{V}_V_(*{V}_V_|*{cV}_cV_)->*{V}_V_}_*{V}_V_(*{V}_V_|*{cV}_cV_)->*{V}_V__'dup'||*{V(*{V}_V_|*{V}_V_)->V}_V(*{V}_V_|*{V}_V_)->V_'free'||*{SYM#tag-coucal_hashkeys#(*{V}_V_|*{cV}_cV_)->SYM#tag-coucal_hashkeys#}_SYM#tag-coucal_hashkeys#(*{V}_V_|*{cV}_cV_)->SYM#tag-coucal_hashkeys#_'hash'||*{S32(*{V}_V_|*{cV}_cV_|*{cV}_cV_)->S32}_S32(*{V}_V_|*{cV}_cV_|*{cV}_cV_)->S32_'equals'||*{V}_V_'arg'|]#'key'||SYM#tag-#anon#ST[*{V(*{V}_V_|ENtag-coucal_loglevel#{U32}_U32_|*{cS8}_cS8_|*{*{V}_V_}_*{V}_V__)->V}_V(*{V}_V_|ENtag-coucal_loglevel#{U32}_U32_|*{cS8}_cS8_|*{*{V}_V_}_*{V}_V__)->V_'log'||*{V(*{V}_V_|*{cS8}_cS8_|*{cS8}_cS8_|S32)->V}_V(*{V}_V_|*{cS8}_cS8_|*{cS8}_cS8_|S32)->V_'fatal'||*{V}_V_'arg'||*{cV}_cV_'name'|]#'error'||SYM#tag-#anon#ST[*{*{cS8}_cS8_(*{V}_V_|*{cV}_cV_)->*{cS8}_cS8_}_*{cS8}_cS8_(*{V}_V_|*{cV}_cV_)->*{cS8}_cS8__'key'||*{*{cS8}_cS8_(*{V}_V_|cSYM#tag-coucal_value#)->*{cS8}_cS8_}_*{cS8}_cS8_(*{V}_V_|cSYM#tag-coucal_value#)->*{cS8}_cS8__'value'||*{V}_V_'arg'|]#'print'|]
// file coucal.c line 175
struct anonymous_7;

// tag-#anon#ST[SYM#tag-tm_zip_s#'tmz_date'||U64'dosDate'||U64'internal_fa'||U64'external_fa'|]
// file proxy/../minizip/zip.h line 99
struct anonymous_10;

// tag-#anon#ST[SYM#tag-z_stream_s#'stream'||S32'stream_initialised'||U32'pos_in_buffered_data'||U64'pos_local_header'||*{S8}_S8_'central_header'||U64'size_centralExtra'||U64'size_centralheader'||U64'size_centralExtraFree'||U64'flag'||S32'method'||S32'raw'||ARR65536{U8}_U8_'buffered_data'||U64'dosDate'||U64'crc32'||S32'encrypt'||S32'zip64'||U64'pos_zip64extrainfo'||U64'totalCompressedData'||U64'totalUncompressedData'||ARR3{U64}_U64_'keys'||*{cU32}_cU32_'pcrc_32_tab'||S32'crypt_header_size'||U32'_pad0'|]
// file minizip/zip.c line 130
struct anonymous_8;

// tag-#anon#ST[SYM#tag-zlib_filefunc64_32_def_s#'z_filefunc'||*{V}_V_'filestream'||SYM#tag-linkedlist_data_s#'central_dir'||S32'in_opened_file_inzip'||U32'_pad0'||SYM#tag-#anon#ST[SYM#tag-z_stream_s#'stream'||S32'stream_initialised'||U32'pos_in_buffered_data'||U64'pos_local_header'||*{S8}_S8_'central_header'||U64'size_centralExtra'||U64'size_centralheader'||U64'size_centralExtraFree'||U64'flag'||S32'method'||S32'raw'||ARR65536{U8}_U8_'buffered_data'||U64'dosDate'||U64'crc32'||S32'encrypt'||S32'zip64'||U64'pos_zip64extrainfo'||U64'totalCompressedData'||U64'totalUncompressedData'||ARR3{U64}_U64_'keys'||*{cU32}_cU32_'pcrc_32_tab'||S32'crypt_header_size'||U32'_pad0'|]#'ci'||U64'begin_pos'||U64'add_position_when_writting_offset'||U64'number_entry'||*{S8}_S8_'globalcomment'|]
// file minizip/zip.c line 165
struct anonymous_9;

// tag-#anon#ST[SYM#tag-zlib_filefunc64_32_def_s#'z_filefunc'||S32'is64bitOpenFunction'||U32'_pad0'||*{V}_V_'filestream'||SYM#tag-unz_global_info64_s#'gi'||U64'byte_before_the_zipfile'||U64'num_file'||U64'pos_in_central_dir'||U64'current_file_ok'||U64'central_pos'||U64'size_central_dir'||U64'offset_central_dir'||SYM#tag-unz_file_info64_s#'cur_file_info'||SYM#tag-unz_file_info64_internal_s#'cur_file_info_internal'||*{SYM#tag-#anon#ST[*{S8}_S8_'read_buffer'||SYM#tag-z_stream_s#'stream'||U64'pos_in_zipfile'||U64'stream_initialised'||U64'offset_local_extrafield'||U32'size_local_extrafield'||U32'_pad0'||U64'pos_local_extrafield'||U64'total_out_64'||U64'crc32'||U64'crc32_wait'||U64'rest_read_compressed'||U64'rest_read_uncompressed'||SYM#tag-zlib_filefunc64_32_def_s#'z_filefunc'||*{V}_V_'filestream'||U64'compression_method'||U64'byte_before_the_zipfile'||S32'raw'||U32'_pad1'|]#}_SYM#tag-#anon#ST[*{S8}_S8_'read_buffer'||SYM#tag-z_stream_s#'stream'||U64'pos_in_zipfile'||U64'stream_initialised'||U64'offset_local_extrafield'||U32'size_local_extrafield'||U32'_pad0'||U64'pos_local_extrafield'||U64'total_out_64'||U64'crc32'||U64'crc32_wait'||U64'rest_read_compressed'||U64'rest_read_uncompressed'||SYM#tag-zlib_filefunc64_32_def_s#'z_filefunc'||*{V}_V_'filestream'||U64'compression_method'||U64'byte_before_the_zipfile'||S32'raw'||U32'_pad1'|]#_'pfile_in_zip_read'||S32'encrypted'||S32'isZip64'|]
// file minizip/unzip.c line 165
struct anonymous_0;

// tag-#anon#ST[U64'max_stash_size'||U64'write_count'||U64'add_count'||U64'cuckoo_moved'||U64'stash_added'||U64'rehash_count'||U64'pool_compact_count'||U64'pool_realloc_count'|]
// file coucal.c line 155
struct anonymous_6;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_13;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_11;

// tag-#anon#UN[ARR64{U8}_U8_'ui8'||ARR16{U32}_U32_'ui32'|]
// file md5.h line 21
union anonymous_15;

// tag-#anon#UN[SYM#tag-_PT_Index__New#'formatNew'||SYM#tag-_PT_Index__Old#'formatOld'||SYM#tag-_PT_Index__Arc#'formatArc'||SYM#tag-#anon#ST[S64'timestamp'||*{SYM#tag-struct_coucal#}_SYM#tag-struct_coucal#_'hash'||ARR1024{S8}_S8_'startUrl'|]#'common'|]
// file proxy/store.c line 208
union anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_1;

// tag-#anon#UN[SYM#tag-sockaddr#'sa'||SYM#tag-sockaddr_in#'in'||SYM#tag-sockaddr_in6#'in6'|]
// file ./htsnet.h line 94
union anonymous_14;

// tag-MD5Context
// file md5.h line 20
struct MD5Context;

// tag-OLD_htsblk
// file ./htslib.h line 121
struct OLD_htsblk;

// tag-OLD_t_proxy
// file ./htslib.h line 111
struct OLD_t_proxy;

// tag-PT_SaveCache__Arc_t
// file proxy/store.c line 2275
struct PT_SaveCache__Arc_t;

// tag-SOCaddr
// file ./htsnet.h line 91
struct SOCaddr;

// tag-String
// file ./htsstrings.h line 57
struct String;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PT_Element
// file proxy/store.h line 51
struct _PT_Element;

// tag-_PT_Index
// file proxy/store.h line 39
struct _PT_Index;

// tag-_PT_Index_Functions
// file proxy/store.c line 117
struct _PT_Index_Functions;

// tag-_PT_Index__Arc
// file proxy/store.c line 116
struct _PT_Index__Arc;

// tag-_PT_Index__New
// file proxy/store.c line 114
struct _PT_Index__New;

// tag-_PT_Index__Old
// file proxy/store.c line 115
struct _PT_Index__Old;

// tag-_PT_Indexes
// file proxy/store.h line 40
struct _PT_Indexes;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-coucal_hashkeys
// file ./coucal.h line 160
struct coucal_hashkeys;

// tag-coucal_item
// file ./coucal.h line 136
struct coucal_item;

// tag-coucal_loglevel
// file coucal.h line 181
enum coucal_loglevel { coucal_log_critical=0, coucal_log_warning=1, coucal_log_info=2, coucal_log_debug=3, coucal_log_trace=4 };

// tag-coucal_value
// file ./coucal.h line 117
union coucal_value;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-linkedlist_data_s
// file minizip/zip.c line 123
struct linkedlist_data_s;

// tag-linkedlist_datablock_internal_s
// file minizip/zip.c line 114
struct linkedlist_datablock_internal_s;

// tag-proxytrack_process_th_p
// file proxy/proxytrack.c line 1433
struct proxytrack_process_th_p;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-struct_coucal
// file coucal.h line 231
struct struct_coucal;

// tag-struct_coucal_enum
// file ./coucal.h line 237
struct struct_coucal_enum;

// tag-timeb
// file /usr/include/x86_64-linux-gnu/sys/timeb.h line 31
struct timeb;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-tm_unz_s
// file proxy/../minizip/unzip.h line 84
struct tm_unz_s;

// tag-tm_zip_s
// file proxy/../minizip/zip.h line 89
struct tm_zip_s;

// tag-unz64_file_pos_s
// file minizip/unzip.h line 272
struct unz64_file_pos_s;

// tag-unz_file_info64_internal_s
// file minizip/unzip.c line 126
struct unz_file_info64_internal_s;

// tag-unz_file_info64_s
// file minizip/unzip.h line 111
struct unz_file_info64_s;

// tag-unz_file_info_s
// file proxy/../minizip/unzip.h line 132
struct unz_file_info_s;

// tag-unz_file_pos_s
// file minizip/unzip.h line 258
struct unz_file_pos_s;

// tag-unz_global_info64_s
// file minizip/unzip.h line 96
struct unz_global_info64_s;

// tag-unz_global_info_s
// file minizip/unzip.h line 103
struct unz_global_info_s;

// tag-utimbuf
// file ./httrack-library.h line 322
struct utimbuf;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

// tag-zlib_filefunc64_32_def_s
// file minizip/ioapi.h line 199
struct zlib_filefunc64_32_def_s;

// tag-zlib_filefunc64_def_s
// file minizip/ioapi.h line 182
struct zlib_filefunc64_def_s;

// tag-zlib_filefunc_def_s
// file minizip/ioapi.h line 165
struct zlib_filefunc_def_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// DecodeUrl
// file proxy/store.c line 1553
static struct String DecodeUrl(const char *url);
// GetHttpMessage
// file proxy/proxytrack.c line 387
static const char * GetHttpMessage(signed int statuscode);
// ICP_reply
// file proxy/proxytrack.c line 1520
static signed int ICP_reply(struct sockaddr *clientAddr, signed int clientAddrLen, signed int soc, unsigned char Opcode, unsigned char Version, unsigned short int Message_Length, unsigned int Request_Number, unsigned int Options, unsigned int Option_Data, unsigned int Sender_Host_Address, unsigned char *Message);
// LoadCentralDirectoryRecord
// file minizip/zip.c line 640
static signed int LoadCentralDirectoryRecord(struct anonymous_9 *pziinit);
// MD5Final
// file md5.h line 33
void MD5Final(unsigned char *digest, struct MD5Context *ctx);
// MD5Init
// file md5.h line 30
void MD5Init(struct MD5Context *ctx, signed int brokenEndian);
// MD5Transform
// file md5.c line 189
void MD5Transform(unsigned int *buf, const unsigned int *in);
// MD5Update
// file md5.h line 31
void MD5Update(struct MD5Context *ctx, const unsigned char *buf, unsigned int len);
// MutexFree
// file proxy/store.c line 107
void MutexFree(union anonymous_1 *pMutex);
// MutexInit
// file proxy/store.c line 95
void MutexInit(union anonymous_1 *pMutex);
// MutexLock
// file proxy/store.c line 99
void MutexLock(union anonymous_1 *pMutex);
// MutexUnlock
// file proxy/store.c line 103
void MutexUnlock(union anonymous_1 *pMutex);
// PT_AddIndex
// file proxy/store.h line 90
signed int PT_AddIndex(struct _PT_Indexes *indexes, const char *path);
// PT_CompatibleScheme
// file proxy/store.c line 1988
static signed int PT_CompatibleScheme(const char *url);
// PT_Delete
// file proxy/store.h line 87
void PT_Delete(struct _PT_Indexes *index);
// PT_ElementNew
// file proxy/store.h line 113
struct _PT_Element * PT_ElementNew(void);
// PT_Element_Delete
// file proxy/store.h line 114
void PT_Element_Delete(struct _PT_Element **pentry);
// PT_EnumCache
// file proxy/store.c line 624
signed int PT_EnumCache(struct _PT_Indexes *indexes, signed int (*callback)(void *, const char *, struct _PT_Element *), void *arg);

//

// PT_Enumerate
// file proxy/store.h line 98
char ** PT_Enumerate(struct _PT_Indexes *indexes, const char *url, signed int subtree);
// PT_Enumerate_Delete
// file proxy/store.h line 99
void PT_Enumerate_Delete(char ***plist);
// PT_GetIndex
// file proxy/store.h line 93
struct _PT_Index * PT_GetIndex(struct _PT_Indexes *indexes, signed int indexId);
// PT_GetTime
// file proxy/proxytrack.h line 363
static struct tm PT_GetTime(signed long int t);
// PT_GetTimeIndex
// file proxy/store.c line 794
signed long int PT_GetTimeIndex(struct _PT_Indexes *indexes);
// PT_GetType
// file proxy/store.c line 531
static signed int PT_GetType(const char *filename);
// PT_IndexMerge
// file proxy/store.c line 688
signed int PT_IndexMerge(struct _PT_Indexes *indexes, struct _PT_Index **pindex);
// PT_Index_Check__
// file proxy/store.c line 288
static signed int PT_Index_Check__(struct _PT_Index *index, const char *file, signed int line);
// PT_Index_Delete
// file proxy/store.c line 304
void PT_Index_Delete(struct _PT_Index **pindex);
// PT_Index_Delete__Arc
// file proxy/store.c line 350
static void PT_Index_Delete__Arc(struct _PT_Index **pindex);
// PT_Index_Delete__New
// file proxy/store.c line 316
static void PT_Index_Delete__New(struct _PT_Index **pindex);
// PT_Index_Delete__Old
// file proxy/store.c line 332
static void PT_Index_Delete__Old(struct _PT_Index **pindex);
// PT_Index_HTML_BuildRootInfo
// file proxy/store.h line 97
struct _PT_Element * PT_Index_HTML_BuildRootInfo(struct _PT_Indexes *indexes);
// PT_Index_Timestamp
// file proxy/store.h line 110
signed long int PT_Index_Timestamp(struct _PT_Index *index);
// PT_LoadCache
// file proxy/store.c line 546
struct _PT_Index * PT_LoadCache(const char *filename);
// PT_LoadCache__Arc
// file proxy/store.c line 1995
static signed int PT_LoadCache__Arc(struct _PT_Index *index_, const char *filename);
// PT_LoadCache__New
// file proxy/store.c line 881
static signed int PT_LoadCache__New(struct _PT_Index *index_, const char *filename);
// PT_LoadCache__Old
// file proxy/store.c line 1422
static signed int PT_LoadCache__Old(struct _PT_Index *index_, const char *filename);
// PT_LookupCache
// file proxy/store.c line 601
signed int PT_LookupCache(struct _PT_Index *index, const char *url);
// PT_LookupCache__Arc
// file proxy/store.c line 2250
static signed int PT_LookupCache__Arc(struct _PT_Index *index, const char *url);
// PT_LookupCache__Arc_u
// file proxy/store.c line 2261
static signed int PT_LookupCache__Arc_u(struct _PT_Index *index_, const char *url);
// PT_LookupCache__New
// file proxy/store.c line 660
static signed int PT_LookupCache__New(struct _PT_Index *index, const char *url);
// PT_LookupCache__New_u
// file proxy/store.c line 671
static signed int PT_LookupCache__New_u(struct _PT_Index *index_, const char *url);
// PT_LookupCache__Old
// file proxy/store.c line 1832
static signed int PT_LookupCache__Old(struct _PT_Index *index, const char *url);
// PT_LookupCache__Old_u
// file proxy/store.c line 1843
static signed int PT_LookupCache__Old_u(struct _PT_Index *index_, const char *url);
// PT_LookupIndex
// file proxy/store.h line 89
signed int PT_LookupIndex(struct _PT_Indexes *indexes, const char *url);
// PT_New
// file proxy/store.h line 86
struct _PT_Indexes * PT_New(void);
// PT_ReadCache
// file proxy/store.c line 828
struct _PT_Element * PT_ReadCache(struct _PT_Index *index, const char *url, signed int flags);
// PT_ReadCache__Arc
// file proxy/store.c line 2097
static struct _PT_Element * PT_ReadCache__Arc(struct _PT_Index *index, const char *url, signed int flags);
// PT_ReadCache__Arc_u
// file proxy/store.c line 2108
static struct _PT_Element * PT_ReadCache__Arc_u(struct _PT_Index *index_, const char *url, signed int flags);
// PT_ReadCache__New
// file proxy/store.c line 835
static struct _PT_Element * PT_ReadCache__New(struct _PT_Index *index, const char *url, signed int flags);
// PT_ReadCache__New_u
// file proxy/store.c line 1000
static struct _PT_Element * PT_ReadCache__New_u(struct _PT_Index *index_, const char *url, signed int flags);
// PT_ReadCache__Old
// file proxy/store.c line 1584
static struct _PT_Element * PT_ReadCache__Old(struct _PT_Index *index, const char *url, signed int flags);
// PT_ReadCache__Old_u
// file proxy/store.c line 1595
static struct _PT_Element * PT_ReadCache__Old_u(struct _PT_Index *index_, const char *url, signed int flags);
// PT_ReadIndex
// file proxy/store.h line 88
struct _PT_Element * PT_ReadIndex(struct _PT_Indexes *indexes, const char *url, signed int flags);
// PT_RemoveIndex
// file proxy/store.c line 254
signed int PT_RemoveIndex(struct _PT_Indexes *index, signed int indexId);
// PT_SaveCache
// file proxy/store.h line 103
signed int PT_SaveCache(struct _PT_Indexes *indexes, const char *filename);
// PT_SaveCache__Arc
// file proxy/store.c line 2346
static signed int PT_SaveCache__Arc(struct _PT_Indexes *indexes, const char *filename);
// PT_SaveCache__Arc_Fun
// file proxy/store.c line 2285
static signed int PT_SaveCache__Arc_Fun(void *arg, const char *url, struct _PT_Element *element);
// PT_SaveCache__New
// file proxy/store.c line 1333
static signed int PT_SaveCache__New(struct _PT_Indexes *indexes, const char *filename);
// PT_SaveCache__New_Fun
// file proxy/store.c line 1239
static signed int PT_SaveCache__New_Fun(void *arg, const char *url, struct _PT_Element *element);
// SOCaddr_copyaddr_
// file ./htsnet.h line 185
static unsigned int SOCaddr_copyaddr_(struct SOCaddr * const server, const void *data, const unsigned long int data_size, const char *file, const signed int line);
// SOCaddr_inetntoa_
// file ./htsnet.h line 231
static void SOCaddr_inetntoa_(char *namebuf, unsigned long int namebuflen, struct SOCaddr * const ss, const char *file, const signed int line);
// SOCaddr_initany_
// file ./htsnet.h line 170
static unsigned int SOCaddr_initany_(struct SOCaddr * const addr, const char *file, const signed int line);
// SOCaddr_sinport_
// file ./htsnet.h line 106
static unsigned short int * SOCaddr_sinport_(struct SOCaddr * const addr, const char *file, const signed int line);
// SOCaddr_size_
// file ./htsnet.h line 125
static unsigned int SOCaddr_size_(const struct SOCaddr * const addr, const char *file, const signed int line);
// StringAcquire
// file ./htsstrings.h line 211
static char * StringAcquire(struct String *blk);
// StringAcquire_link1
// file ./htsstrings.h line 211
static char * StringAcquire_link1(struct String *blk_link1);
// StringAttach
// file ./htsstrings.h line 229
static void StringAttach(struct String *blk, char **str);
// Write_EndOfCentralDirectoryRecord
// file minizip/zip.c line 1817
static signed int Write_EndOfCentralDirectoryRecord(struct anonymous_9 *zi, unsigned long int size_centraldir, unsigned long long int centraldir_pos_inzip);
// Write_GlobalComment
// file minizip/zip.c line 1865
static signed int Write_GlobalComment(struct anonymous_9 *zi, const char *global_comment);
// Write_LocalFileHeader
// file minizip/zip.c line 958
static signed int Write_LocalFileHeader(struct anonymous_9 *zi, const char *filename, unsigned int size_extrafield_local, const void *extrafield_local);
// Write_Zip64EndOfCentralDirectoryLocator
// file minizip/zip.c line 1755
static signed int Write_Zip64EndOfCentralDirectoryLocator(struct anonymous_9 *zi, unsigned long long int zip64eocd_pos_inzip);
// Write_Zip64EndOfCentralDirectoryRecord
// file minizip/zip.c line 1777
static signed int Write_Zip64EndOfCentralDirectoryRecord(struct anonymous_9 *zi, unsigned long int size_centraldir, unsigned long long int centraldir_pos_inzip);
// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abortLog__fnc
// file proxy/proxytrack.c line 150
void abortLog__fnc(char *msg, char *file, signed int line);
// abortf_
// file ./htssafe.h line 95
static void abortf_(const char *exp, const char *file, signed int line);
// abortf__link1
// file ./htssafe.h line 95
static void abortf__link1(const char *exp_link1, const char *file_link1, signed int line_link1);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_data_in_datablock
// file minizip/zip.c line 225
static signed int add_data_in_datablock(struct linkedlist_data_s *ll, const void *buf, unsigned long int len);
// allocate_new_datablock
// file minizip/zip.c line 189
static struct linkedlist_datablock_internal_s * allocate_new_datablock(void);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// binput
// file proxy/store.c line 258
static signed int binput(char *buff, char *s, signed int max);
// byteReverse
// file md5.c line 33
static void byteReverse(unsigned char *buf, unsigned int longs);
// cache_brstr
// file proxy/store.c line 1354
static signed int cache_brstr(char *adr, char *s);
// cache_rLLint
// file proxy/store.c line 1413
static void cache_rLLint(struct _IO_FILE *fp, unsigned long int *i);
// cache_rint
// file proxy/store.c line 1406
static void cache_rint(struct _IO_FILE *fp, signed int *i);
// cache_rstr
// file proxy/store.c line 1369
static void cache_rstr(struct _IO_FILE *fp, char *s);
// cache_rstr_addr
// file proxy/store.c line 1385
static char * cache_rstr_addr(struct _IO_FILE *fp);
// call_zopen64
// file minizip/ioapi.c line 31
void * call_zopen64(const struct zlib_filefunc64_32_def_s *pfilefunc, const void *filename, signed int mode);
// call_zseek64
// file minizip/ioapi.c line 41
signed long int call_zseek64(const struct zlib_filefunc64_32_def_s *pfilefunc, void *filestream, unsigned long long int offset, signed int origin);
// call_ztell64
// file minizip/ioapi.c line 55
unsigned long long int call_ztell64(const struct zlib_filefunc64_32_def_s *pfilefunc, void *filestream);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_readinput_t
// file proxy/proxytrack.c line 204
static signed int check_readinput_t(signed int soc, signed int timeout);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// convert_time_rfc822
// file proxy/proxytrack.h line 271
static struct tm * convert_time_rfc822(struct tm *result, const char *s);
// copyArcField
// file proxy/store.c line 1877
static char * copyArcField(const char *line, signed int npos, char *dest, signed int destMax);
// coucal_add
// file ./coucal.h line 435
extern void coucal_add(struct struct_coucal *hashtable, const void *name, signed long int intvalue);
// coucal_add_item_
// file coucal.c line 883
static signed int coucal_add_item_(struct struct_coucal *hashtable, struct coucal_item item);
// coucal_add_pvoid
// file coucal.c line 775
extern void coucal_add_pvoid(struct struct_coucal *hashtable, const void *name, void *pvalue);
// coucal_assert_failed
// file coucal.c line 293
static void coucal_assert_failed(struct struct_coucal * const hashtable, const char *exp, const char *file, signed int line);
// coucal_calc_hashes
// file coucal.c line 480
inline struct coucal_hashkeys coucal_calc_hashes(struct struct_coucal *hashtable, const void *value);
// coucal_compact_pool
// file coucal.c line 519
static void coucal_compact_pool(struct struct_coucal *hashtable, unsigned long int capacity);
// coucal_created
// file coucal.c line 1412
extern signed int coucal_created(struct struct_coucal *hashtable);
// coucal_crit
// file coucal.c line 266
static void coucal_crit(struct struct_coucal * const hashtable, const char *format, ...);
// coucal_dec
// file coucal.c line 1246
extern signed int coucal_dec(struct struct_coucal *hashtable, const void *name);
// coucal_default_free_handler
// file coucal.c line 789
static void coucal_default_free_handler(void *arg, union coucal_value value);
// coucal_del_item
// file coucal.c line 817
static void coucal_del_item(struct struct_coucal *hashtable, struct coucal_item *pitem);
// coucal_del_name
// file coucal.c line 808
static void coucal_del_name(struct struct_coucal *hashtable, struct coucal_item *item);
// coucal_del_value
// file coucal.c line 804
static inline void coucal_del_value(struct struct_coucal *hashtable, unsigned long int pos);
// coucal_del_value_
// file coucal.c line 796
static inline void coucal_del_value_(struct struct_coucal *hashtable, union coucal_value *pvalue);
// coucal_delete
// file ./coucal.h line 272
extern void coucal_delete(struct struct_coucal **phashtable);
// coucal_dup_name
// file coucal.c line 695
static inline void * coucal_dup_name(struct struct_coucal *hashtable, const void *name);
// coucal_dup_name_internal
// file coucal.c line 661
static void * coucal_dup_name_internal(struct struct_coucal *hashtable, const void *name_);
// coucal_enum_new
// file ./coucal.h line 486
extern struct struct_coucal_enum coucal_enum_new(struct struct_coucal *hashtable);
// coucal_enum_next
// file ./coucal.h line 491
extern struct coucal_item * coucal_enum_next(struct struct_coucal_enum *e);
// coucal_equals
// file coucal.c line 493
static inline signed int coucal_equals(struct struct_coucal *hashtable, const void *a, const void *b);
// coucal_exists
// file ./coucal.h line 383
extern signed int coucal_exists(struct struct_coucal *hashtable, const void *name);
// coucal_fail
// file coucal.c line 287
static void coucal_fail(const char *exp, const char *file, signed int line);
// coucal_fetch_value
// file coucal.c line 1210
inline union coucal_value * coucal_fetch_value(struct struct_coucal *hashtable, const void *name);
// coucal_fetch_value_hashes
// file coucal.c line 1178
extern union coucal_value * coucal_fetch_value_hashes(struct struct_coucal *hashtable, const void *name, const struct coucal_hashkeys *hashes);
// coucal_free_key
// file coucal.c line 732
static void coucal_free_key(struct struct_coucal *hashtable, void *name);
// coucal_free_key_internal
// file coucal.c line 704
static void coucal_free_key_internal(struct struct_coucal *hashtable, void *name_);
// coucal_get_intptr
// file coucal.c line 1346
extern signed long int coucal_get_intptr(struct struct_coucal *hashtable, const void *name);
// coucal_get_name
// file coucal.c line 332
extern const char * coucal_get_name(struct struct_coucal *hashtable);
// coucal_get_pow2
// file coucal.c line 1354
static inline unsigned long int coucal_get_pow2(unsigned long int initial_size);
// coucal_get_pvoid
// file coucal.c line 760
extern void * coucal_get_pvoid(struct struct_coucal *hashtable, const void *name);
// coucal_hash_data
// file coucal.c line 379
extern struct coucal_hashkeys coucal_hash_data(const void *data_, unsigned long int size);
// coucal_hash_size
// file coucal.c line 1485
extern unsigned long int coucal_hash_size(void);
// coucal_hash_string
// file coucal.c line 476
inline struct coucal_hashkeys coucal_hash_string(const char *name);
// coucal_hash_to_pos
// file coucal.c line 746
static inline unsigned long int coucal_hash_to_pos(struct struct_coucal * const hashtable, unsigned int hash);
// coucal_hash_to_pos_
// file coucal.c line 740
static inline unsigned long int coucal_hash_to_pos_(unsigned long int lg_size, unsigned int hash);
// coucal_inc
// file coucal.c line 1242
extern signed int coucal_inc(struct struct_coucal *hashtable, const void *name);
// coucal_inc_
// file coucal.c line 1228
static unsigned long int coucal_inc_(struct struct_coucal *hashtable, const void *name, unsigned long int inc);
// coucal_info
// file coucal.c line 268
static void coucal_info(struct struct_coucal * const hashtable, const char *format, ...);
// coucal_is_acceptable_pow2
// file coucal.c line 1029
static inline signed int coucal_is_acceptable_pow2(unsigned long int lg_size);
// coucal_is_free
// file coucal.c line 488
static inline signed int coucal_is_free(struct struct_coucal * const hashtable, unsigned long int pos);
// coucal_log
// file coucal.c line 308
static void coucal_log(struct struct_coucal * const hashtable, enum coucal_loglevel level, const char *format, void **args);
// coucal_log_stats
// file coucal.c line 336
static void coucal_log_stats(struct struct_coucal *hashtable);
// coucal_matches
// file coucal.c line 511
static inline signed int coucal_matches(struct struct_coucal *hashtable, unsigned long int pos, const void *name, const struct coucal_hashkeys *hashes);
// coucal_matches_
// file coucal.c line 501
static inline signed int coucal_matches_(struct struct_coucal *hashtable, const struct coucal_item * const item, const void *name, const struct coucal_hashkeys *hashes);
// coucal_memory_size
// file coucal.c line 1478
extern unsigned long int coucal_memory_size(struct struct_coucal *hashtable);
// coucal_new
// file ./coucal.h line 261
extern struct struct_coucal * coucal_new(unsigned long int initial_size);
// coucal_nitems
// file coucal.c line 1472
extern unsigned long int coucal_nitems(struct struct_coucal *hashtable);
// coucal_nolog
// file coucal.c line 326
static inline void coucal_nolog(struct struct_coucal * const hashtable, const char *format, ...);
// coucal_print_key
// file coucal.c line 875
static const char * coucal_print_key(struct struct_coucal *hashtable, const void *name);
// coucal_read
// file ./coucal.h line 364
extern signed int coucal_read(struct struct_coucal *hashtable, const void *name, signed long int *intvalue);
// coucal_read_pvoid
// file coucal.c line 751
extern signed int coucal_read_pvoid(struct struct_coucal *hashtable, const void *name, void **pvalue);
// coucal_read_value
// file coucal.c line 1216
extern signed int coucal_read_value(struct struct_coucal *hashtable, const void *name, union coucal_value *pvalue);
// coucal_readptr
// file coucal.c line 1336
extern signed int coucal_readptr(struct struct_coucal *hashtable, const void *name, signed long int *value);
// coucal_realloc_pool
// file coucal.c line 602
static void coucal_realloc_pool(struct struct_coucal *hashtable, unsigned long int capacity);
// coucal_remove
// file coucal.c line 1297
extern signed int coucal_remove(struct struct_coucal *hashtable, const void *name);
// coucal_remove_
// file coucal.c line 1254
static signed int coucal_remove_(struct struct_coucal *hashtable, const void *name, const struct coucal_hashkeys *hashes, unsigned long int *removed);
// coucal_set_assert_handler
// file coucal.c line 1454
extern void coucal_set_assert_handler(struct struct_coucal *hashtable, void (*log)(void *, enum coucal_loglevel, const char *, void **), void (*fatal)(void *, const char *, const char *, signed int), void *arg);
// coucal_set_assert_handler::fatal_object
//
void fatal_object(void *, const char *, const char *, signed int);
// coucal_set_assert_handler::log_object
//
void log_object(void *, enum coucal_loglevel, const char *, void **);
// coucal_set_global_assert_handler
// file coucal.c line 1557
extern void coucal_set_global_assert_handler(void (*log)(void *, enum coucal_loglevel, const char *, void **), void (*fatal)(void *, const char *, const char *, signed int));
// coucal_set_global_assert_handler::fatal_object
//
void fatal_object(void *, const char *, const char *, signed int);
// coucal_set_global_assert_handler::log_object
//
void log_object(void *, enum coucal_loglevel, const char *, void **);
// coucal_set_name
// file ./coucal.h line 352
extern void coucal_set_name(struct struct_coucal *hashtable, const void *name);
// coucal_set_print_handler
// file coucal.c line 1463
extern void coucal_set_print_handler(struct struct_coucal *hashtable, const char * (*key)(void *, const void *), const char * (*value)(void *, const union coucal_value), void *arg);
// coucal_set_print_handler::key_object
//
const char * key_object(void *, const void *);
// coucal_set_print_handler::value_object
//
const char * value_object(void *, const union coucal_value);
// coucal_value_is_malloc
// file coucal.c line 1416
extern void coucal_value_is_malloc(struct struct_coucal *hashtable, signed int flag);
// coucal_value_set_key_handler
// file coucal.c line 1439
extern void coucal_value_set_key_handler(struct struct_coucal *hashtable, void * (*dup)(void *, const void *), void (*free)(void *, void *), struct coucal_hashkeys (*hash)(void *, const void *), signed int (*equals)(void *, const void *, const void *), void *arg);
// coucal_value_set_key_handler::dup_object
//
void * dup_object(void *, const void *);
// coucal_value_set_key_handler::equals_object
//
signed int equals_object(void *, const void *, const void *);
// coucal_value_set_key_handler::free_object
//
void free_object(void *, void *);
// coucal_value_set_key_handler::hash_object
//
struct coucal_hashkeys hash_object(void *, const void *);
// coucal_value_set_value_handler
// file coucal.c line 1432
extern void coucal_value_set_value_handler(struct struct_coucal *hashtable, void (*free)(void *, union coucal_value), void *arg);
// coucal_value_set_value_handler::free_object
//
void free_object(void *, union coucal_value);
// coucal_warning
// file coucal.c line 267
static void coucal_warning(struct struct_coucal * const hashtable, const char *format, ...);
// coucal_write
// file ./coucal.h line 429
extern signed int coucal_write(struct struct_coucal *hashtable, const void *name, signed long int intvalue);
// coucal_write_pvoid
// file coucal.c line 768
extern signed int coucal_write_pvoid(struct struct_coucal *hashtable, const void *name, void *pvalue);
// coucal_write_value
// file coucal.c line 1033
extern signed int coucal_write_value(struct struct_coucal *hashtable, const void *name, const union coucal_value value);
// coucal_write_value_
// file coucal.c line 825
static signed int coucal_write_value_(struct struct_coucal *hashtable, const void *name, union coucal_value value);
// crc32
// file /usr/include/zlib.h line 1600
extern unsigned long int crc32(unsigned long int, const unsigned char *, unsigned int);
// crypthead
// file minizip/crypt.h line 90
static signed int crypthead(const char *passwd, unsigned char *buf, signed int bufSize, unsigned long int *pkeys, const unsigned int *pcrc_32_tab, unsigned long int crcForCrypting);
// decrypt_byte
// file minizip/crypt.h line 35
static signed int decrypt_byte(unsigned long int *pkeys, const unsigned int *pcrc_32_tab);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit2_
// file /usr/include/zlib.h line 1637
extern signed int deflateInit2_(struct z_stream_s *, signed int, signed int, signed int, signed int, signed int, const char *, signed int);
// domd5mem
// file ./htsmd5.h line 43
signed int domd5mem(const char *buf, unsigned long int len, char *digest, signed int asAscii);
// escapexml
// file proxy/proxystrings.h line 71
static void escapexml(const char *s, struct String *tempo);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fclose_file_func
// file minizip/ioapi.c line 219
static signed int fclose_file_func(void *opaque, void *stream);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// ferror_file_func
// file minizip/ioapi.c line 226
static signed int ferror_file_func(void *opaque, void *stream);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fflush_file_func
// file minizip/ioapi.c line 212
static signed int fflush_file_func(void *opaque, void *stream);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// file_convert
// file proxy/proxystrings.h line 88
static char * file_convert(char *dest, unsigned long int size, const char *src);
// file_timestamp
// file proxy/store.c line 275
static signed long int file_timestamp(const char *file);
// filesize
// file proxy/store.c line 591
static signed long int filesize(const char *filename);
// fill_fopen64_filefunc
// file minizip/ioapi.c line 246
void fill_fopen64_filefunc(struct zlib_filefunc64_def_s *pzlib_filefunc_def);
// fill_fopen_filefunc
// file minizip/ioapi.c line 233
void fill_fopen_filefunc(struct zlib_filefunc_def_s *pzlib_filefunc_def);
// fill_zlib_filefunc64_32_def_from_filefunc32
// file minizip/ioapi.c line 69
void fill_zlib_filefunc64_32_def_from_filefunc32(struct zlib_filefunc64_32_def_s *p_filefunc64_32, const struct zlib_filefunc_def_s *p_filefunc32);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fopen64
// file /usr/include/stdio.h line 297
extern struct _IO_FILE * fopen64(const char *, const char *);
// fopen64_file_func
// file minizip/ioapi.c line 116
static void * fopen64_file_func(void *opaque, const void *filename, signed int mode);
// fopen_file_func
// file minizip/ioapi.c line 98
static void * fopen_file_func(void *opaque, const char *filename, signed int mode);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// fread_file_func
// file minizip/ioapi.c line 135
static unsigned long int fread_file_func(void *opaque, void *stream, void *buf, unsigned long int size);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_datablock
// file minizip/zip.c line 203
static void free_datablock(struct linkedlist_datablock_internal_s *ldi);
// free_linkedlist
// file minizip/zip.c line 218
static void free_linkedlist(struct linkedlist_data_s *ll);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// fseek64_file_func
// file minizip/ioapi.c line 187
static signed long int fseek64_file_func(void *opaque, void *stream, unsigned long long int offset, signed int origin);
// fseek_file_func
// file minizip/ioapi.c line 164
static signed long int fseek_file_func(void *opaque, void *stream, unsigned long int offset, signed int origin);
// fseeko64
// file /usr/include/stdio.h line 818
extern signed int fseeko64(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// ftell64_file_func
// file minizip/ioapi.c line 157
static unsigned long long int ftell64_file_func(void *opaque, void *stream);
// ftell_file_func
// file minizip/ioapi.c line 149
static signed long int ftell_file_func(void *opaque, void *stream);
// ftello64
// file /usr/include/stdio.h line 819
extern signed long int ftello64(struct _IO_FILE *);
// ftime
// file /usr/include/x86_64-linux-gnu/sys/timeb.h line 41
extern signed int ftime(struct timeb *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// fwrite_file_func
// file minizip/ioapi.c line 142
static unsigned long int fwrite_file_func(void *opaque, void *stream, const void *buf, unsigned long int size);
// getArcField
// file proxy/store.c line 1865
static const char * getArcField(const char *line, signed int pos);
// getArcLength
// file proxy/store.c line 1893
static signed int getArcLength(const char *line);
// getArcTimestamp
// file proxy/store.c line 1953
static signed long int getArcTimestamp(const char * const line);
// getDigit
// file proxy/store.c line 1926
static signed int getDigit(const char digit);
// getDigit2
// file proxy/store.c line 1930
static signed int getDigit2(const char * const pos);
// getDigit4
// file proxy/store.c line 1934
static signed int getDigit4(const char * const pos);
// getGMT
// file proxy/store.c line 1939
static signed long int getGMT(struct tm *tm);
// get_crc_table
// file /usr/include/zlib.h line 1748
extern const unsigned int * get_crc_table(void);
// get_time_rfc822
// file proxy/proxytrack.c line 581
static signed long int get_time_rfc822(const char *s);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// gethost
// file proxy/proxytrack.c line 229
static signed int gethost(const char *hostname, struct SOCaddr *server);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getip
// file proxy/proxytrack.c line 278
static struct String getip(struct SOCaddr *server);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);

//


//

// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// init_keys
// file minizip/crypt.h line 65
static void init_keys(const char *passwd, unsigned long int *pkeys, const unsigned int *pcrc_32_tab);
// init_linkedlist
// file minizip/zip.c line 213
static void init_linkedlist(struct linkedlist_data_s *ll);
// jump_protocol
// file proxy/proxytrack.h line 165
static const char * jump_protocol(const char *source);
// jump_protocol_link1
// file proxy/proxytrack.h line 165
static const char * jump_protocol_link1(const char *source_link1);
// jump_protocol_and_auth
// file proxy/proxytrack.h line 201
static const char * jump_protocol_and_auth(const char *source);
// jump_protocol_and_auth_link1
// file proxy/proxytrack.h line 201
static const char * jump_protocol_and_auth_link1(const char *source_link1);
// link_has_authority
// file proxy/proxytrack.h line 148
static signed int link_has_authority(const char *lien);
// link_has_authority_link1
// file proxy/proxytrack.h line 148
static signed int link_has_authority_link1(const char *lien_link1);
// linput
// file proxy/proxytrack.h line 121
static signed int linput(struct _IO_FILE *fp, char *s, signed int max);
// linput_link1
// file proxy/proxytrack.h line 121
static signed int linput_link1(struct _IO_FILE *fp_link1, char *s_link1, signed int max_link1);
// linputsoc
// file proxy/proxytrack.c line 172
static signed int linputsoc(signed int soc, char *s, signed int max);
// linputsoc_t
// file proxy/proxytrack.c line 222
static signed int linputsoc_t(signed int soc, char *s, signed int max, signed int timeout);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// log_abort_
// file ./htssafe.h line 90
static void log_abort_(const char *msg, const char *file, signed int line);
// log_abort__link1
// file ./htssafe.h line 90
static void log_abort__link1(const char *msg_link1, const char *file_link1, signed int line_link1);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// md5selftest
// file htsmd5.c line 83
void md5selftest(void);
// md5sum32
// file htsmd5.c line 73
unsigned long int md5sum32(const char *buff);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mktime
// file /usr/include/time.h line 199
extern signed long int mktime(struct tm *);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// proxytrack_add_DAV_Item
// file proxy/proxytrack.c line 523
static void proxytrack_add_DAV_Item(struct String *item, struct String *buff, const char *filename, unsigned long int size, signed long int timestamp, const char *mime, signed int isDir, signed int isRoot, signed int isDefault);
// proxytrack_main
// file proxy/proxytrack.h line 55
signed int proxytrack_main(char *proxyAddr, signed int proxyPort, char *icpAddr, signed int icpPort, struct _PT_Indexes *index);
// proxytrack_print_log
// file proxy/proxytrack.h line 67
static void proxytrack_print_log(const char *severity, const char *format, ...);
// proxytrack_print_log_link1
// file proxy/proxytrack.h line 67
static void proxytrack_print_log_link1(const char *severity_link1, const char *format_link1, ...);
// proxytrack_process_DAV_Request
// file proxy/proxytrack.c line 683
static struct _PT_Element * proxytrack_process_DAV_Request(struct _PT_Indexes *indexes, const char *urlFull, signed int depth);
// proxytrack_process_HTTP
// file proxy/proxytrack.c line 893
static void proxytrack_process_HTTP(struct _PT_Indexes *indexes, signed int soc_c);
// proxytrack_process_HTTP_List
// file proxy/proxytrack.c line 840
static struct _PT_Element * proxytrack_process_HTTP_List(struct _PT_Indexes *indexes, const char *url);
// proxytrack_process_HTTP_threaded
// file proxy/proxytrack.c line 1479
static signed int proxytrack_process_HTTP_threaded(struct _PT_Indexes *indexes, signed int soc);
// proxytrack_process_generic
// file proxy/proxytrack.c line 1461
static signed int proxytrack_process_generic(void (*process)(struct _PT_Indexes *, signed int), struct _PT_Indexes *indexes, signed int soc_c);
// proxytrack_process_generic::process_object
//
void process_object(struct _PT_Indexes *, signed int);
// proxytrack_process_th
// file proxy/proxytrack.c line 1448
static void * proxytrack_process_th(void *param_);
// proxytrack_process_th::1::process_object
//
void process_object(struct _PT_Indexes *, signed int);
// proxytrack_start
// file proxy/proxytrack.c line 1716
static signed int proxytrack_start(struct _PT_Indexes *indexes, signed int soc, signed int socICP);
// proxytrack_start_HTTP
// file proxy/proxytrack.c line 1484
static signed int proxytrack_start_HTTP(struct _PT_Indexes *indexes, signed int soc);
// proxytrack_start_ICP
// file proxy/proxytrack.c line 1555
static signed int proxytrack_start_ICP(struct _PT_Indexes *indexes, signed int soc);
// proxytrack_start_ICP_th
// file proxy/proxytrack.c line 1712
static void proxytrack_start_ICP_th(struct _PT_Indexes *indexes, signed int soc);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_1 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_1 *, const union anonymous_11 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_1 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_1 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// readArcURLRecord
// file proxy/store.c line 1979
static signed int readArcURLRecord(struct _PT_Index__Arc *index);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int,  struct sockaddr *, unsigned int *);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// scanHostPort
// file proxy/main.c line 48
static signed int scanHostPort(const char *str, char *host, signed int *port);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_12 *, struct anonymous_12 *, struct anonymous_12 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// set_filetime
// file proxy/proxytrack.h line 378
static signed int set_filetime(const char *file, struct tm *tm_time);
// set_filetime_time_t
// file proxy/proxytrack.h line 394
static signed int set_filetime_time_t(const char *file, signed long int t);
// set_lowcase
// file proxy/proxytrack.h line 264
static void set_lowcase(char *s);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sig_brpipe
// file proxy/main.c line 43
static void sig_brpipe(signed int code);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// skipArcData
// file proxy/store.c line 1915
static signed int skipArcData(struct _IO_FILE *file, const char *line);
// skipArcNl
// file proxy/store.c line 1908
static signed int skipArcNl(struct _IO_FILE *file);
// smallserver_init
// file proxy/proxytrack.c line 299
static signed int smallserver_init(const char *adr, signed int port, signed int family);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// startThread
// file proxy/proxytrack.c line 1413
static signed int startThread(void * (*funct)(void *), void *param);
// startThread::funct_object
//
void * funct_object(void *);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strchr_stop
// file proxy/store.c line 417
static char * strchr_stop(char *str, char c, char stop);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcmpcasenosensitive_internal
// file minizip/unzip.c line 349
static signed int strcmpcasenosensitive_internal(const char *fileName1, const char *fileName2);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strfield
// file ./htslib.h line 431
static signed int strfield(const char *f, const char *s);
// strfield_link1
// file ./htslib.h line 431
static signed int strfield_link1(const char *f_link1, const char *s_link1);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strrchr_limit
// file proxy/proxytrack.h line 184
static const char * strrchr_limit(const char *s, char c, const char *limit);
// strrchr_limit_link1
// file proxy/proxytrack.h line 184
static const char * strrchr_limit_link1(const char *s_link1, char c_link1, const char *limit_link1);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unz64local_CheckCurrentFileCoherencyHeader
// file minizip/unzip.c line 1385
static signed int unz64local_CheckCurrentFileCoherencyHeader(struct anonymous_0 *s, unsigned int *piSizeVar, unsigned long long int *poffset_local_extrafield, unsigned int *psize_local_extrafield);
// unz64local_DosDateToTmuDate
// file minizip/unzip.c line 852
static void unz64local_DosDateToTmuDate(unsigned long long int ulDosDate, struct tm_unz_s *ptm);
// unz64local_GetCurrentFileInfoInternal
// file minizip/unzip.c line 879
static signed int unz64local_GetCurrentFileInfoInternal(void *file, struct unz_file_info64_s *pfile_info, struct unz_file_info64_internal_s *pfile_info_internal, char *szFileName, unsigned long int fileNameBufferSize, void *extraField, unsigned long int extraFieldBufferSize, char *szComment, unsigned long int commentBufferSize);
// unz64local_SearchCentralDir
// file minizip/unzip.c line 413
static unsigned long long int unz64local_SearchCentralDir(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream);
// unz64local_SearchCentralDir64
// file minizip/unzip.c line 478
static unsigned long long int unz64local_SearchCentralDir64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream);
// unz64local_getByte
// file minizip/unzip.c line 212
static signed int unz64local_getByte(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, signed int *pi);
// unz64local_getLong
// file minizip/unzip.c line 266
static signed int unz64local_getLong(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX);
// unz64local_getLong64
// file minizip/unzip.c line 302
static signed int unz64local_getLong64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long long int *pX);
// unz64local_getShort
// file minizip/unzip.c line 239
static signed int unz64local_getShort(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX);
// unzClose
// file proxy/../minizip/unzip.h line 198
extern signed int unzClose(void *file);
// unzCloseCurrentFile
// file proxy/../minizip/unzip.h line 373
extern signed int unzCloseCurrentFile(void *file);
// unzGetCurrentFileInfo
// file proxy/../minizip/unzip.h line 297
extern signed int unzGetCurrentFileInfo(void *file, struct unz_file_info_s *pfile_info, char *szFileName, unsigned long int fileNameBufferSize, void *extraField, unsigned long int extraFieldBufferSize, char *szComment, unsigned long int commentBufferSize);
// unzGetCurrentFileInfo64
// file minizip/unzip.c line 1124
extern signed int unzGetCurrentFileInfo64(void *file, struct unz_file_info64_s *pfile_info, char *szFileName, unsigned long int fileNameBufferSize, void *extraField, unsigned long int extraFieldBufferSize, char *szComment, unsigned long int commentBufferSize);
// unzGetCurrentFileZStreamPos64
// file minizip/unzip.c line 1658
extern unsigned long long int unzGetCurrentFileZStreamPos64(void *file);
// unzGetFilePos
// file minizip/unzip.c line 1324
extern signed int unzGetFilePos(void *file, struct unz_file_pos_s *file_pos);
// unzGetFilePos64
// file minizip/unzip.c line 1308
extern signed int unzGetFilePos64(void *file, struct unz64_file_pos_s *file_pos);
// unzGetGlobalComment
// file minizip/unzip.c line 2051
extern signed int unzGetGlobalComment(void *file, char *szComment, unsigned long int uSizeBuf);
// unzGetGlobalInfo
// file minizip/unzip.c line 838
extern signed int unzGetGlobalInfo(void *file, struct unz_global_info_s *pglobal_info32);
// unzGetGlobalInfo64
// file minizip/unzip.c line 828
extern signed int unzGetGlobalInfo64(void *file, struct unz_global_info64_s *pglobal_info);
// unzGetLocalExtrafield
// file proxy/../minizip/unzip.h line 405
extern signed int unzGetLocalExtrafield(void *file, void *buf, unsigned int len);
// unzGetOffset
// file proxy/../minizip/unzip.h line 425
extern unsigned long int unzGetOffset(void *file);
// unzGetOffset64
// file minizip/unzip.c line 2079
extern unsigned long long int unzGetOffset64(void *file);
// unzGoToFilePos
// file minizip/unzip.c line 1360
extern signed int unzGoToFilePos(void *file, struct unz_file_pos_s *file_pos);
// unzGoToFilePos64
// file minizip/unzip.c line 1338
extern signed int unzGoToFilePos64(void *file, const struct unz64_file_pos_s *file_pos);
// unzGoToFirstFile
// file proxy/../minizip/unzip.h line 229
extern signed int unzGoToFirstFile(void *file);
// unzGoToNextFile
// file proxy/../minizip/unzip.h line 235
extern signed int unzGoToNextFile(void *file);
// unzLocateFile
// file minizip/unzip.c line 1232
extern signed int unzLocateFile(void *file, const char *szFileName, signed int iCaseSensitivity);
// unzOpen
// file proxy/../minizip/unzip.h line 166
extern void * unzOpen(const char *path);
// unzOpen2
// file minizip/unzip.c line 765
extern void * unzOpen2(const char *path, struct zlib_filefunc_def_s *pzlib_filefunc32_def);
// unzOpen2_64
// file minizip/unzip.c line 778
extern void * unzOpen2_64(const void *path, struct zlib_filefunc64_def_s *pzlib_filefunc_def);
// unzOpen64
// file minizip/unzip.c line 798
extern void * unzOpen64(const void *path);
// unzOpenCurrentFile
// file proxy/../minizip/unzip.h line 331
extern signed int unzOpenCurrentFile(void *file);
// unzOpenCurrentFile2
// file minizip/unzip.c line 1651
extern signed int unzOpenCurrentFile2(void *file, signed int *method, signed int *level, signed int raw);
// unzOpenCurrentFile3
// file minizip/unzip.c line 1472
extern signed int unzOpenCurrentFile3(void *file, signed int *method, signed int *level, signed int raw, const char *password);
// unzOpenCurrentFilePassword
// file minizip/unzip.c line 1646
extern signed int unzOpenCurrentFilePassword(void *file, const char *password);
// unzOpenInternal
// file minizip/unzip.c line 584
static void * unzOpenInternal(const void *path, struct zlib_filefunc64_32_def_s *pzlib_filefunc64_32_def, signed int is64bitOpenFunction);
// unzReadCurrentFile
// file proxy/../minizip/unzip.h line 379
extern signed int unzReadCurrentFile(void *file, void *buf, unsigned int len);
// unzRepair
// file minizip/mztools.c line 31
extern signed int unzRepair(const char *file, const char *fileOut, const char *fileOutTmp, unsigned long int *nRecovered, unsigned long int *bytesRecovered);
// unzSetOffset
// file proxy/../minizip/unzip.h line 429
extern signed int unzSetOffset(void *file, unsigned long int pos);
// unzSetOffset64
// file minizip/unzip.c line 2104
extern signed int unzSetOffset64(void *file, unsigned long long int pos);
// unzStringFileNameCompare
// file minizip/unzip.c line 390
extern signed int unzStringFileNameCompare(const char *fileName1, const char *fileName2, signed int iCaseSensitivity);
// unzeof
// file minizip/unzip.c line 1924
extern signed int unzeof(void *file);
// unztell
// file minizip/unzip.c line 1889
extern signed long int unztell(void *file);
// unztell64
// file minizip/unzip.c line 1904
extern unsigned long long int unztell64(void *file);
// update_keys
// file minizip/crypt.h line 48
static signed int update_keys(unsigned long int *pkeys, const unsigned int *pcrc_32_tab, signed int c);
// utime
// file /usr/include/utime.h line 45
extern signed int utime(const char *, struct utimbuf *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// zip64FlushWriteBuffer
// file minizip/zip.c line 1363
static signed int zip64FlushWriteBuffer(struct anonymous_9 *zi);
// zip64local_SearchCentralDir
// file minizip/zip.c line 480
static unsigned long long int zip64local_SearchCentralDir(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream);
// zip64local_SearchCentralDir64
// file minizip/zip.c line 542
static unsigned long long int zip64local_SearchCentralDir64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream);
// zip64local_TmzDateToDosDate
// file minizip/zip.c line 332
static unsigned long int zip64local_TmzDateToDosDate(const struct tm_zip_s *ptm);
// zip64local_getByte
// file minizip/zip.c line 349
static signed int zip64local_getByte(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, signed int *pi);
// zip64local_getLong
// file minizip/zip.c line 395
static signed int zip64local_getLong(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX);
// zip64local_getLong64
// file minizip/zip.c line 426
static signed int zip64local_getLong64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long long int *pX);
// zip64local_getShort
// file minizip/zip.c line 373
static signed int zip64local_getShort(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX);
// zip64local_putValue
// file minizip/zip.c line 287
static signed int zip64local_putValue(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long long int x, signed int nbByte);
// zip64local_putValue_inmemory
// file minizip/zip.c line 311
static void zip64local_putValue_inmemory(void *dest, unsigned long long int x, signed int nbByte);
// zipClose
// file proxy/../minizip/zip.h line 343
extern signed int zipClose(void *file, const char *global_comment);
// zipCloseFileInZip
// file proxy/../minizip/zip.h line 324
extern signed int zipCloseFileInZip(void *file);
// zipCloseFileInZipRaw
// file minizip/zip.c line 1509
extern signed int zipCloseFileInZipRaw(void *file, unsigned long int uncompressed_size, unsigned long int crc32);
// zipCloseFileInZipRaw64
// file minizip/zip.c line 1514
extern signed int zipCloseFileInZipRaw64(void *file, unsigned long long int uncompressed_size, unsigned long int crc32);
// zipFlush
// file proxy/../minizip/zip.h line 319
extern signed int zipFlush(void *file);
// zipOpen
// file proxy/../minizip/zip.h line 116
extern void * zipOpen(const char *pathname, signed int append);
// zipOpen2
// file minizip/zip.c line 920
extern void * zipOpen2(const char *pathname, signed int append, const char **globalcomment, struct zlib_filefunc_def_s *pzlib_filefunc32_def);
// zipOpen2_64
// file minizip/zip.c line 932
extern void * zipOpen2_64(const void *pathname, signed int append, const char **globalcomment, struct zlib_filefunc64_def_s *pzlib_filefunc_def);
// zipOpen3
// file minizip/zip.c line 849
extern void * zipOpen3(const void *pathname, signed int append, const char **globalcomment, struct zlib_filefunc64_32_def_s *pzlib_filefunc64_32_def);
// zipOpen64
// file minizip/zip.c line 953
extern void * zipOpen64(const void *pathname, signed int append);
// zipOpenNewFileInZip
// file proxy/../minizip/zip.h line 152
extern signed int zipOpenNewFileInZip(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level);
// zipOpenNewFileInZip2
// file minizip/zip.c line 1311
extern signed int zipOpenNewFileInZip2(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw);
// zipOpenNewFileInZip2_64
// file minizip/zip.c line 1324
extern signed int zipOpenNewFileInZip2_64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int zip64);
// zipOpenNewFileInZip3
// file minizip/zip.c line 1281
extern signed int zipOpenNewFileInZip3(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting);
// zipOpenNewFileInZip3_64
// file minizip/zip.c line 1296
extern signed int zipOpenNewFileInZip3_64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting, signed int zip64);
// zipOpenNewFileInZip4
// file minizip/zip.c line 1265
extern signed int zipOpenNewFileInZip4(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting, unsigned long int versionMadeBy, unsigned long int flagBase);
// zipOpenNewFileInZip4_64
// file minizip/zip.c line 1055
extern signed int zipOpenNewFileInZip4_64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting, unsigned long int versionMadeBy, unsigned long int flagBase, signed int zip64);
// zipOpenNewFileInZip64
// file minizip/zip.c line 1337
extern signed int zipOpenNewFileInZip64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int zip64);
// zipRemoveExtraInfoBlock
// file minizip/zip.c line 1964
extern signed int zipRemoveExtraInfoBlock(char *pData, signed int *dataLen, signed short int sHeader);
// zipWriteInFileInZip
// file proxy/../minizip/zip.h line 312
extern signed int zipWriteInFileInZip(void *file, const void *buf, unsigned int len);

struct anonymous_17
{
  // dup
  void * (*dup)(void *, const void *);
  // free
  void (*free)(void *, void *);
  // hash
  struct coucal_hashkeys (*hash)(void *, const void *);
  // equals
  signed int (*equals)(void *, const void *, const void *);
  // arg
  void *arg;
};

struct anonymous_19
{
  // key
  const char * (*key)(void *, const void *);
  // value
  const char * (*value)(void *, const union coucal_value);
  // arg
  void *arg;
};

struct anonymous_5
{
  // buffer
  char *buffer;
  // size
  unsigned long int size;
  // capacity
  unsigned long int capacity;
  // used
  unsigned long int used;
};

struct z_stream_s
{
  // next_in
  const unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  const char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};

struct zlib_filefunc64_def_s
{
  // zopen64_file
  void * (*zopen64_file)(void *, const void *, signed int);
  // zread_file
  unsigned long int (*zread_file)(void *, void *, void *, unsigned long int);
  // zwrite_file
  unsigned long int (*zwrite_file)(void *, void *, const void *, unsigned long int);
  // zflush_file
  signed int (*zflush_file)(void *, void *);
  // ztell64_file
  unsigned long long int (*ztell64_file)(void *, void *);
  // zseek64_file
  signed long int (*zseek64_file)(void *, void *, unsigned long long int, signed int);
  // zclose_file
  signed int (*zclose_file)(void *, void *);
  // zerror_file
  signed int (*zerror_file)(void *, void *);
  // opaque
  void *opaque;
};

struct zlib_filefunc64_32_def_s
{
  // zfile_func64
  struct zlib_filefunc64_def_s zfile_func64;
  // zopen32_file
  void * (*zopen32_file)(void *, const char *, signed int);
  // ztell32_file
  signed long int (*ztell32_file)(void *, void *);
  // zseek32_file
  signed long int (*zseek32_file)(void *, void *, unsigned long int, signed int);
};

struct anonymous
{
  // read_buffer
  char *read_buffer;
  // stream
  struct z_stream_s stream;
  // pos_in_zipfile
  unsigned long long int pos_in_zipfile;
  // stream_initialised
  unsigned long int stream_initialised;
  // offset_local_extrafield
  unsigned long long int offset_local_extrafield;
  // size_local_extrafield
  unsigned int size_local_extrafield;
  // pos_local_extrafield
  unsigned long long int pos_local_extrafield;
  // total_out_64
  unsigned long long int total_out_64;
  // crc32
  unsigned long int crc32;
  // crc32_wait
  unsigned long int crc32_wait;
  // rest_read_compressed
  unsigned long long int rest_read_compressed;
  // rest_read_uncompressed
  unsigned long long int rest_read_uncompressed;
  // z_filefunc
  struct zlib_filefunc64_32_def_s z_filefunc;
  // filestream
  void *filestream;
  // compression_method
  unsigned long int compression_method;
  // byte_before_the_zipfile
  unsigned long long int byte_before_the_zipfile;
  // raw
  signed int raw;
};

struct anonymous_18
{
  // log
  void (*log)(void *, enum coucal_loglevel, const char *, void **);
  // fatal
  void (*fatal)(void *, const char *, const char *, signed int);
  // arg
  void *arg;
  // name
  const void *name;
};

struct anonymous_16
{
  // free
  void (*free)(void *, union coucal_value);
  // arg
  void *arg;
};

struct anonymous_12
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

union coucal_value
{
  // intg
  signed long int intg;
  // uintg
  unsigned long int uintg;
  // ptr
  void *ptr;
};

struct coucal_hashkeys
{
  // hash1
  unsigned int hash1;
  // hash2
  unsigned int hash2;
};

struct coucal_item
{
  // name
  void *name;
  // value
  union coucal_value value;
  // hashes
  struct coucal_hashkeys hashes;
};

struct anonymous_4
{
  // items
  struct coucal_item items[16l];
  // size
  unsigned long int size;
};

struct anonymous_2
{
  // timestamp
  signed long int timestamp;
  // hash
  struct struct_coucal *hash;
  // startUrl
  char startUrl[1024l];
};

struct anonymous_7
{
  // value
  struct anonymous_16 value;
  // key
  struct anonymous_17 key;
  // error
  struct anonymous_18 error;
  // print
  struct anonymous_19 print;
};

struct tm_zip_s
{
  // tm_sec
  unsigned int tm_sec;
  // tm_min
  unsigned int tm_min;
  // tm_hour
  unsigned int tm_hour;
  // tm_mday
  unsigned int tm_mday;
  // tm_mon
  unsigned int tm_mon;
  // tm_year
  unsigned int tm_year;
};

struct anonymous_10
{
  // tmz_date
  struct tm_zip_s tmz_date;
  // dosDate
  unsigned long int dosDate;
  // internal_fa
  unsigned long int internal_fa;
  // external_fa
  unsigned long int external_fa;
};

struct anonymous_8
{
  // stream
  struct z_stream_s stream;
  // stream_initialised
  signed int stream_initialised;
  // pos_in_buffered_data
  unsigned int pos_in_buffered_data;
  // pos_local_header
  unsigned long long int pos_local_header;
  // central_header
  char *central_header;
  // size_centralExtra
  unsigned long int size_centralExtra;
  // size_centralheader
  unsigned long int size_centralheader;
  // size_centralExtraFree
  unsigned long int size_centralExtraFree;
  // flag
  unsigned long int flag;
  // method
  signed int method;
  // raw
  signed int raw;
  // buffered_data
  unsigned char buffered_data[65536l];
  // dosDate
  unsigned long int dosDate;
  // crc32
  unsigned long int crc32;
  // encrypt
  signed int encrypt;
  // zip64
  signed int zip64;
  // pos_zip64extrainfo
  unsigned long long int pos_zip64extrainfo;
  // totalCompressedData
  unsigned long long int totalCompressedData;
  // totalUncompressedData
  unsigned long long int totalUncompressedData;
  // keys
  unsigned long int keys[3l];
  // pcrc_32_tab
  const unsigned int *pcrc_32_tab;
  // crypt_header_size
  signed int crypt_header_size;
};

struct linkedlist_data_s
{
  // first_block
  struct linkedlist_datablock_internal_s *first_block;
  // last_block
  struct linkedlist_datablock_internal_s *last_block;
};

struct anonymous_9
{
  // z_filefunc
  struct zlib_filefunc64_32_def_s z_filefunc;
  // filestream
  void *filestream;
  // central_dir
  struct linkedlist_data_s central_dir;
  // in_opened_file_inzip
  signed int in_opened_file_inzip;
  // ci
  struct anonymous_8 ci;
  // begin_pos
  unsigned long long int begin_pos;
  // add_position_when_writting_offset
  unsigned long long int add_position_when_writting_offset;
  // number_entry
  unsigned long long int number_entry;
  // globalcomment
  char *globalcomment;
};

struct unz_global_info64_s
{
  // number_entry
  unsigned long long int number_entry;
  // size_comment
  unsigned long int size_comment;
};

struct tm_unz_s
{
  // tm_sec
  unsigned int tm_sec;
  // tm_min
  unsigned int tm_min;
  // tm_hour
  unsigned int tm_hour;
  // tm_mday
  unsigned int tm_mday;
  // tm_mon
  unsigned int tm_mon;
  // tm_year
  unsigned int tm_year;
};

struct unz_file_info64_s
{
  // version
  unsigned long int version;
  // version_needed
  unsigned long int version_needed;
  // flag
  unsigned long int flag;
  // compression_method
  unsigned long int compression_method;
  // dosDate
  unsigned long int dosDate;
  // crc
  unsigned long int crc;
  // compressed_size
  unsigned long long int compressed_size;
  // uncompressed_size
  unsigned long long int uncompressed_size;
  // size_filename
  unsigned long int size_filename;
  // size_file_extra
  unsigned long int size_file_extra;
  // size_file_comment
  unsigned long int size_file_comment;
  // disk_num_start
  unsigned long int disk_num_start;
  // internal_fa
  unsigned long int internal_fa;
  // external_fa
  unsigned long int external_fa;
  // tmu_date
  struct tm_unz_s tmu_date;
};

struct unz_file_info64_internal_s
{
  // offset_curfile
  unsigned long long int offset_curfile;
};

struct anonymous_0
{
  // z_filefunc
  struct zlib_filefunc64_32_def_s z_filefunc;
  // is64bitOpenFunction
  signed int is64bitOpenFunction;
  // filestream
  void *filestream;
  // gi
  struct unz_global_info64_s gi;
  // byte_before_the_zipfile
  unsigned long long int byte_before_the_zipfile;
  // num_file
  unsigned long long int num_file;
  // pos_in_central_dir
  unsigned long long int pos_in_central_dir;
  // current_file_ok
  unsigned long long int current_file_ok;
  // central_pos
  unsigned long long int central_pos;
  // size_central_dir
  unsigned long long int size_central_dir;
  // offset_central_dir
  unsigned long long int offset_central_dir;
  // cur_file_info
  struct unz_file_info64_s cur_file_info;
  // cur_file_info_internal
  struct unz_file_info64_internal_s cur_file_info_internal;
  // pfile_in_zip_read
  struct anonymous *pfile_in_zip_read;
  // encrypted
  signed int encrypted;
  // isZip64
  signed int isZip64;
};

struct anonymous_6
{
  // max_stash_size
  unsigned long int max_stash_size;
  // write_count
  unsigned long int write_count;
  // add_count
  unsigned long int add_count;
  // cuckoo_moved
  unsigned long int cuckoo_moved;
  // stash_added
  unsigned long int stash_added;
  // rehash_count
  unsigned long int rehash_count;
  // pool_compact_count
  unsigned long int pool_compact_count;
  // pool_realloc_count
  unsigned long int pool_realloc_count;
};

union anonymous_13
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_11
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_15
{
  // ui8
  unsigned char ui8[64l];
  // ui32
  unsigned int ui32[16l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_1
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _PT_Index__New
{
  // timestamp
  signed long int timestamp;
  // hash
  struct struct_coucal *hash;
  // startUrl
  char startUrl[1024l];
  // path
  char path[1024l];
  // fixedPath
  signed int fixedPath;
  // safeCache
  signed int safeCache;
  // zFile
  void *zFile;
  // zFileLock
  union anonymous_1 zFileLock;
};

struct _PT_Index__Old
{
  // timestamp
  signed long int timestamp;
  // hash
  struct struct_coucal *hash;
  // startUrl
  char startUrl[1024l];
  // filenameDat
  char filenameDat[1024l];
  // filenameNdx
  char filenameNdx[1024l];
  // dat
  struct _IO_FILE *dat;
  // ndx
  struct _IO_FILE *ndx;
  // fileLock
  union anonymous_1 fileLock;
  // version
  signed int version;
  // lastmodified
  char lastmodified[1024l];
  // path
  char path[1024l];
  // fixedPath
  signed int fixedPath;
  // safeCache
  signed int safeCache;
};

struct _PT_Index__Arc
{
  // timestamp
  signed long int timestamp;
  // hash
  struct struct_coucal *hash;
  // startUrl
  char startUrl[1024l];
  // file
  struct _IO_FILE *file;
  // fileLock
  union anonymous_1 fileLock;
  // version
  signed int version;
  // lastmodified
  char lastmodified[1024l];
  // line
  char line[2048l];
  // filenameIndexBuff
  char filenameIndexBuff[2048l];
};

union anonymous_3
{
  // formatNew
  struct _PT_Index__New formatNew;
  // formatOld
  struct _PT_Index__Old formatOld;
  // formatArc
  struct _PT_Index__Arc formatArc;
  // common
  struct anonymous_2 common;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_13 __in6_u;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

union anonymous_14
{
  // sa
  struct sockaddr sa;
  // in
  struct sockaddr_in in;
  // in6
  struct sockaddr_in6 in6;
};

struct MD5Context
{
  // in
  union anonymous_15 in;
  // buf
  unsigned int buf[4l];
  // bits
  unsigned int bits[2l];
  // doByteReverse
  signed int doByteReverse;
};

struct OLD_t_proxy
{
  // active
  signed int active;
  // name
  char name[1024l];
  // port
  signed int port;
};

struct OLD_htsblk
{
  // statuscode
  signed int statuscode;
  // notmodified
  signed int notmodified;
  // is_write
  signed int is_write;
  // adr
  char *adr;
  // out
  struct _IO_FILE *out;
  // size
  signed int size;
  // msg
  char msg[80l];
  // contenttype
  char contenttype[64l];
  // location
  char *location;
  // totalsize
  signed int totalsize;
  // is_file
  signed int is_file;
  // soc
  signed int soc;
  // fp
  struct _IO_FILE *fp;
  // proxy
  struct OLD_t_proxy proxy;
  // user_agent_send
  signed int user_agent_send;
  // user_agent
  char user_agent[64l];
  // http11
  signed int http11;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct PT_SaveCache__Arc_t
{
  // indexes
  struct _PT_Indexes *indexes;
  // fp
  struct _IO_FILE *fp;
  // t
  signed long int t;
  // filename
  char filename[64l];
  // buff
  struct tm buff;
  // headers
  char headers[8192l];
  // md5
  char md5[34l];
};

struct SOCaddr
{
  // m_addr
  union anonymous_14 m_addr;
};

struct String
{
  // buffer_
  char *buffer_;
  // length_
  unsigned long int length_;
  // capacity_
  unsigned long int capacity_;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _PT_Element
{
  // indexId
  signed int indexId;
  // statuscode
  signed int statuscode;
  // adr
  char *adr;
  // headers
  char *headers;
  // size
  unsigned long int size;
  // msg
  char msg[1024l];
  // contenttype
  char contenttype[64l];
  // charset
  char charset[64l];
  // location
  char *location;
  // lastmodified
  char lastmodified[64l];
  // etag
  char etag[64l];
  // cdispo
  char cdispo[256l];
};

struct _PT_Index
{
  // type
  signed int type;
  // slots
  union anonymous_3 slots;
};

struct _PT_Index_Functions
{
  // PT_LoadCache
  signed int (*PT_LoadCache)(struct _PT_Index *, const char *);
  // PT_Index_Delete
  void (*PT_Index_Delete)(struct _PT_Index **);
  // PT_ReadCache
  struct _PT_Element * (*PT_ReadCache)(struct _PT_Index *, const char *, signed int);
  // PT_LookupCache
  signed int (*PT_LookupCache)(struct _PT_Index *, const char *);
  // PT_SaveCache
  signed int (*PT_SaveCache)(struct _PT_Indexes *, const char *);
};

struct _PT_Indexes
{
  // cil
  struct struct_coucal *cil;
  // index
  struct _PT_Index **index;
  // index_size
  signed int index_size;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct linkedlist_datablock_internal_s
{
  // next_datablock
  struct linkedlist_datablock_internal_s *next_datablock;
  // avail_in_this_block
  unsigned long int avail_in_this_block;
  // filled_in_this_block
  unsigned long int filled_in_this_block;
  // unused
  unsigned long int unused;
  // data
  unsigned char data[4080l];
};

struct proxytrack_process_th_p
{
  // soc_c
  signed int soc_c;
  // indexes
  struct _PT_Indexes *indexes;
  // process
  void (*process)(struct _PT_Indexes *, signed int);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct struct_coucal
{
  // items
  struct coucal_item *items;
  // lg_size
  unsigned long int lg_size;
  // used
  unsigned long int used;
  // stash
  struct anonymous_4 stash;
  // pool
  struct anonymous_5 pool;
  // stats
  struct anonymous_6 stats;
  // custom
  struct anonymous_7 custom;
};

struct struct_coucal_enum
{
  // table
  struct struct_coucal *table;
  // index
  unsigned long int index;
};

struct timeb
{
  // time
  signed long int time;
  // millitm
  unsigned short int millitm;
  // timezone
  signed short int timezone;
  // dstflag
  signed short int dstflag;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct unz64_file_pos_s
{
  // pos_in_zip_directory
  unsigned long long int pos_in_zip_directory;
  // num_of_file
  unsigned long long int num_of_file;
};

struct unz_file_info_s
{
  // version
  unsigned long int version;
  // version_needed
  unsigned long int version_needed;
  // flag
  unsigned long int flag;
  // compression_method
  unsigned long int compression_method;
  // dosDate
  unsigned long int dosDate;
  // crc
  unsigned long int crc;
  // compressed_size
  unsigned long int compressed_size;
  // uncompressed_size
  unsigned long int uncompressed_size;
  // size_filename
  unsigned long int size_filename;
  // size_file_extra
  unsigned long int size_file_extra;
  // size_file_comment
  unsigned long int size_file_comment;
  // disk_num_start
  unsigned long int disk_num_start;
  // internal_fa
  unsigned long int internal_fa;
  // external_fa
  unsigned long int external_fa;
  // tmu_date
  struct tm_unz_s tmu_date;
};

struct unz_file_pos_s
{
  // pos_in_zip_directory
  unsigned long int pos_in_zip_directory;
  // num_of_file
  unsigned long int num_of_file;
};

struct unz_global_info_s
{
  // number_entry
  unsigned long int number_entry;
  // size_comment
  unsigned long int size_comment;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct zlib_filefunc_def_s
{
  // zopen_file
  void * (*zopen_file)(void *, const char *, signed int);
  // zread_file
  unsigned long int (*zread_file)(void *, void *, void *, unsigned long int);
  // zwrite_file
  unsigned long int (*zwrite_file)(void *, void *, const void *, unsigned long int);
  // zflush_file
  signed int (*zflush_file)(void *, void *);
  // ztell_file
  signed long int (*ztell_file)(void *, void *);
  // zseek_file
  signed long int (*zseek_file)(void *, void *, unsigned long int, signed int);
  // zclose_file
  signed int (*zclose_file)(void *, void *);
  // zerror_file
  signed int (*zerror_file)(void *, void *);
  // opaque
  void *opaque;
};


// _IndexFuncts
// file proxy/store.c line 159
static struct _PT_Index_Functions _IndexFuncts[4l];
// _IndexFuncts
// file proxy/store.c line 159
static struct _PT_Index_Functions _IndexFuncts[4l] = { { .PT_LoadCache=PT_LoadCache__New, .PT_Index_Delete=PT_Index_Delete__New, .PT_ReadCache=PT_ReadCache__New,
    .PT_LookupCache=PT_LookupCache__New, .PT_SaveCache=PT_SaveCache__New },
    { .PT_LoadCache=PT_LoadCache__Old, .PT_Index_Delete=PT_Index_Delete__Old, .PT_ReadCache=PT_ReadCache__Old,
    .PT_LookupCache=PT_LookupCache__Old, .PT_SaveCache=(signed int (*)(struct _PT_Indexes *, const char *))(void *)0 },
    { .PT_LoadCache=PT_LoadCache__Arc, .PT_Index_Delete=PT_Index_Delete__Arc, .PT_ReadCache=PT_ReadCache__Arc,
    .PT_LookupCache=PT_LookupCache__Arc, .PT_SaveCache=PT_SaveCache__Arc },
    { .PT_LoadCache=(signed int (*)(struct _PT_Index *, const char *))(void *)0, .PT_Index_Delete=(void (*)(struct _PT_Index **))(void *)0,
    .PT_ReadCache=(struct _PT_Element * (*)(struct _PT_Index *, const char *, signed int))(void *)0,
    .PT_LookupCache=(signed int (*)(struct _PT_Index *, const char *))(void *)0,
    .PT_SaveCache=((signed int (*)(struct _PT_Indexes *, const char *))NULL) } };
// global_assert_handler
// file coucal.c line 280
static void (*global_assert_handler)(void *, const char *, const char *, signed int) = (void (*)(void *, const char *, const char *, signed int))(void *)0;
// global_log_handler
// file coucal.c line 283
static void (*global_log_handler)(void *, enum coucal_loglevel, const char *, void **) = (void (*)(void *, enum coucal_loglevel, const char *, void **))(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// the_empty_string
// file coucal.c line 277
static char the_empty_string[1l] = { (char)0 };
// timezone
// file /usr/include/time.h line 298
extern signed long int timezone;
// unz_copyright
// file minizip/unzip.c line 122
const char unz_copyright[81l] = { ' ', 'u', 'n', 'z', 'i', 'p', ' ', '1', '.', '0', '1', ' ', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '1', '9', '9', '8', '-', '2', '0', '0', '4', ' ', 'G', 'i', 'l', 'l', 'e', 's', ' ', 'V', 'o', 'l', 'l', 'a', 'n', 't', ' ', '-', ' ', 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', 'i', 'n', 'i', 'm', 'a', 'g', 'e', '.', 'c', 'o', 'm', '/', 'z', 'L', 'i', 'b', 'D', 'l', 'l', 0 };
// zip_copyright
// file minizip/zip.c line 98
const char zip_copyright[79l] = { ' ', 'z', 'i', 'p', ' ', '1', '.', '0', '1', ' ', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '1', '9', '9', '8', '-', '2', '0', '0', '4', ' ', 'G', 'i', 'l', 'l', 'e', 's', ' ', 'V', 'o', 'l', 'l', 'a', 'n', 't', ' ', '-', ' ', 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', 'i', 'n', 'i', 'm', 'a', 'g', 'e', '.', 'c', 'o', 'm', '/', 'z', 'L', 'i', 'b', 'D', 'l', 'l', 0 };

// DecodeUrl
// file proxy/store.c line 1553
static struct String DecodeUrl(const char *url)
{
  signed int i;
  struct String s = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  do
  {
    s.length_ = (unsigned long int)0;
    do
    {
      const unsigned long int DecodeUrl__1__1__1__capacity_ = (unsigned long int)(s.length_ + (unsigned long int)0 + (unsigned long int)1);
      while(!(s.capacity_ >= DecodeUrl__1__1__1__capacity_))
      {
        if(!(s.capacity_ >= 16ul))
          s.capacity_ = (unsigned long int)16;

        else
          s.capacity_ = s.capacity_ * (unsigned long int)2;
        void *return_value_realloc_1;
        return_value_realloc_1=realloc((void *)s.buffer_, s.capacity_);
        s.buffer_ = (char *)return_value_realloc_1;
        /* assertion (s).buffer_ != ((void *)0) */
        assert(s.buffer_ != (char *)(void *)0);
      }
    }
    while((_Bool)0);
    s.buffer_[(signed long int)0] = (char)0;
  }
  while((_Bool)0);
  i = 0;
  unsigned long int tmp_post_3;
  unsigned long int tmp_post_5;
  unsigned long int tmp_post_7;
  unsigned long int tmp_post_10;
  for( ; !((signed int)url[(signed long int)i] == 0); i = i + 1)
    if((signed int)url[(signed long int)i] == 43)
      do
      {
        struct String * const DecodeUrl__1__2__1__1__1__s__ = &s;
        char DecodeUrl__1__2__1__1__1__c__ = (char)32;
        do
        {
          const unsigned long int DecodeUrl__1__2__1__1__1__1__capacity_ = (unsigned long int)(DecodeUrl__1__2__1__1__1__s__->length_ + (unsigned long int)1 + (unsigned long int)1);
          while(!(DecodeUrl__1__2__1__1__1__s__->capacity_ >= DecodeUrl__1__2__1__1__1__1__capacity_))
          {
            if(!(DecodeUrl__1__2__1__1__1__s__->capacity_ >= 16ul))
              DecodeUrl__1__2__1__1__1__s__->capacity_ = (unsigned long int)16;

            else
              DecodeUrl__1__2__1__1__1__s__->capacity_ = DecodeUrl__1__2__1__1__1__s__->capacity_ * (unsigned long int)2;
            void *return_value_realloc_2;
            return_value_realloc_2=realloc((void *)DecodeUrl__1__2__1__1__1__s__->buffer_, DecodeUrl__1__2__1__1__1__s__->capacity_);
            DecodeUrl__1__2__1__1__1__s__->buffer_ = (char *)return_value_realloc_2;
            /* assertion (*s__).buffer_ != ((void *)0) */
            assert(DecodeUrl__1__2__1__1__1__s__->buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        tmp_post_3 = DecodeUrl__1__2__1__1__1__s__->length_;
        DecodeUrl__1__2__1__1__1__s__->length_ = DecodeUrl__1__2__1__1__1__s__->length_ + 1ul;
        DecodeUrl__1__2__1__1__1__s__->buffer_[(signed long int)tmp_post_3] = DecodeUrl__1__2__1__1__1__c__;
        DecodeUrl__1__2__1__1__1__s__->buffer_[(signed long int)DecodeUrl__1__2__1__1__1__s__->length_] = (char)0;
      }
      while((_Bool)0);

    else
      if((signed int)url[(signed long int)i] == 37)
      {
        if((signed int)url[(signed long int)(1 + i)] == 37)
        {
          do
          {
            struct String * const DecodeUrl__1__2__1__2__1__1__s__ = &s;
            char DecodeUrl__1__2__1__2__1__1__c__ = (char)37;
            do
            {
              const unsigned long int DecodeUrl__1__2__1__2__1__1__1__capacity_ = (unsigned long int)(DecodeUrl__1__2__1__2__1__1__s__->length_ + (unsigned long int)1 + (unsigned long int)1);
              while(!(DecodeUrl__1__2__1__2__1__1__s__->capacity_ >= DecodeUrl__1__2__1__2__1__1__1__capacity_))
              {
                if(!(DecodeUrl__1__2__1__2__1__1__s__->capacity_ >= 16ul))
                  DecodeUrl__1__2__1__2__1__1__s__->capacity_ = (unsigned long int)16;

                else
                  DecodeUrl__1__2__1__2__1__1__s__->capacity_ = DecodeUrl__1__2__1__2__1__1__s__->capacity_ * (unsigned long int)2;
                void *return_value_realloc_4;
                return_value_realloc_4=realloc((void *)DecodeUrl__1__2__1__2__1__1__s__->buffer_, DecodeUrl__1__2__1__2__1__1__s__->capacity_);
                DecodeUrl__1__2__1__2__1__1__s__->buffer_ = (char *)return_value_realloc_4;
                /* assertion (*s__).buffer_ != ((void *)0) */
                assert(DecodeUrl__1__2__1__2__1__1__s__->buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            tmp_post_5 = DecodeUrl__1__2__1__2__1__1__s__->length_;
            DecodeUrl__1__2__1__2__1__1__s__->length_ = DecodeUrl__1__2__1__2__1__1__s__->length_ + 1ul;
            DecodeUrl__1__2__1__2__1__1__s__->buffer_[(signed long int)tmp_post_5] = DecodeUrl__1__2__1__2__1__1__c__;
            DecodeUrl__1__2__1__2__1__1__s__->buffer_[(signed long int)DecodeUrl__1__2__1__2__1__1__s__->length_] = (char)0;
          }
          while((_Bool)0);
          i = i + 1;
        }

        else
          if(!((signed int)url[(signed long int)(1 + i)] == 0))
          {
            if(!((signed int)url[(signed long int)(2 + i)] == 0))
            {
              char tmp[3l];
              signed int codepoint = 0;
              tmp[(signed long int)0] = url[(signed long int)(i + 1)];
              tmp[(signed long int)1] = url[(signed long int)(i + 2)];
              tmp[(signed long int)2] = (char)0;
              signed int return_value_sscanf_8;
              return_value_sscanf_8=sscanf(tmp, "%x", &codepoint);
              if(return_value_sscanf_8 == 1)
                do
                {
                  struct String * const s__ = &s;
                  char c__ = (char)codepoint;
                  do
                  {
                    const unsigned long int capacity_ = (unsigned long int)(s__->length_ + (unsigned long int)1 + (unsigned long int)1);
                    while(!(s__->capacity_ >= capacity_))
                    {
                      if(!(s__->capacity_ >= 16ul))
                        s__->capacity_ = (unsigned long int)16;

                      else
                        s__->capacity_ = s__->capacity_ * (unsigned long int)2;
                      void *return_value_realloc_6;
                      return_value_realloc_6=realloc((void *)s__->buffer_, s__->capacity_);
                      s__->buffer_ = (char *)return_value_realloc_6;
                      /* assertion (*s__).buffer_ != ((void *)0) */
                      assert(s__->buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  tmp_post_7 = s__->length_;
                  s__->length_ = s__->length_ + 1ul;
                  s__->buffer_[(signed long int)tmp_post_7] = c__;
                  s__->buffer_[(signed long int)s__->length_] = (char)0;
                }
                while((_Bool)0);

              i = i + 2;
            }

          }

      }

      else
        do
        {
          struct String * const DecodeUrl__1__2__1__3__1__s__ = &s;
          char DecodeUrl__1__2__1__3__1__c__ = url[(signed long int)i];
          do
          {
            const unsigned long int DecodeUrl__1__2__1__3__1__1__capacity_ = (unsigned long int)(DecodeUrl__1__2__1__3__1__s__->length_ + (unsigned long int)1 + (unsigned long int)1);
            while(!(DecodeUrl__1__2__1__3__1__s__->capacity_ >= DecodeUrl__1__2__1__3__1__1__capacity_))
            {
              if(!(DecodeUrl__1__2__1__3__1__s__->capacity_ >= 16ul))
                DecodeUrl__1__2__1__3__1__s__->capacity_ = (unsigned long int)16;

              else
                DecodeUrl__1__2__1__3__1__s__->capacity_ = DecodeUrl__1__2__1__3__1__s__->capacity_ * (unsigned long int)2;
              void *return_value_realloc_9;
              return_value_realloc_9=realloc((void *)DecodeUrl__1__2__1__3__1__s__->buffer_, DecodeUrl__1__2__1__3__1__s__->capacity_);
              DecodeUrl__1__2__1__3__1__s__->buffer_ = (char *)return_value_realloc_9;
              /* assertion (*s__).buffer_ != ((void *)0) */
              assert(DecodeUrl__1__2__1__3__1__s__->buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          tmp_post_10 = DecodeUrl__1__2__1__3__1__s__->length_;
          DecodeUrl__1__2__1__3__1__s__->length_ = DecodeUrl__1__2__1__3__1__s__->length_ + 1ul;
          DecodeUrl__1__2__1__3__1__s__->buffer_[(signed long int)tmp_post_10] = DecodeUrl__1__2__1__3__1__c__;
          DecodeUrl__1__2__1__3__1__s__->buffer_[(signed long int)DecodeUrl__1__2__1__3__1__s__->length_] = (char)0;
        }
        while((_Bool)0);
  return s;
}

// GetHttpMessage
// file proxy/proxytrack.c line 387
static const char * GetHttpMessage(signed int statuscode)
{
  switch(statuscode)
  {
    case 100:
      return "Continue";
    case 101:
      return "Switching Protocols";
    case 200:
      return "OK";
    case 201:
      return "Created";
    case 202:
      return "Accepted";
    case 203:
      return "Non-Authoritative Information";
    case 204:
      return "No Content";
    case 205:
      return "Reset Content";
    case 206:
      return "Partial Content";
    case 207:
      return "Multi-Status";
    case 300:
      return "Multiple Choices";
    case 301:
      return "Moved Permanently";
    case 302:
      return "Moved Temporarily";
    case 303:
      return "See Other";
    case 304:
      return "Not Modified";
    case 305:
      return "Use Proxy";
    case 306:
      return "Undefined 306 error";
    case 307:
      return "Temporary Redirect";
    case 400:
      return "Bad Request";
    case 401:
      return "Unauthorized";
    case 402:
      return "Payment Required";
    case 403:
      return "Forbidden";
    case 404:
      return "Not Found";
    case 405:
      return "Method Not Allowed";
    case 406:
      return "Not Acceptable";
    case 407:
      return "Proxy Authentication Required";
    case 408:
      return "Request Time-out";
    case 409:
      return "Conflict";
    case 410:
      return "Gone";
    case 411:
      return "Length Required";
    case 412:
      return "Precondition Failed";
    case 413:
      return "Request Entity Too Large";
    case 414:
      return "Request-URI Too Large";
    case 415:
      return "Unsupported Media Type";
    case 416:
      return "Requested Range Not Satisfiable";
    case 417:
      return "Expectation Failed";
    case 500:
      return "Internal Server Error";
    case 501:
      return "Not Implemented";
    case 502:
      return "Bad Gateway";
    case 503:
      return "Service Unavailable";
    case 504:
      return "Gateway Time-out";
    case 505:
      return "HTTP Version Not Supported";
    default:
      return "Unknown HTTP Error";
  }
}

// ICP_reply
// file proxy/proxytrack.c line 1520
static signed int ICP_reply(struct sockaddr *clientAddr, signed int clientAddrLen, signed int soc, unsigned char Opcode, unsigned char Version, unsigned short int Message_Length, unsigned int Request_Number, unsigned int Options, unsigned int Option_Data, unsigned int Sender_Host_Address, unsigned char *Message)
{
  signed int ret = 0;
  unsigned long int BufferSize;
  unsigned char *buffer;
  unsigned long int return_value_strlen_1;
  if((signed int)Message_Length == 0 && !(Message == ((unsigned char *)NULL)))
  {
    return_value_strlen_1=strlen((char *)Message);
    Message_Length = (unsigned short int)((unsigned int)return_value_strlen_1 + (unsigned int)1);
  }

  BufferSize = (unsigned long int)(20 + (signed int)Message_Length);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(BufferSize);
  buffer = (unsigned char *)return_value_malloc_2;
  if(!(buffer == ((unsigned char *)NULL)))
  {
    do
      ((unsigned char *)&buffer[(signed long int)0])[(signed long int)0] = (unsigned char)Opcode;
    while((_Bool)0);
    do
      ((unsigned char *)&buffer[(signed long int)1])[(signed long int)0] = (unsigned char)Version;
    while((_Bool)0);
    do
    {
      ((unsigned char *)&buffer[(signed long int)2])[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)Message_Length >> 8 & 0xff);
      ((unsigned char *)&buffer[(signed long int)2])[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)Message_Length & 0xff);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L5:
      ;
      ((unsigned char *)&buffer[(signed long int)4])[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Request_Number >> 16 & (unsigned int)0xffff) >> 8 & 0xff);
      ((unsigned char *)&buffer[(signed long int)4])[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Request_Number >> 16 & (unsigned int)0xffff) & 0xff);
      do
      {
        ((unsigned char *)&buffer[(signed long int)4] + (signed long int)2)[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Request_Number & (unsigned int)0xffff) >> 8 & 0xff);
        ((unsigned char *)&buffer[(signed long int)4] + (signed long int)2)[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Request_Number & (unsigned int)0xffff) & 0xff);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      ((unsigned char *)&buffer[(signed long int)8])[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Options >> 16 & (unsigned int)0xffff) >> 8 & 0xff);
      ((unsigned char *)&buffer[(signed long int)8])[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Options >> 16 & (unsigned int)0xffff) & 0xff);
      do
      {
        ((unsigned char *)&buffer[(signed long int)8] + (signed long int)2)[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Options & (unsigned int)0xffff) >> 8 & 0xff);
        ((unsigned char *)&buffer[(signed long int)8] + (signed long int)2)[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Options & (unsigned int)0xffff) & 0xff);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L9:
      ;
      ((unsigned char *)&buffer[(signed long int)12])[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Option_Data >> 16 & (unsigned int)0xffff) >> 8 & 0xff);
      ((unsigned char *)&buffer[(signed long int)12])[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Option_Data >> 16 & (unsigned int)0xffff) & 0xff);
      do
      {
        ((unsigned char *)&buffer[(signed long int)12] + (signed long int)2)[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Option_Data & (unsigned int)0xffff) >> 8 & 0xff);
        ((unsigned char *)&buffer[(signed long int)12] + (signed long int)2)[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Option_Data & (unsigned int)0xffff) & 0xff);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L11:
      ;
      ((unsigned char *)&buffer[(signed long int)16])[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Sender_Host_Address >> 16 & (unsigned int)0xffff) >> 8 & 0xff);
      ((unsigned char *)&buffer[(signed long int)16])[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Sender_Host_Address >> 16 & (unsigned int)0xffff) & 0xff);
      do
      {
        ((unsigned char *)&buffer[(signed long int)16] + (signed long int)2)[(signed long int)0] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Sender_Host_Address & (unsigned int)0xffff) >> 8 & 0xff);
        ((unsigned char *)&buffer[(signed long int)16] + (signed long int)2)[(signed long int)1] = (unsigned char)((signed int)(unsigned short int)((unsigned int)Sender_Host_Address & (unsigned int)0xffff) & 0xff);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    if((signed int)Message_Length >= 1 && !(Message == ((unsigned char *)NULL)))
      memcpy((void *)(buffer + (signed long int)20), (const void *)Message, (unsigned long int)Message_Length);

    signed long int return_value_sendto_3;
    return_value_sendto_3=sendto(soc, (const void *)buffer, BufferSize, 0, clientAddr, (unsigned int)clientAddrLen);
    if((unsigned long int)return_value_sendto_3 == BufferSize)
      ret = 1;

    free((void *)buffer);
  }

  return ret;
}

// LoadCentralDirectoryRecord
// file minizip/zip.c line 640
static signed int LoadCentralDirectoryRecord(struct anonymous_9 *pziinit)
{
  signed int err = 0;
  unsigned long long int byte_before_the_zipfile;
  unsigned long long int size_central_dir;
  unsigned long long int offset_central_dir;
  unsigned long long int central_pos;
  unsigned long int uL;
  unsigned long int number_disk;
  unsigned long int number_disk_with_CD;
  unsigned long long int number_entry;
  unsigned long long int number_entry_CD;
  unsigned long int VersionMadeBy;
  unsigned long int VersionNeeded;
  unsigned long int size_comment;
  signed int hasZIP64Record = 0;
  central_pos=zip64local_SearchCentralDir64(&pziinit->z_filefunc, pziinit->filestream);
  if(central_pos >= 1ul)
    hasZIP64Record = 1;

  else
    if(central_pos == 0ul)
      central_pos=zip64local_SearchCentralDir(&pziinit->z_filefunc, pziinit->filestream);

  if(!(hasZIP64Record == 0))
  {
    unsigned long long int sizeEndOfCentralDirectory;
    signed long int return_value_call_zseek64_1;
    return_value_call_zseek64_1=call_zseek64(&pziinit->z_filefunc, pziinit->filestream, central_pos, 0);
    if(!(return_value_call_zseek64_1 == 0l))
      err = -1;

    signed int return_value_zip64local_getLong_2;
    return_value_zip64local_getLong_2=zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL);
    if(!(return_value_zip64local_getLong_2 == 0))
      err = -1;

    signed int return_value_zip64local_getLong64_3;
    return_value_zip64local_getLong64_3=zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory);
    if(!(return_value_zip64local_getLong64_3 == 0))
      err = -1;

    signed int return_value_zip64local_getShort_4;
    return_value_zip64local_getShort_4=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy);
    if(!(return_value_zip64local_getShort_4 == 0))
      err = -1;

    signed int return_value_zip64local_getShort_5;
    return_value_zip64local_getShort_5=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded);
    if(!(return_value_zip64local_getShort_5 == 0))
      err = -1;

    signed int return_value_zip64local_getLong_6;
    return_value_zip64local_getLong_6=zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &number_disk);
    if(!(return_value_zip64local_getLong_6 == 0))
      err = -1;

    signed int return_value_zip64local_getLong_7;
    return_value_zip64local_getLong_7=zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &number_disk_with_CD);
    if(!(return_value_zip64local_getLong_7 == 0))
      err = -1;

    signed int return_value_zip64local_getLong64_8;
    return_value_zip64local_getLong64_8=zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry);
    if(!(return_value_zip64local_getLong64_8 == 0))
      err = -1;

    signed int return_value_zip64local_getLong64_9;
    return_value_zip64local_getLong64_9=zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry_CD);
    if(!(return_value_zip64local_getLong64_9 == 0))
      err = -1;

    if(!(number_disk == 0ul) || !(number_disk_with_CD == 0ul) || !(number_entry_CD == number_entry))
      err = -103;

    signed int return_value_zip64local_getLong64_10;
    return_value_zip64local_getLong64_10=zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &size_central_dir);
    if(!(return_value_zip64local_getLong64_10 == 0))
      err = -1;

    signed int return_value_zip64local_getLong64_11;
    return_value_zip64local_getLong64_11=zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &offset_central_dir);
    if(!(return_value_zip64local_getLong64_11 == 0))
      err = -1;

    size_comment = (unsigned long int)0;
  }

  else
  {
    signed long int return_value_call_zseek64_12;
    return_value_call_zseek64_12=call_zseek64(&pziinit->z_filefunc, pziinit->filestream, central_pos, 0);
    if(!(return_value_call_zseek64_12 == 0l))
      err = -1;

    signed int return_value_zip64local_getLong_13;
    return_value_zip64local_getLong_13=zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL);
    if(!(return_value_zip64local_getLong_13 == 0))
      err = -1;

    signed int return_value_zip64local_getShort_14;
    return_value_zip64local_getShort_14=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &number_disk);
    if(!(return_value_zip64local_getShort_14 == 0))
      err = -1;

    signed int return_value_zip64local_getShort_15;
    return_value_zip64local_getShort_15=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &number_disk_with_CD);
    if(!(return_value_zip64local_getShort_15 == 0))
      err = -1;

    number_entry = (unsigned long long int)0;
    signed int return_value_zip64local_getShort_16;
    return_value_zip64local_getShort_16=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL);
    if(!(return_value_zip64local_getShort_16 == 0))
      err = -1;

    else
      number_entry = uL;
    number_entry_CD = (unsigned long long int)0;
    signed int return_value_zip64local_getShort_17;
    return_value_zip64local_getShort_17=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL);
    if(!(return_value_zip64local_getShort_17 == 0))
      err = -1;

    else
      number_entry_CD = uL;
    if(!(number_disk == 0ul) || !(number_disk_with_CD == 0ul) || !(number_entry_CD == number_entry))
      err = -103;

    size_central_dir = (unsigned long long int)0;
    signed int return_value_zip64local_getLong_18;
    return_value_zip64local_getLong_18=zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL);
    if(!(return_value_zip64local_getLong_18 == 0))
      err = -1;

    else
      size_central_dir = uL;
    offset_central_dir = (unsigned long long int)0;
    signed int return_value_zip64local_getLong_19;
    return_value_zip64local_getLong_19=zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL);
    if(!(return_value_zip64local_getLong_19 == 0))
      err = -1;

    else
      offset_central_dir = uL;
    signed int return_value_zip64local_getShort_20;
    return_value_zip64local_getShort_20=zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment);
    if(!(return_value_zip64local_getShort_20 == 0))
      err = -1;

  }
  if(err == 0 && !(central_pos >= offset_central_dir + size_central_dir))
    err = -103;

  if(!(err == 0))
  {
    pziinit->z_filefunc.zfile_func64.zclose_file(pziinit->z_filefunc.zfile_func64.opaque, pziinit->filestream);
    return -1;
  }

  else
  {
    if(size_comment >= 1ul)
    {
      void *return_value_malloc_21;
      return_value_malloc_21=malloc(size_comment + (unsigned long int)1);
      pziinit->globalcomment = (char *)return_value_malloc_21;
      if(!(pziinit->globalcomment == ((char *)NULL)))
      {
        size_comment=pziinit->z_filefunc.zfile_func64.zread_file(pziinit->z_filefunc.zfile_func64.opaque, pziinit->filestream, (void *)pziinit->globalcomment, size_comment);
        pziinit->globalcomment[(signed long int)size_comment] = (char)0;
      }

    }

    byte_before_the_zipfile = central_pos - (offset_central_dir + size_central_dir);
    pziinit->add_position_when_writting_offset = byte_before_the_zipfile;
    unsigned long long int size_central_dir_to_read = size_central_dir;
    unsigned long int buf_size = (unsigned long int)(4096 - 4 * 4);
    void *buf_read;
    void *return_value_malloc_22;
    return_value_malloc_22=malloc(buf_size);
    buf_read = (void *)return_value_malloc_22;
    signed long int return_value_call_zseek64_23;
    return_value_call_zseek64_23=call_zseek64(&pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, 0);
    if(!(return_value_call_zseek64_23 == 0l))
      err = -1;

    if(err == 0 && size_central_dir_to_read >= 1ul)
    {
      unsigned long long int read_this = (unsigned long long int)(4096 - 4 * 4);
      if(!(size_central_dir_to_read >= read_this))
        read_this = size_central_dir_to_read;

      unsigned long int return_value;
      return_value=pziinit->z_filefunc.zfile_func64.zread_file(pziinit->z_filefunc.zfile_func64.opaque, pziinit->filestream, buf_read, (unsigned long int)read_this);
      if(!(return_value == read_this))
        err = -1;

      if(err == 0)
        err=add_data_in_datablock(&pziinit->central_dir, buf_read, (unsigned long int)read_this);

      size_central_dir_to_read = size_central_dir_to_read - read_this;
    }

    if(!(buf_read == NULL))
      free(buf_read);

    pziinit->begin_pos = byte_before_the_zipfile;
    pziinit->number_entry = number_entry_CD;
    signed long int return_value_call_zseek64_24;
    return_value_call_zseek64_24=call_zseek64(&pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, 0);
    if(!(return_value_call_zseek64_24 == 0l))
      err = -1;

    return err;
  }
}

// MD5Final
// file md5.h line 33
void MD5Final(unsigned char *digest, struct MD5Context *ctx)
{
  unsigned int count;
  unsigned char *p;
  count = ctx->bits[(signed long int)0] >> 3 & (unsigned int)0x3F;
  p = ctx->in.ui8 + (signed long int)count;
  unsigned char *tmp_post_1 = p;
  p = p + 1l;
  *tmp_post_1 = (unsigned char)0x80;
  count = (unsigned int)(64 - 1) - count;
  if(!(count >= 8u))
  {
    memset((void *)p, 0, (unsigned long int)count);
    if(!(ctx->doByteReverse == 0))
      byteReverse(ctx->in.ui8, (unsigned int)16);

    MD5Transform(ctx->buf, ctx->in.ui32);
    memset((void *)ctx->in.ui8, 0, (unsigned long int)56);
  }

  else
    memset((void *)p, 0, (unsigned long int)(count - (unsigned int)8));
  if(!(ctx->doByteReverse == 0))
    byteReverse(ctx->in.ui8, (unsigned int)14);

  ctx->in.ui32[(signed long int)14] = ctx->bits[(signed long int)0];
  ctx->in.ui32[(signed long int)15] = ctx->bits[(signed long int)1];
  MD5Transform(ctx->buf, ctx->in.ui32);
  if(!(ctx->doByteReverse == 0))
    byteReverse((unsigned char *)ctx->buf, (unsigned int)4);

  memcpy((void *)digest, (const void *)ctx->buf, (unsigned long int)16);
  memset((void *)ctx, 0, sizeof(struct MD5Context) /*92ul*/ );
}

// MD5Init
// file md5.h line 30
void MD5Init(struct MD5Context *ctx, signed int brokenEndian)
{
  ctx->buf[(signed long int)0] = (unsigned int)0x67452301;
  ctx->buf[(signed long int)1] = 0xefcdab89;
  ctx->buf[(signed long int)2] = 0x98badcfe;
  ctx->buf[(signed long int)3] = (unsigned int)0x10325476;
  ctx->bits[(signed long int)0] = (unsigned int)0;
  ctx->bits[(signed long int)1] = (unsigned int)0;
  if(!(brokenEndian == 0))
    ctx->doByteReverse = 0;

  else
    ctx->doByteReverse = 1;
}

// MD5Transform
// file md5.c line 189
void MD5Transform(unsigned int *buf, const unsigned int *in)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = buf[(signed long int)0];
  b = buf[(signed long int)1];
  c = buf[(signed long int)2];
  d = buf[(signed long int)3];
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)0] + 0xd76aa478;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)1] + 0xe8c7b756;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)2] + (unsigned int)0x242070db;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)3] + 0xc1bdceee;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)4] + 0xf57c0faf;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)5] + (unsigned int)0x4787c62a;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)6] + 0xa8304613;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)7] + 0xfd469501;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x698098d8;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)9] + 0x8b44f7af;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)10] + 0xffff5bb1;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)11] + 0x895cd7be;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)12] + (unsigned int)0x6b901122;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)13] + 0xfd987193;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)14] + 0xa679438e;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)15] + (unsigned int)0x49b40821;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)1] + 0xf61e2562;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)6] + 0xc040b340;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)11] + (unsigned int)0x265e5a51;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)0] + 0xe9b6c7aa;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)5] + 0xd62f105d;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)10] + (unsigned int)0x02441453;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)15] + 0xd8a1e681;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)4] + 0xe7d3fbc8;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)14] + 0xc33707d6;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)3] + 0xf4d50d87;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x455a14ed;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)13] + 0xa9e3e905;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)2] + 0xfcefa3f8;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)7] + (unsigned int)0x676f02d9;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)12] + 0x8d2a4c8a;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)5] + 0xfffa3942;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)8] + 0x8771f681;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)14] + 0xfde5380c;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)1] + 0xa4beea44;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)7] + 0xf6bb4b60;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)10] + 0xbebfbc70;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)0] + 0xeaa127fa;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)3] + 0xd4ef3085;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)6] + (unsigned int)0x04881d05;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)9] + 0xd9d4d039;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)12] + 0xe6db99e5;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)2] + 0xc4ac5665;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)0] + 0xf4292244;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)7] + (unsigned int)0x432aff97;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)14] + 0xab9423a7;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)5] + 0xfc93a039;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)12] + (unsigned int)0x655b59c3;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)3] + 0x8f0ccc92;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)10] + 0xffeff47d;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)1] + 0x85845dd1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)15] + 0xfe2ce6e0;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)6] + 0xa3014314;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)4] + 0xf7537e82;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)11] + 0xbd3af235;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)9] + 0xeb86d391;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  buf[(signed long int)0] = buf[(signed long int)0] + a;
  buf[(signed long int)1] = buf[(signed long int)1] + b;
  buf[(signed long int)2] = buf[(signed long int)2] + c;
  buf[(signed long int)3] = buf[(signed long int)3] + d;
}

// MD5Update
// file md5.h line 31
void MD5Update(struct MD5Context *ctx, const unsigned char *buf, unsigned int len)
{
  unsigned int t = ctx->bits[(signed long int)0];
  ctx->bits[(signed long int)0] = t + ((unsigned int)len << 3);
  if(!(ctx->bits[0l] >= t))
    ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + 1u;

  ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + (len >> 29);
  t = t >> 3 & (unsigned int)0x3f;
  if(!(t == 0u))
  {
    unsigned char *p = ctx->in.ui8 + (signed long int)t;
    t = (unsigned int)64 - t;
    if(!(len >= t))
    {
      memcpy((void *)p, (const void *)buf, (unsigned long int)len);
      goto __CPROVER_DUMP_L7;
    }

    memcpy((void *)p, (const void *)buf, (unsigned long int)t);
    if(!(ctx->doByteReverse == 0))
      byteReverse(ctx->in.ui8, (unsigned int)16);

    MD5Transform(ctx->buf, ctx->in.ui32);
    buf = buf + (signed long int)t;
    len = len - t;
  }

  for( ; len >= 64u; len = len - (unsigned int)64)
  {
    memcpy((void *)ctx->in.ui8, (const void *)buf, (unsigned long int)64);
    if(!(ctx->doByteReverse == 0))
      byteReverse(ctx->in.ui8, (unsigned int)16);

    MD5Transform(ctx->buf, ctx->in.ui32);
    buf = buf + (signed long int)64;
  }
  memcpy((void *)ctx->in.ui8, (const void *)buf, (unsigned long int)len);

__CPROVER_DUMP_L7:
  ;
}

// MutexFree
// file proxy/store.c line 107
void MutexFree(union anonymous_1 *pMutex)
{
  pthread_mutex_destroy(pMutex);
}

// MutexInit
// file proxy/store.c line 95
void MutexInit(union anonymous_1 *pMutex)
{
  pthread_mutex_init(pMutex, ((const union anonymous_11 *)NULL));
}

// MutexLock
// file proxy/store.c line 99
void MutexLock(union anonymous_1 *pMutex)
{
  pthread_mutex_lock(pMutex);
}

// MutexUnlock
// file proxy/store.c line 103
void MutexUnlock(union anonymous_1 *pMutex)
{
  pthread_mutex_unlock(pMutex);
}

// PT_AddIndex
// file proxy/store.h line 90
signed int PT_AddIndex(struct _PT_Indexes *indexes, const char *path)
{
  struct _PT_Index *index;
  index=PT_LoadCache(path);
  if(!(index == ((struct _PT_Index *)NULL)))
  {
    signed int ret;
    ret=PT_IndexMerge(indexes, &index);
    if(!(index == ((struct _PT_Index *)NULL)))
      PT_Index_Delete(&index);

    return ret;
  }

  return -1;
}

// PT_CompatibleScheme
// file proxy/store.c line 1988
static signed int PT_CompatibleScheme(const char *url)
{
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(url, "http:", sizeof(char [6l]) /*6ul*/  - (unsigned long int)1);
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_2;
  if(return_value_strncmp_1 == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strncmp_2=strncmp(url, "https:", sizeof(char [7l]) /*7ul*/  - (unsigned long int)1);
    tmp_if_expr_3 = return_value_strncmp_2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_strncmp_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strncmp_4=strncmp(url, "ftp:", sizeof(char [5l]) /*5ul*/  - (unsigned long int)1);
    tmp_if_expr_5 = return_value_strncmp_4 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_strncmp_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strncmp_6=strncmp(url, "file:", sizeof(char [6l]) /*6ul*/  - (unsigned long int)1);
    tmp_if_expr_7 = return_value_strncmp_6 == 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_7;
}

// PT_Delete
// file proxy/store.h line 87
void PT_Delete(struct _PT_Indexes *index)
{
  if(!(index == ((struct _PT_Indexes *)NULL)))
  {
    coucal_delete(&index->cil);
    free((void *)index);
  }

}

// PT_ElementNew
// file proxy/store.h line 113
struct _PT_Element * PT_ElementNew(void)
{
  struct _PT_Element *r = (struct _PT_Element *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct _PT_Element) /*1576ul*/ , (unsigned long int)1);
  r = (struct _PT_Element *)return_value_calloc_1;
  if(r == ((struct _PT_Element *)NULL))
    return (struct _PT_Element *)(void *)0;

  else
  {
    r->statuscode = -1;
    r->indexId = -1;
    return r;
  }
}

// PT_Element_Delete
// file proxy/store.h line 114
void PT_Element_Delete(struct _PT_Element **pentry)
{
  if(!(pentry == ((struct _PT_Element **)NULL)))
  {
    struct _PT_Element *entry = *pentry;
    if(!(entry == ((struct _PT_Element *)NULL)))
    {
      if(!(entry->adr == ((char *)NULL)))
      {
        free((void *)entry->adr);
        entry->adr = (char *)(void *)0;
      }

      if(!(entry->headers == ((char *)NULL)))
      {
        free((void *)entry->headers);
        entry->headers = (char *)(void *)0;
      }

      if(!(entry->location == ((char *)NULL)))
      {
        free((void *)entry->location);
        entry->location = (char *)(void *)0;
      }

      free((void *)entry);
    }

    *pentry = (struct _PT_Element *)(void *)0;
  }

}

// PT_EnumCache
// file proxy/store.c line 624
signed int PT_EnumCache(struct _PT_Indexes *indexes, signed int (*callback)(void *, const char *, struct _PT_Element *), void *arg)
{
  _Bool tmp_if_expr_1;
  if(!(indexes == ((struct _PT_Indexes *)NULL)))
  {
    if(!(indexes->cil == ((struct struct_coucal *)NULL)))
    {
      struct struct_coucal_enum en;
      en=coucal_enum_new(indexes->cil);
      struct coucal_item *chain;
      do
      {
        chain=coucal_enum_next(&en);
        if(chain == ((struct coucal_item *)NULL))
          break;

        const signed long int index_id = (signed long int)chain->value.intg;
        const char * const url = (const char *)chain->name;
        if(index_id >= 0l)
          tmp_if_expr_1 = index_id <= (signed long int)indexes->index_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
        {
          struct _PT_Element *item;
          item=PT_ReadCache(indexes->index[index_id], url, 0 | 1);
          if(!(item == ((struct _PT_Element *)NULL)))
          {
            signed int ret;
            ret=callback(arg, url, item);
            PT_Element_Delete(&item);
            if(!(ret == 0))
              return ret;

          }

        }

        else
        {
          proxytrack_print_log_link1("critical", "PT_ReadCache:Corrupted central index locator");
          return -1;
        }
      }
      while((_Bool)1);
    }

  }

  return 0;
}

// PT_Enumerate
// file proxy/store.h line 98
char ** PT_Enumerate(struct _PT_Indexes *indexes, const char *url, signed int subtree)
{
  _Bool tmp_if_expr_21;
  signed int return_value_strncmp_20;
  _Bool tmp_if_expr_19;
  char *tmp_if_expr_7;
  char *return_value_strchr_stop_6;
  unsigned int tmp_if_expr_9;
  unsigned long int return_value_strlen_8;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_17;
  signed int return_value_coucal_exists_16;
  if(!(indexes == ((struct _PT_Indexes *)NULL)))
  {
    if(!(indexes->cil == ((struct struct_coucal *)NULL)))
    {
      unsigned int urlSize;
      struct String list = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
      struct String listindexes = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
      struct String subitem = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
      unsigned int listCount = (unsigned int)0;
      struct struct_coucal_enum en;
      en=coucal_enum_new(indexes->cil);
      struct coucal_item *chain;
      struct struct_coucal *hdupes = (struct struct_coucal *)(void *)0;
      if(subtree == 0)
      {
        hdupes=coucal_new((unsigned long int)0);
        coucal_set_name(hdupes, (const void *)"hdupes");
      }

      do
      {
        list.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int PT_Enumerate__1__1__2__1__capacity_ = (unsigned long int)(list.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(list.capacity_ >= PT_Enumerate__1__1__2__1__capacity_))
          {
            if(!(list.capacity_ >= 16ul))
              list.capacity_ = (unsigned long int)16;

            else
              list.capacity_ = list.capacity_ * (unsigned long int)2;
            void *return_value_realloc_1;
            return_value_realloc_1=realloc((void *)list.buffer_, list.capacity_);
            list.buffer_ = (char *)return_value_realloc_1;
            /* assertion (list).buffer_ != ((void *)0) */
            assert(list.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        list.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        listindexes.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int PT_Enumerate__1__1__3__1__capacity_ = (unsigned long int)(listindexes.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(listindexes.capacity_ >= PT_Enumerate__1__1__3__1__capacity_))
          {
            if(!(listindexes.capacity_ >= 16ul))
              listindexes.capacity_ = (unsigned long int)16;

            else
              listindexes.capacity_ = listindexes.capacity_ * (unsigned long int)2;
            void *return_value_realloc_2;
            return_value_realloc_2=realloc((void *)listindexes.buffer_, listindexes.capacity_);
            listindexes.buffer_ = (char *)return_value_realloc_2;
            /* assertion (listindexes).buffer_ != ((void *)0) */
            assert(listindexes.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        listindexes.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        subitem.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int PT_Enumerate__1__1__4__1__capacity_ = (unsigned long int)(subitem.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(subitem.capacity_ >= PT_Enumerate__1__1__4__1__capacity_))
          {
            if(!(subitem.capacity_ >= 16ul))
              subitem.capacity_ = (unsigned long int)16;

            else
              subitem.capacity_ = subitem.capacity_ * (unsigned long int)2;
            void *return_value_realloc_3;
            return_value_realloc_3=realloc((void *)subitem.buffer_, subitem.capacity_);
            subitem.buffer_ = (char *)return_value_realloc_3;
            /* assertion (subitem).buffer_ != ((void *)0) */
            assert(subitem.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        subitem.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      signed int return_value_strncmp_4;
      return_value_strncmp_4=strncmp(url, "http://", (unsigned long int)7);
      if(return_value_strncmp_4 == 0)
        url = url + (signed long int)7;

      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(url);
      urlSize = (unsigned int)return_value_strlen_5;
      do
      {
        chain=coucal_enum_next(&en);
        if(chain == ((struct coucal_item *)NULL))
          break;

        signed long int index = (signed long int)chain->value.intg;
        if(urlSize == 0u)
          tmp_if_expr_21 = (_Bool)1;

        else
        {
          return_value_strncmp_20=strncmp((const char *)chain->name, url, (unsigned long int)urlSize);
          tmp_if_expr_21 = return_value_strncmp_20 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_21)
        {
          if(index >= 0l)
            tmp_if_expr_19 = index < (signed long int)indexes->index_size ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_19 = (_Bool)0;
          if(tmp_if_expr_19)
          {
            char *item = (char *)chain->name + (signed long int)urlSize;
            if((signed int)*item == 47)
              item = item + 1l;

            char *pos;
            if(!(subtree == 0))
              tmp_if_expr_7 = ((char *)NULL);

            else
            {
              return_value_strchr_stop_6=strchr_stop(item, (char)47, (char)63);
              tmp_if_expr_7 = return_value_strchr_stop_6;
            }
            pos = tmp_if_expr_7;
            unsigned int len;
            if(!(pos == ((char *)NULL)))
              tmp_if_expr_9 = (unsigned int)(pos - item);

            else
            {
              return_value_strlen_8=strlen(item);
              tmp_if_expr_9 = (unsigned int)return_value_strlen_8;
            }
            len = tmp_if_expr_9;
            if(len >= 1u)
              tmp_if_expr_18 = (_Bool)1;

            else
              tmp_if_expr_18 = (signed int)*item == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_18)
            {
              signed int isFolder = (signed int)((signed int)item[(signed long int)len] == 47);
              do
              {
                subitem.length_ = (unsigned long int)0;
                do
                {
                  const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__1__1__capacity_ = (unsigned long int)(subitem.length_ + (unsigned long int)0 + (unsigned long int)1);
                  while(!(subitem.capacity_ >= PT_Enumerate__1__1__5__1__1__1__1__1__1__capacity_))
                  {
                    if(!(subitem.capacity_ >= 16ul))
                      subitem.capacity_ = (unsigned long int)16;

                    else
                      subitem.capacity_ = subitem.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_10;
                    return_value_realloc_10=realloc((void *)subitem.buffer_, subitem.capacity_);
                    subitem.buffer_ = (char *)return_value_realloc_10;
                    /* assertion (subitem).buffer_ != ((void *)0) */
                    assert(subitem.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                subitem.buffer_[(signed long int)0] = (char)0;
              }
              while((_Bool)0);
              if(len >= 1u)
                do
                {
                  const char *PT_Enumerate__1__1__5__1__1__1__1__2__str_mc_ = item;
                  const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__2__size_mc_ = (unsigned long int)len;
                  do
                  {
                    const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__2__1__capacity_ = (unsigned long int)(subitem.length_ + PT_Enumerate__1__1__5__1__1__1__1__2__size_mc_ + (unsigned long int)1);
                    while(!(subitem.capacity_ >= PT_Enumerate__1__1__5__1__1__1__1__2__1__capacity_))
                    {
                      if(!(subitem.capacity_ >= 16ul))
                        subitem.capacity_ = (unsigned long int)16;

                      else
                        subitem.capacity_ = subitem.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_11;
                      return_value_realloc_11=realloc((void *)subitem.buffer_, subitem.capacity_);
                      subitem.buffer_ = (char *)return_value_realloc_11;
                      /* assertion (subitem).buffer_ != ((void *)0) */
                      assert(subitem.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(PT_Enumerate__1__1__5__1__1__1__1__2__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(subitem.buffer_ + (signed long int)subitem.length_), (const void *)PT_Enumerate__1__1__5__1__1__1__1__2__str_mc_, PT_Enumerate__1__1__5__1__1__1__1__2__size_mc_);
                    subitem.length_ = subitem.length_ + PT_Enumerate__1__1__5__1__1__1__1__2__size_mc_;
                  }

                  subitem.buffer_[(signed long int)subitem.length_] = (char)0;
                }
                while((_Bool)0);

              if(len == 0u)
                tmp_if_expr_17 = (_Bool)1;

              else
              {
                return_value_coucal_exists_16=coucal_exists(hdupes, (const void *)(const char *)subitem.buffer_);
                tmp_if_expr_17 = !(return_value_coucal_exists_16 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_17)
              {
                char *PT_Enumerate__1__1__5__1__1__1__1__3__ptr = (char *)(void *)0;
                PT_Enumerate__1__1__5__1__1__1__1__3__ptr = PT_Enumerate__1__1__5__1__1__1__1__3__ptr + (signed long int)list.length_;
                if(len >= 1u)
                  do
                  {
                    const char * const PT_Enumerate__1__1__5__1__1__1__1__3__1__str__ = (const char *)subitem.buffer_;
                    if(!(PT_Enumerate__1__1__5__1__1__1__1__3__1__str__ == ((const char *)NULL)))
                    {
                      unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__1__1__size__;
                      PT_Enumerate__1__1__5__1__1__1__1__3__1__1__size__=strlen(PT_Enumerate__1__1__5__1__1__1__1__3__1__str__);
                      do
                      {
                        const char *PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__str_mc_ = PT_Enumerate__1__1__5__1__1__1__1__3__1__str__;
                        const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__size_mc_ = (unsigned long int)PT_Enumerate__1__1__5__1__1__1__1__3__1__1__size__;
                        do
                        {
                          const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__1__capacity_ = (unsigned long int)(list.length_ + PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__size_mc_ + (unsigned long int)1);
                          while(!(list.capacity_ >= PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__1__capacity_))
                          {
                            if(!(list.capacity_ >= 16ul))
                              list.capacity_ = (unsigned long int)16;

                            else
                              list.capacity_ = list.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_12;
                            return_value_realloc_12=realloc((void *)list.buffer_, list.capacity_);
                            list.buffer_ = (char *)return_value_realloc_12;
                            /* assertion (list).buffer_ != ((void *)0) */
                            assert(list.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        if(PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__size_mc_ >= 1ul)
                        {
                          memcpy((void *)(list.buffer_ + (signed long int)list.length_), (const void *)PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__str_mc_, PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__size_mc_);
                          list.length_ = list.length_ + PT_Enumerate__1__1__5__1__1__1__1__3__1__1__1__size_mc_;
                        }

                        list.buffer_[(signed long int)list.length_] = (char)0;
                      }
                      while((_Bool)0);
                    }

                  }
                  while((_Bool)0);

                if(!(isFolder == 0))
                  do
                  {
                    const char * const str__ = "/";
                    if(!(str__ == ((const char *)NULL)))
                    {
                      unsigned long int size__;
                      size__=strlen(str__);
                      do
                      {
                        const char *str_mc_ = str__;
                        const unsigned long int size_mc_ = (unsigned long int)size__;
                        do
                        {
                          const unsigned long int capacity_ = (unsigned long int)(list.length_ + size_mc_ + (unsigned long int)1);
                          while(!(list.capacity_ >= capacity_))
                          {
                            if(!(list.capacity_ >= 16ul))
                              list.capacity_ = (unsigned long int)16;

                            else
                              list.capacity_ = list.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_13;
                            return_value_realloc_13=realloc((void *)list.buffer_, list.capacity_);
                            list.buffer_ = (char *)return_value_realloc_13;
                            /* assertion (list).buffer_ != ((void *)0) */
                            assert(list.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        if(size_mc_ >= 1ul)
                        {
                          memcpy((void *)(list.buffer_ + (signed long int)list.length_), (const void *)str_mc_, size_mc_);
                          list.length_ = list.length_ + size_mc_;
                        }

                        list.buffer_[(signed long int)list.length_] = (char)0;
                      }
                      while((_Bool)0);
                    }

                  }
                  while((_Bool)0);

                do
                {
                  const char *PT_Enumerate__1__1__5__1__1__1__1__3__3__str_mc_ = "\0";
                  const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__3__size_mc_ = (unsigned long int)1;
                  do
                  {
                    const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__3__1__capacity_ = (unsigned long int)(list.length_ + PT_Enumerate__1__1__5__1__1__1__1__3__3__size_mc_ + (unsigned long int)1);
                    while(!(list.capacity_ >= PT_Enumerate__1__1__5__1__1__1__1__3__3__1__capacity_))
                    {
                      if(!(list.capacity_ >= 16ul))
                        list.capacity_ = (unsigned long int)16;

                      else
                        list.capacity_ = list.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_14;
                      return_value_realloc_14=realloc((void *)list.buffer_, list.capacity_);
                      list.buffer_ = (char *)return_value_realloc_14;
                      /* assertion (list).buffer_ != ((void *)0) */
                      assert(list.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(PT_Enumerate__1__1__5__1__1__1__1__3__3__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(list.buffer_ + (signed long int)list.length_), (const void *)PT_Enumerate__1__1__5__1__1__1__1__3__3__str_mc_, PT_Enumerate__1__1__5__1__1__1__1__3__3__size_mc_);
                    list.length_ = list.length_ + PT_Enumerate__1__1__5__1__1__1__1__3__3__size_mc_;
                  }

                  list.buffer_[(signed long int)list.length_] = (char)0;
                }
                while((_Bool)0);
                do
                {
                  const char *PT_Enumerate__1__1__5__1__1__1__1__3__4__str_mc_ = (char *)&PT_Enumerate__1__1__5__1__1__1__1__3__ptr;
                  const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__4__size_mc_ = (unsigned long int)sizeof(char *) /*8ul*/ ;
                  do
                  {
                    const unsigned long int PT_Enumerate__1__1__5__1__1__1__1__3__4__1__capacity_ = (unsigned long int)(listindexes.length_ + PT_Enumerate__1__1__5__1__1__1__1__3__4__size_mc_ + (unsigned long int)1);
                    while(!(listindexes.capacity_ >= PT_Enumerate__1__1__5__1__1__1__1__3__4__1__capacity_))
                    {
                      if(!(listindexes.capacity_ >= 16ul))
                        listindexes.capacity_ = (unsigned long int)16;

                      else
                        listindexes.capacity_ = listindexes.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_15;
                      return_value_realloc_15=realloc((void *)listindexes.buffer_, listindexes.capacity_);
                      listindexes.buffer_ = (char *)return_value_realloc_15;
                      /* assertion (listindexes).buffer_ != ((void *)0) */
                      assert(listindexes.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(PT_Enumerate__1__1__5__1__1__1__1__3__4__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(listindexes.buffer_ + (signed long int)listindexes.length_), (const void *)PT_Enumerate__1__1__5__1__1__1__1__3__4__str_mc_, PT_Enumerate__1__1__5__1__1__1__1__3__4__size_mc_);
                    listindexes.length_ = listindexes.length_ + PT_Enumerate__1__1__5__1__1__1__1__3__4__size_mc_;
                  }

                  listindexes.buffer_[(signed long int)listindexes.length_] = (char)0;
                }
                while((_Bool)0);
                listCount = listCount + 1u;
                coucal_write(hdupes, (const void *)(const char *)subitem.buffer_, (signed long int)0);
              }

            }

          }

          else
            proxytrack_print_log_link1("critical", "PT_Enumerate:Corrupted central index locator");
        }

      }
      while((_Bool)1);
      do
      {
        if(!(subitem.buffer_ == ((char *)NULL)))
        {
          free((void *)subitem.buffer_);
          subitem.buffer_ = (char *)(void *)0;
        }

        subitem.capacity_ = (unsigned long int)0;
        subitem.length_ = (unsigned long int)0;
      }
      while((_Bool)0);
      coucal_delete(&hdupes);
      if(listCount >= 1u)
      {
        unsigned int i;
        void *blk;
        char *nullPointer = (char *)(void *)0;
        char *startStrings;
        do
        {
          const char *PT_Enumerate__1__1__7__1__str_mc_ = (char *)&nullPointer;
          const unsigned long int PT_Enumerate__1__1__7__1__size_mc_ = (unsigned long int)sizeof(char *) /*8ul*/ ;
          do
          {
            const unsigned long int PT_Enumerate__1__1__7__1__1__capacity_ = (unsigned long int)(listindexes.length_ + PT_Enumerate__1__1__7__1__size_mc_ + (unsigned long int)1);
            while(!(listindexes.capacity_ >= PT_Enumerate__1__1__7__1__1__capacity_))
            {
              if(!(listindexes.capacity_ >= 16ul))
                listindexes.capacity_ = (unsigned long int)16;

              else
                listindexes.capacity_ = listindexes.capacity_ * (unsigned long int)2;
              void *return_value_realloc_22;
              return_value_realloc_22=realloc((void *)listindexes.buffer_, listindexes.capacity_);
              listindexes.buffer_ = (char *)return_value_realloc_22;
              /* assertion (listindexes).buffer_ != ((void *)0) */
              assert(listindexes.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(PT_Enumerate__1__1__7__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(listindexes.buffer_ + (signed long int)listindexes.length_), (const void *)PT_Enumerate__1__1__7__1__str_mc_, PT_Enumerate__1__1__7__1__size_mc_);
            listindexes.length_ = listindexes.length_ + PT_Enumerate__1__1__7__1__size_mc_;
          }

          listindexes.buffer_[(signed long int)listindexes.length_] = (char)0;
        }
        while((_Bool)0);
        startStrings = nullPointer + (signed long int)listindexes.length_;
        do
        {
          const char *PT_Enumerate__1__1__7__2__str_mc_ = (const char *)list.buffer_;
          const unsigned long int PT_Enumerate__1__1__7__2__size_mc_ = (unsigned long int)list.length_;
          do
          {
            const unsigned long int PT_Enumerate__1__1__7__2__1__capacity_ = (unsigned long int)(listindexes.length_ + PT_Enumerate__1__1__7__2__size_mc_ + (unsigned long int)1);
            while(!(listindexes.capacity_ >= PT_Enumerate__1__1__7__2__1__capacity_))
            {
              if(!(listindexes.capacity_ >= 16ul))
                listindexes.capacity_ = (unsigned long int)16;

              else
                listindexes.capacity_ = listindexes.capacity_ * (unsigned long int)2;
              void *return_value_realloc_23;
              return_value_realloc_23=realloc((void *)listindexes.buffer_, listindexes.capacity_);
              listindexes.buffer_ = (char *)return_value_realloc_23;
              /* assertion (listindexes).buffer_ != ((void *)0) */
              assert(listindexes.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(PT_Enumerate__1__1__7__2__size_mc_ >= 1ul)
          {
            memcpy((void *)(listindexes.buffer_ + (signed long int)listindexes.length_), (const void *)PT_Enumerate__1__1__7__2__str_mc_, PT_Enumerate__1__1__7__2__size_mc_);
            listindexes.length_ = listindexes.length_ + PT_Enumerate__1__1__7__2__size_mc_;
          }

          listindexes.buffer_[(signed long int)listindexes.length_] = (char)0;
        }
        while((_Bool)0);
        startStrings = (startStrings - nullPointer) + listindexes.buffer_;
        i = (unsigned int)0;
        for( ; !(i >= listCount); i = i + 1u)
        {
          char *ptr = (char *)(void *)0;
          unsigned int ndx;
          memcpy((void *)&ptr, (const void *)&((const char *)listindexes.buffer_)[(signed long int)((unsigned long int)i * sizeof(char *) /*8ul*/ )], sizeof(char *) /*8ul*/ );
          ndx = (unsigned int)(ptr - nullPointer);
          ptr = startStrings + (signed long int)ndx;
          memcpy((void *)&listindexes.buffer_[(signed long int)((unsigned long int)i * sizeof(char *) /*8ul*/ )], (const void *)&ptr, sizeof(char *) /*8ul*/ );
        }
        char *return_value_StringAcquire_24;
        return_value_StringAcquire_24=StringAcquire_link1(&listindexes);
        blk = (void *)return_value_StringAcquire_24;
        do
        {
          if(!(list.buffer_ == ((char *)NULL)))
          {
            free((void *)list.buffer_);
            list.buffer_ = (char *)(void *)0;
          }

          list.capacity_ = (unsigned long int)0;
          list.length_ = (unsigned long int)0;
        }
        while((_Bool)0);
        do
        {
          if(!(listindexes.buffer_ == ((char *)NULL)))
          {
            free((void *)listindexes.buffer_);
            listindexes.buffer_ = (char *)(void *)0;
          }

          listindexes.capacity_ = (unsigned long int)0;
          listindexes.length_ = (unsigned long int)0;
        }
        while((_Bool)0);
        return (char **)blk;
      }

    }

  }

  return (char **)(void *)0;
}

// PT_Enumerate_Delete
// file proxy/store.h line 99
void PT_Enumerate_Delete(char ***plist)
{
  if(!(plist == ((char ***)NULL)))
  {
    if(!(*plist == ((char **)NULL)))
    {
      free((void *)*plist);
      *plist = (char **)(void *)0;
    }

  }

}

// PT_GetIndex
// file proxy/store.h line 93
struct _PT_Index * PT_GetIndex(struct _PT_Indexes *indexes, signed int indexId)
{
  if(indexId >= 0 && !(indexes == ((struct _PT_Indexes *)NULL)))
  {
    if(indexId >= indexes->index_size)
      goto __CPROVER_DUMP_L1;

    return indexes->index[(signed long int)indexId];
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (struct _PT_Index *)(void *)0;
  }
}

// PT_GetTime
// file proxy/proxytrack.h line 363
static struct tm PT_GetTime(signed long int t)
{
  struct tm tmbuf;
  struct tm *tm;
  tm=gmtime_r(&t, &tmbuf);
  if(!(tm == ((struct tm *)NULL)))
    return *tm;

  else
  {
    memset((void *)&tmbuf, 0, sizeof(struct tm) /*56ul*/ );
    return tmbuf;
  }
}

// PT_GetTimeIndex
// file proxy/store.c line 794
signed long int PT_GetTimeIndex(struct _PT_Indexes *indexes)
{
  if(!(indexes == ((struct _PT_Indexes *)NULL)))
  {
    if(indexes->index_size >= 1)
    {
      signed int i;
      signed long int maxt = indexes->index[(signed long int)0]->slots.common.timestamp;
      i = 1;
      for( ; !(i >= indexes->index_size); i = i + 1)
      {
        const signed long int currt = indexes->index[(signed long int)i]->slots.common.timestamp;
        if(!(maxt >= currt))
          maxt = currt;

      }
      return maxt;
    }

  }

  return (signed long int)-1;
}

// PT_GetType
// file proxy/store.c line 531
static signed int PT_GetType(const char *filename)
{
  char *dot;
  dot=strrchr(filename, 46);
  signed int return_value_strcasecmp_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_1;
  if(!(dot == ((char *)NULL)))
  {
    signed int return_value_strcasecmp_5;
    return_value_strcasecmp_5=strcasecmp(dot, ".zip");
    if(return_value_strcasecmp_5 == 0)
      return 0;

    else
    {
      return_value_strcasecmp_2=strcasecmp(dot, ".ndx");
      if(return_value_strcasecmp_2 == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_strcasecmp_3=strcasecmp(dot, ".dat");
        tmp_if_expr_4 = return_value_strcasecmp_3 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        return 1;

      else
      {
        return_value_strcasecmp_1=strcasecmp(dot, ".arc");
        if(return_value_strcasecmp_1 == 0)
          return 2;

      }
    }
  }

  return -1;
}

// PT_IndexMerge
// file proxy/store.c line 688
signed int PT_IndexMerge(struct _PT_Indexes *indexes, struct _PT_Index **pindex)
{
  signed int tmp_post_1;
  _Bool tmp_if_expr_2;
  if(!(pindex == ((struct _PT_Index **)NULL)))
  {
    if(!(*pindex == ((struct _PT_Index *)NULL)))
    {
      if(!((*pindex)->slots.common.hash == ((struct struct_coucal *)NULL)))
      {
        if(!(indexes == ((struct _PT_Indexes *)NULL)))
        {
          struct _PT_Index *index = *pindex;
          struct struct_coucal_enum en;
          en=coucal_enum_new(index->slots.common.hash);
          struct coucal_item *chain;
          signed int index_id;
          tmp_post_1 = indexes->index_size;
          indexes->index_size = indexes->index_size + 1;
          index_id = tmp_post_1;
          signed int nMerged = 0;
          void *return_value_realloc_4;
          return_value_realloc_4=realloc((void *)indexes->index, sizeof(struct _PT_Index) /*6224ul*/  * (unsigned long int)indexes->index_size);
          indexes->index = (struct _PT_Index **)return_value_realloc_4;
          if(!(indexes->index == ((struct _PT_Index **)NULL)))
          {
            indexes->index[(signed long int)index_id] = index;
            *pindex = (struct _PT_Index *)(void *)0;
            do
            {
              chain=coucal_enum_next(&en);
              if(chain == ((struct coucal_item *)NULL))
                break;

              const char *url = (const char *)chain->name;
              if(!(url == ((const char *)NULL)))
              {
                if(!((signed int)*url == 0))
                {
                  signed long int previous_index_id = (signed long int)0;
                  signed int return_value_coucal_read_3;
                  return_value_coucal_read_3=coucal_read(indexes->cil, (const void *)url, &previous_index_id);
                  if(!(return_value_coucal_read_3 == 0))
                  {
                    if(previous_index_id >= 0l)
                      tmp_if_expr_2 = previous_index_id < (signed long int)indexes->index_size ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr_2 = (_Bool)0;
                    if(tmp_if_expr_2)
                    {
                      if(!(index->slots.common.timestamp >= indexes->index[previous_index_id]->slots.common.timestamp))
                        break;

                    }

                    else
                      proxytrack_print_log_link1("critical", "PT_IndexMerge:Corrupted central index locator");
                  }

                  coucal_write(indexes->cil, chain->name, (signed long int)index_id);
                  nMerged = nMerged + 1;
                }

              }

            }
            while((_Bool)1);
          }

          else
            proxytrack_print_log_link1("critical", "PT_IndexMerge:Memory exhausted");
          return nMerged;
        }

      }

    }

  }

  return -1;
}

// PT_Index_Check__
// file proxy/store.c line 288
static signed int PT_Index_Check__(struct _PT_Index *index, const char *file, signed int line)
{
  if(index == ((struct _PT_Index *)NULL))
    return 0;

  else
    if(index->type >= 0)
    {
      if(index->type >= 3)
        goto __CPROVER_DUMP_L2;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      proxytrack_print_log_link1("critical", "index corrupted in memory at %s:%d", file, line);
      return 0;
    }
}

// PT_Index_Delete
// file proxy/store.c line 304
void PT_Index_Delete(struct _PT_Index **pindex)
{
  if(!(pindex == ((struct _PT_Index **)NULL)))
  {
    if(!(*pindex == ((struct _PT_Index *)NULL)))
    {
      struct _PT_Index *index = *pindex;
      signed int return_value_PT_Index_Check___1;
      return_value_PT_Index_Check___1=PT_Index_Check__(index, "proxy/store.c", 308);
      if(!(return_value_PT_Index_Check___1 == 0))
        _IndexFuncts[(signed long int)index->type].PT_Index_Delete(pindex);

      free((void *)index);
      *pindex = (struct _PT_Index *)(void *)0;
    }

  }

}

// PT_Index_Delete__Arc
// file proxy/store.c line 350
static void PT_Index_Delete__Arc(struct _PT_Index **pindex)
{
  if(!(pindex == ((struct _PT_Index **)NULL)))
  {
    if(!(*pindex == ((struct _PT_Index *)NULL)))
    {
      struct _PT_Index__Arc *index = &(*pindex)->slots.formatArc;
      if(!(index->file == ((struct _IO_FILE *)NULL)))
        fclose(index->file);

      MutexFree(&index->fileLock);
    }

  }

}

// PT_Index_Delete__New
// file proxy/store.c line 316
static void PT_Index_Delete__New(struct _PT_Index **pindex)
{
  if(!(pindex == ((struct _PT_Index **)NULL)))
  {
    if(!(*pindex == ((struct _PT_Index *)NULL)))
    {
      struct _PT_Index__New *index = &(*pindex)->slots.formatNew;
      if(!(index->zFile == NULL))
      {
        unzClose(index->zFile);
        index->zFile = (void *)0;
      }

      if(!(index->hash == ((struct struct_coucal *)NULL)))
      {
        coucal_delete(&index->hash);
        index->hash = (struct struct_coucal *)(void *)0;
      }

      MutexFree(&index->zFileLock);
    }

  }

}

// PT_Index_Delete__Old
// file proxy/store.c line 332
static void PT_Index_Delete__Old(struct _PT_Index **pindex)
{
  if(!(pindex == ((struct _PT_Index **)NULL)))
  {
    if(!(*pindex == ((struct _PT_Index *)NULL)))
    {
      struct _PT_Index__Old *index = &(*pindex)->slots.formatOld;
      if(!(index->dat == ((struct _IO_FILE *)NULL)))
        fclose(index->dat);

      if(!(index->ndx == ((struct _IO_FILE *)NULL)))
        fclose(index->ndx);

      if(!(index->hash == ((struct struct_coucal *)NULL)))
      {
        coucal_delete(&index->hash);
        index->hash = (struct struct_coucal *)(void *)0;
      }

      MutexFree(&index->fileLock);
    }

  }

}

// PT_Index_HTML_BuildRootInfo
// file proxy/store.h line 97
struct _PT_Element * PT_Index_HTML_BuildRootInfo(struct _PT_Indexes *indexes)
{
  if(!(indexes == ((struct _PT_Indexes *)NULL)))
  {
    struct _PT_Element *elt;
    elt=PT_ElementNew();
    signed int i;
    struct String html = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    do
    {
      html.length_ = (unsigned long int)0;
      do
      {
        const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__1__1__capacity_ = (unsigned long int)(html.length_ + (unsigned long int)0 + (unsigned long int)1);
        while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__1__1__capacity_))
        {
          if(!(html.capacity_ >= 16ul))
            html.capacity_ = (unsigned long int)16;

          else
            html.capacity_ = html.capacity_ * (unsigned long int)2;
          void *return_value_realloc_1;
          return_value_realloc_1=realloc((void *)html.buffer_, html.capacity_);
          html.buffer_ = (char *)return_value_realloc_1;
          /* assertion (html).buffer_ != ((void *)0) */
          assert(html.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      html.buffer_[(signed long int)0] = (char)0;
    }
    while((_Bool)0);
    do
    {
      const char * const PT_Index_HTML_BuildRootInfo__1__1__2__str__ = "<html><!-- Generated by ProxyTrack 0.5 -->\r\n<!-- This is an add-on for HTTrack 3.48.21 -->\r\n<!-- Start Disable IE Friendly HTTP Error Messages -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- End Disable IE Friendly HTTP Error Messages -->\r\n<head>\r\n<title>ProxyTrack 0.5 Catalog</title></head>\r\n<body>\r\n<h3>Available sites in this cache:</h3><br /><br />";
      if(!(PT_Index_HTML_BuildRootInfo__1__1__2__str__ == ((const char *)NULL)))
      {
        unsigned long int PT_Index_HTML_BuildRootInfo__1__1__2__1__size__;
        PT_Index_HTML_BuildRootInfo__1__1__2__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__2__str__);
        do
        {
          const char *PT_Index_HTML_BuildRootInfo__1__1__2__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__2__str__;
          const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__2__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__2__1__size__;
          do
          {
            const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__2__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__2__1__1__size_mc_ + (unsigned long int)1);
            while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__2__1__1__1__capacity_))
            {
              if(!(html.capacity_ >= 16ul))
                html.capacity_ = (unsigned long int)16;

              else
                html.capacity_ = html.capacity_ * (unsigned long int)2;
              void *return_value_realloc_2;
              return_value_realloc_2=realloc((void *)html.buffer_, html.capacity_);
              html.buffer_ = (char *)return_value_realloc_2;
              /* assertion (html).buffer_ != ((void *)0) */
              assert(html.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(PT_Index_HTML_BuildRootInfo__1__1__2__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__2__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__2__1__1__size_mc_);
            html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__2__1__1__size_mc_;
          }

          html.buffer_[(signed long int)html.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    do
    {
      const char * const PT_Index_HTML_BuildRootInfo__1__1__3__str__ = "<ul>\r\n";
      if(!(PT_Index_HTML_BuildRootInfo__1__1__3__str__ == ((const char *)NULL)))
      {
        unsigned long int PT_Index_HTML_BuildRootInfo__1__1__3__1__size__;
        PT_Index_HTML_BuildRootInfo__1__1__3__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__3__str__);
        do
        {
          const char *PT_Index_HTML_BuildRootInfo__1__1__3__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__3__str__;
          const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__3__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__3__1__size__;
          do
          {
            const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__3__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__3__1__1__size_mc_ + (unsigned long int)1);
            while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__3__1__1__1__capacity_))
            {
              if(!(html.capacity_ >= 16ul))
                html.capacity_ = (unsigned long int)16;

              else
                html.capacity_ = html.capacity_ * (unsigned long int)2;
              void *return_value_realloc_3;
              return_value_realloc_3=realloc((void *)html.buffer_, html.capacity_);
              html.buffer_ = (char *)return_value_realloc_3;
              /* assertion (html).buffer_ != ((void *)0) */
              assert(html.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(PT_Index_HTML_BuildRootInfo__1__1__3__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__3__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__3__1__1__size_mc_);
            html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__3__1__1__size_mc_;
          }

          html.buffer_[(signed long int)html.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= indexes->index_size); i = i + 1)
      if(!(indexes->index[(signed long int)i] == ((struct _PT_Index *)NULL)))
      {
        if(!((signed int)indexes->index[(signed long int)i]->slots.common.startUrl[0l] == 0))
        {
          const char *url = indexes->index[(signed long int)i]->slots.common.startUrl;
          do
          {
            const char * const PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__str__ = "<li>\r\n";
            if(!(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__str__ == ((const char *)NULL)))
            {
              unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__size__;
              PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__str__);
              do
              {
                const char *PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__str__;
                const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__size__;
                do
                {
                  const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_4;
                    return_value_realloc_4=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_4;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__size_mc_);
                  html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__1__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__str__ = "<a href=\"";
            if(!(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__str__ == ((const char *)NULL)))
            {
              unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__size__;
              PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__str__);
              do
              {
                const char *PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__str__;
                const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__size__;
                do
                {
                  const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_5;
                    return_value_realloc_5=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_5;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__size_mc_);
                  html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__2__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__str__ = url;
            if(!(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__str__ == ((const char *)NULL)))
            {
              unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__size__;
              PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__str__);
              do
              {
                const char *PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__str__;
                const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__size__;
                do
                {
                  const unsigned long int capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_6;
                    return_value_realloc_6=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_6;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__size_mc_);
                  html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__3__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const str__ = "\">";
            if(!(str__ == ((const char *)NULL)))
            {
              unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__size__;
              PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__size__=strlen(str__);
              do
              {
                const char *PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__str_mc_ = str__;
                const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__size__;
                do
                {
                  const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_7;
                    return_value_realloc_7=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_7;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__size_mc_);
                  html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__4__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__str__ = url;
            if(!(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__str__ == ((const char *)NULL)))
            {
              unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__size__;
              PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__str__);
              do
              {
                const char *PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__str__;
                const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__size__;
                do
                {
                  const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_8;
                    return_value_realloc_8=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_8;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__size_mc_);
                  html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__5__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__str__ = "</a>\r\n";
            if(!(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__str__ == ((const char *)NULL)))
            {
              unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__size__;
              PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__str__);
              do
              {
                const char *PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__str__;
                const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__size__;
                do
                {
                  const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_9;
                    return_value_realloc_9=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_9;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__size_mc_);
                  html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__4__1__1__6__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const PT_Index_HTML_BuildRootInfo__1__1__4__1__1__7__str__ = "</li>\r\n";
            if(!(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__7__str__ == ((const char *)NULL)))
            {
              unsigned long int size__;
              size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__4__1__1__7__str__);
              do
              {
                const char *str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__4__1__1__7__str__;
                const unsigned long int size_mc_ = (unsigned long int)size__;
                do
                {
                  const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__4__1__1__7__1__1__1__capacity_ = (unsigned long int)(html.length_ + size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__4__1__1__7__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_10;
                    return_value_realloc_10=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_10;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)str_mc_, size_mc_);
                  html.length_ = html.length_ + size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
        }

      }

    do
    {
      const char * const PT_Index_HTML_BuildRootInfo__1__1__5__str__ = "</ul>\r\n";
      if(!(PT_Index_HTML_BuildRootInfo__1__1__5__str__ == ((const char *)NULL)))
      {
        unsigned long int PT_Index_HTML_BuildRootInfo__1__1__5__1__size__;
        PT_Index_HTML_BuildRootInfo__1__1__5__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__5__str__);
        do
        {
          const char *PT_Index_HTML_BuildRootInfo__1__1__5__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__5__str__;
          const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__5__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__5__1__size__;
          do
          {
            const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__5__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__5__1__1__size_mc_ + (unsigned long int)1);
            while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__5__1__1__1__capacity_))
            {
              if(!(html.capacity_ >= 16ul))
                html.capacity_ = (unsigned long int)16;

              else
                html.capacity_ = html.capacity_ * (unsigned long int)2;
              void *return_value_realloc_11;
              return_value_realloc_11=realloc((void *)html.buffer_, html.capacity_);
              html.buffer_ = (char *)return_value_realloc_11;
              /* assertion (html).buffer_ != ((void *)0) */
              assert(html.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(PT_Index_HTML_BuildRootInfo__1__1__5__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__5__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__5__1__1__size_mc_);
            html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__5__1__1__size_mc_;
          }

          html.buffer_[(signed long int)html.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    do
    {
      const char * const PT_Index_HTML_BuildRootInfo__1__1__6__str__ = "</body></html>\r\n";
      if(!(PT_Index_HTML_BuildRootInfo__1__1__6__str__ == ((const char *)NULL)))
      {
        unsigned long int PT_Index_HTML_BuildRootInfo__1__1__6__1__size__;
        PT_Index_HTML_BuildRootInfo__1__1__6__1__size__=strlen(PT_Index_HTML_BuildRootInfo__1__1__6__str__);
        do
        {
          const char *PT_Index_HTML_BuildRootInfo__1__1__6__1__1__str_mc_ = PT_Index_HTML_BuildRootInfo__1__1__6__str__;
          const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__6__1__1__size_mc_ = (unsigned long int)PT_Index_HTML_BuildRootInfo__1__1__6__1__size__;
          do
          {
            const unsigned long int PT_Index_HTML_BuildRootInfo__1__1__6__1__1__1__capacity_ = (unsigned long int)(html.length_ + PT_Index_HTML_BuildRootInfo__1__1__6__1__1__size_mc_ + (unsigned long int)1);
            while(!(html.capacity_ >= PT_Index_HTML_BuildRootInfo__1__1__6__1__1__1__capacity_))
            {
              if(!(html.capacity_ >= 16ul))
                html.capacity_ = (unsigned long int)16;

              else
                html.capacity_ = html.capacity_ * (unsigned long int)2;
              void *return_value_realloc_12;
              return_value_realloc_12=realloc((void *)html.buffer_, html.capacity_);
              html.buffer_ = (char *)return_value_realloc_12;
              /* assertion (html).buffer_ != ((void *)0) */
              assert(html.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(PT_Index_HTML_BuildRootInfo__1__1__6__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)PT_Index_HTML_BuildRootInfo__1__1__6__1__1__str_mc_, PT_Index_HTML_BuildRootInfo__1__1__6__1__1__size_mc_);
            html.length_ = html.length_ + PT_Index_HTML_BuildRootInfo__1__1__6__1__1__size_mc_;
          }

          html.buffer_[(signed long int)html.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    elt->size = html.length_;
    elt->adr=StringAcquire_link1(&html);
    elt->statuscode = 200;
    strcpy(elt->charset, "iso-8859-1");
    strcpy(elt->contenttype, "text/html");
    strcpy(elt->msg, "OK");
    do
    {
      if(!(html.buffer_ == ((char *)NULL)))
      {
        free((void *)html.buffer_);
        html.buffer_ = (char *)(void *)0;
      }

      html.capacity_ = (unsigned long int)0;
      html.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    return elt;
  }

  return (struct _PT_Element *)(void *)0;
}

// PT_Index_Timestamp
// file proxy/store.h line 110
signed long int PT_Index_Timestamp(struct _PT_Index *index)
{
  return index->slots.common.timestamp;
}

// PT_LoadCache
// file proxy/store.c line 546
struct _PT_Index * PT_LoadCache(const char *filename)
{
  signed int type;
  type=PT_GetType(filename);
  char *return_value_strstr_3;
  if(!(type == -1))
  {
    struct _PT_Index *index;
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct _PT_Index) /*6224ul*/ , (unsigned long int)1);
    index = (struct _PT_Index *)return_value_calloc_1;
    if(!(index == ((struct _PT_Index *)NULL)))
    {
      index->type = type;
      signed long int return_value_time_2;
      return_value_time_2=time((signed long int *)(void *)0);
      index->slots.common.timestamp = (signed long int)return_value_time_2;
      index->slots.common.startUrl[(signed long int)0] = (char)0;
      index->slots.common.hash=coucal_new((unsigned long int)0);
      coucal_set_name(index->slots.common.hash, (const void *)"index->slots.common.hash");
      signed int return_value;
      return_value=_IndexFuncts[(signed long int)type].PT_LoadCache(index, filename);
      if(return_value == 0)
      {
        proxytrack_print_log_link1((const char *)(void *)0, "reading httrack cache (format #%d) %s : error", type, filename);
        free((void *)index);
        index = (struct _PT_Index *)(void *)0;
        return (struct _PT_Index *)(void *)0;
      }

      else
        proxytrack_print_log_link1((const char *)(void *)0, "reading httrack cache (format #%d) %s : success", type, filename);
      if((signed int)index->slots.common.startUrl[0l] == 0)
      {
        struct struct_coucal_enum en;
        en=coucal_enum_new(index->slots.common.hash);
        struct coucal_item *chain;
        chain=coucal_enum_next(&en);
        if(!(chain == ((struct coucal_item *)NULL)))
        {
          return_value_strstr_3=strstr((const char *)chain->name, "/robots.txt");
          if(!(return_value_strstr_3 == ((char *)NULL)))
            chain=coucal_enum_next(&en);

        }

        if(!(chain == ((struct coucal_item *)NULL)))
        {
          signed int return_value_link_has_authority_4;
          return_value_link_has_authority_4=link_has_authority_link1((const char *)chain->name);
          if(return_value_link_has_authority_4 == 0)
            strcat(index->slots.common.startUrl, "http://");

          strcat(index->slots.common.startUrl, (const char *)chain->name);
        }

      }

    }

    return index;
  }

  return (struct _PT_Index *)(void *)0;
}

// PT_LoadCache__Arc
// file proxy/store.c line 1995
static signed int PT_LoadCache__Arc(struct _PT_Index *index_, const char *filename)
{
  _Bool tmp_if_expr_4;
  signed int return_value_skipArcNl_3;
  signed int return_value_feof_5;
  _Bool tmp_if_expr_12;
  signed int return_value_readArcURLRecord_11;
  if(!(filename == ((const char *)NULL)) && !(index_ == ((struct _PT_Index *)NULL)))
  {
    struct _PT_Index__Arc *index = &index_->slots.formatArc;
    index->timestamp=file_timestamp(filename);
    MutexInit(&index->fileLock);
    index->file=fopen(filename, "rb");
    if(!(index->file == ((struct _IO_FILE *)NULL)))
    {
      struct struct_coucal *hashtable = index->hash;
      signed int return_value_readArcURLRecord_13;
      return_value_readArcURLRecord_13=readArcURLRecord(index);
      if(return_value_readArcURLRecord_13 == 0)
      {
        signed int entries = 0;
        signed int return_value_strncmp_1;
        return_value_strncmp_1=strncmp(index->line, "filedesc://", sizeof(char [12l]) /*12ul*/  - (unsigned long int)1);
        if(!(return_value_strncmp_1 == 0))
        {
          fprintf(stderr, "Unexpected bad signature #%s\n", (const void *)index->line);
          fclose(index->file);
          index->file = (struct _IO_FILE *)(void *)0;
          return 0;
        }

        index->timestamp=getArcTimestamp(index->line);
        signed int return_value_skipArcData_2;
        return_value_skipArcData_2=skipArcData(index->file, index->line);
        if(!(return_value_skipArcData_2 == 0))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_skipArcNl_3=skipArcNl(index->file);
          tmp_if_expr_4 = return_value_skipArcNl_3 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          fprintf(stderr, "Unexpected bad data offset size first entry\n");
          fclose(index->file);
          index->file = (struct _IO_FILE *)(void *)0;
          return 0;
        }

        do
        {
          return_value_feof_5=feof(index->file);
          if(!(return_value_feof_5 == 0))
            break;

          unsigned long int fpos;
          signed long int return_value_ftell_6;
          return_value_ftell_6=ftell(index->file);
          fpos = (unsigned long int)return_value_ftell_6;
          signed int return_value_skipArcNl_10;
          return_value_skipArcNl_10=skipArcNl(index->file);
          if(return_value_skipArcNl_10 == 0)
          {
            return_value_readArcURLRecord_11=readArcURLRecord(index);
            tmp_if_expr_12 = return_value_readArcURLRecord_11 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_12 = (_Bool)0;
          if(tmp_if_expr_12)
          {
            signed int length;
            length=getArcLength(index->line);
            if(length >= 0)
            {
              const char *filenameIndex;
              filenameIndex=copyArcField(index->line, 0, index->filenameIndexBuff, (signed int)(sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)1));
              signed int return_value_strncmp_7;
              return_value_strncmp_7=strncmp(filenameIndex, "http://", (unsigned long int)7);
              if(return_value_strncmp_7 == 0)
                filenameIndex = filenameIndex + (signed long int)7;

              if(!((signed int)*filenameIndex == 0))
              {
                signed int return_value_skipArcData_8;
                return_value_skipArcData_8=skipArcData(index->file, index->line);
                if(!(return_value_skipArcData_8 == 0))
                  fprintf(stderr, "Corrupted cache data entry #%d (truncated file?), aborting read\n", (signed int)entries);

                signed int return_value_PT_CompatibleScheme_9;
                return_value_PT_CompatibleScheme_9=PT_CompatibleScheme(index->filenameIndexBuff);
                if(!(return_value_PT_CompatibleScheme_9 == 0))
                {
                  coucal_add(hashtable, (const void *)filenameIndex, (signed long int)fpos);
                  entries = entries + 1;
                }

              }

              else
                fprintf(stderr, "Corrupted cache meta entry #%d\n", (signed int)entries);
            }

            else
            {
              fprintf(stderr, "Corrupted cache meta entry #%d, aborting read\n", (signed int)entries);
              break;
            }
          }

          else
            break;
        }
        while((_Bool)1);
        return 1;
      }

      else
        fprintf(stderr, "Bad file (empty ?)\n");
    }

    else
    {
      fprintf(stderr, "Unable to open file\n");
      index = (struct _PT_Index__Arc *)(void *)0;
    }
  }

  else
    fprintf(stderr, "Bad arguments\n");
  return 0;
}

// PT_LoadCache__New
// file proxy/store.c line 881
static signed int PT_LoadCache__New(struct _PT_Index *index_, const char *filename)
{
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_15;
  signed int return_value_unzGetCurrentFileInfo_14;
  signed int tmp_post_8;
  signed int return_value_unzGoToNextFile_5;
  if(!(filename == ((const char *)NULL)) && !(index_ == ((struct _PT_Index *)NULL)))
  {
    struct _PT_Index__New *index = &index_->slots.formatNew;
    void *zFile;
    index->zFile=unzOpen(filename);
    zFile = index->zFile;
    index->timestamp=file_timestamp(filename);
    MutexInit(&index->zFileLock);
    if(!(zFile == NULL))
    {
      const char *abpath;
      signed int slashes;
      struct struct_coucal *hashtable = index->hash;
      slashes = 2;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(filename);
      abpath = (filename + (signed long int)(signed int)return_value_strlen_1) - (signed long int)1;
      do
      {
        if(!(filename >= abpath))
        {
          if(!((signed int)*abpath == 47))
            tmp_if_expr_2 = (signed int)*abpath != 92 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            slashes = slashes - 1;
            tmp_if_expr_3 = slashes > 0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        abpath = abpath - 1l;
      }
      while((_Bool)1);
      index->path[(signed long int)0] = (char)0;
      if(slashes == 0)
      {
        if(!((signed int)*abpath == 0))
        {
          signed int i;
          strncat(index->path, filename, (unsigned long int)((signed int)(abpath - filename) + 1));
          i = 0;
          for( ; !((signed int)index->path[(signed long int)i] == 0); i = i + 1)
            if((signed int)index->path[(signed long int)i] == 92)
              index->path[(signed long int)i] = (char)47;

        }

      }

      signed int return_value_unzGoToFirstFile_17;
      return_value_unzGoToFirstFile_17=unzGoToFirstFile(zFile);
      if(return_value_unzGoToFirstFile_17 == 0)
      {
        char comment[128l];
        char PT_LoadCache__New__1__1__1__3__filename[4096l];
        signed int entries = 0;
        signed int firstSeen = 0;
        memset((void *)comment, 0, sizeof(char [128l]) /*128ul*/ );
        do
        {
          signed int readSizeHeader = 0;
          PT_LoadCache__New__1__1__1__3__filename[(signed long int)0] = (char)0;
          comment[(signed long int)0] = (char)0;
          signed int return_value_unzOpenCurrentFile_16;
          return_value_unzOpenCurrentFile_16=unzOpenCurrentFile(zFile);
          if(return_value_unzOpenCurrentFile_16 == 0)
          {
            readSizeHeader=unzGetLocalExtrafield(zFile, (void *)comment, (unsigned int)(sizeof(char [128l]) /*128ul*/  - (unsigned long int)2));
            if(readSizeHeader >= 1)
            {
              return_value_unzGetCurrentFileInfo_14=unzGetCurrentFileInfo(zFile, (struct unz_file_info_s *)(void *)0, PT_LoadCache__New__1__1__1__3__filename, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)2, (void *)0, (unsigned long int)0, (char *)(void *)0, (unsigned long int)0);
              tmp_if_expr_15 = return_value_unzGetCurrentFileInfo_14 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_15 = (_Bool)0;
            if(tmp_if_expr_15)
            {
              signed long int pos;
              unsigned long int return_value_unzGetOffset_6;
              return_value_unzGetOffset_6=unzGetOffset(zFile);
              pos = (signed long int)return_value_unzGetOffset_6;
              if(!((unsigned long int)readSizeHeader >= sizeof(char [128l]) /*128ul*/ ))
                (_Bool)1;

              else
              {
                abortf__link1("readSizeHeader < sizeof(comment)", "proxy/store.c", 933);
                (_Bool)0;
              }
              comment[(signed long int)readSizeHeader] = (char)0;
              entries = entries + 1;
              if(pos >= 1l)
              {
                signed int dataincache = 0;
                char *filenameIndex = PT_LoadCache__New__1__1__1__3__filename;
                signed int return_value_strncmp_7;
                return_value_strncmp_7=strncmp(filenameIndex, "http://", (unsigned long int)7);
                if(return_value_strncmp_7 == 0)
                  filenameIndex = filenameIndex + (signed long int)7;

                if(!((signed int)comment[0l] == 0))
                {
                  signed int maxLine = 2;
                  char *a = comment;
                  while(!(*a == 0))
                  {
                    tmp_post_8 = maxLine;
                    maxLine = maxLine - 1;
                    if(!(tmp_post_8 >= 1))
                      break;

                    char line[1024l];
                    line[(signed long int)0] = (char)0;
                    signed int return_value_binput_9;
                    return_value_binput_9=binput(a, line, (signed int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)2));
                    a = a + (signed long int)return_value_binput_9;
                    signed int return_value_strncmp_11;
                    return_value_strncmp_11=strncmp(line, "X-In-Cache:", (unsigned long int)11);
                    if(return_value_strncmp_11 == 0)
                    {
                      signed int return_value_strcmp_10;
                      return_value_strcmp_10=strcmp(line, "X-In-Cache: 1");
                      if(return_value_strcmp_10 == 0)
                        dataincache = 1;

                      else
                        dataincache = 0;
                      break;
                    }

                  }
                }

                if(!(dataincache == 0))
                  coucal_add(hashtable, (const void *)filenameIndex, pos);

                else
                  coucal_add(hashtable, (const void *)filenameIndex, -pos);
                if(firstSeen == 0)
                {
                  char *return_value_strstr_13;
                  return_value_strstr_13=strstr(filenameIndex, "/robots.txt");
                  if(return_value_strstr_13 == ((char *)NULL))
                  {
                    firstSeen = 1;
                    signed int return_value_link_has_authority_12;
                    return_value_link_has_authority_12=link_has_authority_link1(filenameIndex);
                    if(return_value_link_has_authority_12 == 0)
                      strcat(index->startUrl, "http://");

                    strcat(index->startUrl, filenameIndex);
                  }

                }

              }

              else
                fprintf(stderr, "Corrupted cache meta entry #%d\n", (signed int)entries);
            }

            else
              fprintf(stderr, "Corrupted cache entry #%d\n", (signed int)entries);
            unzCloseCurrentFile(zFile);
          }

          else
            fprintf(stderr, "Corrupted cache entry #%d\n", (signed int)entries);
          return_value_unzGoToNextFile_5=unzGoToNextFile(zFile);
        }
        while(return_value_unzGoToNextFile_5 == 0);
        return 1;
      }

      else
      {
        coucal_delete(&index->hash);
        index = (struct _PT_Index__New *)(void *)0;
      }
    }

    else
      index = (struct _PT_Index__New *)(void *)0;
  }

  return 0;
}

// PT_LoadCache__Old
// file proxy/store.c line 1422
static signed int PT_LoadCache__Old(struct _PT_Index *index_, const char *filename)
{
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(!(filename == ((const char *)NULL)) && !(index_ == ((struct _PT_Index *)NULL)))
  {
    char *PT_LoadCache__Old__1__1__pos;
    PT_LoadCache__Old__1__1__pos=strrchr(filename, 46);
    struct _PT_Index__Old *cache = &index_->slots.formatOld;
    signed long int ndxSize;
    cache->filenameDat[(signed long int)0] = (char)0;
    cache->filenameNdx[(signed long int)0] = (char)0;
    cache->path[(signed long int)0] = (char)0;
    struct _PT_Index__Old *PT_LoadCache__Old__1__1__1__index = cache;
    const char *abpath;
    signed int slashes = 2;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(filename);
    abpath = (filename + (signed long int)(signed int)return_value_strlen_1) - (signed long int)1;
    do
    {
      if(!(filename >= abpath))
      {
        if(!((signed int)*abpath == 47))
          tmp_if_expr_2 = (signed int)*abpath != 92 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          slashes = slashes - 1;
          tmp_if_expr_3 = slashes > 0 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!tmp_if_expr_4)
        break;

      abpath = abpath - 1l;
    }
    while((_Bool)1);
    PT_LoadCache__Old__1__1__1__index->path[(signed long int)0] = (char)0;
    if(slashes == 0)
    {
      if(!((signed int)*abpath == 0))
      {
        signed int i;
        strncat(PT_LoadCache__Old__1__1__1__index->path, filename, (unsigned long int)((signed int)(abpath - filename) + 1));
        i = 0;
        for( ; !((signed int)PT_LoadCache__Old__1__1__1__index->path[(signed long int)i] == 0); i = i + 1)
          if((signed int)PT_LoadCache__Old__1__1__1__index->path[(signed long int)i] == 92)
            PT_LoadCache__Old__1__1__1__index->path[(signed long int)i] = (char)47;

      }

    }

    if(!(PT_LoadCache__Old__1__1__pos == ((char *)NULL)))
    {
      signed int nLen = (signed int)(PT_LoadCache__Old__1__1__pos - filename);
      strncat(cache->filenameDat, filename, (unsigned long int)nLen);
      strncat(cache->filenameNdx, filename, (unsigned long int)nLen);
      strcat(cache->filenameDat, ".dat");
      strcat(cache->filenameNdx, ".ndx");
    }

    ndxSize=filesize(cache->filenameNdx);
    cache->timestamp=file_timestamp(cache->filenameDat);
    cache->dat=fopen(cache->filenameDat, "rb");
    cache->ndx=fopen(cache->filenameNdx, "rb");
    if(!(cache->dat == ((struct _IO_FILE *)NULL)))
    {
      if(!(cache->ndx == ((struct _IO_FILE *)NULL)))
      {
        if(ndxSize >= 1l)
        {
          char *use;
          void *return_value_malloc_5;
          return_value_malloc_5=malloc((unsigned long int)(ndxSize + (signed long int)1));
          use = (char *)return_value_malloc_5;
          unsigned long int return_value_fread_16;
          return_value_fread_16=fread((void *)use, (unsigned long int)1, (unsigned long int)ndxSize, cache->ndx);
          if(return_value_fread_16 == (unsigned long int)ndxSize)
          {
            char firstline[256l];
            char *a = use;
            use[ndxSize] = (char)0;
            signed int return_value_cache_brstr_6;
            return_value_cache_brstr_6=cache_brstr(a, firstline);
            a = a + (signed long int)return_value_cache_brstr_6;
            signed int return_value_strncmp_9;
            return_value_strncmp_9=strncmp(firstline, "CACHE-", (unsigned long int)6);
            if(return_value_strncmp_9 == 0)
            {
              signed int return_value_strncmp_8;
              return_value_strncmp_8=strncmp(firstline, "CACHE-1.", (unsigned long int)8);
              if(return_value_strncmp_8 == 0)
              {
                cache->version = (signed int)((signed int)firstline[(signed long int)8] - 48);
                if(!(cache->version >= 6))
                {
                  signed int return_value_cache_brstr_7;
                  return_value_cache_brstr_7=cache_brstr(a, firstline);
                  a = a + (signed long int)return_value_cache_brstr_7;
                  strcpy(cache->lastmodified, firstline);
                }

                else
                {
                  fclose(cache->dat);
                  cache->dat = (struct _IO_FILE *)(void *)0;
                  free((void *)use);
                  use = (char *)(void *)0;
                }
              }

              else
              {
                fclose(cache->dat);
                cache->dat = (struct _IO_FILE *)(void *)0;
                free((void *)use);
                use = (char *)(void *)0;
              }
            }

            else
            {
              cache->version = 0;
              strcpy(cache->lastmodified, firstline);
            }
            if(!(use == ((char *)NULL)))
            {
              char line[2048l];
              char linepos[256l];
              signed int pos;
              signed int firstSeen = 0;
              while(!(a == ((char *)NULL)) && !(a >= use + ndxSize))
              {
                a=strchr(a + (signed long int)1, 10);
                if(!(a == ((char *)NULL)))
                {
                  a = a + 1l;
                  signed int return_value_binput_10;
                  return_value_binput_10=binput(a, line, 1024);
                  a = a + (signed long int)return_value_binput_10;
                  unsigned long int return_value_strlen_11;
                  return_value_strlen_11=strlen(line);
                  signed int return_value_binput_12;
                  return_value_binput_12=binput(a, line + (signed long int)return_value_strlen_11, 1024);
                  a = a + (signed long int)return_value_binput_12;
                  signed int return_value_binput_13;
                  return_value_binput_13=binput(a, linepos, 200);
                  a = a + (signed long int)return_value_binput_13;
                  sscanf(linepos, "%d", &pos);
                  coucal_add(cache->hash, (const void *)line, (signed long int)pos);
                  if(firstSeen == 0)
                  {
                    char *return_value_strstr_15;
                    return_value_strstr_15=strstr(line, "/robots.txt");
                    if(return_value_strstr_15 == ((char *)NULL))
                    {
                      struct _PT_Index__Old *index = cache;
                      firstSeen = 1;
                      signed int return_value_link_has_authority_14;
                      return_value_link_has_authority_14=link_has_authority_link1(line);
                      if(return_value_link_has_authority_14 == 0)
                        strcat(index->startUrl, "http://");

                      strcat(index->startUrl, line);
                    }

                  }

                }

              }
              free((void *)use);
              use = (char *)(void *)0;
              return 1;
            }

          }

        }

      }

    }

  }

  return 0;
}

// PT_LookupCache
// file proxy/store.c line 601
signed int PT_LookupCache(struct _PT_Index *index, const char *url)
{
  signed int return_value_PT_Index_Check___1;
  if(!(index == ((struct _PT_Index *)NULL)))
  {
    return_value_PT_Index_Check___1=PT_Index_Check__(index, "proxy/store.c", 602);
    if(!(return_value_PT_Index_Check___1 == 0))
    {
      signed int return_value;
      return_value=_IndexFuncts[(signed long int)index->type].PT_LookupCache(index, url);
      return return_value;
    }

  }

  return 0;
}

// PT_LookupCache__Arc
// file proxy/store.c line 2250
static signed int PT_LookupCache__Arc(struct _PT_Index *index, const char *url)
{
  signed int retCode;
  MutexLock(&index->slots.formatArc.fileLock);
  retCode=PT_LookupCache__Arc_u(index, url);
  MutexUnlock(&index->slots.formatArc.fileLock);
  return retCode;
}

// PT_LookupCache__Arc_u
// file proxy/store.c line 2261
static signed int PT_LookupCache__Arc_u(struct _PT_Index *index_, const char *url)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(index_ == ((struct _PT_Index *)NULL)))
  {
    struct _PT_Index__New *cache = (struct _PT_Index__New *)&index_->slots.formatNew;
    if(cache == ((struct _PT_Index__New *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = cache->hash == (struct struct_coucal *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(url == ((const char *)NULL) || tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)*url == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(url, "http://", (unsigned long int)7);
    if(return_value_strncmp_3 == 0)
      url = url + (signed long int)7;

    signed int return_value_coucal_read_4;
    return_value_coucal_read_4=coucal_read(cache->hash, (const void *)url, (signed long int *)(void *)0);
    if(!(return_value_coucal_read_4 == 0))
      return 1;

  }

  return 0;
}

// PT_LookupCache__New
// file proxy/store.c line 660
static signed int PT_LookupCache__New(struct _PT_Index *index, const char *url)
{
  signed int retCode;
  MutexLock(&index->slots.formatNew.zFileLock);
  retCode=PT_LookupCache__New_u(index, url);
  MutexUnlock(&index->slots.formatNew.zFileLock);
  return retCode;
}

// PT_LookupCache__New_u
// file proxy/store.c line 671
static signed int PT_LookupCache__New_u(struct _PT_Index *index_, const char *url)
{
  if(!(index_ == ((struct _PT_Index *)NULL)))
  {
    struct _PT_Index__New *index = &index_->slots.formatNew;
    if(!(index->hash == ((struct struct_coucal *)NULL)))
    {
      if(!(index->zFile == NULL))
      {
        if(!(url == ((const char *)NULL)))
        {
          if(!((signed int)*url == 0))
          {
            signed int hash_pos_return;
            signed int return_value_strncmp_1;
            return_value_strncmp_1=strncmp(url, "http://", (unsigned long int)7);
            if(return_value_strncmp_1 == 0)
              url = url + (signed long int)7;

            hash_pos_return=coucal_read(index->hash, (const void *)url, (signed long int *)(void *)0);
            if(!(hash_pos_return == 0))
              return 1;

          }

        }

      }

    }

  }

  return 0;
}

// PT_LookupCache__Old
// file proxy/store.c line 1832
static signed int PT_LookupCache__Old(struct _PT_Index *index, const char *url)
{
  signed int retCode;
  MutexLock(&index->slots.formatOld.fileLock);
  retCode=PT_LookupCache__Old_u(index, url);
  MutexUnlock(&index->slots.formatOld.fileLock);
  return retCode;
}

// PT_LookupCache__Old_u
// file proxy/store.c line 1843
static signed int PT_LookupCache__Old_u(struct _PT_Index *index_, const char *url)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(index_ == ((struct _PT_Index *)NULL)))
  {
    struct _PT_Index__New *cache = (struct _PT_Index__New *)&index_->slots.formatNew;
    if(cache == ((struct _PT_Index__New *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = cache->hash == (struct struct_coucal *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(url == ((const char *)NULL) || tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)*url == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(url, "http://", (unsigned long int)7);
    if(return_value_strncmp_3 == 0)
      url = url + (signed long int)7;

    signed int return_value_coucal_read_4;
    return_value_coucal_read_4=coucal_read(cache->hash, (const void *)url, (signed long int *)(void *)0);
    if(!(return_value_coucal_read_4 == 0))
      return 1;

  }

  return 0;
}

// PT_LookupIndex
// file proxy/store.h line 89
signed int PT_LookupIndex(struct _PT_Indexes *indexes, const char *url)
{
  _Bool tmp_if_expr_2;
  if(!(indexes == ((struct _PT_Indexes *)NULL)))
  {
    signed long int index_id;
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(url, "http://", (unsigned long int)7);
    if(return_value_strncmp_1 == 0)
      url = url + (signed long int)7;

    signed int return_value_coucal_read_3;
    return_value_coucal_read_3=coucal_read(indexes->cil, (const void *)url, &index_id);
    if(!(return_value_coucal_read_3 == 0))
    {
      if(index_id >= 0l)
        tmp_if_expr_2 = index_id <= (signed long int)indexes->index_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        return 1;

      else
        proxytrack_print_log_link1("critical", "PT_ReadCache:Corrupted central index locator");
    }

  }

  return 0;
}

// PT_New
// file proxy/store.h line 86
struct _PT_Indexes * PT_New(void)
{
  struct _PT_Indexes *index;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct _PT_Indexes) /*24ul*/ , (unsigned long int)1);
  index = (struct _PT_Indexes *)return_value_calloc_1;
  index->cil=coucal_new((unsigned long int)0);
  coucal_set_name(index->cil, (const void *)"index->cil");
  index->index_size = 0;
  index->index = (struct _PT_Index **)(void *)0;
  return index;
}

// PT_ReadCache
// file proxy/store.c line 828
struct _PT_Element * PT_ReadCache(struct _PT_Index *index, const char *url, signed int flags)
{
  signed int return_value_PT_Index_Check___1;
  if(!(index == ((struct _PT_Index *)NULL)))
  {
    return_value_PT_Index_Check___1=PT_Index_Check__(index, "proxy/store.c", 829);
    if(!(return_value_PT_Index_Check___1 == 0))
    {
      struct _PT_Element *return_value;
      return_value=_IndexFuncts[(signed long int)index->type].PT_ReadCache(index, url, flags);
      return return_value;
    }

  }

  return (struct _PT_Element *)(void *)0;
}

// PT_ReadCache__Arc
// file proxy/store.c line 2097
static struct _PT_Element * PT_ReadCache__Arc(struct _PT_Index *index, const char *url, signed int flags)
{
  struct _PT_Element *retCode;
  MutexLock(&index->slots.formatArc.fileLock);
  retCode=PT_ReadCache__Arc_u(index, url, flags);
  MutexUnlock(&index->slots.formatArc.fileLock);
  return retCode;
}

// PT_ReadCache__Arc_u
// file proxy/store.c line 2108
static struct _PT_Element * PT_ReadCache__Arc_u(struct _PT_Index *index_, const char *url, signed int flags)
{
  struct _PT_Index__Arc *index = (struct _PT_Index__Arc *)&index_->slots.formatArc;
  char location_default[2048l];
  signed long int hash_pos;
  signed int hash_pos_return;
  struct _PT_Element *r = (struct _PT_Element *)(void *)0;
  _Bool tmp_if_expr_1;
  if(index == ((struct _PT_Index__Arc *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = index->hash == (struct struct_coucal *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(url == ((const char *)NULL) || tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)*url == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_43;
  signed int return_value_readArcURLRecord_42;
  signed int return_value_linput_5;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_strlen_7;
  unsigned long int return_value_strlen_8;
  signed int tmp_if_expr_10;
  signed int return_value_strfield_9;
  unsigned long int return_value_strlen_11;
  unsigned long int return_value_strlen_12;
  signed int tmp_if_expr_14;
  signed int return_value_strfield_13;
  unsigned long int return_value_strlen_15;
  unsigned long int return_value_strlen_16;
  signed int tmp_if_expr_18;
  signed int return_value_strfield_17;
  unsigned long int return_value_strlen_19;
  unsigned long int return_value_strlen_20;
  signed int tmp_if_expr_22;
  signed int return_value_strfield_21;
  unsigned long int return_value_strlen_23;
  unsigned long int return_value_strlen_24;
  signed int tmp_if_expr_26;
  signed int return_value_strfield_25;
  unsigned long int return_value_strlen_27;
  unsigned long int return_value_strlen_28;
  signed int tmp_if_expr_30;
  signed int return_value_strfield_29;
  signed int tmp_if_expr_32;
  unsigned long int return_value_strlen_31;
  unsigned long int return_value_fread_39;
  if(tmp_if_expr_2)
    return (struct _PT_Element *)(void *)0;

  else
  {
    r=PT_ElementNew();
    if(r == ((struct _PT_Element *)NULL))
      return (struct _PT_Element *)(void *)0;

    else
    {
      location_default[(signed long int)0] = (char)0;
      memset((void *)r, 0, sizeof(struct _PT_Element) /*1576ul*/ );
      r->location = location_default;
      strcpy(r->location, "");
      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(url, "http://", (unsigned long int)7);
      if(return_value_strncmp_3 == 0)
        url = url + (signed long int)7;

      hash_pos_return=coucal_read(index->hash, (const void *)url, &hash_pos);
      if(!(hash_pos_return == 0))
      {
        signed int return_value_fseek_44;
        return_value_fseek_44=fseek(index->file, (signed long int)hash_pos, 0);
        if(return_value_fseek_44 == 0)
        {
          signed int return_value_skipArcNl_41;
          return_value_skipArcNl_41=skipArcNl(index->file);
          if(return_value_skipArcNl_41 == 0)
          {
            return_value_readArcURLRecord_42=readArcURLRecord(index);
            tmp_if_expr_43 = return_value_readArcURLRecord_42 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_43 = (_Bool)0;
          if(tmp_if_expr_43)
          {
            signed long int fposMeta;
            fposMeta=ftell(index->file);
            signed int dataLength;
            dataLength=getArcLength(index->line);
            const char *PT_ReadCache__Arc_u__1__1__1__1__pos;
            signed int return_value_linput_40;
            return_value_linput_40=linput_link1(index->file, index->line, (signed int)(sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)1));
            if(!(return_value_linput_40 == 0))
            {
              PT_ReadCache__Arc_u__1__1__1__1__pos=getArcField(index->line, 1);
              if(!(PT_ReadCache__Arc_u__1__1__1__1__pos == ((const char *)NULL)))
              {
                signed int return_value_sscanf_4;
                return_value_sscanf_4=sscanf(PT_ReadCache__Arc_u__1__1__1__1__pos, "%d", &r->statuscode);
                if(!(return_value_sscanf_4 == 1))
                  r->statuscode = -1;

              }

              PT_ReadCache__Arc_u__1__1__1__1__pos=getArcField(index->line, 2);
              if(!(PT_ReadCache__Arc_u__1__1__1__1__pos == ((const char *)NULL)))
              {
                r->msg[(signed long int)0] = (char)0;
                strncat(r->msg, PT_ReadCache__Arc_u__1__1__1__1__pos, sizeof(const char *) /*8ul*/  - (unsigned long int)1);
              }

              do
              {
                return_value_linput_5=linput_link1(index->file, index->line, (signed int)(sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)1));
                if(return_value_linput_5 == 0)
                  break;

                if((signed int)index->line[0l] == 0)
                  break;

                char * const line = index->line;
                char *value;
                value=strchr(line, 58);
                if(!(value == ((char *)NULL)))
                {
                  *value = (char)0;
                  value = value + 1l;
                  do
                  {
                    if((signed int)*value == 32)
                      tmp_if_expr_6 = (_Bool)1;

                    else
                      tmp_if_expr_6 = (signed int)*value == 9 ? (_Bool)1 : (_Bool)0;
                    if(!tmp_if_expr_6)
                      break;

                    value = value + 1l;
                  }
                  while((_Bool)1);
                  do
                    if(!((signed int)*line == 0))
                    {
                      return_value_strlen_7=strlen(line);
                      return_value_strlen_8=strlen("Content-Length");
                      if(!(return_value_strlen_7 == return_value_strlen_8))
                        tmp_if_expr_10 = 0;

                      else
                      {
                        return_value_strfield_9=strfield_link1(line, "Content-Length");
                        tmp_if_expr_10 = return_value_strfield_9;
                      }
                      if(!(tmp_if_expr_10 == 0))
                      {
                        signed int intval = 0;
                        sscanf(value, "%d", &intval);
                        r->size = (unsigned long int)intval;
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)*line == 0))
                    {
                      return_value_strlen_11=strlen(line);
                      return_value_strlen_12=strlen("Content-Type");
                      if(!(return_value_strlen_11 == return_value_strlen_12))
                        tmp_if_expr_14 = 0;

                      else
                      {
                        return_value_strfield_13=strfield_link1(line, "Content-Type");
                        tmp_if_expr_14 = return_value_strfield_13;
                      }
                      if(!(tmp_if_expr_14 == 0))
                      {
                        strcpy(r->contenttype, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)*line == 0))
                    {
                      return_value_strlen_15=strlen(line);
                      return_value_strlen_16=strlen("Last-Modified");
                      if(!(return_value_strlen_15 == return_value_strlen_16))
                        tmp_if_expr_18 = 0;

                      else
                      {
                        return_value_strfield_17=strfield_link1(line, "Last-Modified");
                        tmp_if_expr_18 = return_value_strfield_17;
                      }
                      if(!(tmp_if_expr_18 == 0))
                      {
                        strcpy(r->lastmodified, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)*line == 0))
                    {
                      return_value_strlen_19=strlen(line);
                      return_value_strlen_20=strlen("Etag");
                      if(!(return_value_strlen_19 == return_value_strlen_20))
                        tmp_if_expr_22 = 0;

                      else
                      {
                        return_value_strfield_21=strfield_link1(line, "Etag");
                        tmp_if_expr_22 = return_value_strfield_21;
                      }
                      if(!(tmp_if_expr_22 == 0))
                      {
                        strcpy(r->etag, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)*line == 0))
                    {
                      return_value_strlen_23=strlen(line);
                      return_value_strlen_24=strlen("Location");
                      if(!(return_value_strlen_23 == return_value_strlen_24))
                        tmp_if_expr_26 = 0;

                      else
                      {
                        return_value_strfield_25=strfield_link1(line, "Location");
                        tmp_if_expr_26 = return_value_strfield_25;
                      }
                      if(!(tmp_if_expr_26 == 0))
                      {
                        strcpy(r->location, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)*line == 0))
                    {
                      return_value_strlen_27=strlen(line);
                      return_value_strlen_28=strlen("Content-Disposition");
                      if(!(return_value_strlen_27 == return_value_strlen_28))
                        tmp_if_expr_30 = 0;

                      else
                      {
                        return_value_strfield_29=strfield_link1(line, "Content-Disposition");
                        tmp_if_expr_30 = return_value_strfield_29;
                      }
                      if(!(tmp_if_expr_30 == 0))
                      {
                        strcpy(r->cdispo, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  if(!((signed int)*line == 0))
                  {
                    signed int len;
                    if(!(r->headers == ((char *)NULL)))
                    {
                      return_value_strlen_31=strlen(r->headers);
                      tmp_if_expr_32 = (signed int)return_value_strlen_31;
                    }

                    else
                      tmp_if_expr_32 = 0;
                    len = tmp_if_expr_32;
                    signed int nlen;
                    unsigned long int return_value_strlen_33;
                    return_value_strlen_33=strlen(line);
                    unsigned long int return_value_strlen_34;
                    return_value_strlen_34=strlen(value);
                    nlen = (signed int)(return_value_strlen_33 + (unsigned long int)2 + return_value_strlen_34 + sizeof(char [3l]) /*3ul*/  + (unsigned long int)1);
                    void *return_value_realloc_35;
                    return_value_realloc_35=realloc((void *)r->headers, (unsigned long int)(len + nlen));
                    r->headers = (char *)return_value_realloc_35;
                    r->headers[(signed long int)len] = (char)0;
                    strcat(r->headers, line);
                    strcat(r->headers, ": ");
                    strcat(r->headers, value);
                    strcat(r->headers, "\r\n");
                  }

                }

              }
              while((_Bool)1);
              if(!((signed int)r->contenttype[0l] == 0))
              {
                char *pos;
                pos=strchr(r->contenttype, 59);
                if(!(pos == ((char *)NULL)))
                {
                  *pos = (char)0;
                  pos=strchr(r->contenttype, 32);
                  if(!(pos == ((char *)NULL)))
                    *pos = (char)0;

                }

              }

              if(!(r->statuscode == -1))
              {
                if(!((1 & flags) == 0))
                {
                  signed long int fposCurrent;
                  fposCurrent=ftell(index->file);
                  signed long int metaSize = fposCurrent - fposMeta;
                  signed long int fetchSize = (signed long int)r->size;
                  if(!(fetchSize >= 1l))
                    fetchSize = (signed long int)dataLength - metaSize;

                  else
                    if(!((signed long int)dataLength + -metaSize >= fetchSize))
                    {
                      r->statuscode = -1;
                      strcpy(r->msg, "Cache Read Error : Truncated Data");
                    }

                  r->size = (unsigned long int)0;
                  if(!(r->statuscode == -1))
                  {
                    void *return_value_malloc_36;
                    return_value_malloc_36=malloc((unsigned long int)fetchSize);
                    r->adr = (char *)return_value_malloc_36;
                    if(!(r->adr == ((char *)NULL)))
                    {
                      if(fetchSize >= 1l)
                      {
                        return_value_fread_39=fread((void *)r->adr, (unsigned long int)1, (unsigned long int)fetchSize, index->file);
                        r->size = (unsigned long int)(signed int)return_value_fread_39;
                        if(!(r->size == (unsigned long int)fetchSize))
                        {
                          signed int last_errno;
                          signed int *return_value___errno_location_37;
                          return_value___errno_location_37=__errno_location();
                          last_errno = *return_value___errno_location_37;
                          r->statuscode = -1;
                          char *return_value_strerror_38;
                          return_value_strerror_38=strerror(last_errno);
                          sprintf(r->msg, "Read error in cache disk data: %s", return_value_strerror_38);
                        }

                      }

                    }

                    else
                    {
                      r->statuscode = -1;
                      strcpy(r->msg, "Read error (memory exhausted) from cache");
                    }
                  }

                }

              }

            }

            else
            {
              r->statuscode = -1;
              strcpy(r->msg, "Cache Read Error : Read Header Error");
            }
          }

          else
          {
            r->statuscode = -1;
            strcpy(r->msg, "Cache Read Error : Read Header Error");
          }
        }

        else
        {
          r->statuscode = -1;
          strcpy(r->msg, "Cache Read Error : Seek Error");
        }
      }

      else
      {
        r->statuscode = -1;
        strcpy(r->msg, "File Cache Entry Not Found");
      }
      if(!((signed int)*r->location == 0))
        r->location=strdup(r->location);

      else
        r->location = (char *)(void *)0;
      return r;
    }
  }
}

// PT_ReadCache__New
// file proxy/store.c line 835
static struct _PT_Element * PT_ReadCache__New(struct _PT_Index *index, const char *url, signed int flags)
{
  struct _PT_Element *retCode;
  MutexLock(&index->slots.formatNew.zFileLock);
  retCode=PT_ReadCache__New_u(index, url, flags);
  MutexUnlock(&index->slots.formatNew.zFileLock);
  return retCode;
}

// PT_ReadCache__New_u
// file proxy/store.c line 1000
static struct _PT_Element * PT_ReadCache__New_u(struct _PT_Index *index_, const char *url, signed int flags)
{
  struct _PT_Index__New *index = (struct _PT_Index__New *)&index_->slots.formatNew;
  char location_default[2048l];
  char previous_save[2048l];
  char previous_save_[2048l];
  char catbuff[8192l];
  signed long int hash_pos;
  signed int hash_pos_return;
  struct _PT_Element *r = (struct _PT_Element *)(void *)0;
  _Bool tmp_if_expr_1;
  if(index == ((struct _PT_Index__New *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = index->hash == (struct struct_coucal *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = index->zFile == (void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(url == ((const char *)NULL) || tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*url == 0 ? (_Bool)1 : (_Bool)0;
  char *tmp_post_6;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_8;
  unsigned long int return_value_strlen_9;
  signed int tmp_if_expr_11;
  signed int return_value_strfield_10;
  unsigned long int return_value_strlen_12;
  unsigned long int return_value_strlen_13;
  signed int tmp_if_expr_15;
  signed int return_value_strfield_14;
  unsigned long int return_value_strlen_16;
  unsigned long int return_value_strlen_17;
  signed int tmp_if_expr_19;
  signed int return_value_strfield_18;
  unsigned long int return_value_strlen_20;
  unsigned long int return_value_strlen_21;
  signed int tmp_if_expr_23;
  signed int return_value_strfield_22;
  unsigned long int return_value_strlen_24;
  unsigned long int return_value_strlen_25;
  signed int tmp_if_expr_27;
  signed int return_value_strfield_26;
  unsigned long int return_value_strlen_28;
  unsigned long int return_value_strlen_29;
  signed int tmp_if_expr_31;
  signed int return_value_strfield_30;
  unsigned long int return_value_strlen_32;
  unsigned long int return_value_strlen_33;
  signed int tmp_if_expr_35;
  signed int return_value_strfield_34;
  unsigned long int return_value_strlen_36;
  unsigned long int return_value_strlen_37;
  signed int tmp_if_expr_39;
  signed int return_value_strfield_38;
  unsigned long int return_value_strlen_40;
  unsigned long int return_value_strlen_41;
  signed int tmp_if_expr_43;
  signed int return_value_strfield_42;
  unsigned long int return_value_strlen_44;
  unsigned long int return_value_strlen_45;
  signed int tmp_if_expr_47;
  signed int return_value_strfield_46;
  unsigned long int return_value_strlen_48;
  unsigned long int return_value_strlen_49;
  signed int tmp_if_expr_51;
  signed int return_value_strfield_50;
  signed int tmp_if_expr_53;
  unsigned long int return_value_strlen_52;
  _Bool tmp_if_expr_66;
  signed int return_value_strncmp_65;
  _Bool tmp_if_expr_64;
  _Bool tmp_if_expr_63;
  const unsigned short int **return_value___ctype_b_loc_61;
  _Bool tmp_if_expr_62;
  char *tmp_if_expr_59;
  char *return_value_strchr_58;
  unsigned long int return_value_fread_71;
  if(tmp_if_expr_3)
    return (struct _PT_Element *)(void *)0;

  else
  {
    r=PT_ElementNew();
    if(r == ((struct _PT_Element *)NULL))
      return (struct _PT_Element *)(void *)0;

    else
    {
      location_default[(signed long int)0] = (char)0;
      previous_save_[(signed long int)0] = (char)0;
      previous_save[(signed long int)0] = previous_save_[(signed long int)0];
      memset((void *)r, 0, sizeof(struct _PT_Element) /*1576ul*/ );
      r->location = location_default;
      strcpy(r->location, "");
      signed int return_value_strncmp_4;
      return_value_strncmp_4=strncmp(url, "http://", (unsigned long int)7);
      if(return_value_strncmp_4 == 0)
        url = url + (signed long int)7;

      hash_pos_return=coucal_read(index->hash, (const void *)url, &hash_pos);
      if(!(hash_pos_return == 0))
      {
        unsigned long int posInZip;
        if(hash_pos >= 1l)
          posInZip = (unsigned long int)hash_pos;

        else
          posInZip = (unsigned long int)-hash_pos;
        signed int return_value_unzSetOffset_76;
        return_value_unzSetOffset_76=unzSetOffset(index->zFile, posInZip);
        if(return_value_unzSetOffset_76 == 0)
        {
          signed int return_value_unzOpenCurrentFile_75;
          return_value_unzOpenCurrentFile_75=unzOpenCurrentFile(index->zFile);
          if(return_value_unzOpenCurrentFile_75 == 0)
          {
            char headerBuff[8194l];
            signed int readSizeHeader;
            signed int dataincache = 0;
            headerBuff[(signed long int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)3)] = (char)0;
            headerBuff[(signed long int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)2)] = headerBuff[(signed long int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)3)];
            headerBuff[(signed long int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)1)] = headerBuff[(signed long int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)2)];
            headerBuff[(signed long int)0] = headerBuff[(signed long int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)1)];
            readSizeHeader=unzGetLocalExtrafield(index->zFile, (void *)headerBuff, (unsigned int)(sizeof(char [8194l]) /*8194ul*/  - (unsigned long int)2));
            if(readSizeHeader >= 1)
            {
              signed int offset = 0;
              char line[1026l];
              signed int lineEof = 0;
              headerBuff[(signed long int)readSizeHeader] = (char)0;
              do
              {
                char *value;
                line[(signed long int)0] = (char)0;
                signed int return_value_binput_5;
                return_value_binput_5=binput(headerBuff + (signed long int)offset, line, (signed int)(sizeof(char [1026l]) /*1026ul*/  - (unsigned long int)2));
                offset = offset + return_value_binput_5;
                if((signed int)line[0l] == 0)
                  lineEof = 1;

                value=strchr(line, 58);
                if(!(value == ((char *)NULL)))
                {
                  tmp_post_6 = value;
                  value = value + 1l;
                  *tmp_post_6 = (char)0;
                  if((signed int)*value == 32)
                    tmp_if_expr_7 = (_Bool)1;

                  else
                    tmp_if_expr_7 = (signed int)*value == 9 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_7)
                    value = value + 1l;

                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_8=strlen(line);
                      return_value_strlen_9=strlen("X-In-Cache");
                      if(!(return_value_strlen_8 == return_value_strlen_9))
                        tmp_if_expr_11 = 0;

                      else
                      {
                        return_value_strfield_10=strfield_link1(line, "X-In-Cache");
                        tmp_if_expr_11 = return_value_strfield_10;
                      }
                      if(!(tmp_if_expr_11 == 0))
                      {
                        signed int intval = 0;
                        sscanf(value, "%d", &intval);
                        dataincache = intval;
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_12=strlen(line);
                      return_value_strlen_13=strlen("X-Statuscode");
                      if(!(return_value_strlen_12 == return_value_strlen_13))
                        tmp_if_expr_15 = 0;

                      else
                      {
                        return_value_strfield_14=strfield_link1(line, "X-Statuscode");
                        tmp_if_expr_15 = return_value_strfield_14;
                      }
                      if(!(tmp_if_expr_15 == 0))
                      {
                        signed int PT_ReadCache__New_u__1__1__3__1__1__1__2__2__1__intval = 0;
                        sscanf(value, "%d", &PT_ReadCache__New_u__1__1__3__1__1__1__2__2__1__intval);
                        r->statuscode = PT_ReadCache__New_u__1__1__3__1__1__1__2__2__1__intval;
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_16=strlen(line);
                      return_value_strlen_17=strlen("X-StatusMessage");
                      if(!(return_value_strlen_16 == return_value_strlen_17))
                        tmp_if_expr_19 = 0;

                      else
                      {
                        return_value_strfield_18=strfield_link1(line, "X-StatusMessage");
                        tmp_if_expr_19 = return_value_strfield_18;
                      }
                      if(!(tmp_if_expr_19 == 0))
                      {
                        strcpy(r->msg, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_20=strlen(line);
                      return_value_strlen_21=strlen("X-Size");
                      if(!(return_value_strlen_20 == return_value_strlen_21))
                        tmp_if_expr_23 = 0;

                      else
                      {
                        return_value_strfield_22=strfield_link1(line, "X-Size");
                        tmp_if_expr_23 = return_value_strfield_22;
                      }
                      if(!(tmp_if_expr_23 == 0))
                      {
                        signed int PT_ReadCache__New_u__1__1__3__1__1__1__2__4__1__intval = 0;
                        sscanf(value, "%d", &PT_ReadCache__New_u__1__1__3__1__1__1__2__4__1__intval);
                        r->size = (unsigned long int)PT_ReadCache__New_u__1__1__3__1__1__1__2__4__1__intval;
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_24=strlen(line);
                      return_value_strlen_25=strlen("Content-Type");
                      if(!(return_value_strlen_24 == return_value_strlen_25))
                        tmp_if_expr_27 = 0;

                      else
                      {
                        return_value_strfield_26=strfield_link1(line, "Content-Type");
                        tmp_if_expr_27 = return_value_strfield_26;
                      }
                      if(!(tmp_if_expr_27 == 0))
                      {
                        strcpy(r->contenttype, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_28=strlen(line);
                      return_value_strlen_29=strlen("X-Charset");
                      if(!(return_value_strlen_28 == return_value_strlen_29))
                        tmp_if_expr_31 = 0;

                      else
                      {
                        return_value_strfield_30=strfield_link1(line, "X-Charset");
                        tmp_if_expr_31 = return_value_strfield_30;
                      }
                      if(!(tmp_if_expr_31 == 0))
                      {
                        strcpy(r->charset, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_32=strlen(line);
                      return_value_strlen_33=strlen("Last-Modified");
                      if(!(return_value_strlen_32 == return_value_strlen_33))
                        tmp_if_expr_35 = 0;

                      else
                      {
                        return_value_strfield_34=strfield_link1(line, "Last-Modified");
                        tmp_if_expr_35 = return_value_strfield_34;
                      }
                      if(!(tmp_if_expr_35 == 0))
                      {
                        strcpy(r->lastmodified, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_36=strlen(line);
                      return_value_strlen_37=strlen("Etag");
                      if(!(return_value_strlen_36 == return_value_strlen_37))
                        tmp_if_expr_39 = 0;

                      else
                      {
                        return_value_strfield_38=strfield_link1(line, "Etag");
                        tmp_if_expr_39 = return_value_strfield_38;
                      }
                      if(!(tmp_if_expr_39 == 0))
                      {
                        strcpy(r->etag, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_40=strlen(line);
                      return_value_strlen_41=strlen("Location");
                      if(!(return_value_strlen_40 == return_value_strlen_41))
                        tmp_if_expr_43 = 0;

                      else
                      {
                        return_value_strfield_42=strfield_link1(line, "Location");
                        tmp_if_expr_43 = return_value_strfield_42;
                      }
                      if(!(tmp_if_expr_43 == 0))
                      {
                        strcpy(r->location, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_44=strlen(line);
                      return_value_strlen_45=strlen("Content-Disposition");
                      if(!(return_value_strlen_44 == return_value_strlen_45))
                        tmp_if_expr_47 = 0;

                      else
                      {
                        return_value_strfield_46=strfield_link1(line, "Content-Disposition");
                        tmp_if_expr_47 = return_value_strfield_46;
                      }
                      if(!(tmp_if_expr_47 == 0))
                      {
                        strcpy(r->cdispo, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  do
                    if(!((signed int)line[0l] == 0))
                    {
                      return_value_strlen_48=strlen(line);
                      return_value_strlen_49=strlen("X-Save");
                      if(!(return_value_strlen_48 == return_value_strlen_49))
                        tmp_if_expr_51 = 0;

                      else
                      {
                        return_value_strfield_50=strfield_link1(line, "X-Save");
                        tmp_if_expr_51 = return_value_strfield_50;
                      }
                      if(!(tmp_if_expr_51 == 0))
                      {
                        strcpy(previous_save_, value);
                        line[(signed long int)0] = (char)0;
                      }

                    }

                  while((_Bool)0);
                  if(!((signed int)line[0l] == 0))
                  {
                    signed int len;
                    if(!(r->headers == ((char *)NULL)))
                    {
                      return_value_strlen_52=strlen(r->headers);
                      tmp_if_expr_53 = (signed int)return_value_strlen_52;
                    }

                    else
                      tmp_if_expr_53 = 0;
                    len = tmp_if_expr_53;
                    signed int nlen;
                    unsigned long int return_value_strlen_54;
                    return_value_strlen_54=strlen(line);
                    unsigned long int return_value_strlen_55;
                    return_value_strlen_55=strlen(value);
                    nlen = (signed int)(return_value_strlen_54 + (unsigned long int)2 + return_value_strlen_55 + sizeof(char [3l]) /*3ul*/  + (unsigned long int)1);
                    void *return_value_realloc_56;
                    return_value_realloc_56=realloc((void *)r->headers, (unsigned long int)(len + nlen));
                    r->headers = (char *)return_value_realloc_56;
                    r->headers[(signed long int)len] = (char)0;
                    strcat(r->headers, line);
                    strcat(r->headers, ": ");
                    strcat(r->headers, value);
                    strcat(r->headers, "\r\n");
                  }

                }

              }
              while(lineEof == 0 && !(offset >= readSizeHeader));
              if(!((signed int)previous_save_[0l] == 0))
              {
                signed int pathLen;
                unsigned long int return_value_strlen_57;
                return_value_strlen_57=strlen(index->path);
                pathLen = (signed int)return_value_strlen_57;
                if(pathLen >= 1)
                {
                  return_value_strncmp_65=strncmp(previous_save_, index->path, (unsigned long int)pathLen);
                  tmp_if_expr_66 = return_value_strncmp_65 == 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_66 = (_Bool)0;
                if(tmp_if_expr_66)
                  strcpy(previous_save, previous_save_);

                else
                {
                  if(!(index->safeCache == 0))
                    tmp_if_expr_64 = (_Bool)1;

                  else
                  {
                    if(!((signed int)previous_save_[0l] == 47))
                    {
                      return_value___ctype_b_loc_61=__ctype_b_loc();
                      if((1024 & (signed int)(*return_value___ctype_b_loc_61)[(signed long int)(signed int)previous_save_[0l]]) == 0)
                        tmp_if_expr_62 = (_Bool)1;

                      else
                        tmp_if_expr_62 = (signed int)previous_save_[(signed long int)1] != 58 ? (_Bool)1 : (_Bool)0;
                      tmp_if_expr_63 = tmp_if_expr_62 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_63 = (_Bool)0;
                    tmp_if_expr_64 = tmp_if_expr_63 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_64)
                  {
                    index->safeCache = 1;
                    sprintf(previous_save, "%s%s", (const void *)index->path, (const void *)previous_save_);
                  }

                  else
                  {
                    if(index->fixedPath == 0)
                    {
                      const char *start;
                      start=jump_protocol_and_auth_link1(url);
                      const char *end;
                      if(!(start == ((const char *)NULL)))
                      {
                        return_value_strchr_58=strchr(start, 47);
                        tmp_if_expr_59 = return_value_strchr_58;
                      }

                      else
                        tmp_if_expr_59 = (char *)(void *)0;
                      end = tmp_if_expr_59;
                      signed int PT_ReadCache__New_u__1__1__3__1__1__2__3__1__len = (signed int)(end - start);
                      if(PT_ReadCache__New_u__1__1__3__1__1__2__3__1__len >= 1 && !(end == ((const char *)NULL)) && !(start == ((const char *)NULL)) && !(PT_ReadCache__New_u__1__1__3__1__1__2__3__1__len >= 128))
                      {
                        char piece[130l];
                        const char *where;
                        piece[(signed long int)0] = (char)0;
                        strncat(piece, start, (unsigned long int)PT_ReadCache__New_u__1__1__3__1__1__2__3__1__len);
                        where=strstr(previous_save_, piece);
                        if(!(where == ((const char *)NULL)))
                          index->fixedPath = (signed int)(where - previous_save_);

                      }

                    }

                    if(index->fixedPath >= 1)
                    {
                      signed int saveLen;
                      unsigned long int return_value_strlen_60;
                      return_value_strlen_60=strlen(previous_save_);
                      saveLen = (signed int)return_value_strlen_60;
                      if(!(index->fixedPath >= saveLen))
                        sprintf(previous_save, "%s%s", (const void *)index->path, previous_save_ + (signed long int)index->fixedPath);

                      else
                      {
                        sprintf(r->msg, "Bogus fixePath prefix for %s (prefixLen=%d)", (const void *)previous_save_, (signed int)index->fixedPath);
                        r->statuscode = -1;
                      }
                    }

                    else
                      sprintf(previous_save, "%s%s", (const void *)index->path, (const void *)previous_save_);
                  }
                }
              }

              r->adr = (char *)(void *)0;
              if(!(r->statuscode == -1))
              {
                signed int ok = 0;
                if(!(ok == 0))
                {
                  if((signed int)r->msg[0l] == 0)
                    strcpy(r->msg, "Cache Read Error : Unexpected error");

                }

                else
                  if(dataincache == 0)
                  {
                    if(!((1 & flags) == 0))
                    {
                      if(!((signed int)previous_save[0l] == 0))
                      {
                        struct _IO_FILE *fp;
                        char *return_value_file_convert_67;
                        return_value_file_convert_67=file_convert(catbuff, sizeof(char [8192l]) /*8192ul*/ , previous_save);
                        fp=fopen(return_value_file_convert_67, "rb");
                        if(!(fp == ((struct _IO_FILE *)NULL)))
                        {
                          void *return_value_malloc_68;
                          return_value_malloc_68=malloc(r->size + (unsigned long int)4);
                          r->adr = (char *)return_value_malloc_68;
                          if(!(r->adr == ((char *)NULL)))
                          {
                            if(r->size >= 1ul)
                            {
                              return_value_fread_71=fread((void *)r->adr, (unsigned long int)1, r->size, fp);
                              if(!(return_value_fread_71 == r->size))
                              {
                                signed int last_errno;
                                signed int *return_value___errno_location_69;
                                return_value___errno_location_69=__errno_location();
                                last_errno = *return_value___errno_location_69;
                                r->statuscode = -1;
                                char *return_value_strerror_70;
                                return_value_strerror_70=strerror(last_errno);
                                sprintf(r->msg, "Read error in cache disk data: %s", return_value_strerror_70);
                              }

                            }

                          }

                          else
                          {
                            r->statuscode = -1;
                            strcpy(r->msg, "Read error (memory exhausted) from cache");
                          }
                          fclose(fp);
                        }

                        else
                        {
                          r->statuscode = -1;
                          char *return_value_file_convert_72;
                          return_value_file_convert_72=file_convert(catbuff, sizeof(char [8192l]) /*8192ul*/ , previous_save);
                          sprintf(r->msg, "Read error (can't open '%s') from cache", return_value_file_convert_72);
                        }
                      }

                      else
                      {
                        r->statuscode = -1;
                        strcpy(r->msg, "Cached file name is invalid");
                      }
                    }

                  }

                  else
                    if(!((1 & flags) == 0))
                    {
                      void *return_value_malloc_73;
                      return_value_malloc_73=malloc(r->size + (unsigned long int)1);
                      r->adr = (char *)return_value_malloc_73;
                      if(!(r->adr == ((char *)NULL)))
                      {
                        signed int return_value_unzReadCurrentFile_74;
                        return_value_unzReadCurrentFile_74=unzReadCurrentFile(index->zFile, (void *)r->adr, (unsigned int)r->size);
                        if(!((unsigned long int)return_value_unzReadCurrentFile_74 == r->size))
                        {
                          free((void *)r->adr);
                          r->adr = (char *)(void *)0;
                          r->statuscode = -1;
                          strcpy(r->msg, "Cache Read Error : Read Data");
                        }

                        else
                          r->adr[(signed long int)r->size] = (char)0;
                      }

                      else
                      {
                        r->statuscode = -1;
                        strcpy(r->msg, "Cache Memory Error");
                      }
                    }

              }

            }

            else
            {
              r->statuscode = -1;
              strcpy(r->msg, "Cache Read Error : Read Header Data");
            }
            unzCloseCurrentFile(index->zFile);
          }

          else
          {
            r->statuscode = -1;
            strcpy(r->msg, "Cache Read Error : Open File");
          }
        }

        else
        {
          r->statuscode = -1;
          strcpy(r->msg, "Cache Read Error : Bad Offset");
        }
      }

      else
      {
        r->statuscode = -1;
        strcpy(r->msg, "File Cache Entry Not Found");
      }
      if(!((signed int)*r->location == 0))
        r->location=strdup(r->location);

      else
        r->location = (char *)(void *)0;
      return r;
    }
  }
}

// PT_ReadCache__Old
// file proxy/store.c line 1584
static struct _PT_Element * PT_ReadCache__Old(struct _PT_Index *index, const char *url, signed int flags)
{
  struct _PT_Element *retCode;
  MutexLock(&index->slots.formatOld.fileLock);
  retCode=PT_ReadCache__Old_u(index, url, flags);
  MutexUnlock(&index->slots.formatOld.fileLock);
  return retCode;
}

// PT_ReadCache__Old_u
// file proxy/store.c line 1595
static struct _PT_Element * PT_ReadCache__Old_u(struct _PT_Index *index_, const char *url, signed int flags)
{
  struct _PT_Index__Old *cache = (struct _PT_Index__Old *)&index_->slots.formatOld;
  signed long int hash_pos;
  signed int hash_pos_return;
  char location_default[2048l];
  char previous_save[2048l];
  char previous_save_[2048l];
  struct _PT_Element *r;
  signed int ok = 0;
  _Bool tmp_if_expr_1;
  if(cache == ((struct _PT_Index__Old *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cache->hash == (struct struct_coucal *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(url == ((const char *)NULL) || tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)*url == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_28;
  signed int return_value_strncmp_27;
  _Bool tmp_if_expr_26;
  _Bool tmp_if_expr_25;
  const unsigned short int **return_value___ctype_b_loc_23;
  _Bool tmp_if_expr_24;
  char *tmp_if_expr_21;
  char *return_value_strchr_20;
  _Bool tmp_if_expr_33;
  unsigned long int return_value_fread_30;
  if(tmp_if_expr_2)
    return (struct _PT_Element *)(void *)0;

  else
  {
    r=PT_ElementNew();
    if(r == ((struct _PT_Element *)NULL))
      return (struct _PT_Element *)(void *)0;

    else
    {
      location_default[(signed long int)0] = (char)0;
      previous_save_[(signed long int)0] = (char)0;
      previous_save[(signed long int)0] = previous_save_[(signed long int)0];
      memset((void *)r, 0, sizeof(struct _PT_Element) /*1576ul*/ );
      r->location = location_default;
      strcpy(r->location, "");
      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(url, "http://", (unsigned long int)7);
      if(return_value_strncmp_3 == 0)
        url = url + (signed long int)7;

      hash_pos_return=coucal_read(cache->hash, (const void *)url, &hash_pos);
      if(!(hash_pos_return == 0))
      {
        signed int pos = (signed int)hash_pos;
        signed int return_value_fseek_34;
        return_value_fseek_34=fseek(cache->dat, (signed long int)(pos > 0 ? pos : -pos), 0);
        if(return_value_fseek_34 == 0)
        {
          if(cache->version == 0)
          {
            struct OLD_htsblk old_r;
            unsigned long int return_value_fread_17;
            return_value_fread_17=fread((void *)(char *)&old_r, (unsigned long int)1, sizeof(struct OLD_htsblk) /*1320ul*/ , cache->dat);
            if(return_value_fread_17 == sizeof(struct OLD_htsblk) /*1320ul*/ )
            {
              signed int i;
              struct String urlDecoded;
              r->statuscode = old_r.statuscode;
              r->size = (unsigned long int)old_r.size;
              strcpy(r->msg, old_r.msg);
              strcpy(r->contenttype, old_r.contenttype);
              const char *return_value_jump_protocol_and_auth_4;
              return_value_jump_protocol_and_auth_4=jump_protocol_and_auth_link1(url);
              urlDecoded=DecodeUrl(return_value_jump_protocol_and_auth_4);
              strcpy(previous_save_, (const char *)urlDecoded.buffer_);
              do
              {
                if(!(urlDecoded.buffer_ == ((char *)NULL)))
                {
                  free((void *)urlDecoded.buffer_);
                  urlDecoded.buffer_ = (char *)(void *)0;
                }

                urlDecoded.capacity_ = (unsigned long int)0;
                urlDecoded.length_ = (unsigned long int)0;
              }
              while((_Bool)0);
              i = 0;
              do
              {
                if(!((signed int)previous_save_[(signed long int)i] == 0))
                  tmp_if_expr_5 = (signed int)previous_save_[(signed long int)i] != 63 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_5 = (_Bool)0;
                if(!tmp_if_expr_5)
                  break;

                if((signed int)previous_save_[(signed long int)i] == 126)
                  tmp_if_expr_6 = (_Bool)1;

                else
                  tmp_if_expr_6 = (signed int)previous_save_[(signed long int)i] == 92 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_6)
                  tmp_if_expr_7 = (_Bool)1;

                else
                  tmp_if_expr_7 = (signed int)previous_save_[(signed long int)i] == 58 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_7)
                  tmp_if_expr_8 = (_Bool)1;

                else
                  tmp_if_expr_8 = (signed int)previous_save_[(signed long int)i] == 42 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_8)
                  tmp_if_expr_9 = (_Bool)1;

                else
                  tmp_if_expr_9 = (signed int)previous_save_[(signed long int)i] == 63 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_9)
                  tmp_if_expr_10 = (_Bool)1;

                else
                  tmp_if_expr_10 = (signed int)previous_save_[(signed long int)i] == 34 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_10)
                  tmp_if_expr_11 = (_Bool)1;

                else
                  tmp_if_expr_11 = (signed int)previous_save_[(signed long int)i] == 60 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_11)
                  tmp_if_expr_12 = (_Bool)1;

                else
                  tmp_if_expr_12 = (signed int)previous_save_[(signed long int)i] == 62 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_12)
                  tmp_if_expr_13 = (_Bool)1;

                else
                  tmp_if_expr_13 = (signed int)previous_save_[(signed long int)i] == 124 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_13)
                  tmp_if_expr_14 = (_Bool)1;

                else
                  tmp_if_expr_14 = (signed int)previous_save_[(signed long int)i] == 64 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_14)
                  tmp_if_expr_15 = (_Bool)1;

                else
                  tmp_if_expr_15 = (signed int)(unsigned char)previous_save_[(signed long int)i] <= 31 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_15)
                  tmp_if_expr_16 = (_Bool)1;

                else
                  tmp_if_expr_16 = (signed int)(unsigned char)previous_save_[(signed long int)i] == 127 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_16)
                  previous_save_[(signed long int)i] = (char)95;

                i = i + 1;
              }
              while((_Bool)1);
              previous_save_[(signed long int)i] = (char)0;
              ok = 1;
            }

          }

          else
          {
            char check[256l];
            unsigned long int size_read;
            unsigned long int size_;
            check[(signed long int)0] = (char)0;
            cache_rint(cache->dat, &r->statuscode);
            cache_rLLint(cache->dat, &size_);
            r->size = (unsigned long int)size_;
            cache_rstr(cache->dat, r->msg);
            cache_rstr(cache->dat, r->contenttype);
            if(cache->version >= 3)
              cache_rstr(cache->dat, r->charset);

            cache_rstr(cache->dat, r->lastmodified);
            cache_rstr(cache->dat, r->etag);
            cache_rstr(cache->dat, r->location);
            if(cache->version >= 2)
              cache_rstr(cache->dat, r->cdispo);

            if(cache->version >= 4)
            {
              cache_rstr(cache->dat, previous_save_);
              cache_rstr(cache->dat, previous_save_);
              previous_save[(signed long int)0] = (char)0;
              cache_rstr(cache->dat, previous_save_);
            }

            if(cache->version >= 5)
              r->headers=cache_rstr_addr(cache->dat);

            cache_rstr(cache->dat, check);
            signed int return_value_strcmp_18;
            return_value_strcmp_18=strcmp(check, "HTS");
            if(return_value_strcmp_18 == 0)
              ok = 1;

            cache_rLLint(cache->dat, &size_read);
            if(size_read >= 1ul)
              r->size = size_read;

            else
              r->size = (unsigned long int)0;
          }
          struct _PT_Index__Old *index = cache;
          if(!((signed int)previous_save_[0l] == 0))
          {
            signed int pathLen;
            unsigned long int return_value_strlen_19;
            return_value_strlen_19=strlen(index->path);
            pathLen = (signed int)return_value_strlen_19;
            if(pathLen >= 1)
            {
              return_value_strncmp_27=strncmp(previous_save_, index->path, (unsigned long int)pathLen);
              tmp_if_expr_28 = return_value_strncmp_27 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_28 = (_Bool)0;
            if(tmp_if_expr_28)
              strcpy(previous_save, previous_save_);

            else
            {
              if(!(index->safeCache == 0))
                tmp_if_expr_26 = (_Bool)1;

              else
              {
                if(!((signed int)previous_save_[0l] == 47))
                {
                  return_value___ctype_b_loc_23=__ctype_b_loc();
                  if((1024 & (signed int)(*return_value___ctype_b_loc_23)[(signed long int)(signed int)previous_save_[0l]]) == 0)
                    tmp_if_expr_24 = (_Bool)1;

                  else
                    tmp_if_expr_24 = (signed int)previous_save_[(signed long int)1] != 58 ? (_Bool)1 : (_Bool)0;
                  tmp_if_expr_25 = tmp_if_expr_24 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_25 = (_Bool)0;
                tmp_if_expr_26 = tmp_if_expr_25 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_26)
              {
                index->safeCache = 1;
                sprintf(previous_save, "%s%s", (const void *)index->path, (const void *)previous_save_);
              }

              else
              {
                if(index->fixedPath == 0)
                {
                  const char *start;
                  start=jump_protocol_and_auth_link1(url);
                  const char *end;
                  if(!(start == ((const char *)NULL)))
                  {
                    return_value_strchr_20=strchr(start, 47);
                    tmp_if_expr_21 = return_value_strchr_20;
                  }

                  else
                    tmp_if_expr_21 = (char *)(void *)0;
                  end = tmp_if_expr_21;
                  signed int len = (signed int)(end - start);
                  if(len >= 1 && !(end == ((const char *)NULL)) && !(start == ((const char *)NULL)) && !(len >= 128))
                  {
                    char piece[130l];
                    const char *where;
                    piece[(signed long int)0] = (char)0;
                    strncat(piece, start, (unsigned long int)len);
                    where=strstr(previous_save_, piece);
                    if(!(where == ((const char *)NULL)))
                      index->fixedPath = (signed int)(where - previous_save_);

                  }

                }

                if(index->fixedPath >= 1)
                {
                  signed int saveLen;
                  unsigned long int return_value_strlen_22;
                  return_value_strlen_22=strlen(previous_save_);
                  saveLen = (signed int)return_value_strlen_22;
                  if(!(index->fixedPath >= saveLen))
                    sprintf(previous_save, "%s%s", (const void *)index->path, previous_save_ + (signed long int)index->fixedPath);

                  else
                  {
                    sprintf(r->msg, "Bogus fixePath prefix for %s (prefixLen=%d)", (const void *)previous_save_, (signed int)index->fixedPath);
                    r->statuscode = -1;
                  }
                }

                else
                  sprintf(previous_save, "%s%s", (const void *)index->path, (const void *)previous_save_);
              }
            }
          }

          if(!(ok == 0))
          {
            r->adr = (char *)(void *)0;
            if(r->statuscode >= 0)
              tmp_if_expr_33 = r->statuscode <= 999 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_33 = (_Bool)0;
            if(tmp_if_expr_33)
            {
              r->adr = (char *)(void *)0;
              if(!(pos >= 0))
              {
                if(!((1 & flags) == 0))
                {
                  struct _IO_FILE *fp;
                  fp=fopen(previous_save, "rb");
                  if(!(fp == ((struct _IO_FILE *)NULL)))
                  {
                    void *return_value_malloc_29;
                    return_value_malloc_29=malloc(r->size + (unsigned long int)1);
                    r->adr = (char *)return_value_malloc_29;
                    if(!(r->adr == ((char *)NULL)))
                    {
                      if(r->size >= 1ul)
                      {
                        return_value_fread_30=fread((void *)r->adr, (unsigned long int)1, r->size, fp);
                        if(!(return_value_fread_30 == r->size))
                        {
                          r->statuscode = -1;
                          strcpy(r->msg, "Read error in cache disk data");
                        }

                      }

                      r->adr[(signed long int)r->size] = (char)0;
                    }

                    else
                    {
                      r->statuscode = -1;
                      strcpy(r->msg, "Read error (memory exhausted) from cache");
                    }
                    fclose(fp);
                  }

                  else
                  {
                    r->statuscode = -1;
                    strcpy(r->msg, "Previous cache file not found (2)");
                  }
                }

              }

              else
                if(!((1 & flags) == 0))
                {
                  void *return_value_malloc_31;
                  return_value_malloc_31=malloc(r->size + (unsigned long int)1);
                  r->adr = (char *)return_value_malloc_31;
                  if(!(r->adr == ((char *)NULL)))
                  {
                    unsigned long int return_value_fread_32;
                    return_value_fread_32=fread((void *)r->adr, (unsigned long int)1, r->size, cache->dat);
                    if(!(return_value_fread_32 == r->size))
                    {
                      free((void *)r->adr);
                      r->adr = (char *)(void *)0;
                      r->statuscode = -1;
                      strcpy(r->msg, "Cache Read Error : Read Data");
                    }

                    else
                      r->adr[(signed long int)r->size] = (char)0;
                  }

                  else
                  {
                    r->statuscode = -1;
                    strcpy(r->msg, "Cache Memory Error");
                  }
                }

            }

            else
            {
              r->statuscode = -1;
              strcpy(r->msg, "Cache Read Error : Bad Data");
            }
          }

          else
          {
            r->statuscode = -1;
            strcpy(r->msg, "Cache Read Error : Read Header");
          }
        }

        else
        {
          r->statuscode = -1;
          strcpy(r->msg, "Cache Read Error : Seek Failed");
        }
      }

      else
      {
        r->statuscode = -1;
        strcpy(r->msg, "File Cache Entry Not Found");
      }
      if(!((signed int)*r->location == 0))
        r->location=strdup(r->location);

      else
        r->location = (char *)(void *)0;
      return r;
    }
  }
}

// PT_ReadIndex
// file proxy/store.h line 88
struct _PT_Element * PT_ReadIndex(struct _PT_Indexes *indexes, const char *url, signed int flags)
{
  _Bool tmp_if_expr_2;
  if(!(indexes == ((struct _PT_Indexes *)NULL)))
  {
    signed long int index_id;
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(url, "http://", (unsigned long int)7);
    if(return_value_strncmp_1 == 0)
      url = url + (signed long int)7;

    signed int return_value_coucal_read_3;
    return_value_coucal_read_3=coucal_read(indexes->cil, (const void *)url, &index_id);
    if(!(return_value_coucal_read_3 == 0))
    {
      if(index_id >= 0l)
        tmp_if_expr_2 = index_id <= (signed long int)indexes->index_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        struct _PT_Element *item;
        item=PT_ReadCache(indexes->index[index_id], url, flags);
        if(!(item == ((struct _PT_Element *)NULL)))
        {
          item->indexId = (signed int)index_id;
          return item;
        }

      }

      else
        proxytrack_print_log_link1("critical", "PT_ReadCache:Corrupted central index locator");
    }

  }

  return (struct _PT_Element *)(void *)0;
}

// PT_RemoveIndex
// file proxy/store.c line 254
signed int PT_RemoveIndex(struct _PT_Indexes *index, signed int indexId)
{
  return 0;
}

// PT_SaveCache
// file proxy/store.h line 103
signed int PT_SaveCache(struct _PT_Indexes *indexes, const char *filename)
{
  signed int type;
  type=PT_GetType(filename);
  if(!(type == -1))
  {
    if(!(_IndexFuncts[(signed long int)type].PT_SaveCache == ((signed int (*)(struct _PT_Indexes *, const char *))NULL)))
    {
      signed int ret;
      ret=_IndexFuncts[(signed long int)type].PT_SaveCache(indexes, filename);
      if(ret == 0)
      {
        signed long int return_value_PT_GetTimeIndex_1;
        return_value_PT_GetTimeIndex_1=PT_GetTimeIndex(indexes);
        set_filetime_time_t(filename, return_value_PT_GetTimeIndex_1);
        return 0;
      }

    }

  }

  return -1;
}

// PT_SaveCache__Arc
// file proxy/store.c line 2346
static signed int PT_SaveCache__Arc(struct _PT_Indexes *indexes, const char *filename)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "wb");
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    struct PT_SaveCache__Arc_t st;
    signed int ret;
    signed long int t;
    t=PT_GetTimeIndex(indexes);
    struct tm tm;
    tm=PT_GetTime(t);
    const char *prefix = "2 0 HTTrack Website Copier\nURL IP-address Archive-Date Content-Type Result-code Checksum Location Offset Filename Archive-length\n\n";
    sprintf(st.filename, "httrack_%d.arc", (signed int)t);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(prefix);
    fprintf(fp, "filedesc://%s 0.0.0.0 %04d%02d%02d%02d%02d%02d text/plain 200 - - 0 %s %d\n%s", (const void *)st.filename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, (const void *)st.filename, (signed int)return_value_strlen_1, prefix);
    st.fp = fp;
    st.indexes = indexes;
    st.t = t;
    ret=PT_EnumCache(indexes, PT_SaveCache__Arc_Fun, (void *)&st);
    fclose(fp);
    if(!(ret == 0))
      unlink(filename);

    return ret;
  }

  return -1;
}

// PT_SaveCache__Arc_Fun
// file proxy/store.c line 2285
static signed int PT_SaveCache__Arc_Fun(void *arg, const char *url, struct _PT_Element *element)
{
  struct PT_SaveCache__Arc_t *st = (struct PT_SaveCache__Arc_t *)arg;
  struct _IO_FILE * const fp = st->fp;
  struct tm *tm;
  tm=convert_time_rfc822(&st->buff, element->lastmodified);
  signed int size_headers;
  char *tmp_if_expr_1;
  if(!(element->charset[0l] == 0))
    tmp_if_expr_1 = element->charset;

  else
    tmp_if_expr_1 = "";
  sprintf(st->headers, "HTTP/1.0 %d %s\r\nX-Server: ProxyTrack 0.5\r\nContent-type: %s%s%s%s\r\nLast-modified: %s\r\nContent-length: %d\r\n", element->statuscode, (const void *)element->msg, (const void *)element->contenttype, element->charset[(signed long int)0] != 0 ? "; charset=\"" : "", tmp_if_expr_1, element->charset[(signed long int)0] != 0 ? "\"" : "", (const void *)element->lastmodified, (signed int)element->size);
  if(!(element->location == ((char *)NULL)))
  {
    if(!((signed int)*element->location == 0))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(st->headers);
      sprintf(st->headers + (signed long int)return_value_strlen_2, "Location: %s\r\n", element->location);
    }

  }

  if(!(element->headers == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(element->headers);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(element->headers);
    if(!(return_value_strlen_3 >= sizeof(char [8192l]) /*8192ul*/  + -return_value_strlen_4 + 18446744073709551615ul))
      strcat(st->headers, element->headers);

  }

  strcat(st->headers, "\r\n");
  unsigned long int return_value_strlen_5;
  return_value_strlen_5=strlen(st->headers);
  size_headers = (signed int)return_value_strlen_5;
  if(!(element->adr == ((char *)NULL)))
    domd5mem(element->adr, element->size, st->md5, 1);

  else
    strcpy(st->md5, "-");
  signed int return_value_link_has_authority_6;
  return_value_link_has_authority_6=link_has_authority_link1(url);
  char *tmp_if_expr_7;
  if(!(element->location == ((char *)NULL)))
    tmp_if_expr_7 = element->location;

  else
    tmp_if_expr_7 = "-";
  signed long int return_value_ftell_8;
  return_value_ftell_8=ftell(fp);
  fprintf(fp, "\n%s%s %s %04d%02d%02d%02d%02d%02d %s %d %s %s %ld %s %ld\n", return_value_link_has_authority_6 != 0 ? "" : "http://", url, (const void *)"0.0.0.0", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, (const void *)element->contenttype, element->statuscode, (const void *)st->md5, tmp_if_expr_7, (signed long int)return_value_ftell_8, (const void *)st->filename, (signed long int)((unsigned long int)size_headers + element->size));
  unsigned long int return_value_fwrite_9;
  return_value_fwrite_9=fwrite((const void *)st->headers, (unsigned long int)1, (unsigned long int)size_headers, fp);
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  unsigned long int return_value_fwrite_10;
  if(!(return_value_fwrite_9 == (unsigned long int)size_headers))
    tmp_if_expr_12 = (_Bool)1;

  else
  {
    if(element->size >= 1ul)
    {
      return_value_fwrite_10=fwrite((const void *)element->adr, (unsigned long int)1, element->size, fp);
      tmp_if_expr_11 = return_value_fwrite_10 != element->size ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_11 = (_Bool)0;
    tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_12)
    return 1;

  else
    return 0;
}

// PT_SaveCache__New
// file proxy/store.c line 1333
static signed int PT_SaveCache__New(struct _PT_Indexes *indexes, const char *filename)
{
  void *zFileOut;
  zFileOut=zipOpen(filename, 0);
  if(!(zFileOut == NULL))
  {
    signed int ret;
    ret=PT_EnumCache(indexes, PT_SaveCache__New_Fun, (void *)zFileOut);
    zipClose(zFileOut, "Created by HTTrack Website Copier/ProxyTrack 0.5");
    zFileOut = (void *)0;
    if(!(ret == 0))
      unlink(filename);

    return ret;
  }

  return -1;
}

// PT_SaveCache__New_Fun
// file proxy/store.c line 1239
static signed int PT_SaveCache__New_Fun(void *arg, const char *url, struct _PT_Element *element)
{
  void *zFileOut = (void *)arg;
  char headers[8192l];
  signed int headersSize;
  struct anonymous_10 fi;
  signed int zErr;
  const char *url_adr = "";
  const char *url_fil = "";
  headers[(signed long int)0] = (char)0;
  headersSize = 0;
  headers[(signed long int)0] = (char)0;
  headersSize = 0;
  const char *message;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(element->msg);
  if(!(return_value_strlen_1 >= 32ul))
    message = element->msg;

  else
    message = "(See X-StatusMessage)";
  sprintf(headers + (signed long int)headersSize, "HTTP/1.%c %d %s\r\n", 49, element->statuscode, message);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(headers + (signed long int)headersSize);
  headersSize = headersSize + (signed int)return_value_strlen_2;
  do
  {
    sprintf(headers + (signed long int)headersSize, "%s: %ld\r\n", (const void *)"X-In-Cache", (signed long int)1);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(headers + (signed long int)headersSize);
    headersSize = headersSize + (signed int)return_value_strlen_3;
  }
  while((_Bool)0);
  do
    if(!(element->statuscode == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %ld\r\n", (const void *)"X-StatusCode", (signed long int)element->statuscode);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_4;
    }

  while((_Bool)0);
  do
    if(!((signed int)element->msg[0l] == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"X-StatusMessage", element->msg);
      unsigned long int return_value_strlen_5;
      return_value_strlen_5=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_5;
    }

  while((_Bool)0);
  do
    if(!(element->size == 0ul))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %ld\r\n", (const void *)"X-Size", (signed long int)element->size);
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_6;
    }

  while((_Bool)0);
  do
    if(!((signed int)element->contenttype[0l] == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"Content-Type", element->contenttype);
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_7;
    }

  while((_Bool)0);
  do
    if(!((signed int)element->charset[0l] == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"X-Charset", element->charset);
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_8;
    }

  while((_Bool)0);
  do
    if(!((signed int)element->lastmodified[0l] == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"Last-Modified", element->lastmodified);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_9;
    }

  while((_Bool)0);
  do
    if(!((signed int)element->etag[0l] == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"Etag", element->etag);
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_10;
    }

  while((_Bool)0);
  char *tmp_if_expr_11;
  do
    if(!(element->location == ((char *)NULL)))
    {
      if(!((signed int)*element->location == 0))
      {
        if(!(element->location == ((char *)NULL)))
          tmp_if_expr_11 = element->location;

        else
          tmp_if_expr_11 = "";
        sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"Location", tmp_if_expr_11);
        unsigned long int return_value_strlen_12;
        return_value_strlen_12=strlen(headers + (signed long int)headersSize);
        headersSize = headersSize + (signed int)return_value_strlen_12;
      }

    }

  while((_Bool)0);
  do
    if(!((signed int)element->cdispo[0l] == 0))
    {
      sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"Content-Disposition", element->cdispo);
      unsigned long int return_value_strlen_13;
      return_value_strlen_13=strlen(headers + (signed long int)headersSize);
      headersSize = headersSize + (signed int)return_value_strlen_13;
    }

  while((_Bool)0);
  do
    if(!(url_adr == ((const char *)NULL)))
    {
      if(!((signed int)*url_adr == 0))
      {
        sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"X-Addr", url_adr != (const char *)(void *)0 ? url_adr : "");
        unsigned long int return_value_strlen_14;
        return_value_strlen_14=strlen(headers + (signed long int)headersSize);
        headersSize = headersSize + (signed int)return_value_strlen_14;
      }

    }

  while((_Bool)0);
  do
    if(!(url_fil == ((const char *)NULL)))
    {
      if(!((signed int)*url_fil == 0))
      {
        sprintf(headers + (signed long int)headersSize, "%s: %s\r\n", (const void *)"X-Fil", url_fil != (const char *)(void *)0 ? url_fil : "");
        unsigned long int return_value_strlen_15;
        return_value_strlen_15=strlen(headers + (signed long int)headersSize);
        headersSize = headersSize + (signed int)return_value_strlen_15;
      }

    }

  while((_Bool)0);
  while((_Bool)0)
    ;
  memset((void *)&fi, 0, sizeof(struct anonymous_10) /*48ul*/ );
  if(!((signed int)element->lastmodified[0l] == 0))
  {
    struct tm buffer;
    struct tm *tm_s;
    tm_s=convert_time_rfc822(&buffer, element->lastmodified);
    if(!(tm_s == ((struct tm *)NULL)))
    {
      fi.tmz_date.tm_sec = (unsigned int)tm_s->tm_sec;
      fi.tmz_date.tm_min = (unsigned int)tm_s->tm_min;
      fi.tmz_date.tm_hour = (unsigned int)tm_s->tm_hour;
      fi.tmz_date.tm_mday = (unsigned int)tm_s->tm_mday;
      fi.tmz_date.tm_mon = (unsigned int)tm_s->tm_mon;
      fi.tmz_date.tm_year = (unsigned int)tm_s->tm_year;
    }

  }

  unsigned long int return_value_strlen_17;
  return_value_strlen_17=strlen(headers);
  zErr=zipOpenNewFileInZip(zFileOut, url, &fi, (const void *)headers, (unsigned int)return_value_strlen_17, (void *)0, (unsigned int)0, (const char *)(void *)0, 8, -1);
  if(!(zErr == 0))
  {
    abortf__link1("! \"zip_zipOpenNewFileInZip_failed\"", "proxy/store.c", 1308);
    (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
  }

  if(element->size >= 1ul)
  {
    if(!(element->adr == ((char *)NULL)))
    {
      zErr=zipWriteInFileInZip(zFileOut, (const void *)element->adr, (unsigned int)(signed int)element->size);
      if(!(zErr == 0))
      {
        abortf__link1("! \"zip_zipWriteInFileInZip_failed\"", "proxy/store.c", 1316);
        (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
      }

    }

  }

  zErr=zipCloseFileInZip(zFileOut);
  if(!(zErr == 0))
  {
    abortf__link1("! \"zip_zipCloseFileInZip_failed\"", "proxy/store.c", 1322);
    (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
  }

  zErr=zipFlush(zFileOut);
  if(!(zErr == 0))
  {
    abortf__link1("! \"zip_zipFlush_failed\"", "proxy/store.c", 1327);
    (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
  }

  return 0;
}

// SOCaddr_copyaddr_
// file ./htsnet.h line 185
static unsigned int SOCaddr_copyaddr_(struct SOCaddr * const server, const void *data, const unsigned long int data_size, const char *file, const signed int line)
{
  if(!(server == ((struct SOCaddr *)NULL)))
    (_Bool)1;

  else
  {
    abortf_("server != NULL", file, line);
    (_Bool)0;
  }
  if(!(data == NULL))
    (_Bool)1;

  else
  {
    abortf_("data != NULL", file, line);
    (_Bool)0;
  }
  if(data_size == sizeof(struct sockaddr_in) /*16ul*/ )
  {
    memcpy((void *)&server->m_addr.in, data, sizeof(struct sockaddr_in) /*16ul*/ );
    if((signed int)server->m_addr.sa.sa_family == 2)
      (_Bool)1;

    else
    {
      abortf_("server->m_addr.sa.sa_family == AF_INET", file, line);
      (_Bool)0;
    }
  }

  else
    if(data_size == sizeof(struct sockaddr_in6) /*28ul*/ )
    {
      memcpy((void *)&server->m_addr.in6, data, sizeof(struct sockaddr_in6) /*28ul*/ );
      if((signed int)server->m_addr.sa.sa_family == 10)
        (_Bool)1;

      else
      {
        abortf_("server->m_addr.sa.sa_family == AF_INET6", file, line);
        (_Bool)0;
      }
    }

    else
      if(data_size == 4ul)
      {
        memset((void *)&server->m_addr.in, 0, sizeof(struct sockaddr_in) /*16ul*/ );
        server->m_addr.in.sin_family = (unsigned short int)2;
        server->m_addr.in.sin_port = (unsigned short int)0;
        memcpy((void *)&server->m_addr.in.sin_addr, data, (unsigned long int)4);
      }

      else
        if(data_size == 16ul)
        {
          memset((void *)&server->m_addr.in6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
          server->m_addr.in6.sin6_family = (unsigned short int)10;
          server->m_addr.in6.sin6_port = (unsigned short int)0;
          memcpy((void *)&server->m_addr.in6.sin6_addr, data, (unsigned long int)16);
        }

        else
          server->m_addr.in.sin_family = (unsigned short int)2;
  unsigned int return_value_SOCaddr_size__1;
  return_value_SOCaddr_size__1=SOCaddr_size_(server, file, line);
  return return_value_SOCaddr_size__1;
}

// SOCaddr_inetntoa_
// file ./htsnet.h line 231
static void SOCaddr_inetntoa_(char *namebuf, unsigned long int namebuflen, struct SOCaddr * const ss, const char *file, const signed int line)
{
  if(!(namebuf == ((char *)NULL)))
    (_Bool)1;

  else
  {
    abortf_("namebuf != NULL", file, line);
    (_Bool)0;
  }
  if(!(ss == ((struct SOCaddr *)NULL)))
    (_Bool)1;

  else
  {
    abortf_("ss != NULL", file, line);
    (_Bool)0;
  }
  signed int return_value_getnameinfo_1;
  return_value_getnameinfo_1=getnameinfo(&ss->m_addr.sa, (unsigned int)sizeof(union anonymous_14) /*28ul*/ , namebuf, (unsigned int)namebuflen, (char *)(void *)0, (unsigned int)0, 1);
  if(return_value_getnameinfo_1 == 0)
  {
    char *pos;
    pos=strchr(namebuf, 37);
    if(!(pos == ((char *)NULL)))
      *pos = (char)0;

  }

  else
    namebuf[(signed long int)0] = (char)0;
}

// SOCaddr_initany_
// file ./htsnet.h line 170
static unsigned int SOCaddr_initany_(struct SOCaddr * const addr, const char *file, const signed int line)
{
  if(!(addr == ((struct SOCaddr *)NULL)))
    (_Bool)1;

  else
  {
    abortf_("addr != NULL", file, line);
    (_Bool)0;
  }
  memset((void *)&addr->m_addr.in, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr->m_addr.in.sin_family = (unsigned short int)2;
  unsigned int return_value_SOCaddr_size__1;
  return_value_SOCaddr_size__1=SOCaddr_size_(addr, file, line);
  return return_value_SOCaddr_size__1;
}

// SOCaddr_sinport_
// file ./htsnet.h line 106
static unsigned short int * SOCaddr_sinport_(struct SOCaddr * const addr, const char *file, const signed int line)
{
  if(!(addr == ((struct SOCaddr *)NULL)))
    (_Bool)1;

  else
  {
    abortf_("addr != NULL", file, line);
    (_Bool)0;
  }
  switch((signed int)addr->m_addr.sa.sa_family)
  {
    case 2:
      return &addr->m_addr.in.sin_port;
    case 10:
      return &addr->m_addr.in6.sin6_port;
    default:
    {
      abortf_("! \"invalid structure\"", file, line);
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
      return ((unsigned short int *)NULL);
    }
  }
}

// SOCaddr_size_
// file ./htsnet.h line 125
static unsigned int SOCaddr_size_(const struct SOCaddr * const addr, const char *file, const signed int line)
{
  if(!(addr == ((const struct SOCaddr *)NULL)))
    (_Bool)1;

  else
  {
    abortf_("addr != NULL", file, line);
    (_Bool)0;
  }
  switch((signed int)addr->m_addr.sa.sa_family)
  {
    case 2:
      return (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    case 10:
      return (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ ;
    default:
      return (unsigned int)0;
  }
}

// StringAcquire
// file ./htsstrings.h line 211
static char * StringAcquire(struct String *blk)
{
  char *buff = blk->buffer_;
  blk->buffer_ = (char *)(void *)0;
  blk->capacity_ = (unsigned long int)0;
  blk->length_ = (unsigned long int)0;
  return buff;
}

// StringAcquire_link1
// file ./htsstrings.h line 211
static char * StringAcquire_link1(struct String *blk_link1)
{
  char *buff_link1 = blk_link1->buffer_;
  blk_link1->buffer_ = (char *)(void *)0;
  blk_link1->capacity_ = (unsigned long int)0;
  blk_link1->length_ = (unsigned long int)0;
  return buff_link1;
}

// StringAttach
// file ./htsstrings.h line 229
static void StringAttach(struct String *blk, char **str)
{
  do
  {
    if(!(blk->buffer_ == ((char *)NULL)))
    {
      free((void *)blk->buffer_);
      blk->buffer_ = (char *)(void *)0;
    }

    blk->capacity_ = (unsigned long int)0;
    blk->length_ = (unsigned long int)0;
  }
  while((_Bool)0);
  if(!(str == ((char **)NULL)))
  {
    if(!(*str == ((char *)NULL)))
    {
      blk->buffer_ = *str;
      blk->length_=strlen((const char *)blk->buffer_);
      blk->capacity_ = blk->length_;
      *str = (char *)(void *)0;
    }

  }

}

// Write_EndOfCentralDirectoryRecord
// file minizip/zip.c line 1817
static signed int Write_EndOfCentralDirectoryRecord(struct anonymous_9 *zi, unsigned long int size_centraldir, unsigned long long int centraldir_pos_inzip)
{
  signed int err = 0;
  err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0x06054b50, 4);
  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 2);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 2);

  if(err == 0)
  {
    if(zi->number_entry >= 65535ul)
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0xffff, 2);

    else
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)zi->number_entry, 2);
  }

  if(err == 0)
  {
    if(zi->number_entry >= 65535ul)
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0xffff, 2);

    else
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)zi->number_entry, 2);
  }

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)size_centraldir, 4);

  if(err == 0)
  {
    unsigned long long int pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
    if(pos >= 4294967295ul)
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0xffffffff, 4);

    else
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)(centraldir_pos_inzip - zi->add_position_when_writting_offset), 4);
  }

  return err;
}

// Write_GlobalComment
// file minizip/zip.c line 1865
static signed int Write_GlobalComment(struct anonymous_9 *zi, const char *global_comment)
{
  signed int err = 0;
  unsigned int size_global_comment = (unsigned int)0;
  unsigned long int return_value_strlen_1;
  if(!(global_comment == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(global_comment);
    size_global_comment = (unsigned int)return_value_strlen_1;
  }

  err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)size_global_comment, 2);
  if(err == 0 && size_global_comment >= 1u)
  {
    unsigned long int return_value;
    return_value=zi->z_filefunc.zfile_func64.zwrite_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream, (const void *)global_comment, (unsigned long int)size_global_comment);
    if(!(return_value == (unsigned long int)size_global_comment))
      err = -1;

  }

  return err;
}

// Write_LocalFileHeader
// file minizip/zip.c line 958
static signed int Write_LocalFileHeader(struct anonymous_9 *zi, const char *filename, unsigned int size_extrafield_local, const void *extrafield_local)
{
  signed int err;
  unsigned int size_filename;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(filename);
  size_filename = (unsigned int)return_value_strlen_1;
  unsigned int size_extrafield = size_extrafield_local;
  err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0x04034b50, 4);
  if(err == 0)
  {
    if(!(zi->ci.zip64 == 0))
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)45, 2);

    else
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)20, 2);
  }

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)zi->ci.flag, 2);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)zi->ci.method, 2);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)zi->ci.dosDate, 4);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 4);

  if(err == 0)
  {
    if(!(zi->ci.zip64 == 0))
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0xFFFFFFFF, 4);

    else
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 4);
  }

  if(err == 0)
  {
    if(!(zi->ci.zip64 == 0))
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0xFFFFFFFF, 4);

    else
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 4);
  }

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)size_filename, 2);

  if(!(zi->ci.zip64 == 0))
    size_extrafield = size_extrafield + (unsigned int)20;

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)size_extrafield, 2);

  if(err == 0 && size_filename >= 1u)
  {
    unsigned long int return_value;
    return_value=zi->z_filefunc.zfile_func64.zwrite_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream, (const void *)filename, (unsigned long int)size_filename);
    if(!(return_value == (unsigned long int)size_filename))
      err = -1;

  }

  if(err == 0 && size_extrafield_local >= 1u)
  {
    unsigned long int return_value_1;
    return_value_1=zi->z_filefunc.zfile_func64.zwrite_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream, extrafield_local, (unsigned long int)size_extrafield_local);
    if(!(return_value_1 == (unsigned long int)size_extrafield_local))
      err = -1;

  }

  if(err == 0)
  {
    if(!(zi->ci.zip64 == 0))
    {
      signed short int HeaderID = (signed short int)1;
      signed short int DataSize = (signed short int)16;
      unsigned long long int CompressedSize = (unsigned long long int)0;
      unsigned long long int UncompressedSize = (unsigned long long int)0;
      zi->ci.pos_zip64extrainfo=call_ztell64(&zi->z_filefunc, zi->filestream);
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)(signed short int)HeaderID, 2);
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)(signed short int)DataSize, 2);
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)UncompressedSize, 8);
      err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)CompressedSize, 8);
    }

  }

  return err;
}

// Write_Zip64EndOfCentralDirectoryLocator
// file minizip/zip.c line 1755
static signed int Write_Zip64EndOfCentralDirectoryLocator(struct anonymous_9 *zi, unsigned long long int zip64eocd_pos_inzip)
{
  signed int err = 0;
  unsigned long long int pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;
  err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0x7064b50, 4);
  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 4);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, pos, 8);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)1, 4);

  return err;
}

// Write_Zip64EndOfCentralDirectoryRecord
// file minizip/zip.c line 1777
static signed int Write_Zip64EndOfCentralDirectoryRecord(struct anonymous_9 *zi, unsigned long int size_centraldir, unsigned long long int centraldir_pos_inzip)
{
  signed int err = 0;
  unsigned long int Zip64DataSize = (unsigned long int)44;
  err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0x6064b50, 4);
  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)Zip64DataSize, 8);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)45, 2);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)45, 2);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 4);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long int)0, 4);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);

  if(err == 0)
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)size_centraldir, 8);

  if(err == 0)
  {
    unsigned long long int pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
    err=zip64local_putValue(&zi->z_filefunc, zi->filestream, (unsigned long long int)pos, 8);
  }

  return err;
}

// abortLog__fnc
// file proxy/proxytrack.c line 150
void abortLog__fnc(char *msg, char *file, signed int line)
{
  struct _IO_FILE *fp;
  fp=fopen("CRASH.TXT", "wb");
  if(fp == ((struct _IO_FILE *)NULL))
    fp=fopen("/tmp/CRASH.TXT", "wb");

  if(fp == ((struct _IO_FILE *)NULL))
    fp=fopen("C:\\CRASH.TXT", "wb");

  if(fp == ((struct _IO_FILE *)NULL))
    fp=fopen("CRASH.TXT", "wb");

  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    fprintf(fp, "HTTrack 3.48.21 closed at '%s', line %d\r\n", file, line);
    fprintf(fp, "Reason:\r\n%s\r\n", msg);
    fflush(fp);
    fclose(fp);
  }

}

// abortf_
// file ./htssafe.h line 95
static void abortf_(const char *exp, const char *file, signed int line)
{
  log_abort_(exp, file, line);
  abort();
}

// abortf__link1
// file ./htssafe.h line 95
static void abortf__link1(const char *exp_link1, const char *file_link1, signed int line_link1)
{
  log_abort__link1(exp_link1, file_link1, line_link1);
  abort();
}

// add_data_in_datablock
// file minizip/zip.c line 225
static signed int add_data_in_datablock(struct linkedlist_data_s *ll, const void *buf, unsigned long int len)
{
  struct linkedlist_datablock_internal_s *ldi;
  const unsigned char *from_copy;
  if(ll == ((struct linkedlist_data_s *)NULL))
    return -104;

  else
    if(ll->last_block == ((struct linkedlist_datablock_internal_s *)NULL))
    {
      ll->last_block=allocate_new_datablock();
      ll->first_block = ll->last_block;
      if(!(ll->first_block == ((struct linkedlist_datablock_internal_s *)NULL)))
        goto __CPROVER_DUMP_L2;

      return -104;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      ldi = ll->last_block;
      from_copy = (const unsigned char *)buf;
      while(len >= 1ul)
      {
        unsigned int copy_this;
        unsigned int i;
        unsigned char *to_copy;
        if(ldi->avail_in_this_block == 0ul)
        {
          ldi->next_datablock=allocate_new_datablock();
          if(ldi->next_datablock == ((struct linkedlist_datablock_internal_s *)NULL))
            return -104;

          ldi = ldi->next_datablock;
          ll->last_block = ldi;
        }

        if(!(ldi->avail_in_this_block >= len))
          copy_this = (unsigned int)ldi->avail_in_this_block;

        else
          copy_this = (unsigned int)len;
        to_copy = &ldi->data[(signed long int)ldi->filled_in_this_block];
        i = (unsigned int)0;
        for( ; !(i >= copy_this); i = i + 1u)
          to_copy[(signed long int)i] = from_copy[(signed long int)i];
        ldi->filled_in_this_block = ldi->filled_in_this_block + (unsigned long int)copy_this;
        ldi->avail_in_this_block = ldi->avail_in_this_block - (unsigned long int)copy_this;
        from_copy = from_copy + (signed long int)copy_this;
        len = len - (unsigned long int)copy_this;
      }
      return 0;
    }
}

// allocate_new_datablock
// file minizip/zip.c line 189
static struct linkedlist_datablock_internal_s * allocate_new_datablock(void)
{
  struct linkedlist_datablock_internal_s *ldi;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct linkedlist_datablock_internal_s) /*4112ul*/ );
  ldi = (struct linkedlist_datablock_internal_s *)return_value_malloc_1;
  if(!(ldi == ((struct linkedlist_datablock_internal_s *)NULL)))
  {
    ldi->next_datablock = (struct linkedlist_datablock_internal_s *)(void *)0;
    ldi->filled_in_this_block = (unsigned long int)0;
    ldi->avail_in_this_block = (unsigned long int)(4096 - 4 * 4);
  }

  return ldi;
}

// binput
// file proxy/store.c line 258
static signed int binput(char *buff, char *s, signed int max)
{
  signed int count = 0;
  signed int destCount = 0;
  signed int tmp_post_1;
  for( ; !(destCount >= max); count = count + 1)
  {
    if((signed int)buff[(signed long int)count] == 0)
      break;

    if((signed int)buff[(signed long int)count] == 10)
      break;

    if(!((signed int)buff[(signed long int)count] == 13))
    {
      tmp_post_1 = destCount;
      destCount = destCount + 1;
      s[(signed long int)tmp_post_1] = buff[(signed long int)count];
    }

  }
  s[(signed long int)destCount] = (char)0;
  return count + 1;
}

// byteReverse
// file md5.c line 33
static void byteReverse(unsigned char *buf, unsigned int longs)
{
  do
  {

  __CPROVER_DUMP_L1:
    ;
    buf[(signed long int)0] = buf[(signed long int)0] ^ buf[(signed long int)3];
    buf[(signed long int)3] = buf[(signed long int)3] ^ buf[(signed long int)0];
    buf[(signed long int)0] = buf[(signed long int)0] ^ buf[(signed long int)3];
    do
    {
      buf[(signed long int)1] = buf[(signed long int)1] ^ buf[(signed long int)2];
      buf[(signed long int)2] = buf[(signed long int)2] ^ buf[(signed long int)1];
      buf[(signed long int)1] = buf[(signed long int)1] ^ buf[(signed long int)2];
    }
    while((_Bool)0);
    buf = buf + (signed long int)4;
    longs = longs - 1u;
  }
  while(!(longs == 0u));
}

// cache_brstr
// file proxy/store.c line 1354
static signed int cache_brstr(char *adr, char *s)
{
  signed int i;
  signed int off;
  char buff[257l];
  off=binput(adr, buff, 256);
  adr = adr + (signed long int)off;
  sscanf(buff, "%d", &i);
  if(i >= 1)
    strncpy(s, adr, (unsigned long int)i);

  s[(signed long int)i] = (char)0;
  off = off + i;
  return off;
}

// cache_rLLint
// file proxy/store.c line 1413
static void cache_rLLint(struct _IO_FILE *fp, unsigned long int *i)
{
  signed int l;
  char s[256l];
  cache_rstr(fp, s);
  sscanf(s, "%d", &l);
  *i = (unsigned long int)l;
}

// cache_rint
// file proxy/store.c line 1406
static void cache_rint(struct _IO_FILE *fp, signed int *i)
{
  char s[256l];
  cache_rstr(fp, s);
  sscanf(s, "%d", i);
}

// cache_rstr
// file proxy/store.c line 1369
static void cache_rstr(struct _IO_FILE *fp, char *s)
{
  signed int i;
  char buff[260l];
  linput_link1(fp, buff, 256);
  sscanf(buff, "%d", &i);
  if(i >= 32769 || !(i >= 0))
    i = 0;

  if(i >= 1)
  {
    unsigned long int return_value_fread_1;
    return_value_fread_1=fread((void *)s, (unsigned long int)1, (unsigned long int)i, fp);
    if(!((signed int)return_value_fread_1 == i))
    {
      abortf__link1("! \"fread_cache_failed\"", "proxy/store.c", 1379);
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    }

  }

  s[(signed long int)i] = (char)0;
}

// cache_rstr_addr
// file proxy/store.c line 1385
static char * cache_rstr_addr(struct _IO_FILE *fp)
{
  signed int i;
  char *addr = (char *)(void *)0;
  char buff[260l];
  linput_link1(fp, buff, 256);
  sscanf(buff, "%d", &i);
  if(i >= 32769 || !(i >= 0))
    i = 0;

  if(i >= 1)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(i + 1));
    addr = (char *)return_value_malloc_1;
    if(!(addr == ((char *)NULL)))
    {
      unsigned long int return_value_fread_2;
      return_value_fread_2=fread((void *)addr, (unsigned long int)1, (unsigned long int)i, fp);
      if(!((signed int)return_value_fread_2 == i))
      {
        abortf__link1("! \"fread_cache_failed\"", "proxy/store.c", 1398);
        (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
      }

      addr[(signed long int)i] = (char)0;
    }

  }

  return addr;
}

// call_zopen64
// file minizip/ioapi.c line 31
void * call_zopen64(const struct zlib_filefunc64_32_def_s *pfilefunc, const void *filename, signed int mode)
{
  void *return_value;
  if(!(pfilefunc->zfile_func64.zopen64_file == ((void * (*)(void *, const void *, signed int))NULL)))
  {
    return_value=pfilefunc->zfile_func64.zopen64_file(pfilefunc->zfile_func64.opaque, filename, mode);
    return return_value;
  }

  else
  {
    void *return_value_1;
    return_value_1=pfilefunc->zopen32_file(pfilefunc->zfile_func64.opaque, (const char *)filename, mode);
    return return_value_1;
  }
}

// call_zseek64
// file minizip/ioapi.c line 41
signed long int call_zseek64(const struct zlib_filefunc64_32_def_s *pfilefunc, void *filestream, unsigned long long int offset, signed int origin)
{
  signed long int return_value;
  signed long int return_value_1;
  if(!(pfilefunc->zfile_func64.zseek64_file == ((signed long int (*)(void *, void *, unsigned long long int, signed int))NULL)))
  {
    return_value=pfilefunc->zfile_func64.zseek64_file(pfilefunc->zfile_func64.opaque, filestream, offset, origin);
    return return_value;
  }

  else
  {
    unsigned long int offsetTruncated = (unsigned long int)offset;
    if(!(offsetTruncated == offset))
      return (signed long int)-1;

    else
    {
      return_value_1=pfilefunc->zseek32_file(pfilefunc->zfile_func64.opaque, filestream, offsetTruncated, origin);
      return return_value_1;
    }
  }
}

// call_ztell64
// file minizip/ioapi.c line 55
unsigned long long int call_ztell64(const struct zlib_filefunc64_32_def_s *pfilefunc, void *filestream)
{
  unsigned long long int return_value;
  if(!(pfilefunc->zfile_func64.zseek64_file == ((signed long int (*)(void *, void *, unsigned long long int, signed int))NULL)))
  {
    return_value=pfilefunc->zfile_func64.ztell64_file(pfilefunc->zfile_func64.opaque, filestream);
    return return_value;
  }

  else
  {
    unsigned long int tell_uLong;
    signed long int return_value_1;
    return_value_1=pfilefunc->ztell32_file(pfilefunc->zfile_func64.opaque, filestream);
    tell_uLong = (unsigned long int)return_value_1;
    if(tell_uLong == 4294967295ul)
      return (unsigned long long int)-1;

    else
      return tell_uLong;
  }
}

// check_readinput_t
// file proxy/proxytrack.c line 204
static signed int check_readinput_t(signed int soc, signed int timeout)
{
  if(!(soc == -1))
  {
    struct anonymous_12 fds;
    struct timeval tv;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_12) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&fds)->__fds_bits[(signed long int)(soc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(soc / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << soc % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tv.tv_sec = (signed long int)timeout;
    tv.tv_usec = (signed long int)0;
    select((signed int)(soc + 1), &fds, (struct anonymous_12 *)(void *)0, (struct anonymous_12 *)(void *)0, &tv);
    if(!((fds.__fds_bits[(signed long int)(soc / 8)] & (signed long int)(1UL << soc % 8)) == 0l))
      return 1;

    else
      return 0;
  }

  else
    return 0;
}

// convert_time_rfc822
// file proxy/proxytrack.h line 271
static struct tm * convert_time_rfc822(struct tm *result, const char *s)
{
  char months[48l] = { 'j', 'a', 'n', ' ', 'f', 'e', 'b', ' ', 'm', 'a', 'r', ' ', 'a', 'p', 'r', ' ', 'm', 'a', 'y', ' ', 'j', 'u', 'n', ' ', 'j', 'u', 'l', ' ', 'a', 'u', 'g', ' ', 's', 'e', 'p', ' ', 'o', 'c', 't', ' ', 'n', 'o', 'v', ' ', 'd', 'e', 'c', 0 };
  char str[256l];
  char *a;
  signed int result_mm = -1;
  signed int result_dd = -1;
  signed int result_n1 = -1;
  signed int result_n2 = -1;
  signed int result_n3 = -1;
  signed int result_n4 = -1;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  if((signed int)return_value_strlen_1 >= 201)
    return (struct tm *)(void *)0;

  else
  {
    strcpy(str, s);
    set_lowcase(str);
    do
    {
      a=strchr(str, 45);
      if(a == ((char *)NULL))
        break;

      *a = (char)32;
    }
    while((_Bool)1);
    do
    {
      a=strchr(str, 58);
      if(a == ((char *)NULL))
        break;

      *a = (char)32;
    }
    while((_Bool)1);
    do
    {
      a=strchr(str, 44);
      if(a == ((char *)NULL))
        break;

      *a = (char)32;
    }
    while((_Bool)1);
    a = str;
    while(!(*a == 0))
    {
      char *first;
      char *last;
      char tok[256l];
      for( ; (signed int)*a == 32; a = a + 1l)
        ;
      first = a;
      for( ; !(*a == 0); a = a + 1l)
        if((signed int)*a == 32)
          break;

      last = a;
      tok[(signed long int)0] = (char)0;
      if(!(first == last))
      {
        char *pos;
        strncat(tok, first, (unsigned long int)(signed int)(last - first));
        pos=strstr(months, tok);
        if(!(pos == ((char *)NULL)))
          result_mm = (signed int)(pos - months) / 4;

        else
        {
          signed int number;
          signed int return_value_sscanf_2;
          return_value_sscanf_2=sscanf(tok, "%d", &number);
          if(return_value_sscanf_2 == 1)
          {
            if(!(result_dd >= 0))
              result_dd = number;

            else
              if(!(result_n1 >= 0))
                result_n1 = number;

              else
                if(!(result_n2 >= 0))
                  result_n2 = number;

                else
                  if(!(result_n3 >= 0))
                    result_n3 = number;

                  else
                    if(!(result_n4 >= 0))
                      result_n4 = number;

          }

        }
      }

    }
    if(result_dd >= 0 && result_mm >= 0 && result_n1 >= 0 && result_n2 >= 0 && result_n3 >= 0 && result_n4 >= 0)
    {
      if(result_n4 >= 1000)
      {
        result->tm_year = result_n4 - 1900;
        result->tm_hour = result_n1;
        result->tm_min = result_n2;
        result->tm_sec = result_n3 > 0 ? result_n3 : 0;
      }

      else
      {
        result->tm_hour = result_n2;
        result->tm_min = result_n3;
        result->tm_sec = result_n4 > 0 ? result_n4 : 0;
        if(!(result_n1 >= 51))
          result->tm_year = result_n1 + 100;

        else
          if(!(result_n1 >= 1000))
            result->tm_year = result_n1;

          else
            result->tm_year = result_n1 - 1900;
      }
      result->tm_isdst = 0;
      result->tm_yday = -1;
      result->tm_wday = -1;
      result->tm_mon = result_mm;
      result->tm_mday = result_dd;
      return result;
    }

    else
      return (struct tm *)(void *)0;
  }
}

// copyArcField
// file proxy/store.c line 1877
static char * copyArcField(const char *line, signed int npos, char *dest, signed int destMax)
{
  const char *pos;
  pos=getArcField(line, npos);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(pos == ((const char *)NULL)))
  {
    signed int i = 0;
    do
    {
      if(!((signed int)pos[(signed long int)i] == 0))
        tmp_if_expr_1 = (signed int)pos[(signed long int)i] != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        destMax = destMax - 1;
        tmp_if_expr_2 = destMax > 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      dest[(signed long int)i] = pos[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    dest[(signed long int)i] = (char)0;
    return dest;
  }

  dest[(signed long int)0] = (char)0;
  return (char *)(void *)0;
}

// coucal_add
// file ./coucal.h line 435
extern void coucal_add(struct struct_coucal *hashtable, const void *name, signed long int intvalue)
{
  union coucal_value value = { .intg=(signed long int)0 };
  memset((void *)&value, 0, sizeof(union coucal_value) /*8ul*/ );
  value.intg = intvalue;
  coucal_write_value(hashtable, name, value);
}

// coucal_add_item_
// file coucal.c line 883
static signed int coucal_add_item_(struct struct_coucal *hashtable, struct coucal_item item)
{
  unsigned int cuckoo_hash;
  unsigned int initial_cuckoo_hash;
  unsigned long int loops;
  unsigned long int pos;
  pos=coucal_hash_to_pos(hashtable, item.hashes.hash1);
  signed int return_value_coucal_is_free_3;
  return_value_coucal_is_free_3=coucal_is_free(hashtable, pos);
  if(!(return_value_coucal_is_free_3 == 0))
  {
    hashtable->items[(signed long int)pos] = item;
    return 1;
  }

  else
  {
    pos=coucal_hash_to_pos(hashtable, item.hashes.hash2);
    signed int return_value_coucal_is_free_2;
    return_value_coucal_is_free_2=coucal_is_free(hashtable, pos);
    if(!(return_value_coucal_is_free_2 == 0))
    {
      hashtable->items[(signed long int)pos] = item;
      return 1;
    }

    else
    {
      initial_cuckoo_hash = item.hashes.hash1;
      cuckoo_hash = initial_cuckoo_hash;
      const char *return_value_coucal_print_key_1;
      return_value_coucal_print_key_1=coucal_print_key(hashtable, item.name);
      coucal_nolog(hashtable, "debug:collision with '%s' at %ld (%x)", return_value_coucal_print_key_1, (unsigned long int)pos, cuckoo_hash);
    }
  }
  loops = (unsigned long int)1 << hashtable->lg_size;
  unsigned long int return_value_coucal_hash_to_pos_5;
  for( ; !(loops == 0ul); loops = loops - 1ul)
  {
    unsigned long int coucal_add_item___1__3__1__pos;
    coucal_add_item___1__3__1__pos=coucal_hash_to_pos(hashtable, cuckoo_hash);
    const char *return_value_coucal_print_key_4;
    return_value_coucal_print_key_4=coucal_print_key(hashtable, item.name);
    coucal_nolog(hashtable, "\tdebug:placing cuckoo '%s' at %ld (%x)", return_value_coucal_print_key_4, (unsigned long int)coucal_add_item___1__3__1__pos, cuckoo_hash);
    signed int return_value_coucal_is_free_7;
    return_value_coucal_is_free_7=coucal_is_free(hashtable, coucal_add_item___1__3__1__pos);
    if(!(return_value_coucal_is_free_7 == 0))
    {
      coucal_nolog(hashtable, "debug:free position");
      hashtable->items[(signed long int)coucal_add_item___1__3__1__pos] = item;
      return 1;
    }

    else
    {
      const struct coucal_item backup_item = hashtable->items[(signed long int)coucal_add_item___1__3__1__pos];
      hashtable->items[(signed long int)coucal_add_item___1__3__1__pos] = item;
      hashtable->stats.cuckoo_moved = hashtable->stats.cuckoo_moved + 1ul;
      item = backup_item;
      unsigned long int return_value_coucal_hash_to_pos_6;
      return_value_coucal_hash_to_pos_6=coucal_hash_to_pos(hashtable, item.hashes.hash1);
      if(coucal_add_item___1__3__1__pos == return_value_coucal_hash_to_pos_6)
      {
        coucal_nolog(hashtable, "\tdebug:position 1");
        cuckoo_hash = item.hashes.hash2;
      }

      else
      {
        return_value_coucal_hash_to_pos_5=coucal_hash_to_pos(hashtable, item.hashes.hash2);
        if(coucal_add_item___1__3__1__pos == return_value_coucal_hash_to_pos_5)
        {
          coucal_nolog(hashtable, "\tdebug:position 2");
          cuckoo_hash = item.hashes.hash1;
        }

        else
        {
          coucal_assert_failed(hashtable, "! \"hashtable internal error: unexpected position\"", "coucal.c", 950);
          (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
        }
      }
      if(cuckoo_hash == initial_cuckoo_hash)
        break;

    }
  }
  if(!(hashtable->stash.size >= 16ul))
  {
    hashtable->stash.items[(signed long int)hashtable->stash.size] = item;
    hashtable->stash.size = hashtable->stash.size + 1ul;
    hashtable->stats.stash_added = hashtable->stats.stash_added + 1ul;
    if(!(hashtable->stats.max_stash_size >= hashtable->stash.size))
      hashtable->stats.max_stash_size = hashtable->stash.size;

    coucal_nolog(hashtable, "used stash because of collision (%d entries)", (signed int)hashtable->stash.size);
    return 1;
  }

  else
  {
    if(!(hashtable->custom.print.key == ((const char * (*)(void *, const void *))NULL)))
    {
      if(!(hashtable->custom.print.value == ((const char * (*)(void *, const union coucal_value))NULL)))
      {
        unsigned long int i = (unsigned long int)0;
        if(!(i >= hashtable->stash.size))
        {
          struct coucal_item * const coucal_add_item___1__5__1__1__1__item = &hashtable->stash.items[(signed long int)i];
          unsigned long int pos1;
          pos1=coucal_hash_to_pos(hashtable, coucal_add_item___1__5__1__1__1__item->hashes.hash1);
          unsigned long int pos2;
          pos2=coucal_hash_to_pos(hashtable, coucal_add_item___1__5__1__1__1__item->hashes.hash2);
          const char *return_value;
          return_value=hashtable->custom.print.key(hashtable->custom.print.arg, coucal_add_item___1__5__1__1__1__item->name);
          const char *return_value_1;
          return_value_1=hashtable->custom.print.value(hashtable->custom.print.arg, coucal_add_item___1__5__1__1__1__item->value);
          coucal_crit(hashtable, "stash[%u]: key='%s' value='%s' pos1=%d pos2=%d hash1=%04x hash2=%04x", (signed int)i, return_value, return_value_1, (signed int)pos1, (signed int)pos2, coucal_add_item___1__5__1__1__1__item->hashes.hash1, coucal_add_item___1__5__1__1__1__item->hashes.hash2);
          signed int return_value_coucal_is_free_8;
          return_value_coucal_is_free_8=coucal_is_free(hashtable, pos1);
          if(return_value_coucal_is_free_8 == 0)
          {
            struct coucal_item * const coucal_add_item___1__5__1__1__1__1__item = &hashtable->items[(signed long int)pos1];
            unsigned long int coucal_add_item___1__5__1__1__1__1__pos1;
            coucal_add_item___1__5__1__1__1__1__pos1=coucal_hash_to_pos(hashtable, coucal_add_item___1__5__1__1__1__1__item->hashes.hash1);
            unsigned long int coucal_add_item___1__5__1__1__1__1__pos2;
            coucal_add_item___1__5__1__1__1__1__pos2=coucal_hash_to_pos(hashtable, coucal_add_item___1__5__1__1__1__1__item->hashes.hash2);
            const char *return_value_2;
            return_value_2=hashtable->custom.print.key(hashtable->custom.print.arg, coucal_add_item___1__5__1__1__1__1__item->name);
            const char *return_value_3;
            return_value_3=hashtable->custom.print.value(hashtable->custom.print.arg, coucal_add_item___1__5__1__1__1__1__item->value);
            coucal_crit(hashtable, "\t.. collisionning with key='%s' value='%s' pos1=%d pos2=%d hash1=%04x hash2=%04x", return_value_2, return_value_3, (signed int)coucal_add_item___1__5__1__1__1__1__pos1, (signed int)coucal_add_item___1__5__1__1__1__1__pos2, coucal_add_item___1__5__1__1__1__1__item->hashes.hash1, coucal_add_item___1__5__1__1__1__1__item->hashes.hash2);
          }

          else
            coucal_crit(hashtable, "\t.. collisionning with a free slot (%d)!", (signed int)pos1);
          signed int return_value_coucal_is_free_9;
          return_value_coucal_is_free_9=coucal_is_free(hashtable, pos2);
          if(return_value_coucal_is_free_9 == 0)
          {
            struct coucal_item * const coucal_add_item___1__5__1__1__1__3__item = &hashtable->items[(signed long int)pos2];
            unsigned long int coucal_add_item___1__5__1__1__1__3__pos1;
            coucal_add_item___1__5__1__1__1__3__pos1=coucal_hash_to_pos(hashtable, coucal_add_item___1__5__1__1__1__3__item->hashes.hash1);
            unsigned long int coucal_add_item___1__5__1__1__1__3__pos2;
            coucal_add_item___1__5__1__1__1__3__pos2=coucal_hash_to_pos(hashtable, coucal_add_item___1__5__1__1__1__3__item->hashes.hash2);
            const char *return_value_4;
            return_value_4=hashtable->custom.print.key(hashtable->custom.print.arg, coucal_add_item___1__5__1__1__1__3__item->name);
            const char *return_value_5;
            return_value_5=hashtable->custom.print.value(hashtable->custom.print.arg, coucal_add_item___1__5__1__1__1__3__item->value);
            coucal_crit(hashtable, "\t.. collisionning with key='%s' value='%s' pos1=%d pos2=%d hash1=%04x hash2=%04x", return_value_4, return_value_5, (signed int)coucal_add_item___1__5__1__1__1__3__pos1, (signed int)coucal_add_item___1__5__1__1__1__3__pos2, coucal_add_item___1__5__1__1__1__3__item->hashes.hash1, coucal_add_item___1__5__1__1__1__3__item->hashes.hash2);
          }

          else
            coucal_crit(hashtable, "\t.. collisionning with a free slot (%d)!", (signed int)pos2);
          i = i + 1ul;
        }

      }

    }

    coucal_log_stats(hashtable);
    coucal_assert_failed(hashtable, "! \"hashtable internal error: cuckoo/stash collision\"", "coucal.c", 1022);
    (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    return -1;
  }
}

// coucal_add_pvoid
// file coucal.c line 775
extern void coucal_add_pvoid(struct struct_coucal *hashtable, const void *name, void *pvalue)
{
  union coucal_value value = { .intg=(signed long int)0 };
  value.ptr = pvalue;
  coucal_write_value(hashtable, name, value);
}

// coucal_assert_failed
// file coucal.c line 293
static void coucal_assert_failed(struct struct_coucal * const hashtable, const char *exp, const char *file, signed int line)
{
  const char *name;
  name=coucal_get_name(hashtable);
  coucal_crit(hashtable, "hashtable %s: %s failed at %s:%d", name != (const char *)(void *)0 ? name : "<unknown>", exp, file, line);
  _Bool tmp_if_expr_1;
  if(!(hashtable == ((struct struct_coucal *)NULL)))
    tmp_if_expr_1 = hashtable->custom.error.fatal != (void (*)(void *, const char *, const char *, signed int))(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    hashtable->custom.error.fatal(hashtable->custom.error.arg, exp, file, line);

  else
    if(!(global_assert_handler == ((void (*)(void *, const char *, const char *, signed int))NULL)))
      global_assert_handler((void *)hashtable, exp, file, line);

    else
      coucal_fail(exp, file, line);
  abort();
}

// coucal_calc_hashes
// file coucal.c line 480
inline struct coucal_hashkeys coucal_calc_hashes(struct struct_coucal *hashtable, const void *value)
{
  struct coucal_hashkeys tmp_if_expr_2;
  struct coucal_hashkeys return_value_coucal_hash_string_1;
  struct coucal_hashkeys return_value;
  if(hashtable->custom.key.hash == ((struct coucal_hashkeys (*)(void *, const void *))NULL))
  {
    return_value_coucal_hash_string_1=coucal_hash_string((const char *)value);
    tmp_if_expr_2 = return_value_coucal_hash_string_1;
  }

  else
  {
    return_value=hashtable->custom.key.hash(hashtable->custom.key.arg, value);
    tmp_if_expr_2 = return_value;
  }
  return tmp_if_expr_2;
}

// coucal_compact_pool
// file coucal.c line 519
static void coucal_compact_pool(struct struct_coucal *hashtable, unsigned long int capacity)
{
  const unsigned long int hash_size = (unsigned long int)1 << hashtable->lg_size;
  unsigned long int coucal_compact_pool__1__i;
  char * const old_pool = hashtable->pool.buffer;
  const unsigned long int old_size = hashtable->pool.size;
  unsigned long int count = (unsigned long int)0;
  if(hashtable->custom.key.dup == ((void * (*)(void *, const void *))NULL))
    (_Bool)1;

  else
  {
    coucal_assert_failed(hashtable, "hashtable->custom.key.dup == NULL", "coucal.c", 527);
    (_Bool)0;
  }
  hashtable->stats.pool_compact_count = hashtable->stats.pool_compact_count + 1ul;
  if(!(hashtable->pool.capacity == capacity))
    hashtable->pool.capacity = capacity;

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(hashtable->pool.capacity);
  hashtable->pool.buffer = (char *)return_value_malloc_1;
  hashtable->pool.size = (unsigned long int)0;
  hashtable->pool.used = (unsigned long int)0;
  if(hashtable->pool.buffer == ((char *)NULL))
  {
    coucal_nolog(hashtable, "** hashtable string pool compaction error: could not allocate %ld bytes", (unsigned long int)hashtable->pool.capacity);
    coucal_assert_failed(hashtable, "! \"hashtable string pool compaction error\"", "coucal.c", 546);
    (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
  }

  coucal_compact_pool__1__i = (unsigned long int)0;
  for( ; !(coucal_compact_pool__1__i >= hash_size); coucal_compact_pool__1__i = coucal_compact_pool__1__i + 1ul)
    do
      if(!((hashtable->items + (signed long int)coucal_compact_pool__1__i)->name == NULL))
      {
        if(!((char *)(hashtable->items + (signed long int)coucal_compact_pool__1__i)->name == the_empty_string))
        {
          const char * const src = (const char *)(hashtable->items + (signed long int)coucal_compact_pool__1__i)->name;
          char * const dest = &hashtable->pool.buffer[(signed long int)hashtable->pool.size];
          const unsigned long int coucal_compact_pool__1__3__1__1__1__capacity = hashtable->pool.capacity;
          char * const max_dest = &hashtable->pool.buffer[(signed long int)coucal_compact_pool__1__3__1__1__1__capacity];
          if(!(dest >= max_dest))
            (_Bool)1;

          else
          {
            coucal_assert_failed(hashtable, "dest < max_dest", "coucal.c", 580);
            (_Bool)0;
          }
          dest[(signed long int)0] = src[(signed long int)0];
          unsigned long int i = (unsigned long int)1;
          for( ; !((signed int)src[-1l + (signed long int)i] == 0); i = i + 1ul)
          {
            if(!(dest + (signed long int)i >= max_dest))
              (_Bool)1;

            else
            {
              coucal_assert_failed(hashtable, "&dest[i] < max_dest", "coucal.c", 580);
              (_Bool)0;
            }
            dest[(signed long int)i] = src[(signed long int)i];
          }
          hashtable->pool.size = hashtable->pool.size + i;
          if(coucal_compact_pool__1__3__1__1__1__capacity >= hashtable->pool.size)
            (_Bool)1;

          else
          {
            coucal_assert_failed(hashtable, "hashtable->pool.size <= capacity", "coucal.c", 580);
            (_Bool)0;
          }
          (hashtable->items + (signed long int)coucal_compact_pool__1__i)->name = (void *)dest;
          count = count + 1ul;
        }

      }

    while((_Bool)0);
  coucal_compact_pool__1__i = (unsigned long int)0;
  for( ; !(coucal_compact_pool__1__i >= hashtable->stash.size); coucal_compact_pool__1__i = coucal_compact_pool__1__i + 1ul)
    do
      if(!(hashtable->stash.items[(signed long int)coucal_compact_pool__1__i].name == NULL))
      {
        if(!((char *)hashtable->stash.items[(signed long int)coucal_compact_pool__1__i].name == the_empty_string))
        {
          const char * const coucal_compact_pool__1__4__1__1__1__src = (const char *)hashtable->stash.items[(signed long int)coucal_compact_pool__1__i].name;
          char * const coucal_compact_pool__1__4__1__1__1__dest = &hashtable->pool.buffer[(signed long int)hashtable->pool.size];
          const unsigned long int coucal_compact_pool__1__4__1__1__1__capacity = hashtable->pool.capacity;
          char * const coucal_compact_pool__1__4__1__1__1__max_dest = &hashtable->pool.buffer[(signed long int)coucal_compact_pool__1__4__1__1__1__capacity];
          if(!(coucal_compact_pool__1__4__1__1__1__dest >= coucal_compact_pool__1__4__1__1__1__max_dest))
            (_Bool)1;

          else
          {
            coucal_assert_failed(hashtable, "dest < max_dest", "coucal.c", 583);
            (_Bool)0;
          }
          coucal_compact_pool__1__4__1__1__1__dest[(signed long int)0] = coucal_compact_pool__1__4__1__1__1__src[(signed long int)0];
          unsigned long int coucal_compact_pool__1__4__1__1__1__1__i = (unsigned long int)1;
          for( ; !((signed int)coucal_compact_pool__1__4__1__1__1__src[-1l + (signed long int)coucal_compact_pool__1__4__1__1__1__1__i] == 0); coucal_compact_pool__1__4__1__1__1__1__i = coucal_compact_pool__1__4__1__1__1__1__i + 1ul)
          {
            if(!(coucal_compact_pool__1__4__1__1__1__dest + (signed long int)coucal_compact_pool__1__4__1__1__1__1__i >= coucal_compact_pool__1__4__1__1__1__max_dest))
              (_Bool)1;

            else
            {
              coucal_assert_failed(hashtable, "&dest[i] < max_dest", "coucal.c", 583);
              (_Bool)0;
            }
            coucal_compact_pool__1__4__1__1__1__dest[(signed long int)coucal_compact_pool__1__4__1__1__1__1__i] = coucal_compact_pool__1__4__1__1__1__src[(signed long int)coucal_compact_pool__1__4__1__1__1__1__i];
          }
          hashtable->pool.size = hashtable->pool.size + coucal_compact_pool__1__4__1__1__1__1__i;
          if(coucal_compact_pool__1__4__1__1__1__capacity >= hashtable->pool.size)
            (_Bool)1;

          else
          {
            coucal_assert_failed(hashtable, "hashtable->pool.size <= capacity", "coucal.c", 583);
            (_Bool)0;
          }
          hashtable->stash.items[(signed long int)coucal_compact_pool__1__i].name = (void *)coucal_compact_pool__1__4__1__1__1__dest;
          count = count + 1ul;
        }

      }

    while((_Bool)0);
  hashtable->pool.used = hashtable->pool.size;
  free((void *)old_pool);
  coucal_nolog(hashtable, "compacted string pool for %ld strings: %ld bytes => %ld bytes", (unsigned long int)count, (unsigned long int)old_size, (unsigned long int)hashtable->pool.size);
}

// coucal_created
// file coucal.c line 1412
extern signed int coucal_created(struct struct_coucal *hashtable)
{
  _Bool tmp_if_expr_1;
  if(!(hashtable == ((struct struct_coucal *)NULL)))
    tmp_if_expr_1 = hashtable->items != (struct coucal_item *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// coucal_crit
// file coucal.c line 266
static void coucal_crit(struct struct_coucal * const hashtable, const char *format, ...)
{
  void **args = (void **)&format;
  coucal_log(hashtable, (enum coucal_loglevel)coucal_log_critical, format, args);
  args = ((void **)NULL);
}

// coucal_dec
// file coucal.c line 1246
extern signed int coucal_dec(struct struct_coucal *hashtable, const void *name)
{
  unsigned long int return_value_coucal_inc__1;
  return_value_coucal_inc__1=coucal_inc_(hashtable, name, (unsigned long int)-1);
  return (signed int)return_value_coucal_inc__1;
}

// coucal_default_free_handler
// file coucal.c line 789
static void coucal_default_free_handler(void *arg, union coucal_value value)
{
  (void)arg;
  if(!(value.ptr == NULL))
    free(value.ptr);

}

// coucal_del_item
// file coucal.c line 817
static void coucal_del_item(struct struct_coucal *hashtable, struct coucal_item *pitem)
{
  coucal_del_value_(hashtable, &pitem->value);
  coucal_del_name(hashtable, pitem);
}

// coucal_del_name
// file coucal.c line 808
static void coucal_del_name(struct struct_coucal *hashtable, struct coucal_item *item)
{
  const struct coucal_hashkeys nullHash = { .hash1=(unsigned int)0, .hash2=(unsigned int)0 };
  char * const name = (char *)item->name;
  item->name = (void *)0;
  item->hashes = nullHash;
  coucal_free_key(hashtable, (void *)name);
}

// coucal_del_value
// file coucal.c line 804
static inline void coucal_del_value(struct struct_coucal *hashtable, unsigned long int pos)
{
  coucal_del_value_(hashtable, &(hashtable->items + (signed long int)pos)->value);
}

// coucal_del_value_
// file coucal.c line 796
static inline void coucal_del_value_(struct struct_coucal *hashtable, union coucal_value *pvalue)
{
  if(!(pvalue->ptr == NULL))
  {
    if(!(hashtable->custom.value.free == ((void (*)(void *, union coucal_value))NULL)))
      hashtable->custom.value.free(hashtable->custom.value.arg, *pvalue);

    pvalue->ptr = (void *)0;
  }

}

// coucal_delete
// file ./coucal.h line 272
extern void coucal_delete(struct struct_coucal **phashtable)
{
  if(!(phashtable == ((struct struct_coucal **)NULL)))
  {
    struct struct_coucal *hashtable = *phashtable;
    if(!(hashtable == ((struct struct_coucal *)NULL)))
    {
      coucal_log_stats(hashtable);
      if(!(hashtable->items == ((struct coucal_item *)NULL)))
      {
        const unsigned long int hash_size = (unsigned long int)1 << hashtable->lg_size;
        unsigned long int i = (unsigned long int)0;
        for( ; !(i >= hash_size); i = i + 1ul)
        {
          signed int return_value_coucal_is_free_1;
          return_value_coucal_is_free_1=coucal_is_free(hashtable, i);
          if(return_value_coucal_is_free_1 == 0)
            coucal_del_value(hashtable, i);

        }
        i = (unsigned long int)0;
        for( ; !(i >= hashtable->stash.size); i = i + 1ul)
          coucal_del_value_(hashtable, &hashtable->stash.items[(signed long int)i].value);
      }

      hashtable->lg_size = (unsigned long int)0;
      hashtable->used = (unsigned long int)0;
      free((void *)hashtable->pool.buffer);
      hashtable->pool.buffer = (char *)(void *)0;
      free((void *)hashtable->items);
      hashtable->items = (struct coucal_item *)(void *)0;
      free((void *)hashtable);
      *phashtable = (struct struct_coucal *)(void *)0;
    }

  }

}

// coucal_dup_name
// file coucal.c line 695
static inline void * coucal_dup_name(struct struct_coucal *hashtable, const void *name)
{
  void *tmp_if_expr_2;
  void *return_value_coucal_dup_name_internal_1;
  void *return_value;
  if(hashtable->custom.key.dup == ((void * (*)(void *, const void *))NULL))
  {
    return_value_coucal_dup_name_internal_1=coucal_dup_name_internal(hashtable, name);
    tmp_if_expr_2 = return_value_coucal_dup_name_internal_1;
  }

  else
  {
    return_value=hashtable->custom.key.dup(hashtable->custom.key.arg, name);
    tmp_if_expr_2 = return_value;
  }
  return tmp_if_expr_2;
}

// coucal_dup_name_internal
// file coucal.c line 661
static void * coucal_dup_name_internal(struct struct_coucal *hashtable, const void *name_)
{
  const char * const name = (const char *)name_;
  unsigned long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  len = return_value_strlen_1 + (unsigned long int)1;
  char *s;
  if(len == 1ul)
  {
    if((signed int)the_empty_string[0l] == 0)
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "the_empty_string[0] == '\\0'", "coucal.c", 670);
      (_Bool)0;
    }
    return (void *)the_empty_string;
  }

  else
  {
    if(hashtable->pool.capacity >= hashtable->pool.size)
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "hashtable->pool.size <= hashtable->pool.capacity", "coucal.c", 675);
      (_Bool)0;
    }
    if(!(hashtable->pool.capacity + -hashtable->pool.size >= len))
    {
      unsigned long int capacity = (unsigned long int)256;
      for( ; !(capacity >= hashtable->pool.size + len); capacity = capacity << 1)
        ;
      if(!(hashtable->pool.size >= capacity))
        (_Bool)1;

      else
      {
        coucal_assert_failed(hashtable, "hashtable->pool.size < capacity", "coucal.c", 680);
        (_Bool)0;
      }
      coucal_realloc_pool(hashtable, capacity);
    }

    if(hashtable->pool.capacity >= hashtable->pool.size + len)
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "len + hashtable->pool.size <= hashtable->pool.capacity", "coucal.c", 685);
      (_Bool)0;
    }
    s = &hashtable->pool.buffer[(signed long int)hashtable->pool.size];
    memcpy((void *)s, (const void *)name, len);
    hashtable->pool.size = hashtable->pool.size + len;
    hashtable->pool.used = hashtable->pool.used + len;
    return (void *)s;
  }
}

// coucal_enum_new
// file ./coucal.h line 486
extern struct struct_coucal_enum coucal_enum_new(struct struct_coucal *hashtable)
{
  struct struct_coucal_enum e;
  e.index = (unsigned long int)0;
  e.table = hashtable;
  return e;
}

// coucal_enum_next
// file ./coucal.h line 491
extern struct coucal_item * coucal_enum_next(struct struct_coucal_enum *e)
{
  const unsigned long int hash_size = (unsigned long int)1 << e->table->lg_size;
  _Bool tmp_if_expr_2;
  signed int return_value_coucal_is_free_1;
  do
  {
    if(!(e->index >= hash_size))
    {
      return_value_coucal_is_free_1=coucal_is_free(e->table, e->index);
      tmp_if_expr_2 = return_value_coucal_is_free_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    e->index = e->index + 1ul;
  }
  while((_Bool)1);
  if(!(e->index >= hash_size))
  {
    struct coucal_item * const next = &e->table->items[(signed long int)e->index];
    e->index = e->index + 1ul;
    return next;
  }

  else
    if(!(e->index >= e->table->stash.size + hash_size))
    {
      const unsigned long int index = e->index - hash_size;
      struct coucal_item * const coucal_enum_next__1__3__next = &e->table->stash.items[(signed long int)index];
      e->index = e->index + 1ul;
      return coucal_enum_next__1__3__next;
    }

    else
      return (struct coucal_item *)(void *)0;
}

// coucal_equals
// file coucal.c line 493
static inline signed int coucal_equals(struct struct_coucal *hashtable, const void *a, const void *b)
{
  signed int tmp_if_expr_2;
  signed int return_value_strcmp_1;
  signed int return_value;
  if(hashtable->custom.key.equals == ((signed int (*)(void *, const void *, const void *))NULL))
  {
    return_value_strcmp_1=strcmp((const char *)a, (const char *)b);
    tmp_if_expr_2 = (signed int)(return_value_strcmp_1 == 0);
  }

  else
  {
    return_value=hashtable->custom.key.equals(hashtable->custom.key.arg, a, b);
    tmp_if_expr_2 = return_value;
  }
  return tmp_if_expr_2;
}

// coucal_exists
// file ./coucal.h line 383
extern signed int coucal_exists(struct struct_coucal *hashtable, const void *name)
{
  signed int return_value_coucal_read_value_1;
  return_value_coucal_read_value_1=coucal_read_value(hashtable, name, (union coucal_value *)(void *)0);
  return return_value_coucal_read_value_1;
}

// coucal_fail
// file coucal.c line 287
static void coucal_fail(const char *exp, const char *file, signed int line)
{
  fprintf(stderr, "assertion '%s' failed at %s:%d\n", exp, file, line);
  abort();
}

// coucal_fetch_value
// file coucal.c line 1210
inline union coucal_value * coucal_fetch_value(struct struct_coucal *hashtable, const void *name)
{
  struct coucal_hashkeys hashes;
  hashes=coucal_calc_hashes(hashtable, name);
  union coucal_value *return_value_coucal_fetch_value_hashes_1;
  return_value_coucal_fetch_value_hashes_1=coucal_fetch_value_hashes(hashtable, name, &hashes);
  return return_value_coucal_fetch_value_hashes_1;
}

// coucal_fetch_value_hashes
// file coucal.c line 1178
extern union coucal_value * coucal_fetch_value_hashes(struct struct_coucal *hashtable, const void *name, const struct coucal_hashkeys *hashes)
{
  unsigned long int pos;
  pos=coucal_hash_to_pos(hashtable, hashes->hash1);
  signed int return_value_coucal_matches_1;
  return_value_coucal_matches_1=coucal_matches(hashtable, pos, name, hashes);
  if(!(return_value_coucal_matches_1 == 0))
    return &(hashtable->items + (signed long int)pos)->value;

  else
  {
    pos=coucal_hash_to_pos(hashtable, hashes->hash2);
    signed int return_value_coucal_matches_2;
    return_value_coucal_matches_2=coucal_matches(hashtable, pos, name, hashes);
    if(!(return_value_coucal_matches_2 == 0))
      return &(hashtable->items + (signed long int)pos)->value;

    else
    {
      if(!(hashtable->stash.size == 0ul))
      {
        unsigned long int i = (unsigned long int)0;
        for( ; !(i >= hashtable->stash.size); i = i + 1ul)
        {
          signed int return_value_coucal_matches__3;
          return_value_coucal_matches__3=coucal_matches_(hashtable, &hashtable->stash.items[(signed long int)i], name, hashes);
          if(!(return_value_coucal_matches__3 == 0))
            return &hashtable->stash.items[(signed long int)i].value;

        }
      }

      return (union coucal_value *)(void *)0;
    }
  }
}

// coucal_free_key
// file coucal.c line 732
static void coucal_free_key(struct struct_coucal *hashtable, void *name)
{
  if(hashtable->custom.key.free == ((void (*)(void *, void *))NULL))
    coucal_free_key_internal(hashtable, name);

  else
    hashtable->custom.key.free(hashtable->custom.key.arg, name);
}

// coucal_free_key_internal
// file coucal.c line 704
static void coucal_free_key_internal(struct struct_coucal *hashtable, void *name_)
{
  char * const name = (char *)name_;
  unsigned long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  len = return_value_strlen_1 + (unsigned long int)1;
  if(len == 1ul)
  {
    if(!(name == the_empty_string))
      goto __CPROVER_DUMP_L4;

    if((signed int)the_empty_string[0l] == 0)
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "the_empty_string[0] == '\\0'", "coucal.c", 710);
      (_Bool)0;
    }
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!((signed int)*name == 0))
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "*name != '\\0' || !\"duplicate or bad string pool release\"", "coucal.c", 714);
      (_Bool)0;
    }
    hashtable->pool.used = hashtable->pool.used - len;
    *name = (char)0;
    if(!(hashtable->pool.used >= hashtable->pool.size / 2ul))
    {
      unsigned long int capacity = hashtable->pool.capacity;
      if(!(hashtable->pool.used >= capacity / 4ul))
        capacity = capacity / (unsigned long int)2;

      if(!(hashtable->pool.used >= capacity))
        (_Bool)1;

      else
      {
        coucal_assert_failed(hashtable, "hashtable->pool.used < capacity", "coucal.c", 725);
        (_Bool)0;
      }
      coucal_compact_pool(hashtable, capacity);
    }

  }
}

// coucal_get_intptr
// file coucal.c line 1346
extern signed long int coucal_get_intptr(struct struct_coucal *hashtable, const void *name)
{
  signed long int value;
  signed int return_value_coucal_read_1;
  return_value_coucal_read_1=coucal_read(hashtable, name, &value);
  if(return_value_coucal_read_1 == 0)
    return (signed long int)0;

  else
    return value;
}

// coucal_get_name
// file coucal.c line 332
extern const char * coucal_get_name(struct struct_coucal *hashtable)
{
  return (const char *)hashtable->custom.error.name;
}

// coucal_get_pow2
// file coucal.c line 1354
static inline unsigned long int coucal_get_pow2(unsigned long int initial_size)
{
  unsigned long int size = (unsigned long int)4;
  for( ; !(1ul << size >= initial_size) && !(size >= 33ul); size = size + 1ul)
    ;
  return size;
}

// coucal_get_pvoid
// file coucal.c line 760
extern void * coucal_get_pvoid(struct struct_coucal *hashtable, const void *name)
{
  void *value;
  signed int return_value_coucal_read_pvoid_1;
  return_value_coucal_read_pvoid_1=coucal_read_pvoid(hashtable, name, &value);
  if(return_value_coucal_read_pvoid_1 == 0)
    return (void *)0;

  else
    return value;
}

// coucal_hash_data
// file coucal.c line 379
extern struct coucal_hashkeys coucal_hash_data(const void *data_, unsigned long int size)
{
  const unsigned char * const data = (const unsigned char *)data_;
  struct MD5Context ctx;
  /* tag-#anon#lUN[lARR16{U8}_U8_'md5digest'||lARR2{SYM#tag-coucal_hashkeys#}_SYM#tag-coucal_hashkeys#_'mhashes'||SYM#tag-coucal_hashkeys#'hashes'|] */
union anonymous_20
{
  // md5digest
  unsigned char md5digest[16l];
  // mhashes
  struct coucal_hashkeys mhashes[2l];
  // hashes
  struct coucal_hashkeys hashes;
};

/* */
  ;
  union anonymous_20 u;
  MD5Init(&ctx, 0);
  MD5Update(&ctx, data, (unsigned int)size);
  MD5Final(u.md5digest, &ctx);
  u.mhashes[(signed long int)0].hash1 = u.mhashes[(signed long int)0].hash1 ^ u.mhashes[(signed long int)1].hash1;
  u.mhashes[(signed long int)0].hash2 = u.mhashes[(signed long int)0].hash2 ^ u.mhashes[(signed long int)1].hash2;
  if(u.hashes.hash1 == u.hashes.hash2)
    u.hashes.hash2 = ~u.hashes.hash2;

  return u.hashes;
}

// coucal_hash_size
// file coucal.c line 1485
extern unsigned long int coucal_hash_size(void)
{
  return (unsigned long int)32;
}

// coucal_hash_string
// file coucal.c line 476
inline struct coucal_hashkeys coucal_hash_string(const char *name)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(name);
  struct coucal_hashkeys return_value_coucal_hash_data_2;
  return_value_coucal_hash_data_2=coucal_hash_data((const void *)name, return_value_strlen_1);
  return return_value_coucal_hash_data_2;
}

// coucal_hash_to_pos
// file coucal.c line 746
static inline unsigned long int coucal_hash_to_pos(struct struct_coucal * const hashtable, unsigned int hash)
{
  unsigned long int return_value_coucal_hash_to_pos__1;
  return_value_coucal_hash_to_pos__1=coucal_hash_to_pos_(hashtable->lg_size, hash);
  return return_value_coucal_hash_to_pos__1;
}

// coucal_hash_to_pos_
// file coucal.c line 740
static inline unsigned long int coucal_hash_to_pos_(unsigned long int lg_size, unsigned int hash)
{
  const unsigned int mask = (const unsigned int)(((unsigned long int)1 << lg_size) - (unsigned long int)1);
  return (unsigned long int)(hash & mask);
}

// coucal_inc
// file coucal.c line 1242
extern signed int coucal_inc(struct struct_coucal *hashtable, const void *name)
{
  unsigned long int return_value_coucal_inc__1;
  return_value_coucal_inc__1=coucal_inc_(hashtable, name, (unsigned long int)1);
  return (signed int)return_value_coucal_inc__1;
}

// coucal_inc_
// file coucal.c line 1228
static unsigned long int coucal_inc_(struct struct_coucal *hashtable, const void *name, unsigned long int inc)
{
  union coucal_value *value;
  value=coucal_fetch_value(hashtable, name);
  if(!(value == ((union coucal_value *)NULL)))
  {
    value->uintg = value->uintg + inc;
    return value->uintg;
  }

  else
  {
    signed int ret;
    ret=coucal_write(hashtable, name, (signed long int)inc);
    if(!(ret == 0))
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "ret", "coucal.c", 1237);
      (_Bool)0;
    }
    return inc;
  }
}

// coucal_info
// file coucal.c line 268
static void coucal_info(struct struct_coucal * const hashtable, const char *format, ...)
{
  void **args = (void **)&format;
  coucal_log(hashtable, (enum coucal_loglevel)coucal_log_info, format, args);
  args = ((void **)NULL);
}

// coucal_is_acceptable_pow2
// file coucal.c line 1029
static inline signed int coucal_is_acceptable_pow2(unsigned long int lg_size)
{
  return (signed int)(lg_size <= (unsigned long int)32 && lg_size < sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
}

// coucal_is_free
// file coucal.c line 488
static inline signed int coucal_is_free(struct struct_coucal * const hashtable, unsigned long int pos)
{
  return (signed int)((hashtable->items + (signed long int)pos)->name == (void *)0);
}

// coucal_log
// file coucal.c line 308
static void coucal_log(struct struct_coucal * const hashtable, enum coucal_loglevel level, const char *format, void **args)
{
  if(!(format == ((const char *)NULL)))
    (_Bool)1;

  else
  {
    coucal_assert_failed(hashtable, "format != NULL", "coucal.c", 310);
    (_Bool)0;
  }
  _Bool tmp_if_expr_1;
  if(!(hashtable == ((struct struct_coucal *)NULL)))
    tmp_if_expr_1 = hashtable->custom.error.log != (void (*)(void *, enum coucal_loglevel, const char *, void **))(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    hashtable->custom.error.log(hashtable->custom.error.arg, level, format, args);

  else
    if(!(global_log_handler == ((void (*)(void *, enum coucal_loglevel, const char *, void **))NULL)))
      global_log_handler((void *)hashtable, level, format, args);

    else
    {
      fprintf(stderr, "[%p] ", (void *)hashtable);
      vfprintf(stderr, format, args);
      _IO_putc(10, stderr);
    }
}

// coucal_log_stats
// file coucal.c line 336
static void coucal_log_stats(struct struct_coucal *hashtable)
{
  const char *name;
  name=coucal_get_name(hashtable);
  unsigned long int return_value_coucal_memory_size_1;
  return_value_coucal_memory_size_1=coucal_memory_size(hashtable);
  coucal_info(hashtable, "hashtable %s%s%ssummary: size=%ld (lg2=%ld) used=%ld stash-size=%ld pool-size=%ld pool-capacity=%ld pool-used=%ld writes=%ld (new=%ld) moved=%ld stashed=%ld max-stash-size=%ld avg-moved=%g rehash=%ld pool-compact=%ld pool-realloc=%ld memory=%ld", name != (const char *)(void *)0 ? "\"" : "", name != (const char *)(void *)0 ? name : "", name != (const char *)(void *)0 ? "\" " : "", (unsigned long int)((unsigned long int)1 << hashtable->lg_size), (unsigned long int)hashtable->lg_size, (unsigned long int)hashtable->used, (unsigned long int)hashtable->stash.size, (unsigned long int)hashtable->pool.size, (unsigned long int)hashtable->pool.capacity, (unsigned long int)hashtable->pool.used, (unsigned long int)hashtable->stats.write_count, (unsigned long int)hashtable->stats.add_count, (unsigned long int)hashtable->stats.cuckoo_moved, (unsigned long int)hashtable->stats.stash_added, (unsigned long int)hashtable->stats.max_stash_size, (double)hashtable->stats.cuckoo_moved / (double)hashtable->stats.add_count, (unsigned long int)hashtable->stats.rehash_count, (unsigned long int)hashtable->stats.pool_compact_count, (unsigned long int)hashtable->stats.pool_realloc_count, (unsigned long int)return_value_coucal_memory_size_1);
}

// coucal_matches
// file coucal.c line 511
static inline signed int coucal_matches(struct struct_coucal *hashtable, unsigned long int pos, const void *name, const struct coucal_hashkeys *hashes)
{
  const struct coucal_item * const item = &hashtable->items[(signed long int)pos];
  signed int return_value_coucal_matches__1;
  return_value_coucal_matches__1=coucal_matches_(hashtable, item, name, hashes);
  return return_value_coucal_matches__1;
}

// coucal_matches_
// file coucal.c line 501
static inline signed int coucal_matches_(struct struct_coucal *hashtable, const struct coucal_item * const item, const void *name, const struct coucal_hashkeys *hashes)
{
  _Bool tmp_if_expr_1;
  if(!(item->name == NULL))
    tmp_if_expr_1 = item->hashes.hash1 == hashes->hash1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = item->hashes.hash2 == hashes->hash2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_4;
  signed int return_value_coucal_equals_3;
  if(tmp_if_expr_2)
  {
    return_value_coucal_equals_3=coucal_equals(hashtable, item->name, name);
    tmp_if_expr_4 = return_value_coucal_equals_3 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// coucal_memory_size
// file coucal.c line 1478
extern unsigned long int coucal_memory_size(struct struct_coucal *hashtable)
{
  const unsigned long int size_struct = sizeof(struct struct_coucal) /*624ul*/ ;
  const unsigned long int hash_size = ((unsigned long int)1 << hashtable->lg_size) * sizeof(struct coucal_item) /*24ul*/ ;
  const unsigned long int pool_size = hashtable->pool.capacity * sizeof(char) /*1ul*/ ;
  return size_struct + hash_size + pool_size;
}

// coucal_new
// file ./coucal.h line 261
extern struct struct_coucal * coucal_new(unsigned long int initial_size)
{
  unsigned long int lg_size;
  lg_size=coucal_get_pow2(initial_size);
  signed int lg_valid;
  lg_valid=coucal_is_acceptable_pow2(lg_size);
  struct struct_coucal *hashtable;
  struct struct_coucal *tmp_if_expr_2;
  void *return_value_calloc_1;
  if(!(lg_valid == 0))
  {
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct struct_coucal) /*624ul*/ );
    tmp_if_expr_2 = (struct struct_coucal *)return_value_calloc_1;
  }

  else
    tmp_if_expr_2 = (struct struct_coucal *)(void *)0;
  hashtable = tmp_if_expr_2;
  struct coucal_item *items;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)1 << lg_size, sizeof(struct coucal_item) /*24ul*/ );
  items = (struct coucal_item *)return_value_calloc_3;
  if(!(items == ((struct coucal_item *)NULL)) && !(hashtable == ((struct struct_coucal *)NULL)) && !(lg_valid == 0))
  {
    hashtable->lg_size = lg_size;
    hashtable->items = items;
    hashtable->used = (unsigned long int)0;
    hashtable->stash.size = (unsigned long int)0;
    hashtable->pool.buffer = (char *)(void *)0;
    hashtable->pool.size = (unsigned long int)0;
    hashtable->pool.capacity = (unsigned long int)0;
    hashtable->pool.used = (unsigned long int)0;
    hashtable->stats.max_stash_size = (unsigned long int)0;
    hashtable->stats.write_count = (unsigned long int)0;
    hashtable->stats.add_count = (unsigned long int)0;
    hashtable->stats.cuckoo_moved = (unsigned long int)0;
    hashtable->stats.stash_added = (unsigned long int)0;
    hashtable->stats.pool_compact_count = (unsigned long int)0;
    hashtable->stats.pool_realloc_count = (unsigned long int)0;
    hashtable->stats.rehash_count = (unsigned long int)0;
    hashtable->custom.value.free = (void (*)(void *, union coucal_value))(void *)0;
    hashtable->custom.value.arg = (void *)0;
    hashtable->custom.key.dup = (void * (*)(void *, const void *))(void *)0;
    hashtable->custom.key.free = (void (*)(void *, void *))(void *)0;
    hashtable->custom.key.hash = (struct coucal_hashkeys (*)(void *, const void *))(void *)0;
    hashtable->custom.key.equals = (signed int (*)(void *, const void *, const void *))(void *)0;
    hashtable->custom.key.arg = (void *)0;
    hashtable->custom.error.log = (void (*)(void *, enum coucal_loglevel, const char *, void **))(void *)0;
    hashtable->custom.error.fatal = (void (*)(void *, const char *, const char *, signed int))(void *)0;
    hashtable->custom.error.name = (void *)0;
    hashtable->custom.error.arg = (void *)0;
    hashtable->custom.print.key = (const char * (*)(void *, const void *))(void *)0;
    hashtable->custom.print.value = (const char * (*)(void *, const union coucal_value))(void *)0;
    hashtable->custom.print.arg = (void *)0;
    return hashtable;
  }

  else
  {
    if(!(items == ((struct coucal_item *)NULL)))
      free((void *)items);

    if(!(hashtable == ((struct struct_coucal *)NULL)))
      free((void *)hashtable);

    return (struct struct_coucal *)(void *)0;
  }
}

// coucal_nitems
// file coucal.c line 1472
extern unsigned long int coucal_nitems(struct struct_coucal *hashtable)
{
  if(!(hashtable == ((struct struct_coucal *)NULL)))
    return hashtable->used;

  else
    return (unsigned long int)0;
}

// coucal_nolog
// file coucal.c line 326
static inline void coucal_nolog(struct struct_coucal * const hashtable, const char *format, ...)
{
  (void)hashtable;
  (void)format;
}

// coucal_print_key
// file coucal.c line 875
static const char * coucal_print_key(struct struct_coucal *hashtable, const void *name)
{
  const char *tmp_if_expr_1;
  const char *return_value;
  if(!(hashtable->custom.print.key == ((const char * (*)(void *, const void *))NULL)))
  {
    return_value=hashtable->custom.print.key(hashtable->custom.print.arg, name);
    tmp_if_expr_1 = return_value;
  }

  else
    tmp_if_expr_1 = (const char *)name;
  return tmp_if_expr_1;
}

// coucal_read
// file ./coucal.h line 364
extern signed int coucal_read(struct struct_coucal *hashtable, const void *name, signed long int *intvalue)
{
  union coucal_value value = { .intg=(signed long int)0 };
  signed int ret;
  ret=coucal_read_value(hashtable, name, intvalue != (signed long int *)(void *)0 ? &value : (union coucal_value *)(void *)0);
  if(!(intvalue == ((signed long int *)NULL)))
    *intvalue = value.intg;

  return ret;
}

// coucal_read_pvoid
// file coucal.c line 751
extern signed int coucal_read_pvoid(struct struct_coucal *hashtable, const void *name, void **pvalue)
{
  union coucal_value value = { .intg=(signed long int)0 };
  signed int ret;
  ret=coucal_read_value(hashtable, name, pvalue != (void **)(void *)0 ? &value : (union coucal_value *)(void *)0);
  if(!(pvalue == ((void **)NULL)))
    *pvalue = value.ptr;

  return ret;
}

// coucal_read_value
// file coucal.c line 1216
extern signed int coucal_read_value(struct struct_coucal *hashtable, const void *name, union coucal_value *pvalue)
{
  union coucal_value *value;
  value=coucal_fetch_value(hashtable, name);
  if(!(value == ((union coucal_value *)NULL)))
  {
    if(!(pvalue == ((union coucal_value *)NULL)))
      *pvalue = *value;

    return 1;
  }

  else
    return 0;
}

// coucal_readptr
// file coucal.c line 1336
extern signed int coucal_readptr(struct struct_coucal *hashtable, const void *name, signed long int *value)
{
  signed int ret;
  *value = (signed long int)0;
  ret=coucal_read(hashtable, name, value);
  if(*value == 0l)
    ret = 0;

  return ret;
}

// coucal_realloc_pool
// file coucal.c line 602
static void coucal_realloc_pool(struct struct_coucal *hashtable, unsigned long int capacity)
{
  const unsigned long int hash_size = (unsigned long int)1 << hashtable->lg_size;
  char * const oldbase = hashtable->pool.buffer;
  unsigned long int count = (unsigned long int)0;
  if(hashtable->custom.key.dup == ((void * (*)(void *, const void *))NULL))
    (_Bool)1;

  else
  {
    coucal_assert_failed(hashtable, "hashtable->custom.key.dup == NULL", "coucal.c", 608);
    (_Bool)0;
  }
  if(!(hashtable->pool.used >= (3ul * hashtable->pool.size) / 4ul))
    coucal_compact_pool(hashtable, capacity);

  else
  {
    hashtable->stats.pool_realloc_count = hashtable->stats.pool_realloc_count + 1ul;
    hashtable->pool.capacity = capacity;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)hashtable->pool.buffer, hashtable->pool.capacity);
    hashtable->pool.buffer = (char *)return_value_realloc_1;
    if(hashtable->pool.buffer == ((char *)NULL))
    {
      coucal_crit(hashtable, "** hashtable string pool allocation error: could not allocate %ld bytes", (unsigned long int)hashtable->pool.capacity);
      coucal_assert_failed(hashtable, "! \"hashtable string pool allocation error\"", "coucal.c", 630);
      (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
    }

    if(!(hashtable->pool.buffer == oldbase))
    {
      unsigned long int i = (unsigned long int)0;
      for( ; !(i >= hash_size); i = i + 1ul)
        do
          if(!((hashtable->items + (signed long int)i)->name == NULL))
          {
            if(!((char *)(hashtable->items + (signed long int)i)->name == the_empty_string))
            {
              const unsigned long int coucal_realloc_pool__1__3__1__1__1__1__offset = (const unsigned long int)((const char *)(hashtable->items + (signed long int)i)->name - oldbase);
              if(!(coucal_realloc_pool__1__3__1__1__1__1__offset >= hashtable->pool.capacity))
                (_Bool)1;

              else
              {
                coucal_assert_failed(hashtable, "offset < hashtable->pool.capacity", "coucal.c", 647);
                (_Bool)0;
              }
              (hashtable->items + (signed long int)i)->name = (void *)&hashtable->pool.buffer[(signed long int)coucal_realloc_pool__1__3__1__1__1__1__offset];
              count = count + 1ul;
            }

          }

        while((_Bool)0);
      i = (unsigned long int)0;
      for( ; !(i >= hashtable->stash.size); i = i + 1ul)
        do
          if(!(hashtable->stash.items[(signed long int)i].name == NULL))
          {
            if(!((char *)hashtable->stash.items[(signed long int)i].name == the_empty_string))
            {
              const unsigned long int offset = (const unsigned long int)((const char *)hashtable->stash.items[(signed long int)i].name - oldbase);
              if(!(offset >= hashtable->pool.capacity))
                (_Bool)1;

              else
              {
                coucal_assert_failed(hashtable, "offset < hashtable->pool.capacity", "coucal.c", 650);
                (_Bool)0;
              }
              hashtable->stash.items[(signed long int)i].name = (void *)&hashtable->pool.buffer[(signed long int)offset];
              count = count + 1ul;
            }

          }

        while((_Bool)0);
    }

    coucal_nolog(hashtable, "reallocated string pool for %ld strings: %ld bytes", (unsigned long int)count, (unsigned long int)hashtable->pool.capacity);
  }
}

// coucal_remove
// file coucal.c line 1297
extern signed int coucal_remove(struct struct_coucal *hashtable, const void *name)
{
  struct coucal_hashkeys hashes;
  hashes=coucal_calc_hashes(hashtable, name);
  unsigned long int removed;
  signed int ret;
  ret=coucal_remove_(hashtable, name, &hashes, &removed);
  if(!(ret == 0))
  {
    if(!(hashtable->used == 0ul))
      (_Bool)1;

    else
    {
      coucal_assert_failed(hashtable, "hashtable->used != 0", "coucal.c", 1304);
      (_Bool)0;
    }
    hashtable->used = hashtable->used - 1ul;
    if(!(hashtable->stash.size == 0ul))
    {
      if(!(removed == 18446744073709551615ul))
      {
        unsigned long int i = (unsigned long int)0;
        for( ; !(i >= hashtable->stash.size); i = i + 1ul)
        {
          unsigned long int pos1;
          pos1=coucal_hash_to_pos(hashtable, hashtable->stash.items[(signed long int)i].hashes.hash1);
          unsigned long int pos2;
          pos2=coucal_hash_to_pos(hashtable, hashtable->stash.items[(signed long int)i].hashes.hash2);
          if(pos1 == removed || pos2 == removed)
          {
            if(pos1 == removed)
              hashtable->items[(signed long int)pos1] = hashtable->stash.items[(signed long int)i];

            else
              if(pos2 == removed)
                hashtable->items[(signed long int)pos2] = hashtable->stash.items[(signed long int)i];

            for( ; !(1ul + i >= hashtable->stash.size); i = i + 1ul)
              hashtable->stash.items[(signed long int)i] = hashtable->stash.items[(signed long int)(i + (unsigned long int)1)];
            hashtable->stash.size = hashtable->stash.size - 1ul;
            coucal_nolog(hashtable, "debug:moved item from stash (%d entries)", (signed int)hashtable->stash.size);
            break;
          }

        }
      }

    }

  }

  return ret;
}

// coucal_remove_
// file coucal.c line 1254
static signed int coucal_remove_(struct struct_coucal *hashtable, const void *name, const struct coucal_hashkeys *hashes, unsigned long int *removed)
{
  unsigned long int pos;
  pos=coucal_hash_to_pos(hashtable, hashes->hash1);
  signed int return_value_coucal_matches_1;
  return_value_coucal_matches_1=coucal_matches(hashtable, pos, name, hashes);
  if(!(return_value_coucal_matches_1 == 0))
  {
    coucal_del_item(hashtable, &hashtable->items[(signed long int)pos]);
    *removed = pos;
    return 1;
  }

  else
  {
    pos=coucal_hash_to_pos(hashtable, hashes->hash2);
    signed int return_value_coucal_matches_2;
    return_value_coucal_matches_2=coucal_matches(hashtable, pos, name, hashes);
    if(!(return_value_coucal_matches_2 == 0))
    {
      coucal_del_item(hashtable, &hashtable->items[(signed long int)pos]);
      *removed = pos;
      return 1;
    }

    else
    {
      if(!(hashtable->stash.size == 0ul))
      {
        unsigned long int i = (unsigned long int)0;
        for( ; !(i >= hashtable->stash.size); i = i + 1ul)
        {
          signed int return_value_coucal_matches__3;
          return_value_coucal_matches__3=coucal_matches_(hashtable, &hashtable->stash.items[(signed long int)i], name, hashes);
          if(!(return_value_coucal_matches__3 == 0))
          {
            coucal_del_item(hashtable, &hashtable->stash.items[(signed long int)i]);
            for( ; !(1ul + i >= hashtable->stash.size); i = i + 1ul)
              hashtable->stash.items[(signed long int)i] = hashtable->stash.items[(signed long int)(i + (unsigned long int)1)];
            hashtable->stash.size = hashtable->stash.size - 1ul;
            *removed = (unsigned long int)-1;
            coucal_nolog(hashtable, "debug:deleted item in stash (%d entries)", (signed int)hashtable->stash.size);
            return 1;
          }

        }
      }

      return 0;
    }
  }
}

// coucal_set_assert_handler
// file coucal.c line 1454
extern void coucal_set_assert_handler(struct struct_coucal *hashtable, void (*log)(void *, enum coucal_loglevel, const char *, void **), void (*fatal)(void *, const char *, const char *, signed int), void *arg)
{
  hashtable->custom.error.log = log;
  hashtable->custom.error.fatal = fatal;
  hashtable->custom.error.arg = arg;
}

// coucal_set_global_assert_handler
// file coucal.c line 1557
extern void coucal_set_global_assert_handler(void (*log)(void *, enum coucal_loglevel, const char *, void **), void (*fatal)(void *, const char *, const char *, signed int))
{
  global_log_handler = log;
  global_assert_handler = fatal;
}

// coucal_set_name
// file ./coucal.h line 352
extern void coucal_set_name(struct struct_coucal *hashtable, const void *name)
{
  hashtable->custom.error.name = name;
}

// coucal_set_print_handler
// file coucal.c line 1463
extern void coucal_set_print_handler(struct struct_coucal *hashtable, const char * (*key)(void *, const void *), const char * (*value)(void *, const union coucal_value), void *arg)
{
  hashtable->custom.print.key = key;
  hashtable->custom.print.value = value;
  hashtable->custom.print.arg = arg;
}

// coucal_value_is_malloc
// file coucal.c line 1416
extern void coucal_value_is_malloc(struct struct_coucal *hashtable, signed int flag)
{
  if(!(flag == 0))
  {
    if(hashtable->custom.value.free == ((void (*)(void *, union coucal_value))NULL))
    {
      hashtable->custom.value.free = coucal_default_free_handler;
      hashtable->custom.value.arg = (void *)0;
    }

  }

  else
  {
    hashtable->custom.value.free = (void (*)(void *, union coucal_value))(void *)0;
    hashtable->custom.value.arg = (void *)0;
  }
}

// coucal_value_set_key_handler
// file coucal.c line 1439
extern void coucal_value_set_key_handler(struct struct_coucal *hashtable, void * (*dup)(void *, const void *), void (*free)(void *, void *), struct coucal_hashkeys (*hash)(void *, const void *), signed int (*equals)(void *, const void *, const void *), void *arg)
{
  if((dup == ((void * (*)(void *, const void *))NULL)) == (free == ((void (*)(void *, void *))NULL)))
    (_Bool)1;

  else
  {
    coucal_assert_failed(hashtable, "( dup == NULL ) == ( free == NULL )", "coucal.c", 1446);
    (_Bool)0;
  }
  hashtable->custom.key.dup = dup;
  hashtable->custom.key.free = free;
  hashtable->custom.key.hash = hash;
  hashtable->custom.key.equals = equals;
  hashtable->custom.key.arg = arg;
}

// coucal_value_set_value_handler
// file coucal.c line 1432
extern void coucal_value_set_value_handler(struct struct_coucal *hashtable, void (*free)(void *, union coucal_value), void *arg)
{
  hashtable->custom.value.free = free;
  hashtable->custom.value.arg = arg;
}

// coucal_warning
// file coucal.c line 267
static void coucal_warning(struct struct_coucal * const hashtable, const char *format, ...)
{
  void **args = (void **)&format;
  coucal_log(hashtable, (enum coucal_loglevel)coucal_log_warning, format, args);
  args = ((void **)NULL);
}

// coucal_write
// file ./coucal.h line 429
extern signed int coucal_write(struct struct_coucal *hashtable, const void *name, signed long int intvalue)
{
  union coucal_value value = { .intg=(signed long int)0 };
  value.intg = intvalue;
  signed int return_value_coucal_write_value_1;
  return_value_coucal_write_value_1=coucal_write_value(hashtable, name, value);
  return return_value_coucal_write_value_1;
}

// coucal_write_pvoid
// file coucal.c line 768
extern signed int coucal_write_pvoid(struct struct_coucal *hashtable, const void *name, void *pvalue)
{
  union coucal_value value = { .intg=(signed long int)0 };
  value.ptr = pvalue;
  signed int return_value_coucal_write_value_1;
  return_value_coucal_write_value_1=coucal_write_value(hashtable, name, value);
  return return_value_coucal_write_value_1;
}

// coucal_write_value
// file coucal.c line 1033
extern signed int coucal_write_value(struct struct_coucal *hashtable, const void *name, const union coucal_value value)
{
  signed int coucal_write_value__1__ret;
  coucal_write_value__1__ret=coucal_write_value_(hashtable, name, value);
  _Bool tmp_if_expr_6;
  unsigned long int return_value_coucal_hash_to_pos__3;
  if(!(coucal_write_value__1__ret == 0))
  {
    const unsigned long int half_size = (unsigned long int)1 << hashtable->lg_size - (unsigned long int)1;
    const unsigned long int half_stash_size = (const unsigned long int)(16 / 2);
    hashtable->used = hashtable->used + 1ul;
    if(hashtable->used >= half_size)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = hashtable->stash.size >= half_stash_size ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      unsigned long int i;
      const unsigned long int prev_power = hashtable->lg_size;
      const unsigned long int prev_size = half_size * (unsigned long int)2;
      const unsigned long int prev_alloc_size = prev_size * sizeof(struct coucal_item) /*24ul*/ ;
      const unsigned long int alloc_size = prev_alloc_size * (unsigned long int)2;
      if(hashtable->stash.size >= half_stash_size)
      {
        if(half_size >= 65537ul)
        {
          if(!(hashtable->used >= half_size / 4ul))
            coucal_warning(hashtable, "stash size still full despite %ld elements used out of %ld", (unsigned long int)hashtable->used, (unsigned long int)half_size * (unsigned long int)2);

        }

      }

      hashtable->stats.rehash_count = hashtable->stats.rehash_count + 1ul;
      hashtable->lg_size = hashtable->lg_size + 1ul;
      signed int return_value_coucal_is_acceptable_pow2_1;
      return_value_coucal_is_acceptable_pow2_1=coucal_is_acceptable_pow2(hashtable->lg_size);
      if(!(return_value_coucal_is_acceptable_pow2_1 == 0))
        (_Bool)1;

      else
      {
        coucal_assert_failed(hashtable, "coucal_is_acceptable_pow2(hashtable->lg_size)", "coucal.c", 1077);
        (_Bool)0;
      }
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)hashtable->items, alloc_size);
      hashtable->items = (struct coucal_item *)return_value_realloc_2;
      if(hashtable->items == ((struct coucal_item *)NULL))
      {
        coucal_crit(hashtable, "** hashtable allocation error: could not allocate %ld bytes", (unsigned long int)alloc_size);
        coucal_assert_failed(hashtable, "! \"hashtable allocation error\"", "coucal.c", 1085);
        (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
      }

      memset((void *)&hashtable->items[(signed long int)prev_size], 0, prev_alloc_size);
      i = (unsigned long int)0;
      for( ; !(i >= prev_size); i = i + 1ul)
      {
        signed int return_value_coucal_is_free_5;
        return_value_coucal_is_free_5=coucal_is_free(hashtable, i);
        if(return_value_coucal_is_free_5 == 0)
        {
          const struct coucal_hashkeys * const hashes = &(hashtable->items + (signed long int)i)->hashes;
          unsigned long int return_value_coucal_hash_to_pos__4;
          return_value_coucal_hash_to_pos__4=coucal_hash_to_pos_(prev_power, hashes->hash1);
          if(return_value_coucal_hash_to_pos__4 == i)
          {
            unsigned long int pos;
            pos=coucal_hash_to_pos(hashtable, hashes->hash1);
            if(!(pos == i))
            {
              if(pos >= prev_size)
                (_Bool)1;

              else
              {
                coucal_assert_failed(hashtable, "pos >= prev_size", "coucal.c", 1101);
                (_Bool)0;
              }
              hashtable->items[(signed long int)pos] = hashtable->items[(signed long int)i];
              memset((void *)&hashtable->items[(signed long int)i], 0, sizeof(struct coucal_item) /*24ul*/ );
            }

          }

          else
          {
            return_value_coucal_hash_to_pos__3=coucal_hash_to_pos_(prev_power, hashes->hash2);
            if(return_value_coucal_hash_to_pos__3 == i)
            {
              unsigned long int coucal_write_value__1__1__1__3__1__1__2__pos;
              coucal_write_value__1__1__1__3__1__1__2__pos=coucal_hash_to_pos(hashtable, hashes->hash2);
              if(!(coucal_write_value__1__1__1__3__1__1__2__pos == i))
              {
                if(coucal_write_value__1__1__1__3__1__1__2__pos >= prev_size)
                  (_Bool)1;

                else
                {
                  coucal_assert_failed(hashtable, "pos >= prev_size", "coucal.c", 1110);
                  (_Bool)0;
                }
                hashtable->items[(signed long int)coucal_write_value__1__1__1__3__1__1__2__pos] = hashtable->items[(signed long int)i];
                memset((void *)&hashtable->items[(signed long int)i], 0, sizeof(struct coucal_item) /*24ul*/ );
              }

            }

            else
            {
              coucal_assert_failed(hashtable, "! \"hashtable unexpected internal error (bad position)\"", "coucal.c", 1116);
              (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
            }
          }
        }

      }
      coucal_nolog(hashtable, "expanded hashtable to %ld elements", (unsigned long int)((unsigned long int)1 << hashtable->lg_size));
      if(!(hashtable->stash.size == 0ul))
      {
        const unsigned long int old_size = hashtable->stash.size;
        unsigned long int coucal_write_value__1__1__1__4__i;
        struct coucal_item stash[16l];
        memcpy((void *)&stash, (const void *)hashtable->stash.items, sizeof(struct coucal_item [16l]) /*384ul*/ );
        hashtable->stash.size = (unsigned long int)0;
        coucal_write_value__1__1__1__4__i = (unsigned long int)0;
        for( ; !(coucal_write_value__1__1__1__4__i >= old_size); coucal_write_value__1__1__1__4__i = coucal_write_value__1__1__1__4__i + 1ul)
        {
          signed int ret;
          ret=coucal_add_item_(hashtable, stash[(signed long int)coucal_write_value__1__1__1__4__i]);
          if(ret == 0)
          {
            coucal_assert_failed(hashtable, "! \"hashtable duplicate key when merging the stash\"", "coucal.c", 1139);
            (void)(0 != 0 ? (_Bool)1 : (_Bool)0);
          }

        }
        if(old_size >= hashtable->stash.size)
          (_Bool)1;

        else
        {
          coucal_assert_failed(hashtable, "hashtable->stash.size <= old_size", "coucal.c", 1144);
          (_Bool)0;
        }
        if(!(hashtable->stash.size >= old_size))
          coucal_nolog(hashtable, "reduced stash size from %ld to %ld", (unsigned long int)old_size, (unsigned long int)hashtable->stash.size);

        else
          coucal_nolog(hashtable, "stash has still %ld elements", (unsigned long int)hashtable->stash.size);
      }

    }

  }

  return coucal_write_value__1__ret;
}

// coucal_write_value_
// file coucal.c line 825
static signed int coucal_write_value_(struct struct_coucal *hashtable, const void *name, union coucal_value value)
{
  struct coucal_item item;
  unsigned long int pos;
  struct coucal_hashkeys hashes;
  hashes=coucal_calc_hashes(hashtable, name);
  hashtable->stats.write_count = hashtable->stats.write_count + 1ul;
  pos=coucal_hash_to_pos(hashtable, hashes.hash1);
  signed int return_value_coucal_matches_1;
  return_value_coucal_matches_1=coucal_matches(hashtable, pos, name, &hashes);
  if(!(return_value_coucal_matches_1 == 0))
  {
    coucal_del_value(hashtable, pos);
    (hashtable->items + (signed long int)pos)->value = value;
    return 0;
  }

  else
  {
    pos=coucal_hash_to_pos(hashtable, hashes.hash2);
    signed int return_value_coucal_matches_2;
    return_value_coucal_matches_2=coucal_matches(hashtable, pos, name, &hashes);
    if(!(return_value_coucal_matches_2 == 0))
    {
      coucal_del_value(hashtable, pos);
      (hashtable->items + (signed long int)pos)->value = value;
      return 0;
    }

    else
    {
      if(!(hashtable->stash.size == 0ul))
      {
        unsigned long int i = (unsigned long int)0;
        for( ; !(i >= hashtable->stash.size); i = i + 1ul)
        {
          signed int return_value_coucal_matches__3;
          return_value_coucal_matches__3=coucal_matches_(hashtable, &hashtable->stash.items[(signed long int)i], name, &hashes);
          if(!(return_value_coucal_matches__3 == 0))
          {
            coucal_del_value_(hashtable, &hashtable->stash.items[(signed long int)i].value);
            hashtable->stash.items[(signed long int)i].value = value;
            return 0;
          }

        }
      }

      hashtable->stats.add_count = hashtable->stats.add_count + 1ul;
      item.name=coucal_dup_name(hashtable, name);
      item.value = value;
      item.hashes = hashes;
      signed int return_value_coucal_add_item__4;
      return_value_coucal_add_item__4=coucal_add_item_(hashtable, item);
      return return_value_coucal_add_item__4;
    }
  }
}

// crypthead
// file minizip/crypt.h line 90
static signed int crypthead(const char *passwd, unsigned char *buf, signed int bufSize, unsigned long int *pkeys, const unsigned int *pcrc_32_tab, unsigned long int crcForCrypting)
{
  signed int n;
  signed int t;
  signed int c;
  unsigned char header[10l];
  signed int tmp_post_3;
  signed int tmp_post_4;
  if(!(bufSize >= 12))
    return 0;

  else
  {
    static unsigned int calls = (unsigned int)0;
    calls = calls + 1u;
    if(calls == 1u)
    {
      signed long int return_value_time_1;
      return_value_time_1=time((signed long int *)(void *)0);
      srand((unsigned int)((unsigned long int)return_value_time_1 ^ 3141592654UL));
    }

    init_keys(passwd, pkeys, pcrc_32_tab);
    n = 0;
    for( ; !(n >= 12); n = n + 1)
    {
      signed int return_value_rand_2;
      return_value_rand_2=rand();
      c = return_value_rand_2 >> 7 & 0xff;
      t=decrypt_byte(pkeys, pcrc_32_tab);
      update_keys(pkeys, pcrc_32_tab, c);
      header[(signed long int)n] = (unsigned char)(t ^ c);
    }
    init_keys(passwd, pkeys, pcrc_32_tab);
    n = 0;
    for( ; !(n >= 12); n = n + 1)
    {
      t=decrypt_byte(pkeys, pcrc_32_tab);
      update_keys(pkeys, pcrc_32_tab, (signed int)header[(signed long int)n]);
      buf[(signed long int)n] = (unsigned char)(t ^ (signed int)header[(signed long int)n]);
    }
    tmp_post_3 = n;
    n = n + 1;
    t=decrypt_byte(pkeys, pcrc_32_tab);
    update_keys(pkeys, pcrc_32_tab, (signed int)(crcForCrypting >> 16) & 0xff);
    buf[(signed long int)tmp_post_3] = (unsigned char)(t ^ (signed int)(crcForCrypting >> 16) & 0xff);
    tmp_post_4 = n;
    n = n + 1;
    t=decrypt_byte(pkeys, pcrc_32_tab);
    update_keys(pkeys, pcrc_32_tab, (signed int)(crcForCrypting >> 24) & 0xff);
    buf[(signed long int)tmp_post_4] = (unsigned char)(t ^ (signed int)(crcForCrypting >> 24) & 0xff);
    return n;
  }
}

// decrypt_byte
// file minizip/crypt.h line 35
static signed int decrypt_byte(unsigned long int *pkeys, const unsigned int *pcrc_32_tab)
{
  unsigned int temp = (unsigned int)pkeys[(signed long int)2] & (unsigned int)0xffff | (unsigned int)2;
  return (signed int)(temp * (temp ^ (unsigned int)1) >> 8 & (unsigned int)0xff);
}

// domd5mem
// file ./htsmd5.h line 43
signed int domd5mem(const char *buf, unsigned long int len, char *digest, signed int asAscii)
{
  signed int endian = 1;
  unsigned char bindigest[16l];
  struct MD5Context ctx;
  MD5Init(&ctx, (signed int)*((char *)&endian));
  MD5Update(&ctx, (const unsigned char *)buf, (unsigned int)len);
  MD5Final(bindigest, &ctx);
  if(asAscii == 0)
    memcpy((void *)digest, (const void *)bindigest, (unsigned long int)16);

  else
    sprintf(digest, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", bindigest[(signed long int)0], bindigest[(signed long int)1], bindigest[(signed long int)2], bindigest[(signed long int)3], bindigest[(signed long int)4], bindigest[(signed long int)5], bindigest[(signed long int)6], bindigest[(signed long int)7], bindigest[(signed long int)8], bindigest[(signed long int)9], bindigest[(signed long int)10], bindigest[(signed long int)11], bindigest[(signed long int)12], bindigest[(signed long int)13], bindigest[(signed long int)14], bindigest[(signed long int)15]);
  return 0;
}

// escapexml
// file proxy/proxystrings.h line 71
static void escapexml(const char *s, struct String *tempo)
{
  signed int i = 0;
  unsigned long int tmp_post_6;
  for( ; !((signed int)s[(signed long int)i] == 0); i = i + 1)
    if((signed int)s[(signed long int)i] == 38)
      do
      {
        const char * const escapexml__1__1__1__1__str__ = "&amp;";
        if(!(escapexml__1__1__1__1__str__ == ((const char *)NULL)))
        {
          unsigned long int escapexml__1__1__1__1__1__size__;
          escapexml__1__1__1__1__1__size__=strlen(escapexml__1__1__1__1__str__);
          do
          {
            const char *escapexml__1__1__1__1__1__1__str_mc_ = escapexml__1__1__1__1__str__;
            const unsigned long int escapexml__1__1__1__1__1__1__size_mc_ = (unsigned long int)escapexml__1__1__1__1__1__size__;
            do
            {
              const unsigned long int escapexml__1__1__1__1__1__1__1__capacity_ = (unsigned long int)(tempo->length_ + escapexml__1__1__1__1__1__1__size_mc_ + (unsigned long int)1);
              while(!(tempo->capacity_ >= escapexml__1__1__1__1__1__1__1__capacity_))
              {
                if(!(tempo->capacity_ >= 16ul))
                  tempo->capacity_ = (unsigned long int)16;

                else
                  tempo->capacity_ = tempo->capacity_ * (unsigned long int)2;
                void *return_value_realloc_1;
                return_value_realloc_1=realloc((void *)tempo->buffer_, tempo->capacity_);
                tempo->buffer_ = (char *)return_value_realloc_1;
                /* assertion (*tempo).buffer_ != ((void *)0) */
                assert(tempo->buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(escapexml__1__1__1__1__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(tempo->buffer_ + (signed long int)tempo->length_), (const void *)escapexml__1__1__1__1__1__1__str_mc_, escapexml__1__1__1__1__1__1__size_mc_);
              tempo->length_ = tempo->length_ + escapexml__1__1__1__1__1__1__size_mc_;
            }

            tempo->buffer_[(signed long int)tempo->length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);

    else
      if((signed int)s[(signed long int)i] == 60)
        do
        {
          const char * const str__ = "&lt;";
          if(!(str__ == ((const char *)NULL)))
          {
            unsigned long int size__;
            size__=strlen(str__);
            do
            {
              const char *str_mc_ = str__;
              const unsigned long int escapexml__1__1__1__2__1__1__size_mc_ = (unsigned long int)size__;
              do
              {
                const unsigned long int escapexml__1__1__1__2__1__1__1__capacity_ = (unsigned long int)(tempo->length_ + escapexml__1__1__1__2__1__1__size_mc_ + (unsigned long int)1);
                while(!(tempo->capacity_ >= escapexml__1__1__1__2__1__1__1__capacity_))
                {
                  if(!(tempo->capacity_ >= 16ul))
                    tempo->capacity_ = (unsigned long int)16;

                  else
                    tempo->capacity_ = tempo->capacity_ * (unsigned long int)2;
                  void *return_value_realloc_2;
                  return_value_realloc_2=realloc((void *)tempo->buffer_, tempo->capacity_);
                  tempo->buffer_ = (char *)return_value_realloc_2;
                  /* assertion (*tempo).buffer_ != ((void *)0) */
                  assert(tempo->buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              if(escapexml__1__1__1__2__1__1__size_mc_ >= 1ul)
              {
                memcpy((void *)(tempo->buffer_ + (signed long int)tempo->length_), (const void *)str_mc_, escapexml__1__1__1__2__1__1__size_mc_);
                tempo->length_ = tempo->length_ + escapexml__1__1__1__2__1__1__size_mc_;
              }

              tempo->buffer_[(signed long int)tempo->length_] = (char)0;
            }
            while((_Bool)0);
          }

        }
        while((_Bool)0);

      else
        if((signed int)s[(signed long int)i] == 62)
          do
          {
            const char * const escapexml__1__1__1__3__str__ = "&gt;";
            if(!(escapexml__1__1__1__3__str__ == ((const char *)NULL)))
            {
              unsigned long int escapexml__1__1__1__3__1__size__;
              escapexml__1__1__1__3__1__size__=strlen(escapexml__1__1__1__3__str__);
              do
              {
                const char *escapexml__1__1__1__3__1__1__str_mc_ = escapexml__1__1__1__3__str__;
                const unsigned long int size_mc_ = (unsigned long int)escapexml__1__1__1__3__1__size__;
                do
                {
                  const unsigned long int capacity_ = (unsigned long int)(tempo->length_ + size_mc_ + (unsigned long int)1);
                  while(!(tempo->capacity_ >= capacity_))
                  {
                    if(!(tempo->capacity_ >= 16ul))
                      tempo->capacity_ = (unsigned long int)16;

                    else
                      tempo->capacity_ = tempo->capacity_ * (unsigned long int)2;
                    void *return_value_realloc_3;
                    return_value_realloc_3=realloc((void *)tempo->buffer_, tempo->capacity_);
                    tempo->buffer_ = (char *)return_value_realloc_3;
                    /* assertion (*tempo).buffer_ != ((void *)0) */
                    assert(tempo->buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(size_mc_ >= 1ul)
                {
                  memcpy((void *)(tempo->buffer_ + (signed long int)tempo->length_), (const void *)escapexml__1__1__1__3__1__1__str_mc_, size_mc_);
                  tempo->length_ = tempo->length_ + size_mc_;
                }

                tempo->buffer_[(signed long int)tempo->length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);

        else
          if((signed int)s[(signed long int)i] == 34)
            do
            {
              const char * const escapexml__1__1__1__4__str__ = "&quot;";
              if(!(escapexml__1__1__1__4__str__ == ((const char *)NULL)))
              {
                unsigned long int escapexml__1__1__1__4__1__size__;
                escapexml__1__1__1__4__1__size__=strlen(escapexml__1__1__1__4__str__);
                do
                {
                  const char *escapexml__1__1__1__4__1__1__str_mc_ = escapexml__1__1__1__4__str__;
                  const unsigned long int escapexml__1__1__1__4__1__1__size_mc_ = (unsigned long int)escapexml__1__1__1__4__1__size__;
                  do
                  {
                    const unsigned long int escapexml__1__1__1__4__1__1__1__capacity_ = (unsigned long int)(tempo->length_ + escapexml__1__1__1__4__1__1__size_mc_ + (unsigned long int)1);
                    while(!(tempo->capacity_ >= escapexml__1__1__1__4__1__1__1__capacity_))
                    {
                      if(!(tempo->capacity_ >= 16ul))
                        tempo->capacity_ = (unsigned long int)16;

                      else
                        tempo->capacity_ = tempo->capacity_ * (unsigned long int)2;
                      void *return_value_realloc_4;
                      return_value_realloc_4=realloc((void *)tempo->buffer_, tempo->capacity_);
                      tempo->buffer_ = (char *)return_value_realloc_4;
                      /* assertion (*tempo).buffer_ != ((void *)0) */
                      assert(tempo->buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(escapexml__1__1__1__4__1__1__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(tempo->buffer_ + (signed long int)tempo->length_), (const void *)escapexml__1__1__1__4__1__1__str_mc_, escapexml__1__1__1__4__1__1__size_mc_);
                    tempo->length_ = tempo->length_ + escapexml__1__1__1__4__1__1__size_mc_;
                  }

                  tempo->buffer_[(signed long int)tempo->length_] = (char)0;
                }
                while((_Bool)0);
              }

            }
            while((_Bool)0);

          else
            do
            {
              struct String * const s__ = &(*tempo);
              char c__ = s[(signed long int)i];
              do
              {
                const unsigned long int escapexml__1__1__1__5__1__capacity_ = (unsigned long int)(s__->length_ + (unsigned long int)1 + (unsigned long int)1);
                while(!(s__->capacity_ >= escapexml__1__1__1__5__1__capacity_))
                {
                  if(!(s__->capacity_ >= 16ul))
                    s__->capacity_ = (unsigned long int)16;

                  else
                    s__->capacity_ = s__->capacity_ * (unsigned long int)2;
                  void *return_value_realloc_5;
                  return_value_realloc_5=realloc((void *)s__->buffer_, s__->capacity_);
                  s__->buffer_ = (char *)return_value_realloc_5;
                  /* assertion (*s__).buffer_ != ((void *)0) */
                  assert(s__->buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              tmp_post_6 = s__->length_;
              s__->length_ = s__->length_ + 1ul;
              s__->buffer_[(signed long int)tmp_post_6] = c__;
              s__->buffer_[(signed long int)s__->length_] = (char)0;
            }
            while((_Bool)0);
}

// fclose_file_func
// file minizip/ioapi.c line 219
static signed int fclose_file_func(void *opaque, void *stream)
{
  signed int ret;
  ret=fclose((struct _IO_FILE *)stream);
  return ret;
}

// ferror_file_func
// file minizip/ioapi.c line 226
static signed int ferror_file_func(void *opaque, void *stream)
{
  signed int ret;
  ret=ferror((struct _IO_FILE *)stream);
  return ret;
}

// fflush_file_func
// file minizip/ioapi.c line 212
static signed int fflush_file_func(void *opaque, void *stream)
{
  signed int ret;
  ret=fflush((struct _IO_FILE *)stream);
  return ret;
}

// file_convert
// file proxy/proxystrings.h line 88
static char * file_convert(char *dest, unsigned long int size, const char *src)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !((signed int)src[(signed long int)i] == 0) && !(1ul + i >= size); i = i + 1ul)
    dest[(signed long int)i] = src[(signed long int)i];
  dest[(signed long int)i] = (char)0;
  return dest;
}

// file_timestamp
// file proxy/store.c line 275
static signed long int file_timestamp(const char *file)
{
  struct stat buf;
  signed int return_value_stat_1;
  return_value_stat_1=stat(file, &buf);
  if(return_value_stat_1 == 0)
  {
    signed long int tt = buf.st_mtim.tv_sec;
    if(!(tt == 0l) && !(tt == -1l))
      return tt;

  }

  return (signed long int)0;
}

// filesize
// file proxy/store.c line 591
static signed long int filesize(const char *filename)
{
  struct stat st;
  memset((void *)&st, 0, sizeof(struct stat) /*144ul*/ );
  signed int return_value_stat_1;
  return_value_stat_1=stat(filename, &st);
  if(return_value_stat_1 == 0)
    return (signed long int)st.st_size;

  else
    return (signed long int)-1;
}

// fill_fopen64_filefunc
// file minizip/ioapi.c line 246
void fill_fopen64_filefunc(struct zlib_filefunc64_def_s *pzlib_filefunc_def)
{
  pzlib_filefunc_def->zopen64_file = fopen64_file_func;
  pzlib_filefunc_def->zread_file = fread_file_func;
  pzlib_filefunc_def->zwrite_file = fwrite_file_func;
  pzlib_filefunc_def->ztell64_file = ftell64_file_func;
  pzlib_filefunc_def->zseek64_file = fseek64_file_func;
  pzlib_filefunc_def->zflush_file = fflush_file_func;
  pzlib_filefunc_def->zclose_file = fclose_file_func;
  pzlib_filefunc_def->zerror_file = ferror_file_func;
  pzlib_filefunc_def->opaque = (void *)0;
}

// fill_fopen_filefunc
// file minizip/ioapi.c line 233
void fill_fopen_filefunc(struct zlib_filefunc_def_s *pzlib_filefunc_def)
{
  pzlib_filefunc_def->zopen_file = fopen_file_func;
  pzlib_filefunc_def->zread_file = fread_file_func;
  pzlib_filefunc_def->zwrite_file = fwrite_file_func;
  pzlib_filefunc_def->ztell_file = ftell_file_func;
  pzlib_filefunc_def->zseek_file = fseek_file_func;
  pzlib_filefunc_def->zflush_file = fflush_file_func;
  pzlib_filefunc_def->zclose_file = fclose_file_func;
  pzlib_filefunc_def->zerror_file = ferror_file_func;
  pzlib_filefunc_def->opaque = (void *)0;
}

// fill_zlib_filefunc64_32_def_from_filefunc32
// file minizip/ioapi.c line 69
void fill_zlib_filefunc64_32_def_from_filefunc32(struct zlib_filefunc64_32_def_s *p_filefunc64_32, const struct zlib_filefunc_def_s *p_filefunc32)
{
  p_filefunc64_32->zfile_func64.zopen64_file = (void * (*)(void *, const void *, signed int))(void *)0;
  p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
  p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
  p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
  p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
  p_filefunc64_32->zfile_func64.zflush_file = p_filefunc32->zflush_file;
  p_filefunc64_32->zfile_func64.ztell64_file = (unsigned long long int (*)(void *, void *))(void *)0;
  p_filefunc64_32->zfile_func64.zseek64_file = (signed long int (*)(void *, void *, unsigned long long int, signed int))(void *)0;
  p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
  p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
  p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
  p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
  p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
}

// fopen64_file_func
// file minizip/ioapi.c line 116
static void * fopen64_file_func(void *opaque, const void *filename, signed int mode)
{
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  const char *mode_fopen = (const char *)(void *)0;
  if((3 & mode) == 1)
    mode_fopen = "rb";

  else
    if(!((4 & mode) == 0))
      mode_fopen = "r+b";

    else
      if(!((8 & mode) == 0))
        mode_fopen = "wb";

  if(!(filename == NULL) && !(mode_fopen == ((const char *)NULL)))
    file=fopen64((const char *)filename, mode_fopen);

  return (void *)file;
}

// fopen_file_func
// file minizip/ioapi.c line 98
static void * fopen_file_func(void *opaque, const char *filename, signed int mode)
{
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  const char *mode_fopen = (const char *)(void *)0;
  if((3 & mode) == 1)
    mode_fopen = "rb";

  else
    if(!((4 & mode) == 0))
      mode_fopen = "r+b";

    else
      if(!((8 & mode) == 0))
        mode_fopen = "wb";

  if(!(mode_fopen == ((const char *)NULL)) && !(filename == ((const char *)NULL)))
    file=fopen(filename, mode_fopen);

  return (void *)file;
}

// fread_file_func
// file minizip/ioapi.c line 135
static unsigned long int fread_file_func(void *opaque, void *stream, void *buf, unsigned long int size)
{
  unsigned long int ret;
  unsigned long int return_value_fread_1;
  return_value_fread_1=fread(buf, (unsigned long int)1, (unsigned long int)size, (struct _IO_FILE *)stream);
  ret = (unsigned long int)return_value_fread_1;
  return ret;
}

// free_datablock
// file minizip/zip.c line 203
static void free_datablock(struct linkedlist_datablock_internal_s *ldi)
{
  while(!(ldi == ((struct linkedlist_datablock_internal_s *)NULL)))
  {
    struct linkedlist_datablock_internal_s *ldinext = ldi->next_datablock;
    if(!(ldi == ((struct linkedlist_datablock_internal_s *)NULL)))
      free((void *)ldi);

    ldi = ldinext;
  }
}

// free_linkedlist
// file minizip/zip.c line 218
static void free_linkedlist(struct linkedlist_data_s *ll)
{
  free_datablock(ll->first_block);
  ll->last_block = (struct linkedlist_datablock_internal_s *)(void *)0;
  ll->first_block = ll->last_block;
}

// fseek64_file_func
// file minizip/ioapi.c line 187
static signed long int fseek64_file_func(void *opaque, void *stream, unsigned long long int offset, signed int origin)
{
  signed int fseek_origin = 0;
  signed long int ret;
  switch(origin)
  {
    case 1:
    {
      fseek_origin = 1;
      break;
    }
    case 2:
    {
      fseek_origin = 2;
      break;
    }
    case 0:
    {
      fseek_origin = 0;
      break;
    }
    default:
      return (signed long int)-1;
  }
  ret = (signed long int)0;
  signed int return_value_fseeko64_1;
  return_value_fseeko64_1=fseeko64((struct _IO_FILE *)stream, (signed long int)offset, fseek_origin);
  if(!(return_value_fseeko64_1 == 0))
    ret = (signed long int)-1;

  return ret;
}

// fseek_file_func
// file minizip/ioapi.c line 164
static signed long int fseek_file_func(void *opaque, void *stream, unsigned long int offset, signed int origin)
{
  signed int fseek_origin = 0;
  signed long int ret;
  switch(origin)
  {
    case 1:
    {
      fseek_origin = 1;
      break;
    }
    case 2:
    {
      fseek_origin = 2;
      break;
    }
    case 0:
    {
      fseek_origin = 0;
      break;
    }
    default:
      return (signed long int)-1;
  }
  ret = (signed long int)0;
  signed int return_value_fseek_1;
  return_value_fseek_1=fseek((struct _IO_FILE *)stream, (signed long int)offset, fseek_origin);
  if(!(return_value_fseek_1 == 0))
    ret = (signed long int)-1;

  return ret;
}

// ftell64_file_func
// file minizip/ioapi.c line 157
static unsigned long long int ftell64_file_func(void *opaque, void *stream)
{
  unsigned long long int ret;
  signed long int return_value_ftello64_1;
  return_value_ftello64_1=ftello64((struct _IO_FILE *)stream);
  ret = (unsigned long long int)return_value_ftello64_1;
  return ret;
}

// ftell_file_func
// file minizip/ioapi.c line 149
static signed long int ftell_file_func(void *opaque, void *stream)
{
  signed long int ret;
  ret=ftell((struct _IO_FILE *)stream);
  return ret;
}

// fwrite_file_func
// file minizip/ioapi.c line 142
static unsigned long int fwrite_file_func(void *opaque, void *stream, const void *buf, unsigned long int size)
{
  unsigned long int ret;
  unsigned long int return_value_fwrite_1;
  return_value_fwrite_1=fwrite(buf, (unsigned long int)1, (unsigned long int)size, (struct _IO_FILE *)stream);
  ret = (unsigned long int)return_value_fwrite_1;
  return ret;
}

// getArcField
// file proxy/store.c line 1865
static const char * getArcField(const char *line, signed int pos)
{
  signed int i = 0;
  for( ; pos >= 1 && !((signed int)line[(signed long int)i] == 0); i = i + 1)
    if((signed int)line[(signed long int)i] == 32)
      pos = pos - 1;

  if(pos == 0)
    return &line[(signed long int)i];

  else
    return (const char *)(void *)0;
}

// getArcLength
// file proxy/store.c line 1893
static signed int getArcLength(const char *line)
{
  const char *pos;
  pos=getArcField(line, 9);
  _Bool tmp_if_expr_2;
  if(!(pos == ((const char *)NULL)))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    pos=getArcField(line, 4);
    tmp_if_expr_2 = pos != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    pos=getArcField(line, 2);
    tmp_if_expr_3 = pos != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    signed int length;
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(pos, "%d", &length);
    if(return_value_sscanf_1 == 1)
      return length;

  }

  return -1;
}

// getArcTimestamp
// file proxy/store.c line 1953
static signed long int getArcTimestamp(const char * const line)
{
  const char *pos;
  pos=getArcField(line, 2);
  _Bool tmp_if_expr_1;
  if(!(pos == ((const char *)NULL)))
  {
    signed int i = 0;
    do
    {
      if((signed int)pos[(signed long int)i] >= 48)
        tmp_if_expr_1 = (signed int)pos[(signed long int)i] <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if(i == 14)
    {
      struct tm tm;
      memset((void *)&tm, 0, sizeof(struct tm) /*56ul*/ );
      signed int return_value_getDigit4_2;
      return_value_getDigit4_2=getDigit4(pos + (signed long int)0);
      tm.tm_year = return_value_getDigit4_2 - 1900;
      signed int return_value_getDigit2_3;
      return_value_getDigit2_3=getDigit2(pos + (signed long int)4);
      tm.tm_mon = return_value_getDigit2_3 - 1;
      tm.tm_mday=getDigit2(pos + (signed long int)6);
      tm.tm_hour=getDigit2(pos + (signed long int)8);
      tm.tm_min=getDigit2(pos + (signed long int)10);
      tm.tm_sec=getDigit2(pos + (signed long int)12);
      tm.tm_isdst = 0;
      signed long int return_value_getGMT_4;
      return_value_getGMT_4=getGMT(&tm);
      return return_value_getGMT_4;
    }

  }

  return (signed long int)-1;
}

// getDigit
// file proxy/store.c line 1926
static signed int getDigit(const char digit)
{
  return (signed int)((signed int)digit - 48);
}

// getDigit2
// file proxy/store.c line 1930
static signed int getDigit2(const char * const pos)
{
  signed int return_value_getDigit_1;
  return_value_getDigit_1=getDigit(pos[(signed long int)0]);
  signed int return_value_getDigit_2;
  return_value_getDigit_2=getDigit(pos[(signed long int)1]);
  return return_value_getDigit_1 * 10 + return_value_getDigit_2;
}

// getDigit4
// file proxy/store.c line 1934
static signed int getDigit4(const char * const pos)
{
  signed int return_value_getDigit_1;
  return_value_getDigit_1=getDigit(pos[(signed long int)0]);
  signed int return_value_getDigit_2;
  return_value_getDigit_2=getDigit(pos[(signed long int)1]);
  signed int return_value_getDigit_3;
  return_value_getDigit_3=getDigit(pos[(signed long int)2]);
  signed int return_value_getDigit_4;
  return_value_getDigit_4=getDigit(pos[(signed long int)3]);
  return return_value_getDigit_1 * 1000 + return_value_getDigit_2 * 100 + return_value_getDigit_3 * 10 + return_value_getDigit_4;
}

// getGMT
// file proxy/store.c line 1939
static signed long int getGMT(struct tm *tm)
{
  signed long int t;
  t=mktime(tm);
  if(!(t == 0l) && !(t == -1l))
    return (signed long int)(t - timezone);

  else
    return (signed long int)-1;
}

// get_time_rfc822
// file proxy/proxytrack.c line 581
static signed long int get_time_rfc822(const char *s)
{
  struct tm result;
  char months[48l] = { 'j', 'a', 'n', ' ', 'f', 'e', 'b', ' ', 'm', 'a', 'r', ' ', 'a', 'p', 'r', ' ', 'm', 'a', 'y', ' ', 'j', 'u', 'n', ' ', 'j', 'u', 'l', ' ', 'a', 'u', 'g', ' ', 's', 'e', 'p', ' ', 'o', 'c', 't', ' ', 'n', 'o', 'v', ' ', 'd', 'e', 'c', 0 };
  char str[256l];
  char *a;
  signed int i;
  signed int result_mm = -1;
  signed int result_dd = -1;
  signed int result_n1 = -1;
  signed int result_n2 = -1;
  signed int result_n3 = -1;
  signed int result_n4 = -1;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  _Bool tmp_if_expr_2;
  if((signed int)return_value_strlen_1 >= 201)
    return (signed long int)0;

  else
  {
    i = 0;
    for( ; !((signed int)s[(signed long int)i] == 0); i = i + 1)
    {
      if((signed int)s[(signed long int)i] >= 65)
        tmp_if_expr_2 = (signed int)s[(signed long int)i] <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        str[(signed long int)i] = (char)((signed int)s[(signed long int)i] + (97 - 65));

      else
        str[(signed long int)i] = s[(signed long int)i];
    }
    str[(signed long int)i] = (char)0;
    do
    {
      a=strchr(str, 45);
      if(a == ((char *)NULL))
        break;

      *a = (char)32;
    }
    while((_Bool)1);
    do
    {
      a=strchr(str, 58);
      if(a == ((char *)NULL))
        break;

      *a = (char)32;
    }
    while((_Bool)1);
    do
    {
      a=strchr(str, 44);
      if(a == ((char *)NULL))
        break;

      *a = (char)32;
    }
    while((_Bool)1);
    a = str;
    while(!(*a == 0))
    {
      char *first;
      char *last;
      char tok[256l];
      for( ; (signed int)*a == 32; a = a + 1l)
        ;
      first = a;
      for( ; !(*a == 0); a = a + 1l)
        if((signed int)*a == 32)
          break;

      last = a;
      tok[(signed long int)0] = (char)0;
      if(!(first == last))
      {
        char *pos;
        strncat(tok, first, (unsigned long int)(signed int)(last - first));
        pos=strstr(months, tok);
        if(!(pos == ((char *)NULL)))
          result_mm = (signed int)(pos - months) / 4;

        else
        {
          signed int number;
          signed int return_value_sscanf_3;
          return_value_sscanf_3=sscanf(tok, "%d", &number);
          if(return_value_sscanf_3 == 1)
          {
            if(!(result_dd >= 0))
              result_dd = number;

            else
              if(!(result_n1 >= 0))
                result_n1 = number;

              else
                if(!(result_n2 >= 0))
                  result_n2 = number;

                else
                  if(!(result_n3 >= 0))
                    result_n3 = number;

                  else
                    if(!(result_n4 >= 0))
                      result_n4 = number;

          }

        }
      }

    }
    if(result_dd >= 0 && result_mm >= 0 && result_n1 >= 0 && result_n2 >= 0 && result_n3 >= 0 && result_n4 >= 0)
    {
      if(result_n4 >= 1000)
      {
        result.tm_year = result_n4 - 1900;
        result.tm_hour = result_n1;
        result.tm_min = result_n2;
        result.tm_sec = result_n3 > 0 ? result_n3 : 0;
      }

      else
      {
        result.tm_hour = result_n2;
        result.tm_min = result_n3;
        result.tm_sec = result_n4 > 0 ? result_n4 : 0;
        if(!(result_n1 >= 51))
          result.tm_year = result_n1 + 100;

        else
          if(!(result_n1 >= 1000))
            result.tm_year = result_n1;

          else
            result.tm_year = result_n1 - 1900;
      }
      result.tm_isdst = 0;
      result.tm_yday = -1;
      result.tm_wday = -1;
      result.tm_mon = result_mm;
      result.tm_mday = result_dd;
      signed long int return_value_mktime_4;
      return_value_mktime_4=mktime(&result);
      return return_value_mktime_4;
    }

    return (signed long int)0;
  }
}

// gethost
// file proxy/proxytrack.c line 229
static signed int gethost(const char *hostname, struct SOCaddr *server)
{
  if(!(hostname == ((const char *)NULL)))
  {
    if(!((signed int)*hostname == 0))
    {
      struct addrinfo *res = (struct addrinfo *)(void *)0;
      struct addrinfo hints;
      memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
      hints.ai_family = 0;
      hints.ai_socktype = 1;
      hints.ai_protocol = 6;
      signed int return_value_getaddrinfo_1;
      return_value_getaddrinfo_1=getaddrinfo(hostname, (const char *)(void *)0, &hints, &res);
      if(return_value_getaddrinfo_1 == 0)
      {
        if(!(res == ((struct addrinfo *)NULL)))
        {
          if(!(res->ai_addr == ((struct sockaddr *)NULL)))
          {
            if(!(res->ai_addrlen == 0u))
            {
              do
                SOCaddr_copyaddr_(&(*server), (const void *)res->ai_addr, (const unsigned long int)res->ai_addrlen, "proxy/proxytrack.c", 264);
              while((_Bool)0);
              freeaddrinfo(res);
              return 1;
            }

          }

        }

      }

      if(!(res == ((struct addrinfo *)NULL)))
        freeaddrinfo(res);

    }

  }

  return 0;
}

// getip
// file proxy/proxytrack.c line 278
static struct String getip(struct SOCaddr *server)
{
  struct String s = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  unsigned int sizeMax = (unsigned int)sizeof(char [41l]) /*41ul*/ ;
  char *dotted;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(sizeMax + (unsigned int)1));
  dotted = (char *)return_value_malloc_1;
  unsigned short int port;
  unsigned short int *return_value_SOCaddr_sinport__2;
  return_value_SOCaddr_sinport__2=SOCaddr_sinport_(&(*server), "proxy/proxytrack.c", 287);
  port=ntohs(*return_value_SOCaddr_sinport__2);
  if(dotted == ((char *)NULL))
  {
    proxytrack_print_log("critical", "memory exhausted");
    return s;
  }

  else
  {
    SOCaddr_inetntoa_(dotted, (unsigned long int)sizeMax, &(*server), "proxy/proxytrack.c", 293);
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(dotted);
    sprintf(dotted + (signed long int)return_value_strlen_3, ":%d", port);
    StringAttach(&s, &dotted);
    return s;
  }
}

// init_keys
// file minizip/crypt.h line 65
static void init_keys(const char *passwd, unsigned long int *pkeys, const unsigned int *pcrc_32_tab)
{
  pkeys[(signed long int)0] = (unsigned long int)305419896L;
  pkeys[(signed long int)1] = (unsigned long int)591751049L;
  pkeys[(signed long int)2] = (unsigned long int)878082192L;
  for( ; !((signed int)*passwd == 0); passwd = passwd + 1l)
    update_keys(pkeys, pcrc_32_tab, (signed int)*passwd);
}

// init_linkedlist
// file minizip/zip.c line 213
static void init_linkedlist(struct linkedlist_data_s *ll)
{
  ll->last_block = (struct linkedlist_datablock_internal_s *)(void *)0;
  ll->first_block = ll->last_block;
}

// jump_protocol
// file proxy/proxytrack.h line 165
static const char * jump_protocol(const char *source)
{
  signed int p;
  p=strfield(source, "http:");
  if(!(p == 0))
    source = source + (signed long int)p;

  else
  {
    p=strfield(source, "ftp:");
    if(!(p == 0))
      source = source + (signed long int)p;

    else
    {
      p=strfield(source, "https:");
      if(!(p == 0))
        source = source + (signed long int)p;

      else
      {
        p=strfield(source, "file:");
        if(!(p == 0))
          source = source + (signed long int)p;

      }
    }
  }
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(source, "//", (unsigned long int)2);
  if(return_value_strncmp_1 == 0)
    source = source + (signed long int)2;

  return source;
}

// jump_protocol_link1
// file proxy/proxytrack.h line 165
static const char * jump_protocol_link1(const char *source_link1)
{
  signed int p_link1;
  p_link1=strfield_link1(source_link1, "http:");
  if(!(p_link1 == 0))
    source_link1 = source_link1 + (signed long int)p_link1;

  else
  {
    p_link1=strfield_link1(source_link1, "ftp:");
    if(!(p_link1 == 0))
      source_link1 = source_link1 + (signed long int)p_link1;

    else
    {
      p_link1=strfield_link1(source_link1, "https:");
      if(!(p_link1 == 0))
        source_link1 = source_link1 + (signed long int)p_link1;

      else
      {
        p_link1=strfield_link1(source_link1, "file:");
        if(!(p_link1 == 0))
          source_link1 = source_link1 + (signed long int)p_link1;

      }
    }
  }
  signed int return_value_strncmp_1_link1;
  return_value_strncmp_1_link1=strncmp(source_link1, "//", (unsigned long int)2);
  if(return_value_strncmp_1_link1 == 0)
    source_link1 = source_link1 + (signed long int)2;

  return source_link1;
}

// jump_protocol_and_auth
// file proxy/proxytrack.h line 201
static const char * jump_protocol_and_auth(const char *source)
{
  const char *a;
  const char *trytofind;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(source, "file://");
  if(return_value_strcmp_1 == 0)
    return source;

  else
  {
    a=jump_protocol(source);
    char *return_value_strchr_2;
    return_value_strchr_2=strchr(a, 47);
    trytofind=strrchr_limit(a, (char)64, return_value_strchr_2);
    return trytofind != (const char *)(void *)0 ? trytofind : a;
  }
}

// jump_protocol_and_auth_link1
// file proxy/proxytrack.h line 201
static const char * jump_protocol_and_auth_link1(const char *source_link1)
{
  const char *a_link1;
  const char *trytofind_link1;
  signed int return_value_strcmp_1_link1;
  return_value_strcmp_1_link1=strcmp(source_link1, "file://");
  if(return_value_strcmp_1_link1 == 0)
    return source_link1;

  else
  {
    a_link1=jump_protocol_link1(source_link1);
    char *return_value_strchr_2_link1;
    return_value_strchr_2_link1=strchr(a_link1, 47);
    trytofind_link1=strrchr_limit_link1(a_link1, (char)64, return_value_strchr_2_link1);
    return trytofind_link1 != (const char *)(void *)0 ? trytofind_link1 : a_link1;
  }
}

// link_has_authority
// file proxy/proxytrack.h line 148
static signed int link_has_authority(const char *lien)
{
  const char *a = lien;
  const unsigned short int **return_value___ctype_b_loc_2;
  return_value___ctype_b_loc_2=__ctype_b_loc();
  const unsigned short int **return_value___ctype_b_loc_1;
  if(!((1024 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)(const unsigned char)*a]) == 0))
  {
    do
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((1024 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(const unsigned char)*a]) == 0)
        break;

      a = a + 1l;
    }
    while((_Bool)1);
    if((signed int)*a == 58)
      a = a + 1l;

    else
      return 0;
  }

  signed int return_value_strncmp_3;
  return_value_strncmp_3=strncmp(a, "//", (unsigned long int)2);
  if(return_value_strncmp_3 == 0)
    return 1;

  else
    return 0;
}

// link_has_authority_link1
// file proxy/proxytrack.h line 148
static signed int link_has_authority_link1(const char *lien_link1)
{
  const char *a_link1 = lien_link1;
  const unsigned short int **return_value___ctype_b_loc_2_link1;
  return_value___ctype_b_loc_2_link1=__ctype_b_loc();
  const unsigned short int **return_value___ctype_b_loc_1_link1;
  if(!((1024 & (signed int)(*return_value___ctype_b_loc_2_link1)[(signed long int)(signed int)(const unsigned char)*a_link1]) == 0))
  {
    do
    {
      return_value___ctype_b_loc_1_link1=__ctype_b_loc();
      if((1024 & (signed int)(*return_value___ctype_b_loc_1_link1)[(signed long int)(signed int)(const unsigned char)*a_link1]) == 0)
        break;

      a_link1 = a_link1 + 1l;
    }
    while((_Bool)1);
    if((signed int)*a_link1 == 58)
      a_link1 = a_link1 + 1l;

    else
      return 0;
  }

  signed int return_value_strncmp_3_link1;
  return_value_strncmp_3_link1=strncmp(a_link1, "//", (unsigned long int)2);
  if(return_value_strncmp_3_link1 == 0)
    return 1;

  else
    return 0;
}

// linput
// file proxy/proxytrack.h line 121
static signed int linput(struct _IO_FILE *fp, char *s, signed int max)
{
  signed int c;
  signed int j = 0;
  signed int tmp_post_1;
  do
  {
    c=fgetc(fp);
    if(!(c == -1))
      switch(c)
      {
        case 13:
          break;
        case 10:
        {
          c = -1;
          break;
        }
        case 0:

        case 9:

        case 12:
          break;
        default:
        {
          tmp_post_1 = j;
          j = j + 1;
          s[(signed long int)tmp_post_1] = (char)c;
        }
      }

  }
  while(!(c == -1) && !(j >= max + -1));
  s[(signed long int)j] = (char)0;
  return j;
}

// linput_link1
// file proxy/proxytrack.h line 121
static signed int linput_link1(struct _IO_FILE *fp_link1, char *s_link1, signed int max_link1)
{
  signed int c_link1;
  signed int j_link1 = 0;
  signed int tmp_post_1_link1;
  do
  {
    c_link1=fgetc(fp_link1);
    if(!(c_link1 == -1))
      switch(c_link1)
      {
        case 13:
          break;
        case 10:
        {
          c_link1 = -1;
          break;
        }
        case 0:

        case 9:

        case 12:
          break;
        default:
        {
          tmp_post_1_link1 = j_link1;
          j_link1 = j_link1 + 1;
          s_link1[(signed long int)tmp_post_1_link1] = (char)c_link1;
        }
      }

  }
  while(!(c_link1 == -1) && !(j_link1 >= max_link1 + -1));
  s_link1[(signed long int)j_link1] = (char)0;
  return j_link1;
}

// linputsoc
// file proxy/proxytrack.c line 172
static signed int linputsoc(signed int soc, char *s, signed int max)
{
  signed int c;
  signed int j = 0;
  signed int tmp_post_2;
  do
  {
    unsigned char ch;
    signed long int return_value_recv_1;
    return_value_recv_1=recv(soc, (void *)&ch, (unsigned long int)1, 0);
    if(return_value_recv_1 == 1l)
      c = (signed int)ch;

    else
      c = -1;
    if(!(c == -1))
      switch(c)
      {
        case 13:
          break;
        case 10:
        {
          c = -1;
          break;
        }
        case 9:

        case 12:
          break;
        default:
        {
          tmp_post_2 = j;
          j = j + 1;
          s[(signed long int)tmp_post_2] = (char)c;
        }
      }

  }
  while(!(c == -1) && !(j >= max + -1));
  s[(signed long int)j] = (char)0;
  return j;
}

// linputsoc_t
// file proxy/proxytrack.c line 222
static signed int linputsoc_t(signed int soc, char *s, signed int max, signed int timeout)
{
  signed int return_value_check_readinput_t_2;
  return_value_check_readinput_t_2=check_readinput_t(soc, timeout);
  if(!(return_value_check_readinput_t_2 == 0))
  {
    signed int return_value_linputsoc_1;
    return_value_linputsoc_1=linputsoc(soc, s, max);
    return return_value_linputsoc_1;
  }

  return -1;
}

// log_abort_
// file ./htssafe.h line 90
static void log_abort_(const char *msg, const char *file, signed int line)
{
  fprintf(stderr, "%s failed at %s:%d\n", msg, file, line);
  fflush(stderr);
}

// log_abort__link1
// file ./htssafe.h line 90
static void log_abort__link1(const char *msg_link1, const char *file_link1, signed int line_link1)
{
  fprintf(stderr, "%s failed at %s:%d\n", msg_link1, file_link1, line_link1);
  fflush(stderr);
}

// main
// file proxy/main.c line 65
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int ret = 0;
  signed int proxyPort = 0;
  signed int icpPort = 0;
  char proxyAddr[257l];
  char icpAddr[257l];
  struct _PT_Indexes *index;
  printf("ProxyTrack %s, build proxies upon HTTrack Website Copier Archives\n", (const void *)"0.5");
  printf("Copyright (C) 1998-2015 Xavier Roche and other contributors\n");
  printf("\n");
  printf("This program is free software: you can redistribute it and/or modify\n");
  printf("it under the terms of the GNU General Public License as published by\n");
  printf("the Free Software Foundation, either version 3 of the License, or\n");
  printf("(at your option) any later version.\n");
  printf("\n");
  printf("*** This version is a development release ***\n");
  printf("\n");
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_5;
  signed int return_value_scanHostPort_2;
  _Bool tmp_if_expr_4;
  signed int return_value_scanHostPort_3;
  if(!(argc >= 3))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_strcmp_1=strcmp(argv[(signed long int)1], "--convert");
    if(!(return_value_strcmp_1 == 0))
    {
      return_value_scanHostPort_2=scanHostPort(argv[(signed long int)1], proxyAddr, &proxyPort);
      if(return_value_scanHostPort_2 == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_scanHostPort_3=scanHostPort(argv[(signed long int)2], icpAddr, &icpPort);
        tmp_if_expr_4 = !(return_value_scanHostPort_3 != 0) ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_linput_7;
  if(tmp_if_expr_6)
  {
    fprintf(stderr, "proxy mode:\n");
    fprintf(stderr, "usage: %s <proxy-addr:proxy-port> <ICP-addr:ICP-port> [ ( <new.zip path> | <new.ndx path> | <archive.arc path> | --list <file-list> ) ..]\n", argv[(signed long int)0]);
    fprintf(stderr, "\texample:%s proxy:8080 localhost:3130 /home/archives/www-archive-01.zip /home/old-archives/www-archive-02.ndx\n", argv[(signed long int)0]);
    fprintf(stderr, "convert mode:\n");
    fprintf(stderr, "usage: %s --convert <archive-output-path> [ ( <new.zip path> | <new.ndx path> | <archive.arc path> | --list <file-list> ) ..]\n", argv[(signed long int)0]);
    fprintf(stderr, "\texample:%s proxy:8080 localhost:3130 /home/archives/www-archive-01.zip /home/old-archives/www-archive-02.ndx\n", argv[(signed long int)0]);
    return 1;
  }

  else
  {
    index=PT_New();
    i = 3;
    for( ; !(i >= argc); i = i + 1)
      if((signed int)*argv[(signed long int)i] == 45)
      {
        signed int return_value_strcmp_8;
        return_value_strcmp_8=strcmp(argv[(signed long int)i], "--list");
        if(return_value_strcmp_8 == 0)
        {
          if(!(1 + i >= argc))
          {
            char line[257l];
            struct _IO_FILE *fp;
            i = i + 1;
            fp=fopen(argv[(signed long int)i], "rb");
            if(fp == ((struct _IO_FILE *)NULL))
            {
              fprintf(stderr, "error: could not process list %s\n", argv[(signed long int)i]);
              exit(1);
            }

            do
            {
              return_value_linput_7=linput(fp, line, 256);
              if(return_value_linput_7 == 0)
                break;

              signed int main__1__2__1__1__1__1__2__itemsAdded;
              main__1__2__1__1__1__1__2__itemsAdded=PT_AddIndex(index, line);
              if(main__1__2__1__1__1__1__2__itemsAdded >= 1)
                fprintf(stderr, "processed: %s (%d items added)\n", (const void *)line, main__1__2__1__1__1__1__2__itemsAdded);

              else
                if(main__1__2__1__1__1__1__2__itemsAdded == 0)
                  fprintf(stderr, "processed: %s (no items added)\n", (const void *)line);

                else
                  fprintf(stderr, "error: could not process %s\n", (const void *)line);
            }
            while((_Bool)1);
            fclose(fp);
          }

        }

        else
        {
          fprintf(stderr, "* bad arg %s\n", argv[(signed long int)i]);
          exit(1);
        }
      }

      else
      {
        signed int itemsAdded;
        itemsAdded=PT_AddIndex(index, argv[(signed long int)i]);
        if(itemsAdded >= 1)
          fprintf(stderr, "processed: %s (%d items added)\n", argv[(signed long int)i], itemsAdded);

        else
          if(itemsAdded == 0)
            fprintf(stderr, "processed: %s (no items added)\n", argv[(signed long int)i]);

          else
            fprintf(stderr, "error: could not process %s\n", argv[(signed long int)i]);
      }
    signal(13, sig_brpipe);
    signed int return_value_strcmp_9;
    return_value_strcmp_9=strcmp(argv[(signed long int)1], "--convert");
    if(!(return_value_strcmp_9 == 0))
      ret=proxytrack_main(proxyAddr, proxyPort, icpAddr, icpPort, index);

    else
    {
      ret=PT_SaveCache(index, argv[(signed long int)2]);
      if(ret == 0)
        fprintf(stderr, "processed: '%s'\n", argv[(signed long int)2]);

      else
        fprintf(stderr, "error: could not save '%s'\n", argv[(signed long int)2]);
    }
    PT_Delete(index);
    return ret;
  }
}

// md5selftest
// file htsmd5.c line 83
void md5selftest(void)
{
  char digest[64l];
  do
  {
    memset((void *)digest, 0xCC, sizeof(char [64l]) /*64ul*/ );
    static const char str1[45l] = { 'T', 'h', 'e', ' ', 'q', 'u', 'i', 'c', 'k', ' ', 'b', 'r', 'o', 'w', 'n', ' ', 'f', 'o', 'x', ' ', 'j', 'u', 'm', 'p', 's', ' ', 'o', 'v', 'e', 'r', ' ', 't', 'h', 'e', ' ', 'l', 'a', 'z', 'y', ' ', 'd', 'o', 'g', '\n', 0 };
    domd5mem(str1, sizeof(const char [45l]) /*45ul*/  - (unsigned long int)1, digest, 1);
    signed int return_value_strcmp_1;
    static const char str1m[33l] = { '3', '7', 'c', '4', 'b', '8', '7', 'e', 'd', 'f', 'f', 'c', '5', 'd', '1', '9', '8', 'f', 'f', '5', 'a', '1', '8', '5', 'c', 'e', 'e', '7', 'e', 'e', '0', '9', 0 };
    return_value_strcmp_1=strcmp(digest, str1m);
    if(!(return_value_strcmp_1 == 0))
    {
      fprintf(stderr, "error: md5 selftest failed: '%s' => '%s' (!= '%s')\n", (const void *)str1, (const void *)digest, (const void *)str1m);
      /* assertion ! "md5 selftest failed" */
      assert(!((_Bool)"md5 selftest failed"));
    }

  }
  while((_Bool)0);
  do
  {
    memset((void *)digest, 0xCC, sizeof(char [64l]) /*64ul*/ );
    static const char str2[6l] = { 'H', 'e', 'l', 'l', 'o', 0 };
    domd5mem(str2, sizeof(const char [6l]) /*6ul*/  - (unsigned long int)1, digest, 1);
    signed int return_value_strcmp_2;
    static const char str2m[33l] = { '8', 'b', '1', 'a', '9', '9', '5', '3', 'c', '4', '6', '1', '1', '2', '9', '6', 'a', '8', '2', '7', 'a', 'b', 'f', '8', 'c', '4', '7', '8', '0', '4', 'd', '7', 0 };
    return_value_strcmp_2=strcmp(digest, str2m);
    if(!(return_value_strcmp_2 == 0))
    {
      fprintf(stderr, "error: md5 selftest failed: '%s' => '%s' (!= '%s')\n", (const void *)str2, (const void *)digest, (const void *)str2m);
      /* assertion ! "md5 selftest failed" */
      assert(!((_Bool)"md5 selftest failed"));
    }

  }
  while((_Bool)0);
  fprintf(stderr, "md5 selftest succeeded\n");
}

// md5sum32
// file htsmd5.c line 73
unsigned long int md5sum32(const char *buff)
{
  /* tag-#anon#lUN[lARR16{S8}_S8_'md5digest'||U64'hash'|] */
union anonymous_21
{
  // md5digest
  char md5digest[16l];
  // hash
  unsigned long int hash;
};

/* */
  ;
  union anonymous_21 u;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buff);
  domd5mem(buff, return_value_strlen_1, u.md5digest, 0);
  return u.hash;
}

// proxytrack_add_DAV_Item
// file proxy/proxytrack.c line 523
static void proxytrack_add_DAV_Item(struct String *item, struct String *buff, const char *filename, unsigned long int size, signed long int timestamp, const char *mime, signed int isDir, signed int isRoot, signed int isDefault)
{
  struct tm *timetm;
  if(timestamp == 0l || timestamp == -1l)
    timestamp=time((signed long int *)(void *)0);

  timetm=gmtime(&timestamp);
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  if(!(timetm == ((struct tm *)NULL)))
  {
    char tms[257l];
    const char *name;
    strftime(tms, (unsigned long int)256, "%a, %d %b %Y %H:%M:%S GMT", timetm);
    if(mime == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*mime == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      mime = "application/octet-stream";

    buff->length_ = (unsigned long int)0;
    escapexml(filename, buff);
    name=strrchr((const char *)buff->buffer_, 47);
    if(!(name == ((const char *)NULL)))
      name = name + 1l;

    if(name == ((const char *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)*name == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp(mime, "text/html");
      if(return_value_strcmp_2 == 0)
        name = "Default Document for the Folder.html";

      else
        name = "Default Document for the Folder";
    }

    do
    {
      const unsigned long int capacity_ = (unsigned long int)(item->length_ + (unsigned long int)1024 + (unsigned long int)1);
      while(!(item->capacity_ >= capacity_))
      {
        if(!(item->capacity_ >= 16ul))
          item->capacity_ = (unsigned long int)16;

        else
          item->capacity_ = item->capacity_ * (unsigned long int)2;
        void *return_value_realloc_4;
        return_value_realloc_4=realloc((void *)item->buffer_, item->capacity_);
        item->buffer_ = (char *)return_value_realloc_4;
        /* assertion (*item).buffer_ != ((void *)0) */
        assert(item->buffer_ != (char *)(void *)0);
      }
    }
    while((_Bool)0);
    sprintf(item->buffer_, "<response xmlns=\"DAV:\">\r\n<href>/webdav%s%s</href>\r\n<propstat>\r\n<prop>\r\n<displayname>%s</displayname>\r\n<iscollection>%d</iscollection>\r\n<haschildren>%d</haschildren>\r\n<isfolder>%d</isfolder>\r\n<resourcetype>%s</resourcetype>\r\n<creationdate>%d-%02d-%02dT%02d:%02d:%02dZ</creationdate>\r\n<getlastmodified>%s</getlastmodified>\r\n<supportedlock></supportedlock>\r\n<lockdiscovery/>\r\n<getcontenttype>%s</getcontenttype>\r\n<getcontentlength>%d</getcontentlength>\r\n<isroot>%d</isroot>\r\n</prop>\r\n<status>HTTP/1.1 200 OK</status>\r\n</propstat>\r\n</response>\r\n", (signed int)((const char *)buff->buffer_)[(signed long int)0] == 47 ? "" : "/", (const char *)buff->buffer_, name, isDir != 0 ? 1 : 0, isDir != 0 ? 1 : 0, isDir != 0 ? 1 : 0, isDir != 0 ? "<collection/>" : "", timetm->tm_year + 1900, timetm->tm_mon + 1, timetm->tm_mday, timetm->tm_hour, timetm->tm_min, timetm->tm_sec, (const void *)tms, isDir != 0 ? "httpd/unix-directory" : mime, (signed int)size, isRoot != 0 ? 1 : 0);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen((const char *)item->buffer_);
    item->length_ = (unsigned long int)(signed int)return_value_strlen_5;
  }

}

// proxytrack_main
// file proxy/proxytrack.h line 55
signed int proxytrack_main(char *proxyAddr, signed int proxyPort, char *icpAddr, signed int icpPort, struct _PT_Indexes *index)
{
  signed int returncode = 0;
  signed int soc;
  soc=smallserver_init(proxyAddr, proxyPort, 1);
  signed int socICP;
  socICP=smallserver_init(proxyAddr, icpPort, 2);
  if(!(soc == -1) && !(socICP == -1))
  {
    printf("HTTP Proxy installed on %s:%d/\n", proxyAddr, proxyPort);
    printf("ICP Proxy installed on %s:%d/\n", icpAddr, icpPort);
    signed int pid;
    pid=getpid();
    printf("PID=%d\n", (signed int)pid);
    fflush(stdout);
    fflush(stderr);
    signed int return_value_proxytrack_start_3;
    return_value_proxytrack_start_3=proxytrack_start(index, soc, socICP);
    if(return_value_proxytrack_start_3 == 0)
    {
      signed int last_errno;
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      last_errno = *return_value___errno_location_1;
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(last_errno);
      fprintf(stderr, "Unable to create the server: %s\n", return_value_strerror_2);
      close(soc);
      printf("Done\n");
      returncode = 1;
    }

    else
      returncode = 0;
  }

  else
  {
    signed int proxytrack_main__1__2__last_errno;
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    proxytrack_main__1__2__last_errno = *return_value___errno_location_4;
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(proxytrack_main__1__2__last_errno);
    fprintf(stderr, "Unable to initialize a temporary server : %s\n", return_value_strerror_5);
    returncode = 1;
  }
  printf("EXITED\n");
  fflush(stdout);
  fflush(stderr);
  return returncode;
}

// proxytrack_print_log
// file proxy/proxytrack.h line 67
static void proxytrack_print_log(const char *severity, const char *format, ...)
{
  if(!(severity == ((const char *)NULL)))
  {
    signed int error;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    error = *return_value___errno_location_1;
    struct _IO_FILE * const fp = stderr;
    void **args;
    fprintf(fp, " * %s: ", severity);
    args = (void **)&format;
    vfprintf(fp, format, args);
    args = ((void **)NULL);
    fputs("\n", fp);
    fflush(fp);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = error;
  }

}

// proxytrack_print_log_link1
// file proxy/proxytrack.h line 67
static void proxytrack_print_log_link1(const char *severity_link1, const char *format_link1, ...)
{
  if(!(severity_link1 == ((const char *)NULL)))
  {
    signed int error_link1;
    signed int *return_value___errno_location_1_link1;
    return_value___errno_location_1_link1=__errno_location();
    error_link1 = *return_value___errno_location_1_link1;
    struct _IO_FILE * const fp_link1 = stderr;
    void **args_link1;
    fprintf(fp_link1, " * %s: ", severity_link1);
    args_link1 = (void **)&format_link1;
    vfprintf(fp_link1, format_link1, args_link1);
    args_link1 = ((void **)NULL);
    fputs("\n", fp_link1);
    fflush(fp_link1);
    signed int *return_value___errno_location_2_link1;
    return_value___errno_location_2_link1=__errno_location();
    *return_value___errno_location_2_link1 = error_link1;
  }

}

// proxytrack_process_DAV_Request
// file proxy/proxytrack.c line 683
static struct _PT_Element * proxytrack_process_DAV_Request(struct _PT_Indexes *indexes, const char *urlFull, signed int depth)
{
  const char *proxytrack_process_DAV_Request__1__file;
  proxytrack_process_DAV_Request__1__file=jump_protocol_and_auth(urlFull);
  proxytrack_process_DAV_Request__1__file=strchr(proxytrack_process_DAV_Request__1__file, 47);
  unsigned long int return_value_strlen_15;
  unsigned long int return_value_strlen_16;
  if(proxytrack_process_DAV_Request__1__file == ((const char *)NULL))
    return (struct _PT_Element *)(void *)0;

  else
  {
    signed int return_value_strncmp_1;
    return_value_strncmp_1=strncmp(proxytrack_process_DAV_Request__1__file, "/webdav", (unsigned long int)7);
    if(!(return_value_strncmp_1 == 0))
    {
      struct _PT_Element *elt;
      elt=PT_ElementNew();
      elt->statuscode = 405;
      strcpy(elt->msg, "Method Not Allowed");
      return elt;
    }

    proxytrack_process_DAV_Request__1__file = proxytrack_process_DAV_Request__1__file + (signed long int)7;
    struct _PT_Element *proxytrack_process_DAV_Request__1__2__elt;
    proxytrack_process_DAV_Request__1__2__elt=PT_ElementNew();
    signed int i;
    signed int isDir;
    struct String url = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    struct String response = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    struct String item = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    struct String itemUrl = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    struct String buff = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    do
    {
      response.length_ = (unsigned long int)0;
      do
      {
        const unsigned long int proxytrack_process_DAV_Request__1__2__1__1__capacity_ = (unsigned long int)(response.length_ + (unsigned long int)0 + (unsigned long int)1);
        while(!(response.capacity_ >= proxytrack_process_DAV_Request__1__2__1__1__capacity_))
        {
          if(!(response.capacity_ >= 16ul))
            response.capacity_ = (unsigned long int)16;

          else
            response.capacity_ = response.capacity_ * (unsigned long int)2;
          void *return_value_realloc_2;
          return_value_realloc_2=realloc((void *)response.buffer_, response.capacity_);
          response.buffer_ = (char *)return_value_realloc_2;
          /* assertion (response).buffer_ != ((void *)0) */
          assert(response.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      response.buffer_[(signed long int)0] = (char)0;
    }
    while((_Bool)0);
    do
    {
      item.length_ = (unsigned long int)0;
      do
      {
        const unsigned long int proxytrack_process_DAV_Request__1__2__2__1__capacity_ = (unsigned long int)(item.length_ + (unsigned long int)0 + (unsigned long int)1);
        while(!(item.capacity_ >= proxytrack_process_DAV_Request__1__2__2__1__capacity_))
        {
          if(!(item.capacity_ >= 16ul))
            item.capacity_ = (unsigned long int)16;

          else
            item.capacity_ = item.capacity_ * (unsigned long int)2;
          void *return_value_realloc_3;
          return_value_realloc_3=realloc((void *)item.buffer_, item.capacity_);
          item.buffer_ = (char *)return_value_realloc_3;
          /* assertion (item).buffer_ != ((void *)0) */
          assert(item.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      item.buffer_[(signed long int)0] = (char)0;
    }
    while((_Bool)0);
    do
    {
      itemUrl.length_ = (unsigned long int)0;
      do
      {
        const unsigned long int capacity_ = (unsigned long int)(itemUrl.length_ + (unsigned long int)0 + (unsigned long int)1);
        while(!(itemUrl.capacity_ >= capacity_))
        {
          if(!(itemUrl.capacity_ >= 16ul))
            itemUrl.capacity_ = (unsigned long int)16;

          else
            itemUrl.capacity_ = itemUrl.capacity_ * (unsigned long int)2;
          void *return_value_realloc_4;
          return_value_realloc_4=realloc((void *)itemUrl.buffer_, itemUrl.capacity_);
          itemUrl.buffer_ = (char *)return_value_realloc_4;
          /* assertion (itemUrl).buffer_ != ((void *)0) */
          assert(itemUrl.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      itemUrl.buffer_[(signed long int)0] = (char)0;
    }
    while((_Bool)0);
    do
    {
      buff.length_ = (unsigned long int)0;
      do
      {
        const unsigned long int proxytrack_process_DAV_Request__1__2__4__1__capacity_ = (unsigned long int)(buff.length_ + (unsigned long int)0 + (unsigned long int)1);
        while(!(buff.capacity_ >= proxytrack_process_DAV_Request__1__2__4__1__capacity_))
        {
          if(!(buff.capacity_ >= 16ul))
            buff.capacity_ = (unsigned long int)16;

          else
            buff.capacity_ = buff.capacity_ * (unsigned long int)2;
          void *return_value_realloc_5;
          return_value_realloc_5=realloc((void *)buff.buffer_, buff.capacity_);
          buff.buffer_ = (char *)return_value_realloc_5;
          /* assertion (buff).buffer_ != ((void *)0) */
          assert(buff.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      buff.buffer_[(signed long int)0] = (char)0;
    }
    while((_Bool)0);
    do
    {
      const char *str__ = proxytrack_process_DAV_Request__1__file + (signed long int)((signed int)proxytrack_process_DAV_Request__1__file[(signed long int)0] == 47 ? 1 : 0);
      if(!(str__ == ((const char *)NULL)))
      {
        unsigned long int size__;
        size__=strlen(str__);
        do
        {
          url.length_ = (unsigned long int)0;
          do
          {
            const char *proxytrack_process_DAV_Request__1__2__5__1__1__1__str_mc_ = str__;
            const unsigned long int proxytrack_process_DAV_Request__1__2__5__1__1__1__size_mc_ = (unsigned long int)size__;
            do
            {
              const unsigned long int proxytrack_process_DAV_Request__1__2__5__1__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_DAV_Request__1__2__5__1__1__1__size_mc_ + (unsigned long int)1);
              while(!(url.capacity_ >= proxytrack_process_DAV_Request__1__2__5__1__1__1__1__capacity_))
              {
                if(!(url.capacity_ >= 16ul))
                  url.capacity_ = (unsigned long int)16;

                else
                  url.capacity_ = url.capacity_ * (unsigned long int)2;
                void *return_value_realloc_6;
                return_value_realloc_6=realloc((void *)url.buffer_, url.capacity_);
                url.buffer_ = (char *)return_value_realloc_6;
                /* assertion (url).buffer_ != ((void *)0) */
                assert(url.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_DAV_Request__1__2__5__1__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_DAV_Request__1__2__5__1__1__1__str_mc_, proxytrack_process_DAV_Request__1__2__5__1__1__1__size_mc_);
              url.length_ = url.length_ + proxytrack_process_DAV_Request__1__2__5__1__1__1__size_mc_;
            }

            url.buffer_[(signed long int)url.length_] = (char)0;
          }
          while((_Bool)0);
        }
        while((_Bool)0);
      }

      else
        do
        {
          url.length_ = (unsigned long int)0;
          do
          {
            const unsigned long int proxytrack_process_DAV_Request__1__2__5__2__1__1__capacity_ = (unsigned long int)(url.length_ + (unsigned long int)0 + (unsigned long int)1);
            while(!(url.capacity_ >= proxytrack_process_DAV_Request__1__2__5__2__1__1__capacity_))
            {
              if(!(url.capacity_ >= 16ul))
                url.capacity_ = (unsigned long int)16;

              else
                url.capacity_ = url.capacity_ * (unsigned long int)2;
              void *return_value_realloc_7;
              return_value_realloc_7=realloc((void *)url.buffer_, url.capacity_);
              url.buffer_ = (char *)return_value_realloc_7;
              /* assertion (url).buffer_ != ((void *)0) */
              assert(url.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          url.buffer_[(signed long int)0] = (char)0;
        }
        while((_Bool)0);
    }
    while((_Bool)0);
    if(url.length_ >= 1ul)
    {
      if((signed int)url.buffer_[-1l + (signed long int)url.length_] == 47)
      {
        url.buffer_[(signed long int)(url.length_ - (unsigned long int)1)] = (char)0;
        url.length_ = url.length_ - 1ul;
      }

    }

    do
    {
      const unsigned long int proxytrack_process_DAV_Request__1__2__7__capacity_ = (unsigned long int)(response.length_ + (unsigned long int)1024 + (unsigned long int)1);
      while(!(response.capacity_ >= proxytrack_process_DAV_Request__1__2__7__capacity_))
      {
        if(!(response.capacity_ >= 16ul))
          response.capacity_ = (unsigned long int)16;

        else
          response.capacity_ = response.capacity_ * (unsigned long int)2;
        void *return_value_realloc_8;
        return_value_realloc_8=realloc((void *)response.buffer_, response.capacity_);
        response.buffer_ = (char *)return_value_realloc_8;
        /* assertion (response).buffer_ != ((void *)0) */
        assert(response.buffer_ != (char *)(void *)0);
      }
    }
    while((_Bool)0);
    sprintf(response.buffer_, "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<multistatus xmlns=\"DAV:\">\r\n");
    unsigned long int return_value_strlen_9;
    return_value_strlen_9=strlen((const char *)response.buffer_);
    response.length_ = (unsigned long int)(signed int)return_value_strlen_9;
    item.length_ = (unsigned long int)0;
    proxytrack_add_DAV_Item(&item, &buff, (const char *)url.buffer_, (unsigned long int)0, (signed long int)0, (const char *)(void *)0, 1, 1, 0);
    do
    {
      const char *proxytrack_process_DAV_Request__1__2__8__str_mc_ = (const char *)item.buffer_;
      const unsigned long int proxytrack_process_DAV_Request__1__2__8__size_mc_ = (unsigned long int)item.length_;
      do
      {
        const unsigned long int proxytrack_process_DAV_Request__1__2__8__1__capacity_ = (unsigned long int)(response.length_ + proxytrack_process_DAV_Request__1__2__8__size_mc_ + (unsigned long int)1);
        while(!(response.capacity_ >= proxytrack_process_DAV_Request__1__2__8__1__capacity_))
        {
          if(!(response.capacity_ >= 16ul))
            response.capacity_ = (unsigned long int)16;

          else
            response.capacity_ = response.capacity_ * (unsigned long int)2;
          void *return_value_realloc_10;
          return_value_realloc_10=realloc((void *)response.buffer_, response.capacity_);
          response.buffer_ = (char *)return_value_realloc_10;
          /* assertion (response).buffer_ != ((void *)0) */
          assert(response.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      if(proxytrack_process_DAV_Request__1__2__8__size_mc_ >= 1ul)
      {
        memcpy((void *)(response.buffer_ + (signed long int)response.length_), (const void *)proxytrack_process_DAV_Request__1__2__8__str_mc_, proxytrack_process_DAV_Request__1__2__8__size_mc_);
        response.length_ = response.length_ + proxytrack_process_DAV_Request__1__2__8__size_mc_;
      }

      response.buffer_[(signed long int)response.length_] = (char)0;
    }
    while((_Bool)0);
    if(depth >= 1)
    {
      signed long int timestampRep = (signed long int)-1;
      const char *prefix = (const char *)url.buffer_;
      unsigned int prefixLen;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(prefix);
      prefixLen = (unsigned int)return_value_strlen_11;
      char **list;
      list=PT_Enumerate(indexes, prefix, 0);
      if(!(list == ((char **)NULL)))
      {
        isDir = 1;
        for( ; isDir >= 0; isDir = isDir - 1)
        {
          i = 0;
          for( ; !(list[(signed long int)i] == ((char *)NULL)); i = i + 1)
          {
            const char *thisUrl = list[(signed long int)i];
            const char *mimeType = "application/octet-stream";
            unsigned int thisUrlLen;
            unsigned long int return_value_strlen_12;
            return_value_strlen_12=strlen(thisUrl);
            thisUrlLen = (unsigned int)return_value_strlen_12;
            signed int thisIsDir = (signed int)thisUrl[(signed long int)(thisUrlLen - (unsigned int)1)] == 47 ? 1 : 0;
            do
            {
              const unsigned long int proxytrack_process_DAV_Request__1__2__9__1__1__1__1__1__1__capacity_ = (unsigned long int)(itemUrl.length_ + (unsigned long int)(thisUrlLen + prefixLen) + sizeof(char [9l]) /*9ul*/  + (unsigned long int)1 + (unsigned long int)1);
              while(!(itemUrl.capacity_ >= proxytrack_process_DAV_Request__1__2__9__1__1__1__1__1__1__capacity_))
              {
                if(!(itemUrl.capacity_ >= 16ul))
                  itemUrl.capacity_ = (unsigned long int)16;

                else
                  itemUrl.capacity_ = itemUrl.capacity_ * (unsigned long int)2;
                void *return_value_realloc_13;
                return_value_realloc_13=realloc((void *)itemUrl.buffer_, itemUrl.capacity_);
                itemUrl.buffer_ = (char *)return_value_realloc_13;
                /* assertion (itemUrl).buffer_ != ((void *)0) */
                assert(itemUrl.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            do
            {
              itemUrl.length_ = (unsigned long int)0;
              do
              {
                const unsigned long int proxytrack_process_DAV_Request__1__2__9__1__1__1__1__1__2__1__capacity_ = (unsigned long int)(itemUrl.length_ + (unsigned long int)0 + (unsigned long int)1);
                while(!(itemUrl.capacity_ >= proxytrack_process_DAV_Request__1__2__9__1__1__1__1__1__2__1__capacity_))
                {
                  if(!(itemUrl.capacity_ >= 16ul))
                    itemUrl.capacity_ = (unsigned long int)16;

                  else
                    itemUrl.capacity_ = itemUrl.capacity_ * (unsigned long int)2;
                  void *return_value_realloc_14;
                  return_value_realloc_14=realloc((void *)itemUrl.buffer_, itemUrl.capacity_);
                  itemUrl.buffer_ = (char *)return_value_realloc_14;
                  /* assertion (itemUrl).buffer_ != ((void *)0) */
                  assert(itemUrl.buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              itemUrl.buffer_[(signed long int)0] = (char)0;
            }
            while((_Bool)0);
            sprintf(itemUrl.buffer_, "/%s/%s", prefix, thisUrl);
            if(thisIsDir == 0)
            {
              return_value_strlen_15=strlen((const char *)itemUrl.buffer_);
              itemUrl.length_ = (unsigned long int)(signed int)return_value_strlen_15;
            }

            else
            {
              return_value_strlen_16=strlen((const char *)itemUrl.buffer_);
              itemUrl.length_ = (unsigned long int)((signed int)return_value_strlen_16 - 1);
            }
            itemUrl.buffer_[(signed long int)itemUrl.length_] = (char)0;
            if(thisIsDir == isDir)
            {
              unsigned long int size = (unsigned long int)0;
              signed long int timestamp = (signed long int)0;
              struct _PT_Element *file = (struct _PT_Element *)(void *)0;
              if(isDir == 0)
              {
                file=PT_ReadIndex(indexes, (const char *)itemUrl.buffer_ + (signed long int)1, 0);
                if(!(file == ((struct _PT_Element *)NULL)))
                {
                  if(file->statuscode == 200)
                  {
                    size = file->size;
                    timestamp=get_time_rfc822(file->lastmodified);
                    if(timestamp == 0l)
                    {
                      if(timestampRep == -1l)
                      {
                        timestampRep = (signed long int)0;
                        if(!(file->indexId == -1))
                        {
                          struct _PT_Index *return_value_PT_GetIndex_17;
                          return_value_PT_GetIndex_17=PT_GetIndex(indexes, file->indexId);
                          timestampRep=PT_Index_Timestamp(return_value_PT_GetIndex_17);
                        }

                      }

                      timestamp = timestampRep;
                    }

                    mimeType = file->contenttype;
                  }

                }

              }

              item.length_ = (unsigned long int)0;
              proxytrack_add_DAV_Item(&item, &buff, (const char *)itemUrl.buffer_, size, timestamp, mimeType, isDir, 0, (signed int)(thisUrlLen == (unsigned int)0));
              do
              {
                const char *str_mc_ = (const char *)item.buffer_;
                const unsigned long int size_mc_ = (unsigned long int)item.length_;
                do
                {
                  const unsigned long int proxytrack_process_DAV_Request__1__2__9__1__1__1__1__1__3__2__1__capacity_ = (unsigned long int)(response.length_ + size_mc_ + (unsigned long int)1);
                  while(!(response.capacity_ >= proxytrack_process_DAV_Request__1__2__9__1__1__1__1__1__3__2__1__capacity_))
                  {
                    if(!(response.capacity_ >= 16ul))
                      response.capacity_ = (unsigned long int)16;

                    else
                      response.capacity_ = response.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_18;
                    return_value_realloc_18=realloc((void *)response.buffer_, response.capacity_);
                    response.buffer_ = (char *)return_value_realloc_18;
                    /* assertion (response).buffer_ != ((void *)0) */
                    assert(response.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(size_mc_ >= 1ul)
                {
                  memcpy((void *)(response.buffer_ + (signed long int)response.length_), (const void *)str_mc_, size_mc_);
                  response.length_ = response.length_ + size_mc_;
                }

                response.buffer_[(signed long int)response.length_] = (char)0;
              }
              while((_Bool)0);
              if(!(file == ((struct _PT_Element *)NULL)))
                PT_Element_Delete(&file);

            }

          }
        }
        PT_Enumerate_Delete(&list);
      }

    }

    do
    {
      const char * const proxytrack_process_DAV_Request__1__2__10__str__ = "</multistatus>\r\n";
      if(!(proxytrack_process_DAV_Request__1__2__10__str__ == ((const char *)NULL)))
      {
        unsigned long int proxytrack_process_DAV_Request__1__2__10__1__size__;
        proxytrack_process_DAV_Request__1__2__10__1__size__=strlen(proxytrack_process_DAV_Request__1__2__10__str__);
        do
        {
          const char *proxytrack_process_DAV_Request__1__2__10__1__1__str_mc_ = proxytrack_process_DAV_Request__1__2__10__str__;
          const unsigned long int proxytrack_process_DAV_Request__1__2__10__1__1__size_mc_ = (unsigned long int)proxytrack_process_DAV_Request__1__2__10__1__size__;
          do
          {
            const unsigned long int proxytrack_process_DAV_Request__1__2__10__1__1__1__capacity_ = (unsigned long int)(response.length_ + proxytrack_process_DAV_Request__1__2__10__1__1__size_mc_ + (unsigned long int)1);
            while(!(response.capacity_ >= proxytrack_process_DAV_Request__1__2__10__1__1__1__capacity_))
            {
              if(!(response.capacity_ >= 16ul))
                response.capacity_ = (unsigned long int)16;

              else
                response.capacity_ = response.capacity_ * (unsigned long int)2;
              void *return_value_realloc_19;
              return_value_realloc_19=realloc((void *)response.buffer_, response.capacity_);
              response.buffer_ = (char *)return_value_realloc_19;
              /* assertion (response).buffer_ != ((void *)0) */
              assert(response.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(proxytrack_process_DAV_Request__1__2__10__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(response.buffer_ + (signed long int)response.length_), (const void *)proxytrack_process_DAV_Request__1__2__10__1__1__str_mc_, proxytrack_process_DAV_Request__1__2__10__1__1__size_mc_);
            response.length_ = response.length_ + proxytrack_process_DAV_Request__1__2__10__1__1__size_mc_;
          }

          response.buffer_[(signed long int)response.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    do
    {
      if(!(item.buffer_ == ((char *)NULL)))
      {
        free((void *)item.buffer_);
        item.buffer_ = (char *)(void *)0;
      }

      item.capacity_ = (unsigned long int)0;
      item.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(itemUrl.buffer_ == ((char *)NULL)))
      {
        free((void *)itemUrl.buffer_);
        itemUrl.buffer_ = (char *)(void *)0;
      }

      itemUrl.capacity_ = (unsigned long int)0;
      itemUrl.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(url.buffer_ == ((char *)NULL)))
      {
        free((void *)url.buffer_);
        url.buffer_ = (char *)(void *)0;
      }

      url.capacity_ = (unsigned long int)0;
      url.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(buff.buffer_ == ((char *)NULL)))
      {
        free((void *)buff.buffer_);
        buff.buffer_ = (char *)(void *)0;
      }

      buff.capacity_ = (unsigned long int)0;
      buff.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    proxytrack_process_DAV_Request__1__2__elt->size = response.length_;
    proxytrack_process_DAV_Request__1__2__elt->adr=StringAcquire(&response);
    proxytrack_process_DAV_Request__1__2__elt->statuscode = 207;
    strcpy(proxytrack_process_DAV_Request__1__2__elt->charset, "utf-8");
    strcpy(proxytrack_process_DAV_Request__1__2__elt->contenttype, "text/xml");
    strcpy(proxytrack_process_DAV_Request__1__2__elt->msg, "Multi-Status");
    do
    {
      if(!(response.buffer_ == ((char *)NULL)))
      {
        free((void *)response.buffer_);
        response.buffer_ = (char *)(void *)0;
      }

      response.capacity_ = (unsigned long int)0;
      response.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    fprintf(stderr, "RESPONSE:\n%s\n", proxytrack_process_DAV_Request__1__2__elt->adr);
    return proxytrack_process_DAV_Request__1__2__elt;
    return (struct _PT_Element *)(void *)0;
  }
}

// proxytrack_process_HTTP
// file proxy/proxytrack.c line 893
static void proxytrack_process_HTTP(struct _PT_Indexes *indexes, signed int soc_c)
{
  signed int timeout = 30;
  signed int buffer_size = 32768;
  char *buffer;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)buffer_size);
  buffer = (char *)return_value_malloc_1;
  signed int line1Size = 1024;
  char *line1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)line1Size);
  line1 = (char *)return_value_malloc_2;
  signed int lineSize = 8192;
  char *line;
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)lineSize);
  line = (char *)return_value_malloc_3;
  signed int length = 0;
  signed int keepAlive = 1;
  struct String url = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String urlRedirect = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String headers = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String output = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String host = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String localhost = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String davHeaders = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  struct String davRequest = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
  do
  {
    const unsigned long int proxytrack_process_HTTP__1__1__capacity_ = (unsigned long int)(localhost.length_ + (unsigned long int)256 + (unsigned long int)1);
    while(!(localhost.capacity_ >= proxytrack_process_HTTP__1__1__capacity_))
    {
      if(!(localhost.capacity_ >= 16ul))
        localhost.capacity_ = (unsigned long int)16;

      else
        localhost.capacity_ = localhost.capacity_ * (unsigned long int)2;
      void *return_value_realloc_4;
      return_value_realloc_4=realloc((void *)localhost.buffer_, localhost.capacity_);
      localhost.buffer_ = (char *)return_value_realloc_4;
      /* assertion (localhost).buffer_ != ((void *)0) */
      assert(localhost.buffer_ != (char *)(void *)0);
    }
  }
  while((_Bool)0);
  signed int return_value_gethostname_8;
  return_value_gethostname_8=gethostname(localhost.buffer_, (unsigned long int)((signed int)localhost.capacity_ - 1));
  if(return_value_gethostname_8 == 0)
  {
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen((const char *)localhost.buffer_);
    localhost.length_ = (unsigned long int)(signed int)return_value_strlen_5;
  }

  else
    do
    {
      const char *proxytrack_process_HTTP__1__3__1__str__ = "localhost";
      if(!(proxytrack_process_HTTP__1__3__1__str__ == ((const char *)NULL)))
      {
        unsigned long int proxytrack_process_HTTP__1__3__1__1__size__;
        proxytrack_process_HTTP__1__3__1__1__size__=strlen(proxytrack_process_HTTP__1__3__1__str__);
        do
        {
          localhost.length_ = (unsigned long int)0;
          do
          {
            const char *proxytrack_process_HTTP__1__3__1__1__1__1__str_mc_ = proxytrack_process_HTTP__1__3__1__str__;
            const unsigned long int proxytrack_process_HTTP__1__3__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__3__1__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__3__1__1__1__1__1__capacity_ = (unsigned long int)(localhost.length_ + proxytrack_process_HTTP__1__3__1__1__1__1__size_mc_ + (unsigned long int)1);
              while(!(localhost.capacity_ >= proxytrack_process_HTTP__1__3__1__1__1__1__1__capacity_))
              {
                if(!(localhost.capacity_ >= 16ul))
                  localhost.capacity_ = (unsigned long int)16;

                else
                  localhost.capacity_ = localhost.capacity_ * (unsigned long int)2;
                void *return_value_realloc_6;
                return_value_realloc_6=realloc((void *)localhost.buffer_, localhost.capacity_);
                localhost.buffer_ = (char *)return_value_realloc_6;
                /* assertion (localhost).buffer_ != ((void *)0) */
                assert(localhost.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__3__1__1__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(localhost.buffer_ + (signed long int)localhost.length_), (const void *)proxytrack_process_HTTP__1__3__1__1__1__1__str_mc_, proxytrack_process_HTTP__1__3__1__1__1__1__size_mc_);
              localhost.length_ = localhost.length_ + proxytrack_process_HTTP__1__3__1__1__1__1__size_mc_;
            }

            localhost.buffer_[(signed long int)localhost.length_] = (char)0;
          }
          while((_Bool)0);
        }
        while((_Bool)0);
      }

      else
        do
        {
          localhost.length_ = (unsigned long int)0;
          do
          {
            const unsigned long int proxytrack_process_HTTP__1__3__1__2__1__1__capacity_ = (unsigned long int)(localhost.length_ + (unsigned long int)0 + (unsigned long int)1);
            while(!(localhost.capacity_ >= proxytrack_process_HTTP__1__3__1__2__1__1__capacity_))
            {
              if(!(localhost.capacity_ >= 16ul))
                localhost.capacity_ = (unsigned long int)16;

              else
                localhost.capacity_ = localhost.capacity_ * (unsigned long int)2;
              void *return_value_realloc_7;
              return_value_realloc_7=realloc((void *)localhost.buffer_, localhost.capacity_);
              localhost.buffer_ = (char *)return_value_realloc_7;
              /* assertion (localhost).buffer_ != ((void *)0) */
              assert(localhost.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          localhost.buffer_[(signed long int)0] = (char)0;
        }
        while((_Bool)0);
    }
    while((_Bool)0);
  _Bool tmp_if_expr_96;
  _Bool tmp_if_expr_97;
  _Bool tmp_if_expr_98;
  _Bool tmp_if_expr_99;
  _Bool tmp_if_expr_100;
  _Bool tmp_if_expr_101;
  signed int return_value_linputsoc_t_16;
  signed int return_value_strcasecmp_22;
  signed int return_value_strcasecmp_21;
  signed int return_value_strcasecmp_46;
  signed int return_value_strcasecmp_45;
  signed int return_value_strcasecmp_44;
  signed int return_value_strcasecmp_43;
  signed int return_value_strcasecmp_28;
  _Bool tmp_if_expr_30;
  signed int return_value_strcasecmp_29;
  _Bool tmp_if_expr_32;
  signed int return_value_strcasecmp_31;
  _Bool tmp_if_expr_34;
  signed int return_value_strcasecmp_33;
  _Bool tmp_if_expr_36;
  signed int return_value_strcasecmp_35;
  _Bool tmp_if_expr_38;
  signed int return_value_strcasecmp_37;
  _Bool tmp_if_expr_40;
  signed int return_value_strcasecmp_39;
  _Bool tmp_if_expr_42;
  signed int return_value_strcasecmp_41;
  signed int return_value_strcasecmp_48;
  _Bool tmp_if_expr_70;
  signed int return_value_strncasecmp_69;
  _Bool tmp_if_expr_72;
  _Bool tmp_if_expr_71;
  _Bool tmp_if_expr_73;
  signed int return_value_strncasecmp_68;
  _Bool tmp_if_expr_78;
  _Bool tmp_if_expr_79;
  char *tmp_if_expr_80;
  _Bool tmp_if_expr_81;
  char *tmp_if_expr_82;
  char *tmp_if_expr_83;
  char *return_value_strchr_94;
  unsigned long int tmp_if_expr_116;
  unsigned long int tmp_if_expr_115;
  _Bool tmp_if_expr_125;
  _Bool tmp_if_expr_124;
  signed long int return_value_send_123;
  _Bool tmp_if_expr_129;
  _Bool tmp_if_expr_126;
  _Bool tmp_if_expr_128;
  signed long int return_value_send_127;
  signed long int return_value_recv_130;
  if(buffer == ((char *)NULL) || line == ((char *)NULL) || line1 == ((char *)NULL))
  {
    proxytrack_print_log("critical", "proxytrack_process_HTTP:memory exhausted");
    close(soc_c);
  }

  else
  {
    do
    {
      const char *msgError = (const char *)(void *)0;
      signed int msgCode = 0;
      struct _PT_Element *element = (struct _PT_Element *)(void *)0;
      char *command;
      char *proto;
      char *surl;
      signed int headRequest = 0;
      signed int listRequest = 0;
      signed int davDepth = 0;
      line1[(signed long int)0] = (char)0;
      line[(signed long int)0] = line1[(signed long int)0];
      buffer[(signed long int)0] = (char)0;
      command = line1;
      do
      {
        url.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__1__1__capacity_ = (unsigned long int)(url.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__1__1__capacity_))
          {
            if(!(url.capacity_ >= 16ul))
              url.capacity_ = (unsigned long int)16;

            else
              url.capacity_ = url.capacity_ * (unsigned long int)2;
            void *return_value_realloc_9;
            return_value_realloc_9=realloc((void *)url.buffer_, url.capacity_);
            url.buffer_ = (char *)return_value_realloc_9;
            /* assertion (url).buffer_ != ((void *)0) */
            assert(url.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        url.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        urlRedirect.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__2__1__capacity_ = (unsigned long int)(urlRedirect.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(urlRedirect.capacity_ >= proxytrack_process_HTTP__1__5__2__1__capacity_))
          {
            if(!(urlRedirect.capacity_ >= 16ul))
              urlRedirect.capacity_ = (unsigned long int)16;

            else
              urlRedirect.capacity_ = urlRedirect.capacity_ * (unsigned long int)2;
            void *return_value_realloc_10;
            return_value_realloc_10=realloc((void *)urlRedirect.buffer_, urlRedirect.capacity_);
            urlRedirect.buffer_ = (char *)return_value_realloc_10;
            /* assertion (urlRedirect).buffer_ != ((void *)0) */
            assert(urlRedirect.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        urlRedirect.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        headers.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__3__1__capacity_ = (unsigned long int)(headers.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__3__1__capacity_))
          {
            if(!(headers.capacity_ >= 16ul))
              headers.capacity_ = (unsigned long int)16;

            else
              headers.capacity_ = headers.capacity_ * (unsigned long int)2;
            void *return_value_realloc_11;
            return_value_realloc_11=realloc((void *)headers.buffer_, headers.capacity_);
            headers.buffer_ = (char *)return_value_realloc_11;
            /* assertion (headers).buffer_ != ((void *)0) */
            assert(headers.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        headers.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        output.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__4__1__capacity_ = (unsigned long int)(output.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(output.capacity_ >= proxytrack_process_HTTP__1__5__4__1__capacity_))
          {
            if(!(output.capacity_ >= 16ul))
              output.capacity_ = (unsigned long int)16;

            else
              output.capacity_ = output.capacity_ * (unsigned long int)2;
            void *return_value_realloc_12;
            return_value_realloc_12=realloc((void *)output.buffer_, output.capacity_);
            output.buffer_ = (char *)return_value_realloc_12;
            /* assertion (output).buffer_ != ((void *)0) */
            assert(output.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        output.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        host.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__5__1__capacity_ = (unsigned long int)(host.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(host.capacity_ >= proxytrack_process_HTTP__1__5__5__1__capacity_))
          {
            if(!(host.capacity_ >= 16ul))
              host.capacity_ = (unsigned long int)16;

            else
              host.capacity_ = host.capacity_ * (unsigned long int)2;
            void *return_value_realloc_13;
            return_value_realloc_13=realloc((void *)host.buffer_, host.capacity_);
            host.buffer_ = (char *)return_value_realloc_13;
            /* assertion (host).buffer_ != ((void *)0) */
            assert(host.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        host.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        davHeaders.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__6__1__capacity_ = (unsigned long int)(davHeaders.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(davHeaders.capacity_ >= proxytrack_process_HTTP__1__5__6__1__capacity_))
          {
            if(!(davHeaders.capacity_ >= 16ul))
              davHeaders.capacity_ = (unsigned long int)16;

            else
              davHeaders.capacity_ = davHeaders.capacity_ * (unsigned long int)2;
            void *return_value_realloc_14;
            return_value_realloc_14=realloc((void *)davHeaders.buffer_, davHeaders.capacity_);
            davHeaders.buffer_ = (char *)return_value_realloc_14;
            /* assertion (davHeaders).buffer_ != ((void *)0) */
            assert(davHeaders.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        davHeaders.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      do
      {
        davRequest.length_ = (unsigned long int)0;
        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__7__1__capacity_ = (unsigned long int)(davRequest.length_ + (unsigned long int)0 + (unsigned long int)1);
          while(!(davRequest.capacity_ >= proxytrack_process_HTTP__1__5__7__1__capacity_))
          {
            if(!(davRequest.capacity_ >= 16ul))
              davRequest.capacity_ = (unsigned long int)16;

            else
              davRequest.capacity_ = davRequest.capacity_ * (unsigned long int)2;
            void *return_value_realloc_15;
            return_value_realloc_15=realloc((void *)davRequest.buffer_, davRequest.capacity_);
            davRequest.buffer_ = (char *)return_value_realloc_15;
            /* assertion (davRequest).buffer_ != ((void *)0) */
            assert(davRequest.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        davRequest.buffer_[(signed long int)0] = (char)0;
      }
      while((_Bool)0);
      signed int return_value_linputsoc_t_95;
      return_value_linputsoc_t_95=linputsoc_t(soc_c, line1, line1Size - 2, timeout);
      if(return_value_linputsoc_t_95 >= 1)
      {
        surl=strchr(line1, 32);
        tmp_if_expr_96 = surl != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_96 = (_Bool)0;
      if(tmp_if_expr_96)
      {
        *surl = (char)0;
        tmp_if_expr_97 = !(*surl != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_97 = (_Bool)0;
      if(tmp_if_expr_97)
      {
        surl = surl + 1l;
        tmp_if_expr_98 = surl != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_98 = (_Bool)0;
      if(tmp_if_expr_98)
      {
        proto=strchr(surl, 32);
        tmp_if_expr_99 = proto != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_99 = (_Bool)0;
      if(tmp_if_expr_99)
      {
        *proto = (char)0;
        tmp_if_expr_100 = !(*proto != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_100 = (_Bool)0;
      if(tmp_if_expr_100)
      {
        proto = proto + 1l;
        tmp_if_expr_101 = proto != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_101 = (_Bool)0;
      if(tmp_if_expr_101)
      {
        do
        {
          return_value_linputsoc_t_16=linputsoc_t(soc_c, line, lineSize - 2, timeout);
          if(!(return_value_linputsoc_t_16 >= 1))
            break;

          if((signed int)*line == 0)
            break;

          signed int p;
          p=strfield(line, "Content-length:");
          if(!(p == 0))
          {
            signed int return_value_sscanf_17;
            return_value_sscanf_17=sscanf(line + (signed long int)p, "%d", &length);
            if(!(return_value_sscanf_17 == 1))
            {
              msgCode = 500;
              msgError = "Bad HTTP Content-Length Field";
              keepAlive = 0;
              length = 0;
            }

          }

          else
          {
            return_value_strcasecmp_22=strcasecmp(line, "Connection: close");
            if(return_value_strcasecmp_22 == 0)
              keepAlive = 0;

            else
            {
              return_value_strcasecmp_21=strcasecmp(line, "Connection: keep-alive");
              if(return_value_strcasecmp_21 == 0)
                keepAlive = 1;

              else
              {
                p=strfield(line, "Host:");
                if(!(p == 0))
                {
                  char *chost = line + (signed long int)p;
                  if((signed int)*chost == 32)
                    chost = chost + 1l;

                  do
                  {
                    const char *proxytrack_process_HTTP__1__5__8__1__4__1__str__ = chost;
                    if(!(proxytrack_process_HTTP__1__5__8__1__4__1__str__ == ((const char *)NULL)))
                    {
                      unsigned long int proxytrack_process_HTTP__1__5__8__1__4__1__1__size__;
                      proxytrack_process_HTTP__1__5__8__1__4__1__1__size__=strlen(proxytrack_process_HTTP__1__5__8__1__4__1__str__);
                      do
                      {
                        host.length_ = (unsigned long int)0;
                        do
                        {
                          const char *proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__1__4__1__str__;
                          const unsigned long int proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__1__4__1__1__size__;
                          do
                          {
                            const unsigned long int proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__1__capacity_ = (unsigned long int)(host.length_ + proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__size_mc_ + (unsigned long int)1);
                            while(!(host.capacity_ >= proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__1__capacity_))
                            {
                              if(!(host.capacity_ >= 16ul))
                                host.capacity_ = (unsigned long int)16;

                              else
                                host.capacity_ = host.capacity_ * (unsigned long int)2;
                              void *return_value_realloc_18;
                              return_value_realloc_18=realloc((void *)host.buffer_, host.capacity_);
                              host.buffer_ = (char *)return_value_realloc_18;
                              /* assertion (host).buffer_ != ((void *)0) */
                              assert(host.buffer_ != (char *)(void *)0);
                            }
                          }
                          while((_Bool)0);
                          if(proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__size_mc_ >= 1ul)
                          {
                            memcpy((void *)(host.buffer_ + (signed long int)host.length_), (const void *)proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__size_mc_);
                            host.length_ = host.length_ + proxytrack_process_HTTP__1__5__8__1__4__1__1__1__1__size_mc_;
                          }

                          host.buffer_[(signed long int)host.length_] = (char)0;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)0);
                    }

                    else
                      do
                      {
                        host.length_ = (unsigned long int)0;
                        do
                        {
                          const unsigned long int proxytrack_process_HTTP__1__5__8__1__4__1__2__1__1__capacity_ = (unsigned long int)(host.length_ + (unsigned long int)0 + (unsigned long int)1);
                          while(!(host.capacity_ >= proxytrack_process_HTTP__1__5__8__1__4__1__2__1__1__capacity_))
                          {
                            if(!(host.capacity_ >= 16ul))
                              host.capacity_ = (unsigned long int)16;

                            else
                              host.capacity_ = host.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_19;
                            return_value_realloc_19=realloc((void *)host.buffer_, host.capacity_);
                            host.buffer_ = (char *)return_value_realloc_19;
                            /* assertion (host).buffer_ != ((void *)0) */
                            assert(host.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        host.buffer_[(signed long int)0] = (char)0;
                      }
                      while((_Bool)0);
                  }
                  while((_Bool)0);
                }

                else
                {
                  p=strfield(line, "Depth: ");
                  if(!(p == 0))
                  {
                    char *depth = line + (signed long int)p;
                    signed int return_value_sscanf_20;
                    return_value_sscanf_20=sscanf(depth, "%d", &davDepth);
                    if(!(return_value_sscanf_20 == 1))
                      davDepth = 0;

                  }

                }
              }
            }
          }
        }
        while((_Bool)1);
        if(length >= 1)
        {
          if(!(length >= 32768))
          {
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__8__2__1__1__capacity_ = (unsigned long int)(davRequest.length_ + (unsigned long int)(length + 1) + (unsigned long int)1);
              while(!(davRequest.capacity_ >= proxytrack_process_HTTP__1__5__8__2__1__1__capacity_))
              {
                if(!(davRequest.capacity_ >= 16ul))
                  davRequest.capacity_ = (unsigned long int)16;

                else
                  davRequest.capacity_ = davRequest.capacity_ * (unsigned long int)2;
                void *return_value_realloc_23;
                return_value_realloc_23=realloc((void *)davRequest.buffer_, davRequest.capacity_);
                davRequest.buffer_ = (char *)return_value_realloc_23;
                /* assertion (davRequest).buffer_ != ((void *)0) */
                assert(davRequest.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            signed long int return_value_recv_24;
            return_value_recv_24=recv(soc_c, (void *)davRequest.buffer_, (unsigned long int)length, 0);
            if(return_value_recv_24 == (signed long int)length)
              davRequest.buffer_[(signed long int)length] = (char)0;

            else
            {
              msgCode = 500;
              msgError = "Posted Data Read Error";
              keepAlive = 0;
            }
          }

          else
          {
            msgCode = 500;
            msgError = "Posted Data Too Large";
            keepAlive = 0;
          }
        }

        signed int return_value_strcasecmp_47;
        return_value_strcasecmp_47=strcasecmp(command, "post");
        if(return_value_strcasecmp_47 == 0)
        {
          msgCode = 404;
          msgError = "Proxy Error (POST Request Forbidden)";
        }

        else
        {
          return_value_strcasecmp_46=strcasecmp(command, "get");
          if(return_value_strcasecmp_46 == 0)
            headRequest = 0;

          else
          {
            return_value_strcasecmp_45=strcasecmp(command, "head");
            if(return_value_strcasecmp_45 == 0)
              headRequest = 1;

            else
            {
              return_value_strcasecmp_44=strcasecmp(command, "options");
              if(return_value_strcasecmp_44 == 0)
              {
                const char *options = "GET, HEAD, OPTIONS, POST, PROPFIND, TRACE, MKCOL, DELETE, PUT";
                msgCode = 200;
                do
                {
                  const unsigned long int proxytrack_process_HTTP__1__5__8__6__1__capacity_ = (unsigned long int)(headers.length_ + (unsigned long int)8192 + (unsigned long int)1);
                  while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__8__6__1__capacity_))
                  {
                    if(!(headers.capacity_ >= 16ul))
                      headers.capacity_ = (unsigned long int)16;

                    else
                      headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_25;
                    return_value_realloc_25=realloc((void *)headers.buffer_, headers.capacity_);
                    headers.buffer_ = (char *)return_value_realloc_25;
                    /* assertion (headers).buffer_ != ((void *)0) */
                    assert(headers.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                const char *return_value_GetHttpMessage_26;
                return_value_GetHttpMessage_26=GetHttpMessage(msgCode);
                sprintf(headers.buffer_, "HTTP/1.1 %d %s\r\nDAV: 1, 2\r\nMS-Author-Via: DAV\r\nCache-Control: private\r\nAllow: %s\r\n", msgCode, return_value_GetHttpMessage_26, options);
                unsigned long int return_value_strlen_27;
                return_value_strlen_27=strlen((const char *)headers.buffer_);
                headers.length_ = (unsigned long int)(signed int)return_value_strlen_27;
              }

              else
              {
                return_value_strcasecmp_43=strcasecmp(command, "propfind");
                if(return_value_strcasecmp_43 == 0)
                {
                  if(davDepth >= 2)
                  {
                    msgCode = 403;
                    msgError = "DAV Depth Limit Forbidden";
                  }

                  else
                  {
                    fprintf(stderr, "DEBUG: DAV-DATA=<%s>\n", (const char *)davRequest.buffer_);
                    listRequest = 2;
                  }
                }

                else
                {
                  return_value_strcasecmp_28=strcasecmp(command, "mkcol");
                  if(return_value_strcasecmp_28 == 0)
                    tmp_if_expr_30 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_29=strcasecmp(command, "delete");
                    tmp_if_expr_30 = return_value_strcasecmp_29 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_30)
                    tmp_if_expr_32 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_31=strcasecmp(command, "put");
                    tmp_if_expr_32 = return_value_strcasecmp_31 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_32)
                    tmp_if_expr_34 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_33=strcasecmp(command, "proppatch");
                    tmp_if_expr_34 = return_value_strcasecmp_33 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_34)
                    tmp_if_expr_36 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_35=strcasecmp(command, "lock");
                    tmp_if_expr_36 = return_value_strcasecmp_35 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_36)
                    tmp_if_expr_38 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_37=strcasecmp(command, "unlock");
                    tmp_if_expr_38 = return_value_strcasecmp_37 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_38)
                    tmp_if_expr_40 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_39=strcasecmp(command, "copy");
                    tmp_if_expr_40 = return_value_strcasecmp_39 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_40)
                    tmp_if_expr_42 = (_Bool)1;

                  else
                  {
                    return_value_strcasecmp_41=strcasecmp(command, "trace");
                    tmp_if_expr_42 = return_value_strcasecmp_41 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_42)
                  {
                    msgCode = 403;
                    msgError = "Method Forbidden";
                  }

                  else
                  {
                    msgCode = 501;
                    msgError = "Proxy Error (Unsupported or Unknown HTTP Command Request)";
                    keepAlive = 0;
                  }
                }
              }
            }
          }
        }
        signed int return_value_strcasecmp_49;
        return_value_strcasecmp_49=strcasecmp(proto, "http/1.1");
        if(return_value_strcasecmp_49 == 0)
          keepAlive = 1;

        else
        {
          return_value_strcasecmp_48=strcasecmp(proto, "http/1.0");
          if(return_value_strcasecmp_48 == 0)
            keepAlive = 0;

          else
          {
            msgCode = 505;
            msgError = "Proxy Error (Unknown HTTP Version)";
            keepAlive = 0;
          }
        }
        signed int return_value_link_has_authority_74;
        return_value_link_has_authority_74=link_has_authority(surl);
        if(!(return_value_link_has_authority_74 == 0))
        {
          signed int return_value_strncasecmp_50;
          return_value_strncasecmp_50=strncasecmp(surl, "http://proxytrack/", sizeof(char [19l]) /*19ul*/  - (unsigned long int)1);
          do
          {
            const char *proxytrack_process_HTTP__1__5__8__13__2__str__ = surl;
            if(!(proxytrack_process_HTTP__1__5__8__13__2__str__ == ((const char *)NULL)))
            {
              unsigned long int proxytrack_process_HTTP__1__5__8__13__2__1__size__;
              proxytrack_process_HTTP__1__5__8__13__2__1__size__=strlen(proxytrack_process_HTTP__1__5__8__13__2__str__);
              do
              {
                url.length_ = (unsigned long int)0;
                do
                {
                  const char *proxytrack_process_HTTP__1__5__8__13__2__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__13__2__str__;
                  const unsigned long int proxytrack_process_HTTP__1__5__8__13__2__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__13__2__1__size__;
                  do
                  {
                    const unsigned long int proxytrack_process_HTTP__1__5__8__13__2__1__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__13__2__1__1__1__size_mc_ + (unsigned long int)1);
                    while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__13__2__1__1__1__1__capacity_))
                    {
                      if(!(url.capacity_ >= 16ul))
                        url.capacity_ = (unsigned long int)16;

                      else
                        url.capacity_ = url.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_51;
                      return_value_realloc_51=realloc((void *)url.buffer_, url.capacity_);
                      url.buffer_ = (char *)return_value_realloc_51;
                      /* assertion (url).buffer_ != ((void *)0) */
                      assert(url.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(proxytrack_process_HTTP__1__5__8__13__2__1__1__1__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__13__2__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__13__2__1__1__1__size_mc_);
                    url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__13__2__1__1__1__size_mc_;
                  }

                  url.buffer_[(signed long int)url.length_] = (char)0;
                }
                while((_Bool)0);
              }
              while((_Bool)0);
            }

            else
              do
              {
                url.length_ = (unsigned long int)0;
                do
                {
                  const unsigned long int proxytrack_process_HTTP__1__5__8__13__2__2__1__1__capacity_ = (unsigned long int)(url.length_ + (unsigned long int)0 + (unsigned long int)1);
                  while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__13__2__2__1__1__capacity_))
                  {
                    if(!(url.capacity_ >= 16ul))
                      url.capacity_ = (unsigned long int)16;

                    else
                      url.capacity_ = url.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_52;
                    return_value_realloc_52=realloc((void *)url.buffer_, url.capacity_);
                    url.buffer_ = (char *)return_value_realloc_52;
                    /* assertion (url).buffer_ != ((void *)0) */
                    assert(url.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                url.buffer_[(signed long int)0] = (char)0;
              }
              while((_Bool)0);
          }
          while((_Bool)0);
        }

        else
          if(host.length_ >= 1ul)
          {
            if(!(listRequest == 2))
            {
              return_value_strncasecmp_69=strncasecmp((const char *)host.buffer_, (const char *)localhost.buffer_, localhost.length_);
              tmp_if_expr_70 = return_value_strncasecmp_69 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_70 = (_Bool)0;
            if(tmp_if_expr_70)
            {
              if((signed int)host.buffer_[(signed long int)localhost.length_] == 0)
                tmp_if_expr_71 = (_Bool)1;

              else
                tmp_if_expr_71 = (signed int)((const char *)host.buffer_)[(signed long int)localhost.length_] == 58 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr_72 = tmp_if_expr_71 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_72 = (_Bool)0;
            if(tmp_if_expr_72)
              tmp_if_expr_73 = (signed int)surl[(signed long int)0] == 47 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_73 = (_Bool)0;
            if(tmp_if_expr_73)
            {
              const char *toHit = surl + (signed long int)1;
              signed int return_value_strncmp_53;
              return_value_strncmp_53=strncmp(toHit, "webdav/", (unsigned long int)7);
              if(return_value_strncmp_53 == 0)
                toHit = toHit + (signed long int)7;

              do
              {
                const char *proxytrack_process_HTTP__1__5__8__14__1__1__2__str__ = "";
                if(!(proxytrack_process_HTTP__1__5__8__14__1__1__2__str__ == ((const char *)NULL)))
                {
                  unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__2__1__size__;
                  proxytrack_process_HTTP__1__5__8__14__1__1__2__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__1__2__str__);
                  do
                  {
                    url.length_ = (unsigned long int)0;
                    do
                    {
                      const char *proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__1__2__str__;
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__1__2__1__size__;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__size_mc_ + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_54;
                          return_value_realloc_54=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_54;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      if(proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__size_mc_ >= 1ul)
                      {
                        memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__size_mc_);
                        url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__1__2__1__1__1__size_mc_;
                      }

                      url.buffer_[(signed long int)url.length_] = (char)0;
                    }
                    while((_Bool)0);
                  }
                  while((_Bool)0);
                }

                else
                  do
                  {
                    url.length_ = (unsigned long int)0;
                    do
                    {
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__2__2__1__1__capacity_ = (unsigned long int)(url.length_ + (unsigned long int)0 + (unsigned long int)1);
                      while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__1__2__2__1__1__capacity_))
                      {
                        if(!(url.capacity_ >= 16ul))
                          url.capacity_ = (unsigned long int)16;

                        else
                          url.capacity_ = url.capacity_ * (unsigned long int)2;
                        void *return_value_realloc_55;
                        return_value_realloc_55=realloc((void *)url.buffer_, url.capacity_);
                        url.buffer_ = (char *)return_value_realloc_55;
                        /* assertion (url).buffer_ != ((void *)0) */
                        assert(url.buffer_ != (char *)(void *)0);
                      }
                    }
                    while((_Bool)0);
                    url.buffer_[(signed long int)0] = (char)0;
                  }
                  while((_Bool)0);
              }
              while((_Bool)0);
              signed int return_value_link_has_authority_57;
              return_value_link_has_authority_57=link_has_authority(toHit);
              if(return_value_link_has_authority_57 == 0)
                do
                {
                  const char * const proxytrack_process_HTTP__1__5__8__14__1__1__3__str__ = "http://";
                  if(!(proxytrack_process_HTTP__1__5__8__14__1__1__3__str__ == ((const char *)NULL)))
                  {
                    unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__3__1__size__;
                    proxytrack_process_HTTP__1__5__8__14__1__1__3__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__1__3__str__);
                    do
                    {
                      const char *proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__1__3__str__;
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__1__3__1__size__;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__size_mc_ + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_56;
                          return_value_realloc_56=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_56;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      if(proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__size_mc_ >= 1ul)
                      {
                        memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__size_mc_);
                        url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__1__3__1__1__size_mc_;
                      }

                      url.buffer_[(signed long int)url.length_] = (char)0;
                    }
                    while((_Bool)0);
                  }

                }
                while((_Bool)0);

              do
              {
                const char * const proxytrack_process_HTTP__1__5__8__14__1__1__4__str__ = toHit;
                if(!(proxytrack_process_HTTP__1__5__8__14__1__1__4__str__ == ((const char *)NULL)))
                {
                  unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__4__1__size__;
                  proxytrack_process_HTTP__1__5__8__14__1__1__4__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__1__4__str__);
                  do
                  {
                    const char *proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__1__4__str__;
                    const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__1__4__1__size__;
                    do
                    {
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__size_mc_ + (unsigned long int)1);
                      while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__1__capacity_))
                      {
                        if(!(url.capacity_ >= 16ul))
                          url.capacity_ = (unsigned long int)16;

                        else
                          url.capacity_ = url.capacity_ * (unsigned long int)2;
                        void *return_value_realloc_58;
                        return_value_realloc_58=realloc((void *)url.buffer_, url.capacity_);
                        url.buffer_ = (char *)return_value_realloc_58;
                        /* assertion (url).buffer_ != ((void *)0) */
                        assert(url.buffer_ != (char *)(void *)0);
                      }
                    }
                    while((_Bool)0);
                    if(proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__size_mc_ >= 1ul)
                    {
                      memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__size_mc_);
                      url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__1__4__1__1__size_mc_;
                    }

                    url.buffer_[(signed long int)url.length_] = (char)0;
                  }
                  while((_Bool)0);
                }

              }
              while((_Bool)0);
            }

            else
            {
              return_value_strncasecmp_68=strncasecmp(surl, "/proxytrack/", sizeof(char [13l]) /*13ul*/  - (unsigned long int)1);
              if(return_value_strncasecmp_68 == 0)
              {
                const char *proxytrack_process_HTTP__1__5__8__14__1__2__toHit = (surl + (signed long int)sizeof(char [13l]) /*13ul*/ ) - (signed long int)1;
                do
                {
                  const char *proxytrack_process_HTTP__1__5__8__14__1__2__1__str__ = "";
                  if(!(proxytrack_process_HTTP__1__5__8__14__1__2__1__str__ == ((const char *)NULL)))
                  {
                    unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__1__1__size__;
                    proxytrack_process_HTTP__1__5__8__14__1__2__1__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__2__1__str__);
                    do
                    {
                      url.length_ = (unsigned long int)0;
                      do
                      {
                        const char *proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__2__1__str__;
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__2__1__1__size__;
                        do
                        {
                          const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__size_mc_ + (unsigned long int)1);
                          while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__1__capacity_))
                          {
                            if(!(url.capacity_ >= 16ul))
                              url.capacity_ = (unsigned long int)16;

                            else
                              url.capacity_ = url.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_59;
                            return_value_realloc_59=realloc((void *)url.buffer_, url.capacity_);
                            url.buffer_ = (char *)return_value_realloc_59;
                            /* assertion (url).buffer_ != ((void *)0) */
                            assert(url.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        if(proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__size_mc_ >= 1ul)
                        {
                          memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__size_mc_);
                          url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__2__1__1__1__1__size_mc_;
                        }

                        url.buffer_[(signed long int)url.length_] = (char)0;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                  }

                  else
                    do
                    {
                      url.length_ = (unsigned long int)0;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__1__2__1__1__capacity_ = (unsigned long int)(url.length_ + (unsigned long int)0 + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__2__1__2__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_60;
                          return_value_realloc_60=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_60;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      url.buffer_[(signed long int)0] = (char)0;
                    }
                    while((_Bool)0);
                }
                while((_Bool)0);
                signed int return_value_link_has_authority_62;
                return_value_link_has_authority_62=link_has_authority(proxytrack_process_HTTP__1__5__8__14__1__2__toHit);
                if(return_value_link_has_authority_62 == 0)
                  do
                  {
                    const char * const proxytrack_process_HTTP__1__5__8__14__1__2__2__str__ = "http://";
                    if(!(proxytrack_process_HTTP__1__5__8__14__1__2__2__str__ == ((const char *)NULL)))
                    {
                      unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__2__1__size__;
                      proxytrack_process_HTTP__1__5__8__14__1__2__2__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__2__2__str__);
                      do
                      {
                        const char *proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__2__2__str__;
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__2__2__1__size__;
                        do
                        {
                          const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__size_mc_ + (unsigned long int)1);
                          while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__1__capacity_))
                          {
                            if(!(url.capacity_ >= 16ul))
                              url.capacity_ = (unsigned long int)16;

                            else
                              url.capacity_ = url.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_61;
                            return_value_realloc_61=realloc((void *)url.buffer_, url.capacity_);
                            url.buffer_ = (char *)return_value_realloc_61;
                            /* assertion (url).buffer_ != ((void *)0) */
                            assert(url.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        if(proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__size_mc_ >= 1ul)
                        {
                          memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__size_mc_);
                          url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__2__2__1__1__size_mc_;
                        }

                        url.buffer_[(signed long int)url.length_] = (char)0;
                      }
                      while((_Bool)0);
                    }

                  }
                  while((_Bool)0);

                do
                {
                  const char * const proxytrack_process_HTTP__1__5__8__14__1__2__3__str__ = proxytrack_process_HTTP__1__5__8__14__1__2__toHit;
                  if(!(proxytrack_process_HTTP__1__5__8__14__1__2__3__str__ == ((const char *)NULL)))
                  {
                    unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__3__1__size__;
                    proxytrack_process_HTTP__1__5__8__14__1__2__3__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__2__3__str__);
                    do
                    {
                      const char *proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__2__3__str__;
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__2__3__1__size__;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__size_mc_ + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_63;
                          return_value_realloc_63=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_63;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      if(proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__size_mc_ >= 1ul)
                      {
                        memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__size_mc_);
                        url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__2__3__1__1__size_mc_;
                      }

                      url.buffer_[(signed long int)url.length_] = (char)0;
                    }
                    while((_Bool)0);
                  }

                }
                while((_Bool)0);
              }

              else
              {
                do
                {
                  const char *proxytrack_process_HTTP__1__5__8__14__1__3__1__str__ = "http://";
                  if(!(proxytrack_process_HTTP__1__5__8__14__1__3__1__str__ == ((const char *)NULL)))
                  {
                    unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__1__1__size__;
                    proxytrack_process_HTTP__1__5__8__14__1__3__1__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__3__1__str__);
                    do
                    {
                      url.length_ = (unsigned long int)0;
                      do
                      {
                        const char *proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__3__1__str__;
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__3__1__1__size__;
                        do
                        {
                          const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__size_mc_ + (unsigned long int)1);
                          while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__1__capacity_))
                          {
                            if(!(url.capacity_ >= 16ul))
                              url.capacity_ = (unsigned long int)16;

                            else
                              url.capacity_ = url.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_64;
                            return_value_realloc_64=realloc((void *)url.buffer_, url.capacity_);
                            url.buffer_ = (char *)return_value_realloc_64;
                            /* assertion (url).buffer_ != ((void *)0) */
                            assert(url.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        if(proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__size_mc_ >= 1ul)
                        {
                          memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__size_mc_);
                          url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__3__1__1__1__1__size_mc_;
                        }

                        url.buffer_[(signed long int)url.length_] = (char)0;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                  }

                  else
                    do
                    {
                      url.length_ = (unsigned long int)0;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__1__2__1__1__capacity_ = (unsigned long int)(url.length_ + (unsigned long int)0 + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__3__1__2__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_65;
                          return_value_realloc_65=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_65;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      url.buffer_[(signed long int)0] = (char)0;
                    }
                    while((_Bool)0);
                }
                while((_Bool)0);
                do
                {
                  const char * const proxytrack_process_HTTP__1__5__8__14__1__3__2__str__ = (const char *)host.buffer_;
                  if(!(proxytrack_process_HTTP__1__5__8__14__1__3__2__str__ == ((const char *)NULL)))
                  {
                    unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__2__1__size__;
                    proxytrack_process_HTTP__1__5__8__14__1__3__2__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__3__2__str__);
                    do
                    {
                      const char *proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__3__2__str__;
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__3__2__1__size__;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__size_mc_ + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_66;
                          return_value_realloc_66=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_66;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      if(proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__size_mc_ >= 1ul)
                      {
                        memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__size_mc_);
                        url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__3__2__1__1__size_mc_;
                      }

                      url.buffer_[(signed long int)url.length_] = (char)0;
                    }
                    while((_Bool)0);
                  }

                }
                while((_Bool)0);
                do
                {
                  const char * const proxytrack_process_HTTP__1__5__8__14__1__3__3__str__ = surl;
                  if(!(proxytrack_process_HTTP__1__5__8__14__1__3__3__str__ == ((const char *)NULL)))
                  {
                    unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__3__1__size__;
                    proxytrack_process_HTTP__1__5__8__14__1__3__3__1__size__=strlen(proxytrack_process_HTTP__1__5__8__14__1__3__3__str__);
                    do
                    {
                      const char *proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__14__1__3__3__str__;
                      const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__14__1__3__3__1__size__;
                      do
                      {
                        const unsigned long int proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__1__capacity_ = (unsigned long int)(url.length_ + proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__size_mc_ + (unsigned long int)1);
                        while(!(url.capacity_ >= proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__1__capacity_))
                        {
                          if(!(url.capacity_ >= 16ul))
                            url.capacity_ = (unsigned long int)16;

                          else
                            url.capacity_ = url.capacity_ * (unsigned long int)2;
                          void *return_value_realloc_67;
                          return_value_realloc_67=realloc((void *)url.buffer_, url.capacity_);
                          url.buffer_ = (char *)return_value_realloc_67;
                          /* assertion (url).buffer_ != ((void *)0) */
                          assert(url.buffer_ != (char *)(void *)0);
                        }
                      }
                      while((_Bool)0);
                      if(proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__size_mc_ >= 1ul)
                      {
                        memcpy((void *)(url.buffer_ + (signed long int)url.length_), (const void *)proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__size_mc_);
                        url.length_ = url.length_ + proxytrack_process_HTTP__1__5__8__14__1__3__3__1__1__size_mc_;
                      }

                      url.buffer_[(signed long int)url.length_] = (char)0;
                    }
                    while((_Bool)0);
                  }

                }
                while((_Bool)0);
              }
            }
          }

          else
          {
            msgCode = 500;
            msgError = "Transparent Proxy Error ('Host' HTTP Request Header Field Missing)";
            keepAlive = 0;
          }
        if(msgCode == 0)
        {
          if(listRequest == 1)
            element=proxytrack_process_HTTP_List(indexes, (const char *)url.buffer_);

          else
            if(listRequest == 2)
            {
              element=proxytrack_process_DAV_Request(indexes, (const char *)url.buffer_, davDepth);
              if(!(element == ((struct _PT_Element *)NULL)))
              {
                msgCode = element->statuscode;
                do
                {
                  const unsigned long int proxytrack_process_HTTP__1__5__8__15__2__1__1__capacity_ = (unsigned long int)(davHeaders.length_ + (unsigned long int)1024 + (unsigned long int)1);
                  while(!(davHeaders.capacity_ >= proxytrack_process_HTTP__1__5__8__15__2__1__1__capacity_))
                  {
                    if(!(davHeaders.capacity_ >= 16ul))
                      davHeaders.capacity_ = (unsigned long int)16;

                    else
                      davHeaders.capacity_ = davHeaders.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_75;
                    return_value_realloc_75=realloc((void *)davHeaders.buffer_, davHeaders.capacity_);
                    davHeaders.buffer_ = (char *)return_value_realloc_75;
                    /* assertion (davHeaders).buffer_ != ((void *)0) */
                    assert(davHeaders.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                sprintf(davHeaders.buffer_, "DAV: 1, 2\r\nMS-Author-Via: DAV\r\nCache-Control: private\r\n");
                unsigned long int return_value_strlen_76;
                return_value_strlen_76=strlen((const char *)davHeaders.buffer_);
                davHeaders.length_ = (unsigned long int)(signed int)return_value_strlen_76;
              }

            }

            else
              element=PT_ReadIndex(indexes, (const char *)url.buffer_, 1);
          if(element == ((struct _PT_Element *)NULL) && listRequest == 2 && url.length_ >= 1ul)
          {
            if((signed int)url.buffer_[-1l + (signed long int)url.length_] == 47)
            {
              element=PT_Index_HTML_BuildRootInfo(indexes);
              if(!(element == ((struct _PT_Element *)NULL)))
                element->statuscode = 404;

            }

          }

          if(!(element == ((struct _PT_Element *)NULL)))
          {
            msgCode = element->statuscode;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__8__15__5__1__capacity_ = (unsigned long int)(headers.length_ + (unsigned long int)8192 + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__8__15__5__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_77;
                return_value_realloc_77=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_77;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(!(element->location == ((char *)NULL)))
              tmp_if_expr_78 = element->location[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_78 = (_Bool)0;
            if(!(element->location == ((char *)NULL)))
              tmp_if_expr_79 = element->location[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_79 = (_Bool)0;
            if(tmp_if_expr_79)
              tmp_if_expr_80 = element->location;

            else
              tmp_if_expr_80 = "";
            if(!(element->location == ((char *)NULL)))
              tmp_if_expr_81 = element->location[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_81 = (_Bool)0;
            if(!(element->lastmodified[0l] == 0))
              tmp_if_expr_82 = element->lastmodified;

            else
              tmp_if_expr_82 = "";
            if(!(element->etag[0l] == 0))
              tmp_if_expr_83 = element->etag;

            else
              tmp_if_expr_83 = "";
            sprintf(headers.buffer_, "HTTP/1.1 %d %s\r\n%sContent-Type: %s%s%s%s\r\n%s%s%s%s%s%s%s%s%s", msgCode, (const void *)element->msg, (const char *)davHeaders.buffer_, (const void *)element->contenttype, element->charset[(signed long int)0] != 0 ? "; charset=\"" : "", (const void *)element->charset, element->charset[(signed long int)0] != 0 ? "\"" : "", tmp_if_expr_78 ? "Location: " : "", tmp_if_expr_80, tmp_if_expr_81 ? "\r\n" : "", element->lastmodified[(signed long int)0] != 0 ? "Last-Modified: " : "", tmp_if_expr_82, element->lastmodified[(signed long int)0] != 0 ? "\r\n" : "", element->etag[(signed long int)0] != 0 ? "ETag: " : "", tmp_if_expr_83, element->etag[(signed long int)0] != 0 ? "\r\n" : "");
            unsigned long int return_value_strlen_84;
            return_value_strlen_84=strlen((const char *)headers.buffer_);
            headers.length_ = (unsigned long int)(signed int)return_value_strlen_84;
          }

          else
          {
            if(url.length_ >= 1ul)
            {
              if(!((signed int)url.buffer_[-1l + (signed long int)url.length_] == 47))
              {
                return_value_strchr_94=strchr((const char *)url.buffer_, 63);
                if(return_value_strchr_94 == ((char *)NULL))
                {
                  do
                  {
                    const char *proxytrack_process_HTTP__1__5__8__15__6__1__1__str__ = (const char *)url.buffer_;
                    if(!(proxytrack_process_HTTP__1__5__8__15__6__1__1__str__ == ((const char *)NULL)))
                    {
                      unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__1__1__size__;
                      proxytrack_process_HTTP__1__5__8__15__6__1__1__1__size__=strlen(proxytrack_process_HTTP__1__5__8__15__6__1__1__str__);
                      do
                      {
                        urlRedirect.length_ = (unsigned long int)0;
                        do
                        {
                          const char *proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__15__6__1__1__str__;
                          const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__15__6__1__1__1__size__;
                          do
                          {
                            const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__1__capacity_ = (unsigned long int)(urlRedirect.length_ + proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__size_mc_ + (unsigned long int)1);
                            while(!(urlRedirect.capacity_ >= proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__1__capacity_))
                            {
                              if(!(urlRedirect.capacity_ >= 16ul))
                                urlRedirect.capacity_ = (unsigned long int)16;

                              else
                                urlRedirect.capacity_ = urlRedirect.capacity_ * (unsigned long int)2;
                              void *return_value_realloc_85;
                              return_value_realloc_85=realloc((void *)urlRedirect.buffer_, urlRedirect.capacity_);
                              urlRedirect.buffer_ = (char *)return_value_realloc_85;
                              /* assertion (urlRedirect).buffer_ != ((void *)0) */
                              assert(urlRedirect.buffer_ != (char *)(void *)0);
                            }
                          }
                          while((_Bool)0);
                          if(proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__size_mc_ >= 1ul)
                          {
                            memcpy((void *)(urlRedirect.buffer_ + (signed long int)urlRedirect.length_), (const void *)proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__size_mc_);
                            urlRedirect.length_ = urlRedirect.length_ + proxytrack_process_HTTP__1__5__8__15__6__1__1__1__1__1__size_mc_;
                          }

                          urlRedirect.buffer_[(signed long int)urlRedirect.length_] = (char)0;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)0);
                    }

                    else
                      do
                      {
                        urlRedirect.length_ = (unsigned long int)0;
                        do
                        {
                          const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__1__2__1__1__capacity_ = (unsigned long int)(urlRedirect.length_ + (unsigned long int)0 + (unsigned long int)1);
                          while(!(urlRedirect.capacity_ >= proxytrack_process_HTTP__1__5__8__15__6__1__1__2__1__1__capacity_))
                          {
                            if(!(urlRedirect.capacity_ >= 16ul))
                              urlRedirect.capacity_ = (unsigned long int)16;

                            else
                              urlRedirect.capacity_ = urlRedirect.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_86;
                            return_value_realloc_86=realloc((void *)urlRedirect.buffer_, urlRedirect.capacity_);
                            urlRedirect.buffer_ = (char *)return_value_realloc_86;
                            /* assertion (urlRedirect).buffer_ != ((void *)0) */
                            assert(urlRedirect.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        urlRedirect.buffer_[(signed long int)0] = (char)0;
                      }
                      while((_Bool)0);
                  }
                  while((_Bool)0);
                  do
                  {
                    const char * const proxytrack_process_HTTP__1__5__8__15__6__1__2__str__ = "/";
                    if(!(proxytrack_process_HTTP__1__5__8__15__6__1__2__str__ == ((const char *)NULL)))
                    {
                      unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__2__1__size__;
                      proxytrack_process_HTTP__1__5__8__15__6__1__2__1__size__=strlen(proxytrack_process_HTTP__1__5__8__15__6__1__2__str__);
                      do
                      {
                        const char *proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__str_mc_ = proxytrack_process_HTTP__1__5__8__15__6__1__2__str__;
                        const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__8__15__6__1__2__1__size__;
                        do
                        {
                          const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__1__capacity_ = (unsigned long int)(urlRedirect.length_ + proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__size_mc_ + (unsigned long int)1);
                          while(!(urlRedirect.capacity_ >= proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__1__capacity_))
                          {
                            if(!(urlRedirect.capacity_ >= 16ul))
                              urlRedirect.capacity_ = (unsigned long int)16;

                            else
                              urlRedirect.capacity_ = urlRedirect.capacity_ * (unsigned long int)2;
                            void *return_value_realloc_87;
                            return_value_realloc_87=realloc((void *)urlRedirect.buffer_, urlRedirect.capacity_);
                            urlRedirect.buffer_ = (char *)return_value_realloc_87;
                            /* assertion (urlRedirect).buffer_ != ((void *)0) */
                            assert(urlRedirect.buffer_ != (char *)(void *)0);
                          }
                        }
                        while((_Bool)0);
                        if(proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__size_mc_ >= 1ul)
                        {
                          memcpy((void *)(urlRedirect.buffer_ + (signed long int)urlRedirect.length_), (const void *)proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__str_mc_, proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__size_mc_);
                          urlRedirect.length_ = urlRedirect.length_ + proxytrack_process_HTTP__1__5__8__15__6__1__2__1__1__size_mc_;
                        }

                        urlRedirect.buffer_[(signed long int)urlRedirect.length_] = (char)0;
                      }
                      while((_Bool)0);
                    }

                  }
                  while((_Bool)0);
                  signed int return_value_PT_LookupIndex_93;
                  return_value_PT_LookupIndex_93=PT_LookupIndex(indexes, (const char *)urlRedirect.buffer_);
                  if(!(return_value_PT_LookupIndex_93 == 0))
                  {
                    msgCode = 301;
                    do
                    {
                      const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__3__1__capacity_ = (unsigned long int)(headers.length_ + (unsigned long int)8192 + (unsigned long int)1);
                      while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__8__15__6__1__3__1__capacity_))
                      {
                        if(!(headers.capacity_ >= 16ul))
                          headers.capacity_ = (unsigned long int)16;

                        else
                          headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                        void *return_value_realloc_88;
                        return_value_realloc_88=realloc((void *)headers.buffer_, headers.capacity_);
                        headers.buffer_ = (char *)return_value_realloc_88;
                        /* assertion (headers).buffer_ != ((void *)0) */
                        assert(headers.buffer_ != (char *)(void *)0);
                      }
                    }
                    while((_Bool)0);
                    const char *return_value_GetHttpMessage_89;
                    return_value_GetHttpMessage_89=GetHttpMessage(msgCode);
                    sprintf(headers.buffer_, "HTTP/1.1 %d %s\r\nContent-Type: text/html\r\nLocation: %s\r\n", msgCode, return_value_GetHttpMessage_89, (const char *)urlRedirect.buffer_);
                    unsigned long int return_value_strlen_90;
                    return_value_strlen_90=strlen((const char *)headers.buffer_);
                    headers.length_ = (unsigned long int)(signed int)return_value_strlen_90;
                    do
                    {
                      const unsigned long int proxytrack_process_HTTP__1__5__8__15__6__1__3__2__capacity_ = (unsigned long int)(output.length_ + (unsigned long int)1024 + sizeof(char [87l]) /*87ul*/  + sizeof(char [721l]) /*721ul*/  + (unsigned long int)1);
                      while(!(output.capacity_ >= proxytrack_process_HTTP__1__5__8__15__6__1__3__2__capacity_))
                      {
                        if(!(output.capacity_ >= 16ul))
                          output.capacity_ = (unsigned long int)16;

                        else
                          output.capacity_ = output.capacity_ * (unsigned long int)2;
                        void *return_value_realloc_91;
                        return_value_realloc_91=realloc((void *)output.buffer_, output.capacity_);
                        output.buffer_ = (char *)return_value_realloc_91;
                        /* assertion (output).buffer_ != ((void *)0) */
                        assert(output.buffer_ != (char *)(void *)0);
                      }
                    }
                    while((_Bool)0);
                    sprintf(output.buffer_, "<html><!-- Generated by ProxyTrack 0.5 -->\r\n<!-- This is an add-on for HTTrack 3.48.21 -->\r\n<!-- Start Disable IE Friendly HTTP Error Messages -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- End Disable IE Friendly HTTP Error Messages -->\r\n<head><title>ProxyTrack - Page has moved</title></head>\r\n<body><h3>The correct location is:</h3><br /><b><a href=\"%s\">%s</a></b><br /><br /><br />\r\n<i>Generated by ProxyTrack 0.5, (C) Xavier Roche and other contributors</i>\r\n</body></header>", (const char *)urlRedirect.buffer_, (const char *)urlRedirect.buffer_);
                    unsigned long int return_value_strlen_92;
                    return_value_strlen_92=strlen((const char *)output.buffer_);
                    output.length_ = (unsigned long int)(signed int)return_value_strlen_92;
                  }

                }

              }

            }

            if(msgCode == 0)
            {
              msgCode = 404;
              msgError = "Not Found in this cache";
            }

          }
        }

      }

      else
      {
        msgCode = 500;
        msgError = "Server Error";
        keepAlive = 0;
      }
      if(headers.length_ == 0ul)
      {
        if(msgCode == 0)
        {
          msgCode = 500;
          msgError = "Internal Proxy Error";
        }

        else
          if(msgError == ((const char *)NULL))
            msgError=GetHttpMessage(msgCode);

        do
        {
          const unsigned long int proxytrack_process_HTTP__1__5__10__3__capacity_ = (unsigned long int)(headers.length_ + (unsigned long int)256 + (unsigned long int)1);
          while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__10__3__capacity_))
          {
            if(!(headers.capacity_ >= 16ul))
              headers.capacity_ = (unsigned long int)16;

            else
              headers.capacity_ = headers.capacity_ * (unsigned long int)2;
            void *return_value_realloc_102;
            return_value_realloc_102=realloc((void *)headers.buffer_, headers.capacity_);
            headers.buffer_ = (char *)return_value_realloc_102;
            /* assertion (headers).buffer_ != ((void *)0) */
            assert(headers.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        sprintf(headers.buffer_, "HTTP/1.1 %d %s\r\nContent-type: text/html\r\n", msgCode, msgError);
        unsigned long int return_value_strlen_103;
        return_value_strlen_103=strlen((const char *)headers.buffer_);
        headers.length_ = (unsigned long int)(signed int)return_value_strlen_103;
        do
        {
          const unsigned long int capacity_ = (unsigned long int)(output.length_ + (unsigned long int)1024 + sizeof(char [87l]) /*87ul*/  + sizeof(char [721l]) /*721ul*/  + (unsigned long int)1);
          while(!(output.capacity_ >= capacity_))
          {
            if(!(output.capacity_ >= 16ul))
              output.capacity_ = (unsigned long int)16;

            else
              output.capacity_ = output.capacity_ * (unsigned long int)2;
            void *return_value_realloc_104;
            return_value_realloc_104=realloc((void *)output.buffer_, output.capacity_);
            output.buffer_ = (char *)return_value_realloc_104;
            /* assertion (output).buffer_ != ((void *)0) */
            assert(output.buffer_ != (char *)(void *)0);
          }
        }
        while((_Bool)0);
        sprintf(output.buffer_, "<html><!-- Generated by ProxyTrack 0.5 -->\r\n<!-- This is an add-on for HTTrack 3.48.21 -->\r\n<!-- Start Disable IE Friendly HTTP Error Messages -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- End Disable IE Friendly HTTP Error Messages -->\r\n<head><title>ProxyTrack - HTTP Proxy Error %d</title></head>\r\n<body><h3>A proxy error has occured while processing the request.</h3><br /><b>Error HTTP %d: <i>%s</i></b><br /><br /><br />\r\n<i>Generated by ProxyTrack 0.5, (C) Xavier Roche and other contributors</i>\r\n</body></html>", msgCode, msgCode, msgError);
        unsigned long int return_value_strlen_105;
        return_value_strlen_105=strlen((const char *)output.buffer_);
        output.length_ = (unsigned long int)(signed int)return_value_strlen_105;
      }

      char tmp[21l];
      unsigned long int dataSize = (unsigned long int)0;
      if(headRequest == 0)
      {
        dataSize = output.length_;
        if(dataSize == 0ul && !(element == ((struct _PT_Element *)NULL)))
          dataSize = element->size;

      }

      sprintf(tmp, "%d", (signed int)dataSize);
      do
      {
        const char * const str__ = "Content-length: ";
        if(!(str__ == ((const char *)NULL)))
        {
          unsigned long int size__;
          size__=strlen(str__);
          do
          {
            const char *str_mc_ = str__;
            const unsigned long int size_mc_ = (unsigned long int)size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__11__2__1__1__1__capacity_ = (unsigned long int)(headers.length_ + size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__11__2__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_106;
                return_value_realloc_106=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_106;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)str_mc_, size_mc_);
              headers.length_ = headers.length_ + size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      do
      {
        const char * const proxytrack_process_HTTP__1__5__11__3__str__ = tmp;
        if(!(proxytrack_process_HTTP__1__5__11__3__str__ == ((const char *)NULL)))
        {
          unsigned long int proxytrack_process_HTTP__1__5__11__3__1__size__;
          proxytrack_process_HTTP__1__5__11__3__1__size__=strlen(proxytrack_process_HTTP__1__5__11__3__str__);
          do
          {
            const char *proxytrack_process_HTTP__1__5__11__3__1__1__str_mc_ = proxytrack_process_HTTP__1__5__11__3__str__;
            const unsigned long int proxytrack_process_HTTP__1__5__11__3__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__11__3__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__11__3__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__11__3__1__1__size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__11__3__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_107;
                return_value_realloc_107=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_107;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__5__11__3__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__11__3__1__1__str_mc_, proxytrack_process_HTTP__1__5__11__3__1__1__size_mc_);
              headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__11__3__1__1__size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      do
      {
        const char * const proxytrack_process_HTTP__1__5__11__4__str__ = "\r\n";
        if(!(proxytrack_process_HTTP__1__5__11__4__str__ == ((const char *)NULL)))
        {
          unsigned long int proxytrack_process_HTTP__1__5__11__4__1__size__;
          proxytrack_process_HTTP__1__5__11__4__1__size__=strlen(proxytrack_process_HTTP__1__5__11__4__str__);
          do
          {
            const char *proxytrack_process_HTTP__1__5__11__4__1__1__str_mc_ = proxytrack_process_HTTP__1__5__11__4__str__;
            const unsigned long int proxytrack_process_HTTP__1__5__11__4__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__11__4__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__11__4__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__11__4__1__1__size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__11__4__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_108;
                return_value_realloc_108=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_108;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__5__11__4__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__11__4__1__1__str_mc_, proxytrack_process_HTTP__1__5__11__4__1__1__size_mc_);
              headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__11__4__1__1__size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      if(!(keepAlive == 0))
        do
        {
          const char * const proxytrack_process_HTTP__1__5__12__1__str__ = "Connection: Keep-Alive\r\nProxy-Connection: Keep-Alive\r\n";
          if(!(proxytrack_process_HTTP__1__5__12__1__str__ == ((const char *)NULL)))
          {
            unsigned long int proxytrack_process_HTTP__1__5__12__1__1__size__;
            proxytrack_process_HTTP__1__5__12__1__1__size__=strlen(proxytrack_process_HTTP__1__5__12__1__str__);
            do
            {
              const char *proxytrack_process_HTTP__1__5__12__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__12__1__str__;
              const unsigned long int proxytrack_process_HTTP__1__5__12__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__12__1__1__size__;
              do
              {
                const unsigned long int proxytrack_process_HTTP__1__5__12__1__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__12__1__1__1__size_mc_ + (unsigned long int)1);
                while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__12__1__1__1__1__capacity_))
                {
                  if(!(headers.capacity_ >= 16ul))
                    headers.capacity_ = (unsigned long int)16;

                  else
                    headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                  void *return_value_realloc_109;
                  return_value_realloc_109=realloc((void *)headers.buffer_, headers.capacity_);
                  headers.buffer_ = (char *)return_value_realloc_109;
                  /* assertion (headers).buffer_ != ((void *)0) */
                  assert(headers.buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              if(proxytrack_process_HTTP__1__5__12__1__1__1__size_mc_ >= 1ul)
              {
                memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__12__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__12__1__1__1__size_mc_);
                headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__12__1__1__1__size_mc_;
              }

              headers.buffer_[(signed long int)headers.length_] = (char)0;
            }
            while((_Bool)0);
          }

        }
        while((_Bool)0);

      else
        do
        {
          const char * const proxytrack_process_HTTP__1__5__13__1__str__ = "Connection: Close\r\nProxy-Connection: Close\r\n";
          if(!(proxytrack_process_HTTP__1__5__13__1__str__ == ((const char *)NULL)))
          {
            unsigned long int proxytrack_process_HTTP__1__5__13__1__1__size__;
            proxytrack_process_HTTP__1__5__13__1__1__size__=strlen(proxytrack_process_HTTP__1__5__13__1__str__);
            do
            {
              const char *proxytrack_process_HTTP__1__5__13__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__13__1__str__;
              const unsigned long int proxytrack_process_HTTP__1__5__13__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__13__1__1__size__;
              do
              {
                const unsigned long int proxytrack_process_HTTP__1__5__13__1__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__13__1__1__1__size_mc_ + (unsigned long int)1);
                while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__13__1__1__1__1__capacity_))
                {
                  if(!(headers.capacity_ >= 16ul))
                    headers.capacity_ = (unsigned long int)16;

                  else
                    headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                  void *return_value_realloc_110;
                  return_value_realloc_110=realloc((void *)headers.buffer_, headers.capacity_);
                  headers.buffer_ = (char *)return_value_realloc_110;
                  /* assertion (headers).buffer_ != ((void *)0) */
                  assert(headers.buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              if(proxytrack_process_HTTP__1__5__13__1__1__1__size_mc_ >= 1ul)
              {
                memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__13__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__13__1__1__1__size_mc_);
                headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__13__1__1__1__size_mc_;
              }

              headers.buffer_[(signed long int)headers.length_] = (char)0;
            }
            while((_Bool)0);
          }

        }
        while((_Bool)0);
      if(!(msgCode == 500))
        do
        {
          const char * const proxytrack_process_HTTP__1__5__14__str__ = "X-Cache: HIT from ";
          if(!(proxytrack_process_HTTP__1__5__14__str__ == ((const char *)NULL)))
          {
            unsigned long int proxytrack_process_HTTP__1__5__14__1__size__;
            proxytrack_process_HTTP__1__5__14__1__size__=strlen(proxytrack_process_HTTP__1__5__14__str__);
            do
            {
              const char *proxytrack_process_HTTP__1__5__14__1__1__str_mc_ = proxytrack_process_HTTP__1__5__14__str__;
              const unsigned long int proxytrack_process_HTTP__1__5__14__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__14__1__size__;
              do
              {
                const unsigned long int proxytrack_process_HTTP__1__5__14__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__14__1__1__size_mc_ + (unsigned long int)1);
                while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__14__1__1__1__capacity_))
                {
                  if(!(headers.capacity_ >= 16ul))
                    headers.capacity_ = (unsigned long int)16;

                  else
                    headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                  void *return_value_realloc_111;
                  return_value_realloc_111=realloc((void *)headers.buffer_, headers.capacity_);
                  headers.buffer_ = (char *)return_value_realloc_111;
                  /* assertion (headers).buffer_ != ((void *)0) */
                  assert(headers.buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              if(proxytrack_process_HTTP__1__5__14__1__1__size_mc_ >= 1ul)
              {
                memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__14__1__1__str_mc_, proxytrack_process_HTTP__1__5__14__1__1__size_mc_);
                headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__14__1__1__size_mc_;
              }

              headers.buffer_[(signed long int)headers.length_] = (char)0;
            }
            while((_Bool)0);
          }

        }
        while((_Bool)0);

      else
        do
        {
          const char * const proxytrack_process_HTTP__1__5__15__str__ = "X-Cache: MISS from ";
          if(!(proxytrack_process_HTTP__1__5__15__str__ == ((const char *)NULL)))
          {
            unsigned long int proxytrack_process_HTTP__1__5__15__1__size__;
            proxytrack_process_HTTP__1__5__15__1__size__=strlen(proxytrack_process_HTTP__1__5__15__str__);
            do
            {
              const char *proxytrack_process_HTTP__1__5__15__1__1__str_mc_ = proxytrack_process_HTTP__1__5__15__str__;
              const unsigned long int proxytrack_process_HTTP__1__5__15__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__15__1__size__;
              do
              {
                const unsigned long int proxytrack_process_HTTP__1__5__15__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__15__1__1__size_mc_ + (unsigned long int)1);
                while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__15__1__1__1__capacity_))
                {
                  if(!(headers.capacity_ >= 16ul))
                    headers.capacity_ = (unsigned long int)16;

                  else
                    headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                  void *return_value_realloc_112;
                  return_value_realloc_112=realloc((void *)headers.buffer_, headers.capacity_);
                  headers.buffer_ = (char *)return_value_realloc_112;
                  /* assertion (headers).buffer_ != ((void *)0) */
                  assert(headers.buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              if(proxytrack_process_HTTP__1__5__15__1__1__size_mc_ >= 1ul)
              {
                memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__15__1__1__str_mc_, proxytrack_process_HTTP__1__5__15__1__1__size_mc_);
                headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__15__1__1__size_mc_;
              }

              headers.buffer_[(signed long int)headers.length_] = (char)0;
            }
            while((_Bool)0);
          }

        }
        while((_Bool)0);
      do
      {
        const char * const proxytrack_process_HTTP__1__5__16__str__ = (const char *)localhost.buffer_;
        if(!(proxytrack_process_HTTP__1__5__16__str__ == ((const char *)NULL)))
        {
          unsigned long int proxytrack_process_HTTP__1__5__16__1__size__;
          proxytrack_process_HTTP__1__5__16__1__size__=strlen(proxytrack_process_HTTP__1__5__16__str__);
          do
          {
            const char *proxytrack_process_HTTP__1__5__16__1__1__str_mc_ = proxytrack_process_HTTP__1__5__16__str__;
            const unsigned long int proxytrack_process_HTTP__1__5__16__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__16__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__16__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__16__1__1__size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__16__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_113;
                return_value_realloc_113=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_113;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__5__16__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__16__1__1__str_mc_, proxytrack_process_HTTP__1__5__16__1__1__size_mc_);
              headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__16__1__1__size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      do
      {
        const char * const proxytrack_process_HTTP__1__5__17__str__ = "\r\n";
        if(!(proxytrack_process_HTTP__1__5__17__str__ == ((const char *)NULL)))
        {
          unsigned long int proxytrack_process_HTTP__1__5__17__1__size__;
          proxytrack_process_HTTP__1__5__17__1__size__=strlen(proxytrack_process_HTTP__1__5__17__str__);
          do
          {
            const char *proxytrack_process_HTTP__1__5__17__1__1__str_mc_ = proxytrack_process_HTTP__1__5__17__str__;
            const unsigned long int proxytrack_process_HTTP__1__5__17__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__17__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__17__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__17__1__1__size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__17__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_114;
                return_value_realloc_114=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_114;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__5__17__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__17__1__1__str_mc_, proxytrack_process_HTTP__1__5__17__1__1__size_mc_);
              headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__17__1__1__size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      const char *contentType = "text/html";
      unsigned long int size;
      if(!(output.length_ == 0ul))
        tmp_if_expr_116 = output.length_;

      else
      {
        if(!(element == ((struct _PT_Element *)NULL)))
          tmp_if_expr_115 = element->size;

        else
          tmp_if_expr_115 = (unsigned long int)0;
        tmp_if_expr_116 = tmp_if_expr_115;
      }
      size = tmp_if_expr_116;
      struct String ip = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
      struct SOCaddr serverClient;
      unsigned int lenServerClient = (unsigned int)sizeof(union anonymous_14) /*28ul*/ ;
      memset((void *)&serverClient, 0, sizeof(struct SOCaddr) /*28ul*/ );
      signed int return_value_getsockname_119;
      return_value_getsockname_119=getsockname(soc_c, &serverClient.m_addr.sa, &lenServerClient);
      if(return_value_getsockname_119 == 0)
        ip=getip(&serverClient);

      else
        do
        {
          const char *proxytrack_process_HTTP__1__5__18__2__1__str__ = "unknown";
          if(!(proxytrack_process_HTTP__1__5__18__2__1__str__ == ((const char *)NULL)))
          {
            unsigned long int proxytrack_process_HTTP__1__5__18__2__1__1__size__;
            proxytrack_process_HTTP__1__5__18__2__1__1__size__=strlen(proxytrack_process_HTTP__1__5__18__2__1__str__);
            do
            {
              ip.length_ = (unsigned long int)0;
              do
              {
                const char *proxytrack_process_HTTP__1__5__18__2__1__1__1__1__str_mc_ = proxytrack_process_HTTP__1__5__18__2__1__str__;
                const unsigned long int proxytrack_process_HTTP__1__5__18__2__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__18__2__1__1__size__;
                do
                {
                  const unsigned long int proxytrack_process_HTTP__1__5__18__2__1__1__1__1__1__capacity_ = (unsigned long int)(ip.length_ + proxytrack_process_HTTP__1__5__18__2__1__1__1__1__size_mc_ + (unsigned long int)1);
                  while(!(ip.capacity_ >= proxytrack_process_HTTP__1__5__18__2__1__1__1__1__1__capacity_))
                  {
                    if(!(ip.capacity_ >= 16ul))
                      ip.capacity_ = (unsigned long int)16;

                    else
                      ip.capacity_ = ip.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_117;
                    return_value_realloc_117=realloc((void *)ip.buffer_, ip.capacity_);
                    ip.buffer_ = (char *)return_value_realloc_117;
                    /* assertion (ip).buffer_ != ((void *)0) */
                    assert(ip.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(proxytrack_process_HTTP__1__5__18__2__1__1__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(ip.buffer_ + (signed long int)ip.length_), (const void *)proxytrack_process_HTTP__1__5__18__2__1__1__1__1__str_mc_, proxytrack_process_HTTP__1__5__18__2__1__1__1__1__size_mc_);
                  ip.length_ = ip.length_ + proxytrack_process_HTTP__1__5__18__2__1__1__1__1__size_mc_;
                }

                ip.buffer_[(signed long int)ip.length_] = (char)0;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
          }

          else
            do
            {
              ip.length_ = (unsigned long int)0;
              do
              {
                const unsigned long int proxytrack_process_HTTP__1__5__18__2__1__2__1__1__capacity_ = (unsigned long int)(ip.length_ + (unsigned long int)0 + (unsigned long int)1);
                while(!(ip.capacity_ >= proxytrack_process_HTTP__1__5__18__2__1__2__1__1__capacity_))
                {
                  if(!(ip.capacity_ >= 16ul))
                    ip.capacity_ = (unsigned long int)16;

                  else
                    ip.capacity_ = ip.capacity_ * (unsigned long int)2;
                  void *return_value_realloc_118;
                  return_value_realloc_118=realloc((void *)ip.buffer_, ip.capacity_);
                  ip.buffer_ = (char *)return_value_realloc_118;
                  /* assertion (ip).buffer_ != ((void *)0) */
                  assert(ip.buffer_ != (char *)(void *)0);
                }
              }
              while((_Bool)0);
              ip.buffer_[(signed long int)0] = (char)0;
            }
            while((_Bool)0);
        }
        while((_Bool)0);
      if(!(element == ((struct _PT_Element *)NULL)))
      {
        if(!((signed int)element->contenttype[0l] == 0))
          contentType = element->contenttype;

      }

      proxytrack_print_log("log", "HTTP %s %d %d %s %s %s", (const char *)ip.buffer_, msgCode, (signed int)size, command, (const char *)url.buffer_, contentType);
      do
      {
        if(!(ip.buffer_ == ((char *)NULL)))
        {
          free((void *)ip.buffer_);
          ip.buffer_ = (char *)(void *)0;
        }

        ip.capacity_ = (unsigned long int)0;
        ip.length_ = (unsigned long int)0;
      }
      while((_Bool)0);
      do
      {
        const char * const proxytrack_process_HTTP__1__5__19__str__ = "Server: ProxyTrack 0.5 (HTTrack 3.48.21)\r\n";
        if(!(proxytrack_process_HTTP__1__5__19__str__ == ((const char *)NULL)))
        {
          unsigned long int proxytrack_process_HTTP__1__5__19__1__size__;
          proxytrack_process_HTTP__1__5__19__1__size__=strlen(proxytrack_process_HTTP__1__5__19__str__);
          do
          {
            const char *proxytrack_process_HTTP__1__5__19__1__1__str_mc_ = proxytrack_process_HTTP__1__5__19__str__;
            const unsigned long int proxytrack_process_HTTP__1__5__19__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__19__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__19__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__19__1__1__size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__19__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_120;
                return_value_realloc_120=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_120;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__5__19__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__19__1__1__str_mc_, proxytrack_process_HTTP__1__5__19__1__1__size_mc_);
              headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__19__1__1__size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      do
      {
        const char * const proxytrack_process_HTTP__1__5__20__str__ = "\r\n";
        if(!(proxytrack_process_HTTP__1__5__20__str__ == ((const char *)NULL)))
        {
          unsigned long int proxytrack_process_HTTP__1__5__20__1__size__;
          proxytrack_process_HTTP__1__5__20__1__size__=strlen(proxytrack_process_HTTP__1__5__20__str__);
          do
          {
            const char *proxytrack_process_HTTP__1__5__20__1__1__str_mc_ = proxytrack_process_HTTP__1__5__20__str__;
            const unsigned long int proxytrack_process_HTTP__1__5__20__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP__1__5__20__1__size__;
            do
            {
              const unsigned long int proxytrack_process_HTTP__1__5__20__1__1__1__capacity_ = (unsigned long int)(headers.length_ + proxytrack_process_HTTP__1__5__20__1__1__size_mc_ + (unsigned long int)1);
              while(!(headers.capacity_ >= proxytrack_process_HTTP__1__5__20__1__1__1__capacity_))
              {
                if(!(headers.capacity_ >= 16ul))
                  headers.capacity_ = (unsigned long int)16;

                else
                  headers.capacity_ = headers.capacity_ * (unsigned long int)2;
                void *return_value_realloc_121;
                return_value_realloc_121=realloc((void *)headers.buffer_, headers.capacity_);
                headers.buffer_ = (char *)return_value_realloc_121;
                /* assertion (headers).buffer_ != ((void *)0) */
                assert(headers.buffer_ != (char *)(void *)0);
              }
            }
            while((_Bool)0);
            if(proxytrack_process_HTTP__1__5__20__1__1__size_mc_ >= 1ul)
            {
              memcpy((void *)(headers.buffer_ + (signed long int)headers.length_), (const void *)proxytrack_process_HTTP__1__5__20__1__1__str_mc_, proxytrack_process_HTTP__1__5__20__1__1__size_mc_);
              headers.length_ = headers.length_ + proxytrack_process_HTTP__1__5__20__1__1__size_mc_;
            }

            headers.buffer_[(signed long int)headers.length_] = (char)0;
          }
          while((_Bool)0);
        }

      }
      while((_Bool)0);
      signed long int return_value_send_122;
      return_value_send_122=send(soc_c, (const void *)(const char *)headers.buffer_, (unsigned long int)(signed int)headers.length_, 0);
      if(!((unsigned long int)return_value_send_122 == headers.length_))
        tmp_if_expr_125 = (_Bool)1;

      else
      {
        if(headRequest == 0 && output.length_ >= 1ul)
        {
          return_value_send_123=send(soc_c, (const void *)(const char *)output.buffer_, (unsigned long int)(signed int)output.length_, 0);
          tmp_if_expr_124 = (unsigned long int)return_value_send_123 != output.length_ ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_124 = (_Bool)0;
        tmp_if_expr_125 = tmp_if_expr_124 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_125)
        tmp_if_expr_129 = (_Bool)1;

      else
      {
        if(output.length_ == 0ul && headRequest == 0 && !(element == ((struct _PT_Element *)NULL)))
          tmp_if_expr_126 = element->adr != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_126 = (_Bool)0;
        if(tmp_if_expr_126)
        {
          return_value_send_127=send(soc_c, (const void *)element->adr, (unsigned long int)(signed int)element->size, 0);
          tmp_if_expr_128 = (unsigned long int)return_value_send_127 != element->size ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_128 = (_Bool)0;
        tmp_if_expr_129 = tmp_if_expr_128 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_129)
        keepAlive = 0;

      PT_Element_Delete(&element);
      if(keepAlive == 0)
      {
        char c;
        shutdown(soc_c, 1);
        do
        {
          return_value_recv_130=recv(soc_c, (void *)(char *)&c, (unsigned long int)1, 0);
          if(!(return_value_recv_130 >= 1l))
            break;

        }
        while((_Bool)1);
      }

    }
    while(!(keepAlive == 0));
    close(soc_c);
    do
    {
      if(!(url.buffer_ == ((char *)NULL)))
      {
        free((void *)url.buffer_);
        url.buffer_ = (char *)(void *)0;
      }

      url.capacity_ = (unsigned long int)0;
      url.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(urlRedirect.buffer_ == ((char *)NULL)))
      {
        free((void *)urlRedirect.buffer_);
        urlRedirect.buffer_ = (char *)(void *)0;
      }

      urlRedirect.capacity_ = (unsigned long int)0;
      urlRedirect.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(headers.buffer_ == ((char *)NULL)))
      {
        free((void *)headers.buffer_);
        headers.buffer_ = (char *)(void *)0;
      }

      headers.capacity_ = (unsigned long int)0;
      headers.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(output.buffer_ == ((char *)NULL)))
      {
        free((void *)output.buffer_);
        output.buffer_ = (char *)(void *)0;
      }

      output.capacity_ = (unsigned long int)0;
      output.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(host.buffer_ == ((char *)NULL)))
      {
        free((void *)host.buffer_);
        host.buffer_ = (char *)(void *)0;
      }

      host.capacity_ = (unsigned long int)0;
      host.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(localhost.buffer_ == ((char *)NULL)))
      {
        free((void *)localhost.buffer_);
        localhost.buffer_ = (char *)(void *)0;
      }

      localhost.capacity_ = (unsigned long int)0;
      localhost.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(davHeaders.buffer_ == ((char *)NULL)))
      {
        free((void *)davHeaders.buffer_);
        davHeaders.buffer_ = (char *)(void *)0;
      }

      davHeaders.capacity_ = (unsigned long int)0;
      davHeaders.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    do
    {
      if(!(davRequest.buffer_ == ((char *)NULL)))
      {
        free((void *)davRequest.buffer_);
        davRequest.buffer_ = (char *)(void *)0;
      }

      davRequest.capacity_ = (unsigned long int)0;
      davRequest.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    if(!(buffer == ((char *)NULL)))
      free((void *)buffer);

    if(!(line == ((char *)NULL)))
      free((void *)line);

    if(!(line1 == ((char *)NULL)))
      free((void *)line1);

  }
}

// proxytrack_process_HTTP_List
// file proxy/proxytrack.c line 840
static struct _PT_Element * proxytrack_process_HTTP_List(struct _PT_Indexes *indexes, const char *url)
{
  char **list;
  list=PT_Enumerate(indexes, url, 0);
  if(!(list == ((char **)NULL)))
  {
    struct _PT_Element *elt;
    elt=PT_ElementNew();
    signed int i;
    signed int isDir;
    struct String html = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
    do
    {
      html.length_ = (unsigned long int)0;
      do
      {
        const unsigned long int proxytrack_process_HTTP_List__1__1__1__1__capacity_ = (unsigned long int)(html.length_ + (unsigned long int)0 + (unsigned long int)1);
        while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__1__1__capacity_))
        {
          if(!(html.capacity_ >= 16ul))
            html.capacity_ = (unsigned long int)16;

          else
            html.capacity_ = html.capacity_ * (unsigned long int)2;
          void *return_value_realloc_1;
          return_value_realloc_1=realloc((void *)html.buffer_, html.capacity_);
          html.buffer_ = (char *)return_value_realloc_1;
          /* assertion (html).buffer_ != ((void *)0) */
          assert(html.buffer_ != (char *)(void *)0);
        }
      }
      while((_Bool)0);
      html.buffer_[(signed long int)0] = (char)0;
    }
    while((_Bool)0);
    do
    {
      const char * const proxytrack_process_HTTP_List__1__1__2__str__ = "<html><!-- Generated by ProxyTrack 0.5 -->\r\n<!-- This is an add-on for HTTrack 3.48.21 -->\r\n<!-- Start Disable IE Friendly HTTP Error Messages -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- _-._.--._._-._.--._._-._.--._._-._.--._._-._.--._. -->\r\n<!-- End Disable IE Friendly HTTP Error Messages -->\r\n<head>\r\n<title>ProxyTrack 0.5 Catalog</title></head>\r\n<body>\r\n<h3>Directory index:</h3><br /><br /><hr><tt>[DIR] <a href=\"..\">..</a></tt><br />";
      if(!(proxytrack_process_HTTP_List__1__1__2__str__ == ((const char *)NULL)))
      {
        unsigned long int proxytrack_process_HTTP_List__1__1__2__1__size__;
        proxytrack_process_HTTP_List__1__1__2__1__size__=strlen(proxytrack_process_HTTP_List__1__1__2__str__);
        do
        {
          const char *proxytrack_process_HTTP_List__1__1__2__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__2__str__;
          const unsigned long int proxytrack_process_HTTP_List__1__1__2__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__2__1__size__;
          do
          {
            const unsigned long int proxytrack_process_HTTP_List__1__1__2__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__2__1__1__size_mc_ + (unsigned long int)1);
            while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__2__1__1__1__capacity_))
            {
              if(!(html.capacity_ >= 16ul))
                html.capacity_ = (unsigned long int)16;

              else
                html.capacity_ = html.capacity_ * (unsigned long int)2;
              void *return_value_realloc_2;
              return_value_realloc_2=realloc((void *)html.buffer_, html.capacity_);
              html.buffer_ = (char *)return_value_realloc_2;
              /* assertion (html).buffer_ != ((void *)0) */
              assert(html.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(proxytrack_process_HTTP_List__1__1__2__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__2__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__2__1__1__size_mc_);
            html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__2__1__1__size_mc_;
          }

          html.buffer_[(signed long int)html.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    isDir = 1;
    for( ; isDir >= 0; isDir = isDir - 1)
    {
      i = 0;
      for( ; !(list[(signed long int)i] == ((char *)NULL)); i = i + 1)
      {
        char *thisUrl = list[(signed long int)i];
        unsigned int thisUrlLen;
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(thisUrl);
        thisUrlLen = (unsigned int)return_value_strlen_3;
        signed int thisIsDir = (signed int)thisUrl[(signed long int)(thisUrlLen - (unsigned int)1)] == 47 ? 1 : 0;
        if(thisIsDir == isDir)
        {
          if(!(isDir == 0))
            do
            {
              const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__str__ = "<tt>[DIR] ";
              if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__str__ == ((const char *)NULL)))
              {
                unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__size__;
                proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__str__);
                do
                {
                  const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__str__;
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__size__;
                  do
                  {
                    const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__size_mc_ + (unsigned long int)1);
                    while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__1__capacity_))
                    {
                      if(!(html.capacity_ >= 16ul))
                        html.capacity_ = (unsigned long int)16;

                      else
                        html.capacity_ = html.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_4;
                      return_value_realloc_4=realloc((void *)html.buffer_, html.capacity_);
                      html.buffer_ = (char *)return_value_realloc_4;
                      /* assertion (html).buffer_ != ((void *)0) */
                      assert(html.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__size_mc_);
                    html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__1__1__1__size_mc_;
                  }

                  html.buffer_[(signed long int)html.length_] = (char)0;
                }
                while((_Bool)0);
              }

            }
            while((_Bool)0);

          else
            do
            {
              const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__str__ = "<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";
              if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__str__ == ((const char *)NULL)))
              {
                unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__size__;
                proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__str__);
                do
                {
                  const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__str__;
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__size__;
                  do
                  {
                    const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__size_mc_ + (unsigned long int)1);
                    while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__1__capacity_))
                    {
                      if(!(html.capacity_ >= 16ul))
                        html.capacity_ = (unsigned long int)16;

                      else
                        html.capacity_ = html.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_5;
                      return_value_realloc_5=realloc((void *)html.buffer_, html.capacity_);
                      html.buffer_ = (char *)return_value_realloc_5;
                      /* assertion (html).buffer_ != ((void *)0) */
                      assert(html.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__size_mc_);
                    html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__2__1__1__size_mc_;
                  }

                  html.buffer_[(signed long int)html.length_] = (char)0;
                }
                while((_Bool)0);
              }

            }
            while((_Bool)0);
          do
          {
            const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__str__ = "<a href=\"";
            if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__str__ == ((const char *)NULL)))
            {
              unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__size__;
              proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__str__);
              do
              {
                const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__str__;
                const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__size__;
                do
                {
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_6;
                    return_value_realloc_6=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_6;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__size_mc_);
                  html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__3__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          if(!(isDir == 0))
            do
            {
              const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__str__ = "http://proxytrack/";
              if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__str__ == ((const char *)NULL)))
              {
                unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__size__;
                proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__str__);
                do
                {
                  const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__str__;
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__size__;
                  do
                  {
                    const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__size_mc_ + (unsigned long int)1);
                    while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__1__capacity_))
                    {
                      if(!(html.capacity_ >= 16ul))
                        html.capacity_ = (unsigned long int)16;

                      else
                        html.capacity_ = html.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_7;
                      return_value_realloc_7=realloc((void *)html.buffer_, html.capacity_);
                      html.buffer_ = (char *)return_value_realloc_7;
                      /* assertion (html).buffer_ != ((void *)0) */
                      assert(html.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__size_mc_ >= 1ul)
                  {
                    memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__size_mc_);
                    html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__4__1__1__1__size_mc_;
                  }

                  html.buffer_[(signed long int)html.length_] = (char)0;
                }
                while((_Bool)0);
              }

            }
            while((_Bool)0);

          do
          {
            const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__str__ = url;
            if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__str__ == ((const char *)NULL)))
            {
              unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__size__;
              proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__str__);
              do
              {
                const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__str__;
                const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__size__;
                do
                {
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_8;
                    return_value_realloc_8=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_8;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__size_mc_);
                  html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__5__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const str__ = list[(signed long int)i];
            if(!(str__ == ((const char *)NULL)))
            {
              unsigned long int size__;
              size__=strlen(str__);
              do
              {
                const char *str_mc_ = str__;
                const unsigned long int size_mc_ = (unsigned long int)size__;
                do
                {
                  const unsigned long int capacity_ = (unsigned long int)(html.length_ + size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_9;
                    return_value_realloc_9=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_9;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)str_mc_, size_mc_);
                  html.length_ = html.length_ + size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__str__ = "\">";
            if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__str__ == ((const char *)NULL)))
            {
              unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__size__;
              proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__str__);
              do
              {
                const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__str__;
                const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__size__;
                do
                {
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_10;
                    return_value_realloc_10=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_10;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__size_mc_);
                  html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__7__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__str__ = list[(signed long int)i];
            if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__str__ == ((const char *)NULL)))
            {
              unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__size__;
              proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__str__);
              do
              {
                const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__str__;
                const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__size__;
                do
                {
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_11;
                    return_value_realloc_11=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_11;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__size_mc_);
                  html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__8__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
          do
          {
            const char * const proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__str__ = "</a></tt><br />";
            if(!(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__str__ == ((const char *)NULL)))
            {
              unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__size__;
              proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__size__=strlen(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__str__);
              do
              {
                const char *proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__str__;
                const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__size__;
                do
                {
                  const unsigned long int proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__size_mc_ + (unsigned long int)1);
                  while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__1__capacity_))
                  {
                    if(!(html.capacity_ >= 16ul))
                      html.capacity_ = (unsigned long int)16;

                    else
                      html.capacity_ = html.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_12;
                    return_value_realloc_12=realloc((void *)html.buffer_, html.capacity_);
                    html.buffer_ = (char *)return_value_realloc_12;
                    /* assertion (html).buffer_ != ((void *)0) */
                    assert(html.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                if(proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__size_mc_ >= 1ul)
                {
                  memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__size_mc_);
                  html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__3__1__1__1__1__9__1__1__size_mc_;
                }

                html.buffer_[(signed long int)html.length_] = (char)0;
              }
              while((_Bool)0);
            }

          }
          while((_Bool)0);
        }

      }
    }
    do
    {
      const char * const proxytrack_process_HTTP_List__1__1__4__str__ = "</body></html>";
      if(!(proxytrack_process_HTTP_List__1__1__4__str__ == ((const char *)NULL)))
      {
        unsigned long int proxytrack_process_HTTP_List__1__1__4__1__size__;
        proxytrack_process_HTTP_List__1__1__4__1__size__=strlen(proxytrack_process_HTTP_List__1__1__4__str__);
        do
        {
          const char *proxytrack_process_HTTP_List__1__1__4__1__1__str_mc_ = proxytrack_process_HTTP_List__1__1__4__str__;
          const unsigned long int proxytrack_process_HTTP_List__1__1__4__1__1__size_mc_ = (unsigned long int)proxytrack_process_HTTP_List__1__1__4__1__size__;
          do
          {
            const unsigned long int proxytrack_process_HTTP_List__1__1__4__1__1__1__capacity_ = (unsigned long int)(html.length_ + proxytrack_process_HTTP_List__1__1__4__1__1__size_mc_ + (unsigned long int)1);
            while(!(html.capacity_ >= proxytrack_process_HTTP_List__1__1__4__1__1__1__capacity_))
            {
              if(!(html.capacity_ >= 16ul))
                html.capacity_ = (unsigned long int)16;

              else
                html.capacity_ = html.capacity_ * (unsigned long int)2;
              void *return_value_realloc_13;
              return_value_realloc_13=realloc((void *)html.buffer_, html.capacity_);
              html.buffer_ = (char *)return_value_realloc_13;
              /* assertion (html).buffer_ != ((void *)0) */
              assert(html.buffer_ != (char *)(void *)0);
            }
          }
          while((_Bool)0);
          if(proxytrack_process_HTTP_List__1__1__4__1__1__size_mc_ >= 1ul)
          {
            memcpy((void *)(html.buffer_ + (signed long int)html.length_), (const void *)proxytrack_process_HTTP_List__1__1__4__1__1__str_mc_, proxytrack_process_HTTP_List__1__1__4__1__1__size_mc_);
            html.length_ = html.length_ + proxytrack_process_HTTP_List__1__1__4__1__1__size_mc_;
          }

          html.buffer_[(signed long int)html.length_] = (char)0;
        }
        while((_Bool)0);
      }

    }
    while((_Bool)0);
    PT_Enumerate_Delete(&list);
    elt->size = html.length_;
    elt->adr=StringAcquire(&html);
    elt->statuscode = 200;
    strcpy(elt->charset, "iso-8859-1");
    strcpy(elt->contenttype, "text/html");
    strcpy(elt->msg, "OK");
    do
    {
      if(!(html.buffer_ == ((char *)NULL)))
      {
        free((void *)html.buffer_);
        html.buffer_ = (char *)(void *)0;
      }

      html.capacity_ = (unsigned long int)0;
      html.length_ = (unsigned long int)0;
    }
    while((_Bool)0);
    return elt;
  }

  return (struct _PT_Element *)(void *)0;
}

// proxytrack_process_HTTP_threaded
// file proxy/proxytrack.c line 1479
static signed int proxytrack_process_HTTP_threaded(struct _PT_Indexes *indexes, signed int soc)
{
  signed int return_value_proxytrack_process_generic_1;
  return_value_proxytrack_process_generic_1=proxytrack_process_generic(proxytrack_process_HTTP, indexes, soc);
  return return_value_proxytrack_process_generic_1;
}

// proxytrack_process_generic
// file proxy/proxytrack.c line 1461
static signed int proxytrack_process_generic(void (*process)(struct _PT_Indexes *, signed int), struct _PT_Indexes *indexes, signed int soc_c)
{
  struct proxytrack_process_th_p *param;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct proxytrack_process_th_p) /*24ul*/ , (unsigned long int)1);
  param = (struct proxytrack_process_th_p *)return_value_calloc_1;
  if(!(param == ((struct proxytrack_process_th_p *)NULL)))
  {
    param->soc_c = soc_c;
    param->indexes = indexes;
    param->process = process;
    signed int return_value_startThread_2;
    return_value_startThread_2=startThread(proxytrack_process_th, (void *)param);
    return return_value_startThread_2;
  }

  else
  {
    proxytrack_print_log("critical", "proxytrack_process_generic:Memory exhausted");
    return 0;
  }
  return 0;
}

// proxytrack_process_th
// file proxy/proxytrack.c line 1448
static void * proxytrack_process_th(void *param_)
{
  struct proxytrack_process_th_p *param = (struct proxytrack_process_th_p *)param_;
  signed int soc_c = param->soc_c;
  struct _PT_Indexes *indexes = param->indexes;
  void (*process)(struct _PT_Indexes *, signed int) = param->process;
  free((void *)param);
  process(indexes, soc_c);
  return (void *)0;
}

// proxytrack_start
// file proxy/proxytrack.c line 1716
static signed int proxytrack_start(struct _PT_Indexes *indexes, signed int soc, signed int socICP)
{
  signed int ret = 1;
  signed int return_value_proxytrack_process_generic_2;
  return_value_proxytrack_process_generic_2=proxytrack_process_generic(proxytrack_start_ICP_th, indexes, socICP);
  if(!(return_value_proxytrack_process_generic_2 == 0))
  {
    signed int return_value_proxytrack_start_HTTP_1;
    return_value_proxytrack_start_HTTP_1=proxytrack_start_HTTP(indexes, soc);
    if(return_value_proxytrack_start_HTTP_1 == 0)
      ret = 0;

  }

  else
    ret = 0;
  return ret;
}

// proxytrack_start_HTTP
// file proxy/proxytrack.c line 1484
static signed int proxytrack_start_HTTP(struct _PT_Indexes *indexes, signed int soc)
{
  while(!(soc == -1))
  {
    signed int soc_c;
    signed int return_value_accept_2;
    return_value_accept_2=accept(soc, (struct sockaddr *)(void *)0, (unsigned int *)(void *)0);
    soc_c = (signed int)return_value_accept_2;
    if(!(soc_c == -1))
    {
      signed int return_value_proxytrack_process_HTTP_threaded_1;
      return_value_proxytrack_process_HTTP_threaded_1=proxytrack_process_HTTP_threaded(indexes, soc_c);
      if(return_value_proxytrack_process_HTTP_threaded_1 == 0)
        proxytrack_print_log("critical", "proxytrack_start_HTTP::Can not fork a thread");

    }

  }
  if(!(soc == -1))
    close(soc);

  return 1;
}

// proxytrack_start_ICP
// file proxy/proxytrack.c line 1555
static signed int proxytrack_start_ICP(struct _PT_Indexes *indexes, signed int soc)
{
  signed int bufferSize = 16384;
  unsigned char *buffer;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(bufferSize + 1));
  buffer = (unsigned char *)return_value_malloc_1;
  signed int return_value_PT_LookupIndex_7;
  char *return_value_strchr_6;
  if(buffer == ((unsigned char *)NULL))
  {
    proxytrack_print_log("critical", "proxytrack_start_ICP:memory exhausted");
    close(soc);
    return -1;
  }

  else
  {
    while(!(soc == -1))
    {
      struct SOCaddr clientAddr;
      unsigned int clientAddrLen = (unsigned int)sizeof(union anonymous_14) /*28ul*/ ;
      signed int n;
      memset((void *)&clientAddr, 0, sizeof(struct SOCaddr) /*28ul*/ );
      signed long int return_value_recvfrom_2;
      return_value_recvfrom_2=recvfrom(soc, (void *)(char *)buffer, (unsigned long int)bufferSize, 0, &clientAddr.m_addr.sa, &clientAddrLen);
      n = (signed int)return_value_recvfrom_2;
      if(!(n == -1))
      {
        const char *LogRequest = "ERROR";
        const char *LogReply = "ERROR";
        unsigned char *UrlRequest = (unsigned char *)(void *)0;
        if(n >= 20)
        {
          unsigned char Opcode = buffer[(signed long int)0];
          unsigned char Version = buffer[(signed long int)1];
          unsigned short int Message_Length = (unsigned short int)(((signed int)((unsigned char *)&buffer[(signed long int)2])[(signed long int)0] << 8) + (signed int)((unsigned char *)&buffer[(signed long int)2])[(signed long int)1]);
          unsigned int Request_Number = (unsigned int)((((signed int)((unsigned char *)&buffer[(signed long int)4])[(signed long int)0] << 8) + (signed int)((unsigned char *)&buffer[(signed long int)4])[(signed long int)1] << 16) + ((signed int)((unsigned char *)&buffer[(signed long int)4] + (signed long int)2)[(signed long int)0] << 8) + (signed int)((unsigned char *)&buffer[(signed long int)4] + (signed long int)2)[(signed long int)1]);
          unsigned char *Payload = &buffer[(signed long int)20];
          buffer[(signed long int)bufferSize] = (unsigned char)0;
          if(bufferSize + -20 >= (signed int)Message_Length)
          {
            if((signed int)Opcode >= 0 && !((signed int)Opcode >= 24))
            {
              if((signed int)Version == 2)
                switch((signed int)Opcode)
                {
                  case 1:
                  {
                    unsigned int UrlRequestSize;
                    UrlRequest = &Payload[(signed long int)4];
                    unsigned long int return_value_strlen_3;
                    return_value_strlen_3=strlen((char *)UrlRequest);
                    UrlRequestSize = (unsigned int)return_value_strlen_3;
                    LogRequest = "ICP_OP_QUERY";
                    if(indexes == ((struct _PT_Indexes *)NULL))
                    {
                      ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)22, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, UrlRequest);
                      LogReply = "ICP_OP_DENIED";
                    }

                    else
                    {
                      return_value_PT_LookupIndex_7=PT_LookupIndex(indexes, (char *)UrlRequest);
                      if(!(return_value_PT_LookupIndex_7 == 0))
                      {
                        ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)2, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, UrlRequest);
                        LogReply = "ICP_OP_HIT";
                      }

                      else
                      {
                        if(UrlRequestSize >= 1u)
                        {
                          if(!((signed int)UrlRequest[(signed long int)(UrlRequestSize + 4294967295u)] == 47))
                          {
                            return_value_strchr_6=strchr((char *)UrlRequest, 63);
                            if(return_value_strchr_6 == ((char *)NULL))
                            {
                              char *UrlRedirect;
                              void *return_value_malloc_4;
                              return_value_malloc_4=malloc((unsigned long int)(UrlRequestSize + (unsigned int)1 + (unsigned int)1));
                              UrlRedirect = (char *)return_value_malloc_4;
                              if(!(UrlRedirect == ((char *)NULL)))
                              {
                                sprintf(UrlRedirect, "%s/", UrlRequest);
                                signed int return_value_PT_LookupIndex_5;
                                return_value_PT_LookupIndex_5=PT_LookupIndex(indexes, UrlRedirect);
                                if(!(return_value_PT_LookupIndex_5 == 0))
                                {
                                  ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)2, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, UrlRequest);
                                  LogReply = "ICP_OP_HIT";
                                  free((void *)UrlRedirect);
                                  break;
                                }

                                free((void *)UrlRedirect);
                              }

                            }

                          }

                        }

                        ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)21, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, UrlRequest);
                        LogReply = "ICP_OP_MISS_NOFETCH";
                      }
                    }
                    break;
                  }
                  case 10:
                  {
                    UrlRequest = &Payload[(signed long int)4];
                    LogRequest = "ICP_OP_QUERY";
                    LogReply = "ICP_OP_QUERY";
                    ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)10, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, UrlRequest);
                    break;
                  }
                  default:
                  {
                    LogRequest = "NOTIMPLEMENTED";
                    LogReply = "ICP_OP_ERR";
                    ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)4, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, (unsigned char *)(void *)0);
                  }
                }

              else
                ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)4, (unsigned char)2, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, (unsigned char *)(void *)0);
            }

          }

          else
            ICP_reply(&clientAddr.m_addr.sa, (signed int)clientAddrLen, soc, (unsigned char)4, Version, (unsigned short int)0, Request_Number, (unsigned int)0, (unsigned int)0, (unsigned int)0, (unsigned char *)(void *)0);
        }

        struct String ip = { .buffer_=(char *)(void *)0, .length_=(unsigned long int)0, .capacity_=(unsigned long int)0 };
        struct SOCaddr serverClient;
        signed int lenServerClient = (signed int)sizeof(struct SOCaddr) /*28ul*/ ;
        do
        {
          unsigned int return_value_SOCaddr_copyaddr__8;
          return_value_SOCaddr_copyaddr__8=SOCaddr_copyaddr_(&serverClient, (const void *)&clientAddr, (const unsigned long int)clientAddrLen, "proxy/proxytrack.c", 1688);
          lenServerClient = (signed int)return_value_SOCaddr_copyaddr__8;
        }
        while((_Bool)0);
        if(lenServerClient >= 1)
          ip=getip(&clientAddr);

        else
          do
          {
            const char *str__ = "unknown";
            if(!(str__ == ((const char *)NULL)))
            {
              unsigned long int size__;
              size__=strlen(str__);
              do
              {
                ip.length_ = (unsigned long int)0;
                do
                {
                  const char *str_mc_ = str__;
                  const unsigned long int size_mc_ = (unsigned long int)size__;
                  do
                  {
                    const unsigned long int capacity_ = (unsigned long int)(ip.length_ + size_mc_ + (unsigned long int)1);
                    while(!(ip.capacity_ >= capacity_))
                    {
                      if(!(ip.capacity_ >= 16ul))
                        ip.capacity_ = (unsigned long int)16;

                      else
                        ip.capacity_ = ip.capacity_ * (unsigned long int)2;
                      void *return_value_realloc_9;
                      return_value_realloc_9=realloc((void *)ip.buffer_, ip.capacity_);
                      ip.buffer_ = (char *)return_value_realloc_9;
                      /* assertion (ip).buffer_ != ((void *)0) */
                      assert(ip.buffer_ != (char *)(void *)0);
                    }
                  }
                  while((_Bool)0);
                  if(size_mc_ >= 1ul)
                  {
                    memcpy((void *)(ip.buffer_ + (signed long int)ip.length_), (const void *)str_mc_, size_mc_);
                    ip.length_ = ip.length_ + size_mc_;
                  }

                  ip.buffer_[(signed long int)ip.length_] = (char)0;
                }
                while((_Bool)0);
              }
              while((_Bool)0);
            }

            else
              do
              {
                ip.length_ = (unsigned long int)0;
                do
                {
                  const unsigned long int proxytrack_start_ICP__1__2__1__2__3__1__2__1__1__capacity_ = (unsigned long int)(ip.length_ + (unsigned long int)0 + (unsigned long int)1);
                  while(!(ip.capacity_ >= proxytrack_start_ICP__1__2__1__2__3__1__2__1__1__capacity_))
                  {
                    if(!(ip.capacity_ >= 16ul))
                      ip.capacity_ = (unsigned long int)16;

                    else
                      ip.capacity_ = ip.capacity_ * (unsigned long int)2;
                    void *return_value_realloc_10;
                    return_value_realloc_10=realloc((void *)ip.buffer_, ip.capacity_);
                    ip.buffer_ = (char *)return_value_realloc_10;
                    /* assertion (ip).buffer_ != ((void *)0) */
                    assert(ip.buffer_ != (char *)(void *)0);
                  }
                }
                while((_Bool)0);
                ip.buffer_[(signed long int)0] = (char)0;
              }
              while((_Bool)0);
          }
          while((_Bool)0);
        proxytrack_print_log("log", "ICP %s %s/%s %s", (const char *)ip.buffer_, LogRequest, LogReply, UrlRequest != ((unsigned char *)NULL) ? (char *)UrlRequest : "-");
        do
        {
          if(!(ip.buffer_ == ((char *)NULL)))
          {
            free((void *)ip.buffer_);
            ip.buffer_ = (char *)(void *)0;
          }

          ip.capacity_ = (unsigned long int)0;
          ip.length_ = (unsigned long int)0;
        }
        while((_Bool)0);
      }

    }
    if(!(soc == -1))
      close(soc);

    free((void *)buffer);
    return 1;
  }
}

// proxytrack_start_ICP_th
// file proxy/proxytrack.c line 1712
static void proxytrack_start_ICP_th(struct _PT_Indexes *indexes, signed int soc)
{
  proxytrack_start_ICP(indexes, soc);
}

// readArcURLRecord
// file proxy/store.c line 1979
static signed int readArcURLRecord(struct _PT_Index__Arc *index)
{
  index->line[(signed long int)0] = (char)0;
  signed int return_value_linput_1;
  return_value_linput_1=linput_link1(index->file, index->line, (signed int)(sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)1));
  if(!(return_value_linput_1 == 0))
    return 0;

  else
    return -1;
}

// scanHostPort
// file proxy/main.c line 48
static signed int scanHostPort(const char *str, char *host, signed int *port)
{
  char *pos;
  pos=strrchr(str, 58);
  if(!(pos == ((char *)NULL)))
  {
    signed int n = (signed int)(pos - str);
    if(!(n >= 256))
    {
      host[(signed long int)0] = (char)0;
      strncat(host, str, (unsigned long int)n);
      signed int return_value_sscanf_1;
      return_value_sscanf_1=sscanf(pos + (signed long int)1, "%d", port);
      if(return_value_sscanf_1 == 1)
        return 1;

    }

  }

  return 0;
}

// set_filetime
// file proxy/proxytrack.h line 378
static signed int set_filetime(const char *file, struct tm *tm_time)
{
  struct utimbuf tim;
  struct timeb B;
  memset((void *)&B, 0, sizeof(struct timeb) /*16ul*/ );
  B.timezone = (signed short int)0;
  ftime(&B);
  signed long int return_value_mktime_1;
  return_value_mktime_1=mktime(tm_time);
  tim.modtime = return_value_mktime_1 - (signed long int)((signed int)B.timezone * 60);
  tim.actime = tim.modtime;
  signed int return_value_utime_2;
  return_value_utime_2=utime(file, &tim);
  return return_value_utime_2;
}

// set_filetime_time_t
// file proxy/proxytrack.h line 394
static signed int set_filetime_time_t(const char *file, signed long int t)
{
  if(!(t == 0l) && !(t == -1l))
  {
    struct tm tm;
    tm=PT_GetTime(t);
    signed int return_value_set_filetime_1;
    return_value_set_filetime_1=set_filetime(file, &tm);
    return return_value_set_filetime_1;
  }

  return -1;
}

// set_lowcase
// file proxy/proxytrack.h line 264
static void set_lowcase(char *s)
{
  signed int i = 0;
  unsigned long int return_value_strlen_1;
  do
  {
    return_value_strlen_1=strlen(s);
    if(i >= (signed int)return_value_strlen_1)
      break;

    if((signed int)s[(signed long int)i] >= 65)
    {
      if(!((signed int)s[(signed long int)i] >= 91))
        s[(signed long int)i] = s[(signed long int)i] + (char)(97 - 65);

    }

    i = i + 1;
  }
  while((_Bool)1);
}

// sig_brpipe
// file proxy/main.c line 43
static void sig_brpipe(signed int code)
{
  ;
}

// skipArcData
// file proxy/store.c line 1915
static signed int skipArcData(struct _IO_FILE *file, const char *line)
{
  signed int jump;
  jump=getArcLength(line);
  if(!(jump == -1))
  {
    signed int return_value_fseek_1;
    return_value_fseek_1=fseek(file, (signed long int)jump, 1);
    if(return_value_fseek_1 == 0)
      return 0;

  }

  return -1;
}

// skipArcNl
// file proxy/store.c line 1908
static signed int skipArcNl(struct _IO_FILE *file)
{
  signed int return_value_fgetc_1;
  return_value_fgetc_1=fgetc(file);
  if(return_value_fgetc_1 == 0x0a)
    return 0;

  else
    return -1;
}

// smallserver_init
// file proxy/proxytrack.c line 299
static signed int smallserver_init(const char *adr, signed int port, signed int family)
{
  struct SOCaddr server;
  do
    SOCaddr_initany_(&server, "proxy/proxytrack.c", 301);
  while((_Bool)0);
  signed int return_value_gethost_7;
  return_value_gethost_7=gethost(adr, &server);
  _Bool tmp_if_expr_3;
  signed int return_value_listen_2;
  if(!(return_value_gethost_7 == 0))
  {
    signed int soc = -1;
    signed int return_value_socket_6;
    return_value_socket_6=socket((signed int)server.m_addr.sa.sa_family, family, 0);
    soc = (signed int)return_value_socket_6;
    if(!(soc == -1))
    {
      do
      {
        unsigned short int *return_value_SOCaddr_sinport__1;
        return_value_SOCaddr_sinport__1=SOCaddr_sinport_(&server, "proxy/proxytrack.c", 308);
        *return_value_SOCaddr_sinport__1=htons((unsigned short int)port);
      }
      while((_Bool)0);
      unsigned int return_value_SOCaddr_size__4;
      return_value_SOCaddr_size__4=SOCaddr_size_(&server, "proxy/proxytrack.c", 309);
      signed int return_value_bind_5;
      return_value_bind_5=bind(soc, &server.m_addr.sa, return_value_SOCaddr_size__4);
      if(return_value_bind_5 == 0)
      {
        if(!(family == 1))
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_listen_2=listen(soc, 10);
          tmp_if_expr_3 = return_value_listen_2 >= 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          return soc;

        else
        {
          close(soc);
          soc = -1;
        }
      }

      else
      {
        close(soc);
        soc = -1;
      }
    }

  }

  return -1;
}

// startThread
// file proxy/proxytrack.c line 1413
static signed int startThread(void * (*funct)(void *), void *param)
{
  if(!(param == NULL))
  {
    unsigned long int handle = (unsigned long int)0;
    signed int retcode;
    retcode=pthread_create(&handle, (const union pthread_attr_t *)(void *)0, funct, param);
    if(!(retcode == 0))
    {
      free(param);
      return 0;
    }

    else
    {
      pthread_detach(handle);
      return 1;
    }
  }

  else
    return 0;
}

// strchr_stop
// file proxy/store.c line 417
static char * strchr_stop(char *str, char c, char stop)
{
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  do
  {
    if(!((signed int)*str == 0))
      tmp_if_expr_1 = *str != stop ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = *str != c ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    str = str + 1l;
  }
  while((_Bool)1);
  if(*str == c)
    return str;

  else
    return (char *)(void *)0;
}

// strcmpcasenosensitive_internal
// file minizip/unzip.c line 349
static signed int strcmpcasenosensitive_internal(const char *fileName1, const char *fileName2)
{
  const char *tmp_post_1;
  const char *tmp_post_2;
  do
  {
    char c1;
    tmp_post_1 = fileName1;
    fileName1 = fileName1 + 1l;
    c1 = *tmp_post_1;
    char c2;
    tmp_post_2 = fileName2;
    fileName2 = fileName2 + 1l;
    c2 = *tmp_post_2;
    if((signed int)c1 >= 97 && !((signed int)c1 >= 123))
      c1 = c1 - (char)0x20;

    if((signed int)c2 >= 97 && !((signed int)c2 >= 123))
      c2 = c2 - (char)0x20;

    if((signed int)c1 == 0)
      return (signed int)c2 == 0 ? 0 : -1;

    if((signed int)c2 == 0)
      return 1;

    if(!((signed int)c1 >= (signed int)c2))
      return -1;

    if(!((signed int)c2 >= (signed int)c1))
      return 1;

  }
  while((_Bool)1);
}

// strfield
// file ./htslib.h line 431
static signed int strfield(const char *f, const char *s)
{
  signed int r = 0;
  _Bool tmp_if_expr_1;
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  signed int tmp_if_expr_4;
  do
  {
    if((signed int)*f >= 97)
      tmp_if_expr_1 = (signed int)*f <= 122 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (signed int)*f - (97 - 65);

    else
      tmp_if_expr_2 = (signed int)*f;
    if((signed int)*s >= 97)
      tmp_if_expr_3 = (signed int)*s <= 122 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (signed int)*s - (97 - 65);

    else
      tmp_if_expr_4 = (signed int)*s;
    if(!(tmp_if_expr_2 == tmp_if_expr_4))
      break;

    if((signed int)*f == 0)
      break;

    if((signed int)*s == 0)
      break;

    f = f + 1l;
    s = s + 1l;
    r = r + 1;
  }
  while((_Bool)1);
  if((signed int)*s == 0)
    return r;

  else
    return 0;
}

// strfield_link1
// file ./htslib.h line 431
static signed int strfield_link1(const char *f_link1, const char *s_link1)
{
  signed int r_link1 = 0;
  _Bool tmp_if_expr_1_link1;
  signed int tmp_if_expr_2_link1;
  _Bool tmp_if_expr_3_link1;
  signed int tmp_if_expr_4_link1;
  do
  {
    if((signed int)*f_link1 >= 97)
      tmp_if_expr_1_link1 = (signed int)*f_link1 <= 122 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1_link1 = (_Bool)0;
    if(tmp_if_expr_1_link1)
      tmp_if_expr_2_link1 = (signed int)*f_link1 - (97 - 65);

    else
      tmp_if_expr_2_link1 = (signed int)*f_link1;
    if((signed int)*s_link1 >= 97)
      tmp_if_expr_3_link1 = (signed int)*s_link1 <= 122 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3_link1 = (_Bool)0;
    if(tmp_if_expr_3_link1)
      tmp_if_expr_4_link1 = (signed int)*s_link1 - (97 - 65);

    else
      tmp_if_expr_4_link1 = (signed int)*s_link1;
    if(!(tmp_if_expr_2_link1 == tmp_if_expr_4_link1))
      break;

    if((signed int)*f_link1 == 0)
      break;

    if((signed int)*s_link1 == 0)
      break;

    f_link1 = f_link1 + 1l;
    s_link1 = s_link1 + 1l;
    r_link1 = r_link1 + 1;
  }
  while((_Bool)1);
  if((signed int)*s_link1 == 0)
    return r_link1;

  else
    return 0;
}

// strrchr_limit
// file proxy/proxytrack.h line 184
static const char * strrchr_limit(const char *s, char c, const char *limit)
{
  if(limit == ((const char *)NULL))
  {
    char *p;
    p=strrchr(s, (signed int)c);
    return p != ((char *)NULL) ? p + (signed long int)1 : (char *)(void *)0;
  }

  else
  {
    char *a = (char *)(void *)0;
    char *strrchr_limit__1__2__p;
    do
    {
      strrchr_limit__1__2__p=strchr(a != ((char *)NULL) ? a : s, (signed int)c);
      if(strrchr_limit__1__2__p == ((char *)NULL) || strrchr_limit__1__2__p >= limit)
        return a;

      a = strrchr_limit__1__2__p + (signed long int)1;
    }
    while((_Bool)1);
  }
}

// strrchr_limit_link1
// file proxy/proxytrack.h line 184
static const char * strrchr_limit_link1(const char *s_link1, char c_link1, const char *limit_link1)
{
  if(limit_link1 == ((const char *)NULL))
  {
    char *strrchr_limit__1__1__p_link1;
    strrchr_limit__1__1__p_link1=strrchr(s_link1, (signed int)c_link1);
    return strrchr_limit__1__1__p_link1 != ((char *)NULL) ? strrchr_limit__1__1__p_link1 + (signed long int)1 : (char *)(void *)0;
  }

  else
  {
    char *a_link1 = (char *)(void *)0;
    char *p_link1;
    do
    {
      p_link1=strchr(a_link1 != ((char *)NULL) ? a_link1 : s_link1, (signed int)c_link1);
      if(p_link1 == ((char *)NULL) || p_link1 >= limit_link1)
        return a_link1;

      a_link1 = p_link1 + (signed long int)1;
    }
    while((_Bool)1);
  }
}

// unz64local_CheckCurrentFileCoherencyHeader
// file minizip/unzip.c line 1385
static signed int unz64local_CheckCurrentFileCoherencyHeader(struct anonymous_0 *s, unsigned int *piSizeVar, unsigned long long int *poffset_local_extrafield, unsigned int *psize_local_extrafield)
{
  unsigned long int uMagic;
  unsigned long int uData;
  unsigned long int uFlags;
  unsigned long int size_filename;
  unsigned long int size_extra_field;
  signed int err = 0;
  *piSizeVar = (unsigned int)0;
  *poffset_local_extrafield = (unsigned long long int)0;
  *psize_local_extrafield = (unsigned int)0;
  signed long int return_value_call_zseek64_1;
  return_value_call_zseek64_1=call_zseek64(&s->z_filefunc, s->filestream, s->cur_file_info_internal.offset_curfile + s->byte_before_the_zipfile, 0);
  if(!(return_value_call_zseek64_1 == 0l))
    return -1;

  else
  {
    if(err == 0)
    {
      signed int return_value_unz64local_getLong_2;
      return_value_unz64local_getLong_2=unz64local_getLong(&s->z_filefunc, s->filestream, &uMagic);
      if(!(return_value_unz64local_getLong_2 == 0))
        err = -1;

      else
        if(!(uMagic == 67324752ul))
          err = -103;

    }

    signed int return_value_unz64local_getShort_3;
    return_value_unz64local_getShort_3=unz64local_getShort(&s->z_filefunc, s->filestream, &uData);
    if(!(return_value_unz64local_getShort_3 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_4;
    return_value_unz64local_getShort_4=unz64local_getShort(&s->z_filefunc, s->filestream, &uFlags);
    if(!(return_value_unz64local_getShort_4 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_5;
    return_value_unz64local_getShort_5=unz64local_getShort(&s->z_filefunc, s->filestream, &uData);
    if(!(return_value_unz64local_getShort_5 == 0))
      err = -1;

    else
      if(err == 0)
      {
        if(!(uData == s->cur_file_info.compression_method))
          err = -103;

      }

    if(err == 0)
    {
      if(!(s->cur_file_info.compression_method == 0ul))
      {
        if(!(s->cur_file_info.compression_method == 12ul))
        {
          if(!(s->cur_file_info.compression_method == 8ul))
            err = -103;

        }

      }

    }

    signed int return_value_unz64local_getLong_6;
    return_value_unz64local_getLong_6=unz64local_getLong(&s->z_filefunc, s->filestream, &uData);
    if(!(return_value_unz64local_getLong_6 == 0))
      err = -1;

    signed int return_value_unz64local_getLong_7;
    return_value_unz64local_getLong_7=unz64local_getLong(&s->z_filefunc, s->filestream, &uData);
    if(!(return_value_unz64local_getLong_7 == 0))
      err = -1;

    else
      if(err == 0)
      {
        if(!(uData == s->cur_file_info.crc))
        {
          if((8ul & uFlags) == 0ul)
            err = -103;

        }

      }

    signed int return_value_unz64local_getLong_8;
    return_value_unz64local_getLong_8=unz64local_getLong(&s->z_filefunc, s->filestream, &uData);
    if(!(return_value_unz64local_getLong_8 == 0))
      err = -1;

    else
      if(err == 0 && !(uData == 4294967295ul))
      {
        if(!(uData == s->cur_file_info.compressed_size))
        {
          if((8ul & uFlags) == 0ul)
            err = -103;

        }

      }

    signed int return_value_unz64local_getLong_9;
    return_value_unz64local_getLong_9=unz64local_getLong(&s->z_filefunc, s->filestream, &uData);
    if(!(return_value_unz64local_getLong_9 == 0))
      err = -1;

    else
      if(err == 0 && !(uData == 4294967295ul))
      {
        if(!(uData == s->cur_file_info.uncompressed_size))
        {
          if((8ul & uFlags) == 0ul)
            err = -103;

        }

      }

    signed int return_value_unz64local_getShort_10;
    return_value_unz64local_getShort_10=unz64local_getShort(&s->z_filefunc, s->filestream, &size_filename);
    if(!(return_value_unz64local_getShort_10 == 0))
      err = -1;

    else
      if(err == 0)
      {
        if(!(size_filename == s->cur_file_info.size_filename))
          err = -103;

      }

    *piSizeVar = *piSizeVar + (unsigned int)size_filename;
    signed int return_value_unz64local_getShort_11;
    return_value_unz64local_getShort_11=unz64local_getShort(&s->z_filefunc, s->filestream, &size_extra_field);
    if(!(return_value_unz64local_getShort_11 == 0))
      err = -1;

    *poffset_local_extrafield = s->cur_file_info_internal.offset_curfile + (unsigned long int)0x1e + size_filename;
    *psize_local_extrafield = (unsigned int)size_extra_field;
    *piSizeVar = *piSizeVar + (unsigned int)size_extra_field;
    return err;
  }
}

// unz64local_DosDateToTmuDate
// file minizip/unzip.c line 852
static void unz64local_DosDateToTmuDate(unsigned long long int ulDosDate, struct tm_unz_s *ptm)
{
  unsigned long long int uDate = (unsigned long long int)(ulDosDate >> 16);
  ptm->tm_mday = (unsigned int)(uDate & (unsigned long int)0x1f);
  ptm->tm_mon = (unsigned int)((uDate & (unsigned long int)0x1E0) / (unsigned long int)0x20 - (unsigned long int)1);
  ptm->tm_year = (unsigned int)((uDate & (unsigned long int)0x0FE00) / (unsigned long int)0x0200 + (unsigned long int)1980);
  ptm->tm_hour = (unsigned int)((ulDosDate & (unsigned long int)0xF800) / (unsigned long int)0x800);
  ptm->tm_min = (unsigned int)((ulDosDate & (unsigned long int)0x7E0) / (unsigned long int)0x20);
  ptm->tm_sec = (unsigned int)((unsigned long int)2 * (ulDosDate & (unsigned long int)0x1f));
}

// unz64local_GetCurrentFileInfoInternal
// file minizip/unzip.c line 879
static signed int unz64local_GetCurrentFileInfoInternal(void *file, struct unz_file_info64_s *pfile_info, struct unz_file_info64_internal_s *pfile_info_internal, char *szFileName, unsigned long int fileNameBufferSize, void *extraField, unsigned long int extraFieldBufferSize, char *szComment, unsigned long int commentBufferSize)
{
  struct anonymous_0 *s;
  struct unz_file_info64_s file_info;
  struct unz_file_info64_internal_s file_info_internal;
  signed int err = 0;
  unsigned long int uMagic;
  signed long int lSeek = (signed long int)0;
  unsigned long int unz64local_GetCurrentFileInfoInternal__1__uL;
  unsigned long int return_value;
  unsigned long int return_value_1;
  unsigned long int return_value_2;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    signed long int return_value_call_zseek64_1;
    return_value_call_zseek64_1=call_zseek64(&s->z_filefunc, s->filestream, s->pos_in_central_dir + s->byte_before_the_zipfile, 0);
    if(!(return_value_call_zseek64_1 == 0l))
      err = -1;

    if(err == 0)
    {
      signed int return_value_unz64local_getLong_2;
      return_value_unz64local_getLong_2=unz64local_getLong(&s->z_filefunc, s->filestream, &uMagic);
      if(!(return_value_unz64local_getLong_2 == 0))
        err = -1;

      else
        if(!(uMagic == 33639248ul))
          err = -103;

    }

    signed int return_value_unz64local_getShort_3;
    return_value_unz64local_getShort_3=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.version);
    if(!(return_value_unz64local_getShort_3 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_4;
    return_value_unz64local_getShort_4=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.version_needed);
    if(!(return_value_unz64local_getShort_4 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_5;
    return_value_unz64local_getShort_5=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.flag);
    if(!(return_value_unz64local_getShort_5 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_6;
    return_value_unz64local_getShort_6=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.compression_method);
    if(!(return_value_unz64local_getShort_6 == 0))
      err = -1;

    signed int return_value_unz64local_getLong_7;
    return_value_unz64local_getLong_7=unz64local_getLong(&s->z_filefunc, s->filestream, &file_info.dosDate);
    if(!(return_value_unz64local_getLong_7 == 0))
      err = -1;

    unz64local_DosDateToTmuDate(file_info.dosDate, &file_info.tmu_date);
    signed int return_value_unz64local_getLong_8;
    return_value_unz64local_getLong_8=unz64local_getLong(&s->z_filefunc, s->filestream, &file_info.crc);
    if(!(return_value_unz64local_getLong_8 == 0))
      err = -1;

    signed int return_value_unz64local_getLong_9;
    return_value_unz64local_getLong_9=unz64local_getLong(&s->z_filefunc, s->filestream, &unz64local_GetCurrentFileInfoInternal__1__uL);
    if(!(return_value_unz64local_getLong_9 == 0))
      err = -1;

    file_info.compressed_size = unz64local_GetCurrentFileInfoInternal__1__uL;
    signed int return_value_unz64local_getLong_10;
    return_value_unz64local_getLong_10=unz64local_getLong(&s->z_filefunc, s->filestream, &unz64local_GetCurrentFileInfoInternal__1__uL);
    if(!(return_value_unz64local_getLong_10 == 0))
      err = -1;

    file_info.uncompressed_size = unz64local_GetCurrentFileInfoInternal__1__uL;
    signed int return_value_unz64local_getShort_11;
    return_value_unz64local_getShort_11=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.size_filename);
    if(!(return_value_unz64local_getShort_11 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_12;
    return_value_unz64local_getShort_12=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.size_file_extra);
    if(!(return_value_unz64local_getShort_12 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_13;
    return_value_unz64local_getShort_13=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.size_file_comment);
    if(!(return_value_unz64local_getShort_13 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_14;
    return_value_unz64local_getShort_14=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.disk_num_start);
    if(!(return_value_unz64local_getShort_14 == 0))
      err = -1;

    signed int return_value_unz64local_getShort_15;
    return_value_unz64local_getShort_15=unz64local_getShort(&s->z_filefunc, s->filestream, &file_info.internal_fa);
    if(!(return_value_unz64local_getShort_15 == 0))
      err = -1;

    signed int return_value_unz64local_getLong_16;
    return_value_unz64local_getLong_16=unz64local_getLong(&s->z_filefunc, s->filestream, &file_info.external_fa);
    if(!(return_value_unz64local_getLong_16 == 0))
      err = -1;

    signed int return_value_unz64local_getLong_17;
    return_value_unz64local_getLong_17=unz64local_getLong(&s->z_filefunc, s->filestream, &unz64local_GetCurrentFileInfoInternal__1__uL);
    if(!(return_value_unz64local_getLong_17 == 0))
      err = -1;

    file_info_internal.offset_curfile = unz64local_GetCurrentFileInfoInternal__1__uL;
    lSeek = lSeek + (signed long int)file_info.size_filename;
    if(err == 0 && !(szFileName == ((char *)NULL)))
    {
      unsigned long int uSizeRead;
      if(!(file_info.size_filename >= fileNameBufferSize))
      {
        szFileName[(signed long int)file_info.size_filename] = (char)0;
        uSizeRead = file_info.size_filename;
      }

      else
        uSizeRead = fileNameBufferSize;
      if(file_info.size_filename >= 1ul && fileNameBufferSize >= 1ul)
      {
        return_value=s->z_filefunc.zfile_func64.zread_file(s->z_filefunc.zfile_func64.opaque, s->filestream, (void *)szFileName, uSizeRead);
        if(!(return_value == uSizeRead))
          err = -1;

      }

      lSeek = lSeek - (signed long int)uSizeRead;
    }

    if(err == 0 && !(extraField == NULL))
    {
      unsigned long long int unz64local_GetCurrentFileInfoInternal__1__3__uSizeRead;
      if(!(file_info.size_file_extra >= extraFieldBufferSize))
        unz64local_GetCurrentFileInfoInternal__1__3__uSizeRead = file_info.size_file_extra;

      else
        unz64local_GetCurrentFileInfoInternal__1__3__uSizeRead = extraFieldBufferSize;
      if(!(lSeek == 0l))
      {
        signed long int return_value_call_zseek64_18;
        return_value_call_zseek64_18=call_zseek64(&s->z_filefunc, s->filestream, (unsigned long long int)lSeek, 1);
        if(return_value_call_zseek64_18 == 0l)
          lSeek = (signed long int)0;

        else
          err = -1;
      }

      if(file_info.size_file_extra >= 1ul && extraFieldBufferSize >= 1ul)
      {
        return_value_1=s->z_filefunc.zfile_func64.zread_file(s->z_filefunc.zfile_func64.opaque, s->filestream, extraField, (unsigned long int)unz64local_GetCurrentFileInfoInternal__1__3__uSizeRead);
        if(!(return_value_1 == unz64local_GetCurrentFileInfoInternal__1__3__uSizeRead))
          err = -1;

      }

      lSeek = lSeek + (signed long int)(file_info.size_file_extra - (unsigned long int)unz64local_GetCurrentFileInfoInternal__1__3__uSizeRead);
    }

    else
      lSeek = lSeek + (signed long int)file_info.size_file_extra;
    if(err == 0 && !(file_info.size_file_extra == 0ul))
    {
      unsigned long int acc = (unsigned long int)0;
      lSeek = lSeek - (signed long int)file_info.size_file_extra;
      if(!(lSeek == 0l))
      {
        signed long int return_value_call_zseek64_19;
        return_value_call_zseek64_19=call_zseek64(&s->z_filefunc, s->filestream, (unsigned long long int)lSeek, 1);
        if(return_value_call_zseek64_19 == 0l)
          lSeek = (signed long int)0;

        else
          err = -1;
      }

      while(!(acc >= file_info.size_file_extra))
      {
        unsigned long int headerId;
        unsigned long int dataSize;
        signed int return_value_unz64local_getShort_20;
        return_value_unz64local_getShort_20=unz64local_getShort(&s->z_filefunc, s->filestream, &headerId);
        if(!(return_value_unz64local_getShort_20 == 0))
          err = -1;

        signed int return_value_unz64local_getShort_21;
        return_value_unz64local_getShort_21=unz64local_getShort(&s->z_filefunc, s->filestream, &dataSize);
        if(!(return_value_unz64local_getShort_21 == 0))
          err = -1;

        if(headerId == 1ul)
        {
          unsigned long int uL;
          if(file_info.uncompressed_size == 4294967295ul)
          {
            signed int return_value_unz64local_getLong64_22;
            return_value_unz64local_getLong64_22=unz64local_getLong64(&s->z_filefunc, s->filestream, &file_info.uncompressed_size);
            if(!(return_value_unz64local_getLong64_22 == 0))
              err = -1;

          }

          if(file_info.compressed_size == 4294967295ul)
          {
            signed int return_value_unz64local_getLong64_23;
            return_value_unz64local_getLong64_23=unz64local_getLong64(&s->z_filefunc, s->filestream, &file_info.compressed_size);
            if(!(return_value_unz64local_getLong64_23 == 0))
              err = -1;

          }

          if(file_info_internal.offset_curfile == 4294967295ul)
          {
            signed int return_value_unz64local_getLong64_24;
            return_value_unz64local_getLong64_24=unz64local_getLong64(&s->z_filefunc, s->filestream, &file_info_internal.offset_curfile);
            if(!(return_value_unz64local_getLong64_24 == 0))
              err = -1;

          }

          if(file_info.disk_num_start == 4294967295ul)
          {
            signed int return_value_unz64local_getLong_25;
            return_value_unz64local_getLong_25=unz64local_getLong(&s->z_filefunc, s->filestream, &uL);
            if(!(return_value_unz64local_getLong_25 == 0))
              err = -1;

          }

        }

        else
        {
          signed long int return_value_call_zseek64_26;
          return_value_call_zseek64_26=call_zseek64(&s->z_filefunc, s->filestream, dataSize, 1);
          if(!(return_value_call_zseek64_26 == 0l))
            err = -1;

        }
        acc = acc + (unsigned long int)(2 + 2) + dataSize;
      }
    }

    if(err == 0 && !(szComment == ((char *)NULL)))
    {
      unsigned long int unz64local_GetCurrentFileInfoInternal__1__5__uSizeRead;
      if(!(file_info.size_file_comment >= commentBufferSize))
      {
        szComment[(signed long int)file_info.size_file_comment] = (char)0;
        unz64local_GetCurrentFileInfoInternal__1__5__uSizeRead = file_info.size_file_comment;
      }

      else
        unz64local_GetCurrentFileInfoInternal__1__5__uSizeRead = commentBufferSize;
      if(!(lSeek == 0l))
      {
        signed long int return_value_call_zseek64_27;
        return_value_call_zseek64_27=call_zseek64(&s->z_filefunc, s->filestream, (unsigned long long int)lSeek, 1);
        if(return_value_call_zseek64_27 == 0l)
          lSeek = (signed long int)0;

        else
          err = -1;
      }

      if(file_info.size_file_comment >= 1ul && commentBufferSize >= 1ul)
      {
        return_value_2=s->z_filefunc.zfile_func64.zread_file(s->z_filefunc.zfile_func64.opaque, s->filestream, (void *)szComment, unz64local_GetCurrentFileInfoInternal__1__5__uSizeRead);
        if(!(return_value_2 == unz64local_GetCurrentFileInfoInternal__1__5__uSizeRead))
          err = -1;

      }

      lSeek = lSeek + (signed long int)(file_info.size_file_comment - unz64local_GetCurrentFileInfoInternal__1__5__uSizeRead);
    }

    else
      lSeek = lSeek + (signed long int)file_info.size_file_comment;
    if(err == 0 && !(pfile_info == ((struct unz_file_info64_s *)NULL)))
      *pfile_info = file_info;

    if(err == 0 && !(pfile_info_internal == ((struct unz_file_info64_internal_s *)NULL)))
      *pfile_info_internal = file_info_internal;

    return err;
  }
}

// unz64local_SearchCentralDir
// file minizip/unzip.c line 413
static unsigned long long int unz64local_SearchCentralDir(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream)
{
  unsigned char *buf;
  unsigned long long int uSizeFile;
  unsigned long long int uBackRead;
  unsigned long long int uMaxBack = (unsigned long long int)0xffff;
  unsigned long long int uPosFound = (unsigned long long int)0;
  signed long int return_value_call_zseek64_1;
  return_value_call_zseek64_1=call_zseek64(&(*pzlib_filefunc_def), filestream, (unsigned long long int)0, 2);
  signed int tmp_post_4;
  if(!(return_value_call_zseek64_1 == 0l))
    return (unsigned long long int)0;

  else
  {
    uSizeFile=call_ztell64(&(*pzlib_filefunc_def), filestream);
    if(!(uSizeFile >= uMaxBack))
      uMaxBack = uSizeFile;

    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(0x400 + 4));
    buf = (unsigned char *)return_value_malloc_2;
    if(buf == ((unsigned char *)NULL))
      return (unsigned long long int)0;

    else
    {
      uBackRead = (unsigned long long int)4;
      if(!(uBackRead >= uMaxBack))
      {
        unsigned long int uReadSize;
        unsigned long long int uReadPos;
        signed int i;
        if(!(uMaxBack >= 1024ul + uBackRead))
          uBackRead = uMaxBack;

        else
          uBackRead = uBackRead + (unsigned long long int)0x400;
        uReadPos = uSizeFile - uBackRead;
        uReadSize = (unsigned long int)(0x400 + 4) < uSizeFile - uReadPos ? (unsigned long int)(0x400 + 4) : (unsigned long int)(uSizeFile - uReadPos);
        signed long int return_value_call_zseek64_3;
        return_value_call_zseek64_3=call_zseek64(&(*pzlib_filefunc_def), filestream, uReadPos, 0);
        if(return_value_call_zseek64_3 == 0l)
        {
          unsigned long int return_value;
          return_value=pzlib_filefunc_def->zfile_func64.zread_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (void *)buf, uReadSize);
          if(return_value == uReadSize)
          {
            i = (signed int)uReadSize - 3;
            tmp_post_4 = i;
            i = i - 1;
            if(tmp_post_4 >= 1)
            {
              if((signed int)buf[(signed long int)i] == 0x50)
                uPosFound = uReadPos + (unsigned long int)i;

            }

          }

        }

      }

      if(!(buf == ((unsigned char *)NULL)))
        free((void *)buf);

      return uPosFound;
    }
  }
}

// unz64local_SearchCentralDir64
// file minizip/unzip.c line 478
static unsigned long long int unz64local_SearchCentralDir64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream)
{
  unsigned char *buf;
  unsigned long long int uSizeFile;
  unsigned long long int uBackRead;
  unsigned long long int uMaxBack = (unsigned long long int)0xffff;
  unsigned long long int uPosFound = (unsigned long long int)0;
  unsigned long int uL;
  unsigned long long int relativeOffset;
  signed long int return_value_call_zseek64_1;
  return_value_call_zseek64_1=call_zseek64(&(*pzlib_filefunc_def), filestream, (unsigned long long int)0, 2);
  signed int tmp_post_4;
  if(!(return_value_call_zseek64_1 == 0l))
    return (unsigned long long int)0;

  else
  {
    uSizeFile=call_ztell64(&(*pzlib_filefunc_def), filestream);
    if(!(uSizeFile >= uMaxBack))
      uMaxBack = uSizeFile;

    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(0x400 + 4));
    buf = (unsigned char *)return_value_malloc_2;
    if(buf == ((unsigned char *)NULL))
      return (unsigned long long int)0;

    else
    {
      uBackRead = (unsigned long long int)4;
      if(!(uBackRead >= uMaxBack))
      {
        unsigned long int uReadSize;
        unsigned long long int uReadPos;
        signed int i;
        if(!(uMaxBack >= 1024ul + uBackRead))
          uBackRead = uMaxBack;

        else
          uBackRead = uBackRead + (unsigned long long int)0x400;
        uReadPos = uSizeFile - uBackRead;
        uReadSize = (unsigned long int)(0x400 + 4) < uSizeFile - uReadPos ? (unsigned long int)(0x400 + 4) : (unsigned long int)(uSizeFile - uReadPos);
        signed long int return_value_call_zseek64_3;
        return_value_call_zseek64_3=call_zseek64(&(*pzlib_filefunc_def), filestream, uReadPos, 0);
        if(return_value_call_zseek64_3 == 0l)
        {
          unsigned long int return_value;
          return_value=pzlib_filefunc_def->zfile_func64.zread_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (void *)buf, uReadSize);
          if(return_value == uReadSize)
          {
            i = (signed int)uReadSize - 3;
            tmp_post_4 = i;
            i = i - 1;
            if(tmp_post_4 >= 1)
            {
              if((signed int)buf[(signed long int)i] == 0x50)
                uPosFound = uReadPos + (unsigned long int)i;

            }

          }

        }

      }

      if(!(buf == ((unsigned char *)NULL)))
        free((void *)buf);

      if(uPosFound == 0ul)
        return (unsigned long long int)0;

      else
      {
        signed long int return_value_call_zseek64_5;
        return_value_call_zseek64_5=call_zseek64(&(*pzlib_filefunc_def), filestream, uPosFound, 0);
        if(!(return_value_call_zseek64_5 == 0l))
          return (unsigned long long int)0;

        else
        {
          signed int return_value_unz64local_getLong_6;
          return_value_unz64local_getLong_6=unz64local_getLong(pzlib_filefunc_def, filestream, &uL);
          if(!(return_value_unz64local_getLong_6 == 0))
            return (unsigned long long int)0;

          else
          {
            signed int return_value_unz64local_getLong_7;
            return_value_unz64local_getLong_7=unz64local_getLong(pzlib_filefunc_def, filestream, &uL);
            if(!(return_value_unz64local_getLong_7 == 0))
              return (unsigned long long int)0;

            else
              if(!(uL == 0ul))
                return (unsigned long long int)0;

              else
              {
                signed int return_value_unz64local_getLong64_8;
                return_value_unz64local_getLong64_8=unz64local_getLong64(pzlib_filefunc_def, filestream, &relativeOffset);
                if(!(return_value_unz64local_getLong64_8 == 0))
                  return (unsigned long long int)0;

                else
                {
                  signed int return_value_unz64local_getLong_9;
                  return_value_unz64local_getLong_9=unz64local_getLong(pzlib_filefunc_def, filestream, &uL);
                  if(!(return_value_unz64local_getLong_9 == 0))
                    return (unsigned long long int)0;

                  else
                    if(!(uL == 1ul))
                      return (unsigned long long int)0;

                    else
                    {
                      signed long int return_value_call_zseek64_10;
                      return_value_call_zseek64_10=call_zseek64(&(*pzlib_filefunc_def), filestream, relativeOffset, 0);
                      if(!(return_value_call_zseek64_10 == 0l))
                        return (unsigned long long int)0;

                      else
                      {
                        signed int return_value_unz64local_getLong_11;
                        return_value_unz64local_getLong_11=unz64local_getLong(pzlib_filefunc_def, filestream, &uL);
                        if(!(return_value_unz64local_getLong_11 == 0))
                          return (unsigned long long int)0;

                        else
                          if(!(uL == 101075792ul))
                            return (unsigned long long int)0;

                          else
                            return relativeOffset;
                      }
                    }
                }
              }
          }
        }
      }
    }
  }
}

// unz64local_getByte
// file minizip/unzip.c line 212
static signed int unz64local_getByte(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, signed int *pi)
{
  unsigned char c;
  signed int err;
  unsigned long int return_value;
  return_value=pzlib_filefunc_def->zfile_func64.zread_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (void *)&c, (unsigned long int)1);
  err = (signed int)return_value;
  if(err == 1)
  {
    *pi = (signed int)c;
    return 0;
  }

  else
  {
    signed int return_value_1;
    return_value_1=pzlib_filefunc_def->zfile_func64.zerror_file(pzlib_filefunc_def->zfile_func64.opaque, filestream);
    if(!(return_value_1 == 0))
      return -1;

    else
      return 0;
  }
}

// unz64local_getLong
// file minizip/unzip.c line 266
static signed int unz64local_getLong(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX)
{
  unsigned long int x;
  signed int i = 0;
  signed int err;
  err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  x = (unsigned long int)i;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long int)i << 8;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long int)i << 16;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long int)i << 24);
  if(err == 0)
    *pX = x;

  else
    *pX = (unsigned long int)0;
  return err;
}

// unz64local_getLong64
// file minizip/unzip.c line 302
static signed int unz64local_getLong64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long long int *pX)
{
  unsigned long long int x;
  signed int i = 0;
  signed int err;
  err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  x = (unsigned long long int)i;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 8;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 16;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 24;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 32;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 40;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 48;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long long int)i << 56;
  if(err == 0)
    *pX = x;

  else
    *pX = (unsigned long long int)0;
  return err;
}

// unz64local_getShort
// file minizip/unzip.c line 239
static signed int unz64local_getShort(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX)
{
  unsigned long int x;
  signed int i = 0;
  signed int err;
  err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  x = (unsigned long int)i;
  if(err == 0)
    err=unz64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x | (unsigned long int)i << 8;
  if(err == 0)
    *pX = x;

  else
    *pX = (unsigned long int)0;
  return err;
}

// unzClose
// file proxy/../minizip/unzip.h line 198
extern signed int unzClose(void *file)
{
  struct anonymous_0 *s;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    if(!(s->pfile_in_zip_read == ((struct anonymous *)NULL)))
      unzCloseCurrentFile(file);

    s->z_filefunc.zfile_func64.zclose_file(s->z_filefunc.zfile_func64.opaque, s->filestream);
    if(!(s == ((struct anonymous_0 *)NULL)))
      free((void *)s);

    return 0;
  }
}

// unzCloseCurrentFile
// file proxy/../minizip/unzip.h line 373
extern signed int unzCloseCurrentFile(void *file)
{
  signed int err = 0;
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return -102;

    else
    {
      if(pfile_in_zip_read_info->rest_read_uncompressed == 0ul)
      {
        if(pfile_in_zip_read_info->raw == 0)
        {
          if(!(pfile_in_zip_read_info->crc32 == pfile_in_zip_read_info->crc32_wait))
            err = -105;

        }

      }

      if(!(pfile_in_zip_read_info->read_buffer == ((char *)NULL)))
        free((void *)pfile_in_zip_read_info->read_buffer);

      pfile_in_zip_read_info->read_buffer = (char *)(void *)0;
      if(pfile_in_zip_read_info->stream_initialised == 8ul)
        inflateEnd(&pfile_in_zip_read_info->stream);

      pfile_in_zip_read_info->stream_initialised = (unsigned long int)0;
      if(!(pfile_in_zip_read_info == ((struct anonymous *)NULL)))
        free((void *)pfile_in_zip_read_info);

      s->pfile_in_zip_read = (struct anonymous *)(void *)0;
      return err;
    }
  }
}

// unzGetCurrentFileInfo
// file proxy/../minizip/unzip.h line 297
extern signed int unzGetCurrentFileInfo(void *file, struct unz_file_info_s *pfile_info, char *szFileName, unsigned long int fileNameBufferSize, void *extraField, unsigned long int extraFieldBufferSize, char *szComment, unsigned long int commentBufferSize)
{
  signed int err;
  struct unz_file_info64_s file_info64;
  err=unz64local_GetCurrentFileInfoInternal(file, &file_info64, (struct unz_file_info64_internal_s *)(void *)0, szFileName, fileNameBufferSize, extraField, extraFieldBufferSize, szComment, commentBufferSize);
  if(err == 0 && !(pfile_info == ((struct unz_file_info_s *)NULL)))
  {
    pfile_info->version = file_info64.version;
    pfile_info->version_needed = file_info64.version_needed;
    pfile_info->flag = file_info64.flag;
    pfile_info->compression_method = file_info64.compression_method;
    pfile_info->dosDate = file_info64.dosDate;
    pfile_info->crc = file_info64.crc;
    pfile_info->size_filename = file_info64.size_filename;
    pfile_info->size_file_extra = file_info64.size_file_extra;
    pfile_info->size_file_comment = file_info64.size_file_comment;
    pfile_info->disk_num_start = file_info64.disk_num_start;
    pfile_info->internal_fa = file_info64.internal_fa;
    pfile_info->external_fa = file_info64.external_fa;
    pfile_info->tmu_date = file_info64.tmu_date;
    pfile_info->compressed_size = (unsigned long int)file_info64.compressed_size;
    pfile_info->uncompressed_size = (unsigned long int)file_info64.uncompressed_size;
  }

  return err;
}

// unzGetCurrentFileInfo64
// file minizip/unzip.c line 1124
extern signed int unzGetCurrentFileInfo64(void *file, struct unz_file_info64_s *pfile_info, char *szFileName, unsigned long int fileNameBufferSize, void *extraField, unsigned long int extraFieldBufferSize, char *szComment, unsigned long int commentBufferSize)
{
  signed int return_value_unz64local_GetCurrentFileInfoInternal_1;
  return_value_unz64local_GetCurrentFileInfoInternal_1=unz64local_GetCurrentFileInfoInternal(file, pfile_info, (struct unz_file_info64_internal_s *)(void *)0, szFileName, fileNameBufferSize, extraField, extraFieldBufferSize, szComment, commentBufferSize);
  return return_value_unz64local_GetCurrentFileInfoInternal_1;
}

// unzGetCurrentFileZStreamPos64
// file minizip/unzip.c line 1658
extern unsigned long long int unzGetCurrentFileZStreamPos64(void *file)
{
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  s = (struct anonymous_0 *)file;
  if(file == NULL)
    return (unsigned long long int)0;

  else
  {
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return (unsigned long long int)0;

    else
      return pfile_in_zip_read_info->pos_in_zipfile + pfile_in_zip_read_info->byte_before_the_zipfile;
  }
}

// unzGetFilePos
// file minizip/unzip.c line 1324
extern signed int unzGetFilePos(void *file, struct unz_file_pos_s *file_pos)
{
  struct unz64_file_pos_s file_pos64;
  signed int err;
  err=unzGetFilePos64(file, &file_pos64);
  if(err == 0)
  {
    file_pos->pos_in_zip_directory = (unsigned long int)file_pos64.pos_in_zip_directory;
    file_pos->num_of_file = (unsigned long int)file_pos64.num_of_file;
  }

  return err;
}

// unzGetFilePos64
// file minizip/unzip.c line 1308
extern signed int unzGetFilePos64(void *file, struct unz64_file_pos_s *file_pos)
{
  struct anonymous_0 *s;
  if(file == NULL || file_pos == ((struct unz64_file_pos_s *)NULL))
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    if(s->current_file_ok == 0ull)
      return -100;

    else
    {
      file_pos->pos_in_zip_directory = s->pos_in_central_dir;
      file_pos->num_of_file = s->num_file;
      return 0;
    }
  }
}

// unzGetGlobalComment
// file minizip/unzip.c line 2051
extern signed int unzGetGlobalComment(void *file, char *szComment, unsigned long int uSizeBuf)
{
  struct anonymous_0 *s;
  unsigned long int uReadThis;
  if(file == NULL)
    return (signed int)-102;

  else
  {
    s = (struct anonymous_0 *)file;
    uReadThis = uSizeBuf;
    if(!(s->gi.size_comment >= uReadThis))
      uReadThis = s->gi.size_comment;

    signed long int return_value_call_zseek64_1;
    return_value_call_zseek64_1=call_zseek64(&s->z_filefunc, s->filestream, s->central_pos + (unsigned long int)22, 0);
    if(!(return_value_call_zseek64_1 == 0l))
      return -1;

    else
    {
      if(uReadThis >= 1ul)
      {
        *szComment = (char)0;
        unsigned long int return_value;
        return_value=s->z_filefunc.zfile_func64.zread_file(s->z_filefunc.zfile_func64.opaque, s->filestream, (void *)szComment, uReadThis);
        if(!(return_value == uReadThis))
          return -1;

      }

      if(!(szComment == ((char *)NULL)))
      {
        if(!(s->gi.size_comment >= uSizeBuf))
          szComment[(signed long int)s->gi.size_comment] = (char)0;

      }

      return (signed int)uReadThis;
    }
  }
}

// unzGetGlobalInfo
// file minizip/unzip.c line 838
extern signed int unzGetGlobalInfo(void *file, struct unz_global_info_s *pglobal_info32)
{
  struct anonymous_0 *s;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    pglobal_info32->number_entry = (unsigned long int)s->gi.number_entry;
    pglobal_info32->size_comment = s->gi.size_comment;
    return 0;
  }
}

// unzGetGlobalInfo64
// file minizip/unzip.c line 828
extern signed int unzGetGlobalInfo64(void *file, struct unz_global_info64_s *pglobal_info)
{
  struct anonymous_0 *s;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    *pglobal_info = s->gi;
    return 0;
  }
}

// unzGetLocalExtrafield
// file proxy/../minizip/unzip.h line 405
extern signed int unzGetLocalExtrafield(void *file, void *buf, unsigned int len)
{
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  unsigned int read_now;
  unsigned long long int size_to_read;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return -102;

    else
    {
      size_to_read = (unsigned long int)pfile_in_zip_read_info->size_local_extrafield - pfile_in_zip_read_info->pos_local_extrafield;
      if(buf == NULL)
        return (signed int)size_to_read;

      else
      {
        if(!(size_to_read >= (unsigned long int)len))
          read_now = (unsigned int)size_to_read;

        else
          read_now = (unsigned int)len;
        if(read_now == 0u)
          return 0;

        else
        {
          signed long int return_value_call_zseek64_1;
          return_value_call_zseek64_1=call_zseek64(&pfile_in_zip_read_info->z_filefunc, pfile_in_zip_read_info->filestream, pfile_in_zip_read_info->offset_local_extrafield + pfile_in_zip_read_info->pos_local_extrafield, 0);
          if(!(return_value_call_zseek64_1 == 0l))
            return -1;

          else
          {
            unsigned long int return_value;
            return_value=pfile_in_zip_read_info->z_filefunc.zfile_func64.zread_file(pfile_in_zip_read_info->z_filefunc.zfile_func64.opaque, pfile_in_zip_read_info->filestream, buf, (unsigned long int)read_now);
            if(!(return_value == (unsigned long int)read_now))
              return -1;

            else
              return (signed int)read_now;
          }
        }
      }
    }
  }
}

// unzGetOffset
// file proxy/../minizip/unzip.h line 425
extern unsigned long int unzGetOffset(void *file)
{
  unsigned long long int offset64;
  if(file == NULL)
    return (unsigned long int)0;

  else
  {
    offset64=unzGetOffset64(file);
    return (unsigned long int)offset64;
  }
}

// unzGetOffset64
// file minizip/unzip.c line 2079
extern unsigned long long int unzGetOffset64(void *file)
{
  struct anonymous_0 *s;
  if(file == NULL)
    return (unsigned long long int)0;

  else
  {
    s = (struct anonymous_0 *)file;
    if(s->current_file_ok == 0ull)
      return (unsigned long long int)0;

    else
      if(!(s->gi.number_entry == 0ul))
      {
        if(s->gi.number_entry == 65535ul)
          goto __CPROVER_DUMP_L3;

        if(!(s->num_file == s->gi.number_entry))
          goto __CPROVER_DUMP_L3;

        return (unsigned long long int)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return s->pos_in_central_dir;
      }
  }
}

// unzGoToFilePos
// file minizip/unzip.c line 1360
extern signed int unzGoToFilePos(void *file, struct unz_file_pos_s *file_pos)
{
  struct unz64_file_pos_s file_pos64;
  if(file_pos == ((struct unz_file_pos_s *)NULL))
    return -102;

  else
  {
    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
    file_pos64.num_of_file = file_pos->num_of_file;
    signed int return_value_unzGoToFilePos64_1;
    return_value_unzGoToFilePos64_1=unzGoToFilePos64(file, &file_pos64);
    return return_value_unzGoToFilePos64_1;
  }
}

// unzGoToFilePos64
// file minizip/unzip.c line 1338
extern signed int unzGoToFilePos64(void *file, const struct unz64_file_pos_s *file_pos)
{
  struct anonymous_0 *s;
  signed int err;
  if(file == NULL || file_pos == ((const struct unz64_file_pos_s *)NULL))
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
    s->num_file = file_pos->num_of_file;
    err=unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, (char *)(void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, (char *)(void *)0, (unsigned long int)0);
    s->current_file_ok = (unsigned long long int)(err == 0);
    return err;
  }
}

// unzGoToFirstFile
// file proxy/../minizip/unzip.h line 229
extern signed int unzGoToFirstFile(void *file)
{
  signed int err = 0;
  struct anonymous_0 *s;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    s->pos_in_central_dir = s->offset_central_dir;
    s->num_file = (unsigned long long int)0;
    err=unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, (char *)(void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, (char *)(void *)0, (unsigned long int)0);
    s->current_file_ok = (unsigned long long int)(err == 0);
    return err;
  }
}

// unzGoToNextFile
// file proxy/../minizip/unzip.h line 235
extern signed int unzGoToNextFile(void *file)
{
  struct anonymous_0 *s;
  signed int err;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    if(s->current_file_ok == 0ull)
      return -100;

    else
      if(!(s->gi.number_entry == 65535ul))
      {
        if(!(1ul + s->num_file == s->gi.number_entry))
          goto __CPROVER_DUMP_L3;

        return -100;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        s->pos_in_central_dir = s->pos_in_central_dir + (unsigned long int)0x2e + s->cur_file_info.size_filename + s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment;
        s->num_file = s->num_file + 1ull;
        err=unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, (char *)(void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, (char *)(void *)0, (unsigned long int)0);
        s->current_file_ok = (unsigned long long int)(err == 0);
        return err;
      }
  }
}

// unzLocateFile
// file minizip/unzip.c line 1232
extern signed int unzLocateFile(void *file, const char *szFileName, signed int iCaseSensitivity)
{
  struct anonymous_0 *s;
  signed int err;
  struct unz_file_info64_s cur_file_infoSaved;
  struct unz_file_info64_internal_s cur_file_info_internalSaved;
  unsigned long long int num_fileSaved;
  unsigned long long int pos_in_central_dirSaved;
  if(file == NULL)
    return -102;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(szFileName);
    if(return_value_strlen_1 >= 256ul)
      return -102;

    else
    {
      s = (struct anonymous_0 *)file;
      if(s->current_file_ok == 0ull)
        return -100;

      else
      {
        num_fileSaved = s->num_file;
        pos_in_central_dirSaved = s->pos_in_central_dir;
        cur_file_infoSaved = s->cur_file_info;
        cur_file_info_internalSaved = s->cur_file_info_internal;
        err=unzGoToFirstFile(file);
        while(err == 0)
        {
          char szCurrentFileName[257l];
          err=unzGetCurrentFileInfo64(file, (struct unz_file_info64_s *)(void *)0, szCurrentFileName, sizeof(char [257l]) /*257ul*/  - (unsigned long int)1, (void *)0, (unsigned long int)0, (char *)(void *)0, (unsigned long int)0);
          if(err == 0)
          {
            signed int return_value_unzStringFileNameCompare_2;
            return_value_unzStringFileNameCompare_2=unzStringFileNameCompare(szCurrentFileName, szFileName, iCaseSensitivity);
            if(return_value_unzStringFileNameCompare_2 == 0)
              return 0;

            err=unzGoToNextFile(file);
          }

        }
        s->num_file = num_fileSaved;
        s->pos_in_central_dir = pos_in_central_dirSaved;
        s->cur_file_info = cur_file_infoSaved;
        s->cur_file_info_internal = cur_file_info_internalSaved;
        return err;
      }
    }
  }
}

// unzOpen
// file proxy/../minizip/unzip.h line 166
extern void * unzOpen(const char *path)
{
  void *return_value_unzOpenInternal_1;
  return_value_unzOpenInternal_1=unzOpenInternal((const void *)path, (struct zlib_filefunc64_32_def_s *)(void *)0, 0);
  return return_value_unzOpenInternal_1;
}

// unzOpen2
// file minizip/unzip.c line 765
extern void * unzOpen2(const char *path, struct zlib_filefunc_def_s *pzlib_filefunc32_def)
{
  void *return_value_unzOpenInternal_2;
  if(!(pzlib_filefunc32_def == ((struct zlib_filefunc_def_s *)NULL)))
  {
    struct zlib_filefunc64_32_def_s zlib_filefunc64_32_def_fill;
    fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill, pzlib_filefunc32_def);
    void *return_value_unzOpenInternal_1;
    return_value_unzOpenInternal_1=unzOpenInternal((const void *)path, &zlib_filefunc64_32_def_fill, 0);
    return return_value_unzOpenInternal_1;
  }

  else
  {
    return_value_unzOpenInternal_2=unzOpenInternal((const void *)path, (struct zlib_filefunc64_32_def_s *)(void *)0, 0);
    return return_value_unzOpenInternal_2;
  }
}

// unzOpen2_64
// file minizip/unzip.c line 778
extern void * unzOpen2_64(const void *path, struct zlib_filefunc64_def_s *pzlib_filefunc_def)
{
  void *return_value_unzOpenInternal_2;
  if(!(pzlib_filefunc_def == ((struct zlib_filefunc64_def_s *)NULL)))
  {
    struct zlib_filefunc64_32_def_s zlib_filefunc64_32_def_fill;
    zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
    zlib_filefunc64_32_def_fill.ztell32_file = (signed long int (*)(void *, void *))(void *)0;
    zlib_filefunc64_32_def_fill.zseek32_file = (signed long int (*)(void *, void *, unsigned long int, signed int))(void *)0;
    void *return_value_unzOpenInternal_1;
    return_value_unzOpenInternal_1=unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);
    return return_value_unzOpenInternal_1;
  }

  else
  {
    return_value_unzOpenInternal_2=unzOpenInternal(path, (struct zlib_filefunc64_32_def_s *)(void *)0, 1);
    return return_value_unzOpenInternal_2;
  }
}

// unzOpen64
// file minizip/unzip.c line 798
extern void * unzOpen64(const void *path)
{
  void *return_value_unzOpenInternal_1;
  return_value_unzOpenInternal_1=unzOpenInternal(path, (struct zlib_filefunc64_32_def_s *)(void *)0, 1);
  return return_value_unzOpenInternal_1;
}

// unzOpenCurrentFile
// file proxy/../minizip/unzip.h line 331
extern signed int unzOpenCurrentFile(void *file)
{
  signed int return_value_unzOpenCurrentFile3_1;
  return_value_unzOpenCurrentFile3_1=unzOpenCurrentFile3(file, (signed int *)(void *)0, (signed int *)(void *)0, 0, (const char *)(void *)0);
  return return_value_unzOpenCurrentFile3_1;
}

// unzOpenCurrentFile2
// file minizip/unzip.c line 1651
extern signed int unzOpenCurrentFile2(void *file, signed int *method, signed int *level, signed int raw)
{
  signed int return_value_unzOpenCurrentFile3_1;
  return_value_unzOpenCurrentFile3_1=unzOpenCurrentFile3(file, method, level, raw, (const char *)(void *)0);
  return return_value_unzOpenCurrentFile3_1;
}

// unzOpenCurrentFile3
// file minizip/unzip.c line 1472
extern signed int unzOpenCurrentFile3(void *file, signed int *method, signed int *level, signed int raw, const char *password)
{
  signed int err = 0;
  unsigned int iSizeVar;
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  unsigned long long int offset_local_extrafield;
  unsigned int size_local_extrafield;
  if(!(password == ((const char *)NULL)))
    return -102;

  else
    if(file == NULL)
      return -102;

    else
    {
      s = (struct anonymous_0 *)file;
      if(s->current_file_ok == 0ull)
        return -102;

      else
      {
        if(!(s->pfile_in_zip_read == ((struct anonymous *)NULL)))
          unzCloseCurrentFile(file);

        signed int return_value_unz64local_CheckCurrentFileCoherencyHeader_1;
        return_value_unz64local_CheckCurrentFileCoherencyHeader_1=unz64local_CheckCurrentFileCoherencyHeader(s, &iSizeVar, &offset_local_extrafield, &size_local_extrafield);
        if(!(return_value_unz64local_CheckCurrentFileCoherencyHeader_1 == 0))
          return -103;

        else
        {
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(sizeof(struct anonymous) /*328ul*/ );
          pfile_in_zip_read_info = (struct anonymous *)return_value_malloc_2;
          if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
            return -104;

          else
          {
            void *return_value_malloc_3;
            return_value_malloc_3=malloc((unsigned long int)16384);
            pfile_in_zip_read_info->read_buffer = (char *)return_value_malloc_3;
            pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
            pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
            pfile_in_zip_read_info->pos_local_extrafield = (unsigned long long int)0;
            pfile_in_zip_read_info->raw = raw;
            if(pfile_in_zip_read_info->read_buffer == ((char *)NULL))
            {
              if(!(pfile_in_zip_read_info == ((struct anonymous *)NULL)))
                free((void *)pfile_in_zip_read_info);

              return -104;
            }

            else
            {
              pfile_in_zip_read_info->stream_initialised = (unsigned long int)0;
              if(!(method == ((signed int *)NULL)))
                *method = (signed int)s->cur_file_info.compression_method;

              if(!(level == ((signed int *)NULL)))
              {
                *level = 6;
                switch(s->cur_file_info.flag & (unsigned long int)0x06)
                {
                  case (unsigned long int)6:
                  {
                    *level = 1;
                    break;
                  }
                  case (unsigned long int)4:
                  {
                    *level = 2;
                    break;
                  }
                  case (unsigned long int)2:
                    *level = 9;
                }
              }

              if(!(s->cur_file_info.compression_method == 0ul))
              {
                if(!(s->cur_file_info.compression_method == 12ul))
                {
                  if(!(s->cur_file_info.compression_method == 8ul))
                    err = -103;

                }

              }

              pfile_in_zip_read_info->crc32_wait = s->cur_file_info.crc;
              pfile_in_zip_read_info->crc32 = (unsigned long int)0;
              pfile_in_zip_read_info->total_out_64 = (unsigned long long int)0;
              pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;
              pfile_in_zip_read_info->filestream = s->filestream;
              pfile_in_zip_read_info->z_filefunc = s->z_filefunc;
              pfile_in_zip_read_info->byte_before_the_zipfile = s->byte_before_the_zipfile;
              pfile_in_zip_read_info->stream.total_out = (unsigned long int)0;
              if(s->cur_file_info.compression_method == 12ul && raw == 0)
                pfile_in_zip_read_info->raw = 1;

              else
                if(s->cur_file_info.compression_method == 8ul)
                {
                  if(raw == 0)
                  {
                    pfile_in_zip_read_info->stream.zalloc = (void * (*)(void *, unsigned int, unsigned int))0;
                    pfile_in_zip_read_info->stream.zfree = (void (*)(void *, void *))0;
                    pfile_in_zip_read_info->stream.opaque = (void *)0;
                    pfile_in_zip_read_info->stream.next_in = ((const unsigned char *)NULL);
                    pfile_in_zip_read_info->stream.avail_in = (unsigned int)0;
                    err=inflateInit2_(&pfile_in_zip_read_info->stream, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
                    if(err == 0)
                      pfile_in_zip_read_info->stream_initialised = (unsigned long int)8;

                    else
                    {
                      if(!(pfile_in_zip_read_info == ((struct anonymous *)NULL)))
                        free((void *)pfile_in_zip_read_info);

                      return err;
                    }
                  }

                }

              pfile_in_zip_read_info->rest_read_compressed = s->cur_file_info.compressed_size;
              pfile_in_zip_read_info->rest_read_uncompressed = s->cur_file_info.uncompressed_size;
              pfile_in_zip_read_info->pos_in_zipfile = s->cur_file_info_internal.offset_curfile + (unsigned long int)0x1e + (unsigned long int)iSizeVar;
              pfile_in_zip_read_info->stream.avail_in = (unsigned int)0;
              s->pfile_in_zip_read = pfile_in_zip_read_info;
              s->encrypted = 0;
              return 0;
            }
          }
        }
      }
    }
}

// unzOpenCurrentFilePassword
// file minizip/unzip.c line 1646
extern signed int unzOpenCurrentFilePassword(void *file, const char *password)
{
  signed int return_value_unzOpenCurrentFile3_1;
  return_value_unzOpenCurrentFile3_1=unzOpenCurrentFile3(file, (signed int *)(void *)0, (signed int *)(void *)0, 0, password);
  return return_value_unzOpenCurrentFile3_1;
}

// unzOpenInternal
// file minizip/unzip.c line 584
static void * unzOpenInternal(const void *path, struct zlib_filefunc64_32_def_s *pzlib_filefunc64_32_def, signed int is64bitOpenFunction)
{
  struct anonymous_0 us;
  struct anonymous_0 *s;
  unsigned long long int central_pos;
  unsigned long int uL;
  unsigned long int number_disk;
  unsigned long int number_disk_with_CD;
  unsigned long long int number_entry_CD;
  signed int err = 0;
  if(!((signed int)unz_copyright[0l] == 32))
    return (void *)0;

  else
  {
    us.z_filefunc.zseek32_file = (signed long int (*)(void *, void *, unsigned long int, signed int))(void *)0;
    us.z_filefunc.ztell32_file = (signed long int (*)(void *, void *))(void *)0;
    if(pzlib_filefunc64_32_def == ((struct zlib_filefunc64_32_def_s *)NULL))
      fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);

    else
      us.z_filefunc = *pzlib_filefunc64_32_def;
    us.is64bitOpenFunction = is64bitOpenFunction;
    us.filestream=call_zopen64(&us.z_filefunc, path, 1 | 4);
    if(us.filestream == NULL)
      return (void *)0;

    else
    {
      central_pos=unz64local_SearchCentralDir64(&us.z_filefunc, us.filestream);
      if(!(central_pos == 0ull))
      {
        unsigned long int uS;
        unsigned long long int uL64;
        us.isZip64 = 1;
        signed long int return_value_call_zseek64_1;
        return_value_call_zseek64_1=call_zseek64(&us.z_filefunc, us.filestream, central_pos, 0);
        if(!(return_value_call_zseek64_1 == 0l))
          err = -1;

        signed int return_value_unz64local_getLong_2;
        return_value_unz64local_getLong_2=unz64local_getLong(&us.z_filefunc, us.filestream, &uL);
        if(!(return_value_unz64local_getLong_2 == 0))
          err = -1;

        signed int return_value_unz64local_getLong64_3;
        return_value_unz64local_getLong64_3=unz64local_getLong64(&us.z_filefunc, us.filestream, &uL64);
        if(!(return_value_unz64local_getLong64_3 == 0))
          err = -1;

        signed int return_value_unz64local_getShort_4;
        return_value_unz64local_getShort_4=unz64local_getShort(&us.z_filefunc, us.filestream, &uS);
        if(!(return_value_unz64local_getShort_4 == 0))
          err = -1;

        signed int return_value_unz64local_getShort_5;
        return_value_unz64local_getShort_5=unz64local_getShort(&us.z_filefunc, us.filestream, &uS);
        if(!(return_value_unz64local_getShort_5 == 0))
          err = -1;

        signed int return_value_unz64local_getLong_6;
        return_value_unz64local_getLong_6=unz64local_getLong(&us.z_filefunc, us.filestream, &number_disk);
        if(!(return_value_unz64local_getLong_6 == 0))
          err = -1;

        signed int return_value_unz64local_getLong_7;
        return_value_unz64local_getLong_7=unz64local_getLong(&us.z_filefunc, us.filestream, &number_disk_with_CD);
        if(!(return_value_unz64local_getLong_7 == 0))
          err = -1;

        signed int return_value_unz64local_getLong64_8;
        return_value_unz64local_getLong64_8=unz64local_getLong64(&us.z_filefunc, us.filestream, &us.gi.number_entry);
        if(!(return_value_unz64local_getLong64_8 == 0))
          err = -1;

        signed int return_value_unz64local_getLong64_9;
        return_value_unz64local_getLong64_9=unz64local_getLong64(&us.z_filefunc, us.filestream, &number_entry_CD);
        if(!(return_value_unz64local_getLong64_9 == 0))
          err = -1;

        if(!(number_disk == 0ul) || !(number_disk_with_CD == 0ul) || !(number_entry_CD == us.gi.number_entry))
          err = -103;

        signed int return_value_unz64local_getLong64_10;
        return_value_unz64local_getLong64_10=unz64local_getLong64(&us.z_filefunc, us.filestream, &us.size_central_dir);
        if(!(return_value_unz64local_getLong64_10 == 0))
          err = -1;

        signed int return_value_unz64local_getLong64_11;
        return_value_unz64local_getLong64_11=unz64local_getLong64(&us.z_filefunc, us.filestream, &us.offset_central_dir);
        if(!(return_value_unz64local_getLong64_11 == 0))
          err = -1;

        us.gi.size_comment = (unsigned long int)0;
      }

      else
      {
        central_pos=unz64local_SearchCentralDir(&us.z_filefunc, us.filestream);
        if(central_pos == 0ul)
          err = -1;

        us.isZip64 = 0;
        signed long int return_value_call_zseek64_12;
        return_value_call_zseek64_12=call_zseek64(&us.z_filefunc, us.filestream, central_pos, 0);
        if(!(return_value_call_zseek64_12 == 0l))
          err = -1;

        signed int return_value_unz64local_getLong_13;
        return_value_unz64local_getLong_13=unz64local_getLong(&us.z_filefunc, us.filestream, &uL);
        if(!(return_value_unz64local_getLong_13 == 0))
          err = -1;

        signed int return_value_unz64local_getShort_14;
        return_value_unz64local_getShort_14=unz64local_getShort(&us.z_filefunc, us.filestream, &number_disk);
        if(!(return_value_unz64local_getShort_14 == 0))
          err = -1;

        signed int return_value_unz64local_getShort_15;
        return_value_unz64local_getShort_15=unz64local_getShort(&us.z_filefunc, us.filestream, &number_disk_with_CD);
        if(!(return_value_unz64local_getShort_15 == 0))
          err = -1;

        signed int return_value_unz64local_getShort_16;
        return_value_unz64local_getShort_16=unz64local_getShort(&us.z_filefunc, us.filestream, &uL);
        if(!(return_value_unz64local_getShort_16 == 0))
          err = -1;

        us.gi.number_entry = uL;
        signed int return_value_unz64local_getShort_17;
        return_value_unz64local_getShort_17=unz64local_getShort(&us.z_filefunc, us.filestream, &uL);
        if(!(return_value_unz64local_getShort_17 == 0))
          err = -1;

        number_entry_CD = uL;
        if(!(number_disk == 0ul) || !(number_disk_with_CD == 0ul) || !(number_entry_CD == us.gi.number_entry))
          err = -103;

        signed int return_value_unz64local_getLong_18;
        return_value_unz64local_getLong_18=unz64local_getLong(&us.z_filefunc, us.filestream, &uL);
        if(!(return_value_unz64local_getLong_18 == 0))
          err = -1;

        us.size_central_dir = uL;
        signed int return_value_unz64local_getLong_19;
        return_value_unz64local_getLong_19=unz64local_getLong(&us.z_filefunc, us.filestream, &uL);
        if(!(return_value_unz64local_getLong_19 == 0))
          err = -1;

        us.offset_central_dir = uL;
        signed int return_value_unz64local_getShort_20;
        return_value_unz64local_getShort_20=unz64local_getShort(&us.z_filefunc, us.filestream, &us.gi.size_comment);
        if(!(return_value_unz64local_getShort_20 == 0))
          err = -1;

      }
      if(err == 0 && !(central_pos >= us.offset_central_dir + us.size_central_dir))
        err = -103;

      if(!(err == 0))
      {
        us.z_filefunc.zfile_func64.zclose_file(us.z_filefunc.zfile_func64.opaque, us.filestream);
        return (void *)0;
      }

      else
      {
        us.byte_before_the_zipfile = central_pos - (us.offset_central_dir + us.size_central_dir);
        us.central_pos = central_pos;
        us.pfile_in_zip_read = (struct anonymous *)(void *)0;
        us.encrypted = 0;
        void *return_value_malloc_21;
        return_value_malloc_21=malloc(sizeof(struct anonymous_0) /*344ul*/ );
        s = (struct anonymous_0 *)return_value_malloc_21;
        if(!(s == ((struct anonymous_0 *)NULL)))
        {
          *s = us;
          unzGoToFirstFile((void *)s);
        }

        return (void *)s;
      }
    }
  }
}

// unzReadCurrentFile
// file proxy/../minizip/unzip.h line 379
extern signed int unzReadCurrentFile(void *file, void *buf, unsigned int len)
{
  signed int err = 0;
  unsigned int iRead = (unsigned int)0;
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  _Bool tmp_if_expr_2;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return -102;

    else
      if(pfile_in_zip_read_info->read_buffer == ((char *)NULL))
        return -100;

      else
        if(len == 0u)
          return 0;

        else
        {
          pfile_in_zip_read_info->stream.next_out = (unsigned char *)buf;
          pfile_in_zip_read_info->stream.avail_out = (unsigned int)len;
          if(!(pfile_in_zip_read_info->rest_read_uncompressed >= (unsigned long int)len))
          {
            if(pfile_in_zip_read_info->raw == 0)
              pfile_in_zip_read_info->stream.avail_out = (unsigned int)pfile_in_zip_read_info->rest_read_uncompressed;

          }

          if(!(pfile_in_zip_read_info->rest_read_compressed + (unsigned long int)pfile_in_zip_read_info->stream.avail_in >= (unsigned long int)len))
          {
            if(!(pfile_in_zip_read_info->raw == 0))
              pfile_in_zip_read_info->stream.avail_out = (unsigned int)pfile_in_zip_read_info->rest_read_compressed + pfile_in_zip_read_info->stream.avail_in;

          }

          while(pfile_in_zip_read_info->stream.avail_out >= 1u)
          {
            if(pfile_in_zip_read_info->stream.avail_in == 0u)
            {
              if(pfile_in_zip_read_info->rest_read_compressed >= 1ul)
              {
                unsigned int uReadThis = (unsigned int)16384;
                if(!(pfile_in_zip_read_info->rest_read_compressed >= (unsigned long int)uReadThis))
                  uReadThis = (unsigned int)pfile_in_zip_read_info->rest_read_compressed;

                if(uReadThis == 0u)
                  return 0;

                signed long int return_value_call_zseek64_1;
                return_value_call_zseek64_1=call_zseek64(&pfile_in_zip_read_info->z_filefunc, pfile_in_zip_read_info->filestream, pfile_in_zip_read_info->pos_in_zipfile + pfile_in_zip_read_info->byte_before_the_zipfile, 0);
                if(!(return_value_call_zseek64_1 == 0l))
                  return -1;

                unsigned long int return_value;
                return_value=pfile_in_zip_read_info->z_filefunc.zfile_func64.zread_file(pfile_in_zip_read_info->z_filefunc.zfile_func64.opaque, pfile_in_zip_read_info->filestream, (void *)pfile_in_zip_read_info->read_buffer, (unsigned long int)uReadThis);
                if(!(return_value == (unsigned long int)uReadThis))
                  return -1;

                pfile_in_zip_read_info->pos_in_zipfile = pfile_in_zip_read_info->pos_in_zipfile + (unsigned long long int)uReadThis;
                pfile_in_zip_read_info->rest_read_compressed = pfile_in_zip_read_info->rest_read_compressed - (unsigned long long int)uReadThis;
                pfile_in_zip_read_info->stream.next_in = (unsigned char *)pfile_in_zip_read_info->read_buffer;
                pfile_in_zip_read_info->stream.avail_in = (unsigned int)uReadThis;
              }

            }

            if(pfile_in_zip_read_info->compression_method == 0ul)
              tmp_if_expr_2 = (_Bool)1;

            else
              tmp_if_expr_2 = pfile_in_zip_read_info->raw != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_2)
            {
              unsigned int uDoCopy;
              unsigned int i;
              if(pfile_in_zip_read_info->stream.avail_in == 0u)
              {
                if(pfile_in_zip_read_info->rest_read_compressed == 0ul)
                  return (signed int)(iRead == (unsigned int)0 ? (unsigned int)0 : iRead);

              }

              if(!(pfile_in_zip_read_info->stream.avail_out >= pfile_in_zip_read_info->stream.avail_in))
                uDoCopy = pfile_in_zip_read_info->stream.avail_out;

              else
                uDoCopy = pfile_in_zip_read_info->stream.avail_in;
              i = (unsigned int)0;
              for( ; !(i >= uDoCopy); i = i + 1u)
                pfile_in_zip_read_info->stream.next_out[(signed long int)i] = pfile_in_zip_read_info->stream.next_in[(signed long int)i];
              pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + (unsigned long int)uDoCopy;
              pfile_in_zip_read_info->crc32=crc32(pfile_in_zip_read_info->crc32, pfile_in_zip_read_info->stream.next_out, uDoCopy);
              pfile_in_zip_read_info->rest_read_uncompressed = pfile_in_zip_read_info->rest_read_uncompressed - (unsigned long long int)uDoCopy;
              pfile_in_zip_read_info->stream.avail_in = pfile_in_zip_read_info->stream.avail_in - uDoCopy;
              pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->stream.avail_out - uDoCopy;
              pfile_in_zip_read_info->stream.next_out = pfile_in_zip_read_info->stream.next_out + (signed long int)uDoCopy;
              pfile_in_zip_read_info->stream.next_in = pfile_in_zip_read_info->stream.next_in + (signed long int)uDoCopy;
              pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->stream.total_out + (unsigned long int)uDoCopy;
              iRead = iRead + uDoCopy;
            }

            else
              if(!(pfile_in_zip_read_info->compression_method == 12ul))
              {
                unsigned long long int uTotalOutBefore;
                unsigned long long int uTotalOutAfter;
                const unsigned char *bufBefore;
                unsigned long long int uOutThis;
                signed int flush = 2;
                uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
                bufBefore = pfile_in_zip_read_info->stream.next_out;
                err=inflate(&pfile_in_zip_read_info->stream, flush);
                if(err >= 0)
                {
                  if(!(pfile_in_zip_read_info->stream.msg == ((const char *)NULL)))
                    err = -3;

                }

                uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
                uOutThis = uTotalOutAfter - uTotalOutBefore;
                pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
                pfile_in_zip_read_info->crc32=crc32(pfile_in_zip_read_info->crc32, bufBefore, (unsigned int)uOutThis);
                pfile_in_zip_read_info->rest_read_uncompressed = pfile_in_zip_read_info->rest_read_uncompressed - uOutThis;
                iRead = iRead + (unsigned int)(uTotalOutAfter - uTotalOutBefore);
                if(err == 1)
                  return (signed int)(iRead == (unsigned int)0 ? (unsigned int)0 : iRead);

                if(!(err == 0))
                  break;

              }

          }
          if(err == 0)
            return (signed int)iRead;

          else
            return err;
        }
  }
}

// unzRepair
// file minizip/mztools.c line 31
extern signed int unzRepair(const char *file, const char *fileOut, const char *fileOutTmp, unsigned long int *nRecovered, unsigned long int *bytesRecovered)
{
  signed int err = 0;
  struct _IO_FILE *fpZip;
  fpZip=fopen(file, "rb");
  struct _IO_FILE *fpOut;
  fpOut=fopen(fileOut, "wb");
  struct _IO_FILE *fpOutCD;
  fpOutCD=fopen(fileOutTmp, "wb");
  unsigned long int return_value_fread_1;
  unsigned long int return_value_fread_16;
  if(!(fpOut == ((struct _IO_FILE *)NULL)) && !(fpZip == ((struct _IO_FILE *)NULL)))
  {
    signed int entries = 0;
    unsigned long int totalBytes = (unsigned long int)0;
    char unzRepair__1__1__header[30l];
    char filename[1024l];
    char extra[1024l];
    signed int offset = 0;
    signed int offsetCD = 0;
    do
    {
      return_value_fread_1=fread((void *)unzRepair__1__1__header, (unsigned long int)1, (unsigned long int)30, fpZip);
      if(!(return_value_fread_1 == 30ul))
        break;

      signed int currentOffset = offset;
      if((((signed int)(unsigned char)unzRepair__1__1__header[3l] << 8 | (signed int)(unsigned char)unzRepair__1__1__header[2l]) << 16 | (signed int)(unsigned char)unzRepair__1__1__header[1l] << 8 | (signed int)(unsigned char)unzRepair__1__1__header[0l]) == 0x04034b50)
      {
        unsigned int version = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)4] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)4)[(signed long int)1] << 8);
        unsigned int gpflag = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)6] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)6)[(signed long int)1] << 8);
        unsigned int method = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)8] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)8)[(signed long int)1] << 8);
        unsigned int filetime = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)10] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)10)[(signed long int)1] << 8);
        unsigned int filedate = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)12] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)12)[(signed long int)1] << 8);
        unsigned int crc = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)14] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)14)[(signed long int)1] << 8 | ((signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)14)[(signed long int)2] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)14 + (signed long int)2)[(signed long int)1] << 8) << 16);
        unsigned int cpsize = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)18] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)18)[(signed long int)1] << 8 | ((signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)18)[(signed long int)2] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)18 + (signed long int)2)[(signed long int)1] << 8) << 16);
        unsigned int uncpsize = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)22] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)22)[(signed long int)1] << 8 | ((signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)22)[(signed long int)2] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)22 + (signed long int)2)[(signed long int)1] << 8) << 16);
        unsigned int fnsize = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)26] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)26)[(signed long int)1] << 8);
        unsigned int extsize = (unsigned int)((signed int)(unsigned char)unzRepair__1__1__header[(signed long int)28] | (signed int)(unsigned char)(unzRepair__1__1__header + (signed long int)28)[(signed long int)1] << 8);
        extra[(signed long int)0] = (char)0;
        filename[(signed long int)0] = extra[(signed long int)0];
        unsigned long int return_value_fwrite_2;
        return_value_fwrite_2=fwrite((const void *)unzRepair__1__1__header, (unsigned long int)1, (unsigned long int)30, fpOut);
        if(return_value_fwrite_2 == 30ul)
          offset = offset + 30;

        else
        {
          err = -1;
          break;
        }
        if(fnsize >= 1u)
        {
          if(!((unsigned long int)fnsize >= sizeof(char [1024l]) /*1024ul*/ ))
          {
            unsigned long int return_value_fread_4;
            return_value_fread_4=fread((void *)filename, (unsigned long int)1, (unsigned long int)fnsize, fpZip);
            if(return_value_fread_4 == (unsigned long int)fnsize)
            {
              unsigned long int return_value_fwrite_3;
              return_value_fwrite_3=fwrite((const void *)filename, (unsigned long int)1, (unsigned long int)fnsize, fpOut);
              if(return_value_fwrite_3 == (unsigned long int)fnsize)
                offset = offset + (signed int)fnsize;

              else
              {
                err = -1;
                break;
              }
            }

            else
            {
              err = -1;
              break;
            }
          }

          else
          {
            err = -1;
            break;
          }
        }

        else
        {
          err = -2;
          break;
        }
        if(extsize >= 1u)
        {
          if(!((unsigned long int)extsize >= sizeof(char [1024l]) /*1024ul*/ ))
          {
            unsigned long int return_value_fread_6;
            return_value_fread_6=fread((void *)extra, (unsigned long int)1, (unsigned long int)extsize, fpZip);
            if(return_value_fread_6 == (unsigned long int)extsize)
            {
              unsigned long int return_value_fwrite_5;
              return_value_fwrite_5=fwrite((const void *)extra, (unsigned long int)1, (unsigned long int)extsize, fpOut);
              if(return_value_fwrite_5 == (unsigned long int)extsize)
                offset = offset + (signed int)extsize;

              else
              {
                err = -1;
                break;
              }
            }

            else
            {
              err = -1;
              break;
            }
          }

          else
          {
            err = -1;
            break;
          }
        }

        signed int dataSize = (signed int)cpsize;
        if(dataSize == 0)
          dataSize = (signed int)uncpsize;

        if(dataSize >= 1)
        {
          char *data;
          void *return_value_malloc_7;
          return_value_malloc_7=malloc((unsigned long int)dataSize);
          data = (char *)return_value_malloc_7;
          if(!(data == ((char *)NULL)))
          {
            unsigned long int return_value_fread_9;
            return_value_fread_9=fread((void *)data, (unsigned long int)1, (unsigned long int)dataSize, fpZip);
            if((signed int)return_value_fread_9 == dataSize)
            {
              unsigned long int return_value_fwrite_8;
              return_value_fwrite_8=fwrite((const void *)data, (unsigned long int)1, (unsigned long int)dataSize, fpOut);
              if((signed int)return_value_fwrite_8 == dataSize)
              {
                offset = offset + dataSize;
                totalBytes = totalBytes + (unsigned long int)dataSize;
              }

              else
                err = -1;
            }

            else
              err = -1;
            free((void *)data);
            if(!(err == 0))
              break;

          }

          else
          {
            err = -4;
            break;
          }
        }

        char header[46l];
        const char *comment = "";
        unsigned long int comsize;
        comsize=strlen(comment);
        do
        {

        __CPROVER_DUMP_L27:
          ;
          *((unsigned char *)header) = (unsigned char)(0x02014b50 & 0xffff & 0xff);
          do
            *((unsigned char *)((unsigned char *)header + (signed long int)1)) = (unsigned char)((0x02014b50 & 0xffff) >> 8 & 0xff);
          while((_Bool)0);
          do
          {

          __CPROVER_DUMP_L29:
            ;
            *((unsigned char *)((unsigned char *)header + (signed long int)2)) = (unsigned char)(0x02014b50 >> 16 & 0xff);
            do
              *((unsigned char *)((unsigned char *)((unsigned char *)header + (signed long int)2) + (signed long int)1)) = (unsigned char)((0x02014b50 >> 16) >> 8 & 0xff);
            while((_Bool)0);
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L31:
          ;
          *((unsigned char *)(header + (signed long int)4)) = (unsigned char)(version & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)4) + (signed long int)1)) = (unsigned char)(version >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L33:
          ;
          *((unsigned char *)(header + (signed long int)6)) = (unsigned char)(version & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)6) + (signed long int)1)) = (unsigned char)(version >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L35:
          ;
          *((unsigned char *)(header + (signed long int)8)) = (unsigned char)(gpflag & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)8) + (signed long int)1)) = (unsigned char)(gpflag >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L37:
          ;
          *((unsigned char *)(header + (signed long int)10)) = (unsigned char)(method & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)10) + (signed long int)1)) = (unsigned char)(method >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L39:
          ;
          *((unsigned char *)(header + (signed long int)12)) = (unsigned char)(filetime & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)12) + (signed long int)1)) = (unsigned char)(filetime >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L41:
          ;
          *((unsigned char *)(header + (signed long int)14)) = (unsigned char)(filedate & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)14) + (signed long int)1)) = (unsigned char)(filedate >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L43:
          ;
          *((unsigned char *)(header + (signed long int)16)) = (unsigned char)(crc & (unsigned int)0xffff & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)16) + (signed long int)1)) = (unsigned char)((crc & (unsigned int)0xffff) >> 8 & (unsigned int)0xff);
          while((_Bool)0);
          do
          {

          __CPROVER_DUMP_L45:
            ;
            *((unsigned char *)((unsigned char *)(header + (signed long int)16) + (signed long int)2)) = (unsigned char)(crc >> 16 & (unsigned int)0xff);
            do
              *((unsigned char *)((unsigned char *)((unsigned char *)(header + (signed long int)16) + (signed long int)2) + (signed long int)1)) = (unsigned char)((crc >> 16) >> 8 & (unsigned int)0xff);
            while((_Bool)0);
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L47:
          ;
          *((unsigned char *)(header + (signed long int)20)) = (unsigned char)(cpsize & (unsigned int)0xffff & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)20) + (signed long int)1)) = (unsigned char)((cpsize & (unsigned int)0xffff) >> 8 & (unsigned int)0xff);
          while((_Bool)0);
          do
          {

          __CPROVER_DUMP_L49:
            ;
            *((unsigned char *)((unsigned char *)(header + (signed long int)20) + (signed long int)2)) = (unsigned char)(cpsize >> 16 & (unsigned int)0xff);
            do
              *((unsigned char *)((unsigned char *)((unsigned char *)(header + (signed long int)20) + (signed long int)2) + (signed long int)1)) = (unsigned char)((cpsize >> 16) >> 8 & (unsigned int)0xff);
            while((_Bool)0);
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L51:
          ;
          *((unsigned char *)(header + (signed long int)24)) = (unsigned char)(uncpsize & (unsigned int)0xffff & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)24) + (signed long int)1)) = (unsigned char)((uncpsize & (unsigned int)0xffff) >> 8 & (unsigned int)0xff);
          while((_Bool)0);
          do
          {

          __CPROVER_DUMP_L53:
            ;
            *((unsigned char *)((unsigned char *)(header + (signed long int)24) + (signed long int)2)) = (unsigned char)(uncpsize >> 16 & (unsigned int)0xff);
            do
              *((unsigned char *)((unsigned char *)((unsigned char *)(header + (signed long int)24) + (signed long int)2) + (signed long int)1)) = (unsigned char)((uncpsize >> 16) >> 8 & (unsigned int)0xff);
            while((_Bool)0);
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L55:
          ;
          *((unsigned char *)(header + (signed long int)28)) = (unsigned char)(fnsize & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)28) + (signed long int)1)) = (unsigned char)(fnsize >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L57:
          ;
          *((unsigned char *)(header + (signed long int)30)) = (unsigned char)(extsize & (unsigned int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)30) + (signed long int)1)) = (unsigned char)(extsize >> 8 & (unsigned int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L59:
          ;
          *((unsigned char *)(header + (signed long int)32)) = (unsigned char)(comsize & (unsigned long int)0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)32) + (signed long int)1)) = (unsigned char)(comsize >> 8 & (unsigned long int)0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L61:
          ;
          *((unsigned char *)(header + (signed long int)34)) = (unsigned char)(0 & 0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)34) + (signed long int)1)) = (unsigned char)(0 >> 8 & 0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L63:
          ;
          *((unsigned char *)(header + (signed long int)36)) = (unsigned char)(0 & 0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)36) + (signed long int)1)) = (unsigned char)(0 >> 8 & 0xff);
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L65:
          ;
          *((unsigned char *)(header + (signed long int)38)) = (unsigned char)(0 & 0xffff & 0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)38) + (signed long int)1)) = (unsigned char)((0 & 0xffff) >> 8 & 0xff);
          while((_Bool)0);
          do
          {

          __CPROVER_DUMP_L67:
            ;
            *((unsigned char *)((unsigned char *)(header + (signed long int)38) + (signed long int)2)) = (unsigned char)(0 >> 16 & 0xff);
            do
              *((unsigned char *)((unsigned char *)((unsigned char *)(header + (signed long int)38) + (signed long int)2) + (signed long int)1)) = (unsigned char)((0 >> 16) >> 8 & 0xff);
            while((_Bool)0);
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        do
        {

        __CPROVER_DUMP_L69:
          ;
          *((unsigned char *)(header + (signed long int)42)) = (unsigned char)(currentOffset & 0xffff & 0xff);
          do
            *((unsigned char *)((unsigned char *)(header + (signed long int)42) + (signed long int)1)) = (unsigned char)((currentOffset & 0xffff) >> 8 & 0xff);
          while((_Bool)0);
          do
          {

          __CPROVER_DUMP_L71:
            ;
            *((unsigned char *)((unsigned char *)(header + (signed long int)42) + (signed long int)2)) = (unsigned char)(currentOffset >> 16 & 0xff);
            do
              *((unsigned char *)((unsigned char *)((unsigned char *)(header + (signed long int)42) + (signed long int)2) + (signed long int)1)) = (unsigned char)((currentOffset >> 16) >> 8 & 0xff);
            while((_Bool)0);
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        unsigned long int return_value_fwrite_13;
        return_value_fwrite_13=fwrite((const void *)header, (unsigned long int)1, (unsigned long int)46, fpOutCD);
        if(return_value_fwrite_13 == 46ul)
        {
          offsetCD = offsetCD + 46;
          if(fnsize >= 1u)
          {
            unsigned long int return_value_fwrite_10;
            return_value_fwrite_10=fwrite((const void *)filename, (unsigned long int)1, (unsigned long int)fnsize, fpOutCD);
            if(return_value_fwrite_10 == (unsigned long int)fnsize)
              offsetCD = offsetCD + (signed int)fnsize;

            else
            {
              err = -1;
              break;
            }
          }

          else
          {
            err = -2;
            break;
          }
          if(extsize >= 1u)
          {
            unsigned long int return_value_fwrite_11;
            return_value_fwrite_11=fwrite((const void *)extra, (unsigned long int)1, (unsigned long int)extsize, fpOutCD);
            if(return_value_fwrite_11 == (unsigned long int)extsize)
              offsetCD = offsetCD + (signed int)extsize;

            else
            {
              err = -1;
              break;
            }
          }

          if(comsize >= 1ul)
          {
            unsigned long int return_value_fwrite_12;
            return_value_fwrite_12=fwrite((const void *)comment, (unsigned long int)1, comsize, fpOutCD);
            if(return_value_fwrite_12 == comsize)
              offsetCD = offsetCD + (signed int)comsize;

            else
            {
              err = -1;
              break;
            }
          }

        }

        else
        {
          err = -1;
          break;
        }
        entries = entries + 1;
      }

      else
        break;
    }
    while((_Bool)1);
    signed int entriesZip = entries;
    char unzRepair__1__1__2__header[22l];
    const char *unzRepair__1__1__2__comment = "";
    unsigned long int unzRepair__1__1__2__comsize;
    unzRepair__1__1__2__comsize=strlen(unzRepair__1__1__2__comment);
    if(entriesZip >= 65536)
      entriesZip = 0xffff;

    do
    {

    __CPROVER_DUMP_L88:
      ;
      *((unsigned char *)unzRepair__1__1__2__header) = (unsigned char)(0x06054b50 & 0xffff & 0xff);
      do
        *((unsigned char *)((unsigned char *)unzRepair__1__1__2__header + (signed long int)1)) = (unsigned char)((0x06054b50 & 0xffff) >> 8 & 0xff);
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L90:
        ;
        *((unsigned char *)((unsigned char *)unzRepair__1__1__2__header + (signed long int)2)) = (unsigned char)(0x06054b50 >> 16 & 0xff);
        do
          *((unsigned char *)((unsigned char *)((unsigned char *)unzRepair__1__1__2__header + (signed long int)2) + (signed long int)1)) = (unsigned char)((0x06054b50 >> 16) >> 8 & 0xff);
        while((_Bool)0);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L92:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)4)) = (unsigned char)(0 & 0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)4) + (signed long int)1)) = (unsigned char)(0 >> 8 & 0xff);
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L94:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)6)) = (unsigned char)(0 & 0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)6) + (signed long int)1)) = (unsigned char)(0 >> 8 & 0xff);
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L96:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)8)) = (unsigned char)(entriesZip & 0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)8) + (signed long int)1)) = (unsigned char)(entriesZip >> 8 & 0xff);
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L98:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)10)) = (unsigned char)(entriesZip & 0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)10) + (signed long int)1)) = (unsigned char)(entriesZip >> 8 & 0xff);
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L100:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)12)) = (unsigned char)(offsetCD & 0xffff & 0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)12) + (signed long int)1)) = (unsigned char)((offsetCD & 0xffff) >> 8 & 0xff);
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L102:
        ;
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)12) + (signed long int)2)) = (unsigned char)(offsetCD >> 16 & 0xff);
        do
          *((unsigned char *)((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)12) + (signed long int)2) + (signed long int)1)) = (unsigned char)((offsetCD >> 16) >> 8 & 0xff);
        while((_Bool)0);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L104:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)16)) = (unsigned char)(offset & 0xffff & 0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)16) + (signed long int)1)) = (unsigned char)((offset & 0xffff) >> 8 & 0xff);
      while((_Bool)0);
      do
      {

      __CPROVER_DUMP_L106:
        ;
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)16) + (signed long int)2)) = (unsigned char)(offset >> 16 & 0xff);
        do
          *((unsigned char *)((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)16) + (signed long int)2) + (signed long int)1)) = (unsigned char)((offset >> 16) >> 8 & 0xff);
        while((_Bool)0);
      }
      while((_Bool)0);
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L108:
      ;
      *((unsigned char *)(unzRepair__1__1__2__header + (signed long int)20)) = (unsigned char)(unzRepair__1__1__2__comsize & (unsigned long int)0xff);
      do
        *((unsigned char *)((unsigned char *)(unzRepair__1__1__2__header + (signed long int)20) + (signed long int)1)) = (unsigned char)(unzRepair__1__1__2__comsize >> 8 & (unsigned long int)0xff);
      while((_Bool)0);
    }
    while((_Bool)0);
    unsigned long int return_value_fwrite_15;
    return_value_fwrite_15=fwrite((const void *)unzRepair__1__1__2__header, (unsigned long int)1, (unsigned long int)22, fpOutCD);
    if(return_value_fwrite_15 == 22ul)
    {
      if(unzRepair__1__1__2__comsize >= 1ul)
      {
        unsigned long int return_value_fwrite_14;
        return_value_fwrite_14=fwrite((const void *)unzRepair__1__1__2__comment, (unsigned long int)1, unzRepair__1__1__2__comsize, fpOutCD);
        if(!(return_value_fwrite_14 == unzRepair__1__1__2__comsize))
          err = -1;

      }

    }

    else
      err = -1;
    fclose(fpOutCD);
    if(err == 0)
    {
      fpOutCD=fopen(fileOutTmp, "rb");
      if(!(fpOutCD == ((struct _IO_FILE *)NULL)))
      {
        signed int nRead;
        char buffer[8192l];
        do
        {
          return_value_fread_16=fread((void *)buffer, (unsigned long int)1, sizeof(char [8192l]) /*8192ul*/ , fpOutCD);
          nRead = (signed int)return_value_fread_16;
          if(!(nRead >= 1))
            break;

          unsigned long int return_value_fwrite_17;
          return_value_fwrite_17=fwrite((const void *)buffer, (unsigned long int)1, (unsigned long int)nRead, fpOut);
          if(!((signed int)return_value_fwrite_17 == nRead))
          {
            err = -1;
            break;
          }

        }
        while((_Bool)1);
        fclose(fpOutCD);
      }

    }

    fclose(fpZip);
    fclose(fpOut);
    remove(fileOutTmp);
    if(err == 0)
    {
      if(!(nRecovered == ((unsigned long int *)NULL)))
        *nRecovered = (unsigned long int)entries;

      if(!(bytesRecovered == ((unsigned long int *)NULL)))
        *bytesRecovered = totalBytes;

    }

  }

  else
    err = -2;
  return err;
}

// unzSetOffset
// file proxy/../minizip/unzip.h line 429
extern signed int unzSetOffset(void *file, unsigned long int pos)
{
  signed int return_value_unzSetOffset64_1;
  return_value_unzSetOffset64_1=unzSetOffset64(file, pos);
  return return_value_unzSetOffset64_1;
}

// unzSetOffset64
// file minizip/unzip.c line 2104
extern signed int unzSetOffset64(void *file, unsigned long long int pos)
{
  struct anonymous_0 *s;
  signed int err;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    s->pos_in_central_dir = pos;
    s->num_file = s->gi.number_entry;
    err=unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, (char *)(void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, (char *)(void *)0, (unsigned long int)0);
    s->current_file_ok = (unsigned long long int)(err == 0);
    return err;
  }
}

// unzStringFileNameCompare
// file minizip/unzip.c line 390
extern signed int unzStringFileNameCompare(const char *fileName1, const char *fileName2, signed int iCaseSensitivity)
{
  if(iCaseSensitivity == 0)
    iCaseSensitivity = 1;

  signed int return_value_strcmp_1;
  if(iCaseSensitivity == 1)
  {
    return_value_strcmp_1=strcmp(fileName1, fileName2);
    return return_value_strcmp_1;
  }

  else
  {
    signed int return_value_strcmpcasenosensitive_internal_2;
    return_value_strcmpcasenosensitive_internal_2=strcmpcasenosensitive_internal(fileName1, fileName2);
    return return_value_strcmpcasenosensitive_internal_2;
  }
}

// unzeof
// file minizip/unzip.c line 1924
extern signed int unzeof(void *file)
{
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  if(file == NULL)
    return -102;

  else
  {
    s = (struct anonymous_0 *)file;
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return -102;

    else
      if(pfile_in_zip_read_info->rest_read_uncompressed == 0ul)
        return 1;

      else
        return 0;
  }
}

// unztell
// file minizip/unzip.c line 1889
extern signed long int unztell(void *file)
{
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  if(file == NULL)
    return (signed long int)-102;

  else
  {
    s = (struct anonymous_0 *)file;
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return (signed long int)-102;

    else
      return (signed long int)pfile_in_zip_read_info->stream.total_out;
  }
}

// unztell64
// file minizip/unzip.c line 1904
extern unsigned long long int unztell64(void *file)
{
  struct anonymous_0 *s;
  struct anonymous *pfile_in_zip_read_info;
  if(file == NULL)
    return (unsigned long long int)-1;

  else
  {
    s = (struct anonymous_0 *)file;
    pfile_in_zip_read_info = s->pfile_in_zip_read;
    if(pfile_in_zip_read_info == ((struct anonymous *)NULL))
      return (unsigned long long int)-1;

    else
      return pfile_in_zip_read_info->total_out_64;
  }
}

// update_keys
// file minizip/crypt.h line 48
static signed int update_keys(unsigned long int *pkeys, const unsigned int *pcrc_32_tab, signed int c)
{
  pkeys[(signed long int)0] = (unsigned long int)pcrc_32_tab[(signed long int)(((signed int)pkeys[(signed long int)0] ^ c) & 0xff)] ^ pkeys[(signed long int)0] >> 8;
  pkeys[(signed long int)1] = pkeys[(signed long int)1] + (pkeys[(signed long int)0] & (unsigned long int)0xff);
  pkeys[(signed long int)1] = pkeys[(signed long int)1] * (unsigned long int)134775813L + (unsigned long int)1;
  signed int keyshift = (signed int)(pkeys[(signed long int)1] >> 24);
  pkeys[(signed long int)2] = (unsigned long int)pcrc_32_tab[(signed long int)(((signed int)pkeys[(signed long int)2] ^ keyshift) & 0xff)] ^ pkeys[(signed long int)2] >> 8;
  return c;
}

// zip64FlushWriteBuffer
// file minizip/zip.c line 1363
static signed int zip64FlushWriteBuffer(struct anonymous_9 *zi)
{
  signed int err = 0;
  if(!(zi->ci.encrypt == 0))
  {
    unsigned int i;
    signed int t;
    i = (unsigned int)0;
    for( ; !(i >= zi->ci.pos_in_buffered_data); i = i + 1u)
    {
      t=decrypt_byte(zi->ci.keys, zi->ci.pcrc_32_tab);
      update_keys(zi->ci.keys, zi->ci.pcrc_32_tab, (signed int)zi->ci.buffered_data[(signed long int)i]);
      zi->ci.buffered_data[(signed long int)i] = (unsigned char)(t ^ (signed int)zi->ci.buffered_data[(signed long int)i]);
    }
  }

  unsigned long int return_value;
  return_value=zi->z_filefunc.zfile_func64.zwrite_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream, (const void *)zi->ci.buffered_data, (unsigned long int)zi->ci.pos_in_buffered_data);
  if(!(return_value == (unsigned long int)zi->ci.pos_in_buffered_data))
    err = -1;

  zi->ci.totalCompressedData = zi->ci.totalCompressedData + (unsigned long long int)zi->ci.pos_in_buffered_data;
  zi->ci.totalUncompressedData = zi->ci.totalUncompressedData + zi->ci.stream.total_in;
  zi->ci.stream.total_in = (unsigned long int)0;
  zi->ci.pos_in_buffered_data = (unsigned int)0;
  return err;
}

// zip64local_SearchCentralDir
// file minizip/zip.c line 480
static unsigned long long int zip64local_SearchCentralDir(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream)
{
  unsigned char *buf;
  unsigned long long int uSizeFile;
  unsigned long long int uBackRead;
  unsigned long long int uMaxBack = (unsigned long long int)0xffff;
  unsigned long long int uPosFound = (unsigned long long int)0;
  signed long int return_value_call_zseek64_1;
  return_value_call_zseek64_1=call_zseek64(&(*pzlib_filefunc_def), filestream, (unsigned long long int)0, 2);
  signed int tmp_post_4;
  if(!(return_value_call_zseek64_1 == 0l))
    return (unsigned long long int)0;

  else
  {
    uSizeFile=call_ztell64(&(*pzlib_filefunc_def), filestream);
    if(!(uSizeFile >= uMaxBack))
      uMaxBack = uSizeFile;

    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(0x400 + 4));
    buf = (unsigned char *)return_value_malloc_2;
    if(buf == ((unsigned char *)NULL))
      return (unsigned long long int)0;

    else
    {
      uBackRead = (unsigned long long int)4;
      if(!(uBackRead >= uMaxBack))
      {
        unsigned long int uReadSize;
        unsigned long long int uReadPos;
        signed int i;
        if(!(uMaxBack >= 1024ul + uBackRead))
          uBackRead = uMaxBack;

        else
          uBackRead = uBackRead + (unsigned long long int)0x400;
        uReadPos = uSizeFile - uBackRead;
        uReadSize = (unsigned long int)(0x400 + 4) < uSizeFile - uReadPos ? (unsigned long int)(0x400 + 4) : (unsigned long int)(uSizeFile - uReadPos);
        signed long int return_value_call_zseek64_3;
        return_value_call_zseek64_3=call_zseek64(&(*pzlib_filefunc_def), filestream, uReadPos, 0);
        if(return_value_call_zseek64_3 == 0l)
        {
          unsigned long int return_value;
          return_value=pzlib_filefunc_def->zfile_func64.zread_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (void *)buf, uReadSize);
          if(return_value == uReadSize)
          {
            i = (signed int)uReadSize - 3;
            tmp_post_4 = i;
            i = i - 1;
            if(tmp_post_4 >= 1)
            {
              if((signed int)buf[(signed long int)i] == 0x50)
                uPosFound = uReadPos + (unsigned long int)i;

            }

          }

        }

      }

      if(!(buf == ((unsigned char *)NULL)))
        free((void *)buf);

      return uPosFound;
    }
  }
}

// zip64local_SearchCentralDir64
// file minizip/zip.c line 542
static unsigned long long int zip64local_SearchCentralDir64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream)
{
  unsigned char *buf;
  unsigned long long int uSizeFile;
  unsigned long long int uBackRead;
  unsigned long long int uMaxBack = (unsigned long long int)0xffff;
  unsigned long long int uPosFound = (unsigned long long int)0;
  unsigned long int uL;
  unsigned long long int relativeOffset;
  signed long int return_value_call_zseek64_1;
  return_value_call_zseek64_1=call_zseek64(&(*pzlib_filefunc_def), filestream, (unsigned long long int)0, 2);
  signed int tmp_post_4;
  if(!(return_value_call_zseek64_1 == 0l))
    return (unsigned long long int)0;

  else
  {
    uSizeFile=call_ztell64(&(*pzlib_filefunc_def), filestream);
    if(!(uSizeFile >= uMaxBack))
      uMaxBack = uSizeFile;

    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(0x400 + 4));
    buf = (unsigned char *)return_value_malloc_2;
    if(buf == ((unsigned char *)NULL))
      return (unsigned long long int)0;

    else
    {
      uBackRead = (unsigned long long int)4;
      if(!(uBackRead >= uMaxBack))
      {
        unsigned long int uReadSize;
        unsigned long long int uReadPos;
        signed int i;
        if(!(uMaxBack >= 1024ul + uBackRead))
          uBackRead = uMaxBack;

        else
          uBackRead = uBackRead + (unsigned long long int)0x400;
        uReadPos = uSizeFile - uBackRead;
        uReadSize = (unsigned long int)(0x400 + 4) < uSizeFile - uReadPos ? (unsigned long int)(0x400 + 4) : (unsigned long int)(uSizeFile - uReadPos);
        signed long int return_value_call_zseek64_3;
        return_value_call_zseek64_3=call_zseek64(&(*pzlib_filefunc_def), filestream, uReadPos, 0);
        if(return_value_call_zseek64_3 == 0l)
        {
          unsigned long int return_value;
          return_value=pzlib_filefunc_def->zfile_func64.zread_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (void *)buf, uReadSize);
          if(return_value == uReadSize)
          {
            i = (signed int)uReadSize - 3;
            tmp_post_4 = i;
            i = i - 1;
            if(tmp_post_4 >= 1)
            {
              if((signed int)buf[(signed long int)i] == 0x50)
                uPosFound = uReadPos + (unsigned long int)i;

            }

          }

        }

      }

      if(!(buf == ((unsigned char *)NULL)))
        free((void *)buf);

      if(uPosFound == 0ul)
        return (unsigned long long int)0;

      else
      {
        signed long int return_value_call_zseek64_5;
        return_value_call_zseek64_5=call_zseek64(&(*pzlib_filefunc_def), filestream, uPosFound, 0);
        if(!(return_value_call_zseek64_5 == 0l))
          return (unsigned long long int)0;

        else
        {
          signed int return_value_zip64local_getLong_6;
          return_value_zip64local_getLong_6=zip64local_getLong(pzlib_filefunc_def, filestream, &uL);
          if(!(return_value_zip64local_getLong_6 == 0))
            return (unsigned long long int)0;

          else
          {
            signed int return_value_zip64local_getLong_7;
            return_value_zip64local_getLong_7=zip64local_getLong(pzlib_filefunc_def, filestream, &uL);
            if(!(return_value_zip64local_getLong_7 == 0))
              return (unsigned long long int)0;

            else
              if(!(uL == 0ul))
                return (unsigned long long int)0;

              else
              {
                signed int return_value_zip64local_getLong64_8;
                return_value_zip64local_getLong64_8=zip64local_getLong64(pzlib_filefunc_def, filestream, &relativeOffset);
                if(!(return_value_zip64local_getLong64_8 == 0))
                  return (unsigned long long int)0;

                else
                {
                  signed int return_value_zip64local_getLong_9;
                  return_value_zip64local_getLong_9=zip64local_getLong(pzlib_filefunc_def, filestream, &uL);
                  if(!(return_value_zip64local_getLong_9 == 0))
                    return (unsigned long long int)0;

                  else
                    if(!(uL == 1ul))
                      return (unsigned long long int)0;

                    else
                    {
                      signed long int return_value_call_zseek64_10;
                      return_value_call_zseek64_10=call_zseek64(&(*pzlib_filefunc_def), filestream, relativeOffset, 0);
                      if(!(return_value_call_zseek64_10 == 0l))
                        return (unsigned long long int)0;

                      else
                      {
                        signed int return_value_zip64local_getLong_11;
                        return_value_zip64local_getLong_11=zip64local_getLong(pzlib_filefunc_def, filestream, &uL);
                        if(!(return_value_zip64local_getLong_11 == 0))
                          return (unsigned long long int)0;

                        else
                          if(!(uL == 101075792ul))
                            return (unsigned long long int)0;

                          else
                            return relativeOffset;
                      }
                    }
                }
              }
          }
        }
      }
    }
  }
}

// zip64local_TmzDateToDosDate
// file minizip/zip.c line 332
static unsigned long int zip64local_TmzDateToDosDate(const struct tm_zip_s *ptm)
{
  unsigned long int year = (unsigned long int)ptm->tm_year;
  if(year >= 1980ul)
    year = year - (unsigned long int)1980;

  else
    if(year >= 80ul)
      year = year - (unsigned long int)80;

  return (unsigned long int)((unsigned long int)(ptm->tm_mday + (unsigned int)32 * (ptm->tm_mon + (unsigned int)1)) + (unsigned long int)512 * year << 16) | (unsigned long int)(ptm->tm_sec / (unsigned int)2 + (unsigned int)32 * ptm->tm_min) + (unsigned long int)2048 * (unsigned long int)ptm->tm_hour;
}

// zip64local_getByte
// file minizip/zip.c line 349
static signed int zip64local_getByte(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, signed int *pi)
{
  unsigned char c;
  signed int err;
  unsigned long int return_value;
  return_value=pzlib_filefunc_def->zfile_func64.zread_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (void *)&c, (unsigned long int)1);
  err = (signed int)return_value;
  if(err == 1)
  {
    *pi = (signed int)c;
    return 0;
  }

  else
  {
    signed int return_value_1;
    return_value_1=pzlib_filefunc_def->zfile_func64.zerror_file(pzlib_filefunc_def->zfile_func64.opaque, filestream);
    if(!(return_value_1 == 0))
      return -1;

    else
      return 0;
  }
}

// zip64local_getLong
// file minizip/zip.c line 395
static signed int zip64local_getLong(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX)
{
  unsigned long int x;
  signed int i = 0;
  signed int err;
  err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  x = (unsigned long int)i;
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long int)i << 8);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long int)i << 16);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long int)i << 24);
  if(err == 0)
    *pX = x;

  else
    *pX = (unsigned long int)0;
  return err;
}

// zip64local_getLong64
// file minizip/zip.c line 426
static signed int zip64local_getLong64(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long long int *pX)
{
  unsigned long long int x;
  signed int i = 0;
  signed int err;
  err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  x = (unsigned long long int)i;
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 8);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 16);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 24);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 32);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 40);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 48);
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long long int)i << 56);
  if(err == 0)
    *pX = x;

  else
    *pX = (unsigned long long int)0;
  return err;
}

// zip64local_getShort
// file minizip/zip.c line 373
static signed int zip64local_getShort(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long int *pX)
{
  unsigned long int x;
  signed int i = 0;
  signed int err;
  err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  x = (unsigned long int)i;
  if(err == 0)
    err=zip64local_getByte(pzlib_filefunc_def, filestream, &i);

  x = x + ((unsigned long int)i << 8);
  if(err == 0)
    *pX = x;

  else
    *pX = (unsigned long int)0;
  return err;
}

// zip64local_putValue
// file minizip/zip.c line 287
static signed int zip64local_putValue(const struct zlib_filefunc64_32_def_s *pzlib_filefunc_def, void *filestream, unsigned long long int x, signed int nbByte)
{
  unsigned char buf[8l];
  signed int n = 0;
  for( ; !(n >= nbByte); n = n + 1)
  {
    buf[(signed long int)n] = (unsigned char)(x & (unsigned long int)0xff);
    x = x >> 8;
  }
  if(!(x == 0ul))
  {
    n = 0;
    for( ; !(n >= nbByte); n = n + 1)
      buf[(signed long int)n] = (unsigned char)0xff;
  }

  unsigned long int return_value;
  return_value=pzlib_filefunc_def->zfile_func64.zwrite_file(pzlib_filefunc_def->zfile_func64.opaque, filestream, (const void *)buf, (unsigned long int)nbByte);
  if(!(return_value == (unsigned long int)nbByte))
    return -1;

  else
    return 0;
}

// zip64local_putValue_inmemory
// file minizip/zip.c line 311
static void zip64local_putValue_inmemory(void *dest, unsigned long long int x, signed int nbByte)
{
  unsigned char *buf = (unsigned char *)dest;
  signed int n = 0;
  for( ; !(n >= nbByte); n = n + 1)
  {
    buf[(signed long int)n] = (unsigned char)(x & (unsigned long int)0xff);
    x = x >> 8;
  }
  if(!(x == 0ul))
  {
    n = 0;
    for( ; !(n >= nbByte); n = n + 1)
      buf[(signed long int)n] = (unsigned char)0xff;
  }

}

// zipClose
// file proxy/../minizip/zip.h line 343
extern signed int zipClose(void *file, const char *global_comment)
{
  struct anonymous_9 *zi;
  signed int err = 0;
  unsigned long int size_centraldir = (unsigned long int)0;
  unsigned long long int centraldir_pos_inzip;
  unsigned long long int pos;
  _Bool tmp_if_expr_1;
  if(file == NULL)
    return -102;

  else
  {
    zi = (struct anonymous_9 *)file;
    if(zi->in_opened_file_inzip == 1)
      err=zipCloseFileInZip(file);

    if(global_comment == ((const char *)NULL))
      global_comment = zi->globalcomment;

    centraldir_pos_inzip=call_ztell64(&zi->z_filefunc, zi->filestream);
    if(err == 0)
    {
      struct linkedlist_datablock_internal_s *ldi = zi->central_dir.first_block;
      for( ; !(ldi == ((struct linkedlist_datablock_internal_s *)NULL)); ldi = ldi->next_datablock)
      {
        if(err == 0)
        {
          if(ldi->filled_in_this_block >= 1ul)
          {
            unsigned long int return_value;
            return_value=zi->z_filefunc.zfile_func64.zwrite_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream, (const void *)ldi->data, ldi->filled_in_this_block);
            if(!(return_value == ldi->filled_in_this_block))
              err = -1;

          }

        }

        size_centraldir = size_centraldir + ldi->filled_in_this_block;
      }
    }

    free_linkedlist(&zi->central_dir);
    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
    if(pos >= 4294967295ul)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = zi->number_entry > (unsigned long int)0xFFFF ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      unsigned long long int Zip64EOCDpos;
      Zip64EOCDpos=call_ztell64(&zi->z_filefunc, zi->filestream);
      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
    }

    if(err == 0)
      err=Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

    if(err == 0)
      err=Write_GlobalComment(zi, global_comment);

    signed int return_value_1;
    return_value_1=zi->z_filefunc.zfile_func64.zclose_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream);
    if(!(return_value_1 == 0))
    {
      if(err == 0)
        err = -1;

    }

    if(!(zi->globalcomment == ((char *)NULL)))
      free((void *)zi->globalcomment);

    if(!(zi == ((struct anonymous_9 *)NULL)))
      free((void *)zi);

    return err;
  }
}

// zipCloseFileInZip
// file proxy/../minizip/zip.h line 324
extern signed int zipCloseFileInZip(void *file)
{
  signed int return_value_zipCloseFileInZipRaw_1;
  return_value_zipCloseFileInZipRaw_1=zipCloseFileInZipRaw(file, (unsigned long int)0, (unsigned long int)0);
  return return_value_zipCloseFileInZipRaw_1;
}

// zipCloseFileInZipRaw
// file minizip/zip.c line 1509
extern signed int zipCloseFileInZipRaw(void *file, unsigned long int uncompressed_size, unsigned long int crc32)
{
  signed int return_value_zipCloseFileInZipRaw64_1;
  return_value_zipCloseFileInZipRaw64_1=zipCloseFileInZipRaw64(file, uncompressed_size, crc32);
  return return_value_zipCloseFileInZipRaw64_1;
}

// zipCloseFileInZipRaw64
// file minizip/zip.c line 1514
extern signed int zipCloseFileInZipRaw64(void *file, unsigned long long int uncompressed_size, unsigned long int crc32)
{
  struct anonymous_9 *zi;
  unsigned long long int compressed_size;
  unsigned long int invalidValue = (unsigned long int)0xffffffff;
  signed short int datasize = (signed short int)0;
  signed int err = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  if(file == NULL)
    return -102;

  else
  {
    zi = (struct anonymous_9 *)file;
    if(zi->in_opened_file_inzip == 0)
      return -102;

    else
    {
      zi->ci.stream.avail_in = (unsigned int)0;
      if(zi->ci.method == 8)
        tmp_if_expr_2 = !(zi->ci.raw != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        while(err == 0)
        {
          unsigned long int uTotalOutBefore;
          if(zi->ci.stream.avail_out == 0u)
          {
            signed int return_value_zip64FlushWriteBuffer_1;
            return_value_zip64FlushWriteBuffer_1=zip64FlushWriteBuffer(zi);
            if(return_value_zip64FlushWriteBuffer_1 == -1)
              err = -1;

            zi->ci.stream.avail_out = (unsigned int)(64 * 1024);
            zi->ci.stream.next_out = zi->ci.buffered_data;
          }

          uTotalOutBefore = zi->ci.stream.total_out;
          err=deflate(&zi->ci.stream, 4);
          zi->ci.pos_in_buffered_data = zi->ci.pos_in_buffered_data + (unsigned int)(zi->ci.stream.total_out - uTotalOutBefore);
        }

      if(err == 1)
        err = 0;

      if(zi->ci.pos_in_buffered_data >= 1u)
      {
        if(err == 0)
        {
          signed int return_value_zip64FlushWriteBuffer_3;
          return_value_zip64FlushWriteBuffer_3=zip64FlushWriteBuffer(zi);
          if(return_value_zip64FlushWriteBuffer_3 == -1)
            err = -1;

        }

      }

      if(zi->ci.method == 8)
      {
        if(zi->ci.raw == 0)
        {
          signed int tmp_err;
          tmp_err=deflateEnd(&zi->ci.stream);
          if(err == 0)
            err = tmp_err;

          zi->ci.stream_initialised = 0;
        }

      }

      if(zi->ci.raw == 0)
      {
        crc32 = (unsigned long int)zi->ci.crc32;
        uncompressed_size = zi->ci.totalUncompressedData;
      }

      compressed_size = zi->ci.totalCompressedData;
      compressed_size = compressed_size + (unsigned long long int)zi->ci.crypt_header_size;
      if(compressed_size >= 4294967295ul || uncompressed_size >= 4294967295ul)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = zi->ci.pos_local_header >= (unsigned long int)0xffffffff ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)4), (unsigned long int)45, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)6), (unsigned long int)45, 2);
      }

      zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)16), crc32, 4);
      if(compressed_size >= 4294967295ul)
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)20), invalidValue, 4);

      else
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)20), compressed_size, 4);
      if(zi->ci.stream.data_type == 1)
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)36), (unsigned long int)1, 2);

      if(uncompressed_size >= 4294967295ul)
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)24), invalidValue, 4);

      else
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)24), uncompressed_size, 4);
      if(uncompressed_size >= 4294967295ul)
        datasize = datasize + (signed short int)8;

      if(compressed_size >= 4294967295ul)
        datasize = datasize + (signed short int)8;

      if(zi->ci.pos_local_header >= 4294967295ul)
        datasize = datasize + (signed short int)8;

      if((signed int)datasize >= 1)
      {
        char *p = (char *)(void *)0;
        if(!(zi->ci.size_centralExtraFree >= (unsigned long int)(4 + (signed int)datasize)))
          return -103;

        p = zi->ci.central_header + (signed long int)zi->ci.size_centralheader;
        zip64local_putValue_inmemory((void *)p, (unsigned long long int)0x0001, 2);
        p = p + (signed long int)2;
        zip64local_putValue_inmemory((void *)p, (unsigned long long int)datasize, 2);
        p = p + (signed long int)2;
        if(uncompressed_size >= 4294967295ul)
        {
          zip64local_putValue_inmemory((void *)p, uncompressed_size, 8);
          p = p + (signed long int)8;
        }

        if(compressed_size >= 4294967295ul)
        {
          zip64local_putValue_inmemory((void *)p, compressed_size, 8);
          p = p + (signed long int)8;
        }

        if(zi->ci.pos_local_header >= 4294967295ul)
        {
          zip64local_putValue_inmemory((void *)p, zi->ci.pos_local_header, 8);
          p = p + (signed long int)8;
        }

        zi->ci.size_centralExtraFree = zi->ci.size_centralExtraFree - (unsigned long int)((signed int)datasize + 4);
        zi->ci.size_centralheader = zi->ci.size_centralheader + (unsigned long int)((signed int)datasize + 4);
        zi->ci.size_centralExtra = zi->ci.size_centralExtra + (unsigned long int)((signed int)datasize + 4);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)30), (unsigned long int)zi->ci.size_centralExtra, 2);
      }

      if(err == 0)
        err=add_data_in_datablock(&zi->central_dir, (const void *)zi->ci.central_header, (unsigned long int)zi->ci.size_centralheader);

      free((void *)zi->ci.central_header);
      if(err == 0)
      {
        unsigned long long int cur_pos_inzip;
        cur_pos_inzip=call_ztell64(&zi->z_filefunc, zi->filestream);
        signed long int return_value_call_zseek64_5;
        return_value_call_zseek64_5=call_zseek64(&zi->z_filefunc, zi->filestream, zi->ci.pos_local_header + (unsigned long int)14, 0);
        if(!(return_value_call_zseek64_5 == 0l))
          err = -1;

        if(err == 0)
          err=zip64local_putValue(&zi->z_filefunc, zi->filestream, crc32, 4);

        if(compressed_size >= 4294967295ul || uncompressed_size >= 4294967295ul)
        {
          if(zi->ci.pos_zip64extrainfo >= 1ul)
          {
            signed long int return_value_call_zseek64_6;
            return_value_call_zseek64_6=call_zseek64(&zi->z_filefunc, zi->filestream, zi->ci.pos_zip64extrainfo + (unsigned long int)4, 0);
            if(!(return_value_call_zseek64_6 == 0l))
              err = -1;

            if(err == 0)
              err=zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);

            if(err == 0)
              err=zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);

          }

          else
            err = -103;
        }

        else
        {
          if(err == 0)
            err=zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 4);

          if(err == 0)
            err=zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 4);

        }
        signed long int return_value_call_zseek64_7;
        return_value_call_zseek64_7=call_zseek64(&zi->z_filefunc, zi->filestream, cur_pos_inzip, 0);
        if(!(return_value_call_zseek64_7 == 0l))
          err = -1;

      }

      zi->number_entry = zi->number_entry + 1ull;
      zi->in_opened_file_inzip = 0;
      return err;
    }
  }
}

// zipFlush
// file proxy/../minizip/zip.h line 319
extern signed int zipFlush(void *file)
{
  struct anonymous_9 *zi;
  if(file == NULL)
    return -102;

  else
  {
    zi = (struct anonymous_9 *)file;
    signed int return_value;
    return_value=zi->z_filefunc.zfile_func64.zflush_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream);
    return return_value;
  }
}

// zipOpen
// file proxy/../minizip/zip.h line 116
extern void * zipOpen(const char *pathname, signed int append)
{
  void *return_value_zipOpen3_1;
  return_value_zipOpen3_1=zipOpen3((const void *)pathname, append, (const char **)(void *)0, (struct zlib_filefunc64_32_def_s *)(void *)0);
  return return_value_zipOpen3_1;
}

// zipOpen2
// file minizip/zip.c line 920
extern void * zipOpen2(const char *pathname, signed int append, const char **globalcomment, struct zlib_filefunc_def_s *pzlib_filefunc32_def)
{
  void *return_value_zipOpen3_2;
  if(!(pzlib_filefunc32_def == ((struct zlib_filefunc_def_s *)NULL)))
  {
    struct zlib_filefunc64_32_def_s zlib_filefunc64_32_def_fill;
    fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill, pzlib_filefunc32_def);
    void *return_value_zipOpen3_1;
    return_value_zipOpen3_1=zipOpen3((const void *)pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
    return return_value_zipOpen3_1;
  }

  else
  {
    return_value_zipOpen3_2=zipOpen3((const void *)pathname, append, globalcomment, (struct zlib_filefunc64_32_def_s *)(void *)0);
    return return_value_zipOpen3_2;
  }
}

// zipOpen2_64
// file minizip/zip.c line 932
extern void * zipOpen2_64(const void *pathname, signed int append, const char **globalcomment, struct zlib_filefunc64_def_s *pzlib_filefunc_def)
{
  void *return_value_zipOpen3_2;
  if(!(pzlib_filefunc_def == ((struct zlib_filefunc64_def_s *)NULL)))
  {
    struct zlib_filefunc64_32_def_s zlib_filefunc64_32_def_fill;
    zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
    zlib_filefunc64_32_def_fill.ztell32_file = (signed long int (*)(void *, void *))(void *)0;
    zlib_filefunc64_32_def_fill.zseek32_file = (signed long int (*)(void *, void *, unsigned long int, signed int))(void *)0;
    void *return_value_zipOpen3_1;
    return_value_zipOpen3_1=zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
    return return_value_zipOpen3_1;
  }

  else
  {
    return_value_zipOpen3_2=zipOpen3(pathname, append, globalcomment, (struct zlib_filefunc64_32_def_s *)(void *)0);
    return return_value_zipOpen3_2;
  }
}

// zipOpen3
// file minizip/zip.c line 849
extern void * zipOpen3(const void *pathname, signed int append, const char **globalcomment, struct zlib_filefunc64_32_def_s *pzlib_filefunc64_32_def)
{
  struct anonymous_9 ziinit;
  struct anonymous_9 *zi;
  signed int err = 0;
  ziinit.z_filefunc.zseek32_file = (signed long int (*)(void *, void *, unsigned long int, signed int))(void *)0;
  ziinit.z_filefunc.ztell32_file = (signed long int (*)(void *, void *))(void *)0;
  if(pzlib_filefunc64_32_def == ((struct zlib_filefunc64_32_def_s *)NULL))
    fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);

  else
    ziinit.z_filefunc = *pzlib_filefunc64_32_def;
  ziinit.filestream=call_zopen64(&ziinit.z_filefunc, pathname, append == 0 ? 1 | 2 | 8 : 1 | 2 | 4);
  if(ziinit.filestream == NULL)
    return (void *)0;

  else
  {
    if(append == 1)
      call_zseek64(&ziinit.z_filefunc, ziinit.filestream, (unsigned long long int)0, 2);

    ziinit.begin_pos=call_ztell64(&ziinit.z_filefunc, ziinit.filestream);
    ziinit.in_opened_file_inzip = 0;
    ziinit.ci.stream_initialised = 0;
    ziinit.number_entry = (unsigned long long int)0;
    ziinit.add_position_when_writting_offset = (unsigned long long int)0;
    init_linkedlist(&ziinit.central_dir);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct anonymous_9) /*65960ul*/ );
    zi = (struct anonymous_9 *)return_value_malloc_1;
    if(zi == ((struct anonymous_9 *)NULL))
    {
      ziinit.z_filefunc.zfile_func64.zclose_file(ziinit.z_filefunc.zfile_func64.opaque, ziinit.filestream);
      return (void *)0;
    }

    else
    {
      ziinit.globalcomment = (char *)(void *)0;
      if(append == 2)
        err=LoadCentralDirectoryRecord(&ziinit);

      if(!(globalcomment == ((const char **)NULL)))
        *globalcomment = ziinit.globalcomment;

      if(!(err == 0))
      {
        if(!(ziinit.globalcomment == ((char *)NULL)))
          free((void *)ziinit.globalcomment);

        if(!(zi == ((struct anonymous_9 *)NULL)))
          free((void *)zi);

        return (void *)0;
      }

      else
      {
        *zi = ziinit;
        return (void *)zi;
      }
    }
  }
}

// zipOpen64
// file minizip/zip.c line 953
extern void * zipOpen64(const void *pathname, signed int append)
{
  void *return_value_zipOpen3_1;
  return_value_zipOpen3_1=zipOpen3(pathname, append, (const char **)(void *)0, (struct zlib_filefunc64_32_def_s *)(void *)0);
  return return_value_zipOpen3_1;
}

// zipOpenNewFileInZip
// file proxy/../minizip/zip.h line 152
extern signed int zipOpenNewFileInZip(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, 0, -15, 8, 0, (const char *)(void *)0, (unsigned long int)0, (unsigned long int)0x0, (unsigned long int)0, 0);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipOpenNewFileInZip2
// file minizip/zip.c line 1311
extern signed int zipOpenNewFileInZip2(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, -15, 8, 0, (const char *)(void *)0, (unsigned long int)0, (unsigned long int)0x0, (unsigned long int)0, 0);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipOpenNewFileInZip2_64
// file minizip/zip.c line 1324
extern signed int zipOpenNewFileInZip2_64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int zip64)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, -15, 8, 0, (const char *)(void *)0, (unsigned long int)0, (unsigned long int)0x0, (unsigned long int)0, zip64);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipOpenNewFileInZip3
// file minizip/zip.c line 1281
extern signed int zipOpenNewFileInZip3(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy, password, crcForCrypting, (unsigned long int)0x0, (unsigned long int)0, 0);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipOpenNewFileInZip3_64
// file minizip/zip.c line 1296
extern signed int zipOpenNewFileInZip3_64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting, signed int zip64)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy, password, crcForCrypting, (unsigned long int)0x0, (unsigned long int)0, zip64);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipOpenNewFileInZip4
// file minizip/zip.c line 1265
extern signed int zipOpenNewFileInZip4(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting, unsigned long int versionMadeBy, unsigned long int flagBase)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy, password, crcForCrypting, versionMadeBy, flagBase, 0);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipOpenNewFileInZip4_64
// file minizip/zip.c line 1055
extern signed int zipOpenNewFileInZip4_64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int raw, signed int windowBits, signed int memLevel, signed int strategy, const char *password, unsigned long int crcForCrypting, unsigned long int versionMadeBy, unsigned long int flagBase, signed int zip64)
{
  struct anonymous_9 *zi;
  unsigned int size_filename;
  unsigned int size_comment;
  unsigned int i;
  signed int err = 0;
  unsigned long int return_value_strlen_1;
  if(file == NULL)
    return -102;

  else
    if(!(method == 0) && !(method == 8))
      return -102;

    else
    {
      zi = (struct anonymous_9 *)file;
      if(zi->in_opened_file_inzip == 1)
      {
        err=zipCloseFileInZip(file);
        if(err == 0)
          goto __CPROVER_DUMP_L3;

        return err;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(filename == ((const char *)NULL))
          filename = "-";

        if(comment == ((const char *)NULL))
          size_comment = (unsigned int)0;

        else
        {
          return_value_strlen_1=strlen(comment);
          size_comment = (unsigned int)return_value_strlen_1;
        }
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(filename);
        size_filename = (unsigned int)return_value_strlen_2;
        if(zipfi == ((const struct anonymous_10 *)NULL))
          zi->ci.dosDate = (unsigned long int)0;

        else
          if(!(zipfi->dosDate == 0ul))
            zi->ci.dosDate = zipfi->dosDate;

          else
            zi->ci.dosDate=zip64local_TmzDateToDosDate(&zipfi->tmz_date);
        zi->ci.flag = flagBase;
        if(level == 8 || level == 9)
          zi->ci.flag = zi->ci.flag | (unsigned long int)2;

        if(level == 2)
          zi->ci.flag = zi->ci.flag | (unsigned long int)4;

        if(level == 1)
          zi->ci.flag = zi->ci.flag | (unsigned long int)6;

        if(!(password == ((const char *)NULL)))
          zi->ci.flag = zi->ci.flag | (unsigned long int)1;

        zi->ci.crc32 = (unsigned long int)0;
        zi->ci.method = method;
        zi->ci.encrypt = 0;
        zi->ci.stream_initialised = 0;
        zi->ci.pos_in_buffered_data = (unsigned int)0;
        zi->ci.raw = raw;
        zi->ci.pos_local_header=call_ztell64(&zi->z_filefunc, zi->filestream);
        zi->ci.size_centralheader = (unsigned long int)((unsigned int)0x2e + size_filename + size_extrafield_global + size_comment);
        zi->ci.size_centralExtraFree = (unsigned long int)32;
        void *return_value_malloc_3;
        return_value_malloc_3=malloc((unsigned long int)(unsigned int)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);
        zi->ci.central_header = (char *)return_value_malloc_3;
        zi->ci.size_centralExtra = (unsigned long int)size_extrafield_global;
        zip64local_putValue_inmemory((void *)zi->ci.central_header, (unsigned long int)0x02014b50, 4);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)4), (unsigned long int)versionMadeBy, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)6), (unsigned long int)20, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)8), (unsigned long int)zi->ci.flag, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)10), (unsigned long int)zi->ci.method, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)12), (unsigned long int)zi->ci.dosDate, 4);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)16), (unsigned long int)0, 4);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)20), (unsigned long int)0, 4);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)24), (unsigned long int)0, 4);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)28), (unsigned long int)size_filename, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)30), (unsigned long int)size_extrafield_global, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)32), (unsigned long int)size_comment, 2);
        zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)34), (unsigned long int)0, 2);
        if(zipfi == ((const struct anonymous_10 *)NULL))
          zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)36), (unsigned long int)0, 2);

        else
          zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)36), (unsigned long int)zipfi->internal_fa, 2);
        if(zipfi == ((const struct anonymous_10 *)NULL))
          zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)38), (unsigned long int)0, 4);

        else
          zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)38), (unsigned long int)zipfi->external_fa, 4);
        if(zi->ci.pos_local_header >= 4294967295ul)
          zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)42), (unsigned long int)0xffffffff, 4);

        else
          zip64local_putValue_inmemory((void *)(zi->ci.central_header + (signed long int)42), (unsigned long int)zi->ci.pos_local_header - zi->add_position_when_writting_offset, 4);
        i = (unsigned int)0;
        for( ; !(i >= size_filename); i = i + 1u)
          (zi->ci.central_header + (signed long int)0x2e)[(signed long int)i] = filename[(signed long int)i];
        i = (unsigned int)0;
        for( ; !(i >= size_extrafield_global); i = i + 1u)
          (zi->ci.central_header + (signed long int)0x2e + (signed long int)size_filename)[(signed long int)i] = ((const char *)extrafield_global)[(signed long int)i];
        i = (unsigned int)0;
        for( ; !(i >= size_comment); i = i + 1u)
          (zi->ci.central_header + (signed long int)0x2e + (signed long int)size_filename + (signed long int)size_extrafield_global)[(signed long int)i] = comment[(signed long int)i];
        if(zi->ci.central_header == ((char *)NULL))
          return -104;

        else
        {
          zi->ci.zip64 = zip64;
          zi->ci.totalCompressedData = (unsigned long long int)0;
          zi->ci.totalUncompressedData = (unsigned long long int)0;
          zi->ci.pos_zip64extrainfo = (unsigned long long int)0;
          err=Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);
          zi->ci.stream.avail_in = (unsigned int)0;
          zi->ci.stream.avail_out = (unsigned int)(64 * 1024);
          zi->ci.stream.next_out = zi->ci.buffered_data;
          zi->ci.stream.total_in = (unsigned long int)0;
          zi->ci.stream.total_out = (unsigned long int)0;
          zi->ci.stream.data_type = 0;
          if(err == 0)
          {
            if(zi->ci.method == 8)
            {
              if(zi->ci.raw == 0)
              {
                if(zi->ci.method == 8)
                {
                  zi->ci.stream.zalloc = (void * (*)(void *, unsigned int, unsigned int))0;
                  zi->ci.stream.zfree = (void (*)(void *, void *))0;
                  zi->ci.stream.opaque = (void *)0;
                  if(windowBits >= 1)
                    windowBits = -windowBits;

                  err=deflateInit2_(&zi->ci.stream, level, 8, windowBits, memLevel, strategy, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
                  if(err == 0)
                    zi->ci.stream_initialised = 8;

                }

              }

            }

          }

          zi->ci.crypt_header_size = 0;
          if(err == 0 && !(password == ((const char *)NULL)))
          {
            unsigned char bufHead[12l];
            unsigned int sizeHead;
            zi->ci.encrypt = 1;
            zi->ci.pcrc_32_tab=get_crc_table();
            signed int return_value_crypthead_4;
            return_value_crypthead_4=crypthead(password, bufHead, 12, zi->ci.keys, zi->ci.pcrc_32_tab, crcForCrypting);
            sizeHead = (unsigned int)return_value_crypthead_4;
            zi->ci.crypt_header_size = (signed int)sizeHead;
            unsigned long int return_value;
            return_value=zi->z_filefunc.zfile_func64.zwrite_file(zi->z_filefunc.zfile_func64.opaque, zi->filestream, (const void *)bufHead, (unsigned long int)sizeHead);
            if(!(return_value == (unsigned long int)sizeHead))
              err = -1;

          }

          if(err == 0)
            zi->in_opened_file_inzip = 1;

          return err;
        }
      }
    }
}

// zipOpenNewFileInZip64
// file minizip/zip.c line 1337
extern signed int zipOpenNewFileInZip64(void *file, const char *filename, const struct anonymous_10 *zipfi, const void *extrafield_local, unsigned int size_extrafield_local, const void *extrafield_global, unsigned int size_extrafield_global, const char *comment, signed int method, signed int level, signed int zip64)
{
  signed int return_value_zipOpenNewFileInZip4_64_1;
  return_value_zipOpenNewFileInZip4_64_1=zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local, extrafield_global, size_extrafield_global, comment, method, level, 0, -15, 8, 0, (const char *)(void *)0, (unsigned long int)0, (unsigned long int)0x0, (unsigned long int)0, zip64);
  return return_value_zipOpenNewFileInZip4_64_1;
}

// zipRemoveExtraInfoBlock
// file minizip/zip.c line 1964
extern signed int zipRemoveExtraInfoBlock(char *pData, signed int *dataLen, signed short int sHeader)
{
  char *p = pData;
  signed int size = 0;
  char *pNewHeader;
  char *pTmp;
  signed short int header;
  signed short int dataSize;
  signed int retVal = 0;
  _Bool tmp_if_expr_1;
  if(pData == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *dataLen < 4 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -102;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)*dataLen);
    pNewHeader = (char *)return_value_malloc_2;
    pTmp = pNewHeader;
    while(!(p >= pData + (signed long int)*dataLen))
    {
      header = *((signed short int *)p);
      dataSize = ((signed short int *)p)[(signed long int)1];
      if(header == sHeader)
        p = p + (signed long int)((signed int)dataSize + 4);

      else
      {
        memcpy((void *)pTmp, (const void *)p, (unsigned long int)((signed int)dataSize + 4));
        p = p + (signed long int)((signed int)dataSize + 4);
        size = size + (signed int)dataSize + 4;
      }
    }
    if(!(size >= *dataLen))
    {
      memset((void *)pData, 0, (unsigned long int)*dataLen);
      if(size >= 1)
        memcpy((void *)pData, (const void *)pNewHeader, (unsigned long int)size);

      *dataLen = size;
      retVal = 0;
    }

    else
      retVal = -1;
    if(!(pNewHeader == ((char *)NULL)))
      free((void *)pNewHeader);

    return retVal;
  }
}

// zipWriteInFileInZip
// file proxy/../minizip/zip.h line 312
extern signed int zipWriteInFileInZip(void *file, const void *buf, unsigned int len)
{
  struct anonymous_9 *zi;
  signed int err = 0;
  _Bool tmp_if_expr_2;
  if(file == NULL)
    return -102;

  else
  {
    zi = (struct anonymous_9 *)file;
    if(zi->in_opened_file_inzip == 0)
      return -102;

    else
    {
      zi->ci.crc32=crc32(zi->ci.crc32, (const unsigned char *)buf, (unsigned int)len);
      zi->ci.stream.next_in = (const unsigned char *)buf;
      zi->ci.stream.avail_in = len;
      while(err == 0)
      {
        if(!(zi->ci.stream.avail_in >= 1u))
          break;

        if(zi->ci.stream.avail_out == 0u)
        {
          signed int return_value_zip64FlushWriteBuffer_1;
          return_value_zip64FlushWriteBuffer_1=zip64FlushWriteBuffer(zi);
          if(return_value_zip64FlushWriteBuffer_1 == -1)
            err = -1;

          zi->ci.stream.avail_out = (unsigned int)(64 * 1024);
          zi->ci.stream.next_out = zi->ci.buffered_data;
        }

        if(!(err == 0))
          break;

        if(zi->ci.method == 8)
          tmp_if_expr_2 = !(zi->ci.raw != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
        {
          unsigned long int uTotalOutBefore = zi->ci.stream.total_out;
          err=deflate(&zi->ci.stream, 0);
          if(!(zi->ci.stream.total_out >= uTotalOutBefore))
          {
            signed int bBreak = 0;
            bBreak = bBreak + 1;
          }

          zi->ci.pos_in_buffered_data = zi->ci.pos_in_buffered_data + (unsigned int)(zi->ci.stream.total_out - uTotalOutBefore);
        }

        else
        {
          unsigned int copy_this;
          unsigned int i;
          if(!(zi->ci.stream.avail_in >= zi->ci.stream.avail_out))
            copy_this = zi->ci.stream.avail_in;

          else
            copy_this = zi->ci.stream.avail_out;
          i = (unsigned int)0;
          for( ; !(i >= copy_this); i = i + 1u)
            ((char *)zi->ci.stream.next_out)[(signed long int)i] = ((const char *)zi->ci.stream.next_in)[(signed long int)i];
          zi->ci.stream.avail_in = zi->ci.stream.avail_in - copy_this;
          zi->ci.stream.avail_out = zi->ci.stream.avail_out - copy_this;
          zi->ci.stream.next_in = zi->ci.stream.next_in + (signed long int)copy_this;
          zi->ci.stream.next_out = zi->ci.stream.next_out + (signed long int)copy_this;
          zi->ci.stream.total_in = zi->ci.stream.total_in + (unsigned long int)copy_this;
          zi->ci.stream.total_out = zi->ci.stream.total_out + (unsigned long int)copy_this;
          zi->ci.pos_in_buffered_data = zi->ci.pos_in_buffered_data + copy_this;
        }
      }
      return err;
    }
  }
}

