// #anon_enum$CONTROL_VAR_G_GAIN=0$CONTROL_VAR_B_BLACK=1$CONTROL_VAR_VER_KEYSTONE=2$CONTROL_VAR_G_BLACK=3$CONTROL_VAR_VOLUME=4$CONTROL_VAR_LOUDNESS=5$CONTROL_VAR_AAT_INSTANCE_ID=6$CONTROL_VAR_R_GAIN=7$CONTROL_VAR_COLOR_TEMP=8$CONTROL_VAR_SHARPNESS=9$CONTROL_VAR_AAT_PRESET_NAME=10$CONTROL_VAR_R_BLACK=11$CONTROL_VAR_B_GAIN=12$CONTROL_VAR_MUTE=13$CONTROL_VAR_LAST_CHANGE=14$CONTROL_VAR_AAT_CHANNEL=15$CONTROL_VAR_HOR_KEYSTONE=16$CONTROL_VAR_VOLUME_DB=17$CONTROL_VAR_PRESET_NAME_LIST=18$CONTROL_VAR_CONTRAST=19$CONTROL_VAR_BRIGHTNESS=20$CONTROL_VAR_UNKNOWN=21$CONTROL_VAR_COUNT=22
// file upnp_control.c line 63
enum anonymous$19 { CONTROL_VAR_G_GAIN=0, CONTROL_VAR_B_BLACK=1, CONTROL_VAR_VER_KEYSTONE=2, CONTROL_VAR_G_BLACK=3, CONTROL_VAR_VOLUME=4, CONTROL_VAR_LOUDNESS=5, CONTROL_VAR_AAT_INSTANCE_ID=6, CONTROL_VAR_R_GAIN=7, CONTROL_VAR_COLOR_TEMP=8, CONTROL_VAR_SHARPNESS=9, CONTROL_VAR_AAT_PRESET_NAME=10, CONTROL_VAR_R_BLACK=11, CONTROL_VAR_B_GAIN=12, CONTROL_VAR_MUTE=13, CONTROL_VAR_LAST_CHANGE=14, CONTROL_VAR_AAT_CHANNEL=15, CONTROL_VAR_HOR_KEYSTONE=16, CONTROL_VAR_VOLUME_DB=17, CONTROL_VAR_PRESET_NAME_LIST=18, CONTROL_VAR_CONTRAST=19, CONTROL_VAR_BRIGHTNESS=20, CONTROL_VAR_UNKNOWN=21, CONTROL_VAR_COUNT=22 };

// #anon_enum$DATATYPE_STRING=0$DATATYPE_BOOLEAN=1$DATATYPE_I2=2$DATATYPE_I4=3$DATATYPE_UI2=4$DATATYPE_UI4=5$DATATYPE_UNKNOWN=6$DATATYPE_COUNT=7
// file upnp.h line 49
enum anonymous$30 { DATATYPE_STRING=0, DATATYPE_BOOLEAN=1, DATATYPE_I2=2, DATATYPE_I4=3, DATATYPE_UI2=4, DATATYPE_UI4=5, DATATYPE_UNKNOWN=6, DATATYPE_COUNT=7 };

// #anon_enum$GST_EVENT_UNKNOWN=0$GST_EVENT_FLUSH_START=2563$GST_EVENT_FLUSH_STOP=5127$GST_EVENT_STREAM_START=10254$GST_EVENT_CAPS=12814$GST_EVENT_SEGMENT=17934$GST_EVENT_TAG=20510$GST_EVENT_BUFFERSIZE=23054$GST_EVENT_SINK_MESSAGE=25630$GST_EVENT_EOS=28174$GST_EVENT_TOC=30750$GST_EVENT_PROTECTION=33310$GST_EVENT_SEGMENT_DONE=38406$GST_EVENT_GAP=40966$GST_EVENT_QOS=48641$GST_EVENT_SEEK=51201$GST_EVENT_NAVIGATION=53761$GST_EVENT_LATENCY=56321$GST_EVENT_STEP=58881$GST_EVENT_RECONFIGURE=61441$GST_EVENT_TOC_SELECT=64001$GST_EVENT_CUSTOM_UPSTREAM=69121$GST_EVENT_CUSTOM_DOWNSTREAM=71686$GST_EVENT_CUSTOM_DOWNSTREAM_OOB=74242$GST_EVENT_CUSTOM_DOWNSTREAM_STICKY=76830$GST_EVENT_CUSTOM_BOTH=79367$GST_EVENT_CUSTOM_BOTH_OOB=81923
// file /usr/include/gstreamer-1.0/gst/gstevent.h line 136
enum anonymous$4 { GST_EVENT_UNKNOWN=0, GST_EVENT_FLUSH_START=2563, GST_EVENT_FLUSH_STOP=5127, GST_EVENT_STREAM_START=10254, GST_EVENT_CAPS=12814, GST_EVENT_SEGMENT=17934, GST_EVENT_TAG=20510, GST_EVENT_BUFFERSIZE=23054, GST_EVENT_SINK_MESSAGE=25630, GST_EVENT_EOS=28174, GST_EVENT_TOC=30750, GST_EVENT_PROTECTION=33310, GST_EVENT_SEGMENT_DONE=38406, GST_EVENT_GAP=40966, GST_EVENT_QOS=48641, GST_EVENT_SEEK=51201, GST_EVENT_NAVIGATION=53761, GST_EVENT_LATENCY=56321, GST_EVENT_STEP=58881, GST_EVENT_RECONFIGURE=61441, GST_EVENT_TOC_SELECT=64001, GST_EVENT_CUSTOM_UPSTREAM=69121, GST_EVENT_CUSTOM_DOWNSTREAM=71686, GST_EVENT_CUSTOM_DOWNSTREAM_OOB=74242, GST_EVENT_CUSTOM_DOWNSTREAM_STICKY=76830, GST_EVENT_CUSTOM_BOTH=79367, GST_EVENT_CUSTOM_BOTH_OOB=81923 };

// #anon_enum$GST_FLOW_CUSTOM_SUCCESS_2=102$GST_FLOW_CUSTOM_SUCCESS_1=101$GST_FLOW_CUSTOM_SUCCESS=100$GST_FLOW_OK=0$GST_FLOW_NOT_LINKED=-1$GST_FLOW_FLUSHING=-2$GST_FLOW_EOS=-3$GST_FLOW_NOT_NEGOTIATED=-4$GST_FLOW_ERROR=-5$GST_FLOW_NOT_SUPPORTED=-6$GST_FLOW_CUSTOM_ERROR=-100$GST_FLOW_CUSTOM_ERROR_1=-101$GST_FLOW_CUSTOM_ERROR_2=-102
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 161
enum anonymous$24 { GST_FLOW_CUSTOM_SUCCESS_2=102, GST_FLOW_CUSTOM_SUCCESS_1=101, GST_FLOW_CUSTOM_SUCCESS=100, GST_FLOW_OK=0, GST_FLOW_NOT_LINKED=-1, GST_FLOW_FLUSHING=-2, GST_FLOW_EOS=-3, GST_FLOW_NOT_NEGOTIATED=-4, GST_FLOW_ERROR=-5, GST_FLOW_NOT_SUPPORTED=-6, GST_FLOW_CUSTOM_ERROR=-100, GST_FLOW_CUSTOM_ERROR_1=-101, GST_FLOW_CUSTOM_ERROR_2=-102 };

// #anon_enum$GST_FORMAT_UNDEFINED=0$GST_FORMAT_DEFAULT=1$GST_FORMAT_BYTES=2$GST_FORMAT_TIME=3$GST_FORMAT_BUFFERS=4$GST_FORMAT_PERCENT=5
// file /usr/include/gstreamer-1.0/gst/gstformat.h line 52
enum anonymous$11 { GST_FORMAT_UNDEFINED=0, GST_FORMAT_DEFAULT=1, GST_FORMAT_BYTES=2, GST_FORMAT_TIME=3, GST_FORMAT_BUFFERS=4, GST_FORMAT_PERCENT=5 };

// #anon_enum$GST_ITERATOR_DONE=0$GST_ITERATOR_OK=1$GST_ITERATOR_RESYNC=2$GST_ITERATOR_ERROR=3
// file /usr/include/gstreamer-1.0/gst/gstiterator.h line 42
enum anonymous$5 { GST_ITERATOR_DONE=0, GST_ITERATOR_OK=1, GST_ITERATOR_RESYNC=2, GST_ITERATOR_ERROR=3 };

// #anon_enum$GST_ITERATOR_ITEM_SKIP=0$GST_ITERATOR_ITEM_PASS=1$GST_ITERATOR_ITEM_END=2
// file /usr/include/gstreamer-1.0/gst/gstiterator.h line 59
enum anonymous$6 { GST_ITERATOR_ITEM_SKIP=0, GST_ITERATOR_ITEM_PASS=1, GST_ITERATOR_ITEM_END=2 };

// #anon_enum$GST_MESSAGE_UNKNOWN=0$GST_MESSAGE_EOS=1$GST_MESSAGE_ERROR=2$GST_MESSAGE_WARNING=4$GST_MESSAGE_INFO=8$GST_MESSAGE_TAG=16$GST_MESSAGE_BUFFERING=32$GST_MESSAGE_STATE_CHANGED=64$GST_MESSAGE_STATE_DIRTY=128$GST_MESSAGE_STEP_DONE=256$GST_MESSAGE_CLOCK_PROVIDE=512$GST_MESSAGE_CLOCK_LOST=1024$GST_MESSAGE_NEW_CLOCK=2048$GST_MESSAGE_STRUCTURE_CHANGE=4096$GST_MESSAGE_STREAM_STATUS=8192$GST_MESSAGE_APPLICATION=16384$GST_MESSAGE_ELEMENT=32768$GST_MESSAGE_SEGMENT_START=65536$GST_MESSAGE_SEGMENT_DONE=131072$GST_MESSAGE_DURATION_CHANGED=262144$GST_MESSAGE_LATENCY=524288$GST_MESSAGE_ASYNC_START=1048576$GST_MESSAGE_ASYNC_DONE=2097152$GST_MESSAGE_REQUEST_STATE=4194304$GST_MESSAGE_STEP_START=8388608$GST_MESSAGE_QOS=16777216$GST_MESSAGE_PROGRESS=33554432$GST_MESSAGE_TOC=67108864$GST_MESSAGE_RESET_TIME=134217728$GST_MESSAGE_STREAM_START=268435456$GST_MESSAGE_NEED_CONTEXT=536870912$GST_MESSAGE_HAVE_CONTEXT=1073741824$GST_MESSAGE_EXTENDED=-2147483648$GST_MESSAGE_DEVICE_ADDED=-2147483647$GST_MESSAGE_DEVICE_REMOVED=-2147483646$GST_MESSAGE_ANY=-1
// file /usr/include/gstreamer-1.0/gst/gstmessage.h line 122
enum anonymous$7 { GST_MESSAGE_UNKNOWN=0, GST_MESSAGE_EOS=1, GST_MESSAGE_ERROR=2, GST_MESSAGE_WARNING=4, GST_MESSAGE_INFO=8, GST_MESSAGE_TAG=16, GST_MESSAGE_BUFFERING=32, GST_MESSAGE_STATE_CHANGED=64, GST_MESSAGE_STATE_DIRTY=128, GST_MESSAGE_STEP_DONE=256, GST_MESSAGE_CLOCK_PROVIDE=512, GST_MESSAGE_CLOCK_LOST=1024, GST_MESSAGE_NEW_CLOCK=2048, GST_MESSAGE_STRUCTURE_CHANGE=4096, GST_MESSAGE_STREAM_STATUS=8192, GST_MESSAGE_APPLICATION=16384, GST_MESSAGE_ELEMENT=32768, GST_MESSAGE_SEGMENT_START=65536, GST_MESSAGE_SEGMENT_DONE=131072, GST_MESSAGE_DURATION_CHANGED=262144, GST_MESSAGE_LATENCY=524288, GST_MESSAGE_ASYNC_START=1048576, GST_MESSAGE_ASYNC_DONE=2097152, GST_MESSAGE_REQUEST_STATE=4194304, GST_MESSAGE_STEP_START=8388608, GST_MESSAGE_QOS=16777216, GST_MESSAGE_PROGRESS=33554432, GST_MESSAGE_TOC=67108864, GST_MESSAGE_RESET_TIME=134217728, GST_MESSAGE_STREAM_START=268435456, GST_MESSAGE_NEED_CONTEXT=536870912, GST_MESSAGE_HAVE_CONTEXT=1073741824, GST_MESSAGE_EXTENDED=-2147483648, GST_MESSAGE_DEVICE_ADDED=-2147483647, GST_MESSAGE_DEVICE_REMOVED=-2147483646, GST_MESSAGE_ANY=-1 };

// #anon_enum$GST_PAD_ALWAYS=0$GST_PAD_SOMETIMES=1$GST_PAD_REQUEST=2
// file /usr/include/gstreamer-1.0/gst/gstpadtemplate.h line 59
enum anonymous$22 { GST_PAD_ALWAYS=0, GST_PAD_SOMETIMES=1, GST_PAD_REQUEST=2 };

// #anon_enum$GST_PAD_LINK_OK=0$GST_PAD_LINK_WRONG_HIERARCHY=-1$GST_PAD_LINK_WAS_LINKED=-2$GST_PAD_LINK_WRONG_DIRECTION=-3$GST_PAD_LINK_NOFORMAT=-4$GST_PAD_LINK_NOSCHED=-5$GST_PAD_LINK_REFUSED=-6
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 103
enum anonymous$2 { GST_PAD_LINK_OK=0, GST_PAD_LINK_WRONG_HIERARCHY=-1, GST_PAD_LINK_WAS_LINKED=-2, GST_PAD_LINK_WRONG_DIRECTION=-3, GST_PAD_LINK_NOFORMAT=-4, GST_PAD_LINK_NOSCHED=-5, GST_PAD_LINK_REFUSED=-6 };

// #anon_enum$GST_PAD_MODE_NONE=0$GST_PAD_MODE_PUSH=1$GST_PAD_MODE_PULL=2
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 58
enum anonymous$1 { GST_PAD_MODE_NONE=0, GST_PAD_MODE_PUSH=1, GST_PAD_MODE_PULL=2 };

// #anon_enum$GST_PAD_UNKNOWN=0$GST_PAD_SRC=1$GST_PAD_SINK=2
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 42
enum anonymous { GST_PAD_UNKNOWN=0, GST_PAD_SRC=1, GST_PAD_SINK=2 };

// #anon_enum$GST_QUERY_UNKNOWN=0$GST_QUERY_POSITION=2563$GST_QUERY_DURATION=5123$GST_QUERY_LATENCY=7683$GST_QUERY_JITTER=10243$GST_QUERY_RATE=12803$GST_QUERY_SEEKING=15363$GST_QUERY_SEGMENT=17923$GST_QUERY_CONVERT=20483$GST_QUERY_FORMATS=23043$GST_QUERY_BUFFERING=28163$GST_QUERY_CUSTOM=30723$GST_QUERY_URI=33283$GST_QUERY_ALLOCATION=35846$GST_QUERY_SCHEDULING=38401$GST_QUERY_ACCEPT_CAPS=40963$GST_QUERY_CAPS=43523$GST_QUERY_DRAIN=46086$GST_QUERY_CONTEXT=48643
// file /usr/include/gstreamer-1.0/gst/gstquery.h line 112
enum anonymous$18 { GST_QUERY_UNKNOWN=0, GST_QUERY_POSITION=2563, GST_QUERY_DURATION=5123, GST_QUERY_LATENCY=7683, GST_QUERY_JITTER=10243, GST_QUERY_RATE=12803, GST_QUERY_SEEKING=15363, GST_QUERY_SEGMENT=17923, GST_QUERY_CONVERT=20483, GST_QUERY_FORMATS=23043, GST_QUERY_BUFFERING=28163, GST_QUERY_CUSTOM=30723, GST_QUERY_URI=33283, GST_QUERY_ALLOCATION=35846, GST_QUERY_SCHEDULING=38401, GST_QUERY_ACCEPT_CAPS=40963, GST_QUERY_CAPS=43523, GST_QUERY_DRAIN=46086, GST_QUERY_CONTEXT=48643 };

// #anon_enum$GST_SEEK_FLAG_NONE=0$GST_SEEK_FLAG_FLUSH=1$GST_SEEK_FLAG_ACCURATE=2$GST_SEEK_FLAG_KEY_UNIT=4$GST_SEEK_FLAG_SEGMENT=8$GST_SEEK_FLAG_TRICKMODE=16$GST_SEEK_FLAG_SKIP=16$GST_SEEK_FLAG_SNAP_BEFORE=32$GST_SEEK_FLAG_SNAP_AFTER=64$GST_SEEK_FLAG_SNAP_NEAREST=96$GST_SEEK_FLAG_TRICKMODE_KEY_UNITS=128$GST_SEEK_FLAG_TRICKMODE_NO_AUDIO=256
// file /usr/include/gstreamer-1.0/gst/gstsegment.h line 124
enum anonymous$12 { GST_SEEK_FLAG_NONE=0, GST_SEEK_FLAG_FLUSH=1, GST_SEEK_FLAG_ACCURATE=2, GST_SEEK_FLAG_KEY_UNIT=4, GST_SEEK_FLAG_SEGMENT=8, GST_SEEK_FLAG_TRICKMODE=16, GST_SEEK_FLAG_SKIP=16, GST_SEEK_FLAG_SNAP_BEFORE=32, GST_SEEK_FLAG_SNAP_AFTER=64, GST_SEEK_FLAG_SNAP_NEAREST=96, GST_SEEK_FLAG_TRICKMODE_KEY_UNITS=128, GST_SEEK_FLAG_TRICKMODE_NO_AUDIO=256 };

// #anon_enum$GST_SEEK_TYPE_NONE=0$GST_SEEK_TYPE_SET=1$GST_SEEK_TYPE_END=2
// file /usr/include/gstreamer-1.0/gst/gstsegment.h line 43
enum anonymous$13 { GST_SEEK_TYPE_NONE=0, GST_SEEK_TYPE_SET=1, GST_SEEK_TYPE_END=2 };

// #anon_enum$GST_STATE_CHANGE_FAILURE=0$GST_STATE_CHANGE_SUCCESS=1$GST_STATE_CHANGE_ASYNC=2$GST_STATE_CHANGE_NO_PREROLL=3
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 90
enum anonymous$20 { GST_STATE_CHANGE_FAILURE=0, GST_STATE_CHANGE_SUCCESS=1, GST_STATE_CHANGE_ASYNC=2, GST_STATE_CHANGE_NO_PREROLL=3 };

// #anon_enum$GST_STATE_CHANGE_NULL_TO_READY=10$GST_STATE_CHANGE_READY_TO_PAUSED=19$GST_STATE_CHANGE_PAUSED_TO_PLAYING=28$GST_STATE_CHANGE_PLAYING_TO_PAUSED=35$GST_STATE_CHANGE_PAUSED_TO_READY=26$GST_STATE_CHANGE_READY_TO_NULL=17
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 302
enum anonymous$9 { GST_STATE_CHANGE_NULL_TO_READY=10, GST_STATE_CHANGE_READY_TO_PAUSED=19, GST_STATE_CHANGE_PAUSED_TO_PLAYING=28, GST_STATE_CHANGE_PLAYING_TO_PAUSED=35, GST_STATE_CHANGE_PAUSED_TO_READY=26, GST_STATE_CHANGE_READY_TO_NULL=17 };

// #anon_enum$GST_STATE_VOID_PENDING=0$GST_STATE_NULL=1$GST_STATE_READY=2$GST_STATE_PAUSED=3$GST_STATE_PLAYING=4
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 46
enum anonymous$21 { GST_STATE_VOID_PENDING=0, GST_STATE_NULL=1, GST_STATE_READY=2, GST_STATE_PAUSED=3, GST_STATE_PLAYING=4 };

// #anon_enum$GST_TASK_STARTED=0$GST_TASK_STOPPED=1$GST_TASK_PAUSED=2
// file /usr/include/gstreamer-1.0/gst/gsttask.h line 61
enum anonymous$0 { GST_TASK_STARTED=0, GST_TASK_STOPPED=1, GST_TASK_PAUSED=2 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$16 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_OPTION_ARG_NONE=0$G_OPTION_ARG_STRING=1$G_OPTION_ARG_INT=2$G_OPTION_ARG_CALLBACK=3$G_OPTION_ARG_FILENAME=4$G_OPTION_ARG_STRING_ARRAY=5$G_OPTION_ARG_FILENAME_ARRAY=6$G_OPTION_ARG_DOUBLE=7$G_OPTION_ARG_INT64=8
// file /usr/include/glib-2.0/glib/goption.h line 118
enum anonymous$26 { G_OPTION_ARG_NONE=0, G_OPTION_ARG_STRING=1, G_OPTION_ARG_INT=2, G_OPTION_ARG_CALLBACK=3, G_OPTION_ARG_FILENAME=4, G_OPTION_ARG_STRING_ARRAY=5, G_OPTION_ARG_FILENAME_ARRAY=6, G_OPTION_ARG_DOUBLE=7, G_OPTION_ARG_INT64=8 };

// #anon_enum$G_PARAM_READABLE=1$G_PARAM_WRITABLE=2$G_PARAM_READWRITE=3$G_PARAM_CONSTRUCT=4$G_PARAM_CONSTRUCT_ONLY=8$G_PARAM_LAX_VALIDATION=16$G_PARAM_STATIC_NAME=32$G_PARAM_PRIVATE=32$G_PARAM_STATIC_NICK=64$G_PARAM_STATIC_BLURB=128$G_PARAM_EXPLICIT_NOTIFY=1073741824$G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous$10 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum$G_THREAD_PRIORITY_LOW=0$G_THREAD_PRIORITY_NORMAL=1$G_THREAD_PRIORITY_HIGH=2$G_THREAD_PRIORITY_URGENT=3
// file /usr/include/glib-2.0/glib/deprecated/gthread.h line 38
enum anonymous$15 { G_THREAD_PRIORITY_LOW=0, G_THREAD_PRIORITY_NORMAL=1, G_THREAD_PRIORITY_HIGH=2, G_THREAD_PRIORITY_URGENT=3 };

// #anon_enum$PARAM_DIR_IN=0$PARAM_DIR_OUT=1
// file upnp.h line 38
enum anonymous$8 { PARAM_DIR_IN=0, PARAM_DIR_OUT=1 };

// #anon_enum$SENDEVENT_NO=0$SENDEVENT_YES=1
// file upnp.h line 60
enum anonymous$29 { SENDEVENT_NO=0, SENDEVENT_YES=1 };

// #anon_enum$TRANSPORT_VAR_TRANSPORT_STATUS=0$TRANSPORT_VAR_NEXT_AV_URI=1$TRANSPORT_VAR_NEXT_AV_URI_META=2$TRANSPORT_VAR_CUR_TRACK_META=3$TRANSPORT_VAR_REL_CTR_POS=4$TRANSPORT_VAR_AAT_INSTANCE_ID=5$TRANSPORT_VAR_AAT_SEEK_TARGET=6$TRANSPORT_VAR_PLAY_MEDIUM=7$TRANSPORT_VAR_REL_TIME_POS=8$TRANSPORT_VAR_REC_MEDIA=9$TRANSPORT_VAR_CUR_PLAY_MODE=10$TRANSPORT_VAR_TRANSPORT_PLAY_SPEED=11$TRANSPORT_VAR_PLAY_MEDIA=12$TRANSPORT_VAR_ABS_TIME_POS=13$TRANSPORT_VAR_CUR_TRACK=14$TRANSPORT_VAR_CUR_TRACK_URI=15$TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS=16$TRANSPORT_VAR_NR_TRACKS=17$TRANSPORT_VAR_AV_URI=18$TRANSPORT_VAR_ABS_CTR_POS=19$TRANSPORT_VAR_CUR_REC_QUAL_MODE=20$TRANSPORT_VAR_CUR_MEDIA_DUR=21$TRANSPORT_VAR_AAT_SEEK_MODE=22$TRANSPORT_VAR_AV_URI_META=23$TRANSPORT_VAR_REC_MEDIUM=24$TRANSPORT_VAR_REC_MEDIUM_WR_STATUS=25$TRANSPORT_VAR_LAST_CHANGE=26$TRANSPORT_VAR_CUR_TRACK_DUR=27$TRANSPORT_VAR_TRANSPORT_STATE=28$TRANSPORT_VAR_POS_REC_QUAL_MODE=29$TRANSPORT_VAR_UNKNOWN=30$TRANSPORT_VAR_COUNT=31
// file upnp_transport.c line 58
enum anonymous$31 { TRANSPORT_VAR_TRANSPORT_STATUS=0, TRANSPORT_VAR_NEXT_AV_URI=1, TRANSPORT_VAR_NEXT_AV_URI_META=2, TRANSPORT_VAR_CUR_TRACK_META=3, TRANSPORT_VAR_REL_CTR_POS=4, TRANSPORT_VAR_AAT_INSTANCE_ID=5, TRANSPORT_VAR_AAT_SEEK_TARGET=6, TRANSPORT_VAR_PLAY_MEDIUM=7, TRANSPORT_VAR_REL_TIME_POS=8, TRANSPORT_VAR_REC_MEDIA=9, TRANSPORT_VAR_CUR_PLAY_MODE=10, TRANSPORT_VAR_TRANSPORT_PLAY_SPEED=11, TRANSPORT_VAR_PLAY_MEDIA=12, TRANSPORT_VAR_ABS_TIME_POS=13, TRANSPORT_VAR_CUR_TRACK=14, TRANSPORT_VAR_CUR_TRACK_URI=15, TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS=16, TRANSPORT_VAR_NR_TRACKS=17, TRANSPORT_VAR_AV_URI=18, TRANSPORT_VAR_ABS_CTR_POS=19, TRANSPORT_VAR_CUR_REC_QUAL_MODE=20, TRANSPORT_VAR_CUR_MEDIA_DUR=21, TRANSPORT_VAR_AAT_SEEK_MODE=22, TRANSPORT_VAR_AV_URI_META=23, TRANSPORT_VAR_REC_MEDIUM=24, TRANSPORT_VAR_REC_MEDIUM_WR_STATUS=25, TRANSPORT_VAR_LAST_CHANGE=26, TRANSPORT_VAR_CUR_TRACK_DUR=27, TRANSPORT_VAR_TRANSPORT_STATE=28, TRANSPORT_VAR_POS_REC_QUAL_MODE=29, TRANSPORT_VAR_UNKNOWN=30, TRANSPORT_VAR_COUNT=31 };

// #anon_enum$eINVALID_NODE=0$eELEMENT_NODE=1$eATTRIBUTE_NODE=2$eTEXT_NODE=3$eCDATA_SECTION_NODE=4$eENTITY_REFERENCE_NODE=5$eENTITY_NODE=6$ePROCESSING_INSTRUCTION_NODE=7$eCOMMENT_NODE=8$eDOCUMENT_NODE=9$eDOCUMENT_TYPE_NODE=10$eDOCUMENT_FRAGMENT_NODE=11$eNOTATION_NODE=12
// file /usr/include/upnp/ixml.h line 103
enum anonymous$17 { eINVALID_NODE=0, eELEMENT_NODE=1, eATTRIBUTE_NODE=2, eTEXT_NODE=3, eCDATA_SECTION_NODE=4, eENTITY_REFERENCE_NODE=5, eENTITY_NODE=6, ePROCESSING_INSTRUCTION_NODE=7, eCOMMENT_NODE=8, eDOCUMENT_NODE=9, eDOCUMENT_TYPE_NODE=10, eDOCUMENT_FRAGMENT_NODE=11, eNOTATION_NODE=12 };

// tag-#anon#ST[EN#anon_enum$GST_FLOW_CUSTOM_SUCCESS_2=102$GST_FLOW_CUSTOM_SUCCESS_1=101$GST_FLOW_CUSTOM_SUCCESS=100$GST_FLOW_OK=0$GST_FLOW_NOT_LINKED=-1$GST_FLOW_FLUSHING=-2$GST_FLOW_EOS=-3$GST_FLOW_NOT_NEGOTIATED=-4$GST_FLOW_ERROR=-5$GST_FLOW_NOT_SUPPORTED=-6$GST_FLOW_CUSTOM_ERROR=-100$GST_FLOW_CUSTOM_ERROR_1=-101$GST_FLOW_CUSTOM_ERROR_2=-102#{S32}$S32$'last_flowret'|]
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 757
struct anonymous$25;

// tag-#anon#ST[S64'pos'||*{cS8}$cS8$'contents'||U64'len'|]
// file webserver.c line 46
struct anonymous$28;

// tag-#anon#UN[ARR4{*{V}$V$}$*{V}$V$$'_gst_reserved'||SYM#tag-#anon#ST[EN#anon_enum$GST_FLOW_CUSTOM_SUCCESS_2=102$GST_FLOW_CUSTOM_SUCCESS_1=101$GST_FLOW_CUSTOM_SUCCESS=100$GST_FLOW_OK=0$GST_FLOW_NOT_LINKED=-1$GST_FLOW_FLUSHING=-2$GST_FLOW_EOS=-3$GST_FLOW_NOT_NEGOTIATED=-4$GST_FLOW_ERROR=-5$GST_FLOW_NOT_SUPPORTED=-6$GST_FLOW_CUSTOM_ERROR=-100$GST_FLOW_CUSTOM_ERROR_1=-101$GST_FLOW_CUSTOM_ERROR_2=-102#{S32}$S32$'last_flowret'|]#'abi'|]
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 755
union anonymous$3;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$23;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$14;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$27;

// tag-File_Info
// file /usr/include/upnp/upnp.h line 803
struct File_Info;

// tag-MetaModify
// file output_gstreamer.c line 251
struct MetaModify;

// tag-PlayFeedback
// file output.h line 32
enum PlayFeedback { PLAY_STOPPED=0, PLAY_STARTED_NEXT_STREAM=1 };

// tag-SongMetaData
// file song-meta-data.h line 28
struct SongMetaData;

// tag-UpnpOpenFileMode
// file /usr/include/upnp/upnp.h line 412
enum UpnpOpenFileMode { UPNP_READ=0, UPNP_WRITE=1 };

// tag-Upnp_Action_Request
// file /usr/include/upnp/upnp.h line 606
struct Upnp_Action_Request;

// tag-Upnp_DescType_e
// file /usr/include/upnp/upnp.h line 588
enum Upnp_DescType_e { UPNPREG_URL_DESC=0, UPNPREG_FILENAME_DESC=1, UPNPREG_BUF_DESC=2 };

// tag-Upnp_EventType_e
// file /usr/include/upnp/upnp.h line 444
enum Upnp_EventType_e { UPNP_CONTROL_ACTION_REQUEST=0, UPNP_CONTROL_ACTION_COMPLETE=1, UPNP_CONTROL_GET_VAR_REQUEST=2, UPNP_CONTROL_GET_VAR_COMPLETE=3, UPNP_DISCOVERY_ADVERTISEMENT_ALIVE=4, UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE=5, UPNP_DISCOVERY_SEARCH_RESULT=6, UPNP_DISCOVERY_SEARCH_TIMEOUT=7, UPNP_EVENT_SUBSCRIPTION_REQUEST=8, UPNP_EVENT_RECEIVED=9, UPNP_EVENT_RENEWAL_COMPLETE=10, UPNP_EVENT_SUBSCRIBE_COMPLETE=11, UPNP_EVENT_UNSUBSCRIBE_COMPLETE=12, UPNP_EVENT_AUTORENEWAL_FAILED=13, UPNP_EVENT_SUBSCRIPTION_EXPIRED=14 };

// tag-Upnp_State_Var_Request
// file /usr/include/upnp/upnp.h line 659
struct Upnp_State_Var_Request;

// tag-Upnp_Subscription_Request
// file /usr/include/upnp/upnp.h line 790
struct Upnp_Subscription_Request;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GCond
// file /usr/include/glib-2.0/glib/gthread.h line 54
struct _GCond;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GHook
// file /usr/include/glib-2.0/glib/ghook.h line 38
struct _GHook;

// tag-_GHookList
// file /usr/include/glib-2.0/glib/ghook.h line 39
struct _GHookList;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GMainLoop
// file /usr/include/glib-2.0/glib/gmain.h line 56
struct _GMainLoop;

// tag-_GMutex
// file /usr/include/glib-2.0/glib/gthread.h line 51
union _GMutex;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GOptionContext
// file /usr/include/glib-2.0/glib/goption.h line 38
struct _GOptionContext;

// tag-_GOptionEntry
// file /usr/include/glib-2.0/glib/goption.h line 52
struct _GOptionEntry;

// tag-_GOptionGroup
// file /usr/include/glib-2.0/glib/goption.h line 51
struct _GOptionGroup;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GRecMutex
// file /usr/include/glib-2.0/glib/gthread.h line 52
struct _GRecMutex;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GThread
// file /usr/include/glib-2.0/glib/gthread.h line 49
struct _GThread;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GstBin
// file /usr/include/gstreamer-1.0/gst/gstbin.h line 69
struct _GstBin;

// tag-_GstBinPrivate
// file /usr/include/gstreamer-1.0/gst/gstbin.h line 71
struct _GstBinPrivate;

// tag-_GstBuffer
// file /usr/include/gstreamer-1.0/gst/gstbuffer.h line 35
struct _GstBuffer;

// tag-_GstBufferList
// file /usr/include/gstreamer-1.0/gst/gstbufferlist.h line 37
struct _GstBufferList;

// tag-_GstBufferPool
// file /usr/include/gstreamer-1.0/gst/gstbuffer.h line 36
struct _GstBufferPool;

// tag-_GstBufferPoolPrivate
// file /usr/include/gstreamer-1.0/gst/gstbufferpool.h line 32
struct _GstBufferPoolPrivate;

// tag-_GstBus
// file /usr/include/gstreamer-1.0/gst/gstbus.h line 25
struct _GstBus;

// tag-_GstBusPrivate
// file /usr/include/gstreamer-1.0/gst/gstbus.h line 26
struct _GstBusPrivate;

// tag-_GstCaps
// file /usr/include/gstreamer-1.0/gst/gstcaps.h line 136
struct _GstCaps;

// tag-_GstClock
// file /usr/include/gstreamer-1.0/gst/gstclock.h line 273
struct _GstClock;

// tag-_GstClockPrivate
// file /usr/include/gstreamer-1.0/gst/gstclock.h line 275
struct _GstClockPrivate;

// tag-_GstContext
// file /usr/include/gstreamer-1.0/gst/gstcontext.h line 31
struct _GstContext;

// tag-_GstElement
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 28
struct _GstElement;

// tag-_GstElementClass
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 29
struct _GstElementClass;

// tag-_GstElementFactory
// file /usr/include/gstreamer-1.0/gst/gstelementfactory.h line 32
struct _GstElementFactory;

// tag-_GstEvent
// file /usr/include/gstreamer-1.0/gst/gstevent.h line 28
struct _GstEvent;

// tag-_GstIterator
// file /usr/include/gstreamer-1.0/gst/gstiterator.h line 49
struct _GstIterator;

// tag-_GstMessage
// file /usr/include/gstreamer-1.0/gst/gstmessage.h line 27
struct _GstMessage;

// tag-_GstMiniObject
// file /usr/include/gstreamer-1.0/gst/gstminiobject.h line 37
struct _GstMiniObject;

// tag-_GstObject
// file /usr/include/gstreamer-1.0/gst/gstobject.h line 152
struct _GstObject;

// tag-_GstObjectClass
// file /usr/include/gstreamer-1.0/gst/gstobject.h line 153
struct _GstObjectClass;

// tag-_GstPad
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 29
struct _GstPad;

// tag-_GstPadPrivate
// file /usr/include/gstreamer-1.0/gst/gstpad.h line 30
struct _GstPadPrivate;

// tag-_GstPadTemplate
// file /usr/include/gstreamer-1.0/gst/gstpadtemplate.h line 29
struct _GstPadTemplate;

// tag-_GstPipeline
// file /usr/include/gstreamer-1.0/gst/gstpipeline.h line 39
struct _GstPipeline;

// tag-_GstPipelinePrivate
// file /usr/include/gstreamer-1.0/gst/gstpipeline.h line 41
struct _GstPipelinePrivate;

// tag-_GstPlugin
// file /usr/include/gstreamer-1.0/gst/gstplugin.h line 40
struct _GstPlugin;

// tag-_GstPluginFeature
// file /usr/include/gstreamer-1.0/gst/gstpluginfeature.h line 46
struct _GstPluginFeature;

// tag-_GstQuery
// file /usr/include/gstreamer-1.0/gst/gstquery.h line 42
struct _GstQuery;

// tag-_GstRegistry
// file /usr/include/gstreamer-1.0/gst/gstregistry.h line 40
struct _GstRegistry;

// tag-_GstRegistryPrivate
// file /usr/include/gstreamer-1.0/gst/gstregistry.h line 42
struct _GstRegistryPrivate;

// tag-_GstStructure
// file /usr/include/gstreamer-1.0/gst/gststructure.h line 33
struct _GstStructure;

// tag-_GstTagList
// file /usr/include/gstreamer-1.0/gst/gsttaglist.h line 152
struct _GstTagList;

// tag-_GstTask
// file /usr/include/gstreamer-1.0/gst/gsttask.h line 49
struct _GstTask;

// tag-_GstTaskPrivate
// file /usr/include/gstreamer-1.0/gst/gsttask.h line 51
struct _GstTaskPrivate;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_IXML_Document
// file /usr/include/upnp/ixml.h line 156
struct _IXML_Document;

// tag-_IXML_Element
// file /usr/include/upnp/ixml.h line 205
struct _IXML_Element;

// tag-_IXML_Node
// file /usr/include/upnp/ixml.h line 159
struct _IXML_Node;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-action
// file upnp.h line 27
struct action;

// tag-action_event
// file upnp.h line 29
struct action_event;

// tag-argument
// file upnp.h line 43
struct argument;

// tag-cb_list
// file variable-container.c line 38
struct cb_list;

// tag-icon
// file upnp.h line 80
struct icon;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-mime_type
// file upnp_connmgr.c line 187
struct mime_type;

// tag-output_module
// file output_module.h line 29
struct output_module;

// tag-param_range
// file upnp.h line 65
struct param_range;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-service
// file upnp.h line 28
struct service;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-track_time_info
// file output_gstreamer.c line 155
struct track_time_info;

// tag-transport_state
// file upnp_transport.c line 205
enum transport_state { TRANSPORT_STOPPED=0, TRANSPORT_PLAYING=1, TRANSPORT_TRANSITIONING=2, TRANSPORT_PAUSED_PLAYBACK=3, TRANSPORT_PAUSED_RECORDING=4, TRANSPORT_RECORDING=5, TRANSPORT_NO_MEDIA_PRESENT=6 };

// tag-upnp_device
// file upnp.h line 112
struct upnp_device;

// tag-upnp_device_descriptor
// file upnp_device.h line 28
struct upnp_device_descriptor;

// tag-upnp_last_change_builder
// file variable-container.h line 89
struct upnp_last_change_builder;

// tag-upnp_last_change_collector
// file variable-container.h line 105
struct upnp_last_change_collector;

// tag-var_meta
// file upnp.h line 71
struct var_meta;

// tag-variable_container
// file variable-container.h line 49
struct variable_container;

// tag-virtual_file
// file webserver.c line 52
struct virtual_file;

// tag-xmldoc
// file xmldoc.h line 27
struct xmldoc;

// tag-xmlelement
// file xmldoc.h line 28
struct xmlelement;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// Log_color_allowed
// file logging.h line 34
signed int Log_color_allowed(void);
// Log_error
// file logging.h line 40
void Log_error(const char *category, const char *format, ...);
// Log_error_enabled
// file logging.c line 70
signed int Log_error_enabled(void);
// Log_info
// file logging.h line 38
void Log_info(const char *category, const char *format, ...);
// Log_info_enabled
// file logging.h line 35
signed int Log_info_enabled(void);
// Log_init
// file logging.h line 33
void Log_init(const char *filename);
// Log_internal
// file logging.c line 72
static void Log_internal(signed int fd, const char *markup_start, const char *category, const char *format, void **ap);
// MetaModify_add_tag
// file output_gstreamer.c line 256
static void MetaModify_add_tag(const struct _GstTagList *list, const char *tag, void *user_data);
// SongMetaData_clear
// file song-meta-data.c line 40
void SongMetaData_clear(struct SongMetaData *value);
// SongMetaData_init
// file song-meta-data.c line 37
void SongMetaData_init(struct SongMetaData *value);
// SongMetaData_parse_DIDL
// file song-meta-data.c line 120
signed int SongMetaData_parse_DIDL(struct SongMetaData *object, const char *xml);
// SongMetaData_to_DIDL
// file song-meta-data.h line 45
char * SongMetaData_to_DIDL(struct SongMetaData *object, const char *original_xml);
// UPnPLastChangeBuilder_add
// file variable-container.c line 151
void UPnPLastChangeBuilder_add(struct upnp_last_change_builder *builder, const char *name, const char *value);
// UPnPLastChangeBuilder_delete
// file variable-container.c line 144
void UPnPLastChangeBuilder_delete(struct upnp_last_change_builder *builder);
// UPnPLastChangeBuilder_new
// file variable-container.c line 135
struct upnp_last_change_builder * UPnPLastChangeBuilder_new(const char *xml_namespace);
// UPnPLastChangeBuilder_to_xml
// file variable-container.c line 186
char * UPnPLastChangeBuilder_to_xml(struct upnp_last_change_builder *builder);
// UPnPLastChangeCollector_add_ignore
// file variable-container.h line 120
void UPnPLastChangeCollector_add_ignore(struct upnp_last_change_collector *object, signed int variable_num);
// UPnPLastChangeCollector_callback
// file variable-container.c line 313
static void UPnPLastChangeCollector_callback(void *userdata, signed int var_num, const char *var_name, const char *old_value, const char *new_value);
// UPnPLastChangeCollector_finish
// file variable-container.h line 127
void UPnPLastChangeCollector_finish(struct upnp_last_change_collector *object);
// UPnPLastChangeCollector_new
// file variable-container.h line 114
struct upnp_last_change_collector * UPnPLastChangeCollector_new(struct variable_container *variable_container, const char *event_xml_namespace, struct upnp_device *upnp_device, const char *service_id);
// UPnPLastChangeCollector_notify
// file variable-container.c line 278
static void UPnPLastChangeCollector_notify(struct upnp_last_change_collector *obj);
// UPnPLastChangeCollector_start
// file variable-container.h line 126
void UPnPLastChangeCollector_start(struct upnp_last_change_collector *object);
// UpnpAcceptSubscription
// file /usr/include/upnp/upnp.h line 1789
signed int UpnpAcceptSubscription(signed int, const char *, const char *, const char **, const char **, signed int, char *);
// UpnpAddToActionResponse
// file /usr/include/upnp/upnptools.h line 224
signed int UpnpAddToActionResponse(struct _IXML_Document **, const char *, const char *, const char *, const char *);
// UpnpAddVirtualDir
// file /usr/include/upnp/upnp.h line 2854
signed int UpnpAddVirtualDir(const char *);
// UpnpEnableWebserver
// file /usr/include/upnp/upnp.h line 2816
signed int UpnpEnableWebserver(signed int);
// UpnpFinish
// file /usr/include/upnp/upnp.h line 977
signed int UpnpFinish(void);
// UpnpGetErrorMessage
// file /usr/include/upnp/upnptools.h line 72
const char * UpnpGetErrorMessage(signed int);
// UpnpGetServerIpAddress
// file /usr/include/upnp/upnp.h line 1017
char * UpnpGetServerIpAddress(void);
// UpnpGetServerPort
// file /usr/include/upnp/upnp.h line 990
unsigned short int UpnpGetServerPort(void);
// UpnpInit
// file /usr/include/upnp/upnp.h line 907
signed int UpnpInit(const char *, unsigned short int);
// UpnpMakeActionResponse
// file /usr/include/upnp/upnptools.h line 163
struct _IXML_Document * UpnpMakeActionResponse(const char *, const char *, signed int, const char *, ...);
// UpnpNotify
// file /usr/include/upnp/upnp.h line 1862
signed int UpnpNotify(signed int, const char *, const char *, const char **, const char **, signed int);
// UpnpRegisterRootDevice2
// file /usr/include/upnp/upnp.h line 1150
signed int UpnpRegisterRootDevice2(enum Upnp_DescType_e, const char *, unsigned long int, signed int, signed int (*)(enum Upnp_EventType_e, void *, void *), const void *, signed int *);
// UpnpSendAdvertisement
// file /usr/include/upnp/upnp.h line 1469
signed int UpnpSendAdvertisement(signed int, signed int);
// UpnpVirtualDir_set_CloseCallback
// file /usr/include/upnp/upnp.h line 2792
signed int UpnpVirtualDir_set_CloseCallback(signed int (*)(void *));
// UpnpVirtualDir_set_GetInfoCallback
// file /usr/include/upnp/upnp.h line 2687
signed int UpnpVirtualDir_set_GetInfoCallback(signed int (*)(const char *, struct File_Info *));
// UpnpVirtualDir_set_OpenCallback
// file /usr/include/upnp/upnp.h line 2707
signed int UpnpVirtualDir_set_OpenCallback(void * (*)(const char *, enum UpnpOpenFileMode));
// UpnpVirtualDir_set_ReadCallback
// file /usr/include/upnp/upnp.h line 2728
signed int UpnpVirtualDir_set_ReadCallback(signed int (*)(void *, char *, unsigned long int));
// UpnpVirtualDir_set_SeekCallback
// file /usr/include/upnp/upnp.h line 2775
signed int UpnpVirtualDir_set_SeekCallback(signed int (*)(void *, signed long int, signed int));
// UpnpVirtualDir_set_WriteCallback
// file /usr/include/upnp/upnp.h line 2749
signed int UpnpVirtualDir_set_WriteCallback(signed int (*)(void *, char *, unsigned long int));
// VariableContainer_change
// file variable-container.h line 73
signed int VariableContainer_change(struct variable_container *object, signed int var_num, const char *value);
// VariableContainer_delete
// file variable-container.c line 69
void VariableContainer_delete(struct variable_container *object);
// VariableContainer_get
// file variable-container.h line 67
const char * VariableContainer_get(struct variable_container *object, signed int var, const char **name);
// VariableContainer_get_num_vars
// file variable-container.c line 84
signed int VariableContainer_get_num_vars(struct variable_container *object);
// VariableContainer_new
// file variable-container.h line 54
struct variable_container * VariableContainer_new(signed int variable_num, const char **variable_names, const char **variable_init_values);
// VariableContainer_register_callback
// file variable-container.h line 83
void VariableContainer_register_callback(struct variable_container *object, void (*callback)(void *, signed int, const char *, const char *, const char *), void *userdata);
// VariableContainer_register_callback::callback$object
//
void callback$object(void *, signed int, const char *, const char *, const char *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __error_alias
// file /usr/include/x86_64-linux-gnu/bits/error.h line 24
extern void __error_alias(signed int, signed int, const char *, ...);
// __error_noreturn
// file /usr/include/x86_64-linux-gnu/bits/error.h line 28
extern void __error_noreturn(signed int, signed int, const char *, ...);
// add_attributevalue_element
// file xmldoc.h line 67
struct xmlelement * add_attributevalue_element(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, const char *attribute_name, const char *value);
// add_value_element
// file xmldoc.h line 53
void add_value_element(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, const char *value);
// add_value_element_int
// file xmldoc.h line 73
void add_value_element_int(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, signed int value);
// add_value_element_long
// file xmldoc.h line 76
void add_value_element_long(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, signed long long int value);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// change_transport_state
// file upnp_transport.c line 598
static void change_transport_state(enum transport_state new_state);
// change_volume
// file upnp_control.c line 509
static void change_volume(const char *volume, const char *db_volume);
// change_volume_decibel
// file upnp_control.c line 665
static float change_volume_decibel(float raw_decibel);
// cmd_obtain_variable
// file upnp_control.c line 514
static signed int cmd_obtain_variable(struct action_event *event, enum anonymous$19 varnum, const char *paramname);
// connmgr_init
// file upnp_connmgr.c line 252
signed int connmgr_init(void);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// divide_leave_remainder
// file upnp_transport.c line 753
static signed int divide_leave_remainder(signed long int *val, signed long int divisor);
// do_show_version
// file main.c line 121
static void do_show_version(void);
// error
// file /usr/include/x86_64-linux-gnu/bits/error.h line 37
static inline void error(signed int __status, signed int __errnum, const char *__format, ...);
// event_handler
// file upnp_device.c line 383
static signed int event_handler(enum Upnp_EventType_e EventType, void *event, void *userdata);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_loop_sighandler
// file output.c line 111
static void exit_loop_sighandler(signed int sig);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// find_action
// file upnp.c line 196
struct action * find_action(struct service *event_service, char *action_name);
// find_element
// file xmldoc.c line 105
static struct xmlelement * find_element(struct _IXML_Node *node, const char *key);
// find_element_in_doc
// file xmldoc.h line 58
struct xmlelement * find_element_in_doc(struct xmldoc *doc, const char *key);
// find_element_in_element
// file xmldoc.h line 61
struct xmlelement * find_element_in_element(struct xmlelement *element, const char *key);
// find_service
// file upnp_device.c line 510
struct service * find_service(struct upnp_device_descriptor *device_def, const char *service_id);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// g_error_free
// file /usr/include/glib-2.0/glib/gerror.h line 68
extern void g_error_free(struct _GError *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_main_loop_new
// file /usr/include/glib-2.0/glib/gmain.h line 400
extern struct _GMainLoop * g_main_loop_new(struct _GMainContext *, signed int);
// g_main_loop_quit
// file /usr/include/glib-2.0/glib/gmain.h line 405
extern void g_main_loop_quit(struct _GMainLoop *);
// g_main_loop_run
// file /usr/include/glib-2.0/glib/gmain.h line 403
extern void g_main_loop_run(struct _GMainLoop *);
// g_object_get
// file /usr/include/glib-2.0/gobject/gobject.h line 436
extern void g_object_get(void *, const char *, ...);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_option_context_add_group
// file /usr/include/glib-2.0/glib/goption.h line 342
extern void g_option_context_add_group(struct _GOptionContext *, struct _GOptionGroup *);
// g_option_context_add_main_entries
// file /usr/include/glib-2.0/glib/goption.h line 320
extern void g_option_context_add_main_entries(struct _GOptionContext *, const struct _GOptionEntry *, const char *);
// g_option_context_new
// file /usr/include/glib-2.0/glib/goption.h line 289
extern struct _GOptionContext * g_option_context_new(const char *);
// g_option_context_parse
// file /usr/include/glib-2.0/glib/goption.h line 324
extern signed int g_option_context_parse(struct _GOptionContext *, signed int *, char ***, struct _GError **);
// g_option_group_add_entries
// file /usr/include/glib-2.0/glib/goption.h line 374
extern void g_option_group_add_entries(struct _GOptionGroup *, const struct _GOptionEntry *);
// g_option_group_new
// file /usr/include/glib-2.0/glib/goption.h line 355
extern struct _GOptionGroup * g_option_group_new(const char *, const char *, const char *, void *, void (*)(void *));
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$16);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_type_check_instance_is_a
// file /usr/include/glib-2.0/gobject/gtype.h line 2171
extern signed int g_type_check_instance_is_a(struct _GTypeInstance *, unsigned long int);
// gen_desc_iconlist
// file upnp_device.c line 544
static struct xmlelement * gen_desc_iconlist(struct xmldoc *doc, struct icon **icons);
// gen_desc_servicelist
// file upnp_device.c line 567
static struct xmlelement * gen_desc_servicelist(struct upnp_device_descriptor *device_def, struct xmldoc *doc);
// gen_scpd_action
// file upnp.c line 64
static struct xmlelement * gen_scpd_action(struct xmldoc *doc, struct action *act, struct argument **arglist, const char **varnames);
// gen_scpd_actionlist
// file upnp.c line 94
static struct xmlelement * gen_scpd_actionlist(struct xmldoc *doc, struct service *srv);
// gen_scpd_servicestatetable
// file upnp.c line 159
static struct xmlelement * gen_scpd_servicestatetable(struct xmldoc *doc, struct service *srv);
// gen_scpd_statevar
// file upnp.c line 117
static struct xmlelement * gen_scpd_statevar(struct xmldoc *doc, const char *name, struct var_meta *meta);
// gen_specversion
// file upnp.c line 51
static struct xmlelement * gen_specversion(struct xmldoc *doc, signed int major, signed int minor);
// gen_specversion$link1
// file upnp_device.c line 530
static struct xmlelement * gen_specversion$link1(struct xmldoc *doc$link1, signed int major$link1, signed int minor$link1);
// generate_DIDL
// file song-meta-data.c line 59
static char * generate_DIDL(const char *id, const char *title, const char *artist, const char *album, const char *genre, const char *composer);
// generate_desc
// file upnp_device.c line 592
static struct xmldoc * generate_desc(struct upnp_device_descriptor *device_def);
// generate_scpd
// file upnp.c line 175
static struct xmldoc * generate_scpd(struct service *srv);
// get_blue_videoblacklevel
// file upnp_control.c line 584
static signed int get_blue_videoblacklevel(struct action_event *event);
// get_blue_videogain
// file upnp_control.c line 566
static signed int get_blue_videogain(struct action_event *event);
// get_brightness
// file upnp_control.c line 536
static signed int get_brightness(struct action_event *event);
// get_colortemperature
// file upnp_control.c line 590
static signed int get_colortemperature(struct action_event *event);
// get_contrast
// file upnp_control.c line 542
static signed int get_contrast(struct action_event *event);
// get_current_conn_ids
// file upnp_connmgr.c line 309
static signed int get_current_conn_ids(struct action_event *event);
// get_current_conn_info
// file upnp_connmgr.c line 325
static signed int get_current_conn_info(struct action_event *event);
// get_current_player_state
// file output_gstreamer.c line 161
static enum anonymous$21 get_current_player_state();
// get_current_transportactions
// file upnp_transport.c line 732
static signed int get_current_transportactions(struct action_event *event);
// get_device_caps
// file upnp_transport.c line 823
static signed int get_device_caps(struct action_event *event);
// get_green_videoblacklevel
// file upnp_control.c line 578
static signed int get_green_videoblacklevel(struct action_event *event);
// get_green_videogain
// file upnp_control.c line 560
static signed int get_green_videogain(struct action_event *event);
// get_horizontal_keystone
// file upnp_control.c line 596
static signed int get_horizontal_keystone(struct action_event *event);
// get_loudness
// file upnp_control.c line 732
static signed int get_loudness(struct action_event *event);
// get_media_info
// file upnp_transport.c line 539
static signed int get_media_info(struct action_event *event);
// get_mute
// file upnp_control.c line 608
static signed int get_mute(struct action_event *event);
// get_node_value
// file xmldoc.h line 65
char * get_node_value(struct xmlelement *element);
// get_position_info
// file upnp_transport.c line 803
static signed int get_position_info(struct action_event *event);
// get_protocol_info
// file upnp_connmgr.c line 302
static signed int get_protocol_info(struct action_event *event);
// get_red_videoblacklevel
// file upnp_control.c line 572
static signed int get_red_videoblacklevel(struct action_event *event);
// get_red_videogain
// file upnp_control.c line 554
static signed int get_red_videogain(struct action_event *event);
// get_sharpness
// file upnp_control.c line 548
static signed int get_sharpness(struct action_event *event);
// get_transport_info
// file upnp_transport.c line 717
static signed int get_transport_info(struct action_event *event);
// get_transport_settings
// file upnp_transport.c line 743
static signed int get_transport_settings(struct action_event *event);
// get_var
// file upnp_transport.c line 566
static const char * get_var(enum anonymous$31 varnum);
// get_vertical_keystone
// file upnp_control.c line 602
static signed int get_vertical_keystone(struct action_event *event);
// get_volume
// file upnp_control.c line 629
static signed int get_volume(struct action_event *event);
// get_volume_db
// file upnp_control.c line 716
static signed int get_volume_db(struct action_event *event);
// get_volume_dbrange
// file upnp_control.c line 723
static signed int get_volume_dbrange(struct action_event *event);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gst_bus_add_watch
// file /usr/include/gstreamer-1.0/gst/gstbus.h line 159
unsigned int gst_bus_add_watch(struct _GstBus *, signed int (*)(struct _GstBus *, struct _GstMessage *, void *), void *);
// gst_caps_get_size
// file /usr/include/gstreamer-1.0/gst/gstcaps.h line 451
unsigned int gst_caps_get_size(const struct _GstCaps *);
// gst_caps_get_structure
// file /usr/include/gstreamer-1.0/gst/gstcaps.h line 452
struct _GstStructure * gst_caps_get_structure(const struct _GstCaps *, unsigned int);
// gst_caps_is_any
// file /usr/include/gstreamer-1.0/gst/gstcaps.h line 485
signed int gst_caps_is_any(const struct _GstCaps *);
// gst_caps_is_empty
// file /usr/include/gstreamer-1.0/gst/gstcaps.h line 486
signed int gst_caps_is_empty(const struct _GstCaps *);
// gst_element_factory_create
// file /usr/include/gstreamer-1.0/gst/gstelementfactory.h line 71
struct _GstElement * gst_element_factory_create(struct _GstElementFactory *, const char *);
// gst_element_factory_get_type
// file /usr/include/gstreamer-1.0/gst/gstelementfactory.h line 53
unsigned long int gst_element_factory_get_type(void);
// gst_element_factory_make
// file /usr/include/gstreamer-1.0/gst/gstelementfactory.h line 73
struct _GstElement * gst_element_factory_make(const char *, const char *);
// gst_element_get_state
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 792
enum anonymous$20 gst_element_get_state(struct _GstElement *, enum anonymous$21 *, enum anonymous$21 *, unsigned long int);
// gst_element_query_duration
// file /usr/include/gstreamer-1.0/gst/gstutils.h line 948
signed int gst_element_query_duration(struct _GstElement *, enum anonymous$11, signed long int *);
// gst_element_query_position
// file /usr/include/gstreamer-1.0/gst/gstutils.h line 947
signed int gst_element_query_position(struct _GstElement *, enum anonymous$11, signed long int *);
// gst_element_seek
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 766
signed int gst_element_seek(struct _GstElement *, double, enum anonymous$11, enum anonymous$12, enum anonymous$13, signed long int, enum anonymous$13, signed long int);
// gst_element_set_state
// file /usr/include/gstreamer-1.0/gst/gstelement.h line 796
enum anonymous$20 gst_element_set_state(struct _GstElement *, enum anonymous$21);
// gst_init_get_option_group
// file /usr/include/gstreamer-1.0/gst/gst.h line 97
struct _GOptionGroup * gst_init_get_option_group(void);
// gst_message_parse_error
// file /usr/include/gstreamer-1.0/gst/gstmessage.h line 454
void gst_message_parse_error(struct _GstMessage *, struct _GError **, char **);
// gst_message_parse_state_changed
// file /usr/include/gstreamer-1.0/gst/gstmessage.h line 481
void gst_message_parse_state_changed(struct _GstMessage *, enum anonymous$21 *, enum anonymous$21 *, enum anonymous$21 *);
// gst_message_parse_tag
// file /usr/include/gstreamer-1.0/gst/gstmessage.h line 466
void gst_message_parse_tag(struct _GstMessage *, struct _GstTagList **);
// gst_mini_object_unref
// file /usr/include/gstreamer-1.0/gst/gstminiobject.h line 226
void gst_mini_object_unref(struct _GstMiniObject *);
// gst_object_unref
// file /usr/include/gstreamer-1.0/gst/gstobject.h line 226
void gst_object_unref(void *);
// gst_pipeline_get_bus
// file /usr/include/gstreamer-1.0/gst/gstpipeline.h line 94
struct _GstBus * gst_pipeline_get_bus(struct _GstPipeline *);
// gst_pipeline_get_type
// file /usr/include/gstreamer-1.0/gst/gstpipeline.h line 91
unsigned long int gst_pipeline_get_type(void);
// gst_plugin_feature_get_type
// file /usr/include/gstreamer-1.0/gst/gstpluginfeature.h line 107
unsigned long int gst_plugin_feature_get_type(void);
// gst_plugin_get_name
// file /usr/include/gstreamer-1.0/gst/gstplugin.h line 325
const char * gst_plugin_get_name(struct _GstPlugin *);
// gst_registry_get
// file /usr/include/gstreamer-1.0/gst/gstregistry.h line 62
struct _GstRegistry * gst_registry_get(void);
// gst_registry_get_feature_list_by_plugin
// file /usr/include/gstreamer-1.0/gst/gstregistry.h line 87
struct _GList * gst_registry_get_feature_list_by_plugin(struct _GstRegistry *, const char *);
// gst_registry_get_plugin_list
// file /usr/include/gstreamer-1.0/gst/gstregistry.h line 76
struct _GList * gst_registry_get_plugin_list(struct _GstRegistry *);
// gst_structure_get_name
// file /usr/include/gstreamer-1.0/gst/gststructure.h line 130
const char * gst_structure_get_name(const struct _GstStructure *);
// gst_tag_list_foreach
// file /usr/include/gstreamer-1.0/gst/gsttaglist.h line 275
void gst_tag_list_foreach(const struct _GstTagList *, void (*)(const struct _GstTagList *, const char *, void *), void *);
// gst_tag_list_get_string
// file /usr/include/gstreamer-1.0/gst/gsttaglist.h line 337
signed int gst_tag_list_get_string(const struct _GstTagList *, const char *, char **);
// gst_tag_list_unref
// file /usr/include/gstreamer-1.0/gst/gsttaglist.h line 413
static inline void gst_tag_list_unref(struct _GstTagList *taglist);
// handle_action_request
// file upnp_device.c line 277
static signed int handle_action_request(struct upnp_device *priv, struct Upnp_Action_Request *ar_event);
// handle_subscription_request
// file upnp_device.c line 155
static signed int handle_subscription_request(struct upnp_device *priv, struct Upnp_Subscription_Request *sr_event);
// handle_var_request
// file upnp_device.c line 242
static signed int handle_var_request(struct upnp_device *priv, struct Upnp_State_Var_Request *var_event);
// inform_play_transition_from_output
// file upnp_transport.c line 865
static void inform_play_transition_from_output(enum PlayFeedback fb);
// init_logging
// file main.c line 170
static void init_logging(const char *log_file);
// initialize_device
// file upnp_device.c line 406
static signed int initialize_device(struct upnp_device_descriptor *device_def, struct upnp_device *result_device, const char *ip_address, unsigned short int port);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// ixmlCloneDOMString
// file /usr/include/upnp/ixml.h line 1810
char * ixmlCloneDOMString(const char *);
// ixmlDocument_createDocument
// file /usr/include/upnp/ixml.h line 741
struct _IXML_Document * ixmlDocument_createDocument(void);
// ixmlDocument_createElement
// file /usr/include/upnp/ixml.h line 782
struct _IXML_Element * ixmlDocument_createElement(struct _IXML_Document *, const char *);
// ixmlDocument_createElementNS
// file /usr/include/upnp/ixml.h line 954
struct _IXML_Element * ixmlDocument_createElementNS(struct _IXML_Document *, const char *, const char *);
// ixmlDocument_createTextNode
// file /usr/include/upnp/ixml.h line 818
struct _IXML_Node * ixmlDocument_createTextNode(struct _IXML_Document *, const char *);
// ixmlDocument_free
// file /usr/include/upnp/ixml.h line 1047
void ixmlDocument_free(struct _IXML_Document *);
// ixmlDocumenttoString
// file /usr/include/upnp/ixml.h line 1702
char * ixmlDocumenttoString(struct _IXML_Document *);
// ixmlElement_setAttribute
// file /usr/include/upnp/ixml.h line 1159
signed int ixmlElement_setAttribute(struct _IXML_Element *, const char *, const char *);
// ixmlNode_appendChild
// file /usr/include/upnp/ixml.h line 576
signed int ixmlNode_appendChild(struct _IXML_Node *, struct _IXML_Node *);
// ixmlNode_getFirstChild
// file /usr/include/upnp/ixml.h line 357
struct _IXML_Node * ixmlNode_getFirstChild(struct _IXML_Node *);
// ixmlNode_getNextSibling
// file /usr/include/upnp/ixml.h line 390
struct _IXML_Node * ixmlNode_getNextSibling(struct _IXML_Node *);
// ixmlNode_getNodeName
// file /usr/include/upnp/ixml.h line 279
const char * ixmlNode_getNodeName(struct _IXML_Node *);
// ixmlNode_getNodeValue
// file /usr/include/upnp/ixml.h line 292
const char * ixmlNode_getNodeValue(struct _IXML_Node *);
// ixmlParseBuffer
// file /usr/include/upnp/ixml.h line 1746
struct _IXML_Document * ixmlParseBuffer(const char *);
// list_presets
// file upnp_control.c line 530
static signed int list_presets(struct action_event *event);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log_variable_change
// file main.c line 156
static void log_variable_change(void *userdata, signed int var_num, const char *variable_name, const char *old_value, const char *variable_value);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// meta_update_callback_$object
//
void meta_update_callback_$object(struct SongMetaData *);
// minimum
// file webserver.c line 193
static inline signed int minimum(signed int a, signed int b);
// my_bus_callback
// file output_gstreamer.c line 286
static signed int my_bus_callback(struct _GstBus *bus, struct _GstMessage *msg, void *data);
// obtain_instanceid
// file upnp_transport.c line 524
static signed int obtain_instanceid(struct action_event *event, signed int *instance);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// output_add_options
// file output.h line 43
signed int output_add_options(struct _GOptionContext *ctx);
// output_dump_modules
// file output.h line 44
void output_dump_modules(void);
// output_get_mute
// file output.c line 206
signed int output_get_mute(signed int *value);
// output_get_position
// file output.h line 54
signed int output_get_position(signed long int *track_dur, signed long int *track_pos);
// output_get_volume
// file output.h line 57
signed int output_get_volume(float *value);
// output_gstreamer_add_options
// file output_gstreamer.c line 404
static signed int output_gstreamer_add_options(struct _GOptionContext *ctx);
// output_gstreamer_get_mute
// file output_gstreamer.c line 460
static signed int output_gstreamer_get_mute(signed int *m);
// output_gstreamer_get_position
// file output_gstreamer.c line 418
static signed int output_gstreamer_get_position(signed long int *track_duration, signed long int *track_pos);
// output_gstreamer_get_volume
// file output_gstreamer.c line 448
static signed int output_gstreamer_get_volume(float *v);
// output_gstreamer_init
// file output_gstreamer.c line 489
static signed int output_gstreamer_init(void);
// output_gstreamer_pause
// file output_gstreamer.c line 210
static signed int output_gstreamer_pause(void);
// output_gstreamer_play
// file output_gstreamer.c line 183
static signed int output_gstreamer_play(void (*callback)(enum PlayFeedback));
// output_gstreamer_play::callback$object
//
void callback$object(enum PlayFeedback);
// output_gstreamer_seek
// file output_gstreamer.c line 219
static signed int output_gstreamer_seek(signed long int position_nanos);
// output_gstreamer_set_mute
// file output_gstreamer.c line 466
static signed int output_gstreamer_set_mute(signed int m);
// output_gstreamer_set_next_uri
// file output_gstreamer.c line 168
static void output_gstreamer_set_next_uri(const char *uri);
// output_gstreamer_set_uri
// file output_gstreamer.c line 174
static void output_gstreamer_set_uri(const char *uri, void (*meta_cb)(struct SongMetaData *));
// output_gstreamer_set_uri::meta_cb$object
//
void meta_cb$object(struct SongMetaData *);
// output_gstreamer_set_volume
// file output_gstreamer.c line 455
static signed int output_gstreamer_set_volume(float value);
// output_gstreamer_stop
// file output_gstreamer.c line 201
static signed int output_gstreamer_stop(void);
// output_init
// file output.h line 42
signed int output_init(const char *shortname);
// output_loop
// file output.h line 46
signed int output_loop(void);
// output_pause
// file output.h line 53
signed int output_pause(void);
// output_play
// file output.h line 51
signed int output_play(void (*transition_callback)(enum PlayFeedback));
// output_play::transition_callback$object
//
void transition_callback$object(enum PlayFeedback);
// output_seek
// file output.h line 55
signed int output_seek(signed long int position_nanos);
// output_set_mute
// file output.h line 60
signed int output_set_mute(signed int value);
// output_set_next_uri
// file output.h line 49
void output_set_next_uri(const char *uri);
// output_set_uri
// file output.h line 48
void output_set_uri(const char *uri, void (*meta_cb)(struct SongMetaData *));
// output_set_uri::meta_cb$object
//
void meta_cb$object(struct SongMetaData *);
// output_set_volume
// file output.h line 58
signed int output_set_volume(float value);
// output_stop
// file output.h line 52
signed int output_stop(void);
// parse_upnp_time
// file upnp_transport.c line 766
static signed long int parse_upnp_time(const char *time_string);
// pause_stream
// file upnp_transport.c line 937
static signed int pause_stream(struct action_event *event);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// play
// file upnp_transport.c line 887
static signed int play(struct action_event *event);
// play_trans_callback_$object
//
void play_trans_callback_$object(enum PlayFeedback);
// prepare_for_connection
// file upnp_connmgr.c line 318
static signed int prepare_for_connection(struct action_event *event);
// prepare_next_stream
// file output_gstreamer.c line 472
static void prepare_next_stream(struct _GstElement *obj, void *userdata);
// print_upnp_time
// file upnp_transport.c line 758
static void print_upnp_time(char *result, unsigned long int size, signed long int t);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_cmdline
// file main.c line 132
static signed int process_cmdline(signed int argc, char **argv);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$27 *, const union anonymous$23 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$27 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$27 *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// register_mime_type
// file upnp_connmgr.c line 209
void register_mime_type(const char *mime_type);
// register_mime_type_internal
// file upnp_connmgr.c line 193
static void register_mime_type_internal(const char *mime_type);
// replace_current_uri_and_meta
// file upnp_transport.c line 591
static void replace_current_uri_and_meta(const char *uri, const char *meta);
// replace_range
// file song-meta-data.c line 84
static char * replace_range(char *input, const char *tag_start, const char *tag_end, const char *content, signed int *edit_count);
// replace_transport_uri_and_meta
// file upnp_transport.c line 574
static signed int replace_transport_uri_and_meta(const char *uri, const char *meta);
// replace_var
// file upnp_control.c line 505
static void replace_var(enum anonymous$19 varnum, const char *new_value);
// replace_var$link1
// file upnp_transport.c line 562
static signed int replace_var$link1(enum anonymous$31 varnum$link1, const char *new_value$link1);
// scan_caps
// file output_gstreamer.c line 43
static void scan_caps(const struct _GstCaps *caps);
// scan_mime_list
// file output_gstreamer.c line 99
static void scan_mime_list(void);
// scan_pad_templates_info
// file output_gstreamer.c line 68
static void scan_pad_templates_info(struct _GstElement *element, struct _GstElementFactory *factory);
// seek
// file upnp_transport.c line 971
static signed int seek(struct action_event *event);
// service_lock
// file upnp_control.c line 261
static void service_lock(void);
// service_lock$link1
// file upnp_transport.c line 508
static void service_lock$link1(void);
// service_unlock
// file upnp_control.c line 269
static void service_unlock(void);
// service_unlock$link1
// file upnp_transport.c line 516
static void service_unlock$link1(void);
// set_avtransport_uri
// file upnp_transport.c line 650
static signed int set_avtransport_uri(struct action_event *event);
// set_mute
// file upnp_control.c line 619
static signed int set_mute(struct action_event *event);
// set_mute_toggle
// file upnp_control.c line 614
static void set_mute_toggle(signed int do_mute);
// set_next_avtransport_uri
// file upnp_transport.c line 685
static signed int set_next_avtransport_uri(struct action_event *event);
// set_volume
// file upnp_control.c line 695
static signed int set_volume(struct action_event *event);
// set_volume_db
// file upnp_control.c line 683
static signed int set_volume_db(struct action_event *event);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stop
// file upnp_transport.c line 832
static signed int stop(struct action_event *event);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// thread_update_track_time
// file upnp_transport.c line 777
static void * thread_update_track_time(void *userdata);
// to_idoc
// file xmldoc.c line 44
static struct _IXML_Document * to_idoc(struct xmldoc *x);
// to_ielem
// file xmldoc.c line 48
static struct _IXML_Element * to_ielem(struct xmlelement *x);
// update_meta_from_stream
// file upnp_transport.c line 635
static void update_meta_from_stream(struct SongMetaData *meta);
// upnp_add_response
// file upnp_device.h line 56
signed int upnp_add_response(struct action_event *event, const char *key, const char *value);
// upnp_append_variable
// file upnp_device.h line 67
void upnp_append_variable(struct action_event *event, signed int varnum, const char *paramname);
// upnp_connmgr_get_service
// file upnp_connmgr.c line 347
struct service * upnp_connmgr_get_service(void);
// upnp_control_get_service
// file upnp_control.c line 779
struct service * upnp_control_get_service(void);
// upnp_control_init
// file upnp_control.h line 30
void upnp_control_init(struct upnp_device *device);
// upnp_control_register_variable_listener
// file upnp_control.h line 32
void upnp_control_register_variable_listener(void (*cb)(void *, signed int, const char *, const char *, const char *), void *userdata);
// upnp_control_register_variable_listener::cb$object
//
void cb$object(void *, signed int, const char *, const char *, const char *);
// upnp_create_device_desc
// file upnp_device.h line 80
char * upnp_create_device_desc(struct upnp_device_descriptor *device_def);
// upnp_device_init
// file upnp_device.h line 50
struct upnp_device * upnp_device_init(struct upnp_device_descriptor *device_def, const char *ip_address, unsigned short int port);
// upnp_device_notify
// file upnp_device.h line 70
signed int upnp_device_notify(struct upnp_device *device, const char *serviceID, const char **varnames, const char **varvalues, signed int varcount);
// upnp_device_shutdown
// file upnp_device.h line 54
void upnp_device_shutdown(struct upnp_device *device);
// upnp_get_scpd
// file upnp.c line 213
char * upnp_get_scpd(struct service *srv);
// upnp_get_string
// file upnp_device.h line 62
char * upnp_get_string(struct action_event *event, const char *key);
// upnp_renderer_descriptor
// file upnp_renderer.h line 32
struct upnp_device_descriptor * upnp_renderer_descriptor(const char *friendly_name, const char *uuid);
// upnp_renderer_dump_connmgr_scpd
// file upnp_renderer.h line 27
void upnp_renderer_dump_connmgr_scpd(void);
// upnp_renderer_dump_control_scpd
// file upnp_renderer.h line 28
void upnp_renderer_dump_control_scpd(void);
// upnp_renderer_dump_transport_scpd
// file upnp_renderer.h line 29
void upnp_renderer_dump_transport_scpd(void);
// upnp_renderer_init
// file upnp_renderer.c line 116
static signed int upnp_renderer_init(void);
// upnp_set_error
// file upnp_device.h line 58
void upnp_set_error(struct action_event *event, signed int error_code, const char *format, ...);
// upnp_transport_get_service
// file upnp_transport.c line 1019
struct service * upnp_transport_get_service(void);
// upnp_transport_init
// file upnp_transport.h line 33
void upnp_transport_init(struct upnp_device *device);
// upnp_transport_register_variable_listener
// file upnp_transport.h line 37
void upnp_transport_register_variable_listener(void (*cb)(void *, signed int, const char *, const char *, const char *), void *userdata);
// upnp_transport_register_variable_listener::cb$object
//
void cb$object(void *, signed int, const char *, const char *, const char *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// volume_decibel_to_level
// file upnp_control.c line 651
static signed int volume_decibel_to_level(float decibel);
// volume_level_to_decibel
// file upnp_control.c line 636
static float volume_level_to_decibel(signed int volume);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// webserver_close
// file webserver.c line 246
static signed int webserver_close(void *fh);
// webserver_get_info
// file webserver.c line 145
static signed int webserver_get_info(const char *filename, struct File_Info *info);
// webserver_open
// file webserver.c line 171
static void * webserver_open(const char *filename, enum UpnpOpenFileMode mode);
// webserver_read
// file webserver.c line 198
static signed int webserver_read(void *fh, char *buf, unsigned long int buflen);
// webserver_register_buf
// file webserver.h line 32
signed int webserver_register_buf(const char *path, const char *contents, const char *content_type);
// webserver_register_callbacks
// file webserver.h line 30
signed int webserver_register_callbacks(void);
// webserver_register_file
// file webserver.h line 34
signed int webserver_register_file(const char *path, const char *content_type);
// webserver_seek
// file webserver.c line 220
static signed int webserver_seek(void *fh, signed long int offset, signed int origin);
// webserver_write
// file webserver.c line 215
static signed int webserver_write(void *fh, char *buf, unsigned long int buflen);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xmldoc_free
// file xmldoc.h line 32
void xmldoc_free(struct xmldoc *doc);
// xmldoc_new
// file xmldoc.h line 30
struct xmldoc * xmldoc_new(void);
// xmldoc_new_topelement
// file xmldoc.h line 36
struct xmlelement * xmldoc_new_topelement(struct xmldoc *doc, const char *elementName, const char *xmlns);
// xmldoc_parsexml
// file xmldoc.h line 34
struct xmldoc * xmldoc_parsexml(const char *xml_text);
// xmldoc_tostring
// file xmldoc.h line 33
char * xmldoc_tostring(struct xmldoc *doc);
// xmlelement_add_element
// file xmldoc.h line 42
void xmlelement_add_element(struct xmldoc *doc, struct xmlelement *parent, struct xmlelement *child);
// xmlelement_add_text
// file xmldoc.c line 146
void xmlelement_add_text(struct xmldoc *doc, struct xmlelement *parent, const char *text);
// xmlelement_new
// file xmldoc.h line 40
struct xmlelement * xmlelement_new(struct xmldoc *doc, const char *elementName);
// xmlelement_set_attribute
// file xmldoc.h line 48
void xmlelement_set_attribute(struct xmldoc *doc, struct xmlelement *element, const char *name, const char *value);
// xmlescape
// file xmlescape.h line 30
char * xmlescape(const char *str, signed int attribute);
// xmlescape_real
// file xmlescape.c line 34
static void xmlescape_real(const char *str, char *target, signed int *length, signed int attribute);

struct anonymous$25
{
  // last_flowret
  enum anonymous$24 last_flowret;
};

struct anonymous$28
{
  // pos
  signed long int pos;
  // contents
  const char *contents;
  // len
  unsigned long int len;
};

union anonymous$3
{
  // _gst_reserved
  void *_gst_reserved[4l];
  // abi
  struct anonymous$25 abi;
};

union anonymous$23
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$14
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$27
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct File_Info
{
  // file_length
  signed long int file_length;
  // last_modified
  signed long int last_modified;
  // is_directory
  signed int is_directory;
  // is_readable
  signed int is_readable;
  // content_type
  char *content_type;
};

struct MetaModify
{
  // meta
  struct SongMetaData *meta;
  // any_change
  signed int any_change;
};

struct SongMetaData
{
  // title
  const char *title;
  // artist
  const char *artist;
  // album
  const char *album;
  // genre
  const char *genre;
  // composer
  const char *composer;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct Upnp_Action_Request
{
  // ErrCode
  signed int ErrCode;
  // Socket
  signed int Socket;
  // ErrStr
  char ErrStr[180l];
  // ActionName
  char ActionName[256l];
  // DevUDN
  char DevUDN[256l];
  // ServiceID
  char ServiceID[256l];
  // ActionRequest
  struct _IXML_Document *ActionRequest;
  // ActionResult
  struct _IXML_Document *ActionResult;
  // CtrlPtIPAddr
  struct sockaddr_storage CtrlPtIPAddr;
  // SoapHeader
  struct _IXML_Document *SoapHeader;
};

struct Upnp_State_Var_Request
{
  // ErrCode
  signed int ErrCode;
  // Socket
  signed int Socket;
  // ErrStr
  char ErrStr[180l];
  // DevUDN
  char DevUDN[256l];
  // ServiceID
  char ServiceID[256l];
  // StateVarName
  char StateVarName[256l];
  // CtrlPtIPAddr
  struct sockaddr_storage CtrlPtIPAddr;
  // CurrentVal
  char *CurrentVal;
};

struct Upnp_Subscription_Request
{
  // ServiceId
  char *ServiceId;
  // UDN
  char *UDN;
  // Sid
  char Sid[44l];
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GCond
{
  // p
  void *p;
  // i
  unsigned int i[2l];
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GHook
{
  // data
  void *data;
  // next
  struct _GHook *next;
  // prev
  struct _GHook *prev;
  // ref_count
  unsigned int ref_count;
  // hook_id
  unsigned long int hook_id;
  // flags
  unsigned int flags;
  // func
  void *func;
  // destroy
  void (*destroy)(void *);
};

struct _GHookList
{
  // seq_id
  unsigned long int seq_id;
  // hook_size
  unsigned int hook_size : 16;
  // is_setup
  unsigned int is_setup : 1;
  // hooks
  struct _GHook *hooks;
  // dummy3
  void *dummy3;
  // finalize_hook
  void (*finalize_hook)(struct _GHookList *, struct _GHook *);
  // dummy
  void *dummy[2l];
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

union _GMutex
{
  // p
  void *p;
  // i
  unsigned int i[2l];
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GOptionEntry
{
  // long_name
  const char *long_name;
  // short_name
  char short_name;
  // flags
  signed int flags;
  // arg
  enum anonymous$26 arg;
  // arg_data
  void *arg_data;
  // description
  const char *description;
  // arg_description
  const char *arg_description;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous$10 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GRecMutex
{
  // p
  void *p;
  // i
  unsigned int i[2l];
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GThread
{
  // func
  void * (*func)(void *);
  // data
  void *data;
  // joinable
  signed int joinable;
  // priority
  enum anonymous$15 priority;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$14 data[2l];
};

struct _GstObject
{
  // object
  struct _GObject object;
  // lock
  union _GMutex lock;
  // name
  char *name;
  // parent
  struct _GstObject *parent;
  // flags
  unsigned int flags;
  // control_bindings
  struct _GList *control_bindings;
  // control_rate
  unsigned long int control_rate;
  // last_sync
  unsigned long int last_sync;
  // _gst_reserved
  void *_gst_reserved;
};

struct _GstElement
{
  // object
  struct _GstObject object;
  // state_lock
  struct _GRecMutex state_lock;
  // state_cond
  struct _GCond state_cond;
  // state_cookie
  unsigned int state_cookie;
  // target_state
  enum anonymous$21 target_state;
  // current_state
  enum anonymous$21 current_state;
  // next_state
  enum anonymous$21 next_state;
  // pending_state
  enum anonymous$21 pending_state;
  // last_return
  enum anonymous$20 last_return;
  // bus
  struct _GstBus *bus;
  // clock
  struct _GstClock *clock;
  // base_time
  signed long int base_time;
  // start_time
  unsigned long int start_time;
  // numpads
  unsigned short int numpads;
  // pads
  struct _GList *pads;
  // numsrcpads
  unsigned short int numsrcpads;
  // srcpads
  struct _GList *srcpads;
  // numsinkpads
  unsigned short int numsinkpads;
  // sinkpads
  struct _GList *sinkpads;
  // pads_cookie
  unsigned int pads_cookie;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstBin
{
  // element
  struct _GstElement element;
  // numchildren
  signed int numchildren;
  // children
  struct _GList *children;
  // children_cookie
  unsigned int children_cookie;
  // child_bus
  struct _GstBus *child_bus;
  // messages
  struct _GList *messages;
  // polling
  signed int polling;
  // state_dirty
  signed int state_dirty;
  // clock_dirty
  signed int clock_dirty;
  // provided_clock
  struct _GstClock *provided_clock;
  // clock_provider
  struct _GstElement *clock_provider;
  // priv
  struct _GstBinPrivate *priv;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstMiniObject
{
  // type
  unsigned long int type;
  // refcount
  signed int refcount;
  // lockstate
  signed int lockstate;
  // flags
  unsigned int flags;
  // copy
  struct _GstMiniObject * (*copy)(const struct _GstMiniObject *);
  // dispose
  signed int (*dispose)(struct _GstMiniObject *);
  // free
  void (*free)(struct _GstMiniObject *);
  // n_qdata
  unsigned int n_qdata;
  // qdata
  void *qdata;
};

struct _GstBuffer
{
  // mini_object
  struct _GstMiniObject mini_object;
  // pool
  struct _GstBufferPool *pool;
  // pts
  unsigned long int pts;
  // dts
  unsigned long int dts;
  // duration
  unsigned long int duration;
  // offset
  unsigned long int offset;
  // offset_end
  unsigned long int offset_end;
};

struct _GstBufferPool
{
  // object
  struct _GstObject object;
  // flushing
  signed int flushing;
  // priv
  struct _GstBufferPoolPrivate *priv;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstBus
{
  // object
  struct _GstObject object;
  // priv
  struct _GstBusPrivate *priv;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstCaps
{
  // mini_object
  struct _GstMiniObject mini_object;
};

struct _GstClock
{
  // object
  struct _GstObject object;
  // priv
  struct _GstClockPrivate *priv;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstObjectClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // path_string_separator
  const char *path_string_separator;
  // deep_notify
  void (*deep_notify)(struct _GstObject *, struct _GstObject *, struct _GParamSpec *);
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstElementClass
{
  // parent_class
  struct _GstObjectClass parent_class;
  // metadata
  void *metadata;
  // elementfactory
  struct _GstElementFactory *elementfactory;
  // padtemplates
  struct _GList *padtemplates;
  // numpadtemplates
  signed int numpadtemplates;
  // pad_templ_cookie
  unsigned int pad_templ_cookie;
  // pad_added
  void (*pad_added)(struct _GstElement *, struct _GstPad *);
  // pad_removed
  void (*pad_removed)(struct _GstElement *, struct _GstPad *);
  // no_more_pads
  void (*no_more_pads)(struct _GstElement *);
  // request_new_pad
  struct _GstPad * (*request_new_pad)(struct _GstElement *, struct _GstPadTemplate *, const char *, const struct _GstCaps *);
  // release_pad
  void (*release_pad)(struct _GstElement *, struct _GstPad *);
  // get_state
  enum anonymous$20 (*get_state)(struct _GstElement *, enum anonymous$21 *, enum anonymous$21 *, unsigned long int);
  // set_state
  enum anonymous$20 (*set_state)(struct _GstElement *, enum anonymous$21);
  // change_state
  enum anonymous$20 (*change_state)(struct _GstElement *, enum anonymous$9);
  // state_changed
  void (*state_changed)(struct _GstElement *, enum anonymous$21, enum anonymous$21, enum anonymous$21);
  // set_bus
  void (*set_bus)(struct _GstElement *, struct _GstBus *);
  // provide_clock
  struct _GstClock * (*provide_clock)(struct _GstElement *);
  // set_clock
  signed int (*set_clock)(struct _GstElement *, struct _GstClock *);
  // send_event
  signed int (*send_event)(struct _GstElement *, struct _GstEvent *);
  // query
  signed int (*query)(struct _GstElement *, struct _GstQuery *);
  // post_message
  signed int (*post_message)(struct _GstElement *, struct _GstMessage *);
  // set_context
  void (*set_context)(struct _GstElement *, struct _GstContext *);
  // _gst_reserved
  void *_gst_reserved[18l];
};

struct _GstEvent
{
  // mini_object
  struct _GstMiniObject mini_object;
  // type
  enum anonymous$4 type;
  // timestamp
  unsigned long int timestamp;
  // seqnum
  unsigned int seqnum;
};

struct _GstIterator
{
  // copy
  void (*copy)(const struct _GstIterator *, struct _GstIterator *);
  // next
  enum anonymous$5 (*next)(struct _GstIterator *, struct _GValue *);
  // item
  enum anonymous$6 (*item)(struct _GstIterator *, const struct _GValue *);
  // resync
  void (*resync)(struct _GstIterator *);
  // free
  void (*free)(struct _GstIterator *);
  // pushed
  struct _GstIterator *pushed;
  // type
  unsigned long int type;
  // lock
  union _GMutex *lock;
  // cookie
  unsigned int cookie;
  // master_cookie
  unsigned int *master_cookie;
  // size
  unsigned int size;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstMessage
{
  // mini_object
  struct _GstMiniObject mini_object;
  // type
  enum anonymous$7 type;
  // timestamp
  unsigned long int timestamp;
  // src
  struct _GstObject *src;
  // seqnum
  unsigned int seqnum;
  // lock
  union _GMutex lock;
  // cond
  struct _GCond cond;
};

struct _GstPad
{
  // object
  struct _GstObject object;
  // element_private
  void *element_private;
  // padtemplate
  struct _GstPadTemplate *padtemplate;
  // direction
  enum anonymous direction;
  // stream_rec_lock
  struct _GRecMutex stream_rec_lock;
  // task
  struct _GstTask *task;
  // block_cond
  struct _GCond block_cond;
  // probes
  struct _GHookList probes;
  // mode
  enum anonymous$1 mode;
  // activatefunc
  signed int (*activatefunc)(struct _GstPad *, struct _GstObject *);
  // activatedata
  void *activatedata;
  // activatenotify
  void (*activatenotify)(void *);
  // activatemodefunc
  signed int (*activatemodefunc)(struct _GstPad *, struct _GstObject *, enum anonymous$1, signed int);
  // activatemodedata
  void *activatemodedata;
  // activatemodenotify
  void (*activatemodenotify)(void *);
  // peer
  struct _GstPad *peer;
  // linkfunc
  enum anonymous$2 (*linkfunc)(struct _GstPad *, struct _GstObject *, struct _GstPad *);
  // linkdata
  void *linkdata;
  // linknotify
  void (*linknotify)(void *);
  // unlinkfunc
  void (*unlinkfunc)(struct _GstPad *, struct _GstObject *);
  // unlinkdata
  void *unlinkdata;
  // unlinknotify
  void (*unlinknotify)(void *);
  // chainfunc
  enum anonymous$24 (*chainfunc)(struct _GstPad *, struct _GstObject *, struct _GstBuffer *);
  // chaindata
  void *chaindata;
  // chainnotify
  void (*chainnotify)(void *);
  // chainlistfunc
  enum anonymous$24 (*chainlistfunc)(struct _GstPad *, struct _GstObject *, struct _GstBufferList *);
  // chainlistdata
  void *chainlistdata;
  // chainlistnotify
  void (*chainlistnotify)(void *);
  // getrangefunc
  enum anonymous$24 (*getrangefunc)(struct _GstPad *, struct _GstObject *, unsigned long int, unsigned int, struct _GstBuffer **);
  // getrangedata
  void *getrangedata;
  // getrangenotify
  void (*getrangenotify)(void *);
  // eventfunc
  signed int (*eventfunc)(struct _GstPad *, struct _GstObject *, struct _GstEvent *);
  // eventdata
  void *eventdata;
  // eventnotify
  void (*eventnotify)(void *);
  // offset
  signed long int offset;
  // queryfunc
  signed int (*queryfunc)(struct _GstPad *, struct _GstObject *, struct _GstQuery *);
  // querydata
  void *querydata;
  // querynotify
  void (*querynotify)(void *);
  // iterintlinkfunc
  struct _GstIterator * (*iterintlinkfunc)(struct _GstPad *, struct _GstObject *);
  // iterintlinkdata
  void *iterintlinkdata;
  // iterintlinknotify
  void (*iterintlinknotify)(void *);
  // num_probes
  signed int num_probes;
  // num_blocked
  signed int num_blocked;
  // priv
  struct _GstPadPrivate *priv;
  // ABI
  union anonymous$3 ABI;
};

struct _GstPadTemplate
{
  // object
  struct _GstObject object;
  // name_template
  char *name_template;
  // direction
  enum anonymous direction;
  // presence
  enum anonymous$22 presence;
  // caps
  struct _GstCaps *caps;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstPipeline
{
  // bin
  struct _GstBin bin;
  // fixed_clock
  struct _GstClock *fixed_clock;
  // stream_time
  unsigned long int stream_time;
  // delay
  unsigned long int delay;
  // priv
  struct _GstPipelinePrivate *priv;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _GstQuery
{
  // mini_object
  struct _GstMiniObject mini_object;
  // type
  enum anonymous$18 type;
};

struct _GstRegistry
{
  // object
  struct _GstObject object;
  // priv
  struct _GstRegistryPrivate *priv;
};

struct _GstStructure
{
  // type
  unsigned long int type;
  // name
  unsigned int name;
};

struct _GstTagList
{
  // mini_object
  struct _GstMiniObject mini_object;
};

struct _GstTask
{
  // object
  struct _GstObject object;
  // state
  enum anonymous$0 state;
  // cond
  struct _GCond cond;
  // lock
  struct _GRecMutex *lock;
  // func
  void (*func)(void *);
  // user_data
  void *user_data;
  // notify
  void (*notify)(void *);
  // running
  signed int running;
  // thread
  struct _GThread *thread;
  // priv
  struct _GstTaskPrivate *priv;
  // _gst_reserved
  void *_gst_reserved[4l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _IXML_Node
{
  // nodeName
  char *nodeName;
  // nodeValue
  char *nodeValue;
  // nodeType
  enum anonymous$17 nodeType;
  // namespaceURI
  char *namespaceURI;
  // prefix
  char *prefix;
  // localName
  char *localName;
  // readOnly
  signed int readOnly;
  // parentNode
  struct _IXML_Node *parentNode;
  // firstChild
  struct _IXML_Node *firstChild;
  // prevSibling
  struct _IXML_Node *prevSibling;
  // nextSibling
  struct _IXML_Node *nextSibling;
  // firstAttr
  struct _IXML_Node *firstAttr;
  // ownerDocument
  struct _IXML_Document *ownerDocument;
};

struct _IXML_Document
{
  // n
  struct _IXML_Node n;
};

struct _IXML_Element
{
  // n
  struct _IXML_Node n;
  // tagName
  char *tagName;
};

struct action
{
  // action_name
  const char *action_name;
  // callback
  signed int (*callback)(struct action_event *);
};

struct action_event
{
  // request
  struct Upnp_Action_Request *request;
  // status
  signed int status;
  // service
  struct service *service;
  // device
  struct upnp_device *device;
};

struct argument
{
  // name
  const char *name;
  // direction
  enum anonymous$8 direction;
  // statevar
  signed int statevar;
};

struct cb_list
{
  // callback
  void (*callback)(void *, signed int, const char *, const char *, const char *);
  // userdata
  void *userdata;
  // next
  struct cb_list *next;
};

struct icon
{
  // width
  signed int width;
  // height
  signed int height;
  // depth
  signed int depth;
  // url
  const char *url;
  // mimetype
  const char *mimetype;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct mime_type
{
  // mime_type
  const char *mime_type;
  // next
  struct mime_type *next;
};

struct output_module
{
  // shortname
  const char *shortname;
  // description
  const char *description;
  // add_options
  signed int (*add_options)(struct _GOptionContext *);
  // init
  signed int (*init)(void);
  // set_uri
  void (*set_uri)(const char *, void (*)(struct SongMetaData *));
  // set_next_uri
  void (*set_next_uri)(const char *);
  // play
  signed int (*play)(void (*)(enum PlayFeedback));
  // stop
  signed int (*stop)(void);
  // pause
  signed int (*pause)(void);
  // loop
  signed int (*loop)(void);
  // seek
  signed int (*seek)(signed long int);
  // get_position
  signed int (*get_position)(signed long int *, signed long int *);
  // get_volume
  signed int (*get_volume)(float *);
  // set_volume
  signed int (*set_volume)(float);
  // get_mute
  signed int (*get_mute)(signed int *);
  // set_mute
  signed int (*set_mute)(signed int);
};

struct param_range
{
  // min
  signed long long int min;
  // max
  signed long long int max;
  // step
  signed long long int step;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct service
{
  // service_mutex
  union anonymous$27 *service_mutex;
  // service_id
  const char *service_id;
  // service_type
  const char *service_type;
  // scpd_url
  const char *scpd_url;
  // control_url
  const char *control_url;
  // event_url
  const char *event_url;
  // event_xml_ns
  const char *event_xml_ns;
  // actions
  struct action *actions;
  // action_arguments
  struct argument ***action_arguments;
  // variable_names
  const char **variable_names;
  // variable_container
  struct variable_container *variable_container;
  // last_change
  struct upnp_last_change_collector *last_change;
  // variable_meta
  struct var_meta *variable_meta;
  // variable_count
  signed int variable_count;
  // command_count
  signed int command_count;
  // eventvar_names
  const char **eventvar_names;
  // eventvar_values
  const char **eventvar_values;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct track_time_info
{
  // duration
  signed long int duration;
  // position
  signed long int position;
};

struct upnp_device
{
  // upnp_device_descriptor
  struct upnp_device_descriptor *upnp_device_descriptor;
  // device_mutex
  union anonymous$27 device_mutex;
  // device_handle
  signed int device_handle;
};

struct upnp_device_descriptor
{
  // init_function
  signed int (*init_function)(void);
  // device_type
  const char *device_type;
  // friendly_name
  const char *friendly_name;
  // manufacturer
  const char *manufacturer;
  // manufacturer_url
  const char *manufacturer_url;
  // model_description
  const char *model_description;
  // model_name
  const char *model_name;
  // model_number
  const char *model_number;
  // model_url
  const char *model_url;
  // serial_number
  const char *serial_number;
  // udn
  const char *udn;
  // upc
  const char *upc;
  // presentation_url
  const char *presentation_url;
  // icons
  struct icon **icons;
  // services
  struct service **services;
};

struct upnp_last_change_builder
{
  // xml_namespace
  const char *xml_namespace;
  // change_event_doc
  struct xmldoc *change_event_doc;
  // instance_element
  struct xmlelement *instance_element;
};

struct upnp_last_change_collector
{
  // variable_container
  struct variable_container *variable_container;
  // last_change_variable_num
  signed int last_change_variable_num;
  // not_eventable_variables
  unsigned int not_eventable_variables;
  // upnp_device
  struct upnp_device *upnp_device;
  // service_id
  const char *service_id;
  // open_transactions
  signed int open_transactions;
  // builder
  struct upnp_last_change_builder *builder;
};

struct var_meta
{
  // sendevents
  enum anonymous$29 sendevents;
  // datatype
  enum anonymous$30 datatype;
  // allowed_values
  const char **allowed_values;
  // allowed_range
  struct param_range *allowed_range;
  // default_value
  const char *default_value;
};

struct variable_container
{
  // variable_num
  signed int variable_num;
  // variable_names
  const char **variable_names;
  // values
  char **values;
  // callbacks
  struct cb_list *callbacks;
};

struct virtual_file
{
  // virtual_fname
  const char *virtual_fname;
  // contents
  const char *contents;
  // content_type
  const char *content_type;
  // len
  unsigned long int len;
  // next
  struct virtual_file *next;
};

struct xmldoc
{
};

struct xmlelement
{
};


// aat_channels
// file upnp_control.c line 164
static const char *aat_channels[4l] = { "Master", "LF", "RF", (const char *)(void *)0 };
// aat_presetnames
// file upnp_control.c line 156
static const char *aat_presetnames[4l] = { "FactoryDefaults", "InstallationDefaults", "Vendor defined", (const char *)(void *)0 };
// aat_seekmodi
// file upnp_transport.c line 306
static const char *aat_seekmodi[9l] = { "ABS_TIME", "REL_TIME", "ABS_COUNT", "REL_COUNT", "TRACK_NR", "CHANNEL_FREQ", "TAPE-INDEX", "FRAME", (const char *)(void *)0 };
// argument_list
// file upnp_control.c line 464
static struct argument **argument_list[22l];
// arguments_get_blue_black
// file upnp_control.c line 367
static struct argument *arguments_get_blue_black[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentBlueVideoBlackLevel", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_B_BLACK }),
    (struct argument *)(void *)0 };
// arguments_get_blue_gain
// file upnp_control.c line 337
static struct argument *arguments_get_blue_gain[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentBlueVideoGain", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_B_GAIN }),
    (struct argument *)(void *)0 };
// arguments_get_brightness
// file upnp_control.c line 287
static struct argument *arguments_get_brightness[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentBrightness", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_BRIGHTNESS }),
    (struct argument *)(void *)0 };
// arguments_get_color_temp
// file upnp_control.c line 377
static struct argument *arguments_get_color_temp[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentColorTemperature", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_COLOR_TEMP }),
    (struct argument *)(void *)0 };
// arguments_get_contrast
// file upnp_control.c line 297
static struct argument *arguments_get_contrast[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentContrast", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_CONTRAST }),
    (struct argument *)(void *)0 };
// arguments_get_green_black
// file upnp_control.c line 357
static struct argument *arguments_get_green_black[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentGreenVideoBlackLevel", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_G_BLACK }),
    (struct argument *)(void *)0 };
// arguments_get_green_gain
// file upnp_control.c line 327
static struct argument *arguments_get_green_gain[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentGreenVideoGain", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_G_GAIN }),
    (struct argument *)(void *)0 };
// arguments_get_hor_keystone
// file upnp_control.c line 387
static struct argument *arguments_get_hor_keystone[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentHorizontalKeystone", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_HOR_KEYSTONE }),
    (struct argument *)(void *)0 };
// arguments_get_loudness
// file upnp_control.c line 450
static struct argument *arguments_get_loudness[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="CurrentLoudness", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_LOUDNESS }),
    (struct argument *)(void *)0 };
// arguments_get_mute
// file upnp_control.c line 407
static struct argument *arguments_get_mute[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="CurrentMute", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_MUTE }),
    (struct argument *)(void *)0 };
// arguments_get_red_black
// file upnp_control.c line 347
static struct argument *arguments_get_red_black[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentRedVideoBlackLevel", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_R_BLACK }),
    (struct argument *)(void *)0 };
// arguments_get_red_gain
// file upnp_control.c line 317
static struct argument *arguments_get_red_gain[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentRedVideoGain", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_R_GAIN }),
    (struct argument *)(void *)0 };
// arguments_get_sharpness
// file upnp_control.c line 307
static struct argument *arguments_get_sharpness[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentSharpness", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_SHARPNESS }),
    (struct argument *)(void *)0 };
// arguments_get_vert_keystone
// file upnp_control.c line 397
static struct argument *arguments_get_vert_keystone[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentVerticalKeystone", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_VER_KEYSTONE }),
    (struct argument *)(void *)0 };
// arguments_get_vol
// file upnp_control.c line 419
static struct argument *arguments_get_vol[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="CurrentVolume", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_VOLUME }),
    (struct argument *)(void *)0 };
// arguments_get_vol_db
// file upnp_control.c line 431
static struct argument *arguments_get_vol_db[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="CurrentVolume", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_VOLUME_DB }),
    (struct argument *)(void *)0 };
// arguments_get_vol_dbrange
// file upnp_control.c line 443
static struct argument *arguments_get_vol_dbrange[5l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="MinValue", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_VOLUME_DB }),
    &((struct argument){ .name="MaxValue", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_VOLUME_DB }),
    (struct argument *)(void *)0 };
// arguments_list_presets
// file upnp_control.c line 277
static struct argument *arguments_list_presets[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentPresetNameList", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=CONTROL_VAR_PRESET_NAME_LIST }),
    (struct argument *)(void *)0 };
// arguments_set_mute
// file upnp_control.c line 413
static struct argument *arguments_set_mute[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="DesiredMute", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_MUTE }),
    (struct argument *)(void *)0 };
// arguments_set_vol
// file upnp_control.c line 425
static struct argument *arguments_set_vol[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="DesiredVolume", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_VOLUME }),
    (struct argument *)(void *)0 };
// arguments_set_vol_db
// file upnp_control.c line 437
static struct argument *arguments_set_vol_db[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Channel", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_AAT_CHANNEL }),
    &((struct argument){ .name="DesiredVolume", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=CONTROL_VAR_VOLUME_DB }),
    (struct argument *)(void *)0 };
// argument_list
// file upnp_control.c line 464
static struct argument **argument_list[22l] = { arguments_get_blue_black, arguments_get_blue_gain, arguments_get_brightness, arguments_get_color_temp, arguments_get_contrast, arguments_get_green_black, arguments_get_green_gain, arguments_get_hor_keystone, arguments_get_loudness, arguments_get_mute, arguments_get_red_black, arguments_get_red_gain, arguments_get_sharpness, arguments_get_vert_keystone, arguments_get_vol, arguments_get_vol_db, arguments_get_vol_dbrange, arguments_list_presets, arguments_set_mute, arguments_set_vol, arguments_set_vol_db, (struct argument **)(void *)0 };
// argument_list$link1
// file upnp_connmgr.c line 120
static struct argument **argument_list$link1[5l];
// arguments_getcurrentconnectionids
// file upnp_connmgr.c line 90
static struct argument *arguments_getcurrentconnectionids[2l] = { &((struct argument){ .name="ConnectionIDs", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=9 }),
    (struct argument *)(void *)0 };
// arguments_getprotocolinfo
// file upnp_connmgr.c line 85
static struct argument *arguments_getprotocolinfo[3l] = { &((struct argument){ .name="Source", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=8 }),
    &((struct argument){ .name="Sink", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=1 }),
    (struct argument *)(void *)0 };
// arguments_prepareforconnection
// file upnp_connmgr.c line 105
static struct argument *arguments_prepareforconnection[8l] = { &((struct argument){ .name="RemoteProtocolInfo", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=6 }),
    &((struct argument){ .name="PeerConnectionManager", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=0 }),
    &((struct argument){ .name="PeerConnectionID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=7 }),
    &((struct argument){ .name="Direction", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=4 }),
    &((struct argument){ .name="ConnectionID", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=7 }),
    &((struct argument){ .name="AVTransportID", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=3 }),
    &((struct argument){ .name="RcsID", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=5 }),
    (struct argument *)(void *)0 };
// arguments_setcurrentconnectioninfo
// file upnp_connmgr.c line 94
static struct argument *arguments_setcurrentconnectioninfo[9l] = { &((struct argument){ .name="ConnectionID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=7 }),
    &((struct argument){ .name="RcsID", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=5 }),
    &((struct argument){ .name="AVTransportID", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=3 }),
    &((struct argument){ .name="ProtocolInfo", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=6 }),
    &((struct argument){ .name="PeerConnectionManager", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=0 }),
    &((struct argument){ .name="PeerConnectionID", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=7 }),
    &((struct argument){ .name="Direction", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=4 }),
    &((struct argument){ .name="Status", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=2 }),
    (struct argument *)(void *)0 };
// argument_list$link1
// file upnp_connmgr.c line 120
static struct argument **argument_list$link1[5l] = { arguments_getcurrentconnectionids, arguments_setcurrentconnectioninfo, arguments_getprotocolinfo, arguments_prepareforconnection, (struct argument **)(void *)0 };
// argument_list$link2
// file upnp_transport.c line 477
static struct argument **argument_list$link2[13l];
// arguments_getcurrenttransportactions
// file upnp_transport.c line 470
static struct argument *arguments_getcurrenttransportactions[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Actions", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS }),
    (struct argument *)(void *)0 };
// arguments_getdevicecapabilities
// file upnp_transport.c line 413
static struct argument *arguments_getdevicecapabilities[5l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="PlayMedia", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_PLAY_MEDIA }),
    &((struct argument){ .name="RecMedia", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_REC_MEDIA }),
    &((struct argument){ .name="RecQualityModes", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_POS_REC_QUAL_MODE }),
    (struct argument *)(void *)0 };
// arguments_getmediainfo
// file upnp_transport.c line 378
static struct argument *arguments_getmediainfo[11l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="NrTracks", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_NR_TRACKS }),
    &((struct argument){ .name="MediaDuration", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_MEDIA_DUR }),
    &((struct argument){ .name="CurrentURI", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_AV_URI }),
    &((struct argument){ .name="CurrentURIMetaData", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_AV_URI_META }),
    &((struct argument){ .name="NextURI", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_NEXT_AV_URI }),
    &((struct argument){ .name="NextURIMetaData", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_NEXT_AV_URI_META }),
    &((struct argument){ .name="PlayMedium", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_PLAY_MEDIUM }),
    &((struct argument){ .name="RecordMedium", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_REC_MEDIUM }),
    &((struct argument){ .name="WriteStatus", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_REC_MEDIUM_WR_STATUS }),
    (struct argument *)(void *)0 };
// arguments_getpositioninfo
// file upnp_transport.c line 400
static struct argument *arguments_getpositioninfo[10l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Track", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_TRACK }),
    &((struct argument){ .name="TrackDuration", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_TRACK_DUR }),
    &((struct argument){ .name="TrackMetaData", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_TRACK_META }),
    &((struct argument){ .name="TrackURI", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_TRACK_URI }),
    &((struct argument){ .name="RelTime", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_REL_TIME_POS }),
    &((struct argument){ .name="AbsTime", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_ABS_TIME_POS }),
    &((struct argument){ .name="RelCount", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_REL_CTR_POS }),
    &((struct argument){ .name="AbsCount", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_ABS_CTR_POS }),
    (struct argument *)(void *)0 };
// arguments_gettransportinfo
// file upnp_transport.c line 392
static struct argument *arguments_gettransportinfo[5l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentTransportState", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_TRANSPORT_STATE }),
    &((struct argument){ .name="CurrentTransportStatus", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_TRANSPORT_STATUS }),
    &((struct argument){ .name="CurrentSpeed", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_TRANSPORT_PLAY_SPEED }),
    (struct argument *)(void *)0 };
// arguments_gettransportsettings
// file upnp_transport.c line 421
static struct argument *arguments_gettransportsettings[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="PlayMode", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_PLAY_MODE }),
    &((struct argument){ .name="RecQualityMode", .direction=(enum anonymous$8)PARAM_DIR_OUT, .statevar=TRANSPORT_VAR_CUR_REC_QUAL_MODE }),
    (struct argument *)(void *)0 };
// arguments_pause
// file upnp_transport.c line 437
static struct argument *arguments_pause[2l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    (struct argument *)(void *)0 };
// arguments_play
// file upnp_transport.c line 432
static struct argument *arguments_play[3l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Speed", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_TRANSPORT_PLAY_SPEED }),
    (struct argument *)(void *)0 };
// arguments_seek
// file upnp_transport.c line 446
static struct argument *arguments_seek[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="Unit", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_SEEK_MODE }),
    &((struct argument){ .name="Target", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_SEEK_TARGET }),
    (struct argument *)(void *)0 };
// arguments_setavtransporturi
// file upnp_transport.c line 364
static struct argument *arguments_setavtransporturi[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="CurrentURI", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AV_URI }),
    &((struct argument){ .name="CurrentURIMetaData", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AV_URI_META }),
    (struct argument *)(void *)0 };
// arguments_setnextavtransporturi
// file upnp_transport.c line 371
static struct argument *arguments_setnextavtransporturi[4l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    &((struct argument){ .name="NextURI", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_NEXT_AV_URI }),
    &((struct argument){ .name="NextURIMetaData", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_NEXT_AV_URI_META }),
    (struct argument *)(void *)0 };
// arguments_stop
// file upnp_transport.c line 428
static struct argument *arguments_stop[2l] = { &((struct argument){ .name="InstanceID", .direction=(enum anonymous$8)PARAM_DIR_IN, .statevar=TRANSPORT_VAR_AAT_INSTANCE_ID }),
    (struct argument *)(void *)0 };
// argument_list$link2
// file upnp_transport.c line 477
static struct argument **argument_list$link2[13l] = { arguments_getcurrenttransportactions, arguments_getdevicecapabilities, arguments_getmediainfo, arguments_getpositioninfo, arguments_gettransportinfo, arguments_gettransportsettings, arguments_pause, arguments_play, arguments_seek, arguments_setavtransporturi, arguments_stop, arguments_setnextavtransporturi, (struct argument **)(void *)0 };
// audio_device
// file output_gstreamer.c line 380
static char *audio_device = (char *)(void *)0;
// audio_sink
// file output_gstreamer.c line 379
static char *audio_sink = (char *)(void *)0;
// brightness_range
// file upnp_control.c line 198
static struct param_range brightness_range = { .min=(signed long long int)0, .max=(signed long long int)100, .step=(signed long long int)1 };
// colortemp_range
// file upnp_control.c line 203
static struct param_range colortemp_range = { .min=(signed long long int)0, .max=(signed long long int)65535, .step=(signed long long int)1 };
// connmgr_actions
// file upnp_connmgr.c line 83
static struct action connmgr_actions[5l];
// connmgr_actions
// file upnp_connmgr.c line 83
static struct action connmgr_actions[5l] = { { .action_name="GetCurrentConnectionIDs", .callback=get_current_conn_ids },
    { .action_name="GetCurrentConnectionInfo", .callback=get_current_conn_info },
    { .action_name="GetProtocolInfo", .callback=get_protocol_info },
    { .action_name="PrepareForConnection", .callback=prepare_for_connection },
    { .action_name=(const char *)(void *)0, .callback=(signed int (*)(struct action_event *))(void *)0 } };
// connmgr_default_values
// file upnp_connmgr.c line 143
static const char *connmgr_default_values[11l] = { "/", "http-get:*:audio/mpeg:*", "Unknown", "0", "Input", "0", ":::", "-1", "", "0", (const char *)(void *)0 };
// connmgr_mutex
// file upnp_connmgr.c line 185
static union anonymous$27 connmgr_mutex;
// connmgr_service_
// file upnp_connmgr.c line 367
struct service connmgr_service_;
// connmgr_var_meta
// file upnp_connmgr.c line 171
static struct var_meta connmgr_var_meta[11l];
// connstatus_values
// file upnp_connmgr.c line 157
static const char *connstatus_values[6l] = { "OK", "ContentFormatMismatch", "InsufficientBandwidth", "UnreliableChannel", "Unknown", (const char *)(void *)0 };
// direction_values
// file upnp_connmgr.c line 165
static const char *direction_values[3l] = { "Input", "Output", (const char *)(void *)0 };
// connmgr_var_meta
// file upnp_connmgr.c line 171
static struct var_meta connmgr_var_meta[11l] = { { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_YES, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=connstatus_values,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=direction_values,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_YES, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_YES, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UNKNOWN,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) } };
// connmgr_variable_names
// file upnp_connmgr.c line 129
static const char *connmgr_variable_names[11l] = { "A_ARG_TYPE_ConnectionManager", "SinkProtocolInfo", "A_ARG_TYPE_ConnectionStatus", "A_ARG_TYPE_AVTransportID", "A_ARG_TYPE_Direction", "A_ARG_TYPE_RcsID", "A_ARG_TYPE_ProtocolInfo", "A_ARG_TYPE_ConnectionID", "SourceProtocolInfo", "CurrentConnectionIDs", (const char *)(void *)0 };
// connmgr_service_
// file upnp_connmgr.c line 367
struct service connmgr_service_ = { .service_mutex=&connmgr_mutex, .service_id="urn:upnp-org:serviceId:ConnectionManager", .service_type="urn:schemas-upnp-org:service:ConnectionManager:1",
    .scpd_url="/upnp/renderconnmgrSCPD.xml",
    .control_url="/upnp/control/renderconnmgr1",
    .event_url="/upnp/event/renderconnmgr1",
    .event_xml_ns=((const char *)NULL),
    .actions=connmgr_actions, .action_arguments=argument_list$link1,
    .variable_names=connmgr_variable_names,
    .variable_container=(struct variable_container *)(void *)0,
    .last_change=(struct upnp_last_change_collector *)(void *)0,
    .variable_meta=connmgr_var_meta,
    .variable_count=10, .command_count=4,
    .eventvar_names=((const char **)NULL), .eventvar_values=((const char **)NULL) };
// contrast_range
// file upnp_control.c line 199
static struct param_range contrast_range = { .min=(signed long long int)0, .max=(signed long long int)100, .step=(signed long long int)1 };
// control_actions
// file upnp_control.c line 129
static struct action control_actions[22l];
// control_actions
// file upnp_control.c line 129
static struct action control_actions[22l] = { { .action_name="GetBlueVideoBlackLevel", .callback=get_blue_videoblacklevel },
    { .action_name="GetBlueVideoGain", .callback=get_blue_videogain },
    { .action_name="GetBrightness", .callback=get_brightness },
    { .action_name="GetColorTemperature", .callback=get_colortemperature },
    { .action_name="GetContrast", .callback=get_contrast },
    { .action_name="GetGreenVideoBlackLevel", .callback=get_green_videoblacklevel },
    { .action_name="GetGreenVideoGain", .callback=get_green_videogain },
    { .action_name="GetHorizontalKeystone", .callback=get_horizontal_keystone },
    { .action_name="GetLoudness", .callback=get_loudness },
    { .action_name="GetMute", .callback=get_mute },
    { .action_name="GetRedVideoBlackLevel", .callback=get_red_videoblacklevel },
    { .action_name="GetRedVideoGain", .callback=get_red_videogain },
    { .action_name="GetSharpness", .callback=get_sharpness },
    { .action_name="GetVerticalKeystone", .callback=get_vertical_keystone },
    { .action_name="GetVolume", .callback=get_volume },
    { .action_name="GetVolumeDB", .callback=get_volume_db },
    { .action_name="GetVolumeDBRange", .callback=get_volume_dbrange },
    { .action_name="ListPresets", .callback=list_presets },
    { .action_name="SetMute", .callback=set_mute },
    { .action_name="SetVolume", .callback=set_volume },
    { .action_name="SetVolumeDB", .callback=set_volume_db },
    { .action_name=(const char *)(void *)0, .callback=(signed int (*)(struct action_event *))(void *)0 } };
// control_default_values
// file upnp_control.c line 231
static const char *control_default_values[22l] = { "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "", "0", "0", "0", "<Event xmlns = \"urn:schemas-upnp-org:metadata-1-0/RCS/\"/>",
    "", "0", "0", "", "0", "0", (const char *)(void *)0 };
// control_mutex
// file upnp_control.c line 259
static union anonymous$27 control_mutex;
// control_service_
// file upnp_control.c line 822
struct service control_service_;
// control_var_meta
// file upnp_control.c line 206
static struct var_meta control_var_meta[22l];
// keystone_range
// file upnp_control.c line 204
static struct param_range keystone_range = { .min=(signed long long int)-32768, .max=(signed long long int)32767, .step=(signed long long int)1 };
// sharpness_range
// file upnp_control.c line 200
static struct param_range sharpness_range = { .min=(signed long long int)0, .max=(signed long long int)100, .step=(signed long long int)1 };
// vid_black_range
// file upnp_control.c line 202
static struct param_range vid_black_range = { .min=(signed long long int)0, .max=(signed long long int)100, .step=(signed long long int)1 };
// vid_gain_range
// file upnp_control.c line 201
static struct param_range vid_gain_range = { .min=(signed long long int)0, .max=(signed long long int)100, .step=(signed long long int)1 };
// volume_db_range
// file upnp_control.c line 194
static struct param_range volume_db_range = { .min=(signed long long int)(-60 * 256), .max=(signed long long int)0,
    .step=(signed long long int)0 };
// volume_range
// file upnp_control.c line 193
static struct param_range volume_range = { .min=(signed long long int)0, .max=(signed long long int)100, .step=(signed long long int)1 };
// control_var_meta
// file upnp_control.c line 206
static struct var_meta control_var_meta[22l] = { { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&vid_gain_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&vid_black_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&keystone_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&vid_black_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&volume_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_BOOLEAN,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&vid_gain_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&colortemp_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&sharpness_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=aat_presetnames,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&vid_black_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&vid_gain_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_BOOLEAN,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_YES, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=aat_channels,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&keystone_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&volume_db_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&contrast_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI2,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&brightness_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UNKNOWN,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) } };
// control_variable_names
// file upnp_control.c line 131
static const char *control_variable_names[22l] = { "GreenVideoGain", "BlueVideoBlackLevel", "VerticalKeystone", "GreenVideoBlackLevel", "Volume", "Loudness", "A_ARG_TYPE_InstanceID", "RedVideoGain", "ColorTemperature", "Sharpness", "A_ARG_TYPE_PresetName", "RedVideoBlackLevel", "BlueVideoGain", "Mute", "LastChange", "A_ARG_TYPE_Channel", "HorizontalKeystone", "VolumeDB", "PresetNameList", "Contrast", "Brightness", (const char *)(void *)0 };
// control_service_
// file upnp_control.c line 822
struct service control_service_ = { .service_mutex=&control_mutex, .service_id="urn:upnp-org:serviceId:RenderingControl", .service_type="urn:schemas-upnp-org:service:RenderingControl:1",
    .scpd_url="/upnp/rendercontrolSCPD.xml",
    .control_url="/upnp/control/rendercontrol1",
    .event_url="/upnp/event/rendercontrol1",
    .event_xml_ns="urn:schemas-upnp-org:metadata-1-0/RCS/",
    .actions=control_actions,
    .action_arguments=argument_list, .variable_names=control_variable_names,
    .variable_container=(struct variable_container *)(void *)0,
    .last_change=(struct upnp_last_change_collector *)(void *)0,
    .variable_meta=control_var_meta,
    .variable_count=CONTROL_VAR_UNKNOWN, .command_count=21,
    .eventvar_names=((const char **)NULL), .eventvar_values=((const char **)NULL) };
// daemon_mode
// file main.c line 64
static signed int daemon_mode = 0;
// enable_color
// file logging.c line 42
static signed int enable_color = 0;
// error_markup_start_
// file logging.c line 49
static const char *error_markup_start_ = "ERROR ";
// friendly_name
// file main.c line 79
static const char *friendly_name = "gmediarender";
// gs_next_uri_
// file output_gstreamer.c line 149
static char *gs_next_uri_ = (char *)(void *)0;
// gstreamer_output
// file output_gstreamer.c line 546
struct output_module gstreamer_output;
// gstreamer_output
// file output_gstreamer.c line 546
struct output_module gstreamer_output = { .shortname="gst", .description="GStreamer multimedia framework", .add_options=output_gstreamer_add_options,
    .init=output_gstreamer_init,
    .set_uri=output_gstreamer_set_uri, .set_next_uri=output_gstreamer_set_next_uri,
    .play=output_gstreamer_play,
    .stop=output_gstreamer_stop, .pause=output_gstreamer_pause,
    .loop=((signed int (*)(void))NULL), .seek=output_gstreamer_seek,
    .get_position=output_gstreamer_get_position, .get_volume=output_gstreamer_get_volume,
    .set_volume=output_gstreamer_set_volume,
    .get_mute=output_gstreamer_get_mute,
    .set_mute=output_gstreamer_set_mute };
// gsuri_
// file output_gstreamer.c line 148
static char *gsuri_ = (char *)(void *)0;
// icon1
// file upnp_renderer.c line 54
static struct icon icon1 = { .width=64, .height=64, .depth=24, .url="/upnp/grender-64x64.png", .mimetype="image/png" };
// icon2
// file upnp_renderer.c line 61
static struct icon icon2 = { .width=128, .height=128, .depth=24, .url="/upnp/grender-128x128.png", .mimetype="image/png" };
// info_markup_start_
// file logging.c line 48
static const char *info_markup_start_ = "INFO  ";
// initial_db
// file output_gstreamer.c line 382
static double initial_db = 0.0;
// ip_address
// file main.c line 70
static const char *ip_address = (const char *)(void *)0;
// kDidlFooter
// file song-meta-data.c line 55
static const char kDidlFooter[13l] = { '<', '/', 'D', 'I', 'D', 'L', '-', 'L', 'i', 't', 'e', '>', 0 };
// kDidlHeader
// file song-meta-data.c line 51
static const char kDidlHeader[162l] = { '<', 'D', 'I', 'D', 'L', '-', 'L', 'i', 't', 'e', ' ', 'x', 'm', 'l', 'n', 's', '=', '"', 'u', 'r', 'n', ':', 's', 'c', 'h', 'e', 'm', 'a', 's', '-', 'u', 'p', 'n', 'p', '-', 'o', 'r', 'g', ':', 'm', 'e', 't', 'a', 'd', 'a', 't', 'a', '-', '1', '-', '0', '/', 'D', 'I', 'D', 'L', '-', 'L', 'i', 't', 'e', '/', '"', ' ', 'x', 'm', 'l', 'n', 's', ':', 'd', 'c', '=', '"', 'h', 't', 't', 'p', ':', '/', '/', 'p', 'u', 'r', 'l', '.', 'o', 'r', 'g', '/', 'd', 'c', '/', 'e', 'l', 'e', 'm', 'e', 'n', 't', 's', '/', '1', '.', '1', '/', '"', ' ', 'x', 'm', 'l', 'n', 's', ':', 'u', 'p', 'n', 'p', '=', '"', 'u', 'r', 'n', ':', 's', 'c', 'h', 'e', 'm', 'a', 's', '-', 'u', 'p', 'n', 'p', '-', 'o', 'r', 'g', ':', 'm', 'e', 't', 'a', 'd', 'a', 't', 'a', '-', '1', '-', '0', '/', 'u', 'p', 'n', 'p', '/', '"', '>', 0 };
// kErrorHighlight
// file logging.c line 45
static const char * const kErrorHighlight = "\033[1m\033[31mERROR ";
// kInfoHighlight
// file logging.c line 44
static const char * const kInfoHighlight = "\033[1mINFO  ";
// kTermReset
// file logging.c line 46
static const char * const kTermReset = "\033[0m";
// kZeroTime
// file upnp_transport.c line 170
static const char kZeroTime[8l] = { '0', ':', '0', '0', ':', '0', '0', 0 };
// last_known_time_
// file output_gstreamer.c line 159
static struct track_time_info last_known_time_ = { .duration=(signed long int)0, .position=(signed long int)0 };
// listen_port
// file main.c line 71
static signed int listen_port = 49494;
// log_fd
// file logging.c line 41
static signed int log_fd = -1;
// log_file
// file main.c line 82
static const char *log_file = (const char *)(void *)0;
// main_loop_
// file output.c line 110
static struct _GMainLoop *main_loop_ = (struct _GMainLoop *)(void *)0;
// markup_end_
// file logging.c line 50
static const char *markup_end_ = "";
// media
// file upnp_transport.c line 231
static const char *media[34l] = { "UNKNOWN", "DV", "MINI-DV", "VHS", "W-VHS", "S-VHS", "D-VHS", "VHSC", "VIDEO8", "HI8", "CD-ROM", "CD-DA", "CD-R", "CD-RW", "VIDEO-CD", "SACD", "MD-AUDIO", "MD-PICTURE", "DVD-ROM", "DVD-VIDEO", "DVD-R", "DVD+RW", "DVD-RW", "DVD-RAM", "DVD-AUDIO", "DAT", "LD", "HDD", "MICRO-MV", "NETWORK", "NONE", "NOT_IMPLEMENTED", " vendor-defined ", (const char *)(void *)0 };
// meta_update_callback_
// file output_gstreamer.c line 153
static void (*meta_update_callback_)(struct SongMetaData *) = (void (*)(struct SongMetaData *))(void *)0;
// modules
// file output.c line 43
static struct output_module *modules[1l];
// modules
// file output.c line 43
static struct output_module *modules[1l] = { &gstreamer_output };
// option_entries
// file main.c line 85
static struct _GOptionEntry option_entries[15l];
// output
// file main.c line 80
static const char *output = (const char *)(void *)0;
// pid_file
// file main.c line 81
static const char *pid_file = (const char *)(void *)0;
// show_connmgr_scpd
// file main.c line 60
static signed int show_connmgr_scpd = 0;
// show_control_scpd
// file main.c line 61
static signed int show_control_scpd = 0;
// show_devicedesc
// file main.c line 59
static signed int show_devicedesc = 0;
// show_outputs
// file main.c line 63
static signed int show_outputs = 0;
// show_transport_scpd
// file main.c line 62
static signed int show_transport_scpd = 0;
// show_version
// file main.c line 58
static signed int show_version = 0;
// uuid
// file main.c line 77
static const char *uuid = "GMediaRender-1_0-000-000-002";
// option_entries
// file main.c line 85
static struct _GOptionEntry option_entries[15l] = { { .long_name="version", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&show_version,
    .description="Output version information and exit", .arg_description=(const char *)(void *)0 },
    { .long_name="ip-address", .short_name=(char)73, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&ip_address,
    .description="The local IP address the service is running and advertised (only one, 0.0.0.0 won't work)", .arg_description=(const char *)(void *)0 },
    { .long_name="port", .short_name=(char)112, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_INT, .arg_data=(void *)&listen_port,
    .description="Port to listen to; [49152..65535] (libupnp does not use SO_REUSEADDR, so might increment)", .arg_description=(const char *)(void *)0 },
    { .long_name="uuid", .short_name=(char)117, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&uuid,
    .description="UUID to advertise", .arg_description=(const char *)(void *)0 },
    { .long_name="friendly-name", .short_name=(char)102, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&friendly_name,
    .description="Friendly name to advertise.", .arg_description=(const char *)(void *)0 },
    { .long_name="output", .short_name=(char)111, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&output,
    .description="Output module to use.", .arg_description=(const char *)(void *)0 },
    { .long_name="pid-file", .short_name=(char)80, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&pid_file,
    .description="File the process ID should be written to.", .arg_description=(const char *)(void *)0 },
    { .long_name="daemon", .short_name=(char)100, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&daemon_mode,
    .description="Run as daemon.", .arg_description=(const char *)(void *)0 },
    { .long_name="logfile", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&log_file,
    .description="Debug log filename. Use /dev/stdout to log to console.", .arg_description=(const char *)(void *)0 },
    { .long_name="list-outputs", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&show_outputs,
    .description="List available output modules and exit", .arg_description=(const char *)(void *)0 },
    { .long_name="dump-devicedesc", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&show_devicedesc,
    .description="Dump device descriptor XML and exit.", .arg_description=(const char *)(void *)0 },
    { .long_name="dump-connmgr-scpd", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&show_connmgr_scpd,
    .description="Dump Connection Manager service description XML and exit.",
    .arg_description=(const char *)(void *)0 },
    { .long_name="dump-control-scpd", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&show_control_scpd,
    .description="Dump Rendering Control service description XML and exit.",
    .arg_description=(const char *)(void *)0 },
    { .long_name="dump-transport-scpd", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_NONE, .arg_data=(void *)&show_transport_scpd,
    .description="Dump A/V Transport service description XML and exit.",
    .arg_description=(const char *)(void *)0 },
    { .long_name=(const char *)(void *)0, .short_name=0, .flags=0,
    .arg=(enum anonymous$26)0, .arg_data=NULL,
    .description=((const char *)NULL), .arg_description=((const char *)NULL) } };
// option_entries$link1
// file output_gstreamer.c line 385
static struct _GOptionEntry option_entries$link1[5l];
// videosink
// file output_gstreamer.c line 381
static char *videosink = (char *)(void *)0;
// option_entries$link1
// file output_gstreamer.c line 385
static struct _GOptionEntry option_entries$link1[5l] = { { .long_name="gstout-audiosink", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&audio_sink,
    .description="GStreamer audio sink to use (autoaudiosink, alsasink, osssink, esdsink, ...)", .arg_description=(const char *)(void *)0 },
    { .long_name="gstout-audiodevice", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&audio_device,
    .description="GStreamer device for the given audiosink. ", .arg_description=(const char *)(void *)0 },
    { .long_name="gstout-videosink", .short_name=(char)0, .flags=0,
    .arg=(enum anonymous$26)G_OPTION_ARG_STRING, .arg_data=(void *)&videosink,
    .description="GStreamer video sink to use (autovideosink, xvimagesink, ximagesink, ...)", .arg_description=(const char *)(void *)0 },
    { .long_name="gstout-initial-volume-db", .short_name=(char)0,
    .flags=0, .arg=(enum anonymous$26)G_OPTION_ARG_DOUBLE, .arg_data=(void *)&initial_db,
    .description="GStreamer inital volume in decibel (e.g. 0.0 = max; -6 = 1/2 max) ", .arg_description=(const char *)(void *)0 },
    { .long_name=(const char *)(void *)0, .short_name=0, .flags=0,
    .arg=(enum anonymous$26)0, .arg_data=NULL,
    .description=((const char *)NULL), .arg_description=((const char *)NULL) } };
// output_module
// file output.c line 53
static struct output_module *output_module = (struct output_module *)(void *)0;
// param_datatype_names
// file upnp.c line 41
static const char *param_datatype_names[7l] = { "string", "boolean", "i2", "i4", "ui2", "ui4", (const char *)(void *)0 };
// play_trans_callback_
// file output_gstreamer.c line 152
static void (*play_trans_callback_)(enum PlayFeedback) = (void (*)(enum PlayFeedback))(void *)0;
// player_
// file output_gstreamer.c line 147
static struct _GstElement *player_ = (struct _GstElement *)(void *)0;
// playmodi
// file upnp_transport.c line 268
static const char *playmodi[4l] = { "NORMAL", "REPEAT_ALL", "INTRO", (const char *)(void *)0 };
// playspeeds
// file upnp_transport.c line 279
static const char *playspeeds[3l] = { "1", " vendor-defined ", (const char *)(void *)0 };
// rec_quality_modi
// file upnp_transport.c line 294
static const char *rec_quality_modi[9l] = { "0:EP", "1:LP", "2:SP", "0:BASIC", "1:MEDIUM", "2:HIGH", "NOT_IMPLEMENTED", " vendor-defined ", (const char *)(void *)0 };
// rec_write_stati
// file upnp_transport.c line 285
static const char *rec_write_stati[6l] = { "WRITABLE", "PROTECTED", "NOT_WRITABLE", "UNKNOWN", "NOT_IMPLEMENTED", (const char *)(void *)0 };
// render_device
// file upnp_renderer.c line 77
static struct upnp_device_descriptor render_device;
// renderer_icon
// file upnp_renderer.c line 69
static struct icon *renderer_icon[3l];
// renderer_icon
// file upnp_renderer.c line 69
static struct icon *renderer_icon[3l] = { &icon1, &icon2, (struct icon *)(void *)0 };
// render_device
// file upnp_renderer.c line 77
static struct upnp_device_descriptor render_device = { .init_function=upnp_renderer_init, .device_type="urn:schemas-upnp-org:device:MediaRenderer:1", .friendly_name="GMediaRender",
    .manufacturer="Ivo Clarysse, Henner Zeller", .manufacturer_url="http://github.com/hzeller/gmrender-resurrect",
    .model_description="gmediarender 0.0.7-git",
    .model_name="gmediarender",
    .model_number="0.0.7-git", .model_url="http://github.com/hzeller/gmrender-resurrect",
    .serial_number="1",
    .udn="uuid:GMediaRender-1_0-000-000-002", .upc="",
    .presentation_url="", .icons=renderer_icon, .services=((struct service **)NULL) };
// song_meta_
// file output_gstreamer.c line 150
static struct SongMetaData song_meta_;
// state_variables_
// file upnp_control.c line 257
static struct variable_container *state_variables_ = (struct variable_container *)(void *)0;
// state_variables_$link1
// file upnp_transport.c line 502
static struct variable_container *state_variables_$link1 = (struct variable_container *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// supported_types
// file upnp_connmgr.c line 191
static struct mime_type *supported_types = (struct mime_type *)(void *)0;
// track_nr_range
// file upnp_transport.c line 324
static struct param_range track_nr_range = { .min=(signed long long int)0, .max=4294967295LL, .step=(signed long long int)0 };
// track_range
// file upnp_transport.c line 318
static struct param_range track_range = { .min=(signed long long int)0, .max=4294967295LL, .step=(signed long long int)1 };
// transport_actions
// file upnp_transport.c line 998
static struct action transport_actions[13l];
// transport_actions
// file upnp_transport.c line 998
static struct action transport_actions[13l] = { { .action_name="GetCurrentTransportActions", .callback=get_current_transportactions },
    { .action_name="GetDeviceCapabilities", .callback=get_device_caps },
    { .action_name="GetMediaInfo", .callback=get_media_info },
    { .action_name="GetPositionInfo", .callback=get_position_info },
    { .action_name="GetTransportInfo", .callback=get_transport_info },
    { .action_name="GetTransportSettings", .callback=get_transport_settings },
    { .action_name="Pause", .callback=pause_stream },
    { .action_name="Play", .callback=play },
    { .action_name="Seek", .callback=seek },
    { .action_name="SetAVTransportURI", .callback=set_avtransport_uri },
    { .action_name="Stop", .callback=stop },
    { .action_name="SetNextAVTransportURI", .callback=set_next_avtransport_uri },
    { .action_name=(const char *)(void *)0, .callback=(signed int (*)(struct action_event *))(void *)0 } };
// transport_default_values
// file upnp_transport.c line 171
static const char *transport_default_values[31l];
// transport_default_values
// file upnp_transport.c line 171
static const char *transport_default_values[31l] = { "OK", "", "", "", "2147483647", "0", "", "UNKNOWN", kZeroTime, "NOT_IMPLEMENTED", "NORMAL", "1", "NETWORK,UNKNOWN", "NOT_IMPLEMENTED", "0", "", "PLAY", "0", "", "2147483647", "NOT_IMPLEMENTED", "", "TRACK_NR", "", "NOT_IMPLEMENTED", "NOT_IMPLEMENTED", "<Event xmlns=\"urn:schemas-upnp-org:metadata-1-0/AVT/\"/>",
    kZeroTime, "STOPPED", "NOT_IMPLEMENTED", (const char *)(void *)0 };
// transport_mutex
// file upnp_transport.c line 506
static union anonymous$27 transport_mutex;
// transport_service_
// file upnp_transport.c line 1056
struct service transport_service_;
// transport_var_meta
// file upnp_transport.c line 330
static struct var_meta transport_var_meta[31l];
// transport_states
// file upnp_transport.c line 215
static const char *transport_states[8l] = { "STOPPED", "PLAYING", "TRANSITIONING", "PAUSED_PLAYBACK", "PAUSED_RECORDING", "RECORDING", "NO_MEDIA_PRESENT", (const char *)(void *)0 };
// transport_stati
// file upnp_transport.c line 225
static const char *transport_stati[4l] = { "OK", "ERROR_OCCURRED", " vendor-defined ", (const char *)(void *)0 };
// transport_var_meta
// file upnp_transport.c line 330
static struct var_meta transport_var_meta[31l] = { { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=transport_stati,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=media,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=playmodi,
    .allowed_range=(struct param_range *)(void *)0, .default_value="NORMAL" },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=playspeeds,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&track_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UI4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=&track_nr_range,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_I4,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=rec_quality_modi,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=aat_seekmodi,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=media,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=rec_write_stati,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_YES, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=transport_states,
    .allowed_range=(struct param_range *)(void *)0, .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_STRING,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) },
    { .sendevents=(enum anonymous$29)SENDEVENT_NO, .datatype=(enum anonymous$30)DATATYPE_UNKNOWN,
    .allowed_values=(const char **)(void *)0,
    .allowed_range=(struct param_range *)(void *)0,
    .default_value=((const char *)NULL) } };
// transport_variable_names
// file upnp_transport.c line 136
static const char *transport_variable_names[31l] = { "TransportStatus", "NextAVTransportURI", "NextAVTransportURIMetaData", "CurrentTrackMetaData", "RelativeCounterPosition", "A_ARG_TYPE_InstanceID", "A_ARG_TYPE_SeekTarget", "PlaybackStorageMedium", "RelativeTimePosition", "PossibleRecordStorageMedia", "CurrentPlayMode", "TransportPlaySpeed", "PossiblePlaybackStorageMedia", "AbsoluteTimePosition", "CurrentTrack", "CurrentTrackURI", "CurrentTransportActions", "NumberOfTracks", "AVTransportURI", "AbsoluteCounterPosition", "CurrentRecordQualityMode", "CurrentMediaDuration", "A_ARG_TYPE_SeekMode", "AVTransportURIMetaData", "RecordStorageMedium", "RecordMediumWriteStatus", "LastChange", "CurrentTrackDuration", "TransportState", "PossibleRecordQualityModes", (const char *)(void *)0 };
// transport_service_
// file upnp_transport.c line 1056
struct service transport_service_ = { .service_mutex=&transport_mutex, .service_id="urn:upnp-org:serviceId:AVTransport", .service_type="urn:schemas-upnp-org:service:AVTransport:1",
    .scpd_url="/upnp/rendertransportSCPD.xml",
    .control_url="/upnp/control/rendertransport1",
    .event_url="/upnp/event/rendertransport1",
    .event_xml_ns="urn:schemas-upnp-org:metadata-1-0/AVT/",
    .actions=transport_actions,
    .action_arguments=argument_list$link2, .variable_names=transport_variable_names,
    .variable_container=(struct variable_container *)(void *)0,
    .last_change=(struct upnp_last_change_collector *)(void *)0,
    .variable_meta=transport_var_meta,
    .variable_count=TRANSPORT_VAR_UNKNOWN, .command_count=12,
    .eventvar_names=((const char **)NULL), .eventvar_values=((const char **)NULL) };
// transport_state_
// file upnp_transport.c line 500
static enum transport_state transport_state_ = (enum transport_state)TRANSPORT_STOPPED;
// virtual_files
// file webserver.c line 60
static struct virtual_file *virtual_files = (struct virtual_file *)(void *)0;
// vol_max_db
// file upnp_control.c line 188
static const float vol_max_db = (const float)0.0;
// vol_mid_db
// file upnp_control.c line 187
static const float vol_mid_db = (const float)-20.0;
// vol_mid_point
// file upnp_control.c line 189
static const signed int vol_mid_point = 50;
// vol_min_db
// file upnp_control.c line 186
static const float vol_min_db = (const float)-60.0;

// Log_color_allowed
// file logging.h line 34
signed int Log_color_allowed(void)
{
  return enable_color;
}

// Log_error
// file logging.h line 40
void Log_error(const char *category, const char *format, ...)
{
  void **ap = (void **)&format;
  Log_internal(log_fd < 0 ? 2 : log_fd, error_markup_start_, category, format, ap);
  ap = ((void **)NULL);
}

// Log_error_enabled
// file logging.c line 70
signed int Log_error_enabled(void)
{
  return 1;
}

// Log_info
// file logging.h line 38
void Log_info(const char *category, const char *format, ...)
{
  if(log_fd >= 0)
  {
    void **ap = (void **)&format;
    Log_internal(log_fd, info_markup_start_, category, format, ap);
    ap = ((void **)NULL);
  }

}

// Log_info_enabled
// file logging.h line 35
signed int Log_info_enabled(void)
{
  return (signed int)(log_fd >= 0);
}

// Log_init
// file logging.h line 33
void Log_init(const char *filename)
{
  if(!(filename == ((const char *)NULL)))
  {
    log_fd=open(filename, 0100 | 02000 | 01, 0644);
    if(!(log_fd >= 0))
      perror("Cannot open logfile");

    else
    {
      enable_color=isatty(log_fd);
      if(!(enable_color == 0))
      {
        info_markup_start_ = kInfoHighlight;
        error_markup_start_ = kErrorHighlight;
        markup_end_ = kTermReset;
      }

    }
  }

}

// Log_internal
// file logging.c line 72
static void Log_internal(signed int fd, const char *markup_start, const char *category, const char *format, void **ap)
{
  struct timeval now;
  gettimeofday(&now, (struct timezone *)(void *)0);
  struct tm time_breakdown;
  localtime_r(&now.tv_sec, &time_breakdown);
  char fmt_buf[128l];
  strftime(fmt_buf, sizeof(char [128l]) /*128ul*/ , "%F %T", &time_breakdown);
  struct iovec parts[3l];
  signed int return_value_asprintf$1;
  return_value_asprintf$1=asprintf((char **)&parts[(signed long int)0].iov_base, "%s[%s.%06ld | %s]%s ", markup_start, (const void *)fmt_buf, now.tv_usec, category, markup_end_);
  parts[(signed long int)0].iov_len = (unsigned long int)return_value_asprintf$1;
  signed int return_value_vasprintf$2;
  return_value_vasprintf$2=vasprintf((char **)&parts[(signed long int)1].iov_base, format, ap);
  parts[(signed long int)1].iov_len = (unsigned long int)return_value_vasprintf$2;
  parts[(signed long int)2].iov_base = (void *)"\n";
  parts[(signed long int)2].iov_len = (unsigned long int)1;
  signed int already_newline;
  _Bool tmp_if_expr$3;
  if(parts[1l].iov_len >= 1ul)
    tmp_if_expr$3 = (signed int)((const char *)parts[(signed long int)1].iov_base)[(signed long int)(parts[(signed long int)1].iov_len - (unsigned long int)1)] == 10 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  already_newline = (signed int)tmp_if_expr$3;
  signed long int return_value_writev$4;
  return_value_writev$4=writev(fd, parts, already_newline != 0 ? 2 : 3);
  free(parts[(signed long int)0].iov_base);
  free(parts[(signed long int)1].iov_base);
}

// MetaModify_add_tag
// file output_gstreamer.c line 256
static void MetaModify_add_tag(const struct _GstTagList *list, const char *tag, void *user_data)
{
  struct MetaModify *data = (struct MetaModify *)user_data;
  const char **destination = (const char **)(void *)0;
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(tag, "title");
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$5 == 0)
    destination = &data->meta->title;

  else
  {
    return_value_strcmp$4=strcmp(tag, "artist");
    if(return_value_strcmp$4 == 0)
      destination = &data->meta->artist;

    else
    {
      return_value_strcmp$3=strcmp(tag, "album");
      if(return_value_strcmp$3 == 0)
        destination = &data->meta->album;

      else
      {
        return_value_strcmp$2=strcmp(tag, "genre");
        if(return_value_strcmp$2 == 0)
          destination = &data->meta->genre;

        else
        {
          return_value_strcmp$1=strcmp(tag, "composer");
          if(return_value_strcmp$1 == 0)
            destination = &data->meta->composer;

        }
      }
    }
  }
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  if(!(destination == ((const char **)NULL)))
  {
    char *replace = (char *)(void *)0;
    gst_tag_list_get_string(list, tag, &replace);
    if(!(replace == ((char *)NULL)))
    {
      if(*destination == ((const char *)NULL))
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_strcmp$6=strcmp(replace, *destination);
        tmp_if_expr$7 = return_value_strcmp$6 != 0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
    {
      free((void *)(char *)*destination);
      *destination = replace;
      data->any_change = data->any_change + 1;
    }

    else
      free((void *)replace);
  }

}

// SongMetaData_clear
// file song-meta-data.c line 40
void SongMetaData_clear(struct SongMetaData *value)
{
  free((void *)(char *)value->title);
  value->title = (const char *)(void *)0;
  free((void *)(char *)value->artist);
  value->artist = (const char *)(void *)0;
  free((void *)(char *)value->album);
  value->album = (const char *)(void *)0;
  free((void *)(char *)value->genre);
  value->genre = (const char *)(void *)0;
}

// SongMetaData_init
// file song-meta-data.c line 37
void SongMetaData_init(struct SongMetaData *value)
{
  memset((void *)value, 0, sizeof(struct SongMetaData) /*40ul*/ );
}

// SongMetaData_parse_DIDL
// file song-meta-data.c line 120
signed int SongMetaData_parse_DIDL(struct SongMetaData *object, const char *xml)
{
  struct xmldoc *doc;
  doc=xmldoc_parsexml(xml);
  if(doc == ((struct xmldoc *)NULL))
    return 0;

  else
  {
    struct xmlelement *didl_node;
    didl_node=find_element_in_doc(doc, "DIDL-Lite");
    if(didl_node == ((struct xmlelement *)NULL))
      return 0;

    else
    {
      struct xmlelement *item_node;
      item_node=find_element_in_element(didl_node, "item");
      if(item_node == ((struct xmlelement *)NULL))
        return 0;

      else
      {
        struct xmlelement *value_node = (struct xmlelement *)(void *)0;
        value_node=find_element_in_element(item_node, "dc:title");
        if(!(value_node == ((struct xmlelement *)NULL)))
          object->title=get_node_value(value_node);

        value_node=find_element_in_element(item_node, "upnp:artist");
        if(!(value_node == ((struct xmlelement *)NULL)))
          object->artist=get_node_value(value_node);

        value_node=find_element_in_element(item_node, "upnp:album");
        if(!(value_node == ((struct xmlelement *)NULL)))
          object->album=get_node_value(value_node);

        value_node=find_element_in_element(item_node, "upnp:genre");
        if(!(value_node == ((struct xmlelement *)NULL)))
          object->genre=get_node_value(value_node);

        xmldoc_free(doc);
        return 1;
      }
    }
  }
}

// SongMetaData_to_DIDL
// file song-meta-data.h line 45
char * SongMetaData_to_DIDL(struct SongMetaData *object, const char *original_xml)
{
  char unique_id[13l];
  static unsigned int xml_id = (unsigned int)42;
  unsigned int tmp_post$1 = xml_id;
  xml_id = xml_id + 1u;
  snprintf(unique_id, sizeof(char [13l]) /*13ul*/ , "gmr-%08x", tmp_post$1);
  char *result;
  char *title;
  char *artist;
  char *album;
  char *genre;
  char *composer;
  char *tmp_if_expr$3;
  char *return_value_xmlescape$2;
  if(!(object->title == ((const char *)NULL)))
  {
    return_value_xmlescape$2=xmlescape(object->title, 0);
    tmp_if_expr$3 = return_value_xmlescape$2;
  }

  else
    tmp_if_expr$3 = (char *)(void *)0;
  title = tmp_if_expr$3;
  char *tmp_if_expr$5;
  char *return_value_xmlescape$4;
  if(!(object->artist == ((const char *)NULL)))
  {
    return_value_xmlescape$4=xmlescape(object->artist, 0);
    tmp_if_expr$5 = return_value_xmlescape$4;
  }

  else
    tmp_if_expr$5 = (char *)(void *)0;
  artist = tmp_if_expr$5;
  char *tmp_if_expr$7;
  char *return_value_xmlescape$6;
  if(!(object->album == ((const char *)NULL)))
  {
    return_value_xmlescape$6=xmlescape(object->album, 0);
    tmp_if_expr$7 = return_value_xmlescape$6;
  }

  else
    tmp_if_expr$7 = (char *)(void *)0;
  album = tmp_if_expr$7;
  char *tmp_if_expr$9;
  char *return_value_xmlescape$8;
  if(!(object->genre == ((const char *)NULL)))
  {
    return_value_xmlescape$8=xmlescape(object->genre, 0);
    tmp_if_expr$9 = return_value_xmlescape$8;
  }

  else
    tmp_if_expr$9 = (char *)(void *)0;
  genre = tmp_if_expr$9;
  char *tmp_if_expr$11;
  char *return_value_xmlescape$10;
  if(!(object->composer == ((const char *)NULL)))
  {
    return_value_xmlescape$10=xmlescape(object->composer, 0);
    tmp_if_expr$11 = return_value_xmlescape$10;
  }

  else
    tmp_if_expr$11 = (char *)(void *)0;
  composer = tmp_if_expr$11;
  _Bool tmp_if_expr$13;
  unsigned long int return_value_strlen$12;
  if(original_xml == ((const char *)NULL))
    tmp_if_expr$13 = (_Bool)1;

  else
  {
    return_value_strlen$12=strlen(original_xml);
    tmp_if_expr$13 = return_value_strlen$12 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$13)
    result=generate_DIDL(unique_id, title, artist, album, genre, composer);

  else
  {
    signed int edits = 0;
    result=strdup(original_xml);
    result=replace_range(result, "<dc:title>", "</dc:title>", title, &edits);
    result=replace_range(result, "<upnp:artist>", "</upnp:artist>", artist, &edits);
    result=replace_range(result, "<upnp:album>", "</upnp:album>", album, &edits);
    result=replace_range(result, "<upnp:genre>", "</upnp:genre>", genre, &edits);
    result=replace_range(result, "<upnp:creator>", "</upnp:creator>", composer, &edits);
    if(!(edits == 0))
      result=replace_range(result, "id=\"", "\"", unique_id, &edits);

  }
  free((void *)title);
  free((void *)artist);
  free((void *)album);
  free((void *)genre);
  free((void *)composer);
  return result;
}

// UPnPLastChangeBuilder_add
// file variable-container.c line 151
void UPnPLastChangeBuilder_add(struct upnp_last_change_builder *builder, const char *name, const char *value)
{
  /* assertion name != ((void *)0) */
  assert(name != (const char *)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  if(builder->change_event_doc == ((struct xmldoc *)NULL))
  {
    builder->change_event_doc=xmldoc_new();
    struct xmlelement *toplevel;
    toplevel=xmldoc_new_topelement(builder->change_event_doc, "Event", builder->xml_namespace);
    builder->instance_element=add_attributevalue_element(builder->change_event_doc, toplevel, "InstanceID", "val", "0");
  }

  struct xmlelement *xml_value;
  xml_value=add_attributevalue_element(builder->change_event_doc, builder->instance_element, name, "val", value);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(name, "Volume");
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(return_value_strcmp$1 == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_strcmp$2=strcmp(name, "VolumeDB");
    tmp_if_expr$3 = return_value_strcmp$2 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strcmp$4=strcmp(name, "Mute");
    tmp_if_expr$5 = return_value_strcmp$4 == 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_strcmp$6=strcmp(name, "Loudness");
    tmp_if_expr$7 = return_value_strcmp$6 == 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
    xmlelement_set_attribute(builder->change_event_doc, xml_value, "channel", "Master");

}

// UPnPLastChangeBuilder_delete
// file variable-container.c line 144
void UPnPLastChangeBuilder_delete(struct upnp_last_change_builder *builder)
{
  if(!(builder->change_event_doc == ((struct xmldoc *)NULL)))
    xmldoc_free(builder->change_event_doc);

  free((void *)builder);
}

// UPnPLastChangeBuilder_new
// file variable-container.c line 135
struct upnp_last_change_builder * UPnPLastChangeBuilder_new(const char *xml_namespace)
{
  struct upnp_last_change_builder *result;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct upnp_last_change_builder) /*24ul*/ );
  result = (struct upnp_last_change_builder *)return_value_malloc$1;
  result->xml_namespace = xml_namespace;
  result->change_event_doc = (struct xmldoc *)(void *)0;
  result->instance_element = (struct xmlelement *)(void *)0;
  return result;
}

// UPnPLastChangeBuilder_to_xml
// file variable-container.c line 186
char * UPnPLastChangeBuilder_to_xml(struct upnp_last_change_builder *builder)
{
  if(builder->change_event_doc == ((struct xmldoc *)NULL))
    return (char *)(void *)0;

  else
  {
    char *xml_doc_string;
    xml_doc_string=xmldoc_tostring(builder->change_event_doc);
    xmldoc_free(builder->change_event_doc);
    builder->change_event_doc = (struct xmldoc *)(void *)0;
    builder->instance_element = (struct xmlelement *)(void *)0;
    return xml_doc_string;
  }
}

// UPnPLastChangeCollector_add_ignore
// file variable-container.h line 120
void UPnPLastChangeCollector_add_ignore(struct upnp_last_change_collector *object, signed int variable_num)
{
  object->not_eventable_variables = object->not_eventable_variables | (unsigned int)(1 << variable_num);
}

// UPnPLastChangeCollector_callback
// file variable-container.c line 313
static void UPnPLastChangeCollector_callback(void *userdata, signed int var_num, const char *var_name, const char *old_value, const char *new_value)
{
  struct upnp_last_change_collector *object = (struct upnp_last_change_collector *)userdata;
  if((object->not_eventable_variables & (unsigned int)(1 << var_num)) == 0u)
  {
    UPnPLastChangeBuilder_add(object->builder, var_name, new_value);
    UPnPLastChangeCollector_notify(object);
  }

}

// UPnPLastChangeCollector_finish
// file variable-container.h line 127
void UPnPLastChangeCollector_finish(struct upnp_last_change_collector *object)
{
  /* assertion object->open_transactions >= 1 */
  assert(object->open_transactions >= 1);
  object->open_transactions = object->open_transactions - 1;
  UPnPLastChangeCollector_notify(object);
}

// UPnPLastChangeCollector_new
// file variable-container.h line 114
struct upnp_last_change_collector * UPnPLastChangeCollector_new(struct variable_container *variable_container, const char *event_xml_namespace, struct upnp_device *upnp_device, const char *service_id)
{
  struct upnp_last_change_collector *result;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct upnp_last_change_collector) /*48ul*/ );
  result = (struct upnp_last_change_collector *)return_value_malloc$1;
  result->variable_container = variable_container;
  result->last_change_variable_num = -1;
  result->not_eventable_variables = (unsigned int)0;
  result->upnp_device = upnp_device;
  result->service_id = service_id;
  result->open_transactions = 0;
  result->builder=UPnPLastChangeBuilder_new(event_xml_namespace);
  signed int var_count;
  var_count=VariableContainer_get_num_vars(variable_container);
  /* assertion var_count < 32 */
  assert(var_count < 32);
  signed int i = 0;
  for( ; !(i >= var_count); i = i + 1)
  {
    const char *name;
    const char *value;
    value=VariableContainer_get(variable_container, i, &name);
    if(!(value == ((const char *)NULL)))
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp("LastChange", name);
      if(return_value_strcmp$2 == 0)
        result->last_change_variable_num = i;

      else
        UPnPLastChangeBuilder_add(result->builder, name, value);
    }

  }
  /* assertion result->last_change_variable_num >= 0 */
  assert(result->last_change_variable_num >= 0);
  UPnPLastChangeCollector_add_ignore(result, result->last_change_variable_num);
  UPnPLastChangeCollector_notify(result);
  VariableContainer_register_callback(variable_container, UPnPLastChangeCollector_callback, (void *)result);
  return result;
}

// UPnPLastChangeCollector_notify
// file variable-container.c line 278
static void UPnPLastChangeCollector_notify(struct upnp_last_change_collector *obj)
{
  if(obj->open_transactions == 0)
  {
    char *xml_doc_string;
    xml_doc_string=UPnPLastChangeBuilder_to_xml(obj->builder);
    if(!(xml_doc_string == ((char *)NULL)))
    {
      signed int return_value_VariableContainer_change$1;
      return_value_VariableContainer_change$1=VariableContainer_change(obj->variable_container, obj->last_change_variable_num, xml_doc_string);
      if(!(return_value_VariableContainer_change$1 == 0))
      {
        const char *varnames[2l] = { "LastChange", (const char *)(void *)0 };
        const char *varvalues[2l] = { (const char *)(void *)0, (const char *)(void *)0 };
        varvalues[(signed long int)0]=xmlescape(xml_doc_string, 0);
        upnp_device_notify(obj->upnp_device, obj->service_id, varnames, varvalues, 1);
        free((void *)(char *)varvalues[(signed long int)0]);
      }

      free((void *)xml_doc_string);
    }

  }

}

// UPnPLastChangeCollector_start
// file variable-container.h line 126
void UPnPLastChangeCollector_start(struct upnp_last_change_collector *object)
{
  object->open_transactions = object->open_transactions + 1;
}

// VariableContainer_change
// file variable-container.h line 73
signed int VariableContainer_change(struct variable_container *object, signed int var_num, const char *value)
{
  _Bool tmp_if_expr$1;
  if(var_num >= 0)
    tmp_if_expr$1 = var_num < object->variable_num ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion var_num >= 0 && var_num < object->variable_num */
  assert(tmp_if_expr$1);
  if(value == ((const char *)NULL))
    value = "";

  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(value, object->values[(signed long int)var_num]);
  if(return_value_strcmp$2 == 0)
    return 0;

  else
  {
    char *old_value = object->values[(signed long int)var_num];
    char *new_value;
    new_value=strdup(value);
    object->values[(signed long int)var_num] = new_value;
    struct cb_list *it = object->callbacks;
    if(!(it == ((struct cb_list *)NULL)))
    {
      it->callback(it->userdata, var_num, object->variable_names[(signed long int)var_num], old_value, new_value);
      it = it->next;
    }

    free((void *)old_value);
    return 1;
  }
}

// VariableContainer_delete
// file variable-container.c line 69
void VariableContainer_delete(struct variable_container *object)
{
  signed int i = 0;
  for( ; !(i >= object->variable_num); i = i + 1)
    free((void *)object->values[(signed long int)i]);
  free((void *)object->values);
  struct cb_list *list = object->callbacks;
  while(!(list == ((struct cb_list *)NULL)))
  {
    struct cb_list *next = list->next;
    free((void *)list);
    list = next;
  }
  free((void *)object);
}

// VariableContainer_get
// file variable-container.h line 67
const char * VariableContainer_get(struct variable_container *object, signed int var, const char **name)
{
  _Bool tmp_if_expr$1;
  if(!(var >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = var >= object->variable_num ? (_Bool)1 : (_Bool)0;
  char *tmp_if_expr$2;
  if(tmp_if_expr$1)
    return (const char *)(void *)0;

  else
  {
    const char *varname = object->variable_names[(signed long int)var];
    if(!(name == ((const char **)NULL)))
      *name = varname;

    if(!(varname == ((const char *)NULL)))
      tmp_if_expr$2 = object->values[(signed long int)var];

    else
      tmp_if_expr$2 = (char *)(void *)0;
    return tmp_if_expr$2;
  }
}

// VariableContainer_get_num_vars
// file variable-container.c line 84
signed int VariableContainer_get_num_vars(struct variable_container *object)
{
  return object->variable_num;
}

// VariableContainer_new
// file variable-container.h line 54
struct variable_container * VariableContainer_new(signed int variable_num, const char **variable_names, const char **variable_init_values)
{
  /* assertion variable_num > 0 */
  assert(variable_num > 0);
  struct variable_container *result;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct variable_container) /*32ul*/ );
  result = (struct variable_container *)return_value_malloc$1;
  result->variable_num = variable_num;
  result->variable_names = variable_names;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)variable_num * sizeof(char *) /*8ul*/ );
  result->values = (char **)return_value_malloc$2;
  result->callbacks = (struct cb_list *)(void *)0;
  signed int i = 0;
  const char *tmp_if_expr$3;
  for( ; !(i >= variable_num); i = i + 1)
  {
    if(!(variable_init_values[(signed long int)i] == ((const char *)NULL)))
      tmp_if_expr$3 = variable_init_values[(signed long int)i];

    else
      tmp_if_expr$3 = "";
    result->values[(signed long int)i]=strdup(tmp_if_expr$3);
  }
  return result;
}

// VariableContainer_register_callback
// file variable-container.h line 83
void VariableContainer_register_callback(struct variable_container *object, void (*callback)(void *, signed int, const char *, const char *, const char *), void *userdata)
{
  struct cb_list *item;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct cb_list) /*24ul*/ );
  item = (struct cb_list *)return_value_malloc$1;
  item->next = object->callbacks;
  item->userdata = userdata;
  item->callback = callback;
  object->callbacks = item;
}

// add_attributevalue_element
// file xmldoc.h line 67
struct xmlelement * add_attributevalue_element(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, const char *attribute_name, const char *value)
{
  struct xmlelement *top;
  top=xmlelement_new(doc, tagname);
  xmlelement_set_attribute(doc, top, attribute_name, value);
  xmlelement_add_element(doc, parent, top);
  return top;
}

// add_value_element
// file xmldoc.h line 53
void add_value_element(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, const char *value)
{
  struct xmlelement *top;
  top=xmlelement_new(doc, tagname);
  xmlelement_add_text(doc, top, value);
  xmlelement_add_element(doc, parent, top);
}

// add_value_element_int
// file xmldoc.h line 73
void add_value_element_int(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, signed int value)
{
  char *buf;
  signed int return_value_asprintf$1;
  return_value_asprintf$1=asprintf(&buf, "%d", value);
  if(return_value_asprintf$1 >= 0)
  {
    add_value_element(doc, parent, tagname, buf);
    free((void *)buf);
  }

}

// add_value_element_long
// file xmldoc.h line 76
void add_value_element_long(struct xmldoc *doc, struct xmlelement *parent, const char *tagname, signed long long int value)
{
  char *buf;
  signed int return_value_asprintf$1;
  return_value_asprintf$1=asprintf(&buf, "%lld", value);
  if(return_value_asprintf$1 >= 0)
  {
    add_value_element(doc, parent, tagname, buf);
    free((void *)buf);
  }

}

// change_transport_state
// file upnp_transport.c line 598
static void change_transport_state(enum transport_state new_state)
{
  transport_state_ = new_state;
  /* assertion new_state >= TRANSPORT_STOPPED && new_state < TRANSPORT_NO_MEDIA_PRESENT */
  assert((signed int)new_state >= TRANSPORT_STOPPED && (signed int)new_state < TRANSPORT_NO_MEDIA_PRESENT);
  signed int return_value_replace_var$1;
  return_value_replace_var$1=replace_var$link1((enum anonymous$31)TRANSPORT_VAR_TRANSPORT_STATE, transport_states[(signed long int)new_state]);
  const char *return_value_get_var$2;
  unsigned long int return_value_strlen$3;
  if(!(return_value_replace_var$1 == 0))
  {
    const char *available_actions = (const char *)(void *)0;
    switch((signed int)new_state)
    {
      case TRANSPORT_STOPPED:
      {
        return_value_get_var$2=get_var((enum anonymous$31)TRANSPORT_VAR_AV_URI);
        return_value_strlen$3=strlen(return_value_get_var$2);
        if(return_value_strlen$3 == 0ul)
          available_actions = "PLAY";

        else
          available_actions = "PLAY,SEEK";
        goto __CPROVER_DUMP_L7;
      }
      case TRANSPORT_PLAYING:
      {
        available_actions = "PAUSE,STOP,SEEK";
        goto __CPROVER_DUMP_L7;
      }
      case TRANSPORT_PAUSED_PLAYBACK:
      {
        available_actions = "PLAY,STOP,SEEK";
        goto __CPROVER_DUMP_L7;
      }
      case TRANSPORT_TRANSITIONING:

      case TRANSPORT_PAUSED_RECORDING:

      case TRANSPORT_RECORDING:

      case TRANSPORT_NO_MEDIA_PRESENT:
        ;
      default:
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(available_actions == ((const char *)NULL)))
          replace_var$link1((enum anonymous$31)TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS, available_actions);

      }
    }
  }

}

// change_volume
// file upnp_control.c line 509
static void change_volume(const char *volume, const char *db_volume)
{
  replace_var((enum anonymous$19)CONTROL_VAR_VOLUME, volume);
  replace_var((enum anonymous$19)CONTROL_VAR_VOLUME_DB, db_volume);
}

// change_volume_decibel
// file upnp_control.c line 665
static float change_volume_decibel(float raw_decibel)
{
  signed int volume_level;
  volume_level=volume_decibel_to_level(raw_decibel);
  float decibel;
  decibel=volume_level_to_decibel(volume_level);
  char volume[10l];
  snprintf(volume, sizeof(char [10l]) /*10ul*/ , "%d", volume_level);
  char db_volume[10l];
  snprintf(db_volume, sizeof(char [10l]) /*10ul*/ , "%d", (signed int)((float)256 * decibel));
  Log_info("control", "Setting volume-db to %.2fdb == #%d", decibel, volume_level);
  change_volume(volume, db_volume);
  return decibel;
}

// cmd_obtain_variable
// file upnp_control.c line 514
static signed int cmd_obtain_variable(struct action_event *event, enum anonymous$19 varnum, const char *paramname)
{
  char *instance;
  instance=upnp_get_string(event, "InstanceID");
  if(instance == ((char *)NULL))
    return -1;

  else
  {
    Log_info("control", "%s: %s for instance %s\n", (const void *)"cmd_obtain_variable", paramname, instance);
    free((void *)instance);
    upnp_append_variable(event, (signed int)varnum, paramname);
    return 0;
  }
}

// connmgr_init
// file upnp_connmgr.c line 252
signed int connmgr_init(void)
{
  struct mime_type *entry;
  char *buf = (char *)(void *)0;
  char *p;
  signed int offset;
  signed int bufsize = 0;
  struct service *srv;
  srv=upnp_connmgr_get_service();
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)bufsize);
  buf = (char *)return_value_malloc$1;
  p = buf;
  /* assertion buf */
  assert(buf != ((char *)NULL));
  if(buf == ((char *)NULL))
  {
    fprintf(stderr, "%s: initial malloc failed\n", (const void *)"connmgr_init");
    return -1;
  }

  else
  {
    entry = supported_types;
    for( ; !(entry == ((struct mime_type *)NULL)); entry = entry->next)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(entry->mime_type);
      bufsize = bufsize + (signed int)(return_value_strlen$2 + (unsigned long int)1 + (unsigned long int)8 + (unsigned long int)3 + (unsigned long int)2);
      offset = (signed int)(p - buf);
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)buf, (unsigned long int)bufsize);
      buf = (char *)return_value_realloc$3;
      if(buf == ((char *)NULL))
      {
        fprintf(stderr, "%s: realloc failed\n", (const void *)"connmgr_init");
        return -1;
      }

      p = buf;
      p = p + (signed long int)offset;
      strncpy(p, "http-get:*:", (unsigned long int)11);
      p = p + (signed long int)11;
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(entry->mime_type);
      strncpy(p, entry->mime_type, return_value_strlen$4);
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(entry->mime_type);
      p = p + (signed long int)return_value_strlen$5;
      strncpy(p, ":*,", (unsigned long int)3);
      p = p + (signed long int)3;
    }
    if(!(buf >= p))
    {
      p = p - 1l;
      *p = (char)0;
    }

    *p = (char)0;
    VariableContainer_change(srv->variable_container, 1, buf);
    free((void *)buf);
    return 0;
  }
}

// divide_leave_remainder
// file upnp_transport.c line 753
static signed int divide_leave_remainder(signed long int *val, signed long int divisor)
{
  signed int result = (signed int)(*val / divisor);
  *val = *val % divisor;
  return result;
}

// do_show_version
// file main.c line 121
static void do_show_version(void)
{
  puts("gmediarender 0.0.7-git; 0.0.7-git\nThis is free software. You may redistribute copies of it under the terms of\nthe GNU General Public License <http://www.gnu.org/licenses/gpl.html>.\nThere is NO WARRANTY, to the extent permitted by law.");
}

// error
// file /usr/include/x86_64-linux-gnu/bits/error.h line 37
static inline void error(signed int __status, signed int __errnum, const char *__format, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  void *return_value___builtin_va_arg_pack$2;
  return_value___builtin_va_arg_pack$2=__builtin_va_arg_pack();
  __error_alias(__status, __errnum, __format, return_value___builtin_va_arg_pack$2);
}

// event_handler
// file upnp_device.c line 383
static signed int event_handler(enum Upnp_EventType_e EventType, void *event, void *userdata)
{
  struct upnp_device *priv = (struct upnp_device *)userdata;
  switch((signed int)EventType)
  {
    case UPNP_CONTROL_ACTION_REQUEST:
    {
      handle_action_request(priv, (struct Upnp_Action_Request *)event);
      break;
    }
    case UPNP_CONTROL_GET_VAR_REQUEST:
    {
      handle_var_request(priv, (struct Upnp_State_Var_Request *)event);
      break;
    }
    case UPNP_EVENT_SUBSCRIPTION_REQUEST:
    {
      handle_subscription_request(priv, (struct Upnp_Subscription_Request *)event);
      break;
    }
    default:
      Log_error("upnp", "Unknown event type: %d", EventType);
  }
  return 0;
}

// exit_loop_sighandler
// file output.c line 111
static void exit_loop_sighandler(signed int sig)
{
  if(!(main_loop_ == ((struct _GMainLoop *)NULL)))
    g_main_loop_quit(main_loop_);

}

// find_action
// file upnp.c line 196
struct action * find_action(struct service *event_service, char *action_name)
{
  struct action *event_action;
  signed int actionNum = 0;
  if(event_service == ((struct service *)NULL))
    return (struct action *)(void *)0;

  else
  {
    do
    {
      event_action = &event_service->actions[(signed long int)actionNum];
      if(event_action->action_name == ((const char *)NULL))
        break;

      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(event_action->action_name, action_name);
      if(return_value_strcmp$1 == 0)
        return event_action;

      actionNum = actionNum + 1;
    }
    while((_Bool)1);
    return (struct action *)(void *)0;
  }
}

// find_element
// file xmldoc.c line 105
static struct xmlelement * find_element(struct _IXML_Node *node, const char *key)
{
  node=ixmlNode_getFirstChild(node);
  while(!(node == ((struct _IXML_Node *)NULL)))
  {
    const char *return_value_ixmlNode_getNodeName$1;
    return_value_ixmlNode_getNodeName$1=ixmlNode_getNodeName(node);
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(return_value_ixmlNode_getNodeName$1, key);
    if(return_value_strcmp$2 == 0)
      return (struct xmlelement *)node;

    node=ixmlNode_getNextSibling(node);
  }
  return (struct xmlelement *)(void *)0;
}

// find_element_in_doc
// file xmldoc.h line 58
struct xmlelement * find_element_in_doc(struct xmldoc *doc, const char *key)
{
  struct _IXML_Document *return_value_to_idoc$1;
  return_value_to_idoc$1=to_idoc(doc);
  struct xmlelement *return_value_find_element$2;
  return_value_find_element$2=find_element((struct _IXML_Node *)return_value_to_idoc$1, key);
  return return_value_find_element$2;
}

// find_element_in_element
// file xmldoc.h line 61
struct xmlelement * find_element_in_element(struct xmlelement *element, const char *key)
{
  struct _IXML_Element *return_value_to_ielem$1;
  return_value_to_ielem$1=to_ielem(element);
  struct xmlelement *return_value_find_element$2;
  return_value_find_element$2=find_element((struct _IXML_Node *)return_value_to_ielem$1, key);
  return return_value_find_element$2;
}

// find_service
// file upnp_device.c line 510
struct service * find_service(struct upnp_device_descriptor *device_def, const char *service_id)
{
  struct service *event_service;
  signed int serviceNum = 0;
  /* assertion device_def != ((void *)0) */
  assert(device_def != (struct upnp_device_descriptor *)(void *)0);
  /* assertion service_id != ((void *)0) */
  assert(service_id != (const char *)(void *)0);
  do
  {
    event_service = device_def->services[(signed long int)serviceNum];
    if(event_service == ((struct service *)NULL))
      break;

    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(event_service->service_id, service_id);
    if(return_value_strcmp$1 == 0)
      return event_service;

    serviceNum = serviceNum + 1;
  }
  while((_Bool)1);
  return (struct service *)(void *)0;
}

// gen_desc_iconlist
// file upnp_device.c line 544
static struct xmlelement * gen_desc_iconlist(struct xmldoc *doc, struct icon **icons)
{
  struct xmlelement *top;
  struct xmlelement *parent;
  struct icon *icon_entry;
  top=xmlelement_new(doc, "iconList");
  signed int i = 0;
  do
  {
    icon_entry = icons[(signed long int)i];
    if(icon_entry == ((struct icon *)NULL))
      break;

    parent=xmlelement_new(doc, "icon");
    add_value_element(doc, parent, "mimetype", icon_entry->mimetype);
    add_value_element_int(doc, parent, "width", icon_entry->width);
    add_value_element_int(doc, parent, "height", icon_entry->height);
    add_value_element_int(doc, parent, "depth", icon_entry->depth);
    add_value_element(doc, parent, "url", icon_entry->url);
    xmlelement_add_element(doc, top, parent);
    i = i + 1;
  }
  while((_Bool)1);
  return top;
}

// gen_desc_servicelist
// file upnp_device.c line 567
static struct xmlelement * gen_desc_servicelist(struct upnp_device_descriptor *device_def, struct xmldoc *doc)
{
  signed int i;
  struct service *srv;
  struct xmlelement *top;
  struct xmlelement *parent;
  top=xmlelement_new(doc, "serviceList");
  i = 0;
  do
  {
    srv = device_def->services[(signed long int)i];
    if(srv == ((struct service *)NULL))
      break;

    parent=xmlelement_new(doc, "service");
    add_value_element(doc, parent, "serviceType", srv->service_type);
    add_value_element(doc, parent, "serviceId", srv->service_id);
    add_value_element(doc, parent, "SCPDURL", srv->scpd_url);
    add_value_element(doc, parent, "controlURL", srv->control_url);
    add_value_element(doc, parent, "eventSubURL", srv->event_url);
    xmlelement_add_element(doc, top, parent);
    i = i + 1;
  }
  while((_Bool)1);
  return top;
}

// gen_scpd_action
// file upnp.c line 64
static struct xmlelement * gen_scpd_action(struct xmldoc *doc, struct action *act, struct argument **arglist, const char **varnames)
{
  struct xmlelement *top;
  struct xmlelement *parent;
  struct xmlelement *child;
  top=xmlelement_new(doc, "action");
  add_value_element(doc, top, "name", act->action_name);
  if(!(arglist == ((struct argument **)NULL)))
  {
    struct argument *arg;
    signed int j;
    parent=xmlelement_new(doc, "argumentList");
    xmlelement_add_element(doc, top, parent);
    j = 0;
    do
    {
      arg = arglist[(signed long int)j];
      if(arg == ((struct argument *)NULL))
        break;

      child=xmlelement_new(doc, "argument");
      add_value_element(doc, child, "name", arg->name);
      add_value_element(doc, child, "direction", (signed int)arg->direction == PARAM_DIR_IN ? "in" : "out");
      add_value_element(doc, child, "relatedStateVariable", varnames[(signed long int)arg->statevar]);
      xmlelement_add_element(doc, parent, child);
      j = j + 1;
    }
    while((_Bool)1);
  }

  return top;
}

// gen_scpd_actionlist
// file upnp.c line 94
static struct xmlelement * gen_scpd_actionlist(struct xmldoc *doc, struct service *srv)
{
  struct xmlelement *top;
  struct xmlelement *child;
  signed int i;
  top=xmlelement_new(doc, "actionList");
  i = 0;
  for( ; !(i >= srv->command_count); i = i + 1)
  {
    struct action *act;
    struct argument **arglist;
    const char **varnames;
    act = &srv->actions[(signed long int)i];
    arglist = srv->action_arguments[(signed long int)i];
    varnames = srv->variable_names;
    if(!(act == ((struct action *)NULL)))
    {
      child=gen_scpd_action(doc, act, arglist, varnames);
      xmlelement_add_element(doc, top, child);
    }

  }
  return top;
}

// gen_scpd_servicestatetable
// file upnp.c line 159
static struct xmlelement * gen_scpd_servicestatetable(struct xmldoc *doc, struct service *srv)
{
  struct xmlelement *top;
  struct xmlelement *child;
  signed int i;
  top=xmlelement_new(doc, "serviceStateTable");
  i = 0;
  for( ; !(i >= srv->variable_count); i = i + 1)
  {
    struct var_meta *meta = &srv->variable_meta[(signed long int)i];
    const char *name = srv->variable_names[(signed long int)i];
    child=gen_scpd_statevar(doc, name, meta);
    xmlelement_add_element(doc, top, child);
  }
  return top;
}

// gen_scpd_statevar
// file upnp.c line 117
static struct xmlelement * gen_scpd_statevar(struct xmldoc *doc, const char *name, struct var_meta *meta)
{
  struct xmlelement *top;
  struct xmlelement *parent;
  const char **valuelist;
  const char *default_value;
  struct param_range *range;
  valuelist = meta->allowed_values;
  range = meta->allowed_range;
  default_value = meta->default_value;
  top=xmlelement_new(doc, "stateVariable");
  xmlelement_set_attribute(doc, top, "sendEvents", (signed int)meta->sendevents == SENDEVENT_YES ? "yes" : "no");
  add_value_element(doc, top, "name", name);
  add_value_element(doc, top, "dataType", param_datatype_names[(signed long int)meta->datatype]);
  if(!(valuelist == ((const char **)NULL)))
  {
    const char *allowed_value;
    signed int i;
    parent=xmlelement_new(doc, "allowedValueList");
    xmlelement_add_element(doc, top, parent);
    i = 0;
    do
    {
      allowed_value = valuelist[(signed long int)i];
      if(allowed_value == ((const char *)NULL))
        break;

      add_value_element(doc, parent, "allowedValue", allowed_value);
      i = i + 1;
    }
    while((_Bool)1);
  }

  if(!(range == ((struct param_range *)NULL)))
  {
    parent=xmlelement_new(doc, "allowedValueRange");
    xmlelement_add_element(doc, top, parent);
    add_value_element_long(doc, parent, "minimum", range->min);
    add_value_element_long(doc, parent, "maximum", range->max);
    if(!(range->step == 0L))
      add_value_element_long(doc, parent, "step", range->step);

  }

  if(!(default_value == ((const char *)NULL)))
    add_value_element(doc, top, "defaultValue", default_value);

  return top;
}

// gen_specversion
// file upnp.c line 51
static struct xmlelement * gen_specversion(struct xmldoc *doc, signed int major, signed int minor)
{
  struct xmlelement *top;
  top=xmlelement_new(doc, "specVersion");
  add_value_element_int(doc, top, "major", major);
  add_value_element_int(doc, top, "minor", minor);
  return top;
}

// gen_specversion$link1
// file upnp_device.c line 530
static struct xmlelement * gen_specversion$link1(struct xmldoc *doc$link1, signed int major$link1, signed int minor$link1)
{
  struct xmlelement *top$link1;
  top$link1=xmlelement_new(doc$link1, "specVersion");
  add_value_element_int(doc$link1, top$link1, "major", major$link1);
  add_value_element_int(doc$link1, top$link1, "minor", minor$link1);
  return top$link1;
}

// generate_DIDL
// file song-meta-data.c line 59
static char * generate_DIDL(const char *id, const char *title, const char *artist, const char *album, const char *genre, const char *composer)
{
  char *result = (char *)(void *)0;
  signed int ret;
  ret=asprintf(&result, "%s\n<item id=\"%s\">\n\t<dc:title>%s</dc:title>\n\t<upnp:artist>%s</upnp:artist>\n\t<upnp:album>%s</upnp:album>\n\t<upnp:genre>%s</upnp:genre>\n\t<upnp:creator>%s</upnp:creator>\n</item>\n%s", (const void *)kDidlHeader, id, title != ((const char *)NULL) ? title : "", artist != ((const char *)NULL) ? artist : "", album != ((const char *)NULL) ? album : "", genre != ((const char *)NULL) ? genre : "", composer != ((const char *)NULL) ? composer : "", (const void *)kDidlFooter);
  return ret >= 0 ? result : (char *)(void *)0;
}

// generate_desc
// file upnp_device.c line 592
static struct xmldoc * generate_desc(struct upnp_device_descriptor *device_def)
{
  struct xmldoc *doc;
  struct xmlelement *root;
  struct xmlelement *child;
  struct xmlelement *parent;
  doc=xmldoc_new();
  root=xmldoc_new_topelement(doc, "root", "urn:schemas-upnp-org:device-1-0");
  child=gen_specversion$link1(doc, 1, 0);
  xmlelement_add_element(doc, root, child);
  parent=xmlelement_new(doc, "device");
  xmlelement_add_element(doc, root, parent);
  add_value_element(doc, parent, "deviceType", device_def->device_type);
  add_value_element(doc, parent, "presentationURL", device_def->presentation_url);
  add_value_element(doc, parent, "friendlyName", device_def->friendly_name);
  add_value_element(doc, parent, "manufacturer", device_def->manufacturer);
  add_value_element(doc, parent, "manufacturerURL", device_def->manufacturer_url);
  add_value_element(doc, parent, "modelDescription", device_def->model_description);
  add_value_element(doc, parent, "modelName", device_def->model_name);
  add_value_element(doc, parent, "modelNumber", device_def->model_number);
  add_value_element(doc, parent, "modelURL", device_def->model_url);
  add_value_element(doc, parent, "UDN", device_def->udn);
  if(!(device_def->icons == ((struct icon **)NULL)))
  {
    child=gen_desc_iconlist(doc, device_def->icons);
    xmlelement_add_element(doc, parent, child);
  }

  child=gen_desc_servicelist(device_def, doc);
  xmlelement_add_element(doc, parent, child);
  return doc;
}

// generate_scpd
// file upnp.c line 175
static struct xmldoc * generate_scpd(struct service *srv)
{
  struct xmldoc *doc;
  struct xmlelement *root;
  struct xmlelement *child;
  doc=xmldoc_new();
  root=xmldoc_new_topelement(doc, "scpd", "urn:schemas-upnp-org:service-1-0");
  child=gen_specversion(doc, 1, 0);
  xmlelement_add_element(doc, root, child);
  child=gen_scpd_actionlist(doc, srv);
  xmlelement_add_element(doc, root, child);
  child=gen_scpd_servicestatetable(doc, srv);
  xmlelement_add_element(doc, root, child);
  return doc;
}

// get_blue_videoblacklevel
// file upnp_control.c line 584
static signed int get_blue_videoblacklevel(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_B_BLACK, "CurrentBlueVideoBlackLevel");
  return return_value_cmd_obtain_variable$1;
}

// get_blue_videogain
// file upnp_control.c line 566
static signed int get_blue_videogain(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_B_GAIN, "CurrentBlueVideoGain");
  return return_value_cmd_obtain_variable$1;
}

// get_brightness
// file upnp_control.c line 536
static signed int get_brightness(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_BRIGHTNESS, "CurrentBrightness");
  return return_value_cmd_obtain_variable$1;
}

// get_colortemperature
// file upnp_control.c line 590
static signed int get_colortemperature(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_COLOR_TEMP, "CurrentColorTemperature");
  return return_value_cmd_obtain_variable$1;
}

// get_contrast
// file upnp_control.c line 542
static signed int get_contrast(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_CONTRAST, "CurrentContrast");
  return return_value_cmd_obtain_variable$1;
}

// get_current_conn_ids
// file upnp_connmgr.c line 309
static signed int get_current_conn_ids(struct action_event *event)
{
  signed int rc = -1;
  upnp_add_response(event, "ConnectionIDs", "0");
  return rc;
}

// get_current_conn_info
// file upnp_connmgr.c line 325
static signed int get_current_conn_info(struct action_event *event)
{
  char *value;
  value=upnp_get_string(event, "ConnectionID");
  if(value == ((char *)NULL))
    return -1;

  else
  {
    Log_info("connmgr", "Query ConnectionID='%s'", value);
    free((void *)value);
    upnp_append_variable(event, 5, "RcsID");
    upnp_append_variable(event, 3, "AVTransportID");
    upnp_append_variable(event, 6, "ProtocolInfo");
    upnp_append_variable(event, 0, "PeerConnectionManager");
    upnp_append_variable(event, 7, "PeerConnectionID");
    upnp_append_variable(event, 4, "Direction");
    upnp_append_variable(event, 2, "Status");
    return 0;
  }
}

// get_current_player_state
// file output_gstreamer.c line 161
static enum anonymous$21 get_current_player_state()
{
  enum anonymous$21 state = (enum anonymous$21)GST_STATE_PLAYING;
  enum anonymous$21 pending = (enum anonymous$21)GST_STATE_NULL;
  gst_element_get_state(player_, &state, &pending, (unsigned long int)0);
  return state;
}

// get_current_transportactions
// file upnp_transport.c line 732
static signed int get_current_transportactions(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    upnp_append_variable(event, TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS, "Actions");
    return 0;
  }
}

// get_device_caps
// file upnp_transport.c line 823
static signed int get_device_caps(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
    return 0;
}

// get_green_videoblacklevel
// file upnp_control.c line 578
static signed int get_green_videoblacklevel(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_G_BLACK, "CurrentGreenVideoBlackLevel");
  return return_value_cmd_obtain_variable$1;
}

// get_green_videogain
// file upnp_control.c line 560
static signed int get_green_videogain(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_G_GAIN, "CurrentGreenVideoGain");
  return return_value_cmd_obtain_variable$1;
}

// get_horizontal_keystone
// file upnp_control.c line 596
static signed int get_horizontal_keystone(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_HOR_KEYSTONE, "CurrentHorizontalKeystone");
  return return_value_cmd_obtain_variable$1;
}

// get_loudness
// file upnp_control.c line 732
static signed int get_loudness(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_LOUDNESS, "CurrentLoudness");
  return return_value_cmd_obtain_variable$1;
}

// get_media_info
// file upnp_transport.c line 539
static signed int get_media_info(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    upnp_append_variable(event, TRANSPORT_VAR_NR_TRACKS, "NrTracks");
    upnp_append_variable(event, TRANSPORT_VAR_CUR_MEDIA_DUR, "MediaDuration");
    upnp_append_variable(event, TRANSPORT_VAR_AV_URI, "CurrentURI");
    upnp_append_variable(event, TRANSPORT_VAR_AV_URI_META, "CurrentURIMetaData");
    upnp_append_variable(event, TRANSPORT_VAR_NEXT_AV_URI, "NextURI");
    upnp_append_variable(event, TRANSPORT_VAR_NEXT_AV_URI_META, "NextURIMetaData");
    upnp_append_variable(event, TRANSPORT_VAR_REC_MEDIA, "PlayMedium");
    upnp_append_variable(event, TRANSPORT_VAR_REC_MEDIUM, "RecordMedium");
    upnp_append_variable(event, TRANSPORT_VAR_REC_MEDIUM_WR_STATUS, "WriteStatus");
    return 0;
  }
}

// get_mute
// file upnp_control.c line 608
static signed int get_mute(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_MUTE, "CurrentMute");
  return return_value_cmd_obtain_variable$1;
}

// get_node_value
// file xmldoc.h line 65
char * get_node_value(struct xmlelement *element)
{
  struct _IXML_Node *node;
  struct _IXML_Element *return_value_to_ielem$1;
  return_value_to_ielem$1=to_ielem(element);
  node = (struct _IXML_Node *)return_value_to_ielem$1;
  node=ixmlNode_getFirstChild(node);
  const char *node_value;
  const char *tmp_if_expr$3;
  const char *return_value_ixmlNode_getNodeValue$2;
  if(!(node == ((struct _IXML_Node *)NULL)))
  {
    return_value_ixmlNode_getNodeValue$2=ixmlNode_getNodeValue(node);
    tmp_if_expr$3 = return_value_ixmlNode_getNodeValue$2;
  }

  else
    tmp_if_expr$3 = (const char *)(void *)0;
  node_value = tmp_if_expr$3;
  char *return_value_strdup$4;
  return_value_strdup$4=strdup(node_value != (const char *)(void *)0 ? node_value : "");
  return return_value_strdup$4;
}

// get_position_info
// file upnp_transport.c line 803
static signed int get_position_info(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    upnp_append_variable(event, TRANSPORT_VAR_CUR_TRACK, "Track");
    upnp_append_variable(event, TRANSPORT_VAR_CUR_TRACK_DUR, "TrackDuration");
    upnp_append_variable(event, TRANSPORT_VAR_CUR_TRACK_META, "TrackMetaData");
    upnp_append_variable(event, TRANSPORT_VAR_CUR_TRACK_URI, "TrackURI");
    upnp_append_variable(event, TRANSPORT_VAR_REL_TIME_POS, "RelTime");
    upnp_append_variable(event, TRANSPORT_VAR_ABS_TIME_POS, "AbsTime");
    upnp_append_variable(event, TRANSPORT_VAR_REL_CTR_POS, "RelCount");
    upnp_append_variable(event, TRANSPORT_VAR_ABS_CTR_POS, "AbsCount");
    return 0;
  }
}

// get_protocol_info
// file upnp_connmgr.c line 302
static signed int get_protocol_info(struct action_event *event)
{
  upnp_append_variable(event, 8, "Source");
  upnp_append_variable(event, 1, "Sink");
  return event->status;
}

// get_red_videoblacklevel
// file upnp_control.c line 572
static signed int get_red_videoblacklevel(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_R_BLACK, "CurrentRedVideoBlackLevel");
  return return_value_cmd_obtain_variable$1;
}

// get_red_videogain
// file upnp_control.c line 554
static signed int get_red_videogain(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_R_GAIN, "CurrentRedVideoGain");
  return return_value_cmd_obtain_variable$1;
}

// get_sharpness
// file upnp_control.c line 548
static signed int get_sharpness(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_SHARPNESS, "CurrentSharpness");
  return return_value_cmd_obtain_variable$1;
}

// get_transport_info
// file upnp_transport.c line 717
static signed int get_transport_info(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    upnp_append_variable(event, TRANSPORT_VAR_TRANSPORT_STATE, "CurrentTransportState");
    upnp_append_variable(event, TRANSPORT_VAR_TRANSPORT_STATUS, "CurrentTransportStatus");
    upnp_append_variable(event, TRANSPORT_VAR_TRANSPORT_PLAY_SPEED, "CurrentSpeed");
    return 0;
  }
}

// get_transport_settings
// file upnp_transport.c line 743
static signed int get_transport_settings(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
    return 0;
}

// get_var
// file upnp_transport.c line 566
static const char * get_var(enum anonymous$31 varnum)
{
  const char *return_value_VariableContainer_get$1;
  return_value_VariableContainer_get$1=VariableContainer_get(state_variables_$link1, (signed int)varnum, (const char **)(void *)0);
  return return_value_VariableContainer_get$1;
}

// get_vertical_keystone
// file upnp_control.c line 602
static signed int get_vertical_keystone(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_VER_KEYSTONE, "CurrentVerticalKeystone");
  return return_value_cmd_obtain_variable$1;
}

// get_volume
// file upnp_control.c line 629
static signed int get_volume(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_VOLUME, "CurrentVolume");
  return return_value_cmd_obtain_variable$1;
}

// get_volume_db
// file upnp_control.c line 716
static signed int get_volume_db(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_VOLUME_DB, "CurrentVolumeDB");
  return return_value_cmd_obtain_variable$1;
}

// get_volume_dbrange
// file upnp_control.c line 723
static signed int get_volume_dbrange(struct action_event *event)
{
  char minval[16l];
  snprintf(minval, sizeof(char [16l]) /*16ul*/ , "%lld", volume_db_range.min);
  upnp_add_response(event, "MinValue", minval);
  upnp_add_response(event, "MaxValue", "0");
  return 0;
}

// gst_tag_list_unref
// file /usr/include/gstreamer-1.0/gst/gsttaglist.h line 413
static inline void gst_tag_list_unref(struct _GstTagList *taglist)
{
  gst_mini_object_unref((struct _GstMiniObject *)taglist);
}

// handle_action_request
// file upnp_device.c line 277
static signed int handle_action_request(struct upnp_device *priv, struct Upnp_Action_Request *ar_event)
{
  struct service *event_service;
  struct action *event_action;
  event_service=find_service(priv->upnp_device_descriptor, ar_event->ServiceID);
  event_action=find_action(event_service, ar_event->ActionName);
  if(event_action == ((struct action *)NULL))
  {
    Log_error("upnp", "Unknown action '%s' for service '%s'", (const void *)ar_event->ActionName, (const void *)ar_event->ServiceID);
    ar_event->ActionResult = (struct _IXML_Document *)(void *)0;
    ar_event->ErrCode = 401;
    return -1;
  }

  else
  {
    if(!(event_service->last_change == ((struct upnp_last_change_collector *)NULL)))
    {
      pthread_mutex_lock(event_service->service_mutex);
      UPnPLastChangeCollector_start(event_service->last_change);
      pthread_mutex_unlock(event_service->service_mutex);
    }

    if(!(event_action->callback == ((signed int (*)(struct action_event *))NULL)))
    {
      struct action_event event;
      signed int rc;
      event.request = ar_event;
      event.status = 0;
      event.service = event_service;
      event.device = priv;
      rc=event_action->callback(&event);
      if(rc == 0)
        ar_event->ErrCode = 0;

      if(ar_event->ActionResult == ((struct _IXML_Document *)NULL))
        ar_event->ActionResult=UpnpMakeActionResponse(ar_event->ActionName, event_service->service_type, 0, (const char *)(void *)0);

    }

    else
    {
      Log_error("upnp", "Got a valid action, but no handler defined (!)\n  ErrCode:    %d\n  Socket:     %d\n  ErrStr:     '%s'\n  ActionName: '%s'\n  DevUDN:     '%s'\n  ServiceID:  '%s'\n", ar_event->ErrCode, ar_event->Socket, (const void *)ar_event->ErrStr, (const void *)ar_event->ActionName, (const void *)ar_event->DevUDN, (const void *)ar_event->ServiceID);
      ar_event->ErrCode = 0;
    }
    if(!(event_service->last_change == ((struct upnp_last_change_collector *)NULL)))
    {
      pthread_mutex_lock(event_service->service_mutex);
      UPnPLastChangeCollector_finish(event_service->last_change);
      pthread_mutex_unlock(event_service->service_mutex);
    }

    return 0;
  }
}

// handle_subscription_request
// file upnp_device.c line 155
static signed int handle_subscription_request(struct upnp_device *priv, struct Upnp_Subscription_Request *sr_event)
{
  struct service *srv;
  signed int rc;
  /* assertion priv != ((void *)0) */
  assert(priv != (struct upnp_device *)(void *)0);
  Log_info("upnp", "Subscription request for %s (%s)", sr_event->ServiceId, sr_event->UDN);
  srv=find_service(priv->upnp_device_descriptor, sr_event->ServiceId);
  signed int return_value_strcmp$3;
  unsigned long int return_value_strlen$1;
  signed int return_value_strncmp$2;
  if(srv == ((struct service *)NULL))
  {
    Log_error("upnp", "%s: Unknown service '%s'", (const void *)"handle_subscription_request", sr_event->ServiceId);
    return -1;
  }

  else
  {
    signed int result = -1;
    pthread_mutex_lock(&priv->device_mutex);
    const char *eventvar_names[2l] = { "LastChange", (const char *)(void *)0 };
    const char *eventvar_values[2l] = { (const char *)(void *)0, (const char *)(void *)0 };
    pthread_mutex_lock(srv->service_mutex);
    signed int var_count;
    var_count=VariableContainer_get_num_vars(srv->variable_container);
    struct upnp_last_change_builder *builder;
    builder=UPnPLastChangeBuilder_new(srv->event_xml_ns);
    signed int i = 0;
    for( ; !(i >= var_count); i = i + 1)
    {
      const char *name;
      const char *value;
      value=VariableContainer_get(srv->variable_container, i, &name);
      if(!(value == ((const char *)NULL)))
      {
        return_value_strcmp$3=strcmp("LastChange", name);
        if(!(return_value_strcmp$3 == 0))
        {
          return_value_strlen$1=strlen("A_ARG_TYPE_");
          return_value_strncmp$2=strncmp("A_ARG_TYPE_", name, return_value_strlen$1);
          if(!(return_value_strncmp$2 == 0))
            UPnPLastChangeBuilder_add(builder, name, value);

        }

      }

    }
    pthread_mutex_unlock(srv->service_mutex);
    char *xml_value;
    xml_value=UPnPLastChangeBuilder_to_xml(builder);
    Log_info("upnp", "Initial variable sync: %s", xml_value);
    eventvar_values[(signed long int)0]=xmlescape(xml_value, 0);
    free((void *)xml_value);
    UPnPLastChangeBuilder_delete(builder);
    rc=UpnpAcceptSubscription(priv->device_handle, sr_event->UDN, sr_event->ServiceId, eventvar_names, eventvar_values, 1, sr_event->Sid);
    if(rc == 0)
      result = 0;

    else
    {
      const char *return_value_UpnpGetErrorMessage$4;
      return_value_UpnpGetErrorMessage$4=UpnpGetErrorMessage(rc);
      Log_error("upnp", "Accept Subscription Error: %s (%d)", return_value_UpnpGetErrorMessage$4, rc);
    }
    pthread_mutex_unlock(&priv->device_mutex);
    free((void *)(char *)eventvar_values[(signed long int)0]);
    return result;
  }
}

// handle_var_request
// file upnp_device.c line 242
static signed int handle_var_request(struct upnp_device *priv, struct Upnp_State_Var_Request *var_event)
{
  struct service *srv;
  srv=find_service(priv->upnp_device_descriptor, var_event->ServiceID);
  signed int return_value_strcmp$1;
  if(srv == ((struct service *)NULL))
  {
    var_event->ErrCode = 402;
    return -1;
  }

  else
  {
    pthread_mutex_lock(srv->service_mutex);
    char *result = (char *)(void *)0;
    signed int var_count;
    var_count=VariableContainer_get_num_vars(srv->variable_container);
    signed int i = 0;
    for( ; !(i >= var_count); i = i + 1)
    {
      const char *name;
      const char *value;
      value=VariableContainer_get(srv->variable_container, i, &name);
      if(!(value == ((const char *)NULL)))
      {
        return_value_strcmp$1=strcmp(var_event->StateVarName, name);
        if(return_value_strcmp$1 == 0)
        {
          result=strdup(value);
          break;
        }

      }

    }
    pthread_mutex_unlock(srv->service_mutex);
    var_event->CurrentVal = result;
    var_event->ErrCode = result == (char *)(void *)0 ? 404 : 0;
    Log_info("upnp", "Variable request %s -> %s (%s)", (const void *)var_event->StateVarName, result, (const void *)var_event->ServiceID);
    return 0;
  }
}

// inform_play_transition_from_output
// file upnp_transport.c line 865
static void inform_play_transition_from_output(enum PlayFeedback fb)
{
  service_lock$link1();
  const char *av_uri;
  const char *av_meta;
  switch((signed int)fb)
  {
    case PLAY_STOPPED:
    {
      replace_transport_uri_and_meta("", "");
      replace_current_uri_and_meta("", "");
      change_transport_state((enum transport_state)TRANSPORT_STOPPED);
      break;
    }
    case PLAY_STARTED_NEXT_STREAM:
    {
      av_uri=get_var((enum anonymous$31)TRANSPORT_VAR_NEXT_AV_URI);
      av_meta=get_var((enum anonymous$31)TRANSPORT_VAR_NEXT_AV_URI_META);
      replace_transport_uri_and_meta(av_uri, av_meta);
      replace_current_uri_and_meta(av_uri, av_meta);
      replace_var$link1((enum anonymous$31)TRANSPORT_VAR_NEXT_AV_URI, "");
      replace_var$link1((enum anonymous$31)TRANSPORT_VAR_NEXT_AV_URI_META, "");
    }
  }
  service_unlock$link1();
}

// init_logging
// file main.c line 170
static void init_logging(const char *log_file)
{
  char version[1024l];
  snprintf(version, sizeof(char [1024l]) /*1024ul*/ , "[ gmediarender %s (libupnp-%s; glib-%d.%d.%d; gstreamer-%d.%d.%d) ]", (const void *)"0.0.7-git", (const void *)"1.6.19+git20160116", 2, 46, 2, 1, 6, 3);
  if(!(log_file == ((const char *)NULL)))
  {
    Log_init(log_file);
    Log_info("main", "%s log started %s", (const void *)"gmediarender 0.0.7-git", (const void *)version);
  }

  else
    fprintf(stderr, "%s started %s.\nLogging switched off. Enable with --logfile=<filename> (e.g. --logfile=/dev/stdout for console)\n", (const void *)"gmediarender 0.0.7-git", (const void *)version);
}

// initialize_device
// file upnp_device.c line 406
static signed int initialize_device(struct upnp_device_descriptor *device_def, struct upnp_device *result_device, const char *ip_address, unsigned short int port)
{
  signed int rc;
  char *buf;
  rc=UpnpInit(ip_address, port);
  if(!(rc == 0))
  {
    const char *return_value_UpnpGetErrorMessage$1;
    return_value_UpnpGetErrorMessage$1=UpnpGetErrorMessage(rc);
    Log_error("upnp", "UpnpInit(ip=%s, port=%d) Error: %s (%d)", ip_address, port, return_value_UpnpGetErrorMessage$1, rc);
    return 0;
  }

  char *return_value_UpnpGetServerIpAddress$2;
  return_value_UpnpGetServerIpAddress$2=UpnpGetServerIpAddress();
  unsigned short int return_value_UpnpGetServerPort$3;
  return_value_UpnpGetServerPort$3=UpnpGetServerPort();
  Log_info("upnp", "Registered IP=%s port=%d\n", return_value_UpnpGetServerIpAddress$2, return_value_UpnpGetServerPort$3);
  rc=UpnpEnableWebserver((signed int)!(0 != 0));
  if(!(rc == 0))
  {
    const char *return_value_UpnpGetErrorMessage$4;
    return_value_UpnpGetErrorMessage$4=UpnpGetErrorMessage(rc);
    Log_error("upnp", "UpnpEnableWebServer() Error: %s (%d)", return_value_UpnpGetErrorMessage$4, rc);
    return 0;
  }

  signed int return_value_webserver_register_callbacks$5;
  return_value_webserver_register_callbacks$5=webserver_register_callbacks();
  if(return_value_webserver_register_callbacks$5 == 0)
    return 0;

  else
  {
    rc=UpnpAddVirtualDir("/upnp");
    if(!(rc == 0))
    {
      const char *return_value_UpnpGetErrorMessage$6;
      return_value_UpnpGetErrorMessage$6=UpnpGetErrorMessage(rc);
      Log_error("upnp", "UpnpAddVirtualDir() Error: %s (%d)", return_value_UpnpGetErrorMessage$6, rc);
      return 0;
    }

    buf=upnp_create_device_desc(device_def);
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(buf);
    rc=UpnpRegisterRootDevice2((enum Upnp_DescType_e)UPNPREG_BUF_DESC, buf, return_value_strlen$7, 1, event_handler, (const void *)result_device, &result_device->device_handle);
    free((void *)buf);
    if(!(rc == 0))
    {
      const char *return_value_UpnpGetErrorMessage$8;
      return_value_UpnpGetErrorMessage$8=UpnpGetErrorMessage(rc);
      Log_error("upnp", "UpnpRegisterRootDevice2() Error: %s (%d)", return_value_UpnpGetErrorMessage$8, rc);
      return 0;
    }

    rc=UpnpSendAdvertisement(result_device->device_handle, 100);
    if(!(rc == 0))
    {
      const char *return_value_UpnpGetErrorMessage$9;
      return_value_UpnpGetErrorMessage$9=UpnpGetErrorMessage(rc);
      Log_error("unpp", "Error sending advertisements: %s (%d)", return_value_UpnpGetErrorMessage$9, rc);
      return 0;
    }

    return (signed int)!(0 != 0);
  }
}

// list_presets
// file upnp_control.c line 530
static signed int list_presets(struct action_event *event)
{
  signed int return_value_cmd_obtain_variable$1;
  return_value_cmd_obtain_variable$1=cmd_obtain_variable(event, (enum anonymous$19)CONTROL_VAR_PRESET_NAME_LIST, "CurrentPresetNameList");
  return return_value_cmd_obtain_variable$1;
}

// log_variable_change
// file main.c line 156
static void log_variable_change(void *userdata, signed int var_num, const char *variable_name, const char *old_value, const char *variable_value)
{
  const char *category = (const char *)userdata;
  signed int needs_newline;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(variable_value);
  needs_newline = (signed int)((signed int)variable_value[(signed long int)(return_value_strlen$1 - (unsigned long int)1)] != 10);
  const char *var_start;
  signed int return_value_Log_color_allowed$2;
  return_value_Log_color_allowed$2=Log_color_allowed();
  var_start = return_value_Log_color_allowed$2 != 0 ? "\033[1m\033[34m" : "";
  const char *var_end;
  signed int return_value_Log_color_allowed$3;
  return_value_Log_color_allowed$3=Log_color_allowed();
  var_end = return_value_Log_color_allowed$3 != 0 ? "\033[0m" : "";
  Log_info(category, "%s%s%s: %s%s", var_start, variable_name, var_end, variable_value, needs_newline != 0 ? "\n" : "");
}

// main
// file main.c line 189
signed int main(signed int argc, char **argv)
{
  signed int rc;
  struct upnp_device_descriptor *upnp_renderer;
  signed int return_value_process_cmdline$1;
  return_value_process_cmdline$1=process_cmdline(argc, argv);
  if(return_value_process_cmdline$1 == 0)
    return 1;

  else
  {
    if(!(show_version == 0))
    {
      do_show_version();
      exit(0);
    }

    if(!(show_connmgr_scpd == 0))
    {
      upnp_renderer_dump_connmgr_scpd();
      exit(0);
    }

    if(!(show_control_scpd == 0))
    {
      upnp_renderer_dump_control_scpd();
      exit(0);
    }

    if(!(show_transport_scpd == 0))
    {
      upnp_renderer_dump_transport_scpd();
      exit(0);
    }

    if(!(show_outputs == 0))
    {
      output_dump_modules();
      exit(0);
    }

    init_logging(log_file);
    struct _IO_FILE *pid_file_stream = (struct _IO_FILE *)(void *)0;
    if(!(pid_file == ((const char *)NULL)))
      pid_file_stream=fopen(pid_file, "w");

    if(!(daemon_mode == 0))
    {
      signed int return_value_daemon$2;
      return_value_daemon$2=daemon(0, 0);
      if(!(return_value_daemon$2 >= 0))
      {
        perror("Becoming daemon: ");
        return 1;
      }

    }

    if(!(pid_file_stream == ((struct _IO_FILE *)NULL)))
    {
      signed int return_value_getpid$3;
      return_value_getpid$3=getpid();
      fprintf(pid_file_stream, "%d\n", return_value_getpid$3);
      fclose(pid_file_stream);
    }

    upnp_renderer=upnp_renderer_descriptor(friendly_name, uuid);
    if(upnp_renderer == ((struct upnp_device_descriptor *)NULL))
      return 1;

    else
    {
      rc=output_init(output);
      if(!(rc == 0))
      {
        Log_error("main", "ERROR: Failed to initialize Output subsystem");
        return 1;
      }

      else
      {
        struct upnp_device *device;
        if(!(listen_port == 0) && (listen_port >= 65536 || !(listen_port >= 49152)))
        {
          Log_error("main", "Parameter error: --port needs to be in range [49152..65535] (but was set to %d)", listen_port);
          return 1;
        }

        else
        {
          device=upnp_device_init(upnp_renderer, ip_address, (unsigned short int)listen_port);
          if(device == ((struct upnp_device *)NULL))
          {
            Log_error("main", "ERROR: Failed to initialize UPnP device");
            return 1;
          }

          else
          {
            upnp_transport_init(device);
            upnp_control_init(device);
            if(!(show_devicedesc == 0))
            {
              char *buf;
              buf=upnp_create_device_desc(upnp_renderer);
              /* assertion buf != ((void *)0) */
              assert(buf != (char *)(void *)0);
              fputs(buf, stdout);
              exit(0);
            }

            signed int return_value_Log_info_enabled$4;
            return_value_Log_info_enabled$4=Log_info_enabled();
            if(!(return_value_Log_info_enabled$4 == 0))
            {
              upnp_transport_register_variable_listener(log_variable_change, (void *)"transport");
              upnp_control_register_variable_listener(log_variable_change, (void *)"control");
            }

            Log_info("main", "Ready for rendering.");
            fprintf(stderr, "Ready for rendering.\n");
            output_loop();
            Log_info("main", "Exiting.");
            upnp_device_shutdown(device);
            return 0;
          }
        }
      }
    }
  }
}

// minimum
// file webserver.c line 193
static inline signed int minimum(signed int a, signed int b)
{
  return a < b ? a : b;
}

// my_bus_callback
// file output_gstreamer.c line 286
static signed int my_bus_callback(struct _GstBus *bus, struct _GstMessage *msg, void *data)
{
  enum anonymous$7 msgType;
  const struct _GstObject *msgSrc;
  const char *msgSrcName;
  msgType = ((struct _GstMessage *)msg)->type;
  msgSrc = ((struct _GstMessage *)msg)->src;
  msgSrcName = ((struct _GstObject *)msgSrc)->name;
  char *debug;
  struct _GError *err;
  enum anonymous$21 oldstate;
  enum anonymous$21 newstate;
  enum anonymous$21 pending;
  struct _GstTagList *tags;
  switch((signed int)msgType)
  {
    case GST_MESSAGE_EOS:
    {
      Log_info("gstreamer", "%s: End-of-stream", msgSrcName);
      if(!(gs_next_uri_ == ((char *)NULL)))
      {
        free((void *)gsuri_);
        gsuri_ = gs_next_uri_;
        gs_next_uri_ = (char *)(void *)0;
        gst_element_set_state(player_, (enum anonymous$21)GST_STATE_READY);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
        return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)player_, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "uri", gsuri_, (void *)0);
        gst_element_set_state(player_, (enum anonymous$21)GST_STATE_PLAYING);
        if(!(play_trans_callback_ == ((void (*)(enum PlayFeedback))NULL)))
          play_trans_callback_((enum PlayFeedback)PLAY_STARTED_NEXT_STREAM);

      }

      else
        if(!(play_trans_callback_ == ((void (*)(enum PlayFeedback))NULL)))
          play_trans_callback_((enum PlayFeedback)PLAY_STOPPED);

      goto __CPROVER_DUMP_L10;
    }
    case GST_MESSAGE_ERROR:
    {
      gst_message_parse_error(msg, &err, &debug);
      Log_error("gstreamer", "%s: Error: %s (Debug: %s)", msgSrcName, err->message, debug);
      g_error_free(err);
      g_free((void *)debug);
      goto __CPROVER_DUMP_L10;
    }
    case GST_MESSAGE_STATE_CHANGED:
    {
      gst_message_parse_state_changed(msg, &oldstate, &newstate, &pending);
      goto __CPROVER_DUMP_L10;
    }
    case GST_MESSAGE_TAG:
    {
      tags = (struct _GstTagList *)(void *)0;
      if(!(meta_update_callback_ == ((void (*)(struct SongMetaData *))NULL)))
      {
        gst_message_parse_tag(msg, &tags);
        struct MetaModify modify;
        modify.meta = &song_meta_;
        modify.any_change = 0;
        gst_tag_list_foreach(tags, MetaModify_add_tag, (void *)&modify);
        gst_tag_list_unref(tags);
        if(!(modify.any_change == 0))
          meta_update_callback_(&song_meta_);

      }

    }
    case GST_MESSAGE_BUFFERING:

    default:
    {

    __CPROVER_DUMP_L10:
      ;
      return (signed int)!(0 != 0);
    }
  }
}

// obtain_instanceid
// file upnp_transport.c line 524
static signed int obtain_instanceid(struct action_event *event, signed int *instance)
{
  char *value;
  value=upnp_get_string(event, "InstanceID");
  if(value == ((char *)NULL))
  {
    upnp_set_error(event, 402, "Missing InstanceID");
    return -1;
  }

  else
  {
    free((void *)value);
    return 0;
  }
}

// output_add_options
// file output.h line 43
signed int output_add_options(struct _GOptionContext *ctx)
{
  signed int count;
  signed int i;
  count = (signed int)(sizeof(struct output_module *[1l]) /*8ul*/  / sizeof(struct output_module *) /*8ul*/ );
  i = 0;
  for( ; !(i >= count); i = i + 1)
    if(!(modules[(signed long int)i]->add_options == ((signed int (*)(struct _GOptionContext *))NULL)))
    {
      signed int result;
      result=modules[(signed long int)i]->add_options(ctx);
      if(!(result == 0))
        return result;

    }

  return 0;
}

// output_dump_modules
// file output.h line 44
void output_dump_modules(void)
{
  signed int count = (signed int)(sizeof(struct output_module *[1l]) /*8ul*/  / sizeof(struct output_module *) /*8ul*/ );
  if(count == 0)
    puts("  NONE!");

  else
  {
    signed int i = 0;
    for( ; !(i >= count); i = i + 1)
      printf("Available output: %s\t%s%s\n", modules[(signed long int)i]->shortname, modules[(signed long int)i]->description, i == 0 ? " (default)" : "");
  }
}

// output_get_mute
// file output.c line 206
signed int output_get_mute(signed int *value)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->get_mute == ((signed int (*)(signed int *))NULL)))
    {
      signed int return_value;
      return_value=output_module->get_mute(value);
      return return_value;
    }

  }

  return -1;
}

// output_get_position
// file output.h line 54
signed int output_get_position(signed long int *track_dur, signed long int *track_pos)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->get_position == ((signed int (*)(signed long int *, signed long int *))NULL)))
    {
      signed int return_value;
      return_value=output_module->get_position(track_dur, track_pos);
      return return_value;
    }

  }

  return -1;
}

// output_get_volume
// file output.h line 57
signed int output_get_volume(float *value)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->get_volume == ((signed int (*)(float *))NULL)))
    {
      signed int return_value;
      return_value=output_module->get_volume(value);
      return return_value;
    }

  }

  return -1;
}

// output_gstreamer_add_options
// file output_gstreamer.c line 404
static signed int output_gstreamer_add_options(struct _GOptionContext *ctx)
{
  struct _GOptionGroup *option_group;
  option_group=g_option_group_new("gstout", "GStreamer Output Options", "Show GStreamer Output Options", (void *)0, (void (*)(void *))(void *)0);
  g_option_group_add_entries(option_group, option_entries$link1);
  g_option_context_add_group(ctx, option_group);
  struct _GOptionGroup *return_value_gst_init_get_option_group$1;
  return_value_gst_init_get_option_group$1=gst_init_get_option_group();
  g_option_context_add_group(ctx, return_value_gst_init_get_option_group$1);
  return 0;
}

// output_gstreamer_get_mute
// file output_gstreamer.c line 460
static signed int output_gstreamer_get_mute(signed int *m)
{
  signed int val;
  g_object_get((void *)player_, "mute", &val, (void *)0);
  *m = val;
  return 0;
}

// output_gstreamer_get_position
// file output_gstreamer.c line 418
static signed int output_gstreamer_get_position(signed long int *track_duration, signed long int *track_pos)
{
  *track_duration = last_known_time_.duration;
  *track_pos = last_known_time_.position;
  signed int rc = 0;
  enum anonymous$21 return_value_get_current_player_state$1;
  return_value_get_current_player_state$1=get_current_player_state();
  if(!((signed int)return_value_get_current_player_state$1 == GST_STATE_PLAYING))
    return rc;

  else
  {
    enum anonymous$11 query_type = (enum anonymous$11)GST_FORMAT_TIME;
    signed int return_value_gst_element_query_duration$2;
    return_value_gst_element_query_duration$2=gst_element_query_duration(player_, query_type, track_duration);
    if(return_value_gst_element_query_duration$2 == 0)
    {
      Log_error("gstreamer", "Failed to get track duration.");
      rc = -1;
    }

    signed int return_value_gst_element_query_position$3;
    return_value_gst_element_query_position$3=gst_element_query_position(player_, query_type, track_pos);
    if(return_value_gst_element_query_position$3 == 0)
    {
      Log_error("gstreamer", "Failed to get track pos");
      rc = -1;
    }

    last_known_time_.duration = *track_duration;
    last_known_time_.position = *track_pos;
    return rc;
  }
}

// output_gstreamer_get_volume
// file output_gstreamer.c line 448
static signed int output_gstreamer_get_volume(float *v)
{
  double volume;
  g_object_get((void *)player_, "volume", &volume, (void *)0);
  Log_info("gstreamer", "Query volume fraction: %f", volume);
  *v = (float)volume;
  return 0;
}

// output_gstreamer_init
// file output_gstreamer.c line 489
static signed int output_gstreamer_init(void)
{
  struct _GstBus *bus;
  SongMetaData_init(&song_meta_);
  scan_mime_list();
  const char player_element_name[8l] = { 'p', 'l', 'a', 'y', 'b', 'i', 'n', 0 };
  player_=gst_element_factory_make(player_element_name, "play");
  /* assertion player_ != ((void *)0) */
  assert(player_ != (struct _GstElement *)(void *)0);
  unsigned long int return_value_gst_pipeline_get_type$1;
  return_value_gst_pipeline_get_type$1=gst_pipeline_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)player_, return_value_gst_pipeline_get_type$1);
  bus=gst_pipeline_get_bus((struct _GstPipeline *)return_value_g_type_check_instance_cast$2);
  gst_bus_add_watch(bus, my_bus_callback, (void *)0);
  gst_object_unref((void *)bus);
  if(!(audio_sink == ((char *)NULL)))
  {
    struct _GstElement *sink = (struct _GstElement *)(void *)0;
    Log_info("gstreamer", "Setting audio sink to %s; device=%s\n", audio_sink, audio_device != ((char *)NULL) ? audio_device : "");
    sink=gst_element_factory_make(audio_sink, "sink");
    if(sink == ((struct _GstElement *)NULL))
      Log_error("gstreamer", "Couldn't create sink '%s'", audio_sink);

    else
    {
      if(!(audio_device == ((char *)NULL)))
      {
        struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
        return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)sink, (unsigned long int)(20 << 2));
        g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$3, "device", audio_device, (void *)0);
      }

      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)player_, (unsigned long int)(20 << 2));
      g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$4, "audio-sink", sink, (void *)0);
    }
  }

  if(!(videosink == ((char *)NULL)))
  {
    struct _GstElement *output_gstreamer_init$$1$$2$$sink = (struct _GstElement *)(void *)0;
    Log_info("gstreamer", "Setting video sink to %s", videosink);
    output_gstreamer_init$$1$$2$$sink=gst_element_factory_make(videosink, "sink");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)player_, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$5, "video-sink", output_gstreamer_init$$1$$2$$sink, (void *)0);
  }

  enum anonymous$20 return_value_gst_element_set_state$6;
  return_value_gst_element_set_state$6=gst_element_set_state(player_, (enum anonymous$21)GST_STATE_READY);
  if((signed int)return_value_gst_element_set_state$6 == GST_STATE_CHANGE_FAILURE)
    Log_error("gstreamer", "Error: pipeline doesn't become ready.");

  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)player_, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$7, "about-to-finish", (void (*)(void))prepare_next_stream, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$16)0);
  output_gstreamer_set_mute(0);
  if(initial_db < 0.000000)
  {
    double return_value_log$8;
    return_value_log$8=log((double)10);
    double return_value_exp$9;
    return_value_exp$9=exp((initial_db / (double)20) * return_value_log$8);
    output_gstreamer_set_volume((float)return_value_exp$9);
  }

  return 0;
}

// output_gstreamer_pause
// file output_gstreamer.c line 210
static signed int output_gstreamer_pause(void)
{
  enum anonymous$20 return_value_gst_element_set_state$1;
  return_value_gst_element_set_state$1=gst_element_set_state(player_, (enum anonymous$21)GST_STATE_PAUSED);
  if((signed int)return_value_gst_element_set_state$1 == GST_STATE_CHANGE_FAILURE)
    return -1;

  else
    return 0;
}

// output_gstreamer_play
// file output_gstreamer.c line 183
static signed int output_gstreamer_play(void (*callback)(enum PlayFeedback))
{
  play_trans_callback_ = callback;
  enum anonymous$21 return_value_get_current_player_state$3;
  return_value_get_current_player_state$3=get_current_player_state();
  if(!((signed int)return_value_get_current_player_state$3 == GST_STATE_PAUSED))
  {
    enum anonymous$20 return_value_gst_element_set_state$1;
    return_value_gst_element_set_state$1=gst_element_set_state(player_, (enum anonymous$21)GST_STATE_READY);
    if((signed int)return_value_gst_element_set_state$1 == GST_STATE_CHANGE_FAILURE)
      Log_error("gstreamer", "setting play state failed (1)");

    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)player_, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$2, "uri", gsuri_, (void *)0);
  }

  enum anonymous$20 return_value_gst_element_set_state$4;
  return_value_gst_element_set_state$4=gst_element_set_state(player_, (enum anonymous$21)GST_STATE_PLAYING);
  if((signed int)return_value_gst_element_set_state$4 == GST_STATE_CHANGE_FAILURE)
  {
    Log_error("gstreamer", "setting play state failed (2)");
    return -1;
  }

  else
    return 0;
}

// output_gstreamer_seek
// file output_gstreamer.c line 219
static signed int output_gstreamer_seek(signed long int position_nanos)
{
  signed int return_value_gst_element_seek$1;
  return_value_gst_element_seek$1=gst_element_seek(player_, 1.0, (enum anonymous$11)GST_FORMAT_TIME, (enum anonymous$12)GST_SEEK_FLAG_FLUSH, (enum anonymous$13)GST_SEEK_TYPE_SET, position_nanos, (enum anonymous$13)GST_SEEK_TYPE_NONE, (signed long int)(unsigned long int)-1);
  if(!(return_value_gst_element_seek$1 == 0))
    return -1;

  else
    return 0;
}

// output_gstreamer_set_mute
// file output_gstreamer.c line 466
static signed int output_gstreamer_set_mute(signed int m)
{
  Log_info("gstreamer", "Set mute to %s", m != 0 ? "on" : "off");
  g_object_set((void *)player_, "mute", (signed int)m, (void *)0);
  return 0;
}

// output_gstreamer_set_next_uri
// file output_gstreamer.c line 168
static void output_gstreamer_set_next_uri(const char *uri)
{
  Log_info("gstreamer", "Set next uri to '%s'", uri);
  free((void *)gs_next_uri_);
  _Bool tmp_if_expr$1;
  if(!(uri == ((const char *)NULL)))
    tmp_if_expr$1 = *uri != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  char *tmp_if_expr$3;
  char *return_value_strdup$2;
  if(tmp_if_expr$1)
  {
    return_value_strdup$2=strdup(uri);
    tmp_if_expr$3 = return_value_strdup$2;
  }

  else
    tmp_if_expr$3 = (char *)(void *)0;
  gs_next_uri_ = tmp_if_expr$3;
}

// output_gstreamer_set_uri
// file output_gstreamer.c line 174
static void output_gstreamer_set_uri(const char *uri, void (*meta_cb)(struct SongMetaData *))
{
  Log_info("gstreamer", "Set uri to '%s'", uri);
  free((void *)gsuri_);
  _Bool tmp_if_expr$1;
  if(!(uri == ((const char *)NULL)))
    tmp_if_expr$1 = *uri != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  char *tmp_if_expr$3;
  char *return_value_strdup$2;
  if(tmp_if_expr$1)
  {
    return_value_strdup$2=strdup(uri);
    tmp_if_expr$3 = return_value_strdup$2;
  }

  else
    tmp_if_expr$3 = (char *)(void *)0;
  gsuri_ = tmp_if_expr$3;
  meta_update_callback_ = meta_cb;
  SongMetaData_clear(&song_meta_);
}

// output_gstreamer_set_volume
// file output_gstreamer.c line 455
static signed int output_gstreamer_set_volume(float value)
{
  Log_info("gstreamer", "Set volume fraction to %f", value);
  g_object_set((void *)player_, "volume", (double)value, (void *)0);
  return 0;
}

// output_gstreamer_stop
// file output_gstreamer.c line 201
static signed int output_gstreamer_stop(void)
{
  enum anonymous$20 return_value_gst_element_set_state$1;
  return_value_gst_element_set_state$1=gst_element_set_state(player_, (enum anonymous$21)GST_STATE_READY);
  if((signed int)return_value_gst_element_set_state$1 == GST_STATE_CHANGE_FAILURE)
    return -1;

  else
    return 0;
}

// output_init
// file output.h line 42
signed int output_init(const char *shortname)
{
  signed int count = (signed int)(sizeof(struct output_module *[1l]) /*8ul*/  / sizeof(struct output_module *) /*8ul*/ );
  if(count == 0)
  {
    Log_error("output", "No output module available");
    return -1;
  }

  else
  {
    if(shortname == ((const char *)NULL))
      output_module = modules[(signed long int)0];

    else
    {
      signed int i = 0;
      for( ; !(i >= count); i = i + 1)
      {
        signed int return_value_strcmp$1;
        return_value_strcmp$1=strcmp(modules[(signed long int)i]->shortname, shortname);
        if(return_value_strcmp$1 == 0)
        {
          output_module = modules[(signed long int)i];
          break;
        }

      }
    }
    if(output_module == ((struct output_module *)NULL))
    {
      Log_error("error", "ERROR: No such output module: '%s'", shortname);
      return -1;
    }

    else
    {
      Log_info("output", "Using output module: %s (%s)", output_module->shortname, output_module->description);
      if(!(output_module->init == ((signed int (*)(void))NULL)))
      {
        signed int return_value;
        return_value=output_module->init();
        return return_value;
      }

      return 0;
    }
  }
}

// output_loop
// file output.h line 46
signed int output_loop(void)
{
  main_loop_=g_main_loop_new((struct _GMainContext *)(void *)0, 0);
  signal(2, exit_loop_sighandler);
  signal(15, exit_loop_sighandler);
  g_main_loop_run(main_loop_);
  return 0;
}

// output_pause
// file output.h line 53
signed int output_pause(void)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->pause == ((signed int (*)(void))NULL)))
    {
      signed int return_value;
      return_value=output_module->pause();
      return return_value;
    }

  }

  return -1;
}

// output_play
// file output.h line 51
signed int output_play(void (*transition_callback)(enum PlayFeedback))
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->play == ((signed int (*)(void (*)(enum PlayFeedback)))NULL)))
    {
      signed int return_value;
      return_value=output_module->play(transition_callback);
      return return_value;
    }

  }

  return -1;
}

// output_seek
// file output.h line 55
signed int output_seek(signed long int position_nanos)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->seek == ((signed int (*)(signed long int))NULL)))
    {
      signed int return_value;
      return_value=output_module->seek(position_nanos);
      return return_value;
    }

  }

  return -1;
}

// output_set_mute
// file output.h line 60
signed int output_set_mute(signed int value)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->set_mute == ((signed int (*)(signed int))NULL)))
    {
      signed int return_value;
      return_value=output_module->set_mute(value);
      return return_value;
    }

  }

  return -1;
}

// output_set_next_uri
// file output.h line 49
void output_set_next_uri(const char *uri)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->set_next_uri == ((void (*)(const char *))NULL)))
      output_module->set_next_uri(uri);

  }

}

// output_set_uri
// file output.h line 48
void output_set_uri(const char *uri, void (*meta_cb)(struct SongMetaData *))
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->set_uri == ((void (*)(const char *, void (*)(struct SongMetaData *)))NULL)))
      output_module->set_uri(uri, meta_cb);

  }

}

// output_set_volume
// file output.h line 58
signed int output_set_volume(float value)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->set_volume == ((signed int (*)(float))NULL)))
    {
      signed int return_value;
      return_value=output_module->set_volume(value);
      return return_value;
    }

  }

  return -1;
}

// output_stop
// file output.h line 52
signed int output_stop(void)
{
  if(!(output_module == ((struct output_module *)NULL)))
  {
    if(!(output_module->stop == ((signed int (*)(void))NULL)))
    {
      signed int return_value;
      return_value=output_module->stop();
      return return_value;
    }

  }

  return -1;
}

// parse_upnp_time
// file upnp_transport.c line 766
static signed long int parse_upnp_time(const char *time_string)
{
  signed int hour = 0;
  signed int minute = 0;
  signed int second = 0;
  sscanf(time_string, "%d:%02d:%02d", &hour, &minute, &second);
  const signed long int seconds = (const signed long int)(hour * 3600 + minute * 60 + second);
  const signed long int one_sec_unit = 1000000000LL;
  return one_sec_unit * seconds;
}

// pause_stream
// file upnp_transport.c line 937
static signed int pause_stream(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  signed int return_value_output_pause$2;
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    signed int rc = 0;
    service_lock$link1();
    switch((signed int)transport_state_)
    {
      case TRANSPORT_PAUSED_PLAYBACK:
        break;
      case TRANSPORT_PLAYING:
      {
        return_value_output_pause$2=output_pause();
        if(!(return_value_output_pause$2 == 0))
        {
          upnp_set_error(event, 704, "Pause failed");
          rc = -1;
        }

        else
          change_transport_state((enum transport_state)TRANSPORT_PAUSED_PLAYBACK);
        break;
      }
      default:
      {
        const char *return_value_get_var$3;
        return_value_get_var$3=get_var((enum anonymous$31)TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS);
        upnp_set_error(event, 701, "Transition to PAUSE not allowed; allowed=%s", return_value_get_var$3);
        rc = -1;
      }
    }
    service_unlock$link1();
    return rc;
  }
}

// play
// file upnp_transport.c line 887
static signed int play(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  signed int return_value_output_play$2;
  const char *return_value_get_var$3;
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    signed int rc = 0;
    service_lock$link1();
    switch((signed int)transport_state_)
    {
      case TRANSPORT_PLAYING:
        goto __CPROVER_DUMP_L8;
      case TRANSPORT_STOPPED:
        replace_var$link1((enum anonymous$31)TRANSPORT_VAR_REL_TIME_POS, kZeroTime);
      case TRANSPORT_PAUSED_PLAYBACK:
      {
        return_value_output_play$2=output_play(inform_play_transition_from_output);
        if(!(return_value_output_play$2 == 0))
        {
          upnp_set_error(event, 704, "Playing failed");
          rc = -1;
        }

        else
        {
          change_transport_state((enum transport_state)TRANSPORT_PLAYING);
          const char *av_uri;
          av_uri=get_var((enum anonymous$31)TRANSPORT_VAR_AV_URI);
          const char *av_meta;
          av_meta=get_var((enum anonymous$31)TRANSPORT_VAR_AV_URI_META);
          replace_current_uri_and_meta(av_uri, av_meta);
        }
        goto __CPROVER_DUMP_L8;
      }
      case TRANSPORT_NO_MEDIA_PRESENT:

      case TRANSPORT_TRANSITIONING:

      case TRANSPORT_PAUSED_RECORDING:

      case TRANSPORT_RECORDING:
      {
        return_value_get_var$3=get_var((enum anonymous$31)TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS);
        upnp_set_error(event, 701, "Transition to PLAY not allowed; allowed=%s", return_value_get_var$3);
        rc = -1;
      }
      default:
      {

      __CPROVER_DUMP_L8:
        ;
        service_unlock$link1();
        return rc;
      }
    }
  }
}

// prepare_for_connection
// file upnp_connmgr.c line 318
static signed int prepare_for_connection(struct action_event *event)
{
  upnp_append_variable(event, 9, "ConnectionID");
  upnp_append_variable(event, 3, "AVTransportID");
  upnp_append_variable(event, 5, "RcsID");
  return 0;
}

// prepare_next_stream
// file output_gstreamer.c line 472
static void prepare_next_stream(struct _GstElement *obj, void *userdata)
{
  Log_info("gstreamer", "about-to-finish cb: setting uri %s", gs_next_uri_);
  free((void *)gsuri_);
  gsuri_ = gs_next_uri_;
  gs_next_uri_ = (char *)(void *)0;
  if(!(gsuri_ == ((char *)NULL)))
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)player_, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "uri", gsuri_, (void *)0);
    if(!(play_trans_callback_ == ((void (*)(enum PlayFeedback))NULL)))
      play_trans_callback_((enum PlayFeedback)PLAY_STARTED_NEXT_STREAM);

  }

}

// print_upnp_time
// file upnp_transport.c line 758
static void print_upnp_time(char *result, unsigned long int size, signed long int t)
{
  const signed long int one_sec = 1000000000LL;
  signed int hour;
  hour=divide_leave_remainder(&t, 3600LL * one_sec);
  signed int minute;
  minute=divide_leave_remainder(&t, 60LL * one_sec);
  signed int second;
  second=divide_leave_remainder(&t, one_sec);
  snprintf(result, size, "%d:%02d:%02d", hour, minute, second);
}

// process_cmdline
// file main.c line 132
static signed int process_cmdline(signed int argc, char **argv)
{
  struct _GOptionContext *ctx;
  struct _GError *err = (struct _GError *)(void *)0;
  signed int rc;
  ctx=g_option_context_new("- GMediaRender");
  g_option_context_add_main_entries(ctx, option_entries, (const char *)(void *)0);
  rc=output_add_options(ctx);
  if(!(rc == 0))
  {
    fprintf(stderr, "Failed to add output options\n");
    return 0;
  }

  else
  {
    signed int return_value_g_option_context_parse$1;
    return_value_g_option_context_parse$1=g_option_context_parse(ctx, &argc, &argv, &err);
    if(return_value_g_option_context_parse$1 == 0)
    {
      fprintf(stderr, "Failed to initialize: %s\n", err->message);
      g_error_free(err);
      return 0;
    }

    else
      return (signed int)!(0 != 0);
  }
}

// register_mime_type
// file upnp_connmgr.c line 209
void register_mime_type(const char *mime_type)
{
  register_mime_type_internal(mime_type);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp("audio/mpeg", mime_type);
  if(return_value_strcmp$1 == 0)
  {
    register_mime_type_internal("audio/x-mpeg");
    register_mime_type_internal("audio/x-scpls");
    register_mime_type("audio/L16;rate=44100;channels=2");
  }

  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp("audio/x-alac", mime_type);
  if(return_value_strcmp$2 == 0)
    register_mime_type_internal("audio/alac");

  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp("audio/x-aiff", mime_type);
  if(return_value_strcmp$3 == 0)
    register_mime_type_internal("audio/aiff");

  signed int return_value_strcmp$4;
  return_value_strcmp$4=strcmp("audio/x-m4a", mime_type);
  if(return_value_strcmp$4 == 0)
  {
    register_mime_type_internal("audio/m4a");
    register_mime_type_internal("audio/mp4");
  }

}

// register_mime_type_internal
// file upnp_connmgr.c line 193
static void register_mime_type_internal(const char *mime_type)
{
  struct mime_type *entry = supported_types;
  for( ; !(entry == ((struct mime_type *)NULL)); entry = entry->next)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(entry->mime_type, mime_type);
    if(return_value_strcmp$1 == 0)
      goto __CPROVER_DUMP_L4;

  }
  Log_info("connmgr", "Registering support for '%s'", mime_type);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct mime_type) /*16ul*/ );
  entry = (struct mime_type *)return_value_malloc$2;
  entry->mime_type=strdup(mime_type);
  entry->next = supported_types;
  supported_types = entry;

__CPROVER_DUMP_L4:
  ;
}

// replace_current_uri_and_meta
// file upnp_transport.c line 591
static void replace_current_uri_and_meta(const char *uri, const char *meta)
{
  const char *tracks;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(uri == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(uri);
    tmp_if_expr$2 = return_value_strlen$1 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  tracks = tmp_if_expr$2 ? "1" : "0";
  replace_var$link1((enum anonymous$31)TRANSPORT_VAR_CUR_TRACK, tracks);
  replace_var$link1((enum anonymous$31)TRANSPORT_VAR_CUR_TRACK_URI, uri);
  replace_var$link1((enum anonymous$31)TRANSPORT_VAR_CUR_TRACK_META, meta);
}

// replace_range
// file song-meta-data.c line 84
static char * replace_range(char *input, const char *tag_start, const char *tag_end, const char *content, signed int *edit_count)
{
  if(content == ((const char *)NULL))
    return input;

  else
  {
    signed int total_len;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(input);
    total_len = (const signed int)return_value_strlen$1;
    const char *start_pos;
    start_pos=strstr(input, tag_start);
    if(start_pos == ((const char *)NULL))
      return input;

    else
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(tag_start);
      start_pos = start_pos + (signed long int)return_value_strlen$2;
      const char *end_pos;
      end_pos=strstr(start_pos, tag_end);
      if(end_pos == ((const char *)NULL))
        return input;

      else
      {
        signed int old_content_len = (signed int)(end_pos - start_pos);
        signed int new_content_len;
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(content);
        new_content_len = (signed int)return_value_strlen$3;
        char *result = (char *)(void *)0;
        if(!(old_content_len == new_content_len))
        {
          void *return_value_malloc$4;
          return_value_malloc$4=malloc((unsigned long int)(((total_len + new_content_len) - old_content_len) + 1));
          result = (char *)return_value_malloc$4;
          strncpy(result, input, (unsigned long int)(start_pos - input));
          strncpy(result + (start_pos - input), content, (unsigned long int)new_content_len);
          strcpy(result + (start_pos - input) + (signed long int)new_content_len, end_pos);
          free((void *)input);
          *edit_count = *edit_count + 1;
        }

        else
        {
          signed int return_value_strncmp$5;
          return_value_strncmp$5=strncmp(start_pos, content, (unsigned long int)new_content_len);
          if(!(return_value_strncmp$5 == 0))
          {
            const signed int offset = (const signed int)(start_pos - input);
            strncpy(input + (signed long int)offset, content, (unsigned long int)new_content_len);
            *edit_count = *edit_count + 1;
          }

          result = input;
        }
        return result;
      }
    }
  }
}

// replace_transport_uri_and_meta
// file upnp_transport.c line 574
static signed int replace_transport_uri_and_meta(const char *uri, const char *meta)
{
  replace_var$link1((enum anonymous$31)TRANSPORT_VAR_AV_URI, uri);
  replace_var$link1((enum anonymous$31)TRANSPORT_VAR_AV_URI_META, meta);
  const char *tracks;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(uri == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(uri);
    tmp_if_expr$2 = return_value_strlen$1 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  tracks = tmp_if_expr$2 ? "1" : "0";
  replace_var$link1((enum anonymous$31)TRANSPORT_VAR_NR_TRACKS, tracks);
  signed int requires_stream_meta_callback;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(meta);
  _Bool tmp_if_expr$5;
  char *return_value_strstr$4;
  if(return_value_strlen$3 == 0ul)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strstr$4=strstr(meta, "object.item.audioItem");
    tmp_if_expr$5 = return_value_strstr$4 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  requires_stream_meta_callback = (const signed int)tmp_if_expr$5;
  return requires_stream_meta_callback;
}

// replace_var
// file upnp_control.c line 505
static void replace_var(enum anonymous$19 varnum, const char *new_value)
{
  VariableContainer_change(state_variables_, (signed int)varnum, new_value);
}

// replace_var$link1
// file upnp_transport.c line 562
static signed int replace_var$link1(enum anonymous$31 varnum$link1, const char *new_value$link1)
{
  signed int return_value_VariableContainer_change$1;
  return_value_VariableContainer_change$1=VariableContainer_change(state_variables_$link1, (signed int)varnum$link1, new_value$link1);
  return return_value_VariableContainer_change$1;
}

// scan_caps
// file output_gstreamer.c line 43
static void scan_caps(const struct _GstCaps *caps)
{
  unsigned int i;
  do
    if(caps == ((const struct _GstCaps *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"scan_caps", "caps != NULL");
      goto __CPROVER_DUMP_L7;
    }

  while((_Bool)0);
  signed int return_value_gst_caps_is_any$1;
  return_value_gst_caps_is_any$1=gst_caps_is_any(caps);
  unsigned int return_value_gst_caps_get_size$3;
  if(return_value_gst_caps_is_any$1 == 0)
  {
    signed int return_value_gst_caps_is_empty$2;
    return_value_gst_caps_is_empty$2=gst_caps_is_empty(caps);
    if(return_value_gst_caps_is_empty$2 == 0)
    {
      i = (unsigned int)0;
      do
      {
        return_value_gst_caps_get_size$3=gst_caps_get_size(caps);
        if(i >= return_value_gst_caps_get_size$3)
          break;

        struct _GstStructure *structure;
        structure=gst_caps_get_structure(caps, i);
        const char *mime_type;
        mime_type=gst_structure_get_name(structure);
        register_mime_type(mime_type);
        i = i + 1u;
      }
      while((_Bool)1);
      register_mime_type("audio/*");
    }

  }


__CPROVER_DUMP_L7:
  ;
}

// scan_mime_list
// file output_gstreamer.c line 99
static void scan_mime_list(void)
{
  struct _GstRegistry *registry = (struct _GstRegistry *)(void *)0;
  struct _GList *plugins = (struct _GList *)(void *)0;
  registry=gst_registry_get();
  plugins=gst_registry_get_plugin_list(registry);
  struct _GList *tmp_if_expr$1;
  signed int tmp_statement_expression$7;
  _Bool tmp_if_expr$8;
  struct _GList *tmp_if_expr$9;
  while(!(plugins == ((struct _GList *)NULL)))
  {
    struct _GList *features;
    struct _GstPlugin *plugin = (struct _GstPlugin *)plugins->data;
    if(!(plugins == ((struct _GList *)NULL)))
      tmp_if_expr$1 = ((struct _GList *)plugins)->next;

    else
      tmp_if_expr$1 = (struct _GList *)(void *)0;
    plugins = tmp_if_expr$1;
    const char *return_value_gst_plugin_get_name$2;
    return_value_gst_plugin_get_name$2=gst_plugin_get_name(plugin);
    features=gst_registry_get_feature_list_by_plugin(registry, return_value_gst_plugin_get_name$2);
    while(!(features == ((struct _GList *)NULL)))
    {
      struct _GstPluginFeature *feature;
      unsigned long int return_value_gst_plugin_feature_get_type$3;
      return_value_gst_plugin_feature_get_type$3=gst_plugin_feature_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)features->data, return_value_gst_plugin_feature_get_type$3);
      feature = (struct _GstPluginFeature *)return_value_g_type_check_instance_cast$4;
      struct _GTypeInstance *__inst = (struct _GTypeInstance *)feature;
      unsigned long int __t;
      __t=gst_element_factory_get_type();
      signed int __r;
      if(__inst == ((struct _GTypeInstance *)NULL))
        __r = 0;

      else
      {
        if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
          tmp_if_expr$8 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          __r = (signed int)!(0 != 0);

        else
          __r=g_type_check_instance_is_a(__inst, __t);
      }
      tmp_statement_expression$7 = __r;
      if(!(tmp_statement_expression$7 == 0))
      {
        struct _GstElementFactory *factory;
        struct _GstElement *element;
        unsigned long int return_value_gst_element_factory_get_type$5;
        return_value_gst_element_factory_get_type$5=gst_element_factory_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)feature, return_value_gst_element_factory_get_type$5);
        factory = (struct _GstElementFactory *)return_value_g_type_check_instance_cast$6;
        element=gst_element_factory_create(factory, (const char *)(void *)0);
        if(!(element == ((struct _GstElement *)NULL)))
          scan_pad_templates_info(element, factory);

      }

      if(!(features == ((struct _GList *)NULL)))
        tmp_if_expr$9 = ((struct _GList *)features)->next;

      else
        tmp_if_expr$9 = (struct _GList *)(void *)0;
      features = tmp_if_expr$9;
    }
  }
}

// scan_pad_templates_info
// file output_gstreamer.c line 68
static void scan_pad_templates_info(struct _GstElement *element, struct _GstElementFactory *factory)
{
  const struct _GList *pads;
  struct _GstPadTemplate *padtemplate;
  struct _GstElementClass *class = (struct _GstElementClass *)((struct _GTypeInstance *)element)->g_class;
  struct _GList *tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(class->numpadtemplates == 0))
  {
    pads = class->padtemplates;
    while(!(pads == ((const struct _GList *)NULL)))
    {
      padtemplate = (struct _GstPadTemplate *)pads->data;
      if(!(pads == ((const struct _GList *)NULL)))
        tmp_if_expr$1 = ((struct _GList *)pads)->next;

      else
        tmp_if_expr$1 = (struct _GList *)(void *)0;
      pads = tmp_if_expr$1;
      if((signed int)padtemplate->direction == GST_PAD_SINK)
      {
        if((signed int)padtemplate->presence == GST_PAD_ALWAYS)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)padtemplate->presence == GST_PAD_SOMETIMES ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)padtemplate->presence == GST_PAD_REQUEST ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          if(!(padtemplate->caps == ((struct _GstCaps *)NULL)))
            scan_caps(padtemplate->caps);

        }

      }

    }
  }

}

// seek
// file upnp_transport.c line 971
static signed int seek(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    char *unit;
    unit=upnp_get_string(event, "Unit");
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(unit, "REL_TIME");
    if(return_value_strcmp$3 == 0)
    {
      char *target;
      target=upnp_get_string(event, "Target");
      signed long int nanos;
      nanos=parse_upnp_time(target);
      service_lock$link1();
      signed int return_value_output_seek$2;
      return_value_output_seek$2=output_seek(nanos);
      if(return_value_output_seek$2 == 0)
        replace_var$link1((enum anonymous$31)TRANSPORT_VAR_REL_TIME_POS, target);

      service_unlock$link1();
      free((void *)target);
    }

    free((void *)unit);
    return 0;
  }
}

// service_lock
// file upnp_control.c line 261
static void service_lock(void)
{
  pthread_mutex_lock(&control_mutex);
  if(!(control_service_.last_change == ((struct upnp_last_change_collector *)NULL)))
    UPnPLastChangeCollector_start(control_service_.last_change);

}

// service_lock$link1
// file upnp_transport.c line 508
static void service_lock$link1(void)
{
  pthread_mutex_lock(&transport_mutex);
  if(!(transport_service_.last_change == ((struct upnp_last_change_collector *)NULL)))
    UPnPLastChangeCollector_start(transport_service_.last_change);

}

// service_unlock
// file upnp_control.c line 269
static void service_unlock(void)
{
  if(!(control_service_.last_change == ((struct upnp_last_change_collector *)NULL)))
    UPnPLastChangeCollector_finish(control_service_.last_change);

  pthread_mutex_unlock(&control_mutex);
}

// service_unlock$link1
// file upnp_transport.c line 516
static void service_unlock$link1(void)
{
  if(!(transport_service_.last_change == ((struct upnp_last_change_collector *)NULL)))
    UPnPLastChangeCollector_finish(transport_service_.last_change);

  pthread_mutex_unlock(&transport_mutex);
}

// set_avtransport_uri
// file upnp_transport.c line 650
static signed int set_avtransport_uri(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    char *uri;
    uri=upnp_get_string(event, "CurrentURI");
    if(uri == ((char *)NULL))
      return -1;

    else
    {
      service_lock$link1();
      char *meta;
      meta=upnp_get_string(event, "CurrentURIMetaData");
      signed int requires_meta_update;
      requires_meta_update=replace_transport_uri_and_meta(uri, meta);
      if((signed int)transport_state_ == TRANSPORT_PLAYING)
        replace_current_uri_and_meta(uri, meta);

      output_set_uri(uri, requires_meta_update != 0 ? update_meta_from_stream : (void (*)(struct SongMetaData *meta))(void *)0);
      service_unlock$link1();
      free((void *)uri);
      free((void *)meta);
      return 0;
    }
  }
}

// set_mute
// file upnp_control.c line 619
static signed int set_mute(struct action_event *event)
{
  const char *value;
  value=upnp_get_string(event, "DesiredMute");
  service_lock();
  signed int do_mute;
  do_mute=atoi(value);
  set_mute_toggle(do_mute);
  replace_var((enum anonymous$19)CONTROL_VAR_MUTE, do_mute != 0 ? "1" : "0");
  service_unlock();
  return 0;
}

// set_mute_toggle
// file upnp_control.c line 614
static void set_mute_toggle(signed int do_mute)
{
  replace_var((enum anonymous$19)CONTROL_VAR_MUTE, do_mute != 0 ? "1" : "0");
  output_set_mute(do_mute);
}

// set_next_avtransport_uri
// file upnp_transport.c line 685
static signed int set_next_avtransport_uri(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    char *next_uri;
    next_uri=upnp_get_string(event, "NextURI");
    if(next_uri == ((char *)NULL))
      return -1;

    else
    {
      signed int rc = 0;
      service_lock$link1();
      output_set_next_uri(next_uri);
      replace_var$link1((enum anonymous$31)TRANSPORT_VAR_NEXT_AV_URI, next_uri);
      char *next_uri_meta;
      next_uri_meta=upnp_get_string(event, "NextURIMetaData");
      if(next_uri_meta == ((char *)NULL))
        rc = -1;

      else
        replace_var$link1((enum anonymous$31)TRANSPORT_VAR_NEXT_AV_URI_META, next_uri_meta);
      service_unlock$link1();
      free((void *)next_uri);
      free((void *)next_uri_meta);
      return rc;
    }
  }
}

// set_volume
// file upnp_control.c line 695
static signed int set_volume(struct action_event *event)
{
  const char *volume;
  volume=upnp_get_string(event, "DesiredVolume");
  service_lock();
  signed int volume_level;
  volume_level=atoi(volume);
  if(!((signed long int)volume_level >= volume_range.min))
    volume_level = (signed int)volume_range.min;

  if(!(volume_range.max >= (signed long int)volume_level))
    volume_level = (signed int)volume_range.max;

  float decibel;
  decibel=volume_level_to_decibel(volume_level);
  char db_volume[10l];
  snprintf(db_volume, sizeof(char [10l]) /*10ul*/ , "%d", (signed int)((float)256 * decibel));
  double fraction;
  double return_value_log$1;
  return_value_log$1=log((double)10);
  fraction=exp((double)(decibel / (float)20) * return_value_log$1);
  change_volume(volume, db_volume);
  output_set_volume((float)fraction);
  set_mute_toggle((signed int)(volume_level == 0));
  service_unlock();
  return 0;
}

// set_volume_db
// file upnp_control.c line 683
static signed int set_volume_db(struct action_event *event)
{
  const char *str_decibel_in;
  str_decibel_in=upnp_get_string(event, "DesiredVolume");
  service_lock();
  float raw_decibel_in;
  double return_value_atof$1;
  return_value_atof$1=atof(str_decibel_in);
  raw_decibel_in = (float)return_value_atof$1;
  float decibel;
  decibel=change_volume_decibel(raw_decibel_in);
  double return_value_log$2;
  return_value_log$2=log((double)10);
  double return_value_exp$3;
  return_value_exp$3=exp((double)(decibel / (float)20) * return_value_log$2);
  output_set_volume((float)return_value_exp$3);
  service_unlock();
  return 0;
}

// stop
// file upnp_transport.c line 832
static signed int stop(struct action_event *event)
{
  signed int return_value_obtain_instanceid$1;
  return_value_obtain_instanceid$1=obtain_instanceid(event, (signed int *)(void *)0);
  const char *return_value_get_var$2;
  if(!(return_value_obtain_instanceid$1 >= 0))
    return -1;

  else
  {
    service_lock$link1();
    switch((signed int)transport_state_)
    {
      case TRANSPORT_STOPPED:
        break;
      case TRANSPORT_PLAYING:

      case TRANSPORT_TRANSITIONING:

      case TRANSPORT_PAUSED_RECORDING:

      case TRANSPORT_RECORDING:

      case TRANSPORT_PAUSED_PLAYBACK:
      {
        output_stop();
        change_transport_state((enum transport_state)TRANSPORT_STOPPED);
        break;
      }
      case TRANSPORT_NO_MEDIA_PRESENT:
      {
        return_value_get_var$2=get_var((enum anonymous$31)TRANSPORT_VAR_CUR_TRANSPORT_ACTIONS);
        upnp_set_error(event, 701, "Transition to STOP not allowed; allowed=%s", return_value_get_var$2);
      }
    }
    service_unlock$link1();
    return 0;
  }
}

// thread_update_track_time
// file upnp_transport.c line 777
static void * thread_update_track_time(void *userdata)
{
  const signed long int one_sec_unit = 1000000000LL;
  char tbuf[32l];
  signed long int last_duration = (signed long int)-1;
  signed long int last_position = (signed long int)-1;
  do
  {
    usleep((unsigned int)500000);
    service_lock$link1();
    signed long int duration;
    signed long int position;
    signed int pos_result;
    pos_result=output_get_position(&duration, &position);
    if(pos_result == 0)
    {
      if(!(duration == last_duration))
      {
        print_upnp_time(tbuf, sizeof(char [32l]) /*32ul*/ , duration);
        replace_var$link1((enum anonymous$31)TRANSPORT_VAR_CUR_TRACK_DUR, tbuf);
        last_duration = duration;
      }

      if(!(position / one_sec_unit == last_position))
      {
        print_upnp_time(tbuf, sizeof(char [32l]) /*32ul*/ , position);
        replace_var$link1((enum anonymous$31)TRANSPORT_VAR_REL_TIME_POS, tbuf);
        last_position = position / one_sec_unit;
      }

    }

    service_unlock$link1();
  }
  while((_Bool)1);
  return (void *)0;
}

// to_idoc
// file xmldoc.c line 44
static struct _IXML_Document * to_idoc(struct xmldoc *x)
{
  return (struct _IXML_Document *)x;
}

// to_ielem
// file xmldoc.c line 48
static struct _IXML_Element * to_ielem(struct xmlelement *x)
{
  return (struct _IXML_Element *)x;
}

// update_meta_from_stream
// file upnp_transport.c line 635
static void update_meta_from_stream(struct SongMetaData *meta)
{
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(meta->title == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strlen$1=strlen(meta->title);
    tmp_if_expr$2 = return_value_strlen$1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$2)
  {
    const char *original_xml;
    original_xml=get_var((enum anonymous$31)TRANSPORT_VAR_AV_URI_META);
    char *didl;
    didl=SongMetaData_to_DIDL(meta, original_xml);
    service_lock$link1();
    replace_var$link1((enum anonymous$31)TRANSPORT_VAR_AV_URI_META, didl);
    replace_var$link1((enum anonymous$31)TRANSPORT_VAR_CUR_TRACK_META, didl);
    service_unlock$link1();
    free((void *)didl);
  }

}

// upnp_add_response
// file upnp_device.h line 56
signed int upnp_add_response(struct action_event *event, const char *key, const char *value)
{
  /* assertion event != ((void *)0) */
  assert(event != (struct action_event *)(void *)0);
  /* assertion key != ((void *)0) */
  assert(key != (const char *)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  if(!(event->status == 0))
    return -1;

  else
  {
    signed int rc;
    rc=UpnpAddToActionResponse(&event->request->ActionResult, event->request->ActionName, event->service->service_type, key, value);
    if(!(rc == 0))
    {
      event->request->ActionResult = (struct _IXML_Document *)(void *)0;
      event->request->ErrCode = 501;
      const char *return_value_UpnpGetErrorMessage$1;
      return_value_UpnpGetErrorMessage$1=UpnpGetErrorMessage(rc);
      strcpy(event->request->ErrStr, return_value_UpnpGetErrorMessage$1);
      return -1;
    }

    return 0;
  }
}

// upnp_append_variable
// file upnp_device.h line 67
void upnp_append_variable(struct action_event *event, signed int varnum, const char *paramname)
{
  const char *value;
  struct service *service = event->service;
  /* assertion event != ((void *)0) */
  assert(event != (struct action_event *)(void *)0);
  /* assertion paramname != ((void *)0) */
  assert(paramname != (const char *)(void *)0);
  pthread_mutex_lock(service->service_mutex);
  value=VariableContainer_get(service->variable_container, varnum, (const char **)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  upnp_add_response(event, paramname, value);
  pthread_mutex_unlock(service->service_mutex);
}

// upnp_connmgr_get_service
// file upnp_connmgr.c line 347
struct service * upnp_connmgr_get_service(void)
{
  if(connmgr_service_.variable_container == ((struct variable_container *)NULL))
    connmgr_service_.variable_container=VariableContainer_new(11, connmgr_variable_names, connmgr_default_values);

  return &connmgr_service_;
}

// upnp_control_get_service
// file upnp_control.c line 779
struct service * upnp_control_get_service(void)
{
  if(control_service_.variable_container == ((struct variable_container *)NULL))
  {
    state_variables_=VariableContainer_new(CONTROL_VAR_COUNT, control_variable_names, control_default_values);
    control_service_.variable_container = state_variables_;
  }

  return &control_service_;
}

// upnp_control_init
// file upnp_control.h line 30
void upnp_control_init(struct upnp_device *device)
{
  upnp_control_get_service();
  float volume_fraction = (float)0;
  signed int return_value_output_get_volume$3;
  return_value_output_get_volume$3=output_get_volume(&volume_fraction);
  if(return_value_output_get_volume$3 == 0)
  {
    Log_info("control", "Output inital volume is %f; setting control variables accordingly.", volume_fraction);
    double return_value_log$1;
    return_value_log$1=log((double)volume_fraction);
    double return_value_log$2;
    return_value_log$2=log((double)10);
    change_volume_decibel((float)(((double)20 * return_value_log$1) / return_value_log$2));
  }

  /* assertion control_service_.last_change == ((void *)0) */
  assert(control_service_.last_change == (struct upnp_last_change_collector *)(void *)0);
  control_service_.last_change=UPnPLastChangeCollector_new(state_variables_, "urn:schemas-upnp-org:metadata-1-0/RCS/", device, "urn:upnp-org:serviceId:RenderingControl");
  UPnPLastChangeCollector_add_ignore(control_service_.last_change, CONTROL_VAR_AAT_CHANNEL);
  UPnPLastChangeCollector_add_ignore(control_service_.last_change, CONTROL_VAR_AAT_INSTANCE_ID);
  UPnPLastChangeCollector_add_ignore(control_service_.last_change, CONTROL_VAR_AAT_PRESET_NAME);
}

// upnp_control_register_variable_listener
// file upnp_control.h line 32
void upnp_control_register_variable_listener(void (*cb)(void *, signed int, const char *, const char *, const char *), void *userdata)
{
  VariableContainer_register_callback(state_variables_, cb, userdata);
}

// upnp_create_device_desc
// file upnp_device.h line 80
char * upnp_create_device_desc(struct upnp_device_descriptor *device_def)
{
  char *result = (char *)(void *)0;
  struct xmldoc *doc;
  doc=generate_desc(device_def);
  if(!(doc == ((struct xmldoc *)NULL)))
  {
    result=xmldoc_tostring(doc);
    xmldoc_free(doc);
  }

  return result;
}

// upnp_device_init
// file upnp_device.h line 50
struct upnp_device * upnp_device_init(struct upnp_device_descriptor *device_def, const char *ip_address, unsigned short int port)
{
  signed int rc;
  char *buf;
  struct service *srv;
  struct icon *icon_entry;
  /* assertion device_def != ((void *)0) */
  assert(device_def != (struct upnp_device_descriptor *)(void *)0);
  if(!(device_def->init_function == ((signed int (*)(void))NULL)))
  {
    rc=device_def->init_function();
    return (struct upnp_device *)(void *)0;
  }

  else
  {
    struct upnp_device *result_device;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct upnp_device) /*56ul*/ );
    result_device = (struct upnp_device *)return_value_malloc$1;
    result_device->upnp_device_descriptor = device_def;
    pthread_mutex_init(&result_device->device_mutex, (const union anonymous$23 *)(void *)0);
    signed int i = 0;
    do
    {
      icon_entry = device_def->icons[(signed long int)i];
      if(icon_entry == ((struct icon *)NULL))
        break;

      webserver_register_file(icon_entry->url, "image/png");
      i = i + 1;
    }
    while((_Bool)1);
    signed int upnp_device_init$$1$$3$$i = 0;
    do
    {
      srv = device_def->services[(signed long int)upnp_device_init$$1$$3$$i];
      if(srv == ((struct service *)NULL))
        break;

      buf=upnp_get_scpd(srv);
      /* assertion buf != ((void *)0) */
      assert(buf != (char *)(void *)0);
      webserver_register_buf(srv->scpd_url, buf, "text/xml");
      upnp_device_init$$1$$3$$i = upnp_device_init$$1$$3$$i + 1;
    }
    while((_Bool)1);
    signed int return_value_initialize_device$2;
    return_value_initialize_device$2=initialize_device(device_def, result_device, ip_address, port);
    if(return_value_initialize_device$2 == 0)
    {
      UpnpFinish();
      free((void *)result_device);
      return (struct upnp_device *)(void *)0;
    }

    else
      return result_device;
  }
}

// upnp_device_notify
// file upnp_device.h line 70
signed int upnp_device_notify(struct upnp_device *device, const char *serviceID, const char **varnames, const char **varvalues, signed int varcount)
{
  UpnpNotify(device->device_handle, device->upnp_device_descriptor->udn, serviceID, varnames, varvalues, varcount);
  return 0;
}

// upnp_device_shutdown
// file upnp_device.h line 54
void upnp_device_shutdown(struct upnp_device *device)
{
  UpnpFinish();
}

// upnp_get_scpd
// file upnp.c line 213
char * upnp_get_scpd(struct service *srv)
{
  char *result = (char *)(void *)0;
  struct xmldoc *doc;
  doc=generate_scpd(srv);
  if(!(doc == ((struct xmldoc *)NULL)))
  {
    result=xmldoc_tostring(doc);
    xmldoc_free(doc);
  }

  return result;
}

// upnp_get_string
// file upnp_device.h line 62
char * upnp_get_string(struct action_event *event, const char *key)
{
  struct _IXML_Node *node = (struct _IXML_Node *)event->request->ActionRequest;
  const char *tmp_if_expr$2;
  const char *return_value_ixmlNode_getNodeValue$1;
  if(node == ((struct _IXML_Node *)NULL))
  {
    upnp_set_error(event, 402, "Invalid action request document");
    return (char *)(void *)0;
  }

  else
  {
    node=ixmlNode_getFirstChild(node);
    if(node == ((struct _IXML_Node *)NULL))
    {
      upnp_set_error(event, 402, "Invalid action request document");
      return (char *)(void *)0;
    }

    else
    {
      node=ixmlNode_getFirstChild(node);
      while(!(node == ((struct _IXML_Node *)NULL)))
      {
        const char *return_value_ixmlNode_getNodeName$4;
        return_value_ixmlNode_getNodeName$4=ixmlNode_getNodeName(node);
        signed int return_value_strcmp$5;
        return_value_strcmp$5=strcmp(return_value_ixmlNode_getNodeName$4, key);
        if(return_value_strcmp$5 == 0)
        {
          node=ixmlNode_getFirstChild(node);
          const char *node_value;
          if(!(node == ((struct _IXML_Node *)NULL)))
          {
            return_value_ixmlNode_getNodeValue$1=ixmlNode_getNodeValue(node);
            tmp_if_expr$2 = return_value_ixmlNode_getNodeValue$1;
          }

          else
            tmp_if_expr$2 = (const char *)(void *)0;
          node_value = tmp_if_expr$2;
          char *return_value_strdup$3;
          return_value_strdup$3=strdup(node_value != (const char *)(void *)0 ? node_value : "");
          return return_value_strdup$3;
        }

        node=ixmlNode_getNextSibling(node);
      }
      upnp_set_error(event, 402, "Missing action request argument (%s)", key);
      return (char *)(void *)0;
    }
  }
}

// upnp_renderer_descriptor
// file upnp_renderer.h line 32
struct upnp_device_descriptor * upnp_renderer_descriptor(const char *friendly_name, const char *uuid)
{
  render_device.friendly_name = friendly_name;
  char *udn = (char *)(void *)0;
  signed int return_value_asprintf$1;
  return_value_asprintf$1=asprintf(&udn, "uuid:%s", uuid);
  if(return_value_asprintf$1 >= 1)
    render_device.udn = udn;

  return &render_device;
}

// upnp_renderer_dump_connmgr_scpd
// file upnp_renderer.h line 27
void upnp_renderer_dump_connmgr_scpd(void)
{
  char *buf;
  struct service *return_value_upnp_connmgr_get_service$1;
  return_value_upnp_connmgr_get_service$1=upnp_connmgr_get_service();
  buf=upnp_get_scpd(return_value_upnp_connmgr_get_service$1);
  /* assertion buf != ((void *)0) */
  assert(buf != (char *)(void *)0);
  fputs(buf, stdout);
}

// upnp_renderer_dump_control_scpd
// file upnp_renderer.h line 28
void upnp_renderer_dump_control_scpd(void)
{
  char *buf;
  struct service *return_value_upnp_control_get_service$1;
  return_value_upnp_control_get_service$1=upnp_control_get_service();
  buf=upnp_get_scpd(return_value_upnp_control_get_service$1);
  /* assertion buf != ((void *)0) */
  assert(buf != (char *)(void *)0);
  fputs(buf, stdout);
}

// upnp_renderer_dump_transport_scpd
// file upnp_renderer.h line 29
void upnp_renderer_dump_transport_scpd(void)
{
  char *buf;
  struct service *return_value_upnp_transport_get_service$1;
  return_value_upnp_transport_get_service$1=upnp_transport_get_service();
  buf=upnp_get_scpd(return_value_upnp_transport_get_service$1);
  /* assertion buf != ((void *)0) */
  assert(buf != (char *)(void *)0);
  fputs(buf, stdout);
}

// upnp_renderer_init
// file upnp_renderer.c line 116
static signed int upnp_renderer_init(void)
{
  static struct service *upnp_services[4l];
  upnp_services[(signed long int)0]=upnp_transport_get_service();
  upnp_services[(signed long int)1]=upnp_connmgr_get_service();
  upnp_services[(signed long int)2]=upnp_control_get_service();
  upnp_services[(signed long int)3] = (struct service *)(void *)0;
  render_device.services = upnp_services;
  signed int return_value_connmgr_init$1;
  return_value_connmgr_init$1=connmgr_init();
  return return_value_connmgr_init$1;
}

// upnp_set_error
// file upnp_device.h line 58
void upnp_set_error(struct action_event *event, signed int error_code, const char *format, ...)
{
  event->status = -1;
  void **ap = (void **)&format;
  event->request->ActionResult = (struct _IXML_Document *)(void *)0;
  event->request->ErrCode = 501;
  vsnprintf(event->request->ErrStr, sizeof(char [180l]) /*180ul*/ , format, ap);
  ap = ((void **)NULL);
  Log_error("upnp", "%s: %s\n", (const void *)"upnp_set_error", (const void *)event->request->ErrStr);
}

// upnp_transport_get_service
// file upnp_transport.c line 1019
struct service * upnp_transport_get_service(void)
{
  if(transport_service_.variable_container == ((struct variable_container *)NULL))
  {
    state_variables_$link1=VariableContainer_new(TRANSPORT_VAR_COUNT, transport_variable_names, transport_default_values);
    transport_service_.variable_container = state_variables_$link1;
  }

  return &transport_service_;
}

// upnp_transport_init
// file upnp_transport.h line 33
void upnp_transport_init(struct upnp_device *device)
{
  /* assertion transport_service_.last_change == ((void *)0) */
  assert(transport_service_.last_change == (struct upnp_last_change_collector *)(void *)0);
  transport_service_.last_change=UPnPLastChangeCollector_new(state_variables_$link1, "urn:schemas-upnp-org:metadata-1-0/AVT/", device, "urn:upnp-org:serviceId:AVTransport");
  UPnPLastChangeCollector_add_ignore(transport_service_.last_change, TRANSPORT_VAR_REL_TIME_POS);
  UPnPLastChangeCollector_add_ignore(transport_service_.last_change, TRANSPORT_VAR_ABS_TIME_POS);
  UPnPLastChangeCollector_add_ignore(transport_service_.last_change, TRANSPORT_VAR_REL_CTR_POS);
  UPnPLastChangeCollector_add_ignore(transport_service_.last_change, TRANSPORT_VAR_ABS_CTR_POS);
  unsigned long int thread;
  pthread_create(&thread, (const union pthread_attr_t *)(void *)0, thread_update_track_time, (void *)0);
}

// upnp_transport_register_variable_listener
// file upnp_transport.h line 37
void upnp_transport_register_variable_listener(void (*cb)(void *, signed int, const char *, const char *, const char *), void *userdata)
{
  VariableContainer_register_callback(state_variables_$link1, cb, userdata);
}

// volume_decibel_to_level
// file upnp_control.c line 651
static signed int volume_decibel_to_level(float decibel)
{
  if(decibel < vol_min_db)
    return (signed int)volume_range.min;

  else
    if(decibel > vol_max_db)
      return (signed int)volume_range.max;

    else
      if(decibel < vol_mid_db)
        return (signed int)(((decibel - vol_min_db) * (float)vol_mid_point) / (vol_mid_db - vol_min_db));

      else
      {
        const signed int range = (const signed int)(volume_range.max - (signed long int)vol_mid_point);
        return (signed int)(((decibel - vol_mid_db) * (float)range) / (vol_max_db - vol_mid_db) + (float)vol_mid_point);
      }
}

// volume_level_to_decibel
// file upnp_control.c line 636
static float volume_level_to_decibel(signed int volume)
{
  if(!((signed long int)volume >= volume_range.min))
    volume = (signed int)volume_range.min;

  if(!(volume_range.max >= (signed long int)volume))
    volume = (signed int)volume_range.max;

  if(!((signed long int)volume >= volume_range.max / 2l))
    return vol_min_db + ((vol_mid_db - vol_min_db) / (float)vol_mid_point) * (float)volume;

  else
  {
    const signed int range = (const signed int)(volume_range.max - (signed long int)vol_mid_point);
    return vol_mid_db + ((vol_max_db - vol_mid_db) / (float)range) * (float)(volume - vol_mid_point);
  }
}

// webserver_close
// file webserver.c line 246
static signed int webserver_close(void *fh)
{
  struct anonymous$28 *file = (struct anonymous$28 *)fh;
  free((void *)file);
  return 0;
}

// webserver_get_info
// file webserver.c line 145
static signed int webserver_get_info(const char *filename, struct File_Info *info)
{
  struct virtual_file *virtfile = virtual_files;
  while(!(virtfile == ((struct virtual_file *)NULL)))
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(filename, virtfile->virtual_fname);
    if(return_value_strcmp$1 == 0)
    {
      info->file_length = (signed long int)virtfile->len;
      info->last_modified = (signed long int)0;
      info->is_directory = 0;
      info->is_readable = 1;
      info->content_type=ixmlCloneDOMString(virtfile->content_type);
      Log_info("webserver", "Access %s (%s) len=%zd", filename, info->content_type, virtfile->len);
      return 0;
    }

    virtfile = virtfile->next;
  }
  Log_info("webserver", "404 Not found. (attempt to access non-existent '%s')", filename);
  return -1;
}

// webserver_open
// file webserver.c line 171
static void * webserver_open(const char *filename, enum UpnpOpenFileMode mode)
{
  if(!((signed int)mode == UPNP_READ))
  {
    Log_error("webserver", "%s: ignoring request to open file for writing.", filename);
    return (void *)0;
  }

  else
  {
    struct virtual_file *vf = virtual_files;
    for( ; !(vf == ((struct virtual_file *)NULL)); vf = vf->next)
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(filename, vf->virtual_fname);
      if(return_value_strcmp$2 == 0)
      {
        struct anonymous$28 *file;
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(sizeof(struct anonymous$28) /*24ul*/ );
        file = (struct anonymous$28 *)return_value_malloc$1;
        file->pos = (signed long int)0;
        file->len = vf->len;
        file->contents = vf->contents;
        return (void *)file;
      }

    }
    return (void *)0;
  }
}

// webserver_read
// file webserver.c line 198
static signed int webserver_read(void *fh, char *buf, unsigned long int buflen)
{
  struct anonymous$28 *file = (struct anonymous$28 *)fh;
  signed long int len = (signed long int)-1;
  signed int return_value_minimum$1;
  return_value_minimum$1=minimum((signed int)buflen, (signed int)(file->len - (unsigned long int)file->pos));
  len = (signed long int)return_value_minimum$1;
  memcpy((void *)buf, (const void *)(file->contents + file->pos), (unsigned long int)len);
  if(!(len >= 0l))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    error(0, *return_value___errno_location$2, "%s failed", (const void *)"webserver_read");
  }

  else
    file->pos = file->pos + len;
  return (signed int)len;
}

// webserver_register_buf
// file webserver.h line 32
signed int webserver_register_buf(const char *path, const char *contents, const char *content_type)
{
  struct virtual_file *entry;
  Log_info("webserver", "Provide %s (%s) from buffer", path, content_type);
  /* assertion path != ((void *)0) */
  assert(path != (const char *)(void *)0);
  /* assertion contents != ((void *)0) */
  assert(contents != (const char *)(void *)0);
  /* assertion content_type != ((void *)0) */
  assert(content_type != (const char *)(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct virtual_file) /*40ul*/ );
  entry = (struct virtual_file *)return_value_malloc$1;
  if(entry == ((struct virtual_file *)NULL))
    return -1;

  else
  {
    entry->len=strlen(contents);
    entry->contents = contents;
    entry->virtual_fname = path;
    entry->content_type = content_type;
    entry->next = virtual_files;
    virtual_files = entry;
    return 0;
  }
}

// webserver_register_callbacks
// file webserver.h line 30
signed int webserver_register_callbacks(void)
{
  signed int result;
  signed int return_value_UpnpVirtualDir_set_GetInfoCallback$1;
  return_value_UpnpVirtualDir_set_GetInfoCallback$1=UpnpVirtualDir_set_GetInfoCallback(webserver_get_info);
  _Bool tmp_if_expr$3;
  signed int return_value_UpnpVirtualDir_set_OpenCallback$2;
  if(return_value_UpnpVirtualDir_set_GetInfoCallback$1 == 0)
  {
    return_value_UpnpVirtualDir_set_OpenCallback$2=UpnpVirtualDir_set_OpenCallback(webserver_open);
    tmp_if_expr$3 = return_value_UpnpVirtualDir_set_OpenCallback$2 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$5;
  signed int return_value_UpnpVirtualDir_set_ReadCallback$4;
  if(tmp_if_expr$3)
  {
    return_value_UpnpVirtualDir_set_ReadCallback$4=UpnpVirtualDir_set_ReadCallback(webserver_read);
    tmp_if_expr$5 = return_value_UpnpVirtualDir_set_ReadCallback$4 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  _Bool tmp_if_expr$7;
  signed int return_value_UpnpVirtualDir_set_WriteCallback$6;
  if(tmp_if_expr$5)
  {
    return_value_UpnpVirtualDir_set_WriteCallback$6=UpnpVirtualDir_set_WriteCallback(webserver_write);
    tmp_if_expr$7 = return_value_UpnpVirtualDir_set_WriteCallback$6 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  _Bool tmp_if_expr$9;
  signed int return_value_UpnpVirtualDir_set_SeekCallback$8;
  if(tmp_if_expr$7)
  {
    return_value_UpnpVirtualDir_set_SeekCallback$8=UpnpVirtualDir_set_SeekCallback(webserver_seek);
    tmp_if_expr$9 = return_value_UpnpVirtualDir_set_SeekCallback$8 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$9 = (_Bool)0;
  _Bool tmp_if_expr$11;
  signed int return_value_UpnpVirtualDir_set_CloseCallback$10;
  if(tmp_if_expr$9)
  {
    return_value_UpnpVirtualDir_set_CloseCallback$10=UpnpVirtualDir_set_CloseCallback(webserver_close);
    tmp_if_expr$11 = return_value_UpnpVirtualDir_set_CloseCallback$10 == 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$11 = (_Bool)0;
  result = (signed int)tmp_if_expr$11;
  return result;
}

// webserver_register_file
// file webserver.h line 34
signed int webserver_register_file(const char *path, const char *content_type)
{
  char local_fname[4096l];
  struct stat buf;
  struct virtual_file *entry;
  signed int rc;
  char *return_value_strrchr$1;
  return_value_strrchr$1=strrchr(path, 47);
  snprintf(local_fname, (unsigned long int)4096, "%s%s", (const void *)"/usr/share/gmediarender", return_value_strrchr$1);
  Log_info("webserver", "Provide %s (%s) from %s", path, content_type, (const void *)local_fname);
  rc=stat(local_fname, &buf);
  if(!(rc == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    error(0, *return_value___errno_location$2, "Could not stat '%s'", (const void *)local_fname);
    return -1;
  }

  void *return_value_malloc$3;
  return_value_malloc$3=malloc(sizeof(struct virtual_file) /*40ul*/ );
  entry = (struct virtual_file *)return_value_malloc$3;
  if(entry == ((struct virtual_file *)NULL))
    return -1;

  else
  {
    if(!(buf.st_size == 0l))
    {
      char *cbuf;
      struct _IO_FILE *in;
      in=fopen(local_fname, "r");
      if(in == ((struct _IO_FILE *)NULL))
      {
        free((void *)entry);
        return -1;
      }

      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)buf.st_size);
      cbuf = (char *)return_value_malloc$4;
      if(cbuf == ((char *)NULL))
      {
        free((void *)entry);
        return -1;
      }

      unsigned long int return_value_fread$5;
      return_value_fread$5=fread((void *)cbuf, (unsigned long int)buf.st_size, (unsigned long int)1, in);
      if(!(return_value_fread$5 == 1ul))
      {
        free((void *)entry);
        free((void *)cbuf);
        return -1;
      }

      fclose(in);
      entry->len = (unsigned long int)buf.st_size;
      entry->contents = cbuf;
    }

    else
    {
      entry->len = (unsigned long int)0;
      entry->contents = (const char *)(void *)0;
    }
    entry->virtual_fname = path;
    entry->content_type = content_type;
    entry->next = virtual_files;
    virtual_files = entry;
    return 0;
  }
}

// webserver_seek
// file webserver.c line 220
static signed int webserver_seek(void *fh, signed long int offset, signed int origin)
{
  struct anonymous$28 *file = (struct anonymous$28 *)fh;
  signed long int newpos = (signed long int)-1;
  switch(origin)
  {
    case 0:
    {
      newpos = offset;
      break;
    }
    case 1:
    {
      newpos = file->pos + offset;
      break;
    }
    case 2:
      newpos = (signed long int)(file->len + (unsigned long int)offset);
  }
  _Bool tmp_if_expr$2;
  if(!(newpos >= 0l))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (unsigned long int)newpos > file->len ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    error(0, *return_value___errno_location$1, "%s seek failed", (const void *)"webserver_seek");
    return -1;
  }

  file->pos = newpos;
  return 0;
}

// webserver_write
// file webserver.c line 215
static signed int webserver_write(void *fh, char *buf, unsigned long int buflen)
{
  return -1;
}

// xmldoc_free
// file xmldoc.h line 32
void xmldoc_free(struct xmldoc *doc)
{
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  struct _IXML_Document *return_value_to_idoc$1;
  return_value_to_idoc$1=to_idoc(doc);
  ixmlDocument_free(return_value_to_idoc$1);
}

// xmldoc_new
// file xmldoc.h line 30
struct xmldoc * xmldoc_new(void)
{
  struct _IXML_Document *doc;
  doc=ixmlDocument_createDocument();
  return (struct xmldoc *)doc;
}

// xmldoc_new_topelement
// file xmldoc.h line 36
struct xmlelement * xmldoc_new_topelement(struct xmldoc *doc, const char *elementName, const char *xmlns)
{
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  /* assertion elementName != ((void *)0) */
  assert(elementName != (const char *)(void *)0);
  struct _IXML_Element *element;
  if(!(xmlns == ((const char *)NULL)))
  {
    struct _IXML_Document *return_value_to_idoc$1;
    return_value_to_idoc$1=to_idoc(doc);
    element=ixmlDocument_createElementNS(return_value_to_idoc$1, xmlns, elementName);
    ixmlElement_setAttribute(element, "xmlns", xmlns);
  }

  else
  {
    struct _IXML_Document *return_value_to_idoc$2;
    return_value_to_idoc$2=to_idoc(doc);
    element=ixmlDocument_createElement(return_value_to_idoc$2, elementName);
  }
  struct _IXML_Document *return_value_to_idoc$3;
  return_value_to_idoc$3=to_idoc(doc);
  ixmlNode_appendChild((struct _IXML_Node *)return_value_to_idoc$3, (struct _IXML_Node *)element);
  return (struct xmlelement *)element;
}

// xmldoc_parsexml
// file xmldoc.h line 34
struct xmldoc * xmldoc_parsexml(const char *xml_text)
{
  struct _IXML_Document *doc;
  doc=ixmlParseBuffer(xml_text);
  return (struct xmldoc *)doc;
}

// xmldoc_tostring
// file xmldoc.h line 33
char * xmldoc_tostring(struct xmldoc *doc)
{
  char *result = (char *)(void *)0;
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  struct _IXML_Document *return_value_to_idoc$1;
  return_value_to_idoc$1=to_idoc(doc);
  result=ixmlDocumenttoString(return_value_to_idoc$1);
  return result;
}

// xmlelement_add_element
// file xmldoc.h line 42
void xmlelement_add_element(struct xmldoc *doc, struct xmlelement *parent, struct xmlelement *child)
{
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  /* assertion parent != ((void *)0) */
  assert(parent != (struct xmlelement *)(void *)0);
  /* assertion child != ((void *)0) */
  assert(child != (struct xmlelement *)(void *)0);
  struct _IXML_Element *return_value_to_ielem$1;
  return_value_to_ielem$1=to_ielem(parent);
  struct _IXML_Element *return_value_to_ielem$2;
  return_value_to_ielem$2=to_ielem(child);
  ixmlNode_appendChild((struct _IXML_Node *)return_value_to_ielem$1, (struct _IXML_Node *)return_value_to_ielem$2);
}

// xmlelement_add_text
// file xmldoc.c line 146
void xmlelement_add_text(struct xmldoc *doc, struct xmlelement *parent, const char *text)
{
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  /* assertion parent != ((void *)0) */
  assert(parent != (struct xmlelement *)(void *)0);
  /* assertion text != ((void *)0) */
  assert(text != (const char *)(void *)0);
  struct _IXML_Node *textNode;
  struct _IXML_Document *return_value_to_idoc$1;
  return_value_to_idoc$1=to_idoc(doc);
  textNode=ixmlDocument_createTextNode(return_value_to_idoc$1, text);
  struct _IXML_Element *return_value_to_ielem$2;
  return_value_to_ielem$2=to_ielem(parent);
  ixmlNode_appendChild((struct _IXML_Node *)return_value_to_ielem$2, textNode);
}

// xmlelement_new
// file xmldoc.h line 40
struct xmlelement * xmlelement_new(struct xmldoc *doc, const char *elementName)
{
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  /* assertion elementName != ((void *)0) */
  assert(elementName != (const char *)(void *)0);
  struct _IXML_Element *element;
  struct _IXML_Document *return_value_to_idoc$1;
  return_value_to_idoc$1=to_idoc(doc);
  element=ixmlDocument_createElement(return_value_to_idoc$1, elementName);
  return (struct xmlelement *)element;
}

// xmlelement_set_attribute
// file xmldoc.h line 48
void xmlelement_set_attribute(struct xmldoc *doc, struct xmlelement *element, const char *name, const char *value)
{
  /* assertion doc != ((void *)0) */
  assert(doc != (struct xmldoc *)(void *)0);
  /* assertion element != ((void *)0) */
  assert(element != (struct xmlelement *)(void *)0);
  /* assertion name != ((void *)0) */
  assert(name != (const char *)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  struct _IXML_Element *return_value_to_ielem$1;
  return_value_to_ielem$1=to_ielem(element);
  ixmlElement_setAttribute(return_value_to_ielem$1, name, value);
}

// xmlescape
// file xmlescape.h line 30
char * xmlescape(const char *str, signed int attribute)
{
  signed int len;
  char *out;
  xmlescape_real(str, (char *)(void *)0, &len, attribute);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(len + 1));
  out = (char *)return_value_malloc$1;
  xmlescape_real(str, out, (signed int *)(void *)0, attribute);
  return out;
}

// xmlescape_real
// file xmlescape.c line 34
static void xmlescape_real(const char *str, char *target, signed int *length, signed int attribute)
{
  _Bool tmp_if_expr$2;
  signed int tmp_post$1;
  _Bool tmp_if_expr$3;
  if(!(target == ((char *)NULL)))
  {
    signed int len = 0;
    for( ; !(*str == 0); str = str + 1l)
      if((signed int)*str == 60)
      {
        memcpy((void *)(target + (signed long int)len), (const void *)"&lt;", (unsigned long int)4);
        len = len + 4;
      }

      else
      {
        if(!(attribute == 0))
          tmp_if_expr$2 = (signed int)*str == 34 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          memcpy((void *)(target + (signed long int)len), (const void *)"%22", (unsigned long int)3);
          len = len + 3;
        }

        else
          if((signed int)*str == 62)
          {
            memcpy((void *)(target + (signed long int)len), (const void *)"&gt;", (unsigned long int)4);
            len = len + 4;
          }

          else
            if((signed int)*str == 38)
            {
              memcpy((void *)(target + (signed long int)len), (const void *)"&amp;", (unsigned long int)5);
              len = len + 5;
            }

            else
            {
              tmp_post$1 = len;
              len = len + 1;
              target[(signed long int)tmp_post$1] = *str;
            }
      }
    target[(signed long int)len] = (char)0;
    if(!(length == ((signed int *)NULL)))
      *length = len;

  }

  else
    if(!(length == ((signed int *)NULL)))
    {
      signed int xmlescape_real$$1$$2$$len = 0;
      for( ; !(*str == 0); str = str + 1l)
        if((signed int)*str == 60)
          xmlescape_real$$1$$2$$len = xmlescape_real$$1$$2$$len + 4;

        else
        {
          if(!(attribute == 0))
            tmp_if_expr$3 = (signed int)*str == 34 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            xmlescape_real$$1$$2$$len = xmlescape_real$$1$$2$$len + 3;

          else
            if((signed int)*str == 62)
              xmlescape_real$$1$$2$$len = xmlescape_real$$1$$2$$len + 4;

            else
              if((signed int)*str == 38)
                xmlescape_real$$1$$2$$len = xmlescape_real$$1$$2$$len + 5;

              else
                xmlescape_real$$1$$2$$len = xmlescape_real$$1$$2$$len + 1;
        }
      *length = xmlescape_real$$1$$2$$len;
    }

}

