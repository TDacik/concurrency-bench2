// #anon_enum_GNUTLS_CRD_CERTIFICATE=1_GNUTLS_CRD_ANON=2_GNUTLS_CRD_SRP=3_GNUTLS_CRD_PSK=4_GNUTLS_CRD_IA=5
// file /usr/include/gnutls/gnutls.h line 222
enum anonymous_45 { GNUTLS_CRD_CERTIFICATE=1, GNUTLS_CRD_ANON=2, GNUTLS_CRD_SRP=3, GNUTLS_CRD_PSK=4, GNUTLS_CRD_IA=5 };

// #anon_enum_GNUTLS_SHUT_RDWR=0_GNUTLS_SHUT_WR=1
// file /usr/include/gnutls/gnutls.h line 554
enum anonymous_46 { GNUTLS_SHUT_RDWR=0, GNUTLS_SHUT_WR=1 };

// #anon_enum_GNUTLS_SSL3=1_GNUTLS_TLS1_0=2_GNUTLS_TLS1=2_GNUTLS_TLS1_1=3_GNUTLS_TLS1_2=4_GNUTLS_DTLS0_9=200_GNUTLS_DTLS1_0=201_GNUTLS_DTLS1_2=202_GNUTLS_DTLS_VERSION_MIN=200_GNUTLS_DTLS_VERSION_MAX=202_GNUTLS_TLS_VERSION_MAX=4_GNUTLS_VERSION_UNKNOWN=255
// file /usr/include/gnutls/gnutls.h line 574
enum anonymous_47 { GNUTLS_SSL3=1, GNUTLS_TLS1_0=2, GNUTLS_TLS1=2, GNUTLS_TLS1_1=3, GNUTLS_TLS1_2=4, GNUTLS_DTLS0_9=200, GNUTLS_DTLS1_0=201, GNUTLS_DTLS1_2=202, GNUTLS_DTLS_VERSION_MIN=200, GNUTLS_DTLS_VERSION_MAX=202, GNUTLS_TLS_VERSION_MAX=4, GNUTLS_VERSION_UNKNOWN=255 };

// #anon_enum_GNUTLS_X509_FMT_DER=0_GNUTLS_X509_FMT_PEM=1
// file /usr/include/gnutls/gnutls.h line 613
enum anonymous_44 { GNUTLS_X509_FMT_DER=0, GNUTLS_X509_FMT_PEM=1 };

// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous_32 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_37 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum_JDITHER_NONE=0_JDITHER_ORDERED=1_JDITHER_FS=2
// file /usr/include/jpeglib.h line 259
enum anonymous_38 { JDITHER_NONE=0, JDITHER_ORDERED=1, JDITHER_FS=2 };

// #anon_enum_RFB_PROTOCOL_VERSION=0_RFB_SECURITY_TYPE=1_RFB_AUTHENTICATION=2_RFB_INITIALISATION=3_RFB_NORMAL=4_RFB_INITIALISATION_SHARED=5
// file ../rfb/rfb.h line 498
enum anonymous_13 { RFB_PROTOCOL_VERSION=0, RFB_SECURITY_TYPE=1, RFB_AUTHENTICATION=2, RFB_INITIALISATION=3, RFB_NORMAL=4, RFB_INITIALISATION_SHARED=5 };

// #anon_enum_SELECTING=0_OK=1_CANCEL=2
// file selbox.c line 19
enum anonymous_48 { SELECTING=0, OK=1, CANCEL=2 };

// tag-#anon#ST[*{SYM#tag-_rfbScreenInfo#}_SYM#tag-_rfbScreenInfo#_'screen'||*{SYM#tag-rfbFontData#}_SYM#tag-rfbFontData#_'font'||*{*{S8}_S8_}_*{S8}_S8__'list'||S32'listSize'||S32'selected'||S32'displayStart'||S32'x1'||S32'y1'||S32'x2'||S32'y2'||S32'textH'||S32'pageH'||S32'xhot'||S32'yhot'||S32'buttonWidth'||S32'okBX'||S32'cancelBX'||S32'okX'||S32'cancelX'||S32'okY'||S8'okInverted'||S8'cancelInverted'||U16'_pad0'||S32'lastButtons'||U32'colour'||U32'backColour'||U32'_pad1'||*{V(S32)->V}_V(S32)->V_'selChangedHook'||EN#anon_enum_SELECTING=0_OK=1_CANCEL=2#{U32}_U32_'state'||U32'_pad2'|]
// file selbox.c line 5
struct anonymous_49;

// tag-#anon#ST[*{U8}_U8_'start'||*{U8}_U8_'ptr'||*{U8}_U8_'end'|]
// file zrleoutstream.h line 28
struct anonymous_10;

// tag-#anon#ST[ARR127{U32}_U32_'palette'||ARR4223{U8}_U8_'index'||U8'_pad0'||ARR4223{U32}_U32_'key'||S32'size'|]
// file ./zrlepalettehelper.h line 33
struct anonymous_12;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_16;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_39;

// tag-#anon#ST[ARR17{U8}_U8_'bits'||ARR256{U8}_U8_'huffval'||U24'_pad0'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 101
struct anonymous_35;

// tag-#anon#ST[ARR32{U8}_U8_'client2server'||ARR32{U8}_U8_'server2client'|]
// file ../rfb/rfbproto.h line 568
struct anonymous_55;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 84
struct anonymous_33;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_20;

// tag-#anon#ST[S32'component_id'||S32'component_index'||S32'h_samp_factor'||S32'v_samp_factor'||S32'quant_tbl_no'||S32'dc_tbl_no'||S32'ac_tbl_no'||U32'width_in_blocks'||U32'height_in_blocks'||S32'DCT_scaled_size'||U32'downsampled_width'||U32'downsampled_height'||S32'component_needed'||S32'MCU_width'||S32'MCU_height'||S32'MCU_blocks'||S32'MCU_sample_width'||S32'last_col_width'||S32'last_row_height'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#_'quant_table'||*{V}_V_'dct_table'|]
// file /usr/include/jpeglib.h line 117
struct anonymous_34;

// tag-#anon#ST[S32'comps_in_scan'||ARR4{S32}_S32_'component_index'||S32'Ss'||S32'Se'||S32'Ah'||S32'Al'|]
// file /usr/include/jpeglib.h line 190
struct anonymous_36;

// tag-#anon#ST[S32'num'||S32'denom'|]
// file ../common/./turbojpeg.h line 258
struct anonymous_29;

// tag-#anon#ST[SYM#tag-#anon#ST[*{U8}_U8_'start'||*{U8}_U8_'ptr'||*{U8}_U8_'end'|]#'in'||SYM#tag-#anon#ST[*{U8}_U8_'start'||*{U8}_U8_'ptr'||*{U8}_U8_'end'|]#'out'||SYM#tag-z_stream_s#'zs'|]
// file zrleoutstream.h line 34
struct anonymous_11;

// tag-#anon#ST[SYM#tag-#anon#ST[U16'x'||U16'y'||U16'w'||U16'h'|]#'r'||U32'encoding'|]
// file ../rfb/rfbproto.h line 554
struct anonymous_2;

// tag-#anon#ST[U16'framebufferWidth'||U16'framebufferHeight'||SYM#tag-#anon#ST[U8'bitsPerPixel'||U8'depth'||U8'bigEndian'||U8'trueColour'||U16'redMax'||U16'greenMax'||U16'blueMax'||U8'redShift'||U8'greenShift'||U8'blueShift'||U8'pad1'||U16'pad2'|]#'format'||U32'nameLength'|]
// file ../rfb/rfbproto.h line 357
struct anonymous_50;

// tag-#anon#ST[U16'l16'||SYM#tag-ws_mask_s#'m16'|]
// file websockets.c line 109
struct anonymous_40;

// tag-#anon#ST[U16'srcX'||U16'srcY'|]
// file ../rfb/rfbproto.h line 616
struct anonymous_4;

// tag-#anon#ST[U16'x'||U16'y'||U16'w'||U16'h'|]
// file ../rfb/rfbproto.h line 137
struct anonymous_5;

// tag-#anon#ST[U32'count'||S8'is16'||U24'_pad0'||SYM#tag-#anon#UN[*{U8}_U8_'bytes'||*{U16}_U16_'shorts'|]#'data'|]
// file ../rfb/rfb.h line 175
struct anonymous_15;

// tag-#anon#ST[U32'dwFileAttributes'||SYM#tag-#anon#ST[U32'dwLowDateTime'||U32'dwHighDateTime'|]#'ftCreationTime'||SYM#tag-#anon#ST[U32'dwLowDateTime'||U32'dwHighDateTime'|]#'ftLastAccessTime'||SYM#tag-#anon#ST[U32'dwLowDateTime'||U32'dwHighDateTime'|]#'ftLastWriteTime'||U32'nFileSizeHigh'||U32'nFileSizeLow'||U32'dwReserved0'||U32'dwReserved1'||ARR260{U8}_U8_'cFileName'||ARR14{U8}_U8_'cAlternateFileName'||U16'_pad0'|]
// file rfbserver.c line 1240
struct anonymous_53;

// tag-#anon#ST[U32'dwLowDateTime'||U32'dwHighDateTime'|]
// file rfbserver.c line 1235
struct anonymous_52;

// tag-#anon#ST[U32'length'|]
// file ../rfb/rfbproto.h line 939
struct anonymous_18;

// tag-#anon#ST[U32'nBytes'|]
// file ../rfb/rfbproto.h line 715
struct anonymous_3;

// tag-#anon#ST[U32'nSubrects'|]
// file ../rfb/rfbproto.h line 631
struct anonymous_14;

// tag-#anon#ST[U64'l64'||SYM#tag-ws_mask_s#'m64'|]
// file websockets.c line 113
struct anonymous_41;

// tag-#anon#ST[U8'bitsPerPixel'||U8'depth'||U8'bigEndian'||U8'trueColour'||U16'redMax'||U16'greenMax'||U16'blueMax'||U8'redShift'||U8'greenShift'||U8'blueShift'||U8'pad1'||U16'pad2'|]
// file ../rfb/rfbproto.h line 151
struct anonymous_7;

// tag-#anon#ST[U8'foreRed'||U8'foreGreen'||U8'foreBlue'||U8'backRed'||U8'backGreen'||U8'backBlue'|]
// file ../rfb/rfbproto.h line 908
struct anonymous_43;

// tag-#anon#ST[U8'shared'|]
// file ../rfb/rfbproto.h line 342
struct anonymous_54;

// tag-#anon#ST[U8'type'|]
// file ../rfb/rfbproto.h line 992
struct anonymous_56;

// tag-#anon#ST[U8'type'||U8'buttonMask'||U16'x'||U16'y'|]
// file ../rfb/rfbproto.h line 1347
struct anonymous_28;

// tag-#anon#ST[U8'type'||U8'down'||U16'pad'||U32'key'|]
// file ../rfb/rfbproto.h line 1333
struct anonymous_27;

// tag-#anon#ST[U8'type'||U8'incremental'||U16'x'||U16'y'||U16'w'||U16'h'|]
// file ../rfb/rfbproto.h line 1290
struct anonymous_26;

// tag-#anon#ST[U8'type'||U8'pad'||U16'firstColour'||U16'nColours'|]
// file ../rfb/rfbproto.h line 973
struct anonymous_21;

// tag-#anon#ST[U8'type'||U8'pad'||U16'nEncodings'|]
// file ../rfb/rfbproto.h line 1274
struct anonymous_25;

// tag-#anon#ST[U8'type'||U8'pad'||U16'nRects'|]
// file ../rfb/rfbproto.h line 537
struct anonymous_57;

// tag-#anon#ST[U8'type'||U8'pad'||U8'version'||U8'code'|]
// file ../rfb/rfbproto.h line 1134
struct anonymous_23;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'desktop_w'||U16'desktop_h'||U16'buffer_w'||U16'buffer_h'||U16'pad2'|]
// file ../rfb/rfbproto.h line 1175
struct anonymous_8;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'pad2'||SYM#tag-#anon#ST[U8'bitsPerPixel'||U8'depth'||U8'bigEndian'||U8'trueColour'||U16'redMax'||U16'greenMax'||U16'blueMax'||U8'redShift'||U8'greenShift'||U8'blueShift'||U8'pad1'||U16'pad2'|]#'format'|]
// file ../rfb/rfbproto.h line 1237
struct anonymous_24;

// tag-#anon#ST[U8'type'||U8'pad1'||U16'pad2'||U32'length'|]
// file ../rfb/rfbproto.h line 1004
struct anonymous_22;

// tag-#anon#ST[U8'type'||U8'scale'||U16'pad2'|]
// file ../rfb/rfbproto.h line 1403
struct anonymous_30;

// tag-#anon#ST[U8'x'||U8'y'||U8'w'||U8'h'|]
// file ../rfb/rfbproto.h line 646
struct anonymous_17;

// tag-#anon#UN[*{U8}_U8_'bytes'||*{U16}_U16_'shorts'|]
// file ../rfb/rfb.h line 178
union anonymous_19;

// tag-#anon#UN[*{V}_V_'a00'||*{U8}_U8_'a01'||U64'a02'||U64'a03'||U64'a04'||*{V}_V_'a05'||*{U8}_U8_'a06'||U64'a07'||U64'a08'||S64'a09'||U64'a10'|]
// file ../common/lzoconf.h line 364
union anonymous_6;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_0;

// tag-#anon#UN[ARR8{S32}_S32_'i'||ARR80{S8}_S8_'s'|]
// file /usr/include/jpeglib.h line 736
union anonymous_31;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous;

// tag-#anon#UN[SYM#tag-#anon#ST[U16'l16'||SYM#tag-ws_mask_s#'m16'|]#'s16'||SYM#tag-#anon#ST[U64'l64'||SYM#tag-ws_mask_s#'m64'|]#'s64'||SYM#tag-ws_mask_s#'m'||U128'_pad'|]
// file websockets.c line 108
union anonymous_42;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_9;

// tag-#anon#UN[U8'type'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'pad2'||SYM#tag-#anon#ST[U8'bitsPerPixel'||U8'depth'||U8'bigEndian'||U8'trueColour'||U16'redMax'||U16'greenMax'||U16'blueMax'||U8'redShift'||U8'greenShift'||U8'blueShift'||U8'pad1'||U16'pad2'|]#'format'|]#'spf'||SYM#tag-#anon#ST[U8'type'||U8'pad'||U16'firstColour'||U16'nColours'|]#'fcme'||SYM#tag-#anon#ST[U8'type'||U8'pad'||U16'nEncodings'|]#'se'||SYM#tag-#anon#ST[U8'type'||U8'incremental'||U16'x'||U16'y'||U16'w'||U16'h'|]#'fur'||SYM#tag-#anon#ST[U8'type'||U8'down'||U16'pad'||U32'key'|]#'ke'||SYM#tag-#anon#ST[U8'type'||U8'buttonMask'||U16'x'||U16'y'|]#'pe'||SYM#tag-#anon#ST[U8'type'||U8'pad1'||U16'pad2'||U32'length'|]#'cct'||SYM#tag-_rfbSetScaleMsg#'ssc'||SYM#tag-#anon#ST[U8'type'||U8'scale'||U16'pad2'|]#'pssf'||SYM#tag-_rfbSetServerInputMsg#'sim'||SYM#tag-_rfbFileTransferMsg#'ft'||SYM#tag-_rfbSetSWMsg#'sw'||SYM#tag-_rfbTextChatMsg#'tc'||SYM#tag-#anon#ST[U8'type'||U8'pad'||U8'version'||U8'code'|]#'xvp'|]
// file ../rfb/rfbproto.h line 1446
union anonymous_1;

// tag-COLOR_LIST_s
// file tight.c line 120
struct COLOR_LIST_s;

// tag-PALETTE_ENTRY_s
// file tight.c line 126
struct PALETTE_ENTRY_s;

// tag-PALETTE_s
// file tight.c line 131
struct PALETTE_s;

// tag-TIGHT_CONF_s
// file tight.c line 75
struct TIGHT_CONF_s;

// tag-_FileListInfo
// file tightvnc-filetransfer/filelistinfo.h line 50
struct _FileListInfo;

// tag-_FileListItemInfo
// file tightvnc-filetransfer/filelistinfo.h line 39
struct _FileListItemInfo;

// tag-_FileListItemSize
// file tightvnc-filetransfer/filelistinfo.h line 45
struct _FileListItemSize;

// tag-_FileTransferMsg
// file tightvnc-filetransfer/filetransfermsg.h line 34
struct _FileTransferMsg;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_rect
// file ../rfb/rfbregion.h line 11
struct _rect;

// tag-_rfbAuthenticationCapsMsg
// file tightvnc-filetransfer/rfbtightproto.h line 90
struct _rfbAuthenticationCapsMsg;

// tag-_rfbCapabilityInfo
// file tightvnc-filetransfer/rfbtightproto.h line 120
struct _rfbCapabilityInfo;

// tag-_rfbClientFileDownload
// file tightvnc-filetransfer/rfbtightproto.h line 146
struct _rfbClientFileDownload;

// tag-_rfbClientFileTransfer
// file tightvnc-filetransfer/rfbtightproto.h line 161
struct _rfbClientFileTransfer;

// tag-_rfbClientFileUpload
// file tightvnc-filetransfer/rfbtightproto.h line 153
struct _rfbClientFileUpload;

// tag-_rfbClientRec
// file ../rfb/rfb.h line 127
struct _rfbClientRec;

// tag-_rfbClientToServerTightMsg
// file tightvnc-filetransfer/rfbtightproto.h line 381
union _rfbClientToServerTightMsg;

// tag-_rfbExtensionData
// file ../rfb/rfb.h line 223
struct _rfbExtensionData;

// tag-_rfbFileCreateDirRequestMsg
// file tightvnc-filetransfer/rfbtightproto.h line 367
struct _rfbFileCreateDirRequestMsg;

// tag-_rfbFileDownloadCancelMsg
// file tightvnc-filetransfer/rfbtightproto.h line 341
struct _rfbFileDownloadCancelMsg;

// tag-_rfbFileDownloadDataMsg
// file tightvnc-filetransfer/rfbtightproto.h line 413
struct _rfbFileDownloadDataMsg;

// tag-_rfbFileDownloadFailedMsg
// file tightvnc-filetransfer/rfbtightproto.h line 442
struct _rfbFileDownloadFailedMsg;

// tag-_rfbFileDownloadRequestMsg
// file tightvnc-filetransfer/rfbtightproto.h line 297
struct _rfbFileDownloadRequestMsg;

// tag-_rfbFileListDataMsg
// file tightvnc-filetransfer/rfbtightproto.h line 397
struct _rfbFileListDataMsg;

// tag-_rfbFileListRequestMsg
// file tightvnc-filetransfer/rfbtightproto.h line 284
struct _rfbFileListRequestMsg;

// tag-_rfbFileTransferData
// file ../rfb/rfb.h line 417
struct _rfbFileTransferData;

// tag-_rfbFileTransferMsg
// file ../rfb/rfbproto.h line 1021
struct _rfbFileTransferMsg;

// tag-_rfbFileUploadCancelMsg
// file tightvnc-filetransfer/rfbtightproto.h line 429
struct _rfbFileUploadCancelMsg;

// tag-_rfbFileUploadDataMsg
// file tightvnc-filetransfer/rfbtightproto.h line 326
struct _rfbFileUploadDataMsg;

// tag-_rfbFileUploadFailedMsg
// file tightvnc-filetransfer/rfbtightproto.h line 354
struct _rfbFileUploadFailedMsg;

// tag-_rfbFileUploadRequestMsg
// file tightvnc-filetransfer/rfbtightproto.h line 311
struct _rfbFileUploadRequestMsg;

// tag-_rfbInteractionCapsMsg
// file tightvnc-filetransfer/rfbtightproto.h line 217
struct _rfbInteractionCapsMsg;

// tag-_rfbProtocolExtension
// file ../rfb/rfb.h line 198
struct _rfbProtocolExtension;

// tag-_rfbResizeFrameBufferMsg
// file ../rfb/rfbproto.h line 1157
struct _rfbResizeFrameBufferMsg;

// tag-_rfbScreenInfo
// file ../rfb/rfb.h line 128
struct _rfbScreenInfo;

// tag-_rfbSecurity
// file ../rfb/rfb.h line 188
struct _rfbSecurity;

// tag-_rfbSetSWMsg
// file ../rfb/rfbproto.h line 1431
struct _rfbSetSWMsg;

// tag-_rfbSetScaleMsg
// file ../rfb/rfbproto.h line 1388
struct _rfbSetScaleMsg;

// tag-_rfbSetServerInputMsg
// file ../rfb/rfbproto.h line 1418
struct _rfbSetServerInputMsg;

// tag-_rfbSslCtx
// file ../rfb/rfb.h line 438
struct _rfbSslCtx;

// tag-_rfbStatList
// file ../rfb/rfb.h line 427
struct _rfbStatList;

// tag-_rfbTextChatMsg
// file ../rfb/rfbproto.h line 1097
struct _rfbTextChatMsg;

// tag-_rfbTightClientRec
// file tightvnc-filetransfer/rfbtightproto.h line 167
struct _rfbTightClientRec;

// tag-_rfbTunnelingCapsMsg
// file tightvnc-filetransfer/rfbtightproto.h line 57
struct _rfbTunnelingCapsMsg;

// tag-_tjinstance
// file ../common/turbojpeg.c line 87
struct _tjinstance;

// tag-_wsCtx
// file ../rfb/rfb.h line 439
struct _wsCtx;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-gcry_md_context
// file /usr/include/gcrypt.h line 1159
struct gcry_md_context;

// tag-gcry_md_handle
// file /usr/include/gcrypt.h line 1164
struct gcry_md_handle;

// tag-gnutls_certificate_credentials_st
// file /usr/include/gnutls/gnutls.h line 1399
struct gnutls_certificate_credentials_st;

// tag-gnutls_dh_params_int
// file /usr/include/gnutls/gnutls.h line 785
struct gnutls_dh_params_int;

// tag-gnutls_session_int
// file /usr/include/gnutls/gnutls.h line 782
struct gnutls_session_int;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_color_deconverter
// file /usr/include/jpeglib.h line 703
struct jpeg_color_deconverter;

// tag-jpeg_color_quantizer
// file /usr/include/jpeglib.h line 704
struct jpeg_color_quantizer;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_d_coef_controller
// file /usr/include/jpeglib.h line 696
struct jpeg_d_coef_controller;

// tag-jpeg_d_main_controller
// file /usr/include/jpeglib.h line 695
struct jpeg_d_main_controller;

// tag-jpeg_d_post_controller
// file /usr/include/jpeglib.h line 697
struct jpeg_d_post_controller;

// tag-jpeg_decomp_master
// file /usr/include/jpeglib.h line 694
struct jpeg_decomp_master;

// tag-jpeg_decompress_struct
// file /usr/include/jpeglib.h line 290
struct jpeg_decompress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_decoder
// file /usr/include/jpeglib.h line 700
struct jpeg_entropy_decoder;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_input_controller
// file /usr/include/jpeglib.h line 698
struct jpeg_input_controller;

// tag-jpeg_inverse_dct
// file /usr/include/jpeglib.h line 701
struct jpeg_inverse_dct;

// tag-jpeg_marker_reader
// file /usr/include/jpeglib.h line 699
struct jpeg_marker_reader;

// tag-jpeg_marker_struct
// file /usr/include/jpeglib.h line 199
struct jpeg_marker_struct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jpeg_source_mgr
// file /usr/include/jpeglib.h line 474
struct jpeg_source_mgr;

// tag-jpeg_upsampler
// file /usr/include/jpeglib.h line 702
struct jpeg_upsampler;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-lzo_callback_t
// file ../common/lzoconf.h line 265
struct lzo_callback_t;

// tag-lzo_config_check_union
// file ../common/minilzo.c line 4117
union lzo_config_check_union;

// tag-my_error_mgr
// file ../common/turbojpeg.c line 61
struct my_error_mgr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rfbClientIterator
// file ../rfb/rfb.h line 774
struct rfbClientIterator;

// tag-rfbCursor
// file ../rfb/rfb.h line 129
struct rfbCursor;

// tag-rfbFontData
// file ../rfb/rfb.h line 947
struct rfbFontData;

// tag-rfbNewClientAction
// file ../rfb/rfb.h line 131
enum rfbNewClientAction { RFB_CLIENT_ACCEPT=0, RFB_CLIENT_ON_HOLD=1, RFB_CLIENT_REFUSE=2 };

// tag-rfbSocketState
// file ../rfb/rfb.h line 137
enum rfbSocketState { RFB_SOCKET_INIT=0, RFB_SOCKET_READY=1, RFB_SOCKET_SHUTDOWN=2 };

// tag-rfbssl_ctx
// file rfbssl_gnutls.c line 28
struct rfbssl_ctx;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sraRectangleIterator
// file ../rfb/rfbregion.h line 44
struct sraRectangleIterator;

// tag-sraRegion
// file ../rfb/rfb.h line 408
struct sraRegion;

// tag-sraSpan
// file ../rfb/rfbregion.h line 47
struct sraSpan;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-utimbuf
// file /usr/include/utime.h line 37
struct utimbuf;

// tag-ws_ctx_s
// file websockets.c line 81
struct ws_ctx_s;

// tag-ws_header_s
// file websockets.c line 105
struct ws_header_s;

// tag-ws_mask_s
// file websockets.c line 95
union ws_mask_s;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AddFileListItemInfo
// file tightvnc-filetransfer/filelistinfo.h line 55
signed int AddFileListItemInfo(struct _FileListInfo *fileListInfoPtr, char *name, unsigned int size, unsigned int data);
// CheckSolidTile
// file tight.c line 566
static signed char CheckSolidTile(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor);
// CheckSolidTile16
// file tight.c line 610
static signed char CheckSolidTile16(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor);
// CheckSolidTile32
// file tight.c line 611
static signed char CheckSolidTile32(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor);
// CheckSolidTile8
// file tight.c line 609
static signed char CheckSolidTile8(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor);
// ChkFileDownloadErr
// file tightvnc-filetransfer/filetransfermsg.h line 45
struct _FileTransferMsg ChkFileDownloadErr(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// ChkFileUploadErr
// file tightvnc-filetransfer/filetransfermsg.h line 49
struct _FileTransferMsg ChkFileUploadErr(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// ChkFileUploadWriteErr
// file tightvnc-filetransfer/filetransfermsg.h line 50
struct _FileTransferMsg ChkFileUploadWriteErr(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp, char *pBuf);
// CloseUndoneFileTransfer
// file tightvnc-filetransfer/filetransfermsg.h line 54
void CloseUndoneFileTransfer(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// CompressData
// file tight.c line 1026
static signed char CompressData(struct _rfbClientRec *cl, signed int streamId, signed int dataLen, signed int zlibLevel, signed int zlibStrategy);
// ConvertPath
// file tightvnc-filetransfer/handlefiletransferrequest.c line 198
char * ConvertPath(char *path);
// CreateDirectory
// file tightvnc-filetransfer/filetransfermsg.h line 52
void CreateDirectory(char *dirName);
// CreateFileDownloadBlockSizeDataMsg
// file tightvnc-filetransfer/filetransfermsg.c line 578
struct _FileTransferMsg CreateFileDownloadBlockSizeDataMsg(unsigned short int sizeFile, char *pFile);
// CreateFileDownloadErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 514
struct _FileTransferMsg CreateFileDownloadErrMsg(char *reason, unsigned int reasonLen);
// CreateFileDownloadZeroSizeDataMsg
// file tightvnc-filetransfer/filetransfermsg.c line 544
struct _FileTransferMsg CreateFileDownloadZeroSizeDataMsg(unsigned long int mTime);
// CreateFileListErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 326
struct _FileTransferMsg CreateFileListErrMsg(char flags);
// CreateFileListInfo
// file tightvnc-filetransfer/filetransfermsg.c line 253
signed int CreateFileListInfo(struct _FileListInfo *pFileListInfo, char *path, signed int flag);
// CreateFileListMsg
// file tightvnc-filetransfer/filetransfermsg.c line 356
struct _FileTransferMsg CreateFileListMsg(struct _FileListInfo fileListInfo, char flags);
// CreateFileUploadErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 702
struct _FileTransferMsg CreateFileUploadErrMsg(char *reason, unsigned int reasonLen);
// DisplayFileList
// file tightvnc-filetransfer/filelistinfo.c line 33
void DisplayFileList(struct _FileListInfo fli);
// EnableFileTransfer
// file tightvnc-filetransfer/handlefiletransferrequest.h line 34
void EnableFileTransfer(signed char enable);
// EncodeIndexedRect16
// file tight.c line 1491
static void EncodeIndexedRect16(unsigned char *buf, signed int count);
// EncodeIndexedRect32
// file tight.c line 1492
static void EncodeIndexedRect32(unsigned char *buf, signed int count);
// EncodeMonoRect16
// file tight.c line 1546
static void EncodeMonoRect16(unsigned char *buf, signed int w, signed int h);
// EncodeMonoRect32
// file tight.c line 1547
static void EncodeMonoRect32(unsigned char *buf, signed int w, signed int h);
// EncodeMonoRect8
// file tight.c line 1545
static void EncodeMonoRect8(unsigned char *buf, signed int w, signed int h);
// ExtendSolidArea
// file tight.c line 516
static void ExtendSolidArea(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int colorValue, signed int *x_ptr, signed int *y_ptr, signed int *w_ptr, signed int *h_ptr);
// FastFillPalette16
// file tight.c line 1334
static void FastFillPalette16(struct _rfbClientRec *cl, unsigned short int *data, signed int w, signed int pitch, signed int h);
// FastFillPalette32
// file tight.c line 1335
static void FastFillPalette32(struct _rfbClientRec *cl, unsigned int *data, signed int w, signed int pitch, signed int h);
// FileUpdateComplete
// file tightvnc-filetransfer/filetransfermsg.h line 53
void FileUpdateComplete(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// FillPalette16
// file tight.c line 1231
static void FillPalette16(signed int count);
// FillPalette32
// file tight.c line 1232
static void FillPalette32(signed int count);
// FillPalette8
// file tight.c line 1127
static void FillPalette8(signed int count);
// FilterWaveletSquare
// file ../common/zywrletemplate.c line 450
static inline void FilterWaveletSquare(signed int *pBuf, signed int width, signed int height, signed int level, signed int l);
// FindBestSolidArea
// file tight.c line 470
static void FindBestSolidArea(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int colorValue, signed int *w_ptr, signed int *h_ptr);
// FreeFileListInfo
// file tightvnc-filetransfer/filelistinfo.h line 60
void FreeFileListInfo(struct _FileListInfo fileListInfo);
// FreeFileTransferMsg
// file tightvnc-filetransfer/filetransfermsg.h line 56
void FreeFileTransferMsg(struct _FileTransferMsg ftm);
// FreeHomeDir
// file tightvnc-filetransfer/handlefiletransferrequest.c line 182
void FreeHomeDir(char *homedir);
// GetFileDataAt
// file tightvnc-filetransfer/filelistinfo.h line 58
unsigned int GetFileDataAt(struct _FileListInfo fileListInfo, signed int number);
// GetFileDownLoadErrMsg
// file tightvnc-filetransfer/filetransfermsg.h line 43
struct _FileTransferMsg GetFileDownLoadErrMsg();
// GetFileDownloadLengthErrResponseMsg
// file tightvnc-filetransfer/filetransfermsg.h line 42
struct _FileTransferMsg GetFileDownloadLengthErrResponseMsg();
// GetFileDownloadReadDataErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 426
struct _FileTransferMsg GetFileDownloadReadDataErrMsg();
// GetFileDownloadResponseMsgInBlocks
// file tightvnc-filetransfer/filetransfermsg.h line 44
struct _FileTransferMsg GetFileDownloadResponseMsgInBlocks(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// GetFileListResponseMsg
// file tightvnc-filetransfer/filetransfermsg.h line 39
struct _FileTransferMsg GetFileListResponseMsg(char *path, char flags);
// GetFileNameAt
// file tightvnc-filetransfer/filelistinfo.h line 56
char * GetFileNameAt(struct _FileListInfo fileListInfo, signed int number);
// GetFileSizeAt
// file tightvnc-filetransfer/filelistinfo.h line 57
unsigned int GetFileSizeAt(struct _FileListInfo fileListInfo, signed int number);
// GetFileUploadCompressedLevelErrMsg
// file tightvnc-filetransfer/filetransfermsg.h line 48
struct _FileTransferMsg GetFileUploadCompressedLevelErrMsg();
// GetFileUploadLengthErrResponseMsg
// file tightvnc-filetransfer/filetransfermsg.h line 47
struct _FileTransferMsg GetFileUploadLengthErrResponseMsg();
// GetFtpRoot
// file tightvnc-filetransfer/handlefiletransferrequest.c line 235
char * GetFtpRoot();
// GetHomeDir
// file tightvnc-filetransfer/handlefiletransferrequest.c line 159
char * GetHomeDir(unsigned int uid);
// GetSumOfFileNamesLength
// file tightvnc-filetransfer/filelistinfo.h line 59
unsigned int GetSumOfFileNamesLength(struct _FileListInfo fileListInfo);
// HandleFileCreateDirRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 44
void HandleFileCreateDirRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileDownload
// file tightvnc-filetransfer/handlefiletransferrequest.c line 507
void HandleFileDownload(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileDownloadCancelRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 40
void HandleFileDownloadCancelRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileDownloadLengthError
// file tightvnc-filetransfer/handlefiletransferrequest.c line 413
void HandleFileDownloadLengthError(struct _rfbClientRec *cl, signed short int fNameSize);
// HandleFileDownloadRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 39
void HandleFileDownloadRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileListRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 38
void HandleFileListRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *data);
// HandleFileUpload
// file tightvnc-filetransfer/handlefiletransferrequest.c line 737
void HandleFileUpload(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileUploadDataRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 42
void HandleFileUploadDataRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileUploadFailedRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 43
void HandleFileUploadFailedRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileUploadLengthError
// file tightvnc-filetransfer/handlefiletransferrequest.c line 680
void HandleFileUploadLengthError(struct _rfbClientRec *cl, signed short int fNameSize);
// HandleFileUploadRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 41
void HandleFileUploadRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp);
// HandleFileUploadWrite
// file tightvnc-filetransfer/handlefiletransferrequest.c line 858
void HandleFileUploadWrite(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp, char *pBuf);
// Harr
// file ../common/zywrletemplate.c line 313
static inline void Harr(signed char *pX0, signed char *pX1);
// InitFileTransfer
// file tightvnc-filetransfer/handlefiletransferrequest.h line 32
void InitFileTransfer();
// IsFileTransferEnabled
// file tightvnc-filetransfer/handlefiletransferrequest.h line 35
signed char IsFileTransferEnabled();
// Pack24
// file tight.c line 1426
static void Pack24(struct _rfbClientRec *cl, char *buf, struct anonymous_7 *fmt, signed int count);
// PaletteInsert
// file tight.c line 1355
static signed int PaletteInsert(unsigned int rgb, signed int numPixels, signed int bpp);
// PaletteReset
// file tight.c line 1347
static void PaletteReset(void);
// PrintPixelFormat
// file translate.c line 460
static void PrintPixelFormat(struct anonymous_7 *pf);
// RunFileDownloadThread
// file tightvnc-filetransfer/handlefiletransferrequest.c line 471
void * RunFileDownloadThread(void *client);
// ScaleX
// file ./scale.h line 2
signed int ScaleX(struct _rfbScreenInfo *from, struct _rfbScreenInfo *to, signed int x);
// ScaleY
// file ./scale.h line 3
signed int ScaleY(struct _rfbScreenInfo *from, struct _rfbScreenInfo *to, signed int y);
// SendCompressedData
// file tight.c line 1086
static signed char SendCompressedData(struct _rfbClientRec *cl, char *buf, signed int compressedLen);
// SendFileDownloadLengthErrMsg
// file tightvnc-filetransfer/handlefiletransferrequest.c line 449
void SendFileDownloadLengthErrMsg(struct _rfbClientRec *cl);
// SendFileUploadLengthErrMsg
// file tightvnc-filetransfer/handlefiletransferrequest.c line 718
void SendFileUploadLengthErrMsg(struct _rfbClientRec *cl);
// SendFullColorRect
// file tight.c line 987
static signed char SendFullColorRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SendIndexedRect
// file tight.c line 908
static signed char SendIndexedRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SendJpegRect
// file tight.c line 1555
static signed char SendJpegRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, signed int quality);
// SendMonoRect
// file tight.c line 828
static signed char SendMonoRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SendRectEncodingTight
// file tight.c line 291
static signed char SendRectEncodingTight(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SendRectSimple
// file tight.c line 614
static signed char SendRectSimple(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SendSolidRect
// file tight.c line 803
static signed char SendSolidRect(struct _rfbClientRec *cl);
// SendSubrect
// file tight.c line 667
static signed char SendSubrect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SendTightHeader
// file tight.c line 767
static signed char SendTightHeader(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// SetFtpRoot
// file tightvnc-filetransfer/handlefiletransferrequest.h line 33
signed int SetFtpRoot(char *path);
// TJBUFSIZE
// file ../common/turbojpeg.h line 507
unsigned long int TJBUFSIZE(signed int width, signed int height);
// Wavelet
// file ../common/zywrletemplate.c line 478
static inline void Wavelet(signed int *pBuf, signed int width, signed int height, signed int level);
// WaveletLevel
// file ../common/zywrletemplate.c line 357
static inline void WaveletLevel(signed int *data, signed int size, signed int l, signed int SkipPixel);
// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __b64_ntop
// file /usr/include/resolv.h line 335
signed int __b64_ntop(const unsigned char *, unsigned long int, char *, unsigned long int);
// __b64_pton
// file /usr/include/resolv.h line 336
signed int __b64_pton(const char *, unsigned char *, unsigned long int);
// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __lzo_align_gap
// file ../common/minilzo.c line 3886
extern unsigned int __lzo_align_gap(const void *ptr, unsigned long int size);
// __lzo_init_v2
// file ../common/minilzo.c line 4221
extern signed int __lzo_init_v2(unsigned int v, signed int s1, signed int s2, signed int s3, signed int s4, signed int s5, signed int s6, signed int s7, signed int s8, signed int s9);
// __lzo_ptr_linear
// file ../common/minilzo.c line 3870
extern unsigned long int __lzo_ptr_linear(const void *ptr);
// __rfbssl_read
// file rfbssl_gnutls.c line 204
static signed int __rfbssl_read(struct _rfbClientRec *cl, char *buf, signed int bufsize, signed int peek);
// _lzo_config_check
// file ../common/minilzo.c line 4135
extern signed int _lzo_config_check(void);
// _lzo_version_date
// file ../common/minilzo.c line 3953
extern const char * _lzo_version_date(void);
// _lzo_version_string
// file ../common/minilzo.c line 3947
extern const char * _lzo_version_string(void);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// _tjInitCompress
// file ../common/turbojpeg.c line 461
static void * _tjInitCompress(struct _tjinstance *this);
// _tjInitDecompress
// file ../common/turbojpeg.c line 645
static void * _tjInitDecompress(struct _tjinstance *this);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// clientInput
// file main.c line 509
static void * clientInput(void *data);
// clientOutput
// file main.c line 443
static void * clientOutput(void *data);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// compareAndSkip
// file httpd.c line 556
static signed char compareAndSkip(char **ptr, const char *str);
// compress
// file /usr/include/zlib.h line 1160
extern signed int compress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// cookey
// file ../common/d3des.c line 110
static void cookey(unsigned long int *raw1);
// creat
// file /usr/include/fcntl.h line 192
extern signed int creat(const char *, unsigned int);
// deflate
// file /usr/include/zlib.h line 246
extern signed int deflate(struct z_stream_s *, signed int);
// deflateEnd
// file /usr/include/zlib.h line 353
extern signed int deflateEnd(struct z_stream_s *);
// deflateInit2_
// file /usr/include/zlib.h line 1637
extern signed int deflateInit2_(struct z_stream_s *, signed int, signed int, signed int, signed int, signed int, const char *, signed int);
// deflateInit_
// file /usr/include/zlib.h line 1633
extern signed int deflateInit_(struct z_stream_s *, signed int, const char *, signed int);
// deflateParams
// file /usr/include/zlib.h line 660
extern signed int deflateParams(struct z_stream_s *, signed int, signed int);
// desfunc
// file ../common/d3des.c line 333
static void desfunc(unsigned long int *block, unsigned long int *keys);
// digestmd5
// file rfbcrypto.h line 9
void digestmd5(struct iovec *iov, signed int iovcnt, void *dest);
// digestsha1
// file rfbcrypto.h line 10
void digestsha1(struct iovec *iov, signed int iovcnt, void *dest);
// dst_noop
// file ../common/turbojpeg.c line 457
static void dst_noop(struct jpeg_compress_struct *cinfo);
// empty_output_buffer
// file ../common/turbojpeg.c line 451
static signed int empty_output_buffer(struct jpeg_compress_struct *cinfo);
// encodingName
// file ../rfb/rfb.h line 1064
extern char * encodingName(unsigned int type, char *buf, signed int len);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fchmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 296
extern signed int fchmod(signed int, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill_input_buffer
// file ../common/turbojpeg.c line 629
static signed int fill_input_buffer(struct jpeg_decompress_struct *dinfo);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// gcry_md_ctl
// file /usr/include/gcrypt.h line 1200
unsigned int gcry_md_ctl(struct gcry_md_handle *, signed int, void *, unsigned long int);
// gcry_md_get_algo_dlen
// file /usr/include/gcrypt.h line 1230
unsigned int gcry_md_get_algo_dlen(signed int);
// gcry_md_open
// file /usr/include/gcrypt.h line 1185
unsigned int gcry_md_open(struct gcry_md_handle **, signed int, unsigned int);
// gcry_md_read
// file /usr/include/gcrypt.h line 1210
unsigned char * gcry_md_read(struct gcry_md_handle *, signed int);
// gcry_md_write
// file /usr/include/gcrypt.h line 1206
void gcry_md_write(struct gcry_md_handle *, const void *, unsigned long int);
// generate_dh_params
// file rfbssl_gnutls.c line 69
static signed int generate_dh_params(struct rfbssl_ctx *ctx);
// getBgColour
// file corre.c line 302
static unsigned int getBgColour(char *data, signed int size, signed int bpp);
// getBgColour_link1
// file rre.c line 269
static unsigned int getBgColour_link1(char *data_link1, signed int size_link1, signed int bpp_link1);
// getPixelFormat
// file ../common/turbojpeg.c line 116
static signed int getPixelFormat(signed int pixelSize, signed int flags);
// getSubsamp
// file ../common/turbojpeg.c line 259
static signed int getSubsamp(struct jpeg_decompress_struct *dinfo);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, struct sockaddr *, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// gnutls_bye
// file /usr/include/gnutls/gnutls.h line 819
signed int gnutls_bye(struct gnutls_session_int *, enum anonymous_46);
// gnutls_certificate_allocate_credentials
// file /usr/include/gnutls/gnutls.h line 1437
signed int gnutls_certificate_allocate_credentials(struct gnutls_certificate_credentials_st **);
// gnutls_certificate_free_credentials
// file /usr/include/gnutls/gnutls.h line 1435
void gnutls_certificate_free_credentials(struct gnutls_certificate_credentials_st *);
// gnutls_certificate_set_dh_params
// file /usr/include/gnutls/gnutls.h line 1466
void gnutls_certificate_set_dh_params(struct gnutls_certificate_credentials_st *, struct gnutls_dh_params_int *);
// gnutls_certificate_set_x509_key_file
// file /usr/include/gnutls/gnutls.h line 1519
signed int gnutls_certificate_set_x509_key_file(struct gnutls_certificate_credentials_st *, const char *, const char *, enum anonymous_44);
// gnutls_certificate_set_x509_trust_file
// file /usr/include/gnutls/gnutls.h line 1498
signed int gnutls_certificate_set_x509_trust_file(struct gnutls_certificate_credentials_st *, const char *, enum anonymous_44);
// gnutls_credentials_set
// file /usr/include/gnutls/gnutls.h line 1367
signed int gnutls_credentials_set(struct gnutls_session_int *, enum anonymous_45, void *);
// gnutls_deinit
// file /usr/include/gnutls/gnutls.h line 816
void gnutls_deinit(struct gnutls_session_int *);
// gnutls_dh_params_generate2
// file /usr/include/gnutls/gnutls.h line 1673
signed int gnutls_dh_params_generate2(struct gnutls_dh_params_int *, unsigned int);
// gnutls_dh_params_init
// file /usr/include/gnutls/gnutls.h line 1661
signed int gnutls_dh_params_init(struct gnutls_dh_params_int **);
// gnutls_global_init
// file /usr/include/gnutls/gnutls.h line 1607
signed int gnutls_global_init(void);
// gnutls_global_set_log_function
// file /usr/include/gnutls/gnutls.h line 1655
void gnutls_global_set_log_function(void (*)(signed int, const char *));
// gnutls_global_set_log_level
// file /usr/include/gnutls/gnutls.h line 1657
void gnutls_global_set_log_level(signed int);
// gnutls_handshake
// file /usr/include/gnutls/gnutls.h line 821
signed int gnutls_handshake(struct gnutls_session_int *);
// gnutls_init
// file /usr/include/gnutls/gnutls.h line 815
signed int gnutls_init(struct gnutls_session_int **, unsigned int);
// gnutls_priority_set_direct
// file /usr/include/gnutls/gnutls.h line 1176
signed int gnutls_priority_set_direct(struct gnutls_session_int *, const char *, const char **);
// gnutls_protocol_get_name
// file /usr/include/gnutls/gnutls.h line 1213
const char * gnutls_protocol_get_name(enum anonymous_47);
// gnutls_protocol_get_version
// file /usr/include/gnutls/gnutls.h line 1211
enum anonymous_47 gnutls_protocol_get_version(struct gnutls_session_int *);
// gnutls_record_check_pending
// file /usr/include/gnutls/gnutls.h line 1032
unsigned long int gnutls_record_check_pending(struct gnutls_session_int *);
// gnutls_record_recv
// file /usr/include/gnutls/gnutls.h line 997
signed long int gnutls_record_recv(struct gnutls_session_int *, void *, unsigned long int);
// gnutls_record_send
// file /usr/include/gnutls/gnutls.h line 992
signed long int gnutls_record_send(struct gnutls_session_int *, const void *, unsigned long int);
// gnutls_session_enable_compatibility_mode
// file /usr/include/gnutls/gnutls.h line 1022
void gnutls_session_enable_compatibility_mode(struct gnutls_session_int *);
// gnutls_strerror
// file /usr/include/gnutls/gnutls.h line 939
const char * gnutls_strerror(signed int);
// gnutls_transport_set_ptr
// file /usr/include/gnutls/gnutls.h line 1722
void gnutls_transport_set_ptr(struct gnutls_session_int *, void *);
// handleMessage
// file tightvnc-filetransfer/rfbtightserver.c line 373
static signed char handleMessage(struct _rfbClientRec *cl, const char *messageName, void (*handler)(struct _rfbClientRec *, struct _rfbTightClientRec *));
// handleMessage::handler_object
//
void handler_object(struct _rfbClientRec *, struct _rfbTightClientRec *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// httpCloseSock
// file httpd.c line 258
static void httpCloseSock(struct _rfbScreenInfo *rfbScreen);
// httpProcessInput
// file httpd.c line 272
static void httpProcessInput(struct _rfbScreenInfo *rfbScreen);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_CreateDecompress
// file /usr/include/jpeglib.h line 906
extern void jpeg_CreateDecompress(struct jpeg_decompress_struct *, signed int, unsigned long int);
// jpeg_abort_compress
// file /usr/include/jpeglib.h line 1041
extern void jpeg_abort_compress(struct jpeg_compress_struct *);
// jpeg_abort_decompress
// file /usr/include/jpeglib.h line 1042
extern void jpeg_abort_decompress(struct jpeg_decompress_struct *);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_destroy_decompress
// file /usr/include/jpeglib.h line 910
extern void jpeg_destroy_decompress(struct jpeg_decompress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_finish_decompress
// file /usr/include/jpeglib.h line 993
extern signed int jpeg_finish_decompress(struct jpeg_decompress_struct *);
// jpeg_read_header
// file /usr/include/jpeglib.h line 977
extern signed int jpeg_read_header(struct jpeg_decompress_struct *, signed int);
// jpeg_read_scanlines
// file /usr/include/jpeglib.h line 990
extern unsigned int jpeg_read_scanlines(struct jpeg_decompress_struct *, unsigned char **, unsigned int);
// jpeg_resync_to_restart
// file /usr/include/jpeglib.h line 1051
extern signed int jpeg_resync_to_restart(struct jpeg_decompress_struct *, signed int);
// jpeg_set_colorspace
// file /usr/include/jpeglib.h line 928
extern void jpeg_set_colorspace(struct jpeg_compress_struct *, enum anonymous_32);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_start_decompress
// file /usr/include/jpeglib.h line 989
extern signed int jpeg_start_decompress(struct jpeg_decompress_struct *);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// listenerRun
// file main.c line 568
static void * listenerRun(void *data);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// longjmp
// file /usr/include/setjmp.h line 74
extern void longjmp(struct __jmp_buf_tag *, signed int);
// lzo1x_1_compress
// file ../common/minilzo.c line 4884
extern signed int lzo1x_1_compress(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, void *wrkmem);
// lzo1x_1_compress_core
// file ../common/minilzo.c line 4597
static unsigned long int lzo1x_1_compress_core(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, unsigned long int ti, void *wrkmem);
// lzo1x_decompress
// file ../common/minilzo.c line 5067
extern signed int lzo1x_decompress(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, void *wrkmem);
// lzo1x_decompress_safe
// file ../common/minilzo.c line 5608
extern signed int lzo1x_decompress_safe(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, void *wrkmem);
// lzo_adler32
// file ../common/minilzo.c line 3968
extern unsigned int lzo_adler32(unsigned int adler, const unsigned char *buf, unsigned long int len);
// lzo_bitops_ctlz32_func
// file ../common/minilzo.c line 3259
static inline unsigned int lzo_bitops_ctlz32_func(unsigned int v);
// lzo_bitops_ctlz64_func
// file ../common/minilzo.c line 3278
static inline unsigned int lzo_bitops_ctlz64_func(unsigned long int v);
// lzo_bitops_cttz32_func
// file ../common/minilzo.c line 3300
static inline unsigned int lzo_bitops_cttz32_func(unsigned int v);
// lzo_bitops_cttz64_func
// file ../common/minilzo.c line 3319
static inline unsigned int lzo_bitops_cttz64_func(unsigned long int v);
// lzo_bitops_unused_funcs
// file ../common/minilzo.c line 3346
static void lzo_bitops_unused_funcs(void);
// lzo_copyright
// file ../common/minilzo.c line 3923
extern const unsigned char * lzo_copyright(void);
// lzo_memcmp
// file ../common/minilzo.c line 4025
extern signed int lzo_memcmp(const void *s1, const void *s2, unsigned long int len);
// lzo_memcpy
// file ../common/minilzo.c line 4042
extern void * lzo_memcpy(void *dest, const void *src, unsigned long int len);
// lzo_memmove
// file ../common/minilzo.c line 4057
extern void * lzo_memmove(void *dest, const void *src, unsigned long int len);
// lzo_memset
// file ../common/minilzo.c line 4083
extern void * lzo_memset(void *s, signed int cc, unsigned long int len);
// lzo_version
// file ../common/minilzo.c line 3929
extern unsigned int lzo_version(void);
// lzo_version_date
// file ../common/minilzo.c line 3941
extern const char * lzo_version_date(void);
// lzo_version_string
// file ../common/minilzo.c line 3935
extern const char * lzo_version_string(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// messageNameClient2Server
// file stats.c line 68
extern char * messageNameClient2Server(unsigned int type, char *buf, signed int len);
// messageNameServer2Client
// file stats.c line 50
extern char * messageNameServer2Client(unsigned int type, char *buf, signed int len);
// min
// file websockets.c line 177
static signed int min(signed int a, signed int b);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// my_error_exit
// file ../common/turbojpeg.c line 68
static void my_error_exit(struct jpeg_common_struct *cinfo);
// my_output_message
// file ../common/turbojpeg.c line 77
static void my_output_message(struct jpeg_common_struct *cinfo);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// pad4
// file scale.c line 69
static inline signed int pad4(signed int value);
// parseParams
// file httpd.c line 572
static signed char parseParams(const char *request, char *result, signed int max_bytes);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous *, const union anonymous_0 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous *, union anonymous_9 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_9 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_9 *, const union anonymous_0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_9 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_9 *);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rectSwapIfLEAndClip
// file rfbserver.c line 854
static signed char rectSwapIfLEAndClip(unsigned short int *x, unsigned short int *y, unsigned short int *w, unsigned short int *h, struct _rfbClientRec *cl);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// rfbAuthNewClient
// file ../rfb/rfb.h line 834
extern void rfbAuthNewClient(struct _rfbClientRec *cl);
// rfbAuthProcessClientMessage
// file ../rfb/rfb.h line 836
extern void rfbAuthProcessClientMessage(struct _rfbClientRec *cl);
// rfbCPKey
// file ../common/d3des.c line 132
extern void rfbCPKey(unsigned long int *into);
// rfbCheckFds
// file ../rfb/rfb.h line 752
extern signed int rfbCheckFds(struct _rfbScreenInfo *rfbScreen, signed long int usec);
// rfbCheckPasswordByList
// file main.c line 732
signed char rfbCheckPasswordByList(struct _rfbClientRec *cl, const char *response, signed int len);
// rfbClientConnFailed
// file rfbserver.c line 735
extern void rfbClientConnFailed(struct _rfbClientRec *cl, const char *reason);
// rfbClientConnectionGone
// file ../rfb/rfb.h line 787
extern void rfbClientConnectionGone(struct _rfbClientRec *cl);
// rfbClientIteratorHead
// file private.h line 12
struct _rfbClientRec * rfbClientIteratorHead(struct rfbClientIterator *i);
// rfbClientIteratorNext
// file ../rfb/rfb.h line 778
extern struct _rfbClientRec * rfbClientIteratorNext(struct rfbClientIterator *i);
// rfbClientListInit
// file ../rfb/rfb.h line 776
extern void rfbClientListInit(struct _rfbScreenInfo *rfbScreen);
// rfbClientSendString
// file rfbserver.c line 711
void rfbClientSendString(struct _rfbClientRec *cl, const char *reason);
// rfbCloseClient
// file ../rfb/rfb.h line 747
extern void rfbCloseClient(struct _rfbClientRec *cl);
// rfbConnect
// file ../rfb/rfb.h line 753
extern signed int rfbConnect(struct _rfbScreenInfo *rfbScreen, char *host, signed int port);
// rfbConnectToTcpAddr
// file sockets.c line 965
extern signed int rfbConnectToTcpAddr(char *host, signed int port);
// rfbConvertLSBCursorBitmapOrMask
// file cursor.c line 245
extern void rfbConvertLSBCursorBitmapOrMask(signed int width, signed int height, unsigned char *bitmap);
// rfbDecrClientRef
// file ../rfb/rfb.h line 781
extern void rfbDecrClientRef(struct _rfbClientRec *cl);
// rfbDecryptPasswdFromFile
// file ../rfb/rfbproto.h line 1472
extern char * rfbDecryptPasswdFromFile(char *fname);
// rfbDefaultGetCursorPtr
// file main.c line 696
static struct rfbCursor * rfbDefaultGetCursorPtr(struct _rfbClientRec *cl);
// rfbDefaultKbdAddEvent
// file main.c line 631
static void rfbDefaultKbdAddEvent(signed char down, unsigned int keySym, struct _rfbClientRec *cl);
// rfbDefaultLog
// file main.c line 231
static void rfbDefaultLog(const char *format, ...);
// rfbDefaultNewClientHook
// file main.c line 758
static enum rfbNewClientAction rfbDefaultNewClientHook(struct _rfbClientRec *cl);
// rfbDefaultPasswordCheck
// file main.c line 702
static signed char rfbDefaultPasswordCheck(struct _rfbClientRec *cl, const char *response, signed int len);
// rfbDefaultPtrAddEvent
// file main.c line 636
extern void rfbDefaultPtrAddEvent(signed int buttonMask, signed int x, signed int y, struct _rfbClientRec *cl);
// rfbDefaultSetXCutText
// file main.c line 663
static void rfbDefaultSetXCutText(char *text, signed int len, struct _rfbClientRec *cl);
// rfbDes
// file ../common/d3des.c line 150
extern void rfbDes(unsigned char *inblock, unsigned char *outblock);
// rfbDesKey
// file ../common/d3des.c line 74
extern void rfbDesKey(unsigned char *key, signed int edf);
// rfbDisableExtension
// file main.c line 181
signed char rfbDisableExtension(struct _rfbClientRec *cl, struct _rfbProtocolExtension *extension);
// rfbDisconnectUDPSock
// file ../rfb/rfb.h line 746
extern void rfbDisconnectUDPSock(struct _rfbScreenInfo *rfbScreen);
// rfbDoCopyRect
// file main.c line 385
void rfbDoCopyRect(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2, signed int dx, signed int dy);
// rfbDoCopyRegion
// file main.c line 356
void rfbDoCopyRegion(struct _rfbScreenInfo *screen, struct sraRegion *copyRegion, signed int dx, signed int dy);
// rfbDoNothingWithClient
// file main.c line 754
void rfbDoNothingWithClient(struct _rfbClientRec *cl);
// rfbDrawChar
// file font.c line 3
signed int rfbDrawChar(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, unsigned char c, unsigned int col);
// rfbDrawCharWithClip
// file font.c line 48
signed int rfbDrawCharWithClip(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, unsigned char c, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int col, unsigned int bcol);
// rfbDrawLine
// file draw.c line 31
void rfbDrawLine(struct _rfbScreenInfo *s, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int col);
// rfbDrawPixel
// file draw.c line 20
void rfbDrawPixel(struct _rfbScreenInfo *s, signed int x, signed int y, unsigned int col);
// rfbDrawString
// file font.c line 37
void rfbDrawString(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, const char *string, unsigned int colour);
// rfbDrawStringWithClip
// file font.c line 104
void rfbDrawStringWithClip(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, const char *string, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int colour, unsigned int backColour);
// rfbEnableExtension
// file main.c line 162
signed char rfbEnableExtension(struct _rfbClientRec *cl, struct _rfbProtocolExtension *extension, void *data);
// rfbEncryptAndStorePasswd
// file ../rfb/rfbproto.h line 1471
extern signed int rfbEncryptAndStorePasswd(char *passwd, char *fname);
// rfbEncryptBytes
// file ../rfb/rfbproto.h line 1474
extern void rfbEncryptBytes(unsigned char *bytes, char *passwd);
// rfbEncryptBytes2
// file ../common/vncauth.c line 201
void rfbEncryptBytes2(unsigned char *where, const signed int length, unsigned char *key);
// rfbErr_object
//
void rfbErr_object(const char *, ...);
// rfbFilenameTranslate2DOS
// file rfbserver.c line 1300
signed char rfbFilenameTranslate2DOS(struct _rfbClientRec *cl, char *unixPath, char *path);
// rfbFilenameTranslate2UNIX
// file rfbserver.c line 1262
signed char rfbFilenameTranslate2UNIX(struct _rfbClientRec *cl, char *path, char *unixPath, unsigned long int unixPathMaxLen);
// rfbFillRect
// file draw.c line 3
void rfbFillRect(struct _rfbScreenInfo *s, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int col);
// rfbFontBBox
// file font.c line 131
void rfbFontBBox(struct rfbFontData *font, unsigned char c, signed int *x1, signed int *y1, signed int *x2, signed int *y2);
// rfbFreeCursor
// file ../rfb/rfb.h line 929
extern void rfbFreeCursor(struct rfbCursor *cursor);
// rfbFreeFont
// file font.c line 191
void rfbFreeFont(struct rfbFontData *f);
// rfbFreeUltraData
// file ultra.c line 30
void rfbFreeUltraData(struct _rfbClientRec *cl);
// rfbFreeZrleData
// file private.h line 25
void rfbFreeZrleData(struct _rfbClientRec *cl);
// rfbGetClientIterator
// file ../rfb/rfb.h line 777
extern struct rfbClientIterator * rfbGetClientIterator(struct _rfbScreenInfo *rfbScreen);
// rfbGetClientIteratorWithClosed
// file rfbserver.c line 185
struct rfbClientIterator * rfbGetClientIteratorWithClosed(struct _rfbScreenInfo *rfbScreen);
// rfbGetExtensionClientData
// file main.c line 202
void * rfbGetExtensionClientData(struct _rfbClientRec *cl, struct _rfbProtocolExtension *extension);
// rfbGetExtensionIterator
// file main.c line 146
struct _rfbProtocolExtension * rfbGetExtensionIterator();
// rfbGetScreen
// file main.c line 809
extern struct _rfbScreenInfo * rfbGetScreen(signed int *argc, char **argv, signed int width, signed int height, signed int bitsPerSample, signed int samplesPerPixel, signed int bytesPerPixel);
// rfbGetTightClientData
// file tightvnc-filetransfer/rfbtightserver.c line 41
struct _rfbTightClientRec * rfbGetTightClientData(struct _rfbClientRec *cl);
// rfbGotXCutText
// file cutpaste.c line 35
void rfbGotXCutText(struct _rfbScreenInfo *rfbScreen, char *str, signed int len);
// rfbHandleSecTypeTight
// file tightvnc-filetransfer/rfbtightserver.c line 495
void rfbHandleSecTypeTight(struct _rfbClientRec *cl);
// rfbHideCursor
// file private.h line 7
void rfbHideCursor(struct _rfbClientRec *cl);
// rfbHttpCheckFds
// file ../rfb/rfb.h line 828
extern void rfbHttpCheckFds(struct _rfbScreenInfo *rfbScreen);
// rfbHttpInitSockets
// file ../rfb/rfb.h line 826
extern void rfbHttpInitSockets(struct _rfbScreenInfo *rfbScreen);
// rfbHttpShutdownSockets
// file ../rfb/rfb.h line 827
extern void rfbHttpShutdownSockets(struct _rfbScreenInfo *rfbScreen);
// rfbIncrClientRef
// file ../rfb/rfb.h line 780
extern void rfbIncrClientRef(struct _rfbClientRec *cl);
// rfbInitColourMapSingleTable16
// file tableinitcmtemplate.c line 46
static void rfbInitColourMapSingleTable16(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap);
// rfbInitColourMapSingleTable24
// file tableinit24.c line 31
static void rfbInitColourMapSingleTable24(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap);
// rfbInitColourMapSingleTable32
// file tableinitcmtemplate.c line 46
static void rfbInitColourMapSingleTable32(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap);
// rfbInitColourMapSingleTable8
// file tableinitcmtemplate.c line 46
static void rfbInitColourMapSingleTable8(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap);
// rfbInitOneRGBTable16
// file tableinittctemplate.c line 122
static void rfbInitOneRGBTable16(unsigned short int *table, signed int inMax, signed int outMax, signed int outShift, signed int swap);
// rfbInitOneRGBTable24
// file tableinit24.c line 139
static void rfbInitOneRGBTable24(unsigned char *table, signed int inMax, signed int outMax, signed int outShift, signed int swap);
// rfbInitOneRGBTable32
// file tableinittctemplate.c line 122
static void rfbInitOneRGBTable32(unsigned int *table, signed int inMax, signed int outMax, signed int outShift, signed int swap);
// rfbInitOneRGBTable8
// file tableinittctemplate.c line 122
static void rfbInitOneRGBTable8(unsigned char *table, signed int inMax, signed int outMax, signed int outShift, signed int swap);
// rfbInitServerFormat
// file main.c line 768
static void rfbInitServerFormat(struct _rfbScreenInfo *screen, signed int bitsPerSample);
// rfbInitServerWithPthreadsAndZRLE
// file main.c line 1046
extern void rfbInitServerWithPthreadsAndZRLE(struct _rfbScreenInfo *screen);
// rfbInitSockets
// file ../rfb/rfb.h line 744
extern void rfbInitSockets(struct _rfbScreenInfo *rfbScreen);
// rfbInitTrueColourRGBTables16
// file tableinittctemplate.c line 99
static void rfbInitTrueColourRGBTables16(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourRGBTables24
// file tableinit24.c line 116
static void rfbInitTrueColourRGBTables24(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourRGBTables32
// file tableinittctemplate.c line 99
static void rfbInitTrueColourRGBTables32(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourRGBTables8
// file tableinittctemplate.c line 99
static void rfbInitTrueColourRGBTables8(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourSingleTable16
// file tableinittctemplate.c line 60
static void rfbInitTrueColourSingleTable16(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourSingleTable24
// file tableinit24.c line 75
static void rfbInitTrueColourSingleTable24(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourSingleTable32
// file tableinittctemplate.c line 60
static void rfbInitTrueColourSingleTable32(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbInitTrueColourSingleTable8
// file tableinittctemplate.c line 60
static void rfbInitTrueColourSingleTable8(char **table, struct anonymous_7 *in, struct anonymous_7 *out);
// rfbIsActive
// file main.c line 1175
extern signed char rfbIsActive(struct _rfbScreenInfo *screenInfo);
// rfbListenOnTCP6Port
// file sockets.c line 888
extern signed int rfbListenOnTCP6Port(signed int port, const char *iface);
// rfbListenOnTCPPort
// file sockets.c line 854
extern signed int rfbListenOnTCPPort(signed int port, unsigned int iface);
// rfbListenOnUDPPort
// file sockets.c line 1036
extern signed int rfbListenOnUDPPort(signed int port, unsigned int iface);
// rfbLoadConsoleFont
// file font.c line 164
struct rfbFontData * rfbLoadConsoleFont(char *filename);
// rfbLog_object
//
void rfbLog_object(const char *, ...);
// rfbLogEnable
// file main.c line 222
extern void rfbLogEnable(signed int enabled);
// rfbLogPerror
// file main.c line 262
extern void rfbLogPerror(const char *str);
// rfbMakeMaskForXCursor
// file cursor.c line 285
extern char * rfbMakeMaskForXCursor(signed int width, signed int height, char *source);
// rfbMakeMaskFromAlphaSource
// file cursor.c line 310
extern char * rfbMakeMaskFromAlphaSource(signed int width, signed int height, unsigned char *alphaSource);
// rfbMakeRichCursorFromXCursor
// file cursor.c line 440
extern void rfbMakeRichCursorFromXCursor(struct _rfbScreenInfo *rfbScreen, struct rfbCursor *cursor);
// rfbMakeXCursor
// file cursor.c line 254
extern struct rfbCursor * rfbMakeXCursor(signed int width, signed int height, char *cursorString, char *maskString);
// rfbMakeXCursorFromRichCursor
// file cursor.c line 370
extern void rfbMakeXCursorFromRichCursor(struct _rfbScreenInfo *rfbScreen, struct rfbCursor *cursor);
// rfbMarkRectAsModified
// file main.c line 416
void rfbMarkRectAsModified(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2);
// rfbMarkRegionAsModified
// file main.c line 399
void rfbMarkRegionAsModified(struct _rfbScreenInfo *screen, struct sraRegion *modRegion);
// rfbNewClient
// file ../rfb/rfb.h line 784
extern struct _rfbClientRec * rfbNewClient(struct _rfbScreenInfo *rfbScreen, signed int sock);
// rfbNewClientConnection
// file rfbserver.c line 248
extern void rfbNewClientConnection(struct _rfbScreenInfo *rfbScreen, signed int sock);
// rfbNewFramebuffer
// file main.c line 940
extern void rfbNewFramebuffer(struct _rfbScreenInfo *screen, char *framebuffer, signed int width, signed int height, signed int bitsPerSample, signed int samplesPerPixel, signed int bytesPerPixel);
// rfbNewTCPOrUDPClient
// file rfbserver.c line 301
static struct _rfbClientRec * rfbNewTCPOrUDPClient(struct _rfbScreenInfo *rfbScreen, signed int sock, signed char isUDP);
// rfbNewUDPClient
// file rfbserver.c line 520
extern struct _rfbClientRec * rfbNewUDPClient(struct _rfbScreenInfo *rfbScreen);
// rfbNewUDPConnection
// file rfbserver.c line 3527
extern void rfbNewUDPConnection(struct _rfbScreenInfo *rfbScreen, signed int sock);
// rfbNumCodedRectsTight
// file ../rfb/rfb.h line 893
extern signed int rfbNumCodedRectsTight(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbPeekExactTimeout
// file sockets.c line 662
extern signed int rfbPeekExactTimeout(struct _rfbClientRec *cl, char *buf, signed int len, signed int timeout);
// rfbPrintStats
// file ../rfb/rfb.h line 943
extern void rfbPrintStats(struct _rfbClientRec *cl);
// rfbProcessArguments
// file ../rfb/rfb.h line 996
extern signed char rfbProcessArguments(struct _rfbScreenInfo *rfbScreen, signed int *argc, char **argv);
// rfbProcessClientAuthType
// file tightvnc-filetransfer/rfbtightserver.c line 106
void rfbProcessClientAuthType(struct _rfbClientRec *cl);
// rfbProcessClientInitMessage
// file rfbserver.c line 762
static void rfbProcessClientInitMessage(struct _rfbClientRec *cl);
// rfbProcessClientMessage
// file ../rfb/rfb.h line 788
extern void rfbProcessClientMessage(struct _rfbClientRec *cl);
// rfbProcessClientNormalMessage
// file rfbserver.c line 1985
static void rfbProcessClientNormalMessage(struct _rfbClientRec *cl);
// rfbProcessClientProtocolVersion
// file rfbserver.c line 662
static void rfbProcessClientProtocolVersion(struct _rfbClientRec *cl);
// rfbProcessClientSecurityType
// file ../rfb/rfb.h line 835
extern void rfbProcessClientSecurityType(struct _rfbClientRec *cl);
// rfbProcessClientTunnelingType
// file tightvnc-filetransfer/rfbtightserver.c line 166
void rfbProcessClientTunnelingType(struct _rfbClientRec *cl);
// rfbProcessEvents
// file main.c line 1093
extern signed char rfbProcessEvents(struct _rfbScreenInfo *screen, signed long int usec);
// rfbProcessFileTransfer
// file rfbserver.c line 1581
extern signed char rfbProcessFileTransfer(struct _rfbClientRec *cl, unsigned char contentType, unsigned char contentParam, unsigned int size, unsigned int length);
// rfbProcessFileTransferReadBuffer
// file rfbserver.c line 1454
extern char * rfbProcessFileTransferReadBuffer(struct _rfbClientRec *cl, unsigned int length);
// rfbProcessNewConnection
// file sockets.c line 405
signed char rfbProcessNewConnection(struct _rfbScreenInfo *rfbScreen);
// rfbProcessSizeArguments
// file cargs.c line 239
extern signed char rfbProcessSizeArguments(signed int *width, signed int *height, signed int *bpp, signed int *argc, char **argv);
// rfbProcessUDPInput
// file rfbserver.c line 3543
extern void rfbProcessUDPInput(struct _rfbScreenInfo *rfbScreen);
// rfbPurgeArguments
// file cargs.c line 68
extern void rfbPurgeArguments(signed int *argc, signed int *position, signed int count, char **argv);
// rfbRandomBytes
// file ../rfb/rfbproto.h line 1473
extern void rfbRandomBytes(unsigned char *bytes);
// rfbReadExact
// file ../rfb/rfb.h line 748
extern signed int rfbReadExact(struct _rfbClientRec *cl, char *buf, signed int len);
// rfbReadExactTimeout
// file sockets.c line 570
extern signed int rfbReadExactTimeout(struct _rfbClientRec *cl, char *buf, signed int len, signed int timeout);
// rfbRedrawAfterHideCursor
// file private.h line 8
void rfbRedrawAfterHideCursor(struct _rfbClientRec *cl, struct sraRegion *updateRegion);
// rfbRefuseOnHoldClient
// file main.c line 624
extern void rfbRefuseOnHoldClient(struct _rfbClientRec *cl);
// rfbRegisterProtocolExtension
// file main.c line 69
void rfbRegisterProtocolExtension(struct _rfbProtocolExtension *extension);
// rfbRegisterSecurityHandler
// file auth.c line 49
extern void rfbRegisterSecurityHandler(struct _rfbSecurity *handler);
// rfbRegisterTightVNCFileTransferExtension
// file tightvnc-filetransfer/rfbtightserver.c line 536
void rfbRegisterTightVNCFileTransferExtension();
// rfbReleaseClientIterator
// file ../rfb/rfb.h line 779
extern void rfbReleaseClientIterator(struct rfbClientIterator *iterator);
// rfbReleaseExtensionIterator
// file main.c line 157
void rfbReleaseExtensionIterator();
// rfbResetStats
// file ../rfb/rfb.h line 942
extern void rfbResetStats(struct _rfbClientRec *cl);
// rfbReverseConnection
// file rfbserver.c line 261
extern struct _rfbClientRec * rfbReverseConnection(struct _rfbScreenInfo *rfbScreen, char *host, signed int port);
// rfbRunEventLoop
// file main.c line 1179
extern void rfbRunEventLoop(struct _rfbScreenInfo *screen, signed long int usec, signed char runInBackground);
// rfbScaledCorrection
// file ./scale.h line 4
void rfbScaledCorrection(struct _rfbScreenInfo *from, struct _rfbScreenInfo *to, signed int *x, signed int *y, signed int *w, signed int *h, const char *function);
// rfbScaledScreenAllocate
// file scale.c line 284
struct _rfbScreenInfo * rfbScaledScreenAllocate(struct _rfbClientRec *cl, signed int width, signed int height);
// rfbScaledScreenUpdate
// file main.c line 415
void rfbScaledScreenUpdate(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2);
// rfbScaledScreenUpdateRect
// file scale.c line 140
void rfbScaledScreenUpdateRect(struct _rfbScreenInfo *screen, struct _rfbScreenInfo *ptr, signed int x0, signed int y0, signed int w0, signed int h0);
// rfbScalingFind
// file scale.c line 345
struct _rfbScreenInfo * rfbScalingFind(struct _rfbClientRec *cl, signed int width, signed int height);
// rfbScalingSetup
// file ./scale.h line 9
void rfbScalingSetup(struct _rfbClientRec *cl, signed int width, signed int height);
// rfbScheduleCopyRect
// file main.c line 392
void rfbScheduleCopyRect(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2, signed int dx, signed int dy);
// rfbScheduleCopyRegion
// file main.c line 267
void rfbScheduleCopyRegion(struct _rfbScreenInfo *rfbScreen, struct sraRegion *copyRegion, signed int dx, signed int dy);
// rfbScreenCleanup
// file main.c line 1008
extern void rfbScreenCleanup(struct _rfbScreenInfo *screen);
// rfbSelectBox
// file selbox.c line 203
extern signed int rfbSelectBox(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, char **list, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int colour, unsigned int backColour, signed int border, void (*selChangedHook)(signed int));
// rfbSelectBox::1::displayHookBackup_object
//
void displayHookBackup_object(struct _rfbClientRec *);
// rfbSelectBox::1::getCursorPtrBackup_object
//
struct rfbCursor * getCursorPtrBackup_object(struct _rfbClientRec *);
// rfbSelectBox::1::kbdAddEventBackup_object
//
void kbdAddEventBackup_object(signed char, unsigned int, struct _rfbClientRec *);
// rfbSelectBox::1::ptrAddEventBackup_object
//
void ptrAddEventBackup_object(signed int, signed int, signed int, struct _rfbClientRec *);
// rfbSelectBox::selChangedHook_object
//
void selChangedHook_object(signed int);
// rfbSendAuthCaps
// file tightvnc-filetransfer/rfbtightserver.c line 181
static void rfbSendAuthCaps(struct _rfbClientRec *cl);
// rfbSendBell
// file rfbserver.c line 3462
extern void rfbSendBell(struct _rfbScreenInfo *rfbScreen);
// rfbSendCopyRegion
// file rfbserver.c line 3179
extern signed char rfbSendCopyRegion(struct _rfbClientRec *cl, struct sraRegion *reg, signed int dx, signed int dy);
// rfbSendCursorPos
// file ../rfb/rfb.h line 922
extern signed char rfbSendCursorPos(struct _rfbClientRec *cl);
// rfbSendCursorShape
// file ../rfb/rfb.h line 921
extern signed char rfbSendCursorShape(struct _rfbClientRec *cl);
// rfbSendDirContent
// file rfbserver.c line 1312
extern signed char rfbSendDirContent(struct _rfbClientRec *cl, signed int length, char *buffer);
// rfbSendFileTransferChunk
// file ../rfb/rfb.h line 803
extern signed char rfbSendFileTransferChunk(struct _rfbClientRec *cl);
// rfbSendFileTransferMessage
// file rfbserver.c line 1191
extern signed char rfbSendFileTransferMessage(struct _rfbClientRec *cl, unsigned char contentType, unsigned char contentParam, unsigned int size, unsigned int length, const char *buffer);
// rfbSendFramebufferUpdate
// file ../rfb/rfb.h line 792
extern signed char rfbSendFramebufferUpdate(struct _rfbClientRec *cl, struct sraRegion *givenUpdateRegion);
// rfbSendInteractionCaps
// file tightvnc-filetransfer/rfbtightserver.c line 271
void rfbSendInteractionCaps(struct _rfbClientRec *cl);
// rfbSendKeyboardLedState
// file rfbserver.c line 886
signed char rfbSendKeyboardLedState(struct _rfbClientRec *cl);
// rfbSendLastRectMarker
// file rfbserver.c line 3310
extern signed char rfbSendLastRectMarker(struct _rfbClientRec *cl);
// rfbSendNewFBSize
// file rfbserver.c line 3341
extern signed char rfbSendNewFBSize(struct _rfbClientRec *cl, signed int w, signed int h);
// rfbSendNewScaleSize
// file ./scale.h line 10
signed int rfbSendNewScaleSize(struct _rfbClientRec *cl);
// rfbSendOneRectEncodingUltra
// file ultra.c line 39
static signed char rfbSendOneRectEncodingUltra(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendOneRectEncodingZlib
// file zlib.c line 81
static signed char rfbSendOneRectEncodingZlib(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingCoRRE
// file ../rfb/rfb.h line 847
extern signed char rfbSendRectEncodingCoRRE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingHextile
// file ../rfb/rfb.h line 852
extern signed char rfbSendRectEncodingHextile(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingRRE
// file ../rfb/rfb.h line 842
extern signed char rfbSendRectEncodingRRE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingRaw
// file rfbserver.c line 3235
extern signed char rfbSendRectEncodingRaw(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingTight
// file ../rfb/rfb.h line 895
extern signed char rfbSendRectEncodingTight(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingTightPng
// file tight.c line 279
signed char rfbSendRectEncodingTightPng(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingUltra
// file ../rfb/rfb.h line 864
extern signed char rfbSendRectEncodingUltra(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingZRLE
// file ../rfb/rfb.h line 937
extern signed char rfbSendRectEncodingZRLE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendRectEncodingZlib
// file ../rfb/rfb.h line 882
extern signed char rfbSendRectEncodingZlib(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendSecurityType
// file auth.c line 259
static void rfbSendSecurityType(struct _rfbClientRec *cl, signed int securityType);
// rfbSendSecurityTypeList
// file auth.c line 202
static void rfbSendSecurityTypeList(struct _rfbClientRec *cl, signed int primaryType);
// rfbSendServerCutText
// file rfbserver.c line 3488
extern void rfbSendServerCutText(struct _rfbScreenInfo *rfbScreen, char *str, signed int len);
// rfbSendServerIdentity
// file rfbserver.c line 1073
signed char rfbSendServerIdentity(struct _rfbClientRec *cl);
// rfbSendSetColourMapEntries
// file rfbserver.c line 3400
extern signed char rfbSendSetColourMapEntries(struct _rfbClientRec *cl, signed int firstColour, signed int nColours);
// rfbSendSmallRectEncodingCoRRE
// file corre.c line 83
static signed char rfbSendSmallRectEncodingCoRRE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h);
// rfbSendSupportedEncodings
// file rfbserver.c line 985
signed char rfbSendSupportedEncodings(struct _rfbClientRec *cl);
// rfbSendSupportedMessages
// file rfbserver.c line 921
signed char rfbSendSupportedMessages(struct _rfbClientRec *cl);
// rfbSendTextChatMessage
// file rfbserver.c line 1140
extern signed char rfbSendTextChatMessage(struct _rfbClientRec *cl, unsigned int length, char *buffer);
// rfbSendTunnelingCaps
// file tightvnc-filetransfer/rfbtightserver.c line 232
static void rfbSendTunnelingCaps(struct _rfbClientRec *cl);
// rfbSendUpdateBuf
// file rfbserver.c line 3379
extern signed char rfbSendUpdateBuf(struct _rfbClientRec *cl);
// rfbSendXvp
// file rfbserver.c line 1118
signed char rfbSendXvp(struct _rfbClientRec *cl, unsigned char version, unsigned char code);
// rfbSetClientColourMap
// file ../rfb/rfb.h line 821
extern signed char rfbSetClientColourMap(struct _rfbClientRec *cl, signed int firstColour, signed int nColours);
// rfbSetClientColourMapBGR233
// file translate.c line 361
static signed char rfbSetClientColourMapBGR233(struct _rfbClientRec *cl);
// rfbSetClientColourMaps
// file translate.c line 448
extern void rfbSetClientColourMaps(struct _rfbScreenInfo *rfbScreen, signed int firstColour, signed int nColours);
// rfbSetCursor
// file cursor.c line 726
extern void rfbSetCursor(struct _rfbScreenInfo *rfbScreen, struct rfbCursor *c);
// rfbSetNonBlocking
// file ../rfb/rfb.h line 759
extern signed char rfbSetNonBlocking(signed int sock);
// rfbSetProtocolVersion
// file rfbserver.c line 282
extern void rfbSetProtocolVersion(struct _rfbScreenInfo *rfbScreen, signed int major_, signed int minor_);
// rfbSetServerVersionIdentity
// file rfbserver.c line 1055
extern void rfbSetServerVersionIdentity(struct _rfbScreenInfo *screen, char *fmt, ...);
// rfbSetTranslateFunction
// file ../rfb/rfb.h line 820
extern signed char rfbSetTranslateFunction(struct _rfbClientRec *cl);
// rfbShowCursor
// file private.h line 6
void rfbShowCursor(struct _rfbClientRec *cl);
// rfbShutdownServer
// file main.c line 1060
extern void rfbShutdownServer(struct _rfbScreenInfo *screen, signed char disconnectClients);
// rfbShutdownSockets
// file ../rfb/rfb.h line 745
extern void rfbShutdownSockets(struct _rfbScreenInfo *rfbScreen);
// rfbStartOnHoldClient
// file main.c line 608
extern void rfbStartOnHoldClient(struct _rfbClientRec *cl);
// rfbStatGetEncodingCountRcvd
// file stats.c line 348
extern signed int rfbStatGetEncodingCountRcvd(struct _rfbClientRec *cl, unsigned int type);
// rfbStatGetEncodingCountSent
// file stats.c line 340
extern signed int rfbStatGetEncodingCountSent(struct _rfbClientRec *cl, unsigned int type);
// rfbStatGetMessageCountRcvd
// file stats.c line 331
extern signed int rfbStatGetMessageCountRcvd(struct _rfbClientRec *cl, unsigned int type);
// rfbStatGetMessageCountSent
// file stats.c line 323
extern signed int rfbStatGetMessageCountSent(struct _rfbClientRec *cl, unsigned int type);
// rfbStatGetRcvdBytes
// file stats.c line 299
extern signed int rfbStatGetRcvdBytes(struct _rfbClientRec *cl);
// rfbStatGetRcvdBytesIfRaw
// file stats.c line 311
extern signed int rfbStatGetRcvdBytesIfRaw(struct _rfbClientRec *cl);
// rfbStatGetSentBytes
// file stats.c line 275
extern signed int rfbStatGetSentBytes(struct _rfbClientRec *cl);
// rfbStatGetSentBytesIfRaw
// file stats.c line 287
extern signed int rfbStatGetSentBytesIfRaw(struct _rfbClientRec *cl);
// rfbStatLookupEncoding
// file stats.c line 169
extern struct _rfbStatList * rfbStatLookupEncoding(struct _rfbClientRec *cl, unsigned int type);
// rfbStatLookupMessage
// file stats.c line 191
extern struct _rfbStatList * rfbStatLookupMessage(struct _rfbClientRec *cl, unsigned int type);
// rfbStatRecordEncodingRcvd
// file stats.c line 235
extern void rfbStatRecordEncodingRcvd(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw);
// rfbStatRecordEncodingSent
// file ../rfb/rfb.h line 1070
extern void rfbStatRecordEncodingSent(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw);
// rfbStatRecordEncodingSentAdd
// file stats.c line 212
extern void rfbStatRecordEncodingSentAdd(struct _rfbClientRec *cl, unsigned int type, signed int byteCount);
// rfbStatRecordMessageRcvd
// file ../rfb/rfb.h line 1074
extern void rfbStatRecordMessageRcvd(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw);
// rfbStatRecordMessageSent
// file ../rfb/rfb.h line 1073
extern void rfbStatRecordMessageSent(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw);
// rfbStringToAddr
// file sockets.c line 836
extern signed int rfbStringToAddr(char *str, unsigned int *addr);
// rfbTightCleanup
// file private.h line 18
extern void rfbTightCleanup(struct _rfbScreenInfo *screen);
// rfbTightExtensionClientClose
// file tightvnc-filetransfer/rfbtightserver.c line 449
void rfbTightExtensionClientClose(struct _rfbClientRec *cl, void *data);
// rfbTightExtensionInit
// file tightvnc-filetransfer/rfbtightserver.c line 364
signed char rfbTightExtensionInit(struct _rfbClientRec *cl, void *data);
// rfbTightExtensionMsgHandler
// file tightvnc-filetransfer/rfbtightserver.c line 395
signed char rfbTightExtensionMsgHandler(struct _rfbClientRec *cl, void *data, const union anonymous_1 *msg);
// rfbTightProcessArg
// file tightvnc-filetransfer/rfbtightserver.c line 465
signed int rfbTightProcessArg(signed int argc, char **argv);
// rfbTightUsage
// file tightvnc-filetransfer/rfbtightserver.c line 457
void rfbTightUsage(void);
// rfbTranslateNone
// file ../rfb/rfb.h line 815
extern void rfbTranslateNone(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables16to16
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables16to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables16to24
// file tabletrans24template.c line 243
static void rfbTranslateWithRGBTables16to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables16to32
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables16to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables16to8
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables16to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables24to16
// file tabletrans24template.c line 174
static void rfbTranslateWithRGBTables24to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables24to24
// file tabletrans24template.c line 89
static void rfbTranslateWithRGBTables24to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables24to32
// file tabletrans24template.c line 174
static void rfbTranslateWithRGBTables24to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables24to8
// file tabletrans24template.c line 174
static void rfbTranslateWithRGBTables24to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables32to16
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables32to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables32to24
// file tabletrans24template.c line 243
static void rfbTranslateWithRGBTables32to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables32to32
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables32to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables32to8
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables32to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables8to16
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables8to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables8to24
// file tabletrans24template.c line 243
static void rfbTranslateWithRGBTables8to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables8to32
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables8to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithRGBTables8to8
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables8to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable16to16
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable16to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable16to24
// file tabletrans24template.c line 211
static void rfbTranslateWithSingleTable16to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable16to32
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable16to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable16to8
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable16to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable24to16
// file tabletrans24template.c line 141
static void rfbTranslateWithSingleTable24to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable24to24
// file tabletrans24template.c line 50
static void rfbTranslateWithSingleTable24to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable24to32
// file tabletrans24template.c line 141
static void rfbTranslateWithSingleTable24to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable24to8
// file tabletrans24template.c line 141
static void rfbTranslateWithSingleTable24to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable32to16
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable32to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable32to24
// file tabletrans24template.c line 211
static void rfbTranslateWithSingleTable32to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable32to32
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable32to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable32to8
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable32to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable8to16
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable8to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable8to24
// file tabletrans24template.c line 211
static void rfbTranslateWithSingleTable8to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable8to32
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable8to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbTranslateWithSingleTable8to8
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable8to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height);
// rfbUnregisterProtocolExtension
// file main.c line 108
void rfbUnregisterProtocolExtension(struct _rfbProtocolExtension *extension);
// rfbUnregisterSecurityHandler
// file auth.c line 79
extern void rfbUnregisterSecurityHandler(struct _rfbSecurity *handler);
// rfbUnregisterTightVNCFileTransferExtension
// file tightvnc-filetransfer/rfbtightserver.c line 542
void rfbUnregisterTightVNCFileTransferExtension();
// rfbUpdateClient
// file main.c line 1124
signed char rfbUpdateClient(struct _rfbClientRec *cl);
// rfbUsage
// file cargs.c line 20
extern void rfbUsage(void);
// rfbUseKey
// file ../common/d3des.c line 141
extern void rfbUseKey(unsigned long int *from);
// rfbVncAuthNone
// file auth.c line 142
static void rfbVncAuthNone(struct _rfbClientRec *cl);
// rfbVncAuthSendChallenge
// file auth.c line 110
static void rfbVncAuthSendChallenge(struct _rfbClientRec *cl);
// rfbVncAuthSendChallenge_link1
// file tightvnc-filetransfer/rfbtightserver.c line 59
static void rfbVncAuthSendChallenge_link1(struct _rfbClientRec *cl_link1);
// rfbWholeFontBBox
// file font.c line 143
void rfbWholeFontBBox(struct rfbFontData *font, signed int *x1, signed int *y1, signed int *x2, signed int *y2);
// rfbWidthOfChar
// file font.c line 126
signed int rfbWidthOfChar(struct rfbFontData *font, unsigned char c);
// rfbWidthOfString
// file font.c line 116
signed int rfbWidthOfString(struct rfbFontData *font, const char *string);
// rfbWriteExact
// file ../rfb/rfb.h line 751
extern signed int rfbWriteExact(struct _rfbClientRec *cl, const char *buf, signed int len);
// rfbZlibCleanup
// file zlib.c line 62
void rfbZlibCleanup(struct _rfbScreenInfo *screen);
// rfbssl_destroy
// file rfbssl.h line 12
void rfbssl_destroy(struct _rfbClientRec *cl);
// rfbssl_do_read
// file rfbssl_gnutls.c line 148
static signed int rfbssl_do_read(struct _rfbClientRec *cl, char *buf, signed int bufsize);
// rfbssl_error
// file rfbssl_gnutls.c line 45
static void rfbssl_error(const char *msg, signed int e);
// rfbssl_gc_peekbuf
// file rfbssl_gnutls.c line 193
static void rfbssl_gc_peekbuf(struct rfbssl_ctx *ctx, signed int bufsize);
// rfbssl_init
// file rfbssl.h line 7
signed int rfbssl_init(struct _rfbClientRec *cl);
// rfbssl_init_global
// file rfbssl_gnutls.c line 87
struct rfbssl_ctx * rfbssl_init_global(char *key, char *cert);
// rfbssl_init_session
// file rfbssl_gnutls.c line 50
static signed int rfbssl_init_session(struct rfbssl_ctx *ctx, signed int fd);
// rfbssl_log_func
// file rfbssl_gnutls.c line 40
void rfbssl_log_func(signed int level, const char *msg);
// rfbssl_peek
// file rfbssl.h line 9
signed int rfbssl_peek(struct _rfbClientRec *cl, char *buf, signed int bufsize);
// rfbssl_pending
// file rfbssl.h line 8
signed int rfbssl_pending(struct _rfbClientRec *cl);
// rfbssl_read
// file rfbssl.h line 10
signed int rfbssl_read(struct _rfbClientRec *cl, char *buf, signed int bufsize);
// rfbssl_write
// file rfbssl.h line 11
signed int rfbssl_write(struct _rfbClientRec *cl, const char *buf, signed int bufsize);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// scrunch
// file ../common/d3des.c line 161
static void scrunch(unsigned char *outof, unsigned long int *into);
// selGetCursorPtr
// file selbox.c line 198
static struct rfbCursor * selGetCursorPtr(struct _rfbClientRec *cl);
// selKbdAddEvent
// file selbox.c line 125
static void selKbdAddEvent(signed char down, unsigned int keySym, struct _rfbClientRec *cl);
// selPaintButtons
// file selbox.c line 25
static void selPaintButtons(struct anonymous_49 *m, signed char invertOk, signed char invertCancel);
// selPaintLine
// file selbox.c line 55
static void selPaintLine(struct anonymous_49 *m, signed int line, signed char invert);
// selPtrAddEvent
// file selbox.c line 169
static void selPtrAddEvent(signed int buttonMask, signed int x, signed int y, struct _rfbClientRec *cl);
// selSelect
// file selbox.c line 69
static void selSelect(struct anonymous_49 *m, signed int _index);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_16 *, struct anonymous_16 *, struct anonymous_16 *, struct timeval *);
// sendHextiles16
// file hextile.c line 341
static signed char sendHextiles16(struct _rfbClientRec *cl, signed int rx, signed int ry, signed int rw, signed int rh);
// sendHextiles32
// file hextile.c line 342
static signed char sendHextiles32(struct _rfbClientRec *cl, signed int rx, signed int ry, signed int rw, signed int rh);
// sendHextiles8
// file hextile.c line 340
static signed char sendHextiles8(struct _rfbClientRec *cl, signed int rx, signed int ry, signed int rw, signed int rh);
// setCompDefaults
// file ../common/turbojpeg.c line 140
static signed int setCompDefaults(struct jpeg_compress_struct *cinfo, signed int pixelFormat, signed int subsamp, signed int jpegQual);
// setDecompDefaults
// file ../common/turbojpeg.c line 205
static signed int setDecompDefaults(struct jpeg_decompress_struct *dinfo, signed int pixelFormat);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// skip_input_data
// file ../common/turbojpeg.c line 635
static void skip_input_data(struct jpeg_decompress_struct *dinfo, signed long int num_bytes);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sraClipRect
// file rfbregion.c line 789
extern signed char sraClipRect(signed int *x, signed int *y, signed int *w, signed int *h, signed int cx, signed int cy, signed int cw, signed int ch);
// sraClipRect2
// file rfbregion.c line 809
extern signed char sraClipRect2(signed int *x, signed int *y, signed int *x2, signed int *y2, signed int cx, signed int cy, signed int cx2, signed int cy2);
// sraNextSpan
// file rfbregion.c line 729
static struct sraSpan * sraNextSpan(struct sraRectangleIterator *i);
// sraReverse
// file rfbregion.c line 723
static signed char sraReverse(struct sraRectangleIterator *i);
// sraRgnAnd
// file ../rfb/rfbregion.h line 28
extern signed char sraRgnAnd(struct sraRegion *dst, const struct sraRegion *src);
// sraRgnBBox
// file ../rfb/rfbregion.h line 40
extern struct sraRegion * sraRgnBBox(const struct sraRegion *src);
// sraRgnCountRects
// file ../rfb/rfbregion.h line 37
extern unsigned long int sraRgnCountRects(const struct sraRegion *rgn);
// sraRgnCreate
// file ../rfb/rfbregion.h line 22
extern struct sraRegion * sraRgnCreate(void);
// sraRgnCreateRect
// file ../rfb/rfbregion.h line 23
extern struct sraRegion * sraRgnCreateRect(signed int x1, signed int y1, signed int x2, signed int y2);
// sraRgnCreateRgn
// file ../rfb/rfbregion.h line 24
extern struct sraRegion * sraRgnCreateRgn(const struct sraRegion *src);
// sraRgnDestroy
// file ../rfb/rfbregion.h line 26
extern void sraRgnDestroy(struct sraRegion *rgn);
// sraRgnEmpty
// file ../rfb/rfbregion.h line 38
extern signed char sraRgnEmpty(const struct sraRegion *rgn);
// sraRgnGetIterator
// file ../rfb/rfbregion.h line 50
extern struct sraRectangleIterator * sraRgnGetIterator(struct sraRegion *s);
// sraRgnGetReverseIterator
// file ../rfb/rfbregion.h line 51
extern struct sraRectangleIterator * sraRgnGetReverseIterator(struct sraRegion *s, signed char reverseX, signed char reverseY);
// sraRgnIteratorNext
// file ../rfb/rfbregion.h line 52
extern signed char sraRgnIteratorNext(struct sraRectangleIterator *i, struct _rect *r);
// sraRgnMakeEmpty
// file ../rfb/rfbregion.h line 27
extern void sraRgnMakeEmpty(struct sraRegion *rgn);
// sraRgnOffset
// file ../rfb/rfbregion.h line 32
extern void sraRgnOffset(struct sraRegion *dst, signed int dx, signed int dy);
// sraRgnOr
// file ../rfb/rfbregion.h line 29
extern void sraRgnOr(struct sraRegion *dst, const struct sraRegion *src);
// sraRgnPopRect
// file ../rfb/rfbregion.h line 34
extern signed char sraRgnPopRect(struct sraRegion *rgn, struct _rect *rect, unsigned long int flags);
// sraRgnPrint
// file rfbregion.c line 784
void sraRgnPrint(const struct sraRegion *rgn);
// sraRgnReleaseIterator
// file ../rfb/rfbregion.h line 53
extern void sraRgnReleaseIterator(struct sraRectangleIterator *i);
// sraRgnSubtract
// file ../rfb/rfbregion.h line 30
extern signed char sraRgnSubtract(struct sraRegion *dst, const struct sraRegion *src);
// sraSpanCreate
// file rfbregion.c line 34
static struct sraSpan * sraSpanCreate(signed int start, signed int end, const struct sraRegion *subspan);
// sraSpanDestroy
// file rfbregion.c line 74
static void sraSpanDestroy(struct sraSpan *span);
// sraSpanDup
// file rfbregion.c line 44
static struct sraSpan * sraSpanDup(const struct sraSpan *src);
// sraSpanInsertAfter
// file rfbregion.c line 52
static void sraSpanInsertAfter(struct sraSpan *newspan, struct sraSpan *after);
// sraSpanInsertBefore
// file rfbregion.c line 60
static void sraSpanInsertBefore(struct sraSpan *newspan, struct sraSpan *before);
// sraSpanListAnd
// file rfbregion.c line 358
static signed char sraSpanListAnd(struct sraRegion *dest, const struct sraRegion *src);
// sraSpanListCount
// file rfbregion.c line 212
static unsigned long int sraSpanListCount(const struct sraRegion *list);
// sraSpanListCreate
// file rfbregion.c line 118
static struct sraRegion * sraSpanListCreate(void);
// sraSpanListDestroy
// file rfbregion.c line 145
void sraSpanListDestroy(struct sraRegion *list);
// sraSpanListDup
// file rfbregion.c line 128
struct sraRegion * sraSpanListDup(const struct sraRegion *src);
// sraSpanListEmpty
// file rfbregion.c line 207
static signed char sraSpanListEmpty(const struct sraRegion *list);
// sraSpanListEqual
// file rfbregion.c line 174
static signed char sraSpanListEqual(const struct sraRegion *s1, const struct sraRegion *s2);
// sraSpanListMakeEmpty
// file rfbregion.c line 158
static void sraSpanListMakeEmpty(struct sraRegion *list);
// sraSpanListOr
// file rfbregion.c line 268
static void sraSpanListOr(struct sraRegion *dest, const struct sraRegion *src);
// sraSpanListPrint
// file rfbregion.c line 95
static void sraSpanListPrint(const struct sraRegion *l);
// sraSpanListSubtract
// file rfbregion.c line 438
static signed char sraSpanListSubtract(struct sraRegion *dest, const struct sraRegion *src);
// sraSpanMergeNext
// file rfbregion.c line 248
static void sraSpanMergeNext(struct sraSpan *dest);
// sraSpanMergePrevious
// file rfbregion.c line 227
static void sraSpanMergePrevious(struct sraSpan *dest);
// sraSpanPrint
// file rfbregion.c line 111
static void sraSpanPrint(const struct sraSpan *s);
// sraSpanRemove
// file rfbregion.c line 68
static void sraSpanRemove(struct sraSpan *span);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// src_noop
// file ../common/turbojpeg.c line 641
static void src_noop(struct jpeg_decompress_struct *dinfo);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// subrectEncode16
// file corre.c line 294
static signed int subrectEncode16(struct _rfbClientRec *client, unsigned short int *data, signed int w, signed int h);
// subrectEncode16_link1
// file hextile.c line 341
static signed char subrectEncode16_link1(struct _rfbClientRec *cl, unsigned short int *data_link1, signed int w_link1, signed int h_link1, unsigned short int bg, unsigned short int fg, signed char mono);
// subrectEncode16_link2
// file rre.c line 261
static signed int subrectEncode16_link2(struct _rfbClientRec *client_link1, unsigned short int *data_link2, signed int w_link2, signed int h_link2);
// subrectEncode32
// file corre.c line 295
static signed int subrectEncode32(struct _rfbClientRec *client, unsigned int *data, signed int w, signed int h);
// subrectEncode32_link1
// file hextile.c line 342
static signed char subrectEncode32_link1(struct _rfbClientRec *cl, unsigned int *data_link1, signed int w_link1, signed int h_link1, unsigned int bg, unsigned int fg, signed char mono);
// subrectEncode32_link2
// file rre.c line 262
static signed int subrectEncode32_link2(struct _rfbClientRec *client_link1, unsigned int *data_link2, signed int w_link2, signed int h_link2);
// subrectEncode8
// file corre.c line 293
static signed int subrectEncode8(struct _rfbClientRec *client, unsigned char *data, signed int w, signed int h);
// subrectEncode8_link1
// file hextile.c line 340
static signed char subrectEncode8_link1(struct _rfbClientRec *cl, unsigned char *data_link1, signed int w_link1, signed int h_link1, unsigned char bg, unsigned char fg, signed char mono);
// subrectEncode8_link2
// file rre.c line 260
static signed int subrectEncode8_link2(struct _rfbClientRec *client_link1, unsigned char *data_link2, signed int w_link2, signed int h_link2);
// testColours16
// file hextile.c line 341
static void testColours16(unsigned short int *data, signed int size, signed char *mono, signed char *solid, unsigned short int *bg, unsigned short int *fg);
// testColours32
// file hextile.c line 342
static void testColours32(unsigned int *data, signed int size, signed char *mono, signed char *solid, unsigned int *bg, unsigned int *fg);
// testColours8
// file hextile.c line 340
static void testColours8(unsigned char *data, signed int size, signed char *mono, signed char *solid, unsigned char *bg, unsigned char *fg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tjBufSize
// file ../common/turbojpeg.c line 498
unsigned long int tjBufSize(signed int width, signed int height, signed int jpegSubsamp);
// tjCompress
// file ../common/turbojpeg.h line 509
signed int tjCompress(void *handle, unsigned char *srcBuf, signed int width, signed int pitch, signed int height, signed int pixelSize, unsigned char *jpegBuf, unsigned long int *jpegSize, signed int jpegSubsamp, signed int jpegQual, signed int flags);
// tjCompress2
// file ../common/turbojpeg.c line 538
signed int tjCompress2(void *handle, unsigned char *srcBuf, signed int width, signed int pitch, signed int height, signed int pixelFormat, unsigned char **jpegBuf, unsigned long int *jpegSize, signed int jpegSubsamp, signed int jpegQual, signed int flags);
// tjDecompress
// file ../common/turbojpeg.c line 848
signed int tjDecompress(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, unsigned char *dstBuf, signed int width, signed int pitch, signed int height, signed int pixelSize, signed int flags);
// tjDecompress2
// file ../common/turbojpeg.c line 746
signed int tjDecompress2(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, unsigned char *dstBuf, signed int width, signed int pitch, signed int height, signed int pixelFormat, signed int flags);
// tjDecompressHeader
// file ../common/turbojpeg.c line 723
signed int tjDecompressHeader(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, signed int *width, signed int *height);
// tjDecompressHeader2
// file ../common/turbojpeg.c line 684
signed int tjDecompressHeader2(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, signed int *width, signed int *height, signed int *jpegSubsamp);
// tjDestroy
// file ../common/turbojpeg.h line 479
signed int tjDestroy(void *handle);
// tjGetErrorStr
// file ../common/turbojpeg.h line 487
char * tjGetErrorStr(void);
// tjGetScalingFactors
// file ../common/turbojpeg.c line 732
struct anonymous_29 * tjGetScalingFactors(signed int *numscalingfactors);
// tjInitCompress
// file ../common/turbojpeg.h line 302
void * tjInitCompress(void);
// tjInitDecompress
// file ../common/turbojpeg.c line 670
void * tjInitDecompress(void);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// u2p
// file ../common/minilzo.c line 4128
static void * u2p(void *ptr, unsigned long int off);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unscrun
// file ../common/d3des.c line 175
static void unscrun(unsigned long int *outof, unsigned char *into);
// usage
// file storepasswd.c line 25
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// utime
// file /usr/include/utime.h line 45
extern signed int utime(const char *, struct utimbuf *);
// validateString
// file httpd.c line 643
static signed char validateString(char *str);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// webSocketCheckDisconnect
// file ../rfb/rfb.h line 765
extern signed char webSocketCheckDisconnect(struct _rfbClientRec *cl);
// webSocketsCheck
// file ../rfb/rfb.h line 764
extern signed char webSocketsCheck(struct _rfbClientRec *cl);
// webSocketsDecode
// file ../rfb/rfb.h line 767
extern signed int webSocketsDecode(struct _rfbClientRec *cl, char *dst, signed int len);
// webSocketsDecodeHixie
// file websockets.c line 533
static signed int webSocketsDecodeHixie(struct _rfbClientRec *cl, char *dst, signed int len);
// webSocketsDecodeHybi
// file websockets.c line 628
static signed int webSocketsDecodeHybi(struct _rfbClientRec *cl, char *dst, signed int len);
// webSocketsEncode
// file ../rfb/rfb.h line 766
extern signed int webSocketsEncode(struct _rfbClientRec *cl, const char *src, signed int len, char **dst);
// webSocketsEncodeHixie
// file websockets.c line 488
static signed int webSocketsEncodeHixie(struct _rfbClientRec *cl, const char *src, signed int len, char **dst);
// webSocketsEncodeHybi
// file websockets.c line 772
static signed int webSocketsEncodeHybi(struct _rfbClientRec *cl, const char *src, signed int len, char **dst);
// webSocketsGenMd5
// file websockets.c line 438
void webSocketsGenMd5(char *target, char *key1, char *key2, char *key3);
// webSocketsGenSha1Key
// file websockets.c line 181
static void webSocketsGenSha1Key(char *target, signed int size, char *key);
// webSocketsHandshake
// file websockets.c line 249
static signed char webSocketsHandshake(struct _rfbClientRec *cl, char *scheme);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// ws_peek
// file websockets.c line 518
static signed int ws_peek(struct _rfbClientRec *cl, char *buf, signed int len);
// ws_read
// file websockets.c line 506
static signed int ws_read(struct _rfbClientRec *cl, char *buf, signed int len);
// zrleBufferAlloc
// file zrleoutstream.c line 28
static signed char zrleBufferAlloc(struct anonymous_10 *buffer, signed int size);
// zrleBufferFree
// file zrleoutstream.c line 41
static void zrleBufferFree(struct anonymous_10 *buffer);
// zrleBufferGrow
// file zrleoutstream.c line 48
static signed char zrleBufferGrow(struct anonymous_10 *buffer, signed int size);
// zrleEncode15BE
// file ./zrleencodetemplate.c line 97
static void zrleEncode15BE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode15LE
// file ./zrleencodetemplate.c line 97
static void zrleEncode15LE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode16BE
// file ./zrleencodetemplate.c line 97
static void zrleEncode16BE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode16LE
// file ./zrleencodetemplate.c line 97
static void zrleEncode16LE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode24ABE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24ABE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode24ALE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24ALE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode24BBE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24BBE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode24BLE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24BLE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode32BE
// file ./zrleencodetemplate.c line 97
static void zrleEncode32BE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode32LE
// file ./zrleencodetemplate.c line 97
static void zrleEncode32LE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncode8NE
// file ./zrleencodetemplate.c line 97
static void zrleEncode8NE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl);
// zrleEncodeTile15BE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile15BE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile15LE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile15LE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile16BE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile16BE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile16LE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile16LE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile24ABE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24ABE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile24ALE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24ALE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile24BBE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24BBE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile24BLE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24BLE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile32BE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile32BE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile32LE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile32LE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleEncodeTile8NE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile8NE(unsigned char *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper);
// zrleOutStreamCheck
// file zrleoutstream.c line 212
static signed int zrleOutStreamCheck(struct anonymous_11 *os, signed int size);
// zrleOutStreamFlush
// file zrleoutstream.h line 45
signed char zrleOutStreamFlush(struct anonymous_11 *os);
// zrleOutStreamFree
// file zrleoutstream.h line 44
void zrleOutStreamFree(struct anonymous_11 *os);
// zrleOutStreamNew
// file zrleoutstream.h line 43
struct anonymous_11 * zrleOutStreamNew(void);
// zrleOutStreamOverrun
// file zrleoutstream.c line 151
static signed int zrleOutStreamOverrun(struct anonymous_11 *os, signed int size);
// zrleOutStreamWriteBytes
// file zrleoutstream.h line 46
void zrleOutStreamWriteBytes(struct anonymous_11 *os, const unsigned char *data, signed int length);
// zrleOutStreamWriteOpaque16
// file zrleoutstream.h line 53
void zrleOutStreamWriteOpaque16(struct anonymous_11 *os, unsigned short int u);
// zrleOutStreamWriteOpaque24A
// file zrleoutstream.h line 57
void zrleOutStreamWriteOpaque24A(struct anonymous_11 *os, unsigned int u);
// zrleOutStreamWriteOpaque24B
// file zrleoutstream.h line 59
void zrleOutStreamWriteOpaque24B(struct anonymous_11 *os, unsigned int u);
// zrleOutStreamWriteOpaque32
// file zrleoutstream.h line 55
void zrleOutStreamWriteOpaque32(struct anonymous_11 *os, unsigned int u);
// zrleOutStreamWriteOpaque8
// file zrleoutstream.h line 51
void zrleOutStreamWriteOpaque8(struct anonymous_11 *os, unsigned char u);
// zrleOutStreamWriteU8
// file zrleoutstream.h line 49
void zrleOutStreamWriteU8(struct anonymous_11 *os, unsigned char u);
// zrlePaletteHelperInit
// file ./zrlepalettehelper.h line 40
void zrlePaletteHelperInit(struct anonymous_12 *helper);
// zrlePaletteHelperInsert
// file ./zrlepalettehelper.h line 41
void zrlePaletteHelperInsert(struct anonymous_12 *helper, unsigned int pix);
// zrlePaletteHelperLookup
// file ./zrlepalettehelper.h line 43
signed int zrlePaletteHelperLookup(struct anonymous_12 *helper, unsigned int pix);
// zywrleAnalyze15BE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze15BE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf);
// zywrleAnalyze15LE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze15LE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf);
// zywrleAnalyze16BE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze16BE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf);
// zywrleAnalyze16LE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze16LE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf);
// zywrleAnalyze32BE
// file ../common/zywrletemplate.c line 753
unsigned int * zywrleAnalyze32BE(unsigned int *dst, unsigned int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf);
// zywrleAnalyze32LE
// file ../common/zywrletemplate.c line 753
unsigned int * zywrleAnalyze32LE(unsigned int *dst, unsigned int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf);
// zywrleCalcSize
// file ../common/zywrletemplate.c line 701
static inline void zywrleCalcSize(signed int *pW, signed int *pH, signed int level);
// zywrleRGBYUV15BE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV15BE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline);
// zywrleRGBYUV15LE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV15LE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline);
// zywrleRGBYUV16BE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV16BE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline);
// zywrleRGBYUV16LE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV16LE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline);
// zywrleRGBYUV32BE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV32BE(signed int *pBuf, unsigned int *data, signed int width, signed int height, signed int scanline);
// zywrleRGBYUV32LE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV32LE(signed int *pBuf, unsigned int *data, signed int width, signed int height, signed int scanline);

struct anonymous_49
{
  // screen
  struct _rfbScreenInfo *screen;
  // font
  struct rfbFontData *font;
  // list
  char **list;
  // listSize
  signed int listSize;
  // selected
  signed int selected;
  // displayStart
  signed int displayStart;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // textH
  signed int textH;
  // pageH
  signed int pageH;
  // xhot
  signed int xhot;
  // yhot
  signed int yhot;
  // buttonWidth
  signed int buttonWidth;
  // okBX
  signed int okBX;
  // cancelBX
  signed int cancelBX;
  // okX
  signed int okX;
  // cancelX
  signed int cancelX;
  // okY
  signed int okY;
  // okInverted
  signed char okInverted;
  // cancelInverted
  signed char cancelInverted;
  // lastButtons
  signed int lastButtons;
  // colour
  unsigned int colour;
  // backColour
  unsigned int backColour;
  // selChangedHook
  void (*selChangedHook)(signed int);
  // state
  enum anonymous_48 state;
};

struct anonymous_10
{
  // start
  unsigned char *start;
  // ptr
  unsigned char *ptr;
  // end
  unsigned char *end;
};

struct anonymous_12
{
  // palette
  unsigned int palette[127l];
  // index
  unsigned char index[4223l];
  // key
  unsigned int key[4223l];
  // size
  signed int size;
};

struct anonymous_16
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_39
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_35
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_55
{
  // client2server
  unsigned char client2server[32l];
  // server2client
  unsigned char server2client[32l];
};

struct anonymous_33
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_20
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_34
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_33 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous_36
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_29
{
  // num
  signed int num;
  // denom
  signed int denom;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};

struct anonymous_11
{
  // in
  struct anonymous_10 in;
  // out
  struct anonymous_10 out;
  // zs
  struct z_stream_s zs;
};

struct anonymous_5
{
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
};

struct anonymous_2
{
  // r
  struct anonymous_5 r;
  // encoding
  unsigned int encoding;
};

struct anonymous_7
{
  // bitsPerPixel
  unsigned char bitsPerPixel;
  // depth
  unsigned char depth;
  // bigEndian
  unsigned char bigEndian;
  // trueColour
  unsigned char trueColour;
  // redMax
  unsigned short int redMax;
  // greenMax
  unsigned short int greenMax;
  // blueMax
  unsigned short int blueMax;
  // redShift
  unsigned char redShift;
  // greenShift
  unsigned char greenShift;
  // blueShift
  unsigned char blueShift;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned short int pad2;
};

struct anonymous_50
{
  // framebufferWidth
  unsigned short int framebufferWidth;
  // framebufferHeight
  unsigned short int framebufferHeight;
  // format
  struct anonymous_7 format;
  // nameLength
  unsigned int nameLength;
};

union ws_mask_s
{
  // c
  char c[4l];
  // u
  unsigned int u;
};

struct anonymous_40
{
  // l16
  unsigned short int l16;
  // m16
  union ws_mask_s m16;
} __attribute__ ((__packed__));

struct anonymous_4
{
  // srcX
  unsigned short int srcX;
  // srcY
  unsigned short int srcY;
};

union anonymous_19
{
  // bytes
  unsigned char *bytes;
  // shorts
  unsigned short int *shorts;
};

struct anonymous_15
{
  // count
  unsigned int count;
  // is16
  signed char is16;
  // data
  union anonymous_19 data;
};

struct anonymous_52
{
  // dwLowDateTime
  unsigned int dwLowDateTime;
  // dwHighDateTime
  unsigned int dwHighDateTime;
};

struct anonymous_53
{
  // dwFileAttributes
  unsigned int dwFileAttributes;
  // ftCreationTime
  struct anonymous_52 ftCreationTime;
  // ftLastAccessTime
  struct anonymous_52 ftLastAccessTime;
  // ftLastWriteTime
  struct anonymous_52 ftLastWriteTime;
  // nFileSizeHigh
  unsigned int nFileSizeHigh;
  // nFileSizeLow
  unsigned int nFileSizeLow;
  // dwReserved0
  unsigned int dwReserved0;
  // dwReserved1
  unsigned int dwReserved1;
  // cFileName
  unsigned char cFileName[260l];
  // cAlternateFileName
  unsigned char cAlternateFileName[14l];
};

struct anonymous_18
{
  // length
  unsigned int length;
};

struct anonymous_3
{
  // nBytes
  unsigned int nBytes;
};

struct anonymous_14
{
  // nSubrects
  unsigned int nSubrects;
};

struct anonymous_41
{
  // l64
  unsigned long int l64;
  // m64
  union ws_mask_s m64;
} __attribute__ ((__packed__));

struct anonymous_43
{
  // foreRed
  unsigned char foreRed;
  // foreGreen
  unsigned char foreGreen;
  // foreBlue
  unsigned char foreBlue;
  // backRed
  unsigned char backRed;
  // backGreen
  unsigned char backGreen;
  // backBlue
  unsigned char backBlue;
};

struct anonymous_54
{
  // shared
  unsigned char shared;
};

struct anonymous_56
{
  // type
  unsigned char type;
};

struct anonymous_28
{
  // type
  unsigned char type;
  // buttonMask
  unsigned char buttonMask;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
};

struct anonymous_27
{
  // type
  unsigned char type;
  // down
  unsigned char down;
  // pad
  unsigned short int pad;
  // key
  unsigned int key;
};

struct anonymous_26
{
  // type
  unsigned char type;
  // incremental
  unsigned char incremental;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
};

struct anonymous_21
{
  // type
  unsigned char type;
  // pad
  unsigned char pad;
  // firstColour
  unsigned short int firstColour;
  // nColours
  unsigned short int nColours;
};

struct anonymous_25
{
  // type
  unsigned char type;
  // pad
  unsigned char pad;
  // nEncodings
  unsigned short int nEncodings;
};

struct anonymous_57
{
  // type
  unsigned char type;
  // pad
  unsigned char pad;
  // nRects
  unsigned short int nRects;
};

struct anonymous_23
{
  // type
  unsigned char type;
  // pad
  unsigned char pad;
  // version
  unsigned char version;
  // code
  unsigned char code;
};

struct anonymous_8
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // desktop_w
  unsigned short int desktop_w;
  // desktop_h
  unsigned short int desktop_h;
  // buffer_w
  unsigned short int buffer_w;
  // buffer_h
  unsigned short int buffer_h;
  // pad2
  unsigned short int pad2;
};

struct anonymous_24
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned short int pad2;
  // format
  struct anonymous_7 format;
};

struct anonymous_22
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned short int pad2;
  // length
  unsigned int length;
};

struct anonymous_30
{
  // type
  unsigned char type;
  // scale
  unsigned char scale;
  // pad2
  unsigned short int pad2;
};

struct anonymous_17
{
  // x
  unsigned char x;
  // y
  unsigned char y;
  // w
  unsigned char w;
  // h
  unsigned char h;
};

union anonymous_6
{
  // a00
  void *a00;
  // a01
  unsigned char *a01;
  // a02
  unsigned long int a02;
  // a03
  unsigned long int a03;
  // a04
  unsigned long int a04;
  // a05
  void *a05;
  // a06
  unsigned char *a06;
  // a07
  unsigned long int a07;
  // a08
  unsigned long int a08;
  // a09
  signed long int a09;
  // a10
  unsigned long int a10;
};

union anonymous_0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_31
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

union anonymous
{
  // __data
  struct anonymous_20 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_42
{
  // s16
  struct anonymous_40 s16;
  // s64
  struct anonymous_41 s64;
  // m
  union ws_mask_s m;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_9
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _rfbSetScaleMsg
{
  // type
  unsigned char type;
  // scale
  unsigned char scale;
  // pad
  unsigned short int pad;
};

struct _rfbSetServerInputMsg
{
  // type
  unsigned char type;
  // status
  unsigned char status;
  // pad
  unsigned short int pad;
};

struct _rfbFileTransferMsg
{
  // type
  unsigned char type;
  // contentType
  unsigned char contentType;
  // contentParam
  unsigned char contentParam;
  // pad
  unsigned char pad;
  // size
  unsigned int size;
  // length
  unsigned int length;
};

struct _rfbSetSWMsg
{
  // type
  unsigned char type;
  // status
  unsigned char status;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
};

struct _rfbTextChatMsg
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // pad2
  unsigned short int pad2;
  // length
  unsigned int length;
};

union anonymous_1
{
  // type
  unsigned char type;
  // spf
  struct anonymous_24 spf;
  // fcme
  struct anonymous_21 fcme;
  // se
  struct anonymous_25 se;
  // fur
  struct anonymous_26 fur;
  // ke
  struct anonymous_27 ke;
  // pe
  struct anonymous_28 pe;
  // cct
  struct anonymous_22 cct;
  // ssc
  struct _rfbSetScaleMsg ssc;
  // pssf
  struct anonymous_30 pssf;
  // sim
  struct _rfbSetServerInputMsg sim;
  // ft
  struct _rfbFileTransferMsg ft;
  // sw
  struct _rfbSetSWMsg sw;
  // tc
  struct _rfbTextChatMsg tc;
  // xvp
  struct anonymous_23 xvp;
};

struct COLOR_LIST_s
{
  // next
  struct COLOR_LIST_s *next;
  // idx
  signed int idx;
  // rgb
  unsigned int rgb;
};

struct PALETTE_ENTRY_s
{
  // listNode
  struct COLOR_LIST_s *listNode;
  // numPixels
  signed int numPixels;
};

struct PALETTE_s
{
  // entry
  struct PALETTE_ENTRY_s entry[256l];
  // hash
  struct COLOR_LIST_s *hash[256l];
  // list
  struct COLOR_LIST_s list[256l];
};

struct TIGHT_CONF_s
{
  // maxRectSize
  signed int maxRectSize;
  // maxRectWidth
  signed int maxRectWidth;
  // monoMinRectSize
  signed int monoMinRectSize;
  // idxZlibLevel
  signed int idxZlibLevel;
  // monoZlibLevel
  signed int monoZlibLevel;
  // rawZlibLevel
  signed int rawZlibLevel;
  // idxMaxColorsDivisor
  signed int idxMaxColorsDivisor;
  // palMaxColorsWithJPEG
  signed int palMaxColorsWithJPEG;
};

struct _FileListInfo
{
  // pEntries
  struct _FileListItemInfo *pEntries;
  // numEntries
  signed int numEntries;
};

struct _FileListItemInfo
{
  // name
  char name[255l];
  // size
  unsigned int size;
  // data
  unsigned int data;
};

struct _FileListItemSize
{
  // size
  unsigned int size;
  // data
  unsigned int data;
};

struct _FileTransferMsg
{
  // data
  char *data;
  // length
  unsigned int length;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_39 __saved_mask;
};

struct _rect
{
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
};

struct _rfbAuthenticationCapsMsg
{
  // nAuthTypes
  unsigned int nAuthTypes;
};

struct _rfbCapabilityInfo
{
  // code
  unsigned int code;
  // vendorSignature
  unsigned char vendorSignature[4l];
  // nameSignature
  unsigned char nameSignature[8l];
};

struct _rfbClientFileDownload
{
  // fName
  char fName[4096l];
  // downloadInProgress
  signed int downloadInProgress;
  // mTime
  unsigned long int mTime;
  // downloadFD
  signed int downloadFD;
};

struct _rfbClientFileUpload
{
  // fName
  char fName[4096l];
  // uploadInProgress
  signed int uploadInProgress;
  // mTime
  unsigned long int mTime;
  // fSize
  unsigned long int fSize;
  // uploadFD
  signed int uploadFD;
};

struct _rfbClientFileTransfer
{
  // rcfd
  struct _rfbClientFileDownload rcfd;
  // rcfu
  struct _rfbClientFileUpload rcfu;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _rfbFileTransferData
{
  // fd
  signed int fd;
  // compressionEnabled
  signed int compressionEnabled;
  // fileSize
  signed int fileSize;
  // numPackets
  signed int numPackets;
  // receiving
  signed int receiving;
  // sending
  signed int sending;
};

struct _rfbClientRec
{
  // screen
  struct _rfbScreenInfo *screen;
  // scaledScreen
  struct _rfbScreenInfo *scaledScreen;
  // PalmVNC
  signed char PalmVNC;
  // clientData
  void *clientData;
  // clientGoneHook
  void (*clientGoneHook)(struct _rfbClientRec *);
  // sock
  signed int sock;
  // host
  char *host;
  // protocolMajorVersion
  signed int protocolMajorVersion;
  // protocolMinorVersion
  signed int protocolMinorVersion;
  // client_thread
  unsigned long int client_thread;
  // state
  enum anonymous_13 state;
  // reverseConnection
  signed char reverseConnection;
  // onHold
  signed char onHold;
  // readyForSetColourMapEntries
  signed char readyForSetColourMapEntries;
  // useCopyRect
  signed char useCopyRect;
  // preferredEncoding
  signed int preferredEncoding;
  // correMaxWidth
  signed int correMaxWidth;
  // correMaxHeight
  signed int correMaxHeight;
  // viewOnly
  signed char viewOnly;
  // authChallenge
  unsigned char authChallenge[16l];
  // copyRegion
  struct sraRegion *copyRegion;
  // copyDX
  signed int copyDX;
  // copyDY
  signed int copyDY;
  // modifiedRegion
  struct sraRegion *modifiedRegion;
  // requestedRegion
  struct sraRegion *requestedRegion;
  // startDeferring
  struct timeval startDeferring;
  // startPtrDeferring
  struct timeval startPtrDeferring;
  // lastPtrX
  signed int lastPtrX;
  // lastPtrY
  signed int lastPtrY;
  // lastPtrButtons
  signed int lastPtrButtons;
  // translateFn
  void (*translateFn)(char *, struct anonymous_7 *, struct anonymous_7 *, char *, char *, signed int, signed int, signed int);
  // translateLookupTable
  char *translateLookupTable;
  // format
  struct anonymous_7 format;
  // updateBuf
  char updateBuf[30000l];
  // ublen
  signed int ublen;
  // statEncList
  struct _rfbStatList *statEncList;
  // statMsgList
  struct _rfbStatList *statMsgList;
  // rawBytesEquivalent
  signed int rawBytesEquivalent;
  // bytesSent
  signed int bytesSent;
  // compStream
  struct z_stream_s compStream;
  // compStreamInited
  signed char compStreamInited;
  // zlibCompressLevel
  unsigned int zlibCompressLevel;
  // tightQualityLevel
  signed int tightQualityLevel;
  // zsStruct
  struct z_stream_s zsStruct[4l];
  // zsActive
  signed char zsActive[4l];
  // zsLevel
  signed int zsLevel[4l];
  // tightCompressLevel
  signed int tightCompressLevel;
  // compStreamInitedLZO
  signed char compStreamInitedLZO;
  // lzoWrkMem
  char *lzoWrkMem;
  // fileTransfer
  struct _rfbFileTransferData fileTransfer;
  // lastKeyboardLedState
  signed int lastKeyboardLedState;
  // enableSupportedMessages
  signed char enableSupportedMessages;
  // enableSupportedEncodings
  signed char enableSupportedEncodings;
  // enableServerIdentity
  signed char enableServerIdentity;
  // enableKeyboardLedState
  signed char enableKeyboardLedState;
  // enableLastRectEncoding
  signed char enableLastRectEncoding;
  // enableCursorShapeUpdates
  signed char enableCursorShapeUpdates;
  // enableCursorPosUpdates
  signed char enableCursorPosUpdates;
  // useRichCursorEncoding
  signed char useRichCursorEncoding;
  // cursorWasChanged
  signed char cursorWasChanged;
  // cursorWasMoved
  signed char cursorWasMoved;
  // cursorX
  signed int cursorX;
  // cursorY
  signed int cursorY;
  // useNewFBSize
  signed char useNewFBSize;
  // newFBSizePending
  signed char newFBSizePending;
  // prev
  struct _rfbClientRec *prev;
  // next
  struct _rfbClientRec *next;
  // refCount
  signed int refCount;
  // refCountMutex
  union anonymous_9 refCountMutex;
  // deleteCond
  union anonymous deleteCond;
  // outputMutex
  union anonymous_9 outputMutex;
  // updateMutex
  union anonymous_9 updateMutex;
  // updateCond
  union anonymous updateCond;
  // zrleData
  void *zrleData;
  // zywrleLevel
  signed int zywrleLevel;
  // zywrleBuf
  signed int zywrleBuf[4096l];
  // progressiveSliceY
  signed int progressiveSliceY;
  // extensions
  struct _rfbExtensionData *extensions;
  // zrleBeforeBuf
  char *zrleBeforeBuf;
  // paletteHelper
  void *paletteHelper;
  // sendMutex
  union anonymous_9 sendMutex;
  // beforeEncBuf
  char *beforeEncBuf;
  // beforeEncBufSize
  signed int beforeEncBufSize;
  // afterEncBuf
  char *afterEncBuf;
  // afterEncBufSize
  signed int afterEncBufSize;
  // afterEncBufLen
  signed int afterEncBufLen;
  // tightEncoding
  unsigned int tightEncoding;
  // turboSubsampLevel
  signed int turboSubsampLevel;
  // turboQualityLevel
  signed int turboQualityLevel;
  // sslctx
  struct _rfbSslCtx *sslctx;
  // wsctx
  struct _wsCtx *wsctx;
  // wspath
  char *wspath;
};

struct _rfbFileListRequestMsg
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // dirNameSize
  unsigned short int dirNameSize;
};

struct _rfbFileDownloadRequestMsg
{
  // type
  unsigned char type;
  // compressedLevel
  unsigned char compressedLevel;
  // fNameSize
  unsigned short int fNameSize;
  // position
  unsigned int position;
};

struct _rfbFileUploadRequestMsg
{
  // type
  unsigned char type;
  // compressedLevel
  unsigned char compressedLevel;
  // fNameSize
  unsigned short int fNameSize;
  // position
  unsigned int position;
};

struct _rfbFileUploadDataMsg
{
  // type
  unsigned char type;
  // compressedLevel
  unsigned char compressedLevel;
  // realSize
  unsigned short int realSize;
  // compressedSize
  unsigned short int compressedSize;
};

struct _rfbFileDownloadCancelMsg
{
  // type
  unsigned char type;
  // unused
  unsigned char unused;
  // reasonLen
  unsigned short int reasonLen;
};

struct _rfbFileUploadFailedMsg
{
  // type
  unsigned char type;
  // unused
  unsigned char unused;
  // reasonLen
  unsigned short int reasonLen;
};

struct _rfbFileCreateDirRequestMsg
{
  // type
  unsigned char type;
  // unused
  unsigned char unused;
  // dNameLen
  unsigned short int dNameLen;
};

union _rfbClientToServerTightMsg
{
  // flr
  struct _rfbFileListRequestMsg flr;
  // fdr
  struct _rfbFileDownloadRequestMsg fdr;
  // fupr
  struct _rfbFileUploadRequestMsg fupr;
  // fud
  struct _rfbFileUploadDataMsg fud;
  // fdc
  struct _rfbFileDownloadCancelMsg fdc;
  // fuf
  struct _rfbFileUploadFailedMsg fuf;
  // fcdr
  struct _rfbFileCreateDirRequestMsg fcdr;
};

struct _rfbExtensionData
{
  // extension
  struct _rfbProtocolExtension *extension;
  // data
  void *data;
  // next
  struct _rfbExtensionData *next;
};

struct _rfbFileDownloadDataMsg
{
  // type
  unsigned char type;
  // compressLevel
  unsigned char compressLevel;
  // realSize
  unsigned short int realSize;
  // compressedSize
  unsigned short int compressedSize;
};

struct _rfbFileDownloadFailedMsg
{
  // type
  unsigned char type;
  // unused
  unsigned char unused;
  // reasonLen
  unsigned short int reasonLen;
};

struct _rfbFileListDataMsg
{
  // type
  unsigned char type;
  // flags
  unsigned char flags;
  // numFiles
  unsigned short int numFiles;
  // dataSize
  unsigned short int dataSize;
  // compressedSize
  unsigned short int compressedSize;
};

struct _rfbFileUploadCancelMsg
{
  // type
  unsigned char type;
  // unused
  unsigned char unused;
  // reasonLen
  unsigned short int reasonLen;
};

struct _rfbInteractionCapsMsg
{
  // nServerMessageTypes
  unsigned short int nServerMessageTypes;
  // nClientMessageTypes
  unsigned short int nClientMessageTypes;
  // nEncodingTypes
  unsigned short int nEncodingTypes;
  // pad
  unsigned short int pad;
};

struct _rfbProtocolExtension
{
  // newClient
  signed char (*newClient)(struct _rfbClientRec *, void **);
  // init
  signed char (*init)(struct _rfbClientRec *, void *);
  // pseudoEncodings
  signed int *pseudoEncodings;
  // enablePseudoEncoding
  signed char (*enablePseudoEncoding)(struct _rfbClientRec *, void **, signed int);
  // handleMessage
  signed char (*handleMessage)(struct _rfbClientRec *, void *, const union anonymous_1 *);
  // close
  void (*close)(struct _rfbClientRec *, void *);
  // usage
  void (*usage)(void);
  // processArgument
  signed int (*processArgument)(signed int, char **);
  // next
  struct _rfbProtocolExtension *next;
};

struct _rfbResizeFrameBufferMsg
{
  // type
  unsigned char type;
  // pad1
  unsigned char pad1;
  // framebufferWidth
  unsigned short int framebufferWidth;
  // framebufferHeigth
  unsigned short int framebufferHeigth;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct _rfbScreenInfo
{
  // scaledScreenNext
  struct _rfbScreenInfo *scaledScreenNext;
  // scaledScreenRefCount
  signed int scaledScreenRefCount;
  // width
  signed int width;
  // paddedWidthInBytes
  signed int paddedWidthInBytes;
  // height
  signed int height;
  // depth
  signed int depth;
  // bitsPerPixel
  signed int bitsPerPixel;
  // sizeInBytes
  signed int sizeInBytes;
  // blackPixel
  unsigned int blackPixel;
  // whitePixel
  unsigned int whitePixel;
  // screenData
  void *screenData;
  // serverFormat
  struct anonymous_7 serverFormat;
  // colourMap
  struct anonymous_15 colourMap;
  // desktopName
  const char *desktopName;
  // thisHost
  char thisHost[255l];
  // autoPort
  signed char autoPort;
  // port
  signed int port;
  // listenSock
  signed int listenSock;
  // maxSock
  signed int maxSock;
  // maxFd
  signed int maxFd;
  // allFds
  struct anonymous_16 allFds;
  // socketState
  enum rfbSocketState socketState;
  // inetdSock
  signed int inetdSock;
  // inetdInitDone
  signed char inetdInitDone;
  // udpPort
  signed int udpPort;
  // udpSock
  signed int udpSock;
  // udpClient
  struct _rfbClientRec *udpClient;
  // udpSockConnected
  signed char udpSockConnected;
  // udpRemoteAddr
  struct sockaddr_in udpRemoteAddr;
  // maxClientWait
  signed int maxClientWait;
  // httpInitDone
  signed char httpInitDone;
  // httpEnableProxyConnect
  signed char httpEnableProxyConnect;
  // httpPort
  signed int httpPort;
  // httpDir
  char *httpDir;
  // httpListenSock
  signed int httpListenSock;
  // httpSock
  signed int httpSock;
  // passwordCheck
  signed char (*passwordCheck)(struct _rfbClientRec *, const char *, signed int);
  // authPasswdData
  void *authPasswdData;
  // authPasswdFirstViewOnly
  signed int authPasswdFirstViewOnly;
  // maxRectsPerUpdate
  signed int maxRectsPerUpdate;
  // deferUpdateTime
  signed int deferUpdateTime;
  // alwaysShared
  signed char alwaysShared;
  // neverShared
  signed char neverShared;
  // dontDisconnect
  signed char dontDisconnect;
  // clientHead
  struct _rfbClientRec *clientHead;
  // pointerClient
  struct _rfbClientRec *pointerClient;
  // cursorX
  signed int cursorX;
  // cursorY
  signed int cursorY;
  // underCursorBufferLen
  signed int underCursorBufferLen;
  // underCursorBuffer
  char *underCursorBuffer;
  // dontConvertRichCursorToXCursor
  signed char dontConvertRichCursorToXCursor;
  // cursor
  struct rfbCursor *cursor;
  // frameBuffer
  char *frameBuffer;
  // kbdAddEvent
  void (*kbdAddEvent)(signed char, unsigned int, struct _rfbClientRec *);
  // kbdReleaseAllKeys
  void (*kbdReleaseAllKeys)(struct _rfbClientRec *);
  // ptrAddEvent
  void (*ptrAddEvent)(signed int, signed int, signed int, struct _rfbClientRec *);
  // setXCutText
  void (*setXCutText)(char *, signed int, struct _rfbClientRec *);
  // getCursorPtr
  struct rfbCursor * (*getCursorPtr)(struct _rfbClientRec *);
  // setTranslateFunction
  signed char (*setTranslateFunction)(struct _rfbClientRec *);
  // setSingleWindow
  void (*setSingleWindow)(struct _rfbClientRec *, signed int, signed int);
  // setServerInput
  void (*setServerInput)(struct _rfbClientRec *, signed int);
  // getFileTransferPermission
  signed int (*getFileTransferPermission)(struct _rfbClientRec *);
  // setTextChat
  void (*setTextChat)(struct _rfbClientRec *, signed int, char *);
  // newClientHook
  enum rfbNewClientAction (*newClientHook)(struct _rfbClientRec *);
  // displayHook
  void (*displayHook)(struct _rfbClientRec *);
  // getKeyboardLedStateHook
  signed int (*getKeyboardLedStateHook)(struct _rfbScreenInfo *);
  // cursorMutex
  union anonymous_9 cursorMutex;
  // backgroundLoop
  signed char backgroundLoop;
  // ignoreSIGPIPE
  signed char ignoreSIGPIPE;
  // progressiveSliceHeight
  signed int progressiveSliceHeight;
  // listenInterface
  unsigned int listenInterface;
  // deferPtrUpdateTime
  signed int deferPtrUpdateTime;
  // handleEventsEagerly
  signed char handleEventsEagerly;
  // versionString
  char *versionString;
  // protocolMajorVersion
  signed int protocolMajorVersion;
  // protocolMinorVersion
  signed int protocolMinorVersion;
  // permitFileTransfer
  signed char permitFileTransfer;
  // displayFinishedHook
  void (*displayFinishedHook)(struct _rfbClientRec *, signed int);
  // xvpHook
  signed char (*xvpHook)(struct _rfbClientRec *, unsigned char, unsigned char);
  // sslkeyfile
  char *sslkeyfile;
  // sslcertfile
  char *sslcertfile;
  // ipv6port
  signed int ipv6port;
  // listen6Interface
  char *listen6Interface;
  // listen6Sock
  signed int listen6Sock;
  // http6Port
  signed int http6Port;
  // httpListen6Sock
  signed int httpListen6Sock;
};

struct _rfbSecurity
{
  // type
  unsigned char type;
  // handler
  void (*handler)(struct _rfbClientRec *);
  // next
  struct _rfbSecurity *next;
};

struct _rfbStatList
{
  // type
  unsigned int type;
  // sentCount
  unsigned int sentCount;
  // bytesSent
  unsigned int bytesSent;
  // bytesSentIfRaw
  unsigned int bytesSentIfRaw;
  // rcvdCount
  unsigned int rcvdCount;
  // bytesRcvd
  unsigned int bytesRcvd;
  // bytesRcvdIfRaw
  unsigned int bytesRcvdIfRaw;
  // Next
  struct _rfbStatList *Next;
};

struct _rfbTightClientRec
{
  // nAuthCaps
  signed int nAuthCaps;
  // authCaps
  unsigned int authCaps[16l];
  // rcft
  struct _rfbClientFileTransfer rcft;
};

struct _rfbTunnelingCapsMsg
{
  // nTunnelTypes
  unsigned int nTunnelTypes;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous_32 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_32 jpeg_color_space;
  // comp_info
  struct anonymous_34 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_33 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_35 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_35 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous_36 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_37 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_34 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous_36 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_decompress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // src
  struct jpeg_source_mgr *src;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_32 jpeg_color_space;
  // out_color_space
  enum anonymous_32 out_color_space;
  // scale_num
  unsigned int scale_num;
  // scale_denom
  unsigned int scale_denom;
  // output_gamma
  double output_gamma;
  // buffered_image
  signed int buffered_image;
  // raw_data_out
  signed int raw_data_out;
  // dct_method
  enum anonymous_37 dct_method;
  // do_fancy_upsampling
  signed int do_fancy_upsampling;
  // do_block_smoothing
  signed int do_block_smoothing;
  // quantize_colors
  signed int quantize_colors;
  // dither_mode
  enum anonymous_38 dither_mode;
  // two_pass_quantize
  signed int two_pass_quantize;
  // desired_number_of_colors
  signed int desired_number_of_colors;
  // enable_1pass_quant
  signed int enable_1pass_quant;
  // enable_external_quant
  signed int enable_external_quant;
  // enable_2pass_quant
  signed int enable_2pass_quant;
  // output_width
  unsigned int output_width;
  // output_height
  unsigned int output_height;
  // out_color_components
  signed int out_color_components;
  // output_components
  signed int output_components;
  // rec_outbuf_height
  signed int rec_outbuf_height;
  // actual_number_of_colors
  signed int actual_number_of_colors;
  // colormap
  unsigned char **colormap;
  // output_scanline
  unsigned int output_scanline;
  // input_scan_number
  signed int input_scan_number;
  // input_iMCU_row
  unsigned int input_iMCU_row;
  // output_scan_number
  signed int output_scan_number;
  // output_iMCU_row
  unsigned int output_iMCU_row;
  // coef_bits
  signed int (*coef_bits)[64l];
  // quant_tbl_ptrs
  struct anonymous_33 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_35 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_35 *ac_huff_tbl_ptrs[4l];
  // data_precision
  signed int data_precision;
  // comp_info
  struct anonymous_34 *comp_info;
  // progressive_mode
  signed int progressive_mode;
  // arith_code
  signed int arith_code;
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // restart_interval
  unsigned int restart_interval;
  // saw_JFIF_marker
  signed int saw_JFIF_marker;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // saw_Adobe_marker
  signed int saw_Adobe_marker;
  // Adobe_transform
  unsigned char Adobe_transform;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // marker_list
  struct jpeg_marker_struct *marker_list;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // min_DCT_scaled_size
  signed int min_DCT_scaled_size;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // sample_range_limit
  unsigned char *sample_range_limit;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_34 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // unread_marker
  signed int unread_marker;
  // master
  struct jpeg_decomp_master *master;
  // main
  struct jpeg_d_main_controller *main;
  // coef
  struct jpeg_d_coef_controller *coef;
  // post
  struct jpeg_d_post_controller *post;
  // inputctl
  struct jpeg_input_controller *inputctl;
  // marker
  struct jpeg_marker_reader *marker;
  // entropy
  struct jpeg_entropy_decoder *entropy;
  // idct
  struct jpeg_inverse_dct *idct;
  // upsample
  struct jpeg_upsampler *upsample;
  // cconvert
  struct jpeg_color_deconverter *cconvert;
  // cquantize
  struct jpeg_color_quantizer *cquantize;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_source_mgr
{
  // next_input_byte
  const unsigned char *next_input_byte;
  // bytes_in_buffer
  unsigned long int bytes_in_buffer;
  // init_source
  void (*init_source)(struct jpeg_decompress_struct *);
  // fill_input_buffer
  signed int (*fill_input_buffer)(struct jpeg_decompress_struct *);
  // skip_input_data
  void (*skip_input_data)(struct jpeg_decompress_struct *, signed long int);
  // resync_to_restart
  signed int (*resync_to_restart)(struct jpeg_decompress_struct *, signed int);
  // term_source
  void (*term_source)(struct jpeg_decompress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous_31 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct my_error_mgr
{
  // pub
  struct jpeg_error_mgr pub;
  // setjmp_buffer
  struct __jmp_buf_tag setjmp_buffer[1l];
};

struct _tjinstance
{
  // cinfo
  struct jpeg_compress_struct cinfo;
  // dinfo
  struct jpeg_decompress_struct dinfo;
  // jdst
  struct jpeg_destination_mgr jdst;
  // jsrc
  struct jpeg_source_mgr jsrc;
  // jerr
  struct my_error_mgr jerr;
  // init
  signed int init;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct gcry_md_handle
{
  // ctx
  struct gcry_md_context *ctx;
  // bufpos
  signed int bufpos;
  // bufsize
  signed int bufsize;
  // buf
  unsigned char buf[1l];
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_marker_struct
{
  // next
  struct jpeg_marker_struct *next;
  // marker
  unsigned char marker;
  // original_length
  unsigned int original_length;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct lzo_callback_t
{
  // nalloc
  void * (*nalloc)(struct lzo_callback_t *, unsigned long int, unsigned long int);
  // nfree
  void (*nfree)(struct lzo_callback_t *, void *);
  // nprogress
  void (*nprogress)(struct lzo_callback_t *, unsigned long int, unsigned long int, signed int);
  // user1
  void *user1;
  // user2
  unsigned long int user2;
  // user3
  unsigned long int user3;
};

union lzo_config_check_union
{
  // a
  unsigned long int a[2l];
  // b
  unsigned char b[16l];
  // c
  unsigned long int c[2l];
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rfbClientIterator
{
  // next
  struct _rfbClientRec *next;
  // screen
  struct _rfbScreenInfo *screen;
  // closedToo
  signed char closedToo;
};

struct rfbCursor
{
  // cleanup
  signed char cleanup;
  // cleanupSource
  signed char cleanupSource;
  // cleanupMask
  signed char cleanupMask;
  // cleanupRichSource
  signed char cleanupRichSource;
  // source
  unsigned char *source;
  // mask
  unsigned char *mask;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // xhot
  unsigned short int xhot;
  // yhot
  unsigned short int yhot;
  // foreRed
  unsigned short int foreRed;
  // foreGreen
  unsigned short int foreGreen;
  // foreBlue
  unsigned short int foreBlue;
  // backRed
  unsigned short int backRed;
  // backGreen
  unsigned short int backGreen;
  // backBlue
  unsigned short int backBlue;
  // richSource
  unsigned char *richSource;
  // alphaSource
  unsigned char *alphaSource;
  // alphaPreMultiplied
  signed char alphaPreMultiplied;
};

struct rfbFontData
{
  // data
  unsigned char *data;
  // metaData
  signed int *metaData;
};

struct rfbssl_ctx
{
  // peekbuf
  char peekbuf[2048l];
  // peeklen
  signed int peeklen;
  // peekstart
  signed int peekstart;
  // session
  struct gnutls_session_int *session;
  // x509_cred
  struct gnutls_certificate_credentials_st *x509_cred;
  // dh_params
  struct gnutls_dh_params_int *dh_params;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sraRectangleIterator
{
  // reverseX
  signed char reverseX;
  // reverseY
  signed char reverseY;
  // ptrSize
  signed int ptrSize;
  // ptrPos
  signed int ptrPos;
  // sPtrs
  struct sraSpan **sPtrs;
};

struct sraSpan
{
  // _next
  struct sraSpan *_next;
  // _prev
  struct sraSpan *_prev;
  // start
  signed int start;
  // end
  signed int end;
  // subspan
  struct sraRegion *subspan;
};

struct sraRegion
{
  // front
  struct sraSpan front;
  // back
  struct sraSpan back;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utimbuf
{
  // actime
  signed long int actime;
  // modtime
  signed long int modtime;
};

struct ws_ctx_s
{
  // codeBuf
  char codeBuf[40014l];
  // readbuf
  char readbuf[8192l];
  // readbufstart
  signed int readbufstart;
  // readbuflen
  signed int readbuflen;
  // dblen
  signed int dblen;
  // carryBuf
  char carryBuf[3l];
  // carrylen
  signed int carrylen;
  // version
  signed int version;
  // base64
  signed int base64;
  // encode
  signed int (*encode)(struct _rfbClientRec *, const char *, signed int, char **);
  // decode
  signed int (*decode)(struct _rfbClientRec *, char *, signed int);
};

struct ws_header_s
{
  // b0
  unsigned char b0;
  // b1
  unsigned char b1;
  // u
  union anonymous_42 u;
} __attribute__ ((__packed__));


// BGR233Format
// file translate.c line 38
static const struct anonymous_7 BGR233Format = { .bitsPerPixel=(unsigned char)8, .depth=(unsigned char)8, .bigEndian=(unsigned char)0,
    .trueColour=(unsigned char)1, .redMax=(unsigned short int)7,
    .greenMax=(unsigned short int)7, .blueMax=(unsigned short int)3,
    .redShift=(unsigned char)0, .greenShift=(unsigned char)3,
    .blueShift=(unsigned char)6, .pad1=(unsigned char)0,
    .pad2=(unsigned short int)0 };
// DB
// file rfbserver.c line 1189
signed int DB = 1;
// KnL
// file ../common/d3des.c line 36
static unsigned long int KnL[32l] = { (unsigned long int)0L, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul };
// SP1
// file ../common/d3des.c line 189
static unsigned long int SP1[64l] = { (unsigned long int)0x01010400L, (unsigned long int)0x00000000L, (unsigned long int)0x00010000L, (unsigned long int)0x01010404L, (unsigned long int)0x01010004L, (unsigned long int)0x00010404L, (unsigned long int)0x00000004L, (unsigned long int)0x00010000L, (unsigned long int)0x00000400L, (unsigned long int)0x01010400L, (unsigned long int)0x01010404L, (unsigned long int)0x00000400L, (unsigned long int)0x01000404L, (unsigned long int)0x01010004L, (unsigned long int)0x01000000L, (unsigned long int)0x00000004L, (unsigned long int)0x00000404L, (unsigned long int)0x01000400L, (unsigned long int)0x01000400L, (unsigned long int)0x00010400L, (unsigned long int)0x00010400L, (unsigned long int)0x01010000L, (unsigned long int)0x01010000L, (unsigned long int)0x01000404L, (unsigned long int)0x00010004L, (unsigned long int)0x01000004L, (unsigned long int)0x01000004L, (unsigned long int)0x00010004L, (unsigned long int)0x00000000L, (unsigned long int)0x00000404L, (unsigned long int)0x00010404L, (unsigned long int)0x01000000L, (unsigned long int)0x00010000L, (unsigned long int)0x01010404L, (unsigned long int)0x00000004L, (unsigned long int)0x01010000L, (unsigned long int)0x01010400L, (unsigned long int)0x01000000L, (unsigned long int)0x01000000L, (unsigned long int)0x00000400L, (unsigned long int)0x01010004L, (unsigned long int)0x00010000L, (unsigned long int)0x00010400L, (unsigned long int)0x01000004L, (unsigned long int)0x00000400L, (unsigned long int)0x00000004L, (unsigned long int)0x01000404L, (unsigned long int)0x00010404L, (unsigned long int)0x01010404L, (unsigned long int)0x00010004L, (unsigned long int)0x01010000L, (unsigned long int)0x01000404L, (unsigned long int)0x01000004L, (unsigned long int)0x00000404L, (unsigned long int)0x00010404L, (unsigned long int)0x01010400L, (unsigned long int)0x00000404L, (unsigned long int)0x01000400L, (unsigned long int)0x01000400L, (unsigned long int)0x00000000L, (unsigned long int)0x00010004L, (unsigned long int)0x00010400L, (unsigned long int)0x00000000L, (unsigned long int)0x01010004L };
// SP2
// file ../common/d3des.c line 207
static unsigned long int SP2[64l] = { (unsigned long int)0x80108020L, (unsigned long int)0x80008000L, (unsigned long int)0x00008000L, (unsigned long int)0x00108020L, (unsigned long int)0x00100000L, (unsigned long int)0x00000020L, (unsigned long int)0x80100020L, (unsigned long int)0x80008020L, (unsigned long int)0x80000020L, (unsigned long int)0x80108020L, (unsigned long int)0x80108000L, (unsigned long int)0x80000000L, (unsigned long int)0x80008000L, (unsigned long int)0x00100000L, (unsigned long int)0x00000020L, (unsigned long int)0x80100020L, (unsigned long int)0x00108000L, (unsigned long int)0x00100020L, (unsigned long int)0x80008020L, (unsigned long int)0x00000000L, (unsigned long int)0x80000000L, (unsigned long int)0x00008000L, (unsigned long int)0x00108020L, (unsigned long int)0x80100000L, (unsigned long int)0x00100020L, (unsigned long int)0x80000020L, (unsigned long int)0x00000000L, (unsigned long int)0x00108000L, (unsigned long int)0x00008020L, (unsigned long int)0x80108000L, (unsigned long int)0x80100000L, (unsigned long int)0x00008020L, (unsigned long int)0x00000000L, (unsigned long int)0x00108020L, (unsigned long int)0x80100020L, (unsigned long int)0x00100000L, (unsigned long int)0x80008020L, (unsigned long int)0x80100000L, (unsigned long int)0x80108000L, (unsigned long int)0x00008000L, (unsigned long int)0x80100000L, (unsigned long int)0x80008000L, (unsigned long int)0x00000020L, (unsigned long int)0x80108020L, (unsigned long int)0x00108020L, (unsigned long int)0x00000020L, (unsigned long int)0x00008000L, (unsigned long int)0x80000000L, (unsigned long int)0x00008020L, (unsigned long int)0x80108000L, (unsigned long int)0x00100000L, (unsigned long int)0x80000020L, (unsigned long int)0x00100020L, (unsigned long int)0x80008020L, (unsigned long int)0x80000020L, (unsigned long int)0x00100020L, (unsigned long int)0x00108000L, (unsigned long int)0x00000000L, (unsigned long int)0x80008000L, (unsigned long int)0x00008020L, (unsigned long int)0x80000000L, (unsigned long int)0x80100020L, (unsigned long int)0x80108020L, (unsigned long int)0x00108000L };
// SP3
// file ../common/d3des.c line 225
static unsigned long int SP3[64l] = { (unsigned long int)0x00000208L, (unsigned long int)0x08020200L, (unsigned long int)0x00000000L, (unsigned long int)0x08020008L, (unsigned long int)0x08000200L, (unsigned long int)0x00000000L, (unsigned long int)0x00020208L, (unsigned long int)0x08000200L, (unsigned long int)0x00020008L, (unsigned long int)0x08000008L, (unsigned long int)0x08000008L, (unsigned long int)0x00020000L, (unsigned long int)0x08020208L, (unsigned long int)0x00020008L, (unsigned long int)0x08020000L, (unsigned long int)0x00000208L, (unsigned long int)0x08000000L, (unsigned long int)0x00000008L, (unsigned long int)0x08020200L, (unsigned long int)0x00000200L, (unsigned long int)0x00020200L, (unsigned long int)0x08020000L, (unsigned long int)0x08020008L, (unsigned long int)0x00020208L, (unsigned long int)0x08000208L, (unsigned long int)0x00020200L, (unsigned long int)0x00020000L, (unsigned long int)0x08000208L, (unsigned long int)0x00000008L, (unsigned long int)0x08020208L, (unsigned long int)0x00000200L, (unsigned long int)0x08000000L, (unsigned long int)0x08020200L, (unsigned long int)0x08000000L, (unsigned long int)0x00020008L, (unsigned long int)0x00000208L, (unsigned long int)0x00020000L, (unsigned long int)0x08020200L, (unsigned long int)0x08000200L, (unsigned long int)0x00000000L, (unsigned long int)0x00000200L, (unsigned long int)0x00020008L, (unsigned long int)0x08020208L, (unsigned long int)0x08000200L, (unsigned long int)0x08000008L, (unsigned long int)0x00000200L, (unsigned long int)0x00000000L, (unsigned long int)0x08020008L, (unsigned long int)0x08000208L, (unsigned long int)0x00020000L, (unsigned long int)0x08000000L, (unsigned long int)0x08020208L, (unsigned long int)0x00000008L, (unsigned long int)0x00020208L, (unsigned long int)0x00020200L, (unsigned long int)0x08000008L, (unsigned long int)0x08020000L, (unsigned long int)0x08000208L, (unsigned long int)0x00000208L, (unsigned long int)0x08020000L, (unsigned long int)0x00020208L, (unsigned long int)0x00000008L, (unsigned long int)0x08020008L, (unsigned long int)0x00020200L };
// SP4
// file ../common/d3des.c line 243
static unsigned long int SP4[64l] = { (unsigned long int)0x00802001L, (unsigned long int)0x00002081L, (unsigned long int)0x00002081L, (unsigned long int)0x00000080L, (unsigned long int)0x00802080L, (unsigned long int)0x00800081L, (unsigned long int)0x00800001L, (unsigned long int)0x00002001L, (unsigned long int)0x00000000L, (unsigned long int)0x00802000L, (unsigned long int)0x00802000L, (unsigned long int)0x00802081L, (unsigned long int)0x00000081L, (unsigned long int)0x00000000L, (unsigned long int)0x00800080L, (unsigned long int)0x00800001L, (unsigned long int)0x00000001L, (unsigned long int)0x00002000L, (unsigned long int)0x00800000L, (unsigned long int)0x00802001L, (unsigned long int)0x00000080L, (unsigned long int)0x00800000L, (unsigned long int)0x00002001L, (unsigned long int)0x00002080L, (unsigned long int)0x00800081L, (unsigned long int)0x00000001L, (unsigned long int)0x00002080L, (unsigned long int)0x00800080L, (unsigned long int)0x00002000L, (unsigned long int)0x00802080L, (unsigned long int)0x00802081L, (unsigned long int)0x00000081L, (unsigned long int)0x00800080L, (unsigned long int)0x00800001L, (unsigned long int)0x00802000L, (unsigned long int)0x00802081L, (unsigned long int)0x00000081L, (unsigned long int)0x00000000L, (unsigned long int)0x00000000L, (unsigned long int)0x00802000L, (unsigned long int)0x00002080L, (unsigned long int)0x00800080L, (unsigned long int)0x00800081L, (unsigned long int)0x00000001L, (unsigned long int)0x00802001L, (unsigned long int)0x00002081L, (unsigned long int)0x00002081L, (unsigned long int)0x00000080L, (unsigned long int)0x00802081L, (unsigned long int)0x00000081L, (unsigned long int)0x00000001L, (unsigned long int)0x00002000L, (unsigned long int)0x00800001L, (unsigned long int)0x00002001L, (unsigned long int)0x00802080L, (unsigned long int)0x00800081L, (unsigned long int)0x00002001L, (unsigned long int)0x00002080L, (unsigned long int)0x00800000L, (unsigned long int)0x00802001L, (unsigned long int)0x00000080L, (unsigned long int)0x00800000L, (unsigned long int)0x00002000L, (unsigned long int)0x00802080L };
// SP5
// file ../common/d3des.c line 261
static unsigned long int SP5[64l] = { (unsigned long int)0x00000100L, (unsigned long int)0x02080100L, (unsigned long int)0x02080000L, (unsigned long int)0x42000100L, (unsigned long int)0x00080000L, (unsigned long int)0x00000100L, (unsigned long int)0x40000000L, (unsigned long int)0x02080000L, (unsigned long int)0x40080100L, (unsigned long int)0x00080000L, (unsigned long int)0x02000100L, (unsigned long int)0x40080100L, (unsigned long int)0x42000100L, (unsigned long int)0x42080000L, (unsigned long int)0x00080100L, (unsigned long int)0x40000000L, (unsigned long int)0x02000000L, (unsigned long int)0x40080000L, (unsigned long int)0x40080000L, (unsigned long int)0x00000000L, (unsigned long int)0x40000100L, (unsigned long int)0x42080100L, (unsigned long int)0x42080100L, (unsigned long int)0x02000100L, (unsigned long int)0x42080000L, (unsigned long int)0x40000100L, (unsigned long int)0x00000000L, (unsigned long int)0x42000000L, (unsigned long int)0x02080100L, (unsigned long int)0x02000000L, (unsigned long int)0x42000000L, (unsigned long int)0x00080100L, (unsigned long int)0x00080000L, (unsigned long int)0x42000100L, (unsigned long int)0x00000100L, (unsigned long int)0x02000000L, (unsigned long int)0x40000000L, (unsigned long int)0x02080000L, (unsigned long int)0x42000100L, (unsigned long int)0x40080100L, (unsigned long int)0x02000100L, (unsigned long int)0x40000000L, (unsigned long int)0x42080000L, (unsigned long int)0x02080100L, (unsigned long int)0x40080100L, (unsigned long int)0x00000100L, (unsigned long int)0x02000000L, (unsigned long int)0x42080000L, (unsigned long int)0x42080100L, (unsigned long int)0x00080100L, (unsigned long int)0x42000000L, (unsigned long int)0x42080100L, (unsigned long int)0x02080000L, (unsigned long int)0x00000000L, (unsigned long int)0x40080000L, (unsigned long int)0x42000000L, (unsigned long int)0x00080100L, (unsigned long int)0x02000100L, (unsigned long int)0x40000100L, (unsigned long int)0x00080000L, (unsigned long int)0x00000000L, (unsigned long int)0x40080000L, (unsigned long int)0x02080100L, (unsigned long int)0x40000100L };
// SP6
// file ../common/d3des.c line 279
static unsigned long int SP6[64l] = { (unsigned long int)0x20000010L, (unsigned long int)0x20400000L, (unsigned long int)0x00004000L, (unsigned long int)0x20404010L, (unsigned long int)0x20400000L, (unsigned long int)0x00000010L, (unsigned long int)0x20404010L, (unsigned long int)0x00400000L, (unsigned long int)0x20004000L, (unsigned long int)0x00404010L, (unsigned long int)0x00400000L, (unsigned long int)0x20000010L, (unsigned long int)0x00400010L, (unsigned long int)0x20004000L, (unsigned long int)0x20000000L, (unsigned long int)0x00004010L, (unsigned long int)0x00000000L, (unsigned long int)0x00400010L, (unsigned long int)0x20004010L, (unsigned long int)0x00004000L, (unsigned long int)0x00404000L, (unsigned long int)0x20004010L, (unsigned long int)0x00000010L, (unsigned long int)0x20400010L, (unsigned long int)0x20400010L, (unsigned long int)0x00000000L, (unsigned long int)0x00404010L, (unsigned long int)0x20404000L, (unsigned long int)0x00004010L, (unsigned long int)0x00404000L, (unsigned long int)0x20404000L, (unsigned long int)0x20000000L, (unsigned long int)0x20004000L, (unsigned long int)0x00000010L, (unsigned long int)0x20400010L, (unsigned long int)0x00404000L, (unsigned long int)0x20404010L, (unsigned long int)0x00400000L, (unsigned long int)0x00004010L, (unsigned long int)0x20000010L, (unsigned long int)0x00400000L, (unsigned long int)0x20004000L, (unsigned long int)0x20000000L, (unsigned long int)0x00004010L, (unsigned long int)0x20000010L, (unsigned long int)0x20404010L, (unsigned long int)0x00404000L, (unsigned long int)0x20400000L, (unsigned long int)0x00404010L, (unsigned long int)0x20404000L, (unsigned long int)0x00000000L, (unsigned long int)0x20400010L, (unsigned long int)0x00000010L, (unsigned long int)0x00004000L, (unsigned long int)0x20400000L, (unsigned long int)0x00404010L, (unsigned long int)0x00004000L, (unsigned long int)0x00400010L, (unsigned long int)0x20004010L, (unsigned long int)0x00000000L, (unsigned long int)0x20404000L, (unsigned long int)0x20000000L, (unsigned long int)0x00400010L, (unsigned long int)0x20004010L };
// SP7
// file ../common/d3des.c line 297
static unsigned long int SP7[64l] = { (unsigned long int)0x00200000L, (unsigned long int)0x04200002L, (unsigned long int)0x04000802L, (unsigned long int)0x00000000L, (unsigned long int)0x00000800L, (unsigned long int)0x04000802L, (unsigned long int)0x00200802L, (unsigned long int)0x04200800L, (unsigned long int)0x04200802L, (unsigned long int)0x00200000L, (unsigned long int)0x00000000L, (unsigned long int)0x04000002L, (unsigned long int)0x00000002L, (unsigned long int)0x04000000L, (unsigned long int)0x04200002L, (unsigned long int)0x00000802L, (unsigned long int)0x04000800L, (unsigned long int)0x00200802L, (unsigned long int)0x00200002L, (unsigned long int)0x04000800L, (unsigned long int)0x04000002L, (unsigned long int)0x04200000L, (unsigned long int)0x04200800L, (unsigned long int)0x00200002L, (unsigned long int)0x04200000L, (unsigned long int)0x00000800L, (unsigned long int)0x00000802L, (unsigned long int)0x04200802L, (unsigned long int)0x00200800L, (unsigned long int)0x00000002L, (unsigned long int)0x04000000L, (unsigned long int)0x00200800L, (unsigned long int)0x04000000L, (unsigned long int)0x00200800L, (unsigned long int)0x00200000L, (unsigned long int)0x04000802L, (unsigned long int)0x04000802L, (unsigned long int)0x04200002L, (unsigned long int)0x04200002L, (unsigned long int)0x00000002L, (unsigned long int)0x00200002L, (unsigned long int)0x04000000L, (unsigned long int)0x04000800L, (unsigned long int)0x00200000L, (unsigned long int)0x04200800L, (unsigned long int)0x00000802L, (unsigned long int)0x00200802L, (unsigned long int)0x04200800L, (unsigned long int)0x00000802L, (unsigned long int)0x04000002L, (unsigned long int)0x04200802L, (unsigned long int)0x04200000L, (unsigned long int)0x00200800L, (unsigned long int)0x00000000L, (unsigned long int)0x00000002L, (unsigned long int)0x04200802L, (unsigned long int)0x00000000L, (unsigned long int)0x00200802L, (unsigned long int)0x04200000L, (unsigned long int)0x00000800L, (unsigned long int)0x04000002L, (unsigned long int)0x04000800L, (unsigned long int)0x00000800L, (unsigned long int)0x00200002L };
// SP8
// file ../common/d3des.c line 315
static unsigned long int SP8[64l] = { (unsigned long int)0x10001040L, (unsigned long int)0x00001000L, (unsigned long int)0x00040000L, (unsigned long int)0x10041040L, (unsigned long int)0x10000000L, (unsigned long int)0x10001040L, (unsigned long int)0x00000040L, (unsigned long int)0x10000000L, (unsigned long int)0x00040040L, (unsigned long int)0x10040000L, (unsigned long int)0x10041040L, (unsigned long int)0x00041000L, (unsigned long int)0x10041000L, (unsigned long int)0x00041040L, (unsigned long int)0x00001000L, (unsigned long int)0x00000040L, (unsigned long int)0x10040000L, (unsigned long int)0x10000040L, (unsigned long int)0x10001000L, (unsigned long int)0x00001040L, (unsigned long int)0x00041000L, (unsigned long int)0x00040040L, (unsigned long int)0x10040040L, (unsigned long int)0x10041000L, (unsigned long int)0x00001040L, (unsigned long int)0x00000000L, (unsigned long int)0x00000000L, (unsigned long int)0x10040040L, (unsigned long int)0x10000040L, (unsigned long int)0x10001000L, (unsigned long int)0x00041040L, (unsigned long int)0x00040000L, (unsigned long int)0x00041040L, (unsigned long int)0x00040000L, (unsigned long int)0x10041000L, (unsigned long int)0x00001000L, (unsigned long int)0x00000040L, (unsigned long int)0x10040040L, (unsigned long int)0x00001000L, (unsigned long int)0x00041040L, (unsigned long int)0x10001000L, (unsigned long int)0x00000040L, (unsigned long int)0x10000040L, (unsigned long int)0x10040000L, (unsigned long int)0x10040040L, (unsigned long int)0x10000000L, (unsigned long int)0x00040000L, (unsigned long int)0x10001040L, (unsigned long int)0x00000000L, (unsigned long int)0x10041040L, (unsigned long int)0x00040040L, (unsigned long int)0x10000040L, (unsigned long int)0x10040000L, (unsigned long int)0x10001000L, (unsigned long int)0x10001040L, (unsigned long int)0x00000000L, (unsigned long int)0x10041040L, (unsigned long int)0x00041000L, (unsigned long int)0x00041000L, (unsigned long int)0x00001040L, (unsigned long int)0x00001040L, (unsigned long int)0x00040040L, (unsigned long int)0x10000000L, (unsigned long int)0x10041000L };
// VncSecurityHandlerNone
// file auth.c line 194
static struct _rfbSecurity VncSecurityHandlerNone;
// VncSecurityHandlerNone
// file auth.c line 194
static struct _rfbSecurity VncSecurityHandlerNone = { .type=(unsigned char)1, .handler=rfbVncAuthNone, .next=(struct _rfbSecurity *)(void *)0 };
// VncSecurityHandlerVncAuth
// file auth.c line 188
static struct _rfbSecurity VncSecurityHandlerVncAuth;
// VncSecurityHandlerVncAuth
// file auth.c line 188
static struct _rfbSecurity VncSecurityHandlerVncAuth = { .type=(unsigned char)2, .handler=rfbVncAuthSendChallenge, .next=(struct _rfbSecurity *)(void *)0 };
// __lzo_copyright
// file ../common/minilzo.c line 3909
static const char __lzo_copyright[5l] = { '2', '.', '0', '7', 0 };
// bigbyte
// file ../common/d3des.c line 49
static unsigned long int bigbyte[24l] = { (unsigned long int)0x800000L, (unsigned long int)0x400000L, (unsigned long int)0x200000L, (unsigned long int)0x100000L, (unsigned long int)0x80000L, (unsigned long int)0x40000L, (unsigned long int)0x20000L, (unsigned long int)0x10000L, (unsigned long int)0x8000L, (unsigned long int)0x4000L, (unsigned long int)0x2000L, (unsigned long int)0x1000L, (unsigned long int)0x800L, (unsigned long int)0x400L, (unsigned long int)0x200L, (unsigned long int)0x100L, (unsigned long int)0x80L, (unsigned long int)0x40L, (unsigned long int)0x20L, (unsigned long int)0x10L, (unsigned long int)0x8L, (unsigned long int)0x4L, (unsigned long int)0x2L, (unsigned long int)0x1L };
// bitsPerPackedPixel
// file ./zrleencodetemplate.c line 83
static const signed int bitsPerPackedPixel[16l] = { 0, 1, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 };
// buf
// file httpd.c line 96
static char buf[32768l];
// buf_filled
// file httpd.c line 97
static unsigned long int buf_filled = (unsigned long int)0;
// bytebit
// file ../common/d3des.c line 46
static unsigned short int bytebit[8l] = { (unsigned short int)01, (unsigned short int)02, (unsigned short int)04, (unsigned short int)010, (unsigned short int)020, (unsigned short int)040, (unsigned short int)0100, (unsigned short int)0200 };
// cancelStr
// file selbox.c line 23
static const char *cancelStr = "Cancel";
// cl
// file httpd.c line 265
static struct _rfbClientRec cl;
// compressLevel
// file tight.c line 109
static signed int compressLevel = 1;
// errStr
// file ../common/turbojpeg.c line 59
static char errStr[200l] = { 'N', 'o', ' ', 'e', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// extMutex
// file main.c line 45
static union anonymous_9 extMutex;
// extMutex_initialized
// file main.c line 41
static signed int extMutex_initialized = 0;
// fileDownloadMutex
// file tightvnc-filetransfer/handlefiletransferrequest.c line 47
union anonymous_9 fileDownloadMutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// fileTransferEnabled
// file tightvnc-filetransfer/handlefiletransferrequest.c line 49
signed char fileTransferEnabled = (signed char)-1;
// fileTransferInitted
// file tightvnc-filetransfer/handlefiletransferrequest.c line 50
signed char fileTransferInitted = (signed char)0;
// fixedkey
// file ../common/vncauth.c line 64
static unsigned char fixedkey[8l] = { (unsigned char)23, (unsigned char)82, (unsigned char)107, (unsigned char)6, (unsigned char)35, (unsigned char)78, (unsigned char)88, (unsigned char)7 };
// ftproot
// file tightvnc-filetransfer/handlefiletransferrequest.c line 51
char ftproot[4096l];
// j
// file tight.c line 152
static void *j = (void *)0;
// logMutex
// file main.c line 44
static union anonymous_9 logMutex;
// logMutex_initialized
// file main.c line 42
static signed int logMutex_initialized = 0;
// monoBackground
// file tight.c line 140
static unsigned int monoBackground = (unsigned int)0;
// monoForeground
// file tight.c line 141
static unsigned int monoForeground = (unsigned int)0;
// myCursor
// file main.c line 670
static struct rfbCursor myCursor = { .cleanup=(signed char)0, .cleanupSource=(signed char)0, .cleanupMask=(signed char)0,
    .cleanupRichSource=(signed char)0, .source=(unsigned char *)"\0B_\030_B\0",
    .mask=(unsigned char *)"~<~",
    .width=(unsigned short int)8, .height=(unsigned short int)7,
    .xhot=(unsigned short int)3, .yhot=(unsigned short int)3,
    .foreRed=(unsigned short int)0, .foreGreen=(unsigned short int)0,
    .foreBlue=(unsigned short int)0, .backRed=(unsigned short int)0xffff,
    .backGreen=(unsigned short int)0xffff,
    .backBlue=(unsigned short int)0xffff,
    .richSource=(unsigned char *)(void *)0,
    .alphaSource=((unsigned char *)NULL),
    .alphaPreMultiplied=0 };
// okStr
// file selbox.c line 22
static const char *okStr = "OK";
// palette
// file tight.c line 142
static struct PALETTE_s palette;
// paletteMaxColors
// file tight.c line 139
static signed int paletteMaxColors = 0;
// paletteNumColors
// file tight.c line 138
static signed int paletteNumColors = 0;
// pc1
// file ../common/d3des.c line 59
static unsigned char pc1[56l] = { (unsigned char)56, (unsigned char)48, (unsigned char)40, (unsigned char)32, (unsigned char)24, (unsigned char)16, (unsigned char)8, (unsigned char)0, (unsigned char)57, (unsigned char)49, (unsigned char)41, (unsigned char)33, (unsigned char)25, (unsigned char)17, (unsigned char)9, (unsigned char)1, (unsigned char)58, (unsigned char)50, (unsigned char)42, (unsigned char)34, (unsigned char)26, (unsigned char)18, (unsigned char)10, (unsigned char)2, (unsigned char)59, (unsigned char)51, (unsigned char)43, (unsigned char)35, (unsigned char)62, (unsigned char)54, (unsigned char)46, (unsigned char)38, (unsigned char)30, (unsigned char)22, (unsigned char)14, (unsigned char)6, (unsigned char)61, (unsigned char)53, (unsigned char)45, (unsigned char)37, (unsigned char)29, (unsigned char)21, (unsigned char)13, (unsigned char)5, (unsigned char)60, (unsigned char)52, (unsigned char)44, (unsigned char)36, (unsigned char)28, (unsigned char)20, (unsigned char)12, (unsigned char)4, (unsigned char)27, (unsigned char)19, (unsigned char)11, (unsigned char)3 };
// pc2
// file ../common/d3des.c line 68
static unsigned char pc2[48l] = { (unsigned char)13, (unsigned char)16, (unsigned char)10, (unsigned char)23, (unsigned char)0, (unsigned char)4, (unsigned char)2, (unsigned char)27, (unsigned char)14, (unsigned char)5, (unsigned char)20, (unsigned char)9, (unsigned char)22, (unsigned char)18, (unsigned char)11, (unsigned char)3, (unsigned char)25, (unsigned char)7, (unsigned char)15, (unsigned char)6, (unsigned char)26, (unsigned char)19, (unsigned char)12, (unsigned char)1, (unsigned char)40, (unsigned char)51, (unsigned char)30, (unsigned char)36, (unsigned char)46, (unsigned char)54, (unsigned char)29, (unsigned char)39, (unsigned char)50, (unsigned char)44, (unsigned char)32, (unsigned char)47, (unsigned char)43, (unsigned char)48, (unsigned char)38, (unsigned char)55, (unsigned char)33, (unsigned char)52, (unsigned char)45, (unsigned char)41, (unsigned char)49, (unsigned char)35, (unsigned char)28, (unsigned char)31 };
// pixelsize
// file ../common/turbojpeg.c line 97
static const signed int pixelsize[5l] = { 3, 3, 3, 1, 3 };
// ptrAcceleration
// file rfbserver.c line 3524
static unsigned char ptrAcceleration = (unsigned char)50;
// qualityLevel
// file tight.c line 110
static signed int qualityLevel = 95;
// rfbClientListMutex
// file rfbserver.c line 151
static union anonymous_9 rfbClientListMutex;
// rfbEconomicTranslate
// file translate.c line 32
signed char rfbEconomicTranslate = (signed char)0;
// rfbEnableLogging
// file main.c line 48
static signed int rfbEnableLogging = 1;
// rfbEndianTest
// file main.c line 53
char rfbEndianTest = (char)(1 == 1);
// rfbErr
// file main.c line 260
void (*rfbErr)(const char *, ...);
// rfbErr
// file main.c line 260
void (*rfbErr)(const char *, ...) = rfbDefaultLog;
// rfbExtensionHead
// file main.c line 60
static struct _rfbProtocolExtension *rfbExtensionHead = (struct _rfbProtocolExtension *)(void *)0;
// rfbInitColourMapSingleTableFns
// file translate.c line 137
static void (*rfbInitColourMapSingleTableFns[4l])(char **, struct anonymous_7 *, struct anonymous_7 *, struct anonymous_15 *);
// rfbInitColourMapSingleTableFns
// file translate.c line 137
static void (*rfbInitColourMapSingleTableFns[4l])(char **, struct anonymous_7 *, struct anonymous_7 *, struct anonymous_15 *) = { rfbInitColourMapSingleTable8, rfbInitColourMapSingleTable16, rfbInitColourMapSingleTable24, rfbInitColourMapSingleTable32 };
// rfbInitTrueColourRGBTablesFns
// file translate.c line 155
static void (*rfbInitTrueColourRGBTablesFns[4l])(char **, struct anonymous_7 *, struct anonymous_7 *);
// rfbInitTrueColourRGBTablesFns
// file translate.c line 155
static void (*rfbInitTrueColourRGBTablesFns[4l])(char **, struct anonymous_7 *, struct anonymous_7 *) = { rfbInitTrueColourRGBTables8, rfbInitTrueColourRGBTables16, rfbInitTrueColourRGBTables24, rfbInitTrueColourRGBTables32 };
// rfbInitTrueColourSingleTableFns
// file translate.c line 146
static void (*rfbInitTrueColourSingleTableFns[4l])(char **, struct anonymous_7 *, struct anonymous_7 *);
// rfbInitTrueColourSingleTableFns
// file translate.c line 146
static void (*rfbInitTrueColourSingleTableFns[4l])(char **, struct anonymous_7 *, struct anonymous_7 *) = { rfbInitTrueColourSingleTable8, rfbInitTrueColourSingleTable16, rfbInitTrueColourSingleTable24, rfbInitTrueColourSingleTable32 };
// rfbLog
// file main.c line 259
void (*rfbLog)(const char *, ...);
// rfbLog
// file main.c line 259
void (*rfbLog)(const char *, ...) = rfbDefaultLog;
// rfbMaxClientWait
// file sockets.c line 122
signed int rfbMaxClientWait = 20000;
// rfbReverseByte
// file cursor.c line 209
unsigned char rfbReverseByte[256l] = { (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0xc0, (unsigned char)0x20, (unsigned char)0xa0, (unsigned char)0x60, (unsigned char)0xe0, (unsigned char)0x10, (unsigned char)0x90, (unsigned char)0x50, (unsigned char)0xd0, (unsigned char)0x30, (unsigned char)0xb0, (unsigned char)0x70, (unsigned char)0xf0, (unsigned char)0x08, (unsigned char)0x88, (unsigned char)0x48, (unsigned char)0xc8, (unsigned char)0x28, (unsigned char)0xa8, (unsigned char)0x68, (unsigned char)0xe8, (unsigned char)0x18, (unsigned char)0x98, (unsigned char)0x58, (unsigned char)0xd8, (unsigned char)0x38, (unsigned char)0xb8, (unsigned char)0x78, (unsigned char)0xf8, (unsigned char)0x04, (unsigned char)0x84, (unsigned char)0x44, (unsigned char)0xc4, (unsigned char)0x24, (unsigned char)0xa4, (unsigned char)0x64, (unsigned char)0xe4, (unsigned char)0x14, (unsigned char)0x94, (unsigned char)0x54, (unsigned char)0xd4, (unsigned char)0x34, (unsigned char)0xb4, (unsigned char)0x74, (unsigned char)0xf4, (unsigned char)0x0c, (unsigned char)0x8c, (unsigned char)0x4c, (unsigned char)0xcc, (unsigned char)0x2c, (unsigned char)0xac, (unsigned char)0x6c, (unsigned char)0xec, (unsigned char)0x1c, (unsigned char)0x9c, (unsigned char)0x5c, (unsigned char)0xdc, (unsigned char)0x3c, (unsigned char)0xbc, (unsigned char)0x7c, (unsigned char)0xfc, (unsigned char)0x02, (unsigned char)0x82, (unsigned char)0x42, (unsigned char)0xc2, (unsigned char)0x22, (unsigned char)0xa2, (unsigned char)0x62, (unsigned char)0xe2, (unsigned char)0x12, (unsigned char)0x92, (unsigned char)0x52, (unsigned char)0xd2, (unsigned char)0x32, (unsigned char)0xb2, (unsigned char)0x72, (unsigned char)0xf2, (unsigned char)0x0a, (unsigned char)0x8a, (unsigned char)0x4a, (unsigned char)0xca, (unsigned char)0x2a, (unsigned char)0xaa, (unsigned char)0x6a, (unsigned char)0xea, (unsigned char)0x1a, (unsigned char)0x9a, (unsigned char)0x5a, (unsigned char)0xda, (unsigned char)0x3a, (unsigned char)0xba, (unsigned char)0x7a, (unsigned char)0xfa, (unsigned char)0x06, (unsigned char)0x86, (unsigned char)0x46, (unsigned char)0xc6, (unsigned char)0x26, (unsigned char)0xa6, (unsigned char)0x66, (unsigned char)0xe6, (unsigned char)0x16, (unsigned char)0x96, (unsigned char)0x56, (unsigned char)0xd6, (unsigned char)0x36, (unsigned char)0xb6, (unsigned char)0x76, (unsigned char)0xf6, (unsigned char)0x0e, (unsigned char)0x8e, (unsigned char)0x4e, (unsigned char)0xce, (unsigned char)0x2e, (unsigned char)0xae, (unsigned char)0x6e, (unsigned char)0xee, (unsigned char)0x1e, (unsigned char)0x9e, (unsigned char)0x5e, (unsigned char)0xde, (unsigned char)0x3e, (unsigned char)0xbe, (unsigned char)0x7e, (unsigned char)0xfe, (unsigned char)0x01, (unsigned char)0x81, (unsigned char)0x41, (unsigned char)0xc1, (unsigned char)0x21, (unsigned char)0xa1, (unsigned char)0x61, (unsigned char)0xe1, (unsigned char)0x11, (unsigned char)0x91, (unsigned char)0x51, (unsigned char)0xd1, (unsigned char)0x31, (unsigned char)0xb1, (unsigned char)0x71, (unsigned char)0xf1, (unsigned char)0x09, (unsigned char)0x89, (unsigned char)0x49, (unsigned char)0xc9, (unsigned char)0x29, (unsigned char)0xa9, (unsigned char)0x69, (unsigned char)0xe9, (unsigned char)0x19, (unsigned char)0x99, (unsigned char)0x59, (unsigned char)0xd9, (unsigned char)0x39, (unsigned char)0xb9, (unsigned char)0x79, (unsigned char)0xf9, (unsigned char)0x05, (unsigned char)0x85, (unsigned char)0x45, (unsigned char)0xc5, (unsigned char)0x25, (unsigned char)0xa5, (unsigned char)0x65, (unsigned char)0xe5, (unsigned char)0x15, (unsigned char)0x95, (unsigned char)0x55, (unsigned char)0xd5, (unsigned char)0x35, (unsigned char)0xb5, (unsigned char)0x75, (unsigned char)0xf5, (unsigned char)0x0d, (unsigned char)0x8d, (unsigned char)0x4d, (unsigned char)0xcd, (unsigned char)0x2d, (unsigned char)0xad, (unsigned char)0x6d, (unsigned char)0xed, (unsigned char)0x1d, (unsigned char)0x9d, (unsigned char)0x5d, (unsigned char)0xdd, (unsigned char)0x3d, (unsigned char)0xbd, (unsigned char)0x7d, (unsigned char)0xfd, (unsigned char)0x03, (unsigned char)0x83, (unsigned char)0x43, (unsigned char)0xc3, (unsigned char)0x23, (unsigned char)0xa3, (unsigned char)0x63, (unsigned char)0xe3, (unsigned char)0x13, (unsigned char)0x93, (unsigned char)0x53, (unsigned char)0xd3, (unsigned char)0x33, (unsigned char)0xb3, (unsigned char)0x73, (unsigned char)0xf3, (unsigned char)0x0b, (unsigned char)0x8b, (unsigned char)0x4b, (unsigned char)0xcb, (unsigned char)0x2b, (unsigned char)0xab, (unsigned char)0x6b, (unsigned char)0xeb, (unsigned char)0x1b, (unsigned char)0x9b, (unsigned char)0x5b, (unsigned char)0xdb, (unsigned char)0x3b, (unsigned char)0xbb, (unsigned char)0x7b, (unsigned char)0xfb, (unsigned char)0x07, (unsigned char)0x87, (unsigned char)0x47, (unsigned char)0xc7, (unsigned char)0x27, (unsigned char)0xa7, (unsigned char)0x67, (unsigned char)0xe7, (unsigned char)0x17, (unsigned char)0x97, (unsigned char)0x57, (unsigned char)0xd7, (unsigned char)0x37, (unsigned char)0xb7, (unsigned char)0x77, (unsigned char)0xf7, (unsigned char)0x0f, (unsigned char)0x8f, (unsigned char)0x4f, (unsigned char)0xcf, (unsigned char)0x2f, (unsigned char)0xaf, (unsigned char)0x6f, (unsigned char)0xef, (unsigned char)0x1f, (unsigned char)0x9f, (unsigned char)0x5f, (unsigned char)0xdf, (unsigned char)0x3f, (unsigned char)0xbf, (unsigned char)0x7f, (unsigned char)0xff };
// rfbTranslateWithRGBTablesFns
// file translate.c line 191
static void (*rfbTranslateWithRGBTablesFns[4l][4l])(char *, struct anonymous_7 *, struct anonymous_7 *, char *, char *, signed int, signed int, signed int);
// rfbTranslateWithRGBTablesFns
// file translate.c line 191
static void (*rfbTranslateWithRGBTablesFns[4l][4l])(char *, struct anonymous_7 *, struct anonymous_7 *, char *, char *, signed int, signed int, signed int) = { { rfbTranslateWithRGBTables8to8, rfbTranslateWithRGBTables8to16, rfbTranslateWithRGBTables8to24, rfbTranslateWithRGBTables8to32 },
    { rfbTranslateWithRGBTables16to8, rfbTranslateWithRGBTables16to16, rfbTranslateWithRGBTables16to24, rfbTranslateWithRGBTables16to32 },
    { rfbTranslateWithRGBTables24to8, rfbTranslateWithRGBTables24to16, rfbTranslateWithRGBTables24to24, rfbTranslateWithRGBTables24to32 },
    { rfbTranslateWithRGBTables32to8, rfbTranslateWithRGBTables32to16, rfbTranslateWithRGBTables32to24, rfbTranslateWithRGBTables32to32 } };
// rfbTranslateWithSingleTableFns
// file translate.c line 164
static void (*rfbTranslateWithSingleTableFns[4l][4l])(char *, struct anonymous_7 *, struct anonymous_7 *, char *, char *, signed int, signed int, signed int);
// rfbTranslateWithSingleTableFns
// file translate.c line 164
static void (*rfbTranslateWithSingleTableFns[4l][4l])(char *, struct anonymous_7 *, struct anonymous_7 *, char *, char *, signed int, signed int, signed int) = { { rfbTranslateWithSingleTable8to8, rfbTranslateWithSingleTable8to16, rfbTranslateWithSingleTable8to24, rfbTranslateWithSingleTable8to32 },
    { rfbTranslateWithSingleTable16to8, rfbTranslateWithSingleTable16to16, rfbTranslateWithSingleTable16to24, rfbTranslateWithSingleTable16to32 },
    { rfbTranslateWithSingleTable24to8, rfbTranslateWithSingleTable24to16, rfbTranslateWithSingleTable24to24, rfbTranslateWithSingleTable24to32 },
    { rfbTranslateWithSingleTable32to8, rfbTranslateWithSingleTable32to16, rfbTranslateWithSingleTable32to24, rfbTranslateWithSingleTable32to32 } };
// securityHandlers
// file auth.c line 40
static struct _rfbSecurity *securityHandlers = (struct _rfbSecurity *)(void *)0;
// sf
// file ../common/turbojpeg.c line 100
static const struct anonymous_29 sf[4l] = { { .num=1, .denom=1 }, { .num=1, .denom=2 }, { .num=1, .denom=4 }, { .num=1, .denom=8 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// subsampLevel
// file tight.c line 111
static signed int subsampLevel = 0;
// subsampLevel2tjsubsamp
// file tight.c line 113
static const signed int subsampLevel2tjsubsamp[4l] = { 0, 2, 1, 3 };
// tight2turbo_qual
// file rfbserver.c line 116
static const signed int tight2turbo_qual[10l] = { 15, 29, 41, 42, 62, 77, 79, 86, 92, 100 };
// tight2turbo_subsamp
// file rfbserver.c line 120
static const signed int tight2turbo_subsamp[10l] = { 1, 1, 1, 2, 2, 2, 0, 0, 0, 0 };
// tightAfterBuf
// file tight.c line 150
static char *tightAfterBuf = (char *)(void *)0;
// tightAfterBufSize
// file tight.c line 149
static signed int tightAfterBufSize = 0;
// tightBeforeBuf
// file tight.c line 147
static char *tightBeforeBuf = (char *)(void *)0;
// tightBeforeBufSize
// file tight.c line 146
static signed int tightBeforeBufSize = 0;
// tightConf
// file tight.c line 83
static struct TIGHT_CONF_s tightConf[4l] = { { .maxRectSize=65536, .maxRectWidth=2048, .monoMinRectSize=6,
    .idxZlibLevel=0, .monoZlibLevel=0,
    .rawZlibLevel=0, .idxMaxColorsDivisor=4, .palMaxColorsWithJPEG=24 },
    { .maxRectSize=65536, .maxRectWidth=2048, .monoMinRectSize=32,
    .idxZlibLevel=1, .monoZlibLevel=1,
    .rawZlibLevel=1, .idxMaxColorsDivisor=96, .palMaxColorsWithJPEG=24 },
    { .maxRectSize=65536, .maxRectWidth=2048, .monoMinRectSize=32,
    .idxZlibLevel=3, .monoZlibLevel=3,
    .rawZlibLevel=2, .idxMaxColorsDivisor=96, .palMaxColorsWithJPEG=96 },
    { .maxRectSize=65536, .maxRectWidth=2048, .monoMinRectSize=32,
    .idxZlibLevel=7, .monoZlibLevel=7,
    .rawZlibLevel=5, .idxMaxColorsDivisor=96, .palMaxColorsWithJPEG=256 } };
// tightVncFileTransferExtension
// file tightvnc-filetransfer/rfbtightserver.c line 518
struct _rfbProtocolExtension tightVncFileTransferExtension;
// tightVncFileTransferExtension
// file tightvnc-filetransfer/rfbtightserver.c line 518
struct _rfbProtocolExtension tightVncFileTransferExtension = { .newClient=(signed char (*)(struct _rfbClientRec *, void **))(void *)0, .init=rfbTightExtensionInit,
    .pseudoEncodings=(signed int *)(void *)0, .enablePseudoEncoding=(signed char (*)(struct _rfbClientRec *, void **, signed int))(void *)0,
    .handleMessage=rfbTightExtensionMsgHandler,
    .close=rfbTightExtensionClientClose,
    .usage=rfbTightUsage,
    .processArgument=rfbTightProcessArg, .next=(struct _rfbProtocolExtension *)(void *)0 };
// tightVncSecurityHandler
// file tightvnc-filetransfer/rfbtightserver.c line 530
static struct _rfbSecurity tightVncSecurityHandler;
// tightVncSecurityHandler
// file tightvnc-filetransfer/rfbtightserver.c line 530
static struct _rfbSecurity tightVncSecurityHandler = { .type=(unsigned char)16, .handler=rfbHandleSecTypeTight, .next=(struct _rfbSecurity *)(void *)0 };
// tjMCUHeight
// file ../common/./turbojpeg.h line 110
static const signed int tjMCUHeight[5l] = { 8, 8, 16, 8, 16 };
// tjMCUWidth
// file ../common/./turbojpeg.h line 100
static const signed int tjMCUWidth[5l] = { 8, 16, 16, 8, 8 };
// tjPixelSize
// file ../common/./turbojpeg.h line 220
static const signed int tjPixelSize[11l] = { 3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4 };
// totrot
// file ../common/d3des.c line 65
static unsigned char totrot[16l] = { (unsigned char)1, (unsigned char)2, (unsigned char)4, (unsigned char)6, (unsigned char)8, (unsigned char)10, (unsigned char)12, (unsigned char)14, (unsigned char)15, (unsigned char)17, (unsigned char)19, (unsigned char)21, (unsigned char)23, (unsigned char)25, (unsigned char)27, (unsigned char)28 };
// usePixelFormat24
// file tight.c line 68
static signed char usePixelFormat24 = (signed char)0;
// zlibAfterBuf
// file zlib.c line 59
static char *zlibAfterBuf = (char *)(void *)0;
// zlibAfterBufLen
// file zlib.c line 60
static signed int zlibAfterBufLen = 0;
// zlibAfterBufSize
// file zlib.c line 58
static signed int zlibAfterBufSize = 0;
// zlibBeforeBuf
// file zlib.c line 56
static char *zlibBeforeBuf = (char *)(void *)0;
// zlibBeforeBufSize
// file zlib.c line 55
static signed int zlibBeforeBufSize = 0;
// zywrleConv
// file ../common/zywrletemplate.c line 167
static const signed char zywrleConv[4l][256l] = { { (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0 },
    { (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)32, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)56, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)72, (const signed char)72, (const signed char)72, (const signed char)72, (const signed char)72, (const signed char)72, (const signed char)72, (const signed char)72, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)96, (const signed char)96, (const signed char)96, (const signed char)96, (const signed char)96, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)0, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-96, (const signed char)-96, (const signed char)-96, (const signed char)-96, (const signed char)-96, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-72, (const signed char)-72, (const signed char)-72, (const signed char)-72, (const signed char)-72, (const signed char)-72, (const signed char)-72, (const signed char)-72, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-56, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)-32, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0 },
    { (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)48, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)64, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)80, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)104, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)112, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)120, (const signed char)0, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-120, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-112, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-104, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-80, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-64, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)-48, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0 },
    { (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)88, (const signed char)0, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)-88, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0, (const signed char)0 } };
// zywrleParam
// file ../common/zywrletemplate.c line 305
static const signed char *zywrleParam[3l][3l][3l];
// zywrleParam
// file ../common/zywrletemplate.c line 305
static const signed char *zywrleParam[3l][3l][3l] = { { { zywrleConv[(signed long int)0], zywrleConv[(signed long int)2], zywrleConv[(signed long int)0] },
    { zywrleConv[(signed long int)0], zywrleConv[(signed long int)0], zywrleConv[(signed long int)0] },
    { zywrleConv[(signed long int)0], zywrleConv[(signed long int)0], zywrleConv[(signed long int)0] } },
    { { zywrleConv[(signed long int)0], zywrleConv[(signed long int)3], zywrleConv[(signed long int)0] },
    { zywrleConv[(signed long int)1], zywrleConv[(signed long int)1], zywrleConv[(signed long int)1] },
    { zywrleConv[(signed long int)0], zywrleConv[(signed long int)0], zywrleConv[(signed long int)0] } },
    { { zywrleConv[(signed long int)0], zywrleConv[(signed long int)3], zywrleConv[(signed long int)0] },
    { zywrleConv[(signed long int)2], zywrleConv[(signed long int)2], zywrleConv[(signed long int)2] },
    { zywrleConv[(signed long int)1], zywrleConv[(signed long int)1], zywrleConv[(signed long int)1] } } };

// AddFileListItemInfo
// file tightvnc-filetransfer/filelistinfo.h line 55
signed int AddFileListItemInfo(struct _FileListInfo *fileListInfoPtr, char *name, unsigned int size, unsigned int data)
{
  struct _FileListItemInfo *fileListItemInfoPtr;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(fileListInfoPtr->numEntries + 1), sizeof(struct _FileListItemInfo) /*264ul*/ );
  fileListItemInfoPtr = (struct _FileListItemInfo *)return_value_calloc_1;
  if(fileListItemInfoPtr == ((struct _FileListItemInfo *)NULL))
  {
    rfbLog("File [%s]: Method [%s]: fileListItemInfoPtr is NULL\n", (const void *)"tightvnc-filetransfer/filelistinfo.c", (const void *)"AddFileListItemInfo");
    return 0;
  }

  else
  {
    if(!(fileListInfoPtr->numEntries == 0))
      memcpy((void *)fileListItemInfoPtr, (const void *)fileListInfoPtr->pEntries, (unsigned long int)fileListInfoPtr->numEntries * sizeof(struct _FileListItemInfo) /*264ul*/ );

    strcpy((fileListItemInfoPtr + (signed long int)fileListInfoPtr->numEntries)->name, name);
    (fileListItemInfoPtr + (signed long int)fileListInfoPtr->numEntries)->size = size;
    (fileListItemInfoPtr + (signed long int)fileListInfoPtr->numEntries)->data = data;
    if(!(fileListInfoPtr->pEntries == ((struct _FileListItemInfo *)NULL)))
    {
      free((void *)fileListInfoPtr->pEntries);
      fileListInfoPtr->pEntries = (struct _FileListItemInfo *)(void *)0;
    }

    fileListInfoPtr->pEntries = fileListItemInfoPtr;
    fileListItemInfoPtr = (struct _FileListItemInfo *)(void *)0;
    fileListInfoPtr->numEntries = fileListInfoPtr->numEntries + 1;
    return 1;
  }
}

// CheckSolidTile
// file tight.c line 566
static signed char CheckSolidTile(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor)
{
  signed char return_value_CheckSolidTile32_1;
  signed char return_value_CheckSolidTile16_2;
  signed char return_value_CheckSolidTile8_3;
  switch((signed int)cl->screen->serverFormat.bitsPerPixel)
  {
    case 32:
    {
      return_value_CheckSolidTile32_1=CheckSolidTile32(cl, x, y, w, h, colorPtr, needSameColor);
      return return_value_CheckSolidTile32_1;
    }
    case 16:
    {
      return_value_CheckSolidTile16_2=CheckSolidTile16(cl, x, y, w, h, colorPtr, needSameColor);
      return return_value_CheckSolidTile16_2;
    }
    default:
    {
      return_value_CheckSolidTile8_3=CheckSolidTile8(cl, x, y, w, h, colorPtr, needSameColor);
      return return_value_CheckSolidTile8_3;
    }
  }
}

// CheckSolidTile16
// file tight.c line 610
static signed char CheckSolidTile16(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor)
{
  unsigned short int *fbptr;
  unsigned short int colorValue;
  signed int dx;
  signed int dy;
  fbptr = (unsigned short int *)&cl->scaledScreen->frameBuffer[(signed long int)(y * cl->scaledScreen->paddedWidthInBytes + x * (16 / 8))];
  colorValue = *fbptr;
  if(!(needSameColor == 0))
  {
    if((unsigned int)colorValue == *colorPtr)
      goto __CPROVER_DUMP_L1;

    return (signed char)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    dy = 0;
    for( ; !(dy >= h); dy = dy + 1)
    {
      dx = 0;
      for( ; !(dx >= w); dx = dx + 1)
        if(!(colorValue == fbptr[(signed long int)dx]))
          return (signed char)0;

      fbptr = (unsigned short int *)((unsigned char *)fbptr + (signed long int)cl->scaledScreen->paddedWidthInBytes);
    }
    *colorPtr = (unsigned int)colorValue;
    return (signed char)-1;
  }
}

// CheckSolidTile32
// file tight.c line 611
static signed char CheckSolidTile32(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor)
{
  unsigned int *fbptr;
  unsigned int colorValue;
  signed int dx;
  signed int dy;
  fbptr = (unsigned int *)&cl->scaledScreen->frameBuffer[(signed long int)(y * cl->scaledScreen->paddedWidthInBytes + x * (32 / 8))];
  colorValue = *fbptr;
  if(!(needSameColor == 0))
  {
    if(colorValue == *colorPtr)
      goto __CPROVER_DUMP_L1;

    return (signed char)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    dy = 0;
    for( ; !(dy >= h); dy = dy + 1)
    {
      dx = 0;
      for( ; !(dx >= w); dx = dx + 1)
        if(!(colorValue == fbptr[(signed long int)dx]))
          return (signed char)0;

      fbptr = (unsigned int *)((unsigned char *)fbptr + (signed long int)cl->scaledScreen->paddedWidthInBytes);
    }
    *colorPtr = (unsigned int)colorValue;
    return (signed char)-1;
  }
}

// CheckSolidTile8
// file tight.c line 609
static signed char CheckSolidTile8(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int *colorPtr, signed char needSameColor)
{
  unsigned char *fbptr;
  unsigned char colorValue;
  signed int dx;
  signed int dy;
  fbptr = (unsigned char *)&cl->scaledScreen->frameBuffer[(signed long int)(y * cl->scaledScreen->paddedWidthInBytes + x * (8 / 8))];
  colorValue = *fbptr;
  if(!(needSameColor == 0))
  {
    if((unsigned int)colorValue == *colorPtr)
      goto __CPROVER_DUMP_L1;

    return (signed char)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    dy = 0;
    for( ; !(dy >= h); dy = dy + 1)
    {
      dx = 0;
      for( ; !(dx >= w); dx = dx + 1)
        if(!(colorValue == fbptr[(signed long int)dx]))
          return (signed char)0;

      fbptr = (unsigned char *)((unsigned char *)fbptr + (signed long int)cl->scaledScreen->paddedWidthInBytes);
    }
    *colorPtr = (unsigned int)colorValue;
    return (signed char)-1;
  }
}

// ChkFileDownloadErr
// file tightvnc-filetransfer/filetransfermsg.h line 45
struct _FileTransferMsg ChkFileDownloadErr(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  struct _FileTransferMsg fileDownloadMsg;
  struct stat stat_buf;
  signed int sz_rfbFileSize = 0;
  char *path = rtcp->rcft.rcfd.fName;
  memset((void *)&fileDownloadMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(path == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_strlen_2=strlen(path);
    tmp_if_expr_3 = return_value_strlen_2 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_stat_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_stat_4=stat(path, &stat_buf);
    tmp_if_expr_5 = return_value_stat_4 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(!((61440u & stat_buf.st_mode) == 32768u) || tmp_if_expr_5)
  {
    char reason[64l] = { 'C', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 'f', 'i', 'l', 'e', ',', ' ', 'p', 'e', 'r', 'h', 'a', 'p', 's', ' ', 'i', 't', ' ', 'i', 's', ' ', 'a', 'b', 's', 'e', 'n', 't', ' ', 'o', 'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'e', 'g', 'u', 'l', 'a', 'r', ' ', 'f', 'i', 'l', 'e', 0 };
    signed int reasonLen;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(reason);
    reasonLen = (signed int)return_value_strlen_1;
    rfbLog("File [%s]: Method [%s]: Reading stat for path %s failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"ChkFileDownloadErr", path);
    fileDownloadMsg=CreateFileDownloadErrMsg(reason, (unsigned int)reasonLen);
  }

  else
  {
    rtcp->rcft.rcfd.mTime = (unsigned long int)stat_buf.st_mtim.tv_sec;
    sz_rfbFileSize = (signed int)stat_buf.st_size;
    if(!(sz_rfbFileSize >= 1))
      fileDownloadMsg=CreateFileDownloadZeroSizeDataMsg((unsigned long int)stat_buf.st_mtim.tv_sec);

  }
  return fileDownloadMsg;
}

// ChkFileUploadErr
// file tightvnc-filetransfer/filetransfermsg.h line 49
struct _FileTransferMsg ChkFileUploadErr(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  struct _FileTransferMsg fileUploadErrMsg;
  memset((void *)&fileUploadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(rtcp->rcft.rcfu.fName);
  _Bool tmp_if_expr_3;
  if(return_value_strlen_2 == 0ul)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    rtcp->rcft.rcfu.uploadFD=creat(rtcp->rcft.rcfu.fName, (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3));
    tmp_if_expr_3 = rtcp->rcft.rcfu.uploadFD == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    char reason[22l] = { 'C', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'f', 'i', 'l', 'e', 0 };
    signed int reasonLen;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(reason);
    reasonLen = (signed int)return_value_strlen_1;
    fileUploadErrMsg=CreateFileUploadErrMsg(reason, (unsigned int)reasonLen);
  }

  else
    rtcp->rcft.rcfu.uploadInProgress = -1;
  return fileUploadErrMsg;
}

// ChkFileUploadWriteErr
// file tightvnc-filetransfer/filetransfermsg.h line 50
struct _FileTransferMsg ChkFileUploadWriteErr(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp, char *pBuf)
{
  struct _FileTransferMsg ftm;
  unsigned long int numOfBytesWritten = (unsigned long int)0;
  memset((void *)&ftm, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  signed long int return_value_write_1;
  return_value_write_1=write(rtcp->rcft.rcfu.uploadFD, (const void *)pBuf, rtcp->rcft.rcfu.fSize);
  numOfBytesWritten = (unsigned long int)return_value_write_1;
  if(!(numOfBytesWritten == rtcp->rcft.rcfu.fSize))
  {
    char reason[24l] = { 'E', 'r', 'r', 'o', 'r', ' ', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'f', 'i', 'l', 'e', ' ', 'd', 'a', 't', 'a', 0 };
    signed int reasonLen;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(reason);
    reasonLen = (signed int)return_value_strlen_2;
    ftm=CreateFileUploadErrMsg(reason, (unsigned int)reasonLen);
    CloseUndoneFileTransfer(cl, rtcp);
  }

  return ftm;
}

// CloseUndoneFileTransfer
// file tightvnc-filetransfer/filetransfermsg.h line 54
void CloseUndoneFileTransfer(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  if(!(cl == ((struct _rfbClientRec *)NULL)))
  {
    if(rtcp->rcft.rcfu.uploadInProgress == -1)
    {
      rtcp->rcft.rcfu.uploadInProgress = 0;
      if(!(rtcp->rcft.rcfu.uploadFD == -1))
      {
        close(rtcp->rcft.rcfu.uploadFD);
        rtcp->rcft.rcfu.uploadFD = -1;
      }

      signed int return_value_unlink_1;
      return_value_unlink_1=unlink(rtcp->rcft.rcfu.fName);
      if(return_value_unlink_1 == -1)
        rfbLog("File [%s]: Method [%s]: Delete operation on file <%s> failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CloseUndoneFileTransfer", (const void *)rtcp->rcft.rcfu.fName);

      memset((void *)rtcp->rcft.rcfu.fName, 0, (unsigned long int)4096);
    }

    if(rtcp->rcft.rcfd.downloadInProgress == -1)
    {
      rtcp->rcft.rcfd.downloadInProgress = 0;
      if(!(rtcp->rcft.rcfd.downloadFD == -1))
      {
        close(rtcp->rcft.rcfd.downloadFD);
        rtcp->rcft.rcfd.downloadFD = -1;
      }

      memset((void *)rtcp->rcft.rcfd.fName, 0, (unsigned long int)4096);
    }

  }

}

// CompressData
// file tight.c line 1026
static signed char CompressData(struct _rfbClientRec *cl, signed int streamId, signed int dataLen, signed int zlibLevel, signed int zlibStrategy)
{
  struct z_stream_s *pz;
  signed int err;
  signed char return_value_SendCompressedData_1;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(!(dataLen >= 12))
  {
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)tightBeforeBuf, (unsigned long int)dataLen);
    cl->ublen = cl->ublen + dataLen;
    rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, dataLen);
    return (signed char)-1;
  }

  else
    if(zlibLevel == 0)
    {
      return_value_SendCompressedData_1=SendCompressedData(cl, tightBeforeBuf, dataLen);
      return return_value_SendCompressedData_1;
    }

    else
    {
      pz = &cl->zsStruct[(signed long int)streamId];
      if(cl->zsActive[(signed long int)streamId] == 0)
      {
        pz->zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
        pz->zfree = ((void (*)(void *, void *))NULL);
        pz->opaque = NULL;
        err=deflateInit2_(pz, zlibLevel, 8, 15, 9, zlibStrategy, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
        if(!(err == 0))
          return (signed char)0;

        cl->zsActive[(signed long int)streamId] = (signed char)-1;
        cl->zsLevel[(signed long int)streamId] = zlibLevel;
      }

      pz->next_in = (unsigned char *)tightBeforeBuf;
      pz->avail_in = (unsigned int)dataLen;
      pz->next_out = (unsigned char *)tightAfterBuf;
      pz->avail_out = (unsigned int)tightAfterBufSize;
      if(!(zlibLevel == cl->zsLevel[(signed long int)streamId]))
      {
        signed int return_value_deflateParams_2;
        return_value_deflateParams_2=deflateParams(pz, zlibLevel, zlibStrategy);
        if(!(return_value_deflateParams_2 == 0))
          return (signed char)0;

        cl->zsLevel[(signed long int)streamId] = zlibLevel;
      }

      signed int return_value_deflate_3;
      return_value_deflate_3=deflate(pz, 2);
      if(!(return_value_deflate_3 == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = pz->avail_in != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = pz->avail_out == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        return (signed char)0;

      else
      {
        signed char return_value_SendCompressedData_6;
        return_value_SendCompressedData_6=SendCompressedData(cl, tightAfterBuf, (signed int)((unsigned int)tightAfterBufSize - pz->avail_out));
        return return_value_SendCompressedData_6;
      }
    }
}

// ConvertPath
// file tightvnc-filetransfer/handlefiletransferrequest.c line 198
char * ConvertPath(char *path)
{
  char p[4096l];
  memset((void *)p, 0, (unsigned long int)4096);
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(path == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(path);
    tmp_if_expr_2 = return_value_strlen_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(tmp_if_expr_2)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strlen_3=strlen(path);
    return_value_strlen_4=strlen(ftproot);
    tmp_if_expr_5 = return_value_strlen_3 + return_value_strlen_4 > (unsigned long int)(4096 - 1) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    rfbLog("File [%s]: Method [%s]: cannot create path for file transfer\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"ConvertPath");
    return (char *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(path);
    memcpy((void *)p, (const void *)path, return_value_strlen_6);
    memset((void *)path, 0, (unsigned long int)4096);
    sprintf(path, "%s%s", (const void *)ftproot, (const void *)p);
    return path;
  }
}

// CreateDirectory
// file tightvnc-filetransfer/filetransfermsg.h line 52
void CreateDirectory(char *dirName)
{
  if(!(dirName == ((char *)NULL)))
  {
    signed int return_value_mkdir_1;
    return_value_mkdir_1=mkdir(dirName, (unsigned int)0700);
    if(return_value_mkdir_1 == -1)
      rfbLog("File [%s]: Method [%s]: Create operation for directory <%s> failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateDirectory", dirName);

  }

}

// CreateFileDownloadBlockSizeDataMsg
// file tightvnc-filetransfer/filetransfermsg.c line 578
struct _FileTransferMsg CreateFileDownloadBlockSizeDataMsg(unsigned short int sizeFile, char *pFile)
{
  struct _FileTransferMsg fileDownloadBlockSizeDataMsg;
  signed int length = 6 + (signed int)sizeFile;
  struct _rfbFileDownloadDataMsg *pFDD = (struct _rfbFileDownloadDataMsg *)(void *)0;
  char *pFollow = (char *)(void *)0;
  char *pData;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)length, sizeof(char) /*1ul*/ );
  pData = (char *)return_value_calloc_1;
  memset((void *)&fileDownloadBlockSizeDataMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  if(pData == ((char *)NULL))
  {
    rfbLog("File [%s]: Method [%s]: pData is NULL\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileDownloadBlockSizeDataMsg");
    return fileDownloadBlockSizeDataMsg;
  }

  else
  {
    pFDD = (struct _rfbFileDownloadDataMsg *)pData;
    pFollow = &pData[(signed long int)6];
    pFDD->type = (unsigned char)131;
    pFDD->compressLevel = (unsigned char)0;
    pFDD->compressedSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)sizeFile & 0xff) << 8 | (signed int)sizeFile >> 8 & 0xff : (signed int)sizeFile);
    pFDD->realSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)sizeFile & 0xff) << 8 | (signed int)sizeFile >> 8 & 0xff : (signed int)sizeFile);
    memcpy((void *)pFollow, (const void *)pFile, (unsigned long int)sizeFile);
    fileDownloadBlockSizeDataMsg.data = pData;
    fileDownloadBlockSizeDataMsg.length = (unsigned int)length;
    return fileDownloadBlockSizeDataMsg;
  }
}

// CreateFileDownloadErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 514
struct _FileTransferMsg CreateFileDownloadErrMsg(char *reason, unsigned int reasonLen)
{
  struct _FileTransferMsg fileDownloadErrMsg;
  signed int length = (signed int)((unsigned int)4 + reasonLen + (unsigned int)1);
  struct _rfbFileDownloadFailedMsg *pFDF = (struct _rfbFileDownloadFailedMsg *)(void *)0;
  char *pFollow = (char *)(void *)0;
  char *pData;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)length, sizeof(char) /*1ul*/ );
  pData = (char *)return_value_calloc_1;
  memset((void *)&fileDownloadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  if(pData == ((char *)NULL))
  {
    rfbLog("File [%s]: Method [%s]: pData is NULL\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileDownloadErrMsg");
    return fileDownloadErrMsg;
  }

  else
  {
    pFDF = (struct _rfbFileDownloadFailedMsg *)pData;
    pFollow = &pData[(signed long int)4];
    pFDF->type = (unsigned char)133;
    pFDF->reasonLen = (unsigned short int)(rfbEndianTest != 0 ? (reasonLen & (unsigned int)0xff) << 8 | reasonLen >> 8 & (unsigned int)0xff : reasonLen);
    memcpy((void *)pFollow, (const void *)reason, (unsigned long int)reasonLen);
    fileDownloadErrMsg.data = pData;
    fileDownloadErrMsg.length = (unsigned int)length;
    return fileDownloadErrMsg;
  }
}

// CreateFileDownloadZeroSizeDataMsg
// file tightvnc-filetransfer/filetransfermsg.c line 544
struct _FileTransferMsg CreateFileDownloadZeroSizeDataMsg(unsigned long int mTime)
{
  struct _FileTransferMsg fileDownloadZeroSizeDataMsg;
  signed int length = (signed int)((unsigned long int)6 + sizeof(unsigned long int) /*8ul*/ );
  struct _rfbFileDownloadDataMsg *pFDD = (struct _rfbFileDownloadDataMsg *)(void *)0;
  char *pFollow = (char *)(void *)0;
  char *pData;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)length, sizeof(char) /*1ul*/ );
  pData = (char *)return_value_calloc_1;
  memset((void *)&fileDownloadZeroSizeDataMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  if(pData == ((char *)NULL))
  {
    rfbLog("File [%s]: Method [%s]: pData is NULL\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileDownloadZeroSizeDataMsg");
    return fileDownloadZeroSizeDataMsg;
  }

  else
  {
    pFDD = (struct _rfbFileDownloadDataMsg *)pData;
    pFollow = &pData[(signed long int)6];
    pFDD->type = (unsigned char)131;
    pFDD->compressLevel = (unsigned char)0;
    pFDD->compressedSize = (unsigned short int)(rfbEndianTest != 0 ? (0 & 0xff) << 8 | 0 >> 8 & 0xff : 0);
    pFDD->realSize = (unsigned short int)(rfbEndianTest != 0 ? (0 & 0xff) << 8 | 0 >> 8 & 0xff : 0);
    memcpy((void *)pFollow, (const void *)&mTime, sizeof(unsigned long int) /*8ul*/ );
    fileDownloadZeroSizeDataMsg.data = pData;
    fileDownloadZeroSizeDataMsg.length = (unsigned int)length;
    return fileDownloadZeroSizeDataMsg;
  }
}

// CreateFileListErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 326
struct _FileTransferMsg CreateFileListErrMsg(char flags)
{
  struct _FileTransferMsg fileListMsg;
  struct _rfbFileListDataMsg *pFLD = (struct _rfbFileListDataMsg *)(void *)0;
  char *data = (char *)(void *)0;
  unsigned int length = (unsigned int)0;
  memset((void *)&fileListMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct _rfbFileListDataMsg) /*8ul*/ , sizeof(char) /*1ul*/ );
  data = (char *)return_value_calloc_1;
  if(data == ((char *)NULL))
    return fileListMsg;

  else
  {
    length = (unsigned int)(sizeof(struct _rfbFileListDataMsg) /*8ul*/  * sizeof(char) /*1ul*/ );
    pFLD = (struct _rfbFileListDataMsg *)data;
    pFLD->type = (unsigned char)130;
    pFLD->numFiles = (unsigned short int)(rfbEndianTest != 0 ? (0 & 0xff) << 8 | 0 >> 8 & 0xff : 0);
    pFLD->dataSize = (unsigned short int)(rfbEndianTest != 0 ? (0 & 0xff) << 8 | 0 >> 8 & 0xff : 0);
    pFLD->compressedSize = (unsigned short int)(rfbEndianTest != 0 ? (0 & 0xff) << 8 | 0 >> 8 & 0xff : 0);
    pFLD->flags = (unsigned char)((signed int)flags | 0x80);
    fileListMsg.data = data;
    fileListMsg.length = length;
    return fileListMsg;
  }
}

// CreateFileListInfo
// file tightvnc-filetransfer/filetransfermsg.c line 253
signed int CreateFileListInfo(struct _FileListInfo *pFileListInfo, char *path, signed int flag)
{
  struct __dirstream *pDir = (struct __dirstream *)(void *)0;
  struct dirent *pDirent = (struct dirent *)(void *)0;
  signed int return_value_strcmp_7;
  if(path == ((char *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(path);
    if(return_value_strlen_2 == 0ul)
    {
      char *return_value_GetFtpRoot_1;
      return_value_GetFtpRoot_1=GetFtpRoot();
      sprintf(path, "%s%s", return_value_GetFtpRoot_1, (const void *)"/");
    }

    pDir=opendir(path);
    if(pDir == ((struct __dirstream *)NULL))
    {
      rfbLog("File [%s]: Method [%s]: not able to open the dir\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileListInfo");
      return 0;
    }

    else
    {
      do
      {
        pDirent=readdir(pDir);
        if(pDirent == ((struct dirent *)NULL))
          break;

        signed int return_value_strcmp_8;
        return_value_strcmp_8=strcmp(pDirent->d_name, ".");
        if(!(return_value_strcmp_8 == 0))
        {
          return_value_strcmp_7=strcmp(pDirent->d_name, "..");
          if(!(return_value_strcmp_7 == 0))
          {
            struct stat stat_buf;
            char fullpath[4096l];
            memset((void *)fullpath, 0, (unsigned long int)4096);
            strcpy(fullpath, path);
            unsigned long int return_value_strlen_3;
            return_value_strlen_3=strlen(path);
            if(!((signed int)path[-1l + (signed long int)return_value_strlen_3] == 47))
              strcat(fullpath, "/");

            strcat(fullpath, pDirent->d_name);
            signed int return_value_stat_4;
            return_value_stat_4=stat(fullpath, &stat_buf);
            if(!(return_value_stat_4 >= 0))
            {
              rfbLog("File [%s]: Method [%s]: Reading stat for file %s failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileListInfo", (const void *)fullpath);
              continue;
            }

            if((61440u & stat_buf.st_mode) == 16384u)
            {
              signed int return_value_AddFileListItemInfo_5;
              return_value_AddFileListItemInfo_5=AddFileListItemInfo(pFileListInfo, pDirent->d_name, (unsigned int)-1, (unsigned int)0);
              if(return_value_AddFileListItemInfo_5 == 0)
              {
                rfbLog("File [%s]: Method [%s]: Add directory %s in the list failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileListInfo", (const void *)fullpath);
                continue;
              }

            }

            else
              if(!(flag == 0))
              {
                signed int return_value_AddFileListItemInfo_6;
                return_value_AddFileListItemInfo_6=AddFileListItemInfo(pFileListInfo, pDirent->d_name, (unsigned int)stat_buf.st_size, (unsigned int)stat_buf.st_mtim.tv_sec);
                if(return_value_AddFileListItemInfo_6 == 0)
                {
                  rfbLog("File [%s]: Method [%s]: Add file %s in the list failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileListInfo", (const void *)fullpath);
                  continue;
                }

              }

          }

        }

      }
      while((_Bool)1);
      signed int return_value_closedir_9;
      return_value_closedir_9=closedir(pDir);
      if(!(return_value_closedir_9 >= 0))
        rfbLog("File [%s]: Method [%s]: ERROR Couldn't close dir\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileListInfo");

      return 1;
    }
  }
}

// CreateFileListMsg
// file tightvnc-filetransfer/filetransfermsg.c line 356
struct _FileTransferMsg CreateFileListMsg(struct _FileListInfo fileListInfo, char flags)
{
  struct _FileTransferMsg fileListMsg;
  struct _rfbFileListDataMsg *pFLD = (struct _rfbFileListDataMsg *)(void *)0;
  char *data = (char *)(void *)0;
  char *pFileNames = (char *)(void *)0;
  unsigned int length = (unsigned int)0;
  unsigned int dsSize = (unsigned int)0;
  unsigned int i = (unsigned int)0;
  struct _FileListItemSize *pFileListItemSize = (struct _FileListItemSize *)(void *)0;
  memset((void *)&fileListMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  dsSize = (unsigned int)(fileListInfo.numEntries * 8);
  unsigned int return_value_GetSumOfFileNamesLength_1;
  return_value_GetSumOfFileNamesLength_1=GetSumOfFileNamesLength(fileListInfo);
  length = (unsigned int)8 + dsSize + return_value_GetSumOfFileNamesLength_1 + (unsigned int)fileListInfo.numEntries;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)length, sizeof(char) /*1ul*/ );
  data = (char *)return_value_calloc_2;
  unsigned int tmp_if_expr_6;
  unsigned int return_value_GetSumOfFileNamesLength_3;
  unsigned int return_value_GetSumOfFileNamesLength_4;
  unsigned int return_value_GetSumOfFileNamesLength_5;
  unsigned int tmp_if_expr_12;
  unsigned int return_value_GetFileSizeAt_7;
  unsigned int return_value_GetFileSizeAt_8;
  unsigned int return_value_GetFileSizeAt_9;
  unsigned int return_value_GetFileSizeAt_10;
  unsigned int return_value_GetFileSizeAt_11;
  unsigned int tmp_if_expr_18;
  unsigned int return_value_GetFileDataAt_13;
  unsigned int return_value_GetFileDataAt_14;
  unsigned int return_value_GetFileDataAt_15;
  unsigned int return_value_GetFileDataAt_16;
  unsigned int return_value_GetFileDataAt_17;
  unsigned long int return_value_strlen_20;
  if(data == ((char *)NULL))
    return fileListMsg;

  else
  {
    pFLD = (struct _rfbFileListDataMsg *)data;
    pFileListItemSize = (struct _FileListItemSize *)&data[(signed long int)8];
    pFileNames = &data[(signed long int)((unsigned int)8 + dsSize)];
    pFLD->type = (unsigned char)130;
    pFLD->flags = (unsigned char)((signed int)flags & 0xF0);
    pFLD->numFiles = (unsigned short int)(rfbEndianTest != 0 ? (fileListInfo.numEntries & 0xff) << 8 | fileListInfo.numEntries >> 8 & 0xff : fileListInfo.numEntries);
    if(!(rfbEndianTest == 0))
    {
      return_value_GetSumOfFileNamesLength_3=GetSumOfFileNamesLength(fileListInfo);
      return_value_GetSumOfFileNamesLength_4=GetSumOfFileNamesLength(fileListInfo);
      tmp_if_expr_6 = (return_value_GetSumOfFileNamesLength_3 + (unsigned int)fileListInfo.numEntries & (unsigned int)0xff) << 8 | return_value_GetSumOfFileNamesLength_4 + (unsigned int)fileListInfo.numEntries >> 8 & (unsigned int)0xff;
    }

    else
    {
      return_value_GetSumOfFileNamesLength_5=GetSumOfFileNamesLength(fileListInfo);
      tmp_if_expr_6 = return_value_GetSumOfFileNamesLength_5 + (unsigned int)fileListInfo.numEntries;
    }
    pFLD->dataSize = (unsigned short int)tmp_if_expr_6;
    pFLD->compressedSize = pFLD->dataSize;
    i = (unsigned int)0;
    for( ; !(i >= (unsigned int)fileListInfo.numEntries); i = i + 1u)
    {
      if(!(rfbEndianTest == 0))
      {
        return_value_GetFileSizeAt_7=GetFileSizeAt(fileListInfo, (signed int)i);
        return_value_GetFileSizeAt_8=GetFileSizeAt(fileListInfo, (signed int)i);
        return_value_GetFileSizeAt_9=GetFileSizeAt(fileListInfo, (signed int)i);
        return_value_GetFileSizeAt_10=GetFileSizeAt(fileListInfo, (signed int)i);
        tmp_if_expr_12 = return_value_GetFileSizeAt_7 >> 24 | (return_value_GetFileSizeAt_8 & (unsigned int)0x00ff0000) >> 8 | (return_value_GetFileSizeAt_9 & (unsigned int)0x0000ff00) << 8 | return_value_GetFileSizeAt_10 << 24;
      }

      else
      {
        return_value_GetFileSizeAt_11=GetFileSizeAt(fileListInfo, (signed int)i);
        tmp_if_expr_12 = return_value_GetFileSizeAt_11;
      }
      (pFileListItemSize + (signed long int)i)->size = tmp_if_expr_12;
      if(!(rfbEndianTest == 0))
      {
        return_value_GetFileDataAt_13=GetFileDataAt(fileListInfo, (signed int)i);
        return_value_GetFileDataAt_14=GetFileDataAt(fileListInfo, (signed int)i);
        return_value_GetFileDataAt_15=GetFileDataAt(fileListInfo, (signed int)i);
        return_value_GetFileDataAt_16=GetFileDataAt(fileListInfo, (signed int)i);
        tmp_if_expr_18 = return_value_GetFileDataAt_13 >> 24 | (return_value_GetFileDataAt_14 & (unsigned int)0x00ff0000) >> 8 | (return_value_GetFileDataAt_15 & (unsigned int)0x0000ff00) << 8 | return_value_GetFileDataAt_16 << 24;
      }

      else
      {
        return_value_GetFileDataAt_17=GetFileDataAt(fileListInfo, (signed int)i);
        tmp_if_expr_18 = return_value_GetFileDataAt_17;
      }
      (pFileListItemSize + (signed long int)i)->data = tmp_if_expr_18;
      char *return_value_GetFileNameAt_19;
      return_value_GetFileNameAt_19=GetFileNameAt(fileListInfo, (signed int)i);
      strcpy(pFileNames, return_value_GetFileNameAt_19);
      if(!(1u + i >= (unsigned int)fileListInfo.numEntries))
      {
        return_value_strlen_20=strlen(pFileNames);
        pFileNames = pFileNames + (signed long int)(return_value_strlen_20 + (unsigned long int)1);
      }

    }
    fileListMsg.data = data;
    fileListMsg.length = length;
    return fileListMsg;
  }
}

// CreateFileUploadErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 702
struct _FileTransferMsg CreateFileUploadErrMsg(char *reason, unsigned int reasonLen)
{
  struct _FileTransferMsg fileUploadErrMsg;
  signed int length = (signed int)((unsigned int)4 + reasonLen);
  struct _rfbFileUploadCancelMsg *pFDF = (struct _rfbFileUploadCancelMsg *)(void *)0;
  char *pFollow = (char *)(void *)0;
  char *pData;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)length, sizeof(char) /*1ul*/ );
  pData = (char *)return_value_calloc_1;
  memset((void *)&fileUploadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  if(pData == ((char *)NULL))
  {
    rfbLog("File [%s]: Method [%s]: pData is NULL\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"CreateFileUploadErrMsg");
    return fileUploadErrMsg;
  }

  else
  {
    pFDF = (struct _rfbFileUploadCancelMsg *)pData;
    pFollow = &pData[(signed long int)4];
    pFDF->type = (unsigned char)132;
    pFDF->reasonLen = (unsigned short int)(rfbEndianTest != 0 ? (reasonLen & (unsigned int)0xff) << 8 | reasonLen >> 8 & (unsigned int)0xff : reasonLen);
    memcpy((void *)pFollow, (const void *)reason, (unsigned long int)reasonLen);
    fileUploadErrMsg.data = pData;
    fileUploadErrMsg.length = (unsigned int)length;
    return fileUploadErrMsg;
  }
}

// DisplayFileList
// file tightvnc-filetransfer/filelistinfo.c line 33
void DisplayFileList(struct _FileListInfo fli)
{
  signed int i = 0;
  if(!(fli.pEntries == ((struct _FileListItemInfo *)NULL)) && !(fli.numEntries == 0))
  {
    rfbLog("DISPLAYING FILE NAMES IN THE LIST ...START\n\n");
    rfbLog("Numer of entries:: %d\n", fli.numEntries);
    i = 0;
    if(!(i >= fli.numEntries))
    {
      rfbLog("file[%d]\t<%s>\n", i, (const void *)(fli.pEntries + (signed long int)i)->name);
      i = i + 1;
    }

    rfbLog("DISPLAYING FILE NAMES IN THE LIST ...END\n\n");
  }

}

// EnableFileTransfer
// file tightvnc-filetransfer/handlefiletransferrequest.h line 34
void EnableFileTransfer(signed char enable)
{
  fileTransferEnabled = enable;
}

// EncodeIndexedRect16
// file tight.c line 1491
static void EncodeIndexedRect16(unsigned char *buf, signed int count)
{
  struct COLOR_LIST_s *pnode;
  unsigned short int *src;
  unsigned short int rgb;
  signed int rep = 0;
  src = (unsigned short int *)buf;
  signed int tmp_post_1;
  unsigned short int *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  do
  {
    tmp_post_1 = count;
    count = count - 1;
    if(tmp_post_1 == 0)
      break;

    tmp_post_2 = src;
    src = src + 1l;
    rgb = *tmp_post_2;
    for( ; !(count == 0); count = count - 1)
    {
      if(!(*src == rgb))
        break;

      rep = rep + 1;
      src = src + 1l;
    }
    pnode = palette.hash[(signed long int)(signed int)(((signed int)rgb >> 8) + (signed int)rgb & 0xFF)];
    for( ; !(pnode == ((struct COLOR_LIST_s *)NULL)); pnode = pnode->next)
      if((unsigned short int)pnode->rgb == rgb)
      {
        tmp_post_3 = buf;
        buf = buf + 1l;
        *tmp_post_3 = (unsigned char)pnode->idx;
        for( ; !(rep == 0); rep = rep - 1)
        {
          tmp_post_4 = buf;
          buf = buf + 1l;
          *tmp_post_4 = (unsigned char)pnode->idx;
        }
        break;
      }

  }
  while((_Bool)1);
}

// EncodeIndexedRect32
// file tight.c line 1492
static void EncodeIndexedRect32(unsigned char *buf, signed int count)
{
  struct COLOR_LIST_s *pnode;
  unsigned int *src;
  unsigned int rgb;
  signed int rep = 0;
  src = (unsigned int *)buf;
  signed int tmp_post_1;
  unsigned int *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  do
  {
    tmp_post_1 = count;
    count = count - 1;
    if(tmp_post_1 == 0)
      break;

    tmp_post_2 = src;
    src = src + 1l;
    rgb = *tmp_post_2;
    for( ; !(count == 0); count = count - 1)
    {
      if(!(*src == rgb))
        break;

      rep = rep + 1;
      src = src + 1l;
    }
    pnode = palette.hash[(signed long int)(signed int)((rgb >> 16) + (rgb >> 8) & (unsigned int)0xFF)];
    for( ; !(pnode == ((struct COLOR_LIST_s *)NULL)); pnode = pnode->next)
      if(pnode->rgb == rgb)
      {
        tmp_post_3 = buf;
        buf = buf + 1l;
        *tmp_post_3 = (unsigned char)pnode->idx;
        for( ; !(rep == 0); rep = rep - 1)
        {
          tmp_post_4 = buf;
          buf = buf + 1l;
          *tmp_post_4 = (unsigned char)pnode->idx;
        }
        break;
      }

  }
  while((_Bool)1);
}

// EncodeMonoRect16
// file tight.c line 1546
static void EncodeMonoRect16(unsigned char *buf, signed int w, signed int h)
{
  unsigned short int *ptr;
  unsigned short int bg;
  unsigned int value;
  unsigned int mask;
  signed int aligned_width;
  signed int x;
  signed int y;
  signed int bg_bits;
  ptr = (unsigned short int *)buf;
  bg = (unsigned short int)monoBackground;
  aligned_width = w - w % 8;
  y = 0;
  unsigned short int *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned short int *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned short int *tmp_post_5;
  unsigned char *tmp_post_6;
  for( ; !(y >= h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= aligned_width); x = x + 8)
    {
      bg_bits = 0;
      for( ; !(bg_bits >= 8); bg_bits = bg_bits + 1)
      {
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        if(!(*tmp_post_1 == bg))
          break;

      }
      if(bg_bits == 8)
      {
        tmp_post_2 = buf;
        buf = buf + 1l;
        *tmp_post_2 = (unsigned char)0;
      }

      else
      {
        mask = (unsigned int)(0x80 >> bg_bits);
        value = mask;
        bg_bits = bg_bits + 1;
        for( ; !(bg_bits >= 8); bg_bits = bg_bits + 1)
        {
          mask = mask >> 1;
          tmp_post_3 = ptr;
          ptr = ptr + 1l;
          if(!(*tmp_post_3 == bg))
            value = value | mask;

        }
        tmp_post_4 = buf;
        buf = buf + 1l;
        *tmp_post_4 = (unsigned char)value;
      }
    }
    mask = (unsigned int)0x80;
    value = (unsigned int)0;
    if(!(x >= w))
    {
      for( ; !(x >= w); x = x + 1)
      {
        tmp_post_5 = ptr;
        ptr = ptr + 1l;
        if(!(*tmp_post_5 == bg))
          value = value | mask;

        mask = mask >> 1;
      }
      tmp_post_6 = buf;
      buf = buf + 1l;
      *tmp_post_6 = (unsigned char)value;
    }

  }
}

// EncodeMonoRect32
// file tight.c line 1547
static void EncodeMonoRect32(unsigned char *buf, signed int w, signed int h)
{
  unsigned int *ptr;
  unsigned int bg;
  unsigned int value;
  unsigned int mask;
  signed int aligned_width;
  signed int x;
  signed int y;
  signed int bg_bits;
  ptr = (unsigned int *)buf;
  bg = (unsigned int)monoBackground;
  aligned_width = w - w % 8;
  y = 0;
  unsigned int *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned int *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned int *tmp_post_5;
  unsigned char *tmp_post_6;
  for( ; !(y >= h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= aligned_width); x = x + 8)
    {
      bg_bits = 0;
      for( ; !(bg_bits >= 8); bg_bits = bg_bits + 1)
      {
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        if(!(*tmp_post_1 == bg))
          break;

      }
      if(bg_bits == 8)
      {
        tmp_post_2 = buf;
        buf = buf + 1l;
        *tmp_post_2 = (unsigned char)0;
      }

      else
      {
        mask = (unsigned int)(0x80 >> bg_bits);
        value = mask;
        bg_bits = bg_bits + 1;
        for( ; !(bg_bits >= 8); bg_bits = bg_bits + 1)
        {
          mask = mask >> 1;
          tmp_post_3 = ptr;
          ptr = ptr + 1l;
          if(!(*tmp_post_3 == bg))
            value = value | mask;

        }
        tmp_post_4 = buf;
        buf = buf + 1l;
        *tmp_post_4 = (unsigned char)value;
      }
    }
    mask = (unsigned int)0x80;
    value = (unsigned int)0;
    if(!(x >= w))
    {
      for( ; !(x >= w); x = x + 1)
      {
        tmp_post_5 = ptr;
        ptr = ptr + 1l;
        if(!(*tmp_post_5 == bg))
          value = value | mask;

        mask = mask >> 1;
      }
      tmp_post_6 = buf;
      buf = buf + 1l;
      *tmp_post_6 = (unsigned char)value;
    }

  }
}

// EncodeMonoRect8
// file tight.c line 1545
static void EncodeMonoRect8(unsigned char *buf, signed int w, signed int h)
{
  unsigned char *ptr;
  unsigned char bg;
  unsigned int value;
  unsigned int mask;
  signed int aligned_width;
  signed int x;
  signed int y;
  signed int bg_bits;
  ptr = (unsigned char *)buf;
  bg = (unsigned char)monoBackground;
  aligned_width = w - w % 8;
  y = 0;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  for( ; !(y >= h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= aligned_width); x = x + 8)
    {
      bg_bits = 0;
      for( ; !(bg_bits >= 8); bg_bits = bg_bits + 1)
      {
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        if(!(*tmp_post_1 == bg))
          break;

      }
      if(bg_bits == 8)
      {
        tmp_post_2 = buf;
        buf = buf + 1l;
        *tmp_post_2 = (unsigned char)0;
      }

      else
      {
        mask = (unsigned int)(0x80 >> bg_bits);
        value = mask;
        bg_bits = bg_bits + 1;
        for( ; !(bg_bits >= 8); bg_bits = bg_bits + 1)
        {
          mask = mask >> 1;
          tmp_post_3 = ptr;
          ptr = ptr + 1l;
          if(!(*tmp_post_3 == bg))
            value = value | mask;

        }
        tmp_post_4 = buf;
        buf = buf + 1l;
        *tmp_post_4 = (unsigned char)value;
      }
    }
    mask = (unsigned int)0x80;
    value = (unsigned int)0;
    if(!(x >= w))
    {
      for( ; !(x >= w); x = x + 1)
      {
        tmp_post_5 = ptr;
        ptr = ptr + 1l;
        if(!(*tmp_post_5 == bg))
          value = value | mask;

        mask = mask >> 1;
      }
      tmp_post_6 = buf;
      buf = buf + 1l;
      *tmp_post_6 = (unsigned char)value;
    }

  }
}

// ExtendSolidArea
// file tight.c line 516
static void ExtendSolidArea(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int colorValue, signed int *x_ptr, signed int *y_ptr, signed int *w_ptr, signed int *h_ptr)
{
  signed int cx;
  signed int cy = *y_ptr - 1;
  _Bool tmp_if_expr_2;
  signed char return_value_CheckSolidTile_1;
  do
  {
    if(cy >= y)
    {
      return_value_CheckSolidTile_1=CheckSolidTile(cl, *x_ptr, cy, *w_ptr, 1, &colorValue, (signed char)-1);
      tmp_if_expr_2 = return_value_CheckSolidTile_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    cy = cy - 1;
  }
  while((_Bool)1);
  *h_ptr = *h_ptr + (*y_ptr - (cy + 1));
  *y_ptr = cy + 1;
  cy = *y_ptr + *h_ptr;
  _Bool tmp_if_expr_4;
  signed char return_value_CheckSolidTile_3;
  do
  {
    if(!(cy >= h + y))
    {
      return_value_CheckSolidTile_3=CheckSolidTile(cl, *x_ptr, cy, *w_ptr, 1, &colorValue, (signed char)-1);
      tmp_if_expr_4 = return_value_CheckSolidTile_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(!tmp_if_expr_4)
      break;

    cy = cy + 1;
  }
  while((_Bool)1);
  *h_ptr = *h_ptr + (cy - (*y_ptr + *h_ptr));
  cx = *x_ptr - 1;
  _Bool tmp_if_expr_6;
  signed char return_value_CheckSolidTile_5;
  do
  {
    if(cx >= x)
    {
      return_value_CheckSolidTile_5=CheckSolidTile(cl, cx, *y_ptr, 1, *h_ptr, &colorValue, (signed char)-1);
      tmp_if_expr_6 = return_value_CheckSolidTile_5 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(!tmp_if_expr_6)
      break;

    cx = cx - 1;
  }
  while((_Bool)1);
  *w_ptr = *w_ptr + (*x_ptr - (cx + 1));
  *x_ptr = cx + 1;
  cx = *x_ptr + *w_ptr;
  _Bool tmp_if_expr_8;
  signed char return_value_CheckSolidTile_7;
  do
  {
    if(!(cx >= w + x))
    {
      return_value_CheckSolidTile_7=CheckSolidTile(cl, cx, *y_ptr, 1, *h_ptr, &colorValue, (signed char)-1);
      tmp_if_expr_8 = return_value_CheckSolidTile_7 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(!tmp_if_expr_8)
      break;

    cx = cx + 1;
  }
  while((_Bool)1);
  *w_ptr = *w_ptr + (cx - (*x_ptr + *w_ptr));
}

// FastFillPalette16
// file tight.c line 1334
static void FastFillPalette16(struct _rfbClientRec *cl, unsigned short int *data, signed int w, signed int pitch, signed int h)
{
  unsigned short int c0;
  unsigned short int c1;
  unsigned short int ci;
  unsigned short int mask;
  unsigned short int c0t;
  unsigned short int c1t;
  unsigned short int cit;
  signed int i;
  signed int FastFillPalette16__1__j;
  signed int i2 = 0;
  signed int j2;
  signed int n0;
  signed int n1;
  signed int ni;
  if(!(cl->translateFn == rfbTranslateNone))
  {
    mask = (unsigned short int)((signed int)cl->screen->serverFormat.redMax << (signed int)cl->screen->serverFormat.redShift);
    mask = mask | (unsigned short int)((signed int)cl->screen->serverFormat.greenMax << (signed int)cl->screen->serverFormat.greenShift);
    mask = mask | (unsigned short int)((signed int)cl->screen->serverFormat.blueMax << (signed int)cl->screen->serverFormat.blueShift);
  }

  else
    mask = (unsigned short int)~0;
  c0 = (unsigned short int)((signed int)data[(signed long int)0] & (signed int)mask);
  FastFillPalette16__1__j = 0;
  for( ; !(FastFillPalette16__1__j >= h); FastFillPalette16__1__j = FastFillPalette16__1__j + 1)
  {
    i = 0;
    for( ; !(i >= w); i = i + 1)
      if(!(((signed int)data[(signed long int)(FastFillPalette16__1__j * pitch + i)] & (signed int)mask) == (signed int)c0))
        goto done;

  }

done:
  ;
  if(FastFillPalette16__1__j >= h)
    paletteNumColors = 1;

  else
    if(!(paletteMaxColors >= 2))
      paletteNumColors = 0;

    else
    {
      n0 = FastFillPalette16__1__j * w + i;
      c1 = (unsigned short int)((signed int)data[(signed long int)(FastFillPalette16__1__j * pitch + i)] & (signed int)mask);
      n1 = 0;
      i = i + 1;
      if(i >= w)
      {
        i = 0;
        FastFillPalette16__1__j = FastFillPalette16__1__j + 1;
      }

      j2 = FastFillPalette16__1__j;
      for( ; !(j2 >= h); j2 = j2 + 1)
      {
        i2 = i;
        for( ; !(i2 >= w); i2 = i2 + 1)
        {
          ci = (unsigned short int)((signed int)data[(signed long int)(j2 * pitch + i2)] & (signed int)mask);
          if(ci == c0)
            n0 = n0 + 1;

          else
            if(ci == c1)
              n1 = n1 + 1;

            else
              goto done2;
        }
        i = 0;
      }

    done2:
      ;
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&c0, (char *)&c0t, 16 / 8, 1, 1);
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&c1, (char *)&c1t, 16 / 8, 1, 1);
      if(j2 >= h)
      {
        if(!(n1 >= n0))
        {
          monoBackground = (unsigned int)c0t;
          monoForeground = (unsigned int)c1t;
        }

        else
        {
          monoBackground = (unsigned int)c1t;
          monoForeground = (unsigned int)c0t;
        }
        paletteNumColors = 2;
      }

      else
      {
        PaletteReset();
        PaletteInsert((unsigned int)c0t, (signed int)(unsigned int)n0, 16);
        PaletteInsert((unsigned int)c1t, (signed int)(unsigned int)n1, 16);
        ni = 1;
        i2 = i2 + 1;
        if(i2 >= w)
        {
          i2 = 0;
          j2 = j2 + 1;
        }

        FastFillPalette16__1__j = j2;
        if(!(FastFillPalette16__1__j >= h))
        {
          i = i2;
          if(!(i >= w))
          {
            if(((signed int)data[(signed long int)(FastFillPalette16__1__j * pitch + i)] & (signed int)mask) == (signed int)ci)
              ni = ni + 1;

            else
            {
              cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&ci, (char *)&cit, 16 / 8, 1, 1);
              signed int return_value_PaletteInsert_1;
              return_value_PaletteInsert_1=PaletteInsert((unsigned int)cit, (signed int)(unsigned int)ni, 16);
              ci = (unsigned short int)((signed int)data[(signed long int)(FastFillPalette16__1__j * pitch + i)] & (signed int)mask);
              ni = 1;
            }
            i = i + 1;
          }

          i2 = 0;
          FastFillPalette16__1__j = FastFillPalette16__1__j + 1;
        }

        cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&ci, (char *)&cit, 16 / 8, 1, 1);
        PaletteInsert((unsigned int)cit, (signed int)(unsigned int)ni, 16);
      }
    }
}

// FastFillPalette32
// file tight.c line 1335
static void FastFillPalette32(struct _rfbClientRec *cl, unsigned int *data, signed int w, signed int pitch, signed int h)
{
  unsigned int c0;
  unsigned int c1;
  unsigned int ci;
  unsigned int mask;
  unsigned int c0t;
  unsigned int c1t;
  unsigned int cit;
  signed int i;
  signed int FastFillPalette32__1__j;
  signed int i2 = 0;
  signed int j2;
  signed int n0;
  signed int n1;
  signed int ni;
  if(!(cl->translateFn == rfbTranslateNone))
  {
    mask = (unsigned int)((signed int)cl->screen->serverFormat.redMax << (signed int)cl->screen->serverFormat.redShift);
    mask = mask | (unsigned int)((signed int)cl->screen->serverFormat.greenMax << (signed int)cl->screen->serverFormat.greenShift);
    mask = mask | (unsigned int)((signed int)cl->screen->serverFormat.blueMax << (signed int)cl->screen->serverFormat.blueShift);
  }

  else
    mask = (unsigned int)~0;
  c0 = data[(signed long int)0] & mask;
  FastFillPalette32__1__j = 0;
  for( ; !(FastFillPalette32__1__j >= h); FastFillPalette32__1__j = FastFillPalette32__1__j + 1)
  {
    i = 0;
    for( ; !(i >= w); i = i + 1)
      if(!((data[(signed long int)(FastFillPalette32__1__j * pitch + i)] & mask) == c0))
        goto done;

  }

done:
  ;
  if(FastFillPalette32__1__j >= h)
    paletteNumColors = 1;

  else
    if(!(paletteMaxColors >= 2))
      paletteNumColors = 0;

    else
    {
      n0 = FastFillPalette32__1__j * w + i;
      c1 = data[(signed long int)(FastFillPalette32__1__j * pitch + i)] & mask;
      n1 = 0;
      i = i + 1;
      if(i >= w)
      {
        i = 0;
        FastFillPalette32__1__j = FastFillPalette32__1__j + 1;
      }

      j2 = FastFillPalette32__1__j;
      for( ; !(j2 >= h); j2 = j2 + 1)
      {
        i2 = i;
        for( ; !(i2 >= w); i2 = i2 + 1)
        {
          ci = data[(signed long int)(j2 * pitch + i2)] & mask;
          if(ci == c0)
            n0 = n0 + 1;

          else
            if(ci == c1)
              n1 = n1 + 1;

            else
              goto done2;
        }
        i = 0;
      }

    done2:
      ;
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&c0, (char *)&c0t, 32 / 8, 1, 1);
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&c1, (char *)&c1t, 32 / 8, 1, 1);
      if(j2 >= h)
      {
        if(!(n1 >= n0))
        {
          monoBackground = (unsigned int)c0t;
          monoForeground = (unsigned int)c1t;
        }

        else
        {
          monoBackground = (unsigned int)c1t;
          monoForeground = (unsigned int)c0t;
        }
        paletteNumColors = 2;
      }

      else
      {
        PaletteReset();
        PaletteInsert(c0t, (signed int)(unsigned int)n0, 32);
        PaletteInsert(c1t, (signed int)(unsigned int)n1, 32);
        ni = 1;
        i2 = i2 + 1;
        if(i2 >= w)
        {
          i2 = 0;
          j2 = j2 + 1;
        }

        FastFillPalette32__1__j = j2;
        if(!(FastFillPalette32__1__j >= h))
        {
          i = i2;
          if(!(i >= w))
          {
            if((data[(signed long int)(FastFillPalette32__1__j * pitch + i)] & mask) == ci)
              ni = ni + 1;

            else
            {
              cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&ci, (char *)&cit, 32 / 8, 1, 1);
              signed int return_value_PaletteInsert_1;
              return_value_PaletteInsert_1=PaletteInsert(cit, (signed int)(unsigned int)ni, 32);
              ci = data[(signed long int)(FastFillPalette32__1__j * pitch + i)] & mask;
              ni = 1;
            }
            i = i + 1;
          }

          i2 = 0;
          FastFillPalette32__1__j = FastFillPalette32__1__j + 1;
        }

        cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)&ci, (char *)&cit, 32 / 8, 1, 1);
        PaletteInsert(cit, (signed int)(unsigned int)ni, 32);
      }
    }
}

// FileUpdateComplete
// file tightvnc-filetransfer/filetransfermsg.h line 53
void FileUpdateComplete(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  struct utimbuf utb;
  utb.modtime = (signed long int)rtcp->rcft.rcfu.mTime;
  utb.actime = utb.modtime;
  signed int return_value_utime_1;
  return_value_utime_1=utime(rtcp->rcft.rcfu.fName, &utb);
  if(return_value_utime_1 == -1)
    rfbLog("File [%s]: Method [%s]: Setting the modification/access time for the file <%s> failed\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"FileUpdateComplete", (const void *)rtcp->rcft.rcfu.fName);

  if(!(rtcp->rcft.rcfu.uploadFD == -1))
  {
    close(rtcp->rcft.rcfu.uploadFD);
    rtcp->rcft.rcfu.uploadFD = -1;
    rtcp->rcft.rcfu.uploadInProgress = 0;
  }

}

// FillPalette16
// file tight.c line 1231
static void FillPalette16(signed int count)
{
  unsigned short int *data = (unsigned short int *)tightBeforeBuf;
  unsigned short int c0;
  unsigned short int c1;
  unsigned short int ci;
  signed int i;
  signed int n0;
  signed int n1;
  signed int ni;
  c0 = data[(signed long int)0];
  i = 1;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= count))
      tmp_if_expr_1 = data[(signed long int)i] == c0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i >= count)
    paletteNumColors = 1;

  else
    if(!(paletteMaxColors >= 2))
      paletteNumColors = 0;

    else
    {
      n0 = i;
      c1 = data[(signed long int)i];
      n1 = 0;
      i = i + 1;
      for( ; !(i >= count); i = i + 1)
      {
        ci = data[(signed long int)i];
        if(ci == c0)
          n0 = n0 + 1;

        else
          if(ci == c1)
            n1 = n1 + 1;

          else
            break;
      }
      if(i >= count)
      {
        if(!(n1 >= n0))
        {
          monoBackground = (unsigned int)c0;
          monoForeground = (unsigned int)c1;
        }

        else
        {
          monoBackground = (unsigned int)c1;
          monoForeground = (unsigned int)c0;
        }
        paletteNumColors = 2;
      }

      else
      {
        PaletteReset();
        PaletteInsert((unsigned int)c0, (signed int)(unsigned int)n0, 16);
        PaletteInsert((unsigned int)c1, (signed int)(unsigned int)n1, 16);
        ni = 1;
        i = i + 1;
        for( ; !(i >= count); i = i + 1)
          if(data[(signed long int)i] == ci)
            ni = ni + 1;

          else
          {
            signed int return_value_PaletteInsert_2;
            return_value_PaletteInsert_2=PaletteInsert((unsigned int)ci, (signed int)(unsigned int)ni, 16);
            if(return_value_PaletteInsert_2 == 0)
              goto __CPROVER_DUMP_L20;

            ci = data[(signed long int)i];
            ni = 1;
          }
        PaletteInsert((unsigned int)ci, (signed int)(unsigned int)ni, 16);
      }
    }

__CPROVER_DUMP_L20:
  ;
}

// FillPalette32
// file tight.c line 1232
static void FillPalette32(signed int count)
{
  unsigned int *data = (unsigned int *)tightBeforeBuf;
  unsigned int c0;
  unsigned int c1;
  unsigned int ci;
  signed int i;
  signed int n0;
  signed int n1;
  signed int ni;
  c0 = data[(signed long int)0];
  i = 1;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= count))
      tmp_if_expr_1 = data[(signed long int)i] == c0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i >= count)
    paletteNumColors = 1;

  else
    if(!(paletteMaxColors >= 2))
      paletteNumColors = 0;

    else
    {
      n0 = i;
      c1 = data[(signed long int)i];
      n1 = 0;
      i = i + 1;
      for( ; !(i >= count); i = i + 1)
      {
        ci = data[(signed long int)i];
        if(ci == c0)
          n0 = n0 + 1;

        else
          if(ci == c1)
            n1 = n1 + 1;

          else
            break;
      }
      if(i >= count)
      {
        if(!(n1 >= n0))
        {
          monoBackground = (unsigned int)c0;
          monoForeground = (unsigned int)c1;
        }

        else
        {
          monoBackground = (unsigned int)c1;
          monoForeground = (unsigned int)c0;
        }
        paletteNumColors = 2;
      }

      else
      {
        PaletteReset();
        PaletteInsert(c0, (signed int)(unsigned int)n0, 32);
        PaletteInsert(c1, (signed int)(unsigned int)n1, 32);
        ni = 1;
        i = i + 1;
        for( ; !(i >= count); i = i + 1)
          if(data[(signed long int)i] == ci)
            ni = ni + 1;

          else
          {
            signed int return_value_PaletteInsert_2;
            return_value_PaletteInsert_2=PaletteInsert(ci, (signed int)(unsigned int)ni, 32);
            if(return_value_PaletteInsert_2 == 0)
              goto __CPROVER_DUMP_L20;

            ci = data[(signed long int)i];
            ni = 1;
          }
        PaletteInsert(ci, (signed int)(unsigned int)ni, 32);
      }
    }

__CPROVER_DUMP_L20:
  ;
}

// FillPalette8
// file tight.c line 1127
static void FillPalette8(signed int count)
{
  unsigned char *data = (unsigned char *)tightBeforeBuf;
  unsigned char c0;
  unsigned char c1;
  signed int i;
  signed int n0;
  signed int n1;
  paletteNumColors = 0;
  c0 = data[(signed long int)0];
  i = 1;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= count))
      tmp_if_expr_1 = data[(signed long int)i] == c0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i == count)
    paletteNumColors = 1;

  else
    if(paletteMaxColors >= 2)
    {
      n0 = i;
      c1 = data[(signed long int)i];
      n1 = 0;
      i = i + 1;
      for( ; !(i >= count); i = i + 1)
        if(data[(signed long int)i] == c0)
          n0 = n0 + 1;

        else
          if(data[(signed long int)i] == c1)
            n1 = n1 + 1;

          else
            break;
      if(i == count)
      {
        if(!(n1 >= n0))
        {
          monoBackground = (unsigned int)c0;
          monoForeground = (unsigned int)c1;
        }

        else
        {
          monoBackground = (unsigned int)c1;
          monoForeground = (unsigned int)c0;
        }
        paletteNumColors = 2;
      }

    }

}

// FilterWaveletSquare
// file ../common/zywrletemplate.c line 450
static inline void FilterWaveletSquare(signed int *pBuf, signed int width, signed int height, signed int level, signed int l)
{
  signed int r;
  signed int s;
  signed int x;
  signed int y;
  signed int *pH;
  const signed char **pM = zywrleParam[(signed long int)(level - 1)][(signed long int)l];
  s = 2 << l;
  r = 1;
  for( ; !(r >= 4); r = r + 1)
  {
    pH = pBuf;
    if(!((0x01 & r) == 0))
      pH = pH + (signed long int)(s >> 1);

    if(!((0x02 & r) == 0))
      pH = pH + (signed long int)((s >> 1) * width);

    y = 0;
    for( ; !(y >= height / s); y = y + 1)
    {
      x = 0;
      for( ; !(x >= width / s); x = x + 1)
      {
        ((signed char *)pH)[(signed long int)0] = pM[(signed long int)0][(signed long int)((unsigned char *)pH)[(signed long int)0]];
        ((signed char *)pH)[(signed long int)1] = pM[(signed long int)1][(signed long int)((unsigned char *)pH)[(signed long int)1]];
        ((signed char *)pH)[(signed long int)2] = pM[(signed long int)2][(signed long int)((unsigned char *)pH)[(signed long int)2]];
        pH = pH + (signed long int)s;
      }
      pH = pH + (signed long int)((s - 1) * width);
    }
  }
}

// FindBestSolidArea
// file tight.c line 470
static void FindBestSolidArea(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, unsigned int colorValue, signed int *w_ptr, signed int *h_ptr)
{
  signed int dx;
  signed int dy;
  signed int dw;
  signed int dh;
  signed int w_prev;
  signed int w_best = 0;
  signed int h_best = 0;
  w_prev = w;
  dy = y;
  for( ; !(dy >= h + y); dy = dy + 16)
  {
    dh = dy + 16 <= y + h ? 16 : (y + h) - dy;
    dw = w_prev > 16 ? 16 : w_prev;
    signed char return_value_CheckSolidTile_1;
    return_value_CheckSolidTile_1=CheckSolidTile(cl, x, dy, dw, dh, &colorValue, (signed char)-1);
    if(return_value_CheckSolidTile_1 == 0)
      break;

    dx = x + dw;
    while(!(dx >= w_prev + x))
    {
      dw = dx + 16 <= x + w_prev ? 16 : (x + w_prev) - dx;
      signed char return_value_CheckSolidTile_2;
      return_value_CheckSolidTile_2=CheckSolidTile(cl, dx, dy, dw, dh, &colorValue, (signed char)-1);
      if(return_value_CheckSolidTile_2 == 0)
        break;

      dx = dx + dw;
    }
    w_prev = dx - x;
    if(!(h_best * w_best >= (dh + dy + -y) * w_prev))
    {
      w_best = w_prev;
      h_best = (dy + dh) - y;
    }

  }
  *w_ptr = w_best;
  *h_ptr = h_best;
}

// FreeFileListInfo
// file tightvnc-filetransfer/filelistinfo.h line 60
void FreeFileListInfo(struct _FileListInfo fileListInfo)
{
  if(!(fileListInfo.pEntries == ((struct _FileListItemInfo *)NULL)))
  {
    free((void *)fileListInfo.pEntries);
    fileListInfo.pEntries = (struct _FileListItemInfo *)(void *)0;
  }

  fileListInfo.numEntries = 0;
}

// FreeFileTransferMsg
// file tightvnc-filetransfer/filetransfermsg.h line 56
void FreeFileTransferMsg(struct _FileTransferMsg ftm)
{
  if(!(ftm.data == ((char *)NULL)))
  {
    free((void *)ftm.data);
    ftm.data = (char *)(void *)0;
  }

  ftm.length = (unsigned int)0;
}

// FreeHomeDir
// file tightvnc-filetransfer/handlefiletransferrequest.c line 182
void FreeHomeDir(char *homedir)
{
  free((void *)homedir);
}

// GetFileDataAt
// file tightvnc-filetransfer/filelistinfo.h line 58
unsigned int GetFileDataAt(struct _FileListInfo fileListInfo, signed int number)
{
  unsigned int data = (unsigned int)0;
  if(number >= 0 && !(number >= fileListInfo.numEntries))
    data = (fileListInfo.pEntries + (signed long int)number)->data;

  return data;
}

// GetFileDownLoadErrMsg
// file tightvnc-filetransfer/filetransfermsg.h line 43
struct _FileTransferMsg GetFileDownLoadErrMsg()
{
  struct _FileTransferMsg fileDownloadErrMsg;
  char reason[56l] = { 'A', 'n', ' ', 'i', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'c', 'a', 'u', 's', 'e', 'd', ' ', 'd', 'o', 'w', 'n', 'l', 'o', 'a', 'd', ' ', 'f', 'a', 'i', 'l', 'u', 'r', 'e', 0 };
  signed int reasonLen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  reasonLen = (signed int)return_value_strlen_1;
  memset((void *)&fileDownloadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  fileDownloadErrMsg=CreateFileDownloadErrMsg(reason, (unsigned int)reasonLen);
  return fileDownloadErrMsg;
}

// GetFileDownloadLengthErrResponseMsg
// file tightvnc-filetransfer/filetransfermsg.h line 42
struct _FileTransferMsg GetFileDownloadLengthErrResponseMsg()
{
  char reason[42l] = { 'P', 'a', 't', 'h', ' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 's', ' ', 'P', 'A', 'T', 'H', '_', 'M', 'A', 'X', ' ', '(', '4', '0', '9', '6', ')', ' ', 'b', 'y', 't', 'e', 's', 0 };
  signed int reasonLen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  reasonLen = (signed int)return_value_strlen_1;
  struct _FileTransferMsg return_value_CreateFileDownloadErrMsg_2;
  return_value_CreateFileDownloadErrMsg_2=CreateFileDownloadErrMsg(reason, (unsigned int)reasonLen);
  return return_value_CreateFileDownloadErrMsg_2;
}

// GetFileDownloadReadDataErrMsg
// file tightvnc-filetransfer/filetransfermsg.c line 426
struct _FileTransferMsg GetFileDownloadReadDataErrMsg()
{
  char reason[57l] = { 'C', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 'f', 'i', 'l', 'e', ',', ' ', 'p', 'e', 'r', 'h', 'a', 'p', 's', ' ', 'i', 't', ' ', 'i', 's', ' ', 'a', 'b', 's', 'e', 'n', 't', ' ', 'o', 'r', ' ', 'i', 's', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', 0 };
  signed int reasonLen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  reasonLen = (signed int)return_value_strlen_1;
  struct _FileTransferMsg return_value_CreateFileDownloadErrMsg_2;
  return_value_CreateFileDownloadErrMsg_2=CreateFileDownloadErrMsg(reason, (unsigned int)reasonLen);
  return return_value_CreateFileDownloadErrMsg_2;
}

// GetFileDownloadResponseMsgInBlocks
// file tightvnc-filetransfer/filetransfermsg.h line 44
struct _FileTransferMsg GetFileDownloadResponseMsgInBlocks(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int numOfBytesRead = 0;
  char pBuf[8192l];
  char *path = rtcp->rcft.rcfd.fName;
  memset((void *)pBuf, 0, (unsigned long int)8192);
  if(rtcp->rcft.rcfd.downloadInProgress == 0)
  {
    if(rtcp->rcft.rcfd.downloadFD == -1)
    {
      rtcp->rcft.rcfd.downloadFD=open(path, 00);
      if(rtcp->rcft.rcfd.downloadFD == -1)
      {
        rfbLog("File [%s]: Method [%s]: Error: Couldn't open file\n", (const void *)"tightvnc-filetransfer/filetransfermsg.c", (const void *)"GetFileDownloadResponseMsgInBlocks");
        struct _FileTransferMsg return_value_GetFileDownloadReadDataErrMsg_1;
        return_value_GetFileDownloadReadDataErrMsg_1=GetFileDownloadReadDataErrMsg();
        return return_value_GetFileDownloadReadDataErrMsg_1;
      }

      rtcp->rcft.rcfd.downloadInProgress = -1;
    }

  }

  if(rtcp->rcft.rcfd.downloadInProgress == -1)
  {
    if(!(rtcp->rcft.rcfd.downloadFD == -1))
    {
      signed long int return_value_read_4;
      return_value_read_4=read(rtcp->rcft.rcfd.downloadFD, (void *)pBuf, (unsigned long int)8192);
      numOfBytesRead = (signed int)return_value_read_4;
      if(!(numOfBytesRead >= 1))
      {
        close(rtcp->rcft.rcfd.downloadFD);
        rtcp->rcft.rcfd.downloadFD = -1;
        rtcp->rcft.rcfd.downloadInProgress = 0;
        if(numOfBytesRead == 0)
        {
          struct _FileTransferMsg return_value_CreateFileDownloadZeroSizeDataMsg_2;
          return_value_CreateFileDownloadZeroSizeDataMsg_2=CreateFileDownloadZeroSizeDataMsg(rtcp->rcft.rcfd.mTime);
          return return_value_CreateFileDownloadZeroSizeDataMsg_2;
        }

        struct _FileTransferMsg return_value_GetFileDownloadReadDataErrMsg_3;
        return_value_GetFileDownloadReadDataErrMsg_3=GetFileDownloadReadDataErrMsg();
        return return_value_GetFileDownloadReadDataErrMsg_3;
      }

      struct _FileTransferMsg return_value_CreateFileDownloadBlockSizeDataMsg_5;
      return_value_CreateFileDownloadBlockSizeDataMsg_5=CreateFileDownloadBlockSizeDataMsg((unsigned short int)numOfBytesRead, pBuf);
      return return_value_CreateFileDownloadBlockSizeDataMsg_5;
    }

  }

  struct _FileTransferMsg return_value_GetFileDownLoadErrMsg_6;
  return_value_GetFileDownLoadErrMsg_6=GetFileDownLoadErrMsg();
  return return_value_GetFileDownLoadErrMsg_6;
}

// GetFileListResponseMsg
// file tightvnc-filetransfer/filetransfermsg.h line 39
struct _FileTransferMsg GetFileListResponseMsg(char *path, char flags)
{
  struct _FileTransferMsg fileListMsg;
  struct _FileListInfo fileListInfo;
  signed int status = -1;
  memset((void *)&fileListMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  memset((void *)&fileListInfo, 0, sizeof(struct _FileListInfo) /*16ul*/ );
  status=CreateFileListInfo(&fileListInfo, path, (signed int)!(((signed int)flags & 0x10) != 0));
  if(status == 0)
    fileListMsg=CreateFileListErrMsg(flags);

  else
  {
    fileListMsg=CreateFileListMsg(fileListInfo, flags);
    FreeFileListInfo(fileListInfo);
  }
  return fileListMsg;
}

// GetFileNameAt
// file tightvnc-filetransfer/filelistinfo.h line 56
char * GetFileNameAt(struct _FileListInfo fileListInfo, signed int number)
{
  char *name = (char *)(void *)0;
  if(number >= 0 && !(number >= fileListInfo.numEntries))
    name = (fileListInfo.pEntries + (signed long int)number)->name;

  return name;
}

// GetFileSizeAt
// file tightvnc-filetransfer/filelistinfo.h line 57
unsigned int GetFileSizeAt(struct _FileListInfo fileListInfo, signed int number)
{
  unsigned int size = (unsigned int)0;
  if(number >= 0 && !(number >= fileListInfo.numEntries))
    size = (fileListInfo.pEntries + (signed long int)number)->size;

  return size;
}

// GetFileUploadCompressedLevelErrMsg
// file tightvnc-filetransfer/filetransfermsg.h line 48
struct _FileTransferMsg GetFileUploadCompressedLevelErrMsg()
{
  char reason[51l] = { 'S', 'e', 'r', 'v', 'e', 'r', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'd', 'a', 't', 'a', ' ', 'c', 'o', 'm', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 'o', 'n', ' ', 'u', 'p', 'l', 'o', 'a', 'd', 0 };
  signed int reasonLen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  reasonLen = (signed int)return_value_strlen_1;
  struct _FileTransferMsg return_value_CreateFileUploadErrMsg_2;
  return_value_CreateFileUploadErrMsg_2=CreateFileUploadErrMsg(reason, (unsigned int)reasonLen);
  return return_value_CreateFileUploadErrMsg_2;
}

// GetFileUploadLengthErrResponseMsg
// file tightvnc-filetransfer/filetransfermsg.h line 47
struct _FileTransferMsg GetFileUploadLengthErrResponseMsg()
{
  char reason[42l] = { 'P', 'a', 't', 'h', ' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 's', ' ', 'P', 'A', 'T', 'H', '_', 'M', 'A', 'X', ' ', '(', '4', '0', '9', '6', ')', ' ', 'b', 'y', 't', 'e', 's', 0 };
  signed int reasonLen;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  reasonLen = (signed int)return_value_strlen_1;
  struct _FileTransferMsg return_value_CreateFileUploadErrMsg_2;
  return_value_CreateFileUploadErrMsg_2=CreateFileUploadErrMsg(reason, (unsigned int)reasonLen);
  return return_value_CreateFileUploadErrMsg_2;
}

// GetFtpRoot
// file tightvnc-filetransfer/handlefiletransferrequest.c line 235
char * GetFtpRoot()
{
  return ftproot;
}

// GetHomeDir
// file tightvnc-filetransfer/handlefiletransferrequest.c line 159
char * GetHomeDir(unsigned int uid)
{
  struct passwd *pwEnt = (struct passwd *)(void *)0;
  char *homedir = (char *)(void *)0;
  pwEnt=getpwuid(uid);
  if(pwEnt == ((struct passwd *)NULL))
    return (char *)(void *)0;

  else
  {
    if(!(pwEnt->pw_dir == ((char *)NULL)))
      homedir=strdup(pwEnt->pw_dir);

    return homedir;
  }
}

// GetSumOfFileNamesLength
// file tightvnc-filetransfer/filelistinfo.h line 59
unsigned int GetSumOfFileNamesLength(struct _FileListInfo fileListInfo)
{
  signed int i = 0;
  signed int sumLen = 0;
  i = 0;
  unsigned long int return_value_strlen_1;
  for( ; !(i >= fileListInfo.numEntries); i = i + 1)
  {
    return_value_strlen_1=strlen((fileListInfo.pEntries + (signed long int)i)->name);
    sumLen = sumLen + (signed int)return_value_strlen_1;
  }
  return (unsigned int)sumLen;
}

// HandleFileCreateDirRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 44
void HandleFileCreateDirRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int n = 0;
  char dirName[4096l];
  union _rfbClientToServerTightMsg msg;
  memset((void *)dirName, 0, (unsigned long int)4096);
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  if(cl == ((struct _rfbClientRec *)NULL))
    rfbLog("File [%s]: Method [%s]: Unexpected error: rfbClientPtr is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileCreateDirRequest");

  else
  {
    n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading FileCreateDirRequestMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileCreateDirRequest");

      rfbCloseClient(cl);
    }

    else
    {
      msg.fcdr.dNameLen = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fcdr.dNameLen & 0xff) << 8 | (signed int)msg.fcdr.dNameLen >> 8 & 0xff : (signed int)msg.fcdr.dNameLen);
      n=rfbReadExact(cl, dirName, (signed int)msg.fcdr.dNameLen);
      if(!(n >= 1))
      {
        if(!(n >= 0))
          rfbLog("File [%s]: Method [%s]: Error while reading FileUploadFailedMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileCreateDirRequest");

        rfbCloseClient(cl);
      }

      else
      {
        char *return_value_ConvertPath_1;
        return_value_ConvertPath_1=ConvertPath(dirName);
        if(return_value_ConvertPath_1 == ((char *)NULL))
          rfbLog("File [%s]: Method [%s]: Unexpected error: path is NULL\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileCreateDirRequest");

        else
          CreateDirectory(dirName);
      }
    }
  }
}

// HandleFileDownload
// file tightvnc-filetransfer/handlefiletransferrequest.c line 507
void HandleFileDownload(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  unsigned long int fileDownloadThread;
  struct _FileTransferMsg fileDownloadMsg;
  memset((void *)&fileDownloadMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  fileDownloadMsg=ChkFileDownloadErr(cl, rtcp);
  if(!(fileDownloadMsg.data == ((char *)NULL)) && !(fileDownloadMsg.length == 0u))
  {
    rfbWriteExact(cl, fileDownloadMsg.data, (signed int)fileDownloadMsg.length);
    FreeFileTransferMsg(fileDownloadMsg);
  }

  else
  {
    rtcp->rcft.rcfd.downloadInProgress = 0;
    rtcp->rcft.rcfd.downloadFD = -1;
    signed int return_value_pthread_create_1;
    return_value_pthread_create_1=pthread_create(&fileDownloadThread, (const union pthread_attr_t *)(void *)0, RunFileDownloadThread, (void *)cl);
    if(!(return_value_pthread_create_1 == 0))
    {
      struct _FileTransferMsg ftm;
      ftm=GetFileDownLoadErrMsg();
      rfbLog("File [%s]: Method [%s]: Download thread creation failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownload");
      if(!(ftm.data == ((char *)NULL)) && !(ftm.length == 0u))
      {
        rfbWriteExact(cl, ftm.data, (signed int)ftm.length);
        FreeFileTransferMsg(ftm);
      }

    }

  }
}

// HandleFileDownloadCancelRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 40
void HandleFileDownloadCancelRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int n = 0;
  char *reason = (char *)(void *)0;
  union _rfbClientToServerTightMsg msg;
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
  if(!(n >= 1))
  {
    if(!(n >= 0))
      rfbLog("File [%s]: Method [%s]: Error while reading FileDownloadCancelMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadCancelRequest");

    rfbCloseClient(cl);
  }

  else
  {
    msg.fdc.reasonLen = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fdc.reasonLen & 0xff) << 8 | (signed int)msg.fdc.reasonLen >> 8 & 0xff : (signed int)msg.fdc.reasonLen);
    if((signed int)msg.fdc.reasonLen == 0)
      rfbLog("File [%s]: Method [%s]: reason length received is Zero\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadCancelRequest");

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)((signed int)msg.fdc.reasonLen + 1), sizeof(char) /*1ul*/ );
      reason = (char *)return_value_calloc_1;
      if(reason == ((char *)NULL))
        rfbLog("File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadCancelRequest");

      else
      {
        n=rfbReadExact(cl, reason, (signed int)msg.fdc.reasonLen);
        if(!(n >= 1))
        {
          if(!(n >= 0))
            rfbLog("File [%s]: Method [%s]: Error while reading FileDownloadCancelMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadCancelRequest");

          rfbCloseClient(cl);
        }

        rfbLog("File [%s]: Method [%s]: File Download Cancel Request received: reason <%s>\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadCancelRequest", reason);
        pthread_mutex_lock(&fileDownloadMutex);
        CloseUndoneFileTransfer(cl, rtcp);
        pthread_mutex_unlock(&fileDownloadMutex);
        if(!(reason == ((char *)NULL)))
        {
          free((void *)reason);
          reason = (char *)(void *)0;
        }

      }
    }
  }
}

// HandleFileDownloadLengthError
// file tightvnc-filetransfer/handlefiletransferrequest.c line 413
void HandleFileDownloadLengthError(struct _rfbClientRec *cl, signed short int fNameSize)
{
  char *path = (char *)(void *)0;
  signed int n = 0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)fNameSize, sizeof(char) /*1ul*/ );
  path = (char *)return_value_calloc_1;
  if(path == ((char *)NULL))
    rfbLog("File [%s]: Method [%s]: Fatal Error: Alloc failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadLengthError");

  else
  {
    n=rfbReadExact(cl, path, (signed int)fNameSize);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading dir name\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadLengthError");

      rfbCloseClient(cl);
      if(!(path == ((char *)NULL)))
      {
        free((void *)path);
        path = (char *)(void *)0;
      }

    }

    else
    {
      if(!(path == ((char *)NULL)))
      {
        free((void *)path);
        path = (char *)(void *)0;
      }

      SendFileDownloadLengthErrMsg(cl);
    }
  }
}

// HandleFileDownloadRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 39
void HandleFileDownloadRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int n = 0;
  char path[4096l];
  union _rfbClientToServerTightMsg msg;
  memset((void *)path, 0, sizeof(char [4096l]) /*4096ul*/ );
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  if(cl == ((struct _rfbClientRec *)NULL))
    rfbLog("File [%s]: Method [%s]: Unexpected error:: rfbClientPtr is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadRequest");

  else
  {
    n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 8 - 1);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading dir name length\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadRequest");

      rfbCloseClient(cl);
    }

    else
    {
      msg.fdr.fNameSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fdr.fNameSize & 0xff) << 8 | (signed int)msg.fdr.fNameSize >> 8 & 0xff : (signed int)msg.fdr.fNameSize);
      msg.fdr.position = rfbEndianTest != 0 ? (msg.fdr.position & (unsigned int)0xff) << 8 | msg.fdr.position >> 8 & (unsigned int)0xff : msg.fdr.position;
      if((signed int)msg.fdr.fNameSize == 0 || (signed int)msg.fdr.fNameSize >= 4096)
      {
        rfbLog("File [%s]: Method [%s]: Error: path length is greater than PATH_MAX\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadRequest");
        HandleFileDownloadLengthError(cl, (signed short int)msg.fdr.fNameSize);
      }

      else
      {
        n=rfbReadExact(cl, rtcp->rcft.rcfd.fName, (signed int)msg.fdr.fNameSize);
        if(!(n >= 1))
        {
          if(!(n >= 0))
            rfbLog("File [%s]: Method [%s]: Error while reading dir name length\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadRequest");

          rfbCloseClient(cl);
        }

        else
        {
          rtcp->rcft.rcfd.fName[(signed long int)msg.fdr.fNameSize] = (char)0;
          char *return_value_ConvertPath_1;
          return_value_ConvertPath_1=ConvertPath(rtcp->rcft.rcfd.fName);
          if(return_value_ConvertPath_1 == ((char *)NULL))
          {
            rfbLog("File [%s]: Method [%s]: Unexpected error: path is NULL", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileDownloadRequest");
            SendFileDownloadLengthErrMsg(cl);
          }

          else
            HandleFileDownload(cl, rtcp);
        }
      }
    }
  }
}

// HandleFileListRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 38
void HandleFileListRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *data)
{
  union _rfbClientToServerTightMsg msg;
  signed int n = 0;
  char path[4096l];
  struct _FileTransferMsg fileListMsg;
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  memset((void *)path, 0, (unsigned long int)4096);
  memset((void *)&fileListMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  if(cl == ((struct _rfbClientRec *)NULL))
    rfbLog("File [%s]: Method [%s]: Unexpected error: rfbClientPtr is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileListRequest");

  else
  {
    n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Socket error while reading dir name length\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileListRequest");

      rfbCloseClient(cl);
    }

    else
    {
      msg.flr.dirNameSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.flr.dirNameSize & 0xff) << 8 | (signed int)msg.flr.dirNameSize >> 8 & 0xff : (signed int)msg.flr.dirNameSize);
      if((signed int)msg.flr.dirNameSize == 0 || (signed int)msg.flr.dirNameSize >= 4096)
        rfbLog("File [%s]: Method [%s]: Unexpected error:: path length is greater that PATH_MAX\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileListRequest");

      else
      {
        n=rfbReadExact(cl, path, (signed int)msg.flr.dirNameSize);
        if(!(n >= 1))
        {
          if(!(n >= 0))
            rfbLog("File [%s]: Method [%s]: Socket error while reading dir name\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileListRequest");

          rfbCloseClient(cl);
        }

        else
        {
          char *return_value_ConvertPath_1;
          return_value_ConvertPath_1=ConvertPath(path);
          if(return_value_ConvertPath_1 == ((char *)NULL))
            rfbLog("File [%s]: Method [%s]: Unexpected error: path is NULL", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileListRequest");

          else
          {
            fileListMsg=GetFileListResponseMsg(path, (char)msg.flr.flags);
            if(fileListMsg.data == ((char *)NULL) || fileListMsg.length == 0u)
              rfbLog("File [%s]: Method [%s]: Unexpected error:: Data to be sent is of Zero length\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileListRequest");

            else
            {
              rfbWriteExact(cl, fileListMsg.data, (signed int)fileListMsg.length);
              FreeFileTransferMsg(fileListMsg);
            }
          }
        }
      }
    }
  }
}

// HandleFileUpload
// file tightvnc-filetransfer/handlefiletransferrequest.c line 737
void HandleFileUpload(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  struct _FileTransferMsg fileUploadErrMsg;
  memset((void *)&fileUploadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  rtcp->rcft.rcfu.uploadInProgress = 0;
  rtcp->rcft.rcfu.uploadFD = -1;
  fileUploadErrMsg=ChkFileUploadErr(cl, rtcp);
  if(!(fileUploadErrMsg.data == ((char *)NULL)) && !(fileUploadErrMsg.length == 0u))
  {
    rfbWriteExact(cl, fileUploadErrMsg.data, (signed int)fileUploadErrMsg.length);
    FreeFileTransferMsg(fileUploadErrMsg);
  }

}

// HandleFileUploadDataRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 42
void HandleFileUploadDataRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int n = 0;
  char *pBuf = (char *)(void *)0;
  union _rfbClientToServerTightMsg msg;
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  if(cl == ((struct _rfbClientRec *)NULL))
    rfbLog("File [%s]: Method [%s]: Unexpected error: rfbClientPtr is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadDataRequest");

  else
  {
    n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 6 - 1);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading FileUploadRequestMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadDataRequest");

      rfbCloseClient(cl);
    }

    else
    {
      msg.fud.realSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fud.realSize & 0xff) << 8 | (signed int)msg.fud.realSize >> 8 & 0xff : (signed int)msg.fud.realSize);
      msg.fud.compressedSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fud.compressedSize & 0xff) << 8 | (signed int)msg.fud.compressedSize >> 8 & 0xff : (signed int)msg.fud.compressedSize);
      if((signed int)msg.fud.compressedSize == 0 && (signed int)msg.fud.realSize == 0)
      {
        n=rfbReadExact(cl, (char *)&rtcp->rcft.rcfu.mTime, (signed int)sizeof(unsigned long int) /*8ul*/ );
        if(!(n >= 1))
        {
          if(!(n >= 0))
            rfbLog("File [%s]: Method [%s]: Error while reading FileUploadRequestMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadDataRequest");

          rfbCloseClient(cl);
          goto __CPROVER_DUMP_L15;
        }

        FileUpdateComplete(cl, rtcp);
      }

      else
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc((unsigned long int)msg.fud.compressedSize, sizeof(char) /*1ul*/ );
        pBuf = (char *)return_value_calloc_1;
        if(pBuf == ((char *)NULL))
          rfbLog("File [%s]: Method [%s]: Memory alloc failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadDataRequest");

        else
        {
          n=rfbReadExact(cl, pBuf, (signed int)msg.fud.compressedSize);
          if(!(n >= 1))
          {
            if(!(n >= 0))
              rfbLog("File [%s]: Method [%s]: Error while reading FileUploadRequestMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadDataRequest");

            rfbCloseClient(cl);
            if(!(pBuf == ((char *)NULL)))
            {
              free((void *)pBuf);
              pBuf = (char *)(void *)0;
            }

          }

          else
          {
            if(!((signed int)msg.fud.compressedLevel == 0))
            {
              struct _FileTransferMsg ftm;
              memset((void *)&ftm, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
              ftm=GetFileUploadCompressedLevelErrMsg();
              if(!(ftm.data == ((char *)NULL)) && !(ftm.length == 0u))
              {
                rfbWriteExact(cl, ftm.data, (signed int)ftm.length);
                FreeFileTransferMsg(ftm);
              }

              CloseUndoneFileTransfer(cl, rtcp);
              if(!(pBuf == ((char *)NULL)))
              {
                free((void *)pBuf);
                pBuf = (char *)(void *)0;
              }

              goto __CPROVER_DUMP_L15;
            }

            rtcp->rcft.rcfu.fSize = (unsigned long int)msg.fud.compressedSize;
            HandleFileUploadWrite(cl, rtcp, pBuf);
            if(!(pBuf == ((char *)NULL)))
            {
              free((void *)pBuf);
              pBuf = (char *)(void *)0;
            }

          }
        }
      }
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// HandleFileUploadFailedRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 43
void HandleFileUploadFailedRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int n = 0;
  char *reason = (char *)(void *)0;
  union _rfbClientToServerTightMsg msg;
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  if(cl == ((struct _rfbClientRec *)NULL))
    rfbLog("File [%s]: Method [%s]: Unexpected error: rfbClientPtr is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadFailedRequest");

  else
  {
    n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading FileUploadFailedMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadFailedRequest");

      rfbCloseClient(cl);
    }

    else
    {
      msg.fuf.reasonLen = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fuf.reasonLen & 0xff) << 8 | (signed int)msg.fuf.reasonLen >> 8 & 0xff : (signed int)msg.fuf.reasonLen);
      if((signed int)msg.fuf.reasonLen == 0)
        rfbLog("File [%s]: Method [%s]: reason length received is Zero\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadFailedRequest");

      else
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc((unsigned long int)((signed int)msg.fuf.reasonLen + 1), sizeof(char) /*1ul*/ );
        reason = (char *)return_value_calloc_1;
        if(reason == ((char *)NULL))
          rfbLog("File [%s]: Method [%s]: Memory alloc failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadFailedRequest");

        else
        {
          n=rfbReadExact(cl, reason, (signed int)msg.fuf.reasonLen);
          if(!(n >= 1))
          {
            if(!(n >= 0))
              rfbLog("File [%s]: Method [%s]: Error while reading FileUploadFailedMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadFailedRequest");

            rfbCloseClient(cl);
            if(!(reason == ((char *)NULL)))
            {
              free((void *)reason);
              reason = (char *)(void *)0;
            }

          }

          else
          {
            rfbLog("File [%s]: Method [%s]: File Upload Failed Request received: reason <%s>\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadFailedRequest", reason);
            CloseUndoneFileTransfer(cl, rtcp);
            if(!(reason == ((char *)NULL)))
            {
              free((void *)reason);
              reason = (char *)(void *)0;
            }

          }
        }
      }
    }
  }
}

// HandleFileUploadLengthError
// file tightvnc-filetransfer/handlefiletransferrequest.c line 680
void HandleFileUploadLengthError(struct _rfbClientRec *cl, signed short int fNameSize)
{
  char *path = (char *)(void *)0;
  signed int n = 0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)fNameSize, sizeof(char) /*1ul*/ );
  path = (char *)return_value_calloc_1;
  if(path == ((char *)NULL))
    rfbLog("File [%s]: Method [%s]: Fatal Error: Alloc failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadLengthError");

  else
  {
    n=rfbReadExact(cl, path, (signed int)fNameSize);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading dir name\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadLengthError");

      rfbCloseClient(cl);
      if(!(path == ((char *)NULL)))
      {
        free((void *)path);
        path = (char *)(void *)0;
      }

    }

    else
    {
      rfbLog("File [%s]: Method [%s]: File Upload Length Error occuredfile path requested is <%s>\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadLengthError", path);
      if(!(path == ((char *)NULL)))
      {
        free((void *)path);
        path = (char *)(void *)0;
      }

      SendFileUploadLengthErrMsg(cl);
    }
  }
}

// HandleFileUploadRequest
// file tightvnc-filetransfer/handlefiletransferrequest.h line 41
void HandleFileUploadRequest(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp)
{
  signed int n = 0;
  char path[4096l];
  union _rfbClientToServerTightMsg msg;
  memset((void *)path, 0, (unsigned long int)4096);
  memset((void *)&msg, 0, sizeof(union _rfbClientToServerTightMsg) /*8ul*/ );
  if(cl == ((struct _rfbClientRec *)NULL))
    rfbLog("File [%s]: Method [%s]: Unexpected error: rfbClientPtr is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadRequest");

  else
  {
    n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 8 - 1);
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLog("File [%s]: Method [%s]: Error while reading FileUploadRequestMsg\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadRequest");

      rfbCloseClient(cl);
    }

    else
    {
      msg.fupr.fNameSize = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.fupr.fNameSize & 0xff) << 8 | (signed int)msg.fupr.fNameSize >> 8 & 0xff : (signed int)msg.fupr.fNameSize);
      msg.fupr.position = rfbEndianTest != 0 ? (msg.fupr.position & (unsigned int)0xff) << 8 | msg.fupr.position >> 8 & (unsigned int)0xff : msg.fupr.position;
      if((signed int)msg.fupr.fNameSize == 0 || (signed int)msg.fupr.fNameSize >= 4096)
      {
        rfbLog("File [%s]: Method [%s]: error: path length is greater than PATH_MAX\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadRequest");
        HandleFileUploadLengthError(cl, (signed short int)msg.fupr.fNameSize);
      }

      else
      {
        n=rfbReadExact(cl, rtcp->rcft.rcfu.fName, (signed int)msg.fupr.fNameSize);
        if(!(n >= 1))
        {
          if(!(n >= 0))
            rfbLog("File [%s]: Method [%s]: Error while reading FileUploadRequestMsg\ntightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadRequest");

          rfbCloseClient(cl);
        }

        else
        {
          rtcp->rcft.rcfu.fName[(signed long int)msg.fupr.fNameSize] = (char)0;
          char *return_value_ConvertPath_1;
          return_value_ConvertPath_1=ConvertPath(rtcp->rcft.rcfu.fName);
          if(return_value_ConvertPath_1 == ((char *)NULL))
          {
            rfbLog("File [%s]: Method [%s]: Unexpected error: path is NULL\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"HandleFileUploadRequest");
            SendFileUploadLengthErrMsg(cl);
          }

          else
            HandleFileUpload(cl, rtcp);
        }
      }
    }
  }
}

// HandleFileUploadWrite
// file tightvnc-filetransfer/handlefiletransferrequest.c line 858
void HandleFileUploadWrite(struct _rfbClientRec *cl, struct _rfbTightClientRec *rtcp, char *pBuf)
{
  struct _FileTransferMsg ftm;
  memset((void *)&ftm, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  ftm=ChkFileUploadWriteErr(cl, rtcp, pBuf);
  if(!(ftm.data == ((char *)NULL)) && !(ftm.length == 0u))
  {
    rfbWriteExact(cl, ftm.data, (signed int)ftm.length);
    FreeFileTransferMsg(ftm);
  }

}

// Harr
// file ../common/zywrletemplate.c line 313
static inline void Harr(signed char *pX0, signed char *pX1)
{
  signed int X0 = (signed int)*pX0;
  signed int X1 = (signed int)*pX1;
  signed int orgX0 = X0;
  signed int orgX1 = X1;
  if(!(((X0 ^ X1) & 0x80) == 0))
  {
    X1 = X1 + X0;
    if(((X1 ^ orgX1) & 0x80) == 0)
      X0 = X0 - X1;

  }

  else
  {
    X0 = X0 - X1;
    if(((X0 ^ orgX0) & 0x80) == 0)
      X1 = X1 + X0;

  }
  *pX0 = (signed char)X1;
  *pX1 = (signed char)X0;
}

// InitFileTransfer
// file tightvnc-filetransfer/handlefiletransferrequest.h line 32
void InitFileTransfer()
{
  char *userHome = (char *)(void *)0;
  unsigned int uid;
  uid=geteuid();
  unsigned long int return_value_strlen_1;
  if(fileTransferInitted == 0)
  {
    rfbLog("tightvnc-filetransfer/InitFileTransfer\n");
    memset((void *)ftproot, 0, sizeof(char [4096l]) /*4096ul*/ );
    userHome=GetHomeDir(uid);
    if(!(userHome == ((char *)NULL)))
    {
      return_value_strlen_1=strlen(userHome);
      if(!(return_value_strlen_1 == 0ul))
      {
        SetFtpRoot(userHome);
        FreeHomeDir(userHome);
      }

    }

    fileTransferEnabled = (signed char)-1;
    fileTransferInitted = (signed char)-1;
  }

}

// IsFileTransferEnabled
// file tightvnc-filetransfer/handlefiletransferrequest.h line 35
signed char IsFileTransferEnabled()
{
  return fileTransferEnabled;
}

// Pack24
// file tight.c line 1426
static void Pack24(struct _rfbClientRec *cl, char *buf, struct anonymous_7 *fmt, signed int count)
{
  unsigned int *buf32;
  unsigned int pix;
  signed int r_shift;
  signed int g_shift;
  signed int b_shift;
  buf32 = (unsigned int *)buf;
  if((cl->screen->serverFormat.bigEndian == 0) == (fmt->bigEndian == 0))
  {
    r_shift = (signed int)fmt->redShift;
    g_shift = (signed int)fmt->greenShift;
    b_shift = (signed int)fmt->blueShift;
  }

  else
  {
    r_shift = 24 - (signed int)fmt->redShift;
    g_shift = 24 - (signed int)fmt->greenShift;
    b_shift = 24 - (signed int)fmt->blueShift;
  }
  signed int tmp_post_1;
  unsigned int *tmp_post_2;
  char *tmp_post_3;
  char *tmp_post_4;
  char *tmp_post_5;
  do
  {
    tmp_post_1 = count;
    count = count - 1;
    if(tmp_post_1 == 0)
      break;

    tmp_post_2 = buf32;
    buf32 = buf32 + 1l;
    pix = *tmp_post_2;
    tmp_post_3 = buf;
    buf = buf + 1l;
    *tmp_post_3 = (char)(pix >> r_shift);
    tmp_post_4 = buf;
    buf = buf + 1l;
    *tmp_post_4 = (char)(pix >> g_shift);
    tmp_post_5 = buf;
    buf = buf + 1l;
    *tmp_post_5 = (char)(pix >> b_shift);
  }
  while((_Bool)1);
}

// PaletteInsert
// file tight.c line 1355
static signed int PaletteInsert(unsigned int rgb, signed int numPixels, signed int bpp)
{
  struct COLOR_LIST_s *pnode;
  struct COLOR_LIST_s *prev_pnode = (struct COLOR_LIST_s *)(void *)0;
  signed int hash_key;
  signed int idx;
  signed int new_idx;
  signed int count;
  hash_key = bpp == 16 ? (signed int)((rgb >> 8) + rgb & (unsigned int)0xFF) : (signed int)((rgb >> 16) + (rgb >> 8) & (unsigned int)0xFF);
  pnode = palette.hash[(signed long int)hash_key];
  _Bool tmp_if_expr_1;
  for( ; !(pnode == ((struct COLOR_LIST_s *)NULL)); pnode = pnode->next)
  {
    if(pnode->rgb == rgb)
    {
      idx = pnode->idx;
      new_idx = idx;
      count = palette.entry[(signed long int)idx].numPixels + numPixels;
      if(!(new_idx == 0))
      {
        if(!(palette.entry[(signed long int)(new_idx + -1)].numPixels >= count))
        {
          do
          {
            palette.entry[(signed long int)new_idx] = palette.entry[(signed long int)(new_idx - 1)];
            palette.entry[(signed long int)new_idx].listNode->idx = new_idx;
            new_idx = new_idx - 1;
            if(!(new_idx == 0))
              tmp_if_expr_1 = palette.entry[(signed long int)(new_idx - 1)].numPixels < count ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
          }
          while(tmp_if_expr_1);
          palette.entry[(signed long int)new_idx].listNode = pnode;
          pnode->idx = new_idx;
        }

      }

      palette.entry[(signed long int)new_idx].numPixels = count;
      return paletteNumColors;
    }

    prev_pnode = pnode;
  }
  _Bool tmp_if_expr_2;
  if(paletteNumColors == 256 || paletteNumColors == paletteMaxColors)
  {
    paletteNumColors = 0;
    return 0;
  }

  else
  {
    idx = paletteNumColors;
    do
    {
      if(idx >= 1)
        tmp_if_expr_2 = palette.entry[(signed long int)(idx - 1)].numPixels < numPixels ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      palette.entry[(signed long int)idx] = palette.entry[(signed long int)(idx - 1)];
      palette.entry[(signed long int)idx].listNode->idx = idx;
      idx = idx - 1;
    }
    while((_Bool)1);
    pnode = &palette.list[(signed long int)paletteNumColors];
    if(!(prev_pnode == ((struct COLOR_LIST_s *)NULL)))
      prev_pnode->next = pnode;

    else
      palette.hash[(signed long int)hash_key] = pnode;
    pnode->next = (struct COLOR_LIST_s *)(void *)0;
    pnode->idx = idx;
    pnode->rgb = rgb;
    palette.entry[(signed long int)idx].listNode = pnode;
    palette.entry[(signed long int)idx].numPixels = numPixels;
    paletteNumColors = paletteNumColors + 1;
    return paletteNumColors;
  }
}

// PaletteReset
// file tight.c line 1347
static void PaletteReset(void)
{
  paletteNumColors = 0;
  memset((void *)palette.hash, 0, (unsigned long int)256 * sizeof(struct COLOR_LIST_s *) /*8ul*/ );
}

// PrintPixelFormat
// file translate.c line 460
static void PrintPixelFormat(struct anonymous_7 *pf)
{
  char *tmp_if_expr_1;
  if((signed int)pf->bitsPerPixel == 1)
    rfbLog("  1 bpp, %s sig bit in each byte is leftmost on the screen.\n", pf->bigEndian != 0 ? "most" : "least");

  else
  {
    if((signed int)pf->bitsPerPixel == 8)
      tmp_if_expr_1 = "";

    else
      tmp_if_expr_1 = pf->bigEndian != 0 ? ", big endian" : ", little endian";
    rfbLog("  %d bpp, depth %d%s\n", pf->bitsPerPixel, pf->depth, tmp_if_expr_1);
    if(!(pf->trueColour == 0))
      rfbLog("  true colour: max r %d g %d b %d, shift r %d g %d b %d\n", pf->redMax, pf->greenMax, pf->blueMax, pf->redShift, pf->greenShift, pf->blueShift);

    else
      rfbLog("  uses a colour map (not true colour).\n");
  }
}

// RunFileDownloadThread
// file tightvnc-filetransfer/handlefiletransferrequest.c line 471
void * RunFileDownloadThread(void *client)
{
  struct _rfbClientRec *RunFileDownloadThread__1__cl = (struct _rfbClientRec *)client;
  struct _rfbTightClientRec *rtcp;
  rtcp=rfbGetTightClientData(RunFileDownloadThread__1__cl);
  struct _FileTransferMsg fileDownloadMsg;
  if(rtcp == ((struct _rfbTightClientRec *)NULL))
    return (void *)0;

  else
  {
    memset((void *)&fileDownloadMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
    do
    {
      pthread_mutex_lock(&fileDownloadMutex);
      fileDownloadMsg=GetFileDownloadResponseMsgInBlocks(RunFileDownloadThread__1__cl, rtcp);
      pthread_mutex_unlock(&fileDownloadMutex);
      if(!(fileDownloadMsg.data == ((char *)NULL)) && !(fileDownloadMsg.length == 0u))
      {
        signed int return_value_rfbWriteExact_1;
        return_value_rfbWriteExact_1=rfbWriteExact(RunFileDownloadThread__1__cl, fileDownloadMsg.data, (signed int)fileDownloadMsg.length);
        if(!(return_value_rfbWriteExact_1 >= 0))
        {
          rfbLog("File [%s]: Method [%s]: Error while writing to socket \n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"RunFileDownloadThread");
          if(!(RunFileDownloadThread__1__cl == ((struct _rfbClientRec *)NULL)))
          {
            rfbCloseClient(RunFileDownloadThread__1__cl);
            CloseUndoneFileTransfer(RunFileDownloadThread__1__cl, rtcp);
          }

          FreeFileTransferMsg(fileDownloadMsg);
          return (void *)0;
        }

        FreeFileTransferMsg(fileDownloadMsg);
      }

    }
    while(rtcp->rcft.rcfd.downloadInProgress == -1);
    return (void *)0;
  }
}

// ScaleX
// file ./scale.h line 2
signed int ScaleX(struct _rfbScreenInfo *from, struct _rfbScreenInfo *to, signed int x)
{
  if(from == ((struct _rfbScreenInfo *)NULL) || from == to || to == ((struct _rfbScreenInfo *)NULL))
    return x;

  else
    return (signed int)(((double)x / (double)from->width) * (double)to->width);
}

// ScaleY
// file ./scale.h line 3
signed int ScaleY(struct _rfbScreenInfo *from, struct _rfbScreenInfo *to, signed int y)
{
  if(from == ((struct _rfbScreenInfo *)NULL) || from == to || to == ((struct _rfbScreenInfo *)NULL))
    return y;

  else
    return (signed int)(((double)y / (double)from->height) * (double)to->height);
}

// SendCompressedData
// file tight.c line 1086
static signed char SendCompressedData(struct _rfbClientRec *cl, char *buf, signed int compressedLen)
{
  signed int i;
  signed int portionLen;
  signed int tmp_post_1 = cl->ublen;
  cl->ublen = cl->ublen + 1;
  cl->updateBuf[(signed long int)tmp_post_1] = (char)(compressedLen & 0x7F);
  rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 1);
  signed int tmp_post_2;
  signed int tmp_post_3;
  if(compressedLen >= 128)
  {
    cl->updateBuf[(signed long int)(cl->ublen - 1)] = cl->updateBuf[(signed long int)(cl->ublen - 1)] | (char)0x80;
    tmp_post_2 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_2] = (char)(compressedLen >> 7 & 0x7F);
    rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 1);
    if(compressedLen >= 16384)
    {
      cl->updateBuf[(signed long int)(cl->ublen - 1)] = cl->updateBuf[(signed long int)(cl->ublen - 1)] | (char)0x80;
      tmp_post_3 = cl->ublen;
      cl->ublen = cl->ublen + 1;
      cl->updateBuf[(signed long int)tmp_post_3] = (char)(compressedLen >> 14 & 0xFF);
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 1);
    }

  }

  portionLen = 30000;
  i = 0;
  for( ; !(i >= compressedLen); i = i + portionLen)
  {
    if(!(compressedLen >= i + portionLen))
      portionLen = compressedLen - i;

    if(cl->ublen + portionLen >= 30001)
    {
      signed char return_value_rfbSendUpdateBuf_4;
      return_value_rfbSendUpdateBuf_4=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_4 == 0)
        return (signed char)0;

    }

    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)&buf[(signed long int)i], (unsigned long int)portionLen);
    cl->ublen = cl->ublen + portionLen;
  }
  rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, compressedLen);
  return (signed char)-1;
}

// SendFileDownloadLengthErrMsg
// file tightvnc-filetransfer/handlefiletransferrequest.c line 449
void SendFileDownloadLengthErrMsg(struct _rfbClientRec *cl)
{
  struct _FileTransferMsg fileDownloadErrMsg;
  memset((void *)&fileDownloadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  fileDownloadErrMsg=GetFileDownloadLengthErrResponseMsg();
  if(fileDownloadErrMsg.data == ((char *)NULL) || fileDownloadErrMsg.length == 0u)
    rfbLog("File [%s]: Method [%s]: Unexpected error: fileDownloadErrMsg is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"SendFileDownloadLengthErrMsg");

  else
  {
    rfbWriteExact(cl, fileDownloadErrMsg.data, (signed int)fileDownloadErrMsg.length);
    FreeFileTransferMsg(fileDownloadErrMsg);
  }
}

// SendFileUploadLengthErrMsg
// file tightvnc-filetransfer/handlefiletransferrequest.c line 718
void SendFileUploadLengthErrMsg(struct _rfbClientRec *cl)
{
  struct _FileTransferMsg fileUploadErrMsg;
  memset((void *)&fileUploadErrMsg, 0, sizeof(struct _FileTransferMsg) /*16ul*/ );
  fileUploadErrMsg=GetFileUploadLengthErrResponseMsg();
  if(fileUploadErrMsg.data == ((char *)NULL) || fileUploadErrMsg.length == 0u)
    rfbLog("File [%s]: Method [%s]: Unexpected error: fileUploadErrMsg is null\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"SendFileUploadLengthErrMsg");

  else
  {
    rfbWriteExact(cl, fileUploadErrMsg.data, (signed int)fileUploadErrMsg.length);
    FreeFileTransferMsg(fileUploadErrMsg);
  }
}

// SendFullColorRect
// file tight.c line 987
static signed char SendFullColorRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int streamId = 0;
  signed int len;
  if(1 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  _Bool tmp_if_expr_4;
  if(tightConf[(signed long int)compressLevel].rawZlibLevel == 0)
    tmp_if_expr_4 = cl->tightEncoding != 0xFFFFFEFC ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  if(tmp_if_expr_4)
  {
    tmp_post_2 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_2] = (char)(0x0A << 4);
  }

  else
  {
    tmp_post_3 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_3] = (char)0x00;
  }
  rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 1);
  if(!(usePixelFormat24 == 0))
  {
    Pack24(cl, tightBeforeBuf, &cl->format, w * h);
    len = 3;
  }

  else
    len = (signed int)cl->format.bitsPerPixel / 8;
  signed char return_value_CompressData_5;
  return_value_CompressData_5=CompressData(cl, streamId, w * h * len, tightConf[(signed long int)compressLevel].rawZlibLevel, 0);
  return return_value_CompressData_5;
}

// SendIndexedRect
// file tight.c line 908
static signed char SendIndexedRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int streamId = 2;
  signed int i;
  signed int entryLen;
  if((paletteNumColors * (signed int)cl->format.bitsPerPixel) / 8 + 6 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  _Bool tmp_if_expr_4;
  if(tightConf[(signed long int)compressLevel].idxZlibLevel == 0)
    tmp_if_expr_4 = cl->tightEncoding != 0xFFFFFEFC ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  if(tmp_if_expr_4)
  {
    tmp_post_2 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_2] = (char)((0x0A | 0x04) << 4);
  }

  else
  {
    tmp_post_3 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_3] = (char)((streamId | 0x04) << 4);
  }
  signed int tmp_post_5 = cl->ublen;
  cl->ublen = cl->ublen + 1;
  cl->updateBuf[(signed long int)tmp_post_5] = (char)0x01;
  signed int tmp_post_6 = cl->ublen;
  cl->ublen = cl->ublen + 1;
  cl->updateBuf[(signed long int)tmp_post_6] = (char)(paletteNumColors - 1);
  switch((signed int)cl->format.bitsPerPixel)
  {
    case 32:
    {
      EncodeIndexedRect32((unsigned char *)tightBeforeBuf, w * h);
      i = 0;
      for( ; !(i >= paletteNumColors); i = i + 1)
        ((unsigned int *)tightAfterBuf)[(signed long int)i] = palette.entry[(signed long int)i].listNode->rgb;
      if(!(usePixelFormat24 == 0))
      {
        Pack24(cl, tightAfterBuf, &cl->format, paletteNumColors);
        entryLen = 3;
      }

      else
        entryLen = 4;
      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)tightAfterBuf, (unsigned long int)(paletteNumColors * entryLen));
      cl->ublen = cl->ublen + paletteNumColors * entryLen;
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 3 + paletteNumColors * entryLen);
      break;
    }
    case 16:
    {
      EncodeIndexedRect16((unsigned char *)tightBeforeBuf, w * h);
      i = 0;
      for( ; !(i >= paletteNumColors); i = i + 1)
        ((unsigned short int *)tightAfterBuf)[(signed long int)i] = (unsigned short int)palette.entry[(signed long int)i].listNode->rgb;
      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)tightAfterBuf, (unsigned long int)(paletteNumColors * 2));
      cl->ublen = cl->ublen + paletteNumColors * 2;
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 3 + paletteNumColors * 2);
      break;
    }
    default:
      return (signed char)0;
  }
  signed char return_value_CompressData_7;
  return_value_CompressData_7=CompressData(cl, streamId, w * h, tightConf[(signed long int)compressLevel].idxZlibLevel, 0);
  return return_value_CompressData_7;
}

// SendJpegRect
// file tight.c line 1555
static signed char SendJpegRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h, signed int quality)
{
  unsigned char *srcbuf;
  signed int ps = (signed int)cl->screen->serverFormat.bitsPerPixel / 8;
  signed int subsamp = subsampLevel2tjsubsamp[(signed long int)subsampLevel];
  unsigned long int size = (unsigned long int)0;
  signed int flags = 0;
  signed int pitch;
  unsigned char *tmpbuf = (unsigned char *)(void *)0;
  signed char return_value_SendFullColorRect_1;
  unsigned long int return_value_TJBUFSIZE_3;
  void *return_value_malloc_4;
  unsigned long int return_value_TJBUFSIZE_5;
  void *return_value_realloc_6;
  unsigned short int *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  signed int tmp_post_17;
  if((signed int)cl->screen->serverFormat.bitsPerPixel == 8)
  {
    return_value_SendFullColorRect_1=SendFullColorRect(cl, x, y, w, h);
    return return_value_SendFullColorRect_1;
  }

  else
    if(!(ps >= 2))
    {
      rfbLog("Error: JPEG requires 16-bit, 24-bit, or 32-bit pixel format.\n");
      return (signed char)0;
    }

    else
    {
      if(j == NULL)
      {
        j=tjInitCompress();
        if(j == NULL)
        {
          char *return_value_tjGetErrorStr_2;
          return_value_tjGetErrorStr_2=tjGetErrorStr();
          rfbLog("JPEG Error: %s\n", return_value_tjGetErrorStr_2);
          return (signed char)0;
        }

      }

      unsigned long int return_value_TJBUFSIZE_8;
      return_value_TJBUFSIZE_8=TJBUFSIZE(w, h);
      if(!((unsigned long int)tightAfterBufSize >= return_value_TJBUFSIZE_8))
      {
        if(tightAfterBuf == ((char *)NULL))
        {
          return_value_TJBUFSIZE_3=TJBUFSIZE(w, h);
          return_value_malloc_4=malloc(return_value_TJBUFSIZE_3);
          tightAfterBuf = (char *)return_value_malloc_4;
        }

        else
        {
          return_value_TJBUFSIZE_5=TJBUFSIZE(w, h);
          return_value_realloc_6=realloc((void *)tightAfterBuf, return_value_TJBUFSIZE_5);
          tightAfterBuf = (char *)return_value_realloc_6;
        }
        if(tightAfterBuf == ((char *)NULL))
        {
          rfbLog("Memory allocation failure!\n");
          return (signed char)0;
        }

        unsigned long int return_value_TJBUFSIZE_7;
        return_value_TJBUFSIZE_7=TJBUFSIZE(w, h);
        tightAfterBufSize = (signed int)return_value_TJBUFSIZE_7;
      }

      if(ps == 2)
      {
        unsigned short int *srcptr;
        unsigned short int pix;
        unsigned char *dst;
        signed int inRed;
        signed int inGreen;
        signed int inBlue;
        signed int i;
        signed int SendJpegRect__1__4__j;
        void *return_value_malloc_9;
        return_value_malloc_9=malloc((unsigned long int)(w * h * 3));
        tmpbuf = (unsigned char *)return_value_malloc_9;
        if(tmpbuf == ((unsigned char *)NULL))
          rfbLog("Memory allocation failure!\n");

        srcptr = (unsigned short int *)&cl->scaledScreen->frameBuffer[(signed long int)(y * cl->scaledScreen->paddedWidthInBytes + x * ps)];
        dst = tmpbuf;
        SendJpegRect__1__4__j = 0;
        for( ; !(SendJpegRect__1__4__j >= h); SendJpegRect__1__4__j = SendJpegRect__1__4__j + 1)
        {
          unsigned short int *srcptr2 = srcptr;
          unsigned char *dst2 = dst;
          i = 0;
          for( ; !(i >= w); i = i + 1)
          {
            tmp_post_10 = srcptr2;
            srcptr2 = srcptr2 + 1l;
            pix = *tmp_post_10;
            inRed = (signed int)((signed int)pix >> (signed int)cl->screen->serverFormat.redShift & (signed int)cl->screen->serverFormat.redMax);
            inGreen = (signed int)((signed int)pix >> (signed int)cl->screen->serverFormat.greenShift & (signed int)cl->screen->serverFormat.greenMax);
            inBlue = (signed int)((signed int)pix >> (signed int)cl->screen->serverFormat.blueShift & (signed int)cl->screen->serverFormat.blueMax);
            tmp_post_11 = dst2;
            dst2 = dst2 + 1l;
            *tmp_post_11 = (unsigned char)((inRed * 255 + (signed int)cl->screen->serverFormat.redMax / 2) / (signed int)cl->screen->serverFormat.redMax);
            tmp_post_12 = dst2;
            dst2 = dst2 + 1l;
            *tmp_post_12 = (unsigned char)((inGreen * 255 + (signed int)cl->screen->serverFormat.greenMax / 2) / (signed int)cl->screen->serverFormat.greenMax);
            tmp_post_13 = dst2;
            dst2 = dst2 + 1l;
            *tmp_post_13 = (unsigned char)((inBlue * 255 + (signed int)cl->screen->serverFormat.blueMax / 2) / (signed int)cl->screen->serverFormat.blueMax);
          }
          srcptr = srcptr + (signed long int)(cl->scaledScreen->paddedWidthInBytes / ps);
          dst = dst + (signed long int)(w * 3);
        }
        srcbuf = tmpbuf;
        pitch = w * 3;
        ps = 3;
      }

      else
      {
        if(!(cl->screen->serverFormat.bigEndian == 0))
        {
          if(ps == 4)
            flags = flags | 64;

        }

        if((signed int)cl->screen->serverFormat.redShift == 16)
        {
          if((signed int)cl->screen->serverFormat.blueShift == 0)
            flags = flags | 1;

        }

        if(!(cl->screen->serverFormat.bigEndian == 0))
          flags = flags ^ 1;

        pitch = cl->scaledScreen->paddedWidthInBytes;
        srcbuf = (unsigned char *)&cl->scaledScreen->frameBuffer[(signed long int)(y * pitch + x * ps)];
      }
      signed int return_value_tjCompress_15;
      return_value_tjCompress_15=tjCompress(j, srcbuf, w, pitch, h, ps, (unsigned char *)tightAfterBuf, &size, subsamp, quality, flags);
      if(return_value_tjCompress_15 == -1)
      {
        char *return_value_tjGetErrorStr_14;
        return_value_tjGetErrorStr_14=tjGetErrorStr();
        rfbLog("JPEG Error: %s\n", return_value_tjGetErrorStr_14);
        if(!(tmpbuf == ((unsigned char *)NULL)))
        {
          free((void *)tmpbuf);
          tmpbuf = (unsigned char *)(void *)0;
        }

        return (signed char)0;
      }

      if(!(tmpbuf == ((unsigned char *)NULL)))
      {
        free((void *)tmpbuf);
        tmpbuf = (unsigned char *)(void *)0;
      }

      if(1 + cl->ublen >= 30001)
      {
        signed char return_value_rfbSendUpdateBuf_16;
        return_value_rfbSendUpdateBuf_16=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_16 == 0)
          return (signed char)0;

      }

      tmp_post_17 = cl->ublen;
      cl->ublen = cl->ublen + 1;
      cl->updateBuf[(signed long int)tmp_post_17] = (char)(0x09 << 4);
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 1);
      signed char return_value_SendCompressedData_18;
      return_value_SendCompressedData_18=SendCompressedData(cl, tightAfterBuf, (signed int)size);
      return return_value_SendCompressedData_18;
    }
}

// SendMonoRect
// file tight.c line 828
static signed char SendMonoRect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int streamId = 1;
  signed int paletteLen;
  signed int dataLen;
  if((2 * (signed int)cl->format.bitsPerPixel) / 8 + 6 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  dataLen = (w + 7) / 8;
  dataLen = dataLen * h;
  _Bool tmp_if_expr_4;
  if(tightConf[(signed long int)compressLevel].monoZlibLevel == 0)
    tmp_if_expr_4 = cl->tightEncoding != 0xFFFFFEFC ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  signed int tmp_post_2;
  signed int tmp_post_3;
  if(tmp_if_expr_4)
  {
    tmp_post_2 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_2] = (char)((0x0A | 0x04) << 4);
  }

  else
  {
    tmp_post_3 = cl->ublen;
    cl->ublen = cl->ublen + 1;
    cl->updateBuf[(signed long int)tmp_post_3] = (char)((streamId | 0x04) << 4);
  }
  signed int tmp_post_5 = cl->ublen;
  cl->ublen = cl->ublen + 1;
  cl->updateBuf[(signed long int)tmp_post_5] = (char)0x01;
  signed int tmp_post_6 = cl->ublen;
  cl->ublen = cl->ublen + 1;
  cl->updateBuf[(signed long int)tmp_post_6] = (char)1;
  signed int tmp_post_7;
  signed int tmp_post_8;
  switch((signed int)cl->format.bitsPerPixel)
  {
    case 32:
    {
      EncodeMonoRect32((unsigned char *)tightBeforeBuf, w, h);
      ((unsigned int *)tightAfterBuf)[(signed long int)0] = monoBackground;
      ((unsigned int *)tightAfterBuf)[(signed long int)1] = monoForeground;
      if(!(usePixelFormat24 == 0))
      {
        Pack24(cl, tightAfterBuf, &cl->format, 2);
        paletteLen = 6;
      }

      else
        paletteLen = 8;
      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)tightAfterBuf, (unsigned long int)paletteLen);
      cl->ublen = cl->ublen + paletteLen;
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 3 + paletteLen);
      break;
    }
    case 16:
    {
      EncodeMonoRect16((unsigned char *)tightBeforeBuf, w, h);
      ((unsigned short int *)tightAfterBuf)[(signed long int)0] = (unsigned short int)monoBackground;
      ((unsigned short int *)tightAfterBuf)[(signed long int)1] = (unsigned short int)monoForeground;
      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)tightAfterBuf, (unsigned long int)4);
      cl->ublen = cl->ublen + 4;
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 7);
      break;
    }
    default:
    {
      EncodeMonoRect8((unsigned char *)tightBeforeBuf, w, h);
      tmp_post_7 = cl->ublen;
      cl->ublen = cl->ublen + 1;
      cl->updateBuf[(signed long int)tmp_post_7] = (char)monoBackground;
      tmp_post_8 = cl->ublen;
      cl->ublen = cl->ublen + 1;
      cl->updateBuf[(signed long int)tmp_post_8] = (char)monoForeground;
      rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, 5);
    }
  }
  signed char return_value_CompressData_9;
  return_value_CompressData_9=CompressData(cl, streamId, dataLen, tightConf[(signed long int)compressLevel].monoZlibLevel, 0);
  return return_value_CompressData_9;
}

// SendRectEncodingTight
// file tight.c line 291
static signed char SendRectEncodingTight(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int nMaxRows;
  unsigned int colorValue;
  signed int dx;
  signed int dy;
  signed int dw;
  signed int dh;
  signed int x_best;
  signed int y_best;
  signed int w_best;
  signed int h_best;
  char *fbptr;
  rfbSendUpdateBuf(cl);
  compressLevel = cl->tightCompressLevel;
  qualityLevel = cl->turboQualityLevel;
  subsampLevel = cl->turboSubsampLevel;
  if(!(qualityLevel == -1))
  {
    if(!(compressLevel >= 1))
      compressLevel = 1;

    if(compressLevel >= 3)
      compressLevel = 2;

  }

  else
    if(compressLevel >= 2)
      compressLevel = 1;

  if(cl->tightCompressLevel == 9)
    compressLevel = 3;

  _Bool tmp_if_expr_1;
  if((signed int)cl->format.depth == 24)
    tmp_if_expr_1 = (signed int)cl->format.redMax == 0xFF ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (signed int)cl->format.greenMax == 0xFF ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (signed int)cl->format.blueMax == 0xFF ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
    usePixelFormat24 = (signed char)-1;

  else
    usePixelFormat24 = (signed char)0;
  signed char return_value_SendRectSimple_4;
  void *return_value_malloc_5;
  void *return_value_realloc_6;
  signed char return_value_SendRectSimple_8;
  signed char return_value_SendRectEncodingTight_9;
  signed char return_value_SendRectEncodingTight_12;
  signed char return_value_SendRectEncodingTight_13;
  if(cl->enableLastRectEncoding == 0 || !(h * w >= 4096))
  {
    return_value_SendRectSimple_4=SendRectSimple(cl, x, y, w, h);
    return return_value_SendRectSimple_4;
  }

  else
  {
    if(!(tightBeforeBufSize >= 4))
    {
      tightBeforeBufSize = 4;
      if(tightBeforeBuf == ((char *)NULL))
      {
        return_value_malloc_5=malloc((unsigned long int)tightBeforeBufSize);
        tightBeforeBuf = (char *)return_value_malloc_5;
      }

      else
      {
        return_value_realloc_6=realloc((void *)tightBeforeBuf, (unsigned long int)tightBeforeBufSize);
        tightBeforeBuf = (char *)return_value_realloc_6;
      }
    }

    signed int maxRectSize;
    signed int maxRectWidth;
    signed int nMaxWidth;
    maxRectSize = tightConf[(signed long int)compressLevel].maxRectSize;
    maxRectWidth = tightConf[(signed long int)compressLevel].maxRectWidth;
    nMaxWidth = w > maxRectWidth ? maxRectWidth : w;
    nMaxRows = maxRectSize / nMaxWidth;
    dy = y;
    for( ; !(dy >= h + y); dy = dy + 16)
    {
      if(dy + -y >= nMaxRows)
      {
        signed char return_value_SendRectSimple_7;
        return_value_SendRectSimple_7=SendRectSimple(cl, x, y, w, nMaxRows);
        if(return_value_SendRectSimple_7 == 0)
          return (signed char)0;

        y = y + nMaxRows;
        h = h - nMaxRows;
      }

      dh = dy + 16 <= y + h ? 16 : (y + h) - dy;
      dx = x;
      for( ; !(dx >= w + x); dx = dx + 16)
      {
        dw = dx + 16 <= x + w ? 16 : (x + w) - dx;
        signed char return_value_CheckSolidTile_14;
        return_value_CheckSolidTile_14=CheckSolidTile(cl, dx, dy, dw, dh, &colorValue, (signed char)0);
        if(!(return_value_CheckSolidTile_14 == 0))
        {
          if(subsampLevel == 3 && !(qualityLevel == -1))
          {
            unsigned int r = colorValue >> 16 & (unsigned int)0xFF;
            unsigned int g = colorValue >> 8 & (unsigned int)0xFF;
            unsigned int b = colorValue & (unsigned int)0xFF;
            double SendRectEncodingTight__1__6__1__2__1__1__1__y = 0.257 * (double)r + 0.504 * (double)g + 0.098 * (double)b + 16.;
            colorValue = (unsigned int)((signed int)SendRectEncodingTight__1__6__1__2__1__1__1__y + ((signed int)SendRectEncodingTight__1__6__1__2__1__1__1__y << 8) + ((signed int)SendRectEncodingTight__1__6__1__2__1__1__1__y << 16));
          }

          FindBestSolidArea(cl, dx, dy, w - (dx - x), h - (dy - y), colorValue, &w_best, &h_best);
          if(!(h_best * w_best == h * w) && !(h_best * w_best >= 2048))
            goto __CPROVER_DUMP_L30;

          x_best = dx;
          y_best = dy;
          ExtendSolidArea(cl, x, y, w, h, colorValue, &x_best, &y_best, &w_best, &h_best);
          if(!(y_best == y))
          {
            return_value_SendRectSimple_8=SendRectSimple(cl, x, y, w, y_best - y);
            if(return_value_SendRectSimple_8 == 0)
              return (signed char)0;

          }

          if(!(x_best == x))
          {
            return_value_SendRectEncodingTight_9=SendRectEncodingTight(cl, x, y_best, x_best - x, h_best);
            if(return_value_SendRectEncodingTight_9 == 0)
              return (signed char)0;

          }

          signed char return_value_SendTightHeader_10;
          return_value_SendTightHeader_10=SendTightHeader(cl, x_best, y_best, w_best, h_best);
          if(return_value_SendTightHeader_10 == 0)
            return (signed char)0;

          fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y_best) + (signed long int)(x_best * (cl->scaledScreen->bitsPerPixel / 8));
          cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, tightBeforeBuf, cl->scaledScreen->paddedWidthInBytes, 1, 1);
          signed char return_value_SendSolidRect_11;
          return_value_SendSolidRect_11=SendSolidRect(cl);
          if(return_value_SendSolidRect_11 == 0)
            return (signed char)0;

          if(!(w_best + x_best == w + x))
          {
            return_value_SendRectEncodingTight_12=SendRectEncodingTight(cl, x_best + w_best, y_best, (w - (x_best - x)) - w_best, h_best);
            if(return_value_SendRectEncodingTight_12 == 0)
              return (signed char)0;

          }

          if(!(h_best + y_best == h + y))
          {
            return_value_SendRectEncodingTight_13=SendRectEncodingTight(cl, x, y_best + h_best, w, (h - (y_best - y)) - h_best);
            if(return_value_SendRectEncodingTight_13 == 0)
              return (signed char)0;

          }

          return (signed char)-1;
        }


      __CPROVER_DUMP_L30:
        ;
      }
    }
    signed char return_value_SendRectSimple_15;
    return_value_SendRectSimple_15=SendRectSimple(cl, x, y, w, h);
    return return_value_SendRectSimple_15;
  }
}

// SendRectSimple
// file tight.c line 614
static signed char SendRectSimple(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int maxBeforeSize;
  signed int maxAfterSize;
  signed int maxRectSize;
  signed int maxRectWidth;
  signed int subrectMaxWidth;
  signed int subrectMaxHeight;
  signed int dx;
  signed int dy;
  signed int rw;
  signed int rh;
  maxRectSize = tightConf[(signed long int)compressLevel].maxRectSize;
  maxRectWidth = tightConf[(signed long int)compressLevel].maxRectWidth;
  maxBeforeSize = maxRectSize * ((signed int)cl->format.bitsPerPixel / 8);
  maxAfterSize = maxBeforeSize + (maxBeforeSize + 99) / 100 + 12;
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(!(tightBeforeBufSize >= maxBeforeSize))
  {
    tightBeforeBufSize = maxBeforeSize;
    if(tightBeforeBuf == ((char *)NULL))
    {
      return_value_malloc_1=malloc((unsigned long int)tightBeforeBufSize);
      tightBeforeBuf = (char *)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)tightBeforeBuf, (unsigned long int)tightBeforeBufSize);
      tightBeforeBuf = (char *)return_value_realloc_2;
    }
  }

  void *return_value_malloc_3;
  void *return_value_realloc_4;
  if(!(tightAfterBufSize >= maxAfterSize))
  {
    tightAfterBufSize = maxAfterSize;
    if(tightAfterBuf == ((char *)NULL))
    {
      return_value_malloc_3=malloc((unsigned long int)tightAfterBufSize);
      tightAfterBuf = (char *)return_value_malloc_3;
    }

    else
    {
      return_value_realloc_4=realloc((void *)tightAfterBuf, (unsigned long int)tightAfterBufSize);
      tightAfterBuf = (char *)return_value_realloc_4;
    }
  }

  if(!(maxRectSize >= h * w) || !(maxRectWidth >= w))
  {
    subrectMaxWidth = w > maxRectWidth ? maxRectWidth : w;
    subrectMaxHeight = maxRectSize / subrectMaxWidth;
    dy = 0;
    for( ; !(dy >= h); dy = dy + subrectMaxHeight)
    {
      dx = 0;
      for( ; !(dx >= w); dx = dx + maxRectWidth)
      {
        rw = dx + maxRectWidth < w ? maxRectWidth : w - dx;
        rh = dy + subrectMaxHeight < h ? subrectMaxHeight : h - dy;
        signed char return_value_SendSubrect_5;
        return_value_SendSubrect_5=SendSubrect(cl, x + dx, y + dy, rw, rh);
        if(return_value_SendSubrect_5 == 0)
          return (signed char)0;

      }
    }
  }

  else
  {
    signed char return_value_SendSubrect_6;
    return_value_SendSubrect_6=SendSubrect(cl, x, y, w, h);
    if(return_value_SendSubrect_6 == 0)
      return (signed char)0;

  }
  return (signed char)-1;
}

// SendSolidRect
// file tight.c line 803
static signed char SendSolidRect(struct _rfbClientRec *cl)
{
  signed int len;
  if(!(usePixelFormat24 == 0))
  {
    Pack24(cl, tightBeforeBuf, &cl->format, 1);
    len = 3;
  }

  else
    len = (signed int)cl->format.bitsPerPixel / 8;
  if(1 + cl->ublen + len >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  signed int tmp_post_2 = cl->ublen;
  cl->ublen = cl->ublen + 1;
  cl->updateBuf[(signed long int)tmp_post_2] = (char)(0x08 << 4);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)tightBeforeBuf, (unsigned long int)len);
  cl->ublen = cl->ublen + len;
  rfbStatRecordEncodingSentAdd(cl, cl->tightEncoding, len + 1);
  return (signed char)-1;
}

// SendSubrect
// file tight.c line 667
static signed char SendSubrect(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  char *fbptr;
  signed char success = (signed char)0;
  if(cl->ublen >= 129)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  signed char return_value_SendTightHeader_2;
  return_value_SendTightHeader_2=SendTightHeader(cl, x, y, w, h);
  signed char return_value_SendJpegRect_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(return_value_SendTightHeader_2 == 0)
    return (signed char)0;

  else
  {
    fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
    if(subsampLevel == 3 && !(qualityLevel == -1))
    {
      return_value_SendJpegRect_3=SendJpegRect(cl, x, y, w, h, qualityLevel);
      return return_value_SendJpegRect_3;
    }

    else
    {
      paletteMaxColors = (w * h) / tightConf[(signed long int)compressLevel].idxMaxColorsDivisor;
      if(!(qualityLevel == -1))
        paletteMaxColors = tightConf[(signed long int)compressLevel].palMaxColorsWithJPEG;

      if(!(paletteMaxColors >= 2))
      {
        if(h * w >= tightConf[(signed long int)compressLevel].monoMinRectSize)
          paletteMaxColors = 2;

      }

      if(cl->format.bitsPerPixel == cl->screen->serverFormat.bitsPerPixel)
        tmp_if_expr_4 = cl->format.redMax == cl->screen->serverFormat.redMax ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = cl->format.greenMax == cl->screen->serverFormat.greenMax ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = cl->format.blueMax == cl->screen->serverFormat.blueMax ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = (signed int)cl->format.bitsPerPixel >= 16 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        if((signed int)cl->format.bitsPerPixel == 16)
        {
          FastFillPalette16(cl, (unsigned short int *)fbptr, w, cl->scaledScreen->paddedWidthInBytes / 2, h);
          goto __CPROVER_DUMP_L17;
        }

        FastFillPalette32(cl, (unsigned int *)fbptr, w, cl->scaledScreen->paddedWidthInBytes / 4, h);

      __CPROVER_DUMP_L17:
        ;
        if(qualityLevel == -1 || !(paletteNumColors == 0))
          cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, tightBeforeBuf, cl->scaledScreen->paddedWidthInBytes, w, h);

      }

      else
      {
        cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, tightBeforeBuf, cl->scaledScreen->paddedWidthInBytes, w, h);
        if((signed int)cl->format.bitsPerPixel == 8)
        {
          FillPalette8(w * h);
          FillPalette16(w * h);
        }

        FillPalette32(w * h);
      }
      switch(paletteNumColors)
      {
        case 0:
        {
          if(!(qualityLevel == -1))
            success=SendJpegRect(cl, x, y, w, h, qualityLevel);

          else
            success=SendFullColorRect(cl, x, y, w, h);
          break;
        }
        case 1:
        {
          success=SendSolidRect(cl);
          break;
        }
        case 2:
        {
          success=SendMonoRect(cl, x, y, w, h);
          break;
        }
        default:
          success=SendIndexedRect(cl, x, y, w, h);
      }
      return success;
    }
  }
}

// SendTightHeader
// file tight.c line 767
static signed char SendTightHeader(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
  rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  unsigned int tmp_if_expr_2;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_2 = cl->tightEncoding >> 24 | (cl->tightEncoding & (unsigned int)0x00ff0000) >> 8 | (cl->tightEncoding & (unsigned int)0x0000ff00) << 8 | cl->tightEncoding << 24;

  else
    tmp_if_expr_2 = cl->tightEncoding;
  rect.encoding = tmp_if_expr_2;
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, cl->tightEncoding, 8 + 4, 8 + 4 + w * ((signed int)cl->format.bitsPerPixel / 8) * h);
  return (signed char)-1;
}

// SetFtpRoot
// file tightvnc-filetransfer/handlefiletransferrequest.h line 33
signed int SetFtpRoot(char *path)
{
  struct stat stat_buf;
  struct __dirstream *dir = (struct __dirstream *)(void *)0;
  rfbLog("tightvnc-filetransfer/SetFtpRoot\n");
  _Bool tmp_if_expr_2;
  unsigned long int return_value_strlen_1;
  if(path == ((char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strlen_1=strlen(path);
    tmp_if_expr_2 = return_value_strlen_1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_2)
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_strlen_3=strlen(path);
    tmp_if_expr_4 = return_value_strlen_3 > (unsigned long int)(4096 - 1) ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_strlen_7;
  if(tmp_if_expr_4)
  {
    rfbLog("File [%s]: Method [%s]: parameter passed is improper, ftproot not changed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"SetFtpRoot");
    return 0;
  }

  else
  {
    signed int return_value_stat_5;
    return_value_stat_5=stat(path, &stat_buf);
    if(!(return_value_stat_5 >= 0))
    {
      rfbLog("File [%s]: Method [%s]: Reading stat for file %s failed\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"SetFtpRoot", path);
      return 0;
    }

    else
      if(!((61440u & stat_buf.st_mode) == 16384u))
      {
        rfbLog("File [%s]: Method [%s]: path specified is not a directory\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"SetFtpRoot");
        return 0;
      }

      else
      {
        dir=opendir(path);
        if(dir == ((struct __dirstream *)NULL))
        {
          rfbLog("File [%s]: Method [%s]: Not able to open the directory\n", (const void *)"tightvnc-filetransfer/handlefiletransferrequest.c", (const void *)"SetFtpRoot");
          return 0;
        }

        else
        {
          closedir(dir);
          dir = (struct __dirstream *)(void *)0;
        }
        memset((void *)ftproot, 0, (unsigned long int)4096);
        unsigned long int return_value_strlen_8;
        return_value_strlen_8=strlen(path);
        if((signed int)path[-1l + (signed long int)return_value_strlen_8] == 47)
        {
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(path);
          memcpy((void *)ftproot, (const void *)path, return_value_strlen_6 - (unsigned long int)1);
        }

        else
        {
          return_value_strlen_7=strlen(path);
          memcpy((void *)ftproot, (const void *)path, return_value_strlen_7);
        }
        return -1;
      }
  }
}

// TJBUFSIZE
// file ../common/turbojpeg.h line 507
unsigned long int TJBUFSIZE(signed int width, signed int height)
{
  unsigned long int retval = (unsigned long int)0;
  if(!(height >= 1) || !(width >= 1))
  {
    snprintf(errStr, (unsigned long int)200, "%s", (const void *)"TJBUFSIZE(): Invalid argument");
    retval = (unsigned long int)-1;
  }

  else
    retval = (unsigned long int)(((width + 16) - 1 & ~(16 - 1)) * ((height + 16) - 1 & ~(16 - 1)) * 6 + 2048);

bailout:
  ;
  return retval;
}

// Wavelet
// file ../common/zywrletemplate.c line 478
static inline void Wavelet(signed int *pBuf, signed int width, signed int height, signed int level)
{
  signed int l;
  signed int s;
  signed int *pTop;
  signed int *pEnd;
  l = 0;
  for( ; !(l >= level); l = l + 1)
  {
    pTop = pBuf;
    pEnd = pBuf + (signed long int)(height * width);
    s = width << l;
    for( ; !(pTop >= pEnd); pTop = pTop + (signed long int)s)
      WaveletLevel(pTop, width, l, 1);
    pTop = pBuf;
    pEnd = pBuf + (signed long int)width;
    s = 1 << l;
    for( ; !(pTop >= pEnd); pTop = pTop + (signed long int)s)
      WaveletLevel(pTop, height, l, width);
    FilterWaveletSquare(pBuf, width, height, level, l);
  }
}

// WaveletLevel
// file ../common/zywrletemplate.c line 357
static inline void WaveletLevel(signed int *data, signed int size, signed int l, signed int SkipPixel)
{
  signed int s;
  signed int ofs;
  signed char *pX0;
  signed char *end;
  pX0 = (signed char *)data;
  s = (8 << l) * SkipPixel;
  end = pX0 + (signed long int)((size >> l + 1) * s);
  s = s - 2;
  ofs = (4 << l) * SkipPixel;
  for( ; !(pX0 >= end); pX0 = pX0 + (signed long int)s)
  {
    Harr(pX0, pX0 + (signed long int)ofs);
    pX0 = pX0 + 1l;
    Harr(pX0, pX0 + (signed long int)ofs);
    pX0 = pX0 + 1l;
    Harr(pX0, pX0 + (signed long int)ofs);
  }
}

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx)
{
  signed long long int return_value___builtin_bswap64_1;
  return_value___builtin_bswap64_1=__builtin_bswap64((signed long long int)__bsx);
  return (unsigned long int)return_value___builtin_bswap64_1;
}

// __lzo_align_gap
// file ../common/minilzo.c line 3886
extern unsigned int __lzo_align_gap(const void *ptr, unsigned long int size)
{
  unsigned long int p;
  unsigned long int n;
  p=__lzo_ptr_linear(ptr);
  n = (((p + size) - (unsigned long int)1) / size) * size - p;
  return (unsigned int)n;
}

// __lzo_init_v2
// file ../common/minilzo.c line 4221
extern signed int __lzo_init_v2(unsigned int v, signed int s1, signed int s2, signed int s3, signed int s4, signed int s5, signed int s6, signed int s7, signed int s8, signed int s9)
{
  signed int r;
  if(v == 0u)
    return -1;

  else
  {
    r = (signed int)((s1 == -1 || s1 == (signed int)sizeof(signed short int) /*2ul*/ ) && (s2 == -1 || s2 == (signed int)sizeof(signed int) /*4ul*/ ) && (s3 == -1 || s3 == (signed int)sizeof(signed long int) /*8ul*/ ) && (s4 == -1 || s4 == (signed int)sizeof(unsigned int) /*4ul*/ ) && (s5 == -1 || s5 == (signed int)sizeof(unsigned long int) /*8ul*/ ) && (s6 == -1 || s6 == (signed int)(unsigned int)sizeof(unsigned char *) /*8ul*/ ) && (s7 == -1 || s7 == (signed int)sizeof(char *) /*8ul*/ ) && (s8 == -1 || s8 == (signed int)sizeof(void *) /*8ul*/ ) && (s9 == -1 || s9 == (signed int)sizeof(struct lzo_callback_t) /*48ul*/ ));
    if(r == 0)
      return -1;

    else
    {
      r=_lzo_config_check();
      if(!(r == 0))
        return r;

      else
        return r;
    }
  }
}

// __lzo_ptr_linear
// file ../common/minilzo.c line 3870
extern unsigned long int __lzo_ptr_linear(const void *ptr)
{
  unsigned long int p = (unsigned long int)ptr;
  return p;
}

// __rfbssl_read
// file rfbssl_gnutls.c line 204
static signed int __rfbssl_read(struct _rfbClientRec *cl, char *buf, signed int bufsize, signed int peek)
{
  signed int ret = 0;
  struct rfbssl_ctx *ctx = (struct rfbssl_ctx *)cl->sslctx;
  rfbssl_gc_peekbuf(ctx, bufsize);
  signed int tmp_if_expr_1;
  if(!(ctx->peeklen == 0))
  {
    if(!(bufsize >= ctx->peeklen))
      tmp_if_expr_1 = bufsize;

    else
      tmp_if_expr_1 = ctx->peeklen;
    ret = tmp_if_expr_1;
    memcpy((void *)buf, (const void *)(ctx->peekbuf + (signed long int)ctx->peekstart), (unsigned long int)ret);
    if(peek == 0)
    {
      ctx->peeklen = ctx->peeklen - ret;
      if(!(ctx->peeklen == 0))
        ctx->peekstart = ctx->peekstart + ret;

      else
        ctx->peekstart = 0;
    }

  }

  if(!(ret >= bufsize))
  {
    signed int n;
    n=rfbssl_do_read(cl, buf + (signed long int)ret, bufsize - ret);
    if(!(n >= 1))
    {
      rfbErr("rfbssl_%s: %s error\n", (const void *)"__rfbssl_read", peek != 0 ? "peek" : "read");
      return n;
    }

    if(!(peek == 0))
    {
      memcpy((void *)(ctx->peekbuf + (signed long int)ctx->peekstart + (signed long int)ctx->peeklen), (const void *)(buf + (signed long int)ret), (unsigned long int)n);
      ctx->peeklen = ctx->peeklen + n;
    }

    ret = ret + n;
  }

  return ret;
}

// _lzo_config_check
// file ../common/minilzo.c line 4135
extern signed int _lzo_config_check(void)
{
  union lzo_config_check_union u;
  void *p;
  unsigned int r = (unsigned int)1;
  u.a[(signed long int)1] = (unsigned long int)0;
  u.a[(signed long int)0] = u.a[(signed long int)1];
  p=u2p((void *)&u, (unsigned long int)0);
  r = r & (unsigned int)((signed int)*((unsigned char *)p) == 0);
  u.a[(signed long int)1] = (unsigned long int)0;
  u.a[(signed long int)0] = u.a[(signed long int)1];
  u.b[(signed long int)0] = (unsigned char)128;
  p=u2p((void *)&u, (unsigned long int)0);
  r = r & (unsigned int)(*((unsigned long int *)p) == (unsigned long int)128);
  u.a[(signed long int)1] = (unsigned long int)0;
  u.a[(signed long int)0] = u.a[(signed long int)1];
  u.b[(signed long int)0] = (unsigned char)1;
  u.b[(signed long int)3] = (unsigned char)2;
  p=u2p((void *)&u, (unsigned long int)1);
  r = r & (unsigned int)((signed int)*((const volatile unsigned short int *)(const void *)p) == 0);
  r = r & (unsigned int)((signed int)*((const volatile unsigned short int *)(const void *)p) == 0);
  u.b[(signed long int)1] = (unsigned char)128;
  r = r & (unsigned int)((signed int)*((const volatile unsigned short int *)(const void *)p) == 128);
  u.a[(signed long int)1] = (unsigned long int)0;
  u.a[(signed long int)0] = u.a[(signed long int)1];
  u.b[(signed long int)0] = (unsigned char)3;
  u.b[(signed long int)5] = (unsigned char)4;
  p=u2p((void *)&u, (unsigned long int)1);
  r = r & (unsigned int)(*((const volatile unsigned int *)(const void *)p) == (unsigned int)0);
  r = r & (unsigned int)(*((const volatile unsigned int *)(const void *)p) == (unsigned int)0);
  u.b[(signed long int)1] = (unsigned char)128;
  r = r & (unsigned int)(*((const volatile unsigned int *)(const void *)p) == (unsigned int)128);
  u.c[(signed long int)1] = (unsigned long int)0;
  u.c[(signed long int)0] = u.c[(signed long int)1];
  u.b[(signed long int)0] = (unsigned char)5;
  u.b[(signed long int)9] = (unsigned char)6;
  p=u2p((void *)&u, (unsigned long int)1);
  u.c[(signed long int)1] = (unsigned long int)0;
  u.c[(signed long int)0] = u.c[(signed long int)1];
  r = r & (unsigned int)(*((const volatile unsigned long int *)(const void *)p) == (unsigned long int)0);
  r = r & (unsigned int)(*((const volatile unsigned long int *)(const void *)p) == (unsigned long int)0);
  u.b[(signed long int)1] = (unsigned char)128;
  r = r & (unsigned int)(*((const volatile unsigned long int *)(const void *)p) == (unsigned long int)128);
  unsigned int _lzo_config_check__1__1__i = (unsigned int)0;
  unsigned int v = (unsigned int)1;
  for( ; r == 1u && !(v == 0u); _lzo_config_check__1__1__i = _lzo_config_check__1__1__i + 1u)
  {
    signed int return_value___builtin_clz_1;
    return_value___builtin_clz_1=__builtin_clz(v);
    r = r & (unsigned int)((unsigned int)return_value___builtin_clz_1 == (unsigned int)31 - _lzo_config_check__1__1__i);
    unsigned int return_value_lzo_bitops_ctlz32_func_2;
    return_value_lzo_bitops_ctlz32_func_2=lzo_bitops_ctlz32_func(v);
    r = r & (unsigned int)(return_value_lzo_bitops_ctlz32_func_2 == (unsigned int)31 - _lzo_config_check__1__1__i);
    v = v << 1;
  }
  unsigned int _lzo_config_check__1__2__i = (unsigned int)0;
  unsigned long int _lzo_config_check__1__2__v = (unsigned long int)1;
  for( ; r == 1u && !(_lzo_config_check__1__2__v == 0ul); _lzo_config_check__1__2__i = _lzo_config_check__1__2__i + 1u)
  {
    signed int return_value___builtin_clzl_3;
    return_value___builtin_clzl_3=__builtin_clzl(_lzo_config_check__1__2__v);
    r = r & (unsigned int)((unsigned int)return_value___builtin_clzl_3 == (unsigned int)63 - _lzo_config_check__1__2__i);
    unsigned int return_value_lzo_bitops_ctlz64_func_4;
    return_value_lzo_bitops_ctlz64_func_4=lzo_bitops_ctlz64_func(_lzo_config_check__1__2__v);
    r = r & (unsigned int)(return_value_lzo_bitops_ctlz64_func_4 == (unsigned int)63 - _lzo_config_check__1__2__i);
    _lzo_config_check__1__2__v = _lzo_config_check__1__2__v << 1;
  }
  unsigned int i = (unsigned int)0;
  unsigned int _lzo_config_check__1__3__v = (unsigned int)1;
  for( ; r == 1u && !(_lzo_config_check__1__3__v == 0u); i = i + 1u)
  {
    signed int return_value___builtin_ctz_5;
    return_value___builtin_ctz_5=__builtin_ctz(_lzo_config_check__1__3__v);
    r = r & (unsigned int)((unsigned int)return_value___builtin_ctz_5 == i);
    unsigned int return_value_lzo_bitops_cttz32_func_6;
    return_value_lzo_bitops_cttz32_func_6=lzo_bitops_cttz32_func(_lzo_config_check__1__3__v);
    r = r & (unsigned int)(return_value_lzo_bitops_cttz32_func_6 == i);
    _lzo_config_check__1__3__v = _lzo_config_check__1__3__v << 1;
  }
  unsigned int _lzo_config_check__1__4__i = (unsigned int)0;
  unsigned long int _lzo_config_check__1__4__v = (unsigned long int)1;
  for( ; r == 1u && !(_lzo_config_check__1__4__v == 0ul); _lzo_config_check__1__4__i = _lzo_config_check__1__4__i + 1u)
  {
    signed int return_value___builtin_ctzl_7;
    return_value___builtin_ctzl_7=__builtin_ctzl(_lzo_config_check__1__4__v);
    r = r & (unsigned int)((unsigned int)return_value___builtin_ctzl_7 == _lzo_config_check__1__4__i);
    unsigned int return_value_lzo_bitops_cttz64_func_8;
    return_value_lzo_bitops_cttz64_func_8=lzo_bitops_cttz64_func(_lzo_config_check__1__4__v);
    r = r & (unsigned int)(return_value_lzo_bitops_cttz64_func_8 == _lzo_config_check__1__4__i);
    _lzo_config_check__1__4__v = _lzo_config_check__1__4__v << 1;
  }
  (void)lzo_bitops_unused_funcs;
  return r == (unsigned int)1 ? 0 : -1;
}

// _lzo_version_date
// file ../common/minilzo.c line 3953
extern const char * _lzo_version_date(void)
{
  return "Jun 25 2014";
}

// _lzo_version_string
// file ../common/minilzo.c line 3947
extern const char * _lzo_version_string(void)
{
  return "2.07";
}

// _tjInitCompress
// file ../common/turbojpeg.c line 461
static void * _tjInitCompress(struct _tjinstance *this)
{
  this->cinfo.err=jpeg_std_error(&this->jerr.pub);
  this->jerr.pub.error_exit = my_error_exit;
  this->jerr.pub.output_message = my_output_message;
  signed int return_value__setjmp_1;
  return_value__setjmp_1=_setjmp(this->jerr.setjmp_buffer);
  if(!(return_value__setjmp_1 == 0))
  {
    if(!(this == ((struct _tjinstance *)NULL)))
      free((void *)this);

    return (void *)0;
  }

  else
  {
    jpeg_CreateCompress(&this->cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
    this->cinfo.dest = &this->jdst;
    this->jdst.init_destination = dst_noop;
    this->jdst.empty_output_buffer = empty_output_buffer;
    this->jdst.term_destination = dst_noop;
    this->init = this->init | 1;
    return (void *)this;
  }
}

// _tjInitDecompress
// file ../common/turbojpeg.c line 645
static void * _tjInitDecompress(struct _tjinstance *this)
{
  this->dinfo.err=jpeg_std_error(&this->jerr.pub);
  this->jerr.pub.error_exit = my_error_exit;
  this->jerr.pub.output_message = my_output_message;
  signed int return_value__setjmp_1;
  return_value__setjmp_1=_setjmp(this->jerr.setjmp_buffer);
  if(!(return_value__setjmp_1 == 0))
  {
    if(!(this == ((struct _tjinstance *)NULL)))
      free((void *)this);

    return (void *)0;
  }

  else
  {
    jpeg_CreateDecompress(&this->dinfo, 62, (unsigned long int)sizeof(struct jpeg_decompress_struct) /*632ul*/ );
    this->dinfo.src = &this->jsrc;
    this->jsrc.init_source = src_noop;
    this->jsrc.fill_input_buffer = fill_input_buffer;
    this->jsrc.skip_input_data = skip_input_data;
    this->jsrc.resync_to_restart = jpeg_resync_to_restart;
    this->jsrc.term_source = src_noop;
    this->init = this->init | 2;
    return (void *)this;
  }
}

// clientInput
// file main.c line 509
static void * clientInput(void *data)
{
  struct _rfbClientRec *clientInput__1__cl = (struct _rfbClientRec *)data;
  unsigned long int output_thread;
  pthread_create(&output_thread, (const union pthread_attr_t *)(void *)0, clientOutput, (void *)clientInput__1__cl);
  _Bool tmp_if_expr_1;
  while((_Bool)1)
  {
    struct anonymous_16 rfds;
    struct anonymous_16 wfds;
    struct anonymous_16 efds;
    struct timeval tv;
    signed int n;
    if(clientInput__1__cl->sock == -1)
      break;

    do
    {
      signed int clientInput__1__1__2____d0;
      signed int clientInput__1__1__2____d1;
      asm("cld; rep; stosq" : "=c"(clientInput__1__1__2____d0), "=D"(clientInput__1__1__2____d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&rfds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << clientInput__1__cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&efds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&efds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&efds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << clientInput__1__cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    do
    {
      signed int clientInput__1__1__4____d0;
      signed int clientInput__1__1__4____d1;
      asm("cld; rep; stosq" : "=c"(clientInput__1__1__4____d0), "=D"(clientInput__1__1__4____d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    if(!(clientInput__1__cl->fileTransfer.fd == -1))
    {
      if(clientInput__1__cl->fileTransfer.sending == 1)
        (&wfds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << clientInput__1__cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    }

    tv.tv_sec = (signed long int)60;
    tv.tv_usec = (signed long int)0;
    n=select(clientInput__1__cl->sock + 1, &rfds, &wfds, &efds, &tv);
    if(!(n >= 0))
    {
      rfbLogPerror("ReadExact: select");
      break;
    }

    if(n == 0)
      rfbSendFileTransferChunk(clientInput__1__cl);

    else
    {
      if(!((wfds.__fds_bits[(signed long int)(clientInput__1__cl->sock / 8)] & (signed long int)(1UL << clientInput__1__cl->sock % 8)) == 0l))
        rfbSendFileTransferChunk(clientInput__1__cl);

      if(!((rfds.__fds_bits[(signed long int)(clientInput__1__cl->sock / 8)] & (signed long int)(1UL << clientInput__1__cl->sock % 8)) == 0l))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = ((&efds)->__fds_bits[(signed long int)(clientInput__1__cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << clientInput__1__cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        rfbProcessClientMessage(clientInput__1__cl);

    }
  }
  pthread_mutex_lock(&clientInput__1__cl->updateMutex);
  pthread_cond_signal(&clientInput__1__cl->updateCond);
  pthread_mutex_unlock(&clientInput__1__cl->updateMutex);
  pthread_join(output_thread, (void **)(void *)0);
  rfbClientConnectionGone(clientInput__1__cl);
  return (void *)0;
}

// clientOutput
// file main.c line 443
static void * clientOutput(void *data)
{
  struct _rfbClientRec *clientOutput__1__cl = (struct _rfbClientRec *)data;
  signed char haveUpdate;
  struct sraRegion *updateRegion;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_11;
  signed char return_value_sraRgnEmpty_10;
  _Bool tmp_if_expr_13;
  signed char return_value_sraRgnEmpty_12;
  while((_Bool)1)
  {
    haveUpdate = (signed char)0;
    while(haveUpdate == 0)
    {
      if(clientOutput__1__cl->sock == -1)
        return (void *)0;

      if(!((signed int)clientOutput__1__cl->state == RFB_NORMAL))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = clientOutput__1__cl->onHold != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        usleep((unsigned int)(clientOutput__1__cl->screen->deferUpdateTime * 1000));

      else
      {
        pthread_mutex_lock(&clientOutput__1__cl->updateMutex);
        signed char return_value_sraRgnEmpty_14;
        return_value_sraRgnEmpty_14=sraRgnEmpty(clientOutput__1__cl->requestedRegion);
        if(return_value_sraRgnEmpty_14 == 0)
        {
          if(!(clientOutput__1__cl->enableCursorShapeUpdates == 0))
            tmp_if_expr_2 = clientOutput__1__cl->cursorWasChanged != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            if((signed int)clientOutput__1__cl->enableCursorShapeUpdates == 0)
            {
              if(!(clientOutput__1__cl->cursorX == clientOutput__1__cl->screen->cursorX))
                tmp_if_expr_3 = (_Bool)1;

              else
                tmp_if_expr_3 = clientOutput__1__cl->cursorY != clientOutput__1__cl->screen->cursorY ? (_Bool)1 : (_Bool)0;
              tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            if(!(clientOutput__1__cl->useNewFBSize == 0))
              tmp_if_expr_6 = clientOutput__1__cl->newFBSizePending != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_6 = (_Bool)0;
            tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            if(!(clientOutput__1__cl->enableCursorPosUpdates == 0))
              tmp_if_expr_8 = clientOutput__1__cl->cursorWasMoved != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_8 = (_Bool)0;
            tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_9)
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value_sraRgnEmpty_10=sraRgnEmpty(clientOutput__1__cl->copyRegion);
            tmp_if_expr_11 = !(return_value_sraRgnEmpty_10 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            tmp_if_expr_13 = (_Bool)1;

          else
          {
            return_value_sraRgnEmpty_12=sraRgnEmpty(clientOutput__1__cl->modifiedRegion);
            tmp_if_expr_13 = !(return_value_sraRgnEmpty_12 != 0) ? (_Bool)1 : (_Bool)0;
          }
          haveUpdate = (signed char)tmp_if_expr_13;
          if(haveUpdate == 0)
          {
            updateRegion=sraRgnCreateRgn(clientOutput__1__cl->modifiedRegion);
            haveUpdate=sraRgnAnd(updateRegion, clientOutput__1__cl->requestedRegion);
            sraRgnDestroy(updateRegion);
          }

        }

        if(haveUpdate == 0)
          pthread_cond_wait(&clientOutput__1__cl->updateCond, &clientOutput__1__cl->updateMutex);

        pthread_mutex_unlock(&clientOutput__1__cl->updateMutex);
      }
    }
    usleep((unsigned int)(clientOutput__1__cl->screen->deferUpdateTime * 1000));
    pthread_mutex_lock(&clientOutput__1__cl->updateMutex);
    updateRegion=sraRgnCreateRgn(clientOutput__1__cl->modifiedRegion);
    pthread_mutex_unlock(&clientOutput__1__cl->updateMutex);
    rfbIncrClientRef(clientOutput__1__cl);
    pthread_mutex_lock(&clientOutput__1__cl->sendMutex);
    rfbSendFramebufferUpdate(clientOutput__1__cl, updateRegion);
    pthread_mutex_unlock(&clientOutput__1__cl->sendMutex);
    rfbDecrClientRef(clientOutput__1__cl);
    sraRgnDestroy(updateRegion);
  }
  return (void *)0;
}

// compareAndSkip
// file httpd.c line 556
static signed char compareAndSkip(char **ptr, const char *str)
{
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(str);
  signed int return_value_strncmp_3;
  return_value_strncmp_3=strncmp(*ptr, str, return_value_strlen_2);
  if(return_value_strncmp_3 == 0)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    *ptr = *ptr + (signed long int)return_value_strlen_1;
    return (signed char)-1;
  }

  return (signed char)0;
}

// cookey
// file ../common/d3des.c line 110
static void cookey(unsigned long int *raw1)
{
  unsigned long int *cook;
  unsigned long int *raw0;
  unsigned long int dough[32l];
  signed int i;
  cook = dough;
  i = 0;
  unsigned long int *tmp_post_1;
  unsigned long int *tmp_post_2;
  unsigned long int *tmp_post_3;
  for( ; !(i >= 16); raw1 = raw1 + 1l)
  {
    tmp_post_1 = raw1;
    raw1 = raw1 + 1l;
    raw0 = tmp_post_1;
    *cook = (*raw0 & (unsigned long int)0x00fc0000L) << 6;
    *cook = *cook | (*raw0 & (unsigned long int)0x00000fc0L) << 10;
    *cook = *cook | (*raw1 & (unsigned long int)0x00fc0000L) >> 10;
    tmp_post_2 = cook;
    cook = cook + 1l;
    *tmp_post_2 = *tmp_post_2 | (*raw1 & (unsigned long int)0x00000fc0L) >> 6;
    *cook = (*raw0 & (unsigned long int)0x0003f000L) << 12;
    *cook = *cook | (*raw0 & (unsigned long int)0x0000003fL) << 16;
    *cook = *cook | (*raw1 & (unsigned long int)0x0003f000L) >> 4;
    tmp_post_3 = cook;
    cook = cook + 1l;
    *tmp_post_3 = *tmp_post_3 | *raw1 & (unsigned long int)0x0000003fL;
    i = i + 1;
  }
  rfbUseKey(dough);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// desfunc
// file ../common/d3des.c line 333
static void desfunc(unsigned long int *block, unsigned long int *keys)
{
  unsigned long int fval;
  unsigned long int work;
  unsigned long int right;
  unsigned long int leftt;
  signed int round;
  leftt = block[(signed long int)0];
  right = block[(signed long int)1];
  work = (leftt >> 4 ^ right) & (unsigned long int)0x0f0f0f0fL;
  right = right ^ work;
  leftt = leftt ^ work << 4;
  work = (leftt >> 16 ^ right) & (unsigned long int)0x0000ffffL;
  right = right ^ work;
  leftt = leftt ^ work << 16;
  work = (right >> 2 ^ leftt) & (unsigned long int)0x33333333L;
  leftt = leftt ^ work;
  right = right ^ work << 2;
  work = (right >> 8 ^ leftt) & (unsigned long int)0x00ff00ffL;
  leftt = leftt ^ work;
  right = right ^ work << 8;
  right = (right << 1 | right >> 31 & (unsigned long int)1L) & (unsigned long int)0xffffffffL;
  work = (leftt ^ right) & (unsigned long int)0xaaaaaaaaL;
  leftt = leftt ^ work;
  right = right ^ work;
  leftt = (leftt << 1 | leftt >> 31 & (unsigned long int)1L) & (unsigned long int)0xffffffffL;
  round = 0;
  unsigned long int *tmp_post_1;
  unsigned long int *tmp_post_2;
  unsigned long int *tmp_post_3;
  unsigned long int *tmp_post_4;
  for( ; !(round >= 8); round = round + 1)
  {
    work = right << 28 | right >> 4;
    tmp_post_1 = keys;
    keys = keys + 1l;
    work = work ^ *tmp_post_1;
    fval = SP7[(signed long int)(work & (unsigned long int)0x3fL)];
    fval = fval | SP5[(signed long int)(work >> 8 & (unsigned long int)0x3fL)];
    fval = fval | SP3[(signed long int)(work >> 16 & (unsigned long int)0x3fL)];
    fval = fval | SP1[(signed long int)(work >> 24 & (unsigned long int)0x3fL)];
    tmp_post_2 = keys;
    keys = keys + 1l;
    work = right ^ *tmp_post_2;
    fval = fval | SP8[(signed long int)(work & (unsigned long int)0x3fL)];
    fval = fval | SP6[(signed long int)(work >> 8 & (unsigned long int)0x3fL)];
    fval = fval | SP4[(signed long int)(work >> 16 & (unsigned long int)0x3fL)];
    fval = fval | SP2[(signed long int)(work >> 24 & (unsigned long int)0x3fL)];
    leftt = leftt ^ fval;
    work = leftt << 28 | leftt >> 4;
    tmp_post_3 = keys;
    keys = keys + 1l;
    work = work ^ *tmp_post_3;
    fval = SP7[(signed long int)(work & (unsigned long int)0x3fL)];
    fval = fval | SP5[(signed long int)(work >> 8 & (unsigned long int)0x3fL)];
    fval = fval | SP3[(signed long int)(work >> 16 & (unsigned long int)0x3fL)];
    fval = fval | SP1[(signed long int)(work >> 24 & (unsigned long int)0x3fL)];
    tmp_post_4 = keys;
    keys = keys + 1l;
    work = leftt ^ *tmp_post_4;
    fval = fval | SP8[(signed long int)(work & (unsigned long int)0x3fL)];
    fval = fval | SP6[(signed long int)(work >> 8 & (unsigned long int)0x3fL)];
    fval = fval | SP4[(signed long int)(work >> 16 & (unsigned long int)0x3fL)];
    fval = fval | SP2[(signed long int)(work >> 24 & (unsigned long int)0x3fL)];
    right = right ^ fval;
  }
  right = right << 31 | right >> 1;
  work = (leftt ^ right) & (unsigned long int)0xaaaaaaaaL;
  leftt = leftt ^ work;
  right = right ^ work;
  leftt = leftt << 31 | leftt >> 1;
  work = (leftt >> 8 ^ right) & (unsigned long int)0x00ff00ffL;
  right = right ^ work;
  leftt = leftt ^ work << 8;
  work = (leftt >> 2 ^ right) & (unsigned long int)0x33333333L;
  right = right ^ work;
  leftt = leftt ^ work << 2;
  work = (right >> 16 ^ leftt) & (unsigned long int)0x0000ffffL;
  leftt = leftt ^ work;
  right = right ^ work << 16;
  work = (right >> 4 ^ leftt) & (unsigned long int)0x0f0f0f0fL;
  leftt = leftt ^ work;
  right = right ^ work << 4;
  unsigned long int *tmp_post_5 = block;
  block = block + 1l;
  *tmp_post_5 = right;
  *block = leftt;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// digestmd5
// file rfbcrypto.h line 9
void digestmd5(struct iovec *iov, signed int iovcnt, void *dest)
{
  struct gcry_md_handle *c;
  signed int i;
  gcry_md_open(&c, 1, (unsigned int)0);
  i = 0;
  for( ; !(i >= iovcnt); i = i + 1)
    gcry_md_write(c, (iov + (signed long int)i)->iov_base, (iov + (signed long int)i)->iov_len);
  gcry_md_ctl(c, 5, (void *)0, (unsigned long int)0);
  unsigned char *return_value_gcry_md_read_1;
  return_value_gcry_md_read_1=gcry_md_read(c, 0);
  unsigned int return_value_gcry_md_get_algo_dlen_2;
  return_value_gcry_md_get_algo_dlen_2=gcry_md_get_algo_dlen(1);
  memcpy(dest, (const void *)return_value_gcry_md_read_1, (unsigned long int)return_value_gcry_md_get_algo_dlen_2);
}

// digestsha1
// file rfbcrypto.h line 10
void digestsha1(struct iovec *iov, signed int iovcnt, void *dest)
{
  struct gcry_md_handle *c;
  signed int i;
  gcry_md_open(&c, 2, (unsigned int)0);
  i = 0;
  for( ; !(i >= iovcnt); i = i + 1)
    gcry_md_write(c, (iov + (signed long int)i)->iov_base, (iov + (signed long int)i)->iov_len);
  gcry_md_ctl(c, 5, (void *)0, (unsigned long int)0);
  unsigned char *return_value_gcry_md_read_1;
  return_value_gcry_md_read_1=gcry_md_read(c, 0);
  unsigned int return_value_gcry_md_get_algo_dlen_2;
  return_value_gcry_md_get_algo_dlen_2=gcry_md_get_algo_dlen(2);
  memcpy(dest, (const void *)return_value_gcry_md_read_1, (unsigned long int)return_value_gcry_md_get_algo_dlen_2);
}

// dst_noop
// file ../common/turbojpeg.c line 457
static void dst_noop(struct jpeg_compress_struct *cinfo)
{
  ;
}

// empty_output_buffer
// file ../common/turbojpeg.c line 451
static signed int empty_output_buffer(struct jpeg_compress_struct *cinfo)
{
  cinfo->err->msg_code = 23;
  cinfo->err->error_exit((struct jpeg_common_struct *)cinfo);
  return 1;
}

// encodingName
// file ../rfb/rfb.h line 1064
extern char * encodingName(unsigned int type, char *buf, signed int len)
{
  if(buf == ((char *)NULL))
    return "error";

  else
  {
    switch(type)
    {
      case (unsigned int)0:
      {
        snprintf(buf, (unsigned long int)len, "raw");
        break;
      }
      case (unsigned int)1:
      {
        snprintf(buf, (unsigned long int)len, "copyRect");
        break;
      }
      case (unsigned int)2:
      {
        snprintf(buf, (unsigned long int)len, "RRE");
        break;
      }
      case (unsigned int)4:
      {
        snprintf(buf, (unsigned long int)len, "CoRRE");
        break;
      }
      case (unsigned int)5:
      {
        snprintf(buf, (unsigned long int)len, "hextile");
        break;
      }
      case (unsigned int)6:
      {
        snprintf(buf, (unsigned long int)len, "zlib");
        break;
      }
      case (unsigned int)7:
      {
        snprintf(buf, (unsigned long int)len, "tight");
        break;
      }
      case 0xFFFFFEFC:
      {
        snprintf(buf, (unsigned long int)len, "tightPng");
        break;
      }
      case (unsigned int)8:
      {
        snprintf(buf, (unsigned long int)len, "zlibhex");
        break;
      }
      case (unsigned int)9:
      {
        snprintf(buf, (unsigned long int)len, "ultra");
        break;
      }
      case (unsigned int)16:
      {
        snprintf(buf, (unsigned long int)len, "ZRLE");
        break;
      }
      case (unsigned int)17:
      {
        snprintf(buf, (unsigned long int)len, "ZYWRLE");
        break;
      }
      case 0xFFFF0000:
      {
        snprintf(buf, (unsigned long int)len, "cache");
        break;
      }
      case 0xFFFF0001:
      {
        snprintf(buf, (unsigned long int)len, "cacheEnable");
        break;
      }
      case 0xFFFF0002:
      {
        snprintf(buf, (unsigned long int)len, "xorZlib");
        break;
      }
      case 0xFFFF0003:
      {
        snprintf(buf, (unsigned long int)len, "xorMonoZlib");
        break;
      }
      case 0xFFFF0004:
      {
        snprintf(buf, (unsigned long int)len, "xorColorZlib");
        break;
      }
      case 0xFFFF0005:
      {
        snprintf(buf, (unsigned long int)len, "solidColor");
        break;
      }
      case 0xFFFF0006:
      {
        snprintf(buf, (unsigned long int)len, "xorEnable");
        break;
      }
      case 0xFFFF0007:
      {
        snprintf(buf, (unsigned long int)len, "cacheZip");
        break;
      }
      case 0xFFFF0008:
      {
        snprintf(buf, (unsigned long int)len, "monoZip");
        break;
      }
      case 0xFFFF0009:
      {
        snprintf(buf, (unsigned long int)len, "ultraZip");
        break;
      }
      case 0xFFFFFF10:
      {
        snprintf(buf, (unsigned long int)len, "Xcursor");
        break;
      }
      case 0xFFFFFF11:
      {
        snprintf(buf, (unsigned long int)len, "RichCursor");
        break;
      }
      case 0xFFFFFF18:
      {
        snprintf(buf, (unsigned long int)len, "PointerPos");
        break;
      }
      case 0xFFFFFF20:
      {
        snprintf(buf, (unsigned long int)len, "LastRect");
        break;
      }
      case 0xFFFFFF21:
      {
        snprintf(buf, (unsigned long int)len, "NewFBSize");
        break;
      }
      case 0xFFFE0000:
      {
        snprintf(buf, (unsigned long int)len, "LedState");
        break;
      }
      case 0xFFFE0001:
      {
        snprintf(buf, (unsigned long int)len, "SupportedMessage");
        break;
      }
      case 0xFFFE0002:
      {
        snprintf(buf, (unsigned long int)len, "SupportedEncoding");
        break;
      }
      case 0xFFFE0003:
      {
        snprintf(buf, (unsigned long int)len, "ServerIdentify");
        break;
      }
      case 0xFFFFFF00:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel0");
        break;
      }
      case 0xFFFFFF01:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel1");
        break;
      }
      case 0xFFFFFF02:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel2");
        break;
      }
      case 0xFFFFFF03:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel3");
        break;
      }
      case 0xFFFFFF04:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel4");
        break;
      }
      case 0xFFFFFF05:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel5");
        break;
      }
      case 0xFFFFFF06:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel6");
        break;
      }
      case 0xFFFFFF07:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel7");
        break;
      }
      case 0xFFFFFF08:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel8");
        break;
      }
      case 0xFFFFFF09:
      {
        snprintf(buf, (unsigned long int)len, "CompressLevel9");
        break;
      }
      case 0xFFFFFFE0:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel0");
        break;
      }
      case 0xFFFFFFE1:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel1");
        break;
      }
      case 0xFFFFFFE2:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel2");
        break;
      }
      case 0xFFFFFFE3:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel3");
        break;
      }
      case 0xFFFFFFE4:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel4");
        break;
      }
      case 0xFFFFFFE5:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel5");
        break;
      }
      case 0xFFFFFFE6:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel6");
        break;
      }
      case 0xFFFFFFE7:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel7");
        break;
      }
      case 0xFFFFFFE8:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel8");
        break;
      }
      case 0xFFFFFFE9:
      {
        snprintf(buf, (unsigned long int)len, "QualityLevel9");
        break;
      }
      default:
        snprintf(buf, (unsigned long int)len, "Enc(0x%08X)", type);
    }
    return buf;
  }
}

// fill_input_buffer
// file ../common/turbojpeg.c line 629
static signed int fill_input_buffer(struct jpeg_decompress_struct *dinfo)
{
  dinfo->err->msg_code = 23;
  dinfo->err->error_exit((struct jpeg_common_struct *)dinfo);
  return 1;
}

// generate_dh_params
// file rfbssl_gnutls.c line 69
static signed int generate_dh_params(struct rfbssl_ctx *ctx)
{
  signed int ret;
  ret=gnutls_dh_params_init(&ctx->dh_params);
  if(ret == 0)
    ret=gnutls_dh_params_generate2(ctx->dh_params, (unsigned int)1024);

  return ret;
}

// getBgColour
// file corre.c line 302
static unsigned int getBgColour(char *data, signed int size, signed int bpp)
{
  signed int i;
  signed int getBgColour__1__j;
  signed int k;
  signed int maxcount = 0;
  unsigned char maxclr = (unsigned char)0;
  if(!(bpp == 8))
  {
    if(bpp == 16)
      return (unsigned int)((unsigned short int *)data)[(signed long int)0];

    if(bpp == 32)
      return ((unsigned int *)data)[(signed long int)0];

    rfbLog("getBgColour: bpp %d?\n", bpp);
    return (unsigned int)0;
  }

  else
  {
    i = 0;
    static signed int counts[256l];
    for( ; !(i >= 256); i = i + 1)
      counts[(signed long int)i] = 0;
    getBgColour__1__j = 0;
    for( ; !(getBgColour__1__j >= size); getBgColour__1__j = getBgColour__1__j + 1)
    {
      k = (signed int)((unsigned char *)data)[(signed long int)getBgColour__1__j];
      if(k >= 256)
      {
        rfbLog("getBgColour: unusual colour = %d\n", k);
        return (unsigned int)0;
      }

      counts[(signed long int)k] = counts[(signed long int)k] + 1;
      if(!(maxcount >= counts[(signed long int)k]))
      {
        maxcount = counts[(signed long int)k];
        maxclr = ((unsigned char *)data)[(signed long int)getBgColour__1__j];
      }

    }
    return (unsigned int)maxclr;
  }
}

// getBgColour_link1
// file rre.c line 269
static unsigned int getBgColour_link1(char *data_link1, signed int size_link1, signed int bpp_link1)
{
  signed int i_link1;
  signed int j_link1;
  signed int k_link1;
  signed int maxcount_link1 = 0;
  unsigned char maxclr_link1 = (unsigned char)0;
  if(!(bpp_link1 == 8))
  {
    if(bpp_link1 == 16)
      return (unsigned int)((unsigned short int *)data_link1)[(signed long int)0];

    if(bpp_link1 == 32)
      return ((unsigned int *)data_link1)[(signed long int)0];

    rfbLog("getBgColour: bpp %d?\n", bpp_link1);
    return (unsigned int)0;
  }

  else
  {
    i_link1 = 0;
    static signed int counts_link1[256l];
    for( ; !(i_link1 >= 256); i_link1 = i_link1 + 1)
      counts_link1[(signed long int)i_link1] = 0;
    j_link1 = 0;
    for( ; !(j_link1 >= size_link1); j_link1 = j_link1 + 1)
    {
      k_link1 = (signed int)((unsigned char *)data_link1)[(signed long int)j_link1];
      if(k_link1 >= 256)
      {
        rfbErr("getBgColour: unusual colour = %d\n", k_link1);
        return (unsigned int)0;
      }

      counts_link1[(signed long int)k_link1] = counts_link1[(signed long int)k_link1] + 1;
      if(!(maxcount_link1 >= counts_link1[(signed long int)k_link1]))
      {
        maxcount_link1 = counts_link1[(signed long int)k_link1];
        maxclr_link1 = ((unsigned char *)data_link1)[(signed long int)j_link1];
      }

    }
    return (unsigned int)maxclr_link1;
  }
}

// getPixelFormat
// file ../common/turbojpeg.c line 116
static signed int getPixelFormat(signed int pixelSize, signed int flags)
{
  if(pixelSize == 1)
    return 6;

  else
    if(pixelSize == 3)
    {
      if(!((1 & flags) == 0))
        return 1;

      return 0;
    }

    else
      if(pixelSize == 4)
      {
        if(!((64 & flags) == 0))
        {
          if(!((1 & flags) == 0))
            return 4;

          else
            return 5;
        }

        if(!((1 & flags) == 0))
          return 3;

        return 2;
      }

      else
        return -1;
}

// getSubsamp
// file ../common/turbojpeg.c line 259
static signed int getSubsamp(struct jpeg_decompress_struct *dinfo)
{
  signed int retval = -1;
  signed int i;
  signed int k;
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    if(dinfo->num_components == pixelsize[(signed long int)i])
    {
      if(dinfo->comp_info->h_samp_factor == tjMCUWidth[(signed long int)i] / 8)
      {
        if(dinfo->comp_info->v_samp_factor == tjMCUHeight[(signed long int)i] / 8)
        {
          signed int match = 0;
          k = 1;
          for( ; !(k >= dinfo->num_components); k = k + 1)
            if((dinfo->comp_info + (signed long int)k)->h_samp_factor == 1)
            {
              if((dinfo->comp_info + (signed long int)k)->v_samp_factor == 1)
                match = match + 1;

            }

          if(match == dinfo->num_components + -1)
          {
            retval = i;
            break;
          }

        }

      }

    }

  return retval;
}

// handleMessage
// file tightvnc-filetransfer/rfbtightserver.c line 373
static signed char handleMessage(struct _rfbClientRec *cl, const char *messageName, void (*handler)(struct _rfbClientRec *, struct _rfbTightClientRec *))
{
  struct _rfbTightClientRec *data;
  rfbLog("tightvnc-filetransfer: %s message received\n", messageName);
  signed char return_value_IsFileTransferEnabled_1;
  return_value_IsFileTransferEnabled_1=IsFileTransferEnabled();
  _Bool tmp_if_expr_2;
  if((signed int)return_value_IsFileTransferEnabled_1 == 0)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->viewOnly == -1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    data=rfbGetTightClientData(cl);
    if(data == ((struct _rfbTightClientRec *)NULL))
      return (signed char)0;

    else
    {
      handler(cl, data);
      return (signed char)-1;
    }
  }
}

// httpCloseSock
// file httpd.c line 258
static void httpCloseSock(struct _rfbScreenInfo *rfbScreen)
{
  close(rfbScreen->httpSock);
  rfbScreen->httpSock = -1;
  buf_filled = (unsigned long int)0;
}

// httpProcessInput
// file httpd.c line 272
static void httpProcessInput(struct _rfbScreenInfo *rfbScreen)
{
  struct sockaddr_storage addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  char fullFname[512l];
  char params[1024l];
  char *ptr;
  char *fname;
  unsigned int maxFnameLen;
  struct _IO_FILE *fd;
  signed char performSubstitutions = (signed char)0;
  char str[288l];
  char *user;
  user=getenv("USER");
  cl.sock = rfbScreen->httpSock;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(rfbScreen->httpDir);
  _Bool tmp_if_expr_7;
  char *return_value_strstr_6;
  _Bool tmp_if_expr_9;
  char *return_value_strstr_8;
  _Bool tmp_if_expr_11;
  char *return_value_strstr_10;
  char *return_value_strchr_18;
  signed int return_value_strncmp_19;
  unsigned long int return_value_strlen_29;
  signed int return_value_strcmp_30;
  unsigned long int return_value_strlen_33;
  unsigned long int return_value_strlen_34;
  signed char return_value_compareAndSkip_54;
  signed char return_value_compareAndSkip_53;
  signed char return_value_compareAndSkip_52;
  signed char return_value_compareAndSkip_51;
  signed char return_value_compareAndSkip_50;
  signed char return_value_compareAndSkip_49;
  signed char return_value_compareAndSkip_48;
  signed char return_value_compareAndSkip_47;
  unsigned long int return_value_strlen_44;
  if(return_value_strlen_1 >= 256ul)
  {
    rfbErr("-httpd directory too long\n");
    httpCloseSock(rfbScreen);
  }

  else
  {
    strcpy(fullFname, rfbScreen->httpDir);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(fullFname);
    fname = &fullFname[(signed long int)return_value_strlen_2];
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(fullFname);
    maxFnameLen = (unsigned int)((unsigned long int)511 - return_value_strlen_3);
    buf_filled = (unsigned long int)0;
    while((_Bool)1)
    {
      signed long int got;
      if(buf_filled >= 32769ul)
      {
        rfbErr("httpProcessInput: HTTP request is too long\n");
        httpCloseSock(rfbScreen);
      }

      got=read(rfbScreen->httpSock, (void *)(buf + (signed long int)buf_filled), (sizeof(char [32768l]) /*32768ul*/  - buf_filled) - (unsigned long int)1);
      if(!(got >= 1l))
      {
        if(got == 0l)
          rfbErr("httpd: premature connection close\n");

        else
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(*return_value___errno_location_4 == 11)
            goto __CPROVER_DUMP_L55;

          rfbLogPerror("httpProcessInput: read");
        }
        httpCloseSock(rfbScreen);
        goto __CPROVER_DUMP_L55;
      }

      buf_filled = buf_filled + (unsigned long int)got;
      buf[(signed long int)buf_filled] = (char)0;
      char *return_value_strstr_5;
      return_value_strstr_5=strstr(buf, "\r\r");
      if(!(return_value_strstr_5 == ((char *)NULL)))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strstr_6=strstr(buf, "\n\n");
        tmp_if_expr_7 = return_value_strstr_6 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_strstr_8=strstr(buf, "\r\n\r\n");
        tmp_if_expr_9 = return_value_strstr_8 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_strstr_10=strstr(buf, "\n\r\n\r");
        tmp_if_expr_11 = return_value_strstr_10 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        break;

    }
    if(!(rfbScreen->httpEnableProxyConnect == 0))
    {
      signed int return_value_strncmp_16;
      return_value_strncmp_16=strncmp(buf, "CONNECT ", (unsigned long int)8);
      static const char *PROXY_OK_STR = "HTTP/1.0 200 OK\r\nContent-Type: octet-stream\r\nPragma: no-cache\r\n\r\n";
      if(return_value_strncmp_16 == 0)
      {
        char *return_value_strchr_13;
        return_value_strchr_13=strchr(buf, 58);
        signed int return_value_atoi_14;
        return_value_atoi_14=atoi(return_value_strchr_13 + (signed long int)1);
        if(!(return_value_atoi_14 == rfbScreen->port))
        {
          rfbErr("httpd: CONNECT format invalid.\n");
          unsigned long int return_value_strlen_12;
          return_value_strlen_12=strlen("HTTP/1.0 400 Invalid Request\r\nConnection: close\r\n\r\n<HEAD><TITLE>Invalid Request</TITLE></HEAD>\n<BODY><H1>Invalid request</H1></BODY>\n");
          rfbWriteExact(&cl, "HTTP/1.0 400 Invalid Request\r\nConnection: close\r\n\r\n<HEAD><TITLE>Invalid Request</TITLE></HEAD>\n<BODY><H1>Invalid request</H1></BODY>\n", (signed int)return_value_strlen_12);
          httpCloseSock(rfbScreen);
        }

        rfbLog("httpd: client asked for CONNECT\n");
        unsigned long int return_value_strlen_15;
        return_value_strlen_15=strlen(PROXY_OK_STR);
        rfbWriteExact(&cl, PROXY_OK_STR, (signed int)return_value_strlen_15);
        rfbNewClientConnection(rfbScreen, rfbScreen->httpSock);
        rfbScreen->httpSock = -1;
      }

      signed int return_value_strncmp_20;
      return_value_strncmp_20=strncmp(buf, "GET ", (unsigned long int)4);
      if(return_value_strncmp_20 == 0)
      {
        return_value_strchr_18=strchr(buf, 47);
        return_value_strncmp_19=strncmp(return_value_strchr_18, "/proxied.connection HTTP/1.", (unsigned long int)27);
        if(return_value_strncmp_19 == 0)
        {
          rfbLog("httpd: client asked for /proxied.connection\n");
          unsigned long int return_value_strlen_17;
          return_value_strlen_17=strlen(PROXY_OK_STR);
          rfbWriteExact(&cl, PROXY_OK_STR, (signed int)return_value_strlen_17);
          rfbNewClientConnection(rfbScreen, rfbScreen->httpSock);
          rfbScreen->httpSock = -1;
        }

      }

    }

    signed int return_value_strncmp_22;
    return_value_strncmp_22=strncmp(buf, "GET ", (unsigned long int)4);
    if(!(return_value_strncmp_22 == 0))
    {
      rfbErr("httpd: no GET line\n");
      httpCloseSock(rfbScreen);
    }

    else
    {
      unsigned long int return_value_strcspn_21;
      return_value_strcspn_21=strcspn(buf, "\n\r");
      buf[(signed long int)return_value_strcspn_21] = (char)0;
    }
    unsigned long int return_value_strlen_23;
    return_value_strlen_23=strlen(buf);
    if(!((unsigned long int)maxFnameLen >= return_value_strlen_23))
    {
      rfbErr("httpd: GET line too long\n");
      httpCloseSock(rfbScreen);
    }

    else
    {
      signed int return_value_sscanf_24;
      return_value_sscanf_24=sscanf(buf, "GET %s HTTP/1.", fname);
      if(!(return_value_sscanf_24 == 1))
      {
        rfbErr("httpd: couldn't parse GET line\n");
        httpCloseSock(rfbScreen);
      }

      else
      {
        if(!((signed int)*fname == 47))
        {
          rfbErr("httpd: filename didn't begin with '/'\n");
          unsigned long int return_value_strlen_25;
          return_value_strlen_25=strlen("HTTP/1.0 404 Not found\r\nConnection: close\r\n\r\n<HEAD><TITLE>File Not Found</TITLE></HEAD>\n<BODY><H1>File Not Found</H1></BODY>\n");
          rfbWriteExact(&cl, "HTTP/1.0 404 Not found\r\nConnection: close\r\n\r\n<HEAD><TITLE>File Not Found</TITLE></HEAD>\n<BODY><H1>File Not Found</H1></BODY>\n", (signed int)return_value_strlen_25);
          httpCloseSock(rfbScreen);
        }

        getpeername(rfbScreen->httpSock, (struct sockaddr *)&addr, &addrlen);
        char host[1024l];
        signed int return_value_getnameinfo_26;
        return_value_getnameinfo_26=getnameinfo((struct sockaddr *)&addr, addrlen, host, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , (char *)(void *)0, (unsigned int)0, 1);
        if(!(return_value_getnameinfo_26 == 0))
          rfbLogPerror("httpProcessInput: error in getnameinfo");

        rfbLog("httpd: get '%s' for %s\n", fname + (signed long int)1, (const void *)host);
        params[(signed long int)0] = (char)0;
        ptr=strchr(fname, 63);
        if(!(ptr == ((char *)NULL)))
        {
          *ptr = (char)0;
          signed char return_value_parseParams_27;
          return_value_parseParams_27=parseParams(&ptr[(signed long int)1], params, 1024);
          if(return_value_parseParams_27 == 0)
          {
            params[(signed long int)0] = (char)0;
            rfbErr("httpd: bad parameters in the URL\n");
          }

        }

        signed int return_value_strcmp_28;
        return_value_strcmp_28=strcmp(fname, "/");
        if(return_value_strcmp_28 == 0)
        {
          strcpy(fname, "/index.vnc");
          rfbLog("httpd: defaulting to '%s'\n", fname + (signed long int)1);
        }

        unsigned long int return_value_strlen_31;
        return_value_strlen_31=strlen(fname);
        if(return_value_strlen_31 >= 4ul)
        {
          return_value_strlen_29=strlen(fname);
          return_value_strcmp_30=strcmp(&fname[(signed long int)(return_value_strlen_29 - (unsigned long int)4)], ".vnc");
          if(return_value_strcmp_30 == 0)
            performSubstitutions = (signed char)-1;

        }

        fd=fopen(fullFname, "r");
        if(fd == ((struct _IO_FILE *)NULL))
        {
          rfbLogPerror("httpProcessInput: open");
          unsigned long int return_value_strlen_32;
          return_value_strlen_32=strlen("HTTP/1.0 404 Not found\r\nConnection: close\r\n\r\n<HEAD><TITLE>File Not Found</TITLE></HEAD>\n<BODY><H1>File Not Found</H1></BODY>\n");
          rfbWriteExact(&cl, "HTTP/1.0 404 Not found\r\nConnection: close\r\n\r\n<HEAD><TITLE>File Not Found</TITLE></HEAD>\n<BODY><H1>File Not Found</H1></BODY>\n", (signed int)return_value_strlen_32);
          httpCloseSock(rfbScreen);
        }

        if(!(performSubstitutions == 0))
        {
          return_value_strlen_33=strlen("HTTP/1.0 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n");
          rfbWriteExact(&cl, "HTTP/1.0 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n", (signed int)return_value_strlen_33);
        }

        else
        {
          return_value_strlen_34=strlen("HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n");
          rfbWriteExact(&cl, "HTTP/1.0 200 OK\r\nConnection: close\r\n\r\n", (signed int)return_value_strlen_34);
        }
        {
          signed int n;
          unsigned long int return_value_fread_35;
          return_value_fread_35=fread((void *)buf, (unsigned long int)1, (unsigned long int)(32768 - 1), fd);
          n = (signed int)return_value_fread_35;
          if(!(n >= 0))
          {
            rfbLogPerror("httpProcessInput: read");
            fclose(fd);
            httpCloseSock(rfbScreen);
          }

          if(!(n == 0))
          {
            if(!(performSubstitutions == 0))
            {
              char *httpProcessInput__1__14__2__ptr = buf;
              char *dollar;
              buf[(signed long int)n] = (char)0;
              dollar=strchr(httpProcessInput__1__14__2__ptr, 36);
              if(!(dollar == ((char *)NULL)))
              {
                rfbWriteExact(&cl, httpProcessInput__1__14__2__ptr, (signed int)(dollar - httpProcessInput__1__14__2__ptr));
                httpProcessInput__1__14__2__ptr = dollar;
                signed char return_value_compareAndSkip_55;
                return_value_compareAndSkip_55=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_WIDTH");
                if(!(return_value_compareAndSkip_55 == 0))
                {
                  sprintf(str, "%d", rfbScreen->width);
                  unsigned long int return_value_strlen_36;
                  return_value_strlen_36=strlen(str);
                  rfbWriteExact(&cl, str, (signed int)return_value_strlen_36);
                }

                else
                {
                  return_value_compareAndSkip_54=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_HEIGHT");
                  if(!(return_value_compareAndSkip_54 == 0))
                  {
                    sprintf(str, "%d", rfbScreen->height);
                    unsigned long int return_value_strlen_37;
                    return_value_strlen_37=strlen(str);
                    rfbWriteExact(&cl, str, (signed int)return_value_strlen_37);
                  }

                  else
                  {
                    return_value_compareAndSkip_53=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_APPLETWIDTH");
                    if(!(return_value_compareAndSkip_53 == 0))
                    {
                      sprintf(str, "%d", rfbScreen->width);
                      unsigned long int return_value_strlen_38;
                      return_value_strlen_38=strlen(str);
                      rfbWriteExact(&cl, str, (signed int)return_value_strlen_38);
                    }

                    else
                    {
                      return_value_compareAndSkip_52=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_APPLETHEIGHT");
                      if(!(return_value_compareAndSkip_52 == 0))
                      {
                        sprintf(str, "%d", rfbScreen->height + 32);
                        unsigned long int return_value_strlen_39;
                        return_value_strlen_39=strlen(str);
                        rfbWriteExact(&cl, str, (signed int)return_value_strlen_39);
                      }

                      else
                      {
                        return_value_compareAndSkip_51=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_PORT");
                        if(!(return_value_compareAndSkip_51 == 0))
                        {
                          sprintf(str, "%d", rfbScreen->port);
                          unsigned long int return_value_strlen_40;
                          return_value_strlen_40=strlen(str);
                          rfbWriteExact(&cl, str, (signed int)return_value_strlen_40);
                        }

                        else
                        {
                          return_value_compareAndSkip_50=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_DESKTOP");
                          if(!(return_value_compareAndSkip_50 == 0))
                          {
                            unsigned long int return_value_strlen_41;
                            return_value_strlen_41=strlen(rfbScreen->desktopName);
                            rfbWriteExact(&cl, rfbScreen->desktopName, (signed int)return_value_strlen_41);
                          }

                          else
                          {
                            return_value_compareAndSkip_49=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_DISPLAY");
                            if(!(return_value_compareAndSkip_49 == 0))
                            {
                              sprintf(str, "%s:%d", (const void *)rfbScreen->thisHost, rfbScreen->port - 5900);
                              unsigned long int return_value_strlen_42;
                              return_value_strlen_42=strlen(str);
                              rfbWriteExact(&cl, str, (signed int)return_value_strlen_42);
                            }

                            else
                            {
                              return_value_compareAndSkip_48=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_USER");
                              if(!(return_value_compareAndSkip_48 == 0))
                              {
                                if(!(user == ((char *)NULL)))
                                {
                                  unsigned long int return_value_strlen_43;
                                  return_value_strlen_43=strlen(user);
                                  rfbWriteExact(&cl, user, (signed int)return_value_strlen_43);
                                }

                                else
                                  rfbWriteExact(&cl, "?", 1);
                              }

                              else
                              {
                                return_value_compareAndSkip_47=compareAndSkip(&httpProcessInput__1__14__2__ptr, "_PARAMS");
                                if(!(return_value_compareAndSkip_47 == 0))
                                {
                                  if(!((signed int)params[0l] == 0))
                                  {
                                    return_value_strlen_44=strlen(params);
                                    rfbWriteExact(&cl, params, (signed int)return_value_strlen_44);
                                  }

                                }

                                else
                                {
                                  signed char return_value_compareAndSkip_45;
                                  return_value_compareAndSkip_45=compareAndSkip(&httpProcessInput__1__14__2__ptr, "__");
                                  if(return_value_compareAndSkip_45 == 0)
                                    httpProcessInput__1__14__2__ptr = httpProcessInput__1__14__2__ptr + 1l;

                                  signed int return_value_rfbWriteExact_46;
                                  return_value_rfbWriteExact_46=rfbWriteExact(&cl, "_", 1);
                                  if(!(return_value_rfbWriteExact_46 >= 0))
                                  {
                                    fclose(fd);
                                    httpCloseSock(rfbScreen);
                                  }

                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

              signed int return_value_rfbWriteExact_56;
              return_value_rfbWriteExact_56=rfbWriteExact(&cl, httpProcessInput__1__14__2__ptr, (signed int)(&buf[(signed long int)n] - httpProcessInput__1__14__2__ptr));
            }

            else
            {
              signed int return_value_rfbWriteExact_57;
              return_value_rfbWriteExact_57=rfbWriteExact(&cl, buf, n);
            }
          }

        }
        fclose(fd);
        httpCloseSock(rfbScreen);
      }
    }
  }

__CPROVER_DUMP_L55:
  ;
}

// listenerRun
// file main.c line 568
static void * listenerRun(void *data)
{
  struct _rfbScreenInfo *screen = (struct _rfbScreenInfo *)data;
  signed int client_fd;
  struct sockaddr_storage peer;
  struct _rfbClientRec *listenerRun__1__cl = (struct _rfbClientRec *)(void *)0;
  unsigned int len;
  struct anonymous_16 listen_fds;
  while((_Bool)1)
  {
    client_fd = -1;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&listen_fds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    if(screen->listenSock >= 0)
      (&listen_fds)->__fds_bits[(signed long int)(screen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&listen_fds)->__fds_bits[(signed long int)(screen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << screen->listenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    if(screen->listen6Sock >= 0)
      (&listen_fds)->__fds_bits[(signed long int)(screen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&listen_fds)->__fds_bits[(signed long int)(screen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << screen->listen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    signed int return_value_select_1;
    return_value_select_1=select(screen->maxFd + 1, &listen_fds, (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0, (struct timeval *)(void *)0);
    if(return_value_select_1 == -1)
    {
      rfbLogPerror("listenerRun: error in select");
      return (void *)0;
    }

    len = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    if(!((listen_fds.__fds_bits[(signed long int)(screen->listenSock / 8)] & (signed long int)(1UL << screen->listenSock % 8)) == 0l))
      client_fd=accept(screen->listenSock, (struct sockaddr *)&peer, &len);

    else
      if(!((listen_fds.__fds_bits[(signed long int)(screen->listen6Sock / 8)] & (signed long int)(1UL << screen->listen6Sock % 8)) == 0l))
        client_fd=accept(screen->listen6Sock, (struct sockaddr *)&peer, &len);

    if(client_fd >= 0)
      listenerRun__1__cl=rfbNewClient(screen, client_fd);

    if(!(listenerRun__1__cl == ((struct _rfbClientRec *)NULL)))
    {
      if(listenerRun__1__cl->onHold == 0)
        rfbStartOnHoldClient(listenerRun__1__cl);

    }

  }
  return (void *)0;
}

// lzo1x_1_compress
// file ../common/minilzo.c line 4884
extern signed int lzo1x_1_compress(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, void *wrkmem)
{
  const unsigned char *ip = in;
  unsigned char *op = out;
  unsigned long int l = in_len;
  unsigned long int t = (unsigned long int)0;
  while(l >= 21ul)
  {
    unsigned long int ll = l;
    unsigned long int ll_end;
    ll = ll <= (unsigned long int)49152 ? ll : (unsigned long int)49152;
    ll_end = (unsigned long int)ip + ll;
    if(ip + (signed long int)ll >= (const unsigned char *)((ll + t >> 5) + ll_end) || ll_end >= (ll + t >> 5) + ll_end)
      break;

    lzo_memset(wrkmem, 0, ((unsigned long int)1 << 14) * sizeof(unsigned short int) /*2ul*/ );
    t=lzo1x_1_compress_core(ip, ll, op, out_len, t, wrkmem);
    ip = ip + (signed long int)ll;
    op = op + (signed long int)*out_len;
    l = l - ll;
  }
  t = t + l;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  if(t >= 1ul)
  {
    const unsigned char *ii = (in + (signed long int)in_len) - (signed long int)t;
    if(op == out && !(t >= 239ul))
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)((unsigned long int)17 + t);
    }

    else
      if(!(t >= 4ul))
        op[(signed long int)-2] = (unsigned char)((unsigned long int)op[(signed long int)-2] | t);

      else
        if(!(t >= 19ul))
        {
          tmp_post_2 = op;
          op = op + 1l;
          *tmp_post_2 = (unsigned char)(t - (unsigned long int)3);
        }

        else
        {
          unsigned long int tt = t - (unsigned long int)18;
          tmp_post_3 = op;
          op = op + 1l;
          *tmp_post_3 = (unsigned char)0;
          for( ; tt >= 256ul; op = op + 1l)
          {
            tt = tt - (unsigned long int)255;
            do
            {
              volatile unsigned char *d__1 = (volatile unsigned char *)(void *)op;
              d__1[(signed long int)0] = (unsigned char)0;
            }
            while((_Bool)0);
          }
          tmp_post_4 = op;
          op = op + 1l;
          *tmp_post_4 = (unsigned char)tt;
        }
    do
    {
      unsigned char *d__n = (unsigned char *)(void *)op;
      const unsigned char *s__n = (const unsigned char *)(const void *)ii;
      unsigned long int n__n = t;
      for( ; n__n >= 8ul; n__n = n__n - (unsigned long int)8)
      {
        *((volatile unsigned long int *)(void *)d__n) = *((const volatile unsigned long int *)(const void *)s__n);
        d__n = d__n + (signed long int)8;
        s__n = s__n + (signed long int)8;
      }
      if(n__n >= 4ul)
      {
        *((volatile unsigned int *)(void *)d__n) = *((const volatile unsigned int *)(const void *)s__n);
        d__n = d__n + (signed long int)4;
        s__n = s__n + (signed long int)4;
        n__n = n__n - (unsigned long int)4;
      }

      if(n__n >= 1ul)
        do
        {
          tmp_post_5 = d__n;
          d__n = d__n + 1l;
          tmp_post_6 = s__n;
          s__n = s__n + 1l;
          *tmp_post_5 = *tmp_post_6;
          n__n = n__n - 1ul;
        }
        while(n__n >= 1ul);

    }
    while((_Bool)0);
    op = op + (signed long int)t;
  }

  unsigned char *tmp_post_7 = op;
  op = op + 1l;
  *tmp_post_7 = (unsigned char)(16 | 1);
  unsigned char *tmp_post_8 = op;
  op = op + 1l;
  *tmp_post_8 = (unsigned char)0;
  unsigned char *tmp_post_9 = op;
  op = op + 1l;
  *tmp_post_9 = (unsigned char)0;
  *out_len = (unsigned long int)(op - out);
  return 0;
}

// lzo1x_1_compress_core
// file ../common/minilzo.c line 4597
static unsigned long int lzo1x_1_compress_core(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, unsigned long int ti, void *wrkmem)
{
  const unsigned char *ip;
  unsigned char *op;
  const unsigned char * const in_end = in + (signed long int)in_len;
  const unsigned char * const ip_end = (in + (signed long int)in_len) - (signed long int)20;
  const unsigned char *ii;
  unsigned short int * const dict = (unsigned short int *)wrkmem;
  op = out;
  ip = in;
  ii = ip;
  ip = ip + (signed long int)(ti < (unsigned long int)4 ? (unsigned long int)4 - ti : (unsigned long int)0);
  const unsigned char *m_pos;
  unsigned long int m_off;
  unsigned long int m_len;
  unsigned int dv;
  unsigned long int dindex;
  do
  {

  literal:
    ;
    ip = ip + (signed long int)1 + (ip - ii >> 5);

  next:
    ;
    if(ip >= ip_end)
      goto __CPROVER_DUMP_L30;

    dv = *((const volatile unsigned int *)(const void *)ip);
    dindex = (unsigned long int)(((unsigned long int)((unsigned int)0x1824429d * dv) >> 32 - 14 & (unsigned long int)((1u << 14) - (unsigned int)1 >> 0)) << 0);
    m_pos = in + (signed long int)dict[(signed long int)dindex];
    dict[(signed long int)dindex] = (unsigned short int)(unsigned long int)(ip - in);
  }
  while(!(dv == *((const volatile unsigned int *)m_pos)));
  ii = ii - (signed long int)ti;
  ti = (unsigned long int)0;
  unsigned long int t = (unsigned long int)(ip - ii);
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  const unsigned char *tmp_post_6;
  if(!(t == 0ul))
  {
    if(!(t >= 4ul))
    {
      op[(signed long int)-2] = (unsigned char)((unsigned long int)op[(signed long int)-2] | t);
      *((volatile unsigned int *)(void *)op) = *((const volatile unsigned int *)(const void *)ii);
      op = op + (signed long int)t;
    }

    else
      if(!(t >= 17ul))
      {
        tmp_post_1 = op;
        op = op + 1l;
        *tmp_post_1 = (unsigned char)(t - (unsigned long int)3);
        *((volatile unsigned long int *)(void *)op) = *((const volatile unsigned long int *)(const void *)ii);
        *((volatile unsigned long int *)(void *)(op + (signed long int)8)) = *((const volatile unsigned long int *)(const void *)(ii + (signed long int)8));
        op = op + (signed long int)t;
      }

      else
      {
        if(!(t >= 19ul))
        {
          tmp_post_2 = op;
          op = op + 1l;
          *tmp_post_2 = (unsigned char)(t - (unsigned long int)3);
        }

        else
        {
          unsigned long int tt = t - (unsigned long int)18;
          tmp_post_3 = op;
          op = op + 1l;
          *tmp_post_3 = (unsigned char)0;
          for( ; tt >= 256ul; op = op + 1l)
          {
            tt = tt - (unsigned long int)255;
            do
            {
              volatile unsigned char *lzo1x_1_compress_core__1__1__1__2__1__3__1__1__1__d__1 = (volatile unsigned char *)(void *)op;
              lzo1x_1_compress_core__1__1__1__2__1__3__1__1__1__d__1[(signed long int)0] = (unsigned char)0;
            }
            while((_Bool)0);
          }
          tmp_post_4 = op;
          op = op + 1l;
          *tmp_post_4 = (unsigned char)tt;
        }
        do
        {
          *((volatile unsigned long int *)(void *)op) = *((const volatile unsigned long int *)(const void *)ii);
          *((volatile unsigned long int *)(void *)(op + (signed long int)8)) = *((const volatile unsigned long int *)(const void *)(ii + (signed long int)8));
          op = op + (signed long int)16;
          ii = ii + (signed long int)16;
          t = t - (unsigned long int)16;
        }
        while(t >= 16ul);
        if(t >= 1ul)
          do
          {
            tmp_post_5 = op;
            op = op + 1l;
            tmp_post_6 = ii;
            ii = ii + 1l;
            *tmp_post_5 = *tmp_post_6;
            t = t - 1ul;
          }
          while(t >= 1ul);

      }
  }

  m_len = (unsigned long int)4;
  unsigned long int v = *((const volatile unsigned long int *)(const void *)(ip + (signed long int)m_len)) ^ *((const volatile unsigned long int *)(const void *)(m_pos + (signed long int)m_len));
  if(v == 0ul)
    do
    {
      m_len = m_len + (unsigned long int)8;
      v = *((const volatile unsigned long int *)(const void *)(ip + (signed long int)m_len)) ^ *((const volatile unsigned long int *)(const void *)(m_pos + (signed long int)m_len));
      if(ip + (signed long int)m_len >= ip_end)
        goto m_len_done;

    }
    while(v == 0ul);

  signed int return_value___builtin_ctzl_7;
  return_value___builtin_ctzl_7=__builtin_ctzl(v);
  m_len = m_len + (unsigned long int)((unsigned int)return_value___builtin_ctzl_7 / (unsigned int)8);

m_len_done:
  ;
  m_off = (unsigned long int)(ip - m_pos);
  ip = ip + (signed long int)m_len;
  ii = ip;
  unsigned char *tmp_post_8;
  unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  unsigned char *tmp_post_11;
  unsigned char *tmp_post_12;
  unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  unsigned char *tmp_post_19;
  if(!(m_len >= 9ul) && !(m_off >= 2049ul))
  {
    m_off = m_off - (unsigned long int)1;
    tmp_post_8 = op;
    op = op + 1l;
    *tmp_post_8 = (unsigned char)(m_len - (unsigned long int)1 << 5 | (m_off & (unsigned long int)7) << 2);
    tmp_post_9 = op;
    op = op + 1l;
    *tmp_post_9 = (unsigned char)(m_off >> 3);
  }

  else
    if(!(m_off >= 16385ul))
    {
      m_off = m_off - (unsigned long int)1;
      if(!(m_len >= 34ul))
      {
        tmp_post_10 = op;
        op = op + 1l;
        *tmp_post_10 = (unsigned char)((unsigned long int)32 | m_len - (unsigned long int)2);
      }

      else
      {
        m_len = m_len - (unsigned long int)33;
        tmp_post_11 = op;
        op = op + 1l;
        *tmp_post_11 = (unsigned char)(32 | 0);
        for( ; m_len >= 256ul; op = op + 1l)
        {
          m_len = m_len - (unsigned long int)255;
          do
          {
            volatile unsigned char *d__1 = (volatile unsigned char *)(void *)op;
            d__1[(signed long int)0] = (unsigned char)0;
          }
          while((_Bool)0);
        }
        tmp_post_12 = op;
        op = op + 1l;
        *tmp_post_12 = (unsigned char)m_len;
      }
      tmp_post_13 = op;
      op = op + 1l;
      *tmp_post_13 = (unsigned char)(m_off << 2);
      tmp_post_14 = op;
      op = op + 1l;
      *tmp_post_14 = (unsigned char)(m_off >> 6);
    }

    else
    {
      m_off = m_off - (unsigned long int)0x4000;
      if(!(m_len >= 10ul))
      {
        tmp_post_15 = op;
        op = op + 1l;
        *tmp_post_15 = (unsigned char)((unsigned long int)16 | m_off >> 11 & (unsigned long int)8 | m_len - (unsigned long int)2);
      }

      else
      {
        m_len = m_len - (unsigned long int)9;
        tmp_post_16 = op;
        op = op + 1l;
        *tmp_post_16 = (unsigned char)((unsigned long int)16 | m_off >> 11 & (unsigned long int)8);
        for( ; m_len >= 256ul; op = op + 1l)
        {
          m_len = m_len - (unsigned long int)255;
          do
          {
            volatile unsigned char *lzo1x_1_compress_core__1__1__1__6__1__1__1__d__1 = (volatile unsigned char *)(void *)op;
            lzo1x_1_compress_core__1__1__1__6__1__1__1__d__1[(signed long int)0] = (unsigned char)0;
          }
          while((_Bool)0);
        }
        tmp_post_17 = op;
        op = op + 1l;
        *tmp_post_17 = (unsigned char)m_len;
      }
      tmp_post_18 = op;
      op = op + 1l;
      *tmp_post_18 = (unsigned char)(m_off << 2);
      tmp_post_19 = op;
      op = op + 1l;
      *tmp_post_19 = (unsigned char)(m_off >> 6);
    }
  goto next;

__CPROVER_DUMP_L30:
  ;
  *out_len = (unsigned long int)(op - out);
  return (unsigned long int)(in_end - (ii - (signed long int)ti));
}

// lzo1x_decompress
// file ../common/minilzo.c line 5067
extern signed int lzo1x_decompress(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, void *wrkmem)
{
  unsigned char *op;
  const unsigned char *ip;
  unsigned long int t;
  const unsigned char *m_pos;
  const unsigned char * const ip_end = in + (signed long int)in_len;
  (void)wrkmem;
  *out_len = (unsigned long int)0;
  op = out;
  ip = in;
  const unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  const unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  const unsigned char *tmp_post_11;
  if((signed int)*ip >= 18)
  {
    tmp_post_1 = ip;
    ip = ip + 1l;
    t = (unsigned long int)((signed int)*tmp_post_1 - 17);
    if(!(t >= 4ul))
      goto match_next;

    do
    {
      tmp_post_2 = op;
      op = op + 1l;
      tmp_post_3 = ip;
      ip = ip + 1l;
      *tmp_post_2 = *tmp_post_3;
      t = t - 1ul;
    }
    while(t >= 1ul);
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    tmp_post_4 = ip;
    ip = ip + 1l;
    t = (unsigned long int)*tmp_post_4;
    if(t >= 16ul)
      goto match;

    if(t == 0ul)
    {
      for( ; (signed int)*ip == 0; ip = ip + 1l)
        t = t + (unsigned long int)255;
      tmp_post_5 = ip;
      ip = ip + 1l;
      t = t + (unsigned long int)(15 + (signed int)*tmp_post_5);
    }

    t = t + (unsigned long int)3;
    if(t >= 8ul)
      do
      {
        *((volatile unsigned long int *)(void *)op) = *((const volatile unsigned long int *)(const void *)ip);
        op = op + (signed long int)8;
        ip = ip + (signed long int)8;
        t = t - (unsigned long int)8;
      }
      while(t >= 8ul);

    if(t >= 4ul)
    {
      *((volatile unsigned int *)(void *)op) = *((const volatile unsigned int *)(const void *)ip);
      op = op + (signed long int)4;
      ip = ip + (signed long int)4;
      t = t - (unsigned long int)4;
    }

    if(t >= 1ul)
    {
      tmp_post_6 = op;
      op = op + 1l;
      tmp_post_7 = ip;
      ip = ip + 1l;
      *tmp_post_6 = *tmp_post_7;
      if(t >= 2ul)
      {
        tmp_post_8 = op;
        op = op + 1l;
        tmp_post_9 = ip;
        ip = ip + 1l;
        *tmp_post_8 = *tmp_post_9;
        if(t >= 3ul)
        {
          tmp_post_10 = op;
          op = op + 1l;
          tmp_post_11 = ip;
          ip = ip + 1l;
          *tmp_post_10 = *tmp_post_11;
        }

      }

    }

  }

first_literal_run:
  ;
  const unsigned char *tmp_post_12 = ip;
  ip = ip + 1l;
  t = (unsigned long int)*tmp_post_12;
  const unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  const unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  const unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  const unsigned char *tmp_post_19;
  const unsigned char *tmp_post_20;
  const unsigned char *tmp_post_21;
  const unsigned char *tmp_post_22;
  unsigned char *tmp_post_23;
  const unsigned char *tmp_post_24;
  unsigned char *tmp_post_25;
  unsigned char *tmp_post_26;
  unsigned char *tmp_post_27;
  unsigned char *tmp_post_28;
  unsigned char *tmp_post_29;
  const unsigned char *tmp_post_30;
  unsigned char *tmp_post_31;
  const unsigned char *tmp_post_32;
  unsigned char *tmp_post_33;
  const unsigned char *tmp_post_34;
  if(!(t >= 16ul))
  {
    m_pos = op - (signed long int)(1 + 0x0800);
    m_pos = m_pos - (signed long int)(t >> 2);
    tmp_post_13 = ip;
    ip = ip + 1l;
    m_pos = m_pos - (signed long int)((signed int)*tmp_post_13 << 2);
    tmp_post_14 = op;
    op = op + 1l;
    tmp_post_15 = m_pos;
    m_pos = m_pos + 1l;
    *tmp_post_14 = *tmp_post_15;
    tmp_post_16 = op;
    op = op + 1l;
    tmp_post_17 = m_pos;
    m_pos = m_pos + 1l;
    *tmp_post_16 = *tmp_post_17;
    tmp_post_18 = op;
    op = op + 1l;
    *tmp_post_18 = *m_pos;
  }

  else
  {

  match:
    ;
    if(t >= 64ul)
    {
      m_pos = op - (signed long int)1;
      m_pos = m_pos - (signed long int)(t >> 2 & (unsigned long int)7);
      tmp_post_19 = ip;
      ip = ip + 1l;
      m_pos = m_pos - (signed long int)((signed int)*tmp_post_19 << 3);
      t = (t >> 5) - (unsigned long int)1;
      goto copy_match;
    }

    else
      if(t >= 32ul)
      {
        t = t & (unsigned long int)31;
        if(t == 0ul)
        {
          for( ; (signed int)*ip == 0; ip = ip + 1l)
            t = t + (unsigned long int)255;
          tmp_post_20 = ip;
          ip = ip + 1l;
          t = t + (unsigned long int)(31 + (signed int)*tmp_post_20);
        }

        m_pos = op - (signed long int)1;
        m_pos = m_pos - (signed long int)((signed int)*((const volatile unsigned short int *)(const void *)ip) >> 2);
        ip = ip + (signed long int)2;
      }

      else
        if(t >= 16ul)
        {
          m_pos = op;
          m_pos = m_pos - (signed long int)((t & (unsigned long int)8) << 11);
          t = t & (unsigned long int)7;
          if(t == 0ul)
          {
            for( ; (signed int)*ip == 0; ip = ip + 1l)
              t = t + (unsigned long int)255;
            tmp_post_21 = ip;
            ip = ip + 1l;
            t = t + (unsigned long int)(7 + (signed int)*tmp_post_21);
          }

          m_pos = m_pos - (signed long int)((signed int)*((const volatile unsigned short int *)(const void *)ip) >> 2);
          ip = ip + (signed long int)2;
          if(m_pos == op)
            goto eof_found;

          m_pos = m_pos - (signed long int)0x4000;
        }

        else
        {
          m_pos = op - (signed long int)1;
          m_pos = m_pos - (signed long int)(t >> 2);
          tmp_post_22 = ip;
          ip = ip + 1l;
          m_pos = m_pos - (signed long int)((signed int)*tmp_post_22 << 2);
          tmp_post_23 = op;
          op = op + 1l;
          tmp_post_24 = m_pos;
          m_pos = m_pos + 1l;
          *tmp_post_23 = *tmp_post_24;
          tmp_post_25 = op;
          op = op + 1l;
          *tmp_post_25 = *m_pos;
          goto match_done;
        }
    if(op - m_pos >= 8l)
    {
      t = t + (unsigned long int)(3 - 1);
      if(t >= 8ul)
        do
        {
          *((volatile unsigned long int *)(void *)op) = *((const volatile unsigned long int *)(const void *)m_pos);
          op = op + (signed long int)8;
          m_pos = m_pos + (signed long int)8;
          t = t - (unsigned long int)8;
        }
        while(t >= 8ul);

      if(t >= 4ul)
      {
        *((volatile unsigned int *)(void *)op) = *((const volatile unsigned int *)(const void *)m_pos);
        op = op + (signed long int)4;
        m_pos = m_pos + (signed long int)4;
        t = t - (unsigned long int)4;
      }

      if(t >= 1ul)
      {
        tmp_post_26 = op;
        op = op + 1l;
        *tmp_post_26 = m_pos[(signed long int)0];
        if(t >= 2ul)
        {
          tmp_post_27 = op;
          op = op + 1l;
          *tmp_post_27 = m_pos[(signed long int)1];
          if(t >= 3ul)
          {
            tmp_post_28 = op;
            op = op + 1l;
            *tmp_post_28 = m_pos[(signed long int)2];
          }

        }

      }

    }

    else
    {

    copy_match:
      ;
      tmp_post_29 = op;
      op = op + 1l;
      tmp_post_30 = m_pos;
      m_pos = m_pos + 1l;
      *tmp_post_29 = *tmp_post_30;
      tmp_post_31 = op;
      op = op + 1l;
      tmp_post_32 = m_pos;
      m_pos = m_pos + 1l;
      *tmp_post_31 = *tmp_post_32;
      do
      {
        tmp_post_33 = op;
        op = op + 1l;
        tmp_post_34 = m_pos;
        m_pos = m_pos + 1l;
        *tmp_post_33 = *tmp_post_34;
        t = t - 1ul;
      }
      while(t >= 1ul);
    }
  }

match_done:
  ;
  t = (unsigned long int)((signed int)ip[(signed long int)-2] & 3);
  unsigned char *tmp_post_35;
  const unsigned char *tmp_post_36;
  unsigned char *tmp_post_37;
  const unsigned char *tmp_post_38;
  unsigned char *tmp_post_39;
  const unsigned char *tmp_post_40;
  const unsigned char *tmp_post_41;
  if(!(t == 0ul))
  {

  match_next:
    ;
    (void)0;
    tmp_post_35 = op;
    op = op + 1l;
    tmp_post_36 = ip;
    ip = ip + 1l;
    *tmp_post_35 = *tmp_post_36;
    if(t >= 2ul)
    {
      tmp_post_37 = op;
      op = op + 1l;
      tmp_post_38 = ip;
      ip = ip + 1l;
      *tmp_post_37 = *tmp_post_38;
      if(t >= 3ul)
      {
        tmp_post_39 = op;
        op = op + 1l;
        tmp_post_40 = ip;
        ip = ip + 1l;
        *tmp_post_39 = *tmp_post_40;
      }

    }

    tmp_post_41 = ip;
    ip = ip + 1l;
    t = (unsigned long int)*tmp_post_41;
    goto match;
  }

  goto __CPROVER_DUMP_L2;

eof_found:
  ;
  *out_len = (unsigned long int)(op - out);
  return ip == ip_end ? 0 : (ip < ip_end ? -8 : -4);
}

// lzo1x_decompress_safe
// file ../common/minilzo.c line 5608
extern signed int lzo1x_decompress_safe(const unsigned char *in, unsigned long int in_len, unsigned char *out, unsigned long int *out_len, void *wrkmem)
{
  unsigned char *op;
  const unsigned char *ip;
  unsigned long int t;
  const unsigned char *m_pos;
  const unsigned char * const ip_end = in + (signed long int)in_len;
  unsigned char * const op_end = out + (signed long int)*out_len;
  (void)wrkmem;
  *out_len = (unsigned long int)0;
  op = out;
  ip = in;
  const unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  const unsigned char *tmp_post_3;
  const unsigned char *tmp_post_4;
  const unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  const unsigned char *tmp_post_7;
  unsigned char *tmp_post_8;
  const unsigned char *tmp_post_9;
  unsigned char *tmp_post_10;
  const unsigned char *tmp_post_11;
  const unsigned char *tmp_post_12;
  const unsigned char *tmp_post_13;
  unsigned char *tmp_post_14;
  const unsigned char *tmp_post_15;
  unsigned char *tmp_post_16;
  const unsigned char *tmp_post_17;
  unsigned char *tmp_post_18;
  const unsigned char *tmp_post_19;
  const unsigned char *tmp_post_20;
  const unsigned char *tmp_post_21;
  const unsigned char *tmp_post_22;
  unsigned char *tmp_post_23;
  const unsigned char *tmp_post_24;
  unsigned char *tmp_post_25;
  unsigned char *tmp_post_26;
  unsigned char *tmp_post_27;
  unsigned char *tmp_post_28;
  unsigned char *tmp_post_29;
  const unsigned char *tmp_post_30;
  unsigned char *tmp_post_31;
  const unsigned char *tmp_post_32;
  unsigned char *tmp_post_33;
  const unsigned char *tmp_post_34;
  unsigned char *tmp_post_35;
  const unsigned char *tmp_post_36;
  unsigned char *tmp_post_37;
  const unsigned char *tmp_post_38;
  unsigned char *tmp_post_39;
  const unsigned char *tmp_post_40;
  const unsigned char *tmp_post_41;
  if((unsigned long int)(ip_end - ip) >= 1ul)
  {
    if((signed int)*ip >= 18)
    {
      tmp_post_1 = ip;
      ip = ip + 1l;
      t = (unsigned long int)((signed int)*tmp_post_1 - 17);
      if(!(t >= 4ul))
        goto match_next;

      if(!((unsigned long int)(op_end - op) >= t))
        goto output_overrun;

      if(!((unsigned long int)(ip_end - ip) >= 3ul + t))
        goto input_overrun;

      do
      {
        tmp_post_2 = op;
        op = op + 1l;
        tmp_post_3 = ip;
        ip = ip + 1l;
        *tmp_post_2 = *tmp_post_3;
        t = t - 1ul;
      }
      while(t >= 1ul);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!((unsigned long int)(ip_end - ip) >= 3ul))
        goto input_overrun;

      tmp_post_4 = ip;
      ip = ip + 1l;
      t = (unsigned long int)*tmp_post_4;
      if(t >= 16ul)
        goto match;

      if(t == 0ul)
      {
        while((signed int)*ip == 0)
        {
          t = t + (unsigned long int)255;
          ip = ip + 1l;
          if(t >= 18446744073709551106ul)
            goto input_overrun;

          if(!((unsigned long int)(ip_end - ip) >= 1ul))
            goto input_overrun;

        }
        tmp_post_5 = ip;
        ip = ip + 1l;
        t = t + (unsigned long int)(15 + (signed int)*tmp_post_5);
      }

      if(!((unsigned long int)(op_end - op) >= 3ul + t))
        goto output_overrun;

      if(!((unsigned long int)(ip_end - ip) >= 6ul + t))
        goto input_overrun;

      t = t + (unsigned long int)3;
      if(t >= 8ul)
        do
        {
          *((volatile unsigned long int *)(void *)op) = *((const volatile unsigned long int *)(const void *)ip);
          op = op + (signed long int)8;
          ip = ip + (signed long int)8;
          t = t - (unsigned long int)8;
        }
        while(t >= 8ul);

      if(t >= 4ul)
      {
        *((volatile unsigned int *)(void *)op) = *((const volatile unsigned int *)(const void *)ip);
        op = op + (signed long int)4;
        ip = ip + (signed long int)4;
        t = t - (unsigned long int)4;
      }

      if(t >= 1ul)
      {
        tmp_post_6 = op;
        op = op + 1l;
        tmp_post_7 = ip;
        ip = ip + 1l;
        *tmp_post_6 = *tmp_post_7;
        if(t >= 2ul)
        {
          tmp_post_8 = op;
          op = op + 1l;
          tmp_post_9 = ip;
          ip = ip + 1l;
          *tmp_post_8 = *tmp_post_9;
          if(t >= 3ul)
          {
            tmp_post_10 = op;
            op = op + 1l;
            tmp_post_11 = ip;
            ip = ip + 1l;
            *tmp_post_10 = *tmp_post_11;
          }

        }

      }

    }

  first_literal_run:
    ;
    tmp_post_12 = ip;
    ip = ip + 1l;
    t = (unsigned long int)*tmp_post_12;
    if(!(t >= 16ul))
    {
      m_pos = op - (signed long int)(1 + 0x0800);
      m_pos = m_pos - (signed long int)(t >> 2);
      tmp_post_13 = ip;
      ip = ip + 1l;
      m_pos = m_pos - (signed long int)((signed int)*tmp_post_13 << 2);
      if((unsigned long int)m_pos >= (unsigned long int)op || !((unsigned long int)m_pos >= (unsigned long int)out))
        goto lookbehind_overrun;

      if(!((unsigned long int)(op_end - op) >= 3ul))
        goto output_overrun;

      tmp_post_14 = op;
      op = op + 1l;
      tmp_post_15 = m_pos;
      m_pos = m_pos + 1l;
      *tmp_post_14 = *tmp_post_15;
      tmp_post_16 = op;
      op = op + 1l;
      tmp_post_17 = m_pos;
      m_pos = m_pos + 1l;
      *tmp_post_16 = *tmp_post_17;
      tmp_post_18 = op;
      op = op + 1l;
      *tmp_post_18 = *m_pos;
    }

    else
    {

    match:
      ;
      if(t >= 64ul)
      {
        m_pos = op - (signed long int)1;
        m_pos = m_pos - (signed long int)(t >> 2 & (unsigned long int)7);
        tmp_post_19 = ip;
        ip = ip + 1l;
        m_pos = m_pos - (signed long int)((signed int)*tmp_post_19 << 3);
        t = (t >> 5) - (unsigned long int)1;
        if((unsigned long int)m_pos >= (unsigned long int)op || !((unsigned long int)m_pos >= (unsigned long int)out))
          goto lookbehind_overrun;

        if(!((unsigned long int)(op_end - op) >= 3ul + t + 18446744073709551615ul))
          goto output_overrun;

        goto copy_match;
      }

      else
        if(t >= 32ul)
        {
          t = t & (unsigned long int)31;
          if(t == 0ul)
          {
            while((signed int)*ip == 0)
            {
              t = t + (unsigned long int)255;
              ip = ip + 1l;
              if(t >= 18446744073709551106ul)
                goto output_overrun;

              if(!((unsigned long int)(ip_end - ip) >= 1ul))
                goto input_overrun;

            }
            tmp_post_20 = ip;
            ip = ip + 1l;
            t = t + (unsigned long int)(31 + (signed int)*tmp_post_20);
            if(!((unsigned long int)(ip_end - ip) >= 2ul))
              goto input_overrun;

          }

          m_pos = op - (signed long int)1;
          m_pos = m_pos - (signed long int)((signed int)*((const volatile unsigned short int *)(const void *)ip) >> 2);
          ip = ip + (signed long int)2;
        }

        else
          if(t >= 16ul)
          {
            m_pos = op;
            m_pos = m_pos - (signed long int)((t & (unsigned long int)8) << 11);
            t = t & (unsigned long int)7;
            if(t == 0ul)
            {
              while((signed int)*ip == 0)
              {
                t = t + (unsigned long int)255;
                ip = ip + 1l;
                if(t >= 18446744073709551106ul)
                  goto output_overrun;

                if(!((unsigned long int)(ip_end - ip) >= 1ul))
                  goto input_overrun;

              }
              tmp_post_21 = ip;
              ip = ip + 1l;
              t = t + (unsigned long int)(7 + (signed int)*tmp_post_21);
              if(!((unsigned long int)(ip_end - ip) >= 2ul))
                goto input_overrun;

            }

            m_pos = m_pos - (signed long int)((signed int)*((const volatile unsigned short int *)(const void *)ip) >> 2);
            ip = ip + (signed long int)2;
            if(m_pos == op)
              goto eof_found;

            m_pos = m_pos - (signed long int)0x4000;
          }

          else
          {
            m_pos = op - (signed long int)1;
            m_pos = m_pos - (signed long int)(t >> 2);
            tmp_post_22 = ip;
            ip = ip + 1l;
            m_pos = m_pos - (signed long int)((signed int)*tmp_post_22 << 2);
            if((unsigned long int)m_pos >= (unsigned long int)op || !((unsigned long int)m_pos >= (unsigned long int)out))
              goto lookbehind_overrun;

            if(!((unsigned long int)(op_end - op) >= 2ul))
              goto output_overrun;

            tmp_post_23 = op;
            op = op + 1l;
            tmp_post_24 = m_pos;
            m_pos = m_pos + 1l;
            *tmp_post_23 = *tmp_post_24;
            tmp_post_25 = op;
            op = op + 1l;
            *tmp_post_25 = *m_pos;
            goto match_done;
          }
      if((unsigned long int)m_pos >= (unsigned long int)op || !((unsigned long int)m_pos >= (unsigned long int)out))
        goto lookbehind_overrun;

      if(!((unsigned long int)(op_end - op) >= 3ul + t + 18446744073709551615ul))
        goto output_overrun;

      if(op - m_pos >= 8l)
      {
        t = t + (unsigned long int)(3 - 1);
        if(t >= 8ul)
          do
          {
            *((volatile unsigned long int *)(void *)op) = *((const volatile unsigned long int *)(const void *)m_pos);
            op = op + (signed long int)8;
            m_pos = m_pos + (signed long int)8;
            t = t - (unsigned long int)8;
          }
          while(t >= 8ul);

        if(t >= 4ul)
        {
          *((volatile unsigned int *)(void *)op) = *((const volatile unsigned int *)(const void *)m_pos);
          op = op + (signed long int)4;
          m_pos = m_pos + (signed long int)4;
          t = t - (unsigned long int)4;
        }

        if(t >= 1ul)
        {
          tmp_post_26 = op;
          op = op + 1l;
          *tmp_post_26 = m_pos[(signed long int)0];
          if(t >= 2ul)
          {
            tmp_post_27 = op;
            op = op + 1l;
            *tmp_post_27 = m_pos[(signed long int)1];
            if(t >= 3ul)
            {
              tmp_post_28 = op;
              op = op + 1l;
              *tmp_post_28 = m_pos[(signed long int)2];
            }

          }

        }

      }

      else
      {

      copy_match:
        ;
        tmp_post_29 = op;
        op = op + 1l;
        tmp_post_30 = m_pos;
        m_pos = m_pos + 1l;
        *tmp_post_29 = *tmp_post_30;
        tmp_post_31 = op;
        op = op + 1l;
        tmp_post_32 = m_pos;
        m_pos = m_pos + 1l;
        *tmp_post_31 = *tmp_post_32;
        do
        {
          tmp_post_33 = op;
          op = op + 1l;
          tmp_post_34 = m_pos;
          m_pos = m_pos + 1l;
          *tmp_post_33 = *tmp_post_34;
          t = t - 1ul;
        }
        while(t >= 1ul);
      }
    }

  match_done:
    ;
    t = (unsigned long int)((signed int)ip[(signed long int)-2] & 3);
    if(!(t == 0ul))
    {

    match_next:
      ;
      (void)0;
      if(!((unsigned long int)(op_end - op) >= t))
        goto output_overrun;

      if(!((unsigned long int)(ip_end - ip) >= 3ul + t))
        goto input_overrun;

      tmp_post_35 = op;
      op = op + 1l;
      tmp_post_36 = ip;
      ip = ip + 1l;
      *tmp_post_35 = *tmp_post_36;
      if(t >= 2ul)
      {
        tmp_post_37 = op;
        op = op + 1l;
        tmp_post_38 = ip;
        ip = ip + 1l;
        *tmp_post_37 = *tmp_post_38;
        if(t >= 3ul)
        {
          tmp_post_39 = op;
          op = op + 1l;
          tmp_post_40 = ip;
          ip = ip + 1l;
          *tmp_post_39 = *tmp_post_40;
        }

      }

      tmp_post_41 = ip;
      ip = ip + 1l;
      t = (unsigned long int)*tmp_post_41;
      goto match;
    }

    goto __CPROVER_DUMP_L2;

  eof_found:
    ;
    *out_len = (unsigned long int)(op - out);
    return ip == ip_end ? 0 : (ip < ip_end ? -8 : -4);
  }

  else
  {

  input_overrun:
    ;
    *out_len = (unsigned long int)(op - out);
    return -4;

  output_overrun:
    ;
    *out_len = (unsigned long int)(op - out);
    return -5;

  lookbehind_overrun:
    ;
    *out_len = (unsigned long int)(op - out);
    return -6;
  }
}

// lzo_adler32
// file ../common/minilzo.c line 3968
extern unsigned int lzo_adler32(unsigned int adler, const unsigned char *buf, unsigned long int len)
{
  unsigned int s1 = adler & (unsigned int)0xffff;
  unsigned int s2 = adler >> 16 & (unsigned int)0xffff;
  unsigned int k;
  const unsigned char *tmp_post_1;
  if(buf == ((const unsigned char *)NULL))
    return (unsigned int)1;

  else
  {
    for( ; len >= 1ul; s2 = s2 % 65521u)
    {
      k = len < (unsigned long int)5552 ? (unsigned int)len : (unsigned int)5552;
      len = len - (unsigned long int)k;
      if(k >= 16u)
        do
        {
          s1 = s1 + (unsigned int)buf[(signed long int)0];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 2)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 2 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 4)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 4 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 4 + 2)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 4 + 2 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 2)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 2 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 4)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 4 + 1)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 4 + 2)];
          s2 = s2 + s1;
          s1 = s1 + (unsigned int)buf[(signed long int)(0 + 8 + 4 + 2 + 1)];
          s2 = s2 + s1;
          buf = buf + (signed long int)16;
          k = k - (unsigned int)16;
        }
        while(k >= 16u);

      if(!(k == 0u))
        do
        {
          tmp_post_1 = buf;
          buf = buf + 1l;
          s1 = s1 + (unsigned int)*tmp_post_1;
          s2 = s2 + s1;
          k = k - 1u;
        }
        while(k >= 1u);

      s1 = s1 % 65521u;
    }
    return s2 << 16 | s1;
  }
}

// lzo_bitops_ctlz32_func
// file ../common/minilzo.c line 3259
static inline unsigned int lzo_bitops_ctlz32_func(unsigned int v)
{
  unsigned int r;
  signed int return_value___builtin_clz_1;
  return_value___builtin_clz_1=__builtin_clz(v);
  r = (unsigned int)return_value___builtin_clz_1;
  return r;
}

// lzo_bitops_ctlz64_func
// file ../common/minilzo.c line 3278
static inline unsigned int lzo_bitops_ctlz64_func(unsigned long int v)
{
  unsigned int r;
  signed int return_value___builtin_clzl_1;
  return_value___builtin_clzl_1=__builtin_clzl(v);
  r = (unsigned int)return_value___builtin_clzl_1;
  return r;
}

// lzo_bitops_cttz32_func
// file ../common/minilzo.c line 3300
static inline unsigned int lzo_bitops_cttz32_func(unsigned int v)
{
  unsigned int r;
  signed int return_value___builtin_ctz_1;
  return_value___builtin_ctz_1=__builtin_ctz(v);
  r = (unsigned int)return_value___builtin_ctz_1;
  return r;
}

// lzo_bitops_cttz64_func
// file ../common/minilzo.c line 3319
static inline unsigned int lzo_bitops_cttz64_func(unsigned long int v)
{
  unsigned int r;
  signed int return_value___builtin_ctzl_1;
  return_value___builtin_ctzl_1=__builtin_ctzl(v);
  r = (unsigned int)return_value___builtin_ctzl_1;
  return r;
}

// lzo_bitops_unused_funcs
// file ../common/minilzo.c line 3346
static void lzo_bitops_unused_funcs(void)
{
  (void)lzo_bitops_ctlz32_func;
  (void)lzo_bitops_cttz32_func;
  (void)lzo_bitops_ctlz64_func;
  (void)lzo_bitops_cttz64_func;
  (void)lzo_bitops_unused_funcs;
}

// lzo_copyright
// file ../common/minilzo.c line 3923
extern const unsigned char * lzo_copyright(void)
{
  return (const unsigned char *)__lzo_copyright;
}

// lzo_memcmp
// file ../common/minilzo.c line 4025
extern signed int lzo_memcmp(const void *s1, const void *s2, unsigned long int len)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(s1, s2, len);
  return return_value_memcmp_1;
}

// lzo_memcpy
// file ../common/minilzo.c line 4042
extern void * lzo_memcpy(void *dest, const void *src, unsigned long int len)
{
  void *return_value_memcpy_1;
  return_value_memcpy_1=memcpy(dest, src, len);
  return return_value_memcpy_1;
}

// lzo_memmove
// file ../common/minilzo.c line 4057
extern void * lzo_memmove(void *dest, const void *src, unsigned long int len)
{
  void *return_value_memmove_1;
  return_value_memmove_1=memmove(dest, src, len);
  return return_value_memmove_1;
}

// lzo_memset
// file ../common/minilzo.c line 4083
extern void * lzo_memset(void *s, signed int cc, unsigned long int len)
{
  void *return_value_memset_1;
  return_value_memset_1=memset(s, cc, len);
  return return_value_memset_1;
}

// lzo_version
// file ../common/minilzo.c line 3929
extern unsigned int lzo_version(void)
{
  return (unsigned int)0x2070;
}

// lzo_version_date
// file ../common/minilzo.c line 3941
extern const char * lzo_version_date(void)
{
  return "Jun 25 2014";
}

// lzo_version_string
// file ../common/minilzo.c line 3935
extern const char * lzo_version_string(void)
{
  return "2.07";
}

// main
// file storepasswd.c line 34
signed int main(signed int argc, char **argv)
{
  if(!(argc == 3))
    usage();

  signed int return_value_rfbEncryptAndStorePasswd_1;
  return_value_rfbEncryptAndStorePasswd_1=rfbEncryptAndStorePasswd(argv[(signed long int)1], argv[(signed long int)2]);
  if(!(return_value_rfbEncryptAndStorePasswd_1 == 0))
  {
    printf("storing password failed.\n");
    return 1;
  }

  else
  {
    printf("storing password succeeded.\n");
    return 0;
  }
}

// messageNameClient2Server
// file stats.c line 68
extern char * messageNameClient2Server(unsigned int type, char *buf, signed int len)
{
  if(buf == ((char *)NULL))
    return "error";

  else
  {
    switch(type)
    {
      case (unsigned int)0:
      {
        snprintf(buf, (unsigned long int)len, "SetPixelFormat");
        break;
      }
      case (unsigned int)1:
      {
        snprintf(buf, (unsigned long int)len, "FixColourMapEntries");
        break;
      }
      case (unsigned int)2:
      {
        snprintf(buf, (unsigned long int)len, "SetEncodings");
        break;
      }
      case (unsigned int)3:
      {
        snprintf(buf, (unsigned long int)len, "FramebufferUpdate");
        break;
      }
      case (unsigned int)4:
      {
        snprintf(buf, (unsigned long int)len, "KeyEvent");
        break;
      }
      case (unsigned int)5:
      {
        snprintf(buf, (unsigned long int)len, "PointerEvent");
        break;
      }
      case (unsigned int)6:
      {
        snprintf(buf, (unsigned long int)len, "ClientCutText");
        break;
      }
      case (unsigned int)7:
      {
        snprintf(buf, (unsigned long int)len, "FileTransfer");
        break;
      }
      case (unsigned int)8:
      {
        snprintf(buf, (unsigned long int)len, "SetScale");
        break;
      }
      case (unsigned int)9:
      {
        snprintf(buf, (unsigned long int)len, "SetServerInput");
        break;
      }
      case (unsigned int)10:
      {
        snprintf(buf, (unsigned long int)len, "SetSingleWindow");
        break;
      }
      case (unsigned int)11:
      {
        snprintf(buf, (unsigned long int)len, "TextChat");
        break;
      }
      case (unsigned int)0xF:
      {
        snprintf(buf, (unsigned long int)len, "PalmVNCSetScale");
        break;
      }
      case (unsigned int)250:
      {
        snprintf(buf, (unsigned long int)len, "XvpClientMessage");
        break;
      }
      default:
        snprintf(buf, (unsigned long int)len, "cli2svr-0x%08X", type);
    }
    return buf;
  }
}

// messageNameServer2Client
// file stats.c line 50
extern char * messageNameServer2Client(unsigned int type, char *buf, signed int len)
{
  if(buf == ((char *)NULL))
    return "error";

  else
  {
    switch(type)
    {
      case (unsigned int)0:
      {
        snprintf(buf, (unsigned long int)len, "FramebufferUpdate");
        break;
      }
      case (unsigned int)1:
      {
        snprintf(buf, (unsigned long int)len, "SetColourMapEntries");
        break;
      }
      case (unsigned int)2:
      {
        snprintf(buf, (unsigned long int)len, "Bell");
        break;
      }
      case (unsigned int)3:
      {
        snprintf(buf, (unsigned long int)len, "ServerCutText");
        break;
      }
      case (unsigned int)4:
      {
        snprintf(buf, (unsigned long int)len, "ResizeFrameBuffer");
        break;
      }
      case (unsigned int)7:
      {
        snprintf(buf, (unsigned long int)len, "FileTransfer");
        break;
      }
      case (unsigned int)11:
      {
        snprintf(buf, (unsigned long int)len, "TextChat");
        break;
      }
      case (unsigned int)0xF:
      {
        snprintf(buf, (unsigned long int)len, "PalmVNCReSize");
        break;
      }
      case (unsigned int)250:
      {
        snprintf(buf, (unsigned long int)len, "XvpServerMessage");
        break;
      }
      default:
        snprintf(buf, (unsigned long int)len, "svr2cli-0x%08X", 0xFF);
    }
    return buf;
  }
}

// min
// file websockets.c line 177
static signed int min(signed int a, signed int b)
{
  return a < b ? a : b;
}

// my_error_exit
// file ../common/turbojpeg.c line 68
static void my_error_exit(struct jpeg_common_struct *cinfo)
{
  struct my_error_mgr *myerr = (struct my_error_mgr *)cinfo->err;
  cinfo->err->output_message(cinfo);
  longjmp(myerr->setjmp_buffer, 1);
}

// my_output_message
// file ../common/turbojpeg.c line 77
static void my_output_message(struct jpeg_common_struct *cinfo)
{
  cinfo->err->format_message(cinfo, errStr);
}

// pad4
// file scale.c line 69
static inline signed int pad4(signed int value)
{
  signed int remainder = value & 3;
  if(remainder == 0)
    return value;

  else
    return (value + 4) - remainder;
}

// parseParams
// file httpd.c line 572
static signed char parseParams(const char *request, char *result, signed int max_bytes)
{
  char param_request[128l];
  char param_formatted[196l];
  const char *tail;
  char *delim_ptr;
  char *value_str;
  signed int cur_bytes;
  signed int len;
  result[(signed long int)0] = (char)0;
  cur_bytes = 0;
  tail = request;
  char *tmp_post_2;
  _Bool tmp_if_expr_6;
  signed char return_value_validateString_5;
  do
  {
    delim_ptr=strchr((char *)tail, 38);
    if(delim_ptr == ((char *)NULL))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(tail);
      if(return_value_strlen_1 >= sizeof(char [128l]) /*128ul*/ )
        return (signed char)0;

      strcpy(param_request, tail);
    }

    else
    {
      len = (signed int)(delim_ptr - tail);
      if((unsigned long int)len >= sizeof(char [128l]) /*128ul*/ )
        return (signed char)0;

      memcpy((void *)param_request, (const void *)tail, (unsigned long int)len);
      param_request[(signed long int)len] = (char)0;
    }
    value_str=strchr(&param_request[(signed long int)1], 61);
    if(value_str == ((char *)NULL))
      return (signed char)0;

    tmp_post_2 = value_str;
    value_str = value_str + 1l;
    *tmp_post_2 = (char)0;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(value_str);
    if(return_value_strlen_3 == 0ul)
      return (signed char)0;

    signed char return_value_validateString_4;
    return_value_validateString_4=validateString(param_request);
    if(return_value_validateString_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_validateString_5=validateString(value_str);
      tmp_if_expr_6 = !(return_value_validateString_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return (signed char)0;

    len=sprintf(param_formatted, "<PARAM NAME=\"%s\" VALUE=\"%s\">\n", (const void *)param_request, value_str);
    if(!(max_bytes >= 1 + cur_bytes + len))
      return (signed char)0;

    strcat(result, param_formatted);
    cur_bytes = cur_bytes + len;
    if(delim_ptr == ((char *)NULL))
      break;

    tail = delim_ptr + (signed long int)1;
  }
  while((_Bool)1);
  return (signed char)-1;
}

// rectSwapIfLEAndClip
// file rfbserver.c line 854
static signed char rectSwapIfLEAndClip(unsigned short int *x, unsigned short int *y, unsigned short int *w, unsigned short int *h, struct _rfbClientRec *cl)
{
  signed int x1;
  signed int tmp_if_expr_1;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_1 = ((signed int)*x & 0xff) << 8 | (signed int)*x >> 8 & 0xff;

  else
    tmp_if_expr_1 = (signed int)*x;
  x1 = tmp_if_expr_1;
  signed int y1;
  signed int tmp_if_expr_2;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_2 = ((signed int)*y & 0xff) << 8 | (signed int)*y >> 8 & 0xff;

  else
    tmp_if_expr_2 = (signed int)*y;
  y1 = tmp_if_expr_2;
  signed int w1;
  signed int tmp_if_expr_3;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_3 = ((signed int)*w & 0xff) << 8 | (signed int)*w >> 8 & 0xff;

  else
    tmp_if_expr_3 = (signed int)*w;
  w1 = tmp_if_expr_3;
  signed int h1;
  signed int tmp_if_expr_4;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_4 = ((signed int)*h & 0xff) << 8 | (signed int)*h >> 8 & 0xff;

  else
    tmp_if_expr_4 = (signed int)*h;
  h1 = tmp_if_expr_4;
  rfbScaledCorrection(cl->scaledScreen, cl->screen, &x1, &y1, &w1, &h1, "rectSwapIfLEAndClip");
  *x = (unsigned short int)x1;
  *y = (unsigned short int)y1;
  *w = (unsigned short int)w1;
  *h = (unsigned short int)h1;
  if(!(cl->screen->width + -((signed int)*x) >= (signed int)*w))
    *w = (unsigned short int)(cl->screen->width - (signed int)*x);

  if(!(cl->screen->width + -((signed int)*x) >= (signed int)*w))
    return (signed char)0;

  else
  {
    if(!(cl->screen->height + -((signed int)*y) >= (signed int)*h))
      *h = (unsigned short int)(cl->screen->height - (signed int)*y);

    if(!(cl->screen->height + -((signed int)*y) >= (signed int)*h))
      return (signed char)0;

    else
      return (signed char)-1;
  }
}

// rfbAuthNewClient
// file ../rfb/rfb.h line 834
extern void rfbAuthNewClient(struct _rfbClientRec *cl)
{
  signed int securityType = 0;
  _Bool tmp_if_expr_1;
  if(cl->screen->authPasswdData == NULL)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cl->reverseConnection != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    securityType = 1;

  else
    if(!(cl->screen->authPasswdData == NULL))
      securityType = 2;

  _Bool tmp_if_expr_2;
  if(cl->protocolMajorVersion == 3)
    tmp_if_expr_2 = cl->protocolMinorVersion < 7 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    if(securityType == 0)
    {
      rfbLog("VNC authentication disabled - RFB 3.3 client rejected\n");
      rfbClientConnFailed(cl, "Your viewer cannot handle required authentication methods");
    }

    rfbSendSecurityType(cl, securityType);
  }

  else
    rfbSendSecurityTypeList(cl, securityType);
}

// rfbAuthProcessClientMessage
// file ../rfb/rfb.h line 836
extern void rfbAuthProcessClientMessage(struct _rfbClientRec *cl)
{
  signed int n;
  unsigned char response[16l];
  unsigned int authResult;
  n=rfbReadExact(cl, (char *)response, 16);
  if(!(n >= 1))
  {
    if(!(n == 0))
      rfbLogPerror("rfbAuthProcessClientMessage: read");

    rfbCloseClient(cl);
  }

  else
  {
    signed char return_value;
    return_value=cl->screen->passwordCheck(cl, (const char *)response, 16);
    if(return_value == 0)
    {
      rfbErr("rfbAuthProcessClientMessage: password check failed\n");
      authResult = (unsigned int)(rfbEndianTest != 0 ? 1 >> 24 | (1 & 0x00ff0000) >> 8 | (1 & 0x0000ff00) << 8 | 1 << 24 : 1);
      signed int return_value_rfbWriteExact_1;
      return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)&authResult, 4);
      if(!(return_value_rfbWriteExact_1 >= 0))
        rfbLogPerror("rfbAuthProcessClientMessage: write");

      if(cl->protocolMinorVersion >= 8)
        rfbClientSendString(cl, "password check failed!");

      else
        rfbCloseClient(cl);
    }

    authResult = (unsigned int)(rfbEndianTest != 0 ? 0 >> 24 | (0 & 0x00ff0000) >> 8 | (0 & 0x0000ff00) << 8 | 0 << 24 : 0);
    signed int return_value_rfbWriteExact_2;
    return_value_rfbWriteExact_2=rfbWriteExact(cl, (char *)&authResult, 4);
    if(!(return_value_rfbWriteExact_2 >= 0))
    {
      rfbLogPerror("rfbAuthProcessClientMessage: write");
      rfbCloseClient(cl);
    }

    else
      cl->state = (enum anonymous_13)RFB_INITIALISATION;
  }
}

// rfbCPKey
// file ../common/d3des.c line 132
extern void rfbCPKey(unsigned long int *into)
{
  unsigned long int *from;
  unsigned long int *endp;
  from = KnL;
  endp = &KnL[(signed long int)32];
  unsigned long int *tmp_post_1;
  unsigned long int *tmp_post_2;
  for( ; !(from >= endp); *tmp_post_1 = *tmp_post_2)
  {
    tmp_post_1 = into;
    into = into + 1l;
    tmp_post_2 = from;
    from = from + 1l;
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// rfbCheckFds
// file ../rfb/rfb.h line 752
extern signed int rfbCheckFds(struct _rfbScreenInfo *rfbScreen, signed long int usec)
{
  signed int nfds;
  struct anonymous_16 fds;
  struct timeval tv;
  struct sockaddr_in addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  char rfbCheckFds__1__buf[6l];
  struct rfbClientIterator *i;
  struct _rfbClientRec *rfbCheckFds__1__cl;
  signed int result = 0;
  if(rfbScreen->inetdInitDone == 0)
  {
    if(!(rfbScreen->inetdSock == -1))
    {
      rfbNewClientConnection(rfbScreen, rfbScreen->inetdSock);
      rfbScreen->inetdInitDone = (signed char)-1;
    }

  }

  _Bool tmp_if_expr_6;
  signed int return_value_memcmp_5;
  do
  {
    memcpy((void *)(char *)&fds, (const void *)(char *)&rfbScreen->allFds, sizeof(struct anonymous_16) /*128ul*/ );
    tv.tv_sec = (signed long int)0;
    tv.tv_usec = usec;
    nfds=select(rfbScreen->maxFd + 1, &fds, (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0, &tv);
    if(nfds == 0)
    {
      i=rfbGetClientIterator(rfbScreen);
      do
      {
        rfbCheckFds__1__cl=rfbClientIteratorNext(i);
        if(rfbCheckFds__1__cl == ((struct _rfbClientRec *)NULL))
          break;

        if(rfbCheckFds__1__cl->onHold == 0)
        {
          if(!((rfbScreen->allFds.__fds_bits[(signed long int)(rfbCheckFds__1__cl->sock / 8)] & (signed long int)(1UL << rfbCheckFds__1__cl->sock % 8)) == 0l))
            rfbSendFileTransferChunk(rfbCheckFds__1__cl);

        }

      }
      while((_Bool)1);
      rfbReleaseClientIterator(i);
      return result;
    }

    if(!(nfds >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(!(*return_value___errno_location_1 == 4))
        rfbLogPerror("rfbCheckFds: select");

      return -1;
    }

    result = result + nfds;
    if(!(rfbScreen->listenSock == -1))
    {
      if(!((fds.__fds_bits[(signed long int)(rfbScreen->listenSock / 8)] & (signed long int)(1UL << rfbScreen->listenSock % 8)) == 0l))
      {
        signed char return_value_rfbProcessNewConnection_2;
        return_value_rfbProcessNewConnection_2=rfbProcessNewConnection(rfbScreen);
        if(return_value_rfbProcessNewConnection_2 == 0)
          return -1;

        (&fds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->listenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
        nfds = nfds - 1;
        if(nfds == 0)
          return result;

      }

    }

    if(!(rfbScreen->listen6Sock == -1))
    {
      if(!((fds.__fds_bits[(signed long int)(rfbScreen->listen6Sock / 8)] & (signed long int)(1UL << rfbScreen->listen6Sock % 8)) == 0l))
      {
        signed char return_value_rfbProcessNewConnection_3;
        return_value_rfbProcessNewConnection_3=rfbProcessNewConnection(rfbScreen);
        if(return_value_rfbProcessNewConnection_3 == 0)
          return -1;

        (&fds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->listen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
        nfds = nfds - 1;
        if(nfds == 0)
          return result;

      }

    }

    if(!(rfbScreen->udpSock == -1))
    {
      if(!((fds.__fds_bits[(signed long int)(rfbScreen->udpSock / 8)] & (signed long int)(1UL << rfbScreen->udpSock % 8)) == 0l))
      {
        if(rfbScreen->udpClient == ((struct _rfbClientRec *)NULL))
          rfbNewUDPClient(rfbScreen);

        signed long int return_value_recvfrom_7;
        return_value_recvfrom_7=recvfrom(rfbScreen->udpSock, (void *)rfbCheckFds__1__buf, (unsigned long int)1, 2, (struct sockaddr *)&addr, &addrlen);
        if(!(return_value_recvfrom_7 >= 0l))
        {
          rfbLogPerror("rfbCheckFds: UDP: recvfrom");
          rfbDisconnectUDPSock(rfbScreen);
          rfbScreen->udpSockConnected = (signed char)0;
        }

        else
        {
          if(rfbScreen->udpSockConnected == 0)
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value_memcmp_5=memcmp((const void *)&addr, (const void *)&rfbScreen->udpRemoteAddr, (unsigned long int)addrlen);
            tmp_if_expr_6 = return_value_memcmp_5 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_6)
          {
            rfbLog("rfbCheckFds: UDP: got connection\n");
            memcpy((void *)&rfbScreen->udpRemoteAddr, (const void *)&addr, (unsigned long int)addrlen);
            rfbScreen->udpSockConnected = (signed char)-1;
            signed int return_value_connect_4;
            return_value_connect_4=connect(rfbScreen->udpSock, (struct sockaddr *)&addr, addrlen);
            if(!(return_value_connect_4 >= 0))
            {
              rfbLogPerror("rfbCheckFds: UDP: connect");
              rfbDisconnectUDPSock(rfbScreen);
              return -1;
            }

            rfbNewUDPConnection(rfbScreen, rfbScreen->udpSock);
          }

          rfbProcessUDPInput(rfbScreen);
        }
        (&fds)->__fds_bits[(signed long int)(rfbScreen->udpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(rfbScreen->udpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->udpSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
        nfds = nfds - 1;
        if(nfds == 0)
          return result;

      }

    }

    i=rfbGetClientIterator(rfbScreen);
    do
    {
      rfbCheckFds__1__cl=rfbClientIteratorNext(i);
      if(rfbCheckFds__1__cl == ((struct _rfbClientRec *)NULL))
        break;

      if(rfbCheckFds__1__cl->onHold == 0)
      {
        if(!((rfbScreen->allFds.__fds_bits[(signed long int)(rfbCheckFds__1__cl->sock / 8)] & (signed long int)(1UL << rfbCheckFds__1__cl->sock % 8)) == 0l))
        {
          if(!((fds.__fds_bits[(signed long int)(rfbCheckFds__1__cl->sock / 8)] & (signed long int)(1UL << rfbCheckFds__1__cl->sock % 8)) == 0l))
            rfbProcessClientMessage(rfbCheckFds__1__cl);

          else
            rfbSendFileTransferChunk(rfbCheckFds__1__cl);
        }

      }

    }
    while((_Bool)1);
    rfbReleaseClientIterator(i);
  }
  while(!(rfbScreen->handleEventsEagerly == 0));
  return result;
}

// rfbCheckPasswordByList
// file main.c line 732
signed char rfbCheckPasswordByList(struct _rfbClientRec *cl, const char *response, signed int len)
{
  char **passwds;
  signed int i = 0;
  passwds = (char **)cl->screen->authPasswdData;
  for( ; !(*passwds == ((char *)NULL)); i = i + 1)
  {
    unsigned char auth_tmp[16l];
    memcpy((void *)(char *)auth_tmp, (const void *)(char *)cl->authChallenge, (unsigned long int)16);
    rfbEncryptBytes(auth_tmp, *passwds);
    signed int return_value_memcmp_1;
    return_value_memcmp_1=memcmp((const void *)auth_tmp, (const void *)response, (unsigned long int)len);
    if(return_value_memcmp_1 == 0)
    {
      if(i >= cl->screen->authPasswdFirstViewOnly)
        cl->viewOnly = (signed char)-1;

      return (signed char)-1;
    }

    passwds = passwds + 1l;
  }
  rfbErr("authProcessClientMessage: authentication failed from %s\n", cl->host);
  return (signed char)0;
}

// rfbClientConnFailed
// file rfbserver.c line 735
extern void rfbClientConnFailed(struct _rfbClientRec *cl, const char *reason)
{
  char *rfbClientConnFailed__1__buf;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  len = (signed int)return_value_strlen_1;
  rfbLog("rfbClientConnFailed(\"%s\")\n", reason);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(8 + len));
  rfbClientConnFailed__1__buf = (char *)return_value_malloc_2;
  ((unsigned int *)rfbClientConnFailed__1__buf)[(signed long int)0] = (unsigned int)(rfbEndianTest != 0 ? 0 >> 24 | (0 & 0x00ff0000) >> 8 | (0 & 0x0000ff00) << 8 | 0 << 24 : 0);
  ((unsigned int *)rfbClientConnFailed__1__buf)[(signed long int)1] = (unsigned int)(rfbEndianTest != 0 ? len >> 24 | (len & 0x00ff0000) >> 8 | (len & 0x0000ff00) << 8 | len << 24 : len);
  memcpy((void *)(rfbClientConnFailed__1__buf + (signed long int)8), (const void *)reason, (unsigned long int)len);
  signed int return_value_rfbWriteExact_3;
  return_value_rfbWriteExact_3=rfbWriteExact(cl, rfbClientConnFailed__1__buf, 8 + len);
  if(!(return_value_rfbWriteExact_3 >= 0))
    rfbLogPerror("rfbClientConnFailed: write");

  free((void *)rfbClientConnFailed__1__buf);
  rfbCloseClient(cl);
}

// rfbClientConnectionGone
// file ../rfb/rfb.h line 787
extern void rfbClientConnectionGone(struct _rfbClientRec *cl)
{
  signed int i;
  pthread_mutex_lock(&rfbClientListMutex);
  if(!(cl->prev == ((struct _rfbClientRec *)NULL)))
    cl->prev->next = cl->next;

  else
    cl->screen->clientHead = cl->next;
  if(!(cl->next == ((struct _rfbClientRec *)NULL)))
    cl->next->prev = cl->prev;

  pthread_mutex_unlock(&rfbClientListMutex);
  if(!((signed int)cl->screen->backgroundLoop == 0))
  {
    signed int rfbClientConnectionGone__1__1__i;
    do
    {
      pthread_mutex_lock(&cl->refCountMutex);
      rfbClientConnectionGone__1__1__i = cl->refCount;
      if(rfbClientConnectionGone__1__1__i >= 1)
        pthread_cond_wait(&cl->deleteCond, &cl->refCountMutex);

      pthread_mutex_unlock(&cl->refCountMutex);
    }
    while(rfbClientConnectionGone__1__1__i >= 1);
  }

  if(cl->sock >= 0)
    close(cl->sock);

  if(!(cl->scaledScreen == ((struct _rfbScreenInfo *)NULL)))
    cl->scaledScreen->scaledScreenRefCount = cl->scaledScreen->scaledScreenRefCount - 1;

  rfbFreeZrleData(cl);
  rfbFreeUltraData(cl);
  free((void *)cl->beforeEncBuf);
  free((void *)cl->afterEncBuf);
  if(cl->sock >= 0)
    (&cl->screen->allFds)->__fds_bits[(signed long int)(cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&cl->screen->allFds)->__fds_bits[(signed long int)(cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));

  cl->clientGoneHook(cl);
  rfbLog("Client %s gone\n", cl->host);
  free((void *)cl->host);
  if(!(cl->compStreamInited == 0))
    deflateEnd(&cl->compStream);

  i = 0;
  if(!(i >= 4))
  {
    if(!(cl->zsActive[(signed long int)i] == 0))
      deflateEnd(&cl->zsStruct[(signed long int)i]);

    i = i + 1;
  }

  if(cl->screen->pointerClient == cl)
    cl->screen->pointerClient = (struct _rfbClientRec *)(void *)0;

  sraRgnDestroy(cl->modifiedRegion);
  sraRgnDestroy(cl->requestedRegion);
  sraRgnDestroy(cl->copyRegion);
  if(!(cl->translateLookupTable == ((char *)NULL)))
    free((void *)cl->translateLookupTable);

  pthread_cond_destroy(&cl->updateCond);
  pthread_mutex_destroy(&cl->updateMutex);
  pthread_mutex_lock(&cl->outputMutex);
  pthread_mutex_unlock(&cl->outputMutex);
  pthread_mutex_destroy(&cl->outputMutex);
  pthread_mutex_lock(&cl->sendMutex);
  pthread_mutex_unlock(&cl->sendMutex);
  pthread_mutex_destroy(&cl->sendMutex);
  rfbPrintStats(cl);
  rfbResetStats(cl);
  free((void *)cl);
}

// rfbClientIteratorHead
// file private.h line 12
struct _rfbClientRec * rfbClientIteratorHead(struct rfbClientIterator *i)
{
  if(!(i->next == ((struct _rfbClientRec *)NULL)))
  {
    rfbDecrClientRef(i->next);
    rfbIncrClientRef(i->screen->clientHead);
  }

  pthread_mutex_lock(&rfbClientListMutex);
  i->next = i->screen->clientHead;
  pthread_mutex_unlock(&rfbClientListMutex);
  return i->next;
}

// rfbClientIteratorNext
// file ../rfb/rfb.h line 778
extern struct _rfbClientRec * rfbClientIteratorNext(struct rfbClientIterator *i)
{
  if(i->next == ((struct _rfbClientRec *)NULL))
  {
    pthread_mutex_lock(&rfbClientListMutex);
    i->next = i->screen->clientHead;
    pthread_mutex_unlock(&rfbClientListMutex);
  }

  else
  {
    struct _rfbClientRec *rfbClientIteratorNext__1__2__cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(rfbClientIteratorNext__1__2__cl);
  }
  if(i->closedToo == 0)
    for( ; !(i->next == ((struct _rfbClientRec *)NULL)); i->next = i->next->next)
      if(i->next->sock >= 0)
        break;


  if(!(i->next == ((struct _rfbClientRec *)NULL)))
    rfbIncrClientRef(i->next);

  return i->next;
}

// rfbClientListInit
// file ../rfb/rfb.h line 776
extern void rfbClientListInit(struct _rfbScreenInfo *rfbScreen)
{
  rfbScreen->clientHead = (struct _rfbClientRec *)(void *)0;
  pthread_mutex_init(&rfbClientListMutex, (const union anonymous_0 *)(void *)0);
}

// rfbClientSendString
// file rfbserver.c line 711
void rfbClientSendString(struct _rfbClientRec *cl, const char *reason)
{
  char *rfbClientSendString__1__buf;
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(reason);
  len = (signed int)return_value_strlen_1;
  rfbLog("rfbClientSendString(\"%s\")\n", reason);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(4 + len));
  rfbClientSendString__1__buf = (char *)return_value_malloc_2;
  ((unsigned int *)rfbClientSendString__1__buf)[(signed long int)0] = (unsigned int)(rfbEndianTest != 0 ? len >> 24 | (len & 0x00ff0000) >> 8 | (len & 0x0000ff00) << 8 | len << 24 : len);
  memcpy((void *)(rfbClientSendString__1__buf + (signed long int)4), (const void *)reason, (unsigned long int)len);
  signed int return_value_rfbWriteExact_3;
  return_value_rfbWriteExact_3=rfbWriteExact(cl, rfbClientSendString__1__buf, 4 + len);
  if(!(return_value_rfbWriteExact_3 >= 0))
    rfbLogPerror("rfbClientSendString: write");

  free((void *)rfbClientSendString__1__buf);
  rfbCloseClient(cl);
}

// rfbCloseClient
// file ../rfb/rfb.h line 747
extern void rfbCloseClient(struct _rfbClientRec *cl)
{
  struct _rfbExtensionData *extension = cl->extensions;
  for( ; !(extension == ((struct _rfbExtensionData *)NULL)); extension = extension->next)
    if(!(extension->extension->close == ((void (*)(struct _rfbClientRec *, void *))NULL)))
      extension->extension->close(cl, extension->data);

  pthread_mutex_lock(&cl->updateMutex);
  if(!(cl->sock == -1))
  {
    (&cl->screen->allFds)->__fds_bits[(signed long int)(cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&cl->screen->allFds)->__fds_bits[(signed long int)(cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
    if(cl->sock == cl->screen->maxFd)
      for( ; cl->screen->maxFd >= 1; cl->screen->maxFd = cl->screen->maxFd - 1)
        if(!((cl->screen->allFds.__fds_bits[(signed long int)(cl->screen->maxFd / 8)] & (signed long int)(1UL << cl->screen->maxFd % 8)) == 0l))
          break;


    if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
      rfbssl_destroy(cl);

    free((void *)cl->wspath);
    shutdown(cl->sock, 2);
    close(cl->sock);
    cl->sock = -1;
  }

  pthread_cond_signal(&cl->updateCond);
  pthread_mutex_unlock(&cl->updateMutex);
}

// rfbConnect
// file ../rfb/rfb.h line 753
extern signed int rfbConnect(struct _rfbScreenInfo *rfbScreen, char *host, signed int port)
{
  signed int sock;
  signed int one = 1;
  rfbLog("Making connection to client on host %s port %d\n", host, port);
  sock=rfbConnectToTcpAddr(host, port);
  signed int tmp_if_expr_3;
  if(!(sock >= 0))
  {
    rfbLogPerror("connection failed");
    return -1;
  }

  else
  {
    signed char return_value_rfbSetNonBlocking_1;
    return_value_rfbSetNonBlocking_1=rfbSetNonBlocking(sock);
    if(return_value_rfbSetNonBlocking_1 == 0)
    {
      close(sock);
      return -1;
    }

    else
    {
      signed int return_value_setsockopt_2;
      return_value_setsockopt_2=setsockopt(sock, 6, 1, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_2 >= 0))
      {
        rfbLogPerror("setsockopt failed");
        close(sock);
        return -1;
      }

      else
      {
        (&rfbScreen->allFds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(rfbScreen->maxFd >= sock))
          tmp_if_expr_3 = sock;

        else
          tmp_if_expr_3 = rfbScreen->maxFd;
        rfbScreen->maxFd = tmp_if_expr_3;
        return sock;
      }
    }
  }
}

// rfbConnectToTcpAddr
// file sockets.c line 965
extern signed int rfbConnectToTcpAddr(char *host, signed int port)
{
  signed int sock;
  struct addrinfo hints;
  struct addrinfo *servinfo;
  struct addrinfo *p;
  signed int rv;
  char port_str[8l];
  snprintf(port_str, (unsigned long int)8, "%d", port);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  rv=getaddrinfo(host, port_str, &hints, &servinfo);
  if(!(rv == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rv);
    rfbErr("rfbConnectToTcpAddr: error in getaddrinfo: %s\n", return_value_gai_strerror_1);
    return -1;
  }

  p = servinfo;
  for( ; !(p == ((struct addrinfo *)NULL)); p = p->ai_next)
  {
    sock=socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if(sock >= 0)
    {
      signed int return_value_connect_2;
      return_value_connect_2=connect(sock, p->ai_addr, p->ai_addrlen);
      if(!(return_value_connect_2 >= 0))
        close(sock);

      else
        break;
    }

  }
  if(p == ((struct addrinfo *)NULL))
  {
    rfbLogPerror("rfbConnectToTcoAddr: failed to connect\n");
    sock = -1;
  }

  freeaddrinfo(servinfo);
  return sock;
}

// rfbConvertLSBCursorBitmapOrMask
// file cursor.c line 245
extern void rfbConvertLSBCursorBitmapOrMask(signed int width, signed int height, unsigned char *bitmap)
{
  signed int i;
  signed int t = ((width + 7) / 8) * height;
  i = 0;
  for( ; !(i >= t); i = i + 1)
    bitmap[(signed long int)i] = rfbReverseByte[(signed long int)(signed int)bitmap[(signed long int)i]];
}

// rfbDecrClientRef
// file ../rfb/rfb.h line 781
extern void rfbDecrClientRef(struct _rfbClientRec *cl)
{
  pthread_mutex_lock(&cl->refCountMutex);
  cl->refCount = cl->refCount - 1;
  if(!(cl->refCount >= 1))
    pthread_cond_signal(&cl->deleteCond);

  pthread_mutex_unlock(&cl->refCountMutex);
}

// rfbDecryptPasswdFromFile
// file ../rfb/rfbproto.h line 1472
extern char * rfbDecryptPasswdFromFile(char *fname)
{
  struct _IO_FILE *fp;
  signed int i;
  signed int ch;
  unsigned char *passwd;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)9);
  passwd = (unsigned char *)return_value_malloc_1;
  fp=fopen(fname, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    free((void *)passwd);
    return (char *)(void *)0;
  }

  else
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      ch=_IO_getc(fp);
      if(ch == -1)
      {
        fclose(fp);
        free((void *)passwd);
        return (char *)(void *)0;
      }

      passwd[(signed long int)i] = (unsigned char)ch;
    }
    fclose(fp);
    rfbDesKey(fixedkey, 1);
    rfbDes(passwd, passwd);
    passwd[(signed long int)8] = (unsigned char)0;
    return (char *)passwd;
  }
}

// rfbDefaultGetCursorPtr
// file main.c line 696
static struct rfbCursor * rfbDefaultGetCursorPtr(struct _rfbClientRec *cl)
{
  return cl->screen->cursor;
}

// rfbDefaultKbdAddEvent
// file main.c line 631
static void rfbDefaultKbdAddEvent(signed char down, unsigned int keySym, struct _rfbClientRec *cl)
{
  ;
}

// rfbDefaultLog
// file main.c line 231
static void rfbDefaultLog(const char *format, ...)
{
  void **args;
  char rfbDefaultLog__1__buf[256l];
  signed long int log_clock;
  if(!(rfbEnableLogging == 0))
  {
    if(logMutex_initialized == 0)
    {
      pthread_mutex_init(&logMutex, (const union anonymous_0 *)(void *)0);
      logMutex_initialized = 1;
    }

    pthread_mutex_lock(&logMutex);
    args = (void **)&format;
    time(&log_clock);
    struct tm *return_value_localtime_1;
    return_value_localtime_1=localtime(&log_clock);
    strftime(rfbDefaultLog__1__buf, (unsigned long int)255, "%d/%m/%Y %X ", return_value_localtime_1);
    fprintf(stderr, "%s", (const void *)rfbDefaultLog__1__buf);
    vfprintf(stderr, format, args);
    fflush(stderr);
    args = ((void **)NULL);
    pthread_mutex_unlock(&logMutex);
  }

}

// rfbDefaultNewClientHook
// file main.c line 758
static enum rfbNewClientAction rfbDefaultNewClientHook(struct _rfbClientRec *cl)
{
  return (enum rfbNewClientAction)RFB_CLIENT_ACCEPT;
}

// rfbDefaultPasswordCheck
// file main.c line 702
static signed char rfbDefaultPasswordCheck(struct _rfbClientRec *cl, const char *response, signed int len)
{
  signed int i;
  char *passwd;
  passwd=rfbDecryptPasswdFromFile((char *)cl->screen->authPasswdData);
  if(passwd == ((char *)NULL))
  {
    rfbErr("Couldn't read password file: %s\n", cl->screen->authPasswdData);
    return (signed char)0;
  }

  else
  {
    rfbEncryptBytes(cl->authChallenge, passwd);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(passwd);
    i = (signed int)return_value_strlen_1;
    for( ; i >= 0; i = i - 1)
      passwd[(signed long int)i] = (char)0;
    free((void *)passwd);
    signed int return_value_memcmp_2;
    return_value_memcmp_2=memcmp((const void *)cl->authChallenge, (const void *)response, (unsigned long int)len);
    if(!(return_value_memcmp_2 == 0))
    {
      rfbErr("authProcessClientMessage: authentication failed from %s\n", cl->host);
      return (signed char)0;
    }

    else
      return (signed char)-1;
  }
}

// rfbDefaultPtrAddEvent
// file main.c line 636
extern void rfbDefaultPtrAddEvent(signed int buttonMask, signed int x, signed int y, struct _rfbClientRec *cl)
{
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *other_client;
  struct _rfbScreenInfo *s = cl->screen;
  _Bool tmp_if_expr_1;
  if(!(x == s->cursorX))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = y != s->cursorY ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    pthread_mutex_lock(&s->cursorMutex);
    s->cursorX = x;
    s->cursorY = y;
    pthread_mutex_unlock(&s->cursorMutex);
    if(!(cl->enableCursorPosUpdates == 0))
      cl->cursorWasMoved = (signed char)0;

    iterator=rfbGetClientIterator(s);
    do
    {
      other_client=rfbClientIteratorNext(iterator);
      if(other_client == ((struct _rfbClientRec *)NULL))
        break;

      if(!(other_client == cl))
      {
        if(!(other_client->enableCursorPosUpdates == 0))
          other_client->cursorWasMoved = (signed char)-1;

      }

    }
    while((_Bool)1);
    rfbReleaseClientIterator(iterator);
  }

}

// rfbDefaultSetXCutText
// file main.c line 663
static void rfbDefaultSetXCutText(char *text, signed int len, struct _rfbClientRec *cl)
{
  ;
}

// rfbDes
// file ../common/d3des.c line 150
extern void rfbDes(unsigned char *inblock, unsigned char *outblock)
{
  unsigned long int work[2l];
  scrunch(inblock, work);
  desfunc(work, KnL);
  unscrun(work, outblock);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// rfbDesKey
// file ../common/d3des.c line 74
extern void rfbDesKey(unsigned char *key, signed int edf)
{
  signed int i;
  signed int rfbDesKey__1__j;
  signed int l;
  signed int m;
  signed int n;
  unsigned char pc1m[56l];
  unsigned char pcr[56l];
  unsigned long int kn[32l];
  rfbDesKey__1__j = 0;
  for( ; !(rfbDesKey__1__j >= 56); rfbDesKey__1__j = rfbDesKey__1__j + 1)
  {
    l = (signed int)pc1[(signed long int)rfbDesKey__1__j];
    m = l & 07;
    pc1m[(signed long int)rfbDesKey__1__j] = (unsigned char)(((signed int)key[(signed long int)(l >> 3)] & (signed int)bytebit[(signed long int)m]) != 0 ? 1 : 0);
  }
  i = 0;
  for( ; !(i >= 16); i = i + 1)
  {
    if(edf == 1)
      m = 15 - i << 1;

    else
      m = i << 1;
    n = m + 1;
    kn[(signed long int)n] = (unsigned long int)0L;
    kn[(signed long int)m] = kn[(signed long int)n];
    rfbDesKey__1__j = 0;
    for( ; !(rfbDesKey__1__j >= 28); rfbDesKey__1__j = rfbDesKey__1__j + 1)
    {
      l = rfbDesKey__1__j + (signed int)totrot[(signed long int)i];
      if(!(l >= 28))
        pcr[(signed long int)rfbDesKey__1__j] = pc1m[(signed long int)l];

      else
        pcr[(signed long int)rfbDesKey__1__j] = pc1m[(signed long int)(l - 28)];
    }
    rfbDesKey__1__j = 28;
    for( ; !(rfbDesKey__1__j >= 56); rfbDesKey__1__j = rfbDesKey__1__j + 1)
    {
      l = rfbDesKey__1__j + (signed int)totrot[(signed long int)i];
      if(!(l >= 56))
        pcr[(signed long int)rfbDesKey__1__j] = pc1m[(signed long int)l];

      else
        pcr[(signed long int)rfbDesKey__1__j] = pc1m[(signed long int)(l - 28)];
    }
    rfbDesKey__1__j = 0;
    for( ; !(rfbDesKey__1__j >= 24); rfbDesKey__1__j = rfbDesKey__1__j + 1)
    {
      if(!(pcr[(signed long int)pc2[(signed long int)rfbDesKey__1__j]] == 0))
        kn[(signed long int)m] = kn[(signed long int)m] | bigbyte[(signed long int)rfbDesKey__1__j];

      if(!(pcr[(signed long int)pc2[(signed long int)(24 + rfbDesKey__1__j)]] == 0))
        kn[(signed long int)n] = kn[(signed long int)n] | bigbyte[(signed long int)rfbDesKey__1__j];

    }
  }
  cookey(kn);
  goto __CPROVER_DUMP_L19;

__CPROVER_DUMP_L19:
  ;
}

// rfbDisableExtension
// file main.c line 181
signed char rfbDisableExtension(struct _rfbClientRec *cl, struct _rfbProtocolExtension *extension)
{
  struct _rfbExtensionData *extData;
  struct _rfbExtensionData *prevData = (struct _rfbExtensionData *)(void *)0;
  extData = cl->extensions;
  for( ; !(extData == ((struct _rfbExtensionData *)NULL)); extData = extData->next)
  {
    if(extData->extension == extension)
    {
      if(!(extData->data == NULL))
        free(extData->data);

      if(prevData == ((struct _rfbExtensionData *)NULL))
        cl->extensions = extData->next;

      else
        prevData->next = extData->next;
      return (signed char)-1;
    }

    prevData = extData;
  }
  return (signed char)0;
}

// rfbDisconnectUDPSock
// file ../rfb/rfb.h line 746
extern void rfbDisconnectUDPSock(struct _rfbScreenInfo *rfbScreen)
{
  rfbScreen->udpSockConnected = (signed char)0;
}

// rfbDoCopyRect
// file main.c line 385
void rfbDoCopyRect(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2, signed int dx, signed int dy)
{
  struct sraRegion *region;
  region=sraRgnCreateRect(x1, y1, x2, y2);
  rfbDoCopyRegion(screen, region, dx, dy);
  sraRgnDestroy(region);
}

// rfbDoCopyRegion
// file main.c line 356
void rfbDoCopyRegion(struct _rfbScreenInfo *screen, struct sraRegion *copyRegion, signed int dx, signed int dy)
{
  struct sraRectangleIterator *i;
  struct _rect rect;
  signed int rfbDoCopyRegion__1__j;
  signed int widthInBytes;
  signed int bpp = (signed int)screen->serverFormat.bitsPerPixel / 8;
  signed int rowstride = screen->paddedWidthInBytes;
  char *in;
  char *out;
  i=sraRgnGetReverseIterator(copyRegion, (signed char)(dx < 0), (signed char)(dy < 0));
  signed char return_value_sraRgnIteratorNext_1;
  do
  {
    return_value_sraRgnIteratorNext_1=sraRgnIteratorNext(i, &rect);
    if(return_value_sraRgnIteratorNext_1 == 0)
      break;

    widthInBytes = (rect.x2 - rect.x1) * bpp;
    out = screen->frameBuffer + (signed long int)(rect.x1 * bpp) + (signed long int)(rect.y1 * rowstride);
    in = screen->frameBuffer + (signed long int)((rect.x1 - dx) * bpp) + (signed long int)((rect.y1 - dy) * rowstride);
    if(!(dy >= 0))
    {
      rfbDoCopyRegion__1__j = rect.y1;
      for( ; !(rfbDoCopyRegion__1__j >= rect.y2); in = in + (signed long int)rowstride)
      {
        memmove((void *)out, (const void *)in, (unsigned long int)widthInBytes);
        rfbDoCopyRegion__1__j = rfbDoCopyRegion__1__j + 1;
        out = out + (signed long int)rowstride;
      }
    }

    else
    {
      out = out + (signed long int)(rowstride * ((rect.y2 - rect.y1) - 1));
      in = in + (signed long int)(rowstride * ((rect.y2 - rect.y1) - 1));
      rfbDoCopyRegion__1__j = rect.y2 - 1;
      for( ; rfbDoCopyRegion__1__j >= rect.y1; in = in - (signed long int)rowstride)
      {
        memmove((void *)out, (const void *)in, (unsigned long int)widthInBytes);
        rfbDoCopyRegion__1__j = rfbDoCopyRegion__1__j - 1;
        out = out - (signed long int)rowstride;
      }
    }
  }
  while((_Bool)1);
  sraRgnReleaseIterator(i);
  rfbScheduleCopyRegion(screen, copyRegion, dx, dy);
}

// rfbDoNothingWithClient
// file main.c line 754
void rfbDoNothingWithClient(struct _rfbClientRec *cl)
{
  ;
}

// rfbDrawChar
// file font.c line 3
signed int rfbDrawChar(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, unsigned char c, unsigned int col)
{
  signed int i;
  signed int rfbDrawChar__1__j;
  signed int width;
  signed int height;
  unsigned char *data = font->data + (signed long int)font->metaData[(signed long int)((signed int)c * 5)];
  unsigned char d = *data;
  signed int rowstride = rfbScreen->paddedWidthInBytes;
  signed int bpp = (signed int)rfbScreen->serverFormat.bitsPerPixel / 8;
  char *colour = (char *)&col;
  if(rfbEndianTest == 0)
    colour = colour + (signed long int)(4 - bpp);

  width = font->metaData[(signed long int)((signed int)c * 5 + 1)];
  height = font->metaData[(signed long int)((signed int)c * 5 + 2)];
  x = x + font->metaData[(signed long int)((signed int)c * 5 + 3)];
  y = y + (-font->metaData[(signed long int)((signed int)c * 5 + 4)] - height) + 1;
  rfbDrawChar__1__j = 0;
  for( ; !(rfbDrawChar__1__j >= height); rfbDrawChar__1__j = rfbDrawChar__1__j + 1)
  {
    i = 0;
    for( ; !(i >= width); i = i + 1)
    {
      if((7 & i) == 0)
      {
        d = *data;
        data = data + 1l;
      }

      if(rfbDrawChar__1__j + y >= 0 && !((0x80 & (signed int)d) == 0))
      {
        if(!(rfbDrawChar__1__j + y >= rfbScreen->height))
        {
          if(i + x >= 0)
          {
            if(!(i + x >= rfbScreen->width))
              memcpy((void *)(rfbScreen->frameBuffer + (signed long int)((y + rfbDrawChar__1__j) * rowstride) + (signed long int)((x + i) * bpp)), (const void *)colour, (unsigned long int)bpp);

          }

        }

      }

      d = d << 1;
    }
  }
  return width;
}

// rfbDrawCharWithClip
// file font.c line 48
signed int rfbDrawCharWithClip(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, unsigned char c, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int col, unsigned int bcol)
{
  signed int i;
  signed int rfbDrawCharWithClip__1__j;
  signed int width;
  signed int height;
  unsigned char *data = font->data + (signed long int)font->metaData[(signed long int)((signed int)c * 5)];
  unsigned char d;
  signed int rowstride = rfbScreen->paddedWidthInBytes;
  signed int bpp = (signed int)rfbScreen->serverFormat.bitsPerPixel / 8;
  signed int extra_bytes = 0;
  char *colour = (char *)&col;
  char *bcolour = (char *)&bcol;
  if(rfbEndianTest == 0)
  {
    colour = colour + (signed long int)(4 - bpp);
    bcolour = bcolour + (signed long int)(4 - bpp);
  }

  width = font->metaData[(signed long int)((signed int)c * 5 + 1)];
  height = font->metaData[(signed long int)((signed int)c * 5 + 2)];
  x = x + font->metaData[(signed long int)((signed int)c * 5 + 3)];
  y = y + (-font->metaData[(signed long int)((signed int)c * 5 + 4)] - height) + 1;
  if(!(y >= y1))
  {
    y1 = y1 - y;
    data = data + (signed long int)((width + 7) / 8);
    height = height - y1;
    y = y + y1;
  }

  else
    y1 = 0;
  if(!(x >= x1))
  {
    x1 = x1 - x;
    data = data + (signed long int)x1;
    width = width - x1;
    x = x + x1;
    extra_bytes = extra_bytes + x1 / 8;
  }

  else
    x1 = 0;
  if(!(y2 >= height + y))
    height = height - ((y + height) - y2);

  if(!(x2 >= width + x))
  {
    extra_bytes = extra_bytes + ((x1 + width) / 8 - (((x + width) - x2) + 7) / 8);
    width = width - ((x + width) - x2);
  }

  d = *data;
  rfbDrawCharWithClip__1__j = y1;
  for( ; !(rfbDrawCharWithClip__1__j >= height); rfbDrawCharWithClip__1__j = rfbDrawCharWithClip__1__j + 1)
  {
    if(!((7 & x1) == 0))
      d = data[(signed long int)-1];

    i = x1;
    for( ; !(i >= width); i = i + 1)
    {
      if((7 & i) == 0)
      {
        d = *data;
        data = data + 1l;
      }

      if(!((0x80 & (signed int)d) == 0))
        memcpy((void *)(rfbScreen->frameBuffer + (signed long int)((y + rfbDrawCharWithClip__1__j) * rowstride) + (signed long int)((x + i) * bpp)), (const void *)colour, (unsigned long int)bpp);

      else
        if(!(bcol == col))
          memcpy((void *)(rfbScreen->frameBuffer + (signed long int)((y + rfbDrawCharWithClip__1__j) * rowstride) + (signed long int)((x + i) * bpp)), (const void *)bcolour, (unsigned long int)bpp);

      d = d << 1;
    }
    data = data + (signed long int)extra_bytes;
  }
  return width;
}

// rfbDrawLine
// file draw.c line 31
void rfbDrawLine(struct _rfbScreenInfo *s, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int col)
{
  signed int rowstride = s->paddedWidthInBytes;
  signed int bpp = s->bitsPerPixel >> 3;
  signed int i;
  char *colour = (char *)&col;
  if(rfbEndianTest == 0)
    colour = colour + (signed long int)(4 - bpp);

  signed int return_value_abs_1;
  return_value_abs_1=abs(x1 - x2);
  signed int return_value_abs_2;
  return_value_abs_2=abs(y1 - y2);
  if(!(return_value_abs_1 >= return_value_abs_2))
  {
    if(!(y2 >= y1))
    {
      i = x1;
      x1 = x2;
      x2 = i;
      i = y1;
      y1 = y2;
      y2 = i;
    }

    i = y1;
    for( ; y2 >= i; i = i + 1)
      memcpy((void *)(s->frameBuffer + (signed long int)(i * rowstride) + (signed long int)((x1 + ((i - y1) * (x2 - x1)) / (y2 - y1)) * bpp)), (const void *)colour, (unsigned long int)bpp);
    if(!(x2 >= x1))
    {
      i = x1;
      x1 = x2;
      x2 = i;
    }

    rfbMarkRectAsModified(s, x1, y1, x2 + 1, y2 + 1);
  }

  else
  {
    if(!(x2 >= x1))
    {
      i = x1;
      x1 = x2;
      x2 = i;
      i = y1;
      y1 = y2;
      y2 = i;
    }

    else
      if(x1 == x2)
      {
        rfbDrawPixel(s, x1, y1, col);
        goto __CPROVER_DUMP_L13;
      }

    i = x1;
    for( ; x2 >= i; i = i + 1)
      memcpy((void *)(s->frameBuffer + (signed long int)((y1 + ((i - x1) * (y2 - y1)) / (x2 - x1)) * rowstride) + (signed long int)(i * bpp)), (const void *)colour, (unsigned long int)bpp);
    if(!(y2 >= y1))
    {
      i = y1;
      y1 = y2;
      y2 = i;
    }

    rfbMarkRectAsModified(s, x1, y1, x2 + 1, y2 + 1);
  }

__CPROVER_DUMP_L13:
  ;
}

// rfbDrawPixel
// file draw.c line 20
void rfbDrawPixel(struct _rfbScreenInfo *s, signed int x, signed int y, unsigned int col)
{
  signed int rowstride = s->paddedWidthInBytes;
  signed int bpp = s->bitsPerPixel >> 3;
  char *colour = (char *)&col;
  if(rfbEndianTest == 0)
    colour = colour + (signed long int)(4 - bpp);

  memcpy((void *)(s->frameBuffer + (signed long int)(y * rowstride) + (signed long int)(x * bpp)), (const void *)colour, (unsigned long int)bpp);
  rfbMarkRectAsModified(s, x, y, x + 1, y + 1);
}

// rfbDrawString
// file font.c line 37
void rfbDrawString(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, const char *string, unsigned int colour)
{
  while(!(*string == 0))
  {
    signed int return_value_rfbDrawChar_1;
    return_value_rfbDrawChar_1=rfbDrawChar(rfbScreen, font, x, y, (unsigned char)*string, colour);
    x = x + return_value_rfbDrawChar_1;
    string = string + 1l;
  }
}

// rfbDrawStringWithClip
// file font.c line 104
void rfbDrawStringWithClip(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, signed int x, signed int y, const char *string, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int colour, unsigned int backColour)
{
  while(!(*string == 0))
  {
    signed int return_value_rfbDrawCharWithClip_1;
    return_value_rfbDrawCharWithClip_1=rfbDrawCharWithClip(rfbScreen, font, x, y, (unsigned char)*string, x1, y1, x2, y2, colour, backColour);
    x = x + return_value_rfbDrawCharWithClip_1;
    string = string + 1l;
  }
}

// rfbEnableExtension
// file main.c line 162
signed char rfbEnableExtension(struct _rfbClientRec *cl, struct _rfbProtocolExtension *extension, void *data)
{
  struct _rfbExtensionData *extData = cl->extensions;
  for( ; !(extData == ((struct _rfbExtensionData *)NULL)); extData = extData->next)
    if(extData->extension == extension)
      return (signed char)0;

  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct _rfbExtensionData) /*24ul*/ , (unsigned long int)1);
  extData = (struct _rfbExtensionData *)return_value_calloc_1;
  extData->extension = extension;
  extData->data = data;
  extData->next = cl->extensions;
  cl->extensions = extData;
  return (signed char)-1;
}

// rfbEncryptAndStorePasswd
// file ../rfb/rfbproto.h line 1471
extern signed int rfbEncryptAndStorePasswd(char *passwd, char *fname)
{
  struct _IO_FILE *fp;
  unsigned int i;
  unsigned char encryptedPasswd[8l];
  fp=fopen(fname, "w");
  if(fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    signed int return_value_fileno_1;
    return_value_fileno_1=fileno(fp);
    fchmod(return_value_fileno_1, (unsigned int)(0400 | 0200));
    i = (unsigned int)0;
    for( ; !(i >= 8u); i = i + 1u)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(passwd);
      if(!((unsigned long int)i >= return_value_strlen_2))
        encryptedPasswd[(signed long int)i] = (unsigned char)passwd[(signed long int)i];

      else
        encryptedPasswd[(signed long int)i] = (unsigned char)0;
    }
    rfbDesKey(fixedkey, 0);
    rfbDes(encryptedPasswd, encryptedPasswd);
    i = (unsigned int)0;
    for( ; !(i >= 8u); i = i + 1u)
      _IO_putc((signed int)encryptedPasswd[(signed long int)i], fp);
    fclose(fp);
    return 0;
  }
}

// rfbEncryptBytes
// file ../rfb/rfbproto.h line 1474
extern void rfbEncryptBytes(unsigned char *bytes, char *passwd)
{
  unsigned char key[8l];
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 8u); i = i + 1u)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(passwd);
    if(!((unsigned long int)i >= return_value_strlen_1))
      key[(signed long int)i] = (unsigned char)passwd[(signed long int)i];

    else
      key[(signed long int)i] = (unsigned char)0;
  }
  rfbDesKey(key, 0);
  i = (unsigned int)0;
  for( ; !(i >= 16u); i = i + (unsigned int)8)
    rfbDes(bytes + (signed long int)i, bytes + (signed long int)i);
}

// rfbEncryptBytes2
// file ../common/vncauth.c line 201
void rfbEncryptBytes2(unsigned char *where, const signed int length, unsigned char *key)
{
  signed int i;
  signed int rfbEncryptBytes2__1__j;
  rfbDesKey(key, 0);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    where[(signed long int)i] = where[(signed long int)i] ^ key[(signed long int)i];
  rfbDes(where, where);
  i = 8;
  for( ; !(i >= length); i = i + 8)
  {
    rfbEncryptBytes2__1__j = 0;
    for( ; !(rfbEncryptBytes2__1__j >= 8); rfbEncryptBytes2__1__j = rfbEncryptBytes2__1__j + 1)
      where[(signed long int)(i + rfbEncryptBytes2__1__j)] = where[(signed long int)(i + rfbEncryptBytes2__1__j)] ^ where[(signed long int)((i + rfbEncryptBytes2__1__j) - 8)];
    rfbDes(where + (signed long int)i, where + (signed long int)i);
  }
}

// rfbFilenameTranslate2DOS
// file rfbserver.c line 1300
signed char rfbFilenameTranslate2DOS(struct _rfbClientRec *cl, char *unixPath, char *path)
{
  signed int x;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
  {
    return_value=cl->screen->getFileTransferPermission(cl);
    tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->screen->permitFileTransfer != -1 ? (_Bool)1 : (_Bool)0;
  unsigned long int return_value_strlen_3;
  if(tmp_if_expr_2)
  {
    rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", (const void *)"", cl->host);
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    sprintf(path, "C:%s", unixPath);
    x = 2;
    do
    {
      return_value_strlen_3=strlen(path);
      if((unsigned long int)x >= return_value_strlen_3)
        break;

      if((signed int)path[(signed long int)x] == 47)
        path[(signed long int)x] = (char)92;

      x = x + 1;
    }
    while((_Bool)1);
    return (signed char)-1;
  }
}

// rfbFilenameTranslate2UNIX
// file rfbserver.c line 1262
signed char rfbFilenameTranslate2UNIX(struct _rfbClientRec *cl, char *path, char *unixPath, unsigned long int unixPathMaxLen)
{
  signed int x;
  char *home = (char *)(void *)0;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
  {
    return_value=cl->screen->getFileTransferPermission(cl);
    tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->screen->permitFileTransfer != -1 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_6;
  unsigned long int return_value_strlen_7;
  if(tmp_if_expr_2)
  {
    rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", (const void *)"", cl->host);
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(path);
    if(return_value_strlen_3 >= unixPathMaxLen)
      return (signed char)0;

    else
    {
      if((signed int)*path == 67)
        tmp_if_expr_6 = (signed int)path[(signed long int)1] == 58 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        strcpy(unixPath, &path[(signed long int)2]);

      else
      {
        home=getenv("HOME");
        if(!(home == ((char *)NULL)))
        {
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(path);
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(home);
          if(1ul + return_value_strlen_4 + return_value_strlen_5 >= unixPathMaxLen)
            return (signed char)0;

          strcpy(unixPath, home);
          strcat(unixPath, "/");
          strcat(unixPath, path);
        }

        else
          strcpy(unixPath, path);
      }
      x = 0;
      do
      {
        return_value_strlen_7=strlen(unixPath);
        if((unsigned long int)x >= return_value_strlen_7)
          break;

        if((signed int)unixPath[(signed long int)x] == 92)
          unixPath[(signed long int)x] = (char)47;

        x = x + 1;
      }
      while((_Bool)1);
      return (signed char)-1;
    }
  }
}

// rfbFillRect
// file draw.c line 3
void rfbFillRect(struct _rfbScreenInfo *s, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int col)
{
  signed int rowstride = s->paddedWidthInBytes;
  signed int bpp = s->bitsPerPixel >> 3;
  signed int i;
  signed int rfbFillRect__1__j;
  char *colour = (char *)&col;
  if(rfbEndianTest == 0)
    colour = colour + (signed long int)(4 - bpp);

  rfbFillRect__1__j = y1;
  for( ; !(rfbFillRect__1__j >= y2); rfbFillRect__1__j = rfbFillRect__1__j + 1)
  {
    i = x1;
    for( ; !(i >= x2); i = i + 1)
      memcpy((void *)(s->frameBuffer + (signed long int)(rfbFillRect__1__j * rowstride) + (signed long int)(i * bpp)), (const void *)colour, (unsigned long int)bpp);
  }
  rfbMarkRectAsModified(s, x1, y1, x2, y2);
}

// rfbFontBBox
// file font.c line 131
void rfbFontBBox(struct rfbFontData *font, unsigned char c, signed int *x1, signed int *y1, signed int *x2, signed int *y2)
{
  *x1 = *x1 + font->metaData[(signed long int)((signed int)c * 5 + 3)];
  *y1 = *y1 + (-font->metaData[(signed long int)((signed int)c * 5 + 4)] - font->metaData[(signed long int)((signed int)c * 5 + 2)]) + 1;
  *x2 = *x1 + font->metaData[(signed long int)((signed int)c * 5 + 1)] + 1;
  *y2 = *y1 + font->metaData[(signed long int)((signed int)c * 5 + 2)] + 1;
}

// rfbFreeCursor
// file ../rfb/rfb.h line 929
extern void rfbFreeCursor(struct rfbCursor *cursor)
{
  if(!(cursor == ((struct rfbCursor *)NULL)))
  {
    if(!(cursor->cleanupRichSource == 0))
    {
      if(!(cursor->richSource == ((unsigned char *)NULL)))
        free((void *)cursor->richSource);

    }

    if(!(cursor->cleanupRichSource == 0))
    {
      if(!(cursor->alphaSource == ((unsigned char *)NULL)))
        free((void *)cursor->alphaSource);

    }

    if(!(cursor->cleanupSource == 0))
    {
      if(!(cursor->source == ((unsigned char *)NULL)))
        free((void *)cursor->source);

    }

    if(!(cursor->cleanupMask == 0))
    {
      if(!(cursor->mask == ((unsigned char *)NULL)))
        free((void *)cursor->mask);

    }

    if(!(cursor->cleanup == 0))
      free((void *)cursor);

    else
    {
      cursor->cleanupRichSource = (signed char)0;
      cursor->cleanupMask = cursor->cleanupRichSource;
      cursor->cleanupSource = cursor->cleanupMask;
      cursor->cleanup = cursor->cleanupSource;
      cursor->richSource = (unsigned char *)(void *)0;
      cursor->mask = cursor->richSource;
      cursor->source = cursor->mask;
      cursor->alphaSource = (unsigned char *)(void *)0;
    }
  }

}

// rfbFreeFont
// file font.c line 191
void rfbFreeFont(struct rfbFontData *f)
{
  free((void *)f->data);
  free((void *)f->metaData);
  free((void *)f);
}

// rfbFreeUltraData
// file ultra.c line 30
void rfbFreeUltraData(struct _rfbClientRec *cl)
{
  if(!(cl->compStreamInitedLZO == 0))
  {
    free((void *)cl->lzoWrkMem);
    cl->compStreamInitedLZO = (signed char)0;
  }

}

// rfbFreeZrleData
// file private.h line 25
void rfbFreeZrleData(struct _rfbClientRec *cl)
{
  if(!(cl->zrleData == NULL))
    zrleOutStreamFree((struct anonymous_11 *)cl->zrleData);

  cl->zrleData = (void *)0;
  if(!(cl->zrleBeforeBuf == ((char *)NULL)))
    free((void *)cl->zrleBeforeBuf);

  cl->zrleBeforeBuf = (char *)(void *)0;
  if(!(cl->paletteHelper == NULL))
    free(cl->paletteHelper);

  cl->paletteHelper = (void *)0;
}

// rfbGetClientIterator
// file ../rfb/rfb.h line 777
extern struct rfbClientIterator * rfbGetClientIterator(struct _rfbScreenInfo *rfbScreen)
{
  struct rfbClientIterator *i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct rfbClientIterator) /*24ul*/ );
  i = (struct rfbClientIterator *)return_value_malloc_1;
  i->next = (struct _rfbClientRec *)(void *)0;
  i->screen = rfbScreen;
  i->closedToo = (signed char)0;
  return i;
}

// rfbGetClientIteratorWithClosed
// file rfbserver.c line 185
struct rfbClientIterator * rfbGetClientIteratorWithClosed(struct _rfbScreenInfo *rfbScreen)
{
  struct rfbClientIterator *i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct rfbClientIterator) /*24ul*/ );
  i = (struct rfbClientIterator *)return_value_malloc_1;
  i->next = (struct _rfbClientRec *)(void *)0;
  i->screen = rfbScreen;
  i->closedToo = (signed char)-1;
  return i;
}

// rfbGetExtensionClientData
// file main.c line 202
void * rfbGetExtensionClientData(struct _rfbClientRec *cl, struct _rfbProtocolExtension *extension)
{
  struct _rfbExtensionData *data = cl->extensions;
  for( ; !(data == ((struct _rfbExtensionData *)NULL)); data = data->next)
    if(data->extension == extension)
      break;

  if(data == ((struct _rfbExtensionData *)NULL))
  {
    rfbLog("Extension is not enabled !\n");
    return (void *)0;
  }

  else
    return data->data;
}

// rfbGetExtensionIterator
// file main.c line 146
struct _rfbProtocolExtension * rfbGetExtensionIterator()
{
  if(extMutex_initialized == 0)
  {
    pthread_mutex_init(&extMutex, (const union anonymous_0 *)(void *)0);
    extMutex_initialized = 1;
  }

  pthread_mutex_lock(&extMutex);
  return rfbExtensionHead;
}

// rfbGetScreen
// file main.c line 809
extern struct _rfbScreenInfo * rfbGetScreen(signed int *argc, char **argv, signed int width, signed int height, signed int bitsPerSample, signed int samplesPerPixel, signed int bytesPerPixel)
{
  struct _rfbScreenInfo *screen;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct _rfbScreenInfo) /*928ul*/ , (unsigned long int)1);
  screen = (struct _rfbScreenInfo *)return_value_calloc_1;
  if(logMutex_initialized == 0)
  {
    pthread_mutex_init(&logMutex, (const union anonymous_0 *)(void *)0);
    logMutex_initialized = 1;
  }

  if(!((3 & width) == 0))
    rfbErr("WARNING: Width (%d) is not a multiple of 4. VncViewer has problems with that.\n", width);

  screen->autoPort = (signed char)0;
  screen->clientHead = (struct _rfbClientRec *)(void *)0;
  screen->pointerClient = (struct _rfbClientRec *)(void *)0;
  screen->port = 5900;
  screen->ipv6port = 5900;
  screen->socketState = (enum rfbSocketState)RFB_SOCKET_INIT;
  screen->inetdInitDone = (signed char)0;
  screen->inetdSock = -1;
  screen->udpSock = -1;
  screen->udpSockConnected = (signed char)0;
  screen->udpPort = 0;
  screen->udpClient = (struct _rfbClientRec *)(void *)0;
  screen->maxFd = 0;
  screen->listenSock = -1;
  screen->listen6Sock = -1;
  screen->httpInitDone = (signed char)0;
  screen->httpEnableProxyConnect = (signed char)0;
  screen->httpPort = 0;
  screen->http6Port = 0;
  screen->httpDir = (char *)(void *)0;
  screen->httpListenSock = -1;
  screen->httpListen6Sock = -1;
  screen->httpSock = -1;
  screen->desktopName = "LibVNCServer";
  screen->alwaysShared = (signed char)0;
  screen->neverShared = (signed char)0;
  screen->dontDisconnect = (signed char)0;
  screen->authPasswdData = (void *)0;
  screen->authPasswdFirstViewOnly = 1;
  screen->width = width;
  screen->height = height;
  screen->depth = 8 * bytesPerPixel;
  screen->bitsPerPixel = screen->depth;
  screen->passwordCheck = rfbDefaultPasswordCheck;
  screen->ignoreSIGPIPE = (signed char)-1;
  screen->progressiveSliceHeight = 0;
  screen->listenInterface=htonl((unsigned int)0x00000000);
  screen->deferUpdateTime = 5;
  screen->maxRectsPerUpdate = 50;
  screen->handleEventsEagerly = (signed char)0;
  screen->protocolMajorVersion = 3;
  screen->protocolMinorVersion = 8;
  screen->permitFileTransfer = (signed char)0;
  signed char return_value_rfbProcessArguments_2;
  return_value_rfbProcessArguments_2=rfbProcessArguments(screen, argc, argv);
  if(return_value_rfbProcessArguments_2 == 0)
  {
    free((void *)screen);
    return (struct _rfbScreenInfo *)(void *)0;
  }

  else
  {
    gethostname(screen->thisHost, (unsigned long int)255);
    screen->paddedWidthInBytes = width * bytesPerPixel;
    rfbInitServerFormat(screen, bitsPerSample);
    screen->underCursorBufferLen = 0;
    screen->cursorY = screen->underCursorBufferLen;
    screen->cursorX = screen->cursorY;
    screen->underCursorBuffer = (char *)(void *)0;
    screen->dontConvertRichCursorToXCursor = (signed char)0;
    screen->cursor = &myCursor;
    pthread_mutex_init(&screen->cursorMutex, (const union anonymous_0 *)(void *)0);
    screen->backgroundLoop = (signed char)0;
    screen->kbdAddEvent = rfbDefaultKbdAddEvent;
    screen->kbdReleaseAllKeys = rfbDoNothingWithClient;
    screen->ptrAddEvent = rfbDefaultPtrAddEvent;
    screen->setXCutText = rfbDefaultSetXCutText;
    screen->getCursorPtr = rfbDefaultGetCursorPtr;
    screen->setTranslateFunction = rfbSetTranslateFunction;
    screen->newClientHook = rfbDefaultNewClientHook;
    screen->displayHook = (void (*)(struct _rfbClientRec *))(void *)0;
    screen->displayFinishedHook = (void (*)(struct _rfbClientRec *, signed int))(void *)0;
    screen->getKeyboardLedStateHook = (signed int (*)(struct _rfbScreenInfo *))(void *)0;
    screen->xvpHook = (signed char (*)(struct _rfbClientRec *, unsigned char, unsigned char))(void *)0;
    rfbClientListInit(screen);
    return screen;
  }
}

// rfbGetTightClientData
// file tightvnc-filetransfer/rfbtightserver.c line 41
struct _rfbTightClientRec * rfbGetTightClientData(struct _rfbClientRec *cl)
{
  struct _rfbTightClientRec *rtcp;
  void *return_value_rfbGetExtensionClientData_1;
  return_value_rfbGetExtensionClientData_1=rfbGetExtensionClientData(cl, &tightVncFileTransferExtension);
  rtcp = (struct _rfbTightClientRec *)return_value_rfbGetExtensionClientData_1;
  if(rtcp == ((struct _rfbTightClientRec *)NULL))
  {
    rfbLog("Extension client data is null, closing the connection !\n");
    rfbCloseClient(cl);
  }

  return rtcp;
}

// rfbGotXCutText
// file cutpaste.c line 35
void rfbGotXCutText(struct _rfbScreenInfo *rfbScreen, char *str, signed int len)
{
  rfbSendServerCutText(rfbScreen, str, len);
}

// rfbHandleSecTypeTight
// file tightvnc-filetransfer/rfbtightserver.c line 495
void rfbHandleSecTypeTight(struct _rfbClientRec *cl)
{
  struct _rfbTightClientRec *rtcp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _rfbTightClientRec) /*8320ul*/ );
  rtcp = (struct _rfbTightClientRec *)return_value_malloc_1;
  rfbLog("tightvnc-filetransfer/rfbHandleSecTypeTight\n");
  if(rtcp == ((struct _rfbTightClientRec *)NULL))
  {
    rfbLog("Memory error has occured while handling Tight security type... closing connection.\n");
    rfbCloseClient(cl);
  }

  else
  {
    memset((void *)rtcp, 0, sizeof(struct _rfbTightClientRec) /*8320ul*/ );
    rtcp->rcft.rcfd.downloadFD = -1;
    rtcp->rcft.rcfu.uploadFD = -1;
    rfbEnableExtension(cl, &tightVncFileTransferExtension, (void *)rtcp);
    rfbSendTunnelingCaps(cl);
  }
}

// rfbHideCursor
// file private.h line 7
void rfbHideCursor(struct _rfbClientRec *cl)
{
  struct _rfbScreenInfo *s = cl->screen;
  struct rfbCursor *c = s->cursor;
  signed int rfbHideCursor__1__j;
  signed int x1;
  signed int x2;
  signed int y1;
  signed int y2;
  signed int bpp = (signed int)s->serverFormat.bitsPerPixel / 8;
  signed int rowstride = s->paddedWidthInBytes;
  pthread_mutex_lock(&s->cursorMutex);
  if(c == ((struct rfbCursor *)NULL))
    pthread_mutex_unlock(&s->cursorMutex);

  else
  {
    x1 = cl->cursorX - (signed int)c->xhot;
    x2 = x1 + (signed int)c->width;
    if(!(x1 >= 0))
      x1 = 0;

    if(x2 >= s->width)
      x2 = s->width - 1;

    x2 = x2 - x1;
    if(!(x2 >= 1))
      pthread_mutex_unlock(&s->cursorMutex);

    else
    {
      y1 = cl->cursorY - (signed int)c->yhot;
      y2 = y1 + (signed int)c->height;
      if(!(y1 >= 0))
        y1 = 0;

      if(y2 >= s->height)
        y2 = s->height - 1;

      y2 = y2 - y1;
      if(!(y2 >= 1))
        pthread_mutex_unlock(&s->cursorMutex);

      else
      {
        rfbHideCursor__1__j = 0;
        for( ; !(rfbHideCursor__1__j >= y2); rfbHideCursor__1__j = rfbHideCursor__1__j + 1)
          memcpy((void *)(s->frameBuffer + (signed long int)((y1 + rfbHideCursor__1__j) * rowstride) + (signed long int)(x1 * bpp)), (const void *)(s->underCursorBuffer + (signed long int)(rfbHideCursor__1__j * x2 * bpp)), (unsigned long int)(x2 * bpp));
        rfbScaledScreenUpdate(s, x1, y1, x1 + x2, y1 + y2);
        pthread_mutex_unlock(&s->cursorMutex);
      }
    }
  }
}

// rfbHttpCheckFds
// file ../rfb/rfb.h line 828
extern void rfbHttpCheckFds(struct _rfbScreenInfo *rfbScreen)
{
  signed int nfds;
  struct anonymous_16 fds;
  struct timeval tv;
  struct sockaddr_storage addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_2;
  _Bool tmp_if_expr_6;
  if(!(rfbScreen->httpDir == ((char *)NULL)))
  {
    if(rfbScreen->httpListenSock >= 0)
    {
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&fds)->__fds_bits[(signed long int)(rfbScreen->httpListenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(rfbScreen->httpListenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->httpListenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(rfbScreen->httpListen6Sock >= 0)
        (&fds)->__fds_bits[(signed long int)(rfbScreen->httpListen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(rfbScreen->httpListen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->httpListen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      if(rfbScreen->httpSock >= 0)
        (&fds)->__fds_bits[(signed long int)(rfbScreen->httpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(rfbScreen->httpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->httpSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

      tv.tv_sec = (signed long int)0;
      tv.tv_usec = (signed long int)0;
      if(!(rfbScreen->httpListenSock >= rfbScreen->httpSock))
        tmp_if_expr_1 = rfbScreen->httpSock;

      else
        tmp_if_expr_1 = rfbScreen->httpListenSock;
      if(!(tmp_if_expr_1 >= rfbScreen->httpListen6Sock))
        tmp_if_expr_3 = rfbScreen->httpListen6Sock;

      else
      {
        if(!(rfbScreen->httpListenSock >= rfbScreen->httpSock))
          tmp_if_expr_2 = rfbScreen->httpSock;

        else
          tmp_if_expr_2 = rfbScreen->httpListenSock;
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      nfds=select(tmp_if_expr_3 + 1, &fds, (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0, &tv);
      if(!(nfds == 0))
      {
        if(!(nfds >= 0))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 4))
            rfbLogPerror("httpCheckFds: select");

          goto __CPROVER_DUMP_L23;
        }

        if(rfbScreen->httpSock >= 0)
        {
          if(!((fds.__fds_bits[(signed long int)(rfbScreen->httpSock / 8)] & (signed long int)(1UL << rfbScreen->httpSock % 8)) == 0l))
            httpProcessInput(rfbScreen);

        }

        if(!((fds.__fds_bits[(signed long int)(rfbScreen->httpListenSock / 8)] & (signed long int)(1UL << rfbScreen->httpListenSock % 8)) == 0l))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = ((&fds)->__fds_bits[(signed long int)(rfbScreen->httpListen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << rfbScreen->httpListen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          if(rfbScreen->httpSock >= 0)
            close(rfbScreen->httpSock);

          if(!((fds.__fds_bits[(signed long int)(rfbScreen->httpListenSock / 8)] & (signed long int)(1UL << rfbScreen->httpListenSock % 8)) == 0l))
          {
            rfbScreen->httpSock=accept(rfbScreen->httpListenSock, (struct sockaddr *)&addr, &addrlen);
            if(!(rfbScreen->httpSock >= 0))
            {
              rfbLogPerror("httpCheckFds: accept");
              goto __CPROVER_DUMP_L23;
            }

          }

          else
            if(!((fds.__fds_bits[(signed long int)(rfbScreen->httpListen6Sock / 8)] & (signed long int)(1UL << rfbScreen->httpListen6Sock % 8)) == 0l))
            {
              rfbScreen->httpSock=accept(rfbScreen->httpListen6Sock, (struct sockaddr *)&addr, &addrlen);
              if(!(rfbScreen->httpSock >= 0))
              {
                rfbLogPerror("httpCheckFds: accept");
                goto __CPROVER_DUMP_L23;
              }

            }

          signed char return_value_rfbSetNonBlocking_5;
          return_value_rfbSetNonBlocking_5=rfbSetNonBlocking(rfbScreen->httpSock);
          if(return_value_rfbSetNonBlocking_5 == 0)
          {
            close(rfbScreen->httpSock);
            rfbScreen->httpSock = -1;
            goto __CPROVER_DUMP_L23;
          }

        }

      }

    }

  }


__CPROVER_DUMP_L23:
  ;
}

// rfbHttpInitSockets
// file ../rfb/rfb.h line 826
extern void rfbHttpInitSockets(struct _rfbScreenInfo *rfbScreen)
{
  if(rfbScreen->httpInitDone == 0)
  {
    rfbScreen->httpInitDone = (signed char)-1;
    if(!(rfbScreen->httpDir == ((char *)NULL)))
    {
      if(rfbScreen->httpPort == 0)
        rfbScreen->httpPort = rfbScreen->port - 100;

      rfbScreen->httpListenSock=rfbListenOnTCPPort(rfbScreen->httpPort, rfbScreen->listenInterface);
      if(!(rfbScreen->httpListenSock >= 0))
        rfbLogPerror("ListenOnTCPPort");

      else
      {
        rfbLog("Listening for HTTP connections on TCP port %d\n", rfbScreen->httpPort);
        rfbLog("  URL http://%s:%d\n", (const void *)rfbScreen->thisHost, rfbScreen->httpPort);
        if(rfbScreen->http6Port == 0)
          rfbScreen->http6Port = rfbScreen->ipv6port - 100;

        rfbScreen->httpListen6Sock=rfbListenOnTCP6Port(rfbScreen->http6Port, rfbScreen->listen6Interface);
        if(rfbScreen->httpListen6Sock >= 0)
        {
          rfbLog("Listening for HTTP connections on TCP6 port %d\n", rfbScreen->http6Port);
          rfbLog("  URL http://%s:%d\n", (const void *)rfbScreen->thisHost, rfbScreen->http6Port);
        }

      }
    }

  }

}

// rfbHttpShutdownSockets
// file ../rfb/rfb.h line 827
extern void rfbHttpShutdownSockets(struct _rfbScreenInfo *rfbScreen)
{
  if(rfbScreen->httpSock >= 0)
  {
    close(rfbScreen->httpSock);
    (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->httpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->httpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->httpSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
    rfbScreen->httpSock = -1;
  }

  if(rfbScreen->httpListenSock >= 0)
  {
    close(rfbScreen->httpListenSock);
    (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->httpListenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->httpListenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->httpListenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
    rfbScreen->httpListenSock = -1;
  }

  if(rfbScreen->httpListen6Sock >= 0)
  {
    close(rfbScreen->httpListen6Sock);
    (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->httpListen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->httpListen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->httpListen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
    rfbScreen->httpListen6Sock = -1;
  }

}

// rfbIncrClientRef
// file ../rfb/rfb.h line 780
extern void rfbIncrClientRef(struct _rfbClientRec *cl)
{
  pthread_mutex_lock(&cl->refCountMutex);
  cl->refCount = cl->refCount + 1;
  pthread_mutex_unlock(&cl->refCountMutex);
}

// rfbInitColourMapSingleTable16
// file tableinitcmtemplate.c line 46
static void rfbInitColourMapSingleTable16(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap)
{
  unsigned int i;
  unsigned int r;
  unsigned int g;
  unsigned int b;
  unsigned short int *t;
  unsigned int nEntries = (unsigned int)(1 << (signed int)in->bitsPerPixel);
  signed int shift = colourMap->is16 != 0 ? 16 : 8;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nEntries * sizeof(unsigned short int) /*2ul*/ );
  *table = (char *)return_value_malloc_1;
  t = (unsigned short int *)*table;
  i = (unsigned int)0;
  for( ; !(i >= nEntries); i = i + 1u)
  {
    b = (unsigned int)0;
    g = b;
    r = g;
    if(!(i >= colourMap->count))
    {
      if(!(colourMap->is16 == 0))
      {
        r = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }

      else
      {
        r = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }
    }

    t[(signed long int)i] = (unsigned short int)((r * (unsigned int)(1 + (signed int)out->redMax) >> shift) << (signed int)out->redShift | (g * (unsigned int)(1 + (signed int)out->greenMax) >> shift) << (signed int)out->greenShift | (b * (unsigned int)(1 + (signed int)out->blueMax) >> shift) << (signed int)out->blueShift);
    if(!(out->bigEndian == in->bigEndian))
      t[(signed long int)i] = (unsigned short int)(((signed int)t[(signed long int)i] & 0xff) << 8 | (signed int)t[(signed long int)i] >> 8 & 0xff);

  }
}

// rfbInitColourMapSingleTable24
// file tableinit24.c line 31
static void rfbInitColourMapSingleTable24(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap)
{
  unsigned int i;
  unsigned int r;
  unsigned int g;
  unsigned int b;
  unsigned int outValue;
  unsigned char *t;
  unsigned char c;
  unsigned int nEntries = (unsigned int)(1 << (signed int)in->bitsPerPixel);
  signed int shift = colourMap->is16 != 0 ? 16 : 8;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(nEntries * (unsigned int)3 + (unsigned int)1));
  *table = (char *)return_value_malloc_1;
  t = (unsigned char *)*table;
  i = (unsigned int)0;
  for( ; !(i >= nEntries); i = i + 1u)
  {
    b = (unsigned int)0;
    g = b;
    r = g;
    if(!(i >= colourMap->count))
    {
      if(!(colourMap->is16 == 0))
      {
        r = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }

      else
      {
        r = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }
    }

    outValue = (r * (unsigned int)(1 + (signed int)out->redMax) >> shift) << (signed int)out->redShift | (g * (unsigned int)(1 + (signed int)out->greenMax) >> shift) << (signed int)out->greenShift | (b * (unsigned int)(1 + (signed int)out->blueMax) >> shift) << (signed int)out->blueShift;
    *((unsigned int *)&t[(signed long int)((unsigned int)3 * i)]) = outValue;
    if(rfbEndianTest == 0)
      memmove((void *)(t + (signed long int)((unsigned int)3 * i)), (const void *)(t + (signed long int)((unsigned int)3 * i) + (signed long int)1), (unsigned long int)3);

    if(!(out->bigEndian == in->bigEndian))
    {
      c = t[(signed long int)((unsigned int)3 * i)];
      t[(signed long int)((unsigned int)3 * i)] = t[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      t[(signed long int)((unsigned int)3 * i + (unsigned int)2)] = c;
    }

  }
}

// rfbInitColourMapSingleTable32
// file tableinitcmtemplate.c line 46
static void rfbInitColourMapSingleTable32(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap)
{
  unsigned int i;
  unsigned int r;
  unsigned int g;
  unsigned int b;
  unsigned int *t;
  unsigned int nEntries = (unsigned int)(1 << (signed int)in->bitsPerPixel);
  signed int shift = colourMap->is16 != 0 ? 16 : 8;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nEntries * sizeof(unsigned int) /*4ul*/ );
  *table = (char *)return_value_malloc_1;
  t = (unsigned int *)*table;
  i = (unsigned int)0;
  for( ; !(i >= nEntries); i = i + 1u)
  {
    b = (unsigned int)0;
    g = b;
    r = g;
    if(!(i >= colourMap->count))
    {
      if(!(colourMap->is16 == 0))
      {
        r = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }

      else
      {
        r = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }
    }

    t[(signed long int)i] = (r * (unsigned int)(1 + (signed int)out->redMax) >> shift) << (signed int)out->redShift | (g * (unsigned int)(1 + (signed int)out->greenMax) >> shift) << (signed int)out->greenShift | (b * (unsigned int)(1 + (signed int)out->blueMax) >> shift) << (signed int)out->blueShift;
    if(!(out->bigEndian == in->bigEndian))
      t[(signed long int)i] = t[(signed long int)i] >> 24 | (t[(signed long int)i] & (unsigned int)0x00ff0000) >> 8 | (t[(signed long int)i] & (unsigned int)0x0000ff00) << 8 | t[(signed long int)i] << 24;

  }
}

// rfbInitColourMapSingleTable8
// file tableinitcmtemplate.c line 46
static void rfbInitColourMapSingleTable8(char **table, struct anonymous_7 *in, struct anonymous_7 *out, struct anonymous_15 *colourMap)
{
  unsigned int i;
  unsigned int r;
  unsigned int g;
  unsigned int b;
  unsigned char *t;
  unsigned int nEntries = (unsigned int)(1 << (signed int)in->bitsPerPixel);
  signed int shift = colourMap->is16 != 0 ? 16 : 8;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nEntries * sizeof(unsigned char) /*1ul*/ );
  *table = (char *)return_value_malloc_1;
  t = (unsigned char *)*table;
  i = (unsigned int)0;
  for( ; !(i >= nEntries); i = i + 1u)
  {
    b = (unsigned int)0;
    g = b;
    r = g;
    if(!(i >= colourMap->count))
    {
      if(!(colourMap->is16 == 0))
      {
        r = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.shorts[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }

      else
      {
        r = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)0)];
        g = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)1)];
        b = (unsigned int)colourMap->data.bytes[(signed long int)((unsigned int)3 * i + (unsigned int)2)];
      }
    }

    t[(signed long int)i] = (unsigned char)((r * (unsigned int)(1 + (signed int)out->redMax) >> shift) << (signed int)out->redShift | (g * (unsigned int)(1 + (signed int)out->greenMax) >> shift) << (signed int)out->greenShift | (b * (unsigned int)(1 + (signed int)out->blueMax) >> shift) << (signed int)out->blueShift);
  }
}

// rfbInitOneRGBTable16
// file tableinittctemplate.c line 122
static void rfbInitOneRGBTable16(unsigned short int *table, signed int inMax, signed int outMax, signed int outShift, signed int swap)
{
  signed int i;
  signed int nEntries = inMax + 1;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    table[(signed long int)i] = (unsigned short int)((i * outMax + inMax / 2) / inMax << outShift);
    if(!(swap == 0))
      table[(signed long int)i] = (unsigned short int)(((signed int)table[(signed long int)i] & 0xff) << 8 | (signed int)table[(signed long int)i] >> 8 & 0xff);

  }
}

// rfbInitOneRGBTable24
// file tableinit24.c line 139
static void rfbInitOneRGBTable24(unsigned char *table, signed int inMax, signed int outMax, signed int outShift, signed int swap)
{
  signed int i;
  signed int nEntries = inMax + 1;
  unsigned int outValue;
  unsigned char c;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    outValue = (unsigned int)((i * outMax + inMax / 2) / inMax << outShift);
    *((unsigned int *)&table[(signed long int)(3 * i)]) = outValue;
    if(rfbEndianTest == 0)
      memmove((void *)(table + (signed long int)(3 * i)), (const void *)(table + (signed long int)(3 * i) + (signed long int)1), (unsigned long int)3);

    if(!(swap == 0))
    {
      c = table[(signed long int)(3 * i)];
      table[(signed long int)(3 * i)] = table[(signed long int)(3 * i + 2)];
      table[(signed long int)(3 * i + 2)] = c;
    }

  }
}

// rfbInitOneRGBTable32
// file tableinittctemplate.c line 122
static void rfbInitOneRGBTable32(unsigned int *table, signed int inMax, signed int outMax, signed int outShift, signed int swap)
{
  signed int i;
  signed int nEntries = inMax + 1;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    table[(signed long int)i] = (unsigned int)((i * outMax + inMax / 2) / inMax << outShift);
    if(!(swap == 0))
      table[(signed long int)i] = table[(signed long int)i] >> 24 | (table[(signed long int)i] & (unsigned int)0x00ff0000) >> 8 | (table[(signed long int)i] & (unsigned int)0x0000ff00) << 8 | table[(signed long int)i] << 24;

  }
}

// rfbInitOneRGBTable8
// file tableinittctemplate.c line 122
static void rfbInitOneRGBTable8(unsigned char *table, signed int inMax, signed int outMax, signed int outShift, signed int swap)
{
  signed int i;
  signed int nEntries = inMax + 1;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
    table[(signed long int)i] = (unsigned char)((i * outMax + inMax / 2) / inMax << outShift);
}

// rfbInitServerFormat
// file main.c line 768
static void rfbInitServerFormat(struct _rfbScreenInfo *screen, signed int bitsPerSample)
{
  struct anonymous_7 *format = &screen->serverFormat;
  format->bitsPerPixel = (unsigned char)screen->bitsPerPixel;
  format->depth = (unsigned char)screen->depth;
  format->bigEndian = (unsigned char)(rfbEndianTest != 0 ? 0 : -1);
  format->trueColour = (unsigned char)-1;
  screen->colourMap.count = (unsigned int)0;
  screen->colourMap.is16 = (signed char)0;
  screen->colourMap.data.bytes = (unsigned char *)(void *)0;
  if((signed int)format->bitsPerPixel == 8)
  {
    format->redMax = (unsigned short int)7;
    format->greenMax = (unsigned short int)7;
    format->blueMax = (unsigned short int)3;
    format->redShift = (unsigned char)0;
    format->greenShift = (unsigned char)3;
    format->blueShift = (unsigned char)6;
  }

  else
  {
    format->redMax = (unsigned short int)((1 << bitsPerSample) - 1);
    format->greenMax = (unsigned short int)((1 << bitsPerSample) - 1);
    format->blueMax = (unsigned short int)((1 << bitsPerSample) - 1);
    if(!(rfbEndianTest == 0))
    {
      format->redShift = (unsigned char)0;
      format->greenShift = (unsigned char)bitsPerSample;
      format->blueShift = (unsigned char)(bitsPerSample * 2);
    }

    else
      if((signed int)format->bitsPerPixel == 3)
      {
        format->redShift = (unsigned char)(bitsPerSample * 2);
        format->greenShift = (unsigned char)(bitsPerSample * 1);
        format->blueShift = (unsigned char)0;
      }

      else
      {
        format->redShift = (unsigned char)(bitsPerSample * 3);
        format->greenShift = (unsigned char)(bitsPerSample * 2);
        format->blueShift = (unsigned char)bitsPerSample;
      }
  }
}

// rfbInitServerWithPthreadsAndZRLE
// file main.c line 1046
extern void rfbInitServerWithPthreadsAndZRLE(struct _rfbScreenInfo *screen)
{
  rfbInitSockets(screen);
  rfbHttpInitSockets(screen);
  if(!(screen->ignoreSIGPIPE == 0))
    signal(13, (void (*)(signed int))1);

}

// rfbInitSockets
// file ../rfb/rfb.h line 744
extern void rfbInitSockets(struct _rfbScreenInfo *rfbScreen)
{
  unsigned int iface = rfbScreen->listenInterface;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  if(!((signed int)rfbScreen->socketState == RFB_SOCKET_READY))
  {
    rfbScreen->socketState = (enum rfbSocketState)RFB_SOCKET_READY;
    if(!(rfbScreen->inetdSock == -1))
    {
      const signed int one = 1;
      signed char return_value_rfbSetNonBlocking_1;
      return_value_rfbSetNonBlocking_1=rfbSetNonBlocking(rfbScreen->inetdSock);
      if(return_value_rfbSetNonBlocking_1 == 0)
        goto __CPROVER_DUMP_L28;

      signed int return_value_setsockopt_2;
      return_value_setsockopt_2=setsockopt(rfbScreen->inetdSock, 6, 1, (const void *)(char *)&one, (unsigned int)sizeof(const signed int) /*4ul*/ );
      if(!(return_value_setsockopt_2 >= 0))
      {
        rfbLogPerror("setsockopt");
        goto __CPROVER_DUMP_L28;
      }

      do
      {
        signed int rfbInitSockets__1__2__2____d0;
        signed int rfbInitSockets__1__2__2____d1;
        asm("cld; rep; stosq" : "=c"(rfbInitSockets__1__2__2____d0), "=D"(rfbInitSockets__1__2__2____d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfbScreen->allFds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->inetdSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->inetdSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->inetdSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      rfbScreen->maxFd = rfbScreen->inetdSock;
      goto __CPROVER_DUMP_L28;
    }

    if(!(rfbScreen->autoPort == 0))
    {
      signed int i;
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfbScreen->allFds)->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      rfbLog("Autoprobing TCP port \n");
      i = 5900;
      if(!(i >= 6000))
      {
        rfbScreen->listenSock=rfbListenOnTCPPort(i, iface);
        if(rfbScreen->listenSock >= 0)
          rfbScreen->port = i;

        else
          i = i + 1;
      }

      if(i >= 6000)
        rfbLogPerror("Failure autoprobing");

      rfbLog("Autoprobing selected TCP port %d\n", rfbScreen->port);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->listenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      rfbScreen->maxFd = rfbScreen->listenSock;
      rfbLog("Autoprobing TCP6 port \n");
      i = 5900;
      if(!(i >= 6000))
      {
        rfbScreen->listen6Sock=rfbListenOnTCP6Port(i, rfbScreen->listen6Interface);
        if(rfbScreen->listen6Sock >= 0)
          rfbScreen->ipv6port = i;

        else
          i = i + 1;
      }

      if(i >= 6000)
        rfbLogPerror("Failure autoprobing");

      rfbLog("Autoprobing selected TCP6 port %d\n", rfbScreen->ipv6port);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->listen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(rfbScreen->maxFd >= rfbScreen->listen6Sock))
        tmp_if_expr_3 = (signed int)rfbScreen->listen6Sock;

      else
        tmp_if_expr_3 = rfbScreen->maxFd;
      rfbScreen->maxFd = tmp_if_expr_3;
    }

    else
    {
      if(rfbScreen->port >= 1)
      {
        do
        {
          signed int rfbInitSockets__1__4__1__1____d0;
          signed int rfbInitSockets__1__4__1__1____d1;
          asm("cld; rep; stosq" : "=c"(rfbInitSockets__1__4__1__1____d0), "=D"(rfbInitSockets__1__4__1__1____d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfbScreen->allFds)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        rfbScreen->listenSock=rfbListenOnTCPPort(rfbScreen->port, iface);
        if(!(rfbScreen->listenSock >= 0))
        {
          rfbLogPerror("ListenOnTCPPort");
          goto __CPROVER_DUMP_L28;
        }

        rfbLog("Listening for VNC connections on TCP port %d\n", rfbScreen->port);
        (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->listenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        rfbScreen->maxFd = rfbScreen->listenSock;
      }

      if(rfbScreen->ipv6port >= 1)
      {
        rfbScreen->listen6Sock=rfbListenOnTCP6Port(rfbScreen->ipv6port, rfbScreen->listen6Interface);
        if(!(rfbScreen->listen6Sock >= 0))
          goto __CPROVER_DUMP_L28;

        rfbLog("Listening for VNC connections on TCP6 port %d\n", rfbScreen->ipv6port);
        (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->listen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(rfbScreen->maxFd >= rfbScreen->listen6Sock))
          tmp_if_expr_4 = (signed int)rfbScreen->listen6Sock;

        else
          tmp_if_expr_4 = rfbScreen->maxFd;
        rfbScreen->maxFd = tmp_if_expr_4;
      }

    }
    if(!(rfbScreen->udpPort == 0))
    {
      rfbLog("rfbInitSockets: listening for input on UDP port %d\n", rfbScreen->udpPort);
      rfbScreen->udpSock=rfbListenOnUDPPort(rfbScreen->udpPort, iface);
      if(!(rfbScreen->udpSock >= 0))
        rfbLogPerror("ListenOnUDPPort");

      rfbLog("Listening for VNC connections on TCP port %d\n", rfbScreen->port);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->udpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->udpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->udpSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      if(!(rfbScreen->maxFd >= rfbScreen->udpSock))
        tmp_if_expr_5 = (signed int)rfbScreen->udpSock;

      else
        tmp_if_expr_5 = rfbScreen->maxFd;
      rfbScreen->maxFd = tmp_if_expr_5;
    }

  }


__CPROVER_DUMP_L28:
  ;
}

// rfbInitTrueColourRGBTables16
// file tableinittctemplate.c line 99
static void rfbInitTrueColourRGBTables16(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  unsigned short int *redTable;
  unsigned short int *greenTable;
  unsigned short int *blueTable;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)((signed int)in->redMax + (signed int)in->greenMax + (signed int)in->blueMax + 3) * sizeof(unsigned short int) /*2ul*/ );
  *table = (char *)return_value_malloc_1;
  redTable = (unsigned short int *)*table;
  greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  rfbInitOneRGBTable16(redTable, (signed int)in->redMax, (signed int)out->redMax, (signed int)out->redShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable16(greenTable, (signed int)in->greenMax, (signed int)out->greenMax, (signed int)out->greenShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable16(blueTable, (signed int)in->blueMax, (signed int)out->blueMax, (signed int)out->blueShift, (signed int)(out->bigEndian != in->bigEndian));
}

// rfbInitTrueColourRGBTables24
// file tableinit24.c line 116
static void rfbInitTrueColourRGBTables24(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  unsigned char *redTable;
  unsigned char *greenTable;
  unsigned char *blueTable;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(((signed int)in->redMax + (signed int)in->greenMax + (signed int)in->blueMax + 3) * 3 + 1));
  *table = (char *)return_value_malloc_1;
  redTable = (unsigned char *)*table;
  greenTable = redTable + (signed long int)(3 * ((signed int)in->redMax + 1));
  blueTable = greenTable + (signed long int)(3 * ((signed int)in->greenMax + 1));
  rfbInitOneRGBTable24(redTable, (signed int)in->redMax, (signed int)out->redMax, (signed int)out->redShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable24(greenTable, (signed int)in->greenMax, (signed int)out->greenMax, (signed int)out->greenShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable24(blueTable, (signed int)in->blueMax, (signed int)out->blueMax, (signed int)out->blueShift, (signed int)(out->bigEndian != in->bigEndian));
}

// rfbInitTrueColourRGBTables32
// file tableinittctemplate.c line 99
static void rfbInitTrueColourRGBTables32(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  unsigned int *redTable;
  unsigned int *greenTable;
  unsigned int *blueTable;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)((signed int)in->redMax + (signed int)in->greenMax + (signed int)in->blueMax + 3) * sizeof(unsigned int) /*4ul*/ );
  *table = (char *)return_value_malloc_1;
  redTable = (unsigned int *)*table;
  greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  rfbInitOneRGBTable32(redTable, (signed int)in->redMax, (signed int)out->redMax, (signed int)out->redShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable32(greenTable, (signed int)in->greenMax, (signed int)out->greenMax, (signed int)out->greenShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable32(blueTable, (signed int)in->blueMax, (signed int)out->blueMax, (signed int)out->blueShift, (signed int)(out->bigEndian != in->bigEndian));
}

// rfbInitTrueColourRGBTables8
// file tableinittctemplate.c line 99
static void rfbInitTrueColourRGBTables8(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  unsigned char *redTable;
  unsigned char *greenTable;
  unsigned char *blueTable;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)((signed int)in->redMax + (signed int)in->greenMax + (signed int)in->blueMax + 3) * sizeof(unsigned char) /*1ul*/ );
  *table = (char *)return_value_malloc_1;
  redTable = (unsigned char *)*table;
  greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  rfbInitOneRGBTable8(redTable, (signed int)in->redMax, (signed int)out->redMax, (signed int)out->redShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable8(greenTable, (signed int)in->greenMax, (signed int)out->greenMax, (signed int)out->greenShift, (signed int)(out->bigEndian != in->bigEndian));
  rfbInitOneRGBTable8(blueTable, (signed int)in->blueMax, (signed int)out->blueMax, (signed int)out->blueShift, (signed int)(out->bigEndian != in->bigEndian));
}

// rfbInitTrueColourSingleTable16
// file tableinittctemplate.c line 60
static void rfbInitTrueColourSingleTable16(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  signed int i;
  signed int inRed;
  signed int inGreen;
  signed int inBlue;
  signed int outRed;
  signed int outGreen;
  signed int outBlue;
  unsigned short int *t;
  signed int nEntries = 1 << (signed int)in->bitsPerPixel;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nEntries * sizeof(unsigned short int) /*2ul*/ );
  *table = (char *)return_value_malloc_1;
  t = (unsigned short int *)*table;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    inRed = i >> (signed int)in->redShift & (signed int)in->redMax;
    inGreen = i >> (signed int)in->greenShift & (signed int)in->greenMax;
    inBlue = i >> (signed int)in->blueShift & (signed int)in->blueMax;
    outRed = (inRed * (signed int)out->redMax + (signed int)in->redMax / 2) / (signed int)in->redMax;
    outGreen = (inGreen * (signed int)out->greenMax + (signed int)in->greenMax / 2) / (signed int)in->greenMax;
    outBlue = (inBlue * (signed int)out->blueMax + (signed int)in->blueMax / 2) / (signed int)in->blueMax;
    t[(signed long int)i] = (unsigned short int)(outRed << (signed int)out->redShift | outGreen << (signed int)out->greenShift | outBlue << (signed int)out->blueShift);
    if(!(out->bigEndian == in->bigEndian))
      t[(signed long int)i] = (unsigned short int)(((signed int)t[(signed long int)i] & 0xff) << 8 | (signed int)t[(signed long int)i] >> 8 & 0xff);

  }
}

// rfbInitTrueColourSingleTable24
// file tableinit24.c line 75
static void rfbInitTrueColourSingleTable24(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  signed int i;
  signed int outValue;
  signed int inRed;
  signed int inGreen;
  signed int inBlue;
  signed int outRed;
  signed int outGreen;
  signed int outBlue;
  unsigned char *t;
  unsigned char c;
  signed int nEntries = 1 << (signed int)in->bitsPerPixel;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(nEntries * 3 + 1));
  *table = (char *)return_value_malloc_1;
  t = (unsigned char *)*table;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    inRed = i >> (signed int)in->redShift & (signed int)in->redMax;
    inGreen = i >> (signed int)in->greenShift & (signed int)in->greenMax;
    inBlue = i >> (signed int)in->blueShift & (signed int)in->blueMax;
    outRed = (inRed * (signed int)out->redMax + (signed int)in->redMax / 2) / (signed int)in->redMax;
    outGreen = (inGreen * (signed int)out->greenMax + (signed int)in->greenMax / 2) / (signed int)in->greenMax;
    outBlue = (inBlue * (signed int)out->blueMax + (signed int)in->blueMax / 2) / (signed int)in->blueMax;
    outValue = outRed << (signed int)out->redShift | outGreen << (signed int)out->greenShift | outBlue << (signed int)out->blueShift;
    *((unsigned int *)&t[(signed long int)(3 * i)]) = (unsigned int)outValue;
    if(rfbEndianTest == 0)
      memmove((void *)(t + (signed long int)(3 * i)), (const void *)(t + (signed long int)(3 * i) + (signed long int)1), (unsigned long int)3);

    if(!(out->bigEndian == in->bigEndian))
    {
      c = t[(signed long int)(3 * i)];
      t[(signed long int)(3 * i)] = t[(signed long int)(3 * i + 2)];
      t[(signed long int)(3 * i + 2)] = c;
    }

  }
}

// rfbInitTrueColourSingleTable32
// file tableinittctemplate.c line 60
static void rfbInitTrueColourSingleTable32(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  signed int i;
  signed int inRed;
  signed int inGreen;
  signed int inBlue;
  signed int outRed;
  signed int outGreen;
  signed int outBlue;
  unsigned int *t;
  signed int nEntries = 1 << (signed int)in->bitsPerPixel;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nEntries * sizeof(unsigned int) /*4ul*/ );
  *table = (char *)return_value_malloc_1;
  t = (unsigned int *)*table;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    inRed = i >> (signed int)in->redShift & (signed int)in->redMax;
    inGreen = i >> (signed int)in->greenShift & (signed int)in->greenMax;
    inBlue = i >> (signed int)in->blueShift & (signed int)in->blueMax;
    outRed = (inRed * (signed int)out->redMax + (signed int)in->redMax / 2) / (signed int)in->redMax;
    outGreen = (inGreen * (signed int)out->greenMax + (signed int)in->greenMax / 2) / (signed int)in->greenMax;
    outBlue = (inBlue * (signed int)out->blueMax + (signed int)in->blueMax / 2) / (signed int)in->blueMax;
    t[(signed long int)i] = (unsigned int)(outRed << (signed int)out->redShift | outGreen << (signed int)out->greenShift | outBlue << (signed int)out->blueShift);
    if(!(out->bigEndian == in->bigEndian))
      t[(signed long int)i] = t[(signed long int)i] >> 24 | (t[(signed long int)i] & (unsigned int)0x00ff0000) >> 8 | (t[(signed long int)i] & (unsigned int)0x0000ff00) << 8 | t[(signed long int)i] << 24;

  }
}

// rfbInitTrueColourSingleTable8
// file tableinittctemplate.c line 60
static void rfbInitTrueColourSingleTable8(char **table, struct anonymous_7 *in, struct anonymous_7 *out)
{
  signed int i;
  signed int inRed;
  signed int inGreen;
  signed int inBlue;
  signed int outRed;
  signed int outGreen;
  signed int outBlue;
  unsigned char *t;
  signed int nEntries = 1 << (signed int)in->bitsPerPixel;
  if(!(*table == ((char *)NULL)))
    free((void *)*table);

  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)nEntries * sizeof(unsigned char) /*1ul*/ );
  *table = (char *)return_value_malloc_1;
  t = (unsigned char *)*table;
  i = 0;
  for( ; !(i >= nEntries); i = i + 1)
  {
    inRed = i >> (signed int)in->redShift & (signed int)in->redMax;
    inGreen = i >> (signed int)in->greenShift & (signed int)in->greenMax;
    inBlue = i >> (signed int)in->blueShift & (signed int)in->blueMax;
    outRed = (inRed * (signed int)out->redMax + (signed int)in->redMax / 2) / (signed int)in->redMax;
    outGreen = (inGreen * (signed int)out->greenMax + (signed int)in->greenMax / 2) / (signed int)in->greenMax;
    outBlue = (inBlue * (signed int)out->blueMax + (signed int)in->blueMax / 2) / (signed int)in->blueMax;
    t[(signed long int)i] = (unsigned char)(outRed << (signed int)out->redShift | outGreen << (signed int)out->greenShift | outBlue << (signed int)out->blueShift);
  }
}

// rfbIsActive
// file main.c line 1175
extern signed char rfbIsActive(struct _rfbScreenInfo *screenInfo)
{
  _Bool tmp_if_expr_1;
  if(!((signed int)screenInfo->socketState == RFB_SOCKET_SHUTDOWN))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = screenInfo->clientHead != (struct _rfbClientRec *)(void *)0 ? (_Bool)1 : (_Bool)0;
  return (signed char)tmp_if_expr_1;
}

// rfbListenOnTCP6Port
// file sockets.c line 888
extern signed int rfbListenOnTCP6Port(signed int port, const char *iface)
{
  signed int sock;
  signed int one = 1;
  signed int rv;
  struct addrinfo hints;
  struct addrinfo *servinfo;
  struct addrinfo *p;
  char port_str[8l];
  snprintf(port_str, (unsigned long int)8, "%d", port);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 10;
  hints.ai_socktype = 1;
  hints.ai_flags = 0x0001;
  rv=getaddrinfo(iface, port_str, &hints, &servinfo);
  if(!(rv == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rv);
    rfbErr("rfbListenOnTCP6Port error in getaddrinfo: %s\n", return_value_gai_strerror_1);
    return -1;
  }

  p = servinfo;
  for( ; !(p == ((struct addrinfo *)NULL)); p = p->ai_next)
  {
    sock=socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    if(sock >= 0)
    {
      signed int return_value_setsockopt_2;
      return_value_setsockopt_2=setsockopt(sock, 41, 26, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_2 >= 0))
      {
        rfbLogPerror("rfbListenOnTCP6Port error in setsockopt IPV6_V6ONLY");
        close(sock);
        freeaddrinfo(servinfo);
        return -1;
      }

      signed int return_value_setsockopt_3;
      return_value_setsockopt_3=setsockopt(sock, 1, 2, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_3 >= 0))
      {
        rfbLogPerror("rfbListenOnTCP6Port: error in setsockopt SO_REUSEADDR");
        close(sock);
        freeaddrinfo(servinfo);
        return -1;
      }

      signed int return_value_bind_4;
      return_value_bind_4=bind(sock, p->ai_addr, p->ai_addrlen);
      if(!(return_value_bind_4 >= 0))
        close(sock);

      else
        break;
    }

  }
  if(p == ((struct addrinfo *)NULL))
  {
    rfbLogPerror("rfbListenOnTCP6Port: error in bind IPv6 socket");
    freeaddrinfo(servinfo);
    return -1;
  }

  else
  {
    freeaddrinfo(servinfo);
    signed int return_value_listen_5;
    return_value_listen_5=listen(sock, 32);
    if(!(return_value_listen_5 >= 0))
    {
      rfbLogPerror("rfbListenOnTCP6Port: error in listen on IPv6 socket");
      close(sock);
      return -1;
    }

    else
      return sock;
  }
}

// rfbListenOnTCPPort
// file sockets.c line 854
extern signed int rfbListenOnTCPPort(signed int port, unsigned int iface)
{
  struct sockaddr_in addr;
  signed int sock;
  signed int one = 1;
  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  addr.sin_port=htons((unsigned short int)port);
  addr.sin_addr.s_addr = iface;
  sock=socket(2, 1, 0);
  if(!(sock >= 0))
    return -1;

  else
  {
    signed int return_value_setsockopt_1;
    return_value_setsockopt_1=setsockopt(sock, 1, 2, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_1 >= 0))
    {
      close(sock);
      return -1;
    }

    else
    {
      signed int return_value_bind_2;
      return_value_bind_2=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_2 >= 0))
      {
        close(sock);
        return -1;
      }

      else
      {
        signed int return_value_listen_3;
        return_value_listen_3=listen(sock, 32);
        if(!(return_value_listen_3 >= 0))
        {
          close(sock);
          return -1;
        }

        else
          return sock;
      }
    }
  }
}

// rfbListenOnUDPPort
// file sockets.c line 1036
extern signed int rfbListenOnUDPPort(signed int port, unsigned int iface)
{
  struct sockaddr_in addr;
  signed int sock;
  signed int one = 1;
  memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  addr.sin_port=htons((unsigned short int)port);
  addr.sin_addr.s_addr = iface;
  sock=socket(2, 2, 0);
  if(!(sock >= 0))
    return -1;

  else
  {
    signed int return_value_setsockopt_1;
    return_value_setsockopt_1=setsockopt(sock, 1, 2, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_1 >= 0))
      return -1;

    else
    {
      signed int return_value_bind_2;
      return_value_bind_2=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_2 >= 0))
        return -1;

      else
        return sock;
    }
  }
}

// rfbLoadConsoleFont
// file font.c line 164
struct rfbFontData * rfbLoadConsoleFont(char *filename)
{
  struct _IO_FILE *f;
  f=fopen(filename, "rb");
  struct rfbFontData *p;
  signed int i;
  if(f == ((struct _IO_FILE *)NULL))
    return (struct rfbFontData *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct rfbFontData) /*16ul*/ );
    p = (struct rfbFontData *)return_value_malloc_1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)4096);
    p->data = (unsigned char *)return_value_malloc_2;
    unsigned long int return_value_fread_3;
    return_value_fread_3=fread((void *)p->data, (unsigned long int)4096, (unsigned long int)1, f);
    if(!(return_value_fread_3 == 1ul))
    {
      free((void *)p->data);
      free((void *)p);
      return (struct rfbFontData *)(void *)0;
    }

    else
    {
      fclose(f);
      void *return_value_malloc_4;
      return_value_malloc_4=malloc((unsigned long int)(256 * 5) * sizeof(signed int) /*4ul*/ );
      p->metaData = (signed int *)return_value_malloc_4;
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        p->metaData[(signed long int)(i * 5 + 0)] = i * 16;
        p->metaData[(signed long int)(i * 5 + 1)] = 8;
        p->metaData[(signed long int)(i * 5 + 2)] = 16;
        p->metaData[(signed long int)(i * 5 + 3)] = 0;
        p->metaData[(signed long int)(i * 5 + 4)] = 0;
      }
      return p;
    }
  }
}

// rfbLogEnable
// file main.c line 222
extern void rfbLogEnable(signed int enabled)
{
  rfbEnableLogging = enabled;
}

// rfbLogPerror
// file main.c line 262
extern void rfbLogPerror(const char *str)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  char *return_value_strerror_2;
  return_value_strerror_2=strerror(*return_value___errno_location_1);
  rfbErr("%s: %s\n", str, return_value_strerror_2);
}

// rfbMakeMaskForXCursor
// file cursor.c line 285
extern char * rfbMakeMaskForXCursor(signed int width, signed int height, char *source)
{
  signed int i;
  signed int rfbMakeMaskForXCursor__1__j;
  signed int w = (width + 7) / 8;
  char *mask;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)w, (unsigned long int)height);
  mask = (char *)return_value_calloc_1;
  unsigned char c;
  rfbMakeMaskForXCursor__1__j = 0;
  for( ; !(rfbMakeMaskForXCursor__1__j >= height); rfbMakeMaskForXCursor__1__j = rfbMakeMaskForXCursor__1__j + 1)
  {
    i = w - 1;
    for( ; i >= 0; i = i - 1)
    {
      c = (unsigned char)source[(signed long int)(rfbMakeMaskForXCursor__1__j * w + i)];
      if(rfbMakeMaskForXCursor__1__j >= 1)
        c = c | (unsigned char)source[(signed long int)((rfbMakeMaskForXCursor__1__j - 1) * w + i)];

      if(!(rfbMakeMaskForXCursor__1__j >= height + -1))
        c = c | (unsigned char)source[(signed long int)((rfbMakeMaskForXCursor__1__j + 1) * w + i)];

      if(i >= 1 && !((0x80 & (signed int)c) == 0))
        mask[(signed long int)((rfbMakeMaskForXCursor__1__j * w + i) - 1)] = mask[(signed long int)((rfbMakeMaskForXCursor__1__j * w + i) - 1)] | (char)0x01;

      if(!((0x01 & (signed int)c) == 0) && !(i >= w + -1))
        mask[(signed long int)(rfbMakeMaskForXCursor__1__j * w + i + 1)] = mask[(signed long int)(rfbMakeMaskForXCursor__1__j * w + i + 1)] | (char)0x80;

      mask[(signed long int)(rfbMakeMaskForXCursor__1__j * w + i)] = mask[(signed long int)(rfbMakeMaskForXCursor__1__j * w + i)] | (char)((signed int)c << 1 | (signed int)c | (signed int)c >> 1);
    }
  }
  return mask;
}

// rfbMakeMaskFromAlphaSource
// file cursor.c line 310
extern char * rfbMakeMaskFromAlphaSource(signed int width, signed int height, unsigned char *alphaSource)
{
  signed int *error;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(signed int) /*4ul*/ , (unsigned long int)width);
  error = (signed int *)return_value_calloc_1;
  signed int i;
  signed int rfbMakeMaskFromAlphaSource__1__j;
  signed int currentError = 0;
  signed int maskStride = (width + 7) / 8;
  unsigned char *result;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)maskStride, (unsigned long int)height);
  result = (unsigned char *)return_value_calloc_2;
  rfbMakeMaskFromAlphaSource__1__j = 0;
  for( ; !(rfbMakeMaskFromAlphaSource__1__j >= height); rfbMakeMaskFromAlphaSource__1__j = rfbMakeMaskFromAlphaSource__1__j + 1)
  {
    i = 0;
    for( ; !(i >= width); i = i + 1)
    {
      signed int right;
      signed int middle;
      signed int left;
      currentError = currentError + (signed int)alphaSource[(signed long int)(i + width * rfbMakeMaskFromAlphaSource__1__j)] + error[(signed long int)i];
      if(currentError >= 0x80)
      {
        result[(signed long int)(i / 8 + rfbMakeMaskFromAlphaSource__1__j * maskStride)] = result[(signed long int)(i / 8 + rfbMakeMaskFromAlphaSource__1__j * maskStride)] | (unsigned char)(0x100 >> (i & 7));
        currentError = currentError - 0xff;
      }

      right = currentError / 16;
      middle = (currentError * 5) / 16;
      left = (currentError * 3) / 16;
      currentError = currentError - (right + middle + left);
      error[(signed long int)i] = right;
      if(i >= 1)
      {
        error[(signed long int)(i - 1)] = middle;
        if(i >= 2)
          error[(signed long int)(i - 2)] = left;

      }

    }
  }
  free((void *)error);
  return (char *)result;
}

// rfbMakeRichCursorFromXCursor
// file cursor.c line 440
extern void rfbMakeRichCursorFromXCursor(struct _rfbScreenInfo *rfbScreen, struct rfbCursor *cursor)
{
  struct anonymous_7 *format = &rfbScreen->serverFormat;
  signed int i;
  signed int rfbMakeRichCursorFromXCursor__1__j;
  signed int w = ((signed int)cursor->width + 7) / 8;
  signed int bpp = (signed int)format->bitsPerPixel / 8;
  unsigned int background;
  unsigned int foreground;
  char *back = (char *)&background;
  char *fore = (char *)&foreground;
  unsigned char *cp;
  unsigned char bit;
  if(!(cursor->richSource == ((unsigned char *)NULL)))
  {
    if(!(cursor->cleanupRichSource == 0))
      free((void *)cursor->richSource);

  }

  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)((signed int)cursor->width * bpp), (unsigned long int)cursor->height);
  cursor->richSource = (unsigned char *)return_value_calloc_1;
  cp = cursor->richSource;
  cursor->cleanupRichSource = (signed char)-1;
  if(!(format->bigEndian == 0))
  {
    back = back + (signed long int)(4 - bpp);
    fore = fore + (signed long int)(4 - bpp);
  }

  background = (unsigned int)((signed int)cursor->backRed << (signed int)format->redShift | (signed int)cursor->backGreen << (signed int)format->greenShift | (signed int)cursor->backBlue << (signed int)format->blueShift);
  foreground = (unsigned int)((signed int)cursor->foreRed << (signed int)format->redShift | (signed int)cursor->foreGreen << (signed int)format->greenShift | (signed int)cursor->foreBlue << (signed int)format->blueShift);
  rfbMakeRichCursorFromXCursor__1__j = 0;
  for( ; !(rfbMakeRichCursorFromXCursor__1__j >= (signed int)cursor->height); rfbMakeRichCursorFromXCursor__1__j = rfbMakeRichCursorFromXCursor__1__j + 1)
  {
    i = 0;
    bit = (unsigned char)0x80;
    for( ; !(i >= (signed int)cursor->width); cp = cp + (signed long int)bpp)
    {
      if(!(((signed int)cursor->source[(signed long int)(rfbMakeRichCursorFromXCursor__1__j * w + i / 8)] & (signed int)bit) == 0))
        memcpy((void *)cp, (const void *)fore, (unsigned long int)bpp);

      else
        memcpy((void *)cp, (const void *)back, (unsigned long int)bpp);
      i = i + 1;
      bit = (unsigned char)(((signed int)bit & 1) != 0 ? 0x80 : (signed int)bit >> 1);
    }
  }
}

// rfbMakeXCursor
// file cursor.c line 254
extern struct rfbCursor * rfbMakeXCursor(signed int width, signed int height, char *cursorString, char *maskString)
{
  signed int i;
  signed int rfbMakeXCursor__1__j;
  signed int w = (width + 7) / 8;
  struct rfbCursor *cursor;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct rfbCursor) /*72ul*/ );
  cursor = (struct rfbCursor *)return_value_calloc_1;
  char *cp;
  unsigned char bit;
  cursor->cleanup = (signed char)-1;
  cursor->width = (unsigned short int)width;
  cursor->height = (unsigned short int)height;
  cursor->foreBlue = (unsigned short int)0xffff;
  cursor->foreGreen = cursor->foreBlue;
  cursor->foreRed = cursor->foreGreen;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)w, (unsigned long int)height);
  cursor->source = (unsigned char *)return_value_calloc_2;
  cursor->cleanupSource = (signed char)-1;
  rfbMakeXCursor__1__j = 0;
  cp = cursorString;
  for( ; !(rfbMakeXCursor__1__j >= height); rfbMakeXCursor__1__j = rfbMakeXCursor__1__j + 1)
  {
    i = 0;
    bit = (unsigned char)0x80;
    for( ; !(i >= width); cp = cp + 1l)
    {
      if(!((signed int)*cp == 32))
        cursor->source[(signed long int)(rfbMakeXCursor__1__j * w + i / 8)] = cursor->source[(signed long int)(rfbMakeXCursor__1__j * w + i / 8)] | bit;

      i = i + 1;
      bit = (unsigned char)(((signed int)bit & 1) != 0 ? 0x80 : (signed int)bit >> 1);
    }
  }
  char *return_value_rfbMakeMaskForXCursor_4;
  if(!(maskString == ((char *)NULL)))
  {
    void *return_value_calloc_3;
    return_value_calloc_3=calloc((unsigned long int)w, (unsigned long int)height);
    cursor->mask = (unsigned char *)return_value_calloc_3;
    rfbMakeXCursor__1__j = 0;
    cp = maskString;
    for( ; !(rfbMakeXCursor__1__j >= height); rfbMakeXCursor__1__j = rfbMakeXCursor__1__j + 1)
    {
      i = 0;
      bit = (unsigned char)0x80;
      for( ; !(i >= width); cp = cp + 1l)
      {
        if(!((signed int)*cp == 32))
          cursor->mask[(signed long int)(rfbMakeXCursor__1__j * w + i / 8)] = cursor->mask[(signed long int)(rfbMakeXCursor__1__j * w + i / 8)] | bit;

        i = i + 1;
        bit = (unsigned char)(((signed int)bit & 1) != 0 ? 0x80 : (signed int)bit >> 1);
      }
    }
  }

  else
  {
    return_value_rfbMakeMaskForXCursor_4=rfbMakeMaskForXCursor(width, height, (char *)cursor->source);
    cursor->mask = (unsigned char *)return_value_rfbMakeMaskForXCursor_4;
  }
  cursor->cleanupMask = (signed char)-1;
  return cursor;
}

// rfbMakeXCursorFromRichCursor
// file cursor.c line 370
extern void rfbMakeXCursorFromRichCursor(struct _rfbScreenInfo *rfbScreen, struct rfbCursor *cursor)
{
  struct anonymous_7 *format = &rfbScreen->serverFormat;
  signed int i;
  signed int rfbMakeXCursorFromRichCursor__1__j;
  signed int w = ((signed int)cursor->width + 7) / 8;
  signed int bpp = (signed int)format->bitsPerPixel / 8;
  signed int width = (signed int)cursor->width * bpp;
  unsigned int background;
  char *back = (char *)&background;
  unsigned char bit;
  signed int interp = 0;
  signed int db = 0;
  if(!(cursor->source == ((unsigned char *)NULL)))
  {
    if(!(cursor->cleanupSource == 0))
      free((void *)cursor->source);

  }

  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)w, (unsigned long int)cursor->height);
  cursor->source = (unsigned char *)return_value_calloc_1;
  cursor->cleanupSource = (signed char)-1;
  if(!(format->bigEndian == 0))
    back = back + (signed long int)(4 - bpp);

  if(cursor->backRed == 0)
  {
    if(cursor->backGreen == 0)
    {
      if(cursor->backBlue == 0)
      {
        if(cursor->foreRed == 0)
        {
          if(cursor->foreGreen == 0)
          {
            if(cursor->foreBlue == 0)
            {
              if(!(format->trueColour == 0))
              {
                if(bpp == 1 || bpp == 2 || bpp == 4)
                {
                  interp = 1;
                  cursor->foreBlue = (unsigned short int)0xffff;
                  cursor->foreGreen = cursor->foreBlue;
                  cursor->foreRed = cursor->foreGreen;
                }

              }

            }

          }

        }

      }

    }

  }

  background = (unsigned int)(((signed int)format->redMax * (signed int)cursor->backRed) / 0xffff << (signed int)format->redShift | ((signed int)format->greenMax * (signed int)cursor->backGreen) / 0xffff << (signed int)format->greenShift | ((signed int)format->blueMax * (signed int)cursor->backBlue) / 0xffff << (signed int)format->blueShift);
  if(!(db == 0))
    fprintf(stderr, "interp: %d\n", interp);

  rfbMakeXCursorFromRichCursor__1__j = 0;
  signed int return_value_memcmp_2;
  for( ; !(rfbMakeXCursorFromRichCursor__1__j >= (signed int)cursor->height); rfbMakeXCursorFromRichCursor__1__j = rfbMakeXCursorFromRichCursor__1__j + 1)
  {
    i = 0;
    bit = (unsigned char)0x80;
    for( ; !(i >= (signed int)cursor->width); bit = (unsigned char)(((signed int)bit & 1) != 0 ? 0x80 : (signed int)bit >> 1))
    {
      if(!(interp == 0))
      {
        signed int r = 0;
        signed int g = 0;
        signed int b = 0;
        signed int grey;
        unsigned char *p = cursor->richSource + (signed long int)(rfbMakeXCursorFromRichCursor__1__j * width) + (signed long int)(i * bpp);
        if(bpp == 1)
        {
          unsigned char *uc = (unsigned char *)p;
          r = (255 * (((signed int)format->redMax << (signed int)format->redShift & (signed int)*uc) >> (signed int)format->redShift)) / (signed int)format->redMax;
          g = (255 * (((signed int)format->greenMax << (signed int)format->greenShift & (signed int)*uc) >> (signed int)format->greenShift)) / (signed int)format->greenMax;
          b = (255 * (((signed int)format->blueMax << (signed int)format->blueShift & (signed int)*uc) >> (signed int)format->blueShift)) / (signed int)format->blueMax;
        }

        else
          if(bpp == 2)
          {
            unsigned short int *us = (unsigned short int *)p;
            r = (255 * (((signed int)format->redMax << (signed int)format->redShift & (signed int)*us) >> (signed int)format->redShift)) / (signed int)format->redMax;
            g = (255 * (((signed int)format->greenMax << (signed int)format->greenShift & (signed int)*us) >> (signed int)format->greenShift)) / (signed int)format->greenMax;
            b = (255 * (((signed int)format->blueMax << (signed int)format->blueShift & (signed int)*us) >> (signed int)format->blueShift)) / (signed int)format->blueMax;
          }

          else
            if(bpp == 4)
            {
              unsigned int *ui = (unsigned int *)p;
              r = (signed int)(((unsigned int)255 * (((unsigned int)((signed int)format->redMax << (signed int)format->redShift) & *ui) >> (signed int)format->redShift)) / (unsigned int)format->redMax);
              g = (signed int)(((unsigned int)255 * (((unsigned int)((signed int)format->greenMax << (signed int)format->greenShift) & *ui) >> (signed int)format->greenShift)) / (unsigned int)format->greenMax);
              b = (signed int)(((unsigned int)255 * (((unsigned int)((signed int)format->blueMax << (signed int)format->blueShift) & *ui) >> (signed int)format->blueShift)) / (unsigned int)format->blueMax);
            }

        grey = (r + g + b) / 3;
        if(grey >= 128)
        {
          cursor->source[(signed long int)(rfbMakeXCursorFromRichCursor__1__j * w + i / 8)] = cursor->source[(signed long int)(rfbMakeXCursorFromRichCursor__1__j * w + i / 8)] | bit;
          if(!(db == 0))
            fprintf(stderr, "1");

        }

        else
          if(!(db == 0))
            fprintf(stderr, "0");

      }

      else
      {
        return_value_memcmp_2=memcmp((const void *)(cursor->richSource + (signed long int)(rfbMakeXCursorFromRichCursor__1__j * width) + (signed long int)(i * bpp)), (const void *)back, (unsigned long int)bpp);
        if(!(return_value_memcmp_2 == 0))
          cursor->source[(signed long int)(rfbMakeXCursorFromRichCursor__1__j * w + i / 8)] = cursor->source[(signed long int)(rfbMakeXCursorFromRichCursor__1__j * w + i / 8)] | bit;

      }
      i = i + 1;
    }
    if(!(db == 0))
      fprintf(stderr, "\n");

  }
}

// rfbMarkRectAsModified
// file main.c line 416
void rfbMarkRectAsModified(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2)
{
  struct sraRegion *region;
  signed int i;
  if(!(x2 >= x1))
  {
    i = x1;
    x1 = x2;
    x2 = i;
  }

  if(!(x1 >= 0))
    x1 = 0;

  if(!(screen->width >= x2))
    x2 = screen->width;

  if(!(x1 == x2))
  {
    if(!(y2 >= y1))
    {
      i = y1;
      y1 = y2;
      y2 = i;
    }

    if(!(y1 >= 0))
      y1 = 0;

    if(!(screen->height >= y2))
      y2 = screen->height;

    if(!(y1 == y2))
    {
      rfbScaledScreenUpdate(screen, x1, y1, x2, y2);
      region=sraRgnCreateRect(x1, y1, x2, y2);
      rfbMarkRegionAsModified(screen, region);
      sraRgnDestroy(region);
    }

  }

}

// rfbMarkRegionAsModified
// file main.c line 399
void rfbMarkRegionAsModified(struct _rfbScreenInfo *screen, struct sraRegion *modRegion)
{
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *rfbMarkRegionAsModified__1__cl;
  iterator=rfbGetClientIterator(screen);
  do
  {
    rfbMarkRegionAsModified__1__cl=rfbClientIteratorNext(iterator);
    if(rfbMarkRegionAsModified__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    pthread_mutex_lock(&rfbMarkRegionAsModified__1__cl->updateMutex);
    sraRgnOr(rfbMarkRegionAsModified__1__cl->modifiedRegion, modRegion);
    pthread_cond_signal(&rfbMarkRegionAsModified__1__cl->updateCond);
    pthread_mutex_unlock(&rfbMarkRegionAsModified__1__cl->updateMutex);
  }
  while((_Bool)1);
  rfbReleaseClientIterator(iterator);
}

// rfbNewClient
// file ../rfb/rfb.h line 784
extern struct _rfbClientRec * rfbNewClient(struct _rfbScreenInfo *rfbScreen, signed int sock)
{
  struct _rfbClientRec *return_value_rfbNewTCPOrUDPClient_1;
  return_value_rfbNewTCPOrUDPClient_1=rfbNewTCPOrUDPClient(rfbScreen, sock, (signed char)0);
  return return_value_rfbNewTCPOrUDPClient_1;
}

// rfbNewClientConnection
// file rfbserver.c line 248
extern void rfbNewClientConnection(struct _rfbScreenInfo *rfbScreen, signed int sock)
{
  rfbNewClient(rfbScreen, sock);
}

// rfbNewFramebuffer
// file main.c line 940
extern void rfbNewFramebuffer(struct _rfbScreenInfo *screen, char *framebuffer, signed int width, signed int height, signed int bitsPerSample, signed int samplesPerPixel, signed int bytesPerPixel)
{
  struct anonymous_7 old_format;
  signed char format_changed = (signed char)0;
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *rfbNewFramebuffer__1__cl;
  old_format = screen->serverFormat;
  if(!((3 & width) == 0))
    rfbErr("WARNING: New width (%d) is not a multiple of 4.\n", width);

  screen->width = width;
  screen->height = height;
  screen->depth = 8 * bytesPerPixel;
  screen->bitsPerPixel = screen->depth;
  screen->paddedWidthInBytes = width * bytesPerPixel;
  rfbInitServerFormat(screen, bitsPerSample);
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)&screen->serverFormat, (const void *)&old_format, sizeof(struct anonymous_7) /*16ul*/ );
  if(!(return_value_memcmp_1 == 0))
    format_changed = (signed char)-1;

  screen->frameBuffer = framebuffer;
  if(screen->cursorX >= width)
    screen->cursorX = width - 1;

  if(screen->cursorY >= height)
    screen->cursorY = height - 1;

  iterator=rfbGetClientIterator(screen);
  do
  {
    rfbNewFramebuffer__1__cl=rfbClientIteratorNext(iterator);
    if(rfbNewFramebuffer__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    if(!(format_changed == 0))
      screen->setTranslateFunction(rfbNewFramebuffer__1__cl);

    pthread_mutex_lock(&rfbNewFramebuffer__1__cl->updateMutex);
    sraRgnDestroy(rfbNewFramebuffer__1__cl->modifiedRegion);
    rfbNewFramebuffer__1__cl->modifiedRegion=sraRgnCreateRect(0, 0, width, height);
    sraRgnMakeEmpty(rfbNewFramebuffer__1__cl->copyRegion);
    rfbNewFramebuffer__1__cl->copyDX = 0;
    rfbNewFramebuffer__1__cl->copyDY = 0;
    if(!(rfbNewFramebuffer__1__cl->useNewFBSize == 0))
      rfbNewFramebuffer__1__cl->newFBSizePending = (signed char)-1;

    pthread_cond_signal(&rfbNewFramebuffer__1__cl->updateCond);
    pthread_mutex_unlock(&rfbNewFramebuffer__1__cl->updateMutex);
  }
  while((_Bool)1);
  rfbReleaseClientIterator(iterator);
}

// rfbNewTCPOrUDPClient
// file rfbserver.c line 301
static struct _rfbClientRec * rfbNewTCPOrUDPClient(struct _rfbScreenInfo *rfbScreen, signed int sock, signed char isUDP)
{
  char pv[13l];
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *rfbNewTCPOrUDPClient__1__cl;
  struct _rfbClientRec *cl_;
  struct sockaddr_storage addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct _rfbProtocolExtension *extension;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct _rfbClientRec) /*47704ul*/ , (unsigned long int)1);
  rfbNewTCPOrUDPClient__1__cl = (struct _rfbClientRec *)return_value_calloc_1;
  rfbNewTCPOrUDPClient__1__cl->screen = rfbScreen;
  rfbNewTCPOrUDPClient__1__cl->sock = sock;
  rfbNewTCPOrUDPClient__1__cl->viewOnly = (signed char)0;
  rfbNewTCPOrUDPClient__1__cl->scaledScreen = rfbScreen;
  rfbNewTCPOrUDPClient__1__cl->scaledScreen->scaledScreenRefCount = rfbNewTCPOrUDPClient__1__cl->scaledScreen->scaledScreenRefCount + 1;
  rfbResetStats(rfbNewTCPOrUDPClient__1__cl);
  rfbNewTCPOrUDPClient__1__cl->clientData = (void *)0;
  rfbNewTCPOrUDPClient__1__cl->clientGoneHook = rfbDoNothingWithClient;
  signed int tmp_if_expr_5;
  if(!(isUDP == 0))
    rfbLog(" accepted UDP client\n");

  else
  {
    char host[1024l];
    signed int one = 1;
    getpeername(sock, (struct sockaddr *)&addr, &addrlen);
    signed int return_value_getnameinfo_2;
    return_value_getnameinfo_2=getnameinfo((struct sockaddr *)&addr, addrlen, host, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , (char *)(void *)0, (unsigned int)0, 1);
    if(!(return_value_getnameinfo_2 == 0))
    {
      rfbLogPerror("rfbNewClient: error in getnameinfo");
      rfbNewTCPOrUDPClient__1__cl->host=strdup("");
    }

    else
      rfbNewTCPOrUDPClient__1__cl->host=strdup(host);
    rfbLog("  other clients:\n");
    iterator=rfbGetClientIterator(rfbScreen);
    cl_=rfbClientIteratorNext(iterator);
    if(!(cl_ == ((struct _rfbClientRec *)NULL)))
      rfbLog("     %s\n", cl_->host);

    rfbReleaseClientIterator(iterator);
    signed char return_value_rfbSetNonBlocking_3;
    return_value_rfbSetNonBlocking_3=rfbSetNonBlocking(sock);
    if(return_value_rfbSetNonBlocking_3 == 0)
    {
      close(sock);
      return (struct _rfbClientRec *)(void *)0;
    }

    signed int return_value_setsockopt_4;
    return_value_setsockopt_4=setsockopt(sock, 6, 1, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_4 >= 0))
    {
      rfbLogPerror("setsockopt failed");
      close(sock);
      return (struct _rfbClientRec *)(void *)0;
    }

    (&rfbScreen->allFds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!(rfbScreen->maxFd >= sock))
      tmp_if_expr_5 = sock;

    else
      tmp_if_expr_5 = rfbScreen->maxFd;
    rfbScreen->maxFd = tmp_if_expr_5;
    pthread_mutex_init(&rfbNewTCPOrUDPClient__1__cl->outputMutex, (const union anonymous_0 *)(void *)0);
    pthread_mutex_init(&rfbNewTCPOrUDPClient__1__cl->refCountMutex, (const union anonymous_0 *)(void *)0);
    pthread_mutex_init(&rfbNewTCPOrUDPClient__1__cl->sendMutex, (const union anonymous_0 *)(void *)0);
    pthread_cond_init(&rfbNewTCPOrUDPClient__1__cl->deleteCond, (const union anonymous_0 *)(void *)0);
    rfbNewTCPOrUDPClient__1__cl->state = (enum anonymous_13)RFB_PROTOCOL_VERSION;
    rfbNewTCPOrUDPClient__1__cl->reverseConnection = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->readyForSetColourMapEntries = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->useCopyRect = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->preferredEncoding = -1;
    rfbNewTCPOrUDPClient__1__cl->correMaxWidth = 48;
    rfbNewTCPOrUDPClient__1__cl->correMaxHeight = 48;
    rfbNewTCPOrUDPClient__1__cl->zrleData = (void *)0;
    rfbNewTCPOrUDPClient__1__cl->copyRegion=sraRgnCreate();
    rfbNewTCPOrUDPClient__1__cl->copyDX = 0;
    rfbNewTCPOrUDPClient__1__cl->copyDY = 0;
    rfbNewTCPOrUDPClient__1__cl->modifiedRegion=sraRgnCreateRect(0, 0, rfbScreen->width, rfbScreen->height);
    pthread_mutex_init(&rfbNewTCPOrUDPClient__1__cl->updateMutex, (const union anonymous_0 *)(void *)0);
    pthread_cond_init(&rfbNewTCPOrUDPClient__1__cl->updateCond, (const union anonymous_0 *)(void *)0);
    rfbNewTCPOrUDPClient__1__cl->requestedRegion=sraRgnCreate();
    rfbNewTCPOrUDPClient__1__cl->format = rfbNewTCPOrUDPClient__1__cl->screen->serverFormat;
    rfbNewTCPOrUDPClient__1__cl->translateFn = rfbTranslateNone;
    rfbNewTCPOrUDPClient__1__cl->translateLookupTable = (char *)(void *)0;
    pthread_mutex_lock(&rfbClientListMutex);
    rfbNewTCPOrUDPClient__1__cl->refCount = 0;
    rfbNewTCPOrUDPClient__1__cl->next = rfbScreen->clientHead;
    rfbNewTCPOrUDPClient__1__cl->prev = (struct _rfbClientRec *)(void *)0;
    if(!(rfbScreen->clientHead == ((struct _rfbClientRec *)NULL)))
      rfbScreen->clientHead->prev = rfbNewTCPOrUDPClient__1__cl;

    rfbScreen->clientHead = rfbNewTCPOrUDPClient__1__cl;
    pthread_mutex_unlock(&rfbClientListMutex);
    rfbNewTCPOrUDPClient__1__cl->tightQualityLevel = -1;
    rfbNewTCPOrUDPClient__1__cl->tightCompressLevel = 6;
    rfbNewTCPOrUDPClient__1__cl->turboSubsampLevel = 0;
    signed int i = 0;
    if(!(i >= 4))
    {
      rfbNewTCPOrUDPClient__1__cl->zsActive[(signed long int)i] = (signed char)0;
      i = i + 1;
    }

    rfbNewTCPOrUDPClient__1__cl->fileTransfer.fd = -1;
    rfbNewTCPOrUDPClient__1__cl->enableCursorShapeUpdates = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->enableCursorPosUpdates = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->useRichCursorEncoding = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->enableLastRectEncoding = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->enableKeyboardLedState = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->enableSupportedMessages = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->enableSupportedEncodings = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->enableServerIdentity = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->lastKeyboardLedState = -1;
    rfbNewTCPOrUDPClient__1__cl->cursorX = rfbScreen->cursorX;
    rfbNewTCPOrUDPClient__1__cl->cursorY = rfbScreen->cursorY;
    rfbNewTCPOrUDPClient__1__cl->useNewFBSize = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->compStreamInited = (signed char)0;
    rfbNewTCPOrUDPClient__1__cl->compStream.total_in = (unsigned long int)0;
    rfbNewTCPOrUDPClient__1__cl->compStream.total_out = (unsigned long int)0;
    rfbNewTCPOrUDPClient__1__cl->compStream.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    rfbNewTCPOrUDPClient__1__cl->compStream.zfree = ((void (*)(void *, void *))NULL);
    rfbNewTCPOrUDPClient__1__cl->compStream.opaque = NULL;
    rfbNewTCPOrUDPClient__1__cl->zlibCompressLevel = (unsigned int)5;
    rfbNewTCPOrUDPClient__1__cl->progressiveSliceY = 0;
    rfbNewTCPOrUDPClient__1__cl->extensions = (struct _rfbExtensionData *)(void *)0;
    rfbNewTCPOrUDPClient__1__cl->lastPtrX = -1;
    signed char return_value_webSocketsCheck_6;
    return_value_webSocketsCheck_6=webSocketsCheck(rfbNewTCPOrUDPClient__1__cl);
    if(return_value_webSocketsCheck_6 == 0)
    {
      rfbCloseClient(rfbNewTCPOrUDPClient__1__cl);
      rfbClientConnectionGone(rfbNewTCPOrUDPClient__1__cl);
      return (struct _rfbClientRec *)(void *)0;
    }

    sprintf(pv, "RFB %03d.%03d\n", rfbScreen->protocolMajorVersion, rfbScreen->protocolMinorVersion);
    signed int return_value_rfbWriteExact_7;
    return_value_rfbWriteExact_7=rfbWriteExact(rfbNewTCPOrUDPClient__1__cl, pv, 12);
    if(!(return_value_rfbWriteExact_7 >= 0))
    {
      rfbLogPerror("rfbNewClient: write");
      rfbCloseClient(rfbNewTCPOrUDPClient__1__cl);
      rfbClientConnectionGone(rfbNewTCPOrUDPClient__1__cl);
      return (struct _rfbClientRec *)(void *)0;
    }

  }
  extension=rfbGetExtensionIterator();
  signed char return_value;
  if(!(extension == ((struct _rfbProtocolExtension *)NULL)))
  {
    void *data = (void *)0;
    if(!(extension->newClient == ((signed char (*)(struct _rfbClientRec *, void **))NULL)))
    {
      return_value=extension->newClient(rfbNewTCPOrUDPClient__1__cl, &data);
      if(!(return_value == 0))
        rfbEnableExtension(rfbNewTCPOrUDPClient__1__cl, extension, data);

    }

    extension = extension->next;
  }

  rfbReleaseExtensionIterator();
  enum rfbNewClientAction return_value_1;
  return_value_1=rfbNewTCPOrUDPClient__1__cl->screen->newClientHook(rfbNewTCPOrUDPClient__1__cl);
  if((signed int)return_value_1 == RFB_CLIENT_ON_HOLD)
  {
    rfbNewTCPOrUDPClient__1__cl->onHold = (signed char)-1;
    rfbNewTCPOrUDPClient__1__cl->onHold = (signed char)0;
    rfbCloseClient(rfbNewTCPOrUDPClient__1__cl);
    rfbClientConnectionGone(rfbNewTCPOrUDPClient__1__cl);
    rfbNewTCPOrUDPClient__1__cl = (struct _rfbClientRec *)(void *)0;
  }

  return rfbNewTCPOrUDPClient__1__cl;
}

// rfbNewUDPClient
// file rfbserver.c line 520
extern struct _rfbClientRec * rfbNewUDPClient(struct _rfbScreenInfo *rfbScreen)
{
  rfbScreen->udpClient=rfbNewTCPOrUDPClient(rfbScreen, rfbScreen->udpSock, (signed char)-1);
  return rfbScreen->udpClient;
}

// rfbNewUDPConnection
// file rfbserver.c line 3527
extern void rfbNewUDPConnection(struct _rfbScreenInfo *rfbScreen, signed int sock)
{
  signed long int return_value_write_1;
  return_value_write_1=write(sock, (const void *)(char *)&ptrAcceleration, (unsigned long int)1);
  if(!(return_value_write_1 >= 0l))
    rfbLogPerror("rfbNewUDPConnection: write");

}

// rfbNumCodedRectsTight
// file ../rfb/rfb.h line 893
extern signed int rfbNumCodedRectsTight(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int maxRectSize;
  signed int maxRectWidth;
  signed int subrectMaxWidth;
  signed int subrectMaxHeight;
  if(!(cl->enableLastRectEncoding == 0))
  {
    if(!(h * w >= 4096))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    maxRectSize = tightConf[(signed long int)compressLevel].maxRectSize;
    maxRectWidth = tightConf[(signed long int)compressLevel].maxRectWidth;
    if(!(maxRectSize >= h * w) || !(maxRectWidth >= w))
    {
      subrectMaxWidth = w > maxRectWidth ? maxRectWidth : w;
      subrectMaxHeight = maxRectSize / subrectMaxWidth;
      return ((w - 1) / maxRectWidth + 1) * ((h - 1) / subrectMaxHeight + 1);
    }

    else
      return 1;
  }
}

// rfbPeekExactTimeout
// file sockets.c line 662
extern signed int rfbPeekExactTimeout(struct _rfbClientRec *cl, char *buf, signed int len, signed int timeout)
{
  signed int sock = cl->sock;
  signed int n;
  struct anonymous_16 fds;
  struct timeval tv;
  signed long int return_value_recv_1;
  signed int *return_value___errno_location_3;
  while(len >= 1)
  {
    if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
      n=rfbssl_peek(cl, buf, len);

    else
    {
      return_value_recv_1=recv(sock, (void *)buf, (unsigned long int)len, 2);
      n = (signed int)return_value_recv_1;
    }
    if(n == len)
      break;

    else
      if(n == 0)
        return 0;

      else
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(*return_value___errno_location_2 == 4)
          continue;

        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 11))
        {
          return_value___errno_location_3=__errno_location();
          if(!(*return_value___errno_location_3 == 11))
            return n;

        }

        if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
        {
          signed int return_value_rfbssl_pending_5;
          return_value_rfbssl_pending_5=rfbssl_pending(cl);
          if(!(return_value_rfbssl_pending_5 == 0))
            continue;

        }

        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&fds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)(timeout / 1000);
        tv.tv_usec = (signed long int)((timeout % 1000) * 1000);
        n=select(sock + 1, &fds, (struct anonymous_16 *)(void *)0, &fds, &tv);
        if(!(n >= 0))
        {
          rfbLogPerror("PeekExact: select");
          return n;
        }

        if(n == 0)
        {
          signed int *return_value___errno_location_6;
          return_value___errno_location_6=__errno_location();
          *return_value___errno_location_6 = 110;
          return -1;
        }

      }
  }
  return 1;
}

// rfbPrintStats
// file ../rfb/rfb.h line 943
extern void rfbPrintStats(struct _rfbClientRec *cl)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  char encBuf[64l];
  double savings = 0.0;
  signed int totalRects = 0;
  double totalBytes = 0.0;
  double totalBytesIfRaw = 0.0;
  char *name = (char *)(void *)0;
  signed int bytes = 0;
  signed int bytesIfRaw = 0;
  signed int count = 0;
  if(!(cl == ((struct _rfbClientRec *)NULL)))
  {
    rfbLog("%-21.21s  %-6.6s   %9.9s/%9.9s (%6.6s)\n", (const void *)"Statistics", (const void *)"events", (const void *)"Transmit", (const void *)"RawEquiv", (const void *)"saved");
    ptr = cl->statMsgList;
    if(!(ptr == ((struct _rfbStatList *)NULL)))
    {
      name=messageNameServer2Client(ptr->type, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
      count = (signed int)ptr->sentCount;
      bytes = (signed int)ptr->bytesSent;
      bytesIfRaw = (signed int)ptr->bytesSentIfRaw;
      savings = 0.0;
      if((double)bytesIfRaw > 0.0)
        savings = 100.0 - ((double)bytes / (double)bytesIfRaw) * 100.0;

      if(bytes >= 1 || bytesIfRaw >= 1 || count >= 1)
        rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n", name, count, bytes, bytesIfRaw, savings);

      totalRects = totalRects + count;
      totalBytes = totalBytes + (double)bytes;
      totalBytesIfRaw = totalBytesIfRaw + (double)bytesIfRaw;
      ptr = ptr->Next;
    }

    ptr = cl->statEncList;
    if(!(ptr == ((struct _rfbStatList *)NULL)))
    {
      name=encodingName(ptr->type, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
      count = (signed int)ptr->sentCount;
      bytes = (signed int)ptr->bytesSent;
      bytesIfRaw = (signed int)ptr->bytesSentIfRaw;
      savings = 0.0;
      if((double)bytesIfRaw > 0.0)
        savings = 100.0 - ((double)bytes / (double)bytesIfRaw) * 100.0;

      if(bytes >= 1 || bytesIfRaw >= 1 || count >= 1)
        rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n", name, count, bytes, bytesIfRaw, savings);

      totalRects = totalRects + count;
      totalBytes = totalBytes + (double)bytes;
      totalBytesIfRaw = totalBytesIfRaw + (double)bytesIfRaw;
      ptr = ptr->Next;
    }

    savings = 0.0;
    if(totalBytesIfRaw > 0.0)
      savings = 100.0 - (totalBytes / totalBytesIfRaw) * 100.0;

    rfbLog(" %-20.20s: %6d | %9.0f/%9.0f (%5.1f%%)\n", (const void *)"TOTALS", totalRects, totalBytes, totalBytesIfRaw, savings);
    totalRects = (signed int)0.0;
    totalBytes = 0.0;
    totalBytesIfRaw = 0.0;
    rfbLog("%-21.21s  %-6.6s   %9.9s/%9.9s (%6.6s)\n", (const void *)"Statistics", (const void *)"events", (const void *)"Received", (const void *)"RawEquiv", (const void *)"saved");
    ptr = cl->statMsgList;
    if(!(ptr == ((struct _rfbStatList *)NULL)))
    {
      name=messageNameClient2Server(ptr->type, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
      count = (signed int)ptr->rcvdCount;
      bytes = (signed int)ptr->bytesRcvd;
      bytesIfRaw = (signed int)ptr->bytesRcvdIfRaw;
      savings = 0.0;
      if((double)bytesIfRaw > 0.0)
        savings = 100.0 - ((double)bytes / (double)bytesIfRaw) * 100.0;

      if(bytes >= 1 || bytesIfRaw >= 1 || count >= 1)
        rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n", name, count, bytes, bytesIfRaw, savings);

      totalRects = totalRects + count;
      totalBytes = totalBytes + (double)bytes;
      totalBytesIfRaw = totalBytesIfRaw + (double)bytesIfRaw;
      ptr = ptr->Next;
    }

    ptr = cl->statEncList;
    if(!(ptr == ((struct _rfbStatList *)NULL)))
    {
      name=encodingName(ptr->type, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
      count = (signed int)ptr->rcvdCount;
      bytes = (signed int)ptr->bytesRcvd;
      bytesIfRaw = (signed int)ptr->bytesRcvdIfRaw;
      savings = 0.0;
      if((double)bytesIfRaw > 0.0)
        savings = 100.0 - ((double)bytes / (double)bytesIfRaw) * 100.0;

      if(bytes >= 1 || bytesIfRaw >= 1 || count >= 1)
        rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n", name, count, bytes, bytesIfRaw, savings);

      totalRects = totalRects + count;
      totalBytes = totalBytes + (double)bytes;
      totalBytesIfRaw = totalBytesIfRaw + (double)bytesIfRaw;
      ptr = ptr->Next;
    }

    savings = 0.0;
    if(totalBytesIfRaw > 0.0)
      savings = 100.0 - (totalBytes / totalBytesIfRaw) * 100.0;

    rfbLog(" %-20.20s: %6d | %9.0f/%9.0f (%5.1f%%)\n", (const void *)"TOTALS", totalRects, totalBytes, totalBytesIfRaw, savings);
  }

}

// rfbProcessArguments
// file ../rfb/rfb.h line 996
extern signed char rfbProcessArguments(struct _rfbScreenInfo *rfbScreen, signed int *argc, char **argv)
{
  signed int i;
  signed int i1;
  signed int return_value_strcmp_24;
  signed int return_value_strcmp_23;
  signed int return_value_strcmp_22;
  signed int return_value_strcmp_21;
  signed int return_value_strcmp_20;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  if(argc == ((signed int *)NULL))
    return (signed char)-1;

  else
  {
    i1 = 1;
    i = i1;
    while(!(i >= *argc))
    {
      signed int return_value_strcmp_25;
      return_value_strcmp_25=strcmp(argv[(signed long int)i], "-help");
      if(return_value_strcmp_25 == 0)
      {
        rfbUsage();
        return (signed char)0;
      }

      else
      {
        return_value_strcmp_24=strcmp(argv[(signed long int)i], "-rfbport");
        if(return_value_strcmp_24 == 0)
        {
          if(1 + i >= *argc)
          {
            rfbUsage();
            return (signed char)0;
          }

          i = i + 1;
          rfbScreen->port=atoi(argv[(signed long int)i]);
        }

        else
        {
          return_value_strcmp_23=strcmp(argv[(signed long int)i], "-rfbportv6");
          if(return_value_strcmp_23 == 0)
          {
            if(1 + i >= *argc)
            {
              rfbUsage();
              return (signed char)0;
            }

            i = i + 1;
            rfbScreen->ipv6port=atoi(argv[(signed long int)i]);
          }

          else
          {
            return_value_strcmp_22=strcmp(argv[(signed long int)i], "-rfbwait");
            if(return_value_strcmp_22 == 0)
            {
              if(1 + i >= *argc)
              {
                rfbUsage();
                return (signed char)0;
              }

              i = i + 1;
              rfbScreen->maxClientWait=atoi(argv[(signed long int)i]);
            }

            else
            {
              return_value_strcmp_21=strcmp(argv[(signed long int)i], "-rfbauth");
              if(return_value_strcmp_21 == 0)
              {
                if(1 + i >= *argc)
                {
                  rfbUsage();
                  return (signed char)0;
                }

                i = i + 1;
                rfbScreen->authPasswdData = (void *)argv[(signed long int)i];
              }

              else
              {
                return_value_strcmp_20=strcmp(argv[(signed long int)i], "-permitfiletransfer");
                if(return_value_strcmp_20 == 0)
                  rfbScreen->permitFileTransfer = (signed char)-1;

                else
                {
                  return_value_strcmp_19=strcmp(argv[(signed long int)i], "-rfbversion");
                  if(return_value_strcmp_19 == 0)
                  {
                    if(1 + i >= *argc)
                    {
                      rfbUsage();
                      return (signed char)0;
                    }

                    i = i + 1;
                    sscanf(argv[(signed long int)i], "%d.%d", &rfbScreen->protocolMajorVersion, &rfbScreen->protocolMinorVersion);
                  }

                  else
                  {
                    return_value_strcmp_18=strcmp(argv[(signed long int)i], "-passwd");
                    if(return_value_strcmp_18 == 0)
                    {
                      char **passwds;
                      void *return_value_malloc_1;
                      return_value_malloc_1=malloc(sizeof(char **) /*8ul*/  * (unsigned long int)2);
                      passwds = (char **)return_value_malloc_1;
                      if(1 + i >= *argc)
                      {
                        rfbUsage();
                        return (signed char)0;
                      }

                      i = i + 1;
                      passwds[(signed long int)0] = argv[(signed long int)i];
                      passwds[(signed long int)1] = (char *)(void *)0;
                      rfbScreen->authPasswdData = (void *)passwds;
                      rfbScreen->passwordCheck = rfbCheckPasswordByList;
                    }

                    else
                    {
                      return_value_strcmp_17=strcmp(argv[(signed long int)i], "-deferupdate");
                      if(return_value_strcmp_17 == 0)
                      {
                        if(1 + i >= *argc)
                        {
                          rfbUsage();
                          return (signed char)0;
                        }

                        i = i + 1;
                        rfbScreen->deferUpdateTime=atoi(argv[(signed long int)i]);
                      }

                      else
                      {
                        return_value_strcmp_16=strcmp(argv[(signed long int)i], "-deferptrupdate");
                        if(return_value_strcmp_16 == 0)
                        {
                          if(1 + i >= *argc)
                          {
                            rfbUsage();
                            return (signed char)0;
                          }

                          i = i + 1;
                          rfbScreen->deferPtrUpdateTime=atoi(argv[(signed long int)i]);
                        }

                        else
                        {
                          return_value_strcmp_15=strcmp(argv[(signed long int)i], "-desktop");
                          if(return_value_strcmp_15 == 0)
                          {
                            if(1 + i >= *argc)
                            {
                              rfbUsage();
                              return (signed char)0;
                            }

                            i = i + 1;
                            rfbScreen->desktopName = argv[(signed long int)i];
                          }

                          else
                          {
                            return_value_strcmp_14=strcmp(argv[(signed long int)i], "-alwaysshared");
                            if(return_value_strcmp_14 == 0)
                              rfbScreen->alwaysShared = (signed char)-1;

                            else
                            {
                              return_value_strcmp_13=strcmp(argv[(signed long int)i], "-nevershared");
                              if(return_value_strcmp_13 == 0)
                                rfbScreen->neverShared = (signed char)-1;

                              else
                              {
                                return_value_strcmp_12=strcmp(argv[(signed long int)i], "-dontdisconnect");
                                if(return_value_strcmp_12 == 0)
                                  rfbScreen->dontDisconnect = (signed char)-1;

                                else
                                {
                                  return_value_strcmp_11=strcmp(argv[(signed long int)i], "-httpdir");
                                  if(return_value_strcmp_11 == 0)
                                  {
                                    if(1 + i >= *argc)
                                    {
                                      rfbUsage();
                                      return (signed char)0;
                                    }

                                    i = i + 1;
                                    rfbScreen->httpDir = argv[(signed long int)i];
                                  }

                                  else
                                  {
                                    return_value_strcmp_10=strcmp(argv[(signed long int)i], "-httpport");
                                    if(return_value_strcmp_10 == 0)
                                    {
                                      if(1 + i >= *argc)
                                      {
                                        rfbUsage();
                                        return (signed char)0;
                                      }

                                      i = i + 1;
                                      rfbScreen->httpPort=atoi(argv[(signed long int)i]);
                                    }

                                    else
                                    {
                                      return_value_strcmp_9=strcmp(argv[(signed long int)i], "-httpportv6");
                                      if(return_value_strcmp_9 == 0)
                                      {
                                        if(1 + i >= *argc)
                                        {
                                          rfbUsage();
                                          return (signed char)0;
                                        }

                                        i = i + 1;
                                        rfbScreen->http6Port=atoi(argv[(signed long int)i]);
                                      }

                                      else
                                      {
                                        return_value_strcmp_8=strcmp(argv[(signed long int)i], "-enablehttpproxy");
                                        if(return_value_strcmp_8 == 0)
                                          rfbScreen->httpEnableProxyConnect = (signed char)-1;

                                        else
                                        {
                                          return_value_strcmp_7=strcmp(argv[(signed long int)i], "-progressive");
                                          if(return_value_strcmp_7 == 0)
                                          {
                                            if(1 + i >= *argc)
                                            {
                                              rfbUsage();
                                              return (signed char)0;
                                            }

                                            i = i + 1;
                                            rfbScreen->progressiveSliceHeight=atoi(argv[(signed long int)i]);
                                          }

                                          else
                                          {
                                            return_value_strcmp_6=strcmp(argv[(signed long int)i], "-listen");
                                            if(return_value_strcmp_6 == 0)
                                            {
                                              if(1 + i >= *argc)
                                              {
                                                rfbUsage();
                                                return (signed char)0;
                                              }

                                              i = i + 1;
                                              signed int return_value_rfbStringToAddr_2;
                                              return_value_rfbStringToAddr_2=rfbStringToAddr(argv[(signed long int)i], &rfbScreen->listenInterface);
                                              if(return_value_rfbStringToAddr_2 == 0)
                                                return (signed char)0;

                                            }

                                            else
                                            {
                                              return_value_strcmp_5=strcmp(argv[(signed long int)i], "-listenv6");
                                              if(return_value_strcmp_5 == 0)
                                              {
                                                if(1 + i >= *argc)
                                                {
                                                  rfbUsage();
                                                  return (signed char)0;
                                                }

                                                i = i + 1;
                                                rfbScreen->listen6Interface = argv[(signed long int)i];
                                              }

                                              else
                                              {
                                                return_value_strcmp_4=strcmp(argv[(signed long int)i], "-sslkeyfile");
                                                if(return_value_strcmp_4 == 0)
                                                {
                                                  if(1 + i >= *argc)
                                                  {
                                                    rfbUsage();
                                                    return (signed char)0;
                                                  }

                                                  i = i + 1;
                                                  rfbScreen->sslkeyfile = argv[(signed long int)i];
                                                }

                                                else
                                                {
                                                  return_value_strcmp_3=strcmp(argv[(signed long int)i], "-sslcertfile");
                                                  if(return_value_strcmp_3 == 0)
                                                  {
                                                    if(1 + i >= *argc)
                                                    {
                                                      rfbUsage();
                                                      return (signed char)0;
                                                    }

                                                    i = i + 1;
                                                    rfbScreen->sslcertfile = argv[(signed long int)i];
                                                  }

                                                  else
                                                  {
                                                    struct _rfbProtocolExtension *extension;
                                                    signed int handled = 0;
                                                    extension=rfbGetExtensionIterator();
                                                    for( ; handled == 0 && !(extension == ((struct _rfbProtocolExtension *)NULL)); extension = extension->next)
                                                      if(!(extension->processArgument == ((signed int (*)(signed int, char **))NULL)))
                                                        handled=extension->processArgument(*argc - i, argv + (signed long int)i);

                                                    rfbReleaseExtensionIterator();
                                                    if(handled == 0)
                                                    {
                                                      i = i + 1;
                                                      i1 = i;
                                                      continue;
                                                    }

                                                    i = i + (handled - 1);
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      rfbPurgeArguments(argc, &i1, (i - i1) + 1, argv);
      i = i1;
    }
    return (signed char)-1;
  }
}

// rfbProcessClientAuthType
// file tightvnc-filetransfer/rfbtightserver.c line 106
void rfbProcessClientAuthType(struct _rfbClientRec *cl)
{
  unsigned int auth_type;
  signed int n;
  signed int i;
  struct _rfbTightClientRec *rtcp;
  rtcp=rfbGetTightClientData(cl);
  rfbLog("tightvnc-filetransfer/rfbProcessClientAuthType\n");
  if(!(rtcp == ((struct _rfbTightClientRec *)NULL)))
  {
    n=rfbReadExact(cl, (char *)&auth_type, (signed int)sizeof(unsigned int) /*4ul*/ );
    if(!(n >= 1))
    {
      if(n == 0)
        rfbLog("rfbProcessClientAuthType: client gone\n");

      else
        rfbLogPerror("rfbProcessClientAuthType: read");
      rfbCloseClient(cl);
    }

    else
    {
      auth_type = rfbEndianTest != 0 ? auth_type >> 24 | (auth_type & (unsigned int)0x00ff0000) >> 8 | (auth_type & (unsigned int)0x0000ff00) << 8 | auth_type << 24 : auth_type;
      i = 0;
      if(!(i >= rtcp->nAuthCaps))
      {
        if(!(auth_type == rtcp->authCaps[(signed long int)i]))
          i = i + 1;

      }

      if(i >= rtcp->nAuthCaps)
      {
        rfbLog("rfbProcessClientAuthType: wrong authentication type requested\n");
        rfbCloseClient(cl);
      }

      else
      {
        if(auth_type == 1u)
        {
          if(cl->protocolMajorVersion == 3)
          {
            if(cl->protocolMinorVersion >= 8)
            {
              unsigned int authResult;
              rfbLog("rfbProcessClientSecurityType: returning securityResult for client rfb version >= 3.8\n");
              authResult = (unsigned int)(rfbEndianTest != 0 ? 0 >> 24 | (0 & 0x00ff0000) >> 8 | (0 & 0x0000ff00) << 8 | 0 << 24 : 0);
              signed int return_value_rfbWriteExact_1;
              return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)&authResult, 4);
              if(!(return_value_rfbWriteExact_1 >= 0))
              {
                rfbLogPerror("rfbAuthProcessClientMessage: write");
                rfbCloseClient(cl);
              }

            }

          }

          cl->state = (enum anonymous_13)RFB_INITIALISATION;
          rfbVncAuthSendChallenge_link1(cl);
        }

        rfbLog("rfbProcessClientAuthType: unknown authentication scheme\n");
        rfbCloseClient(cl);
      }
    }
  }

}

// rfbProcessClientInitMessage
// file rfbserver.c line 762
static void rfbProcessClientInitMessage(struct _rfbClientRec *cl)
{
  struct anonymous_54 ci;
  /* tag-#anon#lUN[lARR256{S8}_S8_'buf'||SYM#tag-#anon#ST[U16'framebufferWidth'||U16'framebufferHeight'||SYM#tag-#anon#ST[U8'bitsPerPixel'||U8'depth'||U8'bigEndian'||U8'trueColour'||U16'redMax'||U16'greenMax'||U16'blueMax'||U8'redShift'||U8'greenShift'||U8'blueShift'||U8'pad1'||U16'pad2'|]#'format'||U32'nameLength'|]#'si'|] */
union anonymous_51
{
  // buf
  char buf[256l];
  // si
  struct anonymous_50 si;
};

/* */
  ;
  union anonymous_51 u;
  signed int len;
  signed int n;
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *otherCl;
  struct _rfbExtensionData *extension;
  if((signed int)cl->state == RFB_INITIALISATION_SHARED)
  {
    ci.shared = (unsigned char)1;
    cl->state = (enum anonymous_13)RFB_INITIALISATION;
  }

  else
  {
    n=rfbReadExact(cl, (char *)&ci, 1);
    if(!(n >= 1))
    {
      if(n == 0)
        rfbLog("rfbProcessClientInitMessage: client gone\n");

      else
        rfbLogPerror("rfbProcessClientInitMessage: read");
      rfbCloseClient(cl);
      goto __CPROVER_DUMP_L23;
    }

  }
  memset((void *)u.buf, 0, sizeof(char [256l]) /*256ul*/ );
  signed int tmp_if_expr_1;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_1 = (cl->screen->width & 0xff) << 8 | cl->screen->width >> 8 & 0xff;

  else
    tmp_if_expr_1 = cl->screen->width;
  u.si.framebufferWidth = (unsigned short int)tmp_if_expr_1;
  signed int tmp_if_expr_2;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_2 = (cl->screen->height & 0xff) << 8 | cl->screen->height >> 8 & 0xff;

  else
    tmp_if_expr_2 = cl->screen->height;
  u.si.framebufferHeight = (unsigned short int)tmp_if_expr_2;
  u.si.format = cl->screen->serverFormat;
  u.si.format.redMax = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)u.si.format.redMax & 0xff) << 8 | (signed int)u.si.format.redMax >> 8 & 0xff : (signed int)u.si.format.redMax);
  u.si.format.greenMax = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)u.si.format.greenMax & 0xff) << 8 | (signed int)u.si.format.greenMax >> 8 & 0xff : (signed int)u.si.format.greenMax);
  u.si.format.blueMax = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)u.si.format.blueMax & 0xff) << 8 | (signed int)u.si.format.blueMax >> 8 & 0xff : (signed int)u.si.format.blueMax);
  strncpy(u.buf + (signed long int)(8 + 16), cl->screen->desktopName, (unsigned long int)127);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(u.buf + (signed long int)(8 + 16));
  len = (signed int)return_value_strlen_3;
  u.si.nameLength = (unsigned int)(rfbEndianTest != 0 ? len >> 24 | (len & 0x00ff0000) >> 8 | (len & 0x0000ff00) << 8 | len << 24 : len);
  signed int return_value_rfbWriteExact_4;
  return_value_rfbWriteExact_4=rfbWriteExact(cl, u.buf, 8 + 16 + len);
  signed char return_value;
  _Bool tmp_if_expr_5;
  if(!(return_value_rfbWriteExact_4 >= 0))
  {
    rfbLogPerror("rfbProcessClientInitMessage: write");
    rfbCloseClient(cl);
  }

  else
  {
    extension = cl->extensions;
    while(!(extension == ((struct _rfbExtensionData *)NULL)))
    {
      struct _rfbExtensionData *next = extension->next;
      if(!(extension->extension->init == ((signed char (*)(struct _rfbClientRec *, void *))NULL)))
      {
        return_value=extension->extension->init(cl, extension->data);
        if(return_value == 0)
          rfbDisableExtension(cl, extension->extension);

      }

      extension = next;
    }
    cl->state = (enum anonymous_13)RFB_NORMAL;
    if(cl->reverseConnection == 0)
    {
      if(!(cl->screen->neverShared == 0))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (!(cl->screen->alwaysShared != 0) ? (!(ci.shared != 0) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        if(!(cl->screen->dontDisconnect == 0))
        {
          iterator=rfbGetClientIterator(cl->screen);
          do
          {
            otherCl=rfbClientIteratorNext(iterator);
            if(otherCl == ((struct _rfbClientRec *)NULL))
              break;

            if(!(otherCl == cl))
            {
              if((signed int)otherCl->state == RFB_NORMAL)
              {
                rfbLog("-dontdisconnect: Not shared & existing client\n");
                rfbLog("  refusing new client %s\n", cl->host);
                rfbCloseClient(cl);
                rfbReleaseClientIterator(iterator);
              }

            }

          }
          while((_Bool)1);
          rfbReleaseClientIterator(iterator);
        }

        else
        {
          iterator=rfbGetClientIterator(cl->screen);
          do
          {
            otherCl=rfbClientIteratorNext(iterator);
            if(otherCl == ((struct _rfbClientRec *)NULL))
              break;

            if(!(otherCl == cl))
            {
              if((signed int)otherCl->state == RFB_NORMAL)
              {
                rfbLog("Not shared - closing connection to client %s\n", otherCl->host);
                rfbCloseClient(otherCl);
              }

            }

          }
          while((_Bool)1);
          rfbReleaseClientIterator(iterator);
        }
      }

    }

  }

__CPROVER_DUMP_L23:
  ;
}

// rfbProcessClientMessage
// file ../rfb/rfb.h line 788
extern void rfbProcessClientMessage(struct _rfbClientRec *cl)
{
  switch((signed int)cl->state)
  {
    case RFB_PROTOCOL_VERSION:
    {
      rfbProcessClientProtocolVersion(cl);
      break;
    }
    case RFB_SECURITY_TYPE:
    {
      rfbProcessClientSecurityType(cl);
      break;
    }
    case RFB_AUTHENTICATION:
    {
      rfbAuthProcessClientMessage(cl);
      break;
    }
    case RFB_INITIALISATION:

    case RFB_INITIALISATION_SHARED:
    {
      rfbProcessClientInitMessage(cl);
      break;
    }
    default:
      rfbProcessClientNormalMessage(cl);
  }
}

// rfbProcessClientNormalMessage
// file rfbserver.c line 1985
static void rfbProcessClientNormalMessage(struct _rfbClientRec *cl)
{
  signed int n = 0;
  union anonymous_1 msg;
  char *str;
  signed int i;
  unsigned int enc = (unsigned int)0;
  unsigned int lastPreferredEncoding = (unsigned int)-1;
  char encBuf[64l];
  char encBuf2[64l];
  signed char return_value_webSocketCheckDisconnect_1;
  signed char return_value;
  char *return_value_encodingName_3;
  char *return_value_encodingName_7;
  char *return_value_encodingName_8;
  struct sraRegion *tmpRegion;
  signed char return_value_rectSwapIfLEAndClip_9;
  _Bool tmp_if_expr_13;
  void *return_value_malloc_15;
  signed char return_value_2;
  struct _rfbExtensionData *rfbProcessClientNormalMessage__1__2__25__e;
  struct _rfbExtensionData *rfbProcessClientNormalMessage__1__2__25__next;
  signed char return_value_3;
  if(!(cl->wsctx == ((struct _wsCtx *)NULL)))
  {
    return_value_webSocketCheckDisconnect_1=webSocketCheckDisconnect(cl);
    if(return_value_webSocketCheckDisconnect_1 == 0)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    n=rfbReadExact(cl, (char *)&msg, 1);
    if(!(n >= 1))
    {
      if(!(n == 0))
        rfbLogPerror("rfbProcessClientNormalMessage: read");

      rfbCloseClient(cl);
    }

    else
    {
      switch((signed int)msg.type)
      {
        case 0:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, (16 + 4) - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;
          cl->format.depth = msg.spf.format.depth;
          cl->format.bigEndian = (unsigned char)(msg.spf.format.bigEndian != 0 ? -1 : 0);
          cl->format.trueColour = (unsigned char)(msg.spf.format.trueColour != 0 ? -1 : 0);
          cl->format.redMax = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.spf.format.redMax & 0xff) << 8 | (signed int)msg.spf.format.redMax >> 8 & 0xff : (signed int)msg.spf.format.redMax);
          cl->format.greenMax = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.spf.format.greenMax & 0xff) << 8 | (signed int)msg.spf.format.greenMax >> 8 & 0xff : (signed int)msg.spf.format.greenMax);
          cl->format.blueMax = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.spf.format.blueMax & 0xff) << 8 | (signed int)msg.spf.format.blueMax >> 8 & 0xff : (signed int)msg.spf.format.blueMax);
          cl->format.redShift = msg.spf.format.redShift;
          cl->format.greenShift = msg.spf.format.greenShift;
          cl->format.blueShift = msg.spf.format.blueShift;
          cl->readyForSetColourMapEntries = (signed char)-1;
          cl->screen->setTranslateFunction(cl);
        }
        case 1:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 6 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 16 + 4, 16 + 4);
          rfbLog("rfbProcessClientNormalMessage: %s", (const void *)"FixColourMapEntries unsupported\n");
        }
        case 2:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          msg.se.nEncodings = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.se.nEncodings & 0xff) << 8 | (signed int)msg.se.nEncodings >> 8 & 0xff : (signed int)msg.se.nEncodings);
          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 4 + (signed int)msg.se.nEncodings * 4, 4 + (signed int)msg.se.nEncodings * 4);
          if(!(cl->preferredEncoding == -1))
            lastPreferredEncoding = (unsigned int)cl->preferredEncoding;

          cl->preferredEncoding = -1;
          cl->useCopyRect = (signed char)0;
          cl->useNewFBSize = (signed char)0;
          cl->cursorWasChanged = (signed char)0;
          cl->useRichCursorEncoding = (signed char)0;
          cl->enableCursorPosUpdates = (signed char)0;
          cl->enableCursorShapeUpdates = (signed char)0;
          cl->enableCursorShapeUpdates = (signed char)0;
          cl->enableLastRectEncoding = (signed char)0;
          cl->enableKeyboardLedState = (signed char)0;
          cl->enableSupportedMessages = (signed char)0;
          cl->enableSupportedEncodings = (signed char)0;
          cl->enableServerIdentity = (signed char)0;
          cl->tightQualityLevel = -1;
          cl->tightCompressLevel = 6;
          cl->turboSubsampLevel = 0;
          cl->turboQualityLevel = -1;
          i = 0;
          for( ; !(i >= (signed int)msg.se.nEncodings); i = i + 1)
          {
            n=rfbReadExact(cl, (char *)&enc, 4);
            if(!(n >= 1))
            {
              if(!(n == 0))
                rfbLogPerror("rfbProcessClientNormalMessage: read");

              rfbCloseClient(cl);
              goto __CPROVER_DUMP_L136;
            }

            enc = rfbEndianTest != 0 ? enc >> 24 | (enc & (unsigned int)0x00ff0000) >> 8 | (enc & (unsigned int)0x0000ff00) << 8 | enc << 24 : enc;
            switch(enc)
            {
              case (unsigned int)1:
              {
                cl->useCopyRect = (signed char)-1;
                break;
              }
              case (unsigned int)0:

              case (unsigned int)2:

              case (unsigned int)4:

              case (unsigned int)5:

              case (unsigned int)9:

              case (unsigned int)6:

              case (unsigned int)16:

              case (unsigned int)17:

              case (unsigned int)7:
              {
                if(cl->preferredEncoding == -1)
                  cl->preferredEncoding = (signed int)enc;

                break;
              }
              case 0xFFFFFF10:
              {
                if(cl->screen->dontConvertRichCursorToXCursor == 0)
                {
                  rfbLog("Enabling X-style cursor updates for client %s\n", cl->host);
                  if(cl->enableCursorShapeUpdates == 0)
                    rfbRedrawAfterHideCursor(cl, (struct sraRegion *)(void *)0);

                  cl->enableCursorShapeUpdates = (signed char)-1;
                  cl->cursorWasChanged = (signed char)-1;
                }

                break;
              }
              case 0xFFFFFF11:
                rfbLog("Enabling full-color cursor updates for client %s\n", cl->host);
              case 0xFFFFFF18:
              {
                if(cl->enableCursorPosUpdates == 0)
                {
                  rfbLog("Enabling cursor position updates for client %s\n", cl->host);
                  cl->enableCursorPosUpdates = (signed char)-1;
                  cl->cursorWasMoved = (signed char)-1;
                }

                break;
              }
              case 0xFFFFFF20:
              {
                if(cl->enableLastRectEncoding == 0)
                {
                  rfbLog("Enabling LastRect protocol extension for client %s\n", cl->host);
                  cl->enableLastRectEncoding = (signed char)-1;
                }

                break;
              }
              case 0xFFFFFF21:
              {
                if(cl->useNewFBSize == 0)
                {
                  rfbLog("Enabling NewFBSize protocol extension for client %s\n", cl->host);
                  cl->useNewFBSize = (signed char)-1;
                }

                break;
              }
              case 0xFFFE0000:
              {
                if(cl->enableKeyboardLedState == 0)
                {
                  rfbLog("Enabling KeyboardLedState protocol extension for client %s\n", cl->host);
                  cl->enableKeyboardLedState = (signed char)-1;
                }

                break;
              }
              case 0xFFFE0001:
              {
                if(cl->enableSupportedMessages == 0)
                {
                  rfbLog("Enabling SupportedMessages protocol extension for client %s\n", cl->host);
                  cl->enableSupportedMessages = (signed char)-1;
                }

                break;
              }
              case 0xFFFE0002:
              {
                if(cl->enableSupportedEncodings == 0)
                {
                  rfbLog("Enabling SupportedEncodings protocol extension for client %s\n", cl->host);
                  cl->enableSupportedEncodings = (signed char)-1;
                }

                break;
              }
              case 0xFFFE0003:
              {
                if(cl->enableServerIdentity == 0)
                {
                  rfbLog("Enabling ServerIdentity protocol extension for client %s\n", cl->host);
                  cl->enableServerIdentity = (signed char)-1;
                }

                break;
              }
              case 0xFFFFFECB:
                rfbLog("Enabling Xvp protocol extension for client %s\n", cl->host);
              default:
                if(enc >= 0xFFFFFF00 && !(enc >= 4294967050u))
                {
                  cl->zlibCompressLevel = enc & (unsigned int)0x0F;
                  cl->tightCompressLevel = (signed int)(enc & (unsigned int)0x0F);
                  rfbLog("Using compression level %d for client %s\n", cl->tightCompressLevel, cl->host);
                }

                else
                  if(enc >= 0xFFFFFFE0 && !(enc >= 4294967274u))
                  {
                    cl->tightQualityLevel = (signed int)(enc & (unsigned int)0x0F);
                    rfbLog("Using image quality level %d for client %s\n", cl->tightQualityLevel, cl->host);
                    cl->turboQualityLevel = tight2turbo_qual[(signed long int)(enc & (unsigned int)0x0F)];
                    cl->turboSubsampLevel = tight2turbo_subsamp[(signed long int)(enc & (unsigned int)0x0F)];
                    rfbLog("Using JPEG subsampling %d, Q%d for client %s\n", cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);
                  }

                  else
                    if(enc >= 4294966785u && !(enc >= 4294966885u))
                    {
                      cl->turboQualityLevel = (signed int)(enc & (unsigned int)0xFF);
                      rfbLog("Using fine quality level %d for client %s\n", cl->turboQualityLevel, cl->host);
                    }

                    else
                      if(enc >= 0xFFFFFD00 && !(enc >= 4294966532u))
                      {
                        cl->turboSubsampLevel = (signed int)(enc & (unsigned int)0xFF);
                        rfbLog("Using subsampling level %d for client %s\n", cl->turboSubsampLevel, cl->host);
                      }

                      else
                      {
                        struct _rfbExtensionData *e = cl->extensions;
                        while(!(e == ((struct _rfbExtensionData *)NULL)))
                        {
                          struct _rfbExtensionData *next = e->next;
                          if(!(e->extension->enablePseudoEncoding == ((signed char (*)(struct _rfbClientRec *, void **, signed int))NULL)))
                          {
                            return_value=e->extension->enablePseudoEncoding(cl, &e->data, (signed int)enc);
                            if(!(return_value == 0))
                              break;

                          }

                          e = next;
                        }
                        if(e == ((struct _rfbExtensionData *)NULL))
                        {
                          signed char handled = (signed char)0;
                          struct _rfbProtocolExtension *rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e;
                          rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e=rfbGetExtensionIterator();
                          while(!(rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e == ((struct _rfbProtocolExtension *)NULL)))
                          {
                            signed int *encs = rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e->pseudoEncodings;
                            for( ; !(encs == ((signed int *)NULL)); encs = encs + 1l)
                            {
                              if(*encs == 0)
                                break;

                              if(*encs == (signed int)enc)
                              {
                                void *data = (void *)0;
                                signed char return_value_1;
                                return_value_1=rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e->enablePseudoEncoding(cl, &data, (signed int)enc);
                                if(return_value_1 == 0)
                                  rfbLog("Installed extension pretends to handle pseudo encoding 0x%x, but does not!\n", (signed int)enc);

                                else
                                {
                                  rfbEnableExtension(cl, rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e, data);
                                  handled = (signed char)-1;
                                  rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e = (struct _rfbProtocolExtension *)(void *)0;
                                  break;
                                }
                              }

                            }
                            if(!(rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e == ((struct _rfbProtocolExtension *)NULL)))
                              rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e = rfbProcessClientNormalMessage__1__2__3__2__1__2__14__2__e->next;

                          }
                          rfbReleaseExtensionIterator();
                          if(handled == 0)
                          {
                            return_value_encodingName_3=encodingName(enc, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
                            rfbLog("rfbProcessClientNormalMessage: ignoring unsupported encoding type %s\n", return_value_encodingName_3);
                          }

                        }

                      }
            }
          }
          if(cl->preferredEncoding == -1)
          {
            if(lastPreferredEncoding == 4294967295u)
            {
              cl->preferredEncoding = 0;
              char *return_value_encodingName_4;
              return_value_encodingName_4=encodingName((unsigned int)cl->preferredEncoding, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
              rfbLog("Defaulting to %s encoding for client %s\n", return_value_encodingName_4, cl->host);
            }

            else
            {
              cl->preferredEncoding = (signed int)lastPreferredEncoding;
              char *return_value_encodingName_5;
              return_value_encodingName_5=encodingName((unsigned int)cl->preferredEncoding, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
              rfbLog("Sticking with %s encoding for client %s\n", return_value_encodingName_5, cl->host);
            }
          }

          if(lastPreferredEncoding == 4294967295u)
          {
            char *return_value_encodingName_6;
            return_value_encodingName_6=encodingName((unsigned int)cl->preferredEncoding, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
            rfbLog("Using %s encoding for client %s\n", return_value_encodingName_6, cl->host);
          }

          return_value_encodingName_7=encodingName(lastPreferredEncoding, encBuf2, (signed int)sizeof(char [64l]) /*64ul*/ );
          return_value_encodingName_8=encodingName((unsigned int)cl->preferredEncoding, encBuf, (signed int)sizeof(char [64l]) /*64ul*/ );
          rfbLog("Switching from %s to %s Encoding for client %s\n", return_value_encodingName_7, return_value_encodingName_8, cl->host);
        }
        case 3:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 10 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 10, 10);
          return_value_rectSwapIfLEAndClip_9=rectSwapIfLEAndClip(&msg.fur.x, &msg.fur.y, &msg.fur.w, &msg.fur.h, cl);
          if(return_value_rectSwapIfLEAndClip_9 == 0)
          {
            rfbLog("Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\n", msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);
            break;
          }

          tmpRegion=sraRgnCreateRect((signed int)msg.fur.x, (signed int)msg.fur.y, (signed int)msg.fur.x + (signed int)msg.fur.w, (signed int)msg.fur.y + (signed int)msg.fur.h);
          pthread_mutex_lock(&cl->updateMutex);
          sraRgnOr(cl->requestedRegion, tmpRegion);
          if(cl->readyForSetColourMapEntries == 0)
          {
            cl->readyForSetColourMapEntries = (signed char)-1;
            if(cl->format.trueColour == 0)
            {
              signed char return_value_rfbSetClientColourMap_10;
              return_value_rfbSetClientColourMap_10=rfbSetClientColourMap(cl, 0, 0);
              if(return_value_rfbSetClientColourMap_10 == 0)
              {
                sraRgnDestroy(tmpRegion);
                pthread_cond_signal(&cl->updateCond);
                pthread_mutex_unlock(&cl->updateMutex);
                break;
              }

            }

          }

          if(msg.fur.incremental == 0)
          {
            sraRgnOr(cl->modifiedRegion, tmpRegion);
            sraRgnSubtract(cl->copyRegion, tmpRegion);
          }

          pthread_cond_signal(&cl->updateCond);
          pthread_mutex_unlock(&cl->updateMutex);
          sraRgnDestroy(tmpRegion);
          break;
        }
        case 4:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 8 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 8, 8);
          if(cl->viewOnly == 0)
            cl->screen->kbdAddEvent((signed char)msg.ke.down, (unsigned int)(rfbEndianTest != 0 ? msg.ke.key >> 24 | (msg.ke.key & (unsigned int)0x00ff0000) >> 8 | (msg.ke.key & (unsigned int)0x0000ff00) << 8 | msg.ke.key << 24 : msg.ke.key), cl);

          break;
        }
        case 5:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 6 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 6, 6);
          if(!(cl->screen->pointerClient == ((struct _rfbClientRec *)NULL)))
          {
            if(!(cl->screen->pointerClient == cl))
              break;

          }

          if((signed int)msg.pe.buttonMask == 0)
            cl->screen->pointerClient = (struct _rfbClientRec *)(void *)0;

          else
            cl->screen->pointerClient = cl;
          if(cl->viewOnly == 0)
          {
            if(!((signed int)msg.pe.buttonMask == cl->lastPtrButtons))
              tmp_if_expr_13 = (_Bool)1;

            else
              tmp_if_expr_13 = cl->screen->deferPtrUpdateTime == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_13)
            {
              signed int return_value_ScaleX_11;
              return_value_ScaleX_11=ScaleX(cl->scaledScreen, cl->screen, rfbEndianTest != 0 ? ((signed int)msg.pe.x & 0xff) << 8 | (signed int)msg.pe.x >> 8 & 0xff : (signed int)msg.pe.x);
              signed int return_value_ScaleY_12;
              return_value_ScaleY_12=ScaleY(cl->scaledScreen, cl->screen, rfbEndianTest != 0 ? ((signed int)msg.pe.y & 0xff) << 8 | (signed int)msg.pe.y >> 8 & 0xff : (signed int)msg.pe.y);
              cl->screen->ptrAddEvent((signed int)msg.pe.buttonMask, return_value_ScaleX_11, return_value_ScaleY_12, cl);
              cl->lastPtrButtons = (signed int)msg.pe.buttonMask;
            }

            else
            {
              cl->lastPtrX=ScaleX(cl->scaledScreen, cl->screen, rfbEndianTest != 0 ? ((signed int)msg.pe.x & 0xff) << 8 | (signed int)msg.pe.x >> 8 & 0xff : (signed int)msg.pe.x);
              cl->lastPtrY=ScaleY(cl->scaledScreen, cl->screen, rfbEndianTest != 0 ? ((signed int)msg.pe.y & 0xff) << 8 | (signed int)msg.pe.y >> 8 & 0xff : (signed int)msg.pe.y);
              cl->lastPtrButtons = (signed int)msg.pe.buttonMask;
            }
          }

          break;
        }
        case 7:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 12 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          msg.ft.size = rfbEndianTest != 0 ? msg.ft.size >> 24 | (msg.ft.size & (unsigned int)0x00ff0000) >> 8 | (msg.ft.size & (unsigned int)0x0000ff00) << 8 | msg.ft.size << 24 : msg.ft.size;
          msg.ft.length = rfbEndianTest != 0 ? msg.ft.length >> 24 | (msg.ft.length & (unsigned int)0x00ff0000) >> 8 | (msg.ft.length & (unsigned int)0x0000ff00) << 8 | msg.ft.length << 24 : msg.ft.length;
          rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);
          break;
        }
        case 10:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 6 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          msg.sw.x = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.sw.x & 0xff) << 8 | (signed int)msg.sw.x >> 8 & 0xff : (signed int)msg.sw.x);
          msg.sw.y = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.sw.y & 0xff) << 8 | (signed int)msg.sw.y >> 8 & 0xff : (signed int)msg.sw.y);
          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 6, 6);
          rfbLog("Received a rfbSetSingleWindow(%d x, %d y)\n", msg.sw.x, msg.sw.y);
        }
        case 9:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 4, 4);
          rfbLog("Received a rfbSetServerInput(%d status)\n", msg.sim.status);
        }
        case 11:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 8 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          msg.tc.pad2 = (unsigned short int)(rfbEndianTest != 0 ? ((signed int)msg.tc.pad2 & 0xff) << 8 | (signed int)msg.tc.pad2 >> 8 & 0xff : (signed int)msg.tc.pad2);
          msg.tc.length = rfbEndianTest != 0 ? msg.tc.length >> 24 | (msg.tc.length & (unsigned int)0x00ff0000) >> 8 | (msg.tc.length & (unsigned int)0x0000ff00) << 8 | msg.tc.length << 24 : msg.tc.length;
          if(msg.tc.length == 0xFFFFFFFD || msg.tc.length == 0xFFFFFFFE || msg.tc.length == 0xFFFFFFFF)
          {
            str = (char *)(void *)0;
            rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 8, 8);
            goto __CPROVER_DUMP_L109;
          }

          if(msg.tc.length >= 1u && !(msg.tc.length >= 4096u))
          {
            void *return_value_malloc_14;
            return_value_malloc_14=malloc((unsigned long int)msg.tc.length);
            str = (char *)return_value_malloc_14;
            if(str == ((char *)NULL))
            {
              rfbLog("Unable to malloc %d bytes for a TextChat Message\n", msg.tc.length);
              rfbCloseClient(cl);
              break;
            }

            n=rfbReadExact(cl, str, (signed int)msg.tc.length);
            if(!(n >= 1))
            {
              if(!(n == 0))
                rfbLogPerror("rfbProcessClientNormalMessage: read");

              free((void *)str);
              rfbCloseClient(cl);
              break;
            }

            rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, (signed int)((unsigned int)8 + msg.tc.length), (signed int)((unsigned int)8 + msg.tc.length));
          }

          else
          {
            rfbLog("client sent us a Text Message that is too big %d>%d\n", msg.tc.length, 4096);
            rfbCloseClient(cl);
            break;
          }

        __CPROVER_DUMP_L109:
          ;
          if(!(cl->screen->setTextChat == ((void (*)(struct _rfbClientRec *, signed int, char *))NULL)))
            cl->screen->setTextChat(cl, (signed int)msg.tc.length, str);

          free((void *)str);
          break;
        }
        case 6:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 8 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          msg.cct.length = rfbEndianTest != 0 ? msg.cct.length >> 24 | (msg.cct.length & (unsigned int)0x00ff0000) >> 8 | (msg.cct.length & (unsigned int)0x0000ff00) << 8 | msg.cct.length << 24 : msg.cct.length;
          return_value_malloc_15=malloc((unsigned long int)msg.cct.length);
          str = (char *)return_value_malloc_15;
          if(str == ((char *)NULL))
          {
            rfbLogPerror("rfbProcessClientNormalMessage: not enough memory");
            rfbCloseClient(cl);
            break;
          }

          n=rfbReadExact(cl, str, (signed int)msg.cct.length);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            free((void *)str);
            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, (signed int)((unsigned int)8 + msg.cct.length), (signed int)((unsigned int)8 + msg.cct.length));
          if(cl->viewOnly == 0)
            cl->screen->setXCutText(str, (signed int)msg.cct.length, cl);

          free((void *)str);
          break;
        }
        case 0xF:
        {
          cl->PalmVNC = (signed char)-1;
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          if((signed int)msg.ssc.scale == 0)
          {
            rfbLogPerror("rfbProcessClientNormalMessage: will not accept a scale factor of zero");
            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 4, 4);
          rfbLog("rfbSetScale(%d)\n", msg.ssc.scale);
        }
        case 8:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          if((signed int)msg.ssc.scale == 0)
          {
            rfbLogPerror("rfbProcessClientNormalMessage: will not accept a scale factor of zero");
            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 4, 4);
          rfbLog("rfbSetScale(%d)\n", msg.ssc.scale);
        }
        case 250:
        {
          n=rfbReadExact(cl, (char *)&msg + (signed long int)1, 4 - 1);
          if(!(n >= 1))
          {
            if(!(n == 0))
              rfbLogPerror("rfbProcessClientNormalMessage: read");

            rfbCloseClient(cl);
            break;
          }

          rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 4, 4);
          if(!((signed int)msg.xvp.version == 1))
            rfbSendXvp(cl, msg.xvp.version, (unsigned char)0);

          else
            if(!(cl->screen->xvpHook == ((signed char (*)(struct _rfbClientRec *, unsigned char, unsigned char))NULL)))
            {
              return_value_2=cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code);
              if(return_value_2 == 0)
                rfbSendXvp(cl, (unsigned char)1, (unsigned char)0);

            }

          break;
        }
        default:
        {
          rfbProcessClientNormalMessage__1__2__25__e = cl->extensions;
          while(!(rfbProcessClientNormalMessage__1__2__25__e == ((struct _rfbExtensionData *)NULL)))
          {
            rfbProcessClientNormalMessage__1__2__25__next = rfbProcessClientNormalMessage__1__2__25__e->next;
            if(!(rfbProcessClientNormalMessage__1__2__25__e->extension->handleMessage == ((signed char (*)(struct _rfbClientRec *, void *, const union anonymous_1 *))NULL)))
            {
              return_value_3=rfbProcessClientNormalMessage__1__2__25__e->extension->handleMessage(cl, rfbProcessClientNormalMessage__1__2__25__e->data, &msg);
              if(!(return_value_3 == 0))
                rfbStatRecordMessageRcvd(cl, (unsigned int)msg.type, 0, 0);

            }

            rfbProcessClientNormalMessage__1__2__25__e = rfbProcessClientNormalMessage__1__2__25__next;
          }
          rfbLog("rfbProcessClientNormalMessage: unknown message type %d\n", msg.type);
        }
      }
      rfbLog(" ... closing connection\n");
      rfbCloseClient(cl);
    }
  }

__CPROVER_DUMP_L136:
  ;
}

// rfbProcessClientProtocolVersion
// file rfbserver.c line 662
static void rfbProcessClientProtocolVersion(struct _rfbClientRec *cl)
{
  char pv[13l];
  signed int n;
  signed int major_;
  signed int minor_;
  n=rfbReadExact(cl, pv, 12);
  if(!(n >= 1))
  {
    if(n == 0)
      rfbLog("rfbProcessClientProtocolVersion: client gone\n");

    else
      rfbLogPerror("rfbProcessClientProtocolVersion: read");
    rfbCloseClient(cl);
  }

  else
  {
    pv[(signed long int)12] = (char)0;
    signed int return_value_sscanf_1;
    return_value_sscanf_1=sscanf(pv, "RFB %03d.%03d\n", &major_, &minor_);
    if(!(return_value_sscanf_1 == 2))
    {
      rfbErr("rfbProcessClientProtocolVersion: not a valid RFB client: %s\n", (const void *)pv);
      rfbCloseClient(cl);
    }

    else
    {
      rfbLog("Client Protocol Version %d.%d\n", major_, minor_);
      if(!(major_ == 3))
      {
        rfbErr("RFB protocol version mismatch - server %d.%d, client %d.%d", cl->screen->protocolMajorVersion, cl->screen->protocolMinorVersion, major_, minor_);
        rfbCloseClient(cl);
      }

      else
      {
        cl->protocolMajorVersion = major_;
        cl->protocolMinorVersion = minor_;
        rfbLog("Protocol version sent %d.%d, using %d.%d\n", major_, minor_, 3, cl->protocolMinorVersion);
        rfbAuthNewClient(cl);
      }
    }
  }
}

// rfbProcessClientSecurityType
// file ../rfb/rfb.h line 835
extern void rfbProcessClientSecurityType(struct _rfbClientRec *cl)
{
  signed int n;
  unsigned char chosenType;
  struct _rfbSecurity *handler;
  n=rfbReadExact(cl, (char *)&chosenType, 1);
  if(!(n >= 1))
  {
    if(n == 0)
      rfbLog("rfbProcessClientSecurityType: client gone\n");

    else
      rfbLogPerror("rfbProcessClientSecurityType: read");
    rfbCloseClient(cl);
  }

  else
  {
    handler = securityHandlers;
    for( ; !(handler == ((struct _rfbSecurity *)NULL)); handler = handler->next)
      if(chosenType == handler->type)
      {
        rfbLog("rfbProcessClientSecurityType: executing handler for type %d\n", chosenType);
        handler->handler(cl);
      }

    rfbLog("rfbProcessClientSecurityType: wrong security type (%d) requested\n", chosenType);
    rfbCloseClient(cl);
  }
}

// rfbProcessClientTunnelingType
// file tightvnc-filetransfer/rfbtightserver.c line 166
void rfbProcessClientTunnelingType(struct _rfbClientRec *cl)
{
  rfbLog("rfbProcessClientTunnelingType: not implemented\n");
  rfbCloseClient(cl);
}

// rfbProcessEvents
// file main.c line 1093
extern signed char rfbProcessEvents(struct _rfbScreenInfo *screen, signed long int usec)
{
  struct rfbClientIterator *i;
  struct _rfbClientRec *rfbProcessEvents__1__cl;
  struct _rfbClientRec *clPrev;
  signed char result = (signed char)0;
  if(!(usec >= 0l))
    usec = (signed long int)(screen->deferUpdateTime * 1000);

  rfbCheckFds(screen, usec);
  rfbHttpCheckFds(screen);
  i=rfbGetClientIteratorWithClosed(screen);
  rfbProcessEvents__1__cl=rfbClientIteratorHead(i);
  while(!(rfbProcessEvents__1__cl == ((struct _rfbClientRec *)NULL)))
  {
    result=rfbUpdateClient(rfbProcessEvents__1__cl);
    clPrev = rfbProcessEvents__1__cl;
    rfbProcessEvents__1__cl=rfbClientIteratorNext(i);
    if(clPrev->sock == -1)
    {
      rfbClientConnectionGone(clPrev);
      result = (signed char)-1;
    }

  }
  rfbReleaseClientIterator(i);
  return result;
}

// rfbProcessFileTransfer
// file rfbserver.c line 1581
extern signed char rfbProcessFileTransfer(struct _rfbClientRec *cl, unsigned char contentType, unsigned char contentParam, unsigned int size, unsigned int length)
{
  char *buffer = (char *)(void *)0;
  char *p = (char *)(void *)0;
  signed int retval = 0;
  char filename1[260l];
  char filename2[260l];
  char szFileTime[260l];
  struct stat statbuf;
  unsigned int sizeHtmp = (unsigned int)0;
  signed int n = 0;
  char timespec[64l];
  unsigned char compBuff[8192l];
  unsigned long int nRawBytes = (unsigned long int)8192;
  signed int nRet = 0;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
  {
    return_value=cl->screen->getFileTransferPermission(cl);
    tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->screen->permitFileTransfer != -1 ? (_Bool)1 : (_Bool)0;
  signed char return_value_rfbSendFileTransferMessage_3;
  signed char return_value_rfbSendDirContent_4;
  signed char return_value_rfbFilenameTranslate2UNIX_5;
  signed char return_value_rfbSendFileTransferMessage_12;
  signed int return_value_rfbWriteExact_13;
  signed char return_value_rfbSendFileTransferChunk_14;
  signed char return_value_rfbFilenameTranslate2UNIX_15;
  char *tmp_if_expr_18;
  signed int *return_value___errno_location_16;
  char *return_value_strerror_17;
  signed char return_value_rfbSendFileTransferMessage_19;
  signed long int return_value_write_20;
  signed long int return_value_write_21;
  signed char return_value_rfbFilenameTranslate2UNIX_27;
  signed char return_value_rfbSendFileTransferMessage_28;
  signed char return_value_rfbFilenameTranslate2UNIX_29;
  signed int return_value_stat_30;
  signed char return_value_rfbSendFileTransferMessage_31;
  if(tmp_if_expr_2)
  {
    rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", (const void *)"", cl->host);
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    switch((signed int)contentType)
    {
      case 1:
        switch((signed int)contentParam)
        {
          case 2:
          {
            filename2[(signed long int)0] = (char)67;
            filename2[(signed long int)1] = (char)58;
            filename2[(signed long int)2] = (char)108;
            filename2[(signed long int)3] = (char)0;
            filename2[(signed long int)4] = (char)0;
            return_value_rfbSendFileTransferMessage_3=rfbSendFileTransferMessage(cl, (unsigned char)2, (unsigned char)3, (unsigned int)0, (unsigned int)5, filename2);
            retval = (signed int)return_value_rfbSendFileTransferMessage_3;
            if(!(buffer == ((char *)NULL)))
              free((void *)buffer);

            return (signed char)retval;
          }
          case 1:
          {
            buffer=rfbProcessFileTransferReadBuffer(cl, length);
            if(buffer == ((char *)NULL))
              return (signed char)0;

            return_value_rfbSendDirContent_4=rfbSendDirContent(cl, (signed int)length, buffer);
            retval = (signed int)return_value_rfbSendDirContent_4;
            if(!(buffer == ((char *)NULL)))
              free((void *)buffer);

            return (signed char)retval;
          }
          default:
            goto __CPROVER_DUMP_L79;
        }
      case 2:
        rfbLog("rfbProcessFileTransfer() rfbDirPacket\n");
      case 9:
        rfbLog("rfbProcessFileTransfer() rfbFileAcceptHeader\n");
      case 11:
        rfbLog("rfbProcessFileTransfer() rfbCommandReturn\n");
      case 12:
        rfbLog("rfbProcessFileTransfer() rfbFileChecksums\n");
      case 14:
        rfbLog("rfbProcessFileTransfer() rfbFileTransferAccess\n");
      case 3:
      {
        buffer=rfbProcessFileTransferReadBuffer(cl, length);
        if(buffer == ((char *)NULL))
          return (signed char)0;

        return_value_rfbFilenameTranslate2UNIX_5=rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(char [260l]) /*260ul*/ );
        if(return_value_rfbFilenameTranslate2UNIX_5 == 0)
          break;

        cl->fileTransfer.fd=open(filename1, 00, 0744);
        if(!(DB == 0))
          rfbLog("rfbProcessFileTransfer() rfbFileTransferRequest(\"%s\"->\"%s\") Open: %s fd=%d\n", buffer, (const void *)filename1, cl->fileTransfer.fd == -1 ? "Failed" : "Success", cl->fileTransfer.fd);

        if(!(cl->fileTransfer.fd == -1))
        {
          signed int return_value_fstat_11;
          return_value_fstat_11=fstat(cl->fileTransfer.fd, &statbuf);
          if(!(return_value_fstat_11 == 0))
          {
            close(cl->fileTransfer.fd);
            cl->fileTransfer.fd = -1;
          }

          else
          {
            struct tm *return_value_gmtime_6;
            return_value_gmtime_6=gmtime(&statbuf.st_ctim.tv_sec);
            strftime(timespec, sizeof(char [64l]) /*64ul*/ , "%m/%d/%Y %H:%M", return_value_gmtime_6);
            unsigned long int return_value_strlen_7;
            return_value_strlen_7=strlen(timespec);
            void *return_value_realloc_8;
            return_value_realloc_8=realloc((void *)buffer, (unsigned long int)length + return_value_strlen_7 + (unsigned long int)2);
            buffer = (char *)return_value_realloc_8;
            if(buffer == ((char *)NULL))
            {
              unsigned long int return_value_strlen_9;
              return_value_strlen_9=strlen(timespec);
              rfbLog("rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\n", (unsigned long int)length + return_value_strlen_9 + (unsigned long int)2);
              return (signed char)0;
            }

            strcat(buffer, ",");
            strcat(buffer, timespec);
            unsigned long int return_value_strlen_10;
            return_value_strlen_10=strlen(buffer);
            length = (unsigned int)return_value_strlen_10;
            if(!(DB == 0))
              rfbLog("rfbProcessFileTransfer() buffer is now: \"%s\"\n", buffer);

          }
        }

        cl->fileTransfer.compressionEnabled = (signed int)(size == (unsigned int)1);
        return_value_rfbSendFileTransferMessage_12=rfbSendFileTransferMessage(cl, (unsigned char)4, (unsigned char)0, (unsigned int)(cl->fileTransfer.fd == -1 ? (signed long int)-1 : statbuf.st_size), length, buffer);
        retval = (signed int)return_value_rfbSendFileTransferMessage_12;
        if(cl->fileTransfer.fd == -1)
        {
          if(!(buffer == ((char *)NULL)))
            free((void *)buffer);

          return (signed char)retval;
        }

        cl->fileTransfer.fileSize = (signed int)statbuf.st_size;
        cl->fileTransfer.numPackets = (signed int)(statbuf.st_size / (signed long int)8192);
        cl->fileTransfer.receiving = 0;
        cl->fileTransfer.sending = 0;
        sizeHtmp = (unsigned int)0;
        pthread_mutex_lock(&cl->sendMutex);
        return_value_rfbWriteExact_13=rfbWriteExact(cl, (char *)&sizeHtmp, 4);
        if(!(return_value_rfbWriteExact_13 >= 0))
        {
          rfbLogPerror("rfbProcessFileTransfer: write");
          rfbCloseClient(cl);
          pthread_mutex_unlock(&cl->sendMutex);
          if(!(buffer == ((char *)NULL)))
            free((void *)buffer);

          return (signed char)0;
        }

        pthread_mutex_unlock(&cl->sendMutex);
        goto __CPROVER_DUMP_L79;
      }
      case 4:
      {
        if(size == 4294967295u)
        {
          rfbLog("rfbProcessFileTransfer() rfbFileHeader (error, aborting)\n");
          close(cl->fileTransfer.fd);
          cl->fileTransfer.fd = -1;
          return (signed char)-1;
        }

        cl->fileTransfer.sending = 1;
        return_value_rfbSendFileTransferChunk_14=rfbSendFileTransferChunk(cl);
        return return_value_rfbSendFileTransferChunk_14;
      }
      case 8:
      {
        buffer=rfbProcessFileTransferReadBuffer(cl, length);
        if(buffer == ((char *)NULL))
          return (signed char)0;

        p=strrchr(buffer, 44);
        if(!(p == ((char *)NULL)))
        {
          *p = (char)0;
          strncpy(szFileTime, p + (signed long int)1, sizeof(char [260l]) /*260ul*/ );
          szFileTime[(signed long int)(sizeof(char [260l]) /*260ul*/  - (unsigned long int)1)] = (char)0;
        }

        else
          szFileTime[(signed long int)0] = (char)0;
        n=rfbReadExact(cl, (char *)&sizeHtmp, 4);
        if(!(n >= 1))
        {
          if(!(n == 0))
            rfbLogPerror("rfbProcessFileTransfer: read sizeHtmp");

          rfbCloseClient(cl);
          if(!(buffer == ((char *)NULL)))
            free((void *)buffer);

          return (signed char)0;
        }

        sizeHtmp = rfbEndianTest != 0 ? sizeHtmp >> 24 | (sizeHtmp & (unsigned int)0x00ff0000) >> 8 | (sizeHtmp & (unsigned int)0x0000ff00) << 8 | sizeHtmp << 24 : sizeHtmp;
        return_value_rfbFilenameTranslate2UNIX_15=rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(char [260l]) /*260ul*/ );
        if(return_value_rfbFilenameTranslate2UNIX_15 == 0)
          break;

        cl->fileTransfer.fd=open(filename1, 0100 | 01 | 01000, 0744);
        if(!(DB == 0))
        {
          if(cl->fileTransfer.fd == -1)
          {
            return_value___errno_location_16=__errno_location();
            return_value_strerror_17=strerror(*return_value___errno_location_16);
            tmp_if_expr_18 = return_value_strerror_17;
          }

          else
            tmp_if_expr_18 = "";
          rfbLog("rfbProcessFileTransfer() rfbFileTransferOffer(\"%s\"->\"%s\") %s %s fd=%d\n", buffer, (const void *)filename1, cl->fileTransfer.fd == -1 ? "Failed" : "Success", tmp_if_expr_18, cl->fileTransfer.fd);
        }

        return_value_rfbSendFileTransferMessage_19=rfbSendFileTransferMessage(cl, (unsigned char)9, (unsigned char)0, (unsigned int)(cl->fileTransfer.fd == -1 ? -1 : 0), length, buffer);
        retval = (signed int)return_value_rfbSendFileTransferMessage_19;
        if(cl->fileTransfer.fd == -1)
        {
          free((void *)buffer);
          return (signed char)retval;
        }

        cl->fileTransfer.fileSize = (signed int)size;
        cl->fileTransfer.numPackets = (signed int)(size / (unsigned int)8192);
        cl->fileTransfer.receiving = 1;
        cl->fileTransfer.sending = 0;
        goto __CPROVER_DUMP_L79;
      }
      case 5:
      {
        buffer=rfbProcessFileTransferReadBuffer(cl, length);
        if(buffer == ((char *)NULL))
          return (signed char)0;

        if(!(cl->fileTransfer.fd == -1))
        {
          if(size == 0u)
          {
            return_value_write_20=write(cl->fileTransfer.fd, (const void *)buffer, (unsigned long int)length);
            retval = (signed int)return_value_write_20;
          }

          else
          {
            nRet=uncompress(compBuff, &nRawBytes, (const unsigned char *)buffer, (unsigned long int)length);
            if(nRet == 0)
            {
              return_value_write_21=write(cl->fileTransfer.fd, (const void *)(char *)compBuff, nRawBytes);
              retval = (signed int)return_value_write_21;
            }

            else
              retval = -1;
          }
          if(retval == -1)
          {
            close(cl->fileTransfer.fd);
            cl->fileTransfer.fd = -1;
            cl->fileTransfer.sending = 0;
            cl->fileTransfer.receiving = 0;
          }

        }

        goto __CPROVER_DUMP_L79;
      }
      case 6:
      {
        if(!(DB == 0))
          rfbLog("rfbProcessFileTransfer() rfbEndOfFile\n");

        if(!(cl->fileTransfer.fd == -1))
          close(cl->fileTransfer.fd);

        cl->fileTransfer.fd = -1;
        cl->fileTransfer.sending = 0;
        cl->fileTransfer.receiving = 0;
        goto __CPROVER_DUMP_L79;
      }
      case 7:
      {
        if(!(DB == 0))
          rfbLog("rfbProcessFileTransfer() rfbAbortFileTransfer\n");

        if(!(cl->fileTransfer.fd == -1))
        {
          close(cl->fileTransfer.fd);
          cl->fileTransfer.fd = -1;
          cl->fileTransfer.sending = 0;
          cl->fileTransfer.receiving = 0;
        }

        else
        {
          if((signed int)contentParam == 0)
          {
            rfbLog("rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\n");
            signed char return_value_rfbSendFileTransferMessage_22;
            return_value_rfbSendFileTransferMessage_22=rfbSendFileTransferMessage(cl, (unsigned char)7, (unsigned char)0, (unsigned int)-1, (unsigned int)0, "");
            return return_value_rfbSendFileTransferMessage_22;
          }

          if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
          {
            signed int return_value_1;
            return_value_1=cl->screen->getFileTransferPermission(cl);
            if(return_value_1 == -1)
            {
              rfbLog("rfbProcessFileTransfer() File Transfer Permission Granted!\n");
              signed char return_value_rfbSendFileTransferMessage_23;
              return_value_rfbSendFileTransferMessage_23=rfbSendFileTransferMessage(cl, (unsigned char)14, (unsigned char)0, (unsigned int)1, (unsigned int)0, "");
              return return_value_rfbSendFileTransferMessage_23;
            }

            else
            {
              rfbLog("rfbProcessFileTransfer() File Transfer Permission DENIED!\n");
              signed char return_value_rfbSendFileTransferMessage_24;
              return_value_rfbSendFileTransferMessage_24=rfbSendFileTransferMessage(cl, (unsigned char)14, (unsigned char)0, (unsigned int)-1, (unsigned int)0, "");
              return return_value_rfbSendFileTransferMessage_24;
            }
          }

          else
            if(!(cl->screen->permitFileTransfer == 0))
            {
              rfbLog("rfbProcessFileTransfer() File Transfer Permission Granted!\n");
              signed char return_value_rfbSendFileTransferMessage_25;
              return_value_rfbSendFileTransferMessage_25=rfbSendFileTransferMessage(cl, (unsigned char)14, (unsigned char)0, (unsigned int)1, (unsigned int)0, "");
              return return_value_rfbSendFileTransferMessage_25;
            }

            else
            {
              rfbLog("rfbProcessFileTransfer() File Transfer Permission DENIED by default!\n");
              signed char return_value_rfbSendFileTransferMessage_26;
              return_value_rfbSendFileTransferMessage_26=rfbSendFileTransferMessage(cl, (unsigned char)14, (unsigned char)0, (unsigned int)-1, (unsigned int)0, "");
              return return_value_rfbSendFileTransferMessage_26;
            }
        }
        goto __CPROVER_DUMP_L79;
      }
      case 10:
      {
        buffer=rfbProcessFileTransferReadBuffer(cl, length);
        if(buffer == ((char *)NULL))
          return (signed char)0;

        switch((signed int)contentParam)
        {
          case 1:
          {
            return_value_rfbFilenameTranslate2UNIX_27=rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(char [260l]) /*260ul*/ );
            if(return_value_rfbFilenameTranslate2UNIX_27 == 0)
              goto fail;

            retval=mkdir(filename1, (unsigned int)0755);
            if(!(DB == 0))
              rfbLog("rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\"%s\"->\"%s\") %s\n", buffer, (const void *)filename1, retval == -1 ? "Failed" : "Success");

            return_value_rfbSendFileTransferMessage_28=rfbSendFileTransferMessage(cl, (unsigned char)11, (unsigned char)4, (unsigned int)retval, length, buffer);
            retval = (signed int)return_value_rfbSendFileTransferMessage_28;
            if(!(buffer == ((char *)NULL)))
              free((void *)buffer);

            return (signed char)retval;
          }
          case 4:
          {
            return_value_rfbFilenameTranslate2UNIX_29=rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(char [260l]) /*260ul*/ );
            if(return_value_rfbFilenameTranslate2UNIX_29 == 0)
              goto fail;

            return_value_stat_30=stat(filename1, &statbuf);
            if(return_value_stat_30 == 0)
            {
              if((61440u & statbuf.st_mode) == 16384u)
                retval=rmdir(filename1);

              else
                retval=unlink(filename1);
            }

            else
              retval = -1;
            return_value_rfbSendFileTransferMessage_31=rfbSendFileTransferMessage(cl, (unsigned char)11, (unsigned char)7, (unsigned int)retval, length, buffer);
            retval = (signed int)return_value_rfbSendFileTransferMessage_31;
            if(!(buffer == ((char *)NULL)))
              free((void *)buffer);

            return (signed char)retval;
          }
          case 5:
          {
            p=strrchr(buffer, 42);
            if(!(p == ((char *)NULL)))
            {
              *p = (char)0;
              signed char return_value_rfbFilenameTranslate2UNIX_32;
              return_value_rfbFilenameTranslate2UNIX_32=rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(char [260l]) /*260ul*/ );
              if(return_value_rfbFilenameTranslate2UNIX_32 == 0)
                goto fail;

              signed char return_value_rfbFilenameTranslate2UNIX_33;
              return_value_rfbFilenameTranslate2UNIX_33=rfbFilenameTranslate2UNIX(cl, p + (signed long int)1, filename2, sizeof(char [260l]) /*260ul*/ );
              if(return_value_rfbFilenameTranslate2UNIX_33 == 0)
                goto fail;

              retval=rename(filename1, filename2);
              if(!(DB == 0))
                rfbLog("rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\"%s\"->\"%s\" -->> \"%s\"->\"%s\") %s\n", buffer, (const void *)filename1, p + (signed long int)1, (const void *)filename2, retval == -1 ? "Failed" : "Success");

              *p = (char)42;
              signed char return_value_rfbSendFileTransferMessage_34;
              return_value_rfbSendFileTransferMessage_34=rfbSendFileTransferMessage(cl, (unsigned char)11, (unsigned char)8, (unsigned int)retval, length, buffer);
              retval = (signed int)return_value_rfbSendFileTransferMessage_34;
              if(!(buffer == ((char *)NULL)))
                free((void *)buffer);

              return (signed char)retval;
            }

          }
          default:
            ;
        }
      }
      default:
      {

      __CPROVER_DUMP_L79:
        ;
        if(!(buffer == ((char *)NULL)))
          free((void *)buffer);

        return (signed char)-1;
      }
    }

  fail:
    ;
    if(!(buffer == ((char *)NULL)))
      free((void *)buffer);

    return (signed char)0;
  }
}

// rfbProcessFileTransferReadBuffer
// file rfbserver.c line 1454
extern char * rfbProcessFileTransferReadBuffer(struct _rfbClientRec *cl, unsigned int length)
{
  char *buffer = (char *)(void *)0;
  signed int n = 0;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
  {
    return_value=cl->screen->getFileTransferPermission(cl);
    tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->screen->permitFileTransfer != -1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", (const void *)"", cl->host);
    rfbCloseClient(cl);
    return (char *)(void *)0;
  }

  else
  {
    if(length >= 1u)
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)(length + (unsigned int)1));
      buffer = (char *)return_value_malloc_3;
      if(!(buffer == ((char *)NULL)))
      {
        n=rfbReadExact(cl, (char *)buffer, (signed int)length);
        if(!(n >= 1))
        {
          if(!(n == 0))
            rfbLogPerror("rfbProcessFileTransferReadBuffer: read");

          rfbCloseClient(cl);
          if(!(buffer == ((char *)NULL)))
            free((void *)buffer);

          return (char *)(void *)0;
        }

        buffer[(signed long int)length] = (char)0;
      }

    }

    return buffer;
  }
}

// rfbProcessNewConnection
// file sockets.c line 405
signed char rfbProcessNewConnection(struct _rfbScreenInfo *rfbScreen)
{
  const signed int one = 1;
  signed int sock = -1;
  struct sockaddr_storage addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct anonymous_16 listen_fds;
  signed int chosen_listen_sock = -1;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&listen_fds)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  if(rfbScreen->listenSock >= 0)
    (&listen_fds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&listen_fds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->listenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

  if(rfbScreen->listen6Sock >= 0)
    (&listen_fds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&listen_fds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << rfbScreen->listen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

  signed int return_value_select_1;
  return_value_select_1=select(rfbScreen->maxFd + 1, &listen_fds, (struct anonymous_16 *)(void *)0, (struct anonymous_16 *)(void *)0, (struct timeval *)(void *)0);
  if(return_value_select_1 == -1)
  {
    rfbLogPerror("rfbProcessNewConnection: error in select");
    return (signed char)0;
  }

  else
  {
    if(rfbScreen->listenSock >= 0)
    {
      if(!((listen_fds.__fds_bits[(signed long int)(rfbScreen->listenSock / 8)] & (signed long int)(1UL << rfbScreen->listenSock % 8)) == 0l))
        chosen_listen_sock = rfbScreen->listenSock;

    }

    if(rfbScreen->listen6Sock >= 0)
    {
      if(!((listen_fds.__fds_bits[(signed long int)(rfbScreen->listen6Sock / 8)] & (signed long int)(1UL << rfbScreen->listen6Sock % 8)) == 0l))
        chosen_listen_sock = rfbScreen->listen6Sock;

    }

    sock=accept(chosen_listen_sock, (struct sockaddr *)&addr, &addrlen);
    if(!(sock >= 0))
    {
      rfbLogPerror("rfbCheckFds: accept");
      return (signed char)0;
    }

    else
    {
      signed char return_value_rfbSetNonBlocking_2;
      return_value_rfbSetNonBlocking_2=rfbSetNonBlocking(sock);
      if(return_value_rfbSetNonBlocking_2 == 0)
      {
        close(sock);
        return (signed char)0;
      }

      else
      {
        signed int return_value_setsockopt_3;
        return_value_setsockopt_3=setsockopt(sock, 6, 1, (const void *)(char *)&one, (unsigned int)sizeof(const signed int) /*4ul*/ );
        if(!(return_value_setsockopt_3 >= 0))
        {
          rfbLogPerror("rfbCheckFds: setsockopt");
          close(sock);
          return (signed char)0;
        }

        else
        {
          char host[1024l];
          signed int return_value_getnameinfo_4;
          return_value_getnameinfo_4=getnameinfo((struct sockaddr *)&addr, addrlen, host, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , (char *)(void *)0, (unsigned int)0, 1);
          if(!(return_value_getnameinfo_4 == 0))
            rfbLogPerror("rfbProcessNewConnection: error in getnameinfo");

          rfbLog("Got connection from client %s\n", (const void *)host);
          rfbNewClient(rfbScreen, sock);
          return (signed char)-1;
        }
      }
    }
  }
}

// rfbProcessSizeArguments
// file cargs.c line 239
extern signed char rfbProcessSizeArguments(signed int *width, signed int *height, signed int *bpp, signed int *argc, char **argv)
{
  signed int i;
  signed int i1;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  if(argc == ((signed int *)NULL))
    return (signed char)-1;

  else
  {
    i1 = 1;
    i = i1;
    while(!(i >= *argc + -1))
    {
      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(argv[(signed long int)i], "-bpp");
      if(return_value_strcmp_3 == 0)
      {
        i = i + 1;
        *bpp=atoi(argv[(signed long int)i]);
      }

      else
      {
        return_value_strcmp_2=strcmp(argv[(signed long int)i], "-width");
        if(return_value_strcmp_2 == 0)
        {
          i = i + 1;
          *width=atoi(argv[(signed long int)i]);
        }

        else
        {
          return_value_strcmp_1=strcmp(argv[(signed long int)i], "-height");
          if(return_value_strcmp_1 == 0)
          {
            i = i + 1;
            *height=atoi(argv[(signed long int)i]);
          }

          else
          {
            i = i + 1;
            i1 = i;
            continue;
          }
        }
      }
      rfbPurgeArguments(argc, &i1, i - i1, argv);
      i = i1;
    }
    return (signed char)-1;
  }
}

// rfbProcessUDPInput
// file rfbserver.c line 3543
extern void rfbProcessUDPInput(struct _rfbScreenInfo *rfbScreen)
{
  signed int n;
  struct _rfbClientRec *rfbProcessUDPInput__1__cl = rfbScreen->udpClient;
  union anonymous_1 msg;
  _Bool tmp_if_expr_1;
  if(rfbProcessUDPInput__1__cl == ((struct _rfbClientRec *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = rfbProcessUDPInput__1__cl->onHold != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    signed long int return_value_read_2;
    return_value_read_2=read(rfbScreen->udpSock, (void *)(char *)&msg, sizeof(union anonymous_1) /*20ul*/ );
    n = (signed int)return_value_read_2;
    if(!(n >= 1))
    {
      if(!(n >= 0))
        rfbLogPerror("rfbProcessUDPInput: read");

      rfbDisconnectUDPSock(rfbScreen);
    }

    else
    {
      switch((signed int)msg.type)
      {
        case 4:
        {
          if(!(n == 8))
          {
            rfbErr("rfbProcessUDPInput: key event incorrect length\n");
            rfbDisconnectUDPSock(rfbScreen);
          }

          rfbProcessUDPInput__1__cl->screen->kbdAddEvent((signed char)msg.ke.down, (unsigned int)(rfbEndianTest != 0 ? msg.ke.key >> 24 | (msg.ke.key & (unsigned int)0x00ff0000) >> 8 | (msg.ke.key & (unsigned int)0x0000ff00) << 8 | msg.ke.key << 24 : msg.ke.key), rfbProcessUDPInput__1__cl);
        }
        case 5:
        {
          if(!(n == 6))
          {
            rfbErr("rfbProcessUDPInput: ptr event incorrect length\n");
            rfbDisconnectUDPSock(rfbScreen);
          }

          rfbProcessUDPInput__1__cl->screen->ptrAddEvent((signed int)msg.pe.buttonMask, rfbEndianTest != 0 ? ((signed int)msg.pe.x & 0xff) << 8 | (signed int)msg.pe.x >> 8 & 0xff : (signed int)msg.pe.x, rfbEndianTest != 0 ? ((signed int)msg.pe.y & 0xff) << 8 | (signed int)msg.pe.y >> 8 & 0xff : (signed int)msg.pe.y, rfbProcessUDPInput__1__cl);
        }
      }
      rfbErr("rfbProcessUDPInput: unknown message type %d\n", msg.type);
      rfbDisconnectUDPSock(rfbScreen);
    }
  }

}

// rfbPurgeArguments
// file cargs.c line 68
extern void rfbPurgeArguments(signed int *argc, signed int *position, signed int count, char **argv)
{
  signed int amount = (*argc - *position) - count;
  if(!(amount == 0))
    memmove((void *)(argv + (signed long int)*position), (const void *)(argv + (signed long int)*position + (signed long int)count), sizeof(char *) /*8ul*/  * (unsigned long int)amount);

  *argc = *argc - count;
}

// rfbRandomBytes
// file ../rfb/rfbproto.h line 1473
extern void rfbRandomBytes(unsigned char *bytes)
{
  signed int i;
  static signed char s_srandom_called = (signed char)0;
  if(s_srandom_called == 0)
  {
    signed long int return_value_time_1;
    return_value_time_1=time((signed long int *)(void *)0);
    signed int return_value_getpid_2;
    return_value_getpid_2=getpid();
    srandom((unsigned int)return_value_time_1 ^ (unsigned int)return_value_getpid_2);
    s_srandom_called = (signed char)-1;
  }

  i = 0;
  for( ; !(i >= 16); i = i + 1)
  {
    signed long int return_value_random_3;
    return_value_random_3=random();
    bytes[(signed long int)i] = (unsigned char)(return_value_random_3 & (signed long int)255);
  }
}

// rfbReadExact
// file ../rfb/rfb.h line 748
extern signed int rfbReadExact(struct _rfbClientRec *cl, char *buf, signed int len)
{
  _Bool tmp_if_expr_3;
  if(!(cl->screen == ((struct _rfbScreenInfo *)NULL)))
    tmp_if_expr_3 = cl->screen->maxClientWait != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  signed int return_value_rfbReadExactTimeout_1;
  signed int return_value_rfbReadExactTimeout_2;
  if(tmp_if_expr_3)
  {
    return_value_rfbReadExactTimeout_1=rfbReadExactTimeout(cl, buf, len, cl->screen->maxClientWait);
    return return_value_rfbReadExactTimeout_1;
  }

  else
  {
    return_value_rfbReadExactTimeout_2=rfbReadExactTimeout(cl, buf, len, rfbMaxClientWait);
    return return_value_rfbReadExactTimeout_2;
  }
}

// rfbReadExactTimeout
// file sockets.c line 570
extern signed int rfbReadExactTimeout(struct _rfbClientRec *cl, char *buf, signed int len, signed int timeout)
{
  signed int sock = cl->sock;
  signed int n;
  struct anonymous_16 fds;
  struct timeval tv;
  signed int *return_value___errno_location_3;
  while(len >= 1)
  {
    if(!(cl->wsctx == ((struct _wsCtx *)NULL)))
      n=webSocketsDecode(cl, buf, len);

    else
      if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
        n=rfbssl_read(cl, buf, len);

      else
      {
        signed long int return_value_read_1;
        return_value_read_1=read(sock, (void *)buf, (unsigned long int)len);
        n = (signed int)return_value_read_1;
      }
    if(n >= 1)
    {
      buf = buf + (signed long int)n;
      len = len - n;
    }

    else
      if(n == 0)
        return 0;

      else
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        if(!(*return_value___errno_location_2 == 4))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          if(!(*return_value___errno_location_4 == 11))
          {
            return_value___errno_location_3=__errno_location();
            if(!(*return_value___errno_location_3 == 11))
              return n;

          }

          if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
          {
            signed int return_value_rfbssl_pending_5;
            return_value_rfbssl_pending_5=rfbssl_pending(cl);
            if(!(return_value_rfbssl_pending_5 == 0))
              continue;

          }

          do
          {
            signed int __d0;
            signed int __d1;
            asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
          }
          while((_Bool)0);
          (&fds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          tv.tv_sec = (signed long int)(timeout / 1000);
          tv.tv_usec = (signed long int)((timeout % 1000) * 1000);
          n=select(sock + 1, &fds, (struct anonymous_16 *)(void *)0, &fds, &tv);
          if(!(n >= 0))
          {
            rfbLogPerror("ReadExact: select");
            return n;
          }

          if(n == 0)
          {
            rfbErr("ReadExact: select timeout\n");
            signed int *return_value___errno_location_6;
            return_value___errno_location_6=__errno_location();
            *return_value___errno_location_6 = 110;
            return -1;
          }

        }

      }
  }
  return 1;
}

// rfbRedrawAfterHideCursor
// file private.h line 8
void rfbRedrawAfterHideCursor(struct _rfbClientRec *cl, struct sraRegion *updateRegion)
{
  struct _rfbScreenInfo *s = cl->screen;
  struct rfbCursor *c = s->cursor;
  if(!(c == ((struct rfbCursor *)NULL)))
  {
    signed int x;
    signed int y;
    signed int x2;
    signed int y2;
    x = cl->cursorX - (signed int)c->xhot;
    y = cl->cursorY - (signed int)c->yhot;
    x2 = x + (signed int)c->width;
    y2 = y + (signed int)c->height;
    signed char return_value_sraClipRect2_1;
    return_value_sraClipRect2_1=sraClipRect2(&x, &y, &x2, &y2, 0, 0, s->width, s->height);
    if(!(return_value_sraClipRect2_1 == 0))
    {
      struct sraRegion *rect;
      rect=sraRgnCreateRect(x, y, x2, y2);
      if(!(updateRegion == ((struct sraRegion *)NULL)))
        sraRgnOr(updateRegion, rect);

      else
      {
        pthread_mutex_lock(&cl->updateMutex);
        sraRgnOr(cl->modifiedRegion, rect);
        pthread_mutex_unlock(&cl->updateMutex);
      }
      sraRgnDestroy(rect);
    }

  }

}

// rfbRefuseOnHoldClient
// file main.c line 624
extern void rfbRefuseOnHoldClient(struct _rfbClientRec *cl)
{
  rfbCloseClient(cl);
  rfbClientConnectionGone(cl);
}

// rfbRegisterProtocolExtension
// file main.c line 69
void rfbRegisterProtocolExtension(struct _rfbProtocolExtension *extension)
{
  struct _rfbProtocolExtension *head = rfbExtensionHead;
  struct _rfbProtocolExtension *next = (struct _rfbProtocolExtension *)(void *)0;
  if(!(extension == ((struct _rfbProtocolExtension *)NULL)))
  {
    next = extension->next;
    if(extMutex_initialized == 0)
    {
      pthread_mutex_init(&extMutex, (const union anonymous_0 *)(void *)0);
      extMutex_initialized = 1;
    }

    pthread_mutex_lock(&extMutex);
    for( ; !(head == ((struct _rfbProtocolExtension *)NULL)); head = head->next)
      if(head == extension)
      {
        pthread_mutex_unlock(&extMutex);
        rfbRegisterProtocolExtension(next);
        goto __CPROVER_DUMP_L6;
      }

    extension->next = rfbExtensionHead;
    rfbExtensionHead = extension;
    pthread_mutex_unlock(&extMutex);
    rfbRegisterProtocolExtension(next);
  }


__CPROVER_DUMP_L6:
  ;
}

// rfbRegisterSecurityHandler
// file auth.c line 49
extern void rfbRegisterSecurityHandler(struct _rfbSecurity *handler)
{
  struct _rfbSecurity *head = securityHandlers;
  struct _rfbSecurity *next = (struct _rfbSecurity *)(void *)0;
  if(!(handler == ((struct _rfbSecurity *)NULL)))
  {
    next = handler->next;
    for( ; !(head == ((struct _rfbSecurity *)NULL)); head = head->next)
      if(head == handler)
      {
        rfbRegisterSecurityHandler(next);
        goto __CPROVER_DUMP_L5;
      }

    handler->next = securityHandlers;
    securityHandlers = handler;
    rfbRegisterSecurityHandler(next);
  }


__CPROVER_DUMP_L5:
  ;
}

// rfbRegisterTightVNCFileTransferExtension
// file tightvnc-filetransfer/rfbtightserver.c line 536
void rfbRegisterTightVNCFileTransferExtension()
{
  rfbRegisterProtocolExtension(&tightVncFileTransferExtension);
  rfbRegisterSecurityHandler(&tightVncSecurityHandler);
}

// rfbReleaseClientIterator
// file ../rfb/rfb.h line 779
extern void rfbReleaseClientIterator(struct rfbClientIterator *iterator)
{
  if(!(iterator->next == ((struct _rfbClientRec *)NULL)))
    rfbDecrClientRef(iterator->next);

  free((void *)iterator);
}

// rfbReleaseExtensionIterator
// file main.c line 157
void rfbReleaseExtensionIterator()
{
  pthread_mutex_unlock(&extMutex);
}

// rfbResetStats
// file ../rfb/rfb.h line 942
extern void rfbResetStats(struct _rfbClientRec *cl)
{
  struct _rfbStatList *ptr;
  if(!(cl == ((struct _rfbClientRec *)NULL)))
  {
    while(!(cl->statEncList == ((struct _rfbStatList *)NULL)))
    {
      ptr = cl->statEncList;
      cl->statEncList = ptr->Next;
      free((void *)ptr);
    }
    while(!(cl->statMsgList == ((struct _rfbStatList *)NULL)))
    {
      ptr = cl->statMsgList;
      cl->statMsgList = ptr->Next;
      free((void *)ptr);
    }
  }

}

// rfbReverseConnection
// file rfbserver.c line 261
extern struct _rfbClientRec * rfbReverseConnection(struct _rfbScreenInfo *rfbScreen, char *host, signed int port)
{
  signed int sock;
  struct _rfbClientRec *rfbReverseConnection__1__cl;
  sock=rfbConnect(rfbScreen, host, port);
  if(!(sock >= 0))
    return (struct _rfbClientRec *)(void *)0;

  else
  {
    rfbReverseConnection__1__cl=rfbNewClient(rfbScreen, sock);
    if(!(rfbReverseConnection__1__cl == ((struct _rfbClientRec *)NULL)))
      rfbReverseConnection__1__cl->reverseConnection = (signed char)-1;

    return rfbReverseConnection__1__cl;
  }
}

// rfbRunEventLoop
// file main.c line 1179
extern void rfbRunEventLoop(struct _rfbScreenInfo *screen, signed long int usec, signed char runInBackground)
{
  if(!(runInBackground == 0))
  {
    unsigned long int listener_thread;
    screen->backgroundLoop = (signed char)-1;
    pthread_create(&listener_thread, (const union pthread_attr_t *)(void *)0, listenerRun, (void *)screen);
    goto __CPROVER_DUMP_L4;
  }

  if(!(usec >= 0l))
    usec = (signed long int)(screen->deferUpdateTime * 1000);

  signed char return_value_rfbIsActive_1;
  do
  {
    return_value_rfbIsActive_1=rfbIsActive(screen);
    if(return_value_rfbIsActive_1 == 0)
      break;

    rfbProcessEvents(screen, usec);
  }
  while((_Bool)1);

__CPROVER_DUMP_L4:
  ;
}

// rfbScaledCorrection
// file ./scale.h line 4
void rfbScaledCorrection(struct _rfbScreenInfo *from, struct _rfbScreenInfo *to, signed int *x, signed int *y, signed int *w, signed int *h, const char *function)
{
  double x1;
  double y1;
  double w1;
  double h1;
  double x2;
  double y2;
  double w2;
  double h2;
  double scaleW = (double)to->width / (double)from->width;
  double scaleH = (double)to->height / (double)from->height;
  if(!(from == to))
  {
    x1 = (double)*x * scaleW;
    y1 = (double)*y * scaleH;
    w1 = (double)*w * scaleW;
    h1 = (double)*h * scaleH;
    x2 = (double)(signed int)x1;
    y2 = (double)(signed int)y1;
    w2 = IEEE_FLOAT_EQUAL((double)(signed int)(w1 + (x1 - x2)), w1 + (x1 - x2)) ? (double)(signed int)(w1 + (x1 - x2)) : (double)((signed int)(w1 + (x1 - x2)) + 1);
    h2 = IEEE_FLOAT_EQUAL((double)(signed int)(h1 + (y1 - y2)), h1 + (y1 - y2)) ? (double)(signed int)(h1 + (y1 - y2)) : (double)((signed int)(h1 + (y1 - y2)) + 1);
    *x = (signed int)x2;
    *y = (signed int)y2;
    *w = (signed int)w2;
    *h = (signed int)h2;
    if(*w == 0)
      *w = *w + 1;

    if(*h == 0)
      *h = *h + 1;

    if(!(to->width >= *w + *x))
      *w = to->width - *x;

    if(!(to->height >= *h + *y))
      *h = to->height - *y;

  }

}

// rfbScaledScreenAllocate
// file scale.c line 284
struct _rfbScreenInfo * rfbScaledScreenAllocate(struct _rfbClientRec *cl, signed int width, signed int height)
{
  struct _rfbScreenInfo *ptr;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _rfbScreenInfo) /*928ul*/ );
  ptr = (struct _rfbScreenInfo *)return_value_malloc_1;
  if(!(ptr == ((struct _rfbScreenInfo *)NULL)))
  {
    signed int allocSize;
    memcpy((void *)ptr, (const void *)cl->screen, sizeof(struct _rfbScreenInfo) /*928ul*/ );
    allocSize=pad4(width * (ptr->bitsPerPixel / 8));
    if(height == 0 || (unsigned long int)allocSize >= 18446744073709551615UL / (unsigned long int)height)
    {
      free((void *)ptr);
      return (struct _rfbScreenInfo *)(void *)0;
    }

    ptr->width = width;
    ptr->height = height;
    ptr->paddedWidthInBytes = (ptr->bitsPerPixel / 8) * ptr->width;
    ptr->paddedWidthInBytes=pad4(ptr->paddedWidthInBytes);
    ptr->scaledScreenRefCount = 0;
    ptr->sizeInBytes = ptr->paddedWidthInBytes * ptr->height;
    ptr->serverFormat = cl->screen->serverFormat;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)ptr->sizeInBytes);
    ptr->frameBuffer = (char *)return_value_malloc_2;
    if(!(ptr->frameBuffer == ((char *)NULL)))
    {
      rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);
      pthread_mutex_lock(&cl->updateMutex);
      ptr->scaledScreenNext = cl->screen->scaledScreenNext;
      cl->screen->scaledScreenNext = ptr;
      pthread_mutex_unlock(&cl->updateMutex);
    }

    else
    {
      free((void *)ptr);
      ptr = (struct _rfbScreenInfo *)(void *)0;
    }
  }

  return ptr;
}

// rfbScaledScreenUpdate
// file main.c line 415
void rfbScaledScreenUpdate(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2)
{
  struct _rfbScreenInfo *ptr;
  signed int count = 0;
  ptr = screen->scaledScreenNext;
  for( ; !(ptr == ((struct _rfbScreenInfo *)NULL)); ptr = ptr->scaledScreenNext)
    if(ptr->scaledScreenRefCount >= 1)
    {
      rfbScaledScreenUpdateRect(screen, ptr, x1, y1, x2 - x1, y2 - y1);
      count = count + 1;
    }

}

// rfbScaledScreenUpdateRect
// file scale.c line 140
void rfbScaledScreenUpdateRect(struct _rfbScreenInfo *screen, struct _rfbScreenInfo *ptr, signed int x0, signed int y0, signed int w0, signed int h0)
{
  signed int x;
  signed int y;
  signed int w;
  signed int v;
  signed int z;
  signed int x1;
  signed int y1;
  signed int w1;
  signed int h1;
  signed int bitsPerPixel;
  signed int bytesPerPixel;
  signed int bytesPerLine;
  signed int areaX;
  signed int areaY;
  signed int area2;
  unsigned char *srcptr;
  unsigned char *dstptr;
  if(!(screen == ptr))
  {
    x1 = x0;
    y1 = y0;
    w1 = w0;
    h1 = h0;
    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, "rfbScaledScreenUpdateRect");
    x0=ScaleX(ptr, screen, x1);
    y0=ScaleY(ptr, screen, y1);
    w0=ScaleX(ptr, screen, w1);
    h0=ScaleY(ptr, screen, h1);
    bitsPerPixel = screen->bitsPerPixel;
    bytesPerPixel = bitsPerPixel / 8;
    bytesPerLine = w1 * bytesPerPixel;
    srcptr = (unsigned char *)(screen->frameBuffer + (signed long int)(y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));
    dstptr = (unsigned char *)(ptr->frameBuffer + (signed long int)(y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));
    areaX=ScaleX(ptr, screen, 1);
    areaY=ScaleY(ptr, screen, 1);
    area2 = areaX * areaY;
    if(!(ptr->width >= w1 + x1))
    {
      if(x1 == 0)
        w1 = ptr->width;

      else
        x1 = ptr->width - w1;
    }

    if(!(ptr->height >= h1 + y1))
    {
      if(y1 == 0)
        h1 = ptr->height;

      else
        y1 = ptr->height - h1;
    }

    if(!(screen->serverFormat.trueColour == 0))
    {
      unsigned char *srcptr2;
      unsigned long int pixel_value;
      unsigned long int red;
      unsigned long int green;
      unsigned long int blue;
      unsigned int redShift = (unsigned int)screen->serverFormat.redShift;
      unsigned int greenShift = (unsigned int)screen->serverFormat.greenShift;
      unsigned int blueShift = (unsigned int)screen->serverFormat.blueShift;
      unsigned long int redMax = (unsigned long int)screen->serverFormat.redMax;
      unsigned long int greenMax = (unsigned long int)screen->serverFormat.greenMax;
      unsigned long int blueMax = (unsigned long int)screen->serverFormat.blueMax;
      y = 0;
      for( ; !(y >= h1); y = y + 1)
      {
        x = 0;
        for( ; !(x >= w1); x = x + 1)
        {
          blue = (unsigned long int)0;
          green = blue;
          red = green;
          w = 0;
          for( ; !(w >= areaX); w = w + 1)
          {
            v = 0;
            for( ; !(v >= areaY); v = v + 1)
            {
              srcptr2 = &srcptr[(signed long int)((x * areaX + w) * bytesPerPixel + v * screen->paddedWidthInBytes)];
              pixel_value = (unsigned long int)0;
              switch(bytesPerPixel)
              {
                case 4:
                {
                  pixel_value = (unsigned long int)*((unsigned int *)srcptr2);
                  break;
                }
                case 2:
                {
                  pixel_value = (unsigned long int)*((unsigned short int *)srcptr2);
                  break;
                }
                case 1:
                {
                  pixel_value = (unsigned long int)*((unsigned char *)srcptr2);
                  break;
                }
                default:
                {
                  z = 0;
                  for( ; !(z >= bytesPerPixel); z = z + 1)
                    pixel_value = pixel_value + (unsigned long int)((signed int)srcptr2[(signed long int)z] << 8 * z);
                }
              }
              red = red + (pixel_value >> redShift & redMax);
              green = green + (pixel_value >> greenShift & greenMax);
              blue = blue + (pixel_value >> blueShift & blueMax);
            }
          }
          red = red / (unsigned long int)area2;
          green = green / (unsigned long int)area2;
          blue = blue / (unsigned long int)area2;
          pixel_value = (red & redMax) << redShift | (green & greenMax) << greenShift | (blue & blueMax) << blueShift;
          switch(bytesPerPixel)
          {
            case 4:
            {
              *((unsigned int *)dstptr) = (unsigned int)pixel_value;
              break;
            }
            case 2:
            {
              *((unsigned short int *)dstptr) = (unsigned short int)pixel_value;
              break;
            }
            case 1:
            {
              *((unsigned char *)dstptr) = (unsigned char)pixel_value;
              break;
            }
            default:
            {
              z = 0;
              for( ; !(z >= bytesPerPixel); z = z + 1)
                dstptr[(signed long int)z] = (unsigned char)(pixel_value >> 8 * z & (unsigned long int)0xff);
            }
          }
          dstptr = dstptr + (signed long int)bytesPerPixel;
        }
        srcptr = srcptr + (signed long int)(screen->paddedWidthInBytes * areaY);
        dstptr = dstptr + (signed long int)(ptr->paddedWidthInBytes - bytesPerLine);
      }
    }

    else
    {
      y = y1;
      for( ; !(y >= h1 + y1); y = y + 1)
      {
        x = x1;
        for( ; !(x >= w1 + x1); x = x + 1)
          memcpy((void *)&ptr->frameBuffer[(signed long int)(y * ptr->paddedWidthInBytes + x * bytesPerPixel)], (const void *)&screen->frameBuffer[(signed long int)(y * areaY * screen->paddedWidthInBytes + x * areaX * bytesPerPixel)], (unsigned long int)bytesPerPixel);
      }
    }
  }

}

// rfbScalingFind
// file scale.c line 345
struct _rfbScreenInfo * rfbScalingFind(struct _rfbClientRec *cl, signed int width, signed int height)
{
  struct _rfbScreenInfo *ptr = cl->screen;
  for( ; !(ptr == ((struct _rfbScreenInfo *)NULL)); ptr = ptr->scaledScreenNext)
    if(ptr->width == width)
    {
      if(ptr->height == height)
        return ptr;

    }

  return (struct _rfbScreenInfo *)(void *)0;
}

// rfbScalingSetup
// file ./scale.h line 9
void rfbScalingSetup(struct _rfbClientRec *cl, signed int width, signed int height)
{
  struct _rfbScreenInfo *ptr;
  ptr=rfbScalingFind(cl, width, height);
  if(ptr == ((struct _rfbScreenInfo *)NULL))
    ptr=rfbScaledScreenAllocate(cl, width, height);

  if(!(ptr == ((struct _rfbScreenInfo *)NULL)))
  {
    if(!(ptr->scaledScreenRefCount >= 1))
      rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);

    pthread_mutex_lock(&cl->updateMutex);
    cl->scaledScreen->scaledScreenRefCount = cl->scaledScreen->scaledScreenRefCount - 1;
    ptr->scaledScreenRefCount = ptr->scaledScreenRefCount + 1;
    cl->scaledScreen = ptr;
    cl->newFBSizePending = (signed char)-1;
    pthread_mutex_unlock(&cl->updateMutex);
    rfbLog("Scaling to %dx%d (refcount=%d)\n", width, height, ptr->scaledScreenRefCount);
  }

  else
    rfbLog("Scaling to %dx%d failed, leaving things alone\n", width, height);
}

// rfbScheduleCopyRect
// file main.c line 392
void rfbScheduleCopyRect(struct _rfbScreenInfo *screen, signed int x1, signed int y1, signed int x2, signed int y2, signed int dx, signed int dy)
{
  struct sraRegion *region;
  region=sraRgnCreateRect(x1, y1, x2, y2);
  rfbScheduleCopyRegion(screen, region, dx, dy);
  sraRgnDestroy(region);
}

// rfbScheduleCopyRegion
// file main.c line 267
void rfbScheduleCopyRegion(struct _rfbScreenInfo *rfbScreen, struct sraRegion *copyRegion, signed int dx, signed int dy)
{
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *rfbScheduleCopyRegion__1__cl;
  iterator=rfbGetClientIterator(rfbScreen);
  _Bool tmp_if_expr_1;
  do
  {
    rfbScheduleCopyRegion__1__cl=rfbClientIteratorNext(iterator);
    if(rfbScheduleCopyRegion__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    pthread_mutex_lock(&rfbScheduleCopyRegion__1__cl->updateMutex);
    if(!(rfbScheduleCopyRegion__1__cl->useCopyRect == 0))
    {
      struct sraRegion *modifiedRegionBackup;
      signed char return_value_sraRgnEmpty_2;
      return_value_sraRgnEmpty_2=sraRgnEmpty(rfbScheduleCopyRegion__1__cl->copyRegion);
      if(return_value_sraRgnEmpty_2 == 0)
      {
        if(!(rfbScheduleCopyRegion__1__cl->copyDX == dx))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = rfbScheduleCopyRegion__1__cl->copyDY != dy ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          sraRgnOr(rfbScheduleCopyRegion__1__cl->modifiedRegion, rfbScheduleCopyRegion__1__cl->copyRegion);
          sraRgnMakeEmpty(rfbScheduleCopyRegion__1__cl->copyRegion);
        }

        else
        {
          modifiedRegionBackup=sraRgnCreateRgn(copyRegion);
          sraRgnOffset(modifiedRegionBackup, -dx, -dy);
          sraRgnAnd(modifiedRegionBackup, rfbScheduleCopyRegion__1__cl->copyRegion);
          sraRgnOr(rfbScheduleCopyRegion__1__cl->modifiedRegion, modifiedRegionBackup);
          sraRgnDestroy(modifiedRegionBackup);
        }
      }

      sraRgnOr(rfbScheduleCopyRegion__1__cl->copyRegion, copyRegion);
      rfbScheduleCopyRegion__1__cl->copyDX = dx;
      rfbScheduleCopyRegion__1__cl->copyDY = dy;
      modifiedRegionBackup=sraRgnCreateRgn(rfbScheduleCopyRegion__1__cl->modifiedRegion);
      sraRgnOffset(modifiedRegionBackup, dx, dy);
      sraRgnAnd(modifiedRegionBackup, rfbScheduleCopyRegion__1__cl->copyRegion);
      sraRgnOr(rfbScheduleCopyRegion__1__cl->modifiedRegion, modifiedRegionBackup);
      sraRgnDestroy(modifiedRegionBackup);
      if(rfbScheduleCopyRegion__1__cl->enableCursorShapeUpdates == 0)
      {
        struct sraRegion *cursorRegion;
        signed int x = rfbScheduleCopyRegion__1__cl->cursorX - (signed int)rfbScheduleCopyRegion__1__cl->screen->cursor->xhot;
        signed int y = rfbScheduleCopyRegion__1__cl->cursorY - (signed int)rfbScheduleCopyRegion__1__cl->screen->cursor->yhot;
        signed int w = (signed int)rfbScheduleCopyRegion__1__cl->screen->cursor->width;
        signed int h = (signed int)rfbScheduleCopyRegion__1__cl->screen->cursor->height;
        cursorRegion=sraRgnCreateRect(x, y, x + w, y + h);
        sraRgnAnd(cursorRegion, rfbScheduleCopyRegion__1__cl->copyRegion);
        signed char return_value_sraRgnEmpty_3;
        return_value_sraRgnEmpty_3=sraRgnEmpty(cursorRegion);
        if(return_value_sraRgnEmpty_3 == 0)
          sraRgnOr(rfbScheduleCopyRegion__1__cl->modifiedRegion, cursorRegion);

        sraRgnDestroy(cursorRegion);
        cursorRegion=sraRgnCreateRect(x, y, x + w, y + h);
        sraRgnOffset(cursorRegion, dx, dy);
        sraRgnAnd(cursorRegion, rfbScheduleCopyRegion__1__cl->copyRegion);
        signed char return_value_sraRgnEmpty_4;
        return_value_sraRgnEmpty_4=sraRgnEmpty(cursorRegion);
        if(return_value_sraRgnEmpty_4 == 0)
          sraRgnOr(rfbScheduleCopyRegion__1__cl->modifiedRegion, cursorRegion);

        sraRgnDestroy(cursorRegion);
      }

    }

    else
      sraRgnOr(rfbScheduleCopyRegion__1__cl->modifiedRegion, copyRegion);
    pthread_cond_signal(&rfbScheduleCopyRegion__1__cl->updateCond);
    pthread_mutex_unlock(&rfbScheduleCopyRegion__1__cl->updateMutex);
  }
  while((_Bool)1);
  rfbReleaseClientIterator(iterator);
}

// rfbScreenCleanup
// file main.c line 1008
extern void rfbScreenCleanup(struct _rfbScreenInfo *screen)
{
  struct rfbClientIterator *i;
  i=rfbGetClientIterator(screen);
  struct _rfbClientRec *rfbScreenCleanup__1__cl;
  struct _rfbClientRec *cl1;
  cl1=rfbClientIteratorNext(i);
  for( ; !(cl1 == ((struct _rfbClientRec *)NULL)); cl1 = rfbScreenCleanup__1__cl)
  {
    rfbScreenCleanup__1__cl=rfbClientIteratorNext(i);
    rfbClientConnectionGone(cl1);
  }
  rfbReleaseClientIterator(i);
  if(!(screen->colourMap.data.bytes == ((unsigned char *)NULL)))
    free((void *)screen->colourMap.data.bytes);

  if(!(screen->underCursorBuffer == ((char *)NULL)))
    free((void *)screen->underCursorBuffer);

  pthread_mutex_destroy(&screen->cursorMutex);
  if(!(screen->cursor == ((struct rfbCursor *)NULL)))
  {
    if(!(screen->cursor->cleanup == 0))
      rfbFreeCursor(screen->cursor);

  }

  rfbZlibCleanup(screen);
  rfbTightCleanup(screen);
  while(!(screen->scaledScreenNext == ((struct _rfbScreenInfo *)NULL)))
  {
    struct _rfbScreenInfo *ptr = screen->scaledScreenNext;
    screen->scaledScreenNext = ptr->scaledScreenNext;
    free((void *)ptr->frameBuffer);
    free((void *)ptr);
  }
  free((void *)screen);
}

// rfbSelectBox
// file selbox.c line 203
extern signed int rfbSelectBox(struct _rfbScreenInfo *rfbScreen, struct rfbFontData *font, char **list, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int colour, unsigned int backColour, signed int border, void (*selChangedHook)(signed int))
{
  signed int bpp = rfbScreen->bitsPerPixel / 8;
  char *frameBufferBackup;
  void *screenDataBackup = rfbScreen->screenData;
  void (*kbdAddEventBackup)(signed char, unsigned int, struct _rfbClientRec *) = rfbScreen->kbdAddEvent;
  void (*ptrAddEventBackup)(signed int, signed int, signed int, struct _rfbClientRec *) = rfbScreen->ptrAddEvent;
  struct rfbCursor * (*getCursorPtrBackup)(struct _rfbClientRec *) = rfbScreen->getCursorPtr;
  void (*displayHookBackup)(struct _rfbClientRec *) = rfbScreen->displayHook;
  struct anonymous_49 selData;
  signed int i;
  signed int rfbSelectBox__1__j;
  signed int k;
  signed int fx1;
  signed int fy1;
  signed int fx2;
  signed int fy2;
  _Bool tmp_if_expr_1;
  if(list == ((char **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *list == ((char *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    rfbWholeFontBBox(font, &fx1, &fy1, &fx2, &fy2);
    selData.textH = fy2 - fy1;
    if(!(y2 + -y1 >= 2 * selData.textH + 3 * border))
      return -1;

    else
    {
      selData.xhot = -fx1;
      selData.yhot = -fy2;
      selData.x1 = x1 + border;
      selData.y1 = y1 + border;
      selData.y2 = (y2 - selData.textH) - 3 * border;
      selData.x2 = x2 - 2 * border;
      selData.pageH = (selData.y2 - selData.y1) / selData.textH;
      i=rfbWidthOfString(font, okStr);
      rfbSelectBox__1__j=rfbWidthOfString(font, cancelStr);
      k = 4 * border + (i < rfbSelectBox__1__j ? rfbSelectBox__1__j : i);
      selData.buttonWidth = k;
      selData.okBX = x1 + ((x2 - x1) - 2 * k) / 3;
      if(!(selData.okBX >= border + x1))
        return -1;

      else
      {
        selData.cancelBX = x1 + k + (((x2 - x1) - 2 * k) * 2) / 3;
        selData.okX = selData.okBX + (k - i) / 2;
        selData.cancelX = selData.cancelBX + (k - rfbSelectBox__1__j) / 2;
        selData.okY = y2 - border;
        void *return_value_malloc_2;
        return_value_malloc_2=malloc((unsigned long int)(bpp * (x2 - x1) * (y2 - y1)));
        frameBufferBackup = (char *)return_value_malloc_2;
        selData.state = (enum anonymous_48)SELECTING;
        selData.screen = rfbScreen;
        selData.font = font;
        selData.list = list;
        selData.colour = colour;
        selData.backColour = backColour;
        i = 0;
        for( ; !(list[(signed long int)i] == ((char *)NULL)); i = i + 1)
          ;
        selData.selected = i;
        selData.listSize = i;
        selData.displayStart = i;
        selData.lastButtons = 0;
        selData.selChangedHook = selChangedHook;
        rfbScreen->screenData = (void *)&selData;
        rfbScreen->kbdAddEvent = selKbdAddEvent;
        rfbScreen->ptrAddEvent = selPtrAddEvent;
        rfbScreen->getCursorPtr = selGetCursorPtr;
        rfbScreen->displayHook = (void (*)(struct _rfbClientRec *))(void *)0;
        rfbSelectBox__1__j = 0;
        for( ; !(rfbSelectBox__1__j >= y2 + -y1); rfbSelectBox__1__j = rfbSelectBox__1__j + 1)
          memcpy((void *)(frameBufferBackup + (signed long int)(rfbSelectBox__1__j * (x2 - x1) * bpp)), (const void *)(rfbScreen->frameBuffer + (signed long int)(rfbSelectBox__1__j * rfbScreen->paddedWidthInBytes) + (signed long int)(x1 * bpp)), (unsigned long int)((x2 - x1) * bpp));
        rfbFillRect(rfbScreen, x1, y1, x2, y2, colour);
        selPaintButtons(&selData, (signed char)0, (signed char)0);
        selSelect(&selData, 0);
        while((signed int)selData.state == SELECTING)
          rfbProcessEvents(rfbScreen, (signed long int)20000);
        rfbSelectBox__1__j = 0;
        for( ; !(rfbSelectBox__1__j >= y2 + -y1); rfbSelectBox__1__j = rfbSelectBox__1__j + 1)
          memcpy((void *)(rfbScreen->frameBuffer + (signed long int)(rfbSelectBox__1__j * rfbScreen->paddedWidthInBytes) + (signed long int)(x1 * bpp)), (const void *)(frameBufferBackup + (signed long int)(rfbSelectBox__1__j * (x2 - x1) * bpp)), (unsigned long int)((x2 - x1) * bpp));
        free((void *)frameBufferBackup);
        rfbMarkRectAsModified(rfbScreen, x1, y1, x2, y2);
        rfbScreen->screenData = screenDataBackup;
        rfbScreen->kbdAddEvent = kbdAddEventBackup;
        rfbScreen->ptrAddEvent = ptrAddEventBackup;
        rfbScreen->getCursorPtr = getCursorPtrBackup;
        rfbScreen->displayHook = displayHookBackup;
        if((signed int)selData.state == CANCEL)
          selData.selected = -1;

        return selData.selected;
      }
    }
  }
}

// rfbSendAuthCaps
// file tightvnc-filetransfer/rfbtightserver.c line 181
static void rfbSendAuthCaps(struct _rfbClientRec *cl)
{
  struct _rfbAuthenticationCapsMsg caps;
  struct _rfbCapabilityInfo caplist[16l];
  signed int count = 0;
  struct _rfbTightClientRec *rtcp;
  rtcp=rfbGetTightClientData(cl);
  rfbLog("tightvnc-filetransfer/rfbSendAuthCaps\n");
  signed int tmp_post_1;
  if(!(rtcp == ((struct _rfbTightClientRec *)NULL)))
  {
    if(!(cl->screen->authPasswdData == NULL))
    {
      if(cl->reverseConnection == 0)
      {
        struct _rfbCapabilityInfo *pcap = &caplist[(signed long int)count];
        pcap->code = (unsigned int)(rfbEndianTest != 0 ? 2 >> 24 | (2 & 0x00ff0000) >> 8 | (2 & 0x0000ff00) << 8 | 2 << 24 : 2);
        memcpy((void *)pcap->vendorSignature, (const void *)"STDV", (unsigned long int)4);
        memcpy((void *)pcap->nameSignature, (const void *)"VNCAUTH_", (unsigned long int)8);
        tmp_post_1 = count;
        count = count + 1;
        rtcp->authCaps[(signed long int)tmp_post_1] = (unsigned int)2;
      }

    }

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = rfbEndianTest != 0 ? (unsigned int)count >> 24 | ((unsigned int)count & (unsigned int)0x00ff0000) >> 8 | ((unsigned int)count & (unsigned int)0x0000ff00) << 8 | (unsigned int)count << 24 : (unsigned int)count;
    signed int return_value_rfbWriteExact_2;
    return_value_rfbWriteExact_2=rfbWriteExact(cl, (char *)&caps, 4);
    if(!(return_value_rfbWriteExact_2 >= 0))
    {
      rfbLogPerror("rfbSendAuthCaps: write");
      rfbCloseClient(cl);
    }

    else
      if(!(count == 0))
      {
        signed int return_value_rfbWriteExact_3;
        return_value_rfbWriteExact_3=rfbWriteExact(cl, (char *)&caplist[(signed long int)0], count * 16);
        if(!(return_value_rfbWriteExact_3 >= 0))
        {
          rfbLogPerror("rfbSendAuthCaps: write");
          rfbCloseClient(cl);
        }

        rfbProcessClientAuthType(cl);
      }

      else
      {
        if(cl->protocolMajorVersion == 3)
        {
          if(cl->protocolMinorVersion >= 8)
          {
            unsigned int authResult;
            rfbLog("rfbProcessClientSecurityType: returning securityResult for client rfb version >= 3.8\n");
            authResult = (unsigned int)(rfbEndianTest != 0 ? 0 >> 24 | (0 & 0x00ff0000) >> 8 | (0 & 0x0000ff00) << 8 | 0 << 24 : 0);
            signed int return_value_rfbWriteExact_4;
            return_value_rfbWriteExact_4=rfbWriteExact(cl, (char *)&authResult, 4);
            if(!(return_value_rfbWriteExact_4 >= 0))
            {
              rfbLogPerror("rfbAuthProcessClientMessage: write");
              rfbCloseClient(cl);
            }

          }

        }

        cl->state = (enum anonymous_13)RFB_INITIALISATION;
      }
  }

}

// rfbSendBell
// file rfbserver.c line 3462
extern void rfbSendBell(struct _rfbScreenInfo *rfbScreen)
{
  struct rfbClientIterator *i;
  struct _rfbClientRec *rfbSendBell__1__cl;
  struct anonymous_56 b;
  i=rfbGetClientIterator(rfbScreen);
  do
  {
    rfbSendBell__1__cl=rfbClientIteratorNext(i);
    if(rfbSendBell__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    b.type = (unsigned char)2;
    pthread_mutex_lock(&rfbSendBell__1__cl->sendMutex);
    signed int return_value_rfbWriteExact_1;
    return_value_rfbWriteExact_1=rfbWriteExact(rfbSendBell__1__cl, (char *)&b, 1);
    if(!(return_value_rfbWriteExact_1 >= 0))
    {
      rfbLogPerror("rfbSendBell: write");
      rfbCloseClient(rfbSendBell__1__cl);
    }

    pthread_mutex_unlock(&rfbSendBell__1__cl->sendMutex);
  }
  while((_Bool)1);
  rfbStatRecordMessageSent(rfbSendBell__1__cl, (unsigned int)2, 1, 1);
  rfbReleaseClientIterator(i);
}

// rfbSendCopyRegion
// file rfbserver.c line 3179
extern signed char rfbSendCopyRegion(struct _rfbClientRec *cl, struct sraRegion *reg, signed int dx, signed int dy)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  struct anonymous_2 rect;
  struct anonymous_4 cr;
  struct sraRectangleIterator *i;
  struct _rect rect1;
  i=sraRgnGetReverseIterator(reg, (signed char)(dx > 0), (signed char)(dy > 0));
  dx=ScaleX(cl->screen, cl->scaledScreen, dx);
  dy=ScaleX(cl->screen, cl->scaledScreen, dy);
  signed char return_value_sraRgnIteratorNext_1;
  do
  {
    return_value_sraRgnIteratorNext_1=sraRgnIteratorNext(i, &rect1);
    if(return_value_sraRgnIteratorNext_1 == 0)
      break;

    x = rect1.x1;
    y = rect1.y1;
    w = rect1.x2 - x;
    h = rect1.y2 - y;
    rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "copyrect");
    rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
    rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
    rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
    rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
    rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 1 >> 24 | (1 & 0x00ff0000) >> 8 | (1 & 0x0000ff00) << 8 | 1 << 24 : 1);
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
    cl->ublen = cl->ublen + 8 + 4;
    cr.srcX = (unsigned short int)(rfbEndianTest != 0 ? (x - dx & 0xff) << 8 | x - dx >> 8 & 0xff : x - dx);
    cr.srcY = (unsigned short int)(rfbEndianTest != 0 ? (y - dy & 0xff) << 8 | y - dy >> 8 & 0xff : y - dy);
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&cr, (unsigned long int)4);
    cl->ublen = cl->ublen + 4;
    rfbStatRecordEncodingSent(cl, (unsigned int)1, 8 + 4 + 4, w * h * (cl->scaledScreen->bitsPerPixel / 8));
  }
  while((_Bool)1);
  sraRgnReleaseIterator(i);
  return (signed char)-1;
}

// rfbSendCursorPos
// file ../rfb/rfb.h line 922
extern signed char rfbSendCursorPos(struct _rfbClientRec *cl)
{
  struct anonymous_2 rect;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.encoding = rfbEndianTest != 0 ? 0xFFFFFF18 >> 24 | (0xFFFFFF18 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF18 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF18 << 24 : 0xFFFFFF18;
  signed int tmp_if_expr_2;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_2 = (cl->screen->cursorX & 0xff) << 8 | cl->screen->cursorX >> 8 & 0xff;

  else
    tmp_if_expr_2 = cl->screen->cursorX;
  rect.r.x = (unsigned short int)tmp_if_expr_2;
  signed int tmp_if_expr_3;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_3 = (cl->screen->cursorY & 0xff) << 8 | cl->screen->cursorY >> 8 & 0xff;

  else
    tmp_if_expr_3 = cl->screen->cursorY;
  rect.r.y = (unsigned short int)tmp_if_expr_3;
  rect.r.w = (unsigned short int)0;
  rect.r.h = (unsigned short int)0;
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, 0xFFFFFF18, 8 + 4, 8 + 4);
  signed char return_value_rfbSendUpdateBuf_4;
  return_value_rfbSendUpdateBuf_4=rfbSendUpdateBuf(cl);
  if(return_value_rfbSendUpdateBuf_4 == 0)
    return (signed char)0;

  else
    return (signed char)-1;
}

// rfbSendCursorShape
// file ../rfb/rfb.h line 921
extern signed char rfbSendCursorShape(struct _rfbClientRec *cl)
{
  struct rfbCursor *pCursor;
  struct anonymous_2 rect;
  struct anonymous_43 colors;
  signed int saved_ublen;
  signed int bitmapRowBytes;
  signed int maskBytes;
  signed int dataBytes;
  signed int i;
  signed int rfbSendCursorShape__1__j;
  unsigned char *bitmapData;
  unsigned char bitmapByte;
  pCursor=cl->screen->getCursorPtr(cl);
  if(!(cl->useRichCursorEncoding == 0))
  {
    if(!(pCursor == ((struct rfbCursor *)NULL)))
    {
      if(pCursor->richSource == ((unsigned char *)NULL))
        rfbMakeRichCursorFromXCursor(cl->screen, pCursor);

    }

    rect.encoding = rfbEndianTest != 0 ? 0xFFFFFF11 >> 24 | (0xFFFFFF11 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF11 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF11 << 24 : 0xFFFFFF11;
  }

  else
  {
    if(!(pCursor == ((struct rfbCursor *)NULL)))
    {
      if(pCursor->source == ((unsigned char *)NULL))
        rfbMakeXCursorFromRichCursor(cl->screen, pCursor);

    }

    rect.encoding = rfbEndianTest != 0 ? 0xFFFFFF10 >> 24 | (0xFFFFFF10 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF10 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF10 << 24 : 0xFFFFFF10;
  }
  if(!(pCursor == ((struct rfbCursor *)NULL)))
  {
    if((signed int)pCursor->width == 1)
    {
      if((signed int)pCursor->height == 1)
      {
        if((signed int)*pCursor->mask == 0)
          pCursor = (struct rfbCursor *)(void *)0;

      }

    }

  }

  if(pCursor == ((struct rfbCursor *)NULL))
  {
    if(4 + cl->ublen >= 30001)
    {
      signed char return_value_rfbSendUpdateBuf_1;
      return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_1 == 0)
        return (signed char)0;

    }

    rect.r.y = (unsigned short int)0;
    rect.r.x = rect.r.y;
    rect.r.h = (unsigned short int)0;
    rect.r.w = rect.r.h;
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
    cl->ublen = cl->ublen + 8 + 4;
    signed char return_value_rfbSendUpdateBuf_2;
    return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_2 == 0)
      return (signed char)0;

    return (signed char)-1;
  }

  bitmapRowBytes = ((signed int)pCursor->width + 7) / 8;
  maskBytes = bitmapRowBytes * (signed int)pCursor->height;
  signed int tmp_if_expr_3;
  if(!(cl->useRichCursorEncoding == 0))
    tmp_if_expr_3 = (signed int)pCursor->width * (signed int)pCursor->height * ((signed int)cl->format.bitsPerPixel / 8);

  else
    tmp_if_expr_3 = maskBytes;
  dataBytes = tmp_if_expr_3;
  if(6 + cl->ublen + dataBytes + maskBytes >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_4;
    return_value_rfbSendUpdateBuf_4=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_4 == 0)
      return (signed char)0;

  }

  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  if(6 + cl->ublen + dataBytes + maskBytes >= 30001)
    return (signed char)0;

  else
  {
    saved_ublen = cl->ublen;
    if(!(rfbEndianTest == 0))
      tmp_if_expr_5 = ((signed int)pCursor->xhot & 0xff) << 8 | (signed int)pCursor->xhot >> 8 & 0xff;

    else
      tmp_if_expr_5 = (signed int)pCursor->xhot;
    rect.r.x = (unsigned short int)tmp_if_expr_5;
    if(!(rfbEndianTest == 0))
      tmp_if_expr_6 = ((signed int)pCursor->yhot & 0xff) << 8 | (signed int)pCursor->yhot >> 8 & 0xff;

    else
      tmp_if_expr_6 = (signed int)pCursor->yhot;
    rect.r.y = (unsigned short int)tmp_if_expr_6;
    if(!(rfbEndianTest == 0))
      tmp_if_expr_7 = ((signed int)pCursor->width & 0xff) << 8 | (signed int)pCursor->width >> 8 & 0xff;

    else
      tmp_if_expr_7 = (signed int)pCursor->width;
    rect.r.w = (unsigned short int)tmp_if_expr_7;
    if(!(rfbEndianTest == 0))
      tmp_if_expr_8 = ((signed int)pCursor->height & 0xff) << 8 | (signed int)pCursor->height >> 8 & 0xff;

    else
      tmp_if_expr_8 = (signed int)pCursor->height;
    rect.r.h = (unsigned short int)tmp_if_expr_8;
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
    cl->ublen = cl->ublen + 8 + 4;
    if(cl->useRichCursorEncoding == 0)
    {
      colors.foreRed = (unsigned char)(char)((signed int)pCursor->foreRed >> 8);
      colors.foreGreen = (unsigned char)(char)((signed int)pCursor->foreGreen >> 8);
      colors.foreBlue = (unsigned char)(char)((signed int)pCursor->foreBlue >> 8);
      colors.backRed = (unsigned char)(char)((signed int)pCursor->backRed >> 8);
      colors.backGreen = (unsigned char)(char)((signed int)pCursor->backGreen >> 8);
      colors.backBlue = (unsigned char)(char)((signed int)pCursor->backBlue >> 8);
      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&colors, (unsigned long int)6);
      cl->ublen = cl->ublen + 6;
      bitmapData = (unsigned char *)pCursor->source;
      i = 0;
      if(!(i >= (signed int)pCursor->height))
      {
        rfbSendCursorShape__1__j = 0;
        if(!(rfbSendCursorShape__1__j >= bitmapRowBytes))
        {
          bitmapByte = bitmapData[(signed long int)(i * bitmapRowBytes + rfbSendCursorShape__1__j)];
          tmp_post_9 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_9] = (char)bitmapByte;
          rfbSendCursorShape__1__j = rfbSendCursorShape__1__j + 1;
        }

        i = i + 1;
      }

    }

    else
    {
      signed int bpp1 = (signed int)cl->screen->serverFormat.bitsPerPixel / 8;
      signed int bpp2 = (signed int)cl->format.bitsPerPixel / 8;
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, (char *)pCursor->richSource, &cl->updateBuf[(signed long int)cl->ublen], (signed int)pCursor->width * bpp1, (signed int)pCursor->width, (signed int)pCursor->height);
      cl->ublen = cl->ublen + (signed int)pCursor->width * bpp2 * (signed int)pCursor->height;
    }
    bitmapData = (unsigned char *)pCursor->mask;
    i = 0;
    if(!(i >= (signed int)pCursor->height))
    {
      rfbSendCursorShape__1__j = 0;
      if(!(rfbSendCursorShape__1__j >= bitmapRowBytes))
      {
        bitmapByte = bitmapData[(signed long int)(i * bitmapRowBytes + rfbSendCursorShape__1__j)];
        tmp_post_10 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_10] = (char)bitmapByte;
        rfbSendCursorShape__1__j = rfbSendCursorShape__1__j + 1;
      }

      i = i + 1;
    }

    rfbStatRecordEncodingSent(cl, cl->useRichCursorEncoding != 0 ? 0xFFFFFF11 : 0xFFFFFF10, 8 + 4 + (cl->ublen - saved_ublen), 8 + 4 + (cl->ublen - saved_ublen));
    signed char return_value_rfbSendUpdateBuf_11;
    return_value_rfbSendUpdateBuf_11=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_11 == 0)
      return (signed char)0;

    else
      return (signed char)-1;
  }
}

// rfbSendDirContent
// file rfbserver.c line 1312
extern signed char rfbSendDirContent(struct _rfbClientRec *cl, signed int length, char *buffer)
{
  char retfilename[260l];
  char path[260l];
  struct stat statbuf;
  struct anonymous_53 win32filename;
  signed int nOptLen = 0;
  signed int retval = 0;
  struct __dirstream *dirp = (struct __dirstream *)(void *)0;
  struct dirent *direntp = (struct dirent *)(void *)0;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
  {
    return_value=cl->screen->getFileTransferPermission(cl);
    tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->screen->permitFileTransfer != -1 ? (_Bool)1 : (_Bool)0;
  signed char return_value_rfbSendFileTransferMessage_4;
  _Bool tmp_if_expr_9;
  if(tmp_if_expr_2)
  {
    rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", (const void *)"", cl->host);
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    signed char return_value_rfbFilenameTranslate2UNIX_3;
    return_value_rfbFilenameTranslate2UNIX_3=rfbFilenameTranslate2UNIX(cl, buffer, path, sizeof(char [260l]) /*260ul*/ );
    if(return_value_rfbFilenameTranslate2UNIX_3 == 0)
      return (signed char)0;

    else
    {
      if(!(DB == 0))
        rfbLog("rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: \"%s\"->\"%s\"\n", buffer, (const void *)path);

      dirp=opendir(path);
      if(dirp == ((struct __dirstream *)NULL))
      {
        return_value_rfbSendFileTransferMessage_4=rfbSendFileTransferMessage(cl, (unsigned char)2, (unsigned char)1, (unsigned int)0, (unsigned int)0, (const char *)(void *)0);
        return return_value_rfbSendFileTransferMessage_4;
      }

      else
      {
        signed char return_value_rfbSendFileTransferMessage_5;
        return_value_rfbSendFileTransferMessage_5=rfbSendFileTransferMessage(cl, (unsigned char)2, (unsigned char)1, (unsigned int)0, (unsigned int)length, buffer);
        if((signed int)return_value_rfbSendFileTransferMessage_5 == 0)
          return (signed char)0;

        else
        {
          direntp=readdir(dirp);
          while(!(direntp == ((struct dirent *)NULL)))
          {
            snprintf(retfilename, sizeof(char [260l]) /*260ul*/ , "%s/%s", (const void *)path, (const void *)direntp->d_name);
            retval=stat(retfilename, &statbuf);
            if(retval == 0)
            {
              memset((void *)(char *)&win32filename, 0, sizeof(struct anonymous_53) /*320ul*/ );
              win32filename.dwFileAttributes = (unsigned int)(rfbEndianTest != 0 ? 0x80 : 0x80 >> 24 | (0x80 & 0x00ff0000) >> 8 | (0x80 & 0x0000ff00) << 8 | 0x80 << 24);
              if((61440u & statbuf.st_mode) == 16384u)
                win32filename.dwFileAttributes = (unsigned int)(rfbEndianTest != 0 ? 0x10 : 0x10 >> 24 | (0x10 & 0x00ff0000) >> 8 | (0x10 & 0x0000ff00) << 8 | 0x10 << 24);

              win32filename.ftCreationTime.dwLowDateTime = (unsigned int)(rfbEndianTest != 0 ? statbuf.st_ctim.tv_sec : statbuf.st_ctim.tv_sec >> 24 | (statbuf.st_ctim.tv_sec & (signed long int)0x00ff0000) >> 8 | (statbuf.st_ctim.tv_sec & (signed long int)0x0000ff00) << 8 | statbuf.st_ctim.tv_sec << 24);
              win32filename.ftCreationTime.dwHighDateTime = (unsigned int)0;
              win32filename.ftLastAccessTime.dwLowDateTime = (unsigned int)(rfbEndianTest != 0 ? statbuf.st_atim.tv_sec : statbuf.st_atim.tv_sec >> 24 | (statbuf.st_atim.tv_sec & (signed long int)0x00ff0000) >> 8 | (statbuf.st_atim.tv_sec & (signed long int)0x0000ff00) << 8 | statbuf.st_atim.tv_sec << 24);
              win32filename.ftLastAccessTime.dwHighDateTime = (unsigned int)0;
              win32filename.ftLastWriteTime.dwLowDateTime = (unsigned int)(rfbEndianTest != 0 ? statbuf.st_mtim.tv_sec : statbuf.st_mtim.tv_sec >> 24 | (statbuf.st_mtim.tv_sec & (signed long int)0x00ff0000) >> 8 | (statbuf.st_mtim.tv_sec & (signed long int)0x0000ff00) << 8 | statbuf.st_mtim.tv_sec << 24);
              win32filename.ftLastWriteTime.dwHighDateTime = (unsigned int)0;
              win32filename.nFileSizeLow = (unsigned int)(rfbEndianTest != 0 ? statbuf.st_size : statbuf.st_size >> 24 | (statbuf.st_size & (signed long int)0x00ff0000) >> 8 | (statbuf.st_size & (signed long int)0x0000ff00) << 8 | statbuf.st_size << 24);
              win32filename.nFileSizeHigh = (unsigned int)0;
              win32filename.dwReserved0 = (unsigned int)0;
              win32filename.dwReserved1 = (unsigned int)0;
              strcpy((char *)win32filename.cFileName, direntp->d_name);
              signed int return_value_strcmp_8;
              return_value_strcmp_8=strcmp((char *)win32filename.cFileName, "..");
              if(return_value_strcmp_8 == 0)
                tmp_if_expr_9 = (_Bool)1;

              else
                tmp_if_expr_9 = (signed int)win32filename.cFileName[(signed long int)0] != 46 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_9)
              {
                unsigned long int return_value_strlen_6;
                return_value_strlen_6=strlen((char *)win32filename.cFileName);
                nOptLen = (signed int)(((sizeof(struct anonymous_53) /*320ul*/  - (unsigned long int)260) - (unsigned long int)14) + return_value_strlen_6);
                signed char return_value_rfbSendFileTransferMessage_7;
                return_value_rfbSendFileTransferMessage_7=rfbSendFileTransferMessage(cl, (unsigned char)2, (unsigned char)1, (unsigned int)0, (unsigned int)nOptLen, (char *)&win32filename);
                if((signed int)return_value_rfbSendFileTransferMessage_7 == 0)
                {
                  closedir(dirp);
                  return (signed char)0;
                }

              }

            }

            direntp=readdir(dirp);
          }
          closedir(dirp);
          signed char return_value_rfbSendFileTransferMessage_10;
          return_value_rfbSendFileTransferMessage_10=rfbSendFileTransferMessage(cl, (unsigned char)2, (unsigned char)0, (unsigned int)0, (unsigned int)0, (const char *)(void *)0);
          return return_value_rfbSendFileTransferMessage_10;
        }
      }
    }
  }
}

// rfbSendFileTransferChunk
// file ../rfb/rfb.h line 803
extern signed char rfbSendFileTransferChunk(struct _rfbClientRec *cl)
{
  unsigned char readBuf[8192l];
  signed int bytesRead = 0;
  signed int retval = 0;
  struct anonymous_16 wfds;
  struct timeval tv;
  signed int n;
  unsigned char compBuf[9216l];
  unsigned long int nMaxCompSize = sizeof(unsigned char [9216l]) /*9216ul*/ ;
  signed int nRetC = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!((signed int)cl->screen->permitFileTransfer == -1))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
    {
      return_value=cl->screen->getFileTransferPermission(cl);
      tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  signed char return_value_rfbSendFileTransferMessage_6;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  signed char return_value_rfbSendFileTransferMessage_9;
  signed char return_value_rfbSendFileTransferMessage_10;
  signed char return_value_rfbSendFileTransferMessage_11;
  signed char return_value_rfbSendFileTransferMessage_12;
  if(tmp_if_expr_2)
    return (signed char)-1;

  else
  {
    if(!(cl->fileTransfer.fd == -1))
    {
      if(cl->fileTransfer.sending == 1)
      {
        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&wfds)->__fds_bits[(signed long int)(cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->__fds_bits[(signed long int)(cl->sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << cl->sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)0;
        tv.tv_usec = (signed long int)0;
        n=select(cl->sock + 1, (struct anonymous_16 *)(void *)0, &wfds, (struct anonymous_16 *)(void *)0, &tv);
        if(!(n >= 0))
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          char *return_value_strerror_4;
          return_value_strerror_4=strerror(*return_value___errno_location_3);
          rfbLog("rfbSendFileTransferChunk() select failed: %s\n", return_value_strerror_4);
        }

        if(n >= 1)
        {
          signed long int return_value_read_5;
          return_value_read_5=read(cl->fileTransfer.fd, (void *)readBuf, (unsigned long int)8192);
          bytesRead = (signed int)return_value_read_5;
          if(!(bytesRead == 0))
          {
            if(bytesRead == -1)
              goto __CPROVER_DUMP_L9;

          }

          else
          {
            return_value_rfbSendFileTransferMessage_6=rfbSendFileTransferMessage(cl, (unsigned char)6, (unsigned char)0, (unsigned int)0, (unsigned int)0, (const char *)(void *)0);
            retval = (signed int)return_value_rfbSendFileTransferMessage_6;
            close(cl->fileTransfer.fd);
            cl->fileTransfer.fd = -1;
            cl->fileTransfer.sending = 0;
            cl->fileTransfer.receiving = 0;
            return (signed char)retval;

          __CPROVER_DUMP_L9:
            ;
            return_value___errno_location_7=__errno_location();
            return_value_strerror_8=strerror(*return_value___errno_location_7);
            rfbLog("rfbSendFileTransferChunk(): %s\n", return_value_strerror_8);
            return_value_rfbSendFileTransferMessage_9=rfbSendFileTransferMessage(cl, (unsigned char)7, (unsigned char)0, (unsigned int)0, (unsigned int)0, (const char *)(void *)0);
            retval = (signed int)return_value_rfbSendFileTransferMessage_9;
            close(cl->fileTransfer.fd);
            cl->fileTransfer.fd = -1;
            cl->fileTransfer.sending = 0;
            cl->fileTransfer.receiving = 0;
            return (signed char)retval;
          }
          if(cl->fileTransfer.compressionEnabled == 0)
          {
            return_value_rfbSendFileTransferMessage_10=rfbSendFileTransferMessage(cl, (unsigned char)5, (unsigned char)0, (unsigned int)0, (unsigned int)bytesRead, (char *)readBuf);
            return return_value_rfbSendFileTransferMessage_10;
          }

          else
          {
            nRetC=compress(compBuf, &nMaxCompSize, readBuf, (unsigned long int)bytesRead);
            if(nRetC == 0 && !(nMaxCompSize >= (unsigned long int)bytesRead))
            {
              return_value_rfbSendFileTransferMessage_11=rfbSendFileTransferMessage(cl, (unsigned char)5, (unsigned char)0, (unsigned int)1, (unsigned int)nMaxCompSize, (char *)compBuf);
              return return_value_rfbSendFileTransferMessage_11;
            }

            else
            {
              return_value_rfbSendFileTransferMessage_12=rfbSendFileTransferMessage(cl, (unsigned char)5, (unsigned char)0, (unsigned int)0, (unsigned int)bytesRead, (char *)readBuf);
              return return_value_rfbSendFileTransferMessage_12;
            }
          }
        }

      }

    }

    return (signed char)-1;
  }
}

// rfbSendFileTransferMessage
// file rfbserver.c line 1191
extern signed char rfbSendFileTransferMessage(struct _rfbClientRec *cl, unsigned char contentType, unsigned char contentParam, unsigned int size, unsigned int length, const char *buffer)
{
  struct _rfbFileTransferMsg ft;
  ft.type = (unsigned char)7;
  ft.contentType = contentType;
  ft.contentParam = contentParam;
  ft.pad = (unsigned char)0;
  ft.size = rfbEndianTest != 0 ? size >> 24 | (size & (unsigned int)0x00ff0000) >> 8 | (size & (unsigned int)0x0000ff00) << 8 | size << 24 : size;
  ft.length = rfbEndianTest != 0 ? length >> 24 | (length & (unsigned int)0x00ff0000) >> 8 | (length & (unsigned int)0x0000ff00) << 8 | length << 24 : length;
  _Bool tmp_if_expr_1;
  signed int return_value;
  if(!(cl->screen->getFileTransferPermission == ((signed int (*)(struct _rfbClientRec *))NULL)))
  {
    return_value=cl->screen->getFileTransferPermission(cl);
    tmp_if_expr_1 = return_value != -1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)cl->screen->permitFileTransfer != -1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", (const void *)"", cl->host);
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    pthread_mutex_lock(&cl->sendMutex);
    signed int return_value_rfbWriteExact_3;
    return_value_rfbWriteExact_3=rfbWriteExact(cl, (char *)&ft, 12);
    if(!(return_value_rfbWriteExact_3 >= 0))
    {
      rfbLogPerror("rfbSendFileTransferMessage: write");
      rfbCloseClient(cl);
      pthread_mutex_unlock(&cl->sendMutex);
      return (signed char)0;
    }

    else
    {
      if(length >= 1u)
      {
        signed int return_value_rfbWriteExact_4;
        return_value_rfbWriteExact_4=rfbWriteExact(cl, buffer, (signed int)length);
        if(!(return_value_rfbWriteExact_4 >= 0))
        {
          rfbLogPerror("rfbSendFileTransferMessage: write");
          rfbCloseClient(cl);
          pthread_mutex_unlock(&cl->sendMutex);
          return (signed char)0;
        }

      }

      pthread_mutex_unlock(&cl->sendMutex);
      rfbStatRecordMessageSent(cl, (unsigned int)7, (signed int)((unsigned int)12 + length), (signed int)((unsigned int)12 + length));
      return (signed char)-1;
    }
  }
}

// rfbSendFramebufferUpdate
// file ../rfb/rfb.h line 792
extern signed char rfbSendFramebufferUpdate(struct _rfbClientRec *cl, struct sraRegion *givenUpdateRegion)
{
  struct sraRectangleIterator *i = (struct sraRectangleIterator *)(void *)0;
  struct _rect rfbSendFramebufferUpdate__1__rect;
  signed int nUpdateRegionRects;
  struct anonymous_57 *fu = (struct anonymous_57 *)cl->updateBuf;
  struct sraRegion *updateRegion;
  struct sraRegion *updateCopyRegion;
  struct sraRegion *tmpRegion;
  signed int dx;
  signed int dy;
  signed char sendCursorShape = (signed char)0;
  signed char sendCursorPos = (signed char)0;
  signed char sendKeyboardLedState = (signed char)0;
  signed char sendSupportedMessages = (signed char)0;
  signed char sendSupportedEncodings = (signed char)0;
  signed char sendServerIdentity = (signed char)0;
  signed char result = (signed char)-1;
  if(!(cl->screen->displayHook == ((void (*)(struct _rfbClientRec *))NULL)))
    cl->screen->displayHook(cl);

  if(!(cl->useNewFBSize == 0))
  {
    if(!(cl->newFBSizePending == 0))
    {
      pthread_mutex_lock(&cl->updateMutex);
      cl->newFBSizePending = (signed char)0;
      pthread_mutex_unlock(&cl->updateMutex);
      fu->type = (unsigned char)0;
      fu->nRects = (unsigned short int)(rfbEndianTest != 0 ? (1 & 0xff) << 8 | 1 >> 8 & 0xff : 1);
      cl->ublen = 4;
      signed char return_value_rfbSendNewFBSize_1;
      return_value_rfbSendNewFBSize_1=rfbSendNewFBSize(cl, cl->scaledScreen->width, cl->scaledScreen->height);
      if(return_value_rfbSendNewFBSize_1 == 0)
      {
        if(!(cl->screen->displayFinishedHook == ((void (*)(struct _rfbClientRec *, signed int))NULL)))
          cl->screen->displayFinishedHook(cl, 0);

        return (signed char)0;
      }

      result=rfbSendUpdateBuf(cl);
      if(!(cl->screen->displayFinishedHook == ((void (*)(struct _rfbClientRec *, signed int))NULL)))
        cl->screen->displayFinishedHook(cl, (signed int)result);

      return result;
    }

  }

  if(!(cl->enableCursorShapeUpdates == 0))
  {
    if(!(cl->cursorWasChanged == 0))
    {
      if(!(cl->readyForSetColourMapEntries == 0))
        sendCursorShape = (signed char)-1;

    }

  }

  if(!(cl->enableCursorPosUpdates == 0))
  {
    if(!(cl->cursorWasMoved == 0))
      sendCursorPos = (signed char)-1;

  }

  if(!(cl->enableKeyboardLedState == 0))
  {
    if(!(cl->screen->getKeyboardLedStateHook == ((signed int (*)(struct _rfbScreenInfo *))NULL)))
    {
      signed int rfbSendFramebufferUpdate__1__3__x;
      rfbSendFramebufferUpdate__1__3__x=cl->screen->getKeyboardLedStateHook(cl->screen);
      if(!(rfbSendFramebufferUpdate__1__3__x == cl->lastKeyboardLedState))
      {
        sendKeyboardLedState = (signed char)-1;
        cl->lastKeyboardLedState = rfbSendFramebufferUpdate__1__3__x;
      }

    }

  }

  if(!(cl->enableSupportedMessages == 0))
  {
    sendSupportedMessages = (signed char)-1;
    cl->enableSupportedMessages = (signed char)0;
  }

  if(!(cl->enableSupportedEncodings == 0))
  {
    sendSupportedEncodings = (signed char)-1;
    cl->enableSupportedEncodings = (signed char)0;
  }

  if(!(cl->enableServerIdentity == 0))
  {
    sendServerIdentity = (signed char)-1;
    cl->enableServerIdentity = (signed char)0;
  }

  pthread_mutex_lock(&cl->updateMutex);
  sraRgnSubtract(cl->copyRegion, cl->modifiedRegion);
  updateRegion=sraRgnCreateRgn(givenUpdateRegion);
  if(cl->screen->progressiveSliceHeight >= 1)
  {
    signed int height = cl->screen->progressiveSliceHeight;
    signed int rfbSendFramebufferUpdate__1__7__y = cl->progressiveSliceY;
    struct sraRegion *bbox;
    bbox=sraRgnBBox(updateRegion);
    struct _rect rect;
    signed char return_value_sraRgnPopRect_2;
    return_value_sraRgnPopRect_2=sraRgnPopRect(bbox, &rect, (unsigned long int)0);
    if(!(return_value_sraRgnPopRect_2 == 0))
    {
      struct sraRegion *slice;
      if(rfbSendFramebufferUpdate__1__7__y >= rect.y2 || !(rfbSendFramebufferUpdate__1__7__y >= rect.y1))
        rfbSendFramebufferUpdate__1__7__y = rect.y1;

      slice=sraRgnCreateRect(0, rfbSendFramebufferUpdate__1__7__y, cl->screen->width, rfbSendFramebufferUpdate__1__7__y + height);
      sraRgnAnd(updateRegion, slice);
      sraRgnDestroy(slice);
    }

    sraRgnDestroy(bbox);
    rfbSendFramebufferUpdate__1__7__y = rfbSendFramebufferUpdate__1__7__y + height;
    if(rfbSendFramebufferUpdate__1__7__y >= cl->screen->height)
      rfbSendFramebufferUpdate__1__7__y = 0;

    cl->progressiveSliceY = rfbSendFramebufferUpdate__1__7__y;
  }

  sraRgnOr(updateRegion, cl->copyRegion);
  signed char return_value_sraRgnAnd_6;
  return_value_sraRgnAnd_6=sraRgnAnd(updateRegion, cl->requestedRegion);
  signed char return_value_sraRgnEmpty_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_7;
  signed char return_value_sraRgnIteratorNext_8;
  signed char return_value_sraRgnIteratorNext_9;
  signed char return_value_sraRgnIteratorNext_10;
  signed char return_value_sraRgnIteratorNext_11;
  signed int tmp_if_expr_17;
  unsigned long int return_value_sraRgnCountRects_14;
  unsigned long int return_value_sraRgnCountRects_15;
  unsigned long int return_value_sraRgnCountRects_16;
  signed char return_value_sraRgnIteratorNext_26;
  signed char return_value_rfbSendLastRectMarker_35;
  if(return_value_sraRgnAnd_6 == 0)
  {
    return_value_sraRgnEmpty_5=sraRgnEmpty(updateRegion);
    if(return_value_sraRgnEmpty_5 == 0)
      goto __CPROVER_DUMP_L22;

    if(!(cl->enableCursorShapeUpdates == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if(cl->cursorX == cl->screen->cursorX)
        tmp_if_expr_3 = cl->cursorY == cl->screen->cursorY ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_4)
      goto __CPROVER_DUMP_L22;

    if(!(sendCursorShape == 0))
      goto __CPROVER_DUMP_L22;

    if(!(sendCursorPos == 0))
      goto __CPROVER_DUMP_L22;

    if(!(sendKeyboardLedState == 0))
      goto __CPROVER_DUMP_L22;

    if(!(sendSupportedMessages == 0))
      goto __CPROVER_DUMP_L22;

    if(!(sendSupportedEncodings == 0))
      goto __CPROVER_DUMP_L22;

    if(!(sendServerIdentity == 0))
      goto __CPROVER_DUMP_L22;

    sraRgnDestroy(updateRegion);
    pthread_mutex_unlock(&cl->updateMutex);
    if(!(cl->screen->displayFinishedHook == ((void (*)(struct _rfbClientRec *, signed int))NULL)))
      cl->screen->displayFinishedHook(cl, -1);

    return (signed char)-1;
  }

  else
  {

  __CPROVER_DUMP_L22:
    ;
    updateCopyRegion=sraRgnCreateRgn(cl->copyRegion);
    sraRgnAnd(updateCopyRegion, cl->requestedRegion);
    tmpRegion=sraRgnCreateRgn(cl->requestedRegion);
    sraRgnOffset(tmpRegion, cl->copyDX, cl->copyDY);
    sraRgnAnd(updateCopyRegion, tmpRegion);
    sraRgnDestroy(tmpRegion);
    dx = cl->copyDX;
    dy = cl->copyDY;
    sraRgnSubtract(updateRegion, updateCopyRegion);
    sraRgnOr(cl->modifiedRegion, cl->copyRegion);
    sraRgnSubtract(cl->modifiedRegion, updateRegion);
    sraRgnSubtract(cl->modifiedRegion, updateCopyRegion);
    sraRgnMakeEmpty(cl->requestedRegion);
    sraRgnMakeEmpty(cl->copyRegion);
    cl->copyDX = 0;
    cl->copyDY = 0;
    pthread_mutex_unlock(&cl->updateMutex);
    if(cl->enableCursorShapeUpdates == 0)
    {
      if(!(cl->cursorX == cl->screen->cursorX))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = cl->cursorY != cl->screen->cursorY ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
      {
        rfbRedrawAfterHideCursor(cl, updateRegion);
        pthread_mutex_lock(&cl->screen->cursorMutex);
        cl->cursorX = cl->screen->cursorX;
        cl->cursorY = cl->screen->cursorY;
        pthread_mutex_unlock(&cl->screen->cursorMutex);
        rfbRedrawAfterHideCursor(cl, updateRegion);
      }

      rfbShowCursor(cl);
    }

    rfbStatRecordMessageSent(cl, (unsigned int)0, 0, 0);
    if(cl->preferredEncoding == 4)
    {
      nUpdateRegionRects = 0;
      i=sraRgnGetIterator(updateRegion);
      do
      {
        return_value_sraRgnIteratorNext_8=sraRgnIteratorNext(i, &rfbSendFramebufferUpdate__1__rect);
        if(return_value_sraRgnIteratorNext_8 == 0)
          break;

        signed int x = rfbSendFramebufferUpdate__1__rect.x1;
        signed int y = rfbSendFramebufferUpdate__1__rect.y1;
        signed int w = rfbSendFramebufferUpdate__1__rect.x2 - x;
        signed int h = rfbSendFramebufferUpdate__1__rect.y2 - y;
        signed int rectsPerRow;
        signed int rows;
        if(!(cl->screen == cl->scaledScreen))
          rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "rfbSendFramebufferUpdate");

        rectsPerRow = (w - 1) / cl->correMaxWidth + 1;
        rows = (h - 1) / cl->correMaxHeight + 1;
        nUpdateRegionRects = nUpdateRegionRects + rectsPerRow * rows;
      }
      while((_Bool)1);
      sraRgnReleaseIterator(i);
      i = (struct sraRectangleIterator *)(void *)0;
    }

    else
      if(cl->preferredEncoding == 9)
      {
        nUpdateRegionRects = 0;
        i=sraRgnGetIterator(updateRegion);
        do
        {
          return_value_sraRgnIteratorNext_9=sraRgnIteratorNext(i, &rfbSendFramebufferUpdate__1__rect);
          if(return_value_sraRgnIteratorNext_9 == 0)
            break;

          signed int rfbSendFramebufferUpdate__1__11__1__1__x = rfbSendFramebufferUpdate__1__rect.x1;
          signed int rfbSendFramebufferUpdate__1__11__1__1__y = rfbSendFramebufferUpdate__1__rect.y1;
          signed int rfbSendFramebufferUpdate__1__11__1__1__w = rfbSendFramebufferUpdate__1__rect.x2 - rfbSendFramebufferUpdate__1__11__1__1__x;
          signed int rfbSendFramebufferUpdate__1__11__1__1__h = rfbSendFramebufferUpdate__1__rect.y2 - rfbSendFramebufferUpdate__1__11__1__1__y;
          if(!(cl->screen == cl->scaledScreen))
            rfbScaledCorrection(cl->screen, cl->scaledScreen, &rfbSendFramebufferUpdate__1__11__1__1__x, &rfbSendFramebufferUpdate__1__11__1__1__y, &rfbSendFramebufferUpdate__1__11__1__1__w, &rfbSendFramebufferUpdate__1__11__1__1__h, "rfbSendFramebufferUpdate");

          nUpdateRegionRects = nUpdateRegionRects + (rfbSendFramebufferUpdate__1__11__1__1__h - 1) / ((rfbSendFramebufferUpdate__1__11__1__1__w * 2 > 128 * 256 ? rfbSendFramebufferUpdate__1__11__1__1__w * 2 : 128 * 256) / rfbSendFramebufferUpdate__1__11__1__1__w) + 1;
        }
        while((_Bool)1);
        sraRgnReleaseIterator(i);
        i = (struct sraRectangleIterator *)(void *)0;
      }

      else
        if(cl->preferredEncoding == 6)
        {
          nUpdateRegionRects = 0;
          i=sraRgnGetIterator(updateRegion);
          do
          {
            return_value_sraRgnIteratorNext_10=sraRgnIteratorNext(i, &rfbSendFramebufferUpdate__1__rect);
            if(return_value_sraRgnIteratorNext_10 == 0)
              break;

            signed int rfbSendFramebufferUpdate__1__12__1__1__x = rfbSendFramebufferUpdate__1__rect.x1;
            signed int rfbSendFramebufferUpdate__1__12__1__1__y = rfbSendFramebufferUpdate__1__rect.y1;
            signed int rfbSendFramebufferUpdate__1__12__1__1__w = rfbSendFramebufferUpdate__1__rect.x2 - rfbSendFramebufferUpdate__1__12__1__1__x;
            signed int rfbSendFramebufferUpdate__1__12__1__1__h = rfbSendFramebufferUpdate__1__rect.y2 - rfbSendFramebufferUpdate__1__12__1__1__y;
            if(!(cl->screen == cl->scaledScreen))
              rfbScaledCorrection(cl->screen, cl->scaledScreen, &rfbSendFramebufferUpdate__1__12__1__1__x, &rfbSendFramebufferUpdate__1__12__1__1__y, &rfbSendFramebufferUpdate__1__12__1__1__w, &rfbSendFramebufferUpdate__1__12__1__1__h, "rfbSendFramebufferUpdate");

            nUpdateRegionRects = nUpdateRegionRects + (rfbSendFramebufferUpdate__1__12__1__1__h - 1) / ((rfbSendFramebufferUpdate__1__12__1__1__w * 2 > 128 * 256 ? rfbSendFramebufferUpdate__1__12__1__1__w * 2 : 128 * 256) / rfbSendFramebufferUpdate__1__12__1__1__w) + 1;
          }
          while((_Bool)1);
          sraRgnReleaseIterator(i);
          i = (struct sraRectangleIterator *)(void *)0;
        }

        else
          if(cl->preferredEncoding == 7)
          {
            nUpdateRegionRects = 0;
            i=sraRgnGetIterator(updateRegion);
            do
            {
              return_value_sraRgnIteratorNext_11=sraRgnIteratorNext(i, &rfbSendFramebufferUpdate__1__rect);
              if(return_value_sraRgnIteratorNext_11 == 0)
                break;

              signed int rfbSendFramebufferUpdate__1__13__1__1__x = rfbSendFramebufferUpdate__1__rect.x1;
              signed int rfbSendFramebufferUpdate__1__13__1__1__y = rfbSendFramebufferUpdate__1__rect.y1;
              signed int rfbSendFramebufferUpdate__1__13__1__1__w = rfbSendFramebufferUpdate__1__rect.x2 - rfbSendFramebufferUpdate__1__13__1__1__x;
              signed int rfbSendFramebufferUpdate__1__13__1__1__h = rfbSendFramebufferUpdate__1__rect.y2 - rfbSendFramebufferUpdate__1__13__1__1__y;
              signed int n;
              if(!(cl->screen == cl->scaledScreen))
                rfbScaledCorrection(cl->screen, cl->scaledScreen, &rfbSendFramebufferUpdate__1__13__1__1__x, &rfbSendFramebufferUpdate__1__13__1__1__y, &rfbSendFramebufferUpdate__1__13__1__1__w, &rfbSendFramebufferUpdate__1__13__1__1__h, "rfbSendFramebufferUpdate");

              n=rfbNumCodedRectsTight(cl, rfbSendFramebufferUpdate__1__13__1__1__x, rfbSendFramebufferUpdate__1__13__1__1__y, rfbSendFramebufferUpdate__1__13__1__1__w, rfbSendFramebufferUpdate__1__13__1__1__h);
              if(n == 0)
              {
                nUpdateRegionRects = 0xFFFF;
                break;
              }

              nUpdateRegionRects = nUpdateRegionRects + n;
            }
            while((_Bool)1);
            sraRgnReleaseIterator(i);
            i = (struct sraRectangleIterator *)(void *)0;
          }

          else
          {
            unsigned long int return_value_sraRgnCountRects_12;
            return_value_sraRgnCountRects_12=sraRgnCountRects(updateRegion);
            nUpdateRegionRects = (signed int)return_value_sraRgnCountRects_12;
          }
    fu->type = (unsigned char)0;
    if(!(nUpdateRegionRects == 0xFFFF))
    {
      if(cl->screen->maxRectsPerUpdate >= 1)
      {
        if(!(cl->preferredEncoding == 4))
        {
          if(!(cl->preferredEncoding == 9))
          {
            if(!(cl->preferredEncoding == 6))
            {
              if(!(cl->preferredEncoding == 7))
              {
                if(!(cl->screen->maxRectsPerUpdate >= nUpdateRegionRects))
                {
                  struct sraRegion *newUpdateRegion;
                  newUpdateRegion=sraRgnBBox(updateRegion);
                  sraRgnDestroy(updateRegion);
                  updateRegion = newUpdateRegion;
                  unsigned long int return_value_sraRgnCountRects_13;
                  return_value_sraRgnCountRects_13=sraRgnCountRects(updateRegion);
                  nUpdateRegionRects = (signed int)return_value_sraRgnCountRects_13;
                }

              }

            }

          }

        }

      }

      if(!(rfbEndianTest == 0))
      {
        return_value_sraRgnCountRects_14=sraRgnCountRects(updateCopyRegion);
        return_value_sraRgnCountRects_15=sraRgnCountRects(updateCopyRegion);
        tmp_if_expr_17 = ((signed int)(unsigned short int)(return_value_sraRgnCountRects_14 + (unsigned long int)nUpdateRegionRects + (unsigned long int)!(!(sendCursorShape != 0)) + (unsigned long int)!(!(sendCursorPos != 0)) + (unsigned long int)!(!(sendKeyboardLedState != 0)) + (unsigned long int)!(!(sendSupportedMessages != 0)) + (unsigned long int)!(!(sendSupportedEncodings != 0)) + (unsigned long int)!(!(sendServerIdentity != 0))) & 0xff) << 8 | (signed int)(unsigned short int)(return_value_sraRgnCountRects_15 + (unsigned long int)nUpdateRegionRects + (unsigned long int)!(!(sendCursorShape != 0)) + (unsigned long int)!(!(sendCursorPos != 0)) + (unsigned long int)!(!(sendKeyboardLedState != 0)) + (unsigned long int)!(!(sendSupportedMessages != 0)) + (unsigned long int)!(!(sendSupportedEncodings != 0)) + (unsigned long int)!(!(sendServerIdentity != 0))) >> 8 & 0xff;
      }

      else
      {
        return_value_sraRgnCountRects_16=sraRgnCountRects(updateCopyRegion);
        tmp_if_expr_17 = (signed int)(unsigned short int)(return_value_sraRgnCountRects_16 + (unsigned long int)nUpdateRegionRects + (unsigned long int)!(!(sendCursorShape != 0)) + (unsigned long int)!(!(sendCursorPos != 0)) + (unsigned long int)!(!(sendKeyboardLedState != 0)) + (unsigned long int)!(!(sendSupportedMessages != 0)) + (unsigned long int)!(!(sendSupportedEncodings != 0)) + (unsigned long int)!(!(sendServerIdentity != 0)));
      }
      fu->nRects = (unsigned short int)tmp_if_expr_17;
    }

    else
      fu->nRects = (unsigned short int)0xFFFF;
    cl->ublen = 4;
    if(!(sendCursorShape == 0))
    {
      cl->cursorWasChanged = (signed char)0;
      signed char return_value_rfbSendCursorShape_18;
      return_value_rfbSendCursorShape_18=rfbSendCursorShape(cl);
      if(return_value_rfbSendCursorShape_18 == 0)
        goto updateFailed;

    }

    if(!(sendCursorPos == 0))
    {
      cl->cursorWasMoved = (signed char)0;
      signed char return_value_rfbSendCursorPos_19;
      return_value_rfbSendCursorPos_19=rfbSendCursorPos(cl);
      if(return_value_rfbSendCursorPos_19 == 0)
        goto updateFailed;

    }

    if(!(sendKeyboardLedState == 0))
    {
      signed char return_value_rfbSendKeyboardLedState_20;
      return_value_rfbSendKeyboardLedState_20=rfbSendKeyboardLedState(cl);
      if(return_value_rfbSendKeyboardLedState_20 == 0)
        goto updateFailed;

    }

    if(!(sendSupportedMessages == 0))
    {
      signed char return_value_rfbSendSupportedMessages_21;
      return_value_rfbSendSupportedMessages_21=rfbSendSupportedMessages(cl);
      if(return_value_rfbSendSupportedMessages_21 == 0)
        goto updateFailed;

    }

    if(!(sendSupportedEncodings == 0))
    {
      signed char return_value_rfbSendSupportedEncodings_22;
      return_value_rfbSendSupportedEncodings_22=rfbSendSupportedEncodings(cl);
      if(return_value_rfbSendSupportedEncodings_22 == 0)
        goto updateFailed;

    }

    if(!(sendServerIdentity == 0))
    {
      signed char return_value_rfbSendServerIdentity_23;
      return_value_rfbSendServerIdentity_23=rfbSendServerIdentity(cl);
      if(return_value_rfbSendServerIdentity_23 == 0)
        goto updateFailed;

    }

    signed char return_value_sraRgnEmpty_25;
    return_value_sraRgnEmpty_25=sraRgnEmpty(updateCopyRegion);
    if(return_value_sraRgnEmpty_25 == 0)
    {
      signed char return_value_rfbSendCopyRegion_24;
      return_value_rfbSendCopyRegion_24=rfbSendCopyRegion(cl, updateCopyRegion, dx, dy);
      if(return_value_rfbSendCopyRegion_24 == 0)
        goto updateFailed;

    }

    i=sraRgnGetIterator(updateRegion);
    do
    {
      return_value_sraRgnIteratorNext_26=sraRgnIteratorNext(i, &rfbSendFramebufferUpdate__1__rect);
      if(return_value_sraRgnIteratorNext_26 == 0)
        break;

      signed int rfbSendFramebufferUpdate__1__24__1__x = rfbSendFramebufferUpdate__1__rect.x1;
      signed int rfbSendFramebufferUpdate__1__24__1__y = rfbSendFramebufferUpdate__1__rect.y1;
      signed int rfbSendFramebufferUpdate__1__24__1__w = rfbSendFramebufferUpdate__1__rect.x2 - rfbSendFramebufferUpdate__1__24__1__x;
      signed int rfbSendFramebufferUpdate__1__24__1__h = rfbSendFramebufferUpdate__1__rect.y2 - rfbSendFramebufferUpdate__1__24__1__y;
      if(!(cl->screen == cl->scaledScreen))
        rfbScaledCorrection(cl->screen, cl->scaledScreen, &rfbSendFramebufferUpdate__1__24__1__x, &rfbSendFramebufferUpdate__1__24__1__y, &rfbSendFramebufferUpdate__1__24__1__w, &rfbSendFramebufferUpdate__1__24__1__h, "rfbSendFramebufferUpdate");

      if(!(cl->preferredEncoding == 0) && !(cl->preferredEncoding == -1))
      {
        if(cl->preferredEncoding == 2)
          goto __CPROVER_DUMP_L60;

        if(cl->preferredEncoding == 4)
          goto __CPROVER_DUMP_L61;

        if(cl->preferredEncoding == 5)
          goto __CPROVER_DUMP_L62;

        if(cl->preferredEncoding == 9)
          goto __CPROVER_DUMP_L63;

        if(cl->preferredEncoding == 6)
          goto __CPROVER_DUMP_L64;

        if(cl->preferredEncoding == 16 || cl->preferredEncoding == 17)
          goto __CPROVER_DUMP_L65;

        if(cl->preferredEncoding == 7)
          goto __CPROVER_DUMP_L66;

      }

      else
      {
        signed char return_value_rfbSendRectEncodingRaw_27;
        return_value_rfbSendRectEncodingRaw_27=rfbSendRectEncodingRaw(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingRaw_27 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L60:
        ;
        signed char return_value_rfbSendRectEncodingRRE_28;
        return_value_rfbSendRectEncodingRRE_28=rfbSendRectEncodingRRE(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingRRE_28 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L61:
        ;
        signed char return_value_rfbSendRectEncodingCoRRE_29;
        return_value_rfbSendRectEncodingCoRRE_29=rfbSendRectEncodingCoRRE(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingCoRRE_29 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L62:
        ;
        signed char return_value_rfbSendRectEncodingHextile_30;
        return_value_rfbSendRectEncodingHextile_30=rfbSendRectEncodingHextile(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingHextile_30 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L63:
        ;
        signed char return_value_rfbSendRectEncodingUltra_31;
        return_value_rfbSendRectEncodingUltra_31=rfbSendRectEncodingUltra(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingUltra_31 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L64:
        ;
        signed char return_value_rfbSendRectEncodingZlib_32;
        return_value_rfbSendRectEncodingZlib_32=rfbSendRectEncodingZlib(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingZlib_32 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L65:
        ;
        signed char return_value_rfbSendRectEncodingZRLE_33;
        return_value_rfbSendRectEncodingZRLE_33=rfbSendRectEncodingZRLE(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingZRLE_33 == 0)
          goto updateFailed;

        goto __CPROVER_DUMP_L67;

      __CPROVER_DUMP_L66:
        ;
        signed char return_value_rfbSendRectEncodingTight_34;
        return_value_rfbSendRectEncodingTight_34=rfbSendRectEncodingTight(cl, rfbSendFramebufferUpdate__1__24__1__x, rfbSendFramebufferUpdate__1__24__1__y, rfbSendFramebufferUpdate__1__24__1__w, rfbSendFramebufferUpdate__1__24__1__h);
        if(return_value_rfbSendRectEncodingTight_34 == 0)
          goto updateFailed;

      }

    __CPROVER_DUMP_L67:
      ;
    }
    while((_Bool)1);
    if(!(i == ((struct sraRectangleIterator *)NULL)))
    {
      sraRgnReleaseIterator(i);
      i = (struct sraRectangleIterator *)(void *)0;
    }

    if(nUpdateRegionRects == 0xFFFF)
    {
      return_value_rfbSendLastRectMarker_35=rfbSendLastRectMarker(cl);
      if(return_value_rfbSendLastRectMarker_35 == 0)
        goto updateFailed;

    }

    signed char return_value_rfbSendUpdateBuf_36;
    return_value_rfbSendUpdateBuf_36=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_36 == 0)
    {

    updateFailed:
      ;
      result = (signed char)0;
    }

    if(cl->enableCursorShapeUpdates == 0)
      rfbHideCursor(cl);

    if(!(i == ((struct sraRectangleIterator *)NULL)))
      sraRgnReleaseIterator(i);

    sraRgnDestroy(updateRegion);
    sraRgnDestroy(updateCopyRegion);
    if(!(cl->screen->displayFinishedHook == ((void (*)(struct _rfbClientRec *, signed int))NULL)))
      cl->screen->displayFinishedHook(cl, (signed int)result);

    return result;
  }
}

// rfbSendInteractionCaps
// file tightvnc-filetransfer/rfbtightserver.c line 271
void rfbSendInteractionCaps(struct _rfbClientRec *cl)
{
  struct _rfbInteractionCapsMsg intr_caps;
  struct _rfbCapabilityInfo smsg_list[4l];
  struct _rfbCapabilityInfo cmsg_list[6l];
  struct _rfbCapabilityInfo enc_list[12l];
  signed int i;
  signed int n_enc_caps = 12;
  intr_caps.nServerMessageTypes = (unsigned short int)(rfbEndianTest != 0 ? (4 & 0xff) << 8 | 4 >> 8 & 0xff : 4);
  intr_caps.nClientMessageTypes = (unsigned short int)(rfbEndianTest != 0 ? (6 & 0xff) << 8 | 6 >> 8 & 0xff : 6);
  intr_caps.nEncodingTypes = (unsigned short int)(rfbEndianTest != 0 ? (12 & 0xff) << 8 | 12 >> 8 & 0xff : 12);
  intr_caps.pad = (unsigned short int)0;
  rfbLog("tightvnc-filetransfer/rfbSendInteractionCaps\n");
  i = 0;
  signed char return_value_IsFileTransferEnabled_5;
  return_value_IsFileTransferEnabled_5=IsFileTransferEnabled();
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int tmp_post_13;
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed int tmp_post_16;
  signed int tmp_post_17;
  signed int tmp_post_18;
  signed int tmp_post_19;
  signed int tmp_post_20;
  signed int tmp_post_21;
  signed int tmp_post_22;
  signed int tmp_post_23;
  signed int tmp_post_24;
  _Bool tmp_if_expr_27;
  signed int return_value_rfbWriteExact_26;
  _Bool tmp_if_expr_29;
  signed int return_value_rfbWriteExact_28;
  _Bool tmp_if_expr_31;
  signed int return_value_rfbWriteExact_30;
  if((signed int)return_value_IsFileTransferEnabled_5 == -1)
  {
    struct _rfbCapabilityInfo *pcap;
    tmp_post_1 = i;
    i = i + 1;
    pcap = &smsg_list[(signed long int)tmp_post_1];
    pcap->code = (unsigned int)(rfbEndianTest != 0 ? 130 >> 24 | (130 & 0x00ff0000) >> 8 | (130 & 0x0000ff00) << 8 | 130 << 24 : 130);
    memcpy((void *)pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
    memcpy((void *)pcap->nameSignature, (const void *)"FTS_LSDT", (unsigned long int)8);
    struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__1__2__pcap;
    tmp_post_2 = i;
    i = i + 1;
    rfbSendInteractionCaps__1__1__2__pcap = &smsg_list[(signed long int)tmp_post_2];
    rfbSendInteractionCaps__1__1__2__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 131 >> 24 | (131 & 0x00ff0000) >> 8 | (131 & 0x0000ff00) << 8 | 131 << 24 : 131);
    memcpy((void *)rfbSendInteractionCaps__1__1__2__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
    memcpy((void *)rfbSendInteractionCaps__1__1__2__pcap->nameSignature, (const void *)"FTS_DNDT", (unsigned long int)8);
    struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__1__3__pcap;
    tmp_post_3 = i;
    i = i + 1;
    rfbSendInteractionCaps__1__1__3__pcap = &smsg_list[(signed long int)tmp_post_3];
    rfbSendInteractionCaps__1__1__3__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 132 >> 24 | (132 & 0x00ff0000) >> 8 | (132 & 0x0000ff00) << 8 | 132 << 24 : 132);
    memcpy((void *)rfbSendInteractionCaps__1__1__3__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
    memcpy((void *)rfbSendInteractionCaps__1__1__3__pcap->nameSignature, (const void *)"FTS_UPCN", (unsigned long int)8);
    struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__1__4__pcap;
    tmp_post_4 = i;
    i = i + 1;
    rfbSendInteractionCaps__1__1__4__pcap = &smsg_list[(signed long int)tmp_post_4];
    rfbSendInteractionCaps__1__1__4__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 133 >> 24 | (133 & 0x00ff0000) >> 8 | (133 & 0x0000ff00) << 8 | 133 << 24 : 133);
    memcpy((void *)rfbSendInteractionCaps__1__1__4__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
    memcpy((void *)rfbSendInteractionCaps__1__1__4__pcap->nameSignature, (const void *)"FTS_DNFL", (unsigned long int)8);
    rfbLog("rfbSendInteractionCaps: assertion failed, i != N_SMSG_CAPS\n");
    rfbCloseClient(cl);
  }

  else
  {
    i = 0;
    signed char return_value_IsFileTransferEnabled_12;
    return_value_IsFileTransferEnabled_12=IsFileTransferEnabled();
    if((signed int)return_value_IsFileTransferEnabled_12 == -1)
    {
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__2__1__pcap;
      tmp_post_6 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__2__1__pcap = &cmsg_list[(signed long int)tmp_post_6];
      rfbSendInteractionCaps__1__2__1__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 130 >> 24 | (130 & 0x00ff0000) >> 8 | (130 & 0x0000ff00) << 8 | 130 << 24 : 130);
      memcpy((void *)rfbSendInteractionCaps__1__2__1__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__2__1__pcap->nameSignature, (const void *)"FTC_LSRQ", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__2__2__pcap;
      tmp_post_7 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__2__2__pcap = &cmsg_list[(signed long int)tmp_post_7];
      rfbSendInteractionCaps__1__2__2__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 131 >> 24 | (131 & 0x00ff0000) >> 8 | (131 & 0x0000ff00) << 8 | 131 << 24 : 131);
      memcpy((void *)rfbSendInteractionCaps__1__2__2__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__2__2__pcap->nameSignature, (const void *)"FTC_DNRQ", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__2__3__pcap;
      tmp_post_8 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__2__3__pcap = &cmsg_list[(signed long int)tmp_post_8];
      rfbSendInteractionCaps__1__2__3__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 132 >> 24 | (132 & 0x00ff0000) >> 8 | (132 & 0x0000ff00) << 8 | 132 << 24 : 132);
      memcpy((void *)rfbSendInteractionCaps__1__2__3__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__2__3__pcap->nameSignature, (const void *)"FTC_UPRQ", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__2__4__pcap;
      tmp_post_9 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__2__4__pcap = &cmsg_list[(signed long int)tmp_post_9];
      rfbSendInteractionCaps__1__2__4__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 133 >> 24 | (133 & 0x00ff0000) >> 8 | (133 & 0x0000ff00) << 8 | 133 << 24 : 133);
      memcpy((void *)rfbSendInteractionCaps__1__2__4__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__2__4__pcap->nameSignature, (const void *)"FTC_UPDT", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__2__5__pcap;
      tmp_post_10 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__2__5__pcap = &cmsg_list[(signed long int)tmp_post_10];
      rfbSendInteractionCaps__1__2__5__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 134 >> 24 | (134 & 0x00ff0000) >> 8 | (134 & 0x0000ff00) << 8 | 134 << 24 : 134);
      memcpy((void *)rfbSendInteractionCaps__1__2__5__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__2__5__pcap->nameSignature, (const void *)"FTC_DNCN", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__2__6__pcap;
      tmp_post_11 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__2__6__pcap = &cmsg_list[(signed long int)tmp_post_11];
      rfbSendInteractionCaps__1__2__6__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 135 >> 24 | (135 & 0x00ff0000) >> 8 | (135 & 0x0000ff00) << 8 | 135 << 24 : 135);
      memcpy((void *)rfbSendInteractionCaps__1__2__6__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__2__6__pcap->nameSignature, (const void *)"FTC_UPFL", (unsigned long int)8);
      rfbLog("rfbSendInteractionCaps: assertion failed, i != N_CMSG_CAPS\n");
      rfbCloseClient(cl);
    }

    else
    {
      i = 0;
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__3__pcap;
      tmp_post_13 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__3__pcap = &enc_list[(signed long int)tmp_post_13];
      rfbSendInteractionCaps__1__3__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 1 >> 24 | (1 & 0x00ff0000) >> 8 | (1 & 0x0000ff00) << 8 | 1 << 24 : 1);
      memcpy((void *)rfbSendInteractionCaps__1__3__pcap->vendorSignature, (const void *)"STDV", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__3__pcap->nameSignature, (const void *)"COPYRECT", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__4__pcap;
      tmp_post_14 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__4__pcap = &enc_list[(signed long int)tmp_post_14];
      rfbSendInteractionCaps__1__4__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 2 >> 24 | (2 & 0x00ff0000) >> 8 | (2 & 0x0000ff00) << 8 | 2 << 24 : 2);
      memcpy((void *)rfbSendInteractionCaps__1__4__pcap->vendorSignature, (const void *)"STDV", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__4__pcap->nameSignature, (const void *)"RRE_____", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__5__pcap;
      tmp_post_15 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__5__pcap = &enc_list[(signed long int)tmp_post_15];
      rfbSendInteractionCaps__1__5__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 4 >> 24 | (4 & 0x00ff0000) >> 8 | (4 & 0x0000ff00) << 8 | 4 << 24 : 4);
      memcpy((void *)rfbSendInteractionCaps__1__5__pcap->vendorSignature, (const void *)"STDV", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__5__pcap->nameSignature, (const void *)"CORRE___", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__6__pcap;
      tmp_post_16 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__6__pcap = &enc_list[(signed long int)tmp_post_16];
      rfbSendInteractionCaps__1__6__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 5 >> 24 | (5 & 0x00ff0000) >> 8 | (5 & 0x0000ff00) << 8 | 5 << 24 : 5);
      memcpy((void *)rfbSendInteractionCaps__1__6__pcap->vendorSignature, (const void *)"STDV", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__6__pcap->nameSignature, (const void *)"HEXTILE_", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__7__pcap;
      tmp_post_17 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__7__pcap = &enc_list[(signed long int)tmp_post_17];
      rfbSendInteractionCaps__1__7__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 6 >> 24 | (6 & 0x00ff0000) >> 8 | (6 & 0x0000ff00) << 8 | 6 << 24 : 6);
      memcpy((void *)rfbSendInteractionCaps__1__7__pcap->vendorSignature, (const void *)"TRDV", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__7__pcap->nameSignature, (const void *)"ZLIB____", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__8__pcap;
      tmp_post_18 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__8__pcap = &enc_list[(signed long int)tmp_post_18];
      rfbSendInteractionCaps__1__8__pcap->code = (unsigned int)(rfbEndianTest != 0 ? 7 >> 24 | (7 & 0x00ff0000) >> 8 | (7 & 0x0000ff00) << 8 | 7 << 24 : 7);
      memcpy((void *)rfbSendInteractionCaps__1__8__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__8__pcap->nameSignature, (const void *)"TIGHT___", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__9__pcap;
      tmp_post_19 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__9__pcap = &enc_list[(signed long int)tmp_post_19];
      rfbSendInteractionCaps__1__9__pcap->code = rfbEndianTest != 0 ? 0xFFFFFF00 >> 24 | (0xFFFFFF00 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF00 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF00 << 24 : 0xFFFFFF00;
      memcpy((void *)rfbSendInteractionCaps__1__9__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__9__pcap->nameSignature, (const void *)"COMPRLVL", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__10__pcap;
      tmp_post_20 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__10__pcap = &enc_list[(signed long int)tmp_post_20];
      rfbSendInteractionCaps__1__10__pcap->code = rfbEndianTest != 0 ? 0xFFFFFFE0 >> 24 | (0xFFFFFFE0 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFFE0 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFFE0 << 24 : 0xFFFFFFE0;
      memcpy((void *)rfbSendInteractionCaps__1__10__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__10__pcap->nameSignature, (const void *)"JPEGQLVL", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__11__pcap;
      tmp_post_21 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__11__pcap = &enc_list[(signed long int)tmp_post_21];
      rfbSendInteractionCaps__1__11__pcap->code = rfbEndianTest != 0 ? 0xFFFFFF10 >> 24 | (0xFFFFFF10 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF10 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF10 << 24 : 0xFFFFFF10;
      memcpy((void *)rfbSendInteractionCaps__1__11__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__11__pcap->nameSignature, (const void *)"X11CURSR", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__12__pcap;
      tmp_post_22 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__12__pcap = &enc_list[(signed long int)tmp_post_22];
      rfbSendInteractionCaps__1__12__pcap->code = rfbEndianTest != 0 ? 0xFFFFFF11 >> 24 | (0xFFFFFF11 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF11 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF11 << 24 : 0xFFFFFF11;
      memcpy((void *)rfbSendInteractionCaps__1__12__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__12__pcap->nameSignature, (const void *)"RCHCURSR", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__13__pcap;
      tmp_post_23 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__13__pcap = &enc_list[(signed long int)tmp_post_23];
      rfbSendInteractionCaps__1__13__pcap->code = rfbEndianTest != 0 ? 0xFFFFFF18 >> 24 | (0xFFFFFF18 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF18 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF18 << 24 : 0xFFFFFF18;
      memcpy((void *)rfbSendInteractionCaps__1__13__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__13__pcap->nameSignature, (const void *)"POINTPOS", (unsigned long int)8);
      struct _rfbCapabilityInfo *rfbSendInteractionCaps__1__14__pcap;
      tmp_post_24 = i;
      i = i + 1;
      rfbSendInteractionCaps__1__14__pcap = &enc_list[(signed long int)tmp_post_24];
      rfbSendInteractionCaps__1__14__pcap->code = rfbEndianTest != 0 ? 0xFFFFFF20 >> 24 | (0xFFFFFF20 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF20 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF20 << 24 : 0xFFFFFF20;
      memcpy((void *)rfbSendInteractionCaps__1__14__pcap->vendorSignature, (const void *)"TGHT", (unsigned long int)4);
      memcpy((void *)rfbSendInteractionCaps__1__14__pcap->nameSignature, (const void *)"LASTRECT", (unsigned long int)8);
      if(!(i == n_enc_caps))
      {
        rfbLog("rfbSendInteractionCaps: assertion failed, i != N_ENC_CAPS\n");
        rfbCloseClient(cl);
      }

      else
      {
        signed int return_value_rfbWriteExact_25;
        return_value_rfbWriteExact_25=rfbWriteExact(cl, (char *)&intr_caps, 8);
        if(!(return_value_rfbWriteExact_25 >= 0))
          tmp_if_expr_27 = (_Bool)1;

        else
        {
          return_value_rfbWriteExact_26=rfbWriteExact(cl, (char *)&smsg_list[(signed long int)0], 16 * 4);
          tmp_if_expr_27 = return_value_rfbWriteExact_26 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_27)
          tmp_if_expr_29 = (_Bool)1;

        else
        {
          return_value_rfbWriteExact_28=rfbWriteExact(cl, (char *)&cmsg_list[(signed long int)0], 16 * 6);
          tmp_if_expr_29 = return_value_rfbWriteExact_28 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_29)
          tmp_if_expr_31 = (_Bool)1;

        else
        {
          return_value_rfbWriteExact_30=rfbWriteExact(cl, (char *)&enc_list[(signed long int)0], 16 * 12);
          tmp_if_expr_31 = return_value_rfbWriteExact_30 < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_31)
        {
          rfbLogPerror("rfbSendInteractionCaps: write");
          rfbCloseClient(cl);
        }

        else
          cl->state = (enum anonymous_13)RFB_NORMAL;
      }
    }
  }
}

// rfbSendKeyboardLedState
// file rfbserver.c line 886
signed char rfbSendKeyboardLedState(struct _rfbClientRec *cl)
{
  struct anonymous_2 rect;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.encoding = rfbEndianTest != 0 ? 0xFFFE0000 >> 24 | (0xFFFE0000 & (unsigned int)0x00ff0000) >> 8 | (0xFFFE0000 & (unsigned int)0x0000ff00) << 8 | 0xFFFE0000 << 24 : 0xFFFE0000;
  signed int tmp_if_expr_2;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_2 = (cl->lastKeyboardLedState & 0xff) << 8 | cl->lastKeyboardLedState >> 8 & 0xff;

  else
    tmp_if_expr_2 = cl->lastKeyboardLedState;
  rect.r.x = (unsigned short int)tmp_if_expr_2;
  rect.r.y = (unsigned short int)0;
  rect.r.w = (unsigned short int)0;
  rect.r.h = (unsigned short int)0;
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, 0xFFFE0000, 8 + 4, 8 + 4);
  signed char return_value_rfbSendUpdateBuf_3;
  return_value_rfbSendUpdateBuf_3=rfbSendUpdateBuf(cl);
  if(return_value_rfbSendUpdateBuf_3 == 0)
    return (signed char)0;

  else
    return (signed char)-1;
}

// rfbSendLastRectMarker
// file rfbserver.c line 3310
extern signed char rfbSendLastRectMarker(struct _rfbClientRec *cl)
{
  struct anonymous_2 rect;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.encoding = rfbEndianTest != 0 ? 0xFFFFFF20 >> 24 | (0xFFFFFF20 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF20 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF20 << 24 : 0xFFFFFF20;
  rect.r.x = (unsigned short int)0;
  rect.r.y = (unsigned short int)0;
  rect.r.w = (unsigned short int)0;
  rect.r.h = (unsigned short int)0;
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, 0xFFFFFF20, 8 + 4, 8 + 4);
  return (signed char)-1;
}

// rfbSendNewFBSize
// file rfbserver.c line 3341
extern signed char rfbSendNewFBSize(struct _rfbClientRec *cl, signed int w, signed int h)
{
  struct anonymous_2 rect;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  if((signed int)cl->PalmVNC == -1)
    rfbLog("Sending rfbEncodingNewFBSize in response to a PalmVNC style framebuffer resize (%dx%d)\n", w, h);

  else
    rfbLog("Sending rfbEncodingNewFBSize for resize to (%dx%d)\n", w, h);
  rect.encoding = rfbEndianTest != 0 ? 0xFFFFFF21 >> 24 | (0xFFFFFF21 & (unsigned int)0x00ff0000) >> 8 | (0xFFFFFF21 & (unsigned int)0x0000ff00) << 8 | 0xFFFFFF21 << 24 : 0xFFFFFF21;
  rect.r.x = (unsigned short int)0;
  rect.r.y = (unsigned short int)0;
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, 0xFFFFFF21, 8 + 4, 8 + 4);
  return (signed char)-1;
}

// rfbSendNewScaleSize
// file ./scale.h line 10
signed int rfbSendNewScaleSize(struct _rfbClientRec *cl)
{
  signed int tmp_if_expr_1;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  if(!(cl->useNewFBSize == 0))
  {
    if(cl->newFBSizePending == 0)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    pthread_mutex_lock(&cl->updateMutex);
    cl->newFBSizePending = (signed char)0;
    pthread_mutex_unlock(&cl->updateMutex);
    if((signed int)cl->PalmVNC == -1)
    {
      struct anonymous_8 pmsg;
      pmsg.type = (unsigned char)0xF;
      pmsg.pad1 = (unsigned char)0;
      if(!(rfbEndianTest == 0))
        tmp_if_expr_1 = (cl->screen->width & 0xff) << 8 | cl->screen->width >> 8 & 0xff;

      else
        tmp_if_expr_1 = cl->screen->width;
      pmsg.desktop_w = (unsigned short int)tmp_if_expr_1;
      if(!(rfbEndianTest == 0))
        tmp_if_expr_2 = (cl->screen->height & 0xff) << 8 | cl->screen->height >> 8 & 0xff;

      else
        tmp_if_expr_2 = cl->screen->height;
      pmsg.desktop_h = (unsigned short int)tmp_if_expr_2;
      if(!(rfbEndianTest == 0))
        tmp_if_expr_3 = (cl->scaledScreen->width & 0xff) << 8 | cl->scaledScreen->width >> 8 & 0xff;

      else
        tmp_if_expr_3 = cl->scaledScreen->width;
      pmsg.buffer_w = (unsigned short int)tmp_if_expr_3;
      if(!(rfbEndianTest == 0))
        tmp_if_expr_4 = (cl->scaledScreen->height & 0xff) << 8 | cl->scaledScreen->height >> 8 & 0xff;

      else
        tmp_if_expr_4 = cl->scaledScreen->height;
      pmsg.buffer_h = (unsigned short int)tmp_if_expr_4;
      pmsg.pad2 = (unsigned short int)0;
      rfbLog("Sending a response to a PalmVNC style frameuffer resize event (%dx%d)\n", cl->scaledScreen->width, cl->scaledScreen->height);
      signed int return_value_rfbWriteExact_5;
      return_value_rfbWriteExact_5=rfbWriteExact(cl, (char *)&pmsg, 12);
      if(!(return_value_rfbWriteExact_5 >= 0))
      {
        rfbLogPerror("rfbNewClient: write");
        rfbCloseClient(cl);
        return 0;
      }

    }

    else
    {
      struct _rfbResizeFrameBufferMsg rmsg;
      rmsg.type = (unsigned char)4;
      rmsg.pad1 = (unsigned char)0;
      if(!(rfbEndianTest == 0))
        tmp_if_expr_6 = (cl->scaledScreen->width & 0xff) << 8 | cl->scaledScreen->width >> 8 & 0xff;

      else
        tmp_if_expr_6 = cl->scaledScreen->width;
      rmsg.framebufferWidth = (unsigned short int)tmp_if_expr_6;
      if(!(rfbEndianTest == 0))
        tmp_if_expr_7 = (cl->scaledScreen->height & 0xff) << 8 | cl->scaledScreen->height >> 8 & 0xff;

      else
        tmp_if_expr_7 = cl->scaledScreen->height;
      rmsg.framebufferHeigth = (unsigned short int)tmp_if_expr_7;
      rfbLog("Sending a response to a UltraVNC style frameuffer resize event (%dx%d)\n", cl->scaledScreen->width, cl->scaledScreen->height);
      signed int return_value_rfbWriteExact_8;
      return_value_rfbWriteExact_8=rfbWriteExact(cl, (char *)&rmsg, 6);
      if(!(return_value_rfbWriteExact_8 >= 0))
      {
        rfbLogPerror("rfbNewClient: write");
        rfbCloseClient(cl);
        return 0;
      }

    }
    return -1;
  }
}

// rfbSendOneRectEncodingUltra
// file ultra.c line 39
static signed char rfbSendOneRectEncodingUltra(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  struct anonymous_3 hdr;
  signed int deflateResult;
  signed int i;
  char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
  signed int maxRawSize;
  unsigned long int maxCompSize;
  maxRawSize = w * h * ((signed int)cl->format.bitsPerPixel / 8);
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(!(cl->beforeEncBufSize >= maxRawSize))
  {
    cl->beforeEncBufSize = maxRawSize;
    if(cl->beforeEncBuf == ((char *)NULL))
    {
      return_value_malloc_1=malloc((unsigned long int)cl->beforeEncBufSize);
      cl->beforeEncBuf = (char *)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)cl->beforeEncBuf, (unsigned long int)cl->beforeEncBufSize);
      cl->beforeEncBuf = (char *)return_value_realloc_2;
    }
  }

  maxCompSize = (unsigned long int)(maxRawSize + maxRawSize / 16 + 64 + 3);
  void *return_value_malloc_3;
  void *return_value_realloc_4;
  if(!(cl->afterEncBufSize >= (signed int)maxCompSize))
  {
    cl->afterEncBufSize = (signed int)maxCompSize;
    if(cl->afterEncBuf == ((char *)NULL))
    {
      return_value_malloc_3=malloc((unsigned long int)cl->afterEncBufSize);
      cl->afterEncBuf = (char *)return_value_malloc_3;
    }

    else
    {
      return_value_realloc_4=realloc((void *)cl->afterEncBuf, (unsigned long int)cl->afterEncBufSize);
      cl->afterEncBuf = (char *)return_value_realloc_4;
    }
  }

  cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, cl->beforeEncBuf, cl->scaledScreen->paddedWidthInBytes, w, h);
  if((signed int)cl->compStreamInitedLZO == 0)
  {
    cl->compStreamInitedLZO = (signed char)-1;
    void *return_value_malloc_5;
    return_value_malloc_5=malloc(sizeof(union anonymous_6) /*8ul*/  * (((unsigned long int)(unsigned int)(16384L * (signed long int)(unsigned int)sizeof(unsigned char *) /*8ul*/ ) + (sizeof(union anonymous_6) /*8ul*/  - (unsigned long int)1)) / sizeof(union anonymous_6) /*8ul*/ ));
    cl->lzoWrkMem = (char *)return_value_malloc_5;
  }

  deflateResult=lzo1x_1_compress((unsigned char *)cl->beforeEncBuf, (unsigned long int)(w * h * ((signed int)cl->format.bitsPerPixel / 8)), (unsigned char *)cl->afterEncBuf, &maxCompSize, (void *)cl->lzoWrkMem);
  cl->afterEncBufLen = (signed int)maxCompSize;
  signed int tmp_if_expr_7;
  if(!(deflateResult == 0))
  {
    rfbErr("lzo deflation error: %d\n", deflateResult);
    return (signed char)0;
  }

  else
  {
    rfbStatRecordEncodingSent(cl, (unsigned int)9, 8 + 4 + 4 + cl->afterEncBufLen, maxRawSize);
    if(4 + cl->ublen >= 30001)
    {
      signed char return_value_rfbSendUpdateBuf_6;
      return_value_rfbSendUpdateBuf_6=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_6 == 0)
        return (signed char)0;

    }

    rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
    rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
    rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
    rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
    rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 9 >> 24 | (9 & 0x00ff0000) >> 8 | (9 & 0x0000ff00) << 8 | 9 << 24 : 9);
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
    cl->ublen = cl->ublen + 8 + 4;
    if(!(rfbEndianTest == 0))
      tmp_if_expr_7 = cl->afterEncBufLen >> 24 | (cl->afterEncBufLen & 0x00ff0000) >> 8 | (cl->afterEncBufLen & 0x0000ff00) << 8 | cl->afterEncBufLen << 24;

    else
      tmp_if_expr_7 = cl->afterEncBufLen;
    hdr.nBytes = (unsigned int)tmp_if_expr_7;
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&hdr, (unsigned long int)4);
    cl->ublen = cl->ublen + 4;
    i = 0;
    if(!(i >= cl->afterEncBufLen))
    {
      signed int bytesToCopy = 30000 - cl->ublen;
      if(!(cl->afterEncBufLen >= bytesToCopy + i))
        bytesToCopy = cl->afterEncBufLen - i;

      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)&cl->afterEncBuf[(signed long int)i], (unsigned long int)bytesToCopy);
      cl->ublen = cl->ublen + bytesToCopy;
      i = i + bytesToCopy;
      if(cl->ublen == 30000)
      {
        signed char return_value_rfbSendUpdateBuf_8;
        return_value_rfbSendUpdateBuf_8=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_8 == 0)
          return (signed char)0;

      }

    }

    return (signed char)-1;
  }
}

// rfbSendOneRectEncodingZlib
// file zlib.c line 81
static signed char rfbSendOneRectEncodingZlib(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  struct anonymous_3 hdr;
  signed int deflateResult;
  signed int previousOut;
  signed int i;
  char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
  signed int maxRawSize;
  signed int maxCompSize;
  maxRawSize = cl->scaledScreen->width * cl->scaledScreen->height * ((signed int)cl->format.bitsPerPixel / 8);
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(!(zlibBeforeBufSize >= maxRawSize))
  {
    zlibBeforeBufSize = maxRawSize;
    if(zlibBeforeBuf == ((char *)NULL))
    {
      return_value_malloc_1=malloc((unsigned long int)zlibBeforeBufSize);
      zlibBeforeBuf = (char *)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)zlibBeforeBuf, (unsigned long int)zlibBeforeBufSize);
      zlibBeforeBuf = (char *)return_value_realloc_2;
    }
  }

  if(!((cl->scaledScreen->bitsPerPixel / 8) * h * w >= 17))
  {
    signed int result;
    if((signed int)cl->format.bitsPerPixel >= 9)
    {
      if(!(cl->ublen % ((signed int)cl->format.bitsPerPixel / 8) == 0))
      {
        signed char return_value_rfbSendUpdateBuf_3;
        return_value_rfbSendUpdateBuf_3=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_3 == 0)
          return (signed char)0;

      }

    }

    signed char return_value_rfbSendRectEncodingRaw_4;
    return_value_rfbSendRectEncodingRaw_4=rfbSendRectEncodingRaw(cl, x, y, w, h);
    result = (signed int)return_value_rfbSendRectEncodingRaw_4;
    return (signed char)result;
  }

  maxCompSize = maxRawSize + (maxRawSize + 99) / 100 + 12;
  void *return_value_malloc_5;
  void *return_value_realloc_6;
  if(!(zlibAfterBufSize >= maxCompSize))
  {
    zlibAfterBufSize = maxCompSize;
    if(zlibAfterBuf == ((char *)NULL))
    {
      return_value_malloc_5=malloc((unsigned long int)zlibAfterBufSize);
      zlibAfterBuf = (char *)return_value_malloc_5;
    }

    else
    {
      return_value_realloc_6=realloc((void *)zlibAfterBuf, (unsigned long int)zlibAfterBufSize);
      zlibAfterBuf = (char *)return_value_realloc_6;
    }
  }

  cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, zlibBeforeBuf, cl->scaledScreen->paddedWidthInBytes, w, h);
  cl->compStream.next_in = (unsigned char *)zlibBeforeBuf;
  cl->compStream.avail_in = (unsigned int)(w * h * ((signed int)cl->format.bitsPerPixel / 8));
  cl->compStream.next_out = (unsigned char *)zlibAfterBuf;
  cl->compStream.avail_out = (unsigned int)maxCompSize;
  cl->compStream.data_type = 0;
  if((signed int)cl->compStreamInited == 0)
  {
    cl->compStream.total_in = (unsigned long int)0;
    cl->compStream.total_out = (unsigned long int)0;
    cl->compStream.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
    cl->compStream.zfree = ((void (*)(void *, void *))NULL);
    cl->compStream.opaque = NULL;
    deflateInit2_(&cl->compStream, (signed int)cl->zlibCompressLevel, 8, 15, 9, 0, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
    cl->compStreamInited = (signed char)-1;
  }

  previousOut = (signed int)cl->compStream.total_out;
  deflateResult=deflate(&cl->compStream, 2);
  zlibAfterBufLen = (signed int)(cl->compStream.total_out - (unsigned long int)previousOut);
  if(!(deflateResult == 0))
  {
    rfbErr("zlib deflation error: %s\n", cl->compStream.msg);
    return (signed char)0;
  }

  else
  {
    rfbStatRecordEncodingSent(cl, (unsigned int)6, 8 + 4 + 4 + zlibAfterBufLen, +w * ((signed int)cl->format.bitsPerPixel / 8) * h);
    if(4 + cl->ublen >= 30001)
    {
      signed char return_value_rfbSendUpdateBuf_7;
      return_value_rfbSendUpdateBuf_7=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_7 == 0)
        return (signed char)0;

    }

    rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
    rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
    rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
    rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
    rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 6 >> 24 | (6 & 0x00ff0000) >> 8 | (6 & 0x0000ff00) << 8 | 6 << 24 : 6);
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
    cl->ublen = cl->ublen + 8 + 4;
    hdr.nBytes = (unsigned int)(rfbEndianTest != 0 ? zlibAfterBufLen >> 24 | (zlibAfterBufLen & 0x00ff0000) >> 8 | (zlibAfterBufLen & 0x0000ff00) << 8 | zlibAfterBufLen << 24 : zlibAfterBufLen);
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&hdr, (unsigned long int)4);
    cl->ublen = cl->ublen + 4;
    i = 0;
    if(!(i >= zlibAfterBufLen))
    {
      signed int bytesToCopy = 30000 - cl->ublen;
      if(!(zlibAfterBufLen >= bytesToCopy + i))
        bytesToCopy = zlibAfterBufLen - i;

      memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)&zlibAfterBuf[(signed long int)i], (unsigned long int)bytesToCopy);
      cl->ublen = cl->ublen + bytesToCopy;
      i = i + bytesToCopy;
      if(cl->ublen == 30000)
      {
        signed char return_value_rfbSendUpdateBuf_8;
        return_value_rfbSendUpdateBuf_8=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_8 == 0)
          return (signed char)0;

      }

    }

    return (signed char)-1;
  }
}

// rfbSendRectEncodingCoRRE
// file ../rfb/rfb.h line 847
extern signed char rfbSendRectEncodingCoRRE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  _Bool tmp_if_expr_3;
  signed char return_value_rfbSendRectEncodingCoRRE_2;
  if(!(cl->correMaxHeight >= h))
  {
    signed char return_value_rfbSendRectEncodingCoRRE_1;
    return_value_rfbSendRectEncodingCoRRE_1=rfbSendRectEncodingCoRRE(cl, x, y, w, cl->correMaxHeight);
    if(!(return_value_rfbSendRectEncodingCoRRE_1 == 0))
    {
      return_value_rfbSendRectEncodingCoRRE_2=rfbSendRectEncodingCoRRE(cl, x, y + cl->correMaxHeight, w, h - cl->correMaxHeight);
      tmp_if_expr_3 = return_value_rfbSendRectEncodingCoRRE_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    return (signed char)tmp_if_expr_3;
  }

  _Bool tmp_if_expr_6;
  signed char return_value_rfbSendRectEncodingCoRRE_5;
  if(!(cl->correMaxWidth >= w))
  {
    signed char return_value_rfbSendRectEncodingCoRRE_4;
    return_value_rfbSendRectEncodingCoRRE_4=rfbSendRectEncodingCoRRE(cl, x, y, cl->correMaxWidth, h);
    if(!(return_value_rfbSendRectEncodingCoRRE_4 == 0))
    {
      return_value_rfbSendRectEncodingCoRRE_5=rfbSendRectEncodingCoRRE(cl, x + cl->correMaxWidth, y, w - cl->correMaxWidth, h);
      tmp_if_expr_6 = return_value_rfbSendRectEncodingCoRRE_5 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    return (signed char)tmp_if_expr_6;
  }

  rfbSendSmallRectEncodingCoRRE(cl, x, y, w, h);
  return (signed char)-1;
}

// rfbSendRectEncodingHextile
// file ../rfb/rfb.h line 852
extern signed char rfbSendRectEncodingHextile(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
  rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 5 >> 24 | (5 & 0x00ff0000) >> 8 | (5 & 0x0000ff00) << 8 | 5 << 24 : 5);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, (unsigned int)5, 8 + 4, 8 + 4 + w * ((signed int)cl->format.bitsPerPixel / 8) * h);
  signed char return_value_sendHextiles8_2;
  signed char return_value_sendHextiles16_3;
  signed char return_value_sendHextiles32_4;
  switch((signed int)cl->format.bitsPerPixel)
  {
    case 8:
    {
      return_value_sendHextiles8_2=sendHextiles8(cl, x, y, w, h);
      return return_value_sendHextiles8_2;
    }
    case 16:
    {
      return_value_sendHextiles16_3=sendHextiles16(cl, x, y, w, h);
      return return_value_sendHextiles16_3;
    }
    case 32:
    {
      return_value_sendHextiles32_4=sendHextiles32(cl, x, y, w, h);
      return return_value_sendHextiles32_4;
    }
    default:
      rfbLog("rfbSendRectEncodingHextile: bpp %d?\n", cl->format.bitsPerPixel);
  }
  return (signed char)0;
}

// rfbSendRectEncodingRRE
// file ../rfb/rfb.h line 842
extern signed char rfbSendRectEncodingRRE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  struct anonymous_14 hdr;
  signed int nSubrects;
  signed int i;
  char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
  signed int maxRawSize = cl->scaledScreen->width * cl->scaledScreen->height * ((signed int)cl->format.bitsPerPixel / 8);
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(!(cl->beforeEncBufSize >= maxRawSize))
  {
    cl->beforeEncBufSize = maxRawSize;
    if(cl->beforeEncBuf == ((char *)NULL))
    {
      return_value_malloc_1=malloc((unsigned long int)cl->beforeEncBufSize);
      cl->beforeEncBuf = (char *)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)cl->beforeEncBuf, (unsigned long int)cl->beforeEncBufSize);
      cl->beforeEncBuf = (char *)return_value_realloc_2;
    }
  }

  void *return_value_malloc_3;
  void *return_value_realloc_4;
  if(!(cl->afterEncBufSize >= maxRawSize))
  {
    cl->afterEncBufSize = maxRawSize;
    if(cl->afterEncBuf == ((char *)NULL))
    {
      return_value_malloc_3=malloc((unsigned long int)cl->afterEncBufSize);
      cl->afterEncBuf = (char *)return_value_malloc_3;
    }

    else
    {
      return_value_realloc_4=realloc((void *)cl->afterEncBuf, (unsigned long int)cl->afterEncBufSize);
      cl->afterEncBuf = (char *)return_value_realloc_4;
    }
  }

  cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, cl->beforeEncBuf, cl->scaledScreen->paddedWidthInBytes, w, h);
  if((signed int)cl->format.bitsPerPixel == 8)
  {
    nSubrects=subrectEncode8_link2(cl, (unsigned char *)cl->beforeEncBuf, w, h);
    nSubrects=subrectEncode16_link2(cl, (unsigned short int *)cl->beforeEncBuf, w, h);
    nSubrects=subrectEncode32_link2(cl, (unsigned int *)cl->beforeEncBuf, w, h);
  }

  rfbLog("getBgColour: bpp %d?\n", cl->format.bitsPerPixel);
  return (signed char)0;
  if(!(nSubrects >= 0))
  {
    signed char return_value_rfbSendRectEncodingRaw_5;
    return_value_rfbSendRectEncodingRaw_5=rfbSendRectEncodingRaw(cl, x, y, w, h);
    return return_value_rfbSendRectEncodingRaw_5;
  }

  rfbStatRecordEncodingSent(cl, (unsigned int)2, 8 + 4 + 4 + cl->afterEncBufLen, 8 + 4 + w * h * ((signed int)cl->format.bitsPerPixel / 8));
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_6;
    return_value_rfbSendUpdateBuf_6=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_6 == 0)
      return (signed char)0;

  }

  rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
  rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 2 >> 24 | (2 & 0x00ff0000) >> 8 | (2 & 0x0000ff00) << 8 | 2 << 24 : 2);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  hdr.nSubrects = (unsigned int)(rfbEndianTest != 0 ? nSubrects >> 24 | (nSubrects & 0x00ff0000) >> 8 | (nSubrects & 0x0000ff00) << 8 | nSubrects << 24 : nSubrects);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&hdr, (unsigned long int)4);
  cl->ublen = cl->ublen + 4;
  i = 0;
  if(!(i >= cl->afterEncBufLen))
  {
    signed int bytesToCopy = 30000 - cl->ublen;
    if(!(cl->afterEncBufLen >= bytesToCopy + i))
      bytesToCopy = cl->afterEncBufLen - i;

    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)&cl->afterEncBuf[(signed long int)i], (unsigned long int)bytesToCopy);
    cl->ublen = cl->ublen + bytesToCopy;
    i = i + bytesToCopy;
    if(cl->ublen == 30000)
    {
      signed char return_value_rfbSendUpdateBuf_7;
      return_value_rfbSendUpdateBuf_7=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_7 == 0)
        return (signed char)0;

    }

  }

  return (signed char)-1;
}

// rfbSendRectEncodingRaw
// file rfbserver.c line 3235
extern signed char rfbSendRectEncodingRaw(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  signed int nlines;
  signed int bytesPerLine = w * ((signed int)cl->format.bitsPerPixel / 8);
  char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
  if(cl->ublen >= 1)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
  rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 0 >> 24 | (0 & 0x00ff0000) >> 8 | (0 & 0x0000ff00) << 8 | 0 << 24 : 0);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  rfbStatRecordEncodingSent(cl, (unsigned int)0, 8 + 4 + bytesPerLine * h, 8 + 4 + bytesPerLine * h);
  nlines = (30000 - cl->ublen) / bytesPerLine;
  {
    if(!(h >= nlines))
      nlines = h;

    cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, &cl->updateBuf[(signed long int)cl->ublen], cl->scaledScreen->paddedWidthInBytes, w, nlines);
    cl->ublen = cl->ublen + nlines * bytesPerLine;
    h = h - nlines;
    if(h == 0)
      return (signed char)-1;

    signed char return_value_rfbSendUpdateBuf_2;
    return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_2 == 0)
      return (signed char)0;

    fbptr = fbptr + (signed long int)(cl->scaledScreen->paddedWidthInBytes * nlines);
    nlines = (30000 - cl->ublen) / bytesPerLine;
    if(nlines == 0)
    {
      rfbErr("rfbSendRectEncodingRaw: send buffer too small for %d bytes per line\n", bytesPerLine);
      rfbCloseClient(cl);
      return (signed char)0;
    }

  }
}

// rfbSendRectEncodingTight
// file ../rfb/rfb.h line 895
extern signed char rfbSendRectEncodingTight(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  cl->tightEncoding = (unsigned int)7;
  signed char return_value_SendRectEncodingTight_1;
  return_value_SendRectEncodingTight_1=SendRectEncodingTight(cl, x, y, w, h);
  return return_value_SendRectEncodingTight_1;
}

// rfbSendRectEncodingTightPng
// file tight.c line 279
signed char rfbSendRectEncodingTightPng(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  cl->tightEncoding = 0xFFFFFEFC;
  signed char return_value_SendRectEncodingTight_1;
  return_value_SendRectEncodingTight_1=SendRectEncodingTight(cl, x, y, w, h);
  return return_value_SendRectEncodingTight_1;
}

// rfbSendRectEncodingUltra
// file ../rfb/rfb.h line 864
extern signed char rfbSendRectEncodingUltra(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int maxLines;
  signed int linesRemaining;
  struct anonymous_5 partialRect;
  partialRect.x = (unsigned short int)x;
  partialRect.y = (unsigned short int)y;
  partialRect.w = (unsigned short int)w;
  partialRect.h = (unsigned short int)h;
  maxLines = (w * 2 > 128 * 256 ? w * 2 : 128 * 256) / w;
  linesRemaining = h;
  while(linesRemaining >= 1)
  {
    signed int linesToComp;
    if(!(maxLines >= linesRemaining))
      linesToComp = maxLines;

    else
      linesToComp = linesRemaining;
    partialRect.h = (unsigned short int)linesToComp;
    signed char return_value_rfbSendOneRectEncodingUltra_1;
    return_value_rfbSendOneRectEncodingUltra_1=rfbSendOneRectEncodingUltra(cl, (signed int)partialRect.x, (signed int)partialRect.y, (signed int)partialRect.w, (signed int)partialRect.h);
    if(return_value_rfbSendOneRectEncodingUltra_1 == 0)
      return (signed char)0;

    if(cl->ublen >= 1)
    {
      if(linesToComp == maxLines)
      {
        signed char return_value_rfbSendUpdateBuf_2;
        return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_2 == 0)
          return (signed char)0;

      }

    }

    linesRemaining = linesRemaining - linesToComp;
    partialRect.y = partialRect.y + (unsigned short int)linesToComp;
  }
  return (signed char)-1;
}

// rfbSendRectEncodingZRLE
// file ../rfb/rfb.h line 937
extern signed char rfbSendRectEncodingZRLE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_11 *zos;
  struct anonymous_2 rect;
  struct anonymous_18 hdr;
  signed int i;
  char *zrleBeforeBuf;
  if(cl->zrleBeforeBuf == ((char *)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(64 * 64 * 4 + 4));
    cl->zrleBeforeBuf = (char *)return_value_malloc_1;
  }

  zrleBeforeBuf = cl->zrleBeforeBuf;
  if(cl->preferredEncoding == 17)
  {
    if(!(cl->tightQualityLevel >= 0))
      cl->zywrleLevel = 1;

    else
      if(!(cl->tightQualityLevel >= 3))
        cl->zywrleLevel = 3;

      else
        if(!(cl->tightQualityLevel >= 6))
          cl->zywrleLevel = 2;

        else
          cl->zywrleLevel = 1;
  }

  else
    cl->zywrleLevel = 0;
  struct anonymous_11 *return_value_zrleOutStreamNew_2;
  if(cl->zrleData == NULL)
  {
    return_value_zrleOutStreamNew_2=zrleOutStreamNew();
    cl->zrleData = (void *)return_value_zrleOutStreamNew_2;
  }

  zos = (struct anonymous_11 *)cl->zrleData;
  zos->in.ptr = zos->in.start;
  zos->out.ptr = zos->out.start;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_8;
  switch((signed int)cl->format.bitsPerPixel)
  {
    case 8:
    {
      zrleEncode8NE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);
      break;
    }
    case 16:
    {
      if((signed int)cl->format.greenMax >= 32)
      {
        if(!(cl->format.bigEndian == 0))
          zrleEncode16BE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);

        else
          zrleEncode16LE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);
      }

      else
        if(!(cl->format.bigEndian == 0))
          zrleEncode15BE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);

        else
          zrleEncode15LE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);
      break;
    }
    case 32:
    {
      signed char fitsInLS3Bytes;
      if(!((signed int)cl->format.redMax << (signed int)cl->format.redShift >= 16777216))
        tmp_if_expr_3 = (signed int)cl->format.greenMax << (signed int)cl->format.greenShift < 1 << 24 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (signed int)cl->format.blueMax << (signed int)cl->format.blueShift < 1 << 24 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      fitsInLS3Bytes = (signed char)tmp_if_expr_4;
      signed char fitsInMS3Bytes;
      if((signed int)cl->format.redShift >= 8)
        tmp_if_expr_5 = (signed int)cl->format.greenShift > 7 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (signed int)cl->format.blueShift > 7 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      fitsInMS3Bytes = (signed char)tmp_if_expr_6;
      if(!(fitsInLS3Bytes == 0))
        tmp_if_expr_10 = !(cl->format.bigEndian != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        if(!(fitsInMS3Bytes == 0))
          tmp_if_expr_11 = cl->format.bigEndian != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
      {
        if(!(cl->format.bigEndian == 0))
          zrleEncode24ABE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);

        else
          zrleEncode24ALE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);
      }

      else
      {
        if(!(fitsInLS3Bytes == 0))
          tmp_if_expr_7 = cl->format.bigEndian != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          if(!(fitsInMS3Bytes == 0))
            tmp_if_expr_8 = !(cl->format.bigEndian != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
        {
          if(!(cl->format.bigEndian == 0))
            zrleEncode24BBE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);

          else
            zrleEncode24BLE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);
        }

        else
          if(!(cl->format.bigEndian == 0))
            zrleEncode32BE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);

          else
            zrleEncode32LE(x, y, w, h, zos, (void *)zrleBeforeBuf, cl);
      }
    }
  }
  rfbStatRecordEncodingSent(cl, (unsigned int)16, (signed int)((signed long int)(8 + 4 + 4) + ((&zos->out)->ptr - (&zos->out)->start)), +w * ((signed int)cl->format.bitsPerPixel / 8) * h);
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_13;
    return_value_rfbSendUpdateBuf_13=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_13 == 0)
      return (signed char)0;

  }

  rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
  rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  signed int tmp_if_expr_14;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_14 = cl->preferredEncoding >> 24 | (cl->preferredEncoding & 0x00ff0000) >> 8 | (cl->preferredEncoding & 0x0000ff00) << 8 | cl->preferredEncoding << 24;

  else
    tmp_if_expr_14 = cl->preferredEncoding;
  rect.encoding = (unsigned int)tmp_if_expr_14;
  memcpy((void *)(cl->updateBuf + (signed long int)cl->ublen), (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  signed long int tmp_if_expr_15;
  if(!(rfbEndianTest == 0))
    tmp_if_expr_15 = (&zos->out)->ptr - (&zos->out)->start >> 24 | ((&zos->out)->ptr - (&zos->out)->start & (signed long int)0x00ff0000) >> 8 | ((&zos->out)->ptr - (&zos->out)->start & (signed long int)0x0000ff00) << 8 | (&zos->out)->ptr - (&zos->out)->start << 24;

  else
    tmp_if_expr_15 = (&zos->out)->ptr - (&zos->out)->start;
  hdr.length = (unsigned int)tmp_if_expr_15;
  memcpy((void *)(cl->updateBuf + (signed long int)cl->ublen), (const void *)(char *)&hdr, (unsigned long int)4);
  cl->ublen = cl->ublen + 4;
  i = 0;
  while(!((signed long int)i >= zos->out.ptr - zos->out.start))
  {
    signed int bytesToCopy = 30000 - cl->ublen;
    if(!(zos->out.ptr - zos->out.start >= (signed long int)(bytesToCopy + i)))
      bytesToCopy = (signed int)(((&zos->out)->ptr - (&zos->out)->start) - (signed long int)i);

    memcpy((void *)(cl->updateBuf + (signed long int)cl->ublen), (const void *)((unsigned char *)zos->out.start + (signed long int)i), (unsigned long int)bytesToCopy);
    cl->ublen = cl->ublen + bytesToCopy;
    i = i + bytesToCopy;
    if(cl->ublen == 30000)
    {
      signed char return_value_rfbSendUpdateBuf_16;
      return_value_rfbSendUpdateBuf_16=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_16 == 0)
        return (signed char)0;

    }

  }
  return (signed char)-1;
}

// rfbSendRectEncodingZlib
// file ../rfb/rfb.h line 882
extern signed char rfbSendRectEncodingZlib(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  signed int maxLines;
  signed int linesRemaining;
  struct anonymous_5 partialRect;
  partialRect.x = (unsigned short int)x;
  partialRect.y = (unsigned short int)y;
  partialRect.w = (unsigned short int)w;
  partialRect.h = (unsigned short int)h;
  maxLines = (w * 2 > 128 * 256 ? w * 2 : 128 * 256) / w;
  linesRemaining = h;
  while(linesRemaining >= 1)
  {
    signed int linesToComp;
    if(!(maxLines >= linesRemaining))
      linesToComp = maxLines;

    else
      linesToComp = linesRemaining;
    partialRect.h = (unsigned short int)linesToComp;
    signed char return_value_rfbSendOneRectEncodingZlib_1;
    return_value_rfbSendOneRectEncodingZlib_1=rfbSendOneRectEncodingZlib(cl, (signed int)partialRect.x, (signed int)partialRect.y, (signed int)partialRect.w, (signed int)partialRect.h);
    if(return_value_rfbSendOneRectEncodingZlib_1 == 0)
      return (signed char)0;

    if(cl->ublen >= 1)
    {
      if(linesToComp == maxLines)
      {
        signed char return_value_rfbSendUpdateBuf_2;
        return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_2 == 0)
          return (signed char)0;

      }

    }

    linesRemaining = linesRemaining - linesToComp;
    partialRect.y = partialRect.y + (unsigned short int)linesToComp;
  }
  return (signed char)-1;
}

// rfbSendSecurityType
// file auth.c line 259
static void rfbSendSecurityType(struct _rfbClientRec *cl, signed int securityType)
{
  unsigned int value32 = (unsigned int)(rfbEndianTest != 0 ? securityType >> 24 | (securityType & 0x00ff0000) >> 8 | (securityType & 0x0000ff00) << 8 | securityType << 24 : securityType);
  signed int return_value_rfbWriteExact_1;
  return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)&value32, 4);
  if(!(return_value_rfbWriteExact_1 >= 0))
  {
    rfbLogPerror("rfbSendSecurityType: write");
    rfbCloseClient(cl);
  }

  else
    switch(securityType)
    {
      case 1:
      {
        cl->state = (enum anonymous_13)RFB_INITIALISATION;
        break;
      }
      case 2:
      {
        rfbVncAuthSendChallenge(cl);
        break;
      }
      default:
      {
        rfbLogPerror("rfbSendSecurityType: assertion failed");
        rfbCloseClient(cl);
      }
    }
}

// rfbSendSecurityTypeList
// file auth.c line 202
static void rfbSendSecurityTypeList(struct _rfbClientRec *cl, signed int primaryType)
{
  signed int size = 1;
  struct _rfbSecurity *handler;
  unsigned char buffer[256l];
  switch(primaryType)
  {
    case 1:
    {
      rfbRegisterSecurityHandler(&VncSecurityHandlerNone);
      break;
    }
    case 2:
      rfbRegisterSecurityHandler(&VncSecurityHandlerVncAuth);
  }
  handler = securityHandlers;
  for( ; !(handler == ((struct _rfbSecurity *)NULL)) && !(size >= 255); handler = handler->next)
  {
    buffer[(signed long int)size] = handler->type;
    size = size + 1;
  }
  buffer[(signed long int)0] = (unsigned char)((signed int)(unsigned char)size - 1);
  signed int return_value_rfbWriteExact_1;
  return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)buffer, size);
  if(!(return_value_rfbWriteExact_1 >= 0))
  {
    rfbLogPerror("rfbSendSecurityTypeList: write");
    rfbCloseClient(cl);
  }

  else
  {
    if(!(size >= 2))
    {
      char *reason = "No authentication mode is registered!";
      rfbClientSendString(cl, reason);
      goto __CPROVER_DUMP_L8;
    }

    cl->state = (enum anonymous_13)RFB_SECURITY_TYPE;
  }

__CPROVER_DUMP_L8:
  ;
}

// rfbSendServerCutText
// file rfbserver.c line 3488
extern void rfbSendServerCutText(struct _rfbScreenInfo *rfbScreen, char *str, signed int len)
{
  struct _rfbClientRec *rfbSendServerCutText__1__cl;
  struct anonymous_22 sct;
  struct rfbClientIterator *iterator;
  iterator=rfbGetClientIterator(rfbScreen);
  do
  {
    rfbSendServerCutText__1__cl=rfbClientIteratorNext(iterator);
    if(rfbSendServerCutText__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    sct.type = (unsigned char)3;
    sct.length = (unsigned int)(rfbEndianTest != 0 ? len >> 24 | (len & 0x00ff0000) >> 8 | (len & 0x0000ff00) << 8 | len << 24 : len);
    pthread_mutex_lock(&rfbSendServerCutText__1__cl->sendMutex);
    signed int return_value_rfbWriteExact_1;
    return_value_rfbWriteExact_1=rfbWriteExact(rfbSendServerCutText__1__cl, (char *)&sct, 8);
    if(!(return_value_rfbWriteExact_1 >= 0))
    {
      rfbLogPerror("rfbSendServerCutText: write");
      rfbCloseClient(rfbSendServerCutText__1__cl);
      pthread_mutex_unlock(&rfbSendServerCutText__1__cl->sendMutex);
    }

    else
    {
      signed int return_value_rfbWriteExact_2;
      return_value_rfbWriteExact_2=rfbWriteExact(rfbSendServerCutText__1__cl, str, len);
      if(!(return_value_rfbWriteExact_2 >= 0))
      {
        rfbLogPerror("rfbSendServerCutText: write");
        rfbCloseClient(rfbSendServerCutText__1__cl);
      }

      pthread_mutex_unlock(&rfbSendServerCutText__1__cl->sendMutex);
      rfbStatRecordMessageSent(rfbSendServerCutText__1__cl, (unsigned int)3, 8 + len, 8 + len);
    }
  }
  while((_Bool)1);
  rfbReleaseClientIterator(iterator);
}

// rfbSendServerIdentity
// file rfbserver.c line 1073
signed char rfbSendServerIdentity(struct _rfbClientRec *cl)
{
  struct anonymous_2 rect;
  char buffer[512l];
  char *tmp_if_expr_1;
  if(cl->screen->versionString == ((char *)NULL))
    tmp_if_expr_1 = "unknown";

  else
    tmp_if_expr_1 = cl->screen->versionString;
  snprintf(buffer, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1, "%s (%s)", tmp_if_expr_1, (const void *)"LibVNCServer 0.9.10");
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(buffer);
  if(1ul + return_value_strlen_3 + (unsigned long int)(4 + cl->ublen) >= 30001ul)
  {
    signed char return_value_rfbSendUpdateBuf_2;
    return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_2 == 0)
      return (signed char)0;

  }

  rect.encoding = rfbEndianTest != 0 ? 0xFFFE0003 >> 24 | (0xFFFE0003 & (unsigned int)0x00ff0000) >> 8 | (0xFFFE0003 & (unsigned int)0x0000ff00) << 8 | 0xFFFE0003 << 24 : 0xFFFE0003;
  rect.r.x = (unsigned short int)0;
  rect.r.y = (unsigned short int)0;
  unsigned long int tmp_if_expr_7;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  if(!(rfbEndianTest == 0))
  {
    return_value_strlen_4=strlen(buffer);
    return_value_strlen_5=strlen(buffer);
    tmp_if_expr_7 = (return_value_strlen_4 + (unsigned long int)1 & (unsigned long int)0xff) << 8 | return_value_strlen_5 + (unsigned long int)1 >> 8 & (unsigned long int)0xff;
  }

  else
  {
    return_value_strlen_6=strlen(buffer);
    tmp_if_expr_7 = return_value_strlen_6 + (unsigned long int)1;
  }
  rect.r.w = (unsigned short int)tmp_if_expr_7;
  rect.r.h = (unsigned short int)0;
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen(buffer);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)buffer, return_value_strlen_8 + (unsigned long int)1);
  unsigned long int return_value_strlen_9;
  return_value_strlen_9=strlen(buffer);
  cl->ublen = cl->ublen + (signed int)(return_value_strlen_9 + (unsigned long int)1);
  unsigned long int return_value_strlen_10;
  return_value_strlen_10=strlen(buffer);
  unsigned long int return_value_strlen_11;
  return_value_strlen_11=strlen(buffer);
  rfbStatRecordEncodingSent(cl, 0xFFFE0003, (signed int)((unsigned long int)(8 + 4) + return_value_strlen_10 + (unsigned long int)1), (signed int)((unsigned long int)(8 + 4) + return_value_strlen_11 + (unsigned long int)1));
  signed char return_value_rfbSendUpdateBuf_12;
  return_value_rfbSendUpdateBuf_12=rfbSendUpdateBuf(cl);
  if(return_value_rfbSendUpdateBuf_12 == 0)
    return (signed char)0;

  else
    return (signed char)-1;
}

// rfbSendSetColourMapEntries
// file rfbserver.c line 3400
extern signed char rfbSendSetColourMapEntries(struct _rfbClientRec *cl, signed int firstColour, signed int nColours)
{
  char rfbSendSetColourMapEntries__1__buf[1542l];
  char *wbuf = rfbSendSetColourMapEntries__1__buf;
  struct anonymous_21 *scme;
  unsigned short int *rgb;
  struct anonymous_15 *cm = &cl->screen->colourMap;
  signed int i;
  signed int len;
  if(nColours >= 257)
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(6 + nColours * 3 * 2));
    wbuf = (char *)return_value_malloc_1;
  }

  scme = (struct anonymous_21 *)wbuf;
  rgb = (unsigned short int *)&wbuf[(signed long int)6];
  scme->type = (unsigned char)1;
  scme->firstColour = (unsigned short int)(rfbEndianTest != 0 ? (firstColour & 0xff) << 8 | firstColour >> 8 & 0xff : firstColour);
  scme->nColours = (unsigned short int)(rfbEndianTest != 0 ? (nColours & 0xff) << 8 | nColours >> 8 & 0xff : nColours);
  len = 6;
  i = 0;
  signed int tmp_if_expr_2;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_5;
  signed int tmp_if_expr_6;
  signed int tmp_if_expr_7;
  for( ; !(i >= nColours); i = i + 1)
    if(!(i >= (signed int)cm->count))
    {
      if(!(cm->is16 == 0))
      {
        if(!(rfbEndianTest == 0))
          tmp_if_expr_2 = ((signed int)cm->data.shorts[(signed long int)(i * 3)] & 0xff) << 8 | (signed int)cm->data.shorts[(signed long int)(i * 3)] >> 8 & 0xff;

        else
          tmp_if_expr_2 = (signed int)cm->data.shorts[(signed long int)(i * 3)];
        rgb[(signed long int)(i * 3)] = (unsigned short int)tmp_if_expr_2;
        if(!(rfbEndianTest == 0))
          tmp_if_expr_3 = ((signed int)cm->data.shorts[(signed long int)(i * 3 + 1)] & 0xff) << 8 | (signed int)cm->data.shorts[(signed long int)(i * 3 + 1)] >> 8 & 0xff;

        else
          tmp_if_expr_3 = (signed int)cm->data.shorts[(signed long int)(i * 3 + 1)];
        rgb[(signed long int)(i * 3 + 1)] = (unsigned short int)tmp_if_expr_3;
        if(!(rfbEndianTest == 0))
          tmp_if_expr_4 = ((signed int)cm->data.shorts[(signed long int)(i * 3 + 2)] & 0xff) << 8 | (signed int)cm->data.shorts[(signed long int)(i * 3 + 2)] >> 8 & 0xff;

        else
          tmp_if_expr_4 = (signed int)cm->data.shorts[(signed long int)(i * 3 + 2)];
        rgb[(signed long int)(i * 3 + 2)] = (unsigned short int)tmp_if_expr_4;
      }

      else
      {
        if(!(rfbEndianTest == 0))
          tmp_if_expr_5 = ((signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3)] & 0xff) << 8 | (signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3)] >> 8 & 0xff;

        else
          tmp_if_expr_5 = (signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3)];
        rgb[(signed long int)(i * 3)] = (unsigned short int)tmp_if_expr_5;
        if(!(rfbEndianTest == 0))
          tmp_if_expr_6 = ((signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3 + 1)] & 0xff) << 8 | (signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3 + 1)] >> 8 & 0xff;

        else
          tmp_if_expr_6 = (signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3 + 1)];
        rgb[(signed long int)(i * 3 + 1)] = (unsigned short int)tmp_if_expr_6;
        if(!(rfbEndianTest == 0))
          tmp_if_expr_7 = ((signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3 + 2)] & 0xff) << 8 | (signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3 + 2)] >> 8 & 0xff;

        else
          tmp_if_expr_7 = (signed int)(unsigned short int)cm->data.bytes[(signed long int)(i * 3 + 2)];
        rgb[(signed long int)(i * 3 + 2)] = (unsigned short int)tmp_if_expr_7;
      }
    }

  len = len + nColours * 3 * 2;
  pthread_mutex_lock(&cl->sendMutex);
  signed int return_value_rfbWriteExact_8;
  return_value_rfbWriteExact_8=rfbWriteExact(cl, wbuf, len);
  if(!(return_value_rfbWriteExact_8 >= 0))
  {
    rfbLogPerror("rfbSendSetColourMapEntries: write");
    rfbCloseClient(cl);
    if(!(wbuf == rfbSendSetColourMapEntries__1__buf))
      free((void *)wbuf);

    pthread_mutex_unlock(&cl->sendMutex);
    return (signed char)0;
  }

  else
  {
    pthread_mutex_unlock(&cl->sendMutex);
    rfbStatRecordMessageSent(cl, (unsigned int)1, len, len);
    if(!(wbuf == rfbSendSetColourMapEntries__1__buf))
      free((void *)wbuf);

    return (signed char)-1;
  }
}

// rfbSendSmallRectEncodingCoRRE
// file corre.c line 83
static signed char rfbSendSmallRectEncodingCoRRE(struct _rfbClientRec *cl, signed int x, signed int y, signed int w, signed int h)
{
  struct anonymous_2 rect;
  struct anonymous_14 hdr;
  signed int nSubrects;
  signed int i;
  char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
  signed int maxRawSize = cl->scaledScreen->width * cl->scaledScreen->height * ((signed int)cl->format.bitsPerPixel / 8);
  void *return_value_malloc_1;
  void *return_value_realloc_2;
  if(!(cl->beforeEncBufSize >= maxRawSize))
  {
    cl->beforeEncBufSize = maxRawSize;
    if(cl->beforeEncBuf == ((char *)NULL))
    {
      return_value_malloc_1=malloc((unsigned long int)cl->beforeEncBufSize);
      cl->beforeEncBuf = (char *)return_value_malloc_1;
    }

    else
    {
      return_value_realloc_2=realloc((void *)cl->beforeEncBuf, (unsigned long int)cl->beforeEncBufSize);
      cl->beforeEncBuf = (char *)return_value_realloc_2;
    }
  }

  void *return_value_malloc_3;
  void *return_value_realloc_4;
  if(!(cl->afterEncBufSize >= maxRawSize))
  {
    cl->afterEncBufSize = maxRawSize;
    if(cl->afterEncBuf == ((char *)NULL))
    {
      return_value_malloc_3=malloc((unsigned long int)cl->afterEncBufSize);
      cl->afterEncBuf = (char *)return_value_malloc_3;
    }

    else
    {
      return_value_realloc_4=realloc((void *)cl->afterEncBuf, (unsigned long int)cl->afterEncBufSize);
      cl->afterEncBuf = (char *)return_value_realloc_4;
    }
  }

  cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, cl->beforeEncBuf, cl->scaledScreen->paddedWidthInBytes, w, h);
  if((signed int)cl->format.bitsPerPixel == 8)
  {
    nSubrects=subrectEncode8(cl, (unsigned char *)cl->beforeEncBuf, w, h);
    nSubrects=subrectEncode16(cl, (unsigned short int *)cl->beforeEncBuf, w, h);
    nSubrects=subrectEncode32(cl, (unsigned int *)cl->beforeEncBuf, w, h);
  }

  rfbLog("getBgColour: bpp %d?\n", cl->format.bitsPerPixel);
  return (signed char)0;
  if(!(nSubrects >= 0))
  {
    signed char return_value_rfbSendRectEncodingRaw_5;
    return_value_rfbSendRectEncodingRaw_5=rfbSendRectEncodingRaw(cl, x, y, w, h);
    return return_value_rfbSendRectEncodingRaw_5;
  }

  rfbStatRecordEncodingSent(cl, (unsigned int)4, 8 + 4 + 4 + cl->afterEncBufLen, 8 + 4 + w * h * ((signed int)cl->format.bitsPerPixel / 8));
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_6;
    return_value_rfbSendUpdateBuf_6=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_6 == 0)
      return (signed char)0;

  }

  rect.r.x = (unsigned short int)(rfbEndianTest != 0 ? (x & 0xff) << 8 | x >> 8 & 0xff : x);
  rect.r.y = (unsigned short int)(rfbEndianTest != 0 ? (y & 0xff) << 8 | y >> 8 & 0xff : y);
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (w & 0xff) << 8 | w >> 8 & 0xff : w);
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (h & 0xff) << 8 | h >> 8 & 0xff : h);
  rect.encoding = (unsigned int)(rfbEndianTest != 0 ? 4 >> 24 | (4 & 0x00ff0000) >> 8 | (4 & 0x0000ff00) << 8 | 4 << 24 : 4);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  hdr.nSubrects = (unsigned int)(rfbEndianTest != 0 ? nSubrects >> 24 | (nSubrects & 0x00ff0000) >> 8 | (nSubrects & 0x0000ff00) << 8 | nSubrects << 24 : nSubrects);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&hdr, (unsigned long int)4);
  cl->ublen = cl->ublen + 4;
  i = 0;
  if(!(i >= cl->afterEncBufLen))
  {
    signed int bytesToCopy = 30000 - cl->ublen;
    if(!(cl->afterEncBufLen >= bytesToCopy + i))
      bytesToCopy = cl->afterEncBufLen - i;

    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)&cl->afterEncBuf[(signed long int)i], (unsigned long int)bytesToCopy);
    cl->ublen = cl->ublen + bytesToCopy;
    i = i + bytesToCopy;
    if(cl->ublen == 30000)
    {
      signed char return_value_rfbSendUpdateBuf_7;
      return_value_rfbSendUpdateBuf_7=rfbSendUpdateBuf(cl);
      if(return_value_rfbSendUpdateBuf_7 == 0)
        return (signed char)0;

    }

  }

  return (signed char)-1;
}

// rfbSendSupportedEncodings
// file rfbserver.c line 985
signed char rfbSendSupportedEncodings(struct _rfbClientRec *cl)
{
  struct anonymous_2 rect;
  unsigned int nEncodings = (unsigned int)(sizeof(unsigned int [20l]) /*80ul*/  / sizeof(unsigned int) /*4ul*/ );
  unsigned int i;
  if(sizeof(unsigned int) /*4ul*/  * (unsigned long int)nEncodings + (unsigned long int)(4 + cl->ublen) >= 30001ul)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.encoding = rfbEndianTest != 0 ? 0xFFFE0002 >> 24 | (0xFFFE0002 & (unsigned int)0x00ff0000) >> 8 | (0xFFFE0002 & (unsigned int)0x0000ff00) << 8 | 0xFFFE0002 << 24 : 0xFFFE0002;
  rect.r.x = (unsigned short int)0;
  rect.r.y = (unsigned short int)0;
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? ((unsigned long int)nEncodings * sizeof(unsigned int) /*4ul*/  & (unsigned long int)0xff) << 8 | (unsigned long int)nEncodings * sizeof(unsigned int) /*4ul*/  >> 8 & (unsigned long int)0xff : (unsigned long int)nEncodings * sizeof(unsigned int) /*4ul*/ );
  rect.r.h = (unsigned short int)(rfbEndianTest != 0 ? (nEncodings & (unsigned int)0xff) << 8 | nEncodings >> 8 & (unsigned int)0xff : nEncodings);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  i = (unsigned int)0;
  unsigned int tmp_if_expr_2;
  for( ; !(i >= nEncodings); i = i + 1u)
  {
    unsigned int encoding;
    static unsigned int supported[20l] = { (unsigned int)0, (unsigned int)1, (unsigned int)2, (unsigned int)4, (unsigned int)5, (unsigned int)6, (unsigned int)16, (unsigned int)17, (unsigned int)7, (unsigned int)9, 0xFFFF0009, 0xFFFFFF10, 0xFFFFFF11, 0xFFFFFF18, 0xFFFFFF20, 0xFFFFFF21, 0xFFFE0000, 0xFFFE0001, 0xFFFE0002, 0xFFFE0003 };
    if(!(rfbEndianTest == 0))
      tmp_if_expr_2 = supported[(signed long int)i] >> 24 | (supported[(signed long int)i] & (unsigned int)0x00ff0000) >> 8 | (supported[(signed long int)i] & (unsigned int)0x0000ff00) << 8 | supported[(signed long int)i] << 24;

    else
      tmp_if_expr_2 = supported[(signed long int)i];
    encoding = tmp_if_expr_2;
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&encoding, sizeof(unsigned int) /*4ul*/ );
    cl->ublen = cl->ublen + (signed int)sizeof(unsigned int) /*4ul*/ ;
  }
  rfbStatRecordEncodingSent(cl, 0xFFFE0002, (signed int)((unsigned long int)(8 + 4) + (unsigned long int)nEncodings * sizeof(unsigned int) /*4ul*/ ), (signed int)((unsigned long int)(8 + 4) + (unsigned long int)nEncodings * sizeof(unsigned int) /*4ul*/ ));
  signed char return_value_rfbSendUpdateBuf_3;
  return_value_rfbSendUpdateBuf_3=rfbSendUpdateBuf(cl);
  if(return_value_rfbSendUpdateBuf_3 == 0)
    return (signed char)0;

  else
    return (signed char)-1;
}

// rfbSendSupportedMessages
// file rfbserver.c line 921
signed char rfbSendSupportedMessages(struct _rfbClientRec *cl)
{
  struct anonymous_2 rect;
  struct anonymous_55 msgs;
  if(4 + cl->ublen >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  rect.encoding = rfbEndianTest != 0 ? 0xFFFE0001 >> 24 | (0xFFFE0001 & (unsigned int)0x00ff0000) >> 8 | (0xFFFE0001 & (unsigned int)0x0000ff00) << 8 | 0xFFFE0001 << 24 : 0xFFFE0001;
  rect.r.x = (unsigned short int)0;
  rect.r.y = (unsigned short int)0;
  rect.r.w = (unsigned short int)(rfbEndianTest != 0 ? (64 & 0xff) << 8 | 64 >> 8 & 0xff : 64);
  rect.r.h = (unsigned short int)0;
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&rect, (unsigned long int)(8 + 4));
  cl->ublen = cl->ublen + 8 + 4;
  memset((void *)(char *)&msgs, 0, (unsigned long int)64);
  msgs.client2server[(signed long int)((0 & 255) / 8)] = msgs.client2server[(signed long int)((0 & 255) / 8)] | (unsigned char)(1 << 0 % 8);
  msgs.client2server[(signed long int)((1 & 255) / 8)] = msgs.client2server[(signed long int)((1 & 255) / 8)] | (unsigned char)(1 << 1 % 8);
  msgs.client2server[(signed long int)((2 & 255) / 8)] = msgs.client2server[(signed long int)((2 & 255) / 8)] | (unsigned char)(1 << 2 % 8);
  msgs.client2server[(signed long int)((3 & 255) / 8)] = msgs.client2server[(signed long int)((3 & 255) / 8)] | (unsigned char)(1 << 3 % 8);
  msgs.client2server[(signed long int)((4 & 255) / 8)] = msgs.client2server[(signed long int)((4 & 255) / 8)] | (unsigned char)(1 << 4 % 8);
  msgs.client2server[(signed long int)((5 & 255) / 8)] = msgs.client2server[(signed long int)((5 & 255) / 8)] | (unsigned char)(1 << 5 % 8);
  msgs.client2server[(signed long int)((6 & 255) / 8)] = msgs.client2server[(signed long int)((6 & 255) / 8)] | (unsigned char)(1 << 6 % 8);
  msgs.client2server[(signed long int)((7 & 255) / 8)] = msgs.client2server[(signed long int)((7 & 255) / 8)] | (unsigned char)(1 << 7 % 8);
  msgs.client2server[(signed long int)((8 & 255) / 8)] = msgs.client2server[(signed long int)((8 & 255) / 8)] | (unsigned char)(1 << 8 % 8);
  msgs.client2server[(signed long int)((0xF & 255) / 8)] = msgs.client2server[(signed long int)((0xF & 255) / 8)] | (unsigned char)(1 << 0xF % 8);
  msgs.client2server[(signed long int)((250 & 255) / 8)] = msgs.client2server[(signed long int)((250 & 255) / 8)] | (unsigned char)(1 << 250 % 8);
  msgs.server2client[(signed long int)((0 & 255) / 8)] = msgs.server2client[(signed long int)((0 & 255) / 8)] | (unsigned char)(1 << 0 % 8);
  msgs.server2client[(signed long int)((1 & 255) / 8)] = msgs.server2client[(signed long int)((1 & 255) / 8)] | (unsigned char)(1 << 1 % 8);
  msgs.server2client[(signed long int)((2 & 255) / 8)] = msgs.server2client[(signed long int)((2 & 255) / 8)] | (unsigned char)(1 << 2 % 8);
  msgs.server2client[(signed long int)((3 & 255) / 8)] = msgs.server2client[(signed long int)((3 & 255) / 8)] | (unsigned char)(1 << 3 % 8);
  msgs.server2client[(signed long int)((4 & 255) / 8)] = msgs.server2client[(signed long int)((4 & 255) / 8)] | (unsigned char)(1 << 4 % 8);
  msgs.server2client[(signed long int)((0xF & 255) / 8)] = msgs.server2client[(signed long int)((0xF & 255) / 8)] | (unsigned char)(1 << 0xF % 8);
  msgs.server2client[(signed long int)((250 & 255) / 8)] = msgs.server2client[(signed long int)((250 & 255) / 8)] | (unsigned char)(1 << 250 % 8);
  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&msgs, (unsigned long int)64);
  cl->ublen = cl->ublen + 64;
  rfbStatRecordEncodingSent(cl, 0xFFFE0001, 8 + 4 + 64, 8 + 4 + 64);
  signed char return_value_rfbSendUpdateBuf_2;
  return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
  if(return_value_rfbSendUpdateBuf_2 == 0)
    return (signed char)0;

  else
    return (signed char)-1;
}

// rfbSendTextChatMessage
// file rfbserver.c line 1140
extern signed char rfbSendTextChatMessage(struct _rfbClientRec *cl, unsigned int length, char *buffer)
{
  struct _rfbTextChatMsg tc;
  signed int bytesToSend = 0;
  memset((void *)(char *)&tc, 0, sizeof(struct _rfbTextChatMsg) /*8ul*/ );
  tc.type = (unsigned char)11;
  tc.length = rfbEndianTest != 0 ? length >> 24 | (length & (unsigned int)0x00ff0000) >> 8 | (length & (unsigned int)0x0000ff00) << 8 | length << 24 : length;
  if(length == 0xFFFFFFFD || length == 0xFFFFFFFE || length == 0xFFFFFFFF)
  {
    bytesToSend = 0;
    goto __CPROVER_DUMP_L3;
  }

  bytesToSend = (signed int)length;
  if(bytesToSend >= 4097)
    bytesToSend = 4096;


__CPROVER_DUMP_L3:
  ;
  if(8 + cl->ublen + bytesToSend >= 30001)
  {
    signed char return_value_rfbSendUpdateBuf_1;
    return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
    if(return_value_rfbSendUpdateBuf_1 == 0)
      return (signed char)0;

  }

  memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)&tc, (unsigned long int)8);
  cl->ublen = cl->ublen + 8;
  if(bytesToSend >= 1)
  {
    memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)buffer, (unsigned long int)bytesToSend);
    cl->ublen = cl->ublen + bytesToSend;
  }

  rfbStatRecordMessageSent(cl, (unsigned int)11, 8 + bytesToSend, 8 + bytesToSend);
  signed char return_value_rfbSendUpdateBuf_2;
  return_value_rfbSendUpdateBuf_2=rfbSendUpdateBuf(cl);
  if(return_value_rfbSendUpdateBuf_2 == 0)
    return (signed char)0;

  else
    return (signed char)-1;
}

// rfbSendTunnelingCaps
// file tightvnc-filetransfer/rfbtightserver.c line 232
static void rfbSendTunnelingCaps(struct _rfbClientRec *cl)
{
  struct _rfbTunnelingCapsMsg caps;
  unsigned int nTypes = (unsigned int)0;
  rfbLog("tightvnc-filetransfer/rfbSendTunnelingCaps\n");
  caps.nTunnelTypes = rfbEndianTest != 0 ? nTypes >> 24 | (nTypes & (unsigned int)0x00ff0000) >> 8 | (nTypes & (unsigned int)0x0000ff00) << 8 | nTypes << 24 : nTypes;
  signed int return_value_rfbWriteExact_1;
  return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)&caps, 4);
  if(!(return_value_rfbWriteExact_1 >= 0))
  {
    rfbLogPerror("rfbSendTunnelingCaps: write");
    rfbCloseClient(cl);
  }

  else
    if(!(nTypes == 0u))
      rfbProcessClientTunnelingType(cl);

    else
      rfbSendAuthCaps(cl);
}

// rfbSendUpdateBuf
// file rfbserver.c line 3379
extern signed char rfbSendUpdateBuf(struct _rfbClientRec *cl)
{
  if(!(cl->sock >= 0))
    return (signed char)0;

  else
  {
    signed int return_value_rfbWriteExact_1;
    return_value_rfbWriteExact_1=rfbWriteExact(cl, cl->updateBuf, cl->ublen);
    if(!(return_value_rfbWriteExact_1 >= 0))
    {
      rfbLogPerror("rfbSendUpdateBuf: write");
      rfbCloseClient(cl);
      return (signed char)0;
    }

    else
    {
      cl->ublen = 0;
      return (signed char)-1;
    }
  }
}

// rfbSendXvp
// file rfbserver.c line 1118
signed char rfbSendXvp(struct _rfbClientRec *cl, unsigned char version, unsigned char code)
{
  struct anonymous_23 xvp;
  xvp.type = (unsigned char)250;
  xvp.pad = (unsigned char)0;
  xvp.version = version;
  xvp.code = code;
  pthread_mutex_lock(&cl->sendMutex);
  signed int return_value_rfbWriteExact_1;
  return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)&xvp, 4);
  if(!(return_value_rfbWriteExact_1 >= 0))
  {
    rfbLogPerror("rfbSendXvp: write");
    rfbCloseClient(cl);
  }

  pthread_mutex_unlock(&cl->sendMutex);
  rfbStatRecordMessageSent(cl, (unsigned int)250, 4, 4);
  return (signed char)-1;
}

// rfbSetClientColourMap
// file ../rfb/rfb.h line 821
extern signed char rfbSetClientColourMap(struct _rfbClientRec *cl, signed int firstColour, signed int nColours)
{
  _Bool tmp_if_expr_1;
  if(!(cl->screen->serverFormat.trueColour == 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(cl->readyForSetColourMapEntries != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (signed char)-1;

  else
  {
    if(nColours == 0)
      nColours = (signed int)cl->screen->colourMap.count;

    if(!(cl->format.trueColour == 0))
    {
      pthread_mutex_lock(&cl->updateMutex);
      rfbInitColourMapSingleTableFns[(signed long int)((signed int)cl->format.bitsPerPixel / 8 - 1)](&cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, &cl->screen->colourMap);
      sraRgnDestroy(cl->modifiedRegion);
      cl->modifiedRegion=sraRgnCreateRect(0, 0, cl->screen->width, cl->screen->height);
      pthread_mutex_unlock(&cl->updateMutex);
      return (signed char)-1;
    }

    else
    {
      signed char return_value_rfbSendSetColourMapEntries_2;
      return_value_rfbSendSetColourMapEntries_2=rfbSendSetColourMapEntries(cl, firstColour, nColours);
      return return_value_rfbSendSetColourMapEntries_2;
    }
  }
}

// rfbSetClientColourMapBGR233
// file translate.c line 361
static signed char rfbSetClientColourMapBGR233(struct _rfbClientRec *cl)
{
  char rfbSetClientColourMapBGR233__1__buf[1542l];
  struct anonymous_21 *scme = (struct anonymous_21 *)rfbSetClientColourMapBGR233__1__buf;
  unsigned short int *rgb = (unsigned short int *)&rfbSetClientColourMapBGR233__1__buf[(signed long int)6];
  signed int i;
  signed int len;
  signed int r;
  signed int g;
  signed int b;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  if(!((signed int)cl->format.bitsPerPixel == 8))
  {
    rfbErr("%s: client not 8 bits per pixel\n", (const void *)"rfbSetClientColourMapBGR233");
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
  {
    scme->type = (unsigned char)1;
    scme->firstColour = (unsigned short int)(rfbEndianTest != 0 ? (0 & 0xff) << 8 | 0 >> 8 & 0xff : 0);
    scme->nColours = (unsigned short int)(rfbEndianTest != 0 ? (256 & 0xff) << 8 | 256 >> 8 & 0xff : 256);
    len = 6;
    i = 0;
    b = 0;
    for( ; !(b >= 4); b = b + 1)
    {
      g = 0;
      for( ; !(g >= 8); g = g + 1)
      {
        r = 0;
        for( ; !(r >= 8); r = r + 1)
        {
          tmp_post_1 = i;
          i = i + 1;
          rgb[(signed long int)tmp_post_1] = (unsigned short int)(rfbEndianTest != 0 ? ((r * 65535) / 7 & 0xff) << 8 | (r * 65535) / 7 >> 8 & 0xff : (r * 65535) / 7);
          tmp_post_2 = i;
          i = i + 1;
          rgb[(signed long int)tmp_post_2] = (unsigned short int)(rfbEndianTest != 0 ? ((g * 65535) / 7 & 0xff) << 8 | (g * 65535) / 7 >> 8 & 0xff : (g * 65535) / 7);
          tmp_post_3 = i;
          i = i + 1;
          rgb[(signed long int)tmp_post_3] = (unsigned short int)(rfbEndianTest != 0 ? ((b * 65535) / 3 & 0xff) << 8 | (b * 65535) / 3 >> 8 & 0xff : (b * 65535) / 3);
        }
      }
    }
    len = len + 256 * 3 * 2;
    signed int return_value_rfbWriteExact_4;
    return_value_rfbWriteExact_4=rfbWriteExact(cl, rfbSetClientColourMapBGR233__1__buf, len);
    if(!(return_value_rfbWriteExact_4 >= 0))
    {
      rfbLogPerror("rfbSetClientColourMapBGR233: write");
      rfbCloseClient(cl);
      return (signed char)0;
    }

    else
      return (signed char)-1;
  }
}

// rfbSetClientColourMaps
// file translate.c line 448
extern void rfbSetClientColourMaps(struct _rfbScreenInfo *rfbScreen, signed int firstColour, signed int nColours)
{
  struct rfbClientIterator *i;
  struct _rfbClientRec *rfbSetClientColourMaps__1__cl;
  i=rfbGetClientIterator(rfbScreen);
  do
  {
    rfbSetClientColourMaps__1__cl=rfbClientIteratorNext(i);
    if(rfbSetClientColourMaps__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    rfbSetClientColourMap(rfbSetClientColourMaps__1__cl, firstColour, nColours);
  }
  while((_Bool)1);
  rfbReleaseClientIterator(i);
}

// rfbSetCursor
// file cursor.c line 726
extern void rfbSetCursor(struct _rfbScreenInfo *rfbScreen, struct rfbCursor *c)
{
  struct rfbClientIterator *iterator;
  struct _rfbClientRec *rfbSetCursor__1__cl;
  pthread_mutex_lock(&rfbScreen->cursorMutex);
  if(!(rfbScreen->cursor == ((struct rfbCursor *)NULL)))
  {
    iterator=rfbGetClientIterator(rfbScreen);
    do
    {
      rfbSetCursor__1__cl=rfbClientIteratorNext(iterator);
      if(rfbSetCursor__1__cl == ((struct _rfbClientRec *)NULL))
        break;

      if(rfbSetCursor__1__cl->enableCursorShapeUpdates == 0)
        rfbRedrawAfterHideCursor(rfbSetCursor__1__cl, (struct sraRegion *)(void *)0);

    }
    while((_Bool)1);
    rfbReleaseClientIterator(iterator);
    if(!(rfbScreen->cursor->cleanup == 0))
      rfbFreeCursor(rfbScreen->cursor);

  }

  rfbScreen->cursor = c;
  iterator=rfbGetClientIterator(rfbScreen);
  do
  {
    rfbSetCursor__1__cl=rfbClientIteratorNext(iterator);
    if(rfbSetCursor__1__cl == ((struct _rfbClientRec *)NULL))
      break;

    rfbSetCursor__1__cl->cursorWasChanged = (signed char)-1;
    if(rfbSetCursor__1__cl->enableCursorShapeUpdates == 0)
      rfbRedrawAfterHideCursor(rfbSetCursor__1__cl, (struct sraRegion *)(void *)0);

  }
  while((_Bool)1);
  rfbReleaseClientIterator(iterator);
  pthread_mutex_unlock(&rfbScreen->cursorMutex);
}

// rfbSetNonBlocking
// file ../rfb/rfb.h line 759
extern signed char rfbSetNonBlocking(signed int sock)
{
  signed int flags;
  flags=fcntl(sock, 3);
  _Bool tmp_if_expr_2;
  signed int return_value_fcntl_1;
  if(!(flags >= 0))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_fcntl_1=fcntl(sock, 4, flags | 04000);
    tmp_if_expr_2 = return_value_fcntl_1 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    rfbLogPerror("Setting socket to non-blocking failed");
    return (signed char)0;
  }

  else
    return (signed char)-1;
}

// rfbSetProtocolVersion
// file rfbserver.c line 282
extern void rfbSetProtocolVersion(struct _rfbScreenInfo *rfbScreen, signed int major_, signed int minor_)
{
  if(major_ == 3 && minor_ >= 3 && !(minor_ >= 9))
  {
    rfbScreen->protocolMajorVersion = major_;
    rfbScreen->protocolMinorVersion = minor_;
  }

  else
    rfbLog("rfbSetProtocolVersion(%d,%d) set to invalid values\n", major_, minor_);
}

// rfbSetServerVersionIdentity
// file rfbserver.c line 1055
extern void rfbSetServerVersionIdentity(struct _rfbScreenInfo *screen, char *fmt, ...)
{
  char buffer[256l];
  void **ap = (void **)&fmt;
  vsnprintf(buffer, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, fmt, ap);
  ap = ((void **)NULL);
  if(!(screen->versionString == ((char *)NULL)))
    free((void *)screen->versionString);

  screen->versionString=strdup(buffer);
}

// rfbSetTranslateFunction
// file ../rfb/rfb.h line 820
extern signed char rfbSetTranslateFunction(struct _rfbClientRec *cl)
{
  rfbLog("Pixel format for client %s:\n", cl->host);
  PrintPixelFormat(&cl->format);
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  if(!((signed int)cl->screen->serverFormat.bitsPerPixel == 8))
  {
    rfbErr("%s: server bits per pixel not 8, 16 or 32 (is %d)\n", (const void *)"rfbSetTranslateFunction", cl->screen->serverFormat.bitsPerPixel);
    rfbCloseClient(cl);
    return (signed char)0;
  }

  else
    if(!((signed int)cl->format.bitsPerPixel == 8))
    {
      rfbErr("%s: client bits per pixel not 8, 16 or 32\n", (const void *)"rfbSetTranslateFunction");
      rfbCloseClient(cl);
      return (signed char)0;
    }

    else
      if(cl->format.trueColour == 0)
      {
        rfbErr("rfbSetTranslateFunction: client has colour map but %d-bit - can only cope with 8-bit colour maps\n", cl->format.bitsPerPixel);
        rfbCloseClient(cl);
        return (signed char)0;
      }

      else
      {
        if(cl->format.trueColour == 0)
        {
          signed char return_value_rfbSetClientColourMapBGR233_1;
          return_value_rfbSetClientColourMapBGR233_1=rfbSetClientColourMapBGR233(cl);
          if(return_value_rfbSetClientColourMapBGR233_1 == 0)
            return (signed char)0;

          cl->format = BGR233Format;
        }

        if(cl->format.bitsPerPixel == cl->screen->serverFormat.bitsPerPixel)
        {
          if(cl->format.bigEndian == cl->screen->serverFormat.bigEndian)
            tmp_if_expr_8 = (_Bool)1;

          else
            tmp_if_expr_8 = (signed int)cl->format.bitsPerPixel == 8 ? (_Bool)1 : (_Bool)0;
          if(cl->format.trueColour == 0)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            if(cl->format.redMax == cl->screen->serverFormat.redMax)
              tmp_if_expr_2 = cl->format.greenMax == cl->screen->serverFormat.greenMax ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
              tmp_if_expr_3 = cl->format.blueMax == cl->screen->serverFormat.blueMax ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = cl->format.redShift == cl->screen->serverFormat.redShift ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
              tmp_if_expr_5 = cl->format.greenShift == cl->screen->serverFormat.greenShift ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
              tmp_if_expr_6 = cl->format.blueShift == cl->screen->serverFormat.blueShift ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_6 = (_Bool)0;
            tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
          }
          rfbLog("no translation needed\n");
          cl->translateFn = rfbTranslateNone;
          return (signed char)-1;
        }

        else
        {
          if(!((signed int)cl->screen->serverFormat.bitsPerPixel >= 16))
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            if(cl->screen->serverFormat.trueColour == 0 || rfbEconomicTranslate == 0)
              tmp_if_expr_9 = (signed int)cl->screen->serverFormat.bitsPerPixel == 16 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_9 = (_Bool)0;
            tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
          {
            cl->translateFn = rfbTranslateWithSingleTableFns[(signed long int)((signed int)cl->screen->serverFormat.bitsPerPixel / 8 - 1)][(signed long int)((signed int)cl->format.bitsPerPixel / 8 - 1)];
            if(!(cl->screen->serverFormat.trueColour == 0))
              rfbInitTrueColourSingleTableFns[(signed long int)((signed int)cl->format.bitsPerPixel / 8 - 1)](&cl->translateLookupTable, &cl->screen->serverFormat, &cl->format);

            else
              rfbInitColourMapSingleTableFns[(signed long int)((signed int)cl->format.bitsPerPixel / 8 - 1)](&cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, &cl->screen->colourMap);
          }

          else
          {
            cl->translateFn = rfbTranslateWithRGBTablesFns[(signed long int)((signed int)cl->screen->serverFormat.bitsPerPixel / 8 - 1)][(signed long int)((signed int)cl->format.bitsPerPixel / 8 - 1)];
            rfbInitTrueColourRGBTablesFns[(signed long int)((signed int)cl->format.bitsPerPixel / 8 - 1)](&cl->translateLookupTable, &cl->screen->serverFormat, &cl->format);
          }
          return (signed char)-1;
        }
      }
}

// rfbShowCursor
// file private.h line 6
void rfbShowCursor(struct _rfbClientRec *cl)
{
  struct _rfbScreenInfo *s = cl->screen;
  struct rfbCursor *c = s->cursor;
  signed int i;
  signed int rfbShowCursor__1__j;
  signed int x1;
  signed int x2;
  signed int y1;
  signed int y2;
  signed int i1;
  signed int j1;
  signed int bpp = (signed int)s->serverFormat.bitsPerPixel / 8;
  signed int rowstride = s->paddedWidthInBytes;
  signed int bufSize;
  signed int w;
  signed char wasChanged = (signed char)0;
  _Bool tmp_if_expr_3;
  signed int return_value_memcmp_2;
  if(!(c == ((struct rfbCursor *)NULL)))
  {
    pthread_mutex_lock(&s->cursorMutex);
    bufSize = (signed int)c->width * (signed int)c->height * bpp;
    w = ((signed int)c->width + 7) / 8;
    if(!(s->underCursorBufferLen >= bufSize))
    {
      if(!(s->underCursorBuffer == ((char *)NULL)))
        free((void *)s->underCursorBuffer);

      void *return_value_malloc_1;
      return_value_malloc_1=malloc((unsigned long int)bufSize);
      s->underCursorBuffer = (char *)return_value_malloc_1;
      s->underCursorBufferLen = bufSize;
    }

    j1 = 0;
    i1 = j1;
    x1 = cl->cursorX - (signed int)c->xhot;
    x2 = x1 + (signed int)c->width;
    if(!(x1 >= 0))
    {
      i1 = -x1;
      x1 = 0;
    }

    if(x2 >= s->width)
      x2 = s->width - 1;

    x2 = x2 - x1;
    if(!(x2 >= 1))
      pthread_mutex_unlock(&s->cursorMutex);

    else
    {
      y1 = cl->cursorY - (signed int)c->yhot;
      y2 = y1 + (signed int)c->height;
      if(!(y1 >= 0))
      {
        j1 = -y1;
        y1 = 0;
      }

      if(y2 >= s->height)
        y2 = s->height - 1;

      y2 = y2 - y1;
      if(!(y2 >= 1))
        pthread_mutex_unlock(&s->cursorMutex);

      else
      {
        rfbShowCursor__1__j = 0;
        for( ; !(rfbShowCursor__1__j >= y2); rfbShowCursor__1__j = rfbShowCursor__1__j + 1)
        {
          char *rfbShowCursor__1__6__1__dest = s->underCursorBuffer + (signed long int)(rfbShowCursor__1__j * x2 * bpp);
          const char *rfbShowCursor__1__6__1__src = s->frameBuffer + (signed long int)((y1 + rfbShowCursor__1__j) * rowstride) + (signed long int)(x1 * bpp);
          unsigned int count = (unsigned int)(x2 * bpp);
          if(!(wasChanged == 0))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_memcmp_2=memcmp((const void *)rfbShowCursor__1__6__1__dest, (const void *)rfbShowCursor__1__6__1__src, (unsigned long int)count);
            tmp_if_expr_3 = return_value_memcmp_2 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
          {
            wasChanged = (signed char)-1;
            memcpy((void *)rfbShowCursor__1__6__1__dest, (const void *)rfbShowCursor__1__6__1__src, (unsigned long int)count);
          }

        }
        if(c->richSource == ((unsigned char *)NULL))
          rfbMakeRichCursorFromXCursor(s, c);

        if(!(c->alphaSource == ((unsigned char *)NULL)))
        {
          signed int rmax;
          signed int rshift;
          signed int gmax;
          signed int gshift;
          signed int bmax;
          signed int bshift;
          signed int amax = 255;
          unsigned int rmask;
          unsigned int gmask;
          unsigned int bmask;
          rmax = (signed int)s->serverFormat.redMax;
          gmax = (signed int)s->serverFormat.greenMax;
          bmax = (signed int)s->serverFormat.blueMax;
          rshift = (signed int)s->serverFormat.redShift;
          gshift = (signed int)s->serverFormat.greenShift;
          bshift = (signed int)s->serverFormat.blueShift;
          rmask = (unsigned int)(rmax << rshift);
          gmask = (unsigned int)(gmax << gshift);
          bmask = (unsigned int)(bmax << bshift);
          rfbShowCursor__1__j = 0;
          for( ; !(rfbShowCursor__1__j >= y2); rfbShowCursor__1__j = rfbShowCursor__1__j + 1)
          {
            i = 0;
            for( ; !(i >= x2); i = i + 1)
            {
              char *dest;
              unsigned char *src;
              unsigned char *aptr;
              unsigned int val;
              unsigned int dval;
              unsigned int sval;
              signed int rdst;
              signed int gdst;
              signed int bdst;
              signed int asrc;
              signed int rsrc;
              signed int gsrc;
              signed int bsrc;
              dest = s->frameBuffer + (signed long int)((rfbShowCursor__1__j + y1) * rowstride) + (signed long int)((i + x1) * bpp);
              src = c->richSource + (signed long int)((rfbShowCursor__1__j + j1) * (signed int)c->width * bpp) + (signed long int)((i + i1) * bpp);
              aptr = c->alphaSource + (signed long int)((rfbShowCursor__1__j + j1) * (signed int)c->width) + (signed long int)(i + i1);
              asrc = (signed int)*aptr;
              if(!(asrc == 0))
              {
                if(bpp == 1)
                {
                  dval = (unsigned int)*((unsigned char *)dest);
                  sval = (unsigned int)*((unsigned char *)src);
                }

                else
                  if(bpp == 2)
                  {
                    dval = (unsigned int)*((unsigned short int *)dest);
                    sval = (unsigned int)*((unsigned short int *)src);
                  }

                  else
                    if(bpp == 3)
                    {
                      unsigned char *dst = (unsigned char *)dest;
                      dval = (unsigned int)0;
                      dval = dval | (unsigned int)((signed int)dst[(signed long int)0] << 0);
                      dval = dval | (unsigned int)((signed int)dst[(signed long int)1] << 8);
                      dval = dval | (unsigned int)((signed int)dst[(signed long int)2] << 16);
                      sval = (unsigned int)0;
                      sval = sval | (unsigned int)((signed int)src[(signed long int)0] << 0);
                      sval = sval | (unsigned int)((signed int)src[(signed long int)1] << 8);
                      sval = sval | (unsigned int)((signed int)src[(signed long int)2] << 16);
                    }

                    else
                      if(bpp == 4)
                      {
                        dval = *((unsigned int *)dest);
                        sval = *((unsigned int *)src);
                      }

                      else
                        goto __CPROVER_DUMP_L25;
                rdst = (signed int)((dval & rmask) >> rshift);
                gdst = (signed int)((dval & gmask) >> gshift);
                bdst = (signed int)((dval & bmask) >> bshift);
                rsrc = (signed int)((sval & rmask) >> rshift);
                gsrc = (signed int)((sval & gmask) >> gshift);
                bsrc = (signed int)((sval & bmask) >> bshift);
                if(c->alphaPreMultiplied == 0)
                {
                  rsrc = (asrc * rsrc) / amax;
                  gsrc = (asrc * gsrc) / amax;
                  bsrc = (asrc * bsrc) / amax;
                }

                rdst = rsrc + ((amax - asrc) * rdst) / amax;
                gdst = gsrc + ((amax - asrc) * gdst) / amax;
                bdst = bsrc + ((amax - asrc) * bdst) / amax;
                val = (unsigned int)0;
                val = val | (unsigned int)(rdst << rshift);
                val = val | (unsigned int)(gdst << gshift);
                val = val | (unsigned int)(bdst << bshift);
                memcpy((void *)dest, (const void *)&val, (unsigned long int)bpp);
              }


            __CPROVER_DUMP_L25:
              ;
            }
          }
        }

        else
        {
          rfbShowCursor__1__j = 0;
          for( ; !(rfbShowCursor__1__j >= y2); rfbShowCursor__1__j = rfbShowCursor__1__j + 1)
          {
            i = 0;
            for( ; !(i >= x2); i = i + 1)
              if(!((0x80 & (signed int)c->mask[(signed long int)((rfbShowCursor__1__j + j1) * w + (i + i1) / 8)] << (i + i1 & 7)) == 0))
                memcpy((void *)(s->frameBuffer + (signed long int)((rfbShowCursor__1__j + y1) * rowstride) + (signed long int)((i + x1) * bpp)), (const void *)(c->richSource + (signed long int)((rfbShowCursor__1__j + j1) * (signed int)c->width * bpp) + (signed long int)((i + i1) * bpp)), (unsigned long int)bpp);

          }
        }
        rfbScaledScreenUpdate(s, x1, y1, x1 + x2, y1 + y2);
        pthread_mutex_unlock(&s->cursorMutex);
      }
    }
  }

}

// rfbShutdownServer
// file main.c line 1060
extern void rfbShutdownServer(struct _rfbScreenInfo *screen, signed char disconnectClients)
{
  if(!(disconnectClients == 0))
  {
    struct _rfbClientRec *rfbShutdownServer__1__1__cl;
    struct rfbClientIterator *iter;
    iter=rfbGetClientIterator(screen);
    do
    {
      rfbShutdownServer__1__1__cl=rfbClientIteratorNext(iter);
      if(rfbShutdownServer__1__1__cl == ((struct _rfbClientRec *)NULL))
        break;

      if(rfbShutdownServer__1__1__cl->sock >= 0)
      {
        rfbCloseClient(rfbShutdownServer__1__1__cl);
        rfbClientConnectionGone(rfbShutdownServer__1__1__cl);
      }

    }
    while((_Bool)1);
    rfbReleaseClientIterator(iter);
  }

  rfbShutdownSockets(screen);
  rfbHttpShutdownSockets(screen);
}

// rfbShutdownSockets
// file ../rfb/rfb.h line 745
extern void rfbShutdownSockets(struct _rfbScreenInfo *rfbScreen)
{
  if((signed int)rfbScreen->socketState == RFB_SOCKET_READY)
  {
    rfbScreen->socketState = (enum rfbSocketState)RFB_SOCKET_SHUTDOWN;
    if(rfbScreen->inetdSock >= 0)
    {
      close(rfbScreen->inetdSock);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->inetdSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->inetdSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->inetdSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      rfbScreen->inetdSock = -1;
    }

    if(rfbScreen->listenSock >= 0)
    {
      close(rfbScreen->listenSock);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listenSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->listenSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      rfbScreen->listenSock = -1;
    }

    if(rfbScreen->listen6Sock >= 0)
    {
      close(rfbScreen->listen6Sock);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->listen6Sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->listen6Sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      rfbScreen->listen6Sock = -1;
    }

    if(rfbScreen->udpSock >= 0)
    {
      close(rfbScreen->udpSock);
      (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->udpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfbScreen->allFds)->__fds_bits[(signed long int)(rfbScreen->udpSock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)(1UL << rfbScreen->udpSock % (8 * (signed int)sizeof(signed long int) /*8ul*/ )));
      rfbScreen->udpSock = -1;
    }

  }

}

// rfbStartOnHoldClient
// file main.c line 608
extern void rfbStartOnHoldClient(struct _rfbClientRec *cl)
{
  pthread_create(&cl->client_thread, (const union pthread_attr_t *)(void *)0, clientInput, (void *)cl);
}

// rfbStatGetEncodingCountRcvd
// file stats.c line 348
extern signed int rfbStatGetEncodingCountRcvd(struct _rfbClientRec *cl, unsigned int type)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      if(ptr->type == type)
        return (signed int)ptr->rcvdCount;

    return 0;
  }
}

// rfbStatGetEncodingCountSent
// file stats.c line 340
extern signed int rfbStatGetEncodingCountSent(struct _rfbClientRec *cl, unsigned int type)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      if(ptr->type == type)
        return (signed int)ptr->sentCount;

    return 0;
  }
}

// rfbStatGetMessageCountRcvd
// file stats.c line 331
extern signed int rfbStatGetMessageCountRcvd(struct _rfbClientRec *cl, unsigned int type)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      if(ptr->type == type)
        return (signed int)ptr->rcvdCount;

    return 0;
  }
}

// rfbStatGetMessageCountSent
// file stats.c line 323
extern signed int rfbStatGetMessageCountSent(struct _rfbClientRec *cl, unsigned int type)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      if(ptr->type == type)
        return (signed int)ptr->sentCount;

    return 0;
  }
}

// rfbStatGetRcvdBytes
// file stats.c line 299
extern signed int rfbStatGetRcvdBytes(struct _rfbClientRec *cl)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  signed int bytes = 0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesRcvd;
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesRcvd;
    return bytes;
  }
}

// rfbStatGetRcvdBytesIfRaw
// file stats.c line 311
extern signed int rfbStatGetRcvdBytesIfRaw(struct _rfbClientRec *cl)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  signed int bytes = 0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesRcvdIfRaw;
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesRcvdIfRaw;
    return bytes;
  }
}

// rfbStatGetSentBytes
// file stats.c line 275
extern signed int rfbStatGetSentBytes(struct _rfbClientRec *cl)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  signed int bytes = 0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesSent;
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesSent;
    return bytes;
  }
}

// rfbStatGetSentBytesIfRaw
// file stats.c line 287
extern signed int rfbStatGetSentBytesIfRaw(struct _rfbClientRec *cl)
{
  struct _rfbStatList *ptr = (struct _rfbStatList *)(void *)0;
  signed int bytes = 0;
  if(cl == ((struct _rfbClientRec *)NULL))
    return 0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesSentIfRaw;
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      bytes = bytes + (signed int)ptr->bytesSentIfRaw;
    return bytes;
  }
}

// rfbStatLookupEncoding
// file stats.c line 169
extern struct _rfbStatList * rfbStatLookupEncoding(struct _rfbClientRec *cl, unsigned int type)
{
  struct _rfbStatList *ptr;
  if(cl == ((struct _rfbClientRec *)NULL))
    return (struct _rfbStatList *)(void *)0;

  else
  {
    ptr = cl->statEncList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      if(ptr->type == type)
        return ptr;

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _rfbStatList) /*40ul*/ );
    ptr = (struct _rfbStatList *)return_value_malloc_1;
    if(!(ptr == ((struct _rfbStatList *)NULL)))
    {
      memset((void *)(char *)ptr, 0, sizeof(struct _rfbStatList) /*40ul*/ );
      ptr->type = type;
      ptr->Next = cl->statEncList;
      cl->statEncList = ptr;
    }

    return ptr;
  }
}

// rfbStatLookupMessage
// file stats.c line 191
extern struct _rfbStatList * rfbStatLookupMessage(struct _rfbClientRec *cl, unsigned int type)
{
  struct _rfbStatList *ptr;
  if(cl == ((struct _rfbClientRec *)NULL))
    return (struct _rfbStatList *)(void *)0;

  else
  {
    ptr = cl->statMsgList;
    for( ; !(ptr == ((struct _rfbStatList *)NULL)); ptr = ptr->Next)
      if(ptr->type == type)
        return ptr;

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct _rfbStatList) /*40ul*/ );
    ptr = (struct _rfbStatList *)return_value_malloc_1;
    if(!(ptr == ((struct _rfbStatList *)NULL)))
    {
      memset((void *)(char *)ptr, 0, sizeof(struct _rfbStatList) /*40ul*/ );
      ptr->type = type;
      ptr->Next = cl->statMsgList;
      cl->statMsgList = ptr;
    }

    return ptr;
  }
}

// rfbStatRecordEncodingRcvd
// file stats.c line 235
extern void rfbStatRecordEncodingRcvd(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw)
{
  struct _rfbStatList *ptr;
  ptr=rfbStatLookupEncoding(cl, type);
  if(!(ptr == ((struct _rfbStatList *)NULL)))
  {
    ptr->rcvdCount = ptr->rcvdCount + 1u;
    ptr->bytesRcvd = ptr->bytesRcvd + (unsigned int)byteCount;
    ptr->bytesRcvdIfRaw = ptr->bytesRcvdIfRaw + (unsigned int)byteIfRaw;
  }

}

// rfbStatRecordEncodingSent
// file ../rfb/rfb.h line 1070
extern void rfbStatRecordEncodingSent(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw)
{
  struct _rfbStatList *ptr;
  ptr=rfbStatLookupEncoding(cl, type);
  if(!(ptr == ((struct _rfbStatList *)NULL)))
  {
    ptr->sentCount = ptr->sentCount + 1u;
    ptr->bytesSent = ptr->bytesSent + (unsigned int)byteCount;
    ptr->bytesSentIfRaw = ptr->bytesSentIfRaw + (unsigned int)byteIfRaw;
  }

}

// rfbStatRecordEncodingSentAdd
// file stats.c line 212
extern void rfbStatRecordEncodingSentAdd(struct _rfbClientRec *cl, unsigned int type, signed int byteCount)
{
  struct _rfbStatList *ptr;
  ptr=rfbStatLookupEncoding(cl, type);
  if(!(ptr == ((struct _rfbStatList *)NULL)))
    ptr->bytesSent = ptr->bytesSent + (unsigned int)byteCount;

}

// rfbStatRecordMessageRcvd
// file ../rfb/rfb.h line 1074
extern void rfbStatRecordMessageRcvd(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw)
{
  struct _rfbStatList *ptr;
  ptr=rfbStatLookupMessage(cl, type);
  if(!(ptr == ((struct _rfbStatList *)NULL)))
  {
    ptr->rcvdCount = ptr->rcvdCount + 1u;
    ptr->bytesRcvd = ptr->bytesRcvd + (unsigned int)byteCount;
    ptr->bytesRcvdIfRaw = ptr->bytesRcvdIfRaw + (unsigned int)byteIfRaw;
  }

}

// rfbStatRecordMessageSent
// file ../rfb/rfb.h line 1073
extern void rfbStatRecordMessageSent(struct _rfbClientRec *cl, unsigned int type, signed int byteCount, signed int byteIfRaw)
{
  struct _rfbStatList *ptr;
  ptr=rfbStatLookupMessage(cl, type);
  if(!(ptr == ((struct _rfbStatList *)NULL)))
  {
    ptr->sentCount = ptr->sentCount + 1u;
    ptr->bytesSent = ptr->bytesSent + (unsigned int)byteCount;
    ptr->bytesSentIfRaw = ptr->bytesSentIfRaw + (unsigned int)byteIfRaw;
  }

}

// rfbStringToAddr
// file sockets.c line 836
extern signed int rfbStringToAddr(char *str, unsigned int *addr)
{
  _Bool tmp_if_expr_3;
  if(str == ((char *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)*str == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_strcmp_4=strcmp(str, "any");
    tmp_if_expr_5 = return_value_strcmp_4 == 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcmp_2;
  if(tmp_if_expr_5)
    *addr=htonl((unsigned int)0x00000000);

  else
  {
    return_value_strcmp_2=strcmp(str, "localhost");
    if(return_value_strcmp_2 == 0)
      *addr=htonl((unsigned int)0x7f000001);

    else
    {
      struct hostent *hp;
      *addr=inet_addr(str);
      unsigned int return_value_htonl_1;
      return_value_htonl_1=htonl((unsigned int)0xffffffff);
      if(*addr == return_value_htonl_1)
      {
        hp=gethostbyname(str);
        if(hp == ((struct hostent *)NULL))
          return 0;

        *addr = (unsigned int)*((unsigned long int *)hp->h_addr_list[(signed long int)0]);
      }

    }
  }
  return 1;
}

// rfbTightCleanup
// file private.h line 18
extern void rfbTightCleanup(struct _rfbScreenInfo *screen)
{
  if(!(tightBeforeBufSize == 0))
  {
    free((void *)tightBeforeBuf);
    tightBeforeBufSize = 0;
    tightBeforeBuf = (char *)(void *)0;
  }

  if(!(tightAfterBufSize == 0))
  {
    free((void *)tightAfterBuf);
    tightAfterBufSize = 0;
    tightAfterBuf = (char *)(void *)0;
  }

  if(!(j == NULL))
    tjDestroy(j);

}

// rfbTightExtensionClientClose
// file tightvnc-filetransfer/rfbtightserver.c line 449
void rfbTightExtensionClientClose(struct _rfbClientRec *cl, void *data)
{
  if(!(data == NULL))
    free(data);

}

// rfbTightExtensionInit
// file tightvnc-filetransfer/rfbtightserver.c line 364
signed char rfbTightExtensionInit(struct _rfbClientRec *cl, void *data)
{
  rfbSendInteractionCaps(cl);
  return (signed char)-1;
}

// rfbTightExtensionMsgHandler
// file tightvnc-filetransfer/rfbtightserver.c line 395
signed char rfbTightExtensionMsgHandler(struct _rfbClientRec *cl, void *data, const union anonymous_1 *msg)
{
  signed char return_value_handleMessage_1;
  signed char return_value_handleMessage_2;
  signed char return_value_handleMessage_3;
  signed char return_value_handleMessage_4;
  signed char return_value_handleMessage_5;
  signed char return_value_handleMessage_6;
  signed char return_value_handleMessage_7;
  switch((signed int)msg->type)
  {
    case 130:
    {
      return_value_handleMessage_1=handleMessage(cl, "rfbFileListRequest", HandleFileListRequest);
      return return_value_handleMessage_1;
    }
    case 131:
    {
      return_value_handleMessage_2=handleMessage(cl, "rfbFileDownloadRequest", HandleFileDownloadRequest);
      return return_value_handleMessage_2;
    }
    case 132:
    {
      return_value_handleMessage_3=handleMessage(cl, "rfbFileUploadRequest", HandleFileUploadRequest);
      return return_value_handleMessage_3;
    }
    case 133:
    {
      return_value_handleMessage_4=handleMessage(cl, "rfbFileUploadDataRequest", HandleFileUploadDataRequest);
      return return_value_handleMessage_4;
    }
    case 134:
    {
      return_value_handleMessage_5=handleMessage(cl, "rfbFileDownloadCancelRequest", HandleFileDownloadCancelRequest);
      return return_value_handleMessage_5;
    }
    case 135:
    {
      return_value_handleMessage_6=handleMessage(cl, "rfbFileUploadFailedRequest", HandleFileUploadFailedRequest);
      return return_value_handleMessage_6;
    }
    case 136:
    {
      return_value_handleMessage_7=handleMessage(cl, "rfbFileCreateDirRequest", HandleFileCreateDirRequest);
      return return_value_handleMessage_7;
    }
    default:
      rfbLog("rfbProcessClientNormalMessage: unknown message type %d\n", msg->type);
  }
  return (signed char)0;
}

// rfbTightProcessArg
// file tightvnc-filetransfer/rfbtightserver.c line 465
signed int rfbTightProcessArg(signed int argc, char **argv)
{
  rfbLog("tightvnc-filetransfer/rfbTightProcessArg\n");
  InitFileTransfer();
  signed int return_value_strcmp_2;
  if(!(argc >= 1))
    return 0;

  else
  {
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(argv[(signed long int)0], "-ftproot");
    if(return_value_strcmp_3 == 0)
    {
      if(!(argc >= 2))
        return 0;

      rfbLog("ftproot is set to <%s>\n", argv[(signed long int)1]);
      signed int return_value_SetFtpRoot_1;
      return_value_SetFtpRoot_1=SetFtpRoot(argv[(signed long int)1]);
      if(return_value_SetFtpRoot_1 == 0)
      {
        rfbLog("ERROR:: Path specified for ftproot in invalid\n");
        return 0;
      }

      return 2;
    }

    else
    {
      return_value_strcmp_2=strcmp(argv[(signed long int)0], "-disablefiletransfer");
      if(return_value_strcmp_2 == 0)
      {
        EnableFileTransfer((signed char)0);
        return 1;
      }

    }
    return 0;
  }
}

// rfbTightUsage
// file tightvnc-filetransfer/rfbtightserver.c line 457
void rfbTightUsage(void)
{
  fprintf(stderr, "\nlibvncserver-tight-extension options:\n");
  fprintf(stderr, "-disablefiletransfer   disable file transfer\n");
  fprintf(stderr, "-ftproot string        set ftp root\n");
  fprintf(stderr, "\n");
}

// rfbTranslateNone
// file ../rfb/rfb.h line 815
extern void rfbTranslateNone(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  signed int bytesPerOutputLine = width * ((signed int)out->bitsPerPixel / 8);
  for( ; height >= 1; height = height - 1)
  {
    memcpy((void *)optr, (const void *)iptr, (unsigned long int)bytesPerOutputLine);
    iptr = iptr + (signed long int)bytesBetweenInputLines;
    optr = optr + (signed long int)bytesPerOutputLine;
  }
}

// rfbTranslateWithRGBTables16to16
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables16to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned short int *opLineEnd;
  unsigned short int *redTable = (unsigned short int *)table;
  unsigned short int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned short int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned short int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned short int)((signed int)redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | (signed int)greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | (signed int)blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables16to24
// file tabletrans24template.c line 243
static void rfbTranslateWithRGBTables16to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)(3 * ((signed int)in->redMax + 1));
  unsigned char *blueTable = greenTable + (signed long int)(3 * ((signed int)in->greenMax + 1));
  unsigned int outValue;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(3 * width);
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      outValue = (unsigned int)((signed int)redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | (signed int)greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | (signed int)blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)]);
      memcpy((void *)op, (const void *)&outValue, (unsigned long int)3);
      op = op + (signed long int)3;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables16to32
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables16to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned int *opLineEnd;
  unsigned int *redTable = (unsigned int *)table;
  unsigned int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables16to8
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables16to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned char *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned char *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)((signed int)redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | (signed int)greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | (signed int)blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables24to16
// file tabletrans24template.c line 174
static void rfbTranslateWithRGBTables24to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned short int *opLineEnd;
  unsigned short int *redTable = (unsigned short int *)table;
  unsigned short int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned short int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned int inValue;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned short int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      inValue = *((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff;
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned short int)((signed int)redTable[(signed long int)(inValue >> (signed int)in->redShift & (unsigned int)in->redMax)] | (signed int)greenTable[(signed long int)(inValue >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | (signed int)blueTable[(signed long int)(inValue >> (signed int)in->blueShift & (unsigned int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables24to24
// file tabletrans24template.c line 89
static void rfbTranslateWithRGBTables24to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)(3 * ((signed int)in->redMax + 1));
  unsigned char *blueTable = greenTable + (signed long int)(3 * ((signed int)in->greenMax + 1));
  unsigned int outValue;
  unsigned int inValue;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(3 * width);
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      inValue = *((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff;
      outValue = (unsigned int)((signed int)redTable[(signed long int)(inValue >> (signed int)in->redShift & (unsigned int)in->redMax)] | (signed int)greenTable[(signed long int)(inValue >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | (signed int)blueTable[(signed long int)(inValue >> (signed int)in->blueShift & (unsigned int)in->blueMax)]);
      memcpy((void *)op, (const void *)&outValue, (unsigned long int)3);
      op = op + (signed long int)3;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables24to32
// file tabletrans24template.c line 174
static void rfbTranslateWithRGBTables24to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned int *opLineEnd;
  unsigned int *redTable = (unsigned int *)table;
  unsigned int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned int inValue;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      inValue = *((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff;
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = redTable[(signed long int)(inValue >> (signed int)in->redShift & (unsigned int)in->redMax)] | greenTable[(signed long int)(inValue >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | blueTable[(signed long int)(inValue >> (signed int)in->blueShift & (unsigned int)in->blueMax)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables24to8
// file tabletrans24template.c line 174
static void rfbTranslateWithRGBTables24to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned char *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned int inValue;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned char *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      inValue = *((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff;
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)((signed int)redTable[(signed long int)(inValue >> (signed int)in->redShift & (unsigned int)in->redMax)] | (signed int)greenTable[(signed long int)(inValue >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | (signed int)blueTable[(signed long int)(inValue >> (signed int)in->blueShift & (unsigned int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables32to16
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables32to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned short int *opLineEnd;
  unsigned short int *redTable = (unsigned short int *)table;
  unsigned short int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned short int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned short int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned short int)((signed int)redTable[(signed long int)(*ip >> (signed int)in->redShift & (unsigned int)in->redMax)] | (signed int)greenTable[(signed long int)(*ip >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | (signed int)blueTable[(signed long int)(*ip >> (signed int)in->blueShift & (unsigned int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables32to24
// file tabletrans24template.c line 243
static void rfbTranslateWithRGBTables32to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)(3 * ((signed int)in->redMax + 1));
  unsigned char *blueTable = greenTable + (signed long int)(3 * ((signed int)in->greenMax + 1));
  unsigned int outValue;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(3 * width);
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      outValue = (unsigned int)((signed int)redTable[(signed long int)(*ip >> (signed int)in->redShift & (unsigned int)in->redMax)] | (signed int)greenTable[(signed long int)(*ip >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | (signed int)blueTable[(signed long int)(*ip >> (signed int)in->blueShift & (unsigned int)in->blueMax)]);
      memcpy((void *)op, (const void *)&outValue, (unsigned long int)3);
      op = op + (signed long int)3;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables32to32
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables32to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned int *opLineEnd;
  unsigned int *redTable = (unsigned int *)table;
  unsigned int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = redTable[(signed long int)(*ip >> (signed int)in->redShift & (unsigned int)in->redMax)] | greenTable[(signed long int)(*ip >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | blueTable[(signed long int)(*ip >> (signed int)in->blueShift & (unsigned int)in->blueMax)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables32to8
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables32to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned char *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned char *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)((signed int)redTable[(signed long int)(*ip >> (signed int)in->redShift & (unsigned int)in->redMax)] | (signed int)greenTable[(signed long int)(*ip >> (signed int)in->greenShift & (unsigned int)in->greenMax)] | (signed int)blueTable[(signed long int)(*ip >> (signed int)in->blueShift & (unsigned int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables8to16
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables8to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned short int *opLineEnd;
  unsigned short int *redTable = (unsigned short int *)table;
  unsigned short int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned short int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned short int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned short int)((signed int)redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | (signed int)greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | (signed int)blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables8to24
// file tabletrans24template.c line 243
static void rfbTranslateWithRGBTables8to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)(3 * ((signed int)in->redMax + 1));
  unsigned char *blueTable = greenTable + (signed long int)(3 * ((signed int)in->greenMax + 1));
  unsigned int outValue;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(3 * width);
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      outValue = (unsigned int)((signed int)redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | (signed int)greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | (signed int)blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)]);
      memcpy((void *)op, (const void *)&outValue, (unsigned long int)3);
      op = op + (signed long int)3;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables8to32
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables8to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned int *opLineEnd;
  unsigned int *redTable = (unsigned int *)table;
  unsigned int *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned int *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithRGBTables8to8
// file tabletranstemplate.c line 86
static void rfbTranslateWithRGBTables8to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *redTable = (unsigned char *)table;
  unsigned char *greenTable = redTable + (signed long int)in->redMax + (signed long int)1;
  unsigned char *blueTable = greenTable + (signed long int)in->greenMax + (signed long int)1;
  unsigned char *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = &op[(signed long int)width];
    for( ; !(op >= opLineEnd); ip = ip + 1l)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = (unsigned char)((signed int)redTable[(signed long int)((signed int)*ip >> (signed int)in->redShift & (signed int)in->redMax)] | (signed int)greenTable[(signed long int)((signed int)*ip >> (signed int)in->greenShift & (signed int)in->greenMax)] | (signed int)blueTable[(signed long int)((signed int)*ip >> (signed int)in->blueShift & (signed int)in->blueMax)]);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable16to16
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable16to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned short int *opLineEnd;
  unsigned short int *t = (unsigned short int *)table;
  unsigned short int *tmp_post_1;
  unsigned short int *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable16to24
// file tabletrans24template.c line 211
static void rfbTranslateWithSingleTable16to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  unsigned short int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(width * 3);
    for( ; !(op >= opLineEnd); op = op + (signed long int)3)
    {
      tmp_post_1 = ip;
      ip = ip + 1l;
      memcpy((void *)op, (const void *)&t[(signed long int)(3 * (signed int)*tmp_post_1)], (unsigned long int)3);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable16to32
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable16to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned int *opLineEnd;
  unsigned int *t = (unsigned int *)table;
  unsigned int *tmp_post_1;
  unsigned short int *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable16to8
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable16to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned short int *ip = (unsigned short int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned short int) /*2ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  unsigned char *tmp_post_1;
  unsigned short int *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable24to16
// file tabletrans24template.c line 141
static void rfbTranslateWithSingleTable24to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned short int *opLineEnd;
  unsigned short int *t = (unsigned short int *)table;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned short int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = t[(signed long int)(*((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable24to24
// file tabletrans24template.c line 50
static void rfbTranslateWithSingleTable24to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned char c;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(width * 3);
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      *((unsigned int *)op) = (unsigned int)t[(signed long int)(*((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff)];
      if(rfbEndianTest == 0)
        memmove((void *)op, (const void *)(op + (signed long int)1), (unsigned long int)3);

      if(!(out->bigEndian == in->bigEndian))
      {
        c = op[(signed long int)0];
        op[(signed long int)0] = op[(signed long int)2];
        op[(signed long int)2] = c;
      }

      op = op + (signed long int)3;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable24to32
// file tabletrans24template.c line 141
static void rfbTranslateWithSingleTable24to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned int *opLineEnd;
  unsigned int *t = (unsigned int *)table;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = t[(signed long int)(*((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable24to8
// file tabletrans24template.c line 141
static void rfbTranslateWithSingleTable24to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = bytesBetweenInputLines - width * 3;
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  signed int shift = rfbEndianTest != 0 ? 0 : 8;
  unsigned char *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); ip = ip + (signed long int)3)
    {
      tmp_post_1 = op;
      op = op + 1l;
      *tmp_post_1 = t[(signed long int)(*((unsigned int *)ip) >> shift & (unsigned int)0x00ffffff)];
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable32to16
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable32to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned short int *opLineEnd;
  unsigned short int *t = (unsigned short int *)table;
  unsigned short int *tmp_post_1;
  unsigned int *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable32to24
// file tabletrans24template.c line 211
static void rfbTranslateWithSingleTable32to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  unsigned int *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(width * 3);
    for( ; !(op >= opLineEnd); op = op + (signed long int)3)
    {
      tmp_post_1 = ip;
      ip = ip + 1l;
      memcpy((void *)op, (const void *)&t[(signed long int)((unsigned int)3 * *tmp_post_1)], (unsigned long int)3);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable32to32
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable32to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned int *opLineEnd;
  unsigned int *t = (unsigned int *)table;
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable32to8
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable32to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned int *ip = (unsigned int *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned int) /*4ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  unsigned char *tmp_post_1;
  unsigned int *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable8to16
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable8to16(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned short int *op = (unsigned short int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned short int *opLineEnd;
  unsigned short int *t = (unsigned short int *)table;
  unsigned short int *tmp_post_1;
  unsigned char *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable8to24
// file tabletrans24template.c line 211
static void rfbTranslateWithSingleTable8to24(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  unsigned char *tmp_post_1;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)(width * 3);
    for( ; !(op >= opLineEnd); op = op + (signed long int)3)
    {
      tmp_post_1 = ip;
      ip = ip + 1l;
      memcpy((void *)op, (const void *)&t[(signed long int)(3 * (signed int)*tmp_post_1)], (unsigned long int)3);
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable8to32
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable8to32(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned int *op = (unsigned int *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned int *opLineEnd;
  unsigned int *t = (unsigned int *)table;
  unsigned int *tmp_post_1;
  unsigned char *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbTranslateWithSingleTable8to8
// file tabletranstemplate.c line 55
static void rfbTranslateWithSingleTable8to8(char *table, struct anonymous_7 *in, struct anonymous_7 *out, char *iptr, char *optr, signed int bytesBetweenInputLines, signed int width, signed int height)
{
  unsigned char *ip = (unsigned char *)iptr;
  unsigned char *op = (unsigned char *)optr;
  signed int ipextra = (signed int)((unsigned long int)bytesBetweenInputLines / sizeof(unsigned char) /*1ul*/  - (unsigned long int)width);
  unsigned char *opLineEnd;
  unsigned char *t = (unsigned char *)table;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  for( ; height >= 1; height = height - 1)
  {
    opLineEnd = op + (signed long int)width;
    for( ; !(op >= opLineEnd); *tmp_post_1 = t[(signed long int)*tmp_post_2])
    {
      tmp_post_1 = op;
      op = op + 1l;
      tmp_post_2 = ip;
      ip = ip + 1l;
    }
    ip = ip + (signed long int)ipextra;
  }
}

// rfbUnregisterProtocolExtension
// file main.c line 108
void rfbUnregisterProtocolExtension(struct _rfbProtocolExtension *extension)
{
  struct _rfbProtocolExtension *cur = (struct _rfbProtocolExtension *)(void *)0;
  struct _rfbProtocolExtension *pre = (struct _rfbProtocolExtension *)(void *)0;
  if(!(extension == ((struct _rfbProtocolExtension *)NULL)))
  {
    if(extMutex_initialized == 0)
    {
      pthread_mutex_init(&extMutex, (const union anonymous_0 *)(void *)0);
      extMutex_initialized = 1;
    }

    pthread_mutex_lock(&extMutex);
    if(rfbExtensionHead == extension)
    {
      rfbExtensionHead = rfbExtensionHead->next;
      pthread_mutex_unlock(&extMutex);
      rfbUnregisterProtocolExtension(extension->next);
    }

    else
    {
      pre = rfbExtensionHead;
      cur = pre;
      for( ; !(cur == ((struct _rfbProtocolExtension *)NULL)); cur = cur->next)
      {
        if(cur == extension)
        {
          pre->next = cur->next;
          break;
        }

        pre = cur;
      }
      pthread_mutex_unlock(&extMutex);
      rfbUnregisterProtocolExtension(extension->next);
    }
  }

}

// rfbUnregisterSecurityHandler
// file auth.c line 79
extern void rfbUnregisterSecurityHandler(struct _rfbSecurity *handler)
{
  struct _rfbSecurity *cur = (struct _rfbSecurity *)(void *)0;
  struct _rfbSecurity *pre = (struct _rfbSecurity *)(void *)0;
  if(!(handler == ((struct _rfbSecurity *)NULL)))
  {
    if(securityHandlers == handler)
    {
      securityHandlers = securityHandlers->next;
      rfbUnregisterSecurityHandler(handler->next);
    }

    else
    {
      pre = securityHandlers;
      cur = pre;
      for( ; !(cur == ((struct _rfbSecurity *)NULL)); cur = cur->next)
      {
        if(cur == handler)
        {
          pre->next = cur->next;
          break;
        }

        pre = cur;
      }
      rfbUnregisterSecurityHandler(handler->next);
    }
  }

}

// rfbUnregisterTightVNCFileTransferExtension
// file tightvnc-filetransfer/rfbtightserver.c line 542
void rfbUnregisterTightVNCFileTransferExtension()
{
  rfbUnregisterProtocolExtension(&tightVncFileTransferExtension);
  rfbUnregisterSecurityHandler(&tightVncSecurityHandler);
}

// rfbUpdateClient
// file main.c line 1124
signed char rfbUpdateClient(struct _rfbClientRec *cl)
{
  struct timeval tv;
  signed char result = (signed char)0;
  struct _rfbScreenInfo *screen = cl->screen;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_12;
  signed char return_value_sraRgnEmpty_11;
  _Bool tmp_if_expr_14;
  signed char return_value_sraRgnEmpty_13;
  signed char return_value_sraRgnEmpty_2;
  _Bool tmp_if_expr_1;
  if(cl->sock >= 0)
  {
    if(cl->onHold == 0)
    {
      if(!(cl->enableCursorShapeUpdates == 0))
        tmp_if_expr_3 = cl->cursorWasChanged != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if((signed int)cl->enableCursorShapeUpdates == 0)
        {
          if(!(cl->cursorX == cl->screen->cursorX))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = cl->cursorY != cl->screen->cursorY ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        if(!(cl->useNewFBSize == 0))
          tmp_if_expr_7 = cl->newFBSizePending != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        if(!(cl->enableCursorPosUpdates == 0))
          tmp_if_expr_9 = cl->cursorWasMoved != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_10)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_sraRgnEmpty_11=sraRgnEmpty(cl->copyRegion);
        tmp_if_expr_12 = !(return_value_sraRgnEmpty_11 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_sraRgnEmpty_13=sraRgnEmpty(cl->modifiedRegion);
        tmp_if_expr_14 = !(return_value_sraRgnEmpty_13 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_14)
      {
        return_value_sraRgnEmpty_2=sraRgnEmpty(cl->requestedRegion);
        if(return_value_sraRgnEmpty_2 == 0)
        {
          result = (signed char)-1;
          if(screen->deferUpdateTime == 0)
            rfbSendFramebufferUpdate(cl, cl->modifiedRegion);

          else
            if(cl->startDeferring.tv_usec == 0l)
            {
              gettimeofday(&cl->startDeferring, (struct timezone *)(void *)0);
              if(cl->startDeferring.tv_usec == 0l)
                cl->startDeferring.tv_usec = cl->startDeferring.tv_usec + 1l;

            }

            else
            {
              gettimeofday(&tv, (struct timezone *)(void *)0);
              if(!(tv.tv_sec >= cl->startDeferring.tv_sec))
                tmp_if_expr_1 = (_Bool)1;

              else
                tmp_if_expr_1 = (tv.tv_sec - cl->startDeferring.tv_sec) * (signed long int)1000 + (tv.tv_usec - cl->startDeferring.tv_usec) / (signed long int)1000 > (signed long int)screen->deferUpdateTime ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_1)
              {
                cl->startDeferring.tv_usec = (signed long int)0;
                rfbSendFramebufferUpdate(cl, cl->modifiedRegion);
              }

            }
        }

      }

    }

  }

  _Bool tmp_if_expr_15;
  if(cl->viewOnly == 0)
  {
    if(cl->lastPtrX >= 0)
    {
      if(cl->startPtrDeferring.tv_usec == 0l)
      {
        gettimeofday(&cl->startPtrDeferring, (struct timezone *)(void *)0);
        if(cl->startPtrDeferring.tv_usec == 0l)
          cl->startPtrDeferring.tv_usec = cl->startPtrDeferring.tv_usec + 1l;

      }

      else
      {
        struct timeval rfbUpdateClient__1__2__2__tv;
        gettimeofday(&rfbUpdateClient__1__2__2__tv, (struct timezone *)(void *)0);
        if(!(rfbUpdateClient__1__2__2__tv.tv_sec >= cl->startPtrDeferring.tv_sec))
          tmp_if_expr_15 = (_Bool)1;

        else
          tmp_if_expr_15 = (rfbUpdateClient__1__2__2__tv.tv_sec - cl->startPtrDeferring.tv_sec) * (signed long int)1000 + (rfbUpdateClient__1__2__2__tv.tv_usec - cl->startPtrDeferring.tv_usec) / (signed long int)1000 > (signed long int)cl->screen->deferPtrUpdateTime ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_15)
        {
          cl->startPtrDeferring.tv_usec = (signed long int)0;
          cl->screen->ptrAddEvent(cl->lastPtrButtons, cl->lastPtrX, cl->lastPtrY, cl);
          cl->lastPtrX = -1;
        }

      }
    }

  }

  return result;
}

// rfbUsage
// file cargs.c line 20
extern void rfbUsage(void)
{
  struct _rfbProtocolExtension *extension;
  fprintf(stderr, "-rfbport port          TCP port for RFB protocol\n");
  fprintf(stderr, "-rfbportv6 port        TCP6 port for RFB protocol\n");
  fprintf(stderr, "-rfbwait time          max time in ms to wait for RFB client\n");
  fprintf(stderr, "-rfbauth passwd-file   use authentication on RFB protocol\n                       (use 'storepasswd' to create a password file)\n");
  fprintf(stderr, "-rfbversion 3.x        Set the version of the RFB we choose to advertise\n");
  fprintf(stderr, "-permitfiletransfer    permit file transfer support\n");
  fprintf(stderr, "-passwd plain-password use authentication \n                       (use plain-password as password, USE AT YOUR RISK)\n");
  fprintf(stderr, "-deferupdate time      time in ms to defer updates (default 40)\n");
  fprintf(stderr, "-deferptrupdate time   time in ms to defer pointer updates (default none)\n");
  fprintf(stderr, "-desktop name          VNC desktop name (default \"LibVNCServer\")\n");
  fprintf(stderr, "-alwaysshared          always treat new clients as shared\n");
  fprintf(stderr, "-nevershared           never treat new clients as shared\n");
  fprintf(stderr, "-dontdisconnect        don't disconnect existing clients when a new non-shared\n                       connection comes in (refuse new connection instead)\n");
  fprintf(stderr, "-httpdir dir-path      enable http server using dir-path home\n");
  fprintf(stderr, "-httpport portnum      use portnum for http connection\n");
  fprintf(stderr, "-httpportv6 portnum    use portnum for IPv6 http connection\n");
  fprintf(stderr, "-enablehttpproxy       enable http proxy support\n");
  fprintf(stderr, "-progressive height    enable progressive updating for slow links\n");
  fprintf(stderr, "-listen ipaddr         listen for connections only on network interface with\n");
  fprintf(stderr, "                       addr ipaddr. '-listen localhost' and hostname work too.\n");
  fprintf(stderr, "-listenv6 ipv6addr     listen for IPv6 connections only on network interface with\n");
  fprintf(stderr, "                       addr ipv6addr. '-listen localhost' and hostname work too.\n");
  extension=rfbGetExtensionIterator();
  for( ; !(extension == ((struct _rfbProtocolExtension *)NULL)); extension = extension->next)
    if(!(extension->usage == ((void (*)(void))NULL)))
      extension->usage();

  rfbReleaseExtensionIterator();
}

// rfbUseKey
// file ../common/d3des.c line 141
extern void rfbUseKey(unsigned long int *from)
{
  unsigned long int *to;
  unsigned long int *endp;
  to = KnL;
  endp = &KnL[(signed long int)32];
  unsigned long int *tmp_post_1;
  unsigned long int *tmp_post_2;
  for( ; !(to >= endp); *tmp_post_1 = *tmp_post_2)
  {
    tmp_post_1 = to;
    to = to + 1l;
    tmp_post_2 = from;
    from = from + 1l;
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// rfbVncAuthNone
// file auth.c line 142
static void rfbVncAuthNone(struct _rfbClientRec *cl)
{
  unsigned int authResult;
  if(cl->protocolMajorVersion == 3)
  {
    if(cl->protocolMinorVersion >= 8)
    {
      if(!(cl->protocolMinorVersion == 889))
      {
        rfbLog("rfbProcessClientSecurityType: returning securityResult for client rfb version >= 3.8\n");
        authResult = (unsigned int)(rfbEndianTest != 0 ? 0 >> 24 | (0 & 0x00ff0000) >> 8 | (0 & 0x0000ff00) << 8 | 0 << 24 : 0);
        signed int return_value_rfbWriteExact_1;
        return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)&authResult, 4);
        if(!(return_value_rfbWriteExact_1 >= 0))
        {
          rfbLogPerror("rfbAuthProcessClientMessage: write");
          rfbCloseClient(cl);
        }

      }

    }

  }

  cl->state = (enum anonymous_13)(cl->protocolMinorVersion == 889 ? RFB_INITIALISATION_SHARED : RFB_INITIALISATION);
  if((signed int)cl->state == RFB_INITIALISATION_SHARED)
    rfbProcessClientMessage(cl);

  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// rfbVncAuthSendChallenge
// file auth.c line 110
static void rfbVncAuthSendChallenge(struct _rfbClientRec *cl)
{
  rfbRandomBytes(cl->authChallenge);
  signed int return_value_rfbWriteExact_1;
  return_value_rfbWriteExact_1=rfbWriteExact(cl, (char *)cl->authChallenge, 16);
  if(!(return_value_rfbWriteExact_1 >= 0))
  {
    rfbLogPerror("rfbAuthNewClient: write");
    rfbCloseClient(cl);
  }

  else
    cl->state = (enum anonymous_13)RFB_AUTHENTICATION;
}

// rfbVncAuthSendChallenge_link1
// file tightvnc-filetransfer/rfbtightserver.c line 59
static void rfbVncAuthSendChallenge_link1(struct _rfbClientRec *cl_link1)
{
  rfbLog("tightvnc-filetransfer/rfbVncAuthSendChallenge\n");
  rfbRandomBytes(cl_link1->authChallenge);
  signed int return_value_rfbWriteExact_1_link1;
  return_value_rfbWriteExact_1_link1=rfbWriteExact(cl_link1, (char *)cl_link1->authChallenge, 16);
  if(!(return_value_rfbWriteExact_1_link1 >= 0))
  {
    rfbLogPerror("rfbAuthNewClient: write");
    rfbCloseClient(cl_link1);
  }

  else
    rfbAuthProcessClientMessage(cl_link1);
}

// rfbWholeFontBBox
// file font.c line 143
void rfbWholeFontBBox(struct rfbFontData *font, signed int *x1, signed int *y1, signed int *x2, signed int *y2)
{
  signed int i;
  signed int *m = font->metaData;
  *y1 = 0x7fffffff;
  *x1 = *y1;
  *y2 = 1 - 0x7fffffff;
  *x2 = *y2;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    if(!(*x2 >= m[(signed long int)(5 * i + 1)] + -m[(signed long int)(5 * i + 3)]))
      *x2 = m[(signed long int)(i * 5 + 1)] - m[(signed long int)(i * 5 + 3)];

    if(!(m[(signed long int)(5 * i + 4)] + -m[(signed long int)(5 * i + 2)] >= *y1))
      *y1 = -m[(signed long int)(i * 5 + 2)] + m[(signed long int)(i * 5 + 4)];

    if(!(m[(signed long int)(5 * i + 3)] >= *x1))
      *x1 = m[(signed long int)(i * 5 + 3)];

    if(!(*y2 >= -m[(signed long int)(5 * i + 4)]))
      *y2 = -m[(signed long int)(i * 5 + 4)];

  }
  *x2 = *x2 + 1;
  *y2 = *y2 + 1;
}

// rfbWidthOfChar
// file font.c line 126
signed int rfbWidthOfChar(struct rfbFontData *font, unsigned char c)
{
  return font->metaData[(signed long int)((signed int)c * 5 + 1)] + font->metaData[(signed long int)((signed int)c * 5 + 3)];
}

// rfbWidthOfString
// file font.c line 116
signed int rfbWidthOfString(struct rfbFontData *font, const char *string)
{
  signed int i = 0;
  for( ; !(*string == 0); string = string + 1l)
    i = i + font->metaData[(signed long int)((signed int)*string * 5 + 1)];
  return i;
}

// rfbWriteExact
// file ../rfb/rfb.h line 751
extern signed int rfbWriteExact(struct _rfbClientRec *cl, const char *buf, signed int len)
{
  signed int sock = cl->sock;
  signed int n;
  struct anonymous_16 fds;
  struct timeval tv;
  signed int totalTimeWaited = 0;
  signed int timeout;
  _Bool tmp_if_expr_1;
  if(!(cl->screen == ((struct _rfbScreenInfo *)NULL)))
    tmp_if_expr_1 = cl->screen->maxClientWait != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  signed int tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = cl->screen->maxClientWait;

  else
    tmp_if_expr_2 = rfbMaxClientWait;
  timeout = tmp_if_expr_2;
  if(!(cl->wsctx == ((struct _wsCtx *)NULL)))
  {
    char *tmp = (char *)(void *)0;
    len=webSocketsEncode(cl, buf, len, &tmp);
    if(!(len >= 0))
    {
      rfbErr("WriteExact: WebSockets encode error\n");
      return -1;
    }

    buf = tmp;
  }

  pthread_mutex_lock(&cl->outputMutex);
  signed long int return_value_write_3;
  signed int *return_value___errno_location_5;
  while(len >= 1)
  {
    if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
      n=rfbssl_write(cl, buf, len);

    else
    {
      return_value_write_3=write(sock, (const void *)buf, (unsigned long int)len);
      n = (signed int)return_value_write_3;
    }
    if(n >= 1)
    {
      buf = buf + (signed long int)n;
      len = len - n;
    }

    else
      if(n == 0)
      {
        rfbErr("WriteExact: write returned 0?\n");
        return 0;
      }

      else
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(*return_value___errno_location_4 == 4)
          continue;

        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        if(!(*return_value___errno_location_6 == 11))
        {
          return_value___errno_location_5=__errno_location();
          if(!(*return_value___errno_location_5 == 11))
          {
            pthread_mutex_unlock(&cl->outputMutex);
            return n;
          }

        }

        do
        {
          signed int __d0;
          signed int __d1;
          asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_16) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->__fds_bits[(signed long int)0]) : "memory");
        }
        while((_Bool)0);
        (&fds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->__fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        tv.tv_sec = (signed long int)5;
        tv.tv_usec = (signed long int)0;
        n=select(sock + 1, (struct anonymous_16 *)(void *)0, &fds, (struct anonymous_16 *)(void *)0, &tv);
        if(!(n >= 0))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          if(*return_value___errno_location_7 == 4)
            continue;

          rfbLogPerror("WriteExact: select");
          pthread_mutex_unlock(&cl->outputMutex);
          return n;
        }

        if(n == 0)
        {
          totalTimeWaited = totalTimeWaited + 5000;
          if(totalTimeWaited >= timeout)
          {
            signed int *return_value___errno_location_8;
            return_value___errno_location_8=__errno_location();
            *return_value___errno_location_8 = 110;
            pthread_mutex_unlock(&cl->outputMutex);
            return -1;
          }

        }

        else
          totalTimeWaited = 0;
      }
  }
  pthread_mutex_unlock(&cl->outputMutex);
  return 1;
}

// rfbZlibCleanup
// file zlib.c line 62
void rfbZlibCleanup(struct _rfbScreenInfo *screen)
{
  if(!(zlibBeforeBufSize == 0))
  {
    free((void *)zlibBeforeBuf);
    zlibBeforeBufSize = 0;
  }

  if(!(zlibAfterBufSize == 0))
  {
    zlibAfterBufSize = 0;
    free((void *)zlibAfterBuf);
  }

}

// rfbssl_destroy
// file rfbssl.h line 12
void rfbssl_destroy(struct _rfbClientRec *cl)
{
  struct rfbssl_ctx *ctx = (struct rfbssl_ctx *)cl->sslctx;
  gnutls_bye(ctx->session, (enum anonymous_46)GNUTLS_SHUT_WR);
  gnutls_deinit(ctx->session);
  gnutls_certificate_free_credentials(ctx->x509_cred);
}

// rfbssl_do_read
// file rfbssl_gnutls.c line 148
static signed int rfbssl_do_read(struct _rfbClientRec *cl, char *buf, signed int bufsize)
{
  struct rfbssl_ctx *ctx = (struct rfbssl_ctx *)cl->sslctx;
  signed int ret;
  signed long int return_value_gnutls_record_recv_1;
  do
  {
    return_value_gnutls_record_recv_1=gnutls_record_recv(ctx->session, (void *)buf, (unsigned long int)bufsize);
    ret = (signed int)return_value_gnutls_record_recv_1;
    if(ret >= 0)
      break;

    if(!(ret == -28))
    {
      if(!(ret == -52))
        break;

    }

  }
  while((_Bool)1);
  if(!(ret >= 0))
  {
    rfbssl_error("rfbssl_do_read", ret);
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    *return_value___errno_location_2 = 5;
    ret = -1;
  }

  return ret < 0 ? -1 : ret;
}

// rfbssl_error
// file rfbssl_gnutls.c line 45
static void rfbssl_error(const char *msg, signed int e)
{
  const char *return_value_gnutls_strerror_1;
  return_value_gnutls_strerror_1=gnutls_strerror(e);
  rfbErr("%s: %s (%ld)\n", msg, return_value_gnutls_strerror_1, e);
}

// rfbssl_gc_peekbuf
// file rfbssl_gnutls.c line 193
static void rfbssl_gc_peekbuf(struct rfbssl_ctx *ctx, signed int bufsize)
{
  if(!(ctx->peekstart == 0))
  {
    signed int spaceleft = (signed int)((sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)ctx->peeklen) - (unsigned long int)ctx->peekstart);
    if(!(spaceleft >= bufsize))
    {
      memmove((void *)ctx->peekbuf, (const void *)(ctx->peekbuf + (signed long int)ctx->peekstart), (unsigned long int)ctx->peeklen);
      ctx->peekstart = 0;
    }

  }

}

// rfbssl_init
// file rfbssl.h line 7
signed int rfbssl_init(struct _rfbClientRec *cl)
{
  signed int ret = -1;
  struct rfbssl_ctx *ctx;
  char *keyfile = cl->screen->sslkeyfile;
  if(keyfile == ((char *)NULL))
    keyfile = cl->screen->sslcertfile;

  ctx=rfbssl_init_global(keyfile, cl->screen->sslcertfile);
  if(!(ctx == ((struct rfbssl_ctx *)NULL)))
  {
    ret=rfbssl_init_session(ctx, cl->sock);
    if(ret == 0)
      do
      {
        ret=gnutls_handshake(ctx->session);
        if(ret == 0)
          break;

        if(!(ret == -28))
          break;

      }
      while((_Bool)1);

  }

  if(!(ret == 0))
    rfbssl_error("rfbssl_init", ret);

  else
  {
    cl->sslctx = (struct _rfbSslCtx *)ctx;
    enum anonymous_47 return_value_gnutls_protocol_get_version_1;
    return_value_gnutls_protocol_get_version_1=gnutls_protocol_get_version(ctx->session);
    const char *return_value_gnutls_protocol_get_name_2;
    return_value_gnutls_protocol_get_name_2=gnutls_protocol_get_name(return_value_gnutls_protocol_get_version_1);
    rfbLog("%s protocol initialized\n", return_value_gnutls_protocol_get_name_2);
  }
  return ret;
}

// rfbssl_init_global
// file rfbssl_gnutls.c line 87
struct rfbssl_ctx * rfbssl_init_global(char *key, char *cert)
{
  signed int ret = 0;
  struct rfbssl_ctx *ctx = (struct rfbssl_ctx *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct rfbssl_ctx) /*2080ul*/ );
  ctx = (struct rfbssl_ctx *)return_value_malloc_1;
  if(ctx == ((struct rfbssl_ctx *)NULL))
    ret = -25;

  else
  {
    ret=gnutls_global_init();
    if(!(ret == 1))
    {
      ret=gnutls_certificate_allocate_credentials(&ctx->x509_cred);
      if(!(ret == 1))
      {
        ret=gnutls_certificate_set_x509_trust_file(ctx->x509_cred, cert, (enum anonymous_44)GNUTLS_X509_FMT_PEM);
        if(ret >= 0)
        {
          ret=gnutls_certificate_set_x509_key_file(ctx->x509_cred, cert, key, (enum anonymous_44)GNUTLS_X509_FMT_PEM);
          if(!(ret == 1))
          {
            ret=generate_dh_params(ctx);
            if(!(ret == 1))
            {
              gnutls_global_set_log_function(rfbssl_log_func);
              gnutls_global_set_log_level(1);
              gnutls_certificate_set_dh_params(ctx->x509_cred, ctx->dh_params);
              return ctx;
            }

          }

        }

      }

    }

  }
  free((void *)ctx);
  return (struct rfbssl_ctx *)(void *)0;
}

// rfbssl_init_session
// file rfbssl_gnutls.c line 50
static signed int rfbssl_init_session(struct rfbssl_ctx *ctx, signed int fd)
{
  struct gnutls_session_int *session;
  signed int ret;
  ret=gnutls_init(&session, (unsigned int)1);
  if(!(ret == 1))
  {
    ret=gnutls_priority_set_direct(session, "EXPORT", (const char **)(void *)0);
    if(!(ret == 1))
    {
      ret=gnutls_credentials_set(session, (enum anonymous_45)GNUTLS_CRD_CERTIFICATE, (void *)ctx->x509_cred);
      if(!(ret == 1))
      {
        gnutls_session_enable_compatibility_mode(session);
        gnutls_transport_set_ptr(session, (void *)(unsigned long int)fd);
        ctx->session = session;
      }

    }

  }

  return ret;
}

// rfbssl_log_func
// file rfbssl_gnutls.c line 40
void rfbssl_log_func(signed int level, const char *msg)
{
  rfbErr("SSL: %s", msg);
}

// rfbssl_peek
// file rfbssl.h line 9
signed int rfbssl_peek(struct _rfbClientRec *cl, char *buf, signed int bufsize)
{
  signed int return_value___rfbssl_read_1;
  return_value___rfbssl_read_1=__rfbssl_read(cl, buf, bufsize, 1);
  return return_value___rfbssl_read_1;
}

// rfbssl_pending
// file rfbssl.h line 8
signed int rfbssl_pending(struct _rfbClientRec *cl)
{
  struct rfbssl_ctx *ctx = (struct rfbssl_ctx *)cl->sslctx;
  signed int ret = ctx->peeklen;
  unsigned long int return_value_gnutls_record_check_pending_1;
  if(!(ret >= 1))
  {
    return_value_gnutls_record_check_pending_1=gnutls_record_check_pending(ctx->session);
    ret = (signed int)return_value_gnutls_record_check_pending_1;
  }

  return ret;
}

// rfbssl_read
// file rfbssl.h line 10
signed int rfbssl_read(struct _rfbClientRec *cl, char *buf, signed int bufsize)
{
  signed int return_value___rfbssl_read_1;
  return_value___rfbssl_read_1=__rfbssl_read(cl, buf, bufsize, 0);
  return return_value___rfbssl_read_1;
}

// rfbssl_write
// file rfbssl.h line 11
signed int rfbssl_write(struct _rfbClientRec *cl, const char *buf, signed int bufsize)
{
  struct rfbssl_ctx *ctx = (struct rfbssl_ctx *)cl->sslctx;
  signed int ret;
  signed long int return_value_gnutls_record_send_1;
  do
  {
    return_value_gnutls_record_send_1=gnutls_record_send(ctx->session, (const void *)buf, (unsigned long int)bufsize);
    ret = (signed int)return_value_gnutls_record_send_1;
    if(ret >= 0)
      break;

    if(!(ret == -28))
    {
      if(!(ret == -52))
        break;

    }

  }
  while((_Bool)1);
  if(!(ret >= 0))
    rfbssl_error("rfbssl_write", ret);

  return ret;
}

// scrunch
// file ../common/d3des.c line 161
static void scrunch(unsigned char *outof, unsigned long int *into)
{
  unsigned char *tmp_post_1 = outof;
  outof = outof + 1l;
  *into = (unsigned long int)(((signed long int)*tmp_post_1 & 0xffL) << 24);
  unsigned char *tmp_post_2 = outof;
  outof = outof + 1l;
  *into = *into | (unsigned long int)(((signed long int)*tmp_post_2 & 0xffL) << 16);
  unsigned char *tmp_post_3 = outof;
  outof = outof + 1l;
  *into = *into | (unsigned long int)(((signed long int)*tmp_post_3 & 0xffL) << 8);
  unsigned long int *tmp_post_4 = into;
  into = into + 1l;
  unsigned char *tmp_post_5 = outof;
  outof = outof + 1l;
  *tmp_post_4 = *tmp_post_4 | (unsigned long int)((signed long int)*tmp_post_5 & 0xffL);
  unsigned char *tmp_post_6 = outof;
  outof = outof + 1l;
  *into = (unsigned long int)(((signed long int)*tmp_post_6 & 0xffL) << 24);
  unsigned char *tmp_post_7 = outof;
  outof = outof + 1l;
  *into = *into | (unsigned long int)(((signed long int)*tmp_post_7 & 0xffL) << 16);
  unsigned char *tmp_post_8 = outof;
  outof = outof + 1l;
  *into = *into | (unsigned long int)(((signed long int)*tmp_post_8 & 0xffL) << 8);
  *into = *into | (unsigned long int)((signed long int)*outof & 0xffL);
}

// selGetCursorPtr
// file selbox.c line 198
static struct rfbCursor * selGetCursorPtr(struct _rfbClientRec *cl)
{
  return (struct rfbCursor *)(void *)0;
}

// selKbdAddEvent
// file selbox.c line 125
static void selKbdAddEvent(signed char down, unsigned int keySym, struct _rfbClientRec *cl)
{
  _Bool tmp_if_expr_3;
  signed int return_value_tolower_2;
  _Bool tmp_if_expr_5;
  signed int return_value_tolower_4;
  if(!(down == 0))
  {
    if(keySym >= 33u && !(keySym >= 255u))
    {
      signed int i;
      struct anonymous_49 *selKbdAddEvent__1__1__1__m = (struct anonymous_49 *)cl->screen->screenData;
      char c;
      signed int return_value_tolower_1;
      return_value_tolower_1=tolower((signed int)keySym);
      c = (char)return_value_tolower_1;
      i = selKbdAddEvent__1__1__1__m->selected + 1;
      do
      {
        if(!(selKbdAddEvent__1__1__1__m->list[(signed long int)i] == ((char *)NULL)))
        {
          return_value_tolower_2=tolower((signed int)selKbdAddEvent__1__1__1__m->list[(signed long int)i][(signed long int)0]);
          tmp_if_expr_3 = return_value_tolower_2 != (signed int)c ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      if(selKbdAddEvent__1__1__1__m->list[(signed long int)i] == ((char *)NULL))
      {
        i = 0;
        do
        {
          if(!(i >= selKbdAddEvent__1__1__1__m->selected))
          {
            return_value_tolower_4=tolower((signed int)selKbdAddEvent__1__1__1__m->list[(signed long int)i][(signed long int)0]);
            tmp_if_expr_5 = return_value_tolower_4 != (signed int)c ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          if(!tmp_if_expr_5)
            break;

          i = i + 1;
        }
        while((_Bool)1);
      }

      selSelect(selKbdAddEvent__1__1__1__m, i);
    }

    else
      if(keySym == 65307u)
      {
        struct anonymous_49 *m = (struct anonymous_49 *)cl->screen->screenData;
        m->state = (enum anonymous_48)CANCEL;
      }

      else
        if(keySym == 65293u)
        {
          struct anonymous_49 *selKbdAddEvent__1__1__3__m = (struct anonymous_49 *)cl->screen->screenData;
          selKbdAddEvent__1__1__3__m->state = (enum anonymous_48)OK;
        }

        else
        {
          struct anonymous_49 *selKbdAddEvent__1__1__4__m = (struct anonymous_49 *)cl->screen->screenData;
          signed int curSel = selKbdAddEvent__1__1__4__m->selected;
          if(keySym == 65362u)
          {
            if(curSel >= 1)
              selSelect(selKbdAddEvent__1__1__4__m, curSel - 1);

          }

          else
            if(keySym == 65364u)
            {
              if(!(1 + curSel >= selKbdAddEvent__1__1__4__m->listSize))
                selSelect(selKbdAddEvent__1__1__4__m, curSel + 1);

            }

            else
              if(keySym == 65366u)
              {
                if(!(selKbdAddEvent__1__1__4__m->pageH + curSel >= selKbdAddEvent__1__1__4__m->listSize))
                  selSelect(selKbdAddEvent__1__1__4__m, curSel + selKbdAddEvent__1__1__4__m->pageH);

                else
                  selSelect(selKbdAddEvent__1__1__4__m, selKbdAddEvent__1__1__4__m->listSize - 1);
              }

              else
                if(keySym == 65365u)
                {
                  if(curSel + -selKbdAddEvent__1__1__4__m->pageH >= 0)
                    selSelect(selKbdAddEvent__1__1__4__m, curSel - selKbdAddEvent__1__1__4__m->pageH);

                  else
                    selSelect(selKbdAddEvent__1__1__4__m, 0);
                }

        }
  }

}

// selPaintButtons
// file selbox.c line 25
static void selPaintButtons(struct anonymous_49 *m, signed char invertOk, signed char invertCancel)
{
  struct _rfbScreenInfo *s = m->screen;
  unsigned int bcolour = m->backColour;
  unsigned int colour = m->colour;
  rfbFillRect(s, m->x1, m->okY - m->textH, m->x2, m->okY, bcolour);
  if(!(invertOk == 0))
  {
    rfbFillRect(s, m->okBX, m->okY - m->textH, m->okBX + m->buttonWidth, m->okY, colour);
    rfbDrawStringWithClip(s, m->font, m->okX + m->xhot, (m->okY - 1) + m->yhot, okStr, m->x1, m->okY - m->textH, m->x2, m->okY, bcolour, colour);
  }

  else
    rfbDrawString(s, m->font, m->okX + m->xhot, (m->okY - 1) + m->yhot, okStr, colour);
  if(!(invertCancel == 0))
  {
    rfbFillRect(s, m->cancelBX, m->okY - m->textH, m->cancelBX + m->buttonWidth, m->okY, colour);
    rfbDrawStringWithClip(s, m->font, m->cancelX + m->xhot, (m->okY - 1) + m->yhot, cancelStr, m->x1, m->okY - m->textH, m->x2, m->okY, bcolour, colour);
  }

  else
    rfbDrawString(s, m->font, m->cancelX + m->xhot, (m->okY - 1) + m->yhot, cancelStr, colour);
  m->okInverted = invertOk;
  m->cancelInverted = invertCancel;
}

// selPaintLine
// file selbox.c line 55
static void selPaintLine(struct anonymous_49 *m, signed int line, signed char invert)
{
  signed int y1 = m->y1 + line * m->textH;
  signed int y2 = y1 + m->textH;
  if(!(m->y2 >= y2))
    y2 = m->y2;

  unsigned int tmp_if_expr_1;
  if(!(invert == 0))
    tmp_if_expr_1 = m->colour;

  else
    tmp_if_expr_1 = m->backColour;
  rfbFillRect(m->screen, m->x1, y1, m->x2, y2, tmp_if_expr_1);
  unsigned int tmp_if_expr_2;
  unsigned int tmp_if_expr_3;
  if(!(m->displayStart + line >= m->listSize))
  {
    if(!(invert == 0))
      tmp_if_expr_2 = m->backColour;

    else
      tmp_if_expr_2 = m->colour;
    if(!(invert == 0))
      tmp_if_expr_3 = m->backColour;

    else
      tmp_if_expr_3 = m->colour;
    rfbDrawStringWithClip(m->screen, m->font, m->x1 + m->xhot, (y2 - 1) + m->yhot, m->list[(signed long int)(m->displayStart + line)], m->x1, y1, m->x2, y2, tmp_if_expr_2, tmp_if_expr_3);
  }

}

// selPtrAddEvent
// file selbox.c line 169
static void selPtrAddEvent(signed int buttonMask, signed int x, signed int y, struct _rfbClientRec *cl)
{
  struct anonymous_49 *m = (struct anonymous_49 *)cl->screen->screenData;
  _Bool tmp_if_expr_5;
  if(!(y >= m->okY))
    tmp_if_expr_5 = y >= m->okY - m->textH ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_5)
  {
    if(x >= m->okBX)
      tmp_if_expr_3 = x < m->okBX + m->buttonWidth ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      if(m->okInverted == 0)
        selPaintButtons(m, (signed char)-1, (signed char)0);

      if(!(buttonMask == 0))
        m->state = (enum anonymous_48)OK;

    }

    else
    {
      if(x >= m->cancelBX)
        tmp_if_expr_2 = x < m->cancelBX + m->buttonWidth ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(m->cancelInverted == 0)
          selPaintButtons(m, (signed char)0, (signed char)-1);

        if(!(buttonMask == 0))
          m->state = (enum anonymous_48)CANCEL;

      }

      else
      {
        if(!(m->okInverted == 0))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = m->cancelInverted != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          selPaintButtons(m, (signed char)0, (signed char)0);

      }
    }
  }

  else
  {
    if(!(m->okInverted == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = m->cancelInverted != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      selPaintButtons(m, (signed char)0, (signed char)0);

    if(m->lastButtons == 0)
    {
      if(!(buttonMask == 0))
      {
        if(x >= m->x1)
        {
          if(!(x >= m->x2))
          {
            if(y >= m->y1)
            {
              if(!(y >= m->y2))
                selSelect(m, m->displayStart + (y - m->y1) / m->textH);

            }

          }

        }

      }

    }

  }
  m->lastButtons = buttonMask;
}

// selSelect
// file selbox.c line 69
static void selSelect(struct anonymous_49 *m, signed int _index)
{
  signed int delta;
  _Bool tmp_if_expr_1;
  if(_index == m->selected || !(_index >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = _index >= m->listSize ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(!tmp_if_expr_1)
  {
    if(m->selected >= 0)
      selPaintLine(m, m->selected - m->displayStart, (signed char)0);

    if(!(_index >= m->displayStart))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = _index >= m->displayStart + m->pageH ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      signed int targetLine = m->selected - m->displayStart;
      signed int lineStart;
      signed int lineEnd;
      if(!(_index >= targetLine))
        targetLine = _index;

      else
        if(m->pageH + _index + -targetLine >= m->listSize)
          targetLine = (_index + m->pageH) - m->listSize;

      delta = _index - (m->displayStart + targetLine);
      if(!(-m->pageH >= delta))
        tmp_if_expr_2 = delta < m->pageH ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(delta >= 1)
        {
          lineStart = m->pageH - delta;
          lineEnd = m->pageH;
          rfbDoCopyRect(m->screen, m->x1, m->y1, m->x2, m->y1 + lineStart * m->textH, 0, -delta * m->textH);
        }

        else
        {
          lineStart = 0;
          lineEnd = -delta;
          rfbDoCopyRect(m->screen, m->x1, m->y1 + lineEnd * m->textH, m->x2, m->y2, 0, -delta * m->textH);
        }
      }

      else
      {
        lineStart = 0;
        lineEnd = m->pageH;
      }
      m->displayStart = m->displayStart + delta;
      delta = lineStart;
      for( ; !(delta >= lineEnd); delta = delta + 1)
        if(!(delta == _index))
          selPaintLine(m, delta, (signed char)0);

    }

    m->selected = _index;
    selPaintLine(m, m->selected - m->displayStart, (signed char)-1);
    if(!(m->selChangedHook == ((void (*)(signed int))NULL)))
      m->selChangedHook(_index);

  }

}

// sendHextiles16
// file hextile.c line 341
static signed char sendHextiles16(struct _rfbClientRec *cl, signed int rx, signed int ry, signed int rw, signed int rh)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int startUblen;
  char *fbptr;
  unsigned short int bg = (unsigned short int)0;
  unsigned short int fg = (unsigned short int)0;
  unsigned short int newBg;
  unsigned short int newFg;
  signed char mono;
  signed char solid;
  signed char validBg = (signed char)0;
  signed char validFg = (signed char)0;
  unsigned short int clientPixelData[512l];
  y = ry;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_6;
  for( ; !(y >= rh + ry); y = y + 16)
  {
    x = rx;
    if(!(x >= rw + rx))
    {
      h = 16;
      w = h;
      if(!(rw + rx + -x >= 16))
        w = (rx + rw) - x;

      if(!(rh + ry + -y >= 16))
        h = (ry + rh) - y;

      if(1 + cl->ublen >= 30001)
      {
        signed char return_value_rfbSendUpdateBuf_1;
        return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_1 == 0)
          return (signed char)0;

      }

      fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)clientPixelData, cl->scaledScreen->paddedWidthInBytes, w, h);
      startUblen = cl->ublen;
      cl->updateBuf[(signed long int)startUblen] = (char)0;
      cl->ublen = cl->ublen + 1;
      rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
      testColours16(clientPixelData, w * h, &mono, &solid, &newBg, &newFg);
      if(validBg == 0 || !(newBg == bg))
      {
        validBg = (signed char)-1;
        bg = newBg;
        cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 1);
        tmp_post_2 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_2] = ((char *)&bg)[(signed long int)0];
        tmp_post_3 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_3] = ((char *)&bg)[(signed long int)1];
      }

      if(solid == 0)
      {
        cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 3);
        if(!(mono == 0))
        {
          if(validFg == 0 || !(newFg == fg))
          {
            validFg = (signed char)-1;
            fg = newFg;
            cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 2);
            tmp_post_4 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_4] = ((char *)&fg)[(signed long int)0];
            tmp_post_5 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_5] = ((char *)&fg)[(signed long int)1];
          }

        }

        else
        {
          validFg = (signed char)0;
          cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 4);
        }
        signed char return_value_subrectEncode16_7;
        return_value_subrectEncode16_7=subrectEncode16_link1(cl, clientPixelData, w, h, bg, fg, mono);
        if(return_value_subrectEncode16_7 == 0)
        {
          validBg = (signed char)0;
          validFg = (signed char)0;
          cl->ublen = startUblen;
          tmp_post_6 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_6] = (char)(1 << 0);
          cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)clientPixelData, cl->scaledScreen->paddedWidthInBytes, w, h);
          memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)clientPixelData, (unsigned long int)(w * h * (16 / 8)));
          cl->ublen = cl->ublen + w * h * (16 / 8);
          rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, w * h * (16 / 8));
        }

      }

      x = x + 16;
    }

  }
  return (signed char)-1;
}

// sendHextiles32
// file hextile.c line 342
static signed char sendHextiles32(struct _rfbClientRec *cl, signed int rx, signed int ry, signed int rw, signed int rh)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int startUblen;
  char *fbptr;
  unsigned int bg = (unsigned int)0;
  unsigned int fg = (unsigned int)0;
  unsigned int newBg;
  unsigned int newFg;
  signed char mono;
  signed char solid;
  signed char validBg = (signed char)0;
  signed char validFg = (signed char)0;
  unsigned int clientPixelData[1024l];
  y = ry;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  for( ; !(y >= rh + ry); y = y + 16)
  {
    x = rx;
    if(!(x >= rw + rx))
    {
      h = 16;
      w = h;
      if(!(rw + rx + -x >= 16))
        w = (rx + rw) - x;

      if(!(rh + ry + -y >= 16))
        h = (ry + rh) - y;

      if(1 + cl->ublen >= 30001)
      {
        signed char return_value_rfbSendUpdateBuf_1;
        return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_1 == 0)
          return (signed char)0;

      }

      fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)clientPixelData, cl->scaledScreen->paddedWidthInBytes, w, h);
      startUblen = cl->ublen;
      cl->updateBuf[(signed long int)startUblen] = (char)0;
      cl->ublen = cl->ublen + 1;
      rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
      testColours32(clientPixelData, w * h, &mono, &solid, &newBg, &newFg);
      if(validBg == 0 || !(newBg == bg))
      {
        validBg = (signed char)-1;
        bg = newBg;
        cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 1);
        tmp_post_2 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_2] = ((char *)&bg)[(signed long int)0];
        tmp_post_3 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_3] = ((char *)&bg)[(signed long int)1];
        tmp_post_4 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_4] = ((char *)&bg)[(signed long int)2];
        tmp_post_5 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_5] = ((char *)&bg)[(signed long int)3];
      }

      if(solid == 0)
      {
        cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 3);
        if(!(mono == 0))
        {
          if(validFg == 0 || !(newFg == fg))
          {
            validFg = (signed char)-1;
            fg = newFg;
            cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 2);
            tmp_post_6 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_6] = ((char *)&fg)[(signed long int)0];
            tmp_post_7 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_7] = ((char *)&fg)[(signed long int)1];
            tmp_post_8 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_8] = ((char *)&fg)[(signed long int)2];
            tmp_post_9 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_9] = ((char *)&fg)[(signed long int)3];
          }

        }

        else
        {
          validFg = (signed char)0;
          cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 4);
        }
        signed char return_value_subrectEncode32_11;
        return_value_subrectEncode32_11=subrectEncode32_link1(cl, clientPixelData, w, h, bg, fg, mono);
        if(return_value_subrectEncode32_11 == 0)
        {
          validBg = (signed char)0;
          validFg = (signed char)0;
          cl->ublen = startUblen;
          tmp_post_10 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_10] = (char)(1 << 0);
          cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)clientPixelData, cl->scaledScreen->paddedWidthInBytes, w, h);
          memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)clientPixelData, (unsigned long int)(w * h * (32 / 8)));
          cl->ublen = cl->ublen + w * h * (32 / 8);
          rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, w * h * (32 / 8));
        }

      }

      x = x + 16;
    }

  }
  return (signed char)-1;
}

// sendHextiles8
// file hextile.c line 340
static signed char sendHextiles8(struct _rfbClientRec *cl, signed int rx, signed int ry, signed int rw, signed int rh)
{
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int startUblen;
  char *fbptr;
  unsigned char bg = (unsigned char)0;
  unsigned char fg = (unsigned char)0;
  unsigned char newBg;
  unsigned char newFg;
  signed char mono;
  signed char solid;
  signed char validBg = (signed char)0;
  signed char validFg = (signed char)0;
  unsigned char clientPixelData[256l];
  y = ry;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  for( ; !(y >= rh + ry); y = y + 16)
  {
    x = rx;
    if(!(x >= rw + rx))
    {
      h = 16;
      w = h;
      if(!(rw + rx + -x >= 16))
        w = (rx + rw) - x;

      if(!(rh + ry + -y >= 16))
        h = (ry + rh) - y;

      if(1 + cl->ublen >= 30001)
      {
        signed char return_value_rfbSendUpdateBuf_1;
        return_value_rfbSendUpdateBuf_1=rfbSendUpdateBuf(cl);
        if(return_value_rfbSendUpdateBuf_1 == 0)
          return (signed char)0;

      }

      fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * y) + (signed long int)(x * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)clientPixelData, cl->scaledScreen->paddedWidthInBytes, w, h);
      startUblen = cl->ublen;
      cl->updateBuf[(signed long int)startUblen] = (char)0;
      cl->ublen = cl->ublen + 1;
      rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
      testColours8(clientPixelData, w * h, &mono, &solid, &newBg, &newFg);
      if(validBg == 0 || !(newBg == bg))
      {
        validBg = (signed char)-1;
        bg = newBg;
        cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 1);
        tmp_post_2 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_2] = (char)bg;
      }

      if(solid == 0)
      {
        cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 3);
        if(!(mono == 0))
        {
          if(validFg == 0 || !(newFg == fg))
          {
            validFg = (signed char)-1;
            fg = newFg;
            cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 2);
            tmp_post_3 = cl->ublen;
            cl->ublen = cl->ublen + 1;
            cl->updateBuf[(signed long int)tmp_post_3] = (char)fg;
          }

        }

        else
        {
          validFg = (signed char)0;
          cl->updateBuf[(signed long int)startUblen] = cl->updateBuf[(signed long int)startUblen] | (char)(1 << 4);
        }
        signed char return_value_subrectEncode8_5;
        return_value_subrectEncode8_5=subrectEncode8_link1(cl, clientPixelData, w, h, bg, fg, mono);
        if(return_value_subrectEncode8_5 == 0)
        {
          validBg = (signed char)0;
          validFg = (signed char)0;
          cl->ublen = startUblen;
          tmp_post_4 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_4] = (char)(1 << 0);
          cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)clientPixelData, cl->scaledScreen->paddedWidthInBytes, w, h);
          memcpy((void *)&cl->updateBuf[(signed long int)cl->ublen], (const void *)(char *)clientPixelData, (unsigned long int)(w * h * (8 / 8)));
          cl->ublen = cl->ublen + w * h * (8 / 8);
          rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, w * h * (8 / 8));
        }

      }

      x = x + 16;
    }

  }
  return (signed char)-1;
}

// setCompDefaults
// file ../common/turbojpeg.c line 140
static signed int setCompDefaults(struct jpeg_compress_struct *cinfo, signed int pixelFormat, signed int subsamp, signed int jpegQual)
{
  signed int retval = 0;
  switch(pixelFormat)
  {
    case 6:
    {
      cinfo->in_color_space = (enum anonymous_32)JCS_GRAYSCALE;
      goto __CPROVER_DUMP_L8;
    }
    case 0:
    {
      cinfo->in_color_space = (enum anonymous_32)JCS_EXT_RGB;
      goto __CPROVER_DUMP_L8;
    }
    case 1:
    {
      cinfo->in_color_space = (enum anonymous_32)JCS_EXT_BGR;
      goto __CPROVER_DUMP_L8;
    }
    case 2:

    case 7:
    {
      cinfo->in_color_space = (enum anonymous_32)JCS_EXT_RGBX;
      goto __CPROVER_DUMP_L8;
    }
    case 3:

    case 8:
    {
      cinfo->in_color_space = (enum anonymous_32)JCS_EXT_BGRX;
      goto __CPROVER_DUMP_L8;
    }
    case 5:

    case 10:
    {
      cinfo->in_color_space = (enum anonymous_32)JCS_EXT_XRGB;
      goto __CPROVER_DUMP_L8;
    }
    case 4:

    case 9:
      cinfo->in_color_space = (enum anonymous_32)JCS_EXT_XBGR;
    default:
    {

    __CPROVER_DUMP_L8:
      ;
      cinfo->input_components = tjPixelSize[(signed long int)pixelFormat];
      jpeg_set_defaults(cinfo);
      if(jpegQual >= 0)
      {
        jpeg_set_quality(cinfo, jpegQual, 1);
        if(jpegQual >= 96)
          cinfo->dct_method = (enum anonymous_37)JDCT_ISLOW;

        else
          cinfo->dct_method = (enum anonymous_37)JDCT_IFAST;
      }

      if(subsamp == 3)
        jpeg_set_colorspace(cinfo, (enum anonymous_32)JCS_GRAYSCALE);

      else
        jpeg_set_colorspace(cinfo, (enum anonymous_32)JCS_YCbCr);
      (cinfo->comp_info + (signed long int)0)->h_samp_factor = tjMCUWidth[(signed long int)subsamp] / 8;
      (cinfo->comp_info + (signed long int)1)->h_samp_factor = 1;
      (cinfo->comp_info + (signed long int)2)->h_samp_factor = 1;
      (cinfo->comp_info + (signed long int)0)->v_samp_factor = tjMCUHeight[(signed long int)subsamp] / 8;
      (cinfo->comp_info + (signed long int)1)->v_samp_factor = 1;
      (cinfo->comp_info + (signed long int)2)->v_samp_factor = 1;
      return retval;
    }
  }
}

// setDecompDefaults
// file ../common/turbojpeg.c line 205
static signed int setDecompDefaults(struct jpeg_decompress_struct *dinfo, signed int pixelFormat)
{
  signed int retval = 0;
  switch(pixelFormat)
  {
    case 6:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_GRAYSCALE;
      break;
    }
    case 0:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_RGB;
      break;
    }
    case 1:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_BGR;
      break;
    }
    case 2:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_RGBX;
      break;
    }
    case 3:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_BGRX;
      break;
    }
    case 5:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_XRGB;
      break;
    }
    case 4:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_XBGR;
      break;
    }
    case 7:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_RGBA;
      break;
    }
    case 8:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_BGRA;
      break;
    }
    case 10:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_ARGB;
      break;
    }
    case 9:
    {
      dinfo->out_color_space = (enum anonymous_32)JCS_EXT_ABGR;
      break;
    }
    default:
    {
      snprintf(errStr, (unsigned long int)200, "%s", (const void *)"Unsupported pixel format");
      retval = -1;
    }
  }

bailout:
  ;
  return retval;
}

// skip_input_data
// file ../common/turbojpeg.c line 635
static void skip_input_data(struct jpeg_decompress_struct *dinfo, signed long int num_bytes)
{
  dinfo->src->next_input_byte = dinfo->src->next_input_byte + (signed long int)(unsigned long int)num_bytes;
  dinfo->src->bytes_in_buffer = dinfo->src->bytes_in_buffer - (unsigned long int)num_bytes;
}

// sraClipRect
// file rfbregion.c line 789
extern signed char sraClipRect(signed int *x, signed int *y, signed int *w, signed int *h, signed int cx, signed int cy, signed int cw, signed int ch)
{
  if(!(*x >= cx))
  {
    *w = *w - (cx - *x);
    *x = cx;
  }

  if(!(*y >= cy))
  {
    *h = *h - (cy - *y);
    *y = cy;
  }

  if(!(cw + cx >= *w + *x))
    *w = (cx + cw) - *x;

  if(!(ch + cy >= *h + *y))
    *h = (cy + ch) - *y;

  _Bool tmp_if_expr_1;
  if(*w >= 1)
    tmp_if_expr_1 = *h > 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed char)tmp_if_expr_1;
}

// sraClipRect2
// file rfbregion.c line 809
extern signed char sraClipRect2(signed int *x, signed int *y, signed int *x2, signed int *y2, signed int cx, signed int cy, signed int cx2, signed int cy2)
{
  if(!(*x >= cx))
    *x = cx;

  if(!(*y >= cy))
    *y = cy;

  if(*x >= cx2)
    *x = cx2 - 1;

  if(*y >= cy2)
    *y = cy2 - 1;

  if(cx >= *x2)
    *x2 = cx + 1;

  if(cy >= *y2)
    *y2 = cy + 1;

  if(!(cx2 >= *x2))
    *x2 = cx2;

  if(!(cy2 >= *y2))
    *y2 = cy2;

  _Bool tmp_if_expr_1;
  if(!(*x >= *x2))
    tmp_if_expr_1 = *y2 > *y ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed char)tmp_if_expr_1;
}

// sraNextSpan
// file rfbregion.c line 729
static struct sraSpan * sraNextSpan(struct sraRectangleIterator *i)
{
  signed char return_value_sraReverse_1;
  return_value_sraReverse_1=sraReverse(i);
  if(!(return_value_sraReverse_1 == 0))
    return i->sPtrs[(signed long int)i->ptrPos]->_prev;

  else
    return i->sPtrs[(signed long int)i->ptrPos]->_next;
}

// sraReverse
// file rfbregion.c line 723
static signed char sraReverse(struct sraRectangleIterator *i)
{
  _Bool tmp_if_expr_1;
  if(!((2 & i->ptrPos) == 0))
    tmp_if_expr_1 = i->reverseX != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if((2 & i->ptrPos) == 0)
      tmp_if_expr_2 = i->reverseY != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  return (signed char)tmp_if_expr_3;
}

// sraRgnAnd
// file ../rfb/rfbregion.h line 28
extern signed char sraRgnAnd(struct sraRegion *dst, const struct sraRegion *src)
{
  signed char return_value_sraSpanListAnd_1;
  return_value_sraSpanListAnd_1=sraSpanListAnd((struct sraRegion *)dst, (struct sraRegion *)src);
  return return_value_sraSpanListAnd_1;
}

// sraRgnBBox
// file ../rfb/rfbregion.h line 40
extern struct sraRegion * sraRgnBBox(const struct sraRegion *src)
{
  signed int xmin = (signed int)((unsigned int)(signed int)-1 >> 1);
  signed int ymin = xmin;
  signed int xmax = 1 - xmin;
  signed int ymax = xmax;
  struct sraSpan *vcurr;
  struct sraSpan *hcurr;
  struct sraRegion *return_value_sraRgnCreate_1;
  struct sraRegion *return_value_sraRgnCreate_2;
  if(src == ((const struct sraRegion *)NULL))
  {
    return_value_sraRgnCreate_1=sraRgnCreate();
    return return_value_sraRgnCreate_1;
  }

  else
  {
    vcurr = ((struct sraRegion *)src)->front._next;
    for( ; !(vcurr == &src->back); vcurr = vcurr->_next)
    {
      if(!(vcurr->start >= ymin))
        ymin = vcurr->start;

      if(!(ymax >= vcurr->end))
        ymax = vcurr->end;

      hcurr = vcurr->subspan->front._next;
      for( ; !(hcurr == &vcurr->subspan->back); hcurr = hcurr->_next)
      {
        if(!(hcurr->start >= xmin))
          xmin = hcurr->start;

        if(!(xmax >= hcurr->end))
          xmax = hcurr->end;

      }
    }
    if(!(xmax >= xmin) || !(ymax >= ymin))
    {
      return_value_sraRgnCreate_2=sraRgnCreate();
      return return_value_sraRgnCreate_2;
    }

    else
    {
      struct sraRegion *return_value_sraRgnCreateRect_3;
      return_value_sraRgnCreateRect_3=sraRgnCreateRect(xmin, ymin, xmax, ymax);
      return return_value_sraRgnCreateRect_3;
    }
  }
}

// sraRgnCountRects
// file ../rfb/rfbregion.h line 37
extern unsigned long int sraRgnCountRects(const struct sraRegion *rgn)
{
  unsigned long int count;
  count=sraSpanListCount((struct sraRegion *)rgn);
  return count;
}

// sraRgnCreate
// file ../rfb/rfbregion.h line 22
extern struct sraRegion * sraRgnCreate(void)
{
  struct sraRegion *return_value_sraSpanListCreate_1;
  return_value_sraSpanListCreate_1=sraSpanListCreate();
  return (struct sraRegion *)return_value_sraSpanListCreate_1;
}

// sraRgnCreateRect
// file ../rfb/rfbregion.h line 23
extern struct sraRegion * sraRgnCreateRect(signed int x1, signed int y1, signed int x2, signed int y2)
{
  struct sraRegion *vlist;
  struct sraRegion *hlist;
  struct sraSpan *vspan;
  struct sraSpan *hspan;
  hlist=sraSpanListCreate();
  hspan=sraSpanCreate(x1, x2, (const struct sraRegion *)(void *)0);
  sraSpanInsertAfter(hspan, &hlist->front);
  vlist=sraSpanListCreate();
  vspan=sraSpanCreate(y1, y2, hlist);
  sraSpanInsertAfter(vspan, &vlist->front);
  sraSpanListDestroy(hlist);
  return (struct sraRegion *)vlist;
}

// sraRgnCreateRgn
// file ../rfb/rfbregion.h line 24
extern struct sraRegion * sraRgnCreateRgn(const struct sraRegion *src)
{
  struct sraRegion *return_value_sraSpanListDup_1;
  return_value_sraSpanListDup_1=sraSpanListDup((struct sraRegion *)src);
  return (struct sraRegion *)return_value_sraSpanListDup_1;
}

// sraRgnDestroy
// file ../rfb/rfbregion.h line 26
extern void sraRgnDestroy(struct sraRegion *rgn)
{
  sraSpanListDestroy((struct sraRegion *)rgn);
}

// sraRgnEmpty
// file ../rfb/rfbregion.h line 38
extern signed char sraRgnEmpty(const struct sraRegion *rgn)
{
  signed char return_value_sraSpanListEmpty_1;
  return_value_sraSpanListEmpty_1=sraSpanListEmpty((struct sraRegion *)rgn);
  return return_value_sraSpanListEmpty_1;
}

// sraRgnGetIterator
// file ../rfb/rfbregion.h line 50
extern struct sraRectangleIterator * sraRgnGetIterator(struct sraRegion *s)
{
  struct sraRectangleIterator *i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct sraRectangleIterator) /*24ul*/ );
  i = (struct sraRectangleIterator *)return_value_malloc_1;
  if(i == ((struct sraRectangleIterator *)NULL))
    return (struct sraRectangleIterator *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct sraSpan *) /*8ul*/  * (unsigned long int)4);
    i->sPtrs = (struct sraSpan **)return_value_malloc_2;
    if(i->sPtrs == ((struct sraSpan **)NULL))
    {
      free((void *)i);
      return (struct sraRectangleIterator *)(void *)0;
    }

    else
    {
      i->ptrSize = 4;
      i->sPtrs[(signed long int)0] = &s->front;
      i->sPtrs[(signed long int)1] = &s->back;
      i->ptrPos = 0;
      i->reverseX = (signed char)0;
      i->reverseY = (signed char)0;
      return i;
    }
  }
}

// sraRgnGetReverseIterator
// file ../rfb/rfbregion.h line 51
extern struct sraRectangleIterator * sraRgnGetReverseIterator(struct sraRegion *s, signed char reverseX, signed char reverseY)
{
  struct sraRectangleIterator *i;
  i=sraRgnGetIterator(s);
  if(!(reverseY == 0))
  {
    i->sPtrs[(signed long int)1] = &s->front;
    i->sPtrs[(signed long int)0] = &s->back;
  }

  i->reverseX = reverseX;
  i->reverseY = reverseY;
  return i;
}

// sraRgnIteratorNext
// file ../rfb/rfbregion.h line 52
extern signed char sraRgnIteratorNext(struct sraRectangleIterator *i, struct _rect *r)
{
  struct sraSpan *return_value_sraNextSpan_1;
  do
  {
    return_value_sraNextSpan_1=sraNextSpan(i);
    if(!(return_value_sraNextSpan_1 == i->sPtrs[(signed long int)(1 + i->ptrPos)]))
      break;

    i->ptrPos = i->ptrPos - 2;
    if(!(i->ptrPos >= 0))
      return (signed char)0;

  }
  while((_Bool)1);
  i->sPtrs[(signed long int)i->ptrPos]=sraNextSpan(i);
  while(!(i->sPtrs[(signed long int)i->ptrPos]->subspan == ((struct sraRegion *)NULL)))
  {
    if(!(i->ptrSize >= 2 + i->ptrPos))
    {
      i->ptrSize = i->ptrSize + 8;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)i->sPtrs, sizeof(struct sraSpan *) /*8ul*/  * (unsigned long int)i->ptrSize);
      i->sPtrs = (struct sraSpan **)return_value_realloc_2;
    }

    i->ptrPos = i->ptrPos + 2;
    signed char return_value_sraReverse_3;
    return_value_sraReverse_3=sraReverse(i);
    if(!(return_value_sraReverse_3 == 0))
    {
      i->sPtrs[(signed long int)i->ptrPos] = i->sPtrs[(signed long int)(i->ptrPos - 2)]->subspan->back._prev;
      i->sPtrs[(signed long int)(i->ptrPos + 1)] = &i->sPtrs[(signed long int)(i->ptrPos - 2)]->subspan->front;
    }

    else
    {
      i->sPtrs[(signed long int)i->ptrPos] = i->sPtrs[(signed long int)(i->ptrPos - 2)]->subspan->front._next;
      i->sPtrs[(signed long int)(i->ptrPos + 1)] = &i->sPtrs[(signed long int)(i->ptrPos - 2)]->subspan->back;
    }
  }
  if(!(i->ptrPos % 4 == 2))
  {
    rfbErr("sraRgnIteratorNext: offset is wrong (%d%%4!=2)\n", i->ptrPos);
    return (signed char)0;
  }

  else
  {
    r->y1 = i->sPtrs[(signed long int)(i->ptrPos - 2)]->start;
    r->y2 = i->sPtrs[(signed long int)(i->ptrPos - 2)]->end;
    r->x1 = i->sPtrs[(signed long int)i->ptrPos]->start;
    r->x2 = i->sPtrs[(signed long int)i->ptrPos]->end;
    return (signed char)-1;
  }
}

// sraRgnMakeEmpty
// file ../rfb/rfbregion.h line 27
extern void sraRgnMakeEmpty(struct sraRegion *rgn)
{
  sraSpanListMakeEmpty((struct sraRegion *)rgn);
}

// sraRgnOffset
// file ../rfb/rfbregion.h line 32
extern void sraRgnOffset(struct sraRegion *dst, signed int dx, signed int dy)
{
  struct sraSpan *vcurr;
  struct sraSpan *hcurr;
  vcurr = ((struct sraRegion *)dst)->front._next;
  for( ; !(vcurr == &dst->back); vcurr = vcurr->_next)
  {
    vcurr->start = vcurr->start + dy;
    vcurr->end = vcurr->end + dy;
    hcurr = vcurr->subspan->front._next;
    for( ; !(hcurr == &vcurr->subspan->back); hcurr = hcurr->_next)
    {
      hcurr->start = hcurr->start + dx;
      hcurr->end = hcurr->end + dx;
    }
  }
}

// sraRgnOr
// file ../rfb/rfbregion.h line 29
extern void sraRgnOr(struct sraRegion *dst, const struct sraRegion *src)
{
  sraSpanListOr((struct sraRegion *)dst, (struct sraRegion *)src);
}

// sraRgnPopRect
// file ../rfb/rfbregion.h line 34
extern signed char sraRgnPopRect(struct sraRegion *rgn, struct _rect *rect, unsigned long int flags)
{
  struct sraSpan *vcurr;
  struct sraSpan *hcurr;
  struct sraSpan *vend;
  struct sraSpan *hend;
  signed char right2left = (signed char)((flags & (unsigned long int)2) == (unsigned long int)2);
  signed char bottom2top = (signed char)((flags & (unsigned long int)1) == (unsigned long int)1);
  if(!(bottom2top == 0))
  {
    vcurr = ((struct sraRegion *)rgn)->back._prev;
    vend = &((struct sraRegion *)rgn)->front;
  }

  else
  {
    vcurr = ((struct sraRegion *)rgn)->front._next;
    vend = &((struct sraRegion *)rgn)->back;
  }
  if(!(vcurr == vend))
  {
    rect->y1 = vcurr->start;
    rect->y2 = vcurr->end;
    if(!(right2left == 0))
    {
      hcurr = vcurr->subspan->back._prev;
      hend = &vcurr->subspan->front;
    }

    else
    {
      hcurr = vcurr->subspan->front._next;
      hend = &vcurr->subspan->back;
    }
    if(!(hcurr == hend))
    {
      rect->x1 = hcurr->start;
      rect->x2 = hcurr->end;
      sraSpanRemove(hcurr);
      sraSpanDestroy(hcurr);
      signed char return_value_sraSpanListEmpty_1;
      return_value_sraSpanListEmpty_1=sraSpanListEmpty(vcurr->subspan);
      if(!(return_value_sraSpanListEmpty_1 == 0))
      {
        sraSpanRemove(vcurr);
        sraSpanDestroy(vcurr);
      }

      return (signed char)1;
    }

  }

  return (signed char)0;
}

// sraRgnPrint
// file rfbregion.c line 784
void sraRgnPrint(const struct sraRegion *rgn)
{
  sraSpanListPrint((struct sraRegion *)rgn);
}

// sraRgnReleaseIterator
// file ../rfb/rfbregion.h line 53
extern void sraRgnReleaseIterator(struct sraRectangleIterator *i)
{
  free((void *)i->sPtrs);
  free((void *)i);
}

// sraRgnSubtract
// file ../rfb/rfbregion.h line 30
extern signed char sraRgnSubtract(struct sraRegion *dst, const struct sraRegion *src)
{
  signed char return_value_sraSpanListSubtract_1;
  return_value_sraSpanListSubtract_1=sraSpanListSubtract((struct sraRegion *)dst, (struct sraRegion *)src);
  return return_value_sraSpanListSubtract_1;
}

// sraSpanCreate
// file rfbregion.c line 34
static struct sraSpan * sraSpanCreate(signed int start, signed int end, const struct sraRegion *subspan)
{
  struct sraSpan *item;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct sraSpan) /*32ul*/ );
  item = (struct sraSpan *)return_value_malloc_1;
  item->_prev = (struct sraSpan *)(void *)0;
  item->_next = item->_prev;
  item->start = start;
  item->end = end;
  item->subspan=sraSpanListDup(subspan);
  return item;
}

// sraSpanDestroy
// file rfbregion.c line 74
static void sraSpanDestroy(struct sraSpan *span)
{
  if(!(span->subspan == ((struct sraRegion *)NULL)))
    sraSpanListDestroy(span->subspan);

  free((void *)span);
}

// sraSpanDup
// file rfbregion.c line 44
static struct sraSpan * sraSpanDup(const struct sraSpan *src)
{
  struct sraSpan *span;
  if(src == ((const struct sraSpan *)NULL))
    return (struct sraSpan *)(void *)0;

  else
  {
    span=sraSpanCreate(src->start, src->end, src->subspan);
    return span;
  }
}

// sraSpanInsertAfter
// file rfbregion.c line 52
static void sraSpanInsertAfter(struct sraSpan *newspan, struct sraSpan *after)
{
  newspan->_next = after->_next;
  newspan->_prev = after;
  after->_next->_prev = newspan;
  after->_next = newspan;
}

// sraSpanInsertBefore
// file rfbregion.c line 60
static void sraSpanInsertBefore(struct sraSpan *newspan, struct sraSpan *before)
{
  newspan->_next = before;
  newspan->_prev = before->_prev;
  before->_prev->_next = newspan;
  before->_prev = newspan;
}

// sraSpanListAnd
// file rfbregion.c line 358
static signed char sraSpanListAnd(struct sraRegion *dest, const struct sraRegion *src)
{
  struct sraSpan *d_curr;
  struct sraSpan *s_curr;
  struct sraSpan *d_next;
  if(dest == ((struct sraRegion *)NULL))
  {
    if(src == ((const struct sraRegion *)NULL))
      return (signed char)1;

    rfbErr("sraSpanListAnd:incompatible spans (only one NULL!)\n");
    return (signed char)0;
  }

  else
  {
    d_curr = dest->front._next;
    s_curr = src->front._next;
    while(!(s_curr == &src->back))
    {
      if(d_curr == &dest->back)
        break;

      if(d_curr->start >= s_curr->end)
        s_curr = s_curr->_next;

      else
      {
        if(s_curr->start >= d_curr->end)
        {
          struct sraSpan *sraSpanListAnd__1__2__2__next = d_curr->_next;
          sraSpanRemove(d_curr);
          sraSpanDestroy(d_curr);
          d_curr = sraSpanListAnd__1__2__2__next;
          continue;
        }

        if(!(d_curr->start >= s_curr->start))
          d_curr->start = s_curr->start;

        if(!(s_curr->end >= d_curr->end))
        {
          struct sraSpan *return_value_sraSpanCreate_1;
          return_value_sraSpanCreate_1=sraSpanCreate(s_curr->end, d_curr->end, d_curr->subspan);
          sraSpanInsertAfter(return_value_sraSpanCreate_1, d_curr);
          d_curr->end = s_curr->end;
        }

        signed char return_value_sraSpanListAnd_2;
        return_value_sraSpanListAnd_2=sraSpanListAnd(d_curr->subspan, s_curr->subspan);
        if(return_value_sraSpanListAnd_2 == 0)
        {
          struct sraSpan *next = d_curr->_next;
          sraSpanRemove(d_curr);
          sraSpanDestroy(d_curr);
          d_curr = next;
        }

        else
        {
          if(!(d_curr->_prev == &dest->front))
            sraSpanMergePrevious(d_curr);

          d_next = d_curr;
          if(s_curr->end >= d_curr->end)
            d_next = d_curr->_next;

          if(d_curr->end >= s_curr->end)
            s_curr = s_curr->_next;

          d_curr = d_next;
        }
      }
    }
    while(!(d_curr == &dest->back))
    {
      struct sraSpan *sraSpanListAnd__1__3__next = d_curr->_next;
      sraSpanRemove(d_curr);
      sraSpanDestroy(d_curr);
      d_curr = sraSpanListAnd__1__3__next;
    }
    signed char return_value_sraSpanListEmpty_3;
    return_value_sraSpanListEmpty_3=sraSpanListEmpty(dest);
    return (signed char)!(return_value_sraSpanListEmpty_3 != 0);
  }
}

// sraSpanListCount
// file rfbregion.c line 212
static unsigned long int sraSpanListCount(const struct sraRegion *list)
{
  struct sraSpan *curr = list->front._next;
  unsigned long int count = (unsigned long int)0;
  for( ; !(curr == &list->back); curr = curr->_next)
    if(!(curr->subspan == ((struct sraRegion *)NULL)))
    {
      unsigned long int return_value_sraSpanListCount_1;
      return_value_sraSpanListCount_1=sraSpanListCount(curr->subspan);
      count = count + return_value_sraSpanListCount_1;
    }

    else
      count = count + (unsigned long int)1;
  return count;
}

// sraSpanListCreate
// file rfbregion.c line 118
static struct sraRegion * sraSpanListCreate(void)
{
  struct sraRegion *item;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct sraRegion) /*64ul*/ );
  item = (struct sraRegion *)return_value_malloc_1;
  item->front._next = &item->back;
  item->front._prev = (struct sraSpan *)(void *)0;
  item->back._prev = &item->front;
  item->back._next = (struct sraSpan *)(void *)0;
  return item;
}

// sraSpanListDestroy
// file rfbregion.c line 145
void sraSpanListDestroy(struct sraRegion *list)
{
  struct sraSpan *curr;
  struct sraSpan *next;
  for( ; !(list->front._next == &list->back); curr = next)
  {
    curr = list->front._next;
    next = curr->_next;
    sraSpanRemove(curr);
    sraSpanDestroy(curr);
  }
  free((void *)list);
}

// sraSpanListDup
// file rfbregion.c line 128
struct sraRegion * sraSpanListDup(const struct sraRegion *src)
{
  struct sraRegion *newlist;
  struct sraSpan *newspan;
  struct sraSpan *curr;
  if(src == ((const struct sraRegion *)NULL))
    return (struct sraRegion *)(void *)0;

  else
  {
    newlist=sraSpanListCreate();
    curr = src->front._next;
    for( ; !(curr == &src->back); curr = curr->_next)
    {
      newspan=sraSpanDup(curr);
      sraSpanInsertBefore(newspan, &newlist->back);
    }
    return newlist;
  }
}

// sraSpanListEmpty
// file rfbregion.c line 207
static signed char sraSpanListEmpty(const struct sraRegion *list)
{
  return (signed char)(list->front._next == &list->back);
}

// sraSpanListEqual
// file rfbregion.c line 174
static signed char sraSpanListEqual(const struct sraRegion *s1, const struct sraRegion *s2)
{
  struct sraSpan *sp1;
  struct sraSpan *sp2;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed char return_value_sraSpanListEqual_2;
  _Bool tmp_if_expr_4;
  if(s1 == ((const struct sraRegion *)NULL))
  {
    if(s2 == ((const struct sraRegion *)NULL))
      return (signed char)1;

    rfbErr("sraSpanListEqual:incompatible spans (only one NULL!)\n");
    return (signed char)0;
  }

  else
  {
    sp1 = s1->front._next;
    sp2 = s2->front._next;
    while(!(sp1 == &s1->back))
    {
      if(sp2 == &s2->back)
        break;

      if(!(sp1->start == sp2->start))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = sp1->end != sp2->end ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_sraSpanListEqual_2=sraSpanListEqual(sp1->subspan, sp2->subspan);
        tmp_if_expr_3 = !(return_value_sraSpanListEqual_2 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        return (signed char)0;

      sp1 = sp1->_next;
      sp2 = sp2->_next;
    }
    if(sp1 == &s1->back)
      tmp_if_expr_4 = sp2 == &s2->back ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      return (signed char)1;

    else
      return (signed char)0;
  }
}

// sraSpanListMakeEmpty
// file rfbregion.c line 158
static void sraSpanListMakeEmpty(struct sraRegion *list)
{
  struct sraSpan *curr;
  struct sraSpan *next;
  for( ; !(list->front._next == &list->back); curr = next)
  {
    curr = list->front._next;
    next = curr->_next;
    sraSpanRemove(curr);
    sraSpanDestroy(curr);
  }
  list->front._next = &list->back;
  list->front._prev = (struct sraSpan *)(void *)0;
  list->back._prev = &list->front;
  list->back._next = (struct sraSpan *)(void *)0;
}

// sraSpanListOr
// file rfbregion.c line 268
static void sraSpanListOr(struct sraRegion *dest, const struct sraRegion *src)
{
  struct sraSpan *d_curr;
  struct sraSpan *s_curr;
  signed int s_start;
  signed int s_end;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  if(dest == ((struct sraRegion *)NULL))
  {
    if(src == ((const struct sraRegion *)NULL))
      goto __CPROVER_DUMP_L20;

    rfbErr("sraSpanListOr:incompatible spans (only one NULL!)\n");
  }

  else
  {
    d_curr = dest->front._next;
    s_curr = src->front._next;
    s_start = s_curr->start;
    s_end = s_curr->end;
    while(!(s_curr == &src->back))
    {
      if(d_curr == &dest->back)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = d_curr->start >= s_end ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        struct sraSpan *return_value_sraSpanCreate_1;
        return_value_sraSpanCreate_1=sraSpanCreate(s_start, s_end, s_curr->subspan);
        sraSpanInsertBefore(return_value_sraSpanCreate_1, d_curr);
        if(!(d_curr == &dest->back))
          sraSpanMergePrevious(d_curr);

        s_curr = s_curr->_next;
        s_start = s_curr->start;
        s_end = s_curr->end;
      }

      else
      {
        if(!(s_start >= d_curr->end))
          tmp_if_expr_5 = s_end > d_curr->start ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          if(!(s_start >= d_curr->start))
          {
            struct sraSpan *return_value_sraSpanCreate_2;
            return_value_sraSpanCreate_2=sraSpanCreate(s_start, d_curr->start, s_curr->subspan);
            sraSpanInsertBefore(return_value_sraSpanCreate_2, d_curr);
            sraSpanMergePrevious(d_curr);
          }

          if(!(s_end >= d_curr->end))
          {
            struct sraSpan *return_value_sraSpanCreate_3;
            return_value_sraSpanCreate_3=sraSpanCreate(s_end, d_curr->end, d_curr->subspan);
            sraSpanInsertAfter(return_value_sraSpanCreate_3, d_curr);
            d_curr->end = s_end;
          }

          if(!(d_curr->start >= s_start))
          {
            struct sraSpan *return_value_sraSpanCreate_4;
            return_value_sraSpanCreate_4=sraSpanCreate(d_curr->start, s_start, d_curr->subspan);
            sraSpanInsertBefore(return_value_sraSpanCreate_4, d_curr);
            d_curr->start = s_start;
          }

          sraSpanListOr(d_curr->subspan, s_curr->subspan);
          if(!(d_curr->_prev == &dest->front))
            sraSpanMergePrevious(d_curr);

          if(!(d_curr->_next == &dest->back))
            sraSpanMergeNext(d_curr);

          if(!(d_curr->end >= s_end))
          {
            s_start = d_curr->end;
            d_curr = d_curr->_next;
          }

          else
          {
            s_curr = s_curr->_next;
            s_start = s_curr->start;
            s_end = s_curr->end;
          }
        }

        else
          d_curr = d_curr->_next;
      }
    }
  }

__CPROVER_DUMP_L20:
  ;
}

// sraSpanListPrint
// file rfbregion.c line 95
static void sraSpanListPrint(const struct sraRegion *l)
{
  struct sraSpan *curr;
  if(l == ((const struct sraRegion *)NULL))
    printf("NULL");

  else
  {
    curr = l->front._next;
    printf("[");
    for( ; !(curr == &l->back); curr = curr->_next)
      sraSpanPrint(curr);
    printf("]");
  }
}

// sraSpanListSubtract
// file rfbregion.c line 438
static signed char sraSpanListSubtract(struct sraRegion *dest, const struct sraRegion *src)
{
  struct sraSpan *d_curr;
  struct sraSpan *s_curr;
  _Bool tmp_if_expr_4;
  signed char return_value_sraSpanListSubtract_3;
  if(dest == ((struct sraRegion *)NULL))
  {
    if(src == ((const struct sraRegion *)NULL))
      return (signed char)1;

    rfbErr("sraSpanListSubtract:incompatible spans (only one NULL!)\n");
    return (signed char)0;
  }

  else
  {
    d_curr = dest->front._next;
    s_curr = src->front._next;
    while(!(s_curr == &src->back))
    {
      if(d_curr == &dest->back)
        break;

      if(d_curr->start >= s_curr->end)
        s_curr = s_curr->_next;

      else
        if(s_curr->start >= d_curr->end)
          d_curr = d_curr->_next;

        else
        {
          if(!(d_curr->start >= s_curr->start))
          {
            struct sraSpan *return_value_sraSpanCreate_1;
            return_value_sraSpanCreate_1=sraSpanCreate(d_curr->start, s_curr->start, d_curr->subspan);
            sraSpanInsertBefore(return_value_sraSpanCreate_1, d_curr);
            d_curr->start = s_curr->start;
          }

          if(!(s_curr->end >= d_curr->end))
          {
            struct sraSpan *return_value_sraSpanCreate_2;
            return_value_sraSpanCreate_2=sraSpanCreate(s_curr->end, d_curr->end, d_curr->subspan);
            sraSpanInsertAfter(return_value_sraSpanCreate_2, d_curr);
            d_curr->end = s_curr->end;
          }

          if(d_curr->subspan == ((struct sraRegion *)NULL))
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_sraSpanListSubtract_3=sraSpanListSubtract(d_curr->subspan, s_curr->subspan);
            tmp_if_expr_4 = !(return_value_sraSpanListSubtract_3 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
          {
            struct sraSpan *next = d_curr->_next;
            sraSpanRemove(d_curr);
            sraSpanDestroy(d_curr);
            d_curr = next;
          }

          else
          {
            if(!(d_curr->_prev == &dest->front))
              sraSpanMergePrevious(d_curr);

            if(!(d_curr->_next == &dest->back))
              sraSpanMergeNext(d_curr);

            if(!(d_curr->end >= s_curr->end))
              d_curr = d_curr->_next;

            else
              s_curr = s_curr->_next;
          }
        }
    }
    signed char return_value_sraSpanListEmpty_5;
    return_value_sraSpanListEmpty_5=sraSpanListEmpty(dest);
    return (signed char)!(return_value_sraSpanListEmpty_5 != 0);
  }
}

// sraSpanMergeNext
// file rfbregion.c line 248
static void sraSpanMergeNext(struct sraSpan *dest)
{
  struct sraSpan *next = dest->_next;
  signed char return_value_sraSpanListEqual_1;
  for( ; !(next->_next == ((struct sraSpan *)NULL)); next = dest->_next)
  {
    if(!(next->start == dest->end))
      break;

    return_value_sraSpanListEqual_1=sraSpanListEqual(next->subspan, dest->subspan);
    if(return_value_sraSpanListEqual_1 == 0)
      break;

    dest->end = next->end;
    sraSpanRemove(next);
    sraSpanDestroy(next);
  }
}

// sraSpanMergePrevious
// file rfbregion.c line 227
static void sraSpanMergePrevious(struct sraSpan *dest)
{
  struct sraSpan *prev = dest->_prev;
  signed char return_value_sraSpanListEqual_1;
  for( ; !(prev->_prev == ((struct sraSpan *)NULL)); prev = dest->_prev)
  {
    if(!(prev->end == dest->start))
      break;

    return_value_sraSpanListEqual_1=sraSpanListEqual(prev->subspan, dest->subspan);
    if(return_value_sraSpanListEqual_1 == 0)
      break;

    dest->start = prev->start;
    sraSpanRemove(prev);
    sraSpanDestroy(prev);
  }
}

// sraSpanPrint
// file rfbregion.c line 111
static void sraSpanPrint(const struct sraSpan *s)
{
  printf("(%d-%d)", s->start, s->end);
  if(!(s->subspan == ((struct sraRegion *)NULL)))
    sraSpanListPrint(s->subspan);

}

// sraSpanRemove
// file rfbregion.c line 68
static void sraSpanRemove(struct sraSpan *span)
{
  span->_prev->_next = span->_next;
  span->_next->_prev = span->_prev;
}

// src_noop
// file ../common/turbojpeg.c line 641
static void src_noop(struct jpeg_decompress_struct *dinfo)
{
  ;
}

// subrectEncode16
// file corre.c line 294
static signed int subrectEncode16(struct _rfbClientRec *client, unsigned short int *data, signed int w, signed int h)
{
  unsigned short int subrectEncode16__1__cl;
  struct anonymous_17 subrect;
  signed int x;
  signed int y;
  signed int i;
  signed int subrectEncode16__1__j;
  signed int hx = 0;
  signed int hy;
  signed int vx = 0;
  signed int vy;
  signed int hyflag;
  unsigned short int *seg;
  unsigned short int *line;
  signed int hw;
  signed int hh;
  signed int vw;
  signed int vh;
  signed int thex;
  signed int they;
  signed int thew;
  signed int theh;
  signed int numsubs = 0;
  signed int newLen;
  unsigned short int bg;
  unsigned int return_value_getBgColour_1;
  return_value_getBgColour_1=getBgColour((char *)data, w * h, 16);
  bg = (unsigned short int)return_value_getBgColour_1;
  *((unsigned short int *)client->afterEncBuf) = bg;
  client->afterEncBufLen = 16 / 8;
  y = 0;
  _Bool tmp_if_expr_2;
  for( ; !(y >= h); y = y + 1)
  {
    line = data + (signed long int)(y * w);
    x = 0;
    for( ; !(x >= w); x = x + 1)
      if(!(line[(signed long int)x] == bg))
      {
        subrectEncode16__1__cl = line[(signed long int)x];
        hy = y - 1;
        hyflag = 1;
        subrectEncode16__1__j = y;
        for( ; !(subrectEncode16__1__j >= h); subrectEncode16__1__j = subrectEncode16__1__j + 1)
        {
          seg = data + (signed long int)(subrectEncode16__1__j * w);
          if(!(seg[(signed long int)x] == subrectEncode16__1__cl))
            break;

          i = x;
          for( ; seg[(signed long int)i] == subrectEncode16__1__cl; i = i + 1)
            if(i >= w)
              break;

          i = i - 1;
          if(subrectEncode16__1__j == y)
          {
            hx = i;
            vx = hx;
          }

          if(!(i >= vx))
            vx = i;

          if(hyflag >= 1 && i >= hx)
            hy = hy + 1;

          else
            hyflag = 0;
        }
        vy = subrectEncode16__1__j - 1;
        hw = (hx - x) + 1;
        hh = (hy - y) + 1;
        vw = (vx - x) + 1;
        vh = (vy - y) + 1;
        thex = x;
        they = y;
        if(!(vh * vw >= hh * hw))
        {
          thew = hw;
          theh = hh;
        }

        else
        {
          thew = vw;
          theh = vh;
        }
        subrect.x = (unsigned char)thex;
        subrect.y = (unsigned char)they;
        subrect.w = (unsigned char)thew;
        subrect.h = (unsigned char)theh;
        newLen = client->afterEncBufLen + 16 / 8 + 4;
        if(!(2 * h * w >= newLen))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = newLen > client->afterEncBufSize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return -1;

        numsubs = numsubs + 1;
        *((unsigned short int *)(client->afterEncBuf + (signed long int)client->afterEncBufLen)) = subrectEncode16__1__cl;
        client->afterEncBufLen = client->afterEncBufLen + 16 / 8;
        memcpy((void *)&client->afterEncBuf[(signed long int)client->afterEncBufLen], (const void *)&subrect, (unsigned long int)4);
        client->afterEncBufLen = client->afterEncBufLen + 4;
        subrectEncode16__1__j = they;
        for( ; !(subrectEncode16__1__j >= theh + they); subrectEncode16__1__j = subrectEncode16__1__j + 1)
        {
          i = thex;
          for( ; !(i >= thew + thex); i = i + 1)
            data[(signed long int)(subrectEncode16__1__j * w + i)] = bg;
        }
      }

  }
  return numsubs;
}

// subrectEncode16_link1
// file hextile.c line 341
static signed char subrectEncode16_link1(struct _rfbClientRec *cl, unsigned short int *data_link1, signed int w_link1, signed int h_link1, unsigned short int bg, unsigned short int fg, signed char mono)
{
  unsigned short int cl2;
  signed int x_link1;
  signed int y_link1;
  signed int i_link1;
  signed int j_link1;
  signed int hx_link1 = 0;
  signed int hy_link1;
  signed int vx_link1 = 0;
  signed int vy_link1;
  signed int hyflag_link1;
  unsigned short int *seg_link1;
  unsigned short int *line_link1;
  signed int hw_link1;
  signed int hh_link1;
  signed int vw_link1;
  signed int vh_link1;
  signed int thex_link1;
  signed int they_link1;
  signed int thew_link1;
  signed int theh_link1;
  signed int numsubs_link1 = 0;
  signed int newLen_link1;
  signed int nSubrectsUblen = cl->ublen;
  cl->ublen = cl->ublen + 1;
  rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
  y_link1 = 0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  for( ; !(y_link1 >= h_link1); y_link1 = y_link1 + 1)
  {
    line_link1 = data_link1 + (signed long int)(y_link1 * w_link1);
    x_link1 = 0;
    for( ; !(x_link1 >= w_link1); x_link1 = x_link1 + 1)
      if(!(line_link1[(signed long int)x_link1] == bg))
      {
        cl2 = line_link1[(signed long int)x_link1];
        hy_link1 = y_link1 - 1;
        hyflag_link1 = 1;
        j_link1 = y_link1;
        for( ; !(j_link1 >= h_link1); j_link1 = j_link1 + 1)
        {
          seg_link1 = data_link1 + (signed long int)(j_link1 * w_link1);
          if(!(seg_link1[(signed long int)x_link1] == cl2))
            break;

          i_link1 = x_link1;
          for( ; seg_link1[(signed long int)i_link1] == cl2; i_link1 = i_link1 + 1)
            if(i_link1 >= w_link1)
              break;

          i_link1 = i_link1 - 1;
          if(j_link1 == y_link1)
          {
            hx_link1 = i_link1;
            vx_link1 = hx_link1;
          }

          if(!(i_link1 >= vx_link1))
            vx_link1 = i_link1;

          if(hyflag_link1 >= 1 && i_link1 >= hx_link1)
            hy_link1 = hy_link1 + 1;

          else
            hyflag_link1 = 0;
        }
        vy_link1 = j_link1 - 1;
        hw_link1 = (hx_link1 - x_link1) + 1;
        hh_link1 = (hy_link1 - y_link1) + 1;
        vw_link1 = (vx_link1 - x_link1) + 1;
        vh_link1 = (vy_link1 - y_link1) + 1;
        thex_link1 = x_link1;
        they_link1 = y_link1;
        if(!(vh_link1 * vw_link1 >= hh_link1 * hw_link1))
        {
          thew_link1 = hw_link1;
          theh_link1 = hh_link1;
        }

        else
        {
          thew_link1 = vw_link1;
          theh_link1 = vh_link1;
        }
        if(!(mono == 0))
          newLen_link1 = (cl->ublen - nSubrectsUblen) + 2;

        else
          newLen_link1 = (cl->ublen - nSubrectsUblen) + 16 / 8 + 2;
        if(!(2 * h_link1 * w_link1 >= newLen_link1))
          return (signed char)0;

        numsubs_link1 = numsubs_link1 + 1;
        if(mono == 0)
        {
          tmp_post_1 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_1] = ((char *)&cl2)[(signed long int)0];
          tmp_post_2 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_2] = ((char *)&cl2)[(signed long int)1];
        }

        tmp_post_3 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_3] = (char)(thex_link1 << 4 | they_link1);
        tmp_post_4 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_4] = (char)(thew_link1 - 1 << 4 | theh_link1 - 1);
        rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
        j_link1 = they_link1;
        for( ; !(j_link1 >= theh_link1 + they_link1); j_link1 = j_link1 + 1)
        {
          i_link1 = thex_link1;
          for( ; !(i_link1 >= thew_link1 + thex_link1); i_link1 = i_link1 + 1)
            data_link1[(signed long int)(j_link1 * w_link1 + i_link1)] = bg;
        }
      }

  }
  cl->updateBuf[(signed long int)nSubrectsUblen] = (char)numsubs_link1;
  return (signed char)-1;
}

// subrectEncode16_link2
// file rre.c line 261
static signed int subrectEncode16_link2(struct _rfbClientRec *client_link1, unsigned short int *data_link2, signed int w_link2, signed int h_link2)
{
  unsigned short int cl_link1;
  struct anonymous_5 subrect_link1;
  signed int x_link2;
  signed int y_link2;
  signed int i_link2;
  signed int j_link2;
  signed int hx_link2 = 0;
  signed int hy_link2;
  signed int vx_link2 = 0;
  signed int vy_link2;
  signed int hyflag_link2;
  unsigned short int *seg_link2;
  unsigned short int *line_link2;
  signed int hw_link2;
  signed int hh_link2;
  signed int vw_link2;
  signed int vh_link2;
  signed int thex_link2;
  signed int they_link2;
  signed int thew_link2;
  signed int theh_link2;
  signed int numsubs_link2 = 0;
  signed int newLen_link2;
  unsigned short int bg_link1;
  unsigned int return_value_getBgColour_1_link1;
  return_value_getBgColour_1_link1=getBgColour_link1((char *)data_link2, w_link2 * h_link2, 16);
  bg_link1 = (unsigned short int)return_value_getBgColour_1_link1;
  *((unsigned short int *)client_link1->afterEncBuf) = bg_link1;
  client_link1->afterEncBufLen = 16 / 8;
  y_link2 = 0;
  _Bool tmp_if_expr_2_link1;
  for( ; !(y_link2 >= h_link2); y_link2 = y_link2 + 1)
  {
    line_link2 = data_link2 + (signed long int)(y_link2 * w_link2);
    x_link2 = 0;
    for( ; !(x_link2 >= w_link2); x_link2 = x_link2 + 1)
      if(!(line_link2[(signed long int)x_link2] == bg_link1))
      {
        cl_link1 = line_link2[(signed long int)x_link2];
        hy_link2 = y_link2 - 1;
        hyflag_link2 = 1;
        j_link2 = y_link2;
        for( ; !(j_link2 >= h_link2); j_link2 = j_link2 + 1)
        {
          seg_link2 = data_link2 + (signed long int)(j_link2 * w_link2);
          if(!(seg_link2[(signed long int)x_link2] == cl_link1))
            break;

          i_link2 = x_link2;
          for( ; seg_link2[(signed long int)i_link2] == cl_link1; i_link2 = i_link2 + 1)
            if(i_link2 >= w_link2)
              break;

          i_link2 = i_link2 - 1;
          if(j_link2 == y_link2)
          {
            hx_link2 = i_link2;
            vx_link2 = hx_link2;
          }

          if(!(i_link2 >= vx_link2))
            vx_link2 = i_link2;

          if(hyflag_link2 >= 1 && i_link2 >= hx_link2)
            hy_link2 = hy_link2 + 1;

          else
            hyflag_link2 = 0;
        }
        vy_link2 = j_link2 - 1;
        hw_link2 = (hx_link2 - x_link2) + 1;
        hh_link2 = (hy_link2 - y_link2) + 1;
        vw_link2 = (vx_link2 - x_link2) + 1;
        vh_link2 = (vy_link2 - y_link2) + 1;
        thex_link2 = x_link2;
        they_link2 = y_link2;
        if(!(vh_link2 * vw_link2 >= hh_link2 * hw_link2))
        {
          thew_link2 = hw_link2;
          theh_link2 = hh_link2;
        }

        else
        {
          thew_link2 = vw_link2;
          theh_link2 = vh_link2;
        }
        subrect_link1.x = (unsigned short int)(rfbEndianTest != 0 ? (thex_link2 & 0xff) << 8 | thex_link2 >> 8 & 0xff : thex_link2);
        subrect_link1.y = (unsigned short int)(rfbEndianTest != 0 ? (they_link2 & 0xff) << 8 | they_link2 >> 8 & 0xff : they_link2);
        subrect_link1.w = (unsigned short int)(rfbEndianTest != 0 ? (thew_link2 & 0xff) << 8 | thew_link2 >> 8 & 0xff : thew_link2);
        subrect_link1.h = (unsigned short int)(rfbEndianTest != 0 ? (theh_link2 & 0xff) << 8 | theh_link2 >> 8 & 0xff : theh_link2);
        newLen_link2 = client_link1->afterEncBufLen + 16 / 8 + 8;
        if(!(2 * h_link2 * w_link2 >= newLen_link2))
          tmp_if_expr_2_link1 = (_Bool)1;

        else
          tmp_if_expr_2_link1 = newLen_link2 > client_link1->afterEncBufSize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2_link1)
          return -1;

        numsubs_link2 = numsubs_link2 + 1;
        *((unsigned short int *)(client_link1->afterEncBuf + (signed long int)client_link1->afterEncBufLen)) = cl_link1;
        client_link1->afterEncBufLen = client_link1->afterEncBufLen + 16 / 8;
        memcpy((void *)&client_link1->afterEncBuf[(signed long int)client_link1->afterEncBufLen], (const void *)&subrect_link1, (unsigned long int)8);
        client_link1->afterEncBufLen = client_link1->afterEncBufLen + 8;
        j_link2 = they_link2;
        for( ; !(j_link2 >= theh_link2 + they_link2); j_link2 = j_link2 + 1)
        {
          i_link2 = thex_link2;
          for( ; !(i_link2 >= thew_link2 + thex_link2); i_link2 = i_link2 + 1)
            data_link2[(signed long int)(j_link2 * w_link2 + i_link2)] = bg_link1;
        }
      }

  }
  return numsubs_link2;
}

// subrectEncode32
// file corre.c line 295
static signed int subrectEncode32(struct _rfbClientRec *client, unsigned int *data, signed int w, signed int h)
{
  unsigned int subrectEncode32__1__cl;
  struct anonymous_17 subrect;
  signed int x;
  signed int y;
  signed int i;
  signed int subrectEncode32__1__j;
  signed int hx = 0;
  signed int hy;
  signed int vx = 0;
  signed int vy;
  signed int hyflag;
  unsigned int *seg;
  unsigned int *line;
  signed int hw;
  signed int hh;
  signed int vw;
  signed int vh;
  signed int thex;
  signed int they;
  signed int thew;
  signed int theh;
  signed int numsubs = 0;
  signed int newLen;
  unsigned int bg;
  unsigned int return_value_getBgColour_1;
  return_value_getBgColour_1=getBgColour((char *)data, w * h, 32);
  bg = (unsigned int)return_value_getBgColour_1;
  *((unsigned int *)client->afterEncBuf) = bg;
  client->afterEncBufLen = 32 / 8;
  y = 0;
  _Bool tmp_if_expr_2;
  for( ; !(y >= h); y = y + 1)
  {
    line = data + (signed long int)(y * w);
    x = 0;
    for( ; !(x >= w); x = x + 1)
      if(!(line[(signed long int)x] == bg))
      {
        subrectEncode32__1__cl = line[(signed long int)x];
        hy = y - 1;
        hyflag = 1;
        subrectEncode32__1__j = y;
        for( ; !(subrectEncode32__1__j >= h); subrectEncode32__1__j = subrectEncode32__1__j + 1)
        {
          seg = data + (signed long int)(subrectEncode32__1__j * w);
          if(!(seg[(signed long int)x] == subrectEncode32__1__cl))
            break;

          i = x;
          for( ; seg[(signed long int)i] == subrectEncode32__1__cl; i = i + 1)
            if(i >= w)
              break;

          i = i - 1;
          if(subrectEncode32__1__j == y)
          {
            hx = i;
            vx = hx;
          }

          if(!(i >= vx))
            vx = i;

          if(hyflag >= 1 && i >= hx)
            hy = hy + 1;

          else
            hyflag = 0;
        }
        vy = subrectEncode32__1__j - 1;
        hw = (hx - x) + 1;
        hh = (hy - y) + 1;
        vw = (vx - x) + 1;
        vh = (vy - y) + 1;
        thex = x;
        they = y;
        if(!(vh * vw >= hh * hw))
        {
          thew = hw;
          theh = hh;
        }

        else
        {
          thew = vw;
          theh = vh;
        }
        subrect.x = (unsigned char)thex;
        subrect.y = (unsigned char)they;
        subrect.w = (unsigned char)thew;
        subrect.h = (unsigned char)theh;
        newLen = client->afterEncBufLen + 32 / 8 + 4;
        if(!(4 * h * w >= newLen))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = newLen > client->afterEncBufSize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return -1;

        numsubs = numsubs + 1;
        *((unsigned int *)(client->afterEncBuf + (signed long int)client->afterEncBufLen)) = subrectEncode32__1__cl;
        client->afterEncBufLen = client->afterEncBufLen + 32 / 8;
        memcpy((void *)&client->afterEncBuf[(signed long int)client->afterEncBufLen], (const void *)&subrect, (unsigned long int)4);
        client->afterEncBufLen = client->afterEncBufLen + 4;
        subrectEncode32__1__j = they;
        for( ; !(subrectEncode32__1__j >= theh + they); subrectEncode32__1__j = subrectEncode32__1__j + 1)
        {
          i = thex;
          for( ; !(i >= thew + thex); i = i + 1)
            data[(signed long int)(subrectEncode32__1__j * w + i)] = bg;
        }
      }

  }
  return numsubs;
}

// subrectEncode32_link1
// file hextile.c line 342
static signed char subrectEncode32_link1(struct _rfbClientRec *cl, unsigned int *data_link1, signed int w_link1, signed int h_link1, unsigned int bg, unsigned int fg, signed char mono)
{
  unsigned int cl2;
  signed int x_link1;
  signed int y_link1;
  signed int i_link1;
  signed int j_link1;
  signed int hx_link1 = 0;
  signed int hy_link1;
  signed int vx_link1 = 0;
  signed int vy_link1;
  signed int hyflag_link1;
  unsigned int *seg_link1;
  unsigned int *line_link1;
  signed int hw_link1;
  signed int hh_link1;
  signed int vw_link1;
  signed int vh_link1;
  signed int thex_link1;
  signed int they_link1;
  signed int thew_link1;
  signed int theh_link1;
  signed int numsubs_link1 = 0;
  signed int newLen_link1;
  signed int nSubrectsUblen = cl->ublen;
  cl->ublen = cl->ublen + 1;
  rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
  y_link1 = 0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  signed int tmp_post_5;
  signed int tmp_post_6;
  for( ; !(y_link1 >= h_link1); y_link1 = y_link1 + 1)
  {
    line_link1 = data_link1 + (signed long int)(y_link1 * w_link1);
    x_link1 = 0;
    for( ; !(x_link1 >= w_link1); x_link1 = x_link1 + 1)
      if(!(line_link1[(signed long int)x_link1] == bg))
      {
        cl2 = line_link1[(signed long int)x_link1];
        hy_link1 = y_link1 - 1;
        hyflag_link1 = 1;
        j_link1 = y_link1;
        for( ; !(j_link1 >= h_link1); j_link1 = j_link1 + 1)
        {
          seg_link1 = data_link1 + (signed long int)(j_link1 * w_link1);
          if(!(seg_link1[(signed long int)x_link1] == cl2))
            break;

          i_link1 = x_link1;
          for( ; seg_link1[(signed long int)i_link1] == cl2; i_link1 = i_link1 + 1)
            if(i_link1 >= w_link1)
              break;

          i_link1 = i_link1 - 1;
          if(j_link1 == y_link1)
          {
            hx_link1 = i_link1;
            vx_link1 = hx_link1;
          }

          if(!(i_link1 >= vx_link1))
            vx_link1 = i_link1;

          if(hyflag_link1 >= 1 && i_link1 >= hx_link1)
            hy_link1 = hy_link1 + 1;

          else
            hyflag_link1 = 0;
        }
        vy_link1 = j_link1 - 1;
        hw_link1 = (hx_link1 - x_link1) + 1;
        hh_link1 = (hy_link1 - y_link1) + 1;
        vw_link1 = (vx_link1 - x_link1) + 1;
        vh_link1 = (vy_link1 - y_link1) + 1;
        thex_link1 = x_link1;
        they_link1 = y_link1;
        if(!(vh_link1 * vw_link1 >= hh_link1 * hw_link1))
        {
          thew_link1 = hw_link1;
          theh_link1 = hh_link1;
        }

        else
        {
          thew_link1 = vw_link1;
          theh_link1 = vh_link1;
        }
        if(!(mono == 0))
          newLen_link1 = (cl->ublen - nSubrectsUblen) + 2;

        else
          newLen_link1 = (cl->ublen - nSubrectsUblen) + 32 / 8 + 2;
        if(!(4 * h_link1 * w_link1 >= newLen_link1))
          return (signed char)0;

        numsubs_link1 = numsubs_link1 + 1;
        if(mono == 0)
        {
          tmp_post_1 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_1] = ((char *)&cl2)[(signed long int)0];
          tmp_post_2 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_2] = ((char *)&cl2)[(signed long int)1];
          tmp_post_3 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_3] = ((char *)&cl2)[(signed long int)2];
          tmp_post_4 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_4] = ((char *)&cl2)[(signed long int)3];
        }

        tmp_post_5 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_5] = (char)(thex_link1 << 4 | they_link1);
        tmp_post_6 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_6] = (char)(thew_link1 - 1 << 4 | theh_link1 - 1);
        rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
        j_link1 = they_link1;
        for( ; !(j_link1 >= theh_link1 + they_link1); j_link1 = j_link1 + 1)
        {
          i_link1 = thex_link1;
          for( ; !(i_link1 >= thew_link1 + thex_link1); i_link1 = i_link1 + 1)
            data_link1[(signed long int)(j_link1 * w_link1 + i_link1)] = bg;
        }
      }

  }
  cl->updateBuf[(signed long int)nSubrectsUblen] = (char)numsubs_link1;
  return (signed char)-1;
}

// subrectEncode32_link2
// file rre.c line 262
static signed int subrectEncode32_link2(struct _rfbClientRec *client_link1, unsigned int *data_link2, signed int w_link2, signed int h_link2)
{
  unsigned int cl_link1;
  struct anonymous_5 subrect_link1;
  signed int x_link2;
  signed int y_link2;
  signed int i_link2;
  signed int j_link2;
  signed int hx_link2 = 0;
  signed int hy_link2;
  signed int vx_link2 = 0;
  signed int vy_link2;
  signed int hyflag_link2;
  unsigned int *seg_link2;
  unsigned int *line_link2;
  signed int hw_link2;
  signed int hh_link2;
  signed int vw_link2;
  signed int vh_link2;
  signed int thex_link2;
  signed int they_link2;
  signed int thew_link2;
  signed int theh_link2;
  signed int numsubs_link2 = 0;
  signed int newLen_link2;
  unsigned int bg_link1;
  unsigned int return_value_getBgColour_1_link1;
  return_value_getBgColour_1_link1=getBgColour_link1((char *)data_link2, w_link2 * h_link2, 32);
  bg_link1 = (unsigned int)return_value_getBgColour_1_link1;
  *((unsigned int *)client_link1->afterEncBuf) = bg_link1;
  client_link1->afterEncBufLen = 32 / 8;
  y_link2 = 0;
  _Bool tmp_if_expr_2_link1;
  for( ; !(y_link2 >= h_link2); y_link2 = y_link2 + 1)
  {
    line_link2 = data_link2 + (signed long int)(y_link2 * w_link2);
    x_link2 = 0;
    for( ; !(x_link2 >= w_link2); x_link2 = x_link2 + 1)
      if(!(line_link2[(signed long int)x_link2] == bg_link1))
      {
        cl_link1 = line_link2[(signed long int)x_link2];
        hy_link2 = y_link2 - 1;
        hyflag_link2 = 1;
        j_link2 = y_link2;
        for( ; !(j_link2 >= h_link2); j_link2 = j_link2 + 1)
        {
          seg_link2 = data_link2 + (signed long int)(j_link2 * w_link2);
          if(!(seg_link2[(signed long int)x_link2] == cl_link1))
            break;

          i_link2 = x_link2;
          for( ; seg_link2[(signed long int)i_link2] == cl_link1; i_link2 = i_link2 + 1)
            if(i_link2 >= w_link2)
              break;

          i_link2 = i_link2 - 1;
          if(j_link2 == y_link2)
          {
            hx_link2 = i_link2;
            vx_link2 = hx_link2;
          }

          if(!(i_link2 >= vx_link2))
            vx_link2 = i_link2;

          if(hyflag_link2 >= 1 && i_link2 >= hx_link2)
            hy_link2 = hy_link2 + 1;

          else
            hyflag_link2 = 0;
        }
        vy_link2 = j_link2 - 1;
        hw_link2 = (hx_link2 - x_link2) + 1;
        hh_link2 = (hy_link2 - y_link2) + 1;
        vw_link2 = (vx_link2 - x_link2) + 1;
        vh_link2 = (vy_link2 - y_link2) + 1;
        thex_link2 = x_link2;
        they_link2 = y_link2;
        if(!(vh_link2 * vw_link2 >= hh_link2 * hw_link2))
        {
          thew_link2 = hw_link2;
          theh_link2 = hh_link2;
        }

        else
        {
          thew_link2 = vw_link2;
          theh_link2 = vh_link2;
        }
        subrect_link1.x = (unsigned short int)(rfbEndianTest != 0 ? (thex_link2 & 0xff) << 8 | thex_link2 >> 8 & 0xff : thex_link2);
        subrect_link1.y = (unsigned short int)(rfbEndianTest != 0 ? (they_link2 & 0xff) << 8 | they_link2 >> 8 & 0xff : they_link2);
        subrect_link1.w = (unsigned short int)(rfbEndianTest != 0 ? (thew_link2 & 0xff) << 8 | thew_link2 >> 8 & 0xff : thew_link2);
        subrect_link1.h = (unsigned short int)(rfbEndianTest != 0 ? (theh_link2 & 0xff) << 8 | theh_link2 >> 8 & 0xff : theh_link2);
        newLen_link2 = client_link1->afterEncBufLen + 32 / 8 + 8;
        if(!(4 * h_link2 * w_link2 >= newLen_link2))
          tmp_if_expr_2_link1 = (_Bool)1;

        else
          tmp_if_expr_2_link1 = newLen_link2 > client_link1->afterEncBufSize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2_link1)
          return -1;

        numsubs_link2 = numsubs_link2 + 1;
        *((unsigned int *)(client_link1->afterEncBuf + (signed long int)client_link1->afterEncBufLen)) = cl_link1;
        client_link1->afterEncBufLen = client_link1->afterEncBufLen + 32 / 8;
        memcpy((void *)&client_link1->afterEncBuf[(signed long int)client_link1->afterEncBufLen], (const void *)&subrect_link1, (unsigned long int)8);
        client_link1->afterEncBufLen = client_link1->afterEncBufLen + 8;
        j_link2 = they_link2;
        for( ; !(j_link2 >= theh_link2 + they_link2); j_link2 = j_link2 + 1)
        {
          i_link2 = thex_link2;
          for( ; !(i_link2 >= thew_link2 + thex_link2); i_link2 = i_link2 + 1)
            data_link2[(signed long int)(j_link2 * w_link2 + i_link2)] = bg_link1;
        }
      }

  }
  return numsubs_link2;
}

// subrectEncode8
// file corre.c line 293
static signed int subrectEncode8(struct _rfbClientRec *client, unsigned char *data, signed int w, signed int h)
{
  unsigned char subrectEncode8__1__cl;
  struct anonymous_17 subrect;
  signed int x;
  signed int y;
  signed int i;
  signed int subrectEncode8__1__j;
  signed int hx = 0;
  signed int hy;
  signed int vx = 0;
  signed int vy;
  signed int hyflag;
  unsigned char *seg;
  unsigned char *line;
  signed int hw;
  signed int hh;
  signed int vw;
  signed int vh;
  signed int thex;
  signed int they;
  signed int thew;
  signed int theh;
  signed int numsubs = 0;
  signed int newLen;
  unsigned char bg;
  unsigned int return_value_getBgColour_1;
  return_value_getBgColour_1=getBgColour((char *)data, w * h, 8);
  bg = (unsigned char)return_value_getBgColour_1;
  *((unsigned char *)client->afterEncBuf) = bg;
  client->afterEncBufLen = 8 / 8;
  y = 0;
  _Bool tmp_if_expr_2;
  for( ; !(y >= h); y = y + 1)
  {
    line = data + (signed long int)(y * w);
    x = 0;
    for( ; !(x >= w); x = x + 1)
      if(!(line[(signed long int)x] == bg))
      {
        subrectEncode8__1__cl = line[(signed long int)x];
        hy = y - 1;
        hyflag = 1;
        subrectEncode8__1__j = y;
        for( ; !(subrectEncode8__1__j >= h); subrectEncode8__1__j = subrectEncode8__1__j + 1)
        {
          seg = data + (signed long int)(subrectEncode8__1__j * w);
          if(!(seg[(signed long int)x] == subrectEncode8__1__cl))
            break;

          i = x;
          for( ; seg[(signed long int)i] == subrectEncode8__1__cl; i = i + 1)
            if(i >= w)
              break;

          i = i - 1;
          if(subrectEncode8__1__j == y)
          {
            hx = i;
            vx = hx;
          }

          if(!(i >= vx))
            vx = i;

          if(hyflag >= 1 && i >= hx)
            hy = hy + 1;

          else
            hyflag = 0;
        }
        vy = subrectEncode8__1__j - 1;
        hw = (hx - x) + 1;
        hh = (hy - y) + 1;
        vw = (vx - x) + 1;
        vh = (vy - y) + 1;
        thex = x;
        they = y;
        if(!(vh * vw >= hh * hw))
        {
          thew = hw;
          theh = hh;
        }

        else
        {
          thew = vw;
          theh = vh;
        }
        subrect.x = (unsigned char)thex;
        subrect.y = (unsigned char)they;
        subrect.w = (unsigned char)thew;
        subrect.h = (unsigned char)theh;
        newLen = client->afterEncBufLen + 8 / 8 + 4;
        if(!(h * w >= newLen))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = newLen > client->afterEncBufSize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          return -1;

        numsubs = numsubs + 1;
        *((unsigned char *)(client->afterEncBuf + (signed long int)client->afterEncBufLen)) = subrectEncode8__1__cl;
        client->afterEncBufLen = client->afterEncBufLen + 8 / 8;
        memcpy((void *)&client->afterEncBuf[(signed long int)client->afterEncBufLen], (const void *)&subrect, (unsigned long int)4);
        client->afterEncBufLen = client->afterEncBufLen + 4;
        subrectEncode8__1__j = they;
        for( ; !(subrectEncode8__1__j >= theh + they); subrectEncode8__1__j = subrectEncode8__1__j + 1)
        {
          i = thex;
          for( ; !(i >= thew + thex); i = i + 1)
            data[(signed long int)(subrectEncode8__1__j * w + i)] = bg;
        }
      }

  }
  return numsubs;
}

// subrectEncode8_link1
// file hextile.c line 340
static signed char subrectEncode8_link1(struct _rfbClientRec *cl, unsigned char *data_link1, signed int w_link1, signed int h_link1, unsigned char bg, unsigned char fg, signed char mono)
{
  unsigned char cl2;
  signed int x_link1;
  signed int y_link1;
  signed int i_link1;
  signed int j_link1;
  signed int hx_link1 = 0;
  signed int hy_link1;
  signed int vx_link1 = 0;
  signed int vy_link1;
  signed int hyflag_link1;
  unsigned char *seg_link1;
  unsigned char *line_link1;
  signed int hw_link1;
  signed int hh_link1;
  signed int vw_link1;
  signed int vh_link1;
  signed int thex_link1;
  signed int they_link1;
  signed int thew_link1;
  signed int theh_link1;
  signed int numsubs_link1 = 0;
  signed int newLen_link1;
  signed int nSubrectsUblen = cl->ublen;
  cl->ublen = cl->ublen + 1;
  rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
  y_link1 = 0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  for( ; !(y_link1 >= h_link1); y_link1 = y_link1 + 1)
  {
    line_link1 = data_link1 + (signed long int)(y_link1 * w_link1);
    x_link1 = 0;
    for( ; !(x_link1 >= w_link1); x_link1 = x_link1 + 1)
      if(!(line_link1[(signed long int)x_link1] == bg))
      {
        cl2 = line_link1[(signed long int)x_link1];
        hy_link1 = y_link1 - 1;
        hyflag_link1 = 1;
        j_link1 = y_link1;
        for( ; !(j_link1 >= h_link1); j_link1 = j_link1 + 1)
        {
          seg_link1 = data_link1 + (signed long int)(j_link1 * w_link1);
          if(!(seg_link1[(signed long int)x_link1] == cl2))
            break;

          i_link1 = x_link1;
          for( ; seg_link1[(signed long int)i_link1] == cl2; i_link1 = i_link1 + 1)
            if(i_link1 >= w_link1)
              break;

          i_link1 = i_link1 - 1;
          if(j_link1 == y_link1)
          {
            hx_link1 = i_link1;
            vx_link1 = hx_link1;
          }

          if(!(i_link1 >= vx_link1))
            vx_link1 = i_link1;

          if(hyflag_link1 >= 1 && i_link1 >= hx_link1)
            hy_link1 = hy_link1 + 1;

          else
            hyflag_link1 = 0;
        }
        vy_link1 = j_link1 - 1;
        hw_link1 = (hx_link1 - x_link1) + 1;
        hh_link1 = (hy_link1 - y_link1) + 1;
        vw_link1 = (vx_link1 - x_link1) + 1;
        vh_link1 = (vy_link1 - y_link1) + 1;
        thex_link1 = x_link1;
        they_link1 = y_link1;
        if(!(vh_link1 * vw_link1 >= hh_link1 * hw_link1))
        {
          thew_link1 = hw_link1;
          theh_link1 = hh_link1;
        }

        else
        {
          thew_link1 = vw_link1;
          theh_link1 = vh_link1;
        }
        if(!(mono == 0))
          newLen_link1 = (cl->ublen - nSubrectsUblen) + 2;

        else
          newLen_link1 = (cl->ublen - nSubrectsUblen) + 8 / 8 + 2;
        if(!(h_link1 * w_link1 >= newLen_link1))
          return (signed char)0;

        numsubs_link1 = numsubs_link1 + 1;
        if(mono == 0)
        {
          tmp_post_1 = cl->ublen;
          cl->ublen = cl->ublen + 1;
          cl->updateBuf[(signed long int)tmp_post_1] = (char)cl2;
        }

        tmp_post_2 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_2] = (char)(thex_link1 << 4 | they_link1);
        tmp_post_3 = cl->ublen;
        cl->ublen = cl->ublen + 1;
        cl->updateBuf[(signed long int)tmp_post_3] = (char)(thew_link1 - 1 << 4 | theh_link1 - 1);
        rfbStatRecordEncodingSentAdd(cl, (unsigned int)5, 1);
        j_link1 = they_link1;
        for( ; !(j_link1 >= theh_link1 + they_link1); j_link1 = j_link1 + 1)
        {
          i_link1 = thex_link1;
          for( ; !(i_link1 >= thew_link1 + thex_link1); i_link1 = i_link1 + 1)
            data_link1[(signed long int)(j_link1 * w_link1 + i_link1)] = bg;
        }
      }

  }
  cl->updateBuf[(signed long int)nSubrectsUblen] = (char)numsubs_link1;
  return (signed char)-1;
}

// subrectEncode8_link2
// file rre.c line 260
static signed int subrectEncode8_link2(struct _rfbClientRec *client_link1, unsigned char *data_link2, signed int w_link2, signed int h_link2)
{
  unsigned char cl_link1;
  struct anonymous_5 subrect_link1;
  signed int x_link2;
  signed int y_link2;
  signed int i_link2;
  signed int j_link2;
  signed int hx_link2 = 0;
  signed int hy_link2;
  signed int vx_link2 = 0;
  signed int vy_link2;
  signed int hyflag_link2;
  unsigned char *seg_link2;
  unsigned char *line_link2;
  signed int hw_link2;
  signed int hh_link2;
  signed int vw_link2;
  signed int vh_link2;
  signed int thex_link2;
  signed int they_link2;
  signed int thew_link2;
  signed int theh_link2;
  signed int numsubs_link2 = 0;
  signed int newLen_link2;
  unsigned char bg_link1;
  unsigned int return_value_getBgColour_1_link1;
  return_value_getBgColour_1_link1=getBgColour_link1((char *)data_link2, w_link2 * h_link2, 8);
  bg_link1 = (unsigned char)return_value_getBgColour_1_link1;
  *((unsigned char *)client_link1->afterEncBuf) = bg_link1;
  client_link1->afterEncBufLen = 8 / 8;
  y_link2 = 0;
  _Bool tmp_if_expr_2_link1;
  for( ; !(y_link2 >= h_link2); y_link2 = y_link2 + 1)
  {
    line_link2 = data_link2 + (signed long int)(y_link2 * w_link2);
    x_link2 = 0;
    for( ; !(x_link2 >= w_link2); x_link2 = x_link2 + 1)
      if(!(line_link2[(signed long int)x_link2] == bg_link1))
      {
        cl_link1 = line_link2[(signed long int)x_link2];
        hy_link2 = y_link2 - 1;
        hyflag_link2 = 1;
        j_link2 = y_link2;
        for( ; !(j_link2 >= h_link2); j_link2 = j_link2 + 1)
        {
          seg_link2 = data_link2 + (signed long int)(j_link2 * w_link2);
          if(!(seg_link2[(signed long int)x_link2] == cl_link1))
            break;

          i_link2 = x_link2;
          for( ; seg_link2[(signed long int)i_link2] == cl_link1; i_link2 = i_link2 + 1)
            if(i_link2 >= w_link2)
              break;

          i_link2 = i_link2 - 1;
          if(j_link2 == y_link2)
          {
            hx_link2 = i_link2;
            vx_link2 = hx_link2;
          }

          if(!(i_link2 >= vx_link2))
            vx_link2 = i_link2;

          if(hyflag_link2 >= 1 && i_link2 >= hx_link2)
            hy_link2 = hy_link2 + 1;

          else
            hyflag_link2 = 0;
        }
        vy_link2 = j_link2 - 1;
        hw_link2 = (hx_link2 - x_link2) + 1;
        hh_link2 = (hy_link2 - y_link2) + 1;
        vw_link2 = (vx_link2 - x_link2) + 1;
        vh_link2 = (vy_link2 - y_link2) + 1;
        thex_link2 = x_link2;
        they_link2 = y_link2;
        if(!(vh_link2 * vw_link2 >= hh_link2 * hw_link2))
        {
          thew_link2 = hw_link2;
          theh_link2 = hh_link2;
        }

        else
        {
          thew_link2 = vw_link2;
          theh_link2 = vh_link2;
        }
        subrect_link1.x = (unsigned short int)(rfbEndianTest != 0 ? (thex_link2 & 0xff) << 8 | thex_link2 >> 8 & 0xff : thex_link2);
        subrect_link1.y = (unsigned short int)(rfbEndianTest != 0 ? (they_link2 & 0xff) << 8 | they_link2 >> 8 & 0xff : they_link2);
        subrect_link1.w = (unsigned short int)(rfbEndianTest != 0 ? (thew_link2 & 0xff) << 8 | thew_link2 >> 8 & 0xff : thew_link2);
        subrect_link1.h = (unsigned short int)(rfbEndianTest != 0 ? (theh_link2 & 0xff) << 8 | theh_link2 >> 8 & 0xff : theh_link2);
        newLen_link2 = client_link1->afterEncBufLen + 8 / 8 + 8;
        if(!(h_link2 * w_link2 >= newLen_link2))
          tmp_if_expr_2_link1 = (_Bool)1;

        else
          tmp_if_expr_2_link1 = newLen_link2 > client_link1->afterEncBufSize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2_link1)
          return -1;

        numsubs_link2 = numsubs_link2 + 1;
        *((unsigned char *)(client_link1->afterEncBuf + (signed long int)client_link1->afterEncBufLen)) = cl_link1;
        client_link1->afterEncBufLen = client_link1->afterEncBufLen + 8 / 8;
        memcpy((void *)&client_link1->afterEncBuf[(signed long int)client_link1->afterEncBufLen], (const void *)&subrect_link1, (unsigned long int)8);
        client_link1->afterEncBufLen = client_link1->afterEncBufLen + 8;
        j_link2 = they_link2;
        for( ; !(j_link2 >= theh_link2 + they_link2); j_link2 = j_link2 + 1)
        {
          i_link2 = thex_link2;
          for( ; !(i_link2 >= thew_link2 + thex_link2); i_link2 = i_link2 + 1)
            data_link2[(signed long int)(j_link2 * w_link2 + i_link2)] = bg_link1;
        }
      }

  }
  return numsubs_link2;
}

// testColours16
// file hextile.c line 341
static void testColours16(unsigned short int *data, signed int size, signed char *mono, signed char *solid, unsigned short int *bg, unsigned short int *fg)
{
  unsigned short int colour1 = (unsigned short int)0;
  unsigned short int colour2 = (unsigned short int)0;
  signed int n1 = 0;
  signed int n2 = 0;
  *mono = (signed char)-1;
  *solid = (signed char)-1;
  for( ; size >= 1; data = data + 1l)
  {
    if(n1 == 0)
      colour1 = *data;

    if(*data == colour1)
      n1 = n1 + 1;

    else
    {
      if(n2 == 0)
      {
        *solid = (signed char)0;
        colour2 = *data;
      }

      if(*data == colour2)
        n2 = n2 + 1;

      else
      {
        *mono = (signed char)0;
        break;
      }
    }
    size = size - 1;
  }
  if(!(n2 >= n1))
  {
    *bg = colour1;
    *fg = colour2;
  }

  else
  {
    *bg = colour2;
    *fg = colour1;
  }
}

// testColours32
// file hextile.c line 342
static void testColours32(unsigned int *data, signed int size, signed char *mono, signed char *solid, unsigned int *bg, unsigned int *fg)
{
  unsigned int colour1 = (unsigned int)0;
  unsigned int colour2 = (unsigned int)0;
  signed int n1 = 0;
  signed int n2 = 0;
  *mono = (signed char)-1;
  *solid = (signed char)-1;
  for( ; size >= 1; data = data + 1l)
  {
    if(n1 == 0)
      colour1 = *data;

    if(*data == colour1)
      n1 = n1 + 1;

    else
    {
      if(n2 == 0)
      {
        *solid = (signed char)0;
        colour2 = *data;
      }

      if(*data == colour2)
        n2 = n2 + 1;

      else
      {
        *mono = (signed char)0;
        break;
      }
    }
    size = size - 1;
  }
  if(!(n2 >= n1))
  {
    *bg = colour1;
    *fg = colour2;
  }

  else
  {
    *bg = colour2;
    *fg = colour1;
  }
}

// testColours8
// file hextile.c line 340
static void testColours8(unsigned char *data, signed int size, signed char *mono, signed char *solid, unsigned char *bg, unsigned char *fg)
{
  unsigned char colour1 = (unsigned char)0;
  unsigned char colour2 = (unsigned char)0;
  signed int n1 = 0;
  signed int n2 = 0;
  *mono = (signed char)-1;
  *solid = (signed char)-1;
  for( ; size >= 1; data = data + 1l)
  {
    if(n1 == 0)
      colour1 = *data;

    if(*data == colour1)
      n1 = n1 + 1;

    else
    {
      if(n2 == 0)
      {
        *solid = (signed char)0;
        colour2 = *data;
      }

      if(*data == colour2)
        n2 = n2 + 1;

      else
      {
        *mono = (signed char)0;
        break;
      }
    }
    size = size - 1;
  }
  if(!(n2 >= n1))
  {
    *bg = colour1;
    *fg = colour2;
  }

  else
  {
    *bg = colour2;
    *fg = colour1;
  }
}

// tjBufSize
// file ../common/turbojpeg.c line 498
unsigned long int tjBufSize(signed int width, signed int height, signed int jpegSubsamp)
{
  unsigned long int retval = (unsigned long int)0;
  signed int mcuw;
  signed int mcuh;
  signed int chromasf;
  if(jpegSubsamp >= 5 || !(height >= 1) || !(jpegSubsamp >= 0) || !(width >= 1))
  {
    snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjBufSize(): Invalid argument");
    retval = (unsigned long int)-1;
  }

  else
  {
    mcuw = tjMCUWidth[(signed long int)jpegSubsamp];
    mcuh = tjMCUHeight[(signed long int)jpegSubsamp];
    chromasf = jpegSubsamp == 3 ? 0 : (4 * 64) / (mcuw * mcuh);
    retval = (unsigned long int)(((width + mcuw) - 1 & ~(mcuw - 1)) * ((height + mcuh) - 1 & ~(mcuh - 1)) * (2 + chromasf) + 2048);
  }

bailout:
  ;
  return retval;
}

// tjCompress
// file ../common/turbojpeg.h line 509
signed int tjCompress(void *handle, unsigned char *srcBuf, signed int width, signed int pitch, signed int height, signed int pixelSize, unsigned char *jpegBuf, unsigned long int *jpegSize, signed int jpegSubsamp, signed int jpegQual, signed int flags)
{
  signed int retval = 0;
  unsigned long int size;
  signed int return_value_getPixelFormat_1;
  return_value_getPixelFormat_1=getPixelFormat(pixelSize, flags);
  retval=tjCompress2(handle, srcBuf, width, pitch, height, return_value_getPixelFormat_1, &jpegBuf, &size, jpegSubsamp, jpegQual, flags);
  *jpegSize = size;
  return retval;
}

// tjCompress2
// file ../common/turbojpeg.c line 538
signed int tjCompress2(void *handle, unsigned char *srcBuf, signed int width, signed int pitch, signed int height, signed int pixelFormat, unsigned char **jpegBuf, unsigned long int *jpegSize, signed int jpegSubsamp, signed int jpegQual, signed int flags)
{
  signed int i;
  signed int retval = 0;
  unsigned char **row_pointer = (unsigned char **)(void *)0;
  struct _tjinstance *this = (struct _tjinstance *)handle;
  struct jpeg_compress_struct *cinfo = (struct jpeg_compress_struct *)(void *)0;
  struct jpeg_decompress_struct *dinfo = (struct jpeg_decompress_struct *)(void *)0;
  (void)cinfo;
  (void)dinfo;
  signed int return_value__setjmp_1;
  signed int return_value_setCompDefaults_2;
  void *return_value_malloc_3;
  unsigned long int return_value_tjBufSize_4;
  if(this == ((struct _tjinstance *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "Invalid handle");
    return -1;
  }

  else
  {
    cinfo = &this->cinfo;
    dinfo = &this->dinfo;
    if((1 & this->init) == 0)
    {
      snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjCompress2(): Instance has not been initialized for compression");
      retval = -1;
    }

    else
      if(jpegBuf == ((unsigned char **)NULL) || jpegSize == ((unsigned long int *)NULL) || srcBuf == ((unsigned char *)NULL) || jpegQual >= 101 || jpegSubsamp >= 5 || pixelFormat >= 11 || !(height >= 1) || !(jpegQual >= 0) || !(jpegSubsamp >= 0) || !(pitch >= 0) || !(pixelFormat >= 0) || !(width >= 1))
      {
        snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjCompress2(): Invalid argument");
        retval = -1;
      }

      else
      {
        return_value__setjmp_1=_setjmp(this->jerr.setjmp_buffer);
        if(!(return_value__setjmp_1 == 0))
          retval = -1;

        else
        {
          if(pitch == 0)
            pitch = width * tjPixelSize[(signed long int)pixelFormat];

          cinfo->image_width = (unsigned int)width;
          cinfo->image_height = (unsigned int)height;
          if(!((8 & flags) == 0))
            putenv("JSIMD_FORCEMMX=1");

          else
            if(!((16 & flags) == 0))
              putenv("JSIMD_FORCESSE=1");

            else
              if(!((32 & flags) == 0))
                putenv("JSIMD_FORCESSE2=1");

          return_value_setCompDefaults_2=setCompDefaults(cinfo, pixelFormat, jpegSubsamp, jpegQual);
          if(return_value_setCompDefaults_2 == -1)
            return -1;

          this->jdst.next_output_byte = *jpegBuf;
          this->jdst.free_in_buffer=tjBufSize(width, height, jpegSubsamp);
          jpeg_start_compress(cinfo, 1);
          return_value_malloc_3=malloc(sizeof(unsigned char *) /*8ul*/  * (unsigned long int)height);
          row_pointer = (unsigned char **)return_value_malloc_3;
          if(row_pointer == ((unsigned char **)NULL))
          {
            snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjCompress2(): Memory allocation failure");
            retval = -1;
          }

          else
          {
            i = 0;
            for( ; !(i >= height); i = i + 1)
              if(!((2 & flags) == 0))
                row_pointer[(signed long int)i] = &srcBuf[(signed long int)(((height - i) - 1) * pitch)];

              else
                row_pointer[(signed long int)i] = &srcBuf[(signed long int)(i * pitch)];
            while(!(cinfo->next_scanline >= cinfo->image_height))
              jpeg_write_scanlines(cinfo, &row_pointer[(signed long int)cinfo->next_scanline], cinfo->image_height - cinfo->next_scanline);
            jpeg_finish_compress(cinfo);
            return_value_tjBufSize_4=tjBufSize(width, height, jpegSubsamp);
            *jpegSize = return_value_tjBufSize_4 - (unsigned long int)this->jdst.free_in_buffer;
          }
        }
      }

  bailout:
    ;
    if(cinfo->global_state >= 101)
      jpeg_abort_compress(cinfo);

    if(!(row_pointer == ((unsigned char **)NULL)))
      free((void *)row_pointer);

    return retval;
  }
}

// tjDecompress
// file ../common/turbojpeg.c line 848
signed int tjDecompress(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, unsigned char *dstBuf, signed int width, signed int pitch, signed int height, signed int pixelSize, signed int flags)
{
  signed int return_value_getPixelFormat_1;
  return_value_getPixelFormat_1=getPixelFormat(pixelSize, flags);
  signed int return_value_tjDecompress2_2;
  return_value_tjDecompress2_2=tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, width, pitch, height, return_value_getPixelFormat_1, flags);
  return return_value_tjDecompress2_2;
}

// tjDecompress2
// file ../common/turbojpeg.c line 746
signed int tjDecompress2(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, unsigned char *dstBuf, signed int width, signed int pitch, signed int height, signed int pixelFormat, signed int flags)
{
  signed int i;
  signed int retval = 0;
  unsigned char **row_pointer = (unsigned char **)(void *)0;
  signed int jpegwidth;
  signed int jpegheight;
  signed int scaledw;
  signed int scaledh;
  struct _tjinstance *this = (struct _tjinstance *)handle;
  struct jpeg_compress_struct *cinfo = (struct jpeg_compress_struct *)(void *)0;
  struct jpeg_decompress_struct *dinfo = (struct jpeg_decompress_struct *)(void *)0;
  (void)cinfo;
  (void)dinfo;
  signed int return_value__setjmp_1;
  signed int return_value_setDecompDefaults_2;
  void *return_value_malloc_3;
  if(this == ((struct _tjinstance *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "Invalid handle");
    return -1;
  }

  else
  {
    cinfo = &this->cinfo;
    dinfo = &this->dinfo;
    if((2 & this->init) == 0)
    {
      snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompress2(): Instance has not been initialized for decompression");
      retval = -1;
    }

    else
      if(dstBuf == ((unsigned char *)NULL) || jpegBuf == ((unsigned char *)NULL) || pixelFormat >= 11 || !(height >= 0) || !(pitch >= 0) || !(pixelFormat >= 0) || !(width >= 0) || !(jpegSize >= 1ul))
      {
        snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompress2(): Invalid argument");
        retval = -1;
      }

      else
      {
        if(!((8 & flags) == 0))
          putenv("JSIMD_FORCEMMX=1");

        else
          if(!((16 & flags) == 0))
            putenv("JSIMD_FORCESSE=1");

          else
            if(!((32 & flags) == 0))
              putenv("JSIMD_FORCESSE2=1");

        return_value__setjmp_1=_setjmp(this->jerr.setjmp_buffer);
        if(!(return_value__setjmp_1 == 0))
          retval = -1;

        else
        {
          this->jsrc.bytes_in_buffer = jpegSize;
          this->jsrc.next_input_byte = jpegBuf;
          jpeg_read_header(dinfo, 1);
          return_value_setDecompDefaults_2=setDecompDefaults(dinfo, pixelFormat);
          if(return_value_setDecompDefaults_2 == -1)
            retval = -1;

          else
          {
            if(!((256 & flags) == 0))
              dinfo->do_fancy_upsampling = 0;

            jpegwidth = (signed int)dinfo->image_width;
            jpegheight = (signed int)dinfo->image_height;
            if(width == 0)
              width = jpegwidth;

            if(height == 0)
              height = jpegheight;

            i = 0;
            for( ; !(i >= 4); i = i + 1)
            {
              scaledw = ((jpegwidth * sf[(signed long int)i].num + sf[(signed long int)i].denom) - 1) / sf[(signed long int)i].denom;
              scaledh = ((jpegheight * sf[(signed long int)i].num + sf[(signed long int)i].denom) - 1) / sf[(signed long int)i].denom;
              if(height >= scaledh && width >= scaledw)
                break;

            }
            if(!(height >= scaledh) || !(width >= scaledw))
            {
              snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompress2(): Could not scale down to desired image dimensions");
              retval = -1;
            }

            else
            {
              width = scaledw;
              height = scaledh;
              dinfo->scale_num = (unsigned int)sf[(signed long int)i].num;
              dinfo->scale_denom = (unsigned int)sf[(signed long int)i].denom;
              jpeg_start_decompress(dinfo);
              if(pitch == 0)
                pitch = (signed int)(dinfo->output_width * (unsigned int)tjPixelSize[(signed long int)pixelFormat]);

              return_value_malloc_3=malloc(sizeof(unsigned char *) /*8ul*/  * (unsigned long int)dinfo->output_height);
              row_pointer = (unsigned char **)return_value_malloc_3;
              if(row_pointer == ((unsigned char **)NULL))
              {
                snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompress2(): Memory allocation failure");
                retval = -1;
              }

              else
              {
                i = 0;
                for( ; !(i >= (signed int)dinfo->output_height); i = i + 1)
                  if(!((2 & flags) == 0))
                    row_pointer[(signed long int)i] = &dstBuf[(signed long int)(((dinfo->output_height - (unsigned int)i) - (unsigned int)1) * (unsigned int)pitch)];

                  else
                    row_pointer[(signed long int)i] = &dstBuf[(signed long int)(i * pitch)];
                while(!(dinfo->output_scanline >= dinfo->output_height))
                  jpeg_read_scanlines(dinfo, &row_pointer[(signed long int)dinfo->output_scanline], dinfo->output_height - dinfo->output_scanline);
                jpeg_finish_decompress(dinfo);
              }
            }
          }
        }
      }

  bailout:
    ;
    if(dinfo->global_state >= 201)
      jpeg_abort_decompress(dinfo);

    if(!(row_pointer == ((unsigned char **)NULL)))
      free((void *)row_pointer);

    return retval;
  }
}

// tjDecompressHeader
// file ../common/turbojpeg.c line 723
signed int tjDecompressHeader(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, signed int *width, signed int *height)
{
  signed int jpegSubsamp;
  signed int return_value_tjDecompressHeader2_1;
  return_value_tjDecompressHeader2_1=tjDecompressHeader2(handle, jpegBuf, jpegSize, width, height, &jpegSubsamp);
  return return_value_tjDecompressHeader2_1;
}

// tjDecompressHeader2
// file ../common/turbojpeg.c line 684
signed int tjDecompressHeader2(void *handle, unsigned char *jpegBuf, unsigned long int jpegSize, signed int *width, signed int *height, signed int *jpegSubsamp)
{
  signed int retval = 0;
  struct _tjinstance *this = (struct _tjinstance *)handle;
  struct jpeg_compress_struct *cinfo = (struct jpeg_compress_struct *)(void *)0;
  struct jpeg_decompress_struct *dinfo = (struct jpeg_decompress_struct *)(void *)0;
  (void)cinfo;
  (void)dinfo;
  signed int return_value__setjmp_1;
  _Bool tmp_if_expr_2;
  if(this == ((struct _tjinstance *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "Invalid handle");
    return -1;
  }

  else
  {
    cinfo = &this->cinfo;
    dinfo = &this->dinfo;
    if((2 & this->init) == 0)
    {
      snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompressHeader2(): Instance has not been initialized for decompression");
      retval = -1;
    }

    else
      if(height == ((signed int *)NULL) || jpegSubsamp == ((signed int *)NULL) || width == ((signed int *)NULL) || jpegBuf == ((unsigned char *)NULL) || !(jpegSize >= 1ul))
      {
        snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompressHeader2(): Invalid argument");
        retval = -1;
      }

      else
      {
        return_value__setjmp_1=_setjmp(this->jerr.setjmp_buffer);
        if(!(return_value__setjmp_1 == 0))
          return -1;

        this->jsrc.bytes_in_buffer = jpegSize;
        this->jsrc.next_input_byte = jpegBuf;
        jpeg_read_header(dinfo, 1);
        *width = (signed int)dinfo->image_width;
        *height = (signed int)dinfo->image_height;
        *jpegSubsamp=getSubsamp(dinfo);
        jpeg_abort_decompress(dinfo);
        if(!(*jpegSubsamp >= 0))
        {
          snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompressHeader2(): Could not determine subsampling type for JPEG image");
          retval = -1;
        }

        else
        {
          if(!(*width >= 1))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = *height < 1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            snprintf(errStr, (unsigned long int)200, "%s", (const void *)"tjDecompressHeader2(): Invalid data returned in header");
            retval = -1;
          }

        }
      }

  bailout:
    ;
    return retval;
  }
}

// tjDestroy
// file ../common/turbojpeg.h line 479
signed int tjDestroy(void *handle)
{
  struct _tjinstance *this = (struct _tjinstance *)handle;
  struct jpeg_compress_struct *cinfo = (struct jpeg_compress_struct *)(void *)0;
  struct jpeg_decompress_struct *dinfo = (struct jpeg_decompress_struct *)(void *)0;
  (void)cinfo;
  (void)dinfo;
  if(this == ((struct _tjinstance *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "Invalid handle");
    return -1;
  }

  else
  {
    cinfo = &this->cinfo;
    dinfo = &this->dinfo;
    signed int return_value__setjmp_1;
    return_value__setjmp_1=_setjmp(this->jerr.setjmp_buffer);
    if(!(return_value__setjmp_1 == 0))
      return -1;

    else
    {
      if(!((1 & this->init) == 0))
        jpeg_destroy_compress(cinfo);

      if(!((2 & this->init) == 0))
        jpeg_destroy_decompress(dinfo);

      free((void *)this);
      return 0;
    }
  }
}

// tjGetErrorStr
// file ../common/turbojpeg.h line 487
char * tjGetErrorStr(void)
{
  return errStr;
}

// tjGetScalingFactors
// file ../common/turbojpeg.c line 732
struct anonymous_29 * tjGetScalingFactors(signed int *numscalingfactors)
{
  if(numscalingfactors == ((signed int *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "tjGetScalingFactors(): Invalid argument");
    return (struct anonymous_29 *)(void *)0;
  }

  else
  {
    *numscalingfactors = 4;
    return (struct anonymous_29 *)sf;
  }
}

// tjInitCompress
// file ../common/turbojpeg.h line 302
void * tjInitCompress(void)
{
  struct _tjinstance *this = (struct _tjinstance *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _tjinstance) /*1624ul*/ );
  this = (struct _tjinstance *)return_value_malloc_1;
  if(this == ((struct _tjinstance *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "tjInitCompress(): Memory allocation failure");
    return (void *)0;
  }

  else
  {
    memset((void *)this, 0, sizeof(struct _tjinstance) /*1624ul*/ );
    void *return_value__tjInitCompress_2;
    return_value__tjInitCompress_2=_tjInitCompress(this);
    return return_value__tjInitCompress_2;
  }
}

// tjInitDecompress
// file ../common/turbojpeg.c line 670
void * tjInitDecompress(void)
{
  struct _tjinstance *this;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct _tjinstance) /*1624ul*/ );
  this = (struct _tjinstance *)return_value_malloc_1;
  if(this == ((struct _tjinstance *)NULL))
  {
    snprintf(errStr, (unsigned long int)200, "tjInitDecompress(): Memory allocation failure");
    return (void *)0;
  }

  else
  {
    memset((void *)this, 0, sizeof(struct _tjinstance) /*1624ul*/ );
    void *return_value__tjInitDecompress_2;
    return_value__tjInitDecompress_2=_tjInitDecompress(this);
    return return_value__tjInitDecompress_2;
  }
}

// u2p
// file ../common/minilzo.c line 4128
static void * u2p(void *ptr, unsigned long int off)
{
  return (void *)((unsigned char *)ptr + (signed long int)off);
}

// unscrun
// file ../common/d3des.c line 175
static void unscrun(unsigned long int *outof, unsigned char *into)
{
  unsigned char *tmp_post_1 = into;
  into = into + 1l;
  *tmp_post_1 = (unsigned char)(*outof >> 24 & (unsigned long int)0xffL);
  unsigned char *tmp_post_2 = into;
  into = into + 1l;
  *tmp_post_2 = (unsigned char)(*outof >> 16 & (unsigned long int)0xffL);
  unsigned char *tmp_post_3 = into;
  into = into + 1l;
  *tmp_post_3 = (unsigned char)(*outof >> 8 & (unsigned long int)0xffL);
  unsigned char *tmp_post_4 = into;
  into = into + 1l;
  unsigned long int *tmp_post_5 = outof;
  outof = outof + 1l;
  *tmp_post_4 = (unsigned char)(*tmp_post_5 & (unsigned long int)0xffL);
  unsigned char *tmp_post_6 = into;
  into = into + 1l;
  *tmp_post_6 = (unsigned char)(*outof >> 24 & (unsigned long int)0xffL);
  unsigned char *tmp_post_7 = into;
  into = into + 1l;
  *tmp_post_7 = (unsigned char)(*outof >> 16 & (unsigned long int)0xffL);
  unsigned char *tmp_post_8 = into;
  into = into + 1l;
  *tmp_post_8 = (unsigned char)(*outof >> 8 & (unsigned long int)0xffL);
  *into = (unsigned char)(*outof & (unsigned long int)0xffL);
}

// usage
// file storepasswd.c line 25
static void usage(void)
{
  printf("\nusage:  storepasswd <password> <filename>\n\n");
  printf("Stores a password in encrypted format.\n");
  printf("The resulting file can be used with the -rfbauth argument to OSXvnc.\n\n");
  exit(1);
}

// validateString
// file httpd.c line 643
static signed char validateString(char *str)
{
  char *ptr = str;
  for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
  {
    const unsigned short int **return_value___ctype_b_loc_1;
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*ptr]) == 0)
    {
      if(!((signed int)*ptr == 95))
      {
        if(!((signed int)*ptr == 46))
        {
          if(!((signed int)*ptr == 58))
          {
            if(!((signed int)*ptr == 91))
            {
              if(!((signed int)*ptr == 93))
              {
                if((signed int)*ptr == 43)
                  *ptr = (char)32;

                else
                  return (signed char)0;
              }

            }

          }

        }

      }

    }

  }
  return (signed char)-1;
}

// webSocketCheckDisconnect
// file ../rfb/rfb.h line 765
extern signed char webSocketCheckDisconnect(struct _rfbClientRec *cl)
{
  struct ws_ctx_s *wsctx = (struct ws_ctx_s *)cl->wsctx;
  char peekbuf[4l];
  signed int n;
  signed long int return_value_recv_1;
  signed long int return_value_read_2;
  if(wsctx->version == 1)
    return (signed char)0;

  else
  {
    if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
      n=rfbssl_peek(cl, peekbuf, 4);

    else
    {
      return_value_recv_1=recv(cl->sock, (void *)peekbuf, (unsigned long int)4, 2);
      n = (signed int)return_value_recv_1;
    }
    if(!(n >= 1))
    {
      if(!(n == 0))
        rfbErr("%s: peek; %m", (const void *)"webSocketCheckDisconnect");

      rfbCloseClient(cl);
      return (signed char)-1;
    }

    else
    {
      if((signed int)peekbuf[0l] == -1)
      {
        signed int doclose = 0;
        switch(n)
        {
          case 3:
          {
            if((signed int)peekbuf[1l] == -1)
            {
              if((signed int)peekbuf[2l] == 0)
                doclose = 1;

            }

            break;
          }
          case 2:
          {
            if((signed int)peekbuf[1l] == 0)
              doclose = 1;

            break;
          }
          default:
            return (signed char)0;
        }
        if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
          n=rfbssl_read(cl, peekbuf, n);

        else
        {
          return_value_read_2=read(cl->sock, (void *)peekbuf, (unsigned long int)n);
          n = (signed int)return_value_read_2;
        }
        if(!(doclose == 0))
        {
          rfbErr("%s: websocket close frame received\n", (const void *)"webSocketCheckDisconnect");
          rfbCloseClient(cl);
        }

        return (signed char)-1;
      }

      return (signed char)0;
    }
  }
}

// webSocketsCheck
// file ../rfb/rfb.h line 764
extern signed char webSocketsCheck(struct _rfbClientRec *cl)
{
  char bbuf[4l];
  char *scheme;
  signed int ret;
  ret=rfbPeekExactTimeout(cl, bbuf, 4, 100);
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  if(!(ret >= 0))
  {
    return_value___errno_location_1=__errno_location();
    tmp_if_expr_2 = *return_value___errno_location_1 == 110 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    rfbLog("Normal socket connection\n");
    return (signed char)-1;
  }

  else
    if(!(ret >= 1))
    {
      rfbErr("webSocketsHandshake: unknown connection error\n");
      return (signed char)0;
    }

  signed int return_value_strncmp_8;
  return_value_strncmp_8=strncmp(bbuf, "<", (unsigned long int)1);
  signed int return_value_strncmp_5;
  _Bool tmp_if_expr_7;
  signed int return_value_strncmp_6;
  if(return_value_strncmp_8 == 0)
  {
    rfbLog("Got Flash policy request, sending response\n");
    signed int return_value_rfbWriteExact_3;
    return_value_rfbWriteExact_3=rfbWriteExact(cl, "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"*\" /></cross-domain-policy>\n", 93);
    if(!(return_value_rfbWriteExact_3 >= 0))
      rfbErr("webSocketsHandshake: failed sending Flash policy response");

    return (signed char)0;
  }

  else
  {
    return_value_strncmp_5=strncmp(bbuf, "\026", (unsigned long int)1);
    if(return_value_strncmp_5 == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strncmp_6=strncmp(bbuf, "", (unsigned long int)1);
      tmp_if_expr_7 = return_value_strncmp_6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      rfbLog("Got TLS/SSL WebSockets connection\n");
      signed int return_value_rfbssl_init_4;
      return_value_rfbssl_init_4=rfbssl_init(cl);
      if(return_value_rfbssl_init_4 == -1)
      {
        rfbErr("webSocketsHandshake: rfbssl_init failed\n");
        return (signed char)0;
      }

      ret=rfbPeekExactTimeout(cl, bbuf, 4, 100);
      scheme = "wss";
    }

    else
      scheme = "ws";
  }
  signed int return_value_strncmp_9;
  return_value_strncmp_9=strncmp(bbuf, "GET ", (unsigned long int)4);
  if(!(return_value_strncmp_9 == 0))
  {
    rfbErr("webSocketsHandshake: invalid client header\n");
    return (signed char)0;
  }

  else
  {
    rfbLog("Got '%s' WebSockets handshake\n", scheme);
    signed char return_value_webSocketsHandshake_10;
    return_value_webSocketsHandshake_10=webSocketsHandshake(cl, scheme);
    if(return_value_webSocketsHandshake_10 == 0)
      return (signed char)0;

    else
      return (signed char)-1;
  }
}

// webSocketsDecode
// file ../rfb/rfb.h line 767
extern signed int webSocketsDecode(struct _rfbClientRec *cl, char *dst, signed int len)
{
  signed int return_value;
  return_value=((struct ws_ctx_s *)cl->wsctx)->decode(cl, dst, len);
  return return_value;
}

// webSocketsDecodeHixie
// file websockets.c line 533
static signed int webSocketsDecodeHixie(struct _rfbClientRec *cl, char *dst, signed int len)
{
  signed int retlen = 0;
  signed int n;
  signed int i;
  signed int avail;
  signed int modlen;
  signed int needlen;
  char *webSocketsDecodeHixie__1__buf;
  char *end = (char *)(void *)0;
  struct ws_ctx_s *wsctx = (struct ws_ctx_s *)cl->wsctx;
  webSocketsDecodeHixie__1__buf = wsctx->codeBuf;
  n=ws_peek(cl, webSocketsDecodeHixie__1__buf, len * 2 + 2);
  if(!(n >= 1))
  {
    signed int olderrno;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    olderrno = *return_value___errno_location_1;
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    rfbErr("%s: peek (%d) %m\n", (const void *)"webSocketsDecodeHixie", *return_value___errno_location_2);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = olderrno;
    return n;
  }

  if((signed int)*webSocketsDecodeHixie__1__buf == -1)
  {
    i=ws_read(cl, webSocketsDecodeHixie__1__buf, 1);
    webSocketsDecodeHixie__1__buf = webSocketsDecodeHixie__1__buf + 1l;
    n = n - 1;
  }

  if(n == 0)
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    *return_value___errno_location_4 = 11;
    return -1;
  }

  if((signed int)*webSocketsDecodeHixie__1__buf == 0)
  {
    i=ws_read(cl, webSocketsDecodeHixie__1__buf, 1);
    webSocketsDecodeHixie__1__buf = webSocketsDecodeHixie__1__buf + 1l;
    n = n - 1;
  }

  if(n == 0)
  {
    signed int *return_value___errno_location_5;
    return_value___errno_location_5=__errno_location();
    *return_value___errno_location_5 = 11;
    return -1;
  }

  void *return_value_memchr_6;
  return_value_memchr_6=memchr((const void *)webSocketsDecodeHixie__1__buf, -1, (unsigned long int)n);
  end = (char *)return_value_memchr_6;
  if(end == ((char *)NULL))
    end = webSocketsDecodeHixie__1__buf + (signed long int)n;

  avail = (signed int)(end - webSocketsDecodeHixie__1__buf);
  len = len - wsctx->carrylen;
  modlen = len + (len + 2) / 3;
  needlen = modlen;
  if(!(needlen % 4 == 0))
    needlen = needlen + (4 - needlen % 4);

  if(!(avail >= needlen))
  {
    signed int *return_value___errno_location_7;
    return_value___errno_location_7=__errno_location();
    *return_value___errno_location_7 = 11;
    return -1;
  }

  i = 0;
  for( ; !(i >= wsctx->carrylen); i = i + 1)
  {
    dst[(signed long int)i] = wsctx->carryBuf[(signed long int)i];
    retlen = retlen + 1;
  }
  webSocketsDecodeHixie__1__buf[(signed long int)needlen] = (char)0;
  n=__b64_pton(webSocketsDecodeHixie__1__buf, (unsigned char *)dst + (signed long int)retlen, (unsigned long int)(2 + len));
  if(!(n >= len))
  {
    rfbErr("Base64 decode error\n");
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    *return_value___errno_location_8 = 5;
    return -1;
  }

  retlen = retlen + n;
  i=ws_read(cl, webSocketsDecodeHixie__1__buf, needlen);
  wsctx->carrylen = n - len;
  retlen = retlen - wsctx->carrylen;
  i = 0;
  for( ; !(i >= wsctx->carrylen); i = i + 1)
    wsctx->carryBuf[(signed long int)i] = dst[(signed long int)(retlen + i)];
  return retlen;
}

// webSocketsDecodeHybi
// file websockets.c line 628
static signed int webSocketsDecodeHybi(struct _rfbClientRec *cl, char *dst, signed int len)
{
  char *webSocketsDecodeHybi__1__buf;
  char *payload;
  unsigned int *payload32;
  signed int ret = -1;
  signed int result = -1;
  signed int total = 0;
  union ws_mask_s mask;
  struct ws_header_s *header;
  signed int i;
  unsigned char opcode;
  struct ws_ctx_s *wsctx = (struct ws_ctx_s *)cl->wsctx;
  signed int flength;
  signed int fhlen;
  unsigned short int tmp_statement_expression_5;
  unsigned short int tmp_statement_expression_10;
  if(!(wsctx->readbuflen == 0))
  {
    if(!(len >= wsctx->readbuflen))
    {
      memcpy((void *)dst, (const void *)(wsctx->readbuf + (signed long int)wsctx->readbufstart), (unsigned long int)len);
      result = len;
      wsctx->readbuflen = wsctx->readbuflen - len;
      wsctx->readbufstart = wsctx->readbufstart + len;
    }

    else
    {
      memcpy((void *)dst, (const void *)(wsctx->readbuf + (signed long int)wsctx->readbufstart), (unsigned long int)wsctx->readbuflen);
      result = wsctx->readbuflen;
      wsctx->readbuflen = 0;
      wsctx->readbufstart = 0;
    }
  }

  else
  {
    webSocketsDecodeHybi__1__buf = wsctx->codeBuf;
    header = (struct ws_header_s *)wsctx->codeBuf;
    ret=ws_peek(cl, webSocketsDecodeHybi__1__buf, (((len + 2) / 3) * 12) / 3 + 14);
    if(!(ret >= 2))
    {
      if(ret == -1)
      {
        signed int webSocketsDecodeHybi__1__2__1__olderrno;
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        webSocketsDecodeHybi__1__2__1__olderrno = *return_value___errno_location_1;
        rfbErr("%s: peek; %m\n", (const void *)"webSocketsDecodeHybi");
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        *return_value___errno_location_2 = webSocketsDecodeHybi__1__2__1__olderrno;
      }

      else
        if(ret == 0)
          result = 0;

        else
        {
          signed int *return_value___errno_location_3;
          return_value___errno_location_3=__errno_location();
          *return_value___errno_location_3 = 11;
        }
    }

    else
    {
      opcode = (unsigned char)((signed int)header->b0 & 0x0f);
      flength = (signed int)header->b1 & 0x7f;
      if((0x80 & (signed int)header->b1) == 0)
      {
        rfbErr("%s: got frame without mask\n", (const void *)"webSocketsDecodeHybi", ret);
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        *return_value___errno_location_4 = 5;
      }

      if(!(flength >= 126))
      {
        fhlen = 2;
        mask = header->u.m;
      }

      else
        if(flength == 126 && ret >= 4)
        {
          unsigned short int webSocketsDecodeHybi__1__5__1____v;
          unsigned short int __x = (unsigned short int)header->u.s16.l16;
          asm("rorw _8, %w0" : "=r"(webSocketsDecodeHybi__1__5__1____v) : "0"(__x) : "cc");
          tmp_statement_expression_5 = webSocketsDecodeHybi__1__5__1____v;
          flength = (signed int)tmp_statement_expression_5;
          fhlen = 4;
          mask = header->u.s16.m16;
        }

        else
          if(flength == 127 && ret >= 10)
          {
            unsigned long int return_value___bswap_64_6;
            return_value___bswap_64_6=__bswap_64(header->u.s64.l64);
            flength = (signed int)return_value___bswap_64_6;
            fhlen = 10;
            mask = header->u.s64.m64;
          }

          else
          {
            rfbErr("%s: incomplete frame header\n", (const void *)"webSocketsDecodeHybi", ret);
            signed int *return_value___errno_location_7;
            return_value___errno_location_7=__errno_location();
            *return_value___errno_location_7 = 5;
          }
      total = fhlen + flength + 4;
      payload = webSocketsDecodeHybi__1__buf + (signed long int)fhlen + (signed long int)4;
      ret=ws_read(cl, webSocketsDecodeHybi__1__buf, total);
      if(ret == -1)
      {
        signed int olderrno;
        signed int *return_value___errno_location_8;
        return_value___errno_location_8=__errno_location();
        olderrno = *return_value___errno_location_8;
        rfbErr("%s: read; %m", (const void *)"webSocketsDecodeHybi");
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        *return_value___errno_location_9 = olderrno;
        return ret;
      }

      else
        if(!(ret >= total))
          rfbLog("%s: read; got partial data\n", (const void *)"webSocketsDecodeHybi");

        else
          webSocketsDecodeHybi__1__buf[(signed long int)ret] = (char)0;
      payload32 = (unsigned int *)payload;
      i = 0;
      for( ; !(i >= flength / 4); i = i + 1)
        payload32[(signed long int)i] = payload32[(signed long int)i] ^ mask.u;
      i = i * 4;
      for( ; !(i >= flength); i = i + 1)
        payload[(signed long int)i] = payload[(signed long int)i] ^ mask.c[(signed long int)(i % 4)];
      switch((signed int)opcode)
      {
        case 8:
        {
          unsigned short int __v;
          unsigned short int webSocketsDecodeHybi__1__13__1____x = (unsigned short int)((unsigned short int *)payload)[(signed long int)0];
          asm("rorw _8, %w0" : "=r"(__v) : "0"(webSocketsDecodeHybi__1__13__1____x) : "cc");
          tmp_statement_expression_10 = __v;
          rfbLog("got closure, reason %d\n", tmp_statement_expression_10);
        }
        case 1:
        {
          flength=__b64_pton(payload, (unsigned char *)wsctx->codeBuf, sizeof(char [40014l]) /*40014ul*/ );
          if(flength == -1)
          {
            rfbErr("%s: Base64 decode error; %m\n", (const void *)"webSocketsDecodeHybi");
            break;
          }

          payload = wsctx->codeBuf;
        }
        case 2:
        {
          if(!(len >= flength))
          {
            memcpy((void *)wsctx->readbuf, (const void *)(payload + (signed long int)len), (unsigned long int)(flength - len));
            wsctx->readbufstart = 0;
            wsctx->readbuflen = flength - len;
            flength = len;
          }

          memcpy((void *)dst, (const void *)payload, (unsigned long int)flength);
          result = flength;
          break;
        }
        default:
          rfbErr("%s: unhandled opcode %d, b0: %02x, b1: %02x\n", (const void *)"webSocketsDecodeHybi", (signed int)opcode, header->b0, header->b1);
      }
    }
  }

spor:
  ;
  return result;
}

// webSocketsEncode
// file ../rfb/rfb.h line 766
extern signed int webSocketsEncode(struct _rfbClientRec *cl, const char *src, signed int len, char **dst)
{
  signed int return_value;
  return_value=((struct ws_ctx_s *)cl->wsctx)->encode(cl, src, len, dst);
  return return_value;
}

// webSocketsEncodeHixie
// file websockets.c line 488
static signed int webSocketsEncodeHixie(struct _rfbClientRec *cl, const char *src, signed int len, char **dst)
{
  signed int sz = 0;
  struct ws_ctx_s *wsctx = (struct ws_ctx_s *)cl->wsctx;
  signed int tmp_post_1 = sz;
  sz = sz + 1;
  wsctx->codeBuf[(signed long int)tmp_post_1] = (char)0;
  len=__b64_ntop((unsigned char *)src, (unsigned long int)len, wsctx->codeBuf + (signed long int)sz, sizeof(char [40014l]) /*40014ul*/  - (unsigned long int)(sz + 1));
  signed int tmp_post_2;
  if(!(len >= 0))
    return len;

  else
  {
    sz = sz + len;
    tmp_post_2 = sz;
    sz = sz + 1;
    wsctx->codeBuf[(signed long int)tmp_post_2] = (char)-1;
    *dst = wsctx->codeBuf;
    return sz;
  }
}

// webSocketsEncodeHybi
// file websockets.c line 772
static signed int webSocketsEncodeHybi(struct _rfbClientRec *cl, const char *src, signed int len, char **dst)
{
  signed int blen;
  signed int ret = -1;
  signed int sz = 0;
  unsigned char opcode = (unsigned char)0;
  struct ws_header_s *header;
  struct ws_ctx_s *wsctx = (struct ws_ctx_s *)cl->wsctx;
  unsigned short int tmp_statement_expression_1;
  if(len == 0)
    return 0;

  else
  {
    header = (struct ws_header_s *)wsctx->codeBuf;
    if(!(wsctx->base64 == 0))
    {
      opcode = (unsigned char)1;
      blen = (((len + 2) / 3) * 12) / 3;
    }

    else
    {
      opcode = (unsigned char)2;
      blen = len;
    }
    header->b0 = (unsigned char)(0x80 | (signed int)opcode & 0x0f);
    if(!(blen >= 126))
    {
      header->b1 = (unsigned char)blen;
      sz = 2;
    }

    else
      if(!(blen >= 65537))
      {
        header->b1 = (unsigned char)0x7e;
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)blen;
        asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression_1 = __v;
        header->u.s16.l16 = tmp_statement_expression_1;
        sz = 4;
      }

      else
      {
        header->b1 = (unsigned char)0x7f;
        header->u.s64.l64=__bswap_64((unsigned long int)blen);
        sz = 10;
      }
    if(!(wsctx->base64 == 0))
    {
      ret=__b64_ntop((unsigned char *)src, (unsigned long int)len, wsctx->codeBuf + (signed long int)sz, sizeof(char [40014l]) /*40014ul*/  - (unsigned long int)sz);
      if(ret == -1)
        rfbErr("%s: Base 64 encode failed\n", (const void *)"webSocketsEncodeHybi");

      else
      {
        if(!(ret == blen))
          rfbErr("%s: Base 64 encode; something weird happened\n", (const void *)"webSocketsEncodeHybi");

        ret = ret + sz;
      }
    }

    else
    {
      memcpy((void *)(wsctx->codeBuf + (signed long int)sz), (const void *)src, (unsigned long int)len);
      ret = sz + len;
    }
    *dst = wsctx->codeBuf;
    return ret;
  }
}

// webSocketsGenMd5
// file websockets.c line 438
void webSocketsGenMd5(char *target, char *key1, char *key2, char *key3)
{
  unsigned int i;
  unsigned int spaces1 = (unsigned int)0;
  unsigned int spaces2 = (unsigned int)0;
  unsigned long int num1 = (unsigned long int)0;
  unsigned long int num2 = (unsigned long int)0;
  unsigned char webSocketsGenMd5__1__buf[17l];
  struct iovec iov[1l];
  i = (unsigned int)0;
  unsigned long int return_value_strlen_1;
  do
  {
    return_value_strlen_1=strlen(key1);
    if((unsigned long int)i >= return_value_strlen_1)
      break;

    if((signed int)key1[(signed long int)i] == 32)
      spaces1 = spaces1 + (unsigned int)1;

    if((signed int)key1[(signed long int)i] >= 48)
    {
      if(!((signed int)key1[(signed long int)i] >= 58))
        num1 = num1 * (unsigned long int)10 + (unsigned long int)((signed int)key1[(signed long int)i] - 48);

    }

    i = i + 1u;
  }
  while((_Bool)1);
  num1 = num1 / (unsigned long int)spaces1;
  i = (unsigned int)0;
  unsigned long int return_value_strlen_2;
  do
  {
    return_value_strlen_2=strlen(key2);
    if((unsigned long int)i >= return_value_strlen_2)
      break;

    if((signed int)key2[(signed long int)i] == 32)
      spaces2 = spaces2 + (unsigned int)1;

    if((signed int)key2[(signed long int)i] >= 48)
    {
      if(!((signed int)key2[(signed long int)i] >= 58))
        num2 = num2 * (unsigned long int)10 + (unsigned long int)((signed int)key2[(signed long int)i] - 48);

    }

    i = i + 1u;
  }
  while((_Bool)1);
  num2 = num2 / (unsigned long int)spaces2;
  webSocketsGenMd5__1__buf[(signed long int)0] = (unsigned char)((num1 & (unsigned long int)0xff000000) >> 24);
  webSocketsGenMd5__1__buf[(signed long int)1] = (unsigned char)((num1 & (unsigned long int)0xff0000) >> 16);
  webSocketsGenMd5__1__buf[(signed long int)2] = (unsigned char)((num1 & (unsigned long int)0xff00) >> 8);
  webSocketsGenMd5__1__buf[(signed long int)3] = (unsigned char)(num1 & (unsigned long int)0xff);
  webSocketsGenMd5__1__buf[(signed long int)4] = (unsigned char)((num2 & (unsigned long int)0xff000000) >> 24);
  webSocketsGenMd5__1__buf[(signed long int)5] = (unsigned char)((num2 & (unsigned long int)0xff0000) >> 16);
  webSocketsGenMd5__1__buf[(signed long int)6] = (unsigned char)((num2 & (unsigned long int)0xff00) >> 8);
  webSocketsGenMd5__1__buf[(signed long int)7] = (unsigned char)(num2 & (unsigned long int)0xff);
  strncpy((char *)webSocketsGenMd5__1__buf + (signed long int)8, key3, (unsigned long int)8);
  webSocketsGenMd5__1__buf[(signed long int)16] = (unsigned char)0;
  iov[(signed long int)0].iov_base = (void *)webSocketsGenMd5__1__buf;
  iov[(signed long int)0].iov_len = (unsigned long int)16;
  digestmd5(iov, 1, (void *)target);
  target[(signed long int)16] = (char)0;
  goto __CPROVER_DUMP_L9;

__CPROVER_DUMP_L9:
  ;
}

// webSocketsGenSha1Key
// file websockets.c line 181
static void webSocketsGenSha1Key(char *target, signed int size, char *key)
{
  struct iovec iov[2l];
  unsigned char hash[20l];
  iov[(signed long int)0].iov_base = (void *)key;
  iov[(signed long int)0].iov_len=strlen(key);
  iov[(signed long int)1].iov_base = (void *)"258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  iov[(signed long int)1].iov_len = sizeof(char [37l]) /*37ul*/  - (unsigned long int)1;
  digestsha1(iov, 2, (void *)hash);
  signed int return_value___b64_ntop_1;
  return_value___b64_ntop_1=__b64_ntop(hash, sizeof(unsigned char [20l]) /*20ul*/ , target, (unsigned long int)size);
  if(return_value___b64_ntop_1 == -1)
    rfbErr("b64_ntop failed\n");

}

// webSocketsHandshake
// file websockets.c line 249
static signed char webSocketsHandshake(struct _rfbClientRec *cl, char *scheme)
{
  char *webSocketsHandshake__1__buf;
  char *response;
  char *line;
  signed int n;
  signed int linestart = 0;
  signed int len = 0;
  signed int llen;
  signed int base64 = -1;
  char prefix[5l];
  char trailer[17l];
  char *path = (char *)(void *)0;
  char *host = (char *)(void *)0;
  char *origin = (char *)(void *)0;
  char *protocol = (char *)(void *)0;
  char *key1 = (char *)(void *)0;
  char *key2 = (char *)(void *)0;
  char *key3 = (char *)(void *)0;
  char *sec_ws_origin = (char *)(void *)0;
  char *sec_ws_key = (char *)(void *)0;
  char sec_ws_version = (char)0;
  struct ws_ctx_s *wsctx = (struct ws_ctx_s *)(void *)0;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)4096);
  webSocketsHandshake__1__buf = (char *)return_value_malloc_1;
  signed int *return_value___errno_location_3;
  _Bool tmp_if_expr_26;
  signed int return_value_strncmp_25;
  signed int *return_value___errno_location_4;
  _Bool tmp_if_expr_24;
  signed int return_value_min_22;
  signed int return_value_strncmp_23;
  signed int return_value_min_20;
  signed int return_value_strncasecmp_21;
  signed int return_value_min_18;
  signed int return_value_strncasecmp_19;
  signed int return_value_min_16;
  signed int return_value_strncasecmp_17;
  signed int return_value_min_14;
  signed int return_value_strncasecmp_15;
  signed int return_value_min_12;
  signed int return_value_strncasecmp_13;
  signed int return_value_min_10;
  signed int return_value_strncasecmp_11;
  signed int return_value_min_8;
  signed int return_value_strncasecmp_9;
  signed int return_value_min_6;
  signed int return_value_strncasecmp_7;
  _Bool tmp_if_expr_30;
  char *return_value_strstr_29;
  _Bool tmp_if_expr_28;
  char *return_value_strstr_27;
  if(webSocketsHandshake__1__buf == ((char *)NULL))
  {
    rfbLogPerror("webSocketsHandshake: malloc");
    return (signed char)0;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)4096);
    response = (char *)return_value_malloc_2;
    if(response == ((char *)NULL))
    {
      free((void *)webSocketsHandshake__1__buf);
      rfbLogPerror("webSocketsHandshake: malloc");
      return (signed char)0;
    }

    else
    {
      while(!(len >= 4096))
      {
        n=rfbReadExactTimeout(cl, webSocketsHandshake__1__buf + (signed long int)len, 1, 100);
        if(!(n >= 1))
        {
          if(!(n >= 0))
          {
            return_value___errno_location_3=__errno_location();
            if(*return_value___errno_location_3 == 110)
              break;

          }

          if(n == 0)
            rfbLog("webSocketsHandshake: client gone\n");

          else
            rfbLogPerror("webSocketsHandshake: read");
          free((void *)response);
          free((void *)webSocketsHandshake__1__buf);
          return (signed char)0;
        }

        len = len + 1;
        llen = len - linestart;
        if(llen >= 2)
        {
          if((signed int)webSocketsHandshake__1__buf[(signed long int)(len + -1)] == 10)
          {
            line = webSocketsHandshake__1__buf + (signed long int)linestart;
            if(llen == 2)
            {
              return_value_strncmp_25=strncmp("\r\n", line, (unsigned long int)2);
              tmp_if_expr_26 = return_value_strncmp_25 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_26 = (_Bool)0;
            if(tmp_if_expr_26)
            {
              if(!(key1 == ((char *)NULL)) && !(key2 == ((char *)NULL)))
              {
                n=rfbReadExact(cl, webSocketsHandshake__1__buf + (signed long int)len, 8);
                if(!(n >= 1))
                {
                  if(!(n >= 0))
                  {
                    return_value___errno_location_4=__errno_location();
                    if(*return_value___errno_location_4 == 110)
                      break;

                  }

                  if(n == 0)
                    rfbLog("webSocketsHandshake: client gone\n");

                  else
                    rfbLogPerror("webSocketsHandshake: read");
                  free((void *)response);
                  free((void *)webSocketsHandshake__1__buf);
                  return (signed char)0;
                }

                rfbLog("Got key3\n");
                key3 = webSocketsHandshake__1__buf + (signed long int)len;
                len = len + 8;
              }

              else
                webSocketsHandshake__1__buf[(signed long int)len] = (char)0;
              break;
            }

            else
            {
              if(llen >= 16)
              {
                return_value_min_22=min(llen, 4);
                return_value_strncmp_23=strncmp("GET ", line, (unsigned long int)return_value_min_22);
                tmp_if_expr_24 = return_value_strncmp_23 == 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_24 = (_Bool)0;
              if(tmp_if_expr_24)
              {
                path = line + (signed long int)4;
                webSocketsHandshake__1__buf[(signed long int)(len - 11)] = (char)0;
                cl->wspath=strdup(path);
              }

              else
              {
                return_value_min_20=min(llen, 6);
                return_value_strncasecmp_21=strncasecmp("host: ", line, (unsigned long int)return_value_min_20);
                if(return_value_strncasecmp_21 == 0)
                {
                  host = line + (signed long int)6;
                  webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                }

                else
                {
                  return_value_min_18=min(llen, 8);
                  return_value_strncasecmp_19=strncasecmp("origin: ", line, (unsigned long int)return_value_min_18);
                  if(return_value_strncasecmp_19 == 0)
                  {
                    origin = line + (signed long int)8;
                    webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                  }

                  else
                  {
                    return_value_min_16=min(llen, 20);
                    return_value_strncasecmp_17=strncasecmp("sec-websocket-key1: ", line, (unsigned long int)return_value_min_16);
                    if(return_value_strncasecmp_17 == 0)
                    {
                      key1 = line + (signed long int)20;
                      webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                    }

                    else
                    {
                      return_value_min_14=min(llen, 20);
                      return_value_strncasecmp_15=strncasecmp("sec-websocket-key2: ", line, (unsigned long int)return_value_min_14);
                      if(return_value_strncasecmp_15 == 0)
                      {
                        key2 = line + (signed long int)20;
                        webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                      }

                      else
                      {
                        return_value_min_12=min(llen, 24);
                        return_value_strncasecmp_13=strncasecmp("sec-websocket-protocol: ", line, (unsigned long int)return_value_min_12);
                        if(return_value_strncasecmp_13 == 0)
                        {
                          protocol = line + (signed long int)24;
                          webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                          rfbLog("Got protocol: %s\n", protocol);
                        }

                        else
                        {
                          return_value_min_10=min(llen, 22);
                          return_value_strncasecmp_11=strncasecmp("sec-websocket-origin: ", line, (unsigned long int)return_value_min_10);
                          if(return_value_strncasecmp_11 == 0)
                          {
                            sec_ws_origin = line + (signed long int)22;
                            webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                          }

                          else
                          {
                            return_value_min_8=min(llen, 19);
                            return_value_strncasecmp_9=strncasecmp("sec-websocket-key: ", line, (unsigned long int)return_value_min_8);
                            if(return_value_strncasecmp_9 == 0)
                            {
                              sec_ws_key = line + (signed long int)19;
                              webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                            }

                            else
                            {
                              return_value_min_6=min(llen, 23);
                              return_value_strncasecmp_7=strncasecmp("sec-websocket-version: ", line, (unsigned long int)return_value_min_6);
                              if(return_value_strncasecmp_7 == 0)
                              {
                                signed long int return_value_strtol_5;
                                return_value_strtol_5=strtol(line + (signed long int)23, (char ** restrict )(void *)0, 10);
                                sec_ws_version = (char)return_value_strtol_5;
                                webSocketsHandshake__1__buf[(signed long int)(len - 2)] = (char)0;
                              }

                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            linestart = len;
          }

        }

      }
      if(host == ((char *)NULL) || path == ((char *)NULL) || origin == ((char *)NULL) && sec_ws_origin == ((char *)NULL))
      {
        rfbErr("webSocketsHandshake: incomplete client handshake\n");
        free((void *)response);
        free((void *)webSocketsHandshake__1__buf);
        return (signed char)0;
      }

      else
      {
        if(!(protocol == ((char *)NULL)))
        {
          return_value_strstr_29=strstr(protocol, "binary");
          tmp_if_expr_30 = return_value_strstr_29 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_30 = (_Bool)0;
        if(tmp_if_expr_30)
        {
          if(sec_ws_version == 0)
          {
            rfbErr("webSocketsHandshake: 'binary' protocol not supported with Hixie\n");
            free((void *)response);
            free((void *)webSocketsHandshake__1__buf);
            return (signed char)0;
          }

          rfbLog("  - webSocketsHandshake: using binary/raw encoding\n");
          base64 = 0;
          protocol = "binary";
        }

        else
        {
          rfbLog("  - webSocketsHandshake: using base64 encoding\n");
          base64 = -1;
          if(!(protocol == ((char *)NULL)))
          {
            return_value_strstr_27=strstr(protocol, "base64");
            tmp_if_expr_28 = return_value_strstr_27 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_28 = (_Bool)0;
          if(tmp_if_expr_28)
            protocol = "base64";

          else
            protocol = "";
        }
        if(!(sec_ws_version == 0))
        {
          char webSocketsHandshake__1__7__accept[29l];
          rfbLog("  - WebSockets client version hybi-%02d\n", sec_ws_version);
          webSocketsGenSha1Key(webSocketsHandshake__1__7__accept, (signed int)sizeof(char [29l]) /*29ul*/ , sec_ws_key);
          len=snprintf(response, (unsigned long int)4096, "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: %s\r\nSec-WebSocket-Protocol: %s\r\n\r\n", (const void *)webSocketsHandshake__1__7__accept, protocol);
        }

        else
        {
          if(key1 == ((char *)NULL) || key2 == ((char *)NULL) || key3 == ((char *)NULL))
          {
            rfbLog("  - WebSockets client version hixie-75\n");
            prefix[(signed long int)0] = (char)0;
            trailer[(signed long int)0] = (char)0;
          }

          else
          {
            rfbLog("  - WebSockets client version hixie-76\n");
            snprintf(prefix, (unsigned long int)5, "Sec-");
            webSocketsGenMd5(trailer, key1, key2, key3);
          }
          len=snprintf(response, (unsigned long int)4096, "HTTP/1.1 101 Web Socket Protocol Handshake\r\nUpgrade: WebSocket\r\nConnection: Upgrade\r\n%sWebSocket-Origin: %s\r\n%sWebSocket-Location: %s://%s%s\r\n%sWebSocket-Protocol: %s\r\n\r\n%s", (const void *)prefix, origin, (const void *)prefix, scheme, host, path, (const void *)prefix, protocol, (const void *)trailer);
        }
        signed int return_value_rfbWriteExact_31;
        return_value_rfbWriteExact_31=rfbWriteExact(cl, response, len);
        if(!(return_value_rfbWriteExact_31 >= 0))
        {
          rfbErr("webSocketsHandshake: failed sending WebSockets response\n");
          free((void *)response);
          free((void *)webSocketsHandshake__1__buf);
          return (signed char)0;
        }

        else
        {
          free((void *)response);
          free((void *)webSocketsHandshake__1__buf);
          void *return_value_calloc_32;
          return_value_calloc_32=calloc((unsigned long int)1, sizeof(struct ws_ctx_s) /*48256ul*/ );
          wsctx = (struct ws_ctx_s *)return_value_calloc_32;
          if(!(sec_ws_version == 0))
          {
            wsctx->version = 1;
            wsctx->encode = webSocketsEncodeHybi;
            wsctx->decode = webSocketsDecodeHybi;
          }

          else
          {
            wsctx->version = 0;
            wsctx->encode = webSocketsEncodeHixie;
            wsctx->decode = webSocketsDecodeHixie;
          }
          wsctx->base64 = base64;
          cl->wsctx = (struct _wsCtx *)wsctx;
          return (signed char)-1;
        }
      }
    }
  }
}

// ws_peek
// file websockets.c line 518
static signed int ws_peek(struct _rfbClientRec *cl, char *buf, signed int len)
{
  signed int n;
  signed long int return_value_recv_1;
  if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
    n=rfbssl_peek(cl, buf, len);

  else
    do
    {
      return_value_recv_1=recv(cl->sock, (void *)buf, (unsigned long int)len, 2);
      n = (signed int)return_value_recv_1;
      if(!(n == -1))
        break;

      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(!(*return_value___errno_location_2 == 11))
        break;

    }
    while((_Bool)1);
  return n;
}

// ws_read
// file websockets.c line 506
static signed int ws_read(struct _rfbClientRec *cl, char *buf, signed int len)
{
  signed int n;
  if(!(cl->sslctx == ((struct _rfbSslCtx *)NULL)))
    n=rfbssl_read(cl, buf, len);

  else
  {
    signed long int return_value_read_1;
    return_value_read_1=read(cl->sock, (void *)buf, (unsigned long int)len);
    n = (signed int)return_value_read_1;
  }
  return n;
}

// zrleBufferAlloc
// file zrleoutstream.c line 28
static signed char zrleBufferAlloc(struct anonymous_10 *buffer, signed int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)size);
  buffer->start = (unsigned char *)return_value_malloc_1;
  buffer->ptr = buffer->start;
  if(buffer->start == ((unsigned char *)NULL))
  {
    buffer->end = (unsigned char *)(void *)0;
    return (signed char)0;
  }

  else
  {
    buffer->end = buffer->start + (signed long int)size;
    return (signed char)-1;
  }
}

// zrleBufferFree
// file zrleoutstream.c line 41
static void zrleBufferFree(struct anonymous_10 *buffer)
{
  if(!(buffer->start == ((unsigned char *)NULL)))
    free((void *)buffer->start);

  buffer->end = (unsigned char *)(void *)0;
  buffer->ptr = buffer->end;
  buffer->start = buffer->ptr;
}

// zrleBufferGrow
// file zrleoutstream.c line 48
static signed char zrleBufferGrow(struct anonymous_10 *buffer, signed int size)
{
  signed int offset;
  size = size + (signed int)(buffer->end - buffer->start);
  offset = (signed int)(buffer->ptr - buffer->start);
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)buffer->start, (unsigned long int)size);
  buffer->start = (unsigned char *)return_value_realloc_1;
  if(buffer->start == ((unsigned char *)NULL))
    return (signed char)0;

  else
  {
    buffer->end = buffer->start + (signed long int)size;
    buffer->ptr = buffer->start + (signed long int)offset;
    return (signed char)-1;
  }
}

// zrleEncode15BE
// file ./zrleencodetemplate.c line 97
static void zrleEncode15BE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile15BE((unsigned short int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode15LE
// file ./zrleencodetemplate.c line 97
static void zrleEncode15LE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile15LE((unsigned short int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode16BE
// file ./zrleencodetemplate.c line 97
static void zrleEncode16BE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile16BE((unsigned short int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode16LE
// file ./zrleencodetemplate.c line 97
static void zrleEncode16LE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile16LE((unsigned short int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode24ABE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24ABE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile24ABE((unsigned int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode24ALE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24ALE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile24ALE((unsigned int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode24BBE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24BBE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile24BBE((unsigned int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode24BLE
// file ./zrleencodetemplate.c line 97
static void zrleEncode24BLE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile24BLE((unsigned int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode32BE
// file ./zrleencodetemplate.c line 97
static void zrleEncode32BE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile32BE((unsigned int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode32LE
// file ./zrleencodetemplate.c line 97
static void zrleEncode32LE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile32LE((unsigned int *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncode8NE
// file ./zrleencodetemplate.c line 97
static void zrleEncode8NE(signed int x, signed int y, signed int w, signed int h, struct anonymous_11 *os, void *buf, struct _rfbClientRec *cl)
{
  signed int ty = y;
  for( ; !(ty >= h + y); ty = ty + 64)
  {
    signed int tx;
    signed int th = 64;
    if(!(h + y + -ty >= th))
      th = (y + h) - ty;

    tx = x;
    if(!(tx >= w + x))
    {
      signed int tw = 64;
      if(!(w + x + -tx >= tw))
        tw = (x + w) - tx;

      char *fbptr = cl->scaledScreen->frameBuffer + (signed long int)(cl->scaledScreen->paddedWidthInBytes * ty) + (signed long int)(tx * (cl->scaledScreen->bitsPerPixel / 8));
      cl->translateFn(cl->translateLookupTable, &cl->screen->serverFormat, &cl->format, fbptr, (char *)buf, cl->scaledScreen->paddedWidthInBytes, tw, th);
      if(cl->paletteHelper == NULL)
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct anonymous_12) /*21628ul*/ , (unsigned long int)1);
        cl->paletteHelper = (void *)return_value_calloc_1;
      }

      zrleEncodeTile8NE((unsigned char *)buf, tw, th, os, cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
      tx = tx + 64;
    }

  }
  zrleOutStreamFlush(os);
}

// zrleEncodeTile15BE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile15BE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned short int *zrleEncodeTile15BE__1__ptr = data;
  unsigned short int *zrleEncodeTile15BE__1__end = zrleEncodeTile15BE__1__ptr + (signed long int)(h * w);
  *zrleEncodeTile15BE__1__end = (unsigned short int)~((signed int)*(zrleEncodeTile15BE__1__end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile15BE__1__ptr >= zrleEncodeTile15BE__1__end))
  {
    unsigned short int zrleEncodeTile15BE__1__1__pix = *zrleEncodeTile15BE__1__ptr;
    zrleEncodeTile15BE__1__ptr = zrleEncodeTile15BE__1__ptr + 1l;
    if(!(*zrleEncodeTile15BE__1__ptr == zrleEncodeTile15BE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile15BE__1__ptr = zrleEncodeTile15BE__1__ptr + 1l;
        if(!(*zrleEncodeTile15BE__1__ptr == zrleEncodeTile15BE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, (unsigned int)zrleEncodeTile15BE__1__1__pix);
  }
  unsigned short int *tmp_post_1;
  unsigned short int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (16 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (16 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (16 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (16 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned short int *ptr = data;
      unsigned short int *end = ptr + (signed long int)(w * h);
      unsigned short int *runStart;
      unsigned short int pix;
      while(!(ptr >= end))
      {
        signed int len;
        runStart = ptr;
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        pix = *tmp_post_1;
        for( ; *ptr == pix; ptr = ptr + 1l)
          if(ptr >= end)
            break;

        len = (signed int)(ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, (unsigned int)pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile15BE__1__6__1__2__index;
          zrleEncodeTile15BE__1__6__1__2__index=zrlePaletteHelperLookup(ph, (unsigned int)pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile15BE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque16(os, pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned short int *zrleEncodeTile15BE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned short int *eol = zrleEncodeTile15BE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile15BE__1__7__1__ptr >= eol))
          {
            unsigned short int zrleEncodeTile15BE__1__7__1__1__1__1__pix;
            tmp_post_2 = zrleEncodeTile15BE__1__7__1__ptr;
            zrleEncodeTile15BE__1__7__1__ptr = zrleEncodeTile15BE__1__7__1__ptr + 1l;
            zrleEncodeTile15BE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile15BE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile15BE__1__7__1__1__1__1__pix);
            zrleEncodeTile15BE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile15BE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze15BE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile15BE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
          zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (15 / 8));
  }
}

// zrleEncodeTile15LE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile15LE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned short int *ptr = data;
  unsigned short int *end = ptr + (signed long int)(h * w);
  *end = (unsigned short int)~((signed int)*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(ptr >= end))
  {
    unsigned short int pix = *ptr;
    ptr = ptr + 1l;
    if(!(*ptr == pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        ptr = ptr + 1l;
        if(!(*ptr == pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, (unsigned int)pix);
  }
  unsigned short int *tmp_post_1;
  unsigned short int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (16 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (16 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (16 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (16 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned short int *zrleEncodeTile15LE__1__6__ptr = data;
      unsigned short int *zrleEncodeTile15LE__1__6__end = zrleEncodeTile15LE__1__6__ptr + (signed long int)(w * h);
      unsigned short int *runStart;
      unsigned short int zrleEncodeTile15LE__1__6__pix;
      while(!(zrleEncodeTile15LE__1__6__ptr >= zrleEncodeTile15LE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile15LE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile15LE__1__6__ptr;
        zrleEncodeTile15LE__1__6__ptr = zrleEncodeTile15LE__1__6__ptr + 1l;
        zrleEncodeTile15LE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile15LE__1__6__ptr == zrleEncodeTile15LE__1__6__pix; zrleEncodeTile15LE__1__6__ptr = zrleEncodeTile15LE__1__6__ptr + 1l)
          if(zrleEncodeTile15LE__1__6__ptr >= zrleEncodeTile15LE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile15LE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile15LE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile15LE__1__6__1__2__index;
          zrleEncodeTile15LE__1__6__1__2__index=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile15LE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile15LE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque16(os, zrleEncodeTile15LE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned short int *zrleEncodeTile15LE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned short int *eol = zrleEncodeTile15LE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile15LE__1__7__1__ptr >= eol))
          {
            unsigned short int zrleEncodeTile15LE__1__7__1__1__1__1__pix;
            tmp_post_2 = zrleEncodeTile15LE__1__7__1__ptr;
            zrleEncodeTile15LE__1__7__1__ptr = zrleEncodeTile15LE__1__7__1__ptr + 1l;
            zrleEncodeTile15LE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile15LE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile15LE__1__7__1__1__1__1__pix);
            zrleEncodeTile15LE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile15LE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze15LE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile15LE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
          zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (15 / 8));
  }
}

// zrleEncodeTile16BE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile16BE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned short int *zrleEncodeTile16BE__1__ptr = data;
  unsigned short int *end = zrleEncodeTile16BE__1__ptr + (signed long int)(h * w);
  *end = (unsigned short int)~((signed int)*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile16BE__1__ptr >= end))
  {
    unsigned short int zrleEncodeTile16BE__1__1__pix = *zrleEncodeTile16BE__1__ptr;
    zrleEncodeTile16BE__1__ptr = zrleEncodeTile16BE__1__ptr + 1l;
    if(!(*zrleEncodeTile16BE__1__ptr == zrleEncodeTile16BE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile16BE__1__ptr = zrleEncodeTile16BE__1__ptr + 1l;
        if(!(*zrleEncodeTile16BE__1__ptr == zrleEncodeTile16BE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, (unsigned int)zrleEncodeTile16BE__1__1__pix);
  }
  unsigned short int *tmp_post_1;
  unsigned short int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (16 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (16 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (16 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (16 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned short int *zrleEncodeTile16BE__1__6__ptr = data;
      unsigned short int *zrleEncodeTile16BE__1__6__end = zrleEncodeTile16BE__1__6__ptr + (signed long int)(w * h);
      unsigned short int *runStart;
      unsigned short int zrleEncodeTile16BE__1__6__pix;
      while(!(zrleEncodeTile16BE__1__6__ptr >= zrleEncodeTile16BE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile16BE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile16BE__1__6__ptr;
        zrleEncodeTile16BE__1__6__ptr = zrleEncodeTile16BE__1__6__ptr + 1l;
        zrleEncodeTile16BE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile16BE__1__6__ptr == zrleEncodeTile16BE__1__6__pix; zrleEncodeTile16BE__1__6__ptr = zrleEncodeTile16BE__1__6__ptr + 1l)
          if(zrleEncodeTile16BE__1__6__ptr >= zrleEncodeTile16BE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile16BE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int zrleEncodeTile16BE__1__6__1__1__index;
          zrleEncodeTile16BE__1__6__1__1__index=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile16BE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile16BE__1__6__1__1__index);

          zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile16BE__1__6__1__1__index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile16BE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(index | 128));
        }

        else
          zrleOutStreamWriteOpaque16(os, zrleEncodeTile16BE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned short int *ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned short int *eol = ptr + (signed long int)w;
          while(!(ptr >= eol))
          {
            unsigned short int pix;
            tmp_post_2 = ptr;
            ptr = ptr + 1l;
            pix = *tmp_post_2;
            unsigned char zrleEncodeTile16BE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, (unsigned int)pix);
            zrleEncodeTile16BE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile16BE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze16BE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile16BE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
          zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (16 / 8));
  }
}

// zrleEncodeTile16LE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile16LE(unsigned short int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned short int *zrleEncodeTile16LE__1__ptr = data;
  unsigned short int *end = zrleEncodeTile16LE__1__ptr + (signed long int)(h * w);
  *end = (unsigned short int)~((signed int)*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile16LE__1__ptr >= end))
  {
    unsigned short int zrleEncodeTile16LE__1__1__pix = *zrleEncodeTile16LE__1__ptr;
    zrleEncodeTile16LE__1__ptr = zrleEncodeTile16LE__1__ptr + 1l;
    if(!(*zrleEncodeTile16LE__1__ptr == zrleEncodeTile16LE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile16LE__1__ptr = zrleEncodeTile16LE__1__ptr + 1l;
        if(!(*zrleEncodeTile16LE__1__ptr == zrleEncodeTile16LE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, (unsigned int)zrleEncodeTile16LE__1__1__pix);
  }
  unsigned short int *tmp_post_1;
  unsigned short int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (16 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (16 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (16 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (16 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque16(os, (unsigned short int)ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned short int *zrleEncodeTile16LE__1__6__ptr = data;
      unsigned short int *zrleEncodeTile16LE__1__6__end = zrleEncodeTile16LE__1__6__ptr + (signed long int)(w * h);
      unsigned short int *runStart;
      unsigned short int pix;
      while(!(zrleEncodeTile16LE__1__6__ptr >= zrleEncodeTile16LE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile16LE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile16LE__1__6__ptr;
        zrleEncodeTile16LE__1__6__ptr = zrleEncodeTile16LE__1__6__ptr + 1l;
        pix = *tmp_post_1;
        for( ; *zrleEncodeTile16LE__1__6__ptr == pix; zrleEncodeTile16LE__1__6__ptr = zrleEncodeTile16LE__1__6__ptr + 1l)
          if(zrleEncodeTile16LE__1__6__ptr >= zrleEncodeTile16LE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile16LE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, (unsigned int)pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile16LE__1__6__1__2__index;
          zrleEncodeTile16LE__1__6__1__2__index=zrlePaletteHelperLookup(ph, (unsigned int)pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile16LE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque16(os, pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned short int *ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned short int *eol = ptr + (signed long int)w;
          while(!(ptr >= eol))
          {
            unsigned short int zrleEncodeTile16LE__1__7__1__1__1__1__pix;
            tmp_post_2 = ptr;
            ptr = ptr + 1l;
            zrleEncodeTile16LE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile16LE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile16LE__1__7__1__1__1__1__pix);
            zrleEncodeTile16LE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile16LE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze16LE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile16LE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
          zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (16 / 8));
  }
}

// zrleEncodeTile24ABE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24ABE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned int *zrleEncodeTile24ABE__1__ptr = data;
  unsigned int *end = zrleEncodeTile24ABE__1__ptr + (signed long int)(h * w);
  *end = ~(*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile24ABE__1__ptr >= end))
  {
    unsigned int zrleEncodeTile24ABE__1__1__pix = *zrleEncodeTile24ABE__1__ptr;
    zrleEncodeTile24ABE__1__ptr = zrleEncodeTile24ABE__1__ptr + 1l;
    if(!(*zrleEncodeTile24ABE__1__ptr == zrleEncodeTile24ABE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile24ABE__1__ptr = zrleEncodeTile24ABE__1__ptr + 1l;
        if(!(*zrleEncodeTile24ABE__1__ptr == zrleEncodeTile24ABE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, zrleEncodeTile24ABE__1__1__pix);
  }
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque24A(os, ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (24 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (24 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (24 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (24 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque24A(os, ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned int *zrleEncodeTile24ABE__1__6__ptr = data;
      unsigned int *zrleEncodeTile24ABE__1__6__end = zrleEncodeTile24ABE__1__6__ptr + (signed long int)(w * h);
      unsigned int *runStart;
      unsigned int pix;
      while(!(zrleEncodeTile24ABE__1__6__ptr >= zrleEncodeTile24ABE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile24ABE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile24ABE__1__6__ptr;
        zrleEncodeTile24ABE__1__6__ptr = zrleEncodeTile24ABE__1__6__ptr + 1l;
        pix = *tmp_post_1;
        for( ; *zrleEncodeTile24ABE__1__6__ptr == pix; zrleEncodeTile24ABE__1__6__ptr = zrleEncodeTile24ABE__1__6__ptr + 1l)
          if(zrleEncodeTile24ABE__1__6__ptr >= zrleEncodeTile24ABE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile24ABE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile24ABE__1__6__1__2__index;
          zrleEncodeTile24ABE__1__6__1__2__index=zrlePaletteHelperLookup(ph, pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile24ABE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque24A(os, pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned int *ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned int *eol = ptr + (signed long int)w;
          while(!(ptr >= eol))
          {
            unsigned int zrleEncodeTile24ABE__1__7__1__1__1__1__pix;
            tmp_post_2 = ptr;
            ptr = ptr + 1l;
            zrleEncodeTile24ABE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile24ABE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, zrleEncodeTile24ABE__1__7__1__1__1__1__pix);
            zrleEncodeTile24ABE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile24ABE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze32BE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile24ABE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
        {
          unsigned int *zrleEncodeTile24ABE__1__7__2__2__ptr = data;
          for( ; !(zrleEncodeTile24ABE__1__7__2__2__ptr >= data + (signed long int)(h * w)); zrleEncodeTile24ABE__1__7__2__2__ptr = zrleEncodeTile24ABE__1__7__2__2__ptr + 1l)
            zrleOutStreamWriteOpaque24A(os, *zrleEncodeTile24ABE__1__7__2__2__ptr);
        }
  }
}

// zrleEncodeTile24ALE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24ALE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned int *zrleEncodeTile24ALE__1__ptr = data;
  unsigned int *end = zrleEncodeTile24ALE__1__ptr + (signed long int)(h * w);
  *end = ~(*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile24ALE__1__ptr >= end))
  {
    unsigned int zrleEncodeTile24ALE__1__1__pix = *zrleEncodeTile24ALE__1__ptr;
    zrleEncodeTile24ALE__1__ptr = zrleEncodeTile24ALE__1__ptr + 1l;
    if(!(*zrleEncodeTile24ALE__1__ptr == zrleEncodeTile24ALE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile24ALE__1__ptr = zrleEncodeTile24ALE__1__ptr + 1l;
        if(!(*zrleEncodeTile24ALE__1__ptr == zrleEncodeTile24ALE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, zrleEncodeTile24ALE__1__1__pix);
  }
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque24A(os, ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (24 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (24 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (24 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (24 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque24A(os, ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned int *zrleEncodeTile24ALE__1__6__ptr = data;
      unsigned int *zrleEncodeTile24ALE__1__6__end = zrleEncodeTile24ALE__1__6__ptr + (signed long int)(w * h);
      unsigned int *runStart;
      unsigned int zrleEncodeTile24ALE__1__6__pix;
      while(!(zrleEncodeTile24ALE__1__6__ptr >= zrleEncodeTile24ALE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile24ALE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile24ALE__1__6__ptr;
        zrleEncodeTile24ALE__1__6__ptr = zrleEncodeTile24ALE__1__6__ptr + 1l;
        zrleEncodeTile24ALE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile24ALE__1__6__ptr == zrleEncodeTile24ALE__1__6__pix; zrleEncodeTile24ALE__1__6__ptr = zrleEncodeTile24ALE__1__6__ptr + 1l)
          if(zrleEncodeTile24ALE__1__6__ptr >= zrleEncodeTile24ALE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile24ALE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int zrleEncodeTile24ALE__1__6__1__1__index;
          zrleEncodeTile24ALE__1__6__1__1__index=zrlePaletteHelperLookup(ph, zrleEncodeTile24ALE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile24ALE__1__6__1__1__index);

          zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile24ALE__1__6__1__1__index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile24ALE__1__6__1__2__index;
          zrleEncodeTile24ALE__1__6__1__2__index=zrlePaletteHelperLookup(ph, zrleEncodeTile24ALE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile24ALE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque24A(os, zrleEncodeTile24ALE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned int *zrleEncodeTile24ALE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned int *eol = zrleEncodeTile24ALE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile24ALE__1__7__1__ptr >= eol))
          {
            unsigned int pix;
            tmp_post_2 = zrleEncodeTile24ALE__1__7__1__ptr;
            zrleEncodeTile24ALE__1__7__1__ptr = zrleEncodeTile24ALE__1__7__1__ptr + 1l;
            pix = *tmp_post_2;
            unsigned char index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, pix);
            index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze32LE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile24ALE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
        {
          unsigned int *ptr = data;
          for( ; !(ptr >= data + (signed long int)(h * w)); ptr = ptr + 1l)
            zrleOutStreamWriteOpaque24A(os, *ptr);
        }
  }
}

// zrleEncodeTile24BBE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24BBE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned int *zrleEncodeTile24BBE__1__ptr = data;
  unsigned int *end = zrleEncodeTile24BBE__1__ptr + (signed long int)(h * w);
  *end = ~(*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile24BBE__1__ptr >= end))
  {
    unsigned int zrleEncodeTile24BBE__1__1__pix = *zrleEncodeTile24BBE__1__ptr;
    zrleEncodeTile24BBE__1__ptr = zrleEncodeTile24BBE__1__ptr + 1l;
    if(!(*zrleEncodeTile24BBE__1__ptr == zrleEncodeTile24BBE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile24BBE__1__ptr = zrleEncodeTile24BBE__1__ptr + 1l;
        if(!(*zrleEncodeTile24BBE__1__ptr == zrleEncodeTile24BBE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, zrleEncodeTile24BBE__1__1__pix);
  }
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque24B(os, ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (24 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (24 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (24 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (24 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque24B(os, ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned int *zrleEncodeTile24BBE__1__6__ptr = data;
      unsigned int *zrleEncodeTile24BBE__1__6__end = zrleEncodeTile24BBE__1__6__ptr + (signed long int)(w * h);
      unsigned int *runStart;
      unsigned int zrleEncodeTile24BBE__1__6__pix;
      while(!(zrleEncodeTile24BBE__1__6__ptr >= zrleEncodeTile24BBE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile24BBE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile24BBE__1__6__ptr;
        zrleEncodeTile24BBE__1__6__ptr = zrleEncodeTile24BBE__1__6__ptr + 1l;
        zrleEncodeTile24BBE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile24BBE__1__6__ptr == zrleEncodeTile24BBE__1__6__pix; zrleEncodeTile24BBE__1__6__ptr = zrleEncodeTile24BBE__1__6__ptr + 1l)
          if(zrleEncodeTile24BBE__1__6__ptr >= zrleEncodeTile24BBE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile24BBE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int zrleEncodeTile24BBE__1__6__1__1__index;
          zrleEncodeTile24BBE__1__6__1__1__index=zrlePaletteHelperLookup(ph, zrleEncodeTile24BBE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile24BBE__1__6__1__1__index);

          zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile24BBE__1__6__1__1__index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile24BBE__1__6__1__2__index;
          zrleEncodeTile24BBE__1__6__1__2__index=zrlePaletteHelperLookup(ph, zrleEncodeTile24BBE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile24BBE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque24B(os, zrleEncodeTile24BBE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned int *zrleEncodeTile24BBE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned int *eol = zrleEncodeTile24BBE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile24BBE__1__7__1__ptr >= eol))
          {
            unsigned int pix;
            tmp_post_2 = zrleEncodeTile24BBE__1__7__1__ptr;
            zrleEncodeTile24BBE__1__7__1__ptr = zrleEncodeTile24BBE__1__7__1__ptr + 1l;
            pix = *tmp_post_2;
            unsigned char index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, pix);
            index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze32BE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile24BBE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
        {
          unsigned int *ptr = data;
          for( ; !(ptr >= data + (signed long int)(h * w)); ptr = ptr + 1l)
            zrleOutStreamWriteOpaque24B(os, *ptr);
        }
  }
}

// zrleEncodeTile24BLE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile24BLE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned int *ptr = data;
  unsigned int *end = ptr + (signed long int)(h * w);
  *end = ~(*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(ptr >= end))
  {
    unsigned int pix = *ptr;
    ptr = ptr + 1l;
    if(!(*ptr == pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        ptr = ptr + 1l;
        if(!(*ptr == pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, pix);
  }
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque24B(os, ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (24 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (24 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (24 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (24 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque24B(os, ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned int *zrleEncodeTile24BLE__1__6__ptr = data;
      unsigned int *zrleEncodeTile24BLE__1__6__end = zrleEncodeTile24BLE__1__6__ptr + (signed long int)(w * h);
      unsigned int *runStart;
      unsigned int zrleEncodeTile24BLE__1__6__pix;
      while(!(zrleEncodeTile24BLE__1__6__ptr >= zrleEncodeTile24BLE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile24BLE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile24BLE__1__6__ptr;
        zrleEncodeTile24BLE__1__6__ptr = zrleEncodeTile24BLE__1__6__ptr + 1l;
        zrleEncodeTile24BLE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile24BLE__1__6__ptr == zrleEncodeTile24BLE__1__6__pix; zrleEncodeTile24BLE__1__6__ptr = zrleEncodeTile24BLE__1__6__ptr + 1l)
          if(zrleEncodeTile24BLE__1__6__ptr >= zrleEncodeTile24BLE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile24BLE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, zrleEncodeTile24BLE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile24BLE__1__6__1__2__index;
          zrleEncodeTile24BLE__1__6__1__2__index=zrlePaletteHelperLookup(ph, zrleEncodeTile24BLE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile24BLE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque24B(os, zrleEncodeTile24BLE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned int *zrleEncodeTile24BLE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned int *eol = zrleEncodeTile24BLE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile24BLE__1__7__1__ptr >= eol))
          {
            unsigned int zrleEncodeTile24BLE__1__7__1__1__1__1__pix;
            tmp_post_2 = zrleEncodeTile24BLE__1__7__1__ptr;
            zrleEncodeTile24BLE__1__7__1__ptr = zrleEncodeTile24BLE__1__7__1__ptr + 1l;
            zrleEncodeTile24BLE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile24BLE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, zrleEncodeTile24BLE__1__7__1__1__1__1__pix);
            zrleEncodeTile24BLE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile24BLE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze32LE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile24BLE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
        {
          unsigned int *zrleEncodeTile24BLE__1__7__2__2__ptr = data;
          for( ; !(zrleEncodeTile24BLE__1__7__2__2__ptr >= data + (signed long int)(h * w)); zrleEncodeTile24BLE__1__7__2__2__ptr = zrleEncodeTile24BLE__1__7__2__2__ptr + 1l)
            zrleOutStreamWriteOpaque24B(os, *zrleEncodeTile24BLE__1__7__2__2__ptr);
        }
  }
}

// zrleEncodeTile32BE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile32BE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned int *ptr = data;
  unsigned int *end = ptr + (signed long int)(h * w);
  *end = ~(*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(ptr >= end))
  {
    unsigned int pix = *ptr;
    ptr = ptr + 1l;
    if(!(*ptr == pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        ptr = ptr + 1l;
        if(!(*ptr == pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, pix);
  }
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque32(os, ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (32 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (32 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (32 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (32 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque32(os, ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned int *zrleEncodeTile32BE__1__6__ptr = data;
      unsigned int *zrleEncodeTile32BE__1__6__end = zrleEncodeTile32BE__1__6__ptr + (signed long int)(w * h);
      unsigned int *runStart;
      unsigned int zrleEncodeTile32BE__1__6__pix;
      while(!(zrleEncodeTile32BE__1__6__ptr >= zrleEncodeTile32BE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile32BE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile32BE__1__6__ptr;
        zrleEncodeTile32BE__1__6__ptr = zrleEncodeTile32BE__1__6__ptr + 1l;
        zrleEncodeTile32BE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile32BE__1__6__ptr == zrleEncodeTile32BE__1__6__pix; zrleEncodeTile32BE__1__6__ptr = zrleEncodeTile32BE__1__6__ptr + 1l)
          if(zrleEncodeTile32BE__1__6__ptr >= zrleEncodeTile32BE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile32BE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, zrleEncodeTile32BE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile32BE__1__6__1__2__index;
          zrleEncodeTile32BE__1__6__1__2__index=zrlePaletteHelperLookup(ph, zrleEncodeTile32BE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile32BE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque32(os, zrleEncodeTile32BE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned int *zrleEncodeTile32BE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned int *eol = zrleEncodeTile32BE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile32BE__1__7__1__ptr >= eol))
          {
            unsigned int zrleEncodeTile32BE__1__7__1__1__1__1__pix;
            tmp_post_2 = zrleEncodeTile32BE__1__7__1__ptr;
            zrleEncodeTile32BE__1__7__1__ptr = zrleEncodeTile32BE__1__7__1__ptr + 1l;
            zrleEncodeTile32BE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile32BE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, zrleEncodeTile32BE__1__7__1__1__1__1__pix);
            zrleEncodeTile32BE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile32BE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze32BE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile32BE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
          zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (32 / 8));
  }
}

// zrleEncodeTile32LE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile32LE(unsigned int *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned int *ptr = data;
  unsigned int *end = ptr + (signed long int)(h * w);
  *end = ~(*(end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(ptr >= end))
  {
    unsigned int pix = *ptr;
    ptr = ptr + 1l;
    if(!(*ptr == pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        ptr = ptr + 1l;
        if(!(*ptr == pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, pix);
  }
  unsigned int *tmp_post_1;
  unsigned int *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque32(os, ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (32 / 8);
    if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
      estimatedBytes = estimatedBytes >> zywrle_level;

    plainRleBytes = (32 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (32 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (32 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque32(os, ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned int *zrleEncodeTile32LE__1__6__ptr = data;
      unsigned int *zrleEncodeTile32LE__1__6__end = zrleEncodeTile32LE__1__6__ptr + (signed long int)(w * h);
      unsigned int *runStart;
      unsigned int zrleEncodeTile32LE__1__6__pix;
      while(!(zrleEncodeTile32LE__1__6__ptr >= zrleEncodeTile32LE__1__6__end))
      {
        signed int len;
        runStart = zrleEncodeTile32LE__1__6__ptr;
        tmp_post_1 = zrleEncodeTile32LE__1__6__ptr;
        zrleEncodeTile32LE__1__6__ptr = zrleEncodeTile32LE__1__6__ptr + 1l;
        zrleEncodeTile32LE__1__6__pix = *tmp_post_1;
        for( ; *zrleEncodeTile32LE__1__6__ptr == zrleEncodeTile32LE__1__6__pix; zrleEncodeTile32LE__1__6__ptr = zrleEncodeTile32LE__1__6__ptr + 1l)
          if(zrleEncodeTile32LE__1__6__ptr >= zrleEncodeTile32LE__1__6__end)
            break;

        len = (signed int)(zrleEncodeTile32LE__1__6__ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int index;
          index=zrlePaletteHelperLookup(ph, zrleEncodeTile32LE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)index);

          zrleOutStreamWriteU8(os, (unsigned char)index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile32LE__1__6__1__2__index;
          zrleEncodeTile32LE__1__6__1__2__index=zrlePaletteHelperLookup(ph, zrleEncodeTile32LE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile32LE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque32(os, zrleEncodeTile32LE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned int *zrleEncodeTile32LE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned int *eol = zrleEncodeTile32LE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile32LE__1__7__1__ptr >= eol))
          {
            unsigned int zrleEncodeTile32LE__1__7__1__1__1__1__pix;
            tmp_post_2 = zrleEncodeTile32LE__1__7__1__ptr;
            zrleEncodeTile32LE__1__7__1__ptr = zrleEncodeTile32LE__1__7__1__ptr + 1l;
            zrleEncodeTile32LE__1__7__1__1__1__1__pix = *tmp_post_2;
            unsigned char zrleEncodeTile32LE__1__7__1__1__1__1__index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, zrleEncodeTile32LE__1__7__1__1__1__1__pix);
            zrleEncodeTile32LE__1__7__1__1__1__1__index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)zrleEncodeTile32LE__1__7__1__1__1__1__index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        if((0x80 & zywrle_level) == 0 && zywrle_level >= 1)
        {
          zywrleAnalyze32LE(data, data, w, h, w, zywrle_level, zywrleBuf);
          zrleEncodeTile32LE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
        }

        else
          zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (32 / 8));
  }
}

// zrleEncodeTile8NE
// file ./zrleencodetemplate.c line 124
void zrleEncodeTile8NE(unsigned char *data, signed int w, signed int h, struct anonymous_11 *os, signed int zywrle_level, signed int *zywrleBuf, void *paletteHelper)
{
  struct anonymous_12 *ph;
  signed int runs = 0;
  signed int singlePixels = 0;
  signed char useRle;
  signed char usePalette;
  signed int estimatedBytes;
  signed int plainRleBytes;
  signed int i;
  unsigned char *zrleEncodeTile8NE__1__ptr = data;
  unsigned char *zrleEncodeTile8NE__1__end = zrleEncodeTile8NE__1__ptr + (signed long int)(h * w);
  *zrleEncodeTile8NE__1__end = (unsigned char)~((signed int)*(zrleEncodeTile8NE__1__end - (signed long int)1));
  ph = (struct anonymous_12 *)paletteHelper;
  zrlePaletteHelperInit(ph);
  while(!(zrleEncodeTile8NE__1__ptr >= zrleEncodeTile8NE__1__end))
  {
    unsigned char zrleEncodeTile8NE__1__1__pix = *zrleEncodeTile8NE__1__ptr;
    zrleEncodeTile8NE__1__ptr = zrleEncodeTile8NE__1__ptr + 1l;
    if(!(*zrleEncodeTile8NE__1__ptr == zrleEncodeTile8NE__1__1__pix))
      singlePixels = singlePixels + 1;

    else
    {
      do
      {
        zrleEncodeTile8NE__1__ptr = zrleEncodeTile8NE__1__ptr + 1l;
        if(!(*zrleEncodeTile8NE__1__ptr == zrleEncodeTile8NE__1__1__pix))
          break;

      }
      while((_Bool)1);
      runs = runs + 1;
    }
    zrlePaletteHelperInsert(ph, (unsigned int)zrleEncodeTile8NE__1__1__pix);
  }
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  if(ph->size == 1)
  {
    zrleOutStreamWriteU8(os, (unsigned char)1);
    zrleOutStreamWriteOpaque8(os, (unsigned char)ph->palette[(signed long int)0]);
  }

  else
  {
    useRle = (signed char)0;
    usePalette = (signed char)0;
    estimatedBytes = w * h * (8 / 8);
    plainRleBytes = (8 / 8 + 1) * (runs + singlePixels);
    if(!(plainRleBytes >= estimatedBytes))
    {
      useRle = (signed char)-1;
      estimatedBytes = plainRleBytes;
    }

    if(!(ph->size >= 128))
    {
      signed int paletteRleBytes = (8 / 8) * ph->size + 2 * runs + singlePixels;
      if(!(paletteRleBytes >= estimatedBytes))
      {
        useRle = (signed char)-1;
        usePalette = (signed char)-1;
        estimatedBytes = paletteRleBytes;
      }

      if(!(ph->size >= 17))
      {
        signed int packedBytes = (8 / 8) * ph->size + (w * h * bitsPerPackedPixel[(signed long int)(ph->size - 1)]) / 8;
        if(!(packedBytes >= estimatedBytes))
        {
          useRle = (signed char)0;
          usePalette = (signed char)-1;
          estimatedBytes = packedBytes;
        }

      }

    }

    if(usePalette == 0)
      ph->size = 0;

    zrleOutStreamWriteU8(os, (unsigned char)((useRle != 0 ? 128 : 0) | ph->size));
    i = 0;
    for( ; !(i >= ph->size); i = i + 1)
      zrleOutStreamWriteOpaque8(os, (unsigned char)ph->palette[(signed long int)i]);
    if(!(useRle == 0))
    {
      unsigned char *ptr = data;
      unsigned char *end = ptr + (signed long int)(w * h);
      unsigned char *runStart;
      unsigned char zrleEncodeTile8NE__1__6__pix;
      while(!(ptr >= end))
      {
        signed int len;
        runStart = ptr;
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        zrleEncodeTile8NE__1__6__pix = *tmp_post_1;
        for( ; *ptr == zrleEncodeTile8NE__1__6__pix; ptr = ptr + 1l)
          if(ptr >= end)
            break;

        len = (signed int)(ptr - runStart);
        if(!(usePalette == 0) && !(len >= 3))
        {
          signed int zrleEncodeTile8NE__1__6__1__1__index;
          zrleEncodeTile8NE__1__6__1__1__index=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile8NE__1__6__pix);
          if(len == 2)
            zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile8NE__1__6__1__1__index);

          zrleOutStreamWriteU8(os, (unsigned char)zrleEncodeTile8NE__1__6__1__1__index);
          continue;
        }

        if(!(usePalette == 0))
        {
          signed int zrleEncodeTile8NE__1__6__1__2__index;
          zrleEncodeTile8NE__1__6__1__2__index=zrlePaletteHelperLookup(ph, (unsigned int)zrleEncodeTile8NE__1__6__pix);
          zrleOutStreamWriteU8(os, (unsigned char)(zrleEncodeTile8NE__1__6__1__2__index | 128));
        }

        else
          zrleOutStreamWriteOpaque8(os, zrleEncodeTile8NE__1__6__pix);
        len = len - 1;
        for( ; len >= 255; len = len - 255)
          zrleOutStreamWriteU8(os, (unsigned char)255);
        zrleOutStreamWriteU8(os, (unsigned char)len);
      }
    }

    else
      if(!(usePalette == 0))
      {
        signed int bppp;
        unsigned char *zrleEncodeTile8NE__1__7__1__ptr = data;
        /* assertion ph->size < 17 */
        assert(ph->size < 17);
        bppp = bitsPerPackedPixel[(signed long int)(ph->size - 1)];
        i = 0;
        for( ; !(i >= h); i = i + 1)
        {
          unsigned char nbits = (unsigned char)0;
          unsigned char byte = (unsigned char)0;
          unsigned char *eol = zrleEncodeTile8NE__1__7__1__ptr + (signed long int)w;
          while(!(zrleEncodeTile8NE__1__7__1__ptr >= eol))
          {
            unsigned char pix;
            tmp_post_2 = zrleEncodeTile8NE__1__7__1__ptr;
            zrleEncodeTile8NE__1__7__1__ptr = zrleEncodeTile8NE__1__7__1__ptr + 1l;
            pix = *tmp_post_2;
            unsigned char index;
            signed int return_value_zrlePaletteHelperLookup_3;
            return_value_zrlePaletteHelperLookup_3=zrlePaletteHelperLookup(ph, (unsigned int)pix);
            index = (unsigned char)return_value_zrlePaletteHelperLookup_3;
            byte = (unsigned char)((signed int)byte << bppp | (signed int)index);
            nbits = nbits + (unsigned char)bppp;
            if((signed int)nbits >= 8)
            {
              zrleOutStreamWriteU8(os, byte);
              nbits = (unsigned char)0;
            }

          }
          if((signed int)nbits >= 1)
          {
            byte = byte << 8 - (signed int)nbits;
            zrleOutStreamWriteU8(os, byte);
          }

        }
      }

      else
        zrleOutStreamWriteBytes(os, (unsigned char *)data, w * h * (8 / 8));
  }
}

// zrleOutStreamCheck
// file zrleoutstream.c line 212
static signed int zrleOutStreamCheck(struct anonymous_11 *os, signed int size)
{
  if(!(os->in.end >= os->in.ptr + (signed long int)size))
  {
    signed int return_value_zrleOutStreamOverrun_1;
    return_value_zrleOutStreamOverrun_1=zrleOutStreamOverrun(os, size);
    return return_value_zrleOutStreamOverrun_1;
  }

  return size;
}

// zrleOutStreamFlush
// file zrleoutstream.h line 45
signed char zrleOutStreamFlush(struct anonymous_11 *os)
{
  os->zs.next_in = os->in.start;
  os->zs.avail_in = (unsigned int)((&os->in)->ptr - (&os->in)->start);
  signed char return_value_zrleBufferGrow_1;
  while(!(os->zs.avail_in == 0u))
    do
    {
      signed int ret;
      if(os->out.ptr >= os->out.end)
      {
        return_value_zrleBufferGrow_1=zrleBufferGrow(&os->out, (signed int)(os->out.end - os->out.start));
        if(return_value_zrleBufferGrow_1 == 0)
        {
          rfbLog("zrleOutStreamFlush: failed to grow output buffer\n");
          return (signed char)0;
        }

      }

      os->zs.next_out = os->out.ptr;
      os->zs.avail_out = (unsigned int)(os->out.end - os->out.ptr);
      ret=deflate(&os->zs, 2);
      if(!(ret == 0))
      {
        rfbLog("zrleOutStreamFlush: deflate failed with error code %d\n", ret);
        return (signed char)0;
      }

      os->out.ptr = os->zs.next_out;
    }
    while(os->zs.avail_out == 0u);
  os->in.ptr = os->in.start;
  return (signed char)-1;
}

// zrleOutStreamFree
// file zrleoutstream.h line 44
void zrleOutStreamFree(struct anonymous_11 *os)
{
  deflateEnd(&os->zs);
  zrleBufferFree(&os->in);
  zrleBufferFree(&os->out);
  free((void *)os);
}

// zrleOutStreamNew
// file zrleoutstream.h line 43
struct anonymous_11 * zrleOutStreamNew(void)
{
  struct anonymous_11 *os;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct anonymous_11) /*160ul*/ );
  os = (struct anonymous_11 *)return_value_malloc_1;
  if(os == ((struct anonymous_11 *)NULL))
    return (struct anonymous_11 *)(void *)0;

  else
  {
    signed char return_value_zrleBufferAlloc_2;
    return_value_zrleBufferAlloc_2=zrleBufferAlloc(&os->in, 16384);
    if(return_value_zrleBufferAlloc_2 == 0)
    {
      free((void *)os);
      return (struct anonymous_11 *)(void *)0;
    }

    else
    {
      signed char return_value_zrleBufferAlloc_3;
      return_value_zrleBufferAlloc_3=zrleBufferAlloc(&os->out, 1024);
      if(return_value_zrleBufferAlloc_3 == 0)
      {
        zrleBufferFree(&os->in);
        free((void *)os);
        return (struct anonymous_11 *)(void *)0;
      }

      else
      {
        os->zs.zalloc = ((void * (*)(void *, unsigned int, unsigned int))NULL);
        os->zs.zfree = ((void (*)(void *, void *))NULL);
        os->zs.opaque = NULL;
        signed int return_value_deflateInit__4;
        return_value_deflateInit__4=deflateInit_(&os->zs, -1, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
        if(!(return_value_deflateInit__4 == 0))
        {
          zrleBufferFree(&os->in);
          free((void *)os);
          return (struct anonymous_11 *)(void *)0;
        }

        else
          return os;
      }
    }
  }
}

// zrleOutStreamOverrun
// file zrleoutstream.c line 151
static signed int zrleOutStreamOverrun(struct anonymous_11 *os, signed int size)
{
  signed char return_value_zrleBufferGrow_1;
  while(!(os->in.end - os->in.ptr >= (signed long int)size))
  {
    if(os->in.start >= os->in.ptr)
      break;

    os->zs.next_in = os->in.start;
    os->zs.avail_in = (unsigned int)((&os->in)->ptr - (&os->in)->start);
    do
    {
      signed int ret;
      if(os->out.ptr >= os->out.end)
      {
        return_value_zrleBufferGrow_1=zrleBufferGrow(&os->out, (signed int)(os->out.end - os->out.start));
        if(return_value_zrleBufferGrow_1 == 0)
        {
          rfbLog("zrleOutStreamOverrun: failed to grow output buffer\n");
          return 0;
        }

      }

      os->zs.next_out = os->out.ptr;
      os->zs.avail_out = (unsigned int)(os->out.end - os->out.ptr);
      ret=deflate(&os->zs, 0);
      if(!(ret == 0))
      {
        rfbLog("zrleOutStreamOverrun: deflate failed with error code %d\n", ret);
        return 0;
      }

      os->out.ptr = os->zs.next_out;
    }
    while(os->zs.avail_out == 0u);
    if(os->zs.avail_in == 0u)
      os->in.ptr = os->in.start;

    else
    {
      rfbLog("zrleOutStreamOverrun: out buf not full, but in data not consumed\n");
      memmove((void *)os->in.start, (const void *)os->zs.next_in, (unsigned long int)(os->in.ptr - os->zs.next_in));
      os->in.ptr = os->in.ptr - (os->zs.next_in - os->in.start);
    }
  }
  if(!(os->in.end - os->in.ptr >= (signed long int)size))
    size = (signed int)(os->in.end - os->in.ptr);

  return size;
}

// zrleOutStreamWriteBytes
// file zrleoutstream.h line 46
void zrleOutStreamWriteBytes(struct anonymous_11 *os, const unsigned char *data, signed int length)
{
  const unsigned char *dataEnd = data + (signed long int)length;
  while(!(data >= dataEnd))
  {
    signed int n;
    n=zrleOutStreamCheck(os, (signed int)(dataEnd - data));
    memcpy((void *)os->in.ptr, (const void *)data, (unsigned long int)n);
    os->in.ptr = os->in.ptr + (signed long int)n;
    data = data + (signed long int)n;
  }
}

// zrleOutStreamWriteOpaque16
// file zrleoutstream.h line 53
void zrleOutStreamWriteOpaque16(struct anonymous_11 *os, unsigned short int u)
{
  zrleOutStreamCheck(os, 2);
  unsigned char *tmp_post_1 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_1 = ((unsigned char *)&u)[(signed long int)0];
  unsigned char *tmp_post_2 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_2 = ((unsigned char *)&u)[(signed long int)1];
}

// zrleOutStreamWriteOpaque24A
// file zrleoutstream.h line 57
void zrleOutStreamWriteOpaque24A(struct anonymous_11 *os, unsigned int u)
{
  zrleOutStreamCheck(os, 3);
  unsigned char *tmp_post_1 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_1 = ((unsigned char *)&u)[(signed long int)0];
  unsigned char *tmp_post_2 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_2 = ((unsigned char *)&u)[(signed long int)1];
  unsigned char *tmp_post_3 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_3 = ((unsigned char *)&u)[(signed long int)2];
}

// zrleOutStreamWriteOpaque24B
// file zrleoutstream.h line 59
void zrleOutStreamWriteOpaque24B(struct anonymous_11 *os, unsigned int u)
{
  zrleOutStreamCheck(os, 3);
  unsigned char *tmp_post_1 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_1 = ((unsigned char *)&u)[(signed long int)1];
  unsigned char *tmp_post_2 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_2 = ((unsigned char *)&u)[(signed long int)2];
  unsigned char *tmp_post_3 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_3 = ((unsigned char *)&u)[(signed long int)3];
}

// zrleOutStreamWriteOpaque32
// file zrleoutstream.h line 55
void zrleOutStreamWriteOpaque32(struct anonymous_11 *os, unsigned int u)
{
  zrleOutStreamCheck(os, 4);
  unsigned char *tmp_post_1 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_1 = ((unsigned char *)&u)[(signed long int)0];
  unsigned char *tmp_post_2 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_2 = ((unsigned char *)&u)[(signed long int)1];
  unsigned char *tmp_post_3 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_3 = ((unsigned char *)&u)[(signed long int)2];
  unsigned char *tmp_post_4 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_4 = ((unsigned char *)&u)[(signed long int)3];
}

// zrleOutStreamWriteOpaque8
// file zrleoutstream.h line 51
void zrleOutStreamWriteOpaque8(struct anonymous_11 *os, unsigned char u)
{
  zrleOutStreamCheck(os, 1);
  unsigned char *tmp_post_1 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_1 = u;
}

// zrleOutStreamWriteU8
// file zrleoutstream.h line 49
void zrleOutStreamWriteU8(struct anonymous_11 *os, unsigned char u)
{
  zrleOutStreamCheck(os, 1);
  unsigned char *tmp_post_1 = os->in.ptr;
  os->in.ptr = os->in.ptr + 1l;
  *tmp_post_1 = u;
}

// zrlePaletteHelperInit
// file ./zrlepalettehelper.h line 40
void zrlePaletteHelperInit(struct anonymous_12 *helper)
{
  memset((void *)helper->palette, 0, sizeof(unsigned int [127l]) /*508ul*/ );
  memset((void *)helper->index, 255, sizeof(unsigned char [4223l]) /*4223ul*/ );
  memset((void *)helper->key, 0, sizeof(unsigned int [4223l]) /*16892ul*/ );
  helper->size = 0;
}

// zrlePaletteHelperInsert
// file ./zrlepalettehelper.h line 41
void zrlePaletteHelperInsert(struct anonymous_12 *helper, unsigned int pix)
{
  if(!(helper->size >= 127))
  {
    signed int i = (signed int)((pix ^ pix >> 17) & (unsigned int)4095);
    for( ; !((signed int)helper->index[(signed long int)i] == 255); i = i + 1)
      if(helper->key[(signed long int)i] == pix)
        break;

    if(!((signed int)helper->index[(signed long int)i] == 255))
      goto __CPROVER_DUMP_L5;

    helper->index[(signed long int)i] = (unsigned char)helper->size;
    helper->key[(signed long int)i] = pix;
    helper->palette[(signed long int)helper->size] = pix;
  }

  helper->size = helper->size + 1;

__CPROVER_DUMP_L5:
  ;
}

// zrlePaletteHelperLookup
// file ./zrlepalettehelper.h line 43
signed int zrlePaletteHelperLookup(struct anonymous_12 *helper, unsigned int pix)
{
  signed int i = (signed int)((pix ^ pix >> 17) & (unsigned int)4095);
  /* assertion helper->size <= 127 */
  assert(helper->size <= 127);
  for( ; !((signed int)helper->index[(signed long int)i] == 255); i = i + 1)
    if(helper->key[(signed long int)i] == pix)
      break;

  if(!((signed int)helper->index[(signed long int)i] == 255))
    return (signed int)helper->index[(signed long int)i];

  else
    return -1;
}

// zywrleAnalyze15BE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze15BE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf)
{
  signed int l;
  signed int uw = w;
  signed int uh = h;
  signed int *pTop;
  signed int *pEnd;
  signed int *pLine;
  unsigned short int *pData;
  signed int R;
  signed int G;
  signed int B;
  signed int s;
  signed int *pH;
  zywrleCalcSize(&w, &h, level);
  if(h == 0 || w == 0)
    return (unsigned short int *)(void *)0;

  else
  {
    uw = uw - w;
    uh = uh - h;
    pData = dst;
    pTop = pBuf + (signed long int)(w * h);
    if(!(uw == 0))
    {
      pData = src + (signed long int)w;
      pEnd = (signed int *)(pData + (signed long int)(h * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0))
    {
      pData = src + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - w))
      {
        pLine = (signed int *)(pData + (signed long int)w);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0) && !(uw == 0))
    {
      pData = src + (signed long int)w + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    zywrleRGBYUV15BE(pBuf, src, w, h, scanline);
    Wavelet(pBuf, w, h, level);
    l = 0;
    for( ; !(l >= level); l = l + 1)
    {
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xF8;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R >> 1 | G >> 6);
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xF8;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R >> 1 | G >> 6);
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xF8;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R >> 1 | G >> 6);
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      if(l == level + -1)
      {
        pH = pBuf;
        s = 2 << l;
        pEnd = pH + (signed long int)(h * w);
        for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
        {
          pLine = pH + (signed long int)w;
          for( ; !(pH >= pLine); pH = pH + (signed long int)s)
          {
            R = (signed int)((signed char *)pH)[(signed long int)2];
            G = (signed int)((signed char *)pH)[(signed long int)1];
            B = (signed int)((signed char *)pH)[(signed long int)0];
            R = R & 0xF8;
            G = G & 0xF8;
            B = B & 0xF8;
            ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R >> 1 | G >> 6);
            ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
            dst = dst + 1l;
            if(dst - pData >= (signed long int)(uw + w))
            {
              dst = dst + (signed long int)(scanline - (w + uw));
              pData = dst;
            }

          }
        }
      }

    }
    pTop = pBuf + (signed long int)(w * h);
    pEnd = pBuf + (signed long int)((w + uw) * (h + uh));
    for( ; !(pTop >= pEnd); pTop = pTop + 1l)
    {
      *dst = *((unsigned short int *)pTop);
      dst = dst + 1l;
      if(dst - pData >= (signed long int)(uw + w))
      {
        dst = dst + (signed long int)(scanline - (w + uw));
        pData = dst;
      }

    }
    return dst;
  }
}

// zywrleAnalyze15LE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze15LE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf)
{
  signed int l;
  signed int uw = w;
  signed int uh = h;
  signed int *pTop;
  signed int *pEnd;
  signed int *pLine;
  unsigned short int *pData;
  signed int R;
  signed int G;
  signed int B;
  signed int s;
  signed int *pH;
  zywrleCalcSize(&w, &h, level);
  if(h == 0 || w == 0)
    return (unsigned short int *)(void *)0;

  else
  {
    uw = uw - w;
    uh = uh - h;
    pData = dst;
    pTop = pBuf + (signed long int)(w * h);
    if(!(uw == 0))
    {
      pData = src + (signed long int)w;
      pEnd = (signed int *)(pData + (signed long int)(h * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0))
    {
      pData = src + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - w))
      {
        pLine = (signed int *)(pData + (signed long int)w);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0) && !(uw == 0))
    {
      pData = src + (signed long int)w + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    zywrleRGBYUV15LE(pBuf, src, w, h, scanline);
    Wavelet(pBuf, w, h, level);
    l = 0;
    for( ; !(l >= level); l = l + 1)
    {
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xF8;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R >> 1 | G >> 6);
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xF8;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R >> 1 | G >> 6);
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xF8;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R >> 1 | G >> 6);
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      if(l == level + -1)
      {
        pH = pBuf;
        s = 2 << l;
        pEnd = pH + (signed long int)(h * w);
        for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
        {
          pLine = pH + (signed long int)w;
          for( ; !(pH >= pLine); pH = pH + (signed long int)s)
          {
            R = (signed int)((signed char *)pH)[(signed long int)2];
            G = (signed int)((signed char *)pH)[(signed long int)1];
            B = (signed int)((signed char *)pH)[(signed long int)0];
            R = R & 0xF8;
            G = G & 0xF8;
            B = B & 0xF8;
            ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R >> 1 | G >> 6);
            ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 2) & 0xFF);
            dst = dst + 1l;
            if(dst - pData >= (signed long int)(uw + w))
            {
              dst = dst + (signed long int)(scanline - (w + uw));
              pData = dst;
            }

          }
        }
      }

    }
    pTop = pBuf + (signed long int)(w * h);
    pEnd = pBuf + (signed long int)((w + uw) * (h + uh));
    for( ; !(pTop >= pEnd); pTop = pTop + 1l)
    {
      *dst = *((unsigned short int *)pTop);
      dst = dst + 1l;
      if(dst - pData >= (signed long int)(uw + w))
      {
        dst = dst + (signed long int)(scanline - (w + uw));
        pData = dst;
      }

    }
    return dst;
  }
}

// zywrleAnalyze16BE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze16BE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf)
{
  signed int l;
  signed int uw = w;
  signed int uh = h;
  signed int *pTop;
  signed int *pEnd;
  signed int *pLine;
  unsigned short int *pData;
  signed int R;
  signed int G;
  signed int B;
  signed int s;
  signed int *pH;
  zywrleCalcSize(&w, &h, level);
  if(h == 0 || w == 0)
    return (unsigned short int *)(void *)0;

  else
  {
    uw = uw - w;
    uh = uh - h;
    pData = dst;
    pTop = pBuf + (signed long int)(w * h);
    if(!(uw == 0))
    {
      pData = src + (signed long int)w;
      pEnd = (signed int *)(pData + (signed long int)(h * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0))
    {
      pData = src + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - w))
      {
        pLine = (signed int *)(pData + (signed long int)w);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0) && !(uw == 0))
    {
      pData = src + (signed long int)w + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    zywrleRGBYUV16BE(pBuf, src, w, h, scanline);
    Wavelet(pBuf, w, h, level);
    l = 0;
    for( ; !(l >= level); l = l + 1)
    {
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xFC;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R | G >> 5);
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xFC;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R | G >> 5);
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xFC;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R | G >> 5);
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      if(l == level + -1)
      {
        pH = pBuf;
        s = 2 << l;
        pEnd = pH + (signed long int)(h * w);
        for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
        {
          pLine = pH + (signed long int)w;
          for( ; !(pH >= pLine); pH = pH + (signed long int)s)
          {
            R = (signed int)((signed char *)pH)[(signed long int)2];
            G = (signed int)((signed char *)pH)[(signed long int)1];
            B = (signed int)((signed char *)pH)[(signed long int)0];
            R = R & 0xF8;
            G = G & 0xFC;
            B = B & 0xF8;
            ((unsigned char *)dst)[(signed long int)0] = (unsigned char)(R | G >> 5);
            ((unsigned char *)dst)[(signed long int)1] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
            dst = dst + 1l;
            if(dst - pData >= (signed long int)(uw + w))
            {
              dst = dst + (signed long int)(scanline - (w + uw));
              pData = dst;
            }

          }
        }
      }

    }
    pTop = pBuf + (signed long int)(w * h);
    pEnd = pBuf + (signed long int)((w + uw) * (h + uh));
    for( ; !(pTop >= pEnd); pTop = pTop + 1l)
    {
      *dst = *((unsigned short int *)pTop);
      dst = dst + 1l;
      if(dst - pData >= (signed long int)(uw + w))
      {
        dst = dst + (signed long int)(scanline - (w + uw));
        pData = dst;
      }

    }
    return dst;
  }
}

// zywrleAnalyze16LE
// file ../common/zywrletemplate.c line 753
unsigned short int * zywrleAnalyze16LE(unsigned short int *dst, unsigned short int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf)
{
  signed int l;
  signed int uw = w;
  signed int uh = h;
  signed int *pTop;
  signed int *pEnd;
  signed int *pLine;
  unsigned short int *pData;
  signed int R;
  signed int G;
  signed int B;
  signed int s;
  signed int *pH;
  zywrleCalcSize(&w, &h, level);
  if(h == 0 || w == 0)
    return (unsigned short int *)(void *)0;

  else
  {
    uw = uw - w;
    uh = uh - h;
    pData = dst;
    pTop = pBuf + (signed long int)(w * h);
    if(!(uw == 0))
    {
      pData = src + (signed long int)w;
      pEnd = (signed int *)(pData + (signed long int)(h * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0))
    {
      pData = src + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - w))
      {
        pLine = (signed int *)(pData + (signed long int)w);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0) && !(uw == 0))
    {
      pData = src + (signed long int)w + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned short int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned short int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned short int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    zywrleRGBYUV16LE(pBuf, src, w, h, scanline);
    Wavelet(pBuf, w, h, level);
    l = 0;
    for( ; !(l >= level); l = l + 1)
    {
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xFC;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R | G >> 5);
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xFC;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R | G >> 5);
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          R = R & 0xF8;
          G = G & 0xFC;
          B = B & 0xF8;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R | G >> 5);
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      if(l == level + -1)
      {
        pH = pBuf;
        s = 2 << l;
        pEnd = pH + (signed long int)(h * w);
        for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
        {
          pLine = pH + (signed long int)w;
          for( ; !(pH >= pLine); pH = pH + (signed long int)s)
          {
            R = (signed int)((signed char *)pH)[(signed long int)2];
            G = (signed int)((signed char *)pH)[(signed long int)1];
            B = (signed int)((signed char *)pH)[(signed long int)0];
            R = R & 0xF8;
            G = G & 0xFC;
            B = B & 0xF8;
            ((unsigned char *)dst)[(signed long int)1] = (unsigned char)(R | G >> 5);
            ((unsigned char *)dst)[(signed long int)0] = (unsigned char)((B >> 3 | G << 3) & 0xFF);
            dst = dst + 1l;
            if(dst - pData >= (signed long int)(uw + w))
            {
              dst = dst + (signed long int)(scanline - (w + uw));
              pData = dst;
            }

          }
        }
      }

    }
    pTop = pBuf + (signed long int)(w * h);
    pEnd = pBuf + (signed long int)((w + uw) * (h + uh));
    for( ; !(pTop >= pEnd); pTop = pTop + 1l)
    {
      *dst = *((unsigned short int *)pTop);
      dst = dst + 1l;
      if(dst - pData >= (signed long int)(uw + w))
      {
        dst = dst + (signed long int)(scanline - (w + uw));
        pData = dst;
      }

    }
    return dst;
  }
}

// zywrleAnalyze32BE
// file ../common/zywrletemplate.c line 753
unsigned int * zywrleAnalyze32BE(unsigned int *dst, unsigned int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf)
{
  signed int l;
  signed int uw = w;
  signed int uh = h;
  signed int *pTop;
  signed int *pEnd;
  signed int *pLine;
  unsigned int *pData;
  signed int R;
  signed int G;
  signed int B;
  signed int s;
  signed int *pH;
  zywrleCalcSize(&w, &h, level);
  if(h == 0 || w == 0)
    return (unsigned int *)(void *)0;

  else
  {
    uw = uw - w;
    uh = uh - h;
    pData = dst;
    pTop = pBuf + (signed long int)(w * h);
    if(!(uw == 0))
    {
      pData = src + (signed long int)w;
      pEnd = (signed int *)(pData + (signed long int)(h * scanline));
      for( ; !(pData >= (unsigned int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0))
    {
      pData = src + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned int *)pEnd); pData = pData + (signed long int)(scanline - w))
      {
        pLine = (signed int *)(pData + (signed long int)w);
        for( ; !(pData >= (unsigned int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0) && !(uw == 0))
    {
      pData = src + (signed long int)w + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    zywrleRGBYUV32BE(pBuf, src, w, h, scanline);
    Wavelet(pBuf, w, h, level);
    l = 0;
    for( ; !(l >= level); l = l + 1)
    {
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)R;
          ((unsigned char *)dst)[(signed long int)2] = (unsigned char)G;
          ((unsigned char *)dst)[(signed long int)3] = (unsigned char)B;
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)R;
          ((unsigned char *)dst)[(signed long int)2] = (unsigned char)G;
          ((unsigned char *)dst)[(signed long int)3] = (unsigned char)B;
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)R;
          ((unsigned char *)dst)[(signed long int)2] = (unsigned char)G;
          ((unsigned char *)dst)[(signed long int)3] = (unsigned char)B;
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      if(l == level + -1)
      {
        pH = pBuf;
        s = 2 << l;
        pEnd = pH + (signed long int)(h * w);
        for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
        {
          pLine = pH + (signed long int)w;
          for( ; !(pH >= pLine); pH = pH + (signed long int)s)
          {
            R = (signed int)((signed char *)pH)[(signed long int)2];
            G = (signed int)((signed char *)pH)[(signed long int)1];
            B = (signed int)((signed char *)pH)[(signed long int)0];
            ((unsigned char *)dst)[(signed long int)1] = (unsigned char)R;
            ((unsigned char *)dst)[(signed long int)2] = (unsigned char)G;
            ((unsigned char *)dst)[(signed long int)3] = (unsigned char)B;
            dst = dst + 1l;
            if(dst - pData >= (signed long int)(uw + w))
            {
              dst = dst + (signed long int)(scanline - (w + uw));
              pData = dst;
            }

          }
        }
      }

    }
    pTop = pBuf + (signed long int)(w * h);
    pEnd = pBuf + (signed long int)((w + uw) * (h + uh));
    for( ; !(pTop >= pEnd); pTop = pTop + 1l)
    {
      *dst = *((unsigned int *)pTop);
      dst = dst + 1l;
      if(dst - pData >= (signed long int)(uw + w))
      {
        dst = dst + (signed long int)(scanline - (w + uw));
        pData = dst;
      }

    }
    return dst;
  }
}

// zywrleAnalyze32LE
// file ../common/zywrletemplate.c line 753
unsigned int * zywrleAnalyze32LE(unsigned int *dst, unsigned int *src, signed int w, signed int h, signed int scanline, signed int level, signed int *pBuf)
{
  signed int l;
  signed int uw = w;
  signed int uh = h;
  signed int *pTop;
  signed int *pEnd;
  signed int *pLine;
  unsigned int *pData;
  signed int R;
  signed int G;
  signed int B;
  signed int s;
  signed int *pH;
  zywrleCalcSize(&w, &h, level);
  if(h == 0 || w == 0)
    return (unsigned int *)(void *)0;

  else
  {
    uw = uw - w;
    uh = uh - h;
    pData = dst;
    pTop = pBuf + (signed long int)(w * h);
    if(!(uw == 0))
    {
      pData = src + (signed long int)w;
      pEnd = (signed int *)(pData + (signed long int)(h * scanline));
      for( ; !(pData >= (unsigned int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0))
    {
      pData = src + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned int *)pEnd); pData = pData + (signed long int)(scanline - w))
      {
        pLine = (signed int *)(pData + (signed long int)w);
        for( ; !(pData >= (unsigned int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    if(!(uh == 0) && !(uw == 0))
    {
      pData = src + (signed long int)w + (signed long int)(h * scanline);
      pEnd = (signed int *)(pData + (signed long int)(uh * scanline));
      for( ; !(pData >= (unsigned int *)pEnd); pData = pData + (signed long int)(scanline - uw))
      {
        pLine = (signed int *)(pData + (signed long int)uw);
        for( ; !(pData >= (unsigned int *)pLine); pTop = pTop + 1l)
        {
          *((unsigned int *)pTop) = *pData;
          pData = pData + 1l;
        }
      }
    }

    zywrleRGBYUV32LE(pBuf, src, w, h, scanline);
    Wavelet(pBuf, w, h, level);
    l = 0;
    for( ; !(l >= level); l = l + 1)
    {
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          ((unsigned char *)dst)[(signed long int)2] = (unsigned char)R;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)G;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)B;
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)((s >> 1) * w);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          ((unsigned char *)dst)[(signed long int)2] = (unsigned char)R;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)G;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)B;
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      pH = pBuf;
      s = 2 << l;
      pH = pH + (signed long int)(s >> 1);
      pEnd = pH + (signed long int)(h * w);
      for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
      {
        pLine = pH + (signed long int)w;
        for( ; !(pH >= pLine); pH = pH + (signed long int)s)
        {
          R = (signed int)((signed char *)pH)[(signed long int)2];
          G = (signed int)((signed char *)pH)[(signed long int)1];
          B = (signed int)((signed char *)pH)[(signed long int)0];
          ((unsigned char *)dst)[(signed long int)2] = (unsigned char)R;
          ((unsigned char *)dst)[(signed long int)1] = (unsigned char)G;
          ((unsigned char *)dst)[(signed long int)0] = (unsigned char)B;
          dst = dst + 1l;
          if(dst - pData >= (signed long int)(uw + w))
          {
            dst = dst + (signed long int)(scanline - (w + uw));
            pData = dst;
          }

        }
      }
      if(l == level + -1)
      {
        pH = pBuf;
        s = 2 << l;
        pEnd = pH + (signed long int)(h * w);
        for( ; !(pH >= pEnd); pH = pH + (signed long int)((s - 1) * w))
        {
          pLine = pH + (signed long int)w;
          for( ; !(pH >= pLine); pH = pH + (signed long int)s)
          {
            R = (signed int)((signed char *)pH)[(signed long int)2];
            G = (signed int)((signed char *)pH)[(signed long int)1];
            B = (signed int)((signed char *)pH)[(signed long int)0];
            ((unsigned char *)dst)[(signed long int)2] = (unsigned char)R;
            ((unsigned char *)dst)[(signed long int)1] = (unsigned char)G;
            ((unsigned char *)dst)[(signed long int)0] = (unsigned char)B;
            dst = dst + 1l;
            if(dst - pData >= (signed long int)(uw + w))
            {
              dst = dst + (signed long int)(scanline - (w + uw));
              pData = dst;
            }

          }
        }
      }

    }
    pTop = pBuf + (signed long int)(w * h);
    pEnd = pBuf + (signed long int)((w + uw) * (h + uh));
    for( ; !(pTop >= pEnd); pTop = pTop + 1l)
    {
      *dst = *((unsigned int *)pTop);
      dst = dst + 1l;
      if(dst - pData >= (signed long int)(uw + w))
      {
        dst = dst + (signed long int)(scanline - (w + uw));
        pData = dst;
      }

    }
    return dst;
  }
}

// zywrleCalcSize
// file ../common/zywrletemplate.c line 701
static inline void zywrleCalcSize(signed int *pW, signed int *pH, signed int level)
{
  *pW = *pW & ~((1 << level) - 1);
  *pH = *pH & ~((1 << level) - 1);
}

// zywrleRGBYUV15BE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV15BE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline)
{
  signed int R;
  signed int G;
  signed int B;
  signed int Y;
  signed int U;
  signed int V;
  signed int *pLine;
  signed int *pEnd = pBuf + (signed long int)(height * width);
  for( ; !(pBuf >= pEnd); data = data + (signed long int)(scanline - width))
  {
    pLine = pBuf + (signed long int)width;
    for( ; !(pBuf >= pLine); data = data + 1l)
    {
      R = (signed int)((unsigned char *)data)[(signed long int)0] << 1 & 0xF8;
      G = ((signed int)((unsigned char *)data)[(signed long int)0] << 6 | (signed int)((unsigned char *)data)[(signed long int)1] >> 2) & 0xF8;
      B = (signed int)((unsigned char *)data)[(signed long int)1] << 3 & 0xF8;
      Y = R + (G << 1) + B >> 2;
      U = B - G;
      V = R - G;
      Y = Y - 128;
      U = U >> 1;
      V = V >> 1;
      Y = Y & (signed int)0xFFFFFFF8;
      U = U & (signed int)0xFFFFFFF8;
      V = V & (signed int)0xFFFFFFF8;
      if(Y == -128)
        Y = Y + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      if(U == -128)
        U = U + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      if(V == -128)
        V = V + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      ((signed char *)pBuf)[(signed long int)2] = (signed char)V;
      ((signed char *)pBuf)[(signed long int)1] = (signed char)Y;
      ((signed char *)pBuf)[(signed long int)0] = (signed char)U;
      pBuf = pBuf + 1l;
    }
  }
}

// zywrleRGBYUV15LE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV15LE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline)
{
  signed int R;
  signed int G;
  signed int B;
  signed int Y;
  signed int U;
  signed int V;
  signed int *pLine;
  signed int *pEnd = pBuf + (signed long int)(height * width);
  for( ; !(pBuf >= pEnd); data = data + (signed long int)(scanline - width))
  {
    pLine = pBuf + (signed long int)width;
    for( ; !(pBuf >= pLine); data = data + 1l)
    {
      R = (signed int)((unsigned char *)data)[(signed long int)1] << 1 & 0xF8;
      G = ((signed int)((unsigned char *)data)[(signed long int)1] << 6 | (signed int)((unsigned char *)data)[(signed long int)0] >> 2) & 0xF8;
      B = (signed int)((unsigned char *)data)[(signed long int)0] << 3 & 0xF8;
      Y = R + (G << 1) + B >> 2;
      U = B - G;
      V = R - G;
      Y = Y - 128;
      U = U >> 1;
      V = V >> 1;
      Y = Y & (signed int)0xFFFFFFF8;
      U = U & (signed int)0xFFFFFFF8;
      V = V & (signed int)0xFFFFFFF8;
      if(Y == -128)
        Y = Y + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      if(U == -128)
        U = U + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      if(V == -128)
        V = V + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      ((signed char *)pBuf)[(signed long int)2] = (signed char)V;
      ((signed char *)pBuf)[(signed long int)1] = (signed char)Y;
      ((signed char *)pBuf)[(signed long int)0] = (signed char)U;
      pBuf = pBuf + 1l;
    }
  }
}

// zywrleRGBYUV16BE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV16BE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline)
{
  signed int R;
  signed int G;
  signed int B;
  signed int Y;
  signed int U;
  signed int V;
  signed int *pLine;
  signed int *pEnd = pBuf + (signed long int)(height * width);
  for( ; !(pBuf >= pEnd); data = data + (signed long int)(scanline - width))
  {
    pLine = pBuf + (signed long int)width;
    for( ; !(pBuf >= pLine); data = data + 1l)
    {
      R = (signed int)((unsigned char *)data)[(signed long int)0] & 0xF8;
      G = ((signed int)((unsigned char *)data)[(signed long int)0] << 5 | (signed int)((unsigned char *)data)[(signed long int)1] >> 3) & 0xFC;
      B = (signed int)((unsigned char *)data)[(signed long int)1] << 3 & 0xF8;
      Y = R + (G << 1) + B >> 2;
      U = B - G;
      V = R - G;
      Y = Y - 128;
      U = U >> 1;
      V = V >> 1;
      Y = Y & (signed int)0xFFFFFFFC;
      U = U & (signed int)0xFFFFFFF8;
      V = V & (signed int)0xFFFFFFF8;
      if(Y == -128)
        Y = Y + (signed int)((0xFFFFFFFF - 0xFFFFFFFC) + (unsigned int)1);

      if(U == -128)
        U = U + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      if(V == -128)
        V = V + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      ((signed char *)pBuf)[(signed long int)2] = (signed char)V;
      ((signed char *)pBuf)[(signed long int)1] = (signed char)Y;
      ((signed char *)pBuf)[(signed long int)0] = (signed char)U;
      pBuf = pBuf + 1l;
    }
  }
}

// zywrleRGBYUV16LE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV16LE(signed int *pBuf, unsigned short int *data, signed int width, signed int height, signed int scanline)
{
  signed int R;
  signed int G;
  signed int B;
  signed int Y;
  signed int U;
  signed int V;
  signed int *pLine;
  signed int *pEnd = pBuf + (signed long int)(height * width);
  for( ; !(pBuf >= pEnd); data = data + (signed long int)(scanline - width))
  {
    pLine = pBuf + (signed long int)width;
    for( ; !(pBuf >= pLine); data = data + 1l)
    {
      R = (signed int)((unsigned char *)data)[(signed long int)1] & 0xF8;
      G = ((signed int)((unsigned char *)data)[(signed long int)1] << 5 | (signed int)((unsigned char *)data)[(signed long int)0] >> 3) & 0xFC;
      B = (signed int)((unsigned char *)data)[(signed long int)0] << 3 & 0xF8;
      Y = R + (G << 1) + B >> 2;
      U = B - G;
      V = R - G;
      Y = Y - 128;
      U = U >> 1;
      V = V >> 1;
      Y = Y & (signed int)0xFFFFFFFC;
      U = U & (signed int)0xFFFFFFF8;
      V = V & (signed int)0xFFFFFFF8;
      if(Y == -128)
        Y = Y + (signed int)((0xFFFFFFFF - 0xFFFFFFFC) + (unsigned int)1);

      if(U == -128)
        U = U + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      if(V == -128)
        V = V + (signed int)((0xFFFFFFFF - 0xFFFFFFF8) + (unsigned int)1);

      ((signed char *)pBuf)[(signed long int)2] = (signed char)V;
      ((signed char *)pBuf)[(signed long int)1] = (signed char)Y;
      ((signed char *)pBuf)[(signed long int)0] = (signed char)U;
      pBuf = pBuf + 1l;
    }
  }
}

// zywrleRGBYUV32BE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV32BE(signed int *pBuf, unsigned int *data, signed int width, signed int height, signed int scanline)
{
  signed int R;
  signed int G;
  signed int B;
  signed int Y;
  signed int U;
  signed int V;
  signed int *pLine;
  signed int *pEnd = pBuf + (signed long int)(height * width);
  for( ; !(pBuf >= pEnd); data = data + (signed long int)(scanline - width))
  {
    pLine = pBuf + (signed long int)width;
    for( ; !(pBuf >= pLine); data = data + 1l)
    {
      R = (signed int)((unsigned char *)data)[(signed long int)1];
      G = (signed int)((unsigned char *)data)[(signed long int)2];
      B = (signed int)((unsigned char *)data)[(signed long int)3];
      Y = R + (G << 1) + B >> 2;
      U = B - G;
      V = R - G;
      Y = Y - 128;
      U = U >> 1;
      V = V >> 1;
      Y = Y & (signed int)0xFFFFFFFF;
      U = U & (signed int)0xFFFFFFFF;
      V = V & (signed int)0xFFFFFFFF;
      if(Y == -128)
        Y = Y + (signed int)((0xFFFFFFFF - 0xFFFFFFFF) + (unsigned int)1);

      if(U == -128)
        U = U + (signed int)((0xFFFFFFFF - 0xFFFFFFFF) + (unsigned int)1);

      if(V == -128)
        V = V + (signed int)((0xFFFFFFFF - 0xFFFFFFFF) + (unsigned int)1);

      ((signed char *)pBuf)[(signed long int)2] = (signed char)V;
      ((signed char *)pBuf)[(signed long int)1] = (signed char)Y;
      ((signed char *)pBuf)[(signed long int)0] = (signed char)U;
      pBuf = pBuf + 1l;
    }
  }
}

// zywrleRGBYUV32LE
// file ../common/zywrletemplate.c line 711
static inline void zywrleRGBYUV32LE(signed int *pBuf, unsigned int *data, signed int width, signed int height, signed int scanline)
{
  signed int R;
  signed int G;
  signed int B;
  signed int Y;
  signed int U;
  signed int V;
  signed int *pLine;
  signed int *pEnd = pBuf + (signed long int)(height * width);
  for( ; !(pBuf >= pEnd); data = data + (signed long int)(scanline - width))
  {
    pLine = pBuf + (signed long int)width;
    for( ; !(pBuf >= pLine); data = data + 1l)
    {
      R = (signed int)((unsigned char *)data)[(signed long int)2];
      G = (signed int)((unsigned char *)data)[(signed long int)1];
      B = (signed int)((unsigned char *)data)[(signed long int)0];
      Y = R + (G << 1) + B >> 2;
      U = B - G;
      V = R - G;
      Y = Y - 128;
      U = U >> 1;
      V = V >> 1;
      Y = Y & (signed int)0xFFFFFFFF;
      U = U & (signed int)0xFFFFFFFF;
      V = V & (signed int)0xFFFFFFFF;
      if(Y == -128)
        Y = Y + (signed int)((0xFFFFFFFF - 0xFFFFFFFF) + (unsigned int)1);

      if(U == -128)
        U = U + (signed int)((0xFFFFFFFF - 0xFFFFFFFF) + (unsigned int)1);

      if(V == -128)
        V = V + (signed int)((0xFFFFFFFF - 0xFFFFFFFF) + (unsigned int)1);

      ((signed char *)pBuf)[(signed long int)2] = (signed char)V;
      ((signed char *)pBuf)[(signed long int)1] = (signed char)Y;
      ((signed char *)pBuf)[(signed long int)0] = (signed char)U;
      pBuf = pBuf + 1l;
    }
  }
}

