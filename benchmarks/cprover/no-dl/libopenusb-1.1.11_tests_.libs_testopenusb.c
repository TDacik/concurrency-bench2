// #anon_enum_USB_ERROR_TYPE_NONE=0_USB_ERROR_TYPE_STRING=1_USB_ERROR_TYPE_ERRNO=2
// file emulation.c line 46
enum anonymous_1 { USB_ERROR_TYPE_NONE=0, USB_ERROR_TYPE_STRING=1, USB_ERROR_TYPE_ERRNO=2 };

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_0;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_3;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_2;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_4;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-errorstr
// file usb.c line 1170
struct errorstr;

// tag-eventcallback
// file usb.c line 98
struct eventcallback;

// tag-interface_set
// file usbi.h line 112
struct interface_set;

// tag-list_head
// file list.h line 4
struct list_head;

// tag-openusb_bulk_request
// file ../src/openusb.h line 459
struct openusb_bulk_request;

// tag-openusb_ctrl_request
// file ../src/openusb.h line 431
struct openusb_ctrl_request;

// tag-openusb_ctrl_setup
// file ../src/openusb.h line 432
struct openusb_ctrl_setup;

// tag-openusb_dev_data
// file ../src/openusb.h line 386
struct openusb_dev_data;

// tag-openusb_event
// file ../src/openusb.h line 359
enum openusb_event { USB_ATTACH=0, USB_REMOVE=1, USB_SUSPEND=2, USB_RESUME=3, USB_HC_ATTACH=4, USB_HC_REMOVE=5, USB_COLDPLUG_COMPLETED=6 };

// tag-openusb_init_flag
// file ../src/openusb.h line 510
enum openusb_init_flag { USB_INIT_DEFAULT=0, USB_INIT_FAIL_FAST=1, USB_INIT_REVERSIBLE=2, USB_INIT_NON_REVERSIBLE=3 };

// tag-openusb_intr_request
// file ../src/openusb.h line 449
struct openusb_intr_request;

// tag-openusb_isoc_packet
// file ../src/openusb.h line 470
struct openusb_isoc_packet;

// tag-openusb_isoc_pkts
// file ../src/openusb.h line 468
struct openusb_isoc_pkts;

// tag-openusb_isoc_request
// file ../src/openusb.h line 476
struct openusb_isoc_request;

// tag-openusb_multi_bulk_request
// file openusb.h line 1175
struct openusb_multi_bulk_request;

// tag-openusb_multi_intr_request
// file openusb.h line 1164
struct openusb_multi_intr_request;

// tag-openusb_multi_isoc_request
// file openusb.h line 1185
struct openusb_multi_isoc_request;

// tag-openusb_multi_request
// file openusb.h line 1200
union openusb_multi_request;

// tag-openusb_multi_request_handle
// file openusb.h line 1194
struct openusb_multi_request_handle;

// tag-openusb_request
// file ../src/openusb.h line 496
union openusb_request;

// tag-openusb_request_handle
// file ../src/openusb.h line 490
struct openusb_request_handle;

// tag-openusb_request_result
// file ../src/openusb.h line 426
struct openusb_request_result;

// tag-openusb_transfer_type
// file ../src/openusb.h line 371
enum openusb_transfer_type { USB_TYPE_ALL=0, USB_TYPE_CONTROL=1, USB_TYPE_INTERRUPT=2, USB_TYPE_BULK=3, USB_TYPE_ISOCHRONOUS=4, USB_TYPE_LAST=5 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-simple_io
// file io.c line 293
struct simple_io;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-usb_bus
// file /usr/include/usb.h line 236
struct usb_bus;

// tag-usb_config_desc
// file ../src/openusb.h line 124
struct usb_config_desc;

// tag-usb_config_descriptor
// file /usr/include/usb.h line 145
struct usb_config_descriptor;

// tag-usb_descriptor_header
// file descriptors.c line 127
struct usb_descriptor_header;

// tag-usb_dev_handle
// file /usr/include/usb.h line 277
struct usb_dev_handle;

// tag-usb_dev_handle_internal
// file emulation.c line 306
struct usb_dev_handle_internal;

// tag-usb_device
// file /usr/include/usb.h line 235
struct usb_device;

// tag-usb_device_desc
// file ../src/openusb.h line 106
struct usb_device_desc;

// tag-usb_device_descriptor
// file /usr/include/usb.h line 162
struct usb_device_descriptor;

// tag-usb_endpoint_desc
// file ../src/openusb.h line 153
struct usb_endpoint_desc;

// tag-usb_endpoint_descriptor
// file /usr/include/usb.h line 94
struct usb_endpoint_descriptor;

// tag-usb_interface
// file /usr/include/usb.h line 137
struct usb_interface;

// tag-usb_interface_desc
// file ../src/openusb.h line 140
struct usb_interface_desc;

// tag-usb_interface_descriptor
// file /usr/include/usb.h line 119
struct usb_interface_descriptor;

// tag-usb_string_desc
// file ../src/openusb.h line 206
struct usb_string_desc;

// tag-usbi_altsetting
// file descr.h line 33
struct usbi_altsetting;

// tag-usbi_backend
// file usbi.h line 26
struct usbi_backend;

// tag-usbi_backend_ops
// file usbi.h line 30
struct usbi_backend_ops;

// tag-usbi_bus
// file usbi.h line 34
struct usbi_bus;

// tag-usbi_bus_private
// file usbi.h line 49
struct usbi_bus_private;

// tag-usbi_config
// file descr.h line 50
struct usbi_config;

// tag-usbi_descriptors
// file descr.h line 66
struct usbi_descriptors;

// tag-usbi_dev_handle
// file usbi.h line 126
struct usbi_dev_handle;

// tag-usbi_dev_hdl_private
// file usbi.h line 148
struct usbi_dev_hdl_private;

// tag-usbi_dev_private
// file usbi.h line 75
struct usbi_dev_private;

// tag-usbi_device
// file usbi.h line 46
struct usbi_device;

// tag-usbi_device_ops
// file usbi.h line 70
struct usbi_device_ops;

// tag-usbi_devstate
// file usbi.h line 117
enum usbi_devstate { USBI_DEVICE_CLOSED=0, USBI_DEVICE_OPENED=1, USBI_DEVICE_CLOSING=2 };

// tag-usbi_endpoint
// file descr.h line 25
struct usbi_endpoint;

// tag-usbi_event_callback
// file usbi.h line 81
struct usbi_event_callback;

// tag-usbi_handle
// file usbi.h line 87
struct usbi_handle;

// tag-usbi_interface
// file descr.h line 44
struct usbi_interface;

// tag-usbi_io
// file usbi.h line 164
struct usbi_io;

// tag-usbi_io_private
// file usbi.h line 181
struct usbi_io_private;

// tag-usbi_io_status
// file usbi.h line 151
enum usbi_io_status { USBI_IO_INITIAL=0, USBI_IO_INPROGRESS=1, USBI_IO_CANCEL=2, USBI_IO_COMPLETED=3, USBI_IO_COMPLETED_FAIL=4, USBI_IO_TIMEOUT=5 };

// tag-usbi_list
// file usbi.h line 20
struct usbi_list;

// tag-usbi_multi_req_args
// file api.c line 1085
struct usbi_multi_req_args;

// tag-usbi_multi_request
// file api.c line 1071
struct usbi_multi_request;

// tag-usbi_raw_desc
// file descr.h line 60
struct usbi_raw_desc;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _usbi_debug
// file usb.c line 60
void _usbi_debug(struct usbi_handle *hdl, unsigned int level, const char *func, unsigned int line, const char *fmt, ...);
// advance_xfer_test
// file testopenusb.c line 1194
static signed int advance_xfer_test(void);
// async_callback
// file io.c line 344
static void async_callback(struct usbi_io *io, signed int status);
// async_xfer_ctrl_test
// file testopenusb.c line 574
static signed int async_xfer_ctrl_test(unsigned long int devh);
// async_xfer_test
// file testopenusb.c line 695
static signed int async_xfer_test(unsigned long int devh, enum openusb_transfer_type type, signed int flag);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// basic_test
// file testopenusb.c line 1422
static signed int basic_test(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_req_valid
// file api.c line 379
static signed int check_req_valid(struct openusb_request_handle *req, struct usbi_dev_handle *dev);
// cleanup
// file testopenusb.c line 1470
static void cleanup(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// convert_string
// file testopenusb.c line 198
static signed int convert_string(char *buf, struct usb_string_desc *st, signed int buflen);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// dump_dev_data
// file testopenusb.c line 220
static void dump_dev_data(struct openusb_dev_data *pdev);
// event_cb
// file testopenusb.c line 164
static void event_cb(unsigned long int handle, unsigned long int devid, enum openusb_event event, void *arg);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// io_submit
// file io.c line 418
static void * io_submit(void *arg);
// list_add
// file list.h line 10
void list_add(struct list_head *entry, struct list_head *head);
// list_del
// file list.h line 11
void list_del(struct list_head *entry);
// list_init
// file list.h line 9
void list_init(struct list_head *entry);
// load_backend
// file usb.c line 209
static signed int load_backend(const char *filepath);
// load_backends
// file usb.c line 269
static signed int load_backends(const char *dirpath);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// multi_req_callback
// file api.c line 1099
static signed int multi_req_callback(struct openusb_request_handle *req);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openusb_abort
// file usb.c line 1048
signed int openusb_abort(struct openusb_request_handle *phdl);
// openusb_bulk_xfer
// file ../src/openusb.h line 1111
signed int openusb_bulk_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_bulk_request *bulk);
// openusb_claim_interface
// file ../src/openusb.h line 1014
signed int openusb_claim_interface(unsigned long int dev, unsigned char ifc, enum openusb_init_flag flags);
// openusb_close_device
// file ../src/openusb.h line 935
signed int openusb_close_device(unsigned long int dev);
// openusb_coldplug_callbacks_done
// file api.c line 23
void openusb_coldplug_callbacks_done(unsigned long int handle);
// openusb_ctrl_xfer
// file ../src/openusb.h line 1107
signed int openusb_ctrl_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_ctrl_request *ctrl);
// openusb_fini
// file ../src/openusb.h line 561
void openusb_fini(unsigned long int handle);
// openusb_free_busid_list
// file ../src/openusb.h line 733
void openusb_free_busid_list(unsigned long int *busids);
// openusb_free_device_data
// file ../src/openusb.h line 804
void openusb_free_device_data(struct openusb_dev_data *data);
// openusb_free_devid_list
// file ../src/openusb.h line 768
void openusb_free_devid_list(unsigned long int *devids);
// openusb_free_raw_desc
// file devices.c line 883
void openusb_free_raw_desc(unsigned char *buffer);
// openusb_get_altsetting
// file ../src/openusb.h line 1041
signed int openusb_get_altsetting(unsigned long int dev, unsigned char ifc, unsigned char *alt);
// openusb_get_busid_list
// file ../src/openusb.h line 731
signed int openusb_get_busid_list(unsigned long int handle, unsigned long int **busids, unsigned int *num_busids);
// openusb_get_configuration
// file ../src/openusb.h line 989
signed int openusb_get_configuration(unsigned long int dev, unsigned char *cfg);
// openusb_get_device_data
// file ../src/openusb.h line 790
signed int openusb_get_device_data(unsigned long int handle, unsigned long int devid, unsigned int flags, struct openusb_dev_data **data);
// openusb_get_devid
// file ../src/openusb.h line 950
signed int openusb_get_devid(unsigned long int dev, unsigned long int *devid);
// openusb_get_devids_by_bus
// file ../src/openusb.h line 761
signed int openusb_get_devids_by_bus(unsigned long int handle, unsigned long int busid, unsigned long int **devids, unsigned int *num_devids);
// openusb_get_devids_by_class
// file ../src/openusb.h line 765
signed int openusb_get_devids_by_class(unsigned long int handle, signed short int devclass, signed short int subclass, signed short int protocol, unsigned long int **devids, unsigned int *num_devids);
// openusb_get_devids_by_vendor
// file devices.c line 632
signed int openusb_get_devids_by_vendor(unsigned long int handle, signed int vendor, signed int product, unsigned long int **devids, unsigned int *num_devids);
// openusb_get_lib_handle
// file ../src/openusb.h line 965
signed int openusb_get_lib_handle(unsigned long int dev, unsigned long int *lib_handle);
// openusb_get_max_xfer_size
// file devices.c line 1510
signed int openusb_get_max_xfer_size(unsigned long int handle, unsigned long int bus, enum openusb_transfer_type type, unsigned int *bytes);
// openusb_get_raw_desc
// file devices.c line 852
signed int openusb_get_raw_desc(unsigned long int handle, unsigned long int devid, unsigned char type, unsigned char descidx, unsigned short int langid, unsigned char **buffer, unsigned short int *buflen);
// openusb_init
// file ../src/openusb.h line 545
signed int openusb_init(unsigned int flags, unsigned long int *handle);
// openusb_intr_xfer
// file ../src/openusb.h line 1109
signed int openusb_intr_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_intr_request *intr);
// openusb_is_interface_claimed
// file ../src/openusb.h line 1017
signed int openusb_is_interface_claimed(unsigned long int dev, unsigned char ifc);
// openusb_isoc_xfer
// file ../src/openusb.h line 1113
signed int openusb_isoc_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_isoc_request *isoc);
// openusb_le16_to_cpu
// file usb.c line 1120
inline unsigned short int openusb_le16_to_cpu(unsigned short int data);
// openusb_le32_to_cpu
// file usb.c line 1134
inline unsigned int openusb_le32_to_cpu(unsigned int data);
// openusb_open_device
// file ../src/openusb.h line 933
signed int openusb_open_device(unsigned long int handle, unsigned long int devid, enum openusb_init_flag flags, unsigned long int *dev);
// openusb_parse_config_desc
// file ../src/openusb.h line 872
signed int openusb_parse_config_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, unsigned char cfgidx, struct usb_config_desc *cfgdesc);
// openusb_parse_data
// file openusb.h line 713
signed int openusb_parse_data(const char *format, unsigned char *source, unsigned int sourcelen, void *dest, unsigned int destlen, unsigned int *count);
// openusb_parse_device_desc
// file ../src/openusb.h line 869
signed int openusb_parse_device_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, struct usb_device_desc *devdesc);
// openusb_parse_endpoint_desc
// file ../src/openusb.h line 879
signed int openusb_parse_endpoint_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, unsigned char cfgidx, unsigned char ifcidx, unsigned char alt, unsigned char eptidx, struct usb_endpoint_desc *eptdesc);
// openusb_parse_interface_desc
// file ../src/openusb.h line 875
signed int openusb_parse_interface_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, unsigned char cfgidx, unsigned char ifcidx, unsigned char alt, struct usb_interface_desc *ifcdesc);
// openusb_poll
// file ../src/openusb.h line 1153
signed int openusb_poll(unsigned int num_reqs, struct openusb_request_handle **handles, struct openusb_request_handle **handle);
// openusb_release_interface
// file ../src/openusb.h line 1016
signed int openusb_release_interface(unsigned long int dev, unsigned char ifc);
// openusb_reset
// file api.c line 262
signed int openusb_reset(unsigned long int dev);
// openusb_set_altsetting
// file ../src/openusb.h line 1042
signed int openusb_set_altsetting(unsigned long int dev, unsigned char ifc, unsigned char alt);
// openusb_set_configuration
// file ../src/openusb.h line 990
signed int openusb_set_configuration(unsigned long int dev, unsigned char cfg);
// openusb_set_debug
// file usb.c line 738
void openusb_set_debug(unsigned long int handle, unsigned int level, unsigned int flags, void (*callback)(unsigned long int, const char *, void **));
// openusb_set_debug::callback_object
//
void callback_object(unsigned long int, const char *, void **);
// openusb_set_default_timeout
// file ../src/openusb.h line 636
signed int openusb_set_default_timeout(unsigned long int handle, enum openusb_transfer_type type, unsigned int timeout);
// openusb_set_event_callback
// file ../src/openusb.h line 579
signed int openusb_set_event_callback(unsigned long int handle, enum openusb_event type, void (*callback)(unsigned long int, unsigned long int, enum openusb_event, void *), void *arg);
// openusb_set_event_callback::callback_object
//
void callback_object(unsigned long int, unsigned long int, enum openusb_event, void *);
// openusb_start
// file api.c line 1398
signed int openusb_start(struct openusb_multi_request_handle *handle);
// openusb_stop
// file api.c line 1518
signed int openusb_stop(struct openusb_multi_request_handle *handle);
// openusb_strerror
// file ../src/openusb.h line 663
const char * openusb_strerror(signed int error);
// openusb_wait
// file ../src/openusb.h line 1151
signed int openusb_wait(unsigned int num_reqs, struct openusb_request_handle **handles, struct openusb_request_handle **handle);
// openusb_xfer_aio
// file ../src/openusb.h line 1077
signed int openusb_xfer_aio(struct openusb_request_handle *req);
// openusb_xfer_wait
// file api.c line 525
signed int openusb_xfer_wait(struct openusb_request_handle *req);
// parse_option
// file testopenusb.c line 1364
static signed int parse_option(signed int argc, char **argv);
// pause
// file /usr/include/unistd.h line 469
extern signed int pause(void);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// print_configuration
// file testopenusb.c line 83
static void print_configuration(unsigned long int devid, signed int cfgidx, struct usb_config_desc *cfg);
// print_device
// file testopenusb.c line 117
static void print_device(unsigned long int devid, signed int indent);
// print_endpoint
// file testopenusb.c line 41
static void print_endpoint(struct usb_endpoint_desc *ep);
// print_interface
// file testopenusb.c line 52
static void print_interface(unsigned long int devid, signed int cfgidx, signed int ifcidx, signed int alt, struct usb_interface_desc *intf);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_event_callbacks
// file usb.c line 139
static void * process_event_callbacks(void *unused);
// process_event_callbacks::1::1::2::func_object
//
void func_object(unsigned long int, unsigned long int, enum openusb_event, void *);
// process_multi_request
// file api.c line 1177
static signed int process_multi_request(void *arg);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_4 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_4 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_4 *, const union anonymous_2 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_4 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_4 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous_2 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// refresh_bus
// file devices.c line 124
static void refresh_bus(struct usbi_backend *backend);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_0 *, struct anonymous_0 *, struct anonymous_0 *, struct timeval *);
// simple_io_complete
// file io.c line 328
static void simple_io_complete(struct simple_io *io, signed int status);
// simple_io_setup
// file io.c line 302
static void simple_io_setup(struct simple_io *io);
// simple_io_wait
// file io.c line 310
static signed int simple_io_wait(struct simple_io *io);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// test_async_xfer
// file testopenusb.c line 1175
static signed int test_async_xfer(unsigned long int devh);
// test_bulk_sync
// file testopenusb.c line 340
static signed int test_bulk_sync(unsigned long int devh);
// test_ctrl_sync
// file testopenusb.c line 287
static signed int test_ctrl_sync(unsigned long int devh);
// test_get_device_data
// file testopenusb.c line 1113
static signed int test_get_device_data(void);
// test_intr_sync
// file testopenusb.c line 417
static signed int test_intr_sync(unsigned long int devh, signed int flag);
// test_isoc_sync
// file testopenusb.c line 496
static signed int test_isoc_sync(unsigned long int devh);
// test_sync_xfer
// file testopenusb.c line 1149
static signed int test_sync_xfer(unsigned long int devh);
// timeout_thread
// file usb.c line 1222
void * timeout_thread(void *arg);
// usage
// file testopenusb.c line 1344
static void usage(char *prog);
// usb0_bulk_xfer
// file emulation.c line 609
static signed int usb0_bulk_xfer(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout);
// usb0_intr_xfer
// file emulation.c line 654
static signed int usb0_intr_xfer(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout);
// usb_bulk_read
// file emulation.c line 644
signed int usb_bulk_read(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout);
// usb_bulk_write
// file emulation.c line 638
signed int usb_bulk_write(struct usb_dev_handle *dev, signed int ep, const char *bytes, signed int size, signed int timeout);
// usb_claim_interface
// file emulation.c line 758
signed int usb_claim_interface(struct usb_dev_handle *dev, signed int interface);
// usb_clear_halt
// file emulation.c line 831
signed int usb_clear_halt(struct usb_dev_handle *dev, unsigned int ep);
// usb_close
// file emulation.c line 581
signed int usb_close(struct usb_dev_handle *dev);
// usb_control_msg
// file emulation.c line 694
signed int usb_control_msg(struct usb_dev_handle *dev, signed int requesttype, signed int request, signed int value, signed int index, char *bytes, signed int size, signed int timeout);
// usb_detach_kernel_driver_np
// file emulation.c line 985
signed int usb_detach_kernel_driver_np(struct usb_dev_handle *dev, signed int interface);
// usb_device
// file emulation.c line 952
struct usb_device * usb_device(struct usb_dev_handle *dev);
// usb_find_busses
// file emulation.c line 139
signed int usb_find_busses(void);
// usb_find_devices
// file emulation.c line 223
signed int usb_find_devices(void);
// usb_fini
// file emulation.c line 124
void usb_fini(void);
// usb_get_busses
// file emulation.c line 965
struct usb_bus * usb_get_busses(void);
// usb_get_descriptor
// file emulation.c line 931
signed int usb_get_descriptor(struct usb_dev_handle *dev, unsigned char type, unsigned char index, void *buf, signed int size);
// usb_get_descriptor_by_endpoint
// file emulation.c line 911
signed int usb_get_descriptor_by_endpoint(struct usb_dev_handle *dev, signed int ep, unsigned char type, unsigned char index, void *buf, signed int size);
// usb_get_driver_np
// file emulation.c line 970
signed int usb_get_driver_np(struct usb_dev_handle *dev, signed int interface, char *name, unsigned int namelen);
// usb_get_string
// file emulation.c line 868
signed int usb_get_string(struct usb_dev_handle *dev, signed int index, signed int langid, char *buf, unsigned long int buflen);
// usb_get_string_simple
// file emulation.c line 890
signed int usb_get_string_simple(struct usb_dev_handle *dev, signed int index, char *buf, unsigned long int buflen);
// usb_init
// file emulation.c line 110
void usb_init(void);
// usb_interrupt_read
// file emulation.c line 687
signed int usb_interrupt_read(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout);
// usb_interrupt_write
// file emulation.c line 681
signed int usb_interrupt_write(struct usb_dev_handle *dev, signed int ep, const char *bytes, signed int size, signed int timeout);
// usb_open
// file emulation.c line 528
struct usb_dev_handle * usb_open(struct usb_device *dev);
// usb_release_interface
// file emulation.c line 780
signed int usb_release_interface(struct usb_dev_handle *dev, signed int interface);
// usb_reset
// file emulation.c line 847
signed int usb_reset(struct usb_dev_handle *dev);
// usb_resetep
// file emulation.c line 825
signed int usb_resetep(struct usb_dev_handle *dev, unsigned int ep);
// usb_set_altinterface
// file emulation.c line 800
signed int usb_set_altinterface(struct usb_dev_handle *dev, signed int alternate);
// usb_set_configuration
// file emulation.c line 735
signed int usb_set_configuration(struct usb_dev_handle *dev, signed int configuration);
// usb_set_debug
// file emulation.c line 129
void usb_set_debug(signed int level);
// usb_strerror
// file emulation.c line 84
char * usb_strerror(void);
// usbi_add_bus
// file devices.c line 28
static void usbi_add_bus(struct usbi_bus *ibus, struct usbi_backend *backend);
// usbi_add_device
// file devices.c line 209
void usbi_add_device(struct usbi_bus *ibus, struct usbi_device *idev);
// usbi_add_event_callback
// file usb.c line 108
void usbi_add_event_callback(struct usbi_handle *hdl, unsigned long int devid, enum openusb_event type);
// usbi_add_or_stop
// file api.c line 1468
static signed int usbi_add_or_stop(struct openusb_multi_request_handle *handle, signed int flag);
// usbi_alloc_io
// file usbi.h line 381
struct usbi_io * usbi_alloc_io(struct usbi_dev_handle *dev, struct openusb_request_handle *req, unsigned int timeout);
// usbi_alloc_request_handle
// file io.c line 523
struct openusb_request_handle * usbi_alloc_request_handle(void);
// usbi_async_submit
// file io.c line 207
signed int usbi_async_submit(struct usbi_io *io);
// usbi_attach_kernel_driver_np
// file usb.c line 1380
signed int usbi_attach_kernel_driver_np(unsigned long int dev, unsigned char interface);
// usbi_coldplug_complete
// file usb.c line 697
static void usbi_coldplug_complete(struct usbi_handle *hdl);
// usbi_control_xfer
// file api.c line 283
signed int usbi_control_xfer(struct usbi_dev_handle *devh, signed int requesttype, signed int request, signed int value, signed int index, char *bytes, signed int size, signed int timeout);
// usbi_destroy_configuration
// file usbi.h line 390
void usbi_destroy_configuration(struct usbi_device *dev);
// usbi_destroy_handle
// file usb.c line 557
static void usbi_destroy_handle(struct usbi_handle *hdl);
// usbi_detach_kernel_driver_np
// file usb.c line 1397
signed int usbi_detach_kernel_driver_np(unsigned long int dev, unsigned char interface);
// usbi_fetch_and_parse_descriptors
// file usbi.h line 389
signed int usbi_fetch_and_parse_descriptors(struct usbi_dev_handle *hdev);
// usbi_find_bus_by_id
// file devices.c line 72
static struct usbi_bus * usbi_find_bus_by_id(unsigned long int busid);
// usbi_find_bus_by_num
// file devices.c line 98
struct usbi_bus * usbi_find_bus_by_num(unsigned int busnum);
// usbi_find_dev_handle
// file usb.c line 797
struct usbi_dev_handle * usbi_find_dev_handle(unsigned long int dev);
// usbi_find_device_by_id
// file usb.c line 832
struct usbi_device * usbi_find_device_by_id(unsigned long int devid);
// usbi_find_handle
// file usb.c line 485
struct usbi_handle * usbi_find_handle(unsigned long int handle);
// usbi_fini_common
// file usb.c line 467
static void usbi_fini_common(void);
// usbi_free_bus
// file devices.c line 50
void usbi_free_bus(struct usbi_bus *ibus);
// usbi_free_cfg
// file api.c line 364
static void usbi_free_cfg(char *buf);
// usbi_free_device
// file devices.c line 236
void usbi_free_device(struct usbi_device *idev);
// usbi_free_io
// file usbi.h line 383
void usbi_free_io(struct usbi_io *io);
// usbi_get_cfg_index_by_value
// file devices.c line 1564
signed int usbi_get_cfg_index_by_value(struct usbi_dev_handle *hdev, unsigned char cfgval);
// usbi_get_cfg_value_by_index
// file devices.c line 1549
unsigned char usbi_get_cfg_value_by_index(struct usbi_dev_handle *hdev, signed int cfgndx);
// usbi_get_config_desc
// file api.c line 316
static signed int usbi_get_config_desc(struct usbi_dev_handle *devh, signed int cfg, char **cfgbuf, signed int *cfglen);
// usbi_get_descriptor
// file descriptors.c line 20
static signed int usbi_get_descriptor(unsigned long int dev, unsigned char type, unsigned char index, void *buf, unsigned int buflen);
// usbi_get_devices_list
// file devices.c line 1543
struct usbi_list * usbi_get_devices_list(void);
// usbi_get_driver_np
// file usb.c line 1361
signed int usbi_get_driver_np(unsigned long int dev, unsigned char interface, char *name, unsigned int namelen);
// usbi_get_intf_altno
// file descriptors.c line 252
static signed int usbi_get_intf_altno(char *buf, unsigned int buflen);
// usbi_get_num_altsettings
// file devices.c line 377
static signed int usbi_get_num_altsettings(struct usbi_device *idev, unsigned char *buffer, unsigned short int buflen, unsigned char infidx);
// usbi_get_raw_desc
// file descriptors.c line 676
signed int usbi_get_raw_desc(struct usbi_device *idev, unsigned char type, unsigned char descidx, unsigned short int langid, unsigned char **buffer, unsigned short int *buflen);
// usbi_get_string
// file devices.c line 1137
signed int usbi_get_string(unsigned long int dev, signed int index, signed int langid, char *buf, unsigned long int buflen);
// usbi_get_string_simple
// file devices.c line 1177
signed int usbi_get_string_simple(unsigned long int dev, signed int index, char *buf, unsigned long int buflen);
// usbi_get_xfer_timeout
// file api.c line 737
signed int usbi_get_xfer_timeout(struct openusb_request_handle *req, struct usbi_dev_handle *dev);
// usbi_init_common
// file usb.c line 354
static signed int usbi_init_common(void);
// usbi_init_handle
// file usb.c line 513
static struct usbi_handle * usbi_init_handle(void);
// usbi_io_async
// file usbi.h line 376
signed int usbi_io_async(struct usbi_io *iop);
// usbi_io_complete
// file usbi.h line 378
void usbi_io_complete(struct usbi_io *io, signed int status, unsigned long int transferred_bytes);
// usbi_io_sync
// file usbi.h line 375
signed int usbi_io_sync(struct usbi_dev_handle *dev, struct openusb_request_handle *req);
// usbi_list_fini
// file usb.c line 345
static void usbi_list_fini(struct usbi_list *list);
// usbi_list_init
// file usb.c line 333
static signed int usbi_list_init(struct usbi_list *list);
// usbi_match_class
// file devices.c line 425
static signed int usbi_match_class(unsigned long int handle, struct usbi_device *idev, signed short int devclass, signed short int subclass, signed short int protocol);
// usbi_nth_desc
// file devices.c line 1034
static unsigned char * usbi_nth_desc(unsigned char *buffer, unsigned short int buflen, unsigned char type, unsigned char n, unsigned char stop_type);
// usbi_parse_configuration
// file descriptors.c line 484
signed int usbi_parse_configuration(struct usbi_config *cfg, unsigned char *buf, unsigned long int buflen);
// usbi_parse_endpoint
// file descriptors.c line 136
static signed int usbi_parse_endpoint(struct usbi_endpoint *ep, unsigned char *buf, unsigned int buflen);
// usbi_parse_interface
// file descriptors.c line 277
static signed int usbi_parse_interface(struct usbi_interface *intf, unsigned char *buf, unsigned int buflen);
// usbi_refresh_busses
// file devices.c line 195
static void usbi_refresh_busses(void);
// usbi_remove_device
// file devices.c line 253
void usbi_remove_device(struct usbi_device *idev);
// usbi_rescan_devices
// file usbi.h line 401
void usbi_rescan_devices(void);
// usbi_sync_submit
// file io.c line 255
signed int usbi_sync_submit(struct usbi_io *io);
// usbi_timeval_compare
// file usb.c line 1155
signed int usbi_timeval_compare(struct timeval *tva, struct timeval *tvb);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wr_create_devices
// file emulation.c line 163
static signed int wr_create_devices(struct usb_bus *bus, struct usbi_bus *ibus);
// wr_error
// file emulation.c line 74
static signed int wr_error(signed int x);
// wr_error_str
// file emulation.c line 56
static void wr_error_str(signed int x, const char *format, ...);
// wr_find_device
// file emulation.c line 270
static unsigned long int wr_find_device(struct usb_device *dev);
// wr_parse_endpoint
// file emulation.c line 316
static signed int wr_parse_endpoint(struct usb_interface_descriptor *ifdesc, struct usbi_altsetting *alt);
// wr_parse_interface
// file emulation.c line 364
static signed int wr_parse_interface(struct usb_interface *ifc01, struct usbi_interface *ifc10);
// wr_setup_dev_config
// file emulation.c line 422
static signed int wr_setup_dev_config(struct usb_device *dev, unsigned long int devid, unsigned long int devh);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_0
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_2
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_4
{
  // __data
  struct anonymous_3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct errorstr
{
  // code
  signed int code;
  // msg
  const char *msg;
};

struct list_head
{
  // prev
  struct list_head *prev;
  // next
  struct list_head *next;
};

struct eventcallback
{
  // list
  struct list_head list;
  // devid
  unsigned long int devid;
  // type
  enum openusb_event type;
  // handle
  struct usbi_handle *handle;
};

struct interface_set
{
  // clm
  signed int clm;
  // altsetting
  signed int altsetting;
};

struct openusb_request_result
{
  // status
  signed int status;
  // transferred_bytes
  unsigned int transferred_bytes;
};

struct openusb_bulk_request
{
  // payload
  unsigned char *payload;
  // length
  unsigned int length;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
  // result
  struct openusb_request_result result;
  // next
  struct openusb_bulk_request *next;
};

struct openusb_ctrl_setup
{
  // bmRequestType
  unsigned char bmRequestType;
  // bRequest
  unsigned char bRequest;
  // wValue
  unsigned short int wValue;
  // wIndex
  unsigned short int wIndex;
};

struct openusb_ctrl_request
{
  // setup
  struct openusb_ctrl_setup setup;
  // payload
  unsigned char *payload;
  // length
  unsigned int length;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
  // result
  struct openusb_request_result result;
  // next
  struct openusb_ctrl_request *next;
};

struct usb_device_desc
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bcdUSB
  unsigned short int bcdUSB;
  // bDeviceClass
  unsigned char bDeviceClass;
  // bDeviceSubClass
  unsigned char bDeviceSubClass;
  // bDeviceProtocol
  unsigned char bDeviceProtocol;
  // bMaxPacketSize0
  unsigned char bMaxPacketSize0;
  // idVendor
  unsigned short int idVendor;
  // idProduct
  unsigned short int idProduct;
  // bcdDevice
  unsigned short int bcdDevice;
  // iManufacturer
  unsigned char iManufacturer;
  // iProduct
  unsigned char iProduct;
  // iSerialNumber
  unsigned char iSerialNumber;
  // bNumConfigurations
  unsigned char bNumConfigurations;
};

struct usb_config_desc
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // wTotalLength
  unsigned short int wTotalLength;
  // bNumInterfaces
  unsigned char bNumInterfaces;
  // bConfigurationValue
  unsigned char bConfigurationValue;
  // iConfiguration
  unsigned char iConfiguration;
  // bmAttributes
  unsigned char bmAttributes;
  // bMaxPower
  unsigned char bMaxPower;
};

struct openusb_dev_data
{
  // busid
  unsigned long int busid;
  // devid
  unsigned long int devid;
  // bus_address
  unsigned char bus_address;
  // pdevid
  unsigned long int pdevid;
  // pport
  unsigned char pport;
  // nports
  unsigned char nports;
  // sys_path
  char *sys_path;
  // bus_path
  char *bus_path;
  // dev_desc
  struct usb_device_desc dev_desc;
  // cfg_desc
  struct usb_config_desc cfg_desc;
  // raw_cfg_desc
  unsigned char *raw_cfg_desc;
  // manufacturer
  struct usb_string_desc *manufacturer;
  // product
  struct usb_string_desc *product;
  // serialnumber
  struct usb_string_desc *serialnumber;
  // ctrl_max_xfer_size
  unsigned int ctrl_max_xfer_size;
  // intr_max_xfer_size
  unsigned int intr_max_xfer_size;
  // bulk_max_xfer_size
  unsigned int bulk_max_xfer_size;
  // isoc_max_xfer_size
  unsigned int isoc_max_xfer_size;
};

struct openusb_intr_request
{
  // interval
  unsigned short int interval;
  // payload
  unsigned char *payload;
  // length
  unsigned int length;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
  // result
  struct openusb_request_result result;
  // next
  struct openusb_intr_request *next;
};

struct openusb_isoc_packet
{
  // payload
  unsigned char *payload;
  // length
  unsigned int length;
};

struct openusb_isoc_pkts
{
  // num_packets
  unsigned int num_packets;
  // packets
  struct openusb_isoc_packet *packets;
};

struct openusb_isoc_request
{
  // start_frame
  unsigned int start_frame;
  // flags
  unsigned int flags;
  // pkts
  struct openusb_isoc_pkts pkts;
  // isoc_results
  struct openusb_request_result *isoc_results;
  // isoc_status
  signed int isoc_status;
  // next
  struct openusb_isoc_request *next;
};

struct openusb_multi_bulk_request
{
  // payloads
  unsigned char **payloads;
  // lengths
  unsigned int *lengths;
  // num_bufs
  unsigned int num_bufs;
  // rp
  unsigned int rp;
  // wp
  unsigned int wp;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
};

struct openusb_multi_intr_request
{
  // payloads
  unsigned char **payloads;
  // lengths
  unsigned int *lengths;
  // num_bufs
  unsigned int num_bufs;
  // rp
  unsigned int rp;
  // wp
  unsigned int wp;
  // interval
  unsigned short int interval;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
};

struct openusb_multi_isoc_request
{
  // start_frame
  unsigned int start_frame;
  // flags
  unsigned int flags;
  // pkts
  struct openusb_isoc_pkts *pkts;
  // num_pkts
  unsigned int num_pkts;
  // rp
  unsigned int rp;
  // wp
  unsigned int wp;
};

union openusb_multi_request
{
  // intr
  struct openusb_multi_intr_request *intr;
  // bulk
  struct openusb_multi_bulk_request *bulk;
  // isoc
  struct openusb_multi_isoc_request *isoc;
};

struct openusb_multi_request_handle
{
  // dev
  unsigned long int dev;
  // interface
  unsigned char interface;
  // endpoint
  unsigned char endpoint;
  // type
  enum openusb_transfer_type type;
  // req
  union openusb_multi_request req;
  // cb
  signed int (*cb)(struct openusb_multi_request_handle *, unsigned int, struct openusb_request_result *);
  // arg
  void *arg;
};

union openusb_request
{
  // ctrl
  struct openusb_ctrl_request *ctrl;
  // intr
  struct openusb_intr_request *intr;
  // bulk
  struct openusb_bulk_request *bulk;
  // isoc
  struct openusb_isoc_request *isoc;
};

struct openusb_request_handle
{
  // dev
  unsigned long int dev;
  // interface
  unsigned char interface;
  // endpoint
  unsigned char endpoint;
  // type
  enum openusb_transfer_type type;
  // req
  union openusb_request req;
  // cb
  signed int (*cb)(struct openusb_request_handle *);
  // arg
  void *arg;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct simple_io
{
  // lock
  union anonymous lock;
  // complete
  union anonymous_4 complete;
  // completed
  signed int completed;
  // status
  signed int status;
  // transferred_bytes
  unsigned long int transferred_bytes;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct usb_bus
{
  // next
  struct usb_bus *next;
  // prev
  struct usb_bus *prev;
  // dirname
  char dirname[4097l];
  // devices
  struct usb_device *devices;
  // location
  unsigned int location;
  // root_dev
  struct usb_device *root_dev;
};

struct usb_config_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // wTotalLength
  unsigned short int wTotalLength;
  // bNumInterfaces
  unsigned char bNumInterfaces;
  // bConfigurationValue
  unsigned char bConfigurationValue;
  // iConfiguration
  unsigned char iConfiguration;
  // bmAttributes
  unsigned char bmAttributes;
  // MaxPower
  unsigned char MaxPower;
  // interface
  struct usb_interface *interface;
  // extra
  unsigned char *extra;
  // extralen
  signed int extralen;
};

struct usb_descriptor_header
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
};

struct usb_dev_handle_internal
{
  // dev
  struct usb_device *dev;
  // devid
  unsigned long int devid;
  // devh
  unsigned long int devh;
  // config
  signed int config;
  // interface
  signed int interface;
  // alt
  signed int alt;
};

struct usb_device_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bcdUSB
  unsigned short int bcdUSB;
  // bDeviceClass
  unsigned char bDeviceClass;
  // bDeviceSubClass
  unsigned char bDeviceSubClass;
  // bDeviceProtocol
  unsigned char bDeviceProtocol;
  // bMaxPacketSize0
  unsigned char bMaxPacketSize0;
  // idVendor
  unsigned short int idVendor;
  // idProduct
  unsigned short int idProduct;
  // bcdDevice
  unsigned short int bcdDevice;
  // iManufacturer
  unsigned char iManufacturer;
  // iProduct
  unsigned char iProduct;
  // iSerialNumber
  unsigned char iSerialNumber;
  // bNumConfigurations
  unsigned char bNumConfigurations;
} __attribute__ ((__packed__));

struct usb_device
{
  // next
  struct usb_device *next;
  // prev
  struct usb_device *prev;
  // filename
  char filename[4097l];
  // bus
  struct usb_bus *bus;
  // descriptor
  struct usb_device_descriptor descriptor;
  // config
  struct usb_config_descriptor *config;
  // dev
  void *dev;
  // devnum
  unsigned char devnum;
  // num_children
  unsigned char num_children;
  // children
  struct usb_device **children;
};

struct usb_endpoint_desc
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bEndpointAddress
  unsigned char bEndpointAddress;
  // bmAttributes
  unsigned char bmAttributes;
  // wMaxPacketSize
  unsigned short int wMaxPacketSize;
  // bInterval
  unsigned char bInterval;
  // bRefresh
  unsigned char bRefresh;
  // bSynchAddress
  unsigned char bSynchAddress;
};

struct usb_endpoint_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bEndpointAddress
  unsigned char bEndpointAddress;
  // bmAttributes
  unsigned char bmAttributes;
  // wMaxPacketSize
  unsigned short int wMaxPacketSize;
  // bInterval
  unsigned char bInterval;
  // bRefresh
  unsigned char bRefresh;
  // bSynchAddress
  unsigned char bSynchAddress;
  // extra
  unsigned char *extra;
  // extralen
  signed int extralen;
};

struct usb_interface
{
  // altsetting
  struct usb_interface_descriptor *altsetting;
  // num_altsetting
  signed int num_altsetting;
};

struct usb_interface_desc
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bInterfaceNumber
  unsigned char bInterfaceNumber;
  // bAlternateSetting
  unsigned char bAlternateSetting;
  // bNumEndpoints
  unsigned char bNumEndpoints;
  // bInterfaceClass
  unsigned char bInterfaceClass;
  // bInterfaceSubClass
  unsigned char bInterfaceSubClass;
  // bInterfaceProtocol
  unsigned char bInterfaceProtocol;
  // iInterface
  unsigned char iInterface;
};

struct usb_interface_descriptor
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bInterfaceNumber
  unsigned char bInterfaceNumber;
  // bAlternateSetting
  unsigned char bAlternateSetting;
  // bNumEndpoints
  unsigned char bNumEndpoints;
  // bInterfaceClass
  unsigned char bInterfaceClass;
  // bInterfaceSubClass
  unsigned char bInterfaceSubClass;
  // bInterfaceProtocol
  unsigned char bInterfaceProtocol;
  // iInterface
  unsigned char iInterface;
  // endpoint
  struct usb_endpoint_descriptor *endpoint;
  // extra
  unsigned char *extra;
  // extralen
  signed int extralen;
};

struct usb_string_desc
{
  // bLength
  unsigned char bLength;
  // bDescriptorType
  unsigned char bDescriptorType;
  // bString
  unsigned short int bString[0l];
};

struct usbi_altsetting
{
  // desc
  struct usb_interface_desc desc;
  // num_endpoints
  unsigned long int num_endpoints;
  // endpoints
  struct usbi_endpoint *endpoints;
  // extra
  char *extra;
  // extralen
  unsigned long int extralen;
};

struct usbi_backend
{
  // list
  struct list_head list;
  // handle
  void *handle;
  // filepath
  char filepath[4097l];
  // ops
  struct usbi_backend_ops *ops;
};

struct usbi_device_ops
{
  // open
  signed int (*open)(struct usbi_dev_handle *);
  // close
  signed int (*close)(struct usbi_dev_handle *);
  // set_configuration
  signed int (*set_configuration)(struct usbi_dev_handle *, unsigned char);
  // get_configuration
  signed int (*get_configuration)(struct usbi_dev_handle *, unsigned char *);
  // claim_interface
  signed int (*claim_interface)(struct usbi_dev_handle *, unsigned char, enum openusb_init_flag);
  // release_interface
  signed int (*release_interface)(struct usbi_dev_handle *, unsigned char);
  // set_altsetting
  signed int (*set_altsetting)(struct usbi_dev_handle *, unsigned char, unsigned char);
  // get_altsetting
  signed int (*get_altsetting)(struct usbi_dev_handle *, unsigned char, unsigned char *);
  // reset
  signed int (*reset)(struct usbi_dev_handle *);
  // resetep
  signed int (*resetep)(struct usbi_dev_handle *, unsigned char);
  // clear_halt
  signed int (*clear_halt)(struct usbi_dev_handle *, unsigned char);
  // ctrl_xfer_wait
  signed int (*ctrl_xfer_wait)(struct usbi_dev_handle *, struct usbi_io *);
  // intr_xfer_wait
  signed int (*intr_xfer_wait)(struct usbi_dev_handle *, struct usbi_io *);
  // bulk_xfer_wait
  signed int (*bulk_xfer_wait)(struct usbi_dev_handle *, struct usbi_io *);
  // isoc_xfer_wait
  signed int (*isoc_xfer_wait)(struct usbi_dev_handle *, struct usbi_io *);
  // ctrl_xfer_aio
  signed int (*ctrl_xfer_aio)(struct usbi_dev_handle *, struct usbi_io *);
  // intr_xfer_aio
  signed int (*intr_xfer_aio)(struct usbi_dev_handle *, struct usbi_io *);
  // bulk_xfer_aio
  signed int (*bulk_xfer_aio)(struct usbi_dev_handle *, struct usbi_io *);
  // isoc_xfer_aio
  signed int (*isoc_xfer_aio)(struct usbi_dev_handle *, struct usbi_io *);
  // get_raw_desc
  signed int (*get_raw_desc)(struct usbi_device *, unsigned char, unsigned char, unsigned short int, unsigned char **, unsigned short int *);
  // io_cancel
  signed int (*io_cancel)(struct usbi_io *);
  // get_driver_np
  signed int (*get_driver_np)(struct usbi_dev_handle *, unsigned char, char *, unsigned int);
  // attach_kernel_driver_np
  signed int (*attach_kernel_driver_np)(struct usbi_dev_handle *, unsigned char);
  // detach_kernel_driver_np
  signed int (*detach_kernel_driver_np)(struct usbi_dev_handle *, unsigned char);
};

struct usbi_backend_ops
{
  // backend_version
  signed int backend_version;
  // io_pattern
  signed int io_pattern;
  // init
  signed int (*init)(struct usbi_handle *, unsigned int);
  // fini
  void (*fini)(struct usbi_handle *);
  // find_buses
  signed int (*find_buses)(struct list_head *);
  // refresh_devices
  signed int (*refresh_devices)(struct usbi_bus *);
  // free_device
  void (*free_device)(struct usbi_device *);
  // dev
  struct usbi_device_ops dev;
};

struct usbi_list
{
  // head
  struct list_head head;
  // lock
  union anonymous lock;
};

struct usbi_bus
{
  // list
  struct list_head list;
  // lock
  union anonymous lock;
  // busid
  unsigned long int busid;
  // busnum
  unsigned int busnum;
  // sys_path
  char sys_path[4097l];
  // ops
  struct usbi_backend_ops *ops;
  // devices
  struct usbi_list devices;
  // root
  struct usbi_device *root;
  // max_xfer_size
  unsigned int max_xfer_size[5l];
  // priv
  struct usbi_bus_private *priv;
};

struct usbi_config
{
  // desc
  struct usb_config_desc desc;
  // num_interfaces
  unsigned long int num_interfaces;
  // interfaces
  struct usbi_interface *interfaces;
  // extra
  char *extra;
  // extralen
  unsigned long int extralen;
};

struct usbi_raw_desc
{
  // data
  unsigned char *data;
  // len
  unsigned long int len;
};

struct usbi_descriptors
{
  // device_raw
  struct usbi_raw_desc device_raw;
  // num_configs
  unsigned long int num_configs;
  // configs_raw
  struct usbi_raw_desc *configs_raw;
  // device
  struct usb_device_desc device;
  // configs
  struct usbi_config *configs;
};

struct usbi_dev_handle
{
  // list
  struct list_head list;
  // io_head
  struct list_head io_head;
  // m_head
  struct list_head m_head;
  // lib_hdl
  struct usbi_handle *lib_hdl;
  // handle
  unsigned long int handle;
  // idev
  struct usbi_device *idev;
  // flags
  enum openusb_init_flag flags;
  // claimed_ifs
  struct interface_set claimed_ifs[32l];
  // lock
  union anonymous lock;
  // event_pipe
  signed int event_pipe[2l];
  // state
  enum usbi_devstate state;
  // priv
  struct usbi_dev_hdl_private *priv;
};

struct usbi_device
{
  // dev_list
  struct list_head dev_list;
  // bus_list
  struct list_head bus_list;
  // match_list
  struct list_head match_list;
  // devid
  unsigned long int devid;
  // devnum
  unsigned int devnum;
  // bus_addr
  unsigned char bus_addr;
  // bus
  struct usbi_bus *bus;
  // parent
  struct usbi_device *parent;
  // pport
  unsigned char pport;
  // nports
  unsigned char nports;
  // sys_path
  char sys_path[4097l];
  // bus_path
  char bus_path[28l];
  // children
  struct usbi_device **children;
  // ops
  struct usbi_device_ops *ops;
  // cur_config_value
  unsigned char cur_config_value;
  // cur_config_index
  signed int cur_config_index;
  // priv
  struct usbi_dev_private *priv;
  // found
  signed int found;
  // desc
  struct usbi_descriptors desc;
};

struct usbi_endpoint
{
  // desc
  struct usb_endpoint_desc desc;
  // extra
  char *extra;
  // extralen
  unsigned short int extralen;
};

struct usbi_event_callback
{
  // func
  void (*func)(unsigned long int, unsigned long int, enum openusb_event, void *);
  // arg
  void *arg;
};

struct usbi_handle
{
  // list
  struct list_head list;
  // handle
  unsigned long int handle;
  // lock
  union anonymous lock;
  // debug_level
  unsigned int debug_level;
  // debug_flags
  unsigned int debug_flags;
  // debug_cb
  void (*debug_cb)(unsigned long int, const char *, void **);
  // event_cbs
  struct usbi_event_callback event_cbs[7l];
  // coldplug_complete
  unsigned char coldplug_complete;
  // coldplug_cv
  union anonymous_4 coldplug_cv;
  // complete_list
  struct list_head complete_list;
  // complete_lock
  union anonymous complete_lock;
  // complete_cv
  union anonymous_4 complete_cv;
  // complete_count
  signed int complete_count;
  // timeout
  unsigned int timeout[5l];
};

struct usbi_interface
{
  // num_altsettings
  unsigned long int num_altsettings;
  // altsettings
  struct usbi_altsetting *altsettings;
};

struct usbi_io
{
  // list
  struct list_head list;
  // lock
  union anonymous lock;
  // dev
  struct usbi_dev_handle *dev;
  // req
  struct openusb_request_handle *req;
  // status
  enum usbi_io_status status;
  // flag
  unsigned int flag;
  // callback
  void (*callback)(struct usbi_io *, signed int);
  // arg
  void *arg;
  // tvo
  struct timeval tvo;
  // timeout
  unsigned int timeout;
  // cond
  union anonymous_4 cond;
  // priv
  struct usbi_io_private *priv;
};

struct usbi_multi_req_args
{
  // mi_req
  struct usbi_multi_request *mi_req;
  // idx
  unsigned int idx;
  // req
  struct openusb_request_handle *req;
  // list
  struct list_head list;
};

struct usbi_multi_request
{
  // list
  struct list_head list;
  // req_head
  struct list_head req_head;
  // mreq
  struct openusb_multi_request_handle *mreq;
  // lock
  union anonymous lock;
  // cv
  union anonymous_4 cv;
  // flag
  signed int flag;
};


// backends
// file usb.c line 45
struct list_head backends;
// backends
// file usb.c line 45
struct list_head backends = { .prev=&backends, .next=&backends };
// bus
// file testopenusb.c line 30
unsigned long int *bus;
// busnum
// file testopenusb.c line 29
unsigned int busnum;
// callback_queue_full
// file usb.c line 105
signed int callback_queue_full = 0;
// cur_bus_id
// file devices.c line 22
static unsigned long int cur_bus_id = (unsigned long int)1;
// cur_dev_handle
// file usb.c line 40
static unsigned long int cur_dev_handle = (unsigned long int)1;
// cur_device_id
// file devices.c line 23
static unsigned long int cur_device_id = (unsigned long int)1;
// cur_handle
// file usb.c line 39
static unsigned long int cur_handle = (unsigned long int)1;
// devids
// file testopenusb.c line 27
unsigned long int *devids;
// devnum
// file testopenusb.c line 28
unsigned int devnum;
// errorstrs
// file usb.c line 1173
static struct errorstr errorstrs[29l] = { { .code=0, .msg="Call success" }, { .code=-1, .msg="Unspecified kernel/driver failure" },
    { .code=-2, .msg="No resources available" },
    { .code=-3, .msg="No bandwidth available" },
    { .code=-4, .msg="Not supported by HCD" },
    { .code=-5, .msg="USB host controller error" },
    { .code=-6, .msg="Privileged operation" },
    { .code=-7, .msg="Busy condition" }, { .code=-8, .msg="Invalid parameter" }, { .code=-9, .msg="Access to device denied" },
    { .code=-10, .msg="Data could not be parsed" },
    { .code=-11, .msg="Device id is stale or invalid" },
    { .code=-12, .msg="Handle is invalid" },
    { .code=-13, .msg="Call other system function failed" },
    { .code=-14, .msg="Can not find bus or device" },
    { .code=-50, .msg="Endpoint stalled" }, { .code=-51, .msg="CRC error" }, { .code=-52, .msg="Device hung" }, { .code=-53, .msg="Request too big" }, { .code=-54, .msg="Bit stuffing error" },
    { .code=-55, .msg="Unexpected PID" }, { .code=-56, .msg="Data overrun" }, { .code=-57, .msg="Data underrun" }, { .code=-58, .msg="Buffer overrun" }, { .code=-59, .msg="Buffer underrun" }, { .code=-60, .msg="PID check failure" },
    { .code=-61, .msg="Data toggle mismatch" },
    { .code=-62, .msg="I/O timeout" }, { .code=-63, .msg="I/O canceled" } };
// event_callback_cond
// file usb.c line 55
static union anonymous_4 event_callback_cond;
// event_callback_exit
// file usb.c line 56
static volatile signed int event_callback_exit = 0;
// event_callback_thread
// file usb.c line 54
static unsigned long int event_callback_thread;
// event_callbacks
// file usb.c line 51
static struct usbi_list event_callbacks;
// libhandle
// file testopenusb.c line 26
unsigned long int libhandle;
// m_buffers
// file testopenusb.c line 1013
unsigned char *m_buffers[12l];
// m_len
// file testopenusb.c line 1012
unsigned int m_len[12l];
// openusb_global_debug_level
// file usb.c line 38
static signed int openusb_global_debug_level = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// testasync
// file testopenusb.c line 35
signed int testasync = 0;
// testhotplug
// file testopenusb.c line 36
signed int testhotplug = 0;
// testloop
// file testopenusb.c line 32
signed int testloop = 0;
// testmulti
// file testopenusb.c line 33
signed int testmulti = 0;
// testsync
// file testopenusb.c line 34
signed int testsync = 0;
// testtype
// file testopenusb.c line 31
enum openusb_transfer_type testtype = (enum openusb_transfer_type)0;
// usb_busses
// file emulation.c line 40
struct usb_bus *usb_busses = (struct usb_bus *)(void *)0;
// usb_error_errno
// file emulation.c line 52
static signed int usb_error_errno;
// usb_error_string
// file emulation.c line 51
static char usb_error_string[1024l];
// usb_error_type
// file emulation.c line 53
static enum anonymous_1 usb_error_type = (enum anonymous_1)USB_ERROR_TYPE_NONE;
// usbi_buses
// file usb.c line 29
struct usbi_list usbi_buses;
// usbi_dev_handles
// file usb.c line 27
struct usbi_list usbi_dev_handles;
// usbi_devices
// file usb.c line 30
struct usbi_list usbi_devices;
// usbi_handles
// file usb.c line 26
struct usbi_list usbi_handles;
// usbi_inited
// file usb.c line 42
static signed int usbi_inited = 0;
// usbi_lock
// file usb.c line 43
static union anonymous usbi_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// wr_handle
// file emulation.c line 38
unsigned long int wr_handle = (unsigned long int)0;

// _usbi_debug
// file usb.c line 60
void _usbi_debug(struct usbi_handle *hdl, unsigned int level, const char *func, unsigned int line, const char *fmt, ...)
{
  char str[512l];
  void **ap;
  _Bool tmp_if_expr_1;
  if(!(hdl == ((struct usbi_handle *)NULL)) || (unsigned int)openusb_global_debug_level >= level)
  {
    if(!(hdl == ((struct usbi_handle *)NULL)))
    {
      pthread_mutex_lock(&hdl->lock);
      if(hdl->debug_level >= level)
        goto __CPROVER_DUMP_L2;

      pthread_mutex_unlock(&hdl->lock);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      ap = (void **)&fmt;
      if(!(hdl == ((struct usbi_handle *)NULL)))
        tmp_if_expr_1 = hdl->debug_cb != ((void (*)(unsigned long int, const char *, void **))NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        snprintf(str, sizeof(char [512l]) /*512ul*/ , "openusb: [%s:%d] %s", func, line, fmt);
        hdl->debug_cb(hdl->handle, str, ap);
      }

      else
      {
        vsnprintf(str, sizeof(char [512l]) /*512ul*/ , fmt, ap);
        fprintf(stderr, "openusb: [%s:%d] %s\n", func, line, (const void *)str);
      }
      ap = ((void **)NULL);
      if(!(hdl == ((struct usbi_handle *)NULL)))
        pthread_mutex_unlock(&hdl->lock);

    }
  }

}

// advance_xfer_test
// file testopenusb.c line 1194
static signed int advance_xfer_test(void)
{
  signed int ret = 0;
  unsigned long int devh;
  unsigned long int devid;
  unsigned long int libh;
  unsigned char cfg;
  unsigned char alt;
  ret=openusb_get_devids_by_class(libhandle, (signed short int)0xff, (signed short int)-1, (signed short int)-1, &devids, &devnum);
  if(!(ret >= 0))
  {
    const char *return_value_openusb_strerror_1;
    return_value_openusb_strerror_1=openusb_strerror(ret);
    printf("Error get devids by class: %s\n", return_value_openusb_strerror_1);
    return -1;
  }

  ret=openusb_open_device(libhandle, devids[(signed long int)0], (enum openusb_init_flag)0, &devh);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_2;
    return_value_openusb_strerror_2=openusb_strerror(ret);
    printf("Open device(%d) error: %s\n", (signed int)devids[(signed long int)0], return_value_openusb_strerror_2);
    goto err;
  }

  printf("Device(%llu) opened: %llu\n", (signed long long int)devids[(signed long int)0], (signed long long int)devh);
  ret=openusb_get_devid(devh, &devid);
  if(!(ret >= 0))
  {
    const char *return_value_openusb_strerror_3;
    return_value_openusb_strerror_3=openusb_strerror(ret);
    printf("Error get devids by handle: %s\n", return_value_openusb_strerror_3);
    goto err;
  }

  printf("devh=%x devid=%x\n", (signed int)devh, (signed int)devid);
  ret=openusb_get_lib_handle(devh, &libh);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_4;
    return_value_openusb_strerror_4=openusb_strerror(ret);
    printf("Get device(%llu) lib handle error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_4);
    goto err;
  }

  printf("Lib handle = %llu\n", (signed long long int)libh);
  if(testsync == 1)
  {
    ret=test_sync_xfer(devh);
    if(!(ret == 0))
      goto err;

  }

  if(testasync == 1)
  {
    ret=test_async_xfer(devh);
    if(!(ret == 0))
      goto err;

  }

  ret=openusb_set_configuration(devh, (unsigned char)1);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_5;
    return_value_openusb_strerror_5=openusb_strerror(ret);
    printf("Set device(%llu) config error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_5);
    goto err;
  }

  ret=openusb_get_configuration(devh, &cfg);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_6;
    return_value_openusb_strerror_6=openusb_strerror(ret);
    printf("Get device(%llu) config error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_6);
    goto err;
  }

  printf("Configuration= %d\n", cfg);
  ret=openusb_claim_interface(devh, (unsigned char)0, (enum openusb_init_flag)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_7;
    return_value_openusb_strerror_7=openusb_strerror(ret);
    printf("Device(%llu) claim interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_7);
    goto err;
  }

  ret=openusb_is_interface_claimed(devh, (unsigned char)0);
  printf("Device(%llu) interface(0) claimed return %d\n", (signed long long int)devids[(signed long int)0], ret);
  ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_8;
    return_value_openusb_strerror_8=openusb_strerror(ret);
    printf("Device(%llu) interface(0) set alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_8);
    goto err;
  }

  ret=openusb_get_altsetting(devh, (unsigned char)0, &alt);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_9;
    return_value_openusb_strerror_9=openusb_strerror(ret);
    printf("Device(%llu) interface(0) get alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_9);
    goto err;
  }

  printf("Interface(0) alt=%d\n", alt);
  ret=openusb_release_interface(devh, (unsigned char)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_10;
    return_value_openusb_strerror_10=openusb_strerror(ret);
    printf("Device(%llu) release interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_10);
    goto err;
  }


err:
  ;
  openusb_close_device(devh);
  openusb_free_devid_list(devids);
  return ret;
}

// async_callback
// file io.c line 344
static void async_callback(struct usbi_io *io, signed int status)
{
  simple_io_complete((struct simple_io *)io->arg, status);
}

// async_xfer_ctrl_test
// file testopenusb.c line 574
static signed int async_xfer_ctrl_test(unsigned long int devh)
{
  unsigned char bulkdata[128l];
  unsigned char bulkrd[128l];
  struct openusb_ctrl_request ctrl;
  signed int i;
  signed int ret;
  struct openusb_request_handle *req;
  struct openusb_request_handle *completed;
  memset((void *)&ctrl, 0, sizeof(struct openusb_ctrl_request) /*48ul*/ );
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    bulkdata[(signed long int)i] = (unsigned char)i;
  ctrl.setup.bmRequestType = (unsigned char)0x80;
  ctrl.setup.bRequest = (unsigned char)0x06;
  ctrl.setup.wValue = (unsigned short int)(0x02 << 8 | 0x01);
  ctrl.setup.wIndex = (unsigned short int)0;
  ctrl.length = (unsigned int)0xab;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)ctrl.length);
  ctrl.payload = (unsigned char *)return_value_malloc_1;
  if(ctrl.payload == ((unsigned char *)NULL))
  {
    printf("malloc fail\n");
    return -1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct openusb_request_handle) /*40ul*/ );
    req = (struct openusb_request_handle *)return_value_malloc_2;
    memset((void *)req, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
    req->dev = devh;
    req->interface = (unsigned char)0;
    req->endpoint = (unsigned char)0x00;
    req->type = (enum openusb_transfer_type)USB_TYPE_CONTROL;
    ret=openusb_claim_interface(devh, (unsigned char)0, (enum openusb_init_flag)0);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_3;
      return_value_openusb_strerror_3=openusb_strerror(ret);
      printf("Device(%llu) claim interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_3);
      return -1;
    }

    ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)0);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_4;
      return_value_openusb_strerror_4=openusb_strerror(ret);
      printf("Device(%llu) interface(0) set alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_4);
      return -1;
    }

    req->req.ctrl = &ctrl;
    ret=openusb_xfer_aio(req);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_5;
      return_value_openusb_strerror_5=openusb_strerror(ret);
      printf("xfer fail: %s\n", return_value_openusb_strerror_5);
      return -1;
    }

    ret=openusb_wait((unsigned int)1, &req, &completed);
    if(!(ret >= 0))
    {
      const char *return_value_openusb_strerror_6;
      return_value_openusb_strerror_6=openusb_strerror(ret);
      printf("Ctrl async xfer fail: %s\n", return_value_openusb_strerror_6);
      return -1;
    }

    printf("ASYNC xfer write\n");
    printf("ctrl result.status = %d, xfer_bytes=%d, ret=%d\n", completed->req.ctrl->result.status, completed->req.ctrl->result.transferred_bytes, ret);
    req->endpoint = (unsigned char)0x00;
    ctrl.payload = bulkrd;
    req->req.ctrl = &ctrl;
    ret=openusb_xfer_aio(req);
    if(!(ret == 0))
      printf("result.status = %d,xfer_bytes=%d, ret=%d\n", ctrl.result.status, ctrl.result.transferred_bytes, ret);

    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_7;
      return_value_openusb_strerror_7=openusb_strerror(ret);
      printf("Ctrl async xfer fail: %s\n", return_value_openusb_strerror_7);
      return -1;
    }

    while((_Bool)1)
    {
      ret=openusb_poll((unsigned int)1, &req, &completed);
      if(!(ret == 0))
      {
        const char *return_value_openusb_strerror_8;
        return_value_openusb_strerror_8=openusb_strerror(ret);
        printf("async xfer poll: %s\n", return_value_openusb_strerror_8);
        return -1;
      }

      if(!(completed == ((struct openusb_request_handle *)NULL)))
      {
        printf("Polling a data\n");
        break;
      }

      printf("Polling......\n");
      sleep((unsigned int)1);
    }
    printf("\nCTRL ASYNC DATA:\n");
    i = 0;
    for( ; !(i >= 128); i = i + 1)
    {
      if(i % 16 == 0)
        printf("\n");

      printf("%02x ", (unsigned char)completed->req.ctrl->payload[(signed long int)i]);
    }
    printf("\n");
    return 0;
  }
}

// async_xfer_test
// file testopenusb.c line 695
static signed int async_xfer_test(unsigned long int devh, enum openusb_transfer_type type, signed int flag)
{
  unsigned char bulkdata[128l];
  unsigned char bulkrd[128l];
  unsigned char isocrd[1536l];
  struct openusb_bulk_request bulk;
  struct openusb_intr_request intr;
  struct openusb_isoc_request isoc;
  signed int i;
  signed int ret = -1;
  signed int count;
  struct openusb_request_handle *req;
  struct openusb_request_handle *req1;
  struct openusb_request_handle *reqs[3l];
  struct openusb_request_handle *completed;
  signed int loopcnt;
  void *return_value_malloc_9;
  void *return_value_calloc_10;
  if(!((signed int)type == USB_TYPE_INTERRUPT) && !((signed int)type == USB_TYPE_BULK) && !((signed int)type == USB_TYPE_ISOCHRONOUS))
    return 0;

  else
  {
    count = 0;
    memset((void *)&bulk, 0, sizeof(struct openusb_bulk_request) /*40ul*/ );
    memset((void *)&intr, 0, sizeof(struct openusb_intr_request) /*48ul*/ );
    memset((void *)&isoc, 0, sizeof(struct openusb_isoc_request) /*48ul*/ );
    i = 0;
    for( ; !(i >= 128); i = i + 1)
      bulkdata[(signed long int)i] = (unsigned char)(i + 2);
    i = 0;
    for( ; !(i >= 12); i = i + 1)
      isocrd[(signed long int)i] = (unsigned char)(i + 2);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct openusb_request_handle) /*40ul*/ );
    req = (struct openusb_request_handle *)return_value_malloc_1;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct openusb_request_handle) /*40ul*/ );
    req1 = (struct openusb_request_handle *)return_value_malloc_2;
    memset((void *)req, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
    memset((void *)req1, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
    req->dev = devh;
    req->interface = (unsigned char)0;
    req->endpoint = (unsigned char)0x02;
    req->type = type;
    memset((void *)&bulk, 0, sizeof(struct openusb_bulk_request) /*40ul*/ );
    bulk.payload = bulkdata;
    bulk.length = (unsigned int)128;
    bulk.timeout = (unsigned int)0;
    intr.payload = bulkdata;
    intr.length = (unsigned int)128;
    ret=openusb_claim_interface(devh, (unsigned char)0, (enum openusb_init_flag)0);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_3;
      return_value_openusb_strerror_3=openusb_strerror(ret);
      printf("Device(%llu) claim interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_3);
      return -1;
    }

    if((signed int)type == USB_TYPE_INTERRUPT || (signed int)type == USB_TYPE_BULK)
      ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)0);

    else
      if((signed int)type == USB_TYPE_ISOCHRONOUS)
        ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)3);

    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_4;
      return_value_openusb_strerror_4=openusb_strerror(ret);
      printf("Device(%llu) interface(0) set alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_4);
      return -1;
    }

    if(flag == 1)
    {
      if((signed int)type == USB_TYPE_BULK)
      {
        req->req.bulk = &bulk;
        ret=openusb_xfer_aio(req);
      }

      else
        if((signed int)type == USB_TYPE_INTERRUPT)
        {
          req->req.intr = &intr;
          ret=openusb_xfer_aio(req);
        }

        else
          if((signed int)type == USB_TYPE_ISOCHRONOUS)
          {
            signed int pktsize = (signed int)sizeof(struct openusb_isoc_packet) /*16ul*/ ;
            void *return_value_malloc_5;
            return_value_malloc_5=malloc((unsigned long int)(pktsize * 12));
            isoc.pkts.packets = (struct openusb_isoc_packet *)return_value_malloc_5;
            i = 0;
            for( ; !(i >= 12); i = i + 1)
            {
              (isoc.pkts.packets + (signed long int)i)->length = (unsigned int)128;
              (isoc.pkts.packets + (signed long int)i)->payload = isocrd + (signed long int)(128 * i);
            }
            isoc.pkts.num_packets = (unsigned int)12;
            void *return_value_malloc_6;
            return_value_malloc_6=malloc(sizeof(struct openusb_request_result) /*8ul*/  * (unsigned long int)12);
            isoc.isoc_results = (struct openusb_request_result *)return_value_malloc_6;
            if(isoc.isoc_results == ((struct openusb_request_result *)NULL))
              return -1;

            memset((void *)isoc.isoc_results, 0, sizeof(struct openusb_request_result) /*8ul*/  * (unsigned long int)12);
            req->req.isoc = &isoc;
            req->interface = (unsigned char)0;
            req->endpoint = (unsigned char)0x82;
            ret=openusb_xfer_aio(req);
          }

          else
            ret = -1;
      switch((signed int)type)
      {
        case USB_TYPE_BULK:
        {
          printf("bulk result.status=%d,xfer_bytes=%d,ret=%d\n", bulk.result.status, bulk.result.transferred_bytes, ret);
          break;
        }
        case USB_TYPE_INTERRUPT:
          printf("intr result.status=%d,xfer_bytes=%d,ret=%d\n", intr.result.status, intr.result.transferred_bytes, ret);
      }
      if(!(ret == 0))
      {
        const char *return_value_openusb_strerror_7;
        return_value_openusb_strerror_7=openusb_strerror(ret);
        printf("xfer fail: %s\n", return_value_openusb_strerror_7);
        return -1;
      }

      ret=openusb_wait((unsigned int)1, &req, &completed);
      if(!(ret >= 0))
      {
        const char *return_value_openusb_strerror_8;
        return_value_openusb_strerror_8=openusb_strerror(ret);
        printf("Async xfer fail: %s\n", return_value_openusb_strerror_8);
        return -1;
      }

      printf("ASYNC xfer write\n");
    }

    switch((signed int)type)
    {
      case USB_TYPE_BULK:
      {
        req->endpoint = (unsigned char)0x86;
        bulk.payload = bulkrd;
        req->req.bulk = &bulk;
        ret=openusb_xfer_aio(req);
        break;
      }
      case USB_TYPE_INTERRUPT:
      {
        intr.payload = bulkrd;
        req->req.intr = &intr;
        req->endpoint = (unsigned char)0x86;
        ret=openusb_xfer_aio(req);
        if(!(ret == 0))
          return -1;

        memcpy((void *)req1, (const void *)req, sizeof(struct openusb_request_handle) /*40ul*/ );
        ret=openusb_xfer_aio(req1);
        break;
      }
      case USB_TYPE_ISOCHRONOUS:
      {
        return_value_malloc_9=malloc(sizeof(struct openusb_isoc_packet) /*16ul*/  * (unsigned long int)12);
        isoc.pkts.packets = (struct openusb_isoc_packet *)return_value_malloc_9;
        i = 0;
        for( ; !(i >= 12); i = i + 1)
        {
          (isoc.pkts.packets + (signed long int)i)->length = (unsigned int)128;
          (isoc.pkts.packets + (signed long int)i)->payload = isocrd + (signed long int)(128 * i);
        }
        isoc.pkts.num_packets = (unsigned int)12;
        return_value_calloc_10=calloc(sizeof(struct openusb_request_result) /*8ul*/  * (unsigned long int)12, (unsigned long int)1);
        isoc.isoc_results = (struct openusb_request_result *)return_value_calloc_10;
        if(isoc.isoc_results == ((struct openusb_request_result *)NULL))
          return -1;

        req->req.isoc = &isoc;
        req->interface = (unsigned char)0;
        req->endpoint = (unsigned char)0x82;
        ret=openusb_xfer_aio(req);
        if(!(ret == 0))
        {
          const char *return_value_openusb_strerror_11;
          return_value_openusb_strerror_11=openusb_strerror(ret);
          printf("ret=%d(%s)\n", ret, return_value_openusb_strerror_11);
        }

        memcpy((void *)req1, (const void *)req, sizeof(struct openusb_request_handle) /*40ul*/ );
        ret=openusb_xfer_aio(req1);
        if(!(ret == 0))
        {
          const char *return_value_openusb_strerror_12;
          return_value_openusb_strerror_12=openusb_strerror(ret);
          printf("ret=%d(%s)\n", ret, return_value_openusb_strerror_12);
        }

        break;
      }
      default:
        ret = -1;
    }
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_13;
      return_value_openusb_strerror_13=openusb_strerror(ret);
      printf("async xfer fail: %s\n", return_value_openusb_strerror_13);
      return -1;
    }

    reqs[(signed long int)0] = req;
    reqs[(signed long int)1] = req1;
    reqs[(signed long int)2] = (struct openusb_request_handle *)(void *)0;
    i = 0;
    printf("req1=%p, req2=%p\n", reqs[(signed long int)0], reqs[(signed long int)1]);
    if(flag == 1)
      loopcnt = 1;

    else
      loopcnt = 2;
    while(!(count >= loopcnt))
    {
      ret=openusb_poll((unsigned int)loopcnt, reqs, &completed);
      if(!(ret == 0))
      {
        const char *return_value_openusb_strerror_14;
        return_value_openusb_strerror_14=openusb_strerror(ret);
        printf("async xfer poll: %s\n", return_value_openusb_strerror_14);
        return -1;
      }

      if(completed == ((struct openusb_request_handle *)NULL))
      {
        printf("Polling no data\n");
        sleep((unsigned int)1);
      }

      else
      {
        printf("Polling...... %d\n", count);
        sleep((unsigned int)1);
        count = count + 1;
        printf("\nINTR/BULK/ISOC ASYNC DATA:\n");
        if((signed int)type == USB_TYPE_INTERRUPT || (signed int)type == USB_TYPE_BULK)
        {
          unsigned char *p;
          if((signed int)type == USB_TYPE_INTERRUPT)
            p = (unsigned char *)completed->req.intr->payload;

          else
            p = (unsigned char *)completed->req.bulk->payload;
          i = 0;
          for( ; !(i >= 128); i = i + 1)
          {
            if((1 + i) % 16 == 0)
              printf("\n");

            printf("%02x ", p[(signed long int)i]);
          }
        }

        else
          if((signed int)type == USB_TYPE_ISOCHRONOUS)
          {
            signed int j;
            i = 0;
            for( ; !(i >= 12); i = i + 1)
            {
              unsigned char *async_xfer_test__1__11__4__1__1__p;
              unsigned char status;
              unsigned int bytes;
              if(completed == ((struct openusb_request_handle *)NULL))
              {
                printf("NULL completed\n");
                break;
              }

              printf("\nISOC packet: %d STATUS\n", i);
              status = (unsigned char)(completed->req.isoc->isoc_results + (signed long int)i)->status;
              printf("\tstatus=%d\n", status);
              bytes = (completed->req.isoc->isoc_results + (signed long int)i)->transferred_bytes;
              printf("\tTbytes=%d\n", bytes);
              printf("\n");
              printf("ISOC packet: %d DATA\n", i);
              async_xfer_test__1__11__4__1__1__p = (completed->req.isoc->pkts.packets + (signed long int)i)->payload;
              j = 0;
              for( ; !(j >= 128); j = j + 1)
              {
                if(j % 16 == 0)
                  printf("\n");

                printf("%02x ", (unsigned char)async_xfer_test__1__11__4__1__1__p[(signed long int)j]);
              }
            }
          }

      }
    }
    printf("\n");
    return 0;
  }
}

// basic_test
// file testopenusb.c line 1422
static signed int basic_test(void)
{
  signed int ret;
  unsigned int flags = (unsigned int)0;
  ret=openusb_init(flags, &libhandle);
  if(!(ret >= 0))
  {
    const char *return_value_openusb_strerror_1;
    return_value_openusb_strerror_1=openusb_strerror(ret);
    printf("error init: %s (%d)\n", return_value_openusb_strerror_1, ret);
    exit(1);
  }

  printf("lib handle=%llu \n", (signed long long int)libhandle);
  printf("openusb_init PASS\n");
  ret=openusb_set_event_callback(libhandle, (enum openusb_event)USB_ATTACH, event_cb, (void *)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_2;
    return_value_openusb_strerror_2=openusb_strerror(ret);
    printf("set event callback error: %s\n", return_value_openusb_strerror_2);
    return -1;
  }

  ret=openusb_set_event_callback(libhandle, (enum openusb_event)USB_REMOVE, event_cb, (void *)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_3;
    return_value_openusb_strerror_3=openusb_strerror(ret);
    printf("set event callback error: %s\n", return_value_openusb_strerror_3);
    return -1;
  }

  printf("openusb_set_event_callback: PASS\n");
  ret=openusb_set_default_timeout(libhandle, (enum openusb_transfer_type)USB_TYPE_CONTROL, (unsigned int)10);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_4;
    return_value_openusb_strerror_4=openusb_strerror(ret);
    printf("set timeout error: %s\n", return_value_openusb_strerror_4);
    return -1;
  }

  printf("openusb_set_default_timeout: PASS\n");
  ret=openusb_get_busid_list(libhandle, &bus, &busnum);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_5;
    return_value_openusb_strerror_5=openusb_strerror(ret);
    printf("busid error: %s\n", return_value_openusb_strerror_5);
    return -1;
  }

  printf("openusb_get_busid_list: PASS\n");
  test_get_device_data();
  return 0;
}

// check_req_valid
// file api.c line 379
static signed int check_req_valid(struct openusb_request_handle *req, struct usbi_dev_handle *dev)
{
  enum openusb_transfer_type type = req->type;
  unsigned char ifc = req->interface;
  unsigned char endpoint = req->endpoint;
  unsigned char cfg;
  unsigned char alt;
  signed int ret = 0;
  struct usb_endpoint_desc *pdesc = (struct usb_endpoint_desc *)(void *)0;
  signed int i;
  struct usb_interface_desc if_desc;
  struct usb_endpoint_desc ep_desc;
  char *buf;
  signed int buflen;
  if((signed int)type == USB_TYPE_CONTROL && (signed int)endpoint == 0)
    return 0;

  else
    if((signed int)endpoint == 0)
      return -1;

  if(!(dev->lib_hdl->debug_level >= 5u))
  {
    signed int return_value_openusb_is_interface_claimed_1;
    return_value_openusb_is_interface_claimed_1=openusb_is_interface_claimed(dev->handle, ifc);
    if(return_value_openusb_is_interface_claimed_1 == 1)
      return 0;

    else
    {
      _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)413, "interface %d not claimed", ifc);
      return -1;
    }
  }

  ret=openusb_get_configuration(dev->handle, &cfg);
  if(!(ret >= 0))
  {
    _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)421, "fail get current config");
    return ret;
  }

  else
  {
    ret=openusb_get_altsetting(dev->handle, ifc, &alt);
    if(!(ret >= 0))
    {
      _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)428, "fail get current altsetting");
      return ret;
    }

    else
    {
      ret=usbi_get_config_desc(dev, (signed int)cfg, &buf, &buflen);
      if(!(ret >= 0))
      {
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "check_req_valid", (unsigned int)444, "get raw descriptor fail");
        return ret;
      }

      else
      {
        ret=openusb_parse_interface_desc(dev->lib_hdl->handle, dev->idev->devid, (unsigned char *)buf, (unsigned short int)buflen, (unsigned char)((signed int)cfg - 1), ifc, alt, &if_desc);
        if(!(ret >= 0))
        {
          usbi_free_cfg(buf);
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)455, "parse interface desc error");
          return ret;
        }

        else
        {
          i = 0;
          for( ; !(i >= (signed int)if_desc.bNumEndpoints); i = i + 1)
          {
            ret=openusb_parse_endpoint_desc(dev->lib_hdl->handle, dev->idev->devid, (unsigned char *)buf, (unsigned short int)buflen, (unsigned char)((signed int)cfg - 1), ifc, alt, (unsigned char)i, &ep_desc);
            if(!(ret >= 0))
            {
              usbi_free_cfg(buf);
              _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)468, "parse endpoint desc error");
              return ret;
            }

            if(endpoint == ep_desc.bEndpointAddress)
              break;

          }
          if(i == (signed int)if_desc.bNumEndpoints)
          {
            _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)479, "Invalid endpoint in request");
            usbi_free_cfg(buf);
            return -12;
          }

          else
          {
            pdesc = &ep_desc;
            switch((signed int)type)
            {
              case USB_TYPE_CONTROL:
              {
                if(!((0x03 & (signed int)pdesc->bmAttributes) == 0))
                {
                  _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)490, "invalid type");
                  ret = -12;
                }

                break;
              }
              case USB_TYPE_INTERRUPT:
              {
                if(!((0x03 & (signed int)pdesc->bmAttributes) == 3))
                {
                  _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)497, "invalid type");
                  ret = -12;
                }

                break;
              }
              case USB_TYPE_BULK:
              {
                if(!((0x03 & (signed int)pdesc->bmAttributes) == 2))
                {
                  _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)504, "invalid type");
                  ret = -12;
                }

                break;
              }
              case USB_TYPE_ISOCHRONOUS:
              {
                if(!((0x03 & (signed int)pdesc->bmAttributes) == 1))
                {
                  _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)511, "invalid type");
                  ret = -12;
                }

                break;
              }
              default:
              {
                _usbi_debug(dev->lib_hdl, (unsigned int)1, "check_req_valid", (unsigned int)516, "unknown type");
                ret = -12;
              }
            }
            usbi_free_cfg(buf);
            return ret;
          }
        }
      }
    }
  }
}

// cleanup
// file testopenusb.c line 1470
static void cleanup(void)
{
  openusb_free_busid_list(bus);
  openusb_fini(libhandle);
  printf("openusb_fini PASS\n");
}

// convert_string
// file testopenusb.c line 198
static signed int convert_string(char *buf, struct usb_string_desc *st, signed int buflen)
{
  signed int di;
  signed int si;
  unsigned char *tbuf = (unsigned char *)st;
  di = 0;
  si = 2;
  signed int tmp_post_1;
  signed int tmp_post_2;
  for( ; !(si >= (signed int)*tbuf); si = si + 2)
  {
    if(di >= buflen + -1)
      break;

    if(!(tbuf[(signed long int)(1 + si)] == 0))
    {
      tmp_post_1 = di;
      di = di + 1;
      buf[(signed long int)tmp_post_1] = (char)63;
    }

    else
    {
      tmp_post_2 = di;
      di = di + 1;
      buf[(signed long int)tmp_post_2] = (char)tbuf[(signed long int)si];
    }
  }
  buf[(signed long int)di] = (char)0;
  return di;
}

// dump_dev_data
// file testopenusb.c line 220
static void dump_dev_data(struct openusb_dev_data *pdev)
{
  struct usb_device_desc *pdesc;
  signed int i;
  char buf[256l];
  if(pdev == ((struct openusb_dev_data *)NULL))
    printf("Null dev\n");

  printf("busid: 0x%x, devid: 0x%x, bus_addr:0x%x, pdevid: 0x%x, pport: %d, nports: %d\n", (signed int)pdev->busid, (signed int)pdev->devid, pdev->bus_address, (signed int)pdev->pdevid, pdev->pport, pdev->nports);
  printf("sys_path: %s\n", pdev->sys_path);
  printf("bus_path: %s\n", pdev->bus_path);
  pdesc = &pdev->dev_desc;
  printf("Device descriptor:\n");
  printf("\tclass: %02x subclass: %02x vid: %04hx pid: %04hx\n", pdesc->bDeviceClass, pdesc->bDeviceSubClass, pdesc->idVendor, pdesc->idProduct);
  printf("\n");
  printf("Config descriptor:\n");
  printf("\ttype:0x%02x len=%d totalLen = %d\n", pdev->cfg_desc.bDescriptorType, pdev->cfg_desc.bLength, pdev->cfg_desc.wTotalLength);
  if(!(pdev->manufacturer == ((struct usb_string_desc *)NULL)))
  {
    convert_string(buf, pdev->manufacturer, 256);
    printf("manufacturer: %s\n", (const void *)buf);
  }

  if(!(pdev->product == ((struct usb_string_desc *)NULL)))
  {
    convert_string(buf, pdev->product, 256);
    printf("prod: %s\n", (const void *)buf);
  }

  if(!(pdev->serialnumber == ((struct usb_string_desc *)NULL)))
  {
    convert_string(buf, pdev->serialnumber, 256);
    printf("serial: %s\n", (const void *)buf);
  }

  printf("MAX Xfer size:\n");
  printf("CTRL = 0x%x, INTR = 0x%x, BULK = 0x%x, ISOC = 0x%x\n", pdev->ctrl_max_xfer_size, pdev->intr_max_xfer_size, pdev->bulk_max_xfer_size, pdev->isoc_max_xfer_size);
  printf("\nRAW descriptor:\n");
  if(!(pdev->raw_cfg_desc == ((unsigned char *)NULL)))
  {
    i = 0;
    for( ; !(i >= (signed int)pdev->cfg_desc.wTotalLength); i = i + 1)
    {
      if(i % 16 == 0)
        printf("\n");

      printf("%02x ", pdev->raw_cfg_desc[(signed long int)i]);
    }
  }

  printf("\n");
}

// event_cb
// file testopenusb.c line 164
static void event_cb(unsigned long int handle, unsigned long int devid, enum openusb_event event, void *arg)
{
  const char *evstring;
  switch((signed int)event)
  {
    case USB_ATTACH:
    {
      evstring = "USB_ATTACH";
      break;
    }
    case USB_REMOVE:
    {
      evstring = "USB_REMOVE";
      break;
    }
    case USB_SUSPEND:
    {
      evstring = "USB_SUSPEND";
      break;
    }
    case USB_RESUME:
    {
      evstring = "USB_RESUME";
      break;
    }
    case USB_HC_ATTACH:
    {
      evstring = "USB_HC_ATTACH";
      break;
    }
    case USB_HC_REMOVE:
    {
      evstring = "USB_HC_REMOVE";
      break;
    }
    case USB_COLDPLUG_COMPLETED:
    {
      evstring = "USB_COLDPLUG_COMPLETED";
      break;
    }
    default:
      evstring = "Unknown";
  }
  printf("CALLBACK: lib(%llu) device(%llu) get a event(%s) with arg=%p\n", (signed long long int)handle, (signed long long int)devid, evstring, arg);
}

// io_submit
// file io.c line 418
static void * io_submit(void *arg)
{
  struct usbi_io *iop = (struct usbi_io *)arg;
  signed int ret;
  struct usbi_dev_handle *dev;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  _usbi_debug(iop->dev->lib_hdl, (unsigned int)4, "io_submit", (unsigned int)424, "Begin: TID= %d", return_value_pthread_self_1);
  if(iop == ((struct usbi_io *)NULL))
    return (void *)0;

  else
  {
    list_del(&iop->list);
    ret=usbi_sync_submit(iop);
    if(!(iop->req->cb == ((signed int (*)(struct openusb_request_handle *))NULL)))
    {
      _usbi_debug(iop->dev->lib_hdl, (unsigned int)4, "io_submit", (unsigned int)436, "callback get called");
      iop->req->cb(iop->req);
      usbi_free_io(iop);
    }

    else
    {
      dev = iop->dev;
      _usbi_debug(dev->lib_hdl, (unsigned int)4, "io_submit", (unsigned int)448, "lib_hdl = %p,io = %p, cv=%p, lock=%p", dev->lib_hdl, iop, &dev->lib_hdl->complete_cv, &dev->lib_hdl->complete_lock);
      pthread_mutex_lock(&dev->lib_hdl->complete_lock);
      list_add(&iop->list, &dev->lib_hdl->complete_list);
      dev->lib_hdl->complete_count = dev->lib_hdl->complete_count + 1;
      pthread_cond_signal(&dev->lib_hdl->complete_cv);
      pthread_mutex_unlock(&dev->lib_hdl->complete_lock);
    }
    return (void *)0;
  }
}

// list_add
// file list.h line 10
void list_add(struct list_head *entry, struct list_head *head)
{
  entry->next = head;
  entry->prev = head->prev;
  head->prev->next = entry;
  head->prev = entry;
}

// list_del
// file list.h line 11
void list_del(struct list_head *entry)
{
  _Bool tmp_if_expr_1;
  if(entry->prev == ((struct list_head *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = entry->next == (struct list_head *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    entry->next->prev = entry->prev;
    entry->prev->next = entry->next;
    entry->prev = (struct list_head *)(void *)0;
    entry->next = (struct list_head *)(void *)0;
  }

}

// list_init
// file list.h line 9
void list_init(struct list_head *entry)
{
  entry->next = entry;
  entry->prev = entry->next;
}

// load_backend
// file usb.c line 209
static signed int load_backend(const char *filepath)
{
  struct usbi_backend *backend;
  struct usbi_backend_ops *ops;
  signed int version;
  signed int io_pattern;
  void *handle;
  handle=dlopen(filepath, 0x00001);
  if(handle == NULL)
  {
    char *return_value_dlerror_1;
    return_value_dlerror_1=dlerror();
    fprintf(stderr, "dlerror: %s\n", return_value_dlerror_1);
    goto err;
  }

  void *return_value_dlsym_2;
  return_value_dlsym_2=dlsym(handle, "backend_ops");
  ops = (struct usbi_backend_ops *)return_value_dlsym_2;
  void *return_value_calloc_3;
  if(ops == ((struct usbi_backend_ops *)NULL))
    fprintf(stderr, "no backend ops, skipping\n");

  else
  {
    io_pattern = ops->io_pattern;
    if(io_pattern >= 5 || !(io_pattern >= 1))
      fprintf(stderr, "backend io pattern is %d,not a valid pattern\n", io_pattern);

    else
    {
      version = ops->backend_version;
      if(!(version == 1))
        fprintf(stderr, "backend is API version %d, we need version 1\n", version);

      else
      {
        return_value_calloc_3=calloc(sizeof(struct usbi_backend) /*4136ul*/ , (unsigned long int)1);
        backend = (struct usbi_backend *)return_value_calloc_3;
        if(backend == ((struct usbi_backend *)NULL))
          fprintf(stderr, "couldn't allocate memory for backend\n");

        else
        {
          strncpy(backend->filepath, filepath, (unsigned long int)4096);
          backend->handle = handle;
          backend->ops = ops;
          list_add(&backend->list, &backends);
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "load_backend", (unsigned int)255, "load backend");
          return 0;
        }
      }
    }
  }

err:
  ;
  dlclose(handle);
  return 1;
}

// load_backends
// file usb.c line 269
static signed int load_backends(const char *dirpath)
{
  char filepath[4096l];
  struct dirent *entry;
  struct __dirstream *dir;
  signed int err_load = 0;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "load_backends", (unsigned int)276, "open dirpath %s", dirpath);
  dir=opendir(dirpath);
  if(dir == ((struct __dirstream *)NULL))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "load_backends", (unsigned int)279, "fail open %s", dirpath);
    return -1;
  }

  else
  {
    do
    {
      entry=readdir(dir);
      if(entry == ((struct dirent *)NULL))
        break;

      struct usbi_backend *backend;
      signed int found = 0;
      char *p;
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "load_backends", (unsigned int)288, "backend entry %s", (const void *)entry->d_name);
      p=strchr(entry->d_name, 0);
      if(p - entry->d_name >= 3l)
      {
        signed int return_value_strncmp_1;
        return_value_strncmp_1=strncmp(entry->d_name, "lib", (unsigned long int)3);
        if(!(return_value_strncmp_1 == 0))
        {
          signed int return_value_strcmp_2;
          return_value_strcmp_2=strcmp(p - (signed long int)3, ".so");
          if(return_value_strcmp_2 == 0)
          {
            snprintf(filepath, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", dirpath, (const void *)entry->d_name);
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "load_backends", (unsigned int)306, "find backend path %s", (const void *)filepath);
            backend = (struct usbi_backend *)((char *)(&backends)->next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
            for( ; !(&backend->list == &backends); backend = (struct usbi_backend *)((char *)backend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list))
              if(!(backend == ((struct usbi_backend *)NULL)))
              {
                signed int return_value_strcmp_3;
                return_value_strcmp_3=strcmp(filepath, backend->filepath);
                if(return_value_strcmp_3 == 0)
                {
                  found = 1;
                  break;
                }

              }

            if(found == 0)
            {
              signed int return_value_load_backend_4;
              return_value_load_backend_4=load_backend(filepath);
              if(!(return_value_load_backend_4 == 0))
              {
                err_load = err_load + 1;
                fprintf(stderr, "fail to load %s\n", (const void *)filepath);
              }

            }

          }

        }

      }

    }
    while((_Bool)1);
    closedir(dir);
    return err_load;
  }
}

// main
// file testopenusb.c line 1479
signed int main(signed int argc, char **argv)
{
  signed int ret;
  signed int return_value_parse_option_1;
  return_value_parse_option_1=parse_option(argc, argv);
  if(!(return_value_parse_option_1 >= 0))
    exit(1);

  ret=basic_test();
  if(!(ret >= 0))
    exit(1);

  advance_xfer_test();
  if(testhotplug == 1)
    pause();

  cleanup();
  exit(0);
}

// multi_req_callback
// file api.c line 1099
static signed int multi_req_callback(struct openusb_request_handle *req)
{
  struct openusb_multi_request_handle *mreq;
  struct usbi_multi_request *mi_req;
  unsigned int len = (unsigned int)0;
  struct openusb_request_result *result;
  enum openusb_transfer_type type;
  struct openusb_multi_isoc_request *isoc;
  unsigned int idx = (unsigned int)0;
  struct usbi_multi_req_args *args = (struct usbi_multi_req_args *)req->arg;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "multi_req_callback", (unsigned int)1111, "args = %p", args);
  list_del(&args->list);
  mi_req = (struct usbi_multi_request *)args->mi_req;
  if(mi_req == ((struct usbi_multi_request *)NULL))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "multi_req_callback", (unsigned int)1117, "Invalid multi-request handle");
    return -12;
  }

  else
  {
    idx = args->idx;
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "multi_req_callback", (unsigned int)1123, "Idx = %d", idx);
    mreq = mi_req->mreq;
    if(mreq == ((struct openusb_multi_request_handle *)NULL))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "multi_req_callback", (unsigned int)1127, "Multi-Req NULL");
      return -12;
    }

    else
    {
      type = mreq->type;
      if((signed int)type == USB_TYPE_INTERRUPT || (signed int)type == USB_TYPE_BULK)
        len = (unsigned int)sizeof(struct openusb_request_result) /*8ul*/ ;

      else
        if((signed int)type == USB_TYPE_ISOCHRONOUS)
        {
          isoc = mreq->req.isoc;
          len = (unsigned int)(sizeof(struct openusb_request_result) /*8ul*/  * (unsigned long int)(isoc->pkts + (signed long int)idx)->num_packets);
        }

      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)len, (unsigned long int)1);
      result = (struct openusb_request_result *)return_value_calloc_1;
      if(result == ((struct openusb_request_result *)NULL))
        return -2;

      else
      {
        if((signed int)type == USB_TYPE_BULK)
          memcpy((void *)result, (const void *)&req->req.bulk->result, (unsigned long int)len);

        else
          if((signed int)type == USB_TYPE_INTERRUPT)
            memcpy((void *)result, (const void *)&req->req.intr->result, (unsigned long int)len);

          else
            if((signed int)type == USB_TYPE_ISOCHRONOUS)
              memcpy((void *)result, (const void *)req->req.isoc->isoc_results, (unsigned long int)len);

        free((void *)req);
        free((void *)args);
        if(!(mreq->cb == ((signed int (*)(struct openusb_multi_request_handle *, unsigned int, struct openusb_request_result *))NULL)))
        {
          signed int return_value;
          return_value=mreq->cb(mreq, idx, result);
          return return_value;
        }

        free((void *)result);
        return 0;
      }
    }
  }
}

// openusb_abort
// file usb.c line 1048
signed int openusb_abort(struct openusb_request_handle *phdl)
{
  struct usbi_dev_handle *hdev;
  struct usbi_io *io;
  struct usbi_io *tio;
  signed int ret = -1;
  char buf[1l] = { (char)1 };
  if(phdl == ((struct openusb_request_handle *)NULL))
    return -12;

  else
  {
    pthread_mutex_lock(&usbi_dev_handles.lock);
    hdev = (struct usbi_dev_handle *)((char *)(&usbi_dev_handles.head)->next - (signed long int)(unsigned long int)&((struct usbi_dev_handle *)0L)->list);
    for( ; !(&hdev->list == &usbi_dev_handles.head); hdev = (struct usbi_dev_handle *)((char *)hdev->list.next - (signed long int)(unsigned long int)&((struct usbi_dev_handle *)0L)->list))
      if(!(hdev == ((struct usbi_dev_handle *)NULL)))
      {
        pthread_mutex_unlock(&usbi_dev_handles.lock);
        pthread_mutex_lock(&hdev->lock);
        io = (struct usbi_io *)((char *)(&hdev->io_head)->next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
        tio = (struct usbi_io *)((char *)io->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
        for( ; !(&io->list == &hdev->io_head); tio = (struct usbi_io *)((char *)tio->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list))
        {
          if(io->req == phdl)
          {
            ret=hdev->idev->ops->io_cancel(io);
            if(!(ret == 0))
              _usbi_debug(hdev->lib_hdl, (unsigned int)1, "openusb_abort", (unsigned int)1082, "abort error");

            else
              write(hdev->event_pipe[(signed long int)1], (const void *)buf, (unsigned long int)1);
            pthread_mutex_unlock(&hdev->lock);
            return ret;
          }

          io = tio;
        }
        pthread_mutex_unlock(&hdev->lock);
        pthread_mutex_lock(&usbi_dev_handles.lock);
      }

    pthread_mutex_unlock(&usbi_dev_handles.lock);
    return -12;
  }
}

// openusb_bulk_xfer
// file ../src/openusb.h line 1111
signed int openusb_bulk_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_bulk_request *bulk)
{
  struct openusb_request_handle *reqp;
  signed int ret;
  if(bulk == ((struct openusb_bulk_request *)NULL))
    return -8;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct openusb_request_handle) /*40ul*/ , (unsigned long int)1);
    reqp = (struct openusb_request_handle *)return_value_calloc_1;
    if(reqp == ((struct openusb_request_handle *)NULL))
      return -2;

    else
    {
      reqp->dev = dev;
      reqp->interface = ifc;
      reqp->endpoint = ept;
      reqp->type = (enum openusb_transfer_type)USB_TYPE_BULK;
      reqp->req.bulk = bulk;
      ret=openusb_xfer_wait(reqp);
      free((void *)reqp);
      return ret;
    }
  }
}

// openusb_claim_interface
// file ../src/openusb.h line 1014
signed int openusb_claim_interface(unsigned long int dev, unsigned char ifc, enum openusb_init_flag flags)
{
  struct usbi_dev_handle *hdev;
  signed int ret;
  _Bool tmp_if_expr_2;
  if((signed int)ifc >= 33)
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      signed int return_value_usbi_fetch_and_parse_descriptors_1;
      return_value_usbi_fetch_and_parse_descriptors_1=usbi_fetch_and_parse_descriptors(hdev);
      if(!(return_value_usbi_fetch_and_parse_descriptors_1 == 0))
        return -8;

      else
      {
        pthread_mutex_lock(&hdev->lock);
        if((signed int)ifc >= 32)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (unsigned long int)ifc >= (hdev->idev->desc.configs + (signed long int)hdev->idev->cur_config_index)->num_interfaces ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          _usbi_debug(hdev->lib_hdl, (unsigned int)1, "openusb_claim_interface", (unsigned int)106, "interface %d not valid", ifc);
          pthread_mutex_unlock(&hdev->lock);
          return -8;
        }

        else
        {
          pthread_mutex_unlock(&hdev->lock);
          ret=hdev->idev->ops->claim_interface(hdev, ifc, flags);
          pthread_mutex_lock(&hdev->lock);
          if(ret == 0)
          {
            hdev->claimed_ifs[(signed long int)ifc].clm = 1;
            hdev->claimed_ifs[(signed long int)ifc].altsetting = 0;
          }

          pthread_mutex_unlock(&hdev->lock);
          return ret;
        }
      }
    }
  }
}

// openusb_close_device
// file ../src/openusb.h line 935
signed int openusb_close_device(unsigned long int dev)
{
  struct usbi_dev_handle *hdev;
  signed int ret;
  struct usbi_io *io;
  struct usbi_io *tio;
  if(dev == 0ul)
    return 0;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      io = (struct usbi_io *)((char *)(&hdev->io_head)->next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
      tio = (struct usbi_io *)((char *)io->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
      for( ; !(&io->list == &hdev->io_head); tio = (struct usbi_io *)((char *)tio->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list))
      {
        if(!(io == ((struct usbi_io *)NULL)))
        {
          pthread_mutex_unlock(&hdev->lock);
          usbi_free_io(io);
          pthread_mutex_lock(&hdev->lock);
        }

        io = tio;
      }
      pthread_mutex_unlock(&hdev->lock);
      ret = 0;
      if(!(hdev == ((struct usbi_dev_handle *)NULL)))
      {
        if(!(hdev->idev == ((struct usbi_device *)NULL)))
        {
          if(!(hdev->idev->ops == ((struct usbi_device_ops *)NULL)))
          {
            if(!(hdev->idev->ops->close == ((signed int (*)(struct usbi_dev_handle *))NULL)))
              ret=hdev->idev->ops->close(hdev);

          }

        }

      }

      pthread_mutex_lock(&usbi_dev_handles.lock);
      pthread_mutex_lock(&hdev->lock);
      list_del(&hdev->list);
      close(hdev->event_pipe[(signed long int)0]);
      close(hdev->event_pipe[(signed long int)1]);
      pthread_mutex_unlock(&hdev->lock);
      pthread_mutex_unlock(&usbi_dev_handles.lock);
      pthread_mutex_destroy(&hdev->lock);
      free((void *)hdev);
      return ret;
    }
  }
}

// openusb_coldplug_callbacks_done
// file api.c line 23
void openusb_coldplug_callbacks_done(unsigned long int handle)
{
  struct usbi_handle *hdl;
  hdl=usbi_find_handle(handle);
  if(!(hdl == ((struct usbi_handle *)NULL)))
  {
    pthread_mutex_lock(&hdl->lock);
    while(hdl->coldplug_complete == 0)
      pthread_cond_wait(&hdl->coldplug_cv, &hdl->lock);
    hdl->coldplug_complete = (unsigned char)0;
    pthread_mutex_unlock(&hdl->lock);
  }

}

// openusb_ctrl_xfer
// file ../src/openusb.h line 1107
signed int openusb_ctrl_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_ctrl_request *ctrl)
{
  struct openusb_request_handle *reqp;
  signed int ret;
  if(ctrl == ((struct openusb_ctrl_request *)NULL))
    return -8;

  else
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_ctrl_xfer", (unsigned int)635, "ifc=%d ept=%d bRequest=%d", ifc, ept, ctrl->setup.bRequest);
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct openusb_request_handle) /*40ul*/ , (unsigned long int)1);
    reqp = (struct openusb_request_handle *)return_value_calloc_1;
    if(reqp == ((struct openusb_request_handle *)NULL))
      return -2;

    else
    {
      reqp->dev = dev;
      reqp->interface = ifc;
      reqp->endpoint = ept;
      reqp->type = (enum openusb_transfer_type)USB_TYPE_CONTROL;
      reqp->req.ctrl = ctrl;
      ret=openusb_xfer_wait(reqp);
      free((void *)reqp);
      return ret;
    }
  }
}

// openusb_fini
// file ../src/openusb.h line 561
void openusb_fini(unsigned long int handle)
{
  struct usbi_handle *hdl;
  struct usbi_backend *backend;
  struct usbi_backend *tbackend;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_fini", (unsigned int)656, "Begin");
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_fini", (unsigned int)660, "lib handle null");

  else
  {
    backend = (struct usbi_backend *)((char *)(&backends)->next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
    tbackend = (struct usbi_backend *)((char *)backend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
    for( ; !(&backend->list == &backends); tbackend = (struct usbi_backend *)((char *)tbackend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list))
    {
      if(!(backend == ((struct usbi_backend *)NULL)))
      {
        if(!(backend->ops == ((struct usbi_backend_ops *)NULL)))
        {
          if(!(backend->ops->fini == ((void (*)(struct usbi_handle *))NULL)))
            backend->ops->fini(hdl);

        }

      }

      backend = tbackend;
    }
    usbi_destroy_handle(hdl);
    pthread_mutex_lock(&usbi_lock);
    usbi_inited = usbi_inited - 1;
    if(usbi_inited == 0)
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_fini", (unsigned int)675, "Last lib handle");
      usbi_fini_common();
      pthread_mutex_unlock(&usbi_lock);
      backend = (struct usbi_backend *)((char *)(&backends)->next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
      tbackend = (struct usbi_backend *)((char *)backend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
      for( ; !(&backend->list == &backends); tbackend = (struct usbi_backend *)((char *)tbackend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list))
      {
        if(!(backend == ((struct usbi_backend *)NULL)))
        {
          dlclose(backend->handle);
          list_del(&backend->list);
        }

        backend = tbackend;
      }
    }

    else
    {
      pthread_mutex_unlock(&usbi_lock);
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_fini", (unsigned int)694, "End");
    }
  }
}

// openusb_free_busid_list
// file ../src/openusb.h line 733
void openusb_free_busid_list(unsigned long int *busids)
{
  if(!(busids == ((unsigned long int *)NULL)))
    free((void *)busids);

}

// openusb_free_device_data
// file ../src/openusb.h line 804
void openusb_free_device_data(struct openusb_dev_data *data)
{
  if(!(data == ((struct openusb_dev_data *)NULL)))
  {
    if(!(data->raw_cfg_desc == ((unsigned char *)NULL)))
      free((void *)data->raw_cfg_desc);

    if(!(data->product == ((struct usb_string_desc *)NULL)))
      free((void *)data->product);

    if(!(data->manufacturer == ((struct usb_string_desc *)NULL)))
      free((void *)data->manufacturer);

    if(!(data->serialnumber == ((struct usb_string_desc *)NULL)))
      free((void *)data->serialnumber);

    free((void *)data->bus_path);
    free((void *)data->sys_path);
    free((void *)data);
  }

}

// openusb_free_devid_list
// file ../src/openusb.h line 768
void openusb_free_devid_list(unsigned long int *devids)
{
  if(!(devids == ((unsigned long int *)NULL)))
    free((void *)devids);

}

// openusb_free_raw_desc
// file devices.c line 883
void openusb_free_raw_desc(unsigned char *buffer)
{
  free((void *)buffer);
}

// openusb_get_altsetting
// file ../src/openusb.h line 1041
signed int openusb_get_altsetting(unsigned long int dev, unsigned char ifc, unsigned char *alt)
{
  struct usbi_device *idev;
  struct usbi_dev_handle *hdev;
  if(alt == ((unsigned char *)NULL) || (signed int)ifc >= 33)
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      if(!(hdev->claimed_ifs[(signed long int)ifc].clm == 1))
      {
        pthread_mutex_unlock(&hdev->lock);
        return -8;
      }

      else
      {
        idev = hdev->idev;
        pthread_mutex_unlock(&hdev->lock);
        signed int return_value;
        return_value=idev->ops->get_altsetting(hdev, ifc, alt);
        return return_value;
      }
    }
  }
}

// openusb_get_busid_list
// file ../src/openusb.h line 731
signed int openusb_get_busid_list(unsigned long int handle, unsigned long int **busids, unsigned int *num_busids)
{
  struct usbi_handle *hdl;
  struct usbi_bus *ibus;
  unsigned long int *tmp;
  _Bool tmp_if_expr_1;
  if(busids == ((unsigned long int **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *busids != ((unsigned long int *)NULL) ? (_Bool)1 : (_Bool)0;
  if(num_busids == ((unsigned int *)NULL) || tmp_if_expr_1)
    return -8;

  else
  {
    *num_busids = (unsigned int)0;
    *busids = (unsigned long int *)(void *)0;
    hdl=usbi_find_handle(handle);
    if(hdl == ((struct usbi_handle *)NULL))
      return -12;

    else
    {
      pthread_mutex_lock(&usbi_buses.lock);
      ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      for( ; !(&ibus->list == &usbi_buses.head); ibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
        *num_busids = *num_busids + 1u;
      if(*num_busids == 0u)
      {
        pthread_mutex_unlock(&usbi_buses.lock);
        _usbi_debug(hdl, (unsigned int)2, "openusb_get_busid_list", (unsigned int)341, "Null list");
        return -14;
      }

      else
      {
        void *return_value_calloc_2;
        return_value_calloc_2=calloc((unsigned long int)*num_busids * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1);
        *busids = (unsigned long int *)return_value_calloc_2;
        if(*busids == ((unsigned long int *)NULL))
        {
          pthread_mutex_unlock(&usbi_buses.lock);
          _usbi_debug(hdl, (unsigned int)2, "openusb_get_busid_list", (unsigned int)348, "No resource");
          return -2;
        }

        else
        {
          tmp = *busids;
          ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
          for( ; !(&ibus->list == &usbi_buses.head); ibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
            if(!(ibus == ((struct usbi_bus *)NULL)))
            {
              pthread_mutex_lock(&ibus->lock);
              *tmp = ibus->busid;
              pthread_mutex_unlock(&ibus->lock);
              tmp = tmp + 1l;
            }

          pthread_mutex_unlock(&usbi_buses.lock);
          return 0;
        }
      }
    }
  }
}

// openusb_get_configuration
// file ../src/openusb.h line 989
signed int openusb_get_configuration(unsigned long int dev, unsigned char *cfg)
{
  struct usbi_dev_handle *hdev;
  signed int ret;
  if(cfg == ((unsigned char *)NULL))
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      ret=hdev->idev->ops->get_configuration(hdev, cfg);
      pthread_mutex_unlock(&hdev->lock);
      return ret;
    }
  }
}

// openusb_get_device_data
// file ../src/openusb.h line 790
signed int openusb_get_device_data(unsigned long int handle, unsigned long int devid, unsigned int flags, struct openusb_dev_data **data)
{
  struct openusb_dev_data *pdata = (struct openusb_dev_data *)(void *)0;
  struct usbi_handle *plib = (struct usbi_handle *)(void *)0;
  struct usbi_device *pdev = (struct usbi_device *)(void *)0;
  unsigned short int datalen;
  unsigned char *descdata = (unsigned char *)(void *)0;
  signed int ret;
  char strings[256l];
  unsigned long int hdev;
  struct usbi_dev_handle *devh = (struct usbi_dev_handle *)(void *)0;
  struct usbi_dev_handle *dev_found = (struct usbi_dev_handle *)(void *)0;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_device_data", (unsigned int)1266, "devid=%d, flags=%d", (signed int)devid, flags);
  plib=usbi_find_handle(handle);
  void *return_value_calloc_5;
  unsigned long int tmp_if_expr_6;
  if(plib == ((struct usbi_handle *)NULL))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1270, "Can't find lib handle:%d ", handle);
    return -8;
  }

  else
  {
    pdev=usbi_find_device_by_id(devid);
    if(pdev == ((struct usbi_device *)NULL))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1276, "Can't find device:%d ", devid);
      return -8;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct openusb_dev_data) /*136ul*/ );
      pdata = (struct openusb_dev_data *)return_value_malloc_1;
      if(pdata == ((struct openusb_dev_data *)NULL))
        return -2;

      else
      {
        memset((void *)pdata, 0, sizeof(struct openusb_dev_data) /*136ul*/ );
        pthread_mutex_lock(&pdev->bus->lock);
        pdata->bulk_max_xfer_size = pdev->bus->max_xfer_size[(signed long int)USB_TYPE_BULK];
        pdata->ctrl_max_xfer_size = pdev->bus->max_xfer_size[(signed long int)USB_TYPE_CONTROL];
        pdata->intr_max_xfer_size = pdev->bus->max_xfer_size[(signed long int)USB_TYPE_INTERRUPT];
        pdata->isoc_max_xfer_size = pdev->bus->max_xfer_size[(signed long int)USB_TYPE_ISOCHRONOUS];
        pdata->busid = pdev->bus->busid;
        pdata->bus_address = (unsigned char)pdev->bus->busnum;
        pthread_mutex_unlock(&pdev->bus->lock);
        ret=openusb_parse_device_desc(handle, devid, (unsigned char *)(void *)0, (unsigned short int)0, &pdata->dev_desc);
        if(!(ret == 0))
        {
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1302, "Get device desc fail");
          free((void *)pdata);
          return ret;
        }

        else
        {
          if((signed int)pdata->dev_desc.iManufacturer == 0)
          {
            if(!((signed int)pdata->dev_desc.iProduct == 0))
              goto __CPROVER_DUMP_L5;

            if(!((signed int)pdata->dev_desc.iSerialNumber == 0))
              goto __CPROVER_DUMP_L5;

            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_device_data", (unsigned int)1309, "Don't have string descriptors");
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            pthread_mutex_lock(&usbi_dev_handles.lock);
            devh = (struct usbi_dev_handle *)((char *)(&usbi_dev_handles.head)->next - (signed long int)(unsigned long int)&((struct usbi_dev_handle *)0L)->list);
            for( ; !(&devh->list == &usbi_dev_handles.head); devh = (struct usbi_dev_handle *)((char *)devh->list.next - (signed long int)(unsigned long int)&((struct usbi_dev_handle *)0L)->list))
              if(!(devh == ((struct usbi_dev_handle *)NULL)))
              {
                if(!(devh->idev == ((struct usbi_device *)NULL)))
                {
                  if(devh->idev->devid == devid)
                  {
                    dev_found = devh;
                    break;
                  }

                }

              }

            pthread_mutex_unlock(&usbi_dev_handles.lock);
            if(dev_found == ((struct usbi_dev_handle *)NULL))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_device_data", (unsigned int)1336, "device not opened");
              ret=openusb_open_device(handle, devid, (enum openusb_init_flag)0, &hdev);
              if(ret == -4)
              {
                _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)3, "openusb_get_device_data", (unsigned int)1345, "Not support strings");
                pdata->manufacturer = (struct usb_string_desc *)(void *)0;
                pdata->product = (struct usb_string_desc *)(void *)0;
                pdata->serialnumber = (struct usb_string_desc *)(void *)0;
                goto get_raw;
              }

              else
                if(!(ret == 0))
                {
                  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1353, "Fail to open device");
                  free((void *)pdata);
                  return -1;
                }

            }

            else
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_device_data", (unsigned int)1359, "device already opened");
              hdev = dev_found->handle;
            }
            if(!(pdata->dev_desc.iManufacturer == 0))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1365, "get manufacturer");
              ret=usbi_get_string(hdev, (signed int)pdata->dev_desc.iManufacturer, 0x409, strings, sizeof(char [256l]) /*256ul*/ );
              if(!(ret >= 0))
                pdata->manufacturer = (struct usb_string_desc *)(void *)0;

              else
              {
                void *return_value_calloc_2;
                return_value_calloc_2=calloc((unsigned long int)strings[(signed long int)0], (unsigned long int)1);
                pdata->manufacturer = (struct usb_string_desc *)return_value_calloc_2;
                if(pdata->manufacturer == ((struct usb_string_desc *)NULL))
                {
                  free((void *)pdata);
                  if(dev_found == ((struct usbi_dev_handle *)NULL))
                  {
                    openusb_close_device(hdev);
                    hdev = (unsigned long int)0;
                  }

                  return -2;
                }

                memcpy((void *)pdata->manufacturer, (const void *)strings, (unsigned long int)strings[(signed long int)0]);
              }
            }

            if(!(pdata->dev_desc.iProduct == 0))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1385, "get product");
              ret=usbi_get_string(hdev, (signed int)pdata->dev_desc.iProduct, 0x409, strings, sizeof(char [256l]) /*256ul*/ );
              if(!(ret >= 0))
                pdata->product = (struct usb_string_desc *)(void *)0;

              else
              {
                void *return_value_calloc_3;
                return_value_calloc_3=calloc((unsigned long int)strings[(signed long int)0], (unsigned long int)1);
                pdata->product = (struct usb_string_desc *)return_value_calloc_3;
                if(pdata->product == ((struct usb_string_desc *)NULL))
                {
                  free((void *)pdata->manufacturer);
                  free((void *)pdata);
                  if(dev_found == ((struct usbi_dev_handle *)NULL))
                  {
                    openusb_close_device(hdev);
                    hdev = (unsigned long int)0;
                  }

                  return -2;
                }

                memcpy((void *)pdata->product, (const void *)strings, (unsigned long int)strings[(signed long int)0]);
              }
            }

            if(!(pdata->dev_desc.iSerialNumber == 0))
            {
              ret=usbi_get_string(hdev, (signed int)pdata->dev_desc.iSerialNumber, 0x409, strings, sizeof(char [256l]) /*256ul*/ );
              if(!(ret >= 0))
                pdata->serialnumber = (struct usb_string_desc *)(void *)0;

              else
              {
                void *return_value_calloc_4;
                return_value_calloc_4=calloc((unsigned long int)strings[(signed long int)0], (unsigned long int)1);
                pdata->serialnumber = (struct usb_string_desc *)return_value_calloc_4;
                if(pdata->serialnumber == ((struct usb_string_desc *)NULL))
                {
                  free((void *)pdata->product);
                  free((void *)pdata->manufacturer);
                  free((void *)pdata);
                  if(dev_found == ((struct usbi_dev_handle *)NULL))
                  {
                    openusb_close_device(hdev);
                    hdev = (unsigned long int)0;
                  }

                  return -2;
                }

                memcpy((void *)pdata->serialnumber, (const void *)strings, (unsigned long int)strings[(signed long int)0]);
              }
            }

            if(dev_found == ((struct usbi_dev_handle *)NULL))
            {
              openusb_close_device(hdev);
              hdev = (unsigned long int)0;
            }

          }

        get_raw:
          ;
          ret=openusb_get_raw_desc(handle, devid, (unsigned char)0x02, (unsigned char)pdev->cur_config_index, (unsigned short int)0, &descdata, &datalen);
          if(!(ret == 0))
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1436, "Get raw config(%d) desc fail", pdev->cur_config_value);

          else
          {
            ret=openusb_parse_config_desc(handle, devid, descdata, datalen, pdev->cur_config_value, &pdata->cfg_desc);
            if(!(ret == 0))
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_get_device_data", (unsigned int)1443, "Parse config fail");

            else
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_device_data", (unsigned int)1446, "data len = %d", datalen);
              return_value_calloc_5=calloc((unsigned long int)datalen, (unsigned long int)1);
              pdata->raw_cfg_desc = (unsigned char *)return_value_calloc_5;
              if(pdata->raw_cfg_desc == ((unsigned char *)NULL))
              {
                openusb_free_raw_desc(descdata);
                ret = -2;
              }

              else
              {
                memcpy((void *)pdata->raw_cfg_desc, (const void *)descdata, (unsigned long int)datalen);
                openusb_free_raw_desc(descdata);
                pdata->bus_path=strdup(pdev->bus_path);
                pdata->sys_path=strdup(pdev->sys_path);
                pdata->devid = devid;
                pdata->nports = pdev->nports;
                if(!(pdev->parent == ((struct usbi_device *)NULL)))
                  tmp_if_expr_6 = pdev->parent->devid;

                else
                  tmp_if_expr_6 = (unsigned long int)0;
                pdata->pdevid = tmp_if_expr_6;
                pdata->pport = pdev->pport;
                *data = pdata;
                return 0;
              }
            }
          }

        fail:
          ;
          if(dev_found == ((struct usbi_dev_handle *)NULL))
          {
            openusb_close_device(hdev);
            hdev = (unsigned long int)0;
          }

          free((void *)pdata->product);
          free((void *)pdata->manufacturer);
          free((void *)pdata->serialnumber);
          free((void *)pdata);
          return ret;
        }
      }
    }
  }
}

// openusb_get_devid
// file ../src/openusb.h line 950
signed int openusb_get_devid(unsigned long int dev, unsigned long int *devid)
{
  struct usbi_dev_handle *hdev;
  if(devid == ((unsigned long int *)NULL))
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      *devid = hdev->idev->devid;
      pthread_mutex_unlock(&hdev->lock);
      return 0;
    }
  }
}

// openusb_get_devids_by_bus
// file ../src/openusb.h line 761
signed int openusb_get_devids_by_bus(unsigned long int handle, unsigned long int busid, unsigned long int **devids, unsigned int *num_devids)
{
  struct usbi_handle *hdl;
  struct usbi_bus *ibus;
  struct usbi_device *idev;
  unsigned long int *tdevid;
  signed int devcnts = 0;
  if(devids == ((unsigned long int **)NULL) || num_devids == ((unsigned int *)NULL))
    return -8;

  else
  {
    *num_devids = (unsigned int)0;
    *devids = (unsigned long int *)(void *)0;
    hdl=usbi_find_handle(handle);
    if(hdl == ((struct usbi_handle *)NULL))
      return -12;

    else
    {
      if(busid == 0ul)
      {
        pthread_mutex_lock(&usbi_devices.lock);
        idev = (struct usbi_device *)((char *)(&usbi_devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
        for( ; !(&idev->dev_list == &usbi_devices.head); idev = (struct usbi_device *)((char *)idev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list))
          devcnts = devcnts + 1;
        if(devcnts == 0)
        {
          pthread_mutex_unlock(&usbi_devices.lock);
          return -14;
        }

        void *return_value_calloc_1;
        return_value_calloc_1=calloc((unsigned long int)devcnts * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1);
        *devids = (unsigned long int *)return_value_calloc_1;
        if(*devids == ((unsigned long int *)NULL))
        {
          pthread_mutex_unlock(&usbi_devices.lock);
          return -2;
        }

        tdevid = *devids;
        idev = (struct usbi_device *)((char *)(&usbi_devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
        for( ; !(&idev->dev_list == &usbi_devices.head); idev = (struct usbi_device *)((char *)idev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list))
          if(!(idev == ((struct usbi_device *)NULL)))
          {
            *tdevid = idev->devid;
            tdevid = tdevid + 1l;
          }

        *num_devids = (unsigned int)devcnts;
        pthread_mutex_unlock(&usbi_devices.lock);
        return 0;
      }

      ibus=usbi_find_bus_by_id(busid);
      if(ibus == ((struct usbi_bus *)NULL))
        return -11;

      else
      {
        pthread_mutex_lock(&ibus->devices.lock);
        if(ibus->devices.head.next == &ibus->devices.head)
        {
          pthread_mutex_unlock(&ibus->devices.lock);
          return -14;
        }

        else
        {
          idev = (struct usbi_device *)((char *)(&ibus->devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list);
          for( ; !(&idev->bus_list == &ibus->devices.head); idev = (struct usbi_device *)((char *)idev->bus_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list))
            devcnts = devcnts + 1;
          if(devcnts == 0)
          {
            pthread_mutex_unlock(&ibus->devices.lock);
            return -14;
          }

          else
          {
            void *return_value_calloc_2;
            return_value_calloc_2=calloc((unsigned long int)devcnts * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1);
            *devids = (unsigned long int *)return_value_calloc_2;
            if(*devids == ((unsigned long int *)NULL))
            {
              pthread_mutex_unlock(&ibus->devices.lock);
              return -2;
            }

            else
            {
              tdevid = *devids;
              idev = (struct usbi_device *)((char *)(&ibus->devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list);
              for( ; !(&idev->bus_list == &ibus->devices.head); idev = (struct usbi_device *)((char *)idev->bus_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list))
                if(!(idev == ((struct usbi_device *)NULL)))
                {
                  *tdevid = idev->devid;
                  tdevid = tdevid + 1l;
                }

              *num_devids = (unsigned int)devcnts;
              pthread_mutex_unlock(&ibus->devices.lock);
              return 0;
            }
          }
        }
      }
    }
  }
}

// openusb_get_devids_by_class
// file ../src/openusb.h line 765
signed int openusb_get_devids_by_class(unsigned long int handle, signed short int devclass, signed short int subclass, signed short int protocol, unsigned long int **devids, unsigned int *num_devids)
{
  struct usbi_handle *hdl;
  struct usbi_device *idev;
  struct usbi_device *tdev;
  unsigned long int *tdevid;
  struct list_head match_list;
  if(devids == ((unsigned long int **)NULL) || num_devids == ((unsigned int *)NULL))
    return -8;

  else
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_devids_by_class", (unsigned int)740, "class=%d, subclass=%d, protocol=%d", devclass, subclass, protocol);
    *num_devids = (unsigned int)0;
    *devids = (unsigned long int *)(void *)0;
    list_init(&match_list);
    hdl=usbi_find_handle(handle);
    if(hdl == ((struct usbi_handle *)NULL))
      return -12;

    else
      if((signed int)devclass >= 256 || (signed int)protocol >= 256 || (signed int)subclass >= 256 || !((signed int)devclass >= -1) || !((signed int)protocol >= -1) || !((signed int)subclass >= -1))
        return -8;

      else
      {
        pthread_mutex_lock(&usbi_devices.lock);
        idev = (struct usbi_device *)((char *)(&usbi_devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
        tdev = (struct usbi_device *)((char *)idev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
        for( ; !(&idev->dev_list == &usbi_devices.head); tdev = (struct usbi_device *)((char *)tdev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list))
        {
          if(!(idev == ((struct usbi_device *)NULL)))
          {
            pthread_mutex_unlock(&usbi_devices.lock);
            signed int return_value_usbi_match_class_1;
            return_value_usbi_match_class_1=usbi_match_class(handle, idev, devclass, subclass, protocol);
            if(!(return_value_usbi_match_class_1 == 0))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_devids_by_class", (unsigned int)763, "match dev %d", (signed int)idev->devid);
              list_add(&idev->match_list, &match_list);
              *num_devids = *num_devids + 1u;
            }

            pthread_mutex_lock(&usbi_devices.lock);
          }

          idev = tdev;
        }
        if(*num_devids == 0u)
        {
          pthread_mutex_unlock(&usbi_devices.lock);
          return -14;
        }

        else
        {
          void *return_value_calloc_2;
          return_value_calloc_2=calloc((unsigned long int)*num_devids * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1);
          *devids = (unsigned long int *)return_value_calloc_2;
          if(*devids == ((unsigned long int *)NULL))
          {
            pthread_mutex_unlock(&usbi_devices.lock);
            return -2;
          }

          else
          {
            tdevid = *devids;
            idev = (struct usbi_device *)((char *)(&match_list)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->match_list);
            for( ; !(&idev->match_list == &match_list); idev = (struct usbi_device *)((char *)idev->match_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->match_list))
              if(!(idev == ((struct usbi_device *)NULL)))
              {
                *tdevid = idev->devid;
                tdevid = tdevid + 1l;
              }

            pthread_mutex_unlock(&usbi_devices.lock);
            return 0;
          }
        }
      }
  }
}

// openusb_get_devids_by_vendor
// file devices.c line 632
signed int openusb_get_devids_by_vendor(unsigned long int handle, signed int vendor, signed int product, unsigned long int **devids, unsigned int *num_devids)
{
  struct usbi_handle *hdl;
  struct usbi_device *idev = (struct usbi_device *)(void *)0;
  struct usbi_device *tdev;
  unsigned long int *tdevid;
  struct list_head match_list;
  signed int ret;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_get_devids_by_vendor", (unsigned int)642, "Begin");
  _Bool tmp_if_expr_1;
  if(devids == ((unsigned long int **)NULL) || num_devids == ((unsigned int *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *devids != ((unsigned long int *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -8;

  else
  {
    *num_devids = (unsigned int)0;
    *devids = (unsigned long int *)(void *)0;
    list_init(&match_list);
    hdl=usbi_find_handle(handle);
    if(hdl == ((struct usbi_handle *)NULL))
      return -12;

    else
      if(product >= 65536 || vendor >= 65536 || !(product >= -1) || !(vendor >= -1))
        return -8;

      else
      {
        pthread_mutex_lock(&usbi_devices.lock);
        idev = (struct usbi_device *)((char *)(&usbi_devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
        tdev = (struct usbi_device *)((char *)idev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
        for( ; !(&idev->dev_list == &usbi_devices.head); tdev = (struct usbi_device *)((char *)tdev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list))
        {
          if(!(idev == ((struct usbi_device *)NULL)))
          {
            struct usb_device_desc desc;
            unsigned short int Vendor;
            unsigned short int Product;
            pthread_mutex_unlock(&usbi_devices.lock);
            ret=openusb_parse_device_desc(handle, idev->devid, (unsigned char *)(void *)0, (unsigned short int)0, &desc);
            if(!(ret >= 0))
            {
              _usbi_debug(hdl, (unsigned int)2, "openusb_get_devids_by_vendor", (unsigned int)673, "get device desc for devid %d failed (ret = %d)", idev->devid, ret);
              pthread_mutex_lock(&usbi_devices.lock);
            }

            else
            {
              pthread_mutex_lock(&usbi_devices.lock);
              Vendor=openusb_le16_to_cpu(desc.idVendor);
              Product=openusb_le16_to_cpu(desc.idProduct);
              if((product == -1 || product == (signed int)Product) && (vendor == -1 || vendor == (signed int)Vendor))
              {
                list_add(&idev->match_list, &match_list);
                *num_devids = *num_devids + 1u;
              }

            }
          }

          idev = tdev;
        }
        if(*num_devids == 0u)
        {
          pthread_mutex_unlock(&usbi_devices.lock);
          return -14;
        }

        else
        {
          void *return_value_calloc_2;
          return_value_calloc_2=calloc((unsigned long int)*num_devids * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)1);
          *devids = (unsigned long int *)return_value_calloc_2;
          if(*devids == ((unsigned long int *)NULL))
          {
            pthread_mutex_unlock(&usbi_devices.lock);
            return -2;
          }

          else
          {
            tdevid = *devids;
            idev = (struct usbi_device *)((char *)(&match_list)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->match_list);
            for( ; !(&idev->match_list == &match_list); idev = (struct usbi_device *)((char *)idev->match_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->match_list))
              if(!(idev == ((struct usbi_device *)NULL)))
              {
                *tdevid = idev->devid;
                tdevid = tdevid + 1l;
              }

            pthread_mutex_unlock(&usbi_devices.lock);
            return 0;
          }
        }
      }
  }
}

// openusb_get_lib_handle
// file ../src/openusb.h line 965
signed int openusb_get_lib_handle(unsigned long int dev, unsigned long int *lib_handle)
{
  struct usbi_dev_handle *hdev;
  if(lib_handle == ((unsigned long int *)NULL))
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      *lib_handle = hdev->lib_hdl->handle;
      pthread_mutex_unlock(&hdev->lock);
      return 0;
    }
  }
}

// openusb_get_max_xfer_size
// file devices.c line 1510
signed int openusb_get_max_xfer_size(unsigned long int handle, unsigned long int bus, enum openusb_transfer_type type, unsigned int *bytes)
{
  struct usbi_bus *ibus;
  struct usbi_handle *hdl;
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
  {
    ibus=usbi_find_bus_by_id(bus);
    if(ibus == ((struct usbi_bus *)NULL))
      return -11;

    else
      if((signed int)type >= USB_TYPE_LAST || !((signed int)type >= 1))
      {
        _usbi_debug(hdl, (unsigned int)2, "openusb_get_max_xfer_size", (unsigned int)1525, "Invalid transfer type");
        return -8;
      }

      else
        if(bytes == ((unsigned int *)NULL))
          return -8;

        else
        {
          pthread_mutex_lock(&ibus->lock);
          *bytes = ibus->max_xfer_size[(signed long int)type];
          pthread_mutex_unlock(&ibus->lock);
          return 0;
        }
  }
}

// openusb_get_raw_desc
// file devices.c line 852
signed int openusb_get_raw_desc(unsigned long int handle, unsigned long int devid, unsigned char type, unsigned char descidx, unsigned short int langid, unsigned char **buffer, unsigned short int *buflen)
{
  struct usbi_handle *hdl;
  struct usbi_device *idev;
  signed int ret;
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
  {
    idev=usbi_find_device_by_id(devid);
    if(idev == ((struct usbi_device *)NULL))
      return -11;

    else
      if(!(idev->ops->get_raw_desc == ((signed int (*)(struct usbi_device *, unsigned char, unsigned char, unsigned short int, unsigned char **, unsigned short int *))NULL)))
      {
        ret=idev->ops->get_raw_desc(idev, type, descidx, langid, buffer, buflen);
        return ret;
      }

      else
        return -10;
  }
}

// openusb_init
// file ../src/openusb.h line 545
signed int openusb_init(unsigned int flags, unsigned long int *handle)
{
  struct usbi_handle *hdl;
  signed int ret;
  struct usbi_backend *backend;
  signed int back_cnt = 0;
  signed int init_cnt = 0;
  if(handle == ((unsigned long int *)NULL))
    return -8;

  else
  {
    *handle = (unsigned long int)0;
    pthread_mutex_lock(&usbi_lock);
    if(usbi_inited == 0)
    {
      ret=usbi_init_common();
      if(ret >= 0)
        goto __CPROVER_DUMP_L2;

      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_init", (unsigned int)597, "usbi_init_common failed (ret = %d)", ret);
      pthread_mutex_unlock(&usbi_lock);
      return ret;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      usbi_inited = usbi_inited + 1;
      pthread_mutex_unlock(&usbi_lock);
      hdl=usbi_init_handle();
      if(hdl == ((struct usbi_handle *)NULL))
      {
        pthread_mutex_lock(&usbi_lock);
        usbi_inited = usbi_inited - 1;
        if(usbi_inited == 0)
          usbi_fini_common();

        pthread_mutex_unlock(&usbi_lock);
        return -13;
      }

      else
      {
        backend = (struct usbi_backend *)((char *)(&backends)->next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
        for( ; !(&backend->list == &backends); backend = (struct usbi_backend *)((char *)backend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list))
          if(!(backend == ((struct usbi_backend *)NULL)))
          {
            back_cnt = back_cnt + 1;
            signed int return_value;
            return_value=backend->ops->init(hdl, flags);
            if(!(return_value == 0))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_init", (unsigned int)623, "backend init fail");
              init_cnt = init_cnt + 1;
            }

          }

        if(back_cnt == init_cnt)
        {
          pthread_mutex_lock(&usbi_lock);
          usbi_inited = usbi_inited - 1;
          if(usbi_inited == 0)
            usbi_fini_common();

          pthread_mutex_unlock(&usbi_lock);
          free((void *)hdl);
          return -1;
        }

        else
        {
          usbi_rescan_devices();
          *handle = hdl->handle;
          _usbi_debug(hdl, (unsigned int)4, "openusb_init", (unsigned int)646, "End");
          return 0;
        }
      }
    }
  }
}

// openusb_intr_xfer
// file ../src/openusb.h line 1109
signed int openusb_intr_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_intr_request *intr)
{
  struct openusb_request_handle *reqp;
  signed int ret;
  if(intr == ((struct openusb_intr_request *)NULL))
    return -8;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct openusb_request_handle) /*40ul*/ , (unsigned long int)1);
    reqp = (struct openusb_request_handle *)return_value_calloc_1;
    if(reqp == ((struct openusb_request_handle *)NULL))
      return -2;

    else
    {
      reqp->dev = dev;
      reqp->interface = ifc;
      reqp->endpoint = ept;
      reqp->type = (enum openusb_transfer_type)USB_TYPE_INTERRUPT;
      reqp->req.intr = intr;
      ret=openusb_xfer_wait(reqp);
      free((void *)reqp);
      return ret;
    }
  }
}

// openusb_is_interface_claimed
// file ../src/openusb.h line 1017
signed int openusb_is_interface_claimed(unsigned long int dev, unsigned char ifc)
{
  struct usbi_dev_handle *hdev;
  if((signed int)ifc >= 33)
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -8;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      if(hdev->claimed_ifs[(signed long int)ifc].clm == 1)
      {
        pthread_mutex_unlock(&hdev->lock);
        return 1;
      }

      else
      {
        pthread_mutex_unlock(&hdev->lock);
        return 0;
      }
    }
  }
}

// openusb_isoc_xfer
// file ../src/openusb.h line 1113
signed int openusb_isoc_xfer(unsigned long int dev, unsigned char ifc, unsigned char ept, struct openusb_isoc_request *isoc)
{
  struct openusb_request_handle *reqp;
  signed int ret;
  if(isoc == ((struct openusb_isoc_request *)NULL))
    return -8;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct openusb_request_handle) /*40ul*/ , (unsigned long int)1);
    reqp = (struct openusb_request_handle *)return_value_calloc_1;
    if(reqp == ((struct openusb_request_handle *)NULL))
      return -2;

    else
    {
      reqp->dev = dev;
      reqp->interface = ifc;
      reqp->endpoint = ept;
      reqp->type = (enum openusb_transfer_type)USB_TYPE_ISOCHRONOUS;
      reqp->req.isoc = isoc;
      ret=openusb_xfer_wait(reqp);
      free((void *)reqp);
      return ret;
    }
  }
}

// openusb_le16_to_cpu
// file usb.c line 1120
inline unsigned short int openusb_le16_to_cpu(unsigned short int data)
{
  unsigned short int endian = (unsigned short int)0x1234;
  if((signed int)*((unsigned char *)&endian) == 0x12)
  {
    unsigned char *p = (unsigned char *)&data;
    return (unsigned short int)((signed int)p[(signed long int)0] | (signed int)p[(signed long int)1] << 8);
  }

  else
    return data;
}

// openusb_le32_to_cpu
// file usb.c line 1134
inline unsigned int openusb_le32_to_cpu(unsigned int data)
{
  unsigned int endian = (unsigned int)0x12345678;
  if((signed int)*((unsigned char *)&endian) == 0x12)
  {
    unsigned char *p = (unsigned char *)&data;
    return (unsigned int)((signed int)p[(signed long int)0] | (signed int)p[(signed long int)1] << 8 | (signed int)p[(signed long int)2] << 16 | (signed int)p[(signed long int)3] << 24);
  }

  else
    return data;
}

// openusb_open_device
// file ../src/openusb.h line 933
signed int openusb_open_device(unsigned long int handle, unsigned long int devid, enum openusb_init_flag flags, unsigned long int *dev)
{
  struct usbi_handle *hdl;
  struct usbi_device *idev;
  struct usbi_dev_handle *hdev;
  unsigned char cfg;
  signed int ret;
  signed int i;
  unsigned long int tmp_post_2;
  if(dev == ((unsigned long int *)NULL))
    return -8;

  else
  {
    *dev = (unsigned long int)0;
    hdl=usbi_find_handle(handle);
    if(hdl == ((struct usbi_handle *)NULL))
      return -12;

    else
    {
      idev=usbi_find_device_by_id(devid);
      if(idev == ((struct usbi_device *)NULL))
        return -11;

      else
      {
        void *return_value_calloc_1;
        return_value_calloc_1=calloc(sizeof(struct usbi_dev_handle) /*400ul*/ , (unsigned long int)1);
        hdev = (struct usbi_dev_handle *)return_value_calloc_1;
        if(hdev == ((struct usbi_dev_handle *)NULL))
          return -2;

        else
        {
          pthread_mutex_lock(&usbi_lock);
          tmp_post_2 = cur_dev_handle;
          cur_dev_handle = cur_dev_handle + 1ul;
          hdev->handle = tmp_post_2;
          pthread_mutex_unlock(&usbi_lock);
          hdev->lib_hdl = hdl;
          hdev->idev = idev;
          hdev->flags = flags;
          signed int return_value_pthread_mutex_init_3;
          return_value_pthread_mutex_init_3=pthread_mutex_init(&hdev->lock, (const union anonymous_2 *)(void *)0);
          if(!(return_value_pthread_mutex_init_3 == 0))
          {
            free((void *)hdev);
            return -13;
          }

          else
          {
            i = 0;
            for( ; !(i >= 32); i = i + 1)
            {
              hdev->claimed_ifs[(signed long int)i].clm = -1;
              hdev->claimed_ifs[(signed long int)i].altsetting = -1;
            }
            list_init(&hdev->io_head);
            list_init(&hdev->m_head);
            signed int return_value_pipe_4;
            return_value_pipe_4=pipe(hdev->event_pipe);
            if(!(return_value_pipe_4 >= 0))
            {
              pthread_mutex_destroy(&hdev->lock);
              free((void *)hdev);
              return -13;
            }

            else
            {
              ret=idev->ops->open(hdev);
              if(!(ret >= 0))
              {
                pthread_mutex_destroy(&hdev->lock);
                free((void *)hdev);
                return ret;
              }

              else
              {
                pthread_mutex_lock(&usbi_dev_handles.lock);
                pthread_mutex_lock(&hdev->lock);
                list_add(&hdev->list, &usbi_dev_handles.head);
                hdev->state = (enum usbi_devstate)USBI_DEVICE_OPENED;
                *dev = hdev->handle;
                pthread_mutex_unlock(&hdev->lock);
                pthread_mutex_unlock(&usbi_dev_handles.lock);
                ret=openusb_get_configuration(*dev, &cfg);
                if(!(ret == 0))
                {
                  openusb_close_device(*dev);
                  *dev = (unsigned long int)0;
                  return ret;
                }

                else
                  return 0;
              }
            }
          }
        }
      }
    }
  }
}

// openusb_parse_config_desc
// file ../src/openusb.h line 872
signed int openusb_parse_config_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, unsigned char cfgidx, struct usb_config_desc *cfgdesc)
{
  struct usbi_handle *hdl;
  unsigned char *tmpbuf = (unsigned char *)(void *)0;
  unsigned short int tmplen;
  signed int ret = 0;
  unsigned int count;
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
  {
    if(buffer == ((unsigned char *)NULL))
    {
      ret=openusb_get_raw_desc(handle, devid, (unsigned char)0x02, cfgidx, (unsigned short int)0, &tmpbuf, &tmplen);
      if(!(ret >= 0))
        return ret;

    }

    else
    {
      if(!((signed int)buflen >= 9))
        return -8;

      tmpbuf = buffer;
      tmplen = buflen;
    }
    ret=openusb_parse_data("bbwbbbbb", tmpbuf, (unsigned int)tmplen, (void *)cfgdesc, (unsigned int)sizeof(struct usb_config_desc) /*10ul*/ , &count);
    if(ret == 0 && !(count >= 9u))
      ret = -10;

    if(buffer == ((unsigned char *)NULL))
      openusb_free_raw_desc(tmpbuf);

    return ret;
  }
}

// openusb_parse_data
// file openusb.h line 713
signed int openusb_parse_data(const char *format, unsigned char *source, unsigned int sourcelen, void *dest, unsigned int destlen, unsigned int *count)
{
  unsigned char *sp = source;
  unsigned char *dp = (unsigned char *)dest;
  unsigned short int w;
  unsigned int d;
  const char *cp;
  unsigned char *tmp_post_1;
  unsigned char *tmp_post_2;
  if(dest == NULL || format == ((const char *)NULL) || count == ((unsigned int *)NULL) || source == ((unsigned char *)NULL))
    return -8;

  else
  {
    cp = format;
    for( ; !(*cp == 0); cp = cp + 1l)
      switch((signed int)*cp)
      {
        case 46:
        {
          sp = sp + 1l;
          sourcelen = sourcelen - 1u;
          break;
        }
        case 98:
        {
          if(!(destlen >= 1u) || !(sourcelen >= 1u))
            return -2;

          tmp_post_1 = dp;
          dp = dp + 1l;
          tmp_post_2 = sp;
          sp = sp + 1l;
          *tmp_post_1 = *tmp_post_2;
          destlen = destlen - 1u;
          sourcelen = sourcelen - 1u;
          break;
        }
        case 119:
        {
          if(!(destlen >= 2u) || !(sourcelen >= 2u))
            return -2;

          w = (unsigned short int)((signed int)sp[(signed long int)1] << 8 | (signed int)sp[(signed long int)0]);
          sp = sp + (signed long int)2;
          dp = dp + (signed long int)((unsigned long int)dp & (unsigned long int)1);
          *((unsigned short int *)dp) = w;
          dp = dp + (signed long int)2;
          destlen = destlen - (unsigned int)2;
          sourcelen = sourcelen - (unsigned int)2;
          break;
        }
        case 100:
        {
          if(!(destlen >= 4u) || !(sourcelen >= 4u))
            return -2;

          d = (unsigned int)((signed int)sp[(signed long int)3] << 24 | (signed int)sp[(signed long int)2] << 16 | (signed int)sp[(signed long int)1] << 8 | (signed int)sp[(signed long int)0]);
          sp = sp + (signed long int)4;
          dp = dp + (signed long int)((unsigned long int)dp & (unsigned long int)2);
          *((unsigned int *)dp) = d;
          dp = dp + (signed long int)4;
          destlen = destlen - (unsigned int)4;
          sourcelen = sourcelen - (unsigned int)4;
          break;
        }
        case 87:
        {
          if(!(destlen >= 2u) || !(sourcelen >= 2u))
            return -2;

          dp = dp + (signed long int)((unsigned long int)dp & (unsigned long int)1);
          memcpy((void *)dp, (const void *)sp, (unsigned long int)2);
          sp = sp + (signed long int)2;
          dp = dp + (signed long int)2;
          destlen = destlen - (unsigned int)2;
          sourcelen = sourcelen - (unsigned int)2;
          break;
        }
        case 68:
        {
          if(!(destlen >= 4u) || !(sourcelen >= 4u))
            return -2;

          dp = dp + (signed long int)((unsigned long int)dp & (unsigned long int)2);
          memcpy((void *)dp, (const void *)sp, (unsigned long int)4);
          sp = sp + (signed long int)4;
          dp = dp + (signed long int)4;
          destlen = destlen - (unsigned int)4;
          sourcelen = sourcelen - (unsigned int)4;
        }
      }
    *count = (unsigned int)(sp - source);
    return 0;
  }
}

// openusb_parse_device_desc
// file ../src/openusb.h line 869
signed int openusb_parse_device_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, struct usb_device_desc *devdesc)
{
  struct usbi_handle *hdl;
  unsigned char *tmpbuf = (unsigned char *)(void *)0;
  unsigned short int tmplen;
  signed int ret = 0;
  unsigned int count;
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
  {
    _usbi_debug(hdl, (unsigned int)4, "openusb_parse_device_desc", (unsigned int)903, "devid = %d", (signed int)devid);
    if(buffer == ((unsigned char *)NULL))
    {
      ret=openusb_get_raw_desc(handle, devid, (unsigned char)0x01, (unsigned char)0, (unsigned short int)0, &tmpbuf, &tmplen);
      if(!(ret >= 0))
      {
        const char *return_value_openusb_strerror_1;
        return_value_openusb_strerror_1=openusb_strerror(ret);
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_parse_device_desc", (unsigned int)910, "fail:%s", return_value_openusb_strerror_1);
        return ret;
      }

    }

    else
    {
      if(!((signed int)buflen >= 18))
        return -8;

      tmpbuf = buffer;
      tmplen = buflen;
    }
    ret=openusb_parse_data("bbwbbbbwwwbbbb", tmpbuf, (unsigned int)tmplen, (void *)devdesc, (unsigned int)sizeof(struct usb_device_desc) /*18ul*/ , &count);
    if(ret == 0 && !(count >= 18u))
      ret = -10;

    if(buffer == ((unsigned char *)NULL))
      openusb_free_raw_desc(tmpbuf);

    return ret;
  }
}

// openusb_parse_endpoint_desc
// file ../src/openusb.h line 879
signed int openusb_parse_endpoint_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, unsigned char cfgidx, unsigned char ifcidx, unsigned char alt, unsigned char eptidx, struct usb_endpoint_desc *eptdesc)
{
  struct usbi_handle *hdl;
  unsigned char *tmpbuf;
  unsigned char *sp1;
  unsigned char *sp2;
  unsigned short int tmplen;
  signed int ret = -10;
  unsigned int count;
  hdl=usbi_find_handle(handle);
  _Bool tmp_if_expr_2;
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
  {
    if(buffer == ((unsigned char *)NULL))
    {
      ret=openusb_get_raw_desc(handle, devid, (unsigned char)0x02, cfgidx, (unsigned short int)0, &tmpbuf, &tmplen);
      if(!(ret >= 0))
      {
        const char *return_value_openusb_strerror_1;
        return_value_openusb_strerror_1=openusb_strerror(ret);
        _usbi_debug(hdl, (unsigned int)1, "openusb_parse_endpoint_desc", (unsigned int)1079, "Get raw fail:%s", return_value_openusb_strerror_1);
        return ret;
      }

    }

    else
    {
      if(!((signed int)buflen >= 9))
      {
        _usbi_debug(hdl, (unsigned int)1, "openusb_parse_endpoint_desc", (unsigned int)1084, "Invalid buffer length");
        return -8;
      }

      tmpbuf = buffer;
      tmplen = buflen;
    }
    sp1 = tmpbuf;
    while((signed int)tmplen >= 5)
    {
      if((signed int)sp1[1l] == 0x04)
      {
        if(sp1[2l] == ifcidx)
        {
          if(sp1[3l] == alt)
          {
            if((signed int)eptidx >= (signed int)sp1[4l])
            {
              _usbi_debug(hdl, (unsigned int)1, "openusb_parse_endpoint_desc", (unsigned int)1099, "Invalid endpoint:%d", eptidx);
              ret = -8;
              break;
            }

            sp2 = sp1;
            sp1=usbi_nth_desc(sp1, tmplen, (unsigned char)0x05, eptidx, (unsigned char)0x04);
            if(sp1 == ((unsigned char *)NULL))
            {
              ret = -10;
              break;
            }

            tmplen = tmplen - (unsigned short int)(sp1 - sp2);
            ret=openusb_parse_data("bbbbwb", sp1, (unsigned int)tmplen, (void *)eptdesc, (unsigned int)sizeof(struct usb_endpoint_desc) /*10ul*/ , &count);
            if(ret == 0 && !(count >= 7u))
              ret = -10;

            break;
          }

        }

      }

      if((signed int)*sp1 >= 1)
        tmp_if_expr_2 = (signed int)tmplen >= (signed int)sp1[(signed long int)0] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        tmplen = tmplen - (unsigned short int)sp1[(signed long int)0];
        sp1 = sp1 + (signed long int)sp1[(signed long int)0];
      }

      else
      {
        ret = -10;
        break;
      }
    }
    if(buffer == ((unsigned char *)NULL))
      openusb_free_raw_desc(tmpbuf);

    return ret;
  }
}

// openusb_parse_interface_desc
// file ../src/openusb.h line 875
signed int openusb_parse_interface_desc(unsigned long int handle, unsigned long int devid, unsigned char *buffer, unsigned short int buflen, unsigned char cfgidx, unsigned char ifcidx, unsigned char alt, struct usb_interface_desc *ifcdesc)
{
  struct usbi_handle *hdl;
  unsigned char *tmpbuf;
  unsigned char *sp;
  unsigned short int tmplen;
  signed int ret = -10;
  unsigned int count;
  hdl=usbi_find_handle(handle);
  _Bool tmp_if_expr_1;
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
  {
    if(buffer == ((unsigned char *)NULL))
    {
      ret=openusb_get_raw_desc(handle, devid, (unsigned char)0x02, cfgidx, (unsigned short int)0, &tmpbuf, &tmplen);
      if(!(ret >= 0))
        return ret;

    }

    else
    {
      if(!((signed int)buflen >= 9))
        return -8;

      tmpbuf = buffer;
      tmplen = buflen;
    }
    ret = -10;
    sp = tmpbuf;
    while((signed int)tmplen >= 4)
    {
      if((signed int)sp[1l] == 0x04)
      {
        if(sp[2l] == ifcidx)
        {
          if(sp[3l] == alt)
          {
            ret=openusb_parse_data("bbbbbbbbb", sp, (unsigned int)tmplen, (void *)ifcdesc, (unsigned int)sizeof(struct usb_interface_desc) /*9ul*/ , &count);
            if(ret == 0 && !(count >= 9u))
              ret = -10;

            break;
          }

        }

      }

      if((signed int)*sp >= 1)
        tmp_if_expr_1 = (signed int)tmplen >= (signed int)sp[(signed long int)0] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        tmplen = tmplen - (unsigned short int)sp[(signed long int)0];
        sp = sp + (signed long int)sp[(signed long int)0];
      }

      else
      {
        ret = -10;
        break;
      }
    }
    if(buffer == ((unsigned char *)NULL))
      openusb_free_raw_desc(tmpbuf);

    return ret;
  }
}

// openusb_poll
// file ../src/openusb.h line 1153
signed int openusb_poll(unsigned int num_reqs, struct openusb_request_handle **handles, struct openusb_request_handle **handle)
{
  signed int i;
  struct usbi_dev_handle *hdev;
  struct usbi_handle *ph = (struct usbi_handle *)(void *)0;
  struct usbi_io *io = (struct usbi_io *)(void *)0;
  signed int found = 0;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_poll", (unsigned int)1003, "Begin");
  if(num_reqs == 0u)
    return 0;

  else
    if(handle == ((struct openusb_request_handle **)NULL) || handles == ((struct openusb_request_handle **)NULL))
      return -8;

    else
    {
      hdev=usbi_find_dev_handle(handles[(signed long int)0]->dev);
      if(hdev == ((struct usbi_dev_handle *)NULL))
        return -8;

      else
      {
        pthread_mutex_lock(&hdev->lock);
        ph = hdev->lib_hdl;
        pthread_mutex_unlock(&hdev->lock);
        if(ph == ((struct usbi_handle *)NULL))
          return -8;

        else
        {
          pthread_mutex_lock(&ph->complete_lock);
          io = (struct usbi_io *)((char *)(&ph->complete_list)->next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
          for( ; !(&io->list == &ph->complete_list); io = (struct usbi_io *)((char *)io->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list))
            if(!(io == ((struct usbi_io *)NULL)))
            {
              _usbi_debug(ph, (unsigned int)4, "openusb_poll", (unsigned int)1033, "complete list: %p\n", io->req);
              i = 0;
              for( ; !((unsigned int)i >= num_reqs); i = i + 1)
              {
                _usbi_debug(ph, (unsigned int)4, "openusb_poll", (unsigned int)1037, "polling %p", handles[(signed long int)i]);
                if(io->req == handles[(signed long int)i])
                {
                  ph->complete_count = ph->complete_count - 1;
                  found = 1;
                  break;
                }

              }
              if(found == 1)
                break;

            }

          if(found == 1)
          {
            list_del(&io->list);
            *handle = io->req;
            _usbi_debug(ph, (unsigned int)4, "openusb_poll", (unsigned int)1054, "One was completed: %p", io->req);
            usbi_free_io(io);
          }

          else
          {
            _usbi_debug(ph, (unsigned int)4, "openusb_poll", (unsigned int)1059, "No one was completed");
            *handle = (struct openusb_request_handle *)(void *)0;
          }
          pthread_mutex_unlock(&ph->complete_lock);
          return 0;
        }
      }
    }
}

// openusb_release_interface
// file ../src/openusb.h line 1016
signed int openusb_release_interface(unsigned long int dev, unsigned char ifc)
{
  struct usbi_dev_handle *hdev;
  signed int ret;
  if((signed int)ifc >= 33)
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -11;

    else
    {
      signed int return_value_openusb_is_interface_claimed_1;
      return_value_openusb_is_interface_claimed_1=openusb_is_interface_claimed(dev, ifc);
      if(!(return_value_openusb_is_interface_claimed_1 == 1))
        return -8;

      else
      {
        pthread_mutex_lock(&hdev->lock);
        ret=hdev->idev->ops->release_interface(hdev, ifc);
        pthread_mutex_unlock(&hdev->lock);
        return ret;
      }
    }
  }
}

// openusb_reset
// file api.c line 262
signed int openusb_reset(unsigned long int dev)
{
  struct usbi_dev_handle *hdev;
  signed int ret;
  hdev=usbi_find_dev_handle(dev);
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
    if(hdev->idev->ops->reset == ((signed int (*)(struct usbi_dev_handle *))NULL))
      return -4;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      ret=hdev->idev->ops->reset(hdev);
      pthread_mutex_unlock(&hdev->lock);
      return ret;
    }
}

// openusb_set_altsetting
// file ../src/openusb.h line 1042
signed int openusb_set_altsetting(unsigned long int dev, unsigned char ifc, unsigned char alt)
{
  struct usbi_dev_handle *hdev;
  struct usbi_device *idev;
  struct usbi_config *pcfg;
  signed int ret;
  hdev=usbi_find_dev_handle(dev);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
    if((signed int)ifc >= 33)
      return -8;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      idev = hdev->idev;
      pthread_mutex_unlock(&hdev->lock);
      signed int return_value_usbi_fetch_and_parse_descriptors_1;
      return_value_usbi_fetch_and_parse_descriptors_1=usbi_fetch_and_parse_descriptors(hdev);
      if(!(return_value_usbi_fetch_and_parse_descriptors_1 == 0))
        return -10;

      else
      {
        pthread_mutex_lock(&hdev->lock);
        if(!(idev->cur_config_index >= 0))
        {
          _usbi_debug(hdev->lib_hdl, (unsigned int)1, "openusb_set_altsetting", (unsigned int)203, "config value = %d\n", idev->cur_config_value);
          return -10;
        }

        else
          pcfg = &idev->desc.configs[(signed long int)idev->cur_config_index];
        if((signed int)ifc >= 33 || !(pcfg->num_interfaces >= (unsigned long int)ifc))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = hdev->claimed_ifs[(signed long int)ifc].clm != 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (unsigned long int)alt >= (pcfg->interfaces + (signed long int)ifc)->num_altsettings ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_3)
        {
          _usbi_debug(hdev->lib_hdl, (unsigned int)1, "openusb_set_altsetting", (unsigned int)216, "invalid interface(%d) or alt(%d)", ifc, alt);
          pthread_mutex_unlock(&hdev->lock);
          return -8;
        }

        else
          if((signed int)alt == hdev->claimed_ifs[(signed long int)ifc].altsetting)
          {
            _usbi_debug(hdev->lib_hdl, (unsigned int)1, "openusb_set_altsetting", (unsigned int)223, "same alt, no need to change");
            pthread_mutex_unlock(&hdev->lock);
            return 0;
          }

          else
          {
            ret=hdev->idev->ops->set_altsetting(hdev, ifc, alt);
            pthread_mutex_unlock(&hdev->lock);
            return ret;
          }
      }
    }
}

// openusb_set_configuration
// file ../src/openusb.h line 990
signed int openusb_set_configuration(unsigned long int dev, unsigned char cfg)
{
  struct usbi_dev_handle *hdev;
  struct usb_device_desc desc;
  signed int ret;
  hdev=usbi_find_dev_handle(dev);
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
  {
    ret=openusb_parse_device_desc(hdev->lib_hdl->handle, hdev->idev->devid, (unsigned char *)(void *)0, (unsigned short int)0, &desc);
    if(!(ret == 0))
      return ret;

    else
      if(!((signed int)desc.bNumConfigurations >= (signed int)cfg) || !((signed int)cfg >= 1))
        return -8;

      else
      {
        signed int return_value;
        return_value=hdev->idev->ops->set_configuration(hdev, cfg);
        return return_value;
      }
  }
}

// openusb_set_debug
// file usb.c line 738
void openusb_set_debug(unsigned long int handle, unsigned int level, unsigned int flags, void (*callback)(unsigned long int, const char *, void **))
{
  struct usbi_handle *hdl;
  hdl=usbi_find_handle(handle);
  if(!(hdl == ((struct usbi_handle *)NULL)))
  {
    pthread_mutex_lock(&hdl->lock);
    if(!(callback == ((void (*)(unsigned long int, const char *, void **))NULL)))
      hdl->debug_cb = callback;

    hdl->debug_level = level;
    hdl->debug_flags = flags;
    pthread_mutex_unlock(&hdl->lock);
    if(!(level == 0u))
      _usbi_debug(hdl, (unsigned int)4, "openusb_set_debug", (unsigned int)760, "setting debugging level to %d (%s)", level, level != 0u ? "on" : "off");

  }

}

// openusb_set_default_timeout
// file ../src/openusb.h line 636
signed int openusb_set_default_timeout(unsigned long int handle, enum openusb_transfer_type type, unsigned int timeout)
{
  struct usbi_handle *hdl;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_set_default_timeout", (unsigned int)771, "Default timeout for type(%d): %d", type, timeout);
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
    if((signed int)type >= 5 || !((signed int)type >= 0))
      return -8;

    else
    {
      pthread_mutex_lock(&hdl->lock);
      if((signed int)type == USB_TYPE_ALL)
      {
        signed int i = USB_TYPE_CONTROL;
        for( ; !(i >= 5); i = i + 1)
          hdl->timeout[(signed long int)i] = timeout;
      }

      else
        hdl->timeout[(signed long int)type] = timeout;
      pthread_mutex_unlock(&hdl->lock);
      return 0;
    }
}

// openusb_set_event_callback
// file ../src/openusb.h line 579
signed int openusb_set_event_callback(unsigned long int handle, enum openusb_event type, void (*callback)(unsigned long int, unsigned long int, enum openusb_event, void *), void *arg)
{
  struct usbi_handle *hdl;
  hdl=usbi_find_handle(handle);
  if(hdl == ((struct usbi_handle *)NULL))
    return -12;

  else
    if((signed int)type >= 7 || !((signed int)type >= 0))
      return -8;

    else
    {
      pthread_mutex_lock(&hdl->lock);
      hdl->event_cbs[(signed long int)type].func = callback;
      hdl->event_cbs[(signed long int)type].arg = arg;
      pthread_mutex_unlock(&hdl->lock);
      usbi_coldplug_complete(hdl);
      return 0;
    }
}

// openusb_start
// file api.c line 1398
signed int openusb_start(struct openusb_multi_request_handle *handle)
{
  signed int ret = 0;
  unsigned long int dev;
  unsigned char ifc;
  unsigned char endpoint;
  enum openusb_transfer_type type;
  struct openusb_request_handle *req;
  struct usbi_dev_handle *hdev;
  struct usbi_multi_request *mi_req;
  unsigned long int thread;
  if(handle == ((struct openusb_multi_request_handle *)NULL))
    return -8;

  else
  {
    dev = handle->dev;
    ifc = handle->interface;
    endpoint = handle->endpoint;
    type = handle->type;
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_start", (unsigned int)1422, "invalid device");
      return -8;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc(sizeof(struct usbi_multi_request) /*136ul*/ , (unsigned long int)1);
      mi_req = (struct usbi_multi_request *)return_value_calloc_1;
      if(mi_req == ((struct usbi_multi_request *)NULL))
      {
        _usbi_debug(hdev->lib_hdl, (unsigned int)1, "openusb_start", (unsigned int)1428, "malloc fail");
        return -2;
      }

      else
      {
        void *return_value_calloc_2;
        return_value_calloc_2=calloc(sizeof(struct openusb_request_handle) /*40ul*/ , (unsigned long int)1);
        req = (struct openusb_request_handle *)return_value_calloc_2;
        if(req == ((struct openusb_request_handle *)NULL))
          return -2;

        else
        {
          memset((void *)req, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
          req->dev = handle->dev;
          req->interface = handle->interface;
          req->endpoint = handle->endpoint;
          req->type = handle->type;
          signed int return_value_check_req_valid_3;
          return_value_check_req_valid_3=check_req_valid(req, hdev);
          if(!(return_value_check_req_valid_3 == 0))
          {
            free((void *)mi_req);
            ret = -1;
          }

          free((void *)req);
          mi_req->mreq = handle;
          pthread_mutex_init(&mi_req->lock, (const union anonymous_2 *)(void *)0);
          pthread_cond_init(&mi_req->cv, (const union anonymous_2 *)(void *)0);
          list_init(&mi_req->list);
          list_init(&mi_req->req_head);
          pthread_create(&thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)process_multi_request, (void *)mi_req);
          pthread_mutex_lock(&hdev->lock);
          list_add(&mi_req->list, &hdev->m_head);
          pthread_mutex_unlock(&hdev->lock);
          _usbi_debug(hdev->lib_hdl, (unsigned int)4, "openusb_start", (unsigned int)1464, "End");
          return ret;
        }
      }
    }
  }
}

// openusb_stop
// file api.c line 1518
signed int openusb_stop(struct openusb_multi_request_handle *handle)
{
  signed int return_value_usbi_add_or_stop_1;
  return_value_usbi_add_or_stop_1=usbi_add_or_stop(handle, 2);
  return return_value_usbi_add_or_stop_1;
}

// openusb_strerror
// file ../src/openusb.h line 663
const char * openusb_strerror(signed int error)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 29ul); i = i + 1ul)
    if(errorstrs[(signed long int)i].code == error)
      return errorstrs[(signed long int)i].msg;

  return "Unknown error";
}

// openusb_wait
// file ../src/openusb.h line 1151
signed int openusb_wait(unsigned int num_reqs, struct openusb_request_handle **handles, struct openusb_request_handle **handle)
{
  signed int i;
  signed int found = 0;
  struct usbi_dev_handle *hdev;
  struct usbi_handle *ph;
  struct usbi_io *io;
  if(num_reqs == 0u)
    return 0;

  else
    if(handle == ((struct openusb_request_handle **)NULL) || handles == ((struct openusb_request_handle **)NULL))
      return -8;

    else
    {
      hdev=usbi_find_dev_handle(handles[(signed long int)0]->dev);
      if(hdev == ((struct usbi_dev_handle *)NULL))
      {
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_wait", (unsigned int)912, "can't find device");
        return -8;
      }

      else
      {
        ph = hdev->lib_hdl;
        if(ph == ((struct usbi_handle *)NULL))
        {
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_wait", (unsigned int)919, "lib handle error");
          return -8;
        }

        else
        {
          i = 0;
          for( ; !((unsigned int)i >= num_reqs); i = i + 1)
            if(!(handles[(signed long int)i]->cb == ((signed int (*)(struct openusb_request_handle *))NULL)))
            {
              _usbi_debug(ph, (unsigned int)1, "openusb_wait", (unsigned int)931, "Callback should notset here");
              return -8;
            }

          do
          {

          waiting:
            ;
            pthread_mutex_lock(&ph->complete_lock);
            _usbi_debug(ph, (unsigned int)4, "openusb_wait", (unsigned int)940, "ph = %p, cv=%p, count = %d, lock=%p", ph, &ph->complete_cv, ph->complete_count, &ph->complete_lock);
            while(ph->complete_count == 0)
              pthread_cond_wait(&ph->complete_cv, &ph->complete_lock);
            io = (struct usbi_io *)((char *)(&ph->complete_list)->next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
            for( ; !(&io->list == &ph->complete_list); io = (struct usbi_io *)((char *)io->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list))
              if(!(io == ((struct usbi_io *)NULL)))
              {
                _usbi_debug(ph, (unsigned int)4, "openusb_wait", (unsigned int)951, "waiting list: %p\n", io->req);
                i = 0;
                for( ; !((unsigned int)i >= num_reqs); i = i + 1)
                  if(io->req == handles[(signed long int)i])
                  {
                    found = 1;
                    break;
                  }

                if(found == 1)
                  break;

              }

            if(found == 1)
            {
              list_del(&io->list);
              ph->complete_count = ph->complete_count - 1;
              _usbi_debug(ph, (unsigned int)4, "openusb_wait", (unsigned int)969, "One was completed");
              *handle = io->req;
              pthread_mutex_unlock(&ph->complete_lock);
              usbi_free_io(io);
              return 0;
            }

            _usbi_debug(ph, (unsigned int)4, "openusb_wait", (unsigned int)977, "Continue waiting");
            ph->complete_count = ph->complete_count - 1;
            pthread_mutex_unlock(&ph->complete_lock);
          }
          while((_Bool)1);
        }
      }
    }
}

// openusb_xfer_aio
// file ../src/openusb.h line 1077
signed int openusb_xfer_aio(struct openusb_request_handle *req)
{
  signed int ret;
  struct usbi_dev_handle *dev;
  struct usbi_io *io;
  signed int timeout;
  struct usbi_handle *plib;
  if(req == ((struct openusb_request_handle *)NULL))
    return -8;

  else
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_xfer_aio", (unsigned int)784, "Begin: ifc=%d ept=%x type=%d", req->interface, req->endpoint, req->type);
    dev=usbi_find_dev_handle(req->dev);
    if(dev == ((struct usbi_dev_handle *)NULL))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_xfer_aio", (unsigned int)788, "Can't find device");
      return -8;
    }

    else
      if(!(dev->idev->bus->max_xfer_size[(signed long int)req->type] == 0u))
      {
        if(!((signed int)req->type == USB_TYPE_CONTROL))
        {
          if((signed int)req->type == USB_TYPE_INTERRUPT)
            goto __CPROVER_DUMP_L5;

          if((signed int)req->type == USB_TYPE_BULK)
            goto __CPROVER_DUMP_L7;

          if((signed int)req->type == USB_TYPE_ISOCHRONOUS)
            goto __CPROVER_DUMP_L8;

          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)800, "Invalid request type: %d", req->type);
          return -8;
        }

        if(!(dev->idev->bus->max_xfer_size[(signed long int)req->type] >= req->req.ctrl->length))
        {
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)810, "Request too large (%u), max_xfer_size=%u", req->req.ctrl->length, dev->idev->bus->max_xfer_size[(signed long int)req->type]);
          return -53;
        }

        goto __CPROVER_DUMP_L8;

      __CPROVER_DUMP_L5:
        ;
        if(!(dev->idev->bus->max_xfer_size[(signed long int)req->type] >= req->req.intr->length))
        {
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)822, "Request too large (%u), max_xfer_size=%u", req->req.intr->length, dev->idev->bus->max_xfer_size[(signed long int)req->type]);
          return -53;
        }

        goto __CPROVER_DUMP_L8;

      __CPROVER_DUMP_L7:
        ;
        if(dev->idev->bus->max_xfer_size[(signed long int)req->type] >= req->req.bulk->length)
          goto __CPROVER_DUMP_L8;

        _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)835, "Request too large (%u), max_xfer_size=%u", req->req.bulk->length, dev->idev->bus->max_xfer_size[(signed long int)req->type]);
        return -53;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        ret=check_req_valid(req, dev);
        if(!(ret >= 0))
        {
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)849, "Invalid request");
          return -12;
        }

        else
        {
          pthread_mutex_lock(&dev->lock);
          timeout=usbi_get_xfer_timeout(req, dev);
          pthread_mutex_unlock(&dev->lock);
          io=usbi_alloc_io(dev, req, (unsigned int)timeout);
          if(io == ((struct usbi_io *)NULL))
          {
            _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)860, "IO alloc fail");
            return -2;
          }

          else
          {
            io->req = req;
            io->status = (enum usbi_io_status)USBI_IO_INPROGRESS;
            io->flag = (unsigned int)1;
            plib = dev->lib_hdl;
            ret=usbi_io_async(io);
            if(!(ret == 0))
            {
              const char *return_value_openusb_strerror_1;
              return_value_openusb_strerror_1=openusb_strerror(ret);
              _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_aio", (unsigned int)872, "async fail: %s", return_value_openusb_strerror_1);
              pthread_mutex_lock(&dev->lock);
              list_del(&io->list);
              pthread_mutex_unlock(&dev->lock);
              usbi_free_io(io);
              return ret;
            }

            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_xfer_aio", (unsigned int)882, "End");
            return 0;
          }
        }
      }
  }
}

// openusb_xfer_wait
// file api.c line 525
signed int openusb_xfer_wait(struct openusb_request_handle *req)
{
  struct usbi_dev_handle *dev = (struct usbi_dev_handle *)(void *)0;
  signed int io_pattern;
  if(req == ((struct openusb_request_handle *)NULL))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_xfer_wait", (unsigned int)531, "Invalid request");
    return -8;
  }

  else
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "openusb_xfer_wait", (unsigned int)536, "Begin: ifc=%d ept=%x type=%d", req->interface, req->endpoint, req->type);
    dev=usbi_find_dev_handle(req->dev);
    if(dev == ((struct usbi_dev_handle *)NULL))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "openusb_xfer_wait", (unsigned int)540, "Can't find device handle:%llu", req->dev);
      return -12;
    }

    else
      if(!(dev->idev->bus->max_xfer_size[(signed long int)req->type] == 0u))
      {
        if(!((signed int)req->type == USB_TYPE_CONTROL))
        {
          if((signed int)req->type == USB_TYPE_INTERRUPT)
            goto __CPROVER_DUMP_L5;

          if((signed int)req->type == USB_TYPE_BULK)
            goto __CPROVER_DUMP_L7;

          if((signed int)req->type == USB_TYPE_ISOCHRONOUS)
            goto __CPROVER_DUMP_L8;

          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_wait", (unsigned int)550, "Invalid request type: %d", req->type);
          return -8;
        }

        if(!(dev->idev->bus->max_xfer_size[(signed long int)req->type] >= req->req.ctrl->length))
        {
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_wait", (unsigned int)560, "Request too large (%u), max_xfer_size=%u", req->req.ctrl->length, dev->idev->bus->max_xfer_size[(signed long int)req->type]);
          return -53;
        }

        goto __CPROVER_DUMP_L8;

      __CPROVER_DUMP_L5:
        ;
        if(!(dev->idev->bus->max_xfer_size[(signed long int)req->type] >= req->req.intr->length))
        {
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_wait", (unsigned int)572, "Request too large (%u), max_xfer_size=%u", req->req.intr->length, dev->idev->bus->max_xfer_size[(signed long int)req->type]);
          return -53;
        }

        goto __CPROVER_DUMP_L8;

      __CPROVER_DUMP_L7:
        ;
        if(dev->idev->bus->max_xfer_size[(signed long int)req->type] >= req->req.bulk->length)
          goto __CPROVER_DUMP_L8;

        _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_wait", (unsigned int)584, "Request too large (%u), max_xfer_size=%u", req->req.bulk->length, dev->idev->bus->max_xfer_size[(signed long int)req->type]);
        return -53;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        signed int return_value_check_req_valid_1;
        return_value_check_req_valid_1=check_req_valid(req, dev);
        if(!(return_value_check_req_valid_1 >= 0))
        {
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "openusb_xfer_wait", (unsigned int)600, "Not a valid request");
          return -8;
        }

        else
        {
          pthread_mutex_lock(&dev->lock);
          pthread_mutex_lock(&dev->idev->bus->lock);
          io_pattern = dev->idev->bus->ops->io_pattern;
          pthread_mutex_unlock(&dev->idev->bus->lock);
          pthread_mutex_unlock(&dev->lock);
          if(io_pattern >= 5 || !(io_pattern >= 1))
            return -1;

          else
          {
            signed int return_value_usbi_io_sync_2;
            return_value_usbi_io_sync_2=usbi_io_sync(dev, req);
            return return_value_usbi_io_sync_2;
          }
        }
      }
  }
}

// parse_option
// file testopenusb.c line 1364
static signed int parse_option(signed int argc, char **argv)
{
  signed int c;
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_3;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  do
  {
    c=getopt(argc, argv, "t:lmaps");
    if(c == -1)
      break;

    switch(c)
    {
      case 116:
      {
        return_value_strcmp_4=strcmp(optarg, "ctrl");
        if(return_value_strcmp_4 == 0)
          testtype = (enum openusb_transfer_type)USB_TYPE_CONTROL;

        else
        {
          return_value_strcmp_3=strcmp(optarg, "bulk");
          if(return_value_strcmp_3 == 0)
            testtype = (enum openusb_transfer_type)USB_TYPE_BULK;

          else
          {
            return_value_strcmp_2=strcmp(optarg, "intr");
            if(return_value_strcmp_2 == 0)
              testtype = (enum openusb_transfer_type)USB_TYPE_INTERRUPT;

            else
            {
              return_value_strcmp_1=strcmp(optarg, "isoc");
              if(return_value_strcmp_1 == 0)
                testtype = (enum openusb_transfer_type)USB_TYPE_ISOCHRONOUS;

              else
              {
                printf("Unknown type\n");
                goto err1;
              }
            }
          }
        }
        break;
      }
      case 108:
      {
        testloop = 1;
        break;
      }
      case 109:
      {
        testmulti = 1;
        break;
      }
      case 97:
      {
        testasync = 1;
        break;
      }
      case 112:
      {
        testhotplug = 1;
        break;
      }
      case 115:
      {
        testsync = 1;
        break;
      }
      case 58:
      {
        printf("-%c has no arguments\n", optopt);
        goto err1;
      }
      case 63:

      default:
      {
        printf("Unknown option: -%c\n", optopt);
        goto err1;
      }
    }
  }
  while((_Bool)1);
  return 0;

err1:
  ;
  usage(argv[(signed long int)0]);
  return -1;
}

// print_configuration
// file testopenusb.c line 83
static void print_configuration(unsigned long int devid, signed int cfgidx, struct usb_config_desc *cfg)
{
  signed int i;
  signed int ret;
  printf("  Config:\t\t%d\n", cfgidx);
  printf("  wTotalLength:         %d\n", cfg->wTotalLength);
  printf("  bNumInterfaces:       %d\n", cfg->bNumInterfaces);
  printf("  bConfigurationValue:  %d\n", cfg->bConfigurationValue);
  printf("  iConfiguration:       %d\n", cfg->iConfiguration);
  printf("  bmAttributes:         %02xh\n", cfg->bmAttributes);
  printf("  MaxPower:             %d\n", cfg->bMaxPower);
  printf("\n");
  i = 0;
  for( ; !(i >= (signed int)cfg->bNumInterfaces); i = i + 1)
  {
    struct usb_interface_desc intf;
    signed int j = 0;
    do
    {
      ret=openusb_parse_interface_desc(libhandle, devid, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned char)cfgidx, (unsigned char)i, (unsigned char)j, &intf);
      if(!(ret == 0))
        break;

      print_interface(devid, cfgidx, i, j, &intf);
      j = j + 1;
    }
    while((_Bool)1);
  }
}

// print_device
// file testopenusb.c line 117
static void print_device(unsigned long int devid, signed int indent)
{
  struct usb_device_desc dev;
  unsigned char *buf = (unsigned char *)(void *)0;
  unsigned short int buflen = (unsigned short int)0;
  signed int i;
  signed int ret;
  printf("\n%.*s+ device #%d\n", indent * 2, (const void *)"                ", (signed int)devid);
  ret=openusb_parse_device_desc(libhandle, devid, (unsigned char *)(void *)0, (unsigned short int)0, &dev);
  if(ret == 0)
  {
    printf("bcdUSB:                 %04xh\n", dev.bcdUSB);
    printf("bDeviceClass:           %02x\n", dev.bDeviceClass);
    printf("bDeviceSubClass:        %02x\n", dev.bDeviceSubClass);
    printf("bDeviceProtocol:        %02x\n", dev.bDeviceProtocol);
    printf("bMaxPacketSize0:        %02x\n", dev.bMaxPacketSize0);
    printf("idVendor:               %04xh\n", dev.idVendor);
    printf("idProduct:              %04xh\n", dev.idProduct);
    printf("bcdDevice:              %04xh\n", dev.bcdDevice);
    printf("iManufacturer:          %d\n", dev.iManufacturer);
    printf("iProduct:               %d\n", dev.iProduct);
    printf("iSerialNumber:          %d\n", dev.iSerialNumber);
    printf("bNumConfigurations:     %d\n", dev.bNumConfigurations);
    printf("\n");
    i = 0;
    for( ; !(i >= (signed int)dev.bNumConfigurations); i = i + 1)
    {
      struct usb_config_desc cfg;
      ret=openusb_parse_config_desc(libhandle, devid, buf, buflen, (unsigned char)i, &cfg);
      if(!(ret == 0))
      {
        const char *return_value_openusb_strerror_1;
        return_value_openusb_strerror_1=openusb_strerror(ret);
        printf("parse config desc fail: %s\n", return_value_openusb_strerror_1);
        goto __CPROVER_DUMP_L5;
      }

      print_configuration(devid, i, &cfg);
    }
    printf("\n");
  }


__CPROVER_DUMP_L5:
  ;
}

// print_endpoint
// file testopenusb.c line 41
static void print_endpoint(struct usb_endpoint_desc *ep)
{
  printf("      bEndpointAddress: %02xh\n", ep->bEndpointAddress);
  printf("      bmAttributes:     %02xh\n", ep->bmAttributes);
  printf("      wMaxPacketSize:   %d\n", ep->wMaxPacketSize);
  printf("      bInterval:        %d\n", ep->bInterval);
  printf("      bRefresh:         %d\n", ep->bRefresh);
  printf("      bSynchAddress:    %d\n", ep->bSynchAddress);
  printf("\n");
}

// print_interface
// file testopenusb.c line 52
static void print_interface(unsigned long int devid, signed int cfgidx, signed int ifcidx, signed int alt, struct usb_interface_desc *intf)
{
  signed int i;
  signed int ret;
  printf("    Interface:\t\t%d\n", ifcidx);
  printf("    bInterfaceNumber:   %d\n", intf->bInterfaceNumber);
  printf("    bAlternateSetting:  %d\n", intf->bAlternateSetting);
  printf("    bNumEndpoints:      %d\n", intf->bNumEndpoints);
  printf("    bInterfaceClass:    %02x\n", intf->bInterfaceClass);
  printf("    bInterfaceSubClass: %02x\n", intf->bInterfaceSubClass);
  printf("    bInterfaceProtocol: %02x\n", intf->bInterfaceProtocol);
  printf("    iInterface:         %d\n", intf->iInterface);
  printf("\n");
  i = 0;
  for( ; !(i >= (signed int)intf->bNumEndpoints); i = i + 1)
  {
    struct usb_endpoint_desc ep;
    ret=openusb_parse_endpoint_desc(libhandle, devid, (unsigned char *)(void *)0, (unsigned short int)0, (unsigned char)cfgidx, (unsigned char)ifcidx, (unsigned char)alt, (unsigned char)i, &ep);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_1;
      return_value_openusb_strerror_1=openusb_strerror(ret);
      printf("parse endpoint desc fail, ret = %d %s\n", ret, return_value_openusb_strerror_1);
      goto __CPROVER_DUMP_L4;
    }

    print_endpoint(&ep);
  }

__CPROVER_DUMP_L4:
  ;
}

// process_event_callbacks
// file usb.c line 139
static void * process_event_callbacks(void *unused)
{
  while((_Bool)1)
  {
    struct eventcallback *cb = (struct eventcallback *)(void *)0;
    struct list_head *listh;
    pthread_mutex_lock(&event_callbacks.lock);
    while(callback_queue_full == 0)
    {
      pthread_cond_wait(&event_callback_cond, &event_callbacks.lock);
      if(!(event_callback_exit == 0))
      {
        event_callback_exit = 0;
        pthread_mutex_unlock(&event_callbacks.lock);
        return (void *)0;
      }

    }
    listh = event_callbacks.head.next;
    while(!(listh == &event_callbacks.head))
    {
      unsigned long int devid;
      enum openusb_event type;
      struct usbi_handle *hdl;
      void (*func)(unsigned long int, unsigned long int, enum openusb_event, void *);
      void *arg;
      cb = (struct eventcallback *)((char *)&listh->prev - (signed long int)(unsigned long int)&((struct eventcallback *)0L)->list);
      listh = listh->next;
      list_del(&cb->list);
      devid = cb->devid;
      type = cb->type;
      hdl = cb->handle;
      func = hdl->event_cbs[(signed long int)type].func;
      arg = hdl->event_cbs[(signed long int)type].arg;
      pthread_mutex_unlock(&event_callbacks.lock);
      if(!(func == ((void (*)(unsigned long int, unsigned long int, enum openusb_event, void *))NULL)))
      {
        _usbi_debug(hdl, (unsigned int)4, "process_event_callbacks", (unsigned int)190, "callback called");
        func(hdl->handle, devid, type, arg);
      }

      else
        _usbi_debug(hdl, (unsigned int)4, "process_event_callbacks", (unsigned int)193, "No callback");
      pthread_mutex_lock(&event_callbacks.lock);
      free((void *)cb);
      callback_queue_full = callback_queue_full - 1;
    }
    pthread_mutex_unlock(&event_callbacks.lock);
  }
}

// process_multi_request
// file api.c line 1177
static signed int process_multi_request(void *arg)
{
  struct usbi_multi_request *mi_req = (struct usbi_multi_request *)arg;
  signed int i;
  unsigned long int dev;
  unsigned char ifc;
  unsigned char endpoint;
  enum openusb_transfer_type type;
  struct openusb_request_handle *req;
  struct usbi_dev_handle *hdev;
  struct openusb_multi_request_handle *mh;
  struct usbi_multi_req_args *args;
  unsigned int req_num = (unsigned int)0;
  signed int ret;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "process_multi_request", (unsigned int)1192, "Begin");
  if(mi_req == ((struct usbi_multi_request *)NULL))
    return -8;

  else
  {
    mh = mi_req->mreq;
    dev = mh->dev;
    ifc = mh->interface;
    endpoint = mh->endpoint;
    type = mh->type;
    hdev=usbi_find_dev_handle(dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -8;

    else
      do
      {

      loop:
        ;
        pthread_mutex_lock(&mi_req->lock);
        if((signed int)type == USB_TYPE_BULK)
          req_num = mh->req.bulk->num_bufs;

        else
          if((signed int)type == USB_TYPE_INTERRUPT)
            req_num = mh->req.intr->num_bufs;

          else
            if((signed int)type == USB_TYPE_ISOCHRONOUS)
              req_num = mh->req.isoc->num_pkts;

        _usbi_debug(hdev->lib_hdl, (unsigned int)4, "process_multi_request", (unsigned int)1224, "Num_req = %d", req_num);
        i = 0;
        for( ; !((unsigned int)i >= req_num); i = i + 1)
        {
          _usbi_debug(hdev->lib_hdl, (unsigned int)4, "process_multi_request", (unsigned int)1227, "submit request %d", i);
          void *return_value_calloc_1;
          return_value_calloc_1=calloc(sizeof(struct openusb_request_handle) /*40ul*/ , (unsigned long int)1);
          req = (struct openusb_request_handle *)return_value_calloc_1;
          if(req == ((struct openusb_request_handle *)NULL))
          {
            _usbi_debug(hdev->lib_hdl, (unsigned int)1, "process_multi_request", (unsigned int)1231, "No resources");
            pthread_mutex_unlock(&mi_req->lock);
            return -2;
          }

          void *return_value_calloc_2;
          return_value_calloc_2=calloc(sizeof(struct usbi_multi_req_args) /*40ul*/ , (unsigned long int)1);
          args = (struct usbi_multi_req_args *)return_value_calloc_2;
          if(args == ((struct usbi_multi_req_args *)NULL))
          {
            _usbi_debug(hdev->lib_hdl, (unsigned int)1, "process_multi_request", (unsigned int)1241, "No resources");
            pthread_mutex_unlock(&mi_req->lock);
            return -2;
          }

          memset((void *)req, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
          memset((void *)args, 0, sizeof(struct usbi_multi_req_args) /*40ul*/ );
          req->dev = mh->dev;
          req->interface = mh->interface;
          req->endpoint = mh->endpoint;
          req->type = mh->type;
          args->mi_req = mi_req;
          _usbi_debug(hdev->lib_hdl, (unsigned int)4, "process_multi_request", (unsigned int)1256, "args->mi_req = %p", args->mi_req);
          args->idx = (unsigned int)i;
          args->req = req;
          list_add(&args->list, &mi_req->req_head);
          req->arg = (void *)args;
          req->cb = multi_req_callback;
          if((signed int)type == USB_TYPE_BULK)
          {
            struct openusb_multi_bulk_request *m_bulk;
            struct openusb_bulk_request *bulk;
            m_bulk = mh->req.bulk;
            void *return_value_calloc_3;
            return_value_calloc_3=calloc(sizeof(struct openusb_bulk_request) /*40ul*/ , (unsigned long int)1);
            bulk = (struct openusb_bulk_request *)return_value_calloc_3;
            if(bulk == ((struct openusb_bulk_request *)NULL))
            {
              pthread_mutex_unlock(&mi_req->lock);
              return -2;
            }

            memset((void *)bulk, 0, sizeof(struct openusb_bulk_request) /*40ul*/ );
            bulk->payload = m_bulk->payloads[(signed long int)i];
            bulk->length = m_bulk->lengths[(signed long int)i];
            bulk->timeout = m_bulk->timeout;
            bulk->flags = m_bulk->flags;
            req->req.bulk = bulk;
            pthread_mutex_unlock(&mi_req->lock);
            openusb_xfer_aio(req);
            pthread_mutex_lock(&mi_req->lock);
            m_bulk->rp = m_bulk->rp + 1u;
          }

          else
            if((signed int)type == USB_TYPE_INTERRUPT)
            {
              struct openusb_multi_intr_request *m_intr;
              struct openusb_intr_request *intr;
              m_intr = mh->req.intr;
              void *return_value_calloc_4;
              return_value_calloc_4=calloc(sizeof(struct openusb_intr_request) /*48ul*/ , (unsigned long int)1);
              intr = (struct openusb_intr_request *)return_value_calloc_4;
              if(intr == ((struct openusb_intr_request *)NULL))
              {
                pthread_mutex_unlock(&mi_req->lock);
                return -2;
              }

              intr->payload = m_intr->payloads[(signed long int)i];
              intr->length = m_intr->lengths[(signed long int)i];
              intr->timeout = m_intr->timeout;
              intr->flags = m_intr->flags;
              _usbi_debug(hdev->lib_hdl, (unsigned int)4, "process_multi_request", (unsigned int)1314, "Intr len=%d,buf=%p", intr->length, intr->payload);
              req->req.intr = intr;
              pthread_mutex_unlock(&mi_req->lock);
              ret=openusb_xfer_aio(req);
              pthread_mutex_lock(&mi_req->lock);
              if(!(ret == 0))
              {
                _usbi_debug(hdev->lib_hdl, (unsigned int)1, "process_multi_request", (unsigned int)1324, "intr aio fail");
                pthread_mutex_unlock(&mi_req->lock);
                return ret;
              }

              m_intr->rp = m_intr->rp + 1u;
            }

            else
              if((signed int)type == USB_TYPE_ISOCHRONOUS)
              {
                struct openusb_multi_isoc_request *m_isoc;
                struct openusb_isoc_request *isoc;
                m_isoc = mh->req.isoc;
                void *return_value_calloc_5;
                return_value_calloc_5=calloc(sizeof(struct openusb_isoc_request) /*48ul*/ , (unsigned long int)1);
                isoc = (struct openusb_isoc_request *)return_value_calloc_5;
                if(isoc == ((struct openusb_isoc_request *)NULL))
                {
                  free((void *)req);
                  pthread_mutex_unlock(&mi_req->lock);
                  return -2;
                }

                memset((void *)isoc, 0, sizeof(struct openusb_isoc_request) /*48ul*/ );
                isoc->pkts = m_isoc->pkts[(signed long int)i];
                isoc->start_frame = m_isoc->start_frame;
                isoc->flags = m_isoc->flags;
                req->req.isoc = isoc;
                pthread_mutex_unlock(&mi_req->lock);
                openusb_xfer_aio(req);
                pthread_mutex_lock(&mi_req->lock);
                m_isoc->rp = m_isoc->rp + 1u;
              }

              else
              {
                pthread_mutex_unlock(&mi_req->lock);
                return -8;
              }
        }
        mi_req->flag = 0;
        while(mi_req->flag == 0)
          pthread_cond_wait(&mi_req->cv, &mi_req->lock);
        if(mi_req->flag == 2)
        {
          struct usbi_multi_req_args *pargs;
          struct usbi_multi_req_args *tmp;
          pargs = (struct usbi_multi_req_args *)((char *)(&mi_req->req_head)->next - (signed long int)(unsigned long int)&((struct usbi_multi_req_args *)0L)->list);
          tmp = (struct usbi_multi_req_args *)((char *)pargs->list.next - (signed long int)(unsigned long int)&((struct usbi_multi_req_args *)0L)->list);
          for( ; !(&pargs->list == &mi_req->req_head); tmp = (struct usbi_multi_req_args *)((char *)tmp->list.next - (signed long int)(unsigned long int)&((struct usbi_multi_req_args *)0L)->list))
          {
            if(!(pargs == ((struct usbi_multi_req_args *)NULL)))
            {
              pthread_mutex_unlock(&mi_req->lock);
              openusb_abort(pargs->req);
              pthread_mutex_lock(&mi_req->lock);
              free((void *)pargs->req);
              free((void *)pargs);
            }

            pargs = tmp;
          }
          pthread_mutex_unlock(&mi_req->lock);
          free((void *)mi_req);
          return 0;
        }

        pthread_mutex_unlock(&mi_req->lock);
      }
      while((_Bool)1);
  }
}

// refresh_bus
// file devices.c line 124
static void refresh_bus(struct usbi_backend *backend)
{
  struct list_head busses;
  struct usbi_bus *ibus;
  struct usbi_bus *tibus;
  signed int ret;
  list_init(&busses);
  _Bool tmp_if_expr_2;
  signed int return_value_strcmp_1;
  if(backend->ops->find_buses == ((signed int (*)(struct list_head *))NULL))
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "refresh_bus", (unsigned int)133, "NULL bus");

  else
  {
    ret=backend->ops->find_buses(&busses);
    if(ret >= 0)
    {
      pthread_mutex_lock(&usbi_buses.lock);
      ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      tibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      if(!(&ibus->list == &usbi_buses.head))
      {
        if(!(ibus == ((struct usbi_bus *)NULL)))
        {
          struct usbi_bus *nibus;
          struct usbi_bus *tnibus;
          signed int found = 0;
          nibus = (struct usbi_bus *)((char *)(&busses)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
          tnibus = (struct usbi_bus *)((char *)nibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
          if(!(&nibus->list == &busses))
          {
            if(!(nibus == ((struct usbi_bus *)NULL)))
            {
              pthread_mutex_lock(&ibus->lock);
              if(ibus->busnum == nibus->busnum)
                tmp_if_expr_2 = (_Bool)1;

              else
              {
                return_value_strcmp_1=strcmp(ibus->sys_path, nibus->sys_path);
                tmp_if_expr_2 = return_value_strcmp_1 == 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_2)
              {
                pthread_mutex_unlock(&ibus->lock);
                list_del(&nibus->list);
                usbi_free_bus(nibus);
                found = 1;
              }

              pthread_mutex_unlock(&ibus->lock);
            }

            nibus = tnibus;
            tnibus = (struct usbi_bus *)((char *)tnibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
          }

          if(found == 0)
            list_del(&ibus->list);

        }

        ibus = tibus;
        tibus = (struct usbi_bus *)((char *)tibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      }

      ibus = (struct usbi_bus *)((char *)(&busses)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      tibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      if(!(&ibus->list == &busses))
      {
        if(!(ibus == ((struct usbi_bus *)NULL)))
        {
          list_del(&ibus->list);
          usbi_add_bus(ibus, backend);
        }

        ibus = tibus;
        tibus = (struct usbi_bus *)((char *)tibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
      }

      pthread_mutex_unlock(&usbi_buses.lock);
    }

  }
}

// simple_io_complete
// file io.c line 328
static void simple_io_complete(struct simple_io *io, signed int status)
{
  pthread_mutex_lock(&io->lock);
  io->completed = 1;
  io->status = status;
  pthread_cond_signal(&io->complete);
  pthread_mutex_unlock(&io->lock);
}

// simple_io_setup
// file io.c line 302
static void simple_io_setup(struct simple_io *io)
{
  pthread_mutex_init(&io->lock, (const union anonymous_2 *)(void *)0);
  pthread_cond_init(&io->complete, (const union anonymous_2 *)(void *)0);
  io->completed = 0;
}

// simple_io_wait
// file io.c line 310
static signed int simple_io_wait(struct simple_io *io)
{
  signed int status;
  pthread_mutex_lock(&io->lock);
  if(io->completed == 0)
    pthread_cond_wait(&io->complete, &io->lock);

  status = io->status;
  pthread_mutex_unlock(&io->lock);
  return status;
}

// test_async_xfer
// file testopenusb.c line 1175
static signed int test_async_xfer(unsigned long int devh)
{
  signed int ret;
  ret=async_xfer_ctrl_test(devh);
  if(!(ret == 0))
  {
    printf("ASYNC CTRL xfer fail\n");
    return -1;
  }

  else
  {
    ret=async_xfer_test(devh, testtype, testloop);
    if(!(ret == 0))
    {
      printf("TEST ASYNC XFER FAIL\n");
      return -1;
    }

    else
      return 0;
  }
}

// test_bulk_sync
// file testopenusb.c line 340
static signed int test_bulk_sync(unsigned long int devh)
{
  unsigned char bulkdata[128l];
  unsigned char bulkrd[128l];
  struct openusb_bulk_request bulk;
  signed int i;
  signed int ret;
  printf("Test BULK sync:\n");
  memset((void *)&bulk, 0, sizeof(struct openusb_bulk_request) /*40ul*/ );
  memset((void *)bulkrd, 0, (unsigned long int)128);
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    bulkdata[(signed long int)i] = (unsigned char)i;
  bulk.payload = bulkdata;
  bulk.length = (unsigned int)128;
  bulk.timeout = (unsigned int)10;
  ret=openusb_claim_interface(devh, (unsigned char)0, (enum openusb_init_flag)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_1;
    return_value_openusb_strerror_1=openusb_strerror(ret);
    printf("Device(%llu) claim interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_1);
    return -1;
  }

  ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_2;
    return_value_openusb_strerror_2=openusb_strerror(ret);
    printf("Device(%llu) interface(0) set alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_2);
    return -1;
  }

  ret=openusb_bulk_xfer(devh, (unsigned char)0, (unsigned char)2, &bulk);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_3;
    return_value_openusb_strerror_3=openusb_strerror(ret);
    printf("BULK sync xfer test fail: %s\n", return_value_openusb_strerror_3);
    return -1;
  }

  printf("bulk sync xfer result.status = %d,xfer_bytes=%d, ret=%d\n", bulk.result.status, bulk.result.transferred_bytes, ret);
  bulk.payload = bulkrd;
  ret=openusb_bulk_xfer(devh, (unsigned char)0, (unsigned char)0x86, &bulk);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_4;
    return_value_openusb_strerror_4=openusb_strerror(ret);
    printf("bulk sync xfer fail: %s\n", return_value_openusb_strerror_4);
    return -1;
  }

  printf("\nBULK DATA:\n");
  i = 0;
  for( ; !(i >= 128); i = i + 1)
  {
    if(i % 16 == 0)
      printf("\n");

    printf("%02x ", (unsigned char)bulkrd[(signed long int)i]);
  }
  printf("\n");
  printf("BULK SYNC xfer test: PASS\n");
  return 0;
}

// test_ctrl_sync
// file testopenusb.c line 287
static signed int test_ctrl_sync(unsigned long int devh)
{
  struct openusb_ctrl_request ctrl;
  signed int ret;
  signed int i;
  memset((void *)&ctrl, 0, sizeof(struct openusb_ctrl_request) /*48ul*/ );
  ctrl.setup.bmRequestType = (unsigned char)0x80;
  ctrl.setup.bRequest = (unsigned char)0x06;
  ctrl.setup.wValue = (unsigned short int)(0x02 << 8 | 0x01);
  ctrl.setup.wIndex = (unsigned short int)0;
  ctrl.length = (unsigned int)0xab;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)ctrl.length);
  ctrl.payload = (unsigned char *)return_value_malloc_1;
  if(ctrl.payload == ((unsigned char *)NULL))
  {
    printf("malloc fail\n");
    return -1;
  }

  else
  {
    memset((void *)ctrl.payload, 0, (unsigned long int)0xab);
    ret=openusb_ctrl_xfer(devh, (unsigned char)0, (unsigned char)0, &ctrl);
    if(!(ret == 0))
    {
      openusb_free_devid_list(devids);
      const char *return_value_openusb_strerror_2;
      return_value_openusb_strerror_2=openusb_strerror(ret);
      printf("ctrl xfer fail: %s\n", return_value_openusb_strerror_2);
      return -1;
    }

    printf("CONTROL: result.status = %d, xfer_bytes=%d\n", ctrl.result.status, ctrl.result.transferred_bytes);
    printf("CONTROL TEST DATA:\n");
    i = 0;
    for( ; !(i >= 0xab); i = i + 1)
    {
      if(i % 16 == 0)
        printf("\n");

      printf("%02x ", (unsigned char)ctrl.payload[(signed long int)i]);
    }
    printf("\n");
    if(ctrl.result.status == 0)
      printf("openusb_ctrl_xfer: PASS\n");

    free((void *)ctrl.payload);
    return 0;
  }
}

// test_get_device_data
// file testopenusb.c line 1113
static signed int test_get_device_data(void)
{
  signed int ret;
  struct openusb_dev_data *devdata;
  unsigned int i;
  unsigned int j = (unsigned int)0;
  for( ; !(j >= busnum); j = j + 1u)
  {
    ret=openusb_get_devids_by_bus(libhandle, bus[(signed long int)j], &devids, &devnum);
    if(!(ret >= 0))
    {
      const char *return_value_openusb_strerror_1;
      return_value_openusb_strerror_1=openusb_strerror(ret);
      printf("Error get devids by bus: %s\n", return_value_openusb_strerror_1);
      return -1;
    }

    i = (unsigned int)0;
    for( ; !(i >= devnum); i = i + 1u)
    {
      print_device(devids[(signed long int)i], 4);
      ret=openusb_get_device_data(libhandle, devids[(signed long int)i], (unsigned int)0, &devdata);
      if(!(ret >= 0))
      {
        const char *return_value_openusb_strerror_2;
        return_value_openusb_strerror_2=openusb_strerror(ret);
        printf("Get device(%d) data error: %s\n", i, return_value_openusb_strerror_2);
      }

      else
      {
        dump_dev_data(devdata);
        openusb_free_device_data(devdata);
      }
    }
    openusb_free_devid_list(devids);
  }
  return 0;
}

// test_intr_sync
// file testopenusb.c line 417
static signed int test_intr_sync(unsigned long int devh, signed int flag)
{
  unsigned char bulkdata[128l];
  unsigned char bulkrd[128l];
  struct openusb_intr_request intr;
  signed int i;
  signed int ret;
  printf("Test INTR sync:\n");
  memset((void *)&intr, 0, sizeof(struct openusb_intr_request) /*48ul*/ );
  i = 0;
  for( ; !(i >= 128); i = i + 1)
    bulkdata[(signed long int)i] = (unsigned char)i;
  intr.payload = bulkdata;
  intr.length = (unsigned int)128;
  intr.timeout = (unsigned int)10;
  ret=openusb_claim_interface(devh, (unsigned char)0, (enum openusb_init_flag)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_1;
    return_value_openusb_strerror_1=openusb_strerror(ret);
    printf("Device(%llu) claim interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_1);
    return -1;
  }

  ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_2;
    return_value_openusb_strerror_2=openusb_strerror(ret);
    printf("Device(%llu) interface(0) set alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_2);
    return -1;
  }

  if(flag == 1)
  {
    ret=openusb_intr_xfer(devh, (unsigned char)0, (unsigned char)2, &intr);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_3;
      return_value_openusb_strerror_3=openusb_strerror(ret);
      printf("xfer fail: %s\n", return_value_openusb_strerror_3);
      return -1;
    }

    printf("intr result.status = %d,xfer_bytes=%d, ret = %d\n", intr.result.status, intr.result.transferred_bytes, ret);
  }

  intr.payload = bulkrd;
  ret=openusb_intr_xfer(devh, (unsigned char)0, (unsigned char)0x86, &intr);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_4;
    return_value_openusb_strerror_4=openusb_strerror(ret);
    printf("intr xfer sync fail: %s\n", return_value_openusb_strerror_4);
    return -1;
  }

  printf("result.status = %d,xfer_bytes=%d, ret=%d\n", intr.result.status, intr.result.transferred_bytes, ret);
  printf("\nINTR DATA:\n");
  i = 0;
  for( ; !(i >= 128); i = i + 1)
  {
    if(i % 16 == 0)
      printf("\n");

    printf("%02x ", (unsigned char)bulkrd[(signed long int)i]);
  }
  printf("\n");
  return 0;
}

// test_isoc_sync
// file testopenusb.c line 496
static signed int test_isoc_sync(unsigned long int devh)
{
  unsigned char bulkdata[1536l];
  unsigned char bulkrd[1536l];
  struct openusb_isoc_request isoc;
  signed int i;
  signed int ret;
  printf("Test ISOC sync:\n");
  memset((void *)&isoc, 0, sizeof(struct openusb_isoc_request) /*48ul*/ );
  memset((void *)bulkrd, 0, (unsigned long int)(12 * 128));
  i = 0;
  for( ; !(i >= 12); i = i + 1)
    bulkdata[(signed long int)i] = (unsigned char)i;
  ret=openusb_claim_interface(devh, (unsigned char)0, (enum openusb_init_flag)0);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_1;
    return_value_openusb_strerror_1=openusb_strerror(ret);
    printf("Device(%llu) claim interface error: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_1);
    return -1;
  }

  ret=openusb_set_altsetting(devh, (unsigned char)0, (unsigned char)3);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_2;
    return_value_openusb_strerror_2=openusb_strerror(ret);
    printf("Device(%llu) interface(0) set alt: %s\n", (signed long long int)devids[(signed long int)0], return_value_openusb_strerror_2);
    return -1;
  }

  void *return_value_malloc_3;
  return_value_malloc_3=malloc(sizeof(struct openusb_request_result) /*8ul*/  * (unsigned long int)12);
  isoc.isoc_results = (struct openusb_request_result *)return_value_malloc_3;
  memset((void *)isoc.isoc_results, 0, sizeof(struct openusb_request_result) /*8ul*/  * (unsigned long int)12);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(sizeof(struct openusb_isoc_packet) /*16ul*/  * (unsigned long int)12);
  isoc.pkts.packets = (struct openusb_isoc_packet *)return_value_malloc_4;
  i = 0;
  for( ; !(i >= 12); i = i + 1)
  {
    (isoc.pkts.packets + (signed long int)i)->length = (unsigned int)128;
    (isoc.pkts.packets + (signed long int)i)->payload = bulkrd + (signed long int)(128 * i);
  }
  isoc.pkts.num_packets = (unsigned int)12;
  ret=openusb_isoc_xfer(devh, (unsigned char)0, (unsigned char)0x82, &isoc);
  if(!(ret == 0))
  {
    const char *return_value_openusb_strerror_5;
    return_value_openusb_strerror_5=openusb_strerror(ret);
    printf("ISOC xfer fail: %s\n", return_value_openusb_strerror_5);
    return -1;
  }

  printf("\nISOC DATA:\n");
  i = 0;
  for( ; !(i >= 12); i = i + 1)
  {
    signed int j;
    printf("ISOC packet: %d STATUS\n", i);
    printf("\tstatus=%d\n", (isoc.isoc_results + (signed long int)i)->status);
    printf("\tTbytes=%d\n", (isoc.isoc_results + (signed long int)i)->transferred_bytes);
    printf("\n");
    printf("ISOC packet: %d DATA\n", i);
    j = 0;
    for( ; !(j >= 128); j = j + 1)
    {
      if(j % 16 == 0)
        printf("\n");

      printf("%02x ", (isoc.pkts.packets + (signed long int)i)->payload[(signed long int)j]);
    }
    printf("\n");
  }
  printf("\n");
  return 0;
}

// test_sync_xfer
// file testopenusb.c line 1149
static signed int test_sync_xfer(unsigned long int devh)
{
  signed int ret;
  ret=test_ctrl_sync(devh);
  if(!(ret == 0))
  {
    printf("CONTROL xfer fail\n");
    return -1;
  }

  else
  {
    if((signed int)testtype == USB_TYPE_ISOCHRONOUS)
      ret=test_isoc_sync(devh);

    else
      if((signed int)testtype == USB_TYPE_BULK)
        ret=test_bulk_sync(devh);

      else
        if((signed int)testtype == USB_TYPE_INTERRUPT)
          ret=test_intr_sync(devh, testloop);

    if(!(ret == 0))
    {
      printf("TEST SYNC XFER FAIL\n");
      return -1;
    }

    else
      return 0;
  }
}

// timeout_thread
// file usb.c line 1222
void * timeout_thread(void *arg)
{
  struct usbi_dev_handle *devh;
  struct usbi_io *io;
  struct usbi_io *tio;
  devh = (struct usbi_dev_handle *)arg;
  _Bool tmp_if_expr_2;
  signed int return_value_usbi_timeval_compare_1;
  signed int return_value_usbi_timeval_compare_3;
  while((_Bool)1)
  {
    struct timeval tvc;
    struct timeval tvo;
    struct anonymous_0 readfds;
    struct anonymous_0 writefds;
    signed int ret;
    signed int maxfd;
    do
    {
      signed int timeout_thread__1__1__1____d0;
      signed int timeout_thread__1__1__1____d1;
      asm("cld; rep; stosq" : "=c"(timeout_thread__1__1__1____d0), "=D"(timeout_thread__1__1__1____d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_0) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writefds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    pthread_mutex_lock(&devh->lock);
    (&readfds)->__fds_bits[(signed long int)(devh->event_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(devh->event_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << devh->event_pipe[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    maxfd = devh->event_pipe[(signed long int)0];
    pthread_mutex_unlock(&devh->lock);
    gettimeofday(&tvc, (struct timezone *)(void *)0);
    memset((void *)&tvo, 0, sizeof(struct timeval) /*16ul*/ );
    pthread_mutex_lock(&devh->lock);
    io = (struct usbi_io *)((char *)(&devh->io_head)->next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
    for( ; !(&io->list == &devh->io_head); io = (struct usbi_io *)((char *)io->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list))
      if(!(io == ((struct usbi_io *)NULL)))
      {
        if((signed int)io->status == USBI_IO_INPROGRESS)
        {
          if(!(io->tvo.tv_sec == 0l))
          {
            if(tvo.tv_sec == 0l)
              tmp_if_expr_2 = (_Bool)1;

            else
            {
              return_value_usbi_timeval_compare_1=usbi_timeval_compare(&io->tvo, &tvo);
              tmp_if_expr_2 = return_value_usbi_timeval_compare_1 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_2)
              memcpy((void *)&tvo, (const void *)&io->tvo, sizeof(struct timeval) /*16ul*/ );

          }

        }

      }

    pthread_mutex_unlock(&devh->lock);
    if(tvo.tv_sec == 0l)
    {
      tvo.tv_sec = tvc.tv_sec + (signed long int)(60 * 60);
      tvo.tv_usec = tvc.tv_usec;
    }

    else
    {
      return_value_usbi_timeval_compare_3=usbi_timeval_compare(&tvo, &tvc);
      if(!(return_value_usbi_timeval_compare_3 >= 0))
        memcpy((void *)&tvo, (const void *)&tvc, sizeof(struct timeval) /*16ul*/ );

    }
    tvo.tv_sec = tvo.tv_sec - tvc.tv_sec;
    if(!(tvo.tv_usec >= tvc.tv_usec))
    {
      tvo.tv_sec = tvo.tv_sec - 1l;
      tvo.tv_usec = tvo.tv_usec + ((signed long int)1000000 - tvc.tv_usec);
    }

    else
      tvo.tv_usec = tvo.tv_usec - tvc.tv_usec;
    ret=select(maxfd + 1, &readfds, (struct anonymous_0 *)(void *)0, (struct anonymous_0 *)(void *)0, &tvo);
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      _usbi_debug(devh->lib_hdl, (unsigned int)1, "timeout_thread", (unsigned int)1318, "select() call failed: %s", return_value_strerror_5);
      continue;
    }

    gettimeofday(&tvc, (struct timezone *)(void *)0);
    if(!((readfds.__fds_bits[(signed long int)(devh->event_pipe[0l] / 8)] & (signed long int)(1UL << devh->event_pipe[0l] % 8)) == 0l))
    {
      char buf[16l];
      read(devh->event_pipe[(signed long int)0], (void *)buf, sizeof(char [16l]) /*16ul*/ );
      pthread_mutex_lock(&devh->lock);
      if((signed int)devh->state == USBI_DEVICE_CLOSING)
      {
        pthread_mutex_unlock(&devh->lock);
        return (void *)0;
      }

      pthread_mutex_unlock(&devh->lock);
    }

    pthread_testcancel();
    pthread_mutex_lock(&devh->lock);
    io = (struct usbi_io *)((char *)(&devh->io_head)->next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
    tio = (struct usbi_io *)((char *)io->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list);
    for( ; !(&io->list == &devh->io_head); tio = (struct usbi_io *)((char *)tio->list.next - (signed long int)(unsigned long int)&((struct usbi_io *)0L)->list))
    {
      if(!(io == ((struct usbi_io *)NULL)))
      {
        pthread_mutex_unlock(&devh->lock);
        signed int return_value_usbi_timeval_compare_6;
        return_value_usbi_timeval_compare_6=usbi_timeval_compare(&io->tvo, &tvc);
        if(!(return_value_usbi_timeval_compare_6 >= 1))
          usbi_io_complete(io, -62, (unsigned long int)0);

        pthread_mutex_lock(&devh->lock);
      }

      io = tio;
    }
    pthread_mutex_unlock(&devh->lock);
  }
  return (void *)0;
}

// usage
// file testopenusb.c line 1344
static void usage(char *prog)
{
  printf("usage:\n");
  printf("%s\n", prog);
  printf("\tBasic API test\n");
  printf("OR Advanced Xfer Test\n");
  printf("%s [-t <intr|isoc|bulk|ctrl>] [-l] [-m] [-a] [-s] [-p]\n", prog);
  printf("Where:\n");
  printf("\t-t transfer type\n\t-l loop test\n\t-m multi request test\n\t-a async xfer test\n\t-s sync xfer test\n\t-p hotplug test\n");
}

// usb0_bulk_xfer
// file emulation.c line 609
static signed int usb0_bulk_xfer(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout)
{
  struct openusb_bulk_request bulk;
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(bytes == ((char *)NULL) || devh == ((struct usb_dev_handle_internal *)NULL) || !(size >= 1))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    memset((void *)&bulk, 0, sizeof(struct openusb_bulk_request) /*40ul*/ );
    bulk.payload = (unsigned char *)bytes;
    bulk.length = (unsigned int)size;
    bulk.timeout = (unsigned int)timeout;
    ret=openusb_bulk_xfer(devh->devh, (unsigned char)devh->interface, (unsigned char)ep, &bulk);
    if(!(bulk.result.status == 0) || !(ret >= 0))
    {
      wr_error_str(ret, "bulk transfer fail");
      return -1;
    }

    else
      return (signed int)bulk.result.transferred_bytes;
  }
}

// usb0_intr_xfer
// file emulation.c line 654
static signed int usb0_intr_xfer(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout)
{
  struct openusb_intr_request intr;
  signed int ret;
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  if(bytes == ((char *)NULL) || devh == ((struct usb_dev_handle_internal *)NULL) || !(size >= 1))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    memset((void *)&intr, 0, sizeof(struct openusb_intr_request) /*48ul*/ );
    intr.payload = (unsigned char *)bytes;
    intr.length = (unsigned int)size;
    intr.timeout = (unsigned int)timeout;
    ret=openusb_intr_xfer(devh->devh, (unsigned char)devh->interface, (unsigned char)ep, &intr);
    if(!(intr.result.status == 0) || !(ret == 0))
    {
      wr_error_str(ret, "interrupt transfer fail");
      return -1;
    }

    else
      return (signed int)intr.result.transferred_bytes;
  }
}

// usb_bulk_read
// file emulation.c line 644
signed int usb_bulk_read(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout)
{
  signed int return_value_usb0_bulk_xfer_1;
  return_value_usb0_bulk_xfer_1=usb0_bulk_xfer(dev, ep, bytes, size, timeout);
  return return_value_usb0_bulk_xfer_1;
}

// usb_bulk_write
// file emulation.c line 638
signed int usb_bulk_write(struct usb_dev_handle *dev, signed int ep, const char *bytes, signed int size, signed int timeout)
{
  signed int return_value_usb0_bulk_xfer_1;
  return_value_usb0_bulk_xfer_1=usb0_bulk_xfer(dev, ep, (char *)bytes, size, timeout);
  return return_value_usb0_bulk_xfer_1;
}

// usb_claim_interface
// file emulation.c line 758
signed int usb_claim_interface(struct usb_dev_handle *dev, signed int interface)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    ret=openusb_claim_interface(devh->devh, (unsigned char)interface, (enum openusb_init_flag)0);
    if(ret == 0)
    {
      devh->interface = interface;
      return 0;
    }

    else
    {
      wr_error_str(ret, "set_configuration fail");
      return ret;
    }
  }
}

// usb_clear_halt
// file emulation.c line 831
signed int usb_clear_halt(struct usb_dev_handle *dev, unsigned int ep)
{
  signed int ret;
  ret=usb_control_msg(dev, 0x00 | 0x02, 0x01, 0, (signed int)ep, (char *)(void *)0, 0, 0);
  if(!(ret == 0))
    wr_error_str(ret, "clear_halt fail");

  return ret;
}

// usb_close
// file emulation.c line 581
signed int usb_close(struct usb_dev_handle *dev)
{
  struct usb_dev_handle_internal *devh;
  signed int ret;
  if(dev == ((struct usb_dev_handle *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    devh = (struct usb_dev_handle_internal *)dev;
    ret=openusb_close_device(devh->devh);
    devh->devh = (unsigned long int)0;
    if(!(ret == 0))
    {
      wr_error_str(ret, "close_device fail");
      return ret;
    }

    else
    {
      free((void *)devh);
      return 0;
    }
  }
}

// usb_control_msg
// file emulation.c line 694
signed int usb_control_msg(struct usb_dev_handle *dev, signed int requesttype, signed int request, signed int value, signed int index, char *bytes, signed int size, signed int timeout)
{
  struct openusb_ctrl_request ctrl;
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL) || !(size >= 0))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usb_control_msg", (unsigned int)709, "type = %d, request=%d, index= %d", requesttype, request, index);
    memset((void *)&ctrl, 0, sizeof(struct openusb_ctrl_request) /*48ul*/ );
    ctrl.setup.bmRequestType = (unsigned char)requesttype;
    ctrl.setup.bRequest = (unsigned char)request;
    ctrl.setup.wValue = (unsigned short int)value;
    ctrl.setup.wIndex = (unsigned short int)index;
    ctrl.payload = (unsigned char *)bytes;
    ctrl.length = (unsigned int)size;
    ctrl.timeout = (unsigned int)timeout;
    ret=openusb_ctrl_xfer(devh->devh, (unsigned char)0, (unsigned char)0, &ctrl);
    if(!(ctrl.result.status == 0) || !(ret >= 0))
    {
      wr_error_str(ret, "control transfer fail");
      return -1;
    }

    else
      return (signed int)ctrl.result.transferred_bytes;
  }
}

// usb_detach_kernel_driver_np
// file emulation.c line 985
signed int usb_detach_kernel_driver_np(struct usb_dev_handle *dev, signed int interface)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    signed int return_value_usbi_detach_kernel_driver_np_1;
    return_value_usbi_detach_kernel_driver_np_1=usbi_detach_kernel_driver_np(devh->devh, (unsigned char)interface);
    return return_value_usbi_detach_kernel_driver_np_1;
  }
}

// usb_device
// file emulation.c line 952
struct usb_device * usb_device(struct usb_dev_handle *dev)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return (struct usb_device *)(void *)0;
  }

  else
    return devh->dev;
}

// usb_find_busses
// file emulation.c line 139
signed int usb_find_busses(void)
{
  struct usb_bus *usb_find_busses__1__bus;
  if(!(usb_busses == ((struct usb_bus *)NULL)))
    return 0;

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc(sizeof(struct usb_bus) /*4144ul*/ , (unsigned long int)1);
    usb_find_busses__1__bus = (struct usb_bus *)return_value_calloc_2;
    if(usb_find_busses__1__bus == ((struct usb_bus *)NULL))
    {
      signed int return_value_wr_error_1;
      return_value_wr_error_1=wr_error(12);
      return return_value_wr_error_1;
    }

    usb_busses = usb_find_busses__1__bus;
    return 1;
  }
}

// usb_find_devices
// file emulation.c line 223
signed int usb_find_devices(void)
{
  struct usb_bus *usb_find_devices__1__bus;
  struct usbi_bus *ibus;
  struct usbi_bus *tbus;
  signed int dev_cnt = 0;
  signed int ret;
  pthread_mutex_lock(&usbi_buses.lock);
  usb_find_devices__1__bus = usb_busses;
  for( ; !(usb_find_devices__1__bus == ((struct usb_bus *)NULL)); usb_find_devices__1__bus = usb_find_devices__1__bus->next)
  {
    ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
    tbus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
    for( ; !(&ibus->list == &usbi_buses.head); tbus = (struct usbi_bus *)((char *)tbus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
    {
      if(!(ibus == ((struct usbi_bus *)NULL)))
      {
        pthread_mutex_unlock(&usbi_buses.lock);
        ret=wr_create_devices(usb_find_devices__1__bus, ibus);
        pthread_mutex_lock(&usbi_buses.lock);
        if(ret >= 0)
          dev_cnt = dev_cnt + ret;

        else
        {
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usb_find_devices", (unsigned int)248, "create_device error");
          wr_error_str(1, "wr_create_device error");
          pthread_mutex_unlock(&usbi_buses.lock);
          return -1;
        }
      }

      ibus = tbus;
    }
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usb_find_devices", (unsigned int)258, "bus: %s", (const void *)usb_find_devices__1__bus->dirname);
  }
  pthread_mutex_unlock(&usbi_buses.lock);
  return dev_cnt;
}

// usb_fini
// file emulation.c line 124
void usb_fini(void)
{
  ;
}

// usb_get_busses
// file emulation.c line 965
struct usb_bus * usb_get_busses(void)
{
  return usb_busses;
}

// usb_get_descriptor
// file emulation.c line 931
signed int usb_get_descriptor(struct usb_dev_handle *dev, unsigned char type, unsigned char index, void *buf, signed int size)
{
  signed int ret;
  if(buf == NULL || !(size >= 1))
  {
    wr_error_str(22, "Invalid arguments");
    return -8;
  }

  else
  {
    ret=usb_control_msg(dev, 0x80, 0x06, ((signed int)type << 8) + (signed int)index, 0, (char *)buf, size, 1000);
    if(!(ret == 0))
      wr_error_str(ret, "get_descriptor_by_endpoint fail");

    return ret;
  }
}

// usb_get_descriptor_by_endpoint
// file emulation.c line 911
signed int usb_get_descriptor_by_endpoint(struct usb_dev_handle *dev, signed int ep, unsigned char type, unsigned char index, void *buf, signed int size)
{
  signed int ret;
  if(buf == NULL || !(size >= 1))
  {
    wr_error_str(22, "Invalid arguments");
    return -8;
  }

  else
  {
    ret=usb_control_msg(dev, ep | 0x80, 0x06, ((signed int)type << 8) + (signed int)index, 0, (char *)buf, size, 1000);
    if(!(ret == 0))
      wr_error_str(ret, "get_descriptor_by_endpoint fail");

    return ret;
  }
}

// usb_get_driver_np
// file emulation.c line 970
signed int usb_get_driver_np(struct usb_dev_handle *dev, signed int interface, char *name, unsigned int namelen)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    signed int return_value_usbi_get_driver_np_1;
    return_value_usbi_get_driver_np_1=usbi_get_driver_np(devh->devh, (unsigned char)interface, name, namelen);
    return return_value_usbi_get_driver_np_1;
  }
}

// usb_get_string
// file emulation.c line 868
signed int usb_get_string(struct usb_dev_handle *dev, signed int index, signed int langid, char *buf, unsigned long int buflen)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    ret=usbi_get_string(devh->devh, index, langid, buf, buflen);
    if(!(ret == 0))
      wr_error_str(ret, "get_string fail");

    return ret;
  }
}

// usb_get_string_simple
// file emulation.c line 890
signed int usb_get_string_simple(struct usb_dev_handle *dev, signed int index, char *buf, unsigned long int buflen)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -8;
  }

  else
  {
    ret=usbi_get_string_simple(devh->devh, index, buf, buflen);
    if(!(ret >= 0))
      wr_error_str(ret, "get_string_simple fail");

    return ret;
  }
}

// usb_init
// file emulation.c line 110
void usb_init(void)
{
  signed int ret;
  ret=openusb_init((unsigned int)0, &wr_handle);
  if(!(ret >= 0))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usb_init", (unsigned int)116, "fail");
    wr_error_str(ret, "usb_init fail");
  }

}

// usb_interrupt_read
// file emulation.c line 687
signed int usb_interrupt_read(struct usb_dev_handle *dev, signed int ep, char *bytes, signed int size, signed int timeout)
{
  signed int return_value_usb0_intr_xfer_1;
  return_value_usb0_intr_xfer_1=usb0_intr_xfer(dev, ep, bytes, size, timeout);
  return return_value_usb0_intr_xfer_1;
}

// usb_interrupt_write
// file emulation.c line 681
signed int usb_interrupt_write(struct usb_dev_handle *dev, signed int ep, const char *bytes, signed int size, signed int timeout)
{
  signed int return_value_usb0_intr_xfer_1;
  return_value_usb0_intr_xfer_1=usb0_intr_xfer(dev, ep, (char *)bytes, size, timeout);
  return return_value_usb0_intr_xfer_1;
}

// usb_open
// file emulation.c line 528
struct usb_dev_handle * usb_open(struct usb_device *dev)
{
  struct usb_dev_handle_internal *devh;
  unsigned long int usb1_devh;
  signed int ret;
  unsigned long int devid;
  if(dev == ((struct usb_device *)NULL))
  {
    wr_error_str(22, "usb_open: invalid arguments");
    return (struct usb_dev_handle *)(void *)0;
  }

  else
  {
    devid=wr_find_device(dev);
    ret=openusb_open_device(wr_handle, devid, (enum openusb_init_flag)0, &usb1_devh);
    if(!(ret == 0))
    {
      const char *return_value_openusb_strerror_1;
      return_value_openusb_strerror_1=openusb_strerror(ret);
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usb_open", (unsigned int)551, "Fail to open device: %s", return_value_openusb_strerror_1);
      const char *return_value_openusb_strerror_2;
      return_value_openusb_strerror_2=openusb_strerror(ret);
      wr_error_str(ret, "Fail to open device: %s", return_value_openusb_strerror_2);
      return (struct usb_dev_handle *)(void *)0;
    }

    ret=wr_setup_dev_config(dev, devid, usb1_devh);
    if(!(ret == 0))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usb_open", (unsigned int)561, "Fail to set device config");
      return (struct usb_dev_handle *)(void *)0;
    }

    else
    {
      void *return_value_calloc_3;
      return_value_calloc_3=calloc(sizeof(struct usb_dev_handle_internal) /*40ul*/ , (unsigned long int)1);
      devh = (struct usb_dev_handle_internal *)return_value_calloc_3;
      if(devh == ((struct usb_dev_handle_internal *)NULL))
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        wr_error(*return_value___errno_location_4);
        openusb_close_device(usb1_devh);
        usb1_devh = (unsigned long int)0;
        return (struct usb_dev_handle *)(void *)0;
      }

      devh->dev = dev;
      devh->devid = devid;
      devh->devh = usb1_devh;
      return (struct usb_dev_handle *)devh;
    }
  }
}

// usb_release_interface
// file emulation.c line 780
signed int usb_release_interface(struct usb_dev_handle *dev, signed int interface)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    ret=openusb_release_interface(devh->devh, (unsigned char)interface);
    if(!(ret == 0))
      wr_error_str(ret, "release_interface fail");

    return ret;
  }
}

// usb_reset
// file emulation.c line 847
signed int usb_reset(struct usb_dev_handle *dev)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    ret=openusb_reset(devh->devh);
    if(!(ret == 0))
      wr_error_str(ret, "reset fail");

    return ret;
  }
}

// usb_resetep
// file emulation.c line 825
signed int usb_resetep(struct usb_dev_handle *dev, unsigned int ep)
{
  signed int return_value_usb_clear_halt_1;
  return_value_usb_clear_halt_1=usb_clear_halt(dev, ep);
  return return_value_usb_clear_halt_1;
}

// usb_set_altinterface
// file emulation.c line 800
signed int usb_set_altinterface(struct usb_dev_handle *dev, signed int alternate)
{
  struct usb_dev_handle_internal *devh = (struct usb_dev_handle_internal *)dev;
  signed int ret;
  if(devh == ((struct usb_dev_handle_internal *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    ret=openusb_set_altsetting(devh->devh, (unsigned char)devh->interface, (unsigned char)alternate);
    if(ret == 0)
    {
      devh->alt = alternate;
      return 0;
    }

    else
    {
      const char *return_value_openusb_strerror_1;
      return_value_openusb_strerror_1=openusb_strerror(ret);
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usb_set_altinterface", (unsigned int)818, "openusb_set_altsetting error: %s", return_value_openusb_strerror_1);
      wr_error_str(ret, "set_altinterface fail");
      return ret;
    }
  }
}

// usb_set_configuration
// file emulation.c line 735
signed int usb_set_configuration(struct usb_dev_handle *dev, signed int configuration)
{
  struct usb_dev_handle_internal *devh;
  signed int ret;
  if(dev == ((struct usb_dev_handle *)NULL))
  {
    wr_error_str(22, "Invalid arguments");
    return -1;
  }

  else
  {
    devh = (struct usb_dev_handle_internal *)dev;
    ret=openusb_set_configuration(devh->devh, (unsigned char)configuration);
    if(ret == 0)
    {
      devh->config = configuration;
      return 0;
    }

    else
    {
      wr_error_str(ret, "set_configuration fail");
      return ret;
    }
  }
}

// usb_set_debug
// file emulation.c line 129
void usb_set_debug(signed int level)
{
  openusb_set_debug(wr_handle, (unsigned int)level, (unsigned int)0, (void (*)(unsigned long int, const char *, void **))(void *)0);
}

// usb_strerror
// file emulation.c line 84
char * usb_strerror(void)
{
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usb_strerror", (unsigned int)88, "usb_strerror(): usb_error_type=%d, errno=%d\n", usb_error_type, usb_error_errno);
  char *return_value_strerror_1;
  switch((signed int)usb_error_type)
  {
    case USB_ERROR_TYPE_NONE:
      return "No error";
    case USB_ERROR_TYPE_STRING:
      return usb_error_string;
    case USB_ERROR_TYPE_ERRNO:
    {
      if(!(usb_error_errno >= 1))
        goto __CPROVER_DUMP_L4;

      return_value_strerror_1=strerror(usb_error_errno);
      return return_value_strerror_1;
    }
    default:
    {

    __CPROVER_DUMP_L4:
      ;
      return "Unknown error";
    }
  }
}

// usbi_add_bus
// file devices.c line 28
static void usbi_add_bus(struct usbi_bus *ibus, struct usbi_backend *backend)
{
  pthread_mutex_lock(&ibus->lock);
  unsigned long int tmp_post_1 = cur_bus_id;
  cur_bus_id = cur_bus_id + 1ul;
  ibus->busid = tmp_post_1;
  ibus->ops = backend->ops;
  list_init(&ibus->devices.head);
  list_add(&ibus->list, &usbi_buses.head);
  pthread_mutex_unlock(&ibus->lock);
}

// usbi_add_device
// file devices.c line 209
void usbi_add_device(struct usbi_bus *ibus, struct usbi_device *idev)
{
  struct usbi_handle *handle;
  struct usbi_handle *thdl;
  unsigned long int tmp_post_1 = cur_device_id;
  cur_device_id = cur_device_id + 1ul;
  idev->devid = tmp_post_1;
  idev->bus = ibus;
  idev->ops = &ibus->ops->dev;
  list_add(&idev->bus_list, &ibus->devices.head);
  pthread_mutex_lock(&usbi_devices.lock);
  list_add(&idev->dev_list, &usbi_devices.head);
  pthread_mutex_unlock(&usbi_devices.lock);
  pthread_mutex_lock(&usbi_handles.lock);
  handle = (struct usbi_handle *)((char *)(&usbi_handles.head)->next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list);
  thdl = (struct usbi_handle *)((char *)handle->list.next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list);
  for( ; !(&handle->list == &usbi_handles.head); thdl = (struct usbi_handle *)((char *)thdl->list.next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list))
  {
    if(!(handle == ((struct usbi_handle *)NULL)))
      usbi_add_event_callback(handle, idev->devid, (enum openusb_event)USB_ATTACH);

    handle = thdl;
  }
  pthread_mutex_unlock(&usbi_handles.lock);
}

// usbi_add_event_callback
// file usb.c line 108
void usbi_add_event_callback(struct usbi_handle *hdl, unsigned long int devid, enum openusb_event type)
{
  struct eventcallback *cb;
  _usbi_debug(hdl, (unsigned int)4, "usbi_add_event_callback", (unsigned int)114, "hdl=%p,handle=%llu,devid=%llu,type=%d", hdl, hdl->handle, devid, type);
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct eventcallback) /*40ul*/ , (unsigned long int)1);
  cb = (struct eventcallback *)return_value_calloc_1;
  if(cb == ((struct eventcallback *)NULL))
    _usbi_debug(hdl, (unsigned int)1, "usbi_add_event_callback", (unsigned int)119, "allocate memory fail");

  else
  {
    cb->devid = devid;
    cb->type = type;
    cb->handle = hdl;
    list_init(&cb->list);
    pthread_mutex_lock(&event_callbacks.lock);
    list_add(&cb->list, &event_callbacks.head);
    pthread_cond_signal(&event_callback_cond);
    callback_queue_full = callback_queue_full + 1;
    pthread_mutex_unlock(&event_callbacks.lock);
  }
}

// usbi_add_or_stop
// file api.c line 1468
static signed int usbi_add_or_stop(struct openusb_multi_request_handle *handle, signed int flag)
{
  struct usbi_multi_request *mreq;
  struct usbi_dev_handle *hdev;
  if(handle == ((struct openusb_multi_request_handle *)NULL))
    return -8;

  else
  {
    hdev=usbi_find_dev_handle(handle->dev);
    if(hdev == ((struct usbi_dev_handle *)NULL))
      return -8;

    else
    {
      pthread_mutex_lock(&hdev->lock);
      mreq = (struct usbi_multi_request *)(void *)0;
      mreq = (struct usbi_multi_request *)((char *)(&hdev->m_head)->next - (signed long int)(unsigned long int)&((struct usbi_multi_request *)0L)->list);
      for( ; !(&mreq->list == &hdev->m_head); mreq = (struct usbi_multi_request *)((char *)mreq->list.next - (signed long int)(unsigned long int)&((struct usbi_multi_request *)0L)->list))
        if(!(mreq == ((struct usbi_multi_request *)NULL)))
        {
          if(mreq->mreq == handle)
            break;

        }

      pthread_mutex_unlock(&hdev->lock);
      if(mreq == ((struct usbi_multi_request *)NULL))
        return -12;

      else
      {
        pthread_mutex_lock(&mreq->lock);
        pthread_cond_signal(&mreq->cv);
        mreq->flag = flag;
        pthread_mutex_unlock(&mreq->lock);
        return 0;
      }
    }
  }
}

// usbi_alloc_io
// file usbi.h line 381
struct usbi_io * usbi_alloc_io(struct usbi_dev_handle *dev, struct openusb_request_handle *req, unsigned int timeout)
{
  struct usbi_io *io;
  struct timeval tvc;
  char buf[2l] = { (char)1, (char)1 };
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct usbi_io) /*176ul*/ );
  io = (struct usbi_io *)return_value_malloc_1;
  if(io == ((struct usbi_io *)NULL))
    return (struct usbi_io *)(void *)0;

  else
  {
    memset((void *)io, 0, sizeof(struct usbi_io) /*176ul*/ );
    pthread_mutex_init(&io->lock, (const union anonymous_2 *)(void *)0);
    pthread_cond_init(&io->cond, (const union anonymous_2 *)(void *)0);
    pthread_mutex_lock(&io->lock);
    list_init(&io->list);
    io->dev = dev;
    if(timeout == 0u)
    {
      io->timeout = 0xFFFFFFFF;
      timeout = io->timeout;
    }

    else
      io->timeout = timeout;
    io->status = (enum usbi_io_status)USBI_IO_INPROGRESS;
    io->req = req;
    gettimeofday(&tvc, (struct timezone *)(void *)0);
    io->tvo.tv_sec = tvc.tv_sec + (signed long int)(timeout / (unsigned int)1000);
    io->tvo.tv_usec = tvc.tv_usec + (signed long int)((timeout % (unsigned int)1000) * (unsigned int)1000);
    if(io->tvo.tv_usec >= 1000001l)
    {
      io->tvo.tv_usec = io->tvo.tv_usec - (signed long int)1000000;
      io->tvo.tv_sec = io->tvo.tv_sec + 1l;
    }

    pthread_mutex_unlock(&io->lock);
    pthread_mutex_lock(&dev->lock);
    list_add(&io->list, &dev->io_head);
    write(dev->event_pipe[(signed long int)1], (const void *)buf, (unsigned long int)1);
    pthread_mutex_unlock(&dev->lock);
    return io;
  }
}

// usbi_alloc_request_handle
// file io.c line 523
struct openusb_request_handle * usbi_alloc_request_handle(void)
{
  struct openusb_request_handle *reqp;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct openusb_request_handle) /*40ul*/ );
  reqp = (struct openusb_request_handle *)return_value_malloc_1;
  if(reqp == ((struct openusb_request_handle *)NULL))
    return (struct openusb_request_handle *)(void *)0;

  else
  {
    memset((void *)reqp, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
    return reqp;
  }
}

// usbi_async_submit
// file io.c line 207
signed int usbi_async_submit(struct usbi_io *io)
{
  struct usbi_dev_handle *dev;
  signed int ret;
  enum openusb_transfer_type type;
  pthread_mutex_lock(&io->lock);
  type = io->req->type;
  pthread_mutex_unlock(&io->lock);
  dev = io->dev;
  if(dev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
  {
    if((signed int)type == USB_TYPE_CONTROL)
      ret=dev->idev->ops->ctrl_xfer_aio(dev, io);

    else
      if((signed int)type == USB_TYPE_INTERRUPT)
        ret=dev->idev->ops->intr_xfer_aio(dev, io);

      else
        if((signed int)type == USB_TYPE_BULK)
          ret=dev->idev->ops->bulk_xfer_aio(dev, io);

        else
          if((signed int)type == USB_TYPE_ISOCHRONOUS)
            ret=dev->idev->ops->isoc_xfer_aio(dev, io);

          else
            ret = -1;
    if(!(ret >= 0))
      return ret;

    else
      return 0;
  }
}

// usbi_attach_kernel_driver_np
// file usb.c line 1380
signed int usbi_attach_kernel_driver_np(unsigned long int dev, unsigned char interface)
{
  struct usbi_dev_handle *hdev;
  hdev=usbi_find_dev_handle(dev);
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
  {
    if(!(hdev->idev->ops->attach_kernel_driver_np == ((signed int (*)(struct usbi_dev_handle *, unsigned char))NULL)))
    {
      signed int return_value;
      return_value=hdev->idev->ops->attach_kernel_driver_np(hdev, interface);
      return return_value;
    }

    return -4;
  }
}

// usbi_coldplug_complete
// file usb.c line 697
static void usbi_coldplug_complete(struct usbi_handle *hdl)
{
  if(!(hdl == ((struct usbi_handle *)NULL)))
  {
    pthread_mutex_lock(&hdl->lock);
    hdl->coldplug_complete = (unsigned char)1;
    pthread_cond_signal(&hdl->coldplug_cv);
    pthread_mutex_unlock(&hdl->lock);
  }

}

// usbi_control_xfer
// file api.c line 283
signed int usbi_control_xfer(struct usbi_dev_handle *devh, signed int requesttype, signed int request, signed int value, signed int index, char *bytes, signed int size, signed int timeout)
{
  struct openusb_ctrl_request ctrl;
  struct openusb_request_handle req;
  signed int ret;
  memset((void *)&ctrl, 0, sizeof(struct openusb_ctrl_request) /*48ul*/ );
  memset((void *)&req, 0, sizeof(struct openusb_request_handle) /*40ul*/ );
  ctrl.setup.bmRequestType = (unsigned char)requesttype;
  ctrl.setup.bRequest = (unsigned char)request;
  ctrl.setup.wValue = (unsigned short int)value;
  ctrl.setup.wIndex = (unsigned short int)index;
  ctrl.payload = (unsigned char *)bytes;
  ctrl.length = (unsigned int)size;
  ctrl.timeout = (unsigned int)timeout;
  req.dev = devh->handle;
  req.interface = (unsigned char)0;
  req.endpoint = (unsigned char)0;
  req.type = (enum openusb_transfer_type)USB_TYPE_CONTROL;
  req.req.ctrl = &ctrl;
  ret=usbi_io_sync(devh, &req);
  if(!(ret >= 0))
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_control_xfer", (unsigned int)310, "control xfer fail");

  return ret;
}

// usbi_destroy_configuration
// file usbi.h line 390
void usbi_destroy_configuration(struct usbi_device *dev)
{
  signed int c;
  signed int i;
  signed int j;
  signed int k;
  if(!(dev->desc.configs == ((struct usbi_config *)NULL)))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_destroy_configuration", (unsigned int)613, "free %d configs", dev->desc.num_configs);
    c = 0;
    for( ; !((unsigned long int)c >= dev->desc.num_configs); c = c + 1)
    {
      struct usbi_config *cfg = dev->desc.configs + (signed long int)c;
      if(!(cfg->extra == ((char *)NULL)))
        free((void *)cfg->extra);

      if(!((dev->desc.configs_raw + (signed long int)c)->data == ((unsigned char *)NULL)))
        free((void *)(dev->desc.configs_raw + (signed long int)c)->data);

      if(!(cfg->interfaces == ((struct usbi_interface *)NULL)))
      {
        i = 0;
        for( ; !((unsigned long int)i >= cfg->num_interfaces); i = i + 1)
        {
          struct usbi_interface *intf = cfg->interfaces + (signed long int)i;
          j = 0;
          for( ; !((unsigned long int)j >= intf->num_altsettings); j = j + 1)
          {
            struct usbi_altsetting *as = intf->altsettings + (signed long int)j;
            signed int num_ep = (signed int)as->num_endpoints;
            k = 0;
            for( ; !(k >= num_ep); k = k + 1)
              if(!((as->endpoints + (signed long int)k)->extra == ((char *)NULL)))
                free((void *)(as->endpoints + (signed long int)k)->extra);

            free((void *)as->endpoints);
            if(!(as->extra == ((char *)NULL)))
              free((void *)as->extra);

          }
          if(!(intf->altsettings == ((struct usbi_altsetting *)NULL)))
            free((void *)intf->altsettings);

        }
        if(!(cfg->interfaces == ((struct usbi_interface *)NULL)))
          free((void *)cfg->interfaces);

      }

    }
    free((void *)dev->desc.configs_raw);
    free((void *)dev->desc.configs);
    if(!(dev->desc.device_raw.data == ((unsigned char *)NULL)))
      free((void *)dev->desc.device_raw.data);

    dev->desc.configs_raw = (struct usbi_raw_desc *)(void *)0;
    dev->desc.configs = (struct usbi_config *)(void *)0;
    dev->desc.device_raw.data = (unsigned char *)(void *)0;
  }

}

// usbi_destroy_handle
// file usb.c line 557
static void usbi_destroy_handle(struct usbi_handle *hdl)
{
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_destroy_handle", (unsigned int)559, "Begin");
  if(hdl == ((struct usbi_handle *)NULL))
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_destroy_handle", (unsigned int)562, "Destroy handle fail");

  else
  {
    pthread_mutex_lock(&usbi_handles.lock);
    list_del(&hdl->list);
    pthread_mutex_unlock(&usbi_handles.lock);
    pthread_mutex_destroy(&hdl->lock);
    pthread_mutex_destroy(&hdl->complete_lock);
    pthread_cond_destroy(&hdl->complete_cv);
    free((void *)hdl);
  }
}

// usbi_detach_kernel_driver_np
// file usb.c line 1397
signed int usbi_detach_kernel_driver_np(unsigned long int dev, unsigned char interface)
{
  struct usbi_dev_handle *hdev;
  hdev=usbi_find_dev_handle(dev);
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
  {
    if(!(hdev->idev->ops->detach_kernel_driver_np == ((signed int (*)(struct usbi_dev_handle *, unsigned char))NULL)))
    {
      signed int return_value;
      return_value=hdev->idev->ops->detach_kernel_driver_np(hdev, interface);
      return return_value;
    }

    return -4;
  }
}

// usbi_fetch_and_parse_descriptors
// file usbi.h line 389
signed int usbi_fetch_and_parse_descriptors(struct usbi_dev_handle *hdev)
{
  struct usbi_device *dev = hdev->idev;
  signed int i;
  signed int ret;
  char devbuf[19l];
  unsigned int count;
  usbi_destroy_configuration(dev);
  ret=usbi_get_descriptor(hdev->handle, (unsigned char)0x01, (unsigned char)0, (void *)devbuf, (unsigned int)18);
  void *return_value_calloc_2;
  void *return_value_calloc_3;
  if(!(ret >= 0))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)2, "usbi_fetch_and_parse_descriptors", (unsigned int)701, "Fail to get device descriptors: %d", ret);
    return -10;
  }

  else
  {
    ret=openusb_parse_data("bbwbbbbwwwbbbb", (unsigned char *)devbuf, (unsigned int)18, (void *)&dev->desc.device, (unsigned int)sizeof(struct usb_device_desc) /*18ul*/ , &count);
    if(!(ret >= 0) || !(count >= 18u))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_fetch_and_parse_descriptors", (unsigned int)711, "fail to parse device descr");
      return -10;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)count, (unsigned long int)1);
      dev->desc.device_raw.data = (unsigned char *)return_value_calloc_1;
      memcpy((void *)dev->desc.device_raw.data, (const void *)devbuf, (unsigned long int)count);
      dev->desc.num_configs = (unsigned long int)dev->desc.device.bNumConfigurations;
      if(dev->desc.num_configs >= 9ul)
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)722, "too many configurations (%d > %d)", dev->desc.num_configs, 8);

      else
        if(!(dev->desc.num_configs >= 1ul))
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)728, "not enough configurations (%d < 1)", dev->desc.num_configs);

        else
        {
          return_value_calloc_2=calloc(dev->desc.num_configs * sizeof(struct usbi_raw_desc) /*16ul*/ , (unsigned long int)1);
          dev->desc.configs_raw = (struct usbi_raw_desc *)return_value_calloc_2;
          if(dev->desc.configs_raw == ((struct usbi_raw_desc *)NULL))
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)738, "unable to allocate %d bytes for cached descriptors", dev->desc.num_configs * sizeof(struct usbi_raw_desc) /*16ul*/ );

          else
          {
            return_value_calloc_3=calloc(dev->desc.num_configs * sizeof(struct usbi_config) /*48ul*/ , (unsigned long int)1);
            dev->desc.configs = (struct usbi_config *)return_value_calloc_3;
            if(dev->desc.configs == ((struct usbi_config *)NULL))
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)747, "unable to allocate memory for config descriptors", dev->desc.num_configs * sizeof(struct usbi_config) /*48ul*/ );

            else
            {
              i = 0;
              for( ; !((unsigned long int)i >= dev->desc.num_configs); i = i + 1)
              {
                unsigned char buf[8l];
                struct usb_config_desc cfg_desc;
                struct usbi_raw_desc *cfgr = dev->desc.configs_raw + (signed long int)i;
                ret=usbi_get_descriptor(hdev->handle, (unsigned char)0x02, (unsigned char)i, (void *)buf, (unsigned int)8);
                if(!(ret >= 8))
                {
                  if(!(ret >= 0))
                    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)766, "unable to get first 8 bytes of config descriptor (ret = %d)", ret);

                  else
                    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)771, "config descriptor too short (expected 8, got %d)", ret);
                  goto err;
                }

                openusb_parse_data("bbw", buf, (unsigned int)8, (void *)&cfg_desc, (unsigned int)sizeof(struct usb_config_desc) /*10ul*/ , &count);
                cfgr->len = (unsigned long int)cfg_desc.wTotalLength;
                void *return_value_calloc_4;
                return_value_calloc_4=calloc(cfgr->len + (unsigned long int)65536, (unsigned long int)1);
                cfgr->data = (unsigned char *)return_value_calloc_4;
                if(cfgr->data == ((unsigned char *)NULL))
                {
                  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)790, "unable to allocate %d bytes for descriptors", cfgr->len);
                  goto err;
                }

                ret=usbi_get_descriptor(hdev->handle, (unsigned char)0x02, (unsigned char)i, (void *)cfgr->data, (unsigned int)cfgr->len);
                if(!((unsigned long int)ret >= cfgr->len))
                {
                  if(!(ret >= 0))
                    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)800, "unable to get rest of config descriptor (ret = %d)", ret);

                  else
                    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_fetch_and_parse_descriptors", (unsigned int)804, "config descriptor too short (expected %d, got %d)", cfgr->len, ret);
                  cfgr->len = (unsigned long int)0;
                  free((void *)cfgr->data);
                  goto err;
                }

                ret=usbi_parse_configuration(dev->desc.configs + (signed long int)i, cfgr->data, cfgr->len);
                if(ret >= 1)
                  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)2, "usbi_fetch_and_parse_descriptors", (unsigned int)815, "%d bytes of descriptor data still left", ret);

                else
                  if(!(ret >= 0))
                    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)2, "usbi_fetch_and_parse_descriptors", (unsigned int)817, "unable to parse descriptors");

              }
              return 0;
            }
          }
        }

    err:
      ;
      free((void *)dev->desc.configs);
      free((void *)dev->desc.configs_raw);
      dev->desc.configs = (struct usbi_config *)(void *)0;
      dev->desc.configs_raw = (struct usbi_raw_desc *)(void *)0;
      dev->desc.num_configs = (unsigned long int)0;
      return -1;
    }
  }
}

// usbi_find_bus_by_id
// file devices.c line 72
static struct usbi_bus * usbi_find_bus_by_id(unsigned long int busid)
{
  struct usbi_bus *ibus;
  pthread_mutex_lock(&usbi_buses.lock);
  ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
  for( ; !(&ibus->list == &usbi_buses.head); ibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
    if(!(ibus == ((struct usbi_bus *)NULL)))
    {
      pthread_mutex_lock(&ibus->lock);
      if(ibus->busid == busid)
      {
        pthread_mutex_unlock(&ibus->lock);
        pthread_mutex_unlock(&usbi_buses.lock);
        return ibus;
      }

      pthread_mutex_unlock(&ibus->lock);
    }

  pthread_mutex_unlock(&usbi_buses.lock);
  return (struct usbi_bus *)(void *)0;
}

// usbi_find_bus_by_num
// file devices.c line 98
struct usbi_bus * usbi_find_bus_by_num(unsigned int busnum)
{
  struct usbi_bus *ibus;
  pthread_mutex_lock(&usbi_buses.lock);
  ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
  for( ; !(&ibus->list == &usbi_buses.head); ibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
    if(!(ibus == ((struct usbi_bus *)NULL)))
    {
      pthread_mutex_lock(&ibus->lock);
      if(ibus->busnum == busnum)
      {
        pthread_mutex_unlock(&ibus->lock);
        pthread_mutex_unlock(&usbi_buses.lock);
        return ibus;
      }

      pthread_mutex_unlock(&ibus->lock);
    }

  pthread_mutex_unlock(&usbi_buses.lock);
  return (struct usbi_bus *)(void *)0;
}

// usbi_find_dev_handle
// file usb.c line 797
struct usbi_dev_handle * usbi_find_dev_handle(unsigned long int dev)
{
  struct usbi_dev_handle *hdev;
  pthread_mutex_lock(&usbi_lock);
  if(usbi_inited == 0)
  {
    pthread_mutex_unlock(&usbi_lock);
    return (struct usbi_dev_handle *)(void *)0;
  }

  else
  {
    pthread_mutex_unlock(&usbi_lock);
    pthread_mutex_lock(&usbi_dev_handles.lock);
    hdev = (struct usbi_dev_handle *)((char *)(&usbi_dev_handles.head)->next - (signed long int)(unsigned long int)&((struct usbi_dev_handle *)0L)->list);
    for( ; !(&hdev->list == &usbi_dev_handles.head); hdev = (struct usbi_dev_handle *)((char *)hdev->list.next - (signed long int)(unsigned long int)&((struct usbi_dev_handle *)0L)->list))
      if(!(hdev == ((struct usbi_dev_handle *)NULL)))
      {
        pthread_mutex_lock(&hdev->lock);
        if(hdev->handle == dev)
        {
          pthread_mutex_unlock(&hdev->lock);
          pthread_mutex_unlock(&usbi_dev_handles.lock);
          return hdev;
        }

        pthread_mutex_unlock(&hdev->lock);
      }

    pthread_mutex_unlock(&usbi_dev_handles.lock);
    return (struct usbi_dev_handle *)(void *)0;
  }
}

// usbi_find_device_by_id
// file usb.c line 832
struct usbi_device * usbi_find_device_by_id(unsigned long int devid)
{
  struct usbi_device *idev;
  pthread_mutex_lock(&usbi_lock);
  if(usbi_inited == 0)
  {
    pthread_mutex_unlock(&usbi_lock);
    return (struct usbi_device *)(void *)0;
  }

  else
  {
    pthread_mutex_unlock(&usbi_lock);
    pthread_mutex_lock(&usbi_devices.lock);
    idev = (struct usbi_device *)((char *)(&usbi_devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list);
    for( ; !(&idev->dev_list == &usbi_devices.head); idev = (struct usbi_device *)((char *)idev->dev_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->dev_list))
      if(!(idev == ((struct usbi_device *)NULL)))
      {
        if(idev->devid == devid)
        {
          pthread_mutex_unlock(&usbi_devices.lock);
          return idev;
        }

      }

    pthread_mutex_unlock(&usbi_devices.lock);
    return (struct usbi_device *)(void *)0;
  }
}

// usbi_find_handle
// file usb.c line 485
struct usbi_handle * usbi_find_handle(unsigned long int handle)
{
  struct usbi_handle *hdl;
  pthread_mutex_lock(&usbi_lock);
  if(usbi_inited == 0)
  {
    pthread_mutex_unlock(&usbi_lock);
    return (struct usbi_handle *)(void *)0;
  }

  else
  {
    pthread_mutex_unlock(&usbi_lock);
    pthread_mutex_lock(&usbi_handles.lock);
    hdl = (struct usbi_handle *)((char *)(&usbi_handles.head)->next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list);
    for( ; !(&hdl->list == &usbi_handles.head); hdl = (struct usbi_handle *)((char *)hdl->list.next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list))
      if(!(hdl == ((struct usbi_handle *)NULL)))
      {
        if(hdl->handle == handle)
        {
          pthread_mutex_unlock(&usbi_handles.lock);
          return hdl;
        }

      }

    pthread_mutex_unlock(&usbi_handles.lock);
    return (struct usbi_handle *)(void *)0;
  }
}

// usbi_fini_common
// file usb.c line 467
static void usbi_fini_common(void)
{
  event_callback_exit = 1;
  pthread_cond_signal(&event_callback_cond);
  pthread_join(event_callback_thread, (void **)(void *)0);
  pthread_cond_destroy(&event_callback_cond);
  usbi_list_fini(&event_callbacks);
  usbi_list_fini(&usbi_dev_handles);
  usbi_list_fini(&usbi_devices);
  usbi_list_fini(&usbi_buses);
  usbi_list_fini(&usbi_handles);
}

// usbi_free_bus
// file devices.c line 50
void usbi_free_bus(struct usbi_bus *ibus)
{
  pthread_mutex_lock(&ibus->lock);
  if(!(ibus->priv == ((struct usbi_bus_private *)NULL)))
    free((void *)ibus->priv);

  pthread_mutex_unlock(&ibus->lock);
  free((void *)ibus);
}

// usbi_free_cfg
// file api.c line 364
static void usbi_free_cfg(char *buf)
{
  if(!(buf == ((char *)NULL)))
    free((void *)buf);

}

// usbi_free_device
// file devices.c line 236
void usbi_free_device(struct usbi_device *idev)
{
  if(!(idev->children == ((struct usbi_device **)NULL)))
  {
    free((void *)idev->children);
    idev->children = (struct usbi_device **)(void *)0;
  }

  usbi_destroy_configuration(idev);
  if(!(idev->bus->ops->free_device == ((void (*)(struct usbi_device *))NULL)))
    idev->bus->ops->free_device(idev);

  free((void *)idev);
}

// usbi_free_io
// file usbi.h line 383
void usbi_free_io(struct usbi_io *io)
{
  char buf[1l] = { (char)1 };
  signed int return_value_pthread_cond_destroy_1;
  if(!(io == ((struct usbi_io *)NULL)))
  {
    pthread_mutex_lock(&io->lock);
    pthread_mutex_lock(&io->dev->lock);
    list_del(&io->list);
    pthread_mutex_unlock(&io->dev->lock);
    if((signed int)io->status == USBI_IO_INPROGRESS)
    {
      if(io->flag == 1u)
      {
        _usbi_debug(io->dev->lib_hdl, (unsigned int)4, "usbi_free_io", (unsigned int)113, "IO is in progress, cancel it");
        if(!(io->dev->idev->ops->io_cancel == ((signed int (*)(struct usbi_io *))NULL)))
          io->dev->idev->ops->io_cancel(io);

      }

    }

    write(io->dev->event_pipe[(signed long int)1], (const void *)buf, (unsigned long int)1);
    if(!(io->priv == ((struct usbi_io_private *)NULL)))
      free((void *)io->priv);

    pthread_mutex_unlock(&io->lock);
    do
    {
      return_value_pthread_cond_destroy_1=pthread_cond_destroy(&io->cond);
      if(!(return_value_pthread_cond_destroy_1 == 16))
        break;

      pthread_mutex_lock(&io->lock);
      pthread_cond_broadcast(&io->cond);
      pthread_mutex_unlock(&io->lock);
    }
    while((_Bool)1);
    pthread_mutex_destroy(&io->lock);
    free((void *)io);
  }

}

// usbi_get_cfg_index_by_value
// file devices.c line 1564
signed int usbi_get_cfg_index_by_value(struct usbi_dev_handle *hdev, unsigned char cfgval)
{
  signed int cfgndx = -1;
  signed int i;
  signed int return_value_usbi_fetch_and_parse_descriptors_1;
  if(!(hdev == ((struct usbi_dev_handle *)NULL)))
  {
    return_value_usbi_fetch_and_parse_descriptors_1=usbi_fetch_and_parse_descriptors(hdev);
    if(return_value_usbi_fetch_and_parse_descriptors_1 == 0)
    {
      i = 0;
      for( ; !((unsigned long int)i >= hdev->idev->desc.num_configs); i = i + 1)
        if((hdev->idev->desc.configs + (signed long int)i)->desc.bConfigurationValue == cfgval)
        {
          cfgndx = i;
          break;
        }

    }

  }

  return cfgndx;
}

// usbi_get_cfg_value_by_index
// file devices.c line 1549
unsigned char usbi_get_cfg_value_by_index(struct usbi_dev_handle *hdev, signed int cfgndx)
{
  unsigned char cfgval = (unsigned char)0;
  signed int return_value_usbi_fetch_and_parse_descriptors_1;
  if(cfgndx >= 0 && !(hdev == ((struct usbi_dev_handle *)NULL)))
  {
    return_value_usbi_fetch_and_parse_descriptors_1=usbi_fetch_and_parse_descriptors(hdev);
    if(return_value_usbi_fetch_and_parse_descriptors_1 == 0)
    {
      if(!((unsigned long int)cfgndx >= hdev->idev->desc.num_configs))
        cfgval = (hdev->idev->desc.configs + (signed long int)cfgndx)->desc.bConfigurationValue;

    }

  }

  return cfgval;
}

// usbi_get_config_desc
// file api.c line 316
static signed int usbi_get_config_desc(struct usbi_dev_handle *devh, signed int cfg, char **cfgbuf, signed int *cfglen)
{
  char buf[8l];
  char *newbuf;
  signed int ret;
  struct usb_config_desc cfg_desc;
  unsigned int count;
  ret=usbi_control_xfer(devh, 0x80, 0x06, (0x02 << 8) + cfg, 0, buf, 8, 1000);
  if(!(ret >= 0))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_get_config_desc", (unsigned int)331, "usbi_control_xfer fail");
    return ret;
  }

  else
  {
    openusb_parse_data("bbw", (unsigned char *)buf, (unsigned int)8, (void *)&cfg_desc, (unsigned int)sizeof(struct usb_config_desc) /*10ul*/ , &count);
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)cfg_desc.wTotalLength, (unsigned long int)1);
    newbuf = (char *)return_value_calloc_1;
    if(newbuf == ((char *)NULL))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_get_config_desc", (unsigned int)340, "no memory");
      return -2;
    }

    else
    {
      ret=usbi_control_xfer(devh, 0x80, 0x06, (0x02 << 8) + cfg, 0, newbuf, (signed int)cfg_desc.wTotalLength, 1000);
      if(!(ret >= 0))
      {
        free((void *)newbuf);
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_get_config_desc", (unsigned int)352, "usbi_control_xfer fail");
        return ret;
      }

      else
      {
        *cfgbuf = newbuf;
        *cfglen = (signed int)cfg_desc.wTotalLength;
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_config_desc", (unsigned int)359, "End");
        return 0;
      }
    }
  }
}

// usbi_get_descriptor
// file descriptors.c line 20
static signed int usbi_get_descriptor(unsigned long int dev, unsigned char type, unsigned char index, void *buf, unsigned int buflen)
{
  signed int ret;
  struct openusb_ctrl_request ctrl = { .setup={ .bmRequestType=(unsigned char)0x80, .bRequest=(unsigned char)0x06, .wValue=(unsigned short int)(((signed int)type << 8) + (signed int)index),
    .wIndex=(unsigned short int)0 }, .payload=(unsigned char *)buf,
    .length=buflen, .timeout=(unsigned int)1000,
    .flags=0u, .result={ .status=0, .transferred_bytes=0u },
    .next=((struct openusb_ctrl_request *)NULL) };
  if(buf == NULL || buflen == 0u)
    return -8;

  else
  {
    ret=openusb_ctrl_xfer(dev, (unsigned char)0, (unsigned char)0, &ctrl);
    if(!(ctrl.result.status == 0) || !(ret >= 0))
      return -1;

    else
      return (signed int)ctrl.result.transferred_bytes;
  }
}

// usbi_get_devices_list
// file devices.c line 1543
struct usbi_list * usbi_get_devices_list(void)
{
  return &usbi_devices;
}

// usbi_get_driver_np
// file usb.c line 1361
signed int usbi_get_driver_np(unsigned long int dev, unsigned char interface, char *name, unsigned int namelen)
{
  struct usbi_dev_handle *hdev;
  hdev=usbi_find_dev_handle(dev);
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
  {
    if(!(hdev->idev->ops->get_driver_np == ((signed int (*)(struct usbi_dev_handle *, unsigned char, char *, unsigned int))NULL)))
    {
      signed int return_value;
      return_value=hdev->idev->ops->get_driver_np(hdev, interface, name, namelen);
      return return_value;
    }

    return -4;
  }
}

// usbi_get_intf_altno
// file descriptors.c line 252
static signed int usbi_get_intf_altno(char *buf, unsigned int buflen)
{
  signed int fno;
  signed int altno = 1;
  signed int len;
  signed int hlen;
  char *p = buf;
  hlen = 0;
  len = hlen;
  fno = (signed int)p[(signed long int)2];
  while(!((unsigned int)len >= buflen))
  {
    hlen = (signed int)p[(signed long int)0];
    p = p + (signed long int)hlen;
    len = len + hlen;
    if((signed int)p[1l] == 0x04)
    {
      if((signed int)p[2l] == fno)
        altno = altno + 1;

    }

  }
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_intf_altno", (unsigned int)271, "altno = %d", altno);
  return altno;
}

// usbi_get_num_altsettings
// file devices.c line 377
static signed int usbi_get_num_altsettings(struct usbi_device *idev, unsigned char *buffer, unsigned short int buflen, unsigned char infidx)
{
  unsigned char num_alt = (unsigned char)0;
  unsigned char *p = buffer;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(buffer == ((unsigned char *)NULL) || (signed int)buflen == 0)
    return -1;

  else
  {
    while((signed int)buflen >= 3)
    {
      if((signed int)p[1l] == 0x04)
        tmp_if_expr_1 = p[(signed long int)2] == infidx ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        num_alt = num_alt + 1;

      else
        if((signed int)p[1l] == 0x04)
        {
          if(!((signed int)infidx >= (signed int)p[2l]))
            break;

        }

      if((signed int)*p >= 1)
        tmp_if_expr_2 = (signed int)buflen >= (signed int)p[(signed long int)0] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
      {
        buflen = buflen - (unsigned short int)p[(signed long int)0];
        p = p + (signed long int)p[(signed long int)0];
      }

      else
        return -1;
    }
    if((signed int)num_alt >= 1)
      return (signed int)num_alt;

    else
      return -1;
  }
}

// usbi_get_raw_desc
// file descriptors.c line 676
signed int usbi_get_raw_desc(struct usbi_device *idev, unsigned char type, unsigned char descidx, unsigned short int langid, unsigned char **buffer, unsigned short int *buflen)
{
  if(!(idev->ops->get_raw_desc == ((signed int (*)(struct usbi_device *, unsigned char, unsigned char, unsigned short int, unsigned char **, unsigned short int *))NULL)))
  {
    signed int return_value;
    return_value=idev->ops->get_raw_desc(idev, type, descidx, langid, buffer, buflen);
    return return_value;
  }

  else
    return -1;
}

// usbi_get_string
// file devices.c line 1137
signed int usbi_get_string(unsigned long int dev, signed int index, signed int langid, char *buf, unsigned long int buflen)
{
  struct openusb_ctrl_request ctrl;
  if(buf == ((char *)NULL) || buflen == 0ul)
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_get_string", (unsigned int)1147, "usbi_get_string(): NULL handle or data");
    return -8;
  }

  else
  {
    memset((void *)&ctrl, 0, sizeof(struct openusb_ctrl_request) /*48ul*/ );
    ctrl.setup.bmRequestType = (unsigned char)0x80;
    ctrl.setup.bRequest = (unsigned char)0x06;
    ctrl.setup.wValue = (unsigned short int)((0x03 << 8) + index);
    ctrl.setup.wIndex = (unsigned short int)langid;
    ctrl.payload = (unsigned char *)buf;
    ctrl.length = (unsigned int)buflen;
    ctrl.timeout = (unsigned int)100;
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_string", (unsigned int)1163, "usbi_get_string(): index=%d langid=0x%x len=%d", index, langid, buflen);
    signed int return_value_openusb_ctrl_xfer_1;
    return_value_openusb_ctrl_xfer_1=openusb_ctrl_xfer(dev, (unsigned char)0, (unsigned char)0, &ctrl);
    if(return_value_openusb_ctrl_xfer_1 == 0)
      return (signed int)ctrl.result.transferred_bytes;

    else
      return -1;
  }
}

// usbi_get_string_simple
// file devices.c line 1177
signed int usbi_get_string_simple(unsigned long int dev, signed int index, char *buf, unsigned long int buflen)
{
  char tbuf[256l];
  signed int ret;
  signed int langid;
  signed int si;
  signed int di;
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_string_simple", (unsigned int)1183, "usb_get_string_simple(): index=%d", index);
  signed int tmp_post_1;
  signed int tmp_post_2;
  if(index == 0)
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_get_string_simple", (unsigned int)1186, "not a valid string index");
    return -8;
  }

  else
    if(buf == ((char *)NULL) || buflen == 0ul)
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_get_string_simple", (unsigned int)1192, "usbi_get_string_simple(): NULL handle or data\n");
      return -8;
    }

    else
    {
      memset((void *)buf, 0, buflen);
      ret=usbi_get_string(dev, 0, 0, tbuf, sizeof(char [256l]) /*256ul*/ );
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_string_simple", (unsigned int)1208, "usbi_get_string() first returned %d", ret);
      if(!(ret >= 4))
        langid = 0x409;

      else
        langid = (signed int)tbuf[(signed long int)2] | (signed int)tbuf[(signed long int)3] << 8;
      ret=usbi_get_string(dev, index, langid, tbuf, sizeof(char [256l]) /*256ul*/ );
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_string_simple", (unsigned int)1218, "usbi_get_string() returned %d", ret);
      if(!(ret >= 0))
        return ret;

      else
        if(!((signed int)tbuf[1l] == 0x03))
          return -5;

        else
          if(!(ret >= (signed int)tbuf[0l]))
            return -27;

          else
          {
            di = 0;
            si = 2;
            for( ; !(si >= (signed int)tbuf[0l]); si = si + 2)
            {
              if((unsigned long int)di >= buflen + 18446744073709551615ul)
                break;

              if(!(tbuf[(signed long int)(1 + si)] == 0))
              {
                tmp_post_1 = di;
                di = di + 1;
                buf[(signed long int)tmp_post_1] = (char)63;
              }

              else
              {
                tmp_post_2 = di;
                di = di + 1;
                buf[(signed long int)tmp_post_2] = tbuf[(signed long int)si];
              }
            }
            buf[(signed long int)di] = (char)0;
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_get_string_simple", (unsigned int)1247, "usbi_get_string() returned %s", buf);
            return di;
          }
    }
}

// usbi_get_xfer_timeout
// file api.c line 737
signed int usbi_get_xfer_timeout(struct openusb_request_handle *req, struct usbi_dev_handle *dev)
{
  signed int timeout;
  switch((signed int)req->type)
  {
    case USB_TYPE_CONTROL:
    {
      timeout = (signed int)req->req.ctrl->timeout;
      break;
    }
    case USB_TYPE_BULK:
    {
      timeout = (signed int)req->req.bulk->timeout;
      break;
    }
    case USB_TYPE_INTERRUPT:
    {
      timeout = (signed int)req->req.intr->timeout;
      break;
    }
    case USB_TYPE_ISOCHRONOUS:
    {
      timeout = 0;
      break;
    }
    default:
      timeout = -1;
  }
  if(timeout == -1)
    return -1;

  else
  {
    if(timeout == 0)
    {
      pthread_mutex_lock(&dev->lib_hdl->lock);
      timeout = (signed int)dev->lib_hdl->timeout[(signed long int)req->type];
      pthread_mutex_unlock(&dev->lib_hdl->lock);
    }

    return timeout;
  }
}

// usbi_init_common
// file usb.c line 354
static signed int usbi_init_common(void)
{
  const char *driver_path;
  signed int ret;
  char *return_value_getenv_2;
  return_value_getenv_2=getenv("OPENUSB_DEBUG");
  char *return_value_getenv_1;
  if(!(return_value_getenv_2 == ((char *)NULL)))
  {
    return_value_getenv_1=getenv("OPENUSB_DEBUG");
    openusb_global_debug_level=atoi(return_value_getenv_1);
  }

  ret=usbi_list_init(&usbi_handles);
  if(!(ret >= 0))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)366, "unable to init lib handle list (ret = %d)", ret);
    return -13;
  }

  else
  {
    ret=usbi_list_init(&usbi_buses);
    if(!(ret >= 0))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)375, "unable to init bus list (ret = %d)", ret);
      usbi_list_fini(&usbi_handles);
      return -13;
    }

    else
    {
      ret=usbi_list_init(&usbi_devices);
      if(!(ret >= 0))
      {
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)386, "unable to init device list (ret = %d)", ret);
        usbi_list_fini(&usbi_buses);
        usbi_list_fini(&usbi_handles);
        return -13;
      }

      else
      {
        ret=usbi_list_init(&usbi_dev_handles);
        if(!(ret >= 0))
        {
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)398, "unable to init device handle list (ret = %d)", ret);
          usbi_list_fini(&usbi_devices);
          usbi_list_fini(&usbi_buses);
          usbi_list_fini(&usbi_handles);
          return -13;
        }

        else
        {
          ret=usbi_list_init(&event_callbacks);
          if(!(ret >= 0))
          {
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)412, "unable to init callback list (ret = %d)", ret);
            usbi_list_fini(&usbi_dev_handles);
            usbi_list_fini(&usbi_devices);
            usbi_list_fini(&usbi_buses);
            usbi_list_fini(&usbi_handles);
            return -13;
          }

          else
          {
            pthread_cond_init(&event_callback_cond, (const union anonymous_2 *)(void *)0);
            event_callback_exit = 0;
            ret=pthread_create(&event_callback_thread, (const union pthread_attr_t *)(void *)0, process_event_callbacks, (void *)0);
            if(!(ret >= 0))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)430, "unable to create callback thread (ret = %d)", ret);
              pthread_cond_destroy(&event_callback_cond);
              usbi_list_fini(&event_callbacks);
              usbi_list_fini(&usbi_dev_handles);
              usbi_list_fini(&usbi_devices);
              usbi_list_fini(&usbi_buses);
              usbi_list_fini(&usbi_handles);
              return -13;
            }

            else
            {
              load_backends("/usr/lib/x86_64-linux-gnu/openusb_backend");
              driver_path=getenv("OPENUSB_BACKEND_PATH");
              if(!(driver_path == ((const char *)NULL)))
              {
                _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_init_common", (unsigned int)447, "backend path: %s", driver_path);
                load_backends(driver_path);
              }

              if(backends.next == &backends)
              {
                _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_common", (unsigned int)456, "load backends fail");
                return -1;
              }

              else
              {
                _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_init_common", (unsigned int)460, "End");
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// usbi_init_handle
// file usb.c line 513
static struct usbi_handle * usbi_init_handle(void)
{
  struct usbi_handle *hdl;
  signed int ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct usbi_handle) /*376ul*/ );
  hdl = (struct usbi_handle *)return_value_malloc_1;
  if(hdl == ((struct usbi_handle *)NULL))
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_handle", (unsigned int)520, "malloc handle failed (ret = %d)", *return_value___errno_location_2);
    return (struct usbi_handle *)(void *)0;
  }

  memset((void *)hdl, 0, sizeof(struct usbi_handle) /*376ul*/ );
  ret=pthread_mutex_init(&hdl->lock, (const union anonymous_2 *)(void *)0);
  char *return_value_getenv_3;
  signed int return_value_atoi_4;
  unsigned long int tmp_post_6;
  if(!(ret == 0))
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_init_handle", (unsigned int)528, "init handle mutex failed (ret = %d)", ret);
    free((void *)hdl);
    return (struct usbi_handle *)(void *)0;
  }

  else
  {
    char *return_value_getenv_5;
    return_value_getenv_5=getenv("OPENUSB_DEBUG");
    if(!(return_value_getenv_5 == ((char *)NULL)))
    {
      return_value_getenv_3=getenv("OPENUSB_DEBUG");
      return_value_atoi_4=atoi(return_value_getenv_3);
      hdl->debug_level = (unsigned int)return_value_atoi_4;
    }

    pthread_mutex_lock(&usbi_lock);
    tmp_post_6 = cur_handle;
    cur_handle = cur_handle + 1ul;
    hdl->handle = tmp_post_6;
    pthread_mutex_unlock(&usbi_lock);
    pthread_mutex_lock(&usbi_handles.lock);
    list_add(&hdl->list, &usbi_handles.head);
    pthread_mutex_unlock(&usbi_handles.lock);
    list_init(&hdl->complete_list);
    pthread_mutex_init(&hdl->complete_lock, (const union anonymous_2 *)(void *)0);
    pthread_cond_init(&hdl->complete_cv, (const union anonymous_2 *)(void *)0);
    hdl->complete_count = 0;
    return hdl;
  }
}

// usbi_io_async
// file usbi.h line 376
signed int usbi_io_async(struct usbi_io *iop)
{
  struct usbi_dev_handle *dev;
  signed int io_pattern;
  signed int ret = -1;
  enum openusb_transfer_type type;
  pthread_mutex_lock(&iop->lock);
  dev = iop->dev;
  type = iop->req->type;
  pthread_mutex_unlock(&iop->lock);
  if(dev == ((struct usbi_dev_handle *)NULL))
    return -11;

  else
  {
    pthread_mutex_lock(&dev->idev->bus->lock);
    io_pattern = dev->idev->bus->ops->io_pattern;
    pthread_mutex_unlock(&dev->idev->bus->lock);
    if((signed int)type >= 5 || !((signed int)type >= USB_TYPE_CONTROL))
      return -8;

    else
      if(io_pattern == 1 || io_pattern == 4)
      {
        ret=usbi_async_submit(iop);
        if(!(ret == 0))
          _usbi_debug(dev->lib_hdl, (unsigned int)1, "usbi_io_async", (unsigned int)493, "async_submit fail");

        return ret;
      }

      else
        if(io_pattern == 2)
        {
          unsigned long int thrid;
          ret=pthread_create(&thrid, (const union pthread_attr_t *)(void *)0, io_submit, (void *)iop);
          if(!(ret >= 0))
            return -1;

          return 0;
        }

        else
          return -1;
  }
}

// usbi_io_complete
// file usbi.h line 378
void usbi_io_complete(struct usbi_io *io, signed int status, unsigned long int transferred_bytes)
{
  struct openusb_request_result *result = (struct openusb_request_result *)(void *)0;
  enum openusb_transfer_type type;
  struct usbi_dev_handle *hdev = io->dev;
  pthread_mutex_lock(&io->lock);
  io->status = (enum usbi_io_status)USBI_IO_COMPLETED;
  pthread_mutex_unlock(&io->lock);
  list_del(&io->list);
  if(io->flag == 1u)
  {
    pthread_mutex_lock(&hdev->lib_hdl->complete_lock);
    list_add(&io->list, &hdev->lib_hdl->complete_list);
    hdev->lib_hdl->complete_count = hdev->lib_hdl->complete_count + 1;
    pthread_cond_signal(&hdev->lib_hdl->complete_cv);
    pthread_mutex_unlock(&hdev->lib_hdl->complete_lock);
  }

  pthread_mutex_lock(&io->lock);
  type = io->req->type;
  if((signed int)type == USB_TYPE_CONTROL)
    result = &io->req->req.ctrl->result;

  else
    if((signed int)type == USB_TYPE_INTERRUPT)
      result = &io->req->req.intr->result;

    else
      if((signed int)type == USB_TYPE_BULK)
        result = &io->req->req.bulk->result;

      else
        if((signed int)type == USB_TYPE_ISOCHRONOUS)
          result = &io->req->req.isoc->isoc_results[(signed long int)0];

  pthread_mutex_unlock(&io->lock);
  result->status = status;
  result->transferred_bytes = (unsigned int)transferred_bytes;
  pthread_mutex_lock(&io->lock);
  pthread_cond_broadcast(&io->cond);
  pthread_mutex_unlock(&io->lock);
  if(io->flag == 1u)
  {
    if(!(io->req->cb == ((signed int (*)(struct openusb_request_handle *))NULL)))
      io->req->cb(io->req);

  }

  if(!(io->callback == ((void (*)(struct usbi_io *, signed int))NULL)))
    io->callback(io, status);

}

// usbi_io_sync
// file usbi.h line 375
signed int usbi_io_sync(struct usbi_dev_handle *dev, struct openusb_request_handle *req)
{
  signed int io_pattern;
  signed int ret;
  io_pattern = dev->idev->bus->ops->io_pattern;
  if(io_pattern == 1)
  {
    struct simple_io *io;
    struct usbi_io *iop;
    unsigned int timeout;
    signed int return_value_usbi_get_xfer_timeout_1;
    return_value_usbi_get_xfer_timeout_1=usbi_get_xfer_timeout(req, dev);
    timeout = (unsigned int)return_value_usbi_get_xfer_timeout_1;
    iop=usbi_alloc_io(dev, req, timeout);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc(sizeof(struct simple_io) /*104ul*/ , (unsigned long int)1);
    io = (struct simple_io *)return_value_calloc_2;
    if(io == ((struct simple_io *)NULL) || iop == ((struct usbi_io *)NULL))
      return -2;

    iop->callback = async_callback;
    iop->arg = (void *)io;
    simple_io_setup(io);
    ret=usbi_async_submit(iop);
    if(!(ret >= 0))
    {
      usbi_free_io(iop);
      free((void *)io);
      return ret;
    }

    ret=simple_io_wait(io);
    usbi_free_io(iop);
    free((void *)io);
    return ret;
  }

  else
    if(io_pattern == 2 || io_pattern == 4)
    {
      struct usbi_io *usbi_io_sync__1__2__io;
      unsigned int usbi_io_sync__1__2__timeout;
      signed int return_value_usbi_get_xfer_timeout_3;
      return_value_usbi_get_xfer_timeout_3=usbi_get_xfer_timeout(req, dev);
      usbi_io_sync__1__2__timeout = (unsigned int)return_value_usbi_get_xfer_timeout_3;
      usbi_io_sync__1__2__io=usbi_alloc_io(dev, req, usbi_io_sync__1__2__timeout);
      ret=usbi_sync_submit(usbi_io_sync__1__2__io);
      usbi_free_io(usbi_io_sync__1__2__io);
      return ret;
    }

    else
      return -1;
}

// usbi_list_fini
// file usb.c line 345
static void usbi_list_fini(struct usbi_list *list)
{
  pthread_mutex_destroy(&list->lock);
}

// usbi_list_init
// file usb.c line 333
static signed int usbi_list_init(struct usbi_list *list)
{
  signed int ret = 0;
  list_init(&list->head);
  ret=pthread_mutex_init(&list->lock, (const union anonymous_2 *)(void *)0);
  if(!(ret == 0))
    return -13;

  else
    return ret;
}

// usbi_match_class
// file devices.c line 425
static signed int usbi_match_class(unsigned long int handle, struct usbi_device *idev, signed short int devclass, signed short int subclass, signed short int protocol)
{
  unsigned char *buf;
  unsigned short int buflen;
  struct usb_device_desc dev_desc;
  struct usb_config_desc cfg_desc;
  struct usb_interface_desc ifc_desc;
  signed int ret;
  signed int c;
  signed int i;
  signed int a;
  struct usbi_handle *hdl;
  hdl=usbi_find_handle(handle);
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_match_class", (unsigned int)440, "devid= %d class=%d, subclass=%d, proto = %d", (signed int)idev->devid, devclass, subclass, protocol);
  ret=openusb_parse_device_desc(handle, idev->devid, (unsigned char *)(void *)0, (unsigned short int)0, &dev_desc);
  _Bool tmp_if_expr_1;
  if(!(ret >= 0))
  {
    _usbi_debug(hdl, (unsigned int)2, "usbi_match_class", (unsigned int)445, "get device desc for devid %llu failed (ret = %d)", idev->devid, ret);
    return 0;
  }

  else
  {
    _usbi_debug(hdl, (unsigned int)4, "usbi_match_class", (unsigned int)452, "vid=%x, pid=%x, class=%d, subclass=%d, proto=%d %d", dev_desc.idVendor, dev_desc.idProduct, dev_desc.bDeviceClass, dev_desc.bDeviceSubClass, dev_desc.bDeviceProtocol, dev_desc.bNumConfigurations);
    if(((signed int)devclass == -1 || (signed int)devclass == (signed int)dev_desc.bDeviceClass) && ((signed int)subclass == -1 || (signed int)subclass == (signed int)dev_desc.bDeviceSubClass))
    {
      if((signed int)protocol == -1)
        tmp_if_expr_1 = (_Bool)1;

      else
      {
        protocol = (signed short int)dev_desc.bDeviceProtocol;
        tmp_if_expr_1 = protocol != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_1)
        goto __CPROVER_DUMP_L4;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      c = 0;
      for( ; !(c >= (signed int)dev_desc.bNumConfigurations); c = c + 1)
      {
        ret=openusb_get_raw_desc(handle, idev->devid, (unsigned char)0x02, (unsigned char)c, (unsigned short int)0, &buf, &buflen);
        if(!(ret >= 0))
          _usbi_debug(hdl, (unsigned int)2, "usbi_match_class", (unsigned int)467, "get raw config desc index %d for devid %llu failed (ret = %d)", c, idev->devid, ret);

        else
        {
          ret=openusb_parse_config_desc(handle, idev->devid, buf, buflen, (unsigned char)c, &cfg_desc);
          if(!(ret >= 0))
          {
            _usbi_debug(hdl, (unsigned int)2, "usbi_match_class", (unsigned int)475, "parse config desc index %d for devid %d failed (ret = %d)", c, idev->devid, ret);
            openusb_free_raw_desc(buf);
          }

          else
          {
            _usbi_debug(hdl, (unsigned int)4, "usbi_match_class", (unsigned int)481, "buflen = %d, int#=%d", buflen, cfg_desc.bNumInterfaces);
            i = 0;
            for( ; !(i >= (signed int)cfg_desc.bNumInterfaces); i = i + 1)
            {
              signed int num_alt;
              num_alt=usbi_get_num_altsettings(idev, buf, buflen, (unsigned char)i);
              if(!(num_alt >= 0))
                _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_match_class", (unsigned int)489, "altsetting error");

              else
              {
                a = 0;
                for( ; !(a >= num_alt); a = a + 1)
                {
                  ret=openusb_parse_interface_desc(handle, idev->devid, buf, buflen, (unsigned char)c, (unsigned char)i, (unsigned char)a, &ifc_desc);
                  if(!(ret >= 0))
                  {
                    const char *return_value_openusb_strerror_2;
                    return_value_openusb_strerror_2=openusb_strerror(ret);
                    _usbi_debug(hdl, (unsigned int)2, "usbi_match_class", (unsigned int)501, "get ifc desc %d-%d-%d failed (ret = %d (%s))", c, i, a, ret, return_value_openusb_strerror_2);
                    goto __CPROVER_DUMP_L12;
                  }

                  if(((signed int)devclass == -1 || (signed int)devclass == (signed int)ifc_desc.bInterfaceClass) && ((signed int)protocol == -1 || (signed int)protocol == (signed int)ifc_desc.bInterfaceProtocol) && ((signed int)subclass == -1 || (signed int)subclass == (signed int)ifc_desc.bInterfaceSubClass))
                  {
                    openusb_free_raw_desc(buf);
                    return 1;
                  }


                __CPROVER_DUMP_L12:
                  ;
                }
              }
            }
            openusb_free_raw_desc(buf);
          }
        }
      }
      return 0;
    }
  }
}

// usbi_nth_desc
// file devices.c line 1034
static unsigned char * usbi_nth_desc(unsigned char *buffer, unsigned short int buflen, unsigned char type, unsigned char n, unsigned char stop_type)
{
  unsigned char *sp = buffer;
  unsigned char tmp_post_1;
  _Bool tmp_if_expr_2;
  for( ; (signed int)buflen >= 2; sp = sp + (signed long int)sp[(signed long int)0])
  {
    if(!(sp == buffer))
    {
      if(sp[1l] == stop_type)
        return (unsigned char *)(void *)0;

    }

    if(sp[1l] == type)
    {
      tmp_post_1 = n;
      n = n - 1;
      if((signed int)tmp_post_1 == 0)
        return sp;

    }

    if((signed int)*sp == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)buflen < (signed int)sp[(signed long int)0] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (unsigned char *)(void *)0;

    buflen = buflen - (unsigned short int)sp[(signed long int)0];
  }
  return (unsigned char *)(void *)0;
}

// usbi_parse_configuration
// file descriptors.c line 484
signed int usbi_parse_configuration(struct usbi_config *cfg, unsigned char *buf, unsigned long int buflen)
{
  struct usb_descriptor_header header;
  signed int i;
  signed int retval;
  unsigned int count;
  char *extra;
  signed int extra_len;
  signed int numskipped = 0;
  if(buf == ((unsigned char *)NULL) || !(buflen >= 1ul))
    return -10;

  else
  {
    openusb_parse_data("bb", buf, (unsigned int)buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
    openusb_parse_data("bbwbbbbb", buf, (unsigned int)buflen, (void *)&cfg->desc, (unsigned int)sizeof(struct usb_config_desc) /*10ul*/ , &count);
    if((signed int)cfg->desc.bNumInterfaces >= 33)
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_configuration", (unsigned int)505, "too many interfaces, ignoring rest");
      return -1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)cfg->desc.bNumInterfaces * sizeof(struct usbi_interface) /*16ul*/ , (unsigned long int)1);
      cfg->interfaces = (struct usbi_interface *)return_value_calloc_1;
      if(cfg->interfaces == ((struct usbi_interface *)NULL))
      {
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_configuration", (unsigned int)514, "couldn't allocated %d bytes for interfaces", (unsigned long int)cfg->desc.bNumInterfaces * sizeof(struct usbi_interface) /*16ul*/ );
        return -1;
      }

      else
      {
        cfg->num_interfaces = (unsigned long int)cfg->desc.bNumInterfaces;
        memset((void *)cfg->interfaces, 0, cfg->num_interfaces * sizeof(struct usbi_interface) /*16ul*/ );
        buf = buf + (signed long int)header.bLength;
        buflen = buflen - (unsigned long int)header.bLength;
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_configuration", (unsigned int)526, "parse cfg buflen = %d, buf = %p", buflen, buf);
        extra = (char *)buf;
        extra_len = 0;
        while(buflen >= 2ul)
        {
          unsigned char type;
          openusb_parse_data("bb", buf, (unsigned int)buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
          if(!(buflen >= (unsigned long int)header.bLength) || !((signed int)header.bLength >= 2))
          {
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_configuration", (unsigned int)543, "invalid descriptor length of %d", header.bLength);
            free((void *)cfg->interfaces);
            return -1;
          }

          type = header.bDescriptorType;
          if((signed int)type == 0x01 || (signed int)type == 0x02 || (signed int)type == 0x04 || (signed int)type == 0x05)
            break;

          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_configuration", (unsigned int)558, "skipping descriptor 0x%X", type);
          numskipped = numskipped + 1;
          extra_len = extra_len + (signed int)header.bLength;
          buf = buf + (signed long int)header.bLength;
          buflen = buflen - (unsigned long int)header.bLength;
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_configuration", (unsigned int)567, "parse extra cfg buflen = %d, buf = %p", buflen, buf);
        }
        if(!(numskipped == 0))
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_configuration", (unsigned int)573, "skipped %d class/vendor specific endpoint descriptors", numskipped);

        if(!(extra_len == 0))
        {
          void *return_value_calloc_2;
          return_value_calloc_2=calloc((unsigned long int)extra_len, (unsigned long int)1);
          cfg->extra = (char *)return_value_calloc_2;
          if(cfg->extra == ((char *)NULL))
            return -10;

          memcpy((void *)cfg->extra, (const void *)extra, (unsigned long int)extra_len);
          cfg->extralen = (unsigned long int)extra_len;
        }

        else
          cfg->extra = (char *)(void *)0;
        i = 0;
        for( ; buflen >= 1ul && !((unsigned long int)i >= cfg->num_interfaces); i = i + 1)
        {
          retval=usbi_parse_interface(cfg->interfaces + (signed long int)i, buf, (unsigned int)buflen);
          if(!(retval >= 0))
          {
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_configuration", (unsigned int)592, "parse_interface fail");
            free((void *)cfg->interfaces);
            return retval;
          }

          buf = buf + (signed long int)retval;
          buflen = buflen - (unsigned long int)retval;
        }
        return (signed int)buflen;
      }
    }
  }
}

// usbi_parse_endpoint
// file descriptors.c line 136
static signed int usbi_parse_endpoint(struct usbi_endpoint *ep, unsigned char *buf, unsigned int buflen)
{
  struct usb_descriptor_header header;
  signed int parsed = 0;
  signed int numskipped = 0;
  unsigned int count;
  char *extra;
  signed int extra_len;
  if(buf == ((unsigned char *)NULL) || !(buflen >= 1u))
    return -10;

  else
  {
    _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)149, "parse ep buflen = %d, buf = %p", buflen, buf);
    openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
    if(!(buflen >= (unsigned int)header.bLength))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_endpoint", (unsigned int)158, "ran out of descriptors parsing");
      return -1;
    }

    else
      if(!((signed int)header.bDescriptorType == 0x05))
      {
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)167, "unexpected descriptor 0x%X, expecting endpoint descriptor, type 0x%X", header.bDescriptorType, 0x05);
        return parsed;
      }

      else
        if(!((signed int)header.bLength >= 7))
        {
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)174, "endpoint descriptor too short. only %d bytes long", header.bLength);
          return parsed;
        }

        else
        {
          if((signed int)header.bLength >= 9)
            openusb_parse_data("bbbbwbbb", buf, buflen, (void *)&ep->desc, (unsigned int)sizeof(struct usb_endpoint_desc) /*10ul*/ , &count);

          else
            if((signed int)header.bLength >= 7)
              openusb_parse_data("bbbbwb", buf, buflen, (void *)&ep->desc, (unsigned int)sizeof(struct usb_endpoint_desc) /*10ul*/ , &count);

          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)189, "wMaxPacketSize = %d", ep->desc.wMaxPacketSize);
          buf = buf + (signed long int)header.bLength;
          buflen = buflen - (unsigned int)header.bLength;
          parsed = parsed + (signed int)header.bLength;
          extra = (char *)buf;
          extra_len = 0;
          while(buflen >= 2u)
          {
            openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
            if(!((signed int)header.bLength >= 2))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_endpoint", (unsigned int)207, "invalid descriptor length of %d", header.bLength);
              return -1;
            }

            if((signed int)header.bDescriptorType == 0x01 || (signed int)header.bDescriptorType == 0x02 || (signed int)header.bDescriptorType == 0x04 || (signed int)header.bDescriptorType == 0x05)
              break;

            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)219, "skipping descriptor 0x%X", header.bDescriptorType);
            numskipped = numskipped + 1;
            extra_len = extra_len + (signed int)header.bLength;
            buf = buf + (signed long int)header.bLength;
            buflen = buflen - (unsigned int)header.bLength;
            parsed = parsed + (signed int)header.bLength;
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)230, "parse ep buflen = %d, buf = %p", buflen, buf);
          }
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)233, "extra len= %d", extra_len);
          if(!(extra_len == 0))
          {
            void *return_value_calloc_1;
            return_value_calloc_1=calloc((unsigned long int)extra_len, (unsigned long int)1);
            ep->extra = (char *)return_value_calloc_1;
            if(ep->extra == ((char *)NULL))
              return -1;

            memcpy((void *)ep->extra, (const void *)extra, (unsigned long int)extra_len);
            ep->extralen = (unsigned short int)extra_len;
          }

          if(!(numskipped == 0))
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_endpoint", (unsigned int)247, "skipped %d class/vendor specific endpoint descriptors", numskipped);

          return parsed;
        }
  }
}

// usbi_parse_interface
// file descriptors.c line 277
static signed int usbi_parse_interface(struct usbi_interface *intf, unsigned char *buf, unsigned int buflen)
{
  signed int i;
  signed int retval;
  signed int parsed = 0;
  signed int numskipped;
  struct usb_descriptor_header header;
  unsigned char alt_num;
  struct usbi_altsetting *as = (struct usbi_altsetting *)(void *)0;
  unsigned int count;
  char *extra;
  signed int extra_len;
  if(buf == ((unsigned char *)NULL) || !(buflen >= 1u))
    return -10;

  else
    if(!((signed int)buf[1l] == 0x04))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)294, "skipped type %d", buf[(signed long int)1]);
      return (signed int)buflen;
    }

    else
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)298, "parse alt buflen = %d, buf = %p", buflen, buf);
      signed int return_value_usbi_get_intf_altno_1;
      return_value_usbi_get_intf_altno_1=usbi_get_intf_altno((char *)buf, buflen);
      alt_num = (unsigned char)return_value_usbi_get_intf_altno_1;
      void *return_value_calloc_2;
      return_value_calloc_2=calloc(sizeof(struct usbi_altsetting) /*48ul*/  * (unsigned long int)alt_num, (unsigned long int)1);
      intf->altsettings = (struct usbi_altsetting *)return_value_calloc_2;
      if(intf->altsettings == ((struct usbi_altsetting *)NULL))
      {
        intf->num_altsettings = (unsigned long int)0;
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)306, "couldn't allocated memory for altsettings");
        return -1;
      }

      else
      {
        intf->num_altsettings = (unsigned long int)0;
        while(buflen >= 9u)
        {
          openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
          as = intf->altsettings + (signed long int)intf->num_altsettings;
          intf->num_altsettings = intf->num_altsettings + 1ul;
          openusb_parse_data("bbbbbbbbb", buf, buflen, (void *)&as->desc, (unsigned int)sizeof(struct usb_interface_desc) /*9ul*/ , &count);
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)327, "interface: num = %d, alt = %d, altno=%d", as->desc.bInterfaceNumber, as->desc.bAlternateSetting, intf->num_altsettings);
          buf = buf + (signed long int)header.bLength;
          parsed = parsed + (signed int)header.bLength;
          buflen = buflen - (unsigned int)header.bLength;
          numskipped = 0;
          extra = (char *)buf;
          extra_len = 0;
          while(buflen >= 2u)
          {
            unsigned char type;
            openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
            if(!((signed int)header.bLength >= 2))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)347, "invalid descriptor length of %d", header.bLength);
              free((void *)intf->altsettings);
              return -1;
            }

            type = header.bDescriptorType;
            if((signed int)type == 0x01 || (signed int)type == 0x02 || (signed int)type == 0x04 || (signed int)type == 0x05)
              break;

            numskipped = numskipped + 1;
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)364, "Skipped type: %x", type);
            extra_len = extra_len + (signed int)header.bLength;
            buf = buf + (signed long int)header.bLength;
            parsed = parsed + (signed int)header.bLength;
            buflen = buflen - (unsigned int)header.bLength;
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)372, "parse alt extra buflen = %d, buf = %p", buflen, buf);
          }
          if(!(numskipped == 0))
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)377, "skipped %d class/vendor specific interface descriptors", numskipped);

          if(!(extra_len == 0))
          {
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)380, "extra_len: %d", extra_len);
            void *return_value_calloc_3;
            return_value_calloc_3=calloc((unsigned long int)extra_len, (unsigned long int)1);
            as->extra = (char *)return_value_calloc_3;
            if(as->extra == ((char *)NULL))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "usbi_parse_interface", (unsigned int)385, "malloc fail");
              return -1;
            }

            memcpy((void *)as->extra, (const void *)extra, (unsigned long int)extra_len);
            as->extralen = (unsigned long int)extra_len;
          }

          openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
          if(buflen >= 2u && ((signed int)header.bDescriptorType == 0x01 || (signed int)header.bDescriptorType == 0x02))
            return parsed;

          if((signed int)as->desc.bNumEndpoints >= 33)
          {
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)403, "too many endpoints, ignoring rest");
            free((void *)intf->altsettings);
            return -1;
          }

          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)408, "endpoints:%d", as->desc.bNumEndpoints);
          void *return_value_calloc_4;
          return_value_calloc_4=calloc((unsigned long int)as->desc.bNumEndpoints * sizeof(struct usbi_endpoint) /*32ul*/ , (unsigned long int)1);
          as->endpoints = (struct usbi_endpoint *)return_value_calloc_4;
          if(as->endpoints == ((struct usbi_endpoint *)NULL))
          {
            _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)416, "couldn't allocated %d bytes for endpoints", (unsigned long int)as->desc.bNumEndpoints * sizeof(struct usb_endpoint_desc) /*10ul*/ );
            i = 0;
            for( ; !((unsigned long int)i >= intf->num_altsettings); i = i + 1)
            {
              as = intf->altsettings + (signed long int)intf->num_altsettings;
              free((void *)as->endpoints);
            }
            free((void *)intf->altsettings);
            return -1;
          }

          as->num_endpoints = (unsigned long int)as->desc.bNumEndpoints;
          i = 0;
          for( ; !((unsigned long int)i >= as->num_endpoints); i = i + 1)
          {
            openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
            if(!(buflen >= (unsigned int)header.bLength))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)434, "ran out of descriptors parsing");
              i = 0;
              for( ; intf->num_altsettings >= (unsigned long int)i; i = i + 1)
              {
                as = intf->altsettings + (signed long int)intf->num_altsettings;
                free((void *)as->endpoints);
              }
              free((void *)intf->altsettings);
              return -1;
            }

            retval=usbi_parse_endpoint(as->endpoints + (signed long int)i, buf, buflen);
            if(!(retval >= 0))
            {
              _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "usbi_parse_interface", (unsigned int)449, "parse endpoint error");
              i = 0;
              for( ; intf->num_altsettings >= (unsigned long int)i; i = i + 1)
              {
                as = intf->altsettings + (signed long int)intf->num_altsettings;
                free((void *)as->endpoints);
              }
              free((void *)intf->altsettings);
              return retval;
            }

            buf = buf + (signed long int)retval;
            parsed = parsed + retval;
            buflen = buflen - (unsigned int)retval;
          }
          if(!(buflen == 0u))
          {
            openusb_parse_data("bb", buf, buflen, (void *)&header, (unsigned int)sizeof(struct usb_descriptor_header) /*2ul*/ , &count);
            alt_num = buf[(signed long int)3];
            if(alt_num == 0 || !((signed int)header.bDescriptorType == 0x04) || !(buflen >= 9u))
              return parsed;

          }

        }
        return parsed;
      }
    }
}

// usbi_refresh_busses
// file devices.c line 195
static void usbi_refresh_busses(void)
{
  struct usbi_backend *backend;
  struct usbi_backend *tbackend;
  backend = (struct usbi_backend *)((char *)(&backends)->next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
  tbackend = (struct usbi_backend *)((char *)backend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list);
  for( ; !(&backend->list == &backends); tbackend = (struct usbi_backend *)((char *)tbackend->list.next - (signed long int)(unsigned long int)&((struct usbi_backend *)0L)->list))
  {
    if(!(backend == ((struct usbi_backend *)NULL)))
      refresh_bus(backend);

    backend = tbackend;
  }
}

// usbi_remove_device
// file devices.c line 253
void usbi_remove_device(struct usbi_device *idev)
{
  struct usbi_handle *handle;
  struct usbi_handle *thdl;
  unsigned long int devid = idev->devid;
  pthread_mutex_lock(&usbi_buses.lock);
  pthread_mutex_lock(&usbi_devices.lock);
  list_del(&idev->bus_list);
  list_del(&idev->dev_list);
  pthread_mutex_unlock(&usbi_buses.lock);
  pthread_mutex_unlock(&usbi_devices.lock);
  usbi_free_device(idev);
  pthread_mutex_lock(&usbi_handles.lock);
  handle = (struct usbi_handle *)((char *)(&usbi_handles.head)->next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list);
  thdl = (struct usbi_handle *)((char *)handle->list.next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list);
  for( ; !(&handle->list == &usbi_handles.head); thdl = (struct usbi_handle *)((char *)thdl->list.next - (signed long int)(unsigned long int)&((struct usbi_handle *)0L)->list))
  {
    if(!(handle == ((struct usbi_handle *)NULL)))
      usbi_add_event_callback(handle, devid, (enum openusb_event)USB_REMOVE);

    handle = thdl;
  }
  pthread_mutex_unlock(&usbi_handles.lock);
}

// usbi_rescan_devices
// file usbi.h line 401
void usbi_rescan_devices(void)
{
  struct usbi_bus *ibus;
  struct usbi_bus *tbus;
  usbi_refresh_busses();
  pthread_mutex_lock(&usbi_buses.lock);
  ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
  tbus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
  for( ; !(&ibus->list == &usbi_buses.head); tbus = (struct usbi_bus *)((char *)tbus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
  {
    if(!(ibus == ((struct usbi_bus *)NULL)))
    {
      if(!(ibus->ops == ((struct usbi_backend_ops *)NULL)))
      {
        pthread_mutex_unlock(&usbi_buses.lock);
        ibus->ops->refresh_devices(ibus);
        pthread_mutex_lock(&usbi_buses.lock);
      }

    }

    ibus = tbus;
  }
  pthread_mutex_unlock(&usbi_buses.lock);
}

// usbi_sync_submit
// file io.c line 255
signed int usbi_sync_submit(struct usbi_io *io)
{
  enum openusb_transfer_type type;
  struct usbi_dev_handle *dev;
  signed int ret;
  dev = io->dev;
  type = io->req->type;
  switch((signed int)type)
  {
    case USB_TYPE_CONTROL:
      ret=dev->idev->ops->ctrl_xfer_wait(dev, io);
    case USB_TYPE_INTERRUPT:
      ret=dev->idev->ops->intr_xfer_wait(dev, io);
    case USB_TYPE_ISOCHRONOUS:
      ret=dev->idev->ops->isoc_xfer_wait(dev, io);
    case USB_TYPE_BULK:
      ret=dev->idev->ops->bulk_xfer_wait(dev, io);
  }
  ret = -8;
  if(!(ret >= 0))
    return ret;

  else
    return 0;
}

// usbi_timeval_compare
// file usb.c line 1155
signed int usbi_timeval_compare(struct timeval *tva, struct timeval *tvb)
{
  if(!(tva->tv_sec >= tvb->tv_sec))
    return -1;

  else
    if(!(tvb->tv_sec >= tva->tv_sec))
      return 1;

  if(!(tva->tv_usec >= tvb->tv_usec))
    return -1;

  else
    if(!(tvb->tv_usec >= tva->tv_usec))
      return 1;

  return 0;
}

// wr_create_devices
// file emulation.c line 163
static signed int wr_create_devices(struct usb_bus *bus, struct usbi_bus *ibus)
{
  struct usbi_device *idev;
  struct usbi_device *tdev;
  struct usb_device *dev;
  struct usb_device *ndev;
  signed int dev_cnt = 0;
  struct usb_dev_handle *tmph;
  pthread_mutex_lock(&ibus->lock);
  idev = (struct usbi_device *)((char *)(&ibus->devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list);
  tdev = (struct usbi_device *)((char *)idev->bus_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list);
  for( ; !(&idev->bus_list == &ibus->devices.head); tdev = (struct usbi_device *)((char *)tdev->bus_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list))
  {
    if(!(idev == ((struct usbi_device *)NULL)))
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc(sizeof(struct usb_device) /*4184ul*/ , (unsigned long int)1);
      dev = (struct usb_device *)return_value_calloc_1;
      if(dev == ((struct usb_device *)NULL))
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        wr_error_str(*return_value___errno_location_2, "create_devices: No memory");
        pthread_mutex_unlock(&ibus->lock);
        return -1;
      }

      memcpy((void *)dev->filename, (const void *)idev->sys_path, (unsigned long int)4096);
      dev->bus = bus;
      dev->config = (struct usb_config_descriptor *)(void *)0;
      dev->dev = (void *)0;
      pthread_mutex_unlock(&ibus->lock);
      tmph=usb_open(dev);
      pthread_mutex_lock(&ibus->lock);
      if(!(tmph == ((struct usb_dev_handle *)NULL)))
      {
        pthread_mutex_unlock(&ibus->lock);
        usb_close(tmph);
        pthread_mutex_lock(&ibus->lock);
        if(bus->devices == ((struct usb_device *)NULL))
        {
          bus->devices = dev;
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "wr_create_devices", (unsigned int)201, "add device: %s", (const void *)dev->filename);
        }

        else
        {
          ndev = bus->devices;
          for( ; !(ndev->next == ((struct usb_device *)NULL)); ndev = ndev->next)
            ;
          ndev->next = dev;
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "wr_create_devices", (unsigned int)208, "add device: %s", (const void *)dev->filename);
        }
        if(!(idev->parent == ((struct usbi_device *)NULL)))
          dev_cnt = dev_cnt + 1;

      }

    }

    idev = tdev;
  }
  pthread_mutex_unlock(&ibus->lock);
  return dev_cnt;
}

// wr_error
// file emulation.c line 74
static signed int wr_error(signed int x)
{
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "wr_error", (unsigned int)76, "usb_error(): error=%d\n", x);
  usb_error_type = (enum anonymous_1)USB_ERROR_TYPE_ERRNO;
  usb_error_errno = x;
  return -x;
}

// wr_error_str
// file emulation.c line 56
static void wr_error_str(signed int x, const char *format, ...)
{
  void **ap = (void **)&format;
  usb_error_type = (enum anonymous_1)USB_ERROR_TYPE_STRING;
  usb_error_errno = x;
  vsnprintf(usb_error_string, sizeof(char [1024l]) /*1024ul*/ , format, ap);
  _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "wr_error_str", (unsigned int)68, "USB error (%d): %s\n", x, (const void *)usb_error_string);
  ap = ((void **)NULL);
}

// wr_find_device
// file emulation.c line 270
static unsigned long int wr_find_device(struct usb_device *dev)
{
  unsigned long int devid = (unsigned long int)-1;
  struct usbi_bus *ibus;
  struct usbi_device *idev = (struct usbi_device *)(void *)0;
  signed int found = 0;
  pthread_mutex_lock(&usbi_buses.lock);
  ibus = (struct usbi_bus *)((char *)(&usbi_buses.head)->next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list);
  for( ; !(&ibus->list == &usbi_buses.head); ibus = (struct usbi_bus *)((char *)ibus->list.next - (signed long int)(unsigned long int)&((struct usbi_bus *)0L)->list))
    if(!(ibus == ((struct usbi_bus *)NULL)))
    {
      pthread_mutex_lock(&ibus->devices.lock);
      idev = (struct usbi_device *)((char *)(&ibus->devices.head)->next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list);
      for( ; !(&idev->bus_list == &ibus->devices.head); idev = (struct usbi_device *)((char *)idev->bus_list.next - (signed long int)(unsigned long int)&((struct usbi_device *)0L)->bus_list))
      {
        signed int return_value_strncmp_1;
        return_value_strncmp_1=strncmp(idev->sys_path, dev->filename, (unsigned long int)4096);
        if(return_value_strncmp_1 == 0)
        {
          found = 1;
          pthread_mutex_unlock(&ibus->devices.lock);
          goto out;
        }

      }
      pthread_mutex_unlock(&ibus->devices.lock);
    }


out:
  ;
  if(found == 1)
    devid = idev->devid;

  pthread_mutex_unlock(&usbi_buses.lock);
  return devid;
}

// wr_parse_endpoint
// file emulation.c line 316
static signed int wr_parse_endpoint(struct usb_interface_descriptor *ifdesc, struct usbi_altsetting *alt)
{
  signed int num_eps;
  struct usbi_endpoint *ep10;
  struct usb_endpoint_descriptor *ep01;
  signed int len;
  signed int i;
  num_eps = (signed int)alt->num_endpoints;
  if(num_eps >= 1)
  {
    len = (signed int)(sizeof(struct usb_endpoint_descriptor) /*32ul*/  * (unsigned long int)num_eps);
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)len, (unsigned long int)1);
    ifdesc->endpoint = (struct usb_endpoint_descriptor *)return_value_calloc_1;
    if(ifdesc->endpoint == ((struct usb_endpoint_descriptor *)NULL))
      return -1;

  }

  else
    return 0;
  i = 0;
  for( ; !(i >= num_eps); i = i + 1)
  {
    ep01 = &ifdesc->endpoint[(signed long int)i];
    ep10 = &alt->endpoints[(signed long int)i];
    ep01->bLength = ep10->desc.bLength;
    ep01->bDescriptorType = ep10->desc.bDescriptorType;
    ep01->bEndpointAddress = ep10->desc.bEndpointAddress;
    ep01->bmAttributes = ep10->desc.bmAttributes;
    unsigned int return_value_openusb_le32_to_cpu_2;
    return_value_openusb_le32_to_cpu_2=openusb_le32_to_cpu((unsigned int)ep10->desc.wMaxPacketSize);
    ep01->wMaxPacketSize = (unsigned short int)return_value_openusb_le32_to_cpu_2;
    ep01->bInterval = ep10->desc.bInterval;
    ep01->bRefresh = ep10->desc.bRefresh;
    ep01->bSynchAddress = ep10->desc.bSynchAddress;
    if(!(ep10->extra == ((char *)NULL)))
    {
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)ep10->extralen, (unsigned long int)1);
      ep01->extra = (unsigned char *)return_value_calloc_3;
      if(ep01->extra == ((unsigned char *)NULL))
        return -1;

      memcpy((void *)ep01->extra, (const void *)ep10->extra, (unsigned long int)ep10->extralen);
      ep01->extralen = (signed int)ep10->extralen;
    }

  }
  return 0;
}

// wr_parse_interface
// file emulation.c line 364
static signed int wr_parse_interface(struct usb_interface *ifc01, struct usbi_interface *ifc10)
{
  signed int num_alts;
  struct usbi_altsetting *alt;
  struct usb_interface_descriptor *ifdesc;
  signed int i;
  num_alts = (signed int)ifc10->num_altsettings;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct usb_interface_descriptor) /*40ul*/  * (unsigned long int)num_alts, (unsigned long int)1);
  ifc01->altsetting = (struct usb_interface_descriptor *)return_value_calloc_1;
  if(ifc01->altsetting == ((struct usb_interface_descriptor *)NULL))
    return -1;

  else
  {
    ifc01->num_altsetting = num_alts;
    i = 0;
    for( ; !(i >= num_alts); i = i + 1)
    {
      alt = &ifc10->altsettings[(signed long int)i];
      ifdesc = &ifc01->altsetting[(signed long int)i];
      ifdesc->bLength = alt->desc.bLength;
      ifdesc->bDescriptorType = alt->desc.bDescriptorType;
      ifdesc->bInterfaceNumber = alt->desc.bInterfaceNumber;
      ifdesc->bAlternateSetting = alt->desc.bAlternateSetting;
      ifdesc->bNumEndpoints = alt->desc.bNumEndpoints;
      ifdesc->bInterfaceClass = alt->desc.bInterfaceClass;
      ifdesc->bInterfaceSubClass = alt->desc.bInterfaceSubClass;
      ifdesc->bInterfaceProtocol = alt->desc.bInterfaceProtocol;
      ifdesc->iInterface = alt->desc.iInterface;
      if(!(alt->extra == ((char *)NULL)))
      {
        void *return_value_calloc_2;
        return_value_calloc_2=calloc(alt->extralen, (unsigned long int)1);
        ifdesc->extra = (unsigned char *)return_value_calloc_2;
        if(ifdesc->extra == ((unsigned char *)NULL))
          return -1;

        memcpy((void *)ifdesc->extra, (const void *)alt->extra, alt->extralen);
        ifdesc->extralen = (signed int)alt->extralen;
      }

      signed int return_value_wr_parse_endpoint_3;
      return_value_wr_parse_endpoint_3=wr_parse_endpoint(ifdesc, alt);
      if(!(return_value_wr_parse_endpoint_3 == 0))
      {
        free((void *)ifc01->altsetting);
        return -1;
      }

    }
    return 0;
  }
}

// wr_setup_dev_config
// file emulation.c line 422
static signed int wr_setup_dev_config(struct usb_device *dev, unsigned long int devid, unsigned long int devh)
{
  struct usbi_device *idev;
  struct usbi_descriptors *desc;
  signed int num_configs;
  signed int i;
  struct usb_config_descriptor *pcfg;
  struct usb_config_desc *picfg;
  struct usbi_config *config;
  signed int ret;
  struct usbi_dev_handle *hdev;
  hdev=usbi_find_dev_handle(devh);
  if(hdev == ((struct usbi_dev_handle *)NULL))
    return -1;

  else
  {
    ret=usbi_fetch_and_parse_descriptors(hdev);
    if(!(ret == 0))
    {
      _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "wr_setup_dev_config", (unsigned int)443, "fail to get descriptor");
      return -1;
    }

    else
    {
      idev=usbi_find_device_by_id(devid);
      if(idev == ((struct usbi_device *)NULL))
      {
        _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "wr_setup_dev_config", (unsigned int)449, "Can't find device %d", (signed int)devid);
        return -1;
      }

      else
      {
        desc = (struct usbi_descriptors *)&idev->desc;
        memcpy((void *)&dev->descriptor, (const void *)&desc->device, sizeof(struct usb_device_desc) /*18ul*/ );
        num_configs = (signed int)desc->device.bNumConfigurations;
        if(num_configs == 0)
        {
          _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)1, "wr_setup_dev_config", (unsigned int)460, "Zero configurations");
          dev->config = (struct usb_config_descriptor *)(void *)0;
          return -1;
        }

        else
        {
          void *return_value_calloc_1;
          return_value_calloc_1=calloc(sizeof(struct usb_config_descriptor) /*40ul*/  * (unsigned long int)num_configs, (unsigned long int)1);
          dev->config = (struct usb_config_descriptor *)return_value_calloc_1;
          if(dev->config == ((struct usb_config_descriptor *)NULL))
            return -2;

          else
          {
            i = 0;
            for( ; !(i >= num_configs); i = i + 1)
            {
              signed int num_ifs;
              struct usbi_interface *ifc10;
              struct usb_interface *ifc01;
              signed int j;
              pcfg = (struct usb_config_descriptor *)&dev->config[(signed long int)i];
              config = &idev->desc.configs[(signed long int)i];
              picfg = &config->desc;
              pcfg->bLength = picfg->bLength;
              pcfg->bDescriptorType = picfg->bDescriptorType;
              unsigned int return_value_openusb_le32_to_cpu_2;
              return_value_openusb_le32_to_cpu_2=openusb_le32_to_cpu((unsigned int)picfg->wTotalLength);
              pcfg->wTotalLength = (unsigned short int)return_value_openusb_le32_to_cpu_2;
              pcfg->bNumInterfaces = picfg->bNumInterfaces;
              pcfg->bConfigurationValue = picfg->bConfigurationValue;
              pcfg->iConfiguration = picfg->iConfiguration;
              pcfg->bmAttributes = picfg->bmAttributes;
              pcfg->MaxPower = picfg->bMaxPower;
              if(!(config->extralen == 0ul))
              {
                void *return_value_calloc_3;
                return_value_calloc_3=calloc(config->extralen, (unsigned long int)1);
                pcfg->extra = (unsigned char *)return_value_calloc_3;
                if(pcfg->extra == ((unsigned char *)NULL))
                  return -1;

                memcpy((void *)pcfg->extra, (const void *)config->extra, config->extralen);
                pcfg->extralen = (signed int)config->extralen;
              }

              num_ifs = (signed int)config->num_interfaces;
              if(num_ifs == 0)
              {
                _usbi_debug((struct usbi_handle *)(void *)0, (unsigned int)4, "wr_setup_dev_config", (unsigned int)505, "Zero interfaces");
                return 0;
              }

              void *return_value_calloc_4;
              return_value_calloc_4=calloc(sizeof(struct usb_interface) /*16ul*/  * (unsigned long int)num_ifs, (unsigned long int)1);
              pcfg->interface = (struct usb_interface *)return_value_calloc_4;
              if(pcfg->interface == ((struct usb_interface *)NULL))
              {
                free((void *)dev->config);
                return -2;
              }

              j = 0;
              for( ; !(j >= num_ifs); j = j + 1)
              {
                ifc01 = &pcfg->interface[(signed long int)j];
                ifc10 = &config->interfaces[(signed long int)j];
                signed int return_value_wr_parse_interface_5;
                return_value_wr_parse_interface_5=wr_parse_interface(ifc01, ifc10);
                if(!(return_value_wr_parse_interface_5 == 0))
                {
                  free((void *)pcfg->interface);
                  return -1;
                }

              }
            }
            return 0;
          }
        }
      }
    }
  }
}

