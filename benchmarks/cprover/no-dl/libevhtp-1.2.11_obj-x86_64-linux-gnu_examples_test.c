// #anon_enum_s_query_start=0_s_query_separator=1_s_query_key=2_s_query_val=3_s_query_key_hex_1=4_s_query_key_hex_2=5_s_query_val_hex_1=6_s_query_val_hex_2=7_s_query_done=8
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2643
enum anonymous_14 { s_query_start=0, s_query_separator=1, s_query_key=2, s_query_val=3, s_query_key_hex_1=4, s_query_key_hex_2=5, s_query_val_hex_1=6, s_query_val_hex_2=7, s_query_done=8 };

// tag-#anon#ST[*{SYM#tag-evhtp_alias_s#}_SYM#tag-evhtp_alias_s#_'tqe_next'||*{*{SYM#tag-evhtp_alias_s#}_SYM#tag-evhtp_alias_s#_}_*{SYM#tag-evhtp_alias_s#}_SYM#tag-evhtp_alias_s#__'tqe_prev'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 284
struct anonymous_7;

// tag-#anon#ST[*{SYM#tag-evhtp_alias_s#}_SYM#tag-evhtp_alias_s#_'tqh_first'||*{*{SYM#tag-evhtp_alias_s#}_SYM#tag-evhtp_alias_s#_}_*{SYM#tag-evhtp_alias_s#}_SYM#tag-evhtp_alias_s#__'tqh_last'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 327
struct anonymous_18;

// tag-#anon#ST[*{SYM#tag-evhtp_callback_s#}_SYM#tag-evhtp_callback_s#_'tqe_next'||*{*{SYM#tag-evhtp_callback_s#}_SYM#tag-evhtp_callback_s#_}_*{SYM#tag-evhtp_callback_s#}_SYM#tag-evhtp_callback_s#__'tqe_prev'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 361
struct anonymous_4;

// tag-#anon#ST[*{SYM#tag-evhtp_kv_s#}_SYM#tag-evhtp_kv_s#_'tqe_next'||*{*{SYM#tag-evhtp_kv_s#}_SYM#tag-evhtp_kv_s#_}_*{SYM#tag-evhtp_kv_s#}_SYM#tag-evhtp_kv_s#__'tqe_prev'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 379
struct anonymous_21;

// tag-#anon#ST[*{SYM#tag-evhtp_request_s#}_SYM#tag-evhtp_request_s#_'tqe_next'||*{*{SYM#tag-evhtp_request_s#}_SYM#tag-evhtp_request_s#_}_*{SYM#tag-evhtp_request_s#}_SYM#tag-evhtp_request_s#__'tqe_prev'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 452
struct anonymous_17;

// tag-#anon#ST[*{SYM#tag-evhtp_s#}_SYM#tag-evhtp_s#_'tqe_next'||*{*{SYM#tag-evhtp_s#}_SYM#tag-evhtp_s#_}_*{SYM#tag-evhtp_s#}_SYM#tag-evhtp_s#__'tqe_prev'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 329
struct anonymous_20;

// tag-#anon#ST[*{SYM#tag-evhtp_s#}_SYM#tag-evhtp_s#_'tqh_first'||*{*{SYM#tag-evhtp_s#}_SYM#tag-evhtp_s#_}_*{SYM#tag-evhtp_s#}_SYM#tag-evhtp_s#__'tqh_last'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 328
struct anonymous_19;

// tag-#anon#ST[*{SYM#tag-evthr#}_SYM#tag-evthr#_'tqe_next'||*{*{SYM#tag-evthr#}_SYM#tag-evthr#_}_*{SYM#tag-evthr#}_SYM#tag-evthr#__'tqe_prev'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 61
struct anonymous_16;

// tag-#anon#ST[*{V}_V_'onig'||U64're_nsub'||S32'comp_options'||U32'_pad0'|]
// file /usr/include/onigposix.h line 83
struct anonymous_5;

// tag-#anon#ST[ARR128{U8}_U8_'cert_verify_md'||ARR128{U8}_U8_'finish_md'||S32'finish_md_len'||ARR128{U8}_U8_'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'_pad0'||*{cSYM#tag-ssl_cipher_st#}_cSYM#tag-ssl_cipher_st#_'new_cipher'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}_S8_'ctype'||U56'_pad1'||*{SYM#tag-stack_st_X509_NAME#}_SYM#tag-stack_st_X509_NAME#_'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}_U8_'key_block'||*{cSYM#tag-evp_cipher_st#}_cSYM#tag-evp_cipher_st#_'new_sym_enc'||*{cSYM#tag-env_md_st#}_cSYM#tag-env_md_st#_'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}_cSYM#tag-ssl_comp_st#_'new_compression'||S32'cert_request'||U32'_pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous_13;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/onigposix.h line 77
struct anonymous_6;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous_15;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}_U8_'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous_12;

// tag-#anon#UN[*{S8}_S8_'path'||*{S8}_S8_'glob'||*{SYM#tag-#anon#ST[*{V}_V_'onig'||U64're_nsub'||S32'comp_options'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{V}_V_'onig'||U64're_nsub'||S32'comp_options'||U32'_pad0'|]#_'regex'|]
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 353
union anonymous_11;

// tag-#anon#UN[*{S8}_S8_'ptr'||*{SYM#tag-rsa_st#}_SYM#tag-rsa_st#_'rsa'||*{SYM#tag-dsa_st#}_SYM#tag-dsa_st#_'dsa'||*{SYM#tag-dh_st#}_SYM#tag-dh_st#_'dh'||*{SYM#tag-ec_key_st#}_SYM#tag-ec_key_st#_'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous_1;

// tag-#anon#UN[*{S8}_S8_'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'asn1_string'||*{SYM#tag-asn1_object_st#}_SYM#tag-asn1_object_st#_'object'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'integer'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'enumerated'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bit_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'octet_string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'printablestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'t61string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'ia5string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'bmpstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'universalstring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utctime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'generalizedtime'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'visiblestring'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'utf8string'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'set'||*{SYM#tag-asn1_string_st#}_SYM#tag-asn1_string_st#_'sequence'||*{SYM#tag-ASN1_VALUE_st#}_SYM#tag-ASN1_VALUE_st#_'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous_0;

// tag-#anon#UN[*{V(S32|S32|*{V}_V_)->V}_V(S32|S32|*{V}_V_)->V_'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32}_S32(S32|S32|*{SYM#tag-bn_gencb_st#}_SYM#tag-bn_gencb_st#_)->S32_'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_2;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_9;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_8;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_10;

// tag-ASIdentifiers_st
// file /usr/include/openssl/x509.h line 293
struct ASIdentifiers_st;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-bufferevent
// file /usr/include/event2/bufferevent.h line 111
struct bufferevent;

// tag-bufferevent_flush_mode
// file /usr/include/event2/bufferevent.h line 494
enum bufferevent_flush_mode { BEV_NORMAL=0, BEV_FLUSH=1, BEV_FINISHED=2 };

// tag-bufferevent_ssl_state
// file /usr/include/event2/bufferevent_ssl.h line 49
enum bufferevent_ssl_state { BUFFEREVENT_SSL_OPEN=0, BUFFEREVENT_SSL_CONNECTING=1, BUFFEREVENT_SSL_ACCEPTING=2 };

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-ev_token_bucket_cfg
// file /usr/include/event2/bufferevent.h line 604
struct ev_token_bucket_cfg;

// tag-eval_hdr_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 42
enum eval_hdr_val { eval_hdr_val_none=0, eval_hdr_val_connection=1, eval_hdr_val_proxy_connection=2, eval_hdr_val_content_length=3, eval_hdr_val_transfer_encoding=4, eval_hdr_val_hostname=5, eval_hdr_val_content_type=6 };

// tag-evbuffer
// file /usr/include/event2/buffer.h line 95
struct evbuffer;

// tag-evconnlistener
// file /usr/include/event2/listener.h line 37
struct evconnlistener;

// tag-evdns_base
// file /usr/include/event2/dns.h line 201
struct evdns_base;

// tag-event
// file /usr/include/event2/event.h line 272
struct event;

// tag-event_base
// file /usr/include/event2/event.h line 213
struct event_base;

// tag-evhtp_alias_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 96
struct evhtp_alias_s;

// tag-evhtp_authority_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 91
struct evhtp_authority_s;

// tag-evhtp_callback_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 85
struct evhtp_callback_s;

// tag-evhtp_callback_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 138
enum evhtp_callback_type { evhtp_callback_type_hash=0, evhtp_callback_type_glob=1, evhtp_callback_type_regex=2 };

// tag-evhtp_callbacks_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 84
struct evhtp_callbacks_s;

// tag-evhtp_connection_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 94
struct evhtp_connection_s;

// tag-evhtp_defaults_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 83
struct evhtp_defaults_s;

// tag-evhtp_hook_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 120
enum evhtp_hook_type { evhtp_hook_on_header=0, evhtp_hook_on_headers=1, evhtp_hook_on_path=2, evhtp_hook_on_read=3, evhtp_hook_on_request_fini=4, evhtp_hook_on_connection_fini=5, evhtp_hook_on_new_chunk=6, evhtp_hook_on_chunk_complete=7, evhtp_hook_on_chunks_complete=8, evhtp_hook_on_headers_start=9, evhtp_hook_on_error=10, evhtp_hook_on_hostname=11, evhtp_hook_on_write=12, evhtp_hook_on_event=13, evhtp_hook_on_conn_error=14 };

// tag-evhtp_hooks_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 93
struct evhtp_hooks_s;

// tag-evhtp_kv_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 87
struct evhtp_kv_s;

// tag-evhtp_kvs_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 88
struct evhtp_kvs_s;

// tag-evhtp_path_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 90
struct evhtp_path_s;

// tag-evhtp_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 146
enum evhtp_proto { EVHTP_PROTO_INVALID=0, EVHTP_PROTO_10=1, EVHTP_PROTO_11=2 };

// tag-evhtp_request_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 92
struct evhtp_request_s;

// tag-evhtp_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 82
struct evhtp_s;

// tag-evhtp_ssl_cfg_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 95
struct evhtp_ssl_cfg_s;

// tag-evhtp_ssl_scache_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 109
enum evhtp_ssl_scache_type { evhtp_ssl_scache_type_disabled=0, evhtp_ssl_scache_type_internal=1, evhtp_ssl_scache_type_user=2, evhtp_ssl_scache_type_builtin=3 };

// tag-evhtp_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 152
enum evhtp_type { evhtp_type_client=0, evhtp_type_server=1 };

// tag-evhtp_uri_s
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 89
struct evhtp_uri_s;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-evthr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 24
struct evthr;

// tag-evthr_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 25
struct evthr_cmd;

// tag-evthr_pool
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 23
struct evthr_pool;

// tag-evthr_pool_slist
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 26
struct evthr_pool_slist;

// tag-evthr_res
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 15
enum evthr_res { EVTHR_RES_OK=0, EVTHR_RES_BACKLOG=1, EVTHR_RES_RETRY=2, EVTHR_RES_NOCB=3, EVTHR_RES_FATAL=4 };

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-htp_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 26
enum htp_method { htp_method_GET=0, htp_method_HEAD=1, htp_method_POST=2, htp_method_PUT=3, htp_method_DELETE=4, htp_method_MKCOL=5, htp_method_COPY=6, htp_method_MOVE=7, htp_method_OPTIONS=8, htp_method_PROPFIND=9, htp_method_PROPPATCH=10, htp_method_LOCK=11, htp_method_UNLOCK=12, htp_method_TRACE=13, htp_method_CONNECT=14, htp_method_PATCH=15, htp_method_UNKNOWN=16 };

// tag-htp_scheme
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 17
enum htp_scheme { htp_scheme_none=0, htp_scheme_ftp=1, htp_scheme_http=2, htp_scheme_https=3, htp_scheme_nfs=4, htp_scheme_unknown=5 };

// tag-htp_type
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 12
enum htp_type { htp_type_request=0, htp_type_response=1 };

// tag-htparse_hooks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 64
struct htparse_hooks;

// tag-htparser
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 10
struct htparser;

// tag-htpparse_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 46
enum htpparse_error { htparse_error_none=0, htparse_error_too_big=1, htparse_error_inval_method=2, htparse_error_inval_reqline=3, htparse_error_inval_schema=4, htparse_error_inval_proto=5, htparse_error_inval_ver=6, htparse_error_inval_hdr=7, htparse_error_inval_chunk_sz=8, htparse_error_inval_chunk=9, htparse_error_inval_state=10, htparse_error_user=11, htparse_error_status=12, htparse_error_generic=13 };

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-parser_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 52
enum parser_flags { parser_flag_chunked=1, parser_flag_connection_keep_alive=2, parser_flag_connection_close=4, parser_flag_trailing=8 };

// tag-parser_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 59
enum parser_state { s_start=0, s_method=1, s_spaces_before_uri=2, s_schema=3, s_schema_slash=4, s_schema_slash_slash=5, s_host=6, s_host_ipv6=7, s_host_done=8, s_port=9, s_after_slash_in_uri=10, s_check_uri=11, s_uri=12, s_http_09=13, s_http_H=14, s_http_HT=15, s_http_HTT=16, s_http_HTTP=17, s_first_major_digit=18, s_major_digit=19, s_first_minor_digit=20, s_minor_digit=21, s_spaces_after_digit=22, s_almost_done=23, s_done=24, s_hdrline_start=25, s_hdrline_hdr_almost_done=26, s_hdrline_hdr_done=27, s_hdrline_hdr_key=28, s_hdrline_hdr_space_before_val=29, s_hdrline_hdr_val=30, s_hdrline_almost_done=31, s_hdrline_done=32, s_body_read=33, s_chunk_size_start=34, s_chunk_size=35, s_chunk_size_almost_done=36, s_chunk_data=37, s_chunk_data_almost_done=38, s_chunk_data_done=39, s_status=40, s_space_after_status=41, s_status_text=42 };

// tag-pauser
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 29
struct pauser;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/event2/bufferevent_ssl.h line 43
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_IPAddressFamily
// file /usr/include/openssl/x509.h line 292
struct stack_st_IPAddressFamily;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-unscape_state
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2682
enum unscape_state { unscape_state_start=0, unscape_state_hex1=1, unscape_state_hex2=2 };

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_id_callback
// file /usr/include/openssl/crypto.h line 462
void CRYPTO_set_id_callback(unsigned long int (*)(void));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// DH_free
// file /usr/include/openssl/dh.h line 201
void DH_free(struct dh_st *);
// EC_KEY_free
// file /usr/include/openssl/ec.h line 772
void EC_KEY_free(struct ec_key_st *);
// EC_KEY_new_by_curve_name
// file /usr/include/openssl/ec.h line 767
struct ec_key_st * EC_KEY_new_by_curve_name(signed int);
// OBJ_sn2nid
// file /usr/include/openssl/objects.h line 1016
signed int OBJ_sn2nid(const char *);
// PEM_read_DHparams
// file /usr/include/openssl/pem.h line 477
struct dh_st * PEM_read_DHparams(struct _IO_FILE *, struct dh_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// RAND_poll
// file /usr/include/openssl/rand.h line 112
signed int RAND_poll(void);
// SSL_CTX_callback_ctrl
// file /usr/include/openssl/ssl.h line 2340
signed long int SSL_CTX_callback_ctrl(struct ssl_ctx_st *, signed int, void (*)(void));
// SSL_CTX_ctrl
// file /usr/include/openssl/ssl.h line 2339
signed long int SSL_CTX_ctrl(struct ssl_ctx_st *, signed int, signed long int, void *);
// SSL_CTX_free
// file /usr/include/openssl/ssl.h line 2132
void SSL_CTX_free(struct ssl_ctx_st *);
// SSL_CTX_get_cert_store
// file /usr/include/openssl/ssl.h line 2135
struct x509_store_st * SSL_CTX_get_cert_store(const struct ssl_ctx_st *);
// SSL_CTX_get_ex_data
// file /usr/include/openssl/ssl.h line 2472
void * SSL_CTX_get_ex_data(const struct ssl_ctx_st *, signed int);
// SSL_CTX_get_verify_callback
// file /usr/include/openssl/ssl.h line 2260
signed int (*SSL_CTX_get_verify_callback(const struct ssl_ctx_st *))(signed int, struct x509_store_ctx_st *);
// SSL_CTX_get_verify_mode
// file /usr/include/openssl/ssl.h line 2258
signed int SSL_CTX_get_verify_mode(const struct ssl_ctx_st *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_sess_set_get_cb
// file /usr/include/openssl/ssl.h line 1237
void SSL_CTX_sess_set_get_cb(struct ssl_ctx_st *, struct ssl_session_st * (*)(struct ssl_st *, unsigned char *, signed int, signed int *));
// SSL_CTX_sess_set_new_cb
// file /usr/include/openssl/ssl.h line 1225
void SSL_CTX_sess_set_new_cb(struct ssl_ctx_st *, signed int (*)(struct ssl_st *, struct ssl_session_st *));
// SSL_CTX_sess_set_remove_cb
// file /usr/include/openssl/ssl.h line 1230
void SSL_CTX_sess_set_remove_cb(struct ssl_ctx_st *, void (*)(struct ssl_ctx_st *, struct ssl_session_st *));
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_ex_data
// file /usr/include/openssl/ssl.h line 2471
signed int SSL_CTX_set_ex_data(struct ssl_ctx_st *, signed int, void *);
// SSL_CTX_set_session_id_context
// file /usr/include/openssl/ssl.h line 2288
signed int SSL_CTX_set_session_id_context(struct ssl_ctx_st *, const unsigned char *, unsigned int);
// SSL_CTX_set_timeout
// file /usr/include/openssl/ssl.h line 2133
signed long int SSL_CTX_set_timeout(struct ssl_ctx_st *, signed long int);
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_set_verify_depth
// file /usr/include/openssl/ssl.h line 2264
void SSL_CTX_set_verify_depth(struct ssl_ctx_st *, signed int);
// SSL_CTX_use_PrivateKey_file
// file /usr/include/openssl/ssl.h line 2199
signed int SSL_CTX_use_PrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_SESSION_set_timeout
// file /usr/include/openssl/ssl.h line 2224
signed long int SSL_SESSION_set_timeout(struct ssl_session_st *, signed long int);
// SSL_ctrl
// file /usr/include/openssl/ssl.h line 2337
signed long int SSL_ctrl(struct ssl_st *, signed int, signed long int, void *);
// SSL_get_ex_data
// file /usr/include/openssl/ssl.h line 2460
void * SSL_get_ex_data(const struct ssl_st *, signed int);
// SSL_get_servername
// file /usr/include/openssl/tls1.h line 309
const char * SSL_get_servername(const struct ssl_st *, const signed int);
// SSL_get_verify_mode
// file /usr/include/openssl/ssl.h line 2167
signed int SSL_get_verify_mode(const struct ssl_st *);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_set_SSL_CTX
// file /usr/include/openssl/ssl.h line 2448
struct ssl_ctx_st * SSL_set_SSL_CTX(struct ssl_st *, struct ssl_ctx_st *);
// SSL_set_ex_data
// file /usr/include/openssl/ssl.h line 2459
signed int SSL_set_ex_data(struct ssl_st *, signed int, void *);
// SSL_set_shutdown
// file /usr/include/openssl/ssl.h line 2438
void SSL_set_shutdown(struct ssl_st *, signed int);
// SSL_set_verify
// file /usr/include/openssl/ssl.h line 2170
void SSL_set_verify(struct ssl_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_shutdown
// file /usr/include/openssl/ssl.h line 2397
signed int SSL_shutdown(struct ssl_st *);
// SSLv23_server_method
// file /usr/include/openssl/ssl.h line 2362
const struct ssl_method_st * SSLv23_server_method(void);
// X509_STORE_set_flags
// file /usr/include/openssl/x509_vfy.h line 467
signed int X509_STORE_set_flags(struct x509_store_st *, unsigned long int);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _evhtp_accept_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2168
static void _evhtp_accept_cb(struct evconnlistener *serv, signed int fd, struct sockaddr *s, signed int sl, void *arg);
// _evhtp_authority_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 814
static void _evhtp_authority_free(struct evhtp_authority_s *authority);
// _evhtp_authority_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 832
static struct evhtp_authority_s * _evhtp_authority_new(void);
// _evhtp_body_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 444
static inline unsigned short int _evhtp_body_hook(struct evhtp_request_s *request, struct evbuffer *buf);
// _evhtp_callback_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 643
static struct evhtp_callback_s * _evhtp_callback_find(struct evhtp_callbacks_s *cbs, const char *path, unsigned int *start_offset, unsigned int *end_offset);
// _evhtp_chunk_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 473
static inline unsigned short int _evhtp_chunk_fini_hook(struct evhtp_request_s *request);
// _evhtp_chunk_new_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 466
static inline unsigned short int _evhtp_chunk_new_hook(struct evhtp_request_s *request, unsigned long int len);
// _evhtp_chunks_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 480
static inline unsigned short int _evhtp_chunks_fini_hook(struct evhtp_request_s *request);
// _evhtp_connection_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1999
static signed int _evhtp_connection_accept(struct event_base *evbase, struct evhtp_connection_s *connection);
// _evhtp_connection_error_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 532
static inline unsigned short int _evhtp_connection_error_hook(struct evhtp_connection_s *connection, unsigned char errtype);
// _evhtp_connection_eventcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1917
static void _evhtp_connection_eventcb(struct bufferevent *bev, signed short int events, void *arg);
// _evhtp_connection_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 502
static inline unsigned short int _evhtp_connection_fini_hook(struct evhtp_connection_s *connection);
// _evhtp_connection_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2073
static struct evhtp_connection_s * _evhtp_connection_new(struct evhtp_s *htp, signed int sock, enum evhtp_type type);
// _evhtp_connection_readcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1775
static void _evhtp_connection_readcb(struct bufferevent *bev, void *arg);
// _evhtp_connection_resumecb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1743
static void _evhtp_connection_resumecb(signed int fd, signed short int events, void *arg);
// _evhtp_connection_write_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 550
static inline unsigned short int _evhtp_connection_write_hook(struct evhtp_connection_s *connection);
// _evhtp_connection_writecb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1843
static void _evhtp_connection_writecb(struct bufferevent *bev, void *arg);
// _evhtp_create_headers
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1612
static signed int _evhtp_create_headers(struct evhtp_kv_s *header, void *arg);
// _evhtp_create_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1625
static struct evbuffer * _evhtp_create_reply(struct evhtp_request_s *request, unsigned short int code);
// _evhtp_default_request_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2066
static void _evhtp_default_request_cb(struct evhtp_request_s *request, void *arg);
// _evhtp_error_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 518
static inline void _evhtp_error_hook(struct evhtp_request_s *request, unsigned char errtype);
// _evhtp_glob_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 626
static inline signed int _evhtp_glob_match(const char *pattern, unsigned long int pat_len, const char *string, unsigned long int str_len);
// _evhtp_glob_match2
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 560
static signed int _evhtp_glob_match2(const char *pattern, unsigned long int plen, const char *string, unsigned long int str_len);
// _evhtp_header_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 411
static inline unsigned short int _evhtp_header_hook(struct evhtp_request_s *request, struct evhtp_kv_s *header);
// _evhtp_headers_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 427
static inline unsigned short int _evhtp_headers_hook(struct evhtp_request_s *request, struct evhtp_kvs_s *headers);
// _evhtp_headers_start_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 487
static inline unsigned short int _evhtp_headers_start_hook(struct evhtp_request_s *request);
// _evhtp_hostname_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 543
static inline unsigned short int _evhtp_hostname_hook(struct evhtp_request_s *r, const char *hostname);
// _evhtp_path_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 979
static void _evhtp_path_free(struct evhtp_path_s *path);
// _evhtp_path_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 394
static inline unsigned short int _evhtp_path_hook(struct evhtp_request_s *request, struct evhtp_path_s *path);
// _evhtp_path_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 879
static struct evhtp_path_s * _evhtp_path_new(const char *data, unsigned long int len);
// _evhtp_protocol
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 373
static inline enum evhtp_proto _evhtp_protocol(const char major, const char minor);
// _evhtp_quick_hash
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 327
static inline unsigned int _evhtp_quick_hash(const char *str);
// _evhtp_request_find_vhost
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1151
static inline struct evhtp_s * _evhtp_request_find_vhost(struct evhtp_s *evhtp, const char *name);
// _evhtp_request_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 459
static inline unsigned short int _evhtp_request_fini_hook(struct evhtp_request_s *request);
// _evhtp_request_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 757
static void _evhtp_request_free(struct evhtp_request_s *request);
// _evhtp_request_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 706
static struct evhtp_request_s * _evhtp_request_new(struct evhtp_connection_s *c);
// _evhtp_request_parser_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1021
static signed int _evhtp_request_parser_args(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1451
static signed int _evhtp_request_parser_body(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_chunk_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1497
static signed int _evhtp_request_parser_chunk_fini(struct htparser *p);
// _evhtp_request_parser_chunk_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1485
static signed int _evhtp_request_parser_chunk_new(struct htparser *p);
// _evhtp_request_parser_chunks_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1508
static signed int _evhtp_request_parser_chunks_fini(struct htparser *p);
// _evhtp_request_parser_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1563
static signed int _evhtp_request_parser_fini(struct htparser *p);
// _evhtp_request_parser_header_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1100
static signed int _evhtp_request_parser_header_key(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_header_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1123
static signed int _evhtp_request_parser_header_val(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_headers
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1418
static signed int _evhtp_request_parser_headers(struct htparser *p);
// _evhtp_request_parser_headers_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1089
static signed int _evhtp_request_parser_headers_start(struct htparser *p);
// _evhtp_request_parser_host
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1337
static signed int _evhtp_request_parser_host(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_hostname
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1275
static signed int _evhtp_request_parser_hostname(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1386
static signed int _evhtp_request_parser_path(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_port
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1361
static signed int _evhtp_request_parser_port(struct htparser *p, const char *data, unsigned long int len);
// _evhtp_request_parser_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 994
static signed int _evhtp_request_parser_start(struct htparser *p);
// _evhtp_request_set_callbacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1179
static inline signed int _evhtp_request_set_callbacks(struct evhtp_request_s *request);

//

// _evhtp_require_uri
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1327
static signed int _evhtp_require_uri(struct evhtp_connection_s *c);
// _evhtp_run_in_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2145
static void _evhtp_run_in_thread(struct evthr *thr, void *arg, void *shared);
// _evhtp_run_post_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2125
static signed int _evhtp_run_post_accept(struct evhtp_s *htp, struct evhtp_connection_s *connection);
// _evhtp_run_pre_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1980
static signed int _evhtp_run_pre_accept(struct evhtp_s *htp, struct evhtp_connection_s *conn);
// _evhtp_should_parse_query_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1529
static signed int _evhtp_should_parse_query_body(struct evhtp_request_s *req);
// _evhtp_ssl_add_scache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2255
static signed int _evhtp_ssl_add_scache_ent(struct ssl_st *ssl, struct ssl_session_st *sess);
// _evhtp_ssl_delete_scache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2237
static void _evhtp_ssl_delete_scache_ent(struct ssl_ctx_st *ctx, struct ssl_session_st *sess);
// _evhtp_ssl_get_scache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2277
static struct ssl_session_st * _evhtp_ssl_get_scache_ent(struct ssl_st *ssl, unsigned char *sid, signed int sid_len, signed int *copy);
// _evhtp_ssl_get_thread_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2214
static unsigned long int _evhtp_ssl_get_thread_id(void);
// _evhtp_ssl_servername
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2296
static signed int _evhtp_ssl_servername(struct ssl_st *ssl, signed int *unused, void *arg);

//

// _evhtp_ssl_thread_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2225
static void _evhtp_ssl_thread_lock(signed int mode, signed int type, const char *file, signed int line);
// _evhtp_thread_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3598
static void _evhtp_thread_init(struct evthr *thr, void *arg);
// _evhtp_uri_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 848
static void _evhtp_uri_free(struct evhtp_uri_s *uri);
// _evhtp_uri_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 790
static struct evhtp_uri_s * _evhtp_uri_new(void);
// _evthr_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 95
static void * _evthr_loop(void *args);
// _evthr_read_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 68
static void _evthr_read_cmd(signed int sock, signed short int which, void *args);
// _owned_eventcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 120
static void _owned_eventcb(struct bufferevent *bev, signed short int events, void *arg);
// _owned_readcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 114
static void _owned_readcb(struct bufferevent *bev, void *arg);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atoll
// file /usr/include/stdlib.h line 157
extern signed long long int atoll(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bufferevent_disable
// file /usr/include/event2/bufferevent.h line 418
signed int bufferevent_disable(struct bufferevent *, signed short int);
// bufferevent_enable
// file /usr/include/event2/bufferevent.h line 408
signed int bufferevent_enable(struct bufferevent *, signed short int);
// bufferevent_flush
// file /usr/include/event2/bufferevent.h line 513
signed int bufferevent_flush(struct bufferevent *, signed short int, enum bufferevent_flush_mode);
// bufferevent_free
// file /usr/include/event2/bufferevent.h line 282
void bufferevent_free(struct bufferevent *);
// bufferevent_get_input
// file /usr/include/event2/bufferevent.h line 384
struct evbuffer * bufferevent_get_input(struct bufferevent *);
// bufferevent_get_output
// file /usr/include/event2/bufferevent.h line 398
struct evbuffer * bufferevent_get_output(struct bufferevent *);
// bufferevent_openssl_socket_new
// file /usr/include/event2/bufferevent_ssl.h line 85
struct bufferevent * bufferevent_openssl_socket_new(struct event_base *, signed int, struct ssl_st *, enum bufferevent_ssl_state, signed int);
// bufferevent_set_rate_limit
// file /usr/include/event2/bufferevent.h line 654
signed int bufferevent_set_rate_limit(struct bufferevent *, struct ev_token_bucket_cfg *);
// bufferevent_set_timeouts
// file /usr/include/event2/bufferevent.h line 454
signed int bufferevent_set_timeouts(struct bufferevent *, struct timeval *, struct timeval *);
// bufferevent_setcb
// file /usr/include/event2/bufferevent.h line 299
void bufferevent_setcb(struct bufferevent *, void (*)(struct bufferevent *, void *), void (*)(struct bufferevent *, void *), void (*)(struct bufferevent *, signed short int, void *), void *);
// bufferevent_socket_connect
// file /usr/include/event2/bufferevent.h line 205
signed int bufferevent_socket_connect(struct bufferevent *, struct sockaddr *, signed int);
// bufferevent_socket_connect_hostname
// file /usr/include/event2/bufferevent.h line 234
signed int bufferevent_socket_connect_hostname(struct bufferevent *, struct evdns_base *, signed int, const char *, signed int);
// bufferevent_socket_new
// file /usr/include/event2/bufferevent.h line 184
struct bufferevent * bufferevent_socket_new(struct event_base *, signed int, signed int);
// bufferevent_write_buffer
// file /usr/include/event2/bufferevent.h line 350
signed int bufferevent_write_buffer(struct bufferevent *, struct evbuffer *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// create_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 155
static void create_callback(struct evhtp_request_s *r, void *arg);
// dummy_check_issued_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 410
static signed int dummy_check_issued_cb(struct x509_store_ctx_st *ctx, struct x509_st *x, struct x509_st *issuer);
// dummy_ssl_verify_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 405
static signed int dummy_ssl_verify_callback(signed int ok, struct x509_store_ctx_st *x509_store);
// dynamic_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 147
static void dynamic_cb(struct evhtp_request_s *r, void *arg);
// ev_token_bucket_cfg_free
// file /usr/include/event2/bufferevent.h line 641
void ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *);
// ev_token_bucket_cfg_new
// file /usr/include/event2/bufferevent.h line 631
struct ev_token_bucket_cfg * ev_token_bucket_cfg_new(unsigned long int, unsigned long int, unsigned long int, unsigned long int, struct timeval *);
// evbuffer_add
// file /usr/include/event2/buffer.h line 315
signed int evbuffer_add(struct evbuffer *, const void *, unsigned long int);
// evbuffer_add_buffer
// file /usr/include/event2/buffer.h line 411
signed int evbuffer_add_buffer(struct evbuffer *, struct evbuffer *);
// evbuffer_add_printf
// file /usr/include/event2/buffer.h line 477
signed int evbuffer_add_printf(struct evbuffer *, const char *, ...);
// evbuffer_add_reference
// file /usr/include/event2/buffer.h line 437
signed int evbuffer_add_reference(struct evbuffer *, const void *, unsigned long int, void (*)(const void *, unsigned long int, void *), void *);
// evbuffer_drain
// file /usr/include/event2/buffer.h line 505
signed int evbuffer_drain(struct evbuffer *, unsigned long int);
// evbuffer_expand
// file /usr/include/event2/buffer.h line 244
signed int evbuffer_expand(struct evbuffer *, unsigned long int);
// evbuffer_free
// file /usr/include/event2/buffer.h line 149
void evbuffer_free(struct evbuffer *);
// evbuffer_get_length
// file /usr/include/event2/buffer.h line 218
unsigned long int evbuffer_get_length(struct evbuffer *);
// evbuffer_new
// file /usr/include/event2/buffer.h line 143
struct evbuffer * evbuffer_new(void);
// evbuffer_prepend
// file /usr/include/event2/buffer.h line 791
signed int evbuffer_prepend(struct evbuffer *, const void *, unsigned long int);
// evbuffer_pullup
// file /usr/include/event2/buffer.h line 780
unsigned char * evbuffer_pullup(struct evbuffer *, signed long int);
// evconnlistener_free
// file /usr/include/event2/listener.h line 114
void evconnlistener_free(struct evconnlistener *);
// evconnlistener_new
// file /usr/include/event2/listener.h line 90
struct evconnlistener * evconnlistener_new(struct event_base *, void (*)(struct evconnlistener *, signed int, struct sockaddr *, signed int, void *), void *, unsigned int, signed int, signed int);
// event_active
// file /usr/include/event2/event.h line 967
void event_active(struct event *, signed int, signed short int);
// event_add
// file /usr/include/event2/event.h line 937
signed int event_add(struct event *, struct timeval *);
// event_base_free
// file /usr/include/event2/event.h line 561
void event_base_free(struct event_base *);
// event_base_loop
// file /usr/include/event2/event.h line 660
signed int event_base_loop(struct event_base *, signed int);
// event_base_loopbreak
// file /usr/include/event2/event.h line 692
signed int event_base_loopbreak(struct event_base *);
// event_base_loopexit
// file /usr/include/event2/event.h line 677
signed int event_base_loopexit(struct event_base *, struct timeval *);
// event_base_new
// file /usr/include/event2/event.h line 337
struct event_base * event_base_new(void);
// event_del
// file /usr/include/event2/event.h line 950
signed int event_del(struct event *);
// event_free
// file /usr/include/event2/event.h line 889
void event_free(struct event *);
// event_new
// file /usr/include/event2/event.h line 840
struct event * event_new(struct event_base *, signed int, signed short int, void (*)(signed int, signed short int, void *), void *);
// event_pending
// file /usr/include/event2/event.h line 982
signed int event_pending(struct event *, signed short int, struct timeval *);
// evhtp_add_alias
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4082
signed int evhtp_add_alias(struct evhtp_s *evhtp, const char *name);
// evhtp_add_vhost
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4118
signed int evhtp_add_vhost(struct evhtp_s *evhtp, const char *name, struct evhtp_s *vhost);
// evhtp_bind_sockaddr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3182
signed int evhtp_bind_sockaddr(struct evhtp_s *htp, struct sockaddr *sa, unsigned long int sin_len, signed int backlog);
// evhtp_bind_socket
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 811
signed int evhtp_bind_socket(struct evhtp_s *htp, const char *baddr, unsigned short int port, signed int backlog);
// evhtp_callback_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3365
void evhtp_callback_free(struct evhtp_callback_s *callback);
// evhtp_callback_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3325
struct evhtp_callback_s * evhtp_callback_new(const char *path, enum evhtp_callback_type type, void (*cb)(struct evhtp_request_s *, void *), void *arg);

//

// evhtp_callbacks_add_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3395
signed int evhtp_callbacks_add_callback(struct evhtp_callbacks_s *cbs, struct evhtp_callback_s *cb);
// evhtp_callbacks_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3307
void evhtp_callbacks_free(struct evhtp_callbacks_s *callbacks);
// evhtp_connection_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4000
void evhtp_connection_free(struct evhtp_connection_s *connection);
// evhtp_connection_get_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3912
struct bufferevent * evhtp_connection_get_bev(struct evhtp_connection_s *connection);
// evhtp_connection_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4229
struct evhtp_connection_s * evhtp_connection_new(struct event_base *evbase, const char *addr, unsigned short int port);
// evhtp_connection_new_dns
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4234
struct evhtp_connection_s * evhtp_connection_new_dns(struct event_base *evbase, struct evdns_base *dns_base, const char *addr, unsigned short int port);
// evhtp_connection_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2354
void evhtp_connection_pause(struct evhtp_connection_s *c);
// evhtp_connection_resume
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2370
void evhtp_connection_resume(struct evhtp_connection_s *c);
// evhtp_connection_set_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3949
void evhtp_connection_set_bev(struct evhtp_connection_s *conn, struct bufferevent *bev);
// evhtp_connection_set_max_body_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3986
void evhtp_connection_set_max_body_size(struct evhtp_connection_s *c, unsigned long int len);
// evhtp_connection_set_timeouts
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3974
inline void evhtp_connection_set_timeouts(struct evhtp_connection_s *c, struct timeval *rtimeo, struct timeval *wtimeo);
// evhtp_connection_ssl_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4299
struct evhtp_connection_s * evhtp_connection_ssl_new(struct event_base *evbase, const char *addr, unsigned short int port, struct ssl_ctx_st *ctx);
// evhtp_connection_take_ownership
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1272
struct bufferevent * evhtp_connection_take_ownership(struct evhtp_connection_s *connection);
// evhtp_disable_100_continue
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4072
void evhtp_disable_100_continue(struct evhtp_s *htp);
// evhtp_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 564
void evhtp_free(struct evhtp_s *evhtp);
// evhtp_get_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3584
struct evhtp_callback_s * evhtp_get_cb(struct evhtp_s *htp, const char *path);
// evhtp_header_key_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2410
struct evhtp_kv_s * evhtp_header_key_add(struct evhtp_kvs_s *headers, const char *key, char kalloc);
// evhtp_header_val_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2423
struct evhtp_kv_s * evhtp_header_val_add(struct evhtp_kvs_s *headers, const char *val, char valloc);
// evhtp_is_hex_query_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2656
static inline signed int evhtp_is_hex_query_char(unsigned char ch);
// evhtp_kv_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2585
const char * evhtp_kv_find(struct evhtp_kvs_s *kvs, const char *key);
// evhtp_kv_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2518
void evhtp_kv_free(struct evhtp_kv_s *kv);
// evhtp_kv_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2466
struct evhtp_kv_s * evhtp_kv_new(const char *key, const char *val, char kalloc, char valloc);
// evhtp_kv_rm_and_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2535
void evhtp_kv_rm_and_free(struct evhtp_kvs_s *kvs, struct evhtp_kv_s *kv);
// evhtp_kvs_add_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2619
void evhtp_kvs_add_kv(struct evhtp_kvs_s *kvs, struct evhtp_kv_s *kv);
// evhtp_kvs_add_kvs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2628
void evhtp_kvs_add_kvs(struct evhtp_kvs_s *dst, struct evhtp_kvs_s *src);
// evhtp_kvs_find_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2602
struct evhtp_kv_s * evhtp_kvs_find_kv(struct evhtp_kvs_s *kvs, const char *key);
// evhtp_kvs_for_each
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1062
signed int evhtp_kvs_for_each(struct evhtp_kvs_s *kvs, signed int (*cb)(struct evhtp_kv_s *, void *), void *arg);

//

// evhtp_kvs_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2546
void evhtp_kvs_free(struct evhtp_kvs_s *kvs);
// evhtp_kvs_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2454
struct evhtp_kvs_s * evhtp_kvs_new(void);
// evhtp_make_request
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4347
signed int evhtp_make_request(struct evhtp_connection_s *c, struct evhtp_request_s *r, enum htp_method meth, const char *uri);
// evhtp_modp_sizetoa
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.h line 19
inline unsigned long int evhtp_modp_sizetoa(unsigned long int value, char *str);
// evhtp_modp_u32toa
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.h line 29
unsigned long int evhtp_modp_u32toa(unsigned int value, char *str);
// evhtp_modp_u64toa
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.c line 29
unsigned long int evhtp_modp_u64toa(unsigned long int value, char *str);
// evhtp_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 563
struct evhtp_s * evhtp_new(struct event_base *evbase, void *arg);
// evhtp_parse_query
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3007
struct evhtp_kvs_s * evhtp_parse_query(const char *query, unsigned long int len);
// evhtp_parse_query_wflags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2764
struct evhtp_kvs_s * evhtp_parse_query_wflags(const char *query, unsigned long int len, signed int flags);
// evhtp_request_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4035
void evhtp_request_free(struct evhtp_request_s *request);
// evhtp_request_get_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3939
struct bufferevent * evhtp_request_get_bev(struct evhtp_request_s *request);
// evhtp_request_get_connection
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1209
struct evhtp_connection_s * evhtp_request_get_connection(struct evhtp_request_s *request);
// evhtp_request_get_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1192
enum htp_method evhtp_request_get_method(struct evhtp_request_s *r);
// evhtp_request_get_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3969
enum evhtp_proto evhtp_request_get_proto(struct evhtp_request_s *request);
// evhtp_request_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4333
struct evhtp_request_s * evhtp_request_new(void (*cb)(struct evhtp_request_s *, void *), void *arg);

//

// evhtp_request_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2388
void evhtp_request_pause(struct evhtp_request_s *request);
// evhtp_request_resume
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1199
void evhtp_request_resume(struct evhtp_request_s *request);
// evhtp_request_set_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3954
void evhtp_request_set_bev(struct evhtp_request_s *request, struct bufferevent *bev);
// evhtp_request_set_keepalive
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3959
void evhtp_request_set_keepalive(struct evhtp_request_s *request, signed int val);
// evhtp_request_set_max_body_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1308
void evhtp_request_set_max_body_size(struct evhtp_request_s *req, unsigned long int len);
// evhtp_request_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4379
unsigned int evhtp_request_status(struct evhtp_request_s *r);
// evhtp_request_take_ownership
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3944
struct bufferevent * evhtp_request_take_ownership(struct evhtp_request_s *request);
// evhtp_response_needs_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3064
signed int evhtp_response_needs_body(const unsigned short int code, const enum htp_method method);
// evhtp_send_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 857
void evhtp_send_reply(struct evhtp_request_s *request, unsigned short int code);
// evhtp_send_reply_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3031
void evhtp_send_reply_body(struct evhtp_request_s *request, struct evbuffer *buf);
// evhtp_send_reply_chunk
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 891
void evhtp_send_reply_chunk(struct evhtp_request_s *request, struct evbuffer *buf);
// evhtp_send_reply_chunk_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 899
void evhtp_send_reply_chunk_end(struct evhtp_request_s *request);
// evhtp_send_reply_chunk_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 882
void evhtp_send_reply_chunk_start(struct evhtp_request_s *request, unsigned short int code);
// evhtp_send_reply_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3040
void evhtp_send_reply_end(struct evhtp_request_s *request);
// evhtp_send_reply_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3013
void evhtp_send_reply_start(struct evhtp_request_s *request, unsigned short int code);
// evhtp_set_bev_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4062
void evhtp_set_bev_flags(struct evhtp_s *htp, signed int flags);
// evhtp_set_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 669
struct evhtp_callback_s * evhtp_set_cb(struct evhtp_s *htp, const char *path, void (*cb)(struct evhtp_request_s *, void *), void *arg);

//

// evhtp_set_gencb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 633
void evhtp_set_gencb(struct evhtp_s *htp, void (*cb)(struct evhtp_request_s *, void *), void *arg);

//

// evhtp_set_glob_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 702
struct evhtp_callback_s * evhtp_set_glob_cb(struct evhtp_s *htp, const char *pattern, void (*cb)(struct evhtp_request_s *, void *), void *arg);

//

// evhtp_set_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 772
signed int evhtp_set_hook(struct evhtp_hooks_s **hooks, enum evhtp_hook_type type, unsigned short int (*cb)(), void *arg);

//

// evhtp_set_max_body_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4067
void evhtp_set_max_body_size(struct evhtp_s *htp, unsigned long int len);
// evhtp_set_max_keepalive_requests
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1317
void evhtp_set_max_keepalive_requests(struct evhtp_s *htp, unsigned long int num);
// evhtp_set_parser_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 592
void evhtp_set_parser_flags(struct evhtp_s *htp, signed int flags);
// evhtp_set_post_accept_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 657
void evhtp_set_post_accept_cb(struct evhtp_s *htp, unsigned short int (*cb)(struct evhtp_connection_s *, void *), void *arg);

//

// evhtp_set_pre_accept_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 645
void evhtp_set_pre_accept_cb(struct evhtp_s *htp, unsigned short int (*cb)(struct evhtp_connection_s *, void *), void *arg);

//

// evhtp_set_regex_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 684
struct evhtp_callback_s * evhtp_set_regex_cb(struct evhtp_s *htp, const char *pattern, void (*cb)(struct evhtp_request_s *, void *), void *arg);

//

// evhtp_set_timeouts
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4040
void evhtp_set_timeouts(struct evhtp_s *htp, struct timeval *r_timeo, struct timeval *w_timeo);
// evhtp_ssl_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 604
signed int evhtp_ssl_init(struct evhtp_s *htp, struct evhtp_ssl_cfg_s *cfg);
// evhtp_ssl_use_threads
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3734
signed int evhtp_ssl_use_threads(void);
// evhtp_unbind_socket
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 819
void evhtp_unbind_socket(struct evhtp_s *htp);
// evhtp_unescape_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2689
signed int evhtp_unescape_string(unsigned char **out, unsigned char *str, unsigned long int str_len);
// evhtp_unset_all_hooks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3483
signed int evhtp_unset_all_hooks(struct evhtp_hooks_s **hooks);
// evhtp_unset_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3478
signed int evhtp_unset_hook(struct evhtp_hooks_s **hooks, enum evhtp_hook_type type);
// evhtp_use_callback_locks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3628
signed int evhtp_use_callback_locks(struct evhtp_s *htp);
// evhtp_use_threads
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 848
signed int evhtp_use_threads(struct evhtp_s *htp, void (*init_cb)(struct evhtp_s *, struct evthr *, void *), signed int nthreads, void *arg);

//

// evthr_defer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 138
enum evthr_res evthr_defer(struct evthr *thread, void (*cb)(struct evthr *, void *, void *), void *arg);

//

// evthr_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 227
void evthr_free(struct evthr *thread);
// evthr_get_aux
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 179
void * evthr_get_aux(struct evthr *thr);
// evthr_get_base
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 37
struct event_base * evthr_get_base(struct evthr *thr);
// evthr_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 184
struct evthr * evthr_new(void (*init_cb)(struct evthr *, void *), void *args);

//

// evthr_pool_defer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 48
enum evthr_res evthr_pool_defer(struct evthr_pool *pool, void (*cb)(struct evthr *, void *, void *), void *arg);

//

// evthr_pool_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 49
void evthr_pool_free(struct evthr_pool *pool);
// evthr_pool_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 45
struct evthr_pool * evthr_pool_new(signed int nthreads, void (*init_cb)(struct evthr *, void *), void *shared);

//

// evthr_pool_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 46
signed int evthr_pool_start(struct evthr_pool *pool);
// evthr_pool_stop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 47
enum evthr_res evthr_pool_stop(struct evthr_pool *pool);
// evthr_set_aux
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 174
void evthr_set_aux(struct evthr *thr, void *aux);
// evthr_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 214
signed int evthr_start(struct evthr *thread);
// evthr_stop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 153
enum evthr_res evthr_stop(struct evthr *thread);
// evutil_closesocket
// file /usr/include/event2/util.h line 323
signed int evutil_closesocket(signed int);
// evutil_inet_pton
// file /usr/include/event2/util.h line 461
signed int evutil_inet_pton(signed int, const char *, void *);
// evutil_make_socket_closeonexec
// file /usr/include/event2/util.h line 315
signed int evutil_make_socket_closeonexec(signed int);
// evutil_make_socket_nonblocking
// file /usr/include/event2/util.h line 294
signed int evutil_make_socket_nonblocking(signed int);
// evutil_socketpair
// file /usr/include/event2/util.h line 288
signed int evutil_socketpair(signed int, signed int, signed int, signed int *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 518
static enum htp_method get_method(const char *m, const unsigned long int sz);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// hook_args_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 298
static inline signed int hook_args_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_body_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 302
static inline signed int hook_body_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_hdr_key_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 300
static inline signed int hook_hdr_key_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_hdr_val_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 301
static inline signed int hook_hdr_val_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_host_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 295
static inline signed int hook_host_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_hostname_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 303
static inline signed int hook_hostname_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_method_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 293
static inline signed int hook_method_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_on_chunk_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 289
static inline signed int hook_on_chunk_complete_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_on_chunks_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 290
static inline signed int hook_on_chunks_complete_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_on_hdrs_begin_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 286
static inline signed int hook_on_hdrs_begin_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_on_hdrs_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 287
static inline signed int hook_on_hdrs_complete_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_on_msg_begin_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 285
static inline signed int hook_on_msg_begin_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_on_msg_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 291
static inline signed int hook_on_msg_complete_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_on_new_chunk_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 288
static inline signed int hook_on_new_chunk_run(struct htparser *p, struct htparse_hooks *hooks);
// hook_path_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 297
static inline signed int hook_path_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_port_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 296
static inline signed int hook_port_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_scheme_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 294
static inline signed int hook_scheme_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// hook_uri_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 299
static inline signed int hook_uri_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// htparser_get_bytes_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 477
unsigned long int htparser_get_bytes_read(struct htparser *p);
// htparser_get_content_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 109
unsigned long int htparser_get_content_length(struct htparser *p);
// htparser_get_content_pending
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 467
unsigned long int htparser_get_content_pending(struct htparser *p);
// htparser_get_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 112
enum htpparse_error htparser_get_error(struct htparser *p);
// htparser_get_major
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 105
unsigned char htparser_get_major(struct htparser *p);
// htparser_get_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 100
enum htp_method htparser_get_method(struct htparser *p);
// htparser_get_methodstr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 427
const char * htparser_get_methodstr(struct htparser *p);
// htparser_get_methodstr_m
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 102
const char * htparser_get_methodstr_m(enum htp_method meth);
// htparser_get_minor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 106
unsigned char htparser_get_minor(struct htparser *p);
// htparser_get_multipart
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 107
unsigned char htparser_get_multipart(struct htparser *p);
// htparser_get_scheme
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 99
enum htp_scheme htparser_get_scheme(struct htparser *p);
// htparser_get_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 108
unsigned int htparser_get_status(struct htparser *p);
// htparser_get_strerror
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 373
const char * htparser_get_strerror(struct htparser *p);
// htparser_get_total_bytes_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 482
unsigned long int htparser_get_total_bytes_read(struct htparser *p);
// htparser_get_userdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 114
void * htparser_get_userdata(struct htparser *p);
// htparser_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 116
void htparser_init(struct htparser *p, enum htp_type type);
// htparser_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 117
struct htparser * htparser_new(void);
// htparser_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 97
unsigned long int htparser_run(struct htparser *p, struct htparse_hooks *hooks, const char *data, unsigned long int len);
// htparser_set_major
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 103
void htparser_set_major(struct htparser *p, unsigned char major);
// htparser_set_minor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 104
void htparser_set_minor(struct htparser *p, unsigned char minor);
// htparser_set_userdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 115
void htparser_set_userdata(struct htparser *p, void *ud);
// htparser_should_keep_alive
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 98
signed int htparser_should_keep_alive(struct htparser *p);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// is_host_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 503
static signed int is_host_char(unsigned char ch);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// output_header
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 261
static signed int output_header(struct evhtp_kv_s *header, void *arg);
// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 439
signed int parse_args(signed int argc, char **argv);
// pause_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 47
static unsigned short int pause_cb(struct evhtp_request_s *request, struct evhtp_kv_s *header, void *arg);
// pause_connection_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 71
static unsigned short int pause_connection_fini(struct evhtp_connection_s *connection, void *arg);
// pause_init_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 91
static unsigned short int pause_init_cb(struct evhtp_request_s *req, struct evhtp_path_s *path, void *arg);
// pause_request_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 78
static unsigned short int pause_request_fini(struct evhtp_request_s *request, void *arg);
// print_chunk_complete
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 315
static unsigned short int print_chunk_complete(struct evhtp_request_s *req, void *arg);
// print_chunks_complete
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 322
static unsigned short int print_chunks_complete(struct evhtp_request_s *req, void *arg);
// print_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 296
static unsigned short int print_data(struct evhtp_request_s *req, struct evbuffer *buf, void *arg);
// print_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 252
static unsigned short int print_kv(struct evhtp_request_s *req, struct evhtp_kv_s *hdr, void *arg);
// print_kvs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 270
static unsigned short int print_kvs(struct evhtp_request_s *req, struct evhtp_kvs_s *hdrs, void *arg);
// print_new_chunk_len
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 308
static unsigned short int print_new_chunk_len(struct evhtp_request_s *req, unsigned long int len, void *arg);
// print_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 276
static unsigned short int print_path(struct evhtp_request_s *req, struct evhtp_path_s *path, void *arg);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_8 *, const union anonymous_9 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_8 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/onigposix.h line 154
extern signed int regcomp(struct anonymous_5 *, const char *, signed int);
// regexec
// file /usr/include/onigposix.h line 155
extern signed int regexec(struct anonymous_5 *, const char *, unsigned long int, struct anonymous_6 *, signed int);
// regfree
// file /usr/include/onigposix.h line 156
extern void regfree(struct anonymous_5 *);
// resume_request_timer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 37
static void resume_request_timer(signed int sock, signed short int which, void *arg);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// set_max_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 337
static unsigned short int set_max_body(struct evhtp_request_s *req, struct evhtp_kvs_s *hdrs, void *arg);
// set_my_connection_handlers
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 376
static unsigned short int set_my_connection_handlers(struct evhtp_connection_s *conn, void *arg);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigint
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 504
static void sigint(signed int sig, signed short int why, void *data);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// status_code_to_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 142
static const char * status_code_to_str(unsigned short int code);
// str_to_uint64
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 307
static inline unsigned long int str_to_uint64(char *str, unsigned long int n, signed int *err);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strndup
// file /usr/include/string.h line 183
extern char * strndup(const char *, unsigned long int);
// strreverse
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.c line 20
static inline void strreverse(char *begin, char *end);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// test_500_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 186
static void test_500_cb(struct evhtp_request_s *req, void *arg);
// test_bar_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 232
static void test_bar_cb(struct evhtp_request_s *req, void *arg);
// test_chunking
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 210
static void test_chunking(struct evhtp_request_s *req, void *arg);
// test_default_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 243
static void test_default_cb(struct evhtp_request_s *req, void *arg);
// test_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 355
static unsigned short int test_fini(struct evhtp_request_s *r, void *arg);
// test_foo_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 178
static void test_foo_cb(struct evhtp_request_s *req, void *arg);
// test_glob_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 237
static void test_glob_cb(struct evhtp_request_s *req, void *arg);
// test_max_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 194
static void test_max_body(struct evhtp_request_s *req, void *arg);
// test_ownership
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 125
static void test_ownership(struct evhtp_request_s *request, void *arg);
// test_pause_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 108
static void test_pause_cb(struct evhtp_request_s *request, void *arg);
// test_pre_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 344
static unsigned short int test_pre_accept(struct evhtp_connection_s *c, void *arg);
// test_regex
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 137
static void test_regex(struct evhtp_request_s *req, void *arg);
// test_regex_hdrs_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 330
static unsigned short int test_regex_hdrs_cb(struct evhtp_request_s *req, struct evhtp_kvs_s *hdrs, void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);

struct anonymous_7
{
  // tqe_next
  struct evhtp_alias_s *tqe_next;
  // tqe_prev
  struct evhtp_alias_s **tqe_prev;
};

struct anonymous_18
{
  // tqh_first
  struct evhtp_alias_s *tqh_first;
  // tqh_last
  struct evhtp_alias_s **tqh_last;
};

struct anonymous_4
{
  // tqe_next
  struct evhtp_callback_s *tqe_next;
  // tqe_prev
  struct evhtp_callback_s **tqe_prev;
};

struct anonymous_21
{
  // tqe_next
  struct evhtp_kv_s *tqe_next;
  // tqe_prev
  struct evhtp_kv_s **tqe_prev;
};

struct anonymous_17
{
  // tqe_next
  struct evhtp_request_s *tqe_next;
  // tqe_prev
  struct evhtp_request_s **tqe_prev;
};

struct anonymous_20
{
  // tqe_next
  struct evhtp_s *tqe_next;
  // tqe_prev
  struct evhtp_s **tqe_prev;
};

struct anonymous_19
{
  // tqh_first
  struct evhtp_s *tqh_first;
  // tqh_last
  struct evhtp_s **tqh_last;
};

struct anonymous_16
{
  // tqe_next
  struct evthr *tqe_next;
  // tqe_prev
  struct evthr **tqe_prev;
};

struct anonymous_5
{
  // onig
  void *onig;
  // re_nsub
  unsigned long int re_nsub;
  // comp_options
  signed int comp_options;
};

struct anonymous_13
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous_6
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous_15
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous_12
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous_11
{
  // path
  char *path;
  // glob
  char *glob;
  // regex
  struct anonymous_5 *regex;
};

union anonymous_1
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous_0
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous_2
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_9
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_3
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_10
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous_0 value;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evhtp_alias_s
{
  // alias
  char *alias;
  // next
  struct anonymous_7 next;
};

struct evhtp_authority_s
{
  // username
  char *username;
  // password
  char *password;
  // hostname
  char *hostname;
  // port
  unsigned short int port;
};

struct evhtp_callback_s
{
  // type
  enum evhtp_callback_type type;
  // cb
  void (*cb)(struct evhtp_request_s *, void *);
  // hash
  unsigned int hash;
  // cbarg
  void *cbarg;
  // hooks
  struct evhtp_hooks_s *hooks;
  // val
  union anonymous_11 val;
  // next
  struct anonymous_4 next;
};

struct evhtp_callbacks_s
{
  // tqh_first
  struct evhtp_callback_s *tqh_first;
  // tqh_last
  struct evhtp_callback_s **tqh_last;
};

struct evhtp_connection_s
{
  // htp
  struct evhtp_s *htp;
  // evbase
  struct event_base *evbase;
  // bev
  struct bufferevent *bev;
  // thread
  struct evthr *thread;
  // ssl
  struct ssl_st *ssl;
  // hooks
  struct evhtp_hooks_s *hooks;
  // parser
  struct htparser *parser;
  // resume_ev
  struct event *resume_ev;
  // saddr
  struct sockaddr *saddr;
  // recv_timeo
  struct timeval recv_timeo;
  // send_timeo
  struct timeval send_timeo;
  // sock
  signed int sock;
  // request
  struct evhtp_request_s *request;
  // max_body_size
  unsigned long int max_body_size;
  // body_bytes_read
  unsigned long int body_bytes_read;
  // num_requests
  unsigned long int num_requests;
  // type
  enum evhtp_type type;
  // error
  unsigned char error : 1;
  // owner
  unsigned char owner : 1;
  // vhost_via_sni
  unsigned char vhost_via_sni : 1;
  // paused
  unsigned char paused : 1;
  // connected
  unsigned char connected : 1;
  // waiting
  unsigned char waiting : 1;
  // free_connection
  unsigned char free_connection : 1;
  // keepalive
  unsigned char keepalive : 1;
  // scratch_buf
  struct evbuffer *scratch_buf;
};

struct evhtp_defaults_s
{
  // cb
  void (*cb)(struct evhtp_request_s *, void *);
  // pre_accept
  unsigned short int (*pre_accept)(struct evhtp_connection_s *, void *);
  // post_accept
  unsigned short int (*post_accept)(struct evhtp_connection_s *, void *);
  // cbarg
  void *cbarg;
  // pre_accept_cbarg
  void *pre_accept_cbarg;
  // post_accept_cbarg
  void *post_accept_cbarg;
};

struct evhtp_hooks_s
{
  // on_headers_start
  unsigned short int (*on_headers_start)(struct evhtp_request_s *, void *);
  // on_header
  unsigned short int (*on_header)(struct evhtp_request_s *, struct evhtp_kv_s *, void *);
  // on_headers
  unsigned short int (*on_headers)(struct evhtp_request_s *, struct evhtp_kvs_s *, void *);
  // on_path
  unsigned short int (*on_path)(struct evhtp_request_s *, struct evhtp_path_s *, void *);
  // on_read
  unsigned short int (*on_read)(struct evhtp_request_s *, struct evbuffer *, void *);
  // on_request_fini
  unsigned short int (*on_request_fini)(struct evhtp_request_s *, void *);
  // on_connection_fini
  unsigned short int (*on_connection_fini)(struct evhtp_connection_s *, void *);
  // on_connection_error
  unsigned short int (*on_connection_error)(struct evhtp_connection_s *, unsigned char, void *);
  // on_error
  void (*on_error)(struct evhtp_request_s *, unsigned char, void *);
  // on_new_chunk
  unsigned short int (*on_new_chunk)(struct evhtp_request_s *, unsigned long int, void *);
  // on_chunk_fini
  unsigned short int (*on_chunk_fini)(struct evhtp_request_s *, void *);
  // on_chunks_fini
  unsigned short int (*on_chunks_fini)(struct evhtp_request_s *, void *);
  // on_hostname
  unsigned short int (*on_hostname)(struct evhtp_request_s *, const char *, void *);
  // on_write
  unsigned short int (*on_write)(struct evhtp_connection_s *, void *);
  // on_event
  void (*on_event)(struct evhtp_connection_s *, signed short int, void *);
  // on_headers_start_arg
  void *on_headers_start_arg;
  // on_header_arg
  void *on_header_arg;
  // on_headers_arg
  void *on_headers_arg;
  // on_path_arg
  void *on_path_arg;
  // on_read_arg
  void *on_read_arg;
  // on_request_fini_arg
  void *on_request_fini_arg;
  // on_connection_fini_arg
  void *on_connection_fini_arg;
  // on_connection_error_arg
  void *on_connection_error_arg;
  // on_error_arg
  void *on_error_arg;
  // on_new_chunk_arg
  void *on_new_chunk_arg;
  // on_chunk_fini_arg
  void *on_chunk_fini_arg;
  // on_chunks_fini_arg
  void *on_chunks_fini_arg;
  // on_hostname_arg
  void *on_hostname_arg;
  // on_write_arg
  void *on_write_arg;
  // on_event_arg
  void *on_event_arg;
};

struct evhtp_kv_s
{
  // key
  char *key;
  // val
  char *val;
  // klen
  unsigned long int klen;
  // vlen
  unsigned long int vlen;
  // k_heaped
  char k_heaped;
  // v_heaped
  char v_heaped;
  // next
  struct anonymous_21 next;
};

struct evhtp_kvs_s
{
  // tqh_first
  struct evhtp_kv_s *tqh_first;
  // tqh_last
  struct evhtp_kv_s **tqh_last;
};

struct evhtp_path_s
{
  // full
  char *full;
  // path
  char *path;
  // file
  char *file;
  // match_start
  char *match_start;
  // match_end
  char *match_end;
  // matched_soff
  unsigned int matched_soff;
  // matched_eoff
  unsigned int matched_eoff;
};

struct evhtp_request_s
{
  // htp
  struct evhtp_s *htp;
  // conn
  struct evhtp_connection_s *conn;
  // hooks
  struct evhtp_hooks_s *hooks;
  // uri
  struct evhtp_uri_s *uri;
  // buffer_in
  struct evbuffer *buffer_in;
  // buffer_out
  struct evbuffer *buffer_out;
  // headers_in
  struct evhtp_kvs_s *headers_in;
  // headers_out
  struct evhtp_kvs_s *headers_out;
  // proto
  enum evhtp_proto proto;
  // method
  enum htp_method method;
  // status
  unsigned short int status;
  // keepalive
  unsigned char keepalive : 1;
  // finished
  unsigned char finished : 1;
  // chunked
  unsigned char chunked : 1;
  // error
  unsigned char error : 1;
  // pad
  unsigned char pad : 4;
  // cb
  void (*cb)(struct evhtp_request_s *, void *);
  // cbarg
  void *cbarg;
  // next
  struct anonymous_17 next;
};

struct evhtp_s
{
  // parent
  struct evhtp_s *parent;
  // evbase
  struct event_base *evbase;
  // server
  struct evconnlistener *server;
  // server_name
  char *server_name;
  // arg
  void *arg;
  // bev_flags
  signed int bev_flags;
  // max_body_size
  unsigned long int max_body_size;
  // max_keepalive_requests
  unsigned long int max_keepalive_requests;
  // disable_100_cont
  unsigned char disable_100_cont : 1;
  // enable_reuseport
  unsigned char enable_reuseport : 1;
  // enable_nodelay
  unsigned char enable_nodelay : 1;
  // enable_defer_accept
  unsigned char enable_defer_accept : 1;
  // pad
  unsigned char pad : 4;
  // parser_flags
  signed int parser_flags;
  // ssl_ctx
  struct ssl_ctx_st *ssl_ctx;
  // ssl_cfg
  struct evhtp_ssl_cfg_s *ssl_cfg;
  // thr_pool
  struct evthr_pool *thr_pool;
  // lock
  union anonymous_8 *lock;
  // thread_init_cb
  void (*thread_init_cb)(struct evhtp_s *, struct evthr *, void *);
  // thread_init_cbarg
  void *thread_init_cbarg;
  // callbacks
  struct evhtp_callbacks_s *callbacks;
  // defaults
  struct evhtp_defaults_s defaults;
  // recv_timeo
  struct timeval recv_timeo;
  // send_timeo
  struct timeval send_timeo;
  // aliases
  struct anonymous_18 aliases;
  // vhosts
  struct anonymous_19 vhosts;
  // next_vhost
  struct anonymous_20 next_vhost;
};

struct evhtp_ssl_cfg_s
{
  // pemfile
  char *pemfile;
  // privfile
  char *privfile;
  // cafile
  char *cafile;
  // capath
  char *capath;
  // ciphers
  char *ciphers;
  // named_curve
  char *named_curve;
  // dhparams
  char *dhparams;
  // ssl_opts
  signed long int ssl_opts;
  // ssl_ctx_timeout
  signed long int ssl_ctx_timeout;
  // verify_peer
  signed int verify_peer;
  // verify_depth
  signed int verify_depth;
  // x509_verify_cb
  signed int (*x509_verify_cb)(signed int, struct x509_store_ctx_st *);
  // x509_chk_issued_cb
  signed int (*x509_chk_issued_cb)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // store_flags
  signed long int store_flags;
  // scache_type
  enum evhtp_ssl_scache_type scache_type;
  // scache_timeout
  signed long int scache_timeout;
  // scache_size
  signed long int scache_size;
  // scache_init
  void * (*scache_init)(struct evhtp_s *);
  // scache_add
  signed int (*scache_add)(struct evhtp_connection_s *, unsigned char *, signed int, struct ssl_session_st *);
  // scache_get
  struct ssl_session_st * (*scache_get)(struct evhtp_connection_s *, unsigned char *, signed int);
  // scache_del
  void (*scache_del)(struct evhtp_s *, unsigned char *, signed int);
  // args
  void *args;
};

struct evhtp_uri_s
{
  // authority
  struct evhtp_authority_s *authority;
  // path
  struct evhtp_path_s *path;
  // fragment
  unsigned char *fragment;
  // query_raw
  unsigned char *query_raw;
  // query
  struct evhtp_kvs_s *query;
  // scheme
  enum htp_scheme scheme;
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous_1 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct evthr
{
  // rdr
  signed int rdr;
  // wdr
  signed int wdr;
  // err
  char err;
  // event
  struct event *event;
  // evbase
  struct event_base *evbase;
  // lock
  union anonymous_8 lock;
  // thr
  unsigned long int *thr;
  // init_cb
  void (*init_cb)(struct evthr *, void *);
  // arg
  void *arg;
  // aux
  void *aux;
  // next
  struct anonymous_16 next;
};

struct evthr_cmd
{
  // stop
  unsigned char stop;
  // args
  void *args;
  // cb
  void (*cb)(struct evthr *, void *, void *);
} __attribute__ ((__packed__));

struct evthr_pool_slist
{
  // tqh_first
  struct evthr *tqh_first;
  // tqh_last
  struct evthr **tqh_last;
};

struct evthr_pool
{
  // nthreads
  signed int nthreads;
  // threads
  struct evthr_pool_slist threads;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct htparse_hooks
{
  // on_msg_begin
  signed int (*on_msg_begin)(struct htparser *);
  // method
  signed int (*method)(struct htparser *, const char *, unsigned long int);
  // scheme
  signed int (*scheme)(struct htparser *, const char *, unsigned long int);
  // host
  signed int (*host)(struct htparser *, const char *, unsigned long int);
  // port
  signed int (*port)(struct htparser *, const char *, unsigned long int);
  // path
  signed int (*path)(struct htparser *, const char *, unsigned long int);
  // args
  signed int (*args)(struct htparser *, const char *, unsigned long int);
  // uri
  signed int (*uri)(struct htparser *, const char *, unsigned long int);
  // on_hdrs_begin
  signed int (*on_hdrs_begin)(struct htparser *);
  // hdr_key
  signed int (*hdr_key)(struct htparser *, const char *, unsigned long int);
  // hdr_val
  signed int (*hdr_val)(struct htparser *, const char *, unsigned long int);
  // hostname
  signed int (*hostname)(struct htparser *, const char *, unsigned long int);
  // on_hdrs_complete
  signed int (*on_hdrs_complete)(struct htparser *);
  // on_new_chunk
  signed int (*on_new_chunk)(struct htparser *);
  // on_chunk_complete
  signed int (*on_chunk_complete)(struct htparser *);
  // on_chunks_complete
  signed int (*on_chunks_complete)(struct htparser *);
  // body
  signed int (*body)(struct htparser *, const char *, unsigned long int);
  // on_msg_complete
  signed int (*on_msg_complete)(struct htparser *);
};

struct htparser
{
  // error
  enum htpparse_error error;
  // state
  enum parser_state state;
  // flags
  enum parser_flags flags;
  // heval
  enum eval_hdr_val heval;
  // type
  enum htp_type type;
  // scheme
  enum htp_scheme scheme;
  // method
  enum htp_method method;
  // multipart
  unsigned char multipart;
  // major
  unsigned char major;
  // minor
  unsigned char minor;
  // content_len
  unsigned long int content_len;
  // orig_content_len
  unsigned long int orig_content_len;
  // bytes_read
  unsigned long int bytes_read;
  // total_bytes_read
  unsigned long int total_bytes_read;
  // status
  unsigned int status;
  // status_count
  unsigned int status_count;
  // scheme_offset
  char *scheme_offset;
  // host_offset
  char *host_offset;
  // port_offset
  char *port_offset;
  // path_offset
  char *path_offset;
  // args_offset
  char *args_offset;
  // userdata
  void *userdata;
  // buf_idx
  unsigned int buf_idx;
  // buf
  char buf[8192l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_2 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct pauser
{
  // timer_ev
  struct event *timer_ev;
  // request
  struct evhtp_request_s *request;
  // tv
  struct timeval *tv;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous_12 tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous_13 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous_15 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // rfc3779_addr
  struct stack_st_IPAddressFamily *rfc3779_addr;
  // rfc3779_asid
  struct ASIdentifiers_st *rfc3779_asid;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// backlog
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 27
signed int backlog = 1024;
// bind_addr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 19
char *bind_addr = "0.0.0.0";
// bind_port
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 20
unsigned short int bind_port = (unsigned short int)8081;
// bw_limit
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 25
unsigned long int bw_limit = (unsigned long int)0;
// chunk_strings
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 201
const char *chunk_strings[5l] = { "I give you the light of Erendil,\n", "our most beloved star.\n", "May it be a light for you in dark places,\n",
    "when all other lights go out.\n", (const char *)(void *)0 };
// errstr_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 165
static const char *errstr_map[13l] = { "htparse_error_none", "htparse_error_too_big", "htparse_error_invalid_method", "htparse_error_invalid_requestline", "htparse_error_invalid_schema", "htparse_error_invalid_protocol", "htparse_error_invalid_version", "htparse_error_invalid_header", "htparse_error_invalid_chunk_size", "htparse_error_invalid_chunk", "htparse_error_invalid_state", "htparse_error_user", "htparse_error_unknown" };
// ext_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 21
char *ext_body = (char *)(void *)0;
// help
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 418
const char *help = "Options: \n  -h       : This help text\n  -t       : Run requests in a thread (default: off)\n  -n <int> : Number of threads        (default: 0 if -t is off, 4 if -t is on)\n  -s <pem> : Enable SSL and PEM       (default: NULL)\n  -c <ca>  : CA cert file             (default: NULL)\n  -C <path>: CA Path                  (default: NULL)\n  -l <int> : Max bandwidth (in bytes) (default: NULL)\n  -r <str> : Document root            (default: .)\n  -N <str> : Add this string to body. (default: NULL)\n  -a <str> : Bind Address             (default: 0.0.0.0)\n  -p <int> : Bind Port                (default: 8081)\n  -m <int> : Max keepalive requests   (default: 0)\n";
// max_keepalives
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 26
unsigned long int max_keepalives = (unsigned long int)0;
// method_strmap
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 181
static const char *method_strmap[16l] = { "GET", "HEAD", "POST", "PUT", "DELETE", "MKCOL", "COPY", "MOVE", "OPTIONS", "PROPFIND", "PROPATCH", "LOCK", "UNLOCK", "TRACE", "CONNECT", "PATCH" };
// num_threads
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 17
signed int num_threads = 0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optstr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 416
const char *optstr = "htn:a:p:r:s:c:C:l:N:m:b:";
// request_psets
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 246
static struct htparse_hooks request_psets;
// request_psets
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 246
static struct htparse_hooks request_psets = { .on_msg_begin=_evhtp_request_parser_start, .method=(signed int (*)(struct htparser *, const char *, unsigned long int))(void *)0,
    .scheme=(signed int (*)(struct htparser *, const char *, unsigned long int))(void *)0,
    .host=_evhtp_request_parser_host,
    .port=_evhtp_request_parser_port, .path=_evhtp_request_parser_path,
    .args=_evhtp_request_parser_args, .uri=(signed int (*)(struct htparser *, const char *, unsigned long int))(void *)0,
    .on_hdrs_begin=_evhtp_request_parser_headers_start,
    .hdr_key=_evhtp_request_parser_header_key,
    .hdr_val=_evhtp_request_parser_header_val,
    .hostname=_evhtp_request_parser_hostname,
    .on_hdrs_complete=_evhtp_request_parser_headers,
    .on_new_chunk=_evhtp_request_parser_chunk_new,
    .on_chunk_complete=_evhtp_request_parser_chunk_fini,
    .on_chunks_complete=_evhtp_request_parser_chunks_fini,
    .body=_evhtp_request_parser_body,
    .on_msg_complete=_evhtp_request_parser_fini };
// session_id_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 268
static signed int session_id_context = 1;
// ssl_ca
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 23
char *ssl_ca = (char *)(void *)0;
// ssl_capath
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 24
char *ssl_capath = (char *)(void *)0;
// ssl_locks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 271
static union anonymous_8 *ssl_locks;
// ssl_locks_initialized
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 272
static signed int ssl_locks_initialized = 0;
// ssl_num_locks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 270
static signed int ssl_num_locks;
// ssl_pem
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 22
char *ssl_pem = (char *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// unhex
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 154
static signed char unhex[256l] = { (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)0, (signed char)1, (signed char)2, (signed char)3, (signed char)4, (signed char)5, (signed char)6, (signed char)7, (signed char)8, (signed char)9, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)10, (signed char)11, (signed char)12, (signed char)13, (signed char)14, (signed char)15, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)10, (signed char)11, (signed char)12, (signed char)13, (signed char)14, (signed char)15, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, (signed char)-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// use_threads
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 16
signed int use_threads = 0;
// usual
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 143
static unsigned int usual[8l] = { 0xffffdbfe, (unsigned int)0x7fff37d6, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };

// _evhtp_accept_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2168
static void _evhtp_accept_cb(struct evconnlistener *serv, signed int fd, struct sockaddr *s, signed int sl, void *arg)
{
  struct evhtp_s *htp = (struct evhtp_s *)arg;
  struct evhtp_connection_s *connection;
  connection=_evhtp_connection_new(htp, fd, (enum evhtp_type)evhtp_type_server);
  if(!(connection == ((struct evhtp_connection_s *)NULL)))
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)sl);
    connection->saddr = (struct sockaddr *)return_value_malloc_1;
    do
      if(connection->saddr == ((struct sockaddr *)NULL))
      {
        fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_accept_cb", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2179);
        fflush(stderr);
        abort();
      }

    while((_Bool)0);
    memcpy((void *)connection->saddr, (const void *)s, (unsigned long int)sl);
    if(!(htp->thr_pool == ((struct evthr_pool *)NULL)))
    {
      enum evthr_res return_value_evthr_pool_defer_2;
      return_value_evthr_pool_defer_2=evthr_pool_defer(htp->thr_pool, _evhtp_run_in_thread, (void *)connection);
      if(!((signed int)return_value_evthr_pool_defer_2 == EVTHR_RES_OK))
      {
        evutil_closesocket(connection->sock);
        evhtp_connection_free(connection);
        goto __CPROVER_DUMP_L8;
      }

      goto __CPROVER_DUMP_L8;
    }

    connection->evbase = htp->evbase;
    signed int return_value__evhtp_connection_accept_3;
    return_value__evhtp_connection_accept_3=_evhtp_connection_accept(htp->evbase, connection);
    if(!(return_value__evhtp_connection_accept_3 >= 0))
      evhtp_connection_free(connection);

    else
    {
      signed int return_value__evhtp_run_post_accept_4;
      return_value__evhtp_run_post_accept_4=_evhtp_run_post_accept(htp, connection);
      if(!(return_value__evhtp_run_post_accept_4 >= 0))
        evhtp_connection_free(connection);

    }
  }


__CPROVER_DUMP_L8:
  ;
}

// _evhtp_authority_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 814
static void _evhtp_authority_free(struct evhtp_authority_s *authority)
{
  if(!(authority == ((struct evhtp_authority_s *)NULL)))
  {
    do
    {
      free((void *)authority->username);
      authority->username = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)authority->password);
      authority->password = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)authority->hostname);
      authority->hostname = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)authority);
      authority = (struct evhtp_authority_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// _evhtp_authority_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 832
static struct evhtp_authority_s * _evhtp_authority_new(void)
{
  struct evhtp_authority_s *authority;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct evhtp_authority_s) /*32ul*/ );
  authority = (struct evhtp_authority_s *)return_value_calloc_1;
  if(authority == ((struct evhtp_authority_s *)NULL))
    return (struct evhtp_authority_s *)(void *)0;

  else
    return authority;
}

// _evhtp_body_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 444
static inline unsigned short int _evhtp_body_hook(struct evhtp_request_s *request, struct evbuffer *buf)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_read == ((unsigned short int (*)(struct evhtp_request_s *, struct evbuffer *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_read(request, buf, request->hooks->on_read_arg);
        return return_value;
      }

    }

    struct evhtp_connection_s *return_value_evhtp_request_get_connection_2;
    return_value_evhtp_request_get_connection_2=evhtp_request_get_connection(request);
    if(!(return_value_evhtp_request_get_connection_2->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(request);
      if(!(return_value_evhtp_request_get_connection_1->hooks->on_read == ((unsigned short int (*)(struct evhtp_request_s *, struct evbuffer *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_read(request, buf, request->conn->hooks->on_read_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_callback_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 643
static struct evhtp_callback_s * _evhtp_callback_find(struct evhtp_callbacks_s *cbs, const char *path, unsigned int *start_offset, unsigned int *end_offset)
{
  struct anonymous_6 pmatch[28l];
  struct evhtp_callback_s *callback;
  signed int return_value_strcmp_2;
  signed int return_value_regexec_3;
  if(cbs == ((struct evhtp_callbacks_s *)NULL))
    return (struct evhtp_callback_s *)(void *)0;

  else
  {
    callback = cbs->tqh_first;
    for( ; !(callback == ((struct evhtp_callback_s *)NULL)); callback = callback->next.tqe_next)
      switch((signed int)callback->type)
      {
        case evhtp_callback_type_hash:
        {
          return_value_strcmp_2=strcmp(callback->val.path, path);
          if(return_value_strcmp_2 == 0)
          {
            *start_offset = (unsigned int)0;
            unsigned long int return_value_strlen_1;
            return_value_strlen_1=strlen(path);
            *end_offset = (unsigned int)return_value_strlen_1;
            return callback;
          }

          break;
        }
        case evhtp_callback_type_regex:
        {
          return_value_regexec_3=regexec(callback->val.regex, path, callback->val.regex->re_nsub + (unsigned long int)1, pmatch, 0);
          if(return_value_regexec_3 == 0)
          {
            *start_offset = (unsigned int)pmatch[(signed long int)callback->val.regex->re_nsub].rm_so;
            *end_offset = (unsigned int)pmatch[(signed long int)callback->val.regex->re_nsub].rm_eo;
            return callback;
          }

          break;
        }
        case evhtp_callback_type_glob:
        {
          unsigned long int path_len;
          path_len=strlen(path);
          unsigned long int glob_len;
          glob_len=strlen(callback->val.glob);
          signed int return_value__evhtp_glob_match_4;
          return_value__evhtp_glob_match_4=_evhtp_glob_match(callback->val.glob, glob_len, path, path_len);
          if(return_value__evhtp_glob_match_4 == 1)
          {
            *start_offset = (unsigned int)0;
            *end_offset = (unsigned int)path_len;
            return callback;
          }

        }
        default:
          ;
      }
    return (struct evhtp_callback_s *)(void *)0;
  }
}

// _evhtp_chunk_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 473
static inline unsigned short int _evhtp_chunk_fini_hook(struct evhtp_request_s *request)
{
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_chunk_fini == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_chunk_fini(request, request->hooks->on_chunk_fini_arg);
        return return_value;
      }

    }

    if(!(request->conn->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->conn->hooks->on_chunk_fini == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_chunk_fini(request, request->conn->hooks->on_chunk_fini_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_chunk_new_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 466
static inline unsigned short int _evhtp_chunk_new_hook(struct evhtp_request_s *request, unsigned long int len)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_new_chunk == ((unsigned short int (*)(struct evhtp_request_s *, unsigned long int, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_new_chunk(request, len, request->hooks->on_new_chunk_arg);
        return return_value;
      }

    }

    struct evhtp_connection_s *return_value_evhtp_request_get_connection_2;
    return_value_evhtp_request_get_connection_2=evhtp_request_get_connection(request);
    if(!(return_value_evhtp_request_get_connection_2->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(request);
      if(!(return_value_evhtp_request_get_connection_1->hooks->on_new_chunk == ((unsigned short int (*)(struct evhtp_request_s *, unsigned long int, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_new_chunk(request, len, request->conn->hooks->on_new_chunk_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_chunks_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 480
static inline unsigned short int _evhtp_chunks_fini_hook(struct evhtp_request_s *request)
{
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_chunks_fini == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_chunks_fini(request, request->hooks->on_chunks_fini_arg);
        return return_value;
      }

    }

    if(!(request->conn->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->conn->hooks->on_chunks_fini == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_chunks_fini(request, request->conn->hooks->on_chunks_fini_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_connection_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1999
static signed int _evhtp_connection_accept(struct event_base *evbase, struct evhtp_connection_s *connection)
{
  struct timeval *c_recv_timeo;
  struct timeval *c_send_timeo;
  signed int return_value__evhtp_run_pre_accept_1;
  return_value__evhtp_run_pre_accept_1=_evhtp_run_pre_accept(connection->htp, connection);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  if(!(return_value__evhtp_run_pre_accept_1 >= 0))
  {
    evutil_closesocket(connection->sock);
    return -1;
  }

  else
  {
    if(!(connection->htp->ssl_ctx == ((struct ssl_ctx_st *)NULL)))
    {
      connection->ssl=SSL_new(connection->htp->ssl_ctx);
      connection->bev=bufferevent_openssl_socket_new(evbase, connection->sock, connection->ssl, (enum bufferevent_ssl_state)BUFFEREVENT_SSL_ACCEPTING, connection->htp->bev_flags);
      SSL_set_ex_data(connection->ssl, 0, (void *)(char *)connection);
    }

    else
      connection->bev=bufferevent_socket_new(evbase, connection->sock, connection->htp->bev_flags);

  __CPROVER_DUMP_L3:
    ;

  end:
    ;
    if(!(connection->recv_timeo.tv_sec == 0l))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = connection->recv_timeo.tv_usec != 0l ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      c_recv_timeo = &connection->recv_timeo;

    else
    {
      if(!(connection->htp->recv_timeo.tv_sec == 0l))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = connection->htp->recv_timeo.tv_usec != 0l ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        c_recv_timeo = &connection->htp->recv_timeo;

      else
        c_recv_timeo = (struct timeval *)(void *)0;
    }
    if(!(connection->send_timeo.tv_sec == 0l))
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = connection->send_timeo.tv_usec != 0l ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      c_send_timeo = &connection->send_timeo;

    else
    {
      if(!(connection->htp->send_timeo.tv_sec == 0l))
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = connection->htp->send_timeo.tv_usec != 0l ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        c_send_timeo = &connection->htp->send_timeo;

      else
        c_send_timeo = (struct timeval *)(void *)0;
    }
    evhtp_connection_set_timeouts(connection, c_recv_timeo, c_send_timeo);
    connection->resume_ev=event_new(evbase, -1, (signed short int)(0x02 | 0x10), _evhtp_connection_resumecb, (void *)connection);
    event_add(connection->resume_ev, (struct timeval *)(void *)0);
    bufferevent_enable(connection->bev, (signed short int)0x02);
    bufferevent_setcb(connection->bev, _evhtp_connection_readcb, _evhtp_connection_writecb, _evhtp_connection_eventcb, (void *)connection);
    return 0;
  }
}

// _evhtp_connection_error_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 532
static inline unsigned short int _evhtp_connection_error_hook(struct evhtp_connection_s *connection, unsigned char errtype)
{
  if(!(connection->request == ((struct evhtp_request_s *)NULL)))
    _evhtp_error_hook(connection->request, errtype);

  do
  {
    if(!(connection->request == ((struct evhtp_request_s *)NULL)))
    {
      struct evhtp_request_s *request = connection->request;
      if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
      {
        if(!(request->hooks->on_connection_error == ((unsigned short int (*)(struct evhtp_connection_s *, unsigned char, void *))NULL)))
        {
          unsigned short int return_value;
          return_value=connection->hooks->on_connection_error(connection, errtype, connection->hooks->on_connection_error_arg);
          return return_value;
        }

      }

    }

    if(!(connection->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(connection->hooks->on_connection_error == ((unsigned short int (*)(struct evhtp_connection_s *, unsigned char, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=connection->hooks->on_connection_error(connection, errtype, connection->hooks->on_connection_error_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_connection_eventcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1917
static void _evhtp_connection_eventcb(struct bufferevent *bev, signed short int events, void *arg)
{
  struct evhtp_connection_s *c = (struct evhtp_connection_s *)arg;
  if(!(c->hooks == ((struct evhtp_hooks_s *)NULL)))
  {
    if(!(c->hooks->on_event == ((void (*)(struct evhtp_connection_s *, signed short int, void *))NULL)))
      c->hooks->on_event(c, events, c->hooks->on_event_arg);

  }

  if(!((0x80 & (signed int)events) == 0))
  {
    if((signed int)c->type == evhtp_type_client)
    {
      c->connected = (unsigned char)1;
      bufferevent_setcb(bev, _evhtp_connection_readcb, _evhtp_connection_writecb, _evhtp_connection_eventcb, (void *)c);
    }

  }

  else
  {
    if(!(c->ssl == ((struct ssl_st *)NULL)))
    {
      if((0x10 & (signed int)events) == 0)
      {
        c->error = (unsigned char)1;
        if(!(c->request == ((struct evhtp_request_s *)NULL)))
          c->request->error = (unsigned char)1;

      }

    }

    if((signed int)events == 17)
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 11)
      {
        bufferevent_enable(bev, (signed short int)0x02);
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        goto __CPROVER_DUMP_L9;
      }

    }

    c->error = (unsigned char)1;
    c->connected = (unsigned char)0;
    _evhtp_connection_error_hook(c, (unsigned char)events);
    if((signed int)c->paused == 1)
      c->free_connection = (unsigned char)1;

    else
      evhtp_connection_free((struct evhtp_connection_s *)arg);
  }

__CPROVER_DUMP_L9:
  ;
}

// _evhtp_connection_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 502
static inline unsigned short int _evhtp_connection_fini_hook(struct evhtp_connection_s *connection)
{
  if(!(connection->hooks == ((struct evhtp_hooks_s *)NULL)))
  {
    if(!(connection->hooks->on_connection_fini == ((unsigned short int (*)(struct evhtp_connection_s *, void *))NULL)))
    {
      unsigned short int return_value;
      return_value=connection->hooks->on_connection_fini(connection, connection->hooks->on_connection_fini_arg);
      return return_value;
    }

  }

  return (unsigned short int)200;
}

// _evhtp_connection_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2073
static struct evhtp_connection_s * _evhtp_connection_new(struct evhtp_s *htp, signed int sock, enum evhtp_type type)
{
  struct evhtp_connection_s *connection;
  enum htp_type ptype;
  switch((signed int)type)
  {
    case evhtp_type_client:
    {
      ptype = (enum htp_type)htp_type_response;
      break;
    }
    case evhtp_type_server:
    {
      ptype = (enum htp_type)htp_type_request;
      break;
    }
    default:
      return (struct evhtp_connection_s *)(void *)0;
  }
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct evhtp_connection_s) /*160ul*/ , (unsigned long int)1);
  connection = (struct evhtp_connection_s *)return_value_calloc_1;
  do
    if(connection == ((struct evhtp_connection_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_connection_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2089);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  connection->scratch_buf=evbuffer_new();
  do
    if(connection->scratch_buf == ((struct evbuffer *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_connection_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2092);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  connection->error = (unsigned char)0;
  connection->owner = (unsigned char)1;
  connection->paused = (unsigned char)0;
  connection->connected = (unsigned char)0;
  connection->sock = sock;
  connection->htp = htp;
  connection->type = type;
  connection->parser=htparser_new();
  do
    if(connection->parser == ((struct htparser *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_connection_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2103);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  htparser_init(connection->parser, ptype);
  htparser_set_userdata(connection->parser, (void *)connection);
  return connection;
}

// _evhtp_connection_readcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1775
static void _evhtp_connection_readcb(struct bufferevent *bev, void *arg)
{
  struct evhtp_connection_s *c = (struct evhtp_connection_s *)arg;
  void *buf;
  unsigned long int nread;
  unsigned long int avail;

__CPROVER_DUMP_L1:
  ;
  struct evbuffer *return_value_bufferevent_get_input_1;
  return_value_bufferevent_get_input_1=bufferevent_get_input(bev);
  avail=evbuffer_get_length(return_value_bufferevent_get_input_1);

__CPROVER_DUMP_L2:
  ;
  _Bool tmp_if_expr_7;
  enum htpparse_error return_value_htparser_get_error_6;
  if(!(avail == 0ul))
  {
    if(!(c->request == ((struct evhtp_request_s *)NULL)))
      c->request->status = (unsigned short int)200;

    if(!((signed int)c->paused == 1))
    {
      struct evbuffer *return_value_bufferevent_get_input_2;
      return_value_bufferevent_get_input_2=bufferevent_get_input(bev);
      unsigned char *return_value_evbuffer_pullup_3;
      return_value_evbuffer_pullup_3=evbuffer_pullup(return_value_bufferevent_get_input_2, (signed long int)avail);
      buf = (void *)return_value_evbuffer_pullup_3;

    __CPROVER_DUMP_L6:
      ;
      nread=htparser_run(c->parser, &request_psets, (const char *)buf, avail);

    __CPROVER_DUMP_L7:
      ;
      if(!((signed int)c->owner == 1))
      {
        struct evbuffer *return_value_bufferevent_get_input_4;
        return_value_bufferevent_get_input_4=bufferevent_get_input(bev);
        evbuffer_drain(return_value_bufferevent_get_input_4, nread);
        evhtp_connection_free(c);
        goto __CPROVER_DUMP_L16;
      }

      if(!(c->request == ((struct evhtp_request_s *)NULL)))
      {
        if(!((signed int)c->request->status == 4))
          goto __CPROVER_DUMP_L10;

        _evhtp_connection_error_hook(c, (unsigned char)-1);
        evhtp_connection_free(c);
      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        struct evbuffer *return_value_bufferevent_get_input_5;
        return_value_bufferevent_get_input_5=bufferevent_get_input(bev);
        evbuffer_drain(return_value_bufferevent_get_input_5, nread);
        if(!(c->request == ((struct evhtp_request_s *)NULL)))
          tmp_if_expr_7 = (signed int)c->request->status == 1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          evhtp_request_pause(c->request);

        else
        {
          return_value_htparser_get_error_6=htparser_get_error(c->parser);
          if(!((signed int)return_value_htparser_get_error_6 == htparse_error_none))
            evhtp_connection_free(c);

          else
            if(!(nread >= avail))
              evhtp_connection_resume(c);

        }
      }
    }

  }


__CPROVER_DUMP_L16:
  ;
}

// _evhtp_connection_resumecb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1743
static void _evhtp_connection_resumecb(signed int fd, signed short int events, void *arg)
{
  struct evhtp_connection_s *c = (struct evhtp_connection_s *)arg;
  c->paused = (unsigned char)0;
  if(!(c->request == ((struct evhtp_request_s *)NULL)))
    c->request->status = (unsigned short int)200;

  if((signed int)c->free_connection == 1)
    evhtp_connection_free(c);

  else
  {
    struct evbuffer *return_value_bufferevent_get_output_1;
    return_value_bufferevent_get_output_1=bufferevent_get_output(c->bev);
    unsigned long int return_value_evbuffer_get_length_2;
    return_value_evbuffer_get_length_2=evbuffer_get_length(return_value_bufferevent_get_output_1);
    if(!(return_value_evbuffer_get_length_2 == 0ul))
    {
      bufferevent_enable(c->bev, (signed short int)0x04);
      c->waiting = (unsigned char)1;
    }

    else
    {
      bufferevent_enable(c->bev, (signed short int)(0x02 | 0x04));
      _evhtp_connection_readcb(c->bev, (void *)c);
    }
  }
}

// _evhtp_connection_write_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 550
static inline unsigned short int _evhtp_connection_write_hook(struct evhtp_connection_s *connection)
{
  if(!(connection->hooks == ((struct evhtp_hooks_s *)NULL)))
  {
    if(!(connection->hooks->on_write == ((unsigned short int (*)(struct evhtp_connection_s *, void *))NULL)))
    {
      unsigned short int return_value;
      return_value=connection->hooks->on_write(connection, connection->hooks->on_write_arg);
      return return_value;
    }

  }

  return (unsigned short int)200;
}

// _evhtp_connection_writecb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1843
static void _evhtp_connection_writecb(struct bufferevent *bev, void *arg)
{
  struct evhtp_connection_s *c = (struct evhtp_connection_s *)arg;

__CPROVER_DUMP_L1:
  ;
  _Bool tmp_if_expr_5;
  struct evbuffer *return_value_bufferevent_get_output_3;
  unsigned long int return_value_evbuffer_get_length_4;
  if(!(c->request == ((struct evhtp_request_s *)NULL)))
  {
    _evhtp_connection_write_hook(c);
    if(!((signed int)c->paused == 1))
    {
      if((signed int)c->waiting == 1)
      {
        c->waiting = (unsigned char)0;
        bufferevent_enable(bev, (signed short int)0x02);
        struct evbuffer *return_value_bufferevent_get_input_1;
        return_value_bufferevent_get_input_1=bufferevent_get_input(bev);
        unsigned long int return_value_evbuffer_get_length_2;
        return_value_evbuffer_get_length_2=evbuffer_get_length(return_value_bufferevent_get_input_1);
        if(!(return_value_evbuffer_get_length_2 == 0ul))
          _evhtp_connection_readcb(bev, arg);

        goto __CPROVER_DUMP_L13;
      }

      if((signed int)c->request->finished == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_bufferevent_get_output_3=bufferevent_get_output(bev);
        return_value_evbuffer_get_length_4=evbuffer_get_length(return_value_bufferevent_get_output_3);
        tmp_if_expr_5 = return_value_evbuffer_get_length_4 != 0ul ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_5)
      {
        if(!(c->htp->max_keepalive_requests == 0ul))
        {
          c->num_requests = c->num_requests + 1ul;
          if(c->num_requests >= c->htp->max_keepalive_requests)
            c->request->keepalive = (unsigned char)0;

        }

        if((signed int)c->request->keepalive == 1)
        {
          _evhtp_request_free(c->request);
          c->keepalive = (unsigned char)1;
          c->request = (struct evhtp_request_s *)(void *)0;
          c->body_bytes_read = (unsigned long int)0;
          if(!(c->htp->parent == ((struct evhtp_s *)NULL)))
          {
            if((signed int)c->vhost_via_sni == 0)
            {
              struct evhtp_s *orig_htp = c->htp->parent;
              c->htp = orig_htp;
            }

          }

          htparser_init(c->parser, (enum htp_type)htp_type_request);
          htparser_set_userdata(c->parser, (void *)c);
          goto __CPROVER_DUMP_L13;
        }

        else
        {
          evhtp_connection_free(c);
          goto __CPROVER_DUMP_L13;
        }
      }

    }

  }


__CPROVER_DUMP_L13:
  ;
}

// _evhtp_create_headers
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1612
static signed int _evhtp_create_headers(struct evhtp_kv_s *header, void *arg)
{
  struct evbuffer *buf = (struct evbuffer *)arg;
  evbuffer_expand(buf, header->klen + (unsigned long int)2 + header->vlen + (unsigned long int)2);
  evbuffer_add(buf, (const void *)header->key, header->klen);
  evbuffer_add(buf, (const void *)": ", (unsigned long int)2);
  evbuffer_add(buf, (const void *)header->val, header->vlen);
  evbuffer_add(buf, (const void *)"\r\n", (unsigned long int)2);
  return 0;
}

// _evhtp_create_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1625
static struct evbuffer * _evhtp_create_reply(struct evhtp_request_s *request, unsigned short int code)
{
  struct evbuffer *buf;
  const char *content_type;
  char res_buf[2048l];
  signed int sres;
  unsigned long int out_len;
  unsigned char major;
  unsigned char minor;
  char out_buf[64l];
  content_type=evhtp_kv_find(request->headers_out, "Content-Type");
  out_len=evbuffer_get_length(request->buffer_out);
  buf = request->conn->scratch_buf;
  do
    if(buf == ((struct evbuffer *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"buf != NULL", (const void *)"_evhtp_create_reply", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1640);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  evbuffer_drain(buf, (unsigned long int)-1);
  unsigned char return_value_htparser_get_multipart_1;
  return_value_htparser_get_multipart_1=htparser_get_multipart(request->conn->parser);
  if(!((signed int)return_value_htparser_get_multipart_1 == 1))
  {
    if(!(out_len == 0ul))
    {
      if((signed int)request->chunked == 0)
      {
        const char *return_value_evhtp_kv_find_3;
        return_value_evhtp_kv_find_3=evhtp_kv_find(request->headers_out, "Content-Length");
        if(return_value_evhtp_kv_find_3 == ((const char *)NULL))
        {
          evhtp_modp_sizetoa(out_len, out_buf);
          struct evhtp_kv_s *return_value_evhtp_kv_new_2;
          return_value_evhtp_kv_new_2=evhtp_kv_new("Content-Length", out_buf, (char)0, (char)1);
          evhtp_kvs_add_kv(request->headers_out, return_value_evhtp_kv_new_2);
        }

      }

    }

  }


check_proto:
  ;
  switch((signed int)request->proto)
  {
    case EVHTP_PROTO_11:
    {
      if((signed int)request->keepalive == 0)
      {
        struct evhtp_kv_s *return_value_evhtp_kv_new_4;
        return_value_evhtp_kv_new_4=evhtp_kv_new("Connection", "close", (char)0, (char)0);
        evhtp_kvs_add_kv(request->headers_out, return_value_evhtp_kv_new_4);
      }

      break;
    }
    case EVHTP_PROTO_10:
    {
      if((signed int)request->keepalive == 1)
      {
        struct evhtp_kv_s *return_value_evhtp_kv_new_5;
        return_value_evhtp_kv_new_5=evhtp_kv_new("Connection", "keep-alive", (char)0, (char)0);
        evhtp_kvs_add_kv(request->headers_out, return_value_evhtp_kv_new_5);
      }

      break;
    }
    default:
    {
      htparser_set_major(request->conn->parser, (unsigned char)1);
      htparser_set_minor(request->conn->parser, (unsigned char)0);
    }
  }
  if(content_type == ((const char *)NULL))
  {
    struct evhtp_kv_s *return_value_evhtp_kv_new_6;
    return_value_evhtp_kv_new_6=evhtp_kv_new("Content-Type", "text/plain", (char)0, (char)0);
    evhtp_kvs_add_kv(request->headers_out, return_value_evhtp_kv_new_6);
  }

  unsigned char return_value_htparser_get_major_7;
  return_value_htparser_get_major_7=htparser_get_major(request->conn->parser);
  major = (unsigned char)(48 + (signed int)return_value_htparser_get_major_7);
  unsigned char return_value_htparser_get_minor_8;
  return_value_htparser_get_minor_8=htparser_get_minor(request->conn->parser);
  minor = (unsigned char)(48 + (signed int)return_value_htparser_get_minor_8);
  evhtp_modp_u32toa((unsigned int)code, out_buf);
  const char *return_value_status_code_to_str_9;
  return_value_status_code_to_str_9=status_code_to_str(code);
  sres=snprintf(res_buf, sizeof(char [2048l]) /*2048ul*/ , "HTTP/%c.%c %s %s\r\n", major, minor, (const void *)out_buf, return_value_status_code_to_str_9);
  if((unsigned long int)sres >= sizeof(char [2048l]) /*2048ul*/  || !(sres >= 0))
  {
    const char *return_value_status_code_to_str_10;
    return_value_status_code_to_str_10=status_code_to_str(code);
    evbuffer_add_printf(buf, "HTTP/%c.%c %d %s\r\n", major, minor, code, return_value_status_code_to_str_10);
  }

  else
    evbuffer_add(buf, (const void *)res_buf, (unsigned long int)sres);
  evhtp_kvs_for_each(request->headers_out, _evhtp_create_headers, (void *)buf);
  evbuffer_add(buf, (const void *)"\r\n", (unsigned long int)2);
  unsigned long int return_value_evbuffer_get_length_11;
  return_value_evbuffer_get_length_11=evbuffer_get_length(request->buffer_out);
  if(!(return_value_evbuffer_get_length_11 == 0ul))
    evbuffer_add_buffer(buf, request->buffer_out);

  return buf;
}

// _evhtp_default_request_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2066
static void _evhtp_default_request_cb(struct evhtp_request_s *request, void *arg)
{
  struct evhtp_kv_s *return_value_evhtp_kv_new_1;
  return_value_evhtp_kv_new_1=evhtp_kv_new("Content-Length", "0", (char)0, (char)0);
  evhtp_kvs_add_kv(request->headers_out, return_value_evhtp_kv_new_1);
  evhtp_send_reply(request, (unsigned short int)404);
}

// _evhtp_error_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 518
static inline void _evhtp_error_hook(struct evhtp_request_s *request, unsigned char errtype)
{
  if(!(request == ((struct evhtp_request_s *)NULL)))
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_error == ((void (*)(struct evhtp_request_s *, unsigned char, void *))NULL)))
        request->hooks->on_error(request, errtype, request->hooks->on_error_arg);

    }

  }

}

// _evhtp_glob_match
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 626
static inline signed int _evhtp_glob_match(const char *pattern, unsigned long int pat_len, const char *string, unsigned long int str_len)
{
  if(pattern == ((const char *)NULL) || string == ((const char *)NULL))
    return 0;

  else
  {
    if(pat_len == 0ul)
      pat_len=strlen(pattern);

    if(str_len == 0ul)
      str_len=strlen(string);

    signed int return_value__evhtp_glob_match2_1;
    return_value__evhtp_glob_match2_1=_evhtp_glob_match2(pattern, pat_len, string, str_len);
    return return_value__evhtp_glob_match2_1;
  }
}

// _evhtp_glob_match2
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 560
static signed int _evhtp_glob_match2(const char *pattern, unsigned long int plen, const char *string, unsigned long int str_len)
{
  while(!(plen == 0ul))
  {
    if((signed int)*pattern == 42)
    {
      for( ; (signed int)pattern[1l] == 42; plen = plen - 1ul)
        pattern = pattern + 1l;
      if(plen == 1ul)
        return 1;

      while(!(str_len == 0ul))
      {
        signed int return_value__evhtp_glob_match2_1;
        return_value__evhtp_glob_match2_1=_evhtp_glob_match2(pattern + (signed long int)1, plen - (unsigned long int)1, string, str_len);
        if(!(return_value__evhtp_glob_match2_1 == 0))
          return 1;

        string = string + 1l;
        str_len = str_len - 1ul;
      }
      return 0;
    }

    if(!(*pattern == *string))
      return 0;

    string = string + 1l;
    str_len = str_len - 1ul;
    pattern = pattern + 1l;
    plen = plen - 1ul;
    if(str_len == 0ul)
    {
      for( ; (signed int)*pattern == 42; plen = plen - 1ul)
        pattern = pattern + 1l;
      break;
    }

  }
  if(plen == 0ul && str_len == 0ul)
    return 1;

  else
    return 0;
}

// _evhtp_header_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 411
static inline unsigned short int _evhtp_header_hook(struct evhtp_request_s *request, struct evhtp_kv_s *header)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_header == ((unsigned short int (*)(struct evhtp_request_s *, struct evhtp_kv_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_header(request, header, request->hooks->on_header_arg);
        return return_value;
      }

    }

    struct evhtp_connection_s *return_value_evhtp_request_get_connection_2;
    return_value_evhtp_request_get_connection_2=evhtp_request_get_connection(request);
    if(!(return_value_evhtp_request_get_connection_2->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(request);
      if(!(return_value_evhtp_request_get_connection_1->hooks->on_header == ((unsigned short int (*)(struct evhtp_request_s *, struct evhtp_kv_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_header(request, header, request->conn->hooks->on_header_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_headers_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 427
static inline unsigned short int _evhtp_headers_hook(struct evhtp_request_s *request, struct evhtp_kvs_s *headers)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_headers == ((unsigned short int (*)(struct evhtp_request_s *, struct evhtp_kvs_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_headers(request, headers, request->hooks->on_headers_arg);
        return return_value;
      }

    }

    struct evhtp_connection_s *return_value_evhtp_request_get_connection_2;
    return_value_evhtp_request_get_connection_2=evhtp_request_get_connection(request);
    if(!(return_value_evhtp_request_get_connection_2->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(request);
      if(!(return_value_evhtp_request_get_connection_1->hooks->on_headers == ((unsigned short int (*)(struct evhtp_request_s *, struct evhtp_kvs_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_headers(request, headers, request->conn->hooks->on_headers_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_headers_start_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 487
static inline unsigned short int _evhtp_headers_start_hook(struct evhtp_request_s *request)
{
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_headers_start == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_headers_start(request, request->hooks->on_headers_start_arg);
        return return_value;
      }

    }

    if(!(request->conn->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->conn->hooks->on_headers_start == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_headers_start(request, request->conn->hooks->on_headers_start_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_hostname_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 543
static inline unsigned short int _evhtp_hostname_hook(struct evhtp_request_s *r, const char *hostname)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  do
  {
    if(!(r->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(r->hooks->on_hostname == ((unsigned short int (*)(struct evhtp_request_s *, const char *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=r->hooks->on_hostname(r, hostname, r->hooks->on_hostname_arg);
        return return_value;
      }

    }

    struct evhtp_connection_s *return_value_evhtp_request_get_connection_2;
    return_value_evhtp_request_get_connection_2=evhtp_request_get_connection(r);
    if(!(return_value_evhtp_request_get_connection_2->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(r);
      if(!(return_value_evhtp_request_get_connection_1->hooks->on_hostname == ((unsigned short int (*)(struct evhtp_request_s *, const char *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=r->conn->hooks->on_hostname(r, hostname, r->conn->hooks->on_hostname_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_path_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 979
static void _evhtp_path_free(struct evhtp_path_s *path)
{
  if(!(path == ((struct evhtp_path_s *)NULL)))
  {
    do
    {
      free((void *)path->full);
      path->full = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)path->path);
      path->path = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)path->file);
      path->file = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)path->match_start);
      path->match_start = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)path->match_end);
      path->match_end = (char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)path);
      path = (struct evhtp_path_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// _evhtp_path_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 394
static inline unsigned short int _evhtp_path_hook(struct evhtp_request_s *request, struct evhtp_path_s *path)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_path == ((unsigned short int (*)(struct evhtp_request_s *, struct evhtp_path_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_path(request, path, request->hooks->on_path_arg);
        return return_value;
      }

    }

    struct evhtp_connection_s *return_value_evhtp_request_get_connection_2;
    return_value_evhtp_request_get_connection_2=evhtp_request_get_connection(request);
    if(!(return_value_evhtp_request_get_connection_2->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(request);
      if(!(return_value_evhtp_request_get_connection_1->hooks->on_path == ((unsigned short int (*)(struct evhtp_request_s *, struct evhtp_path_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_path(request, path, request->conn->hooks->on_path_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_path_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 879
static struct evhtp_path_s * _evhtp_path_new(const char *data, unsigned long int len)
{
  struct evhtp_path_s *req_path;
  const char *data_end = (const char *)(data + (signed long int)len);
  char *path = (char *)(void *)0;
  char *file = (char *)(void *)0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct evhtp_path_s) /*48ul*/ , (unsigned long int)1);
  req_path = (struct evhtp_path_s *)return_value_calloc_1;
  do
    if(req_path == ((struct evhtp_path_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 886);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  if(len == 0ul)
  {
    path=strdup("/");
    do
      if(path == ((char *)NULL))
      {
        fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 893);
        fflush(stderr);
        abort();
      }

    while((_Bool)0);
  }

  else
    if(!((signed int)*data == 47))
    {
      path=strdup("/");
      file=strndup(data, len);
      do
        if(path == ((char *)NULL))
        {
          fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 901);
          fflush(stderr);
          abort();
        }

      while((_Bool)0);
      do
        if(file == ((char *)NULL))
        {
          fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 902);
          fflush(stderr);
          abort();
        }

      while((_Bool)0);
    }

    else
      if(!((signed int)data[-1l + (signed long int)len] == 47))
      {
        unsigned long int i = len - (unsigned long int)1;
        for( ; !(i == 0ul); i = i - 1ul)
          if((signed int)data[(signed long int)i] == 47)
          {
            unsigned long int path_len;
            unsigned long int file_len;
            path_len = (unsigned long int)(&data[(signed long int)i] - data) + (unsigned long int)1;
            file_len = (unsigned long int)(data_end - &data[(signed long int)(i + (unsigned long int)1)]);
            if(!(data_end >= data + (signed long int)path_len))
            {
              do
              {
                free((void *)req_path);
                req_path = (struct evhtp_path_s *)(void *)0;
              }
              while((_Bool)0);
              return (struct evhtp_path_s *)(void *)0;
            }

            if(!(data_end >= data + 1l + (signed long int)i + (signed long int)file_len))
            {
              do
              {
                free((void *)req_path);
                req_path = (struct evhtp_path_s *)(void *)0;
              }
              while((_Bool)0);
              return (struct evhtp_path_s *)(void *)0;
            }

            path=strndup(data, path_len);
            file=strndup(&data[(signed long int)(i + (unsigned long int)1)], file_len);
            do
              if(path == ((char *)NULL))
              {
                fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 940);
                fflush(stderr);
                abort();
              }

            while((_Bool)0);
            do
              if(file == ((char *)NULL))
              {
                fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 941);
                fflush(stderr);
                abort();
              }

            while((_Bool)0);
            break;
          }

        if(i == 0ul)
        {
          if((signed int)data[(signed long int)i] == 47)
          {
            if(file == ((char *)NULL))
            {
              if(path == ((char *)NULL))
              {
                path=strdup("/");
                do
                  if(path == ((char *)NULL))
                  {
                    fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 950);
                    fflush(stderr);
                    abort();
                  }

                while((_Bool)0);
                if(len >= 2ul)
                {
                  file=strndup((const char *)(data + (signed long int)1), len);
                  do
                    if(file == ((char *)NULL))
                    {
                      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 954);
                      fflush(stderr);
                      abort();
                    }

                  while((_Bool)0);
                }

              }

            }

          }

        }

      }

      else
      {
        path=strndup(data, len);
        do
          if(path == ((char *)NULL))
          {
            fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 960);
            fflush(stderr);
            abort();
          }

        while((_Bool)0);
      }
  if(!(len == 0ul))
    req_path->full=strndup(data, len);

  else
    req_path->full=strdup("/");
  do
    if(req_path->full == ((char *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_path_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 970);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  req_path->path = path;
  req_path->file = file;
  return req_path;
}

// _evhtp_protocol
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 373
static inline enum evhtp_proto _evhtp_protocol(const char major, const char minor)
{
  if((signed int)major >= 1 && !((signed int)minor >= 1))
    return (enum evhtp_proto)EVHTP_PROTO_10;

  else
    if((signed int)major >= 1 && (signed int)minor >= 1)
      return (enum evhtp_proto)EVHTP_PROTO_11;

    else
      return (enum evhtp_proto)EVHTP_PROTO_INVALID;
}

// _evhtp_quick_hash
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 327
static inline unsigned int _evhtp_quick_hash(const char *str)
{
  unsigned int h = (unsigned int)0;
  for( ; !(*str == 0); str = str + 1l)
    h = (unsigned int)31 * h + (unsigned int)*str;
  return h;
}

// _evhtp_request_find_vhost
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1151
static inline struct evhtp_s * _evhtp_request_find_vhost(struct evhtp_s *evhtp, const char *name)
{
  struct evhtp_s *evhtp_vhost;
  struct evhtp_alias_s *evhtp_alias;
  evhtp_vhost = (&evhtp->vhosts)->tqh_first;
  for( ; !(evhtp_vhost == ((struct evhtp_s *)NULL)); evhtp_vhost = evhtp_vhost->next_vhost.tqe_next)
    if(!(evhtp_vhost->server_name == ((char *)NULL)))
    {
      signed int return_value__evhtp_glob_match_1;
      return_value__evhtp_glob_match_1=_evhtp_glob_match(evhtp_vhost->server_name, (unsigned long int)0, name, (unsigned long int)0);
      if(return_value__evhtp_glob_match_1 == 1)
        return evhtp_vhost;

      evhtp_alias = (&evhtp_vhost->aliases)->tqh_first;
      for( ; !(evhtp_alias == ((struct evhtp_alias_s *)NULL)); evhtp_alias = evhtp_alias->next.tqe_next)
        if(!(evhtp_alias->alias == ((char *)NULL)))
        {
          signed int return_value__evhtp_glob_match_2;
          return_value__evhtp_glob_match_2=_evhtp_glob_match(evhtp_alias->alias, (unsigned long int)0, name, (unsigned long int)0);
          if(return_value__evhtp_glob_match_2 == 1)
            return evhtp_vhost;

        }

    }

  return (struct evhtp_s *)(void *)0;
}

// _evhtp_request_fini_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 459
static inline unsigned short int _evhtp_request_fini_hook(struct evhtp_request_s *request)
{
  do
  {
    if(!(request->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->hooks->on_request_fini == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value;
        return_value=request->hooks->on_request_fini(request, request->hooks->on_request_fini_arg);
        return return_value;
      }

    }

    if(!(request->conn->hooks == ((struct evhtp_hooks_s *)NULL)))
    {
      if(!(request->conn->hooks->on_request_fini == ((unsigned short int (*)(struct evhtp_request_s *, void *))NULL)))
      {
        unsigned short int return_value_1;
        return_value_1=request->conn->hooks->on_request_fini(request, request->conn->hooks->on_request_fini_arg);
        return return_value_1;
      }

    }

  }
  while((_Bool)0);
  return (unsigned short int)200;
}

// _evhtp_request_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 757
static void _evhtp_request_free(struct evhtp_request_s *request)
{
  if(!(request == ((struct evhtp_request_s *)NULL)))
  {
    _evhtp_request_fini_hook(request);
    _evhtp_uri_free(request->uri);
    evhtp_kvs_free(request->headers_in);
    evhtp_kvs_free(request->headers_out);
    if(!(request->conn == ((struct evhtp_connection_s *)NULL)))
    {
      if(request->conn->request == request)
        request->conn->request = (struct evhtp_request_s *)(void *)0;

    }

    if(!(request->buffer_in == ((struct evbuffer *)NULL)))
      evbuffer_free(request->buffer_in);

    if(!(request->buffer_out == ((struct evbuffer *)NULL)))
      evbuffer_free(request->buffer_out);

    free((void *)request->hooks);
    free((void *)request);
  }

}

// _evhtp_request_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 706
static struct evhtp_request_s * _evhtp_request_new(struct evhtp_connection_s *c)
{
  struct evhtp_request_s *req;
  unsigned char error;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct evhtp_request_s) /*112ul*/ , (unsigned long int)1);
  req = (struct evhtp_request_s *)return_value_calloc_1;
  struct evhtp_s *tmp_if_expr_2;
  if(req == ((struct evhtp_request_s *)NULL))
    return (struct evhtp_request_s *)(void *)0;

  else
  {
    error = (unsigned char)1;
    req->conn = c;
    if(!(c == ((struct evhtp_connection_s *)NULL)))
      tmp_if_expr_2 = c->htp;

    else
      tmp_if_expr_2 = (struct evhtp_s *)(void *)0;
    req->htp = tmp_if_expr_2;
    req->status = (unsigned short int)200;
    do
    {
      req->buffer_in=evbuffer_new();
      if(req->buffer_in == ((struct evbuffer *)NULL))
        break;

      req->buffer_out=evbuffer_new();
      if(req->buffer_out == ((struct evbuffer *)NULL))
        break;

      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct evhtp_kvs_s) /*16ul*/ );
      req->headers_in = (struct evhtp_kvs_s *)return_value_malloc_3;
      if(req->headers_in == ((struct evhtp_kvs_s *)NULL))
        break;

      void *return_value_malloc_4;
      return_value_malloc_4=malloc(sizeof(struct evhtp_kvs_s) /*16ul*/ );
      req->headers_out = (struct evhtp_kvs_s *)return_value_malloc_4;
      if(req->headers_out == ((struct evhtp_kvs_s *)NULL))
        break;

      do
      {
        req->headers_in->tqh_first = (struct evhtp_kv_s *)(void *)0;
        req->headers_in->tqh_last = &req->headers_in->tqh_first;
      }
      while((_Bool)0);
      do
      {
        req->headers_out->tqh_first = (struct evhtp_kv_s *)(void *)0;
        req->headers_out->tqh_last = &req->headers_out->tqh_first;
      }
      while((_Bool)0);
      error = (unsigned char)0;
    }
    while((_Bool)0);
    if((signed int)error == 0)
      return req;

    else
    {
      _evhtp_request_free(req);
      return (struct evhtp_request_s *)(void *)0;
    }
  }
}

// _evhtp_request_parser_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1021
static signed int _evhtp_request_parser_args(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  struct evhtp_uri_s *uri = c->request->uri;
  const char *fragment;
  signed int ignore_fragment;
  void *return_value_memchr_3;
  if((signed int)c->type == evhtp_type_client)
    return 0;

  else
  {
    ignore_fragment = c->htp->parser_flags & 1 << 4;
    if(ignore_fragment == 0)
    {
      return_value_memchr_3=memchr((const void *)data, 35, len);
      fragment = (const char *)return_value_memchr_3;
      if(!(fragment == ((const char *)NULL)))
      {
        signed long int frag_offset = fragment - data;
        if(!((unsigned long int)frag_offset >= len))
        {
          unsigned long int fraglen;
          fragment = fragment + (signed long int)1;
          frag_offset = frag_offset + (signed long int)1;
          fraglen = len - (unsigned long int)frag_offset;
          void *return_value_malloc_2;
          return_value_malloc_2=malloc(fraglen + (unsigned long int)1);
          uri->fragment = (unsigned char *)return_value_malloc_2;
          do
            if(uri->fragment == ((unsigned char *)NULL))
            {
              fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_parser_args", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1062);
              fflush(stderr);
              abort();
            }

          while((_Bool)0);
          memcpy((void *)uri->fragment, (const void *)fragment, fraglen);
          uri->fragment[(signed long int)fraglen] = (unsigned char)0;
          len = len - (fraglen + (unsigned long int)1);
        }

      }

    }

    uri->query=evhtp_parse_query_wflags(data, len, c->htp->parser_flags);
    if(uri->query == ((struct evhtp_kvs_s *)NULL))
    {
      c->request->status = (unsigned short int)0;
      return -1;
    }

    else
    {
      void *return_value_malloc_4;
      return_value_malloc_4=malloc(len + (unsigned long int)1);
      uri->query_raw = (unsigned char *)return_value_malloc_4;
      do
        if(uri->query_raw == ((unsigned char *)NULL))
        {
          fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_parser_args", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1080);
          fflush(stderr);
          abort();
        }

      while((_Bool)0);
      memcpy((void *)uri->query_raw, (const void *)data, len);
      uri->query_raw[(signed long int)len] = (unsigned char)0;
      return 0;
    }
  }
}

// _evhtp_request_parser_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1451
static signed int _evhtp_request_parser_body(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  struct evbuffer *buf;
  signed int res = 0;
  if(c->max_body_size >= 1ul)
  {
    if(!(c->body_bytes_read + len >= c->max_body_size))
      goto __CPROVER_DUMP_L1;

    c->error = (unsigned char)1;
    c->request->status = (unsigned short int)4;
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    buf = c->scratch_buf;
    do
      if(buf == ((struct evbuffer *)NULL))
      {
        fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"buf != NULL", (const void *)"_evhtp_request_parser_body", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1464);
        fflush(stderr);
        abort();
      }

    while((_Bool)0);
    evbuffer_add(buf, (const void *)data, len);
    c->request->status=_evhtp_body_hook(c->request, buf);
    if(!((signed int)c->request->status == 200))
      res = -1;

    unsigned long int return_value_evbuffer_get_length_2;
    return_value_evbuffer_get_length_2=evbuffer_get_length(buf);
    if(!(return_value_evbuffer_get_length_2 == 0ul))
      evbuffer_add_buffer(c->request->buffer_in, buf);

    evbuffer_drain(buf, (unsigned long int)-1);
    c->body_bytes_read = c->body_bytes_read + len;
    return res;
  }
}

// _evhtp_request_parser_chunk_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1497
static signed int _evhtp_request_parser_chunk_fini(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  c->request->status=_evhtp_chunk_fini_hook(c->request);
  if(!((signed int)c->request->status == 200))
    return -1;

  else
    return 0;
}

// _evhtp_request_parser_chunk_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1485
static signed int _evhtp_request_parser_chunk_new(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  unsigned long int return_value_htparser_get_content_length_2;
  return_value_htparser_get_content_length_2=htparser_get_content_length(p);
  c->request->status=_evhtp_chunk_new_hook(c->request, return_value_htparser_get_content_length_2);
  if(!((signed int)c->request->status == 200))
    return -1;

  else
    return 0;
}

// _evhtp_request_parser_chunks_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1508
static signed int _evhtp_request_parser_chunks_fini(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  c->request->status=_evhtp_chunks_fini_hook(c->request);
  if(!((signed int)c->request->status == 200))
    return -1;

  else
    return 0;
}

// _evhtp_request_parser_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1563
static signed int _evhtp_request_parser_fini(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  if((signed int)c->paused == 1)
    return -1;

  else
  {
    signed int return_value__evhtp_should_parse_query_body_4;
    return_value__evhtp_should_parse_query_body_4=_evhtp_should_parse_query_body(c->request);
    if(return_value__evhtp_should_parse_query_body_4 == 1)
    {
      const char *body;
      unsigned long int body_len;
      struct evhtp_uri_s *uri;
      struct evbuffer *buf_in;
      uri = c->request->uri;
      buf_in = c->request->buffer_in;
      body_len=evbuffer_get_length(buf_in);
      unsigned char *return_value_evbuffer_pullup_2;
      return_value_evbuffer_pullup_2=evbuffer_pullup(buf_in, (signed long int)body_len);
      body = (const char *)return_value_evbuffer_pullup_2;
      void *return_value_calloc_3;
      return_value_calloc_3=calloc(body_len + (unsigned long int)1, (unsigned long int)1);
      uri->query_raw = (unsigned char *)return_value_calloc_3;
      do
        if(uri->query_raw == ((unsigned char *)NULL))
        {
          fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_parser_fini", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1586);
          fflush(stderr);
          abort();
        }

      while((_Bool)0);
      memcpy((void *)uri->query_raw, (const void *)body, body_len);
      uri->query=evhtp_parse_query(body, body_len);
    }

    if(!(c->request == ((struct evhtp_request_s *)NULL)))
    {
      if(!(c->request->cb == ((void (*)(struct evhtp_request_s *, void *))NULL)))
        c->request->cb(c->request, c->request->cbarg);

    }

    if((signed int)c->paused == 1)
      return -1;

    else
      return 0;
  }
}

// _evhtp_request_parser_header_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1100
static signed int _evhtp_request_parser_header_key(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  char *key_s;
  struct evhtp_kv_s *hdr;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(len + (unsigned long int)1);
  key_s = (char *)return_value_malloc_2;
  do
    if(key_s == ((char *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_parser_header_key", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1106);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  key_s[(signed long int)len] = (char)0;
  memcpy((void *)key_s, (const void *)data, len);
  hdr=evhtp_header_key_add(c->request->headers_in, key_s, (char)0);
  if(hdr == ((struct evhtp_kv_s *)NULL))
  {
    c->request->status = (unsigned short int)2;
    return -1;
  }

  else
  {
    hdr->k_heaped = (char)1;
    return 0;
  }
}

// _evhtp_request_parser_header_val
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1123
static signed int _evhtp_request_parser_header_val(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  char *val_s;
  struct evhtp_kv_s *header;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(len + (unsigned long int)1);
  val_s = (char *)return_value_malloc_2;
  do
    if(val_s == ((char *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_parser_header_val", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1129);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  val_s[(signed long int)len] = (char)0;
  memcpy((void *)val_s, (const void *)data, len);
  header=evhtp_header_val_add(c->request->headers_in, val_s, (char)0);
  if(header == ((struct evhtp_kv_s *)NULL))
  {
    do
    {
      free((void *)val_s);
      val_s = (char *)(void *)0;
    }
    while((_Bool)0);
    c->request->status = (unsigned short int)2;
    return -1;
  }

  else
  {
    header->v_heaped = (char)1;
    c->request->status=_evhtp_header_hook(c->request, header);
    if(!((signed int)c->request->status == 200))
      return -1;

    else
      return 0;
  }
}

// _evhtp_request_parser_headers
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1418
static signed int _evhtp_request_parser_headers(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  do
    if(c == ((struct evhtp_connection_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"c != NULL", (const void *)"_evhtp_request_parser_headers", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1422);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  signed int return_value_htparser_should_keep_alive_2;
  return_value_htparser_should_keep_alive_2=htparser_should_keep_alive(p);
  c->request->keepalive = (unsigned char)return_value_htparser_should_keep_alive_2;
  unsigned char return_value_htparser_get_major_3;
  return_value_htparser_get_major_3=htparser_get_major(p);
  unsigned char return_value_htparser_get_minor_4;
  return_value_htparser_get_minor_4=htparser_get_minor(p);
  c->request->proto=_evhtp_protocol((const char)return_value_htparser_get_major_3, (const char)return_value_htparser_get_minor_4);
  c->request->status=_evhtp_headers_hook(c->request, c->request->headers_in);
  if(!((signed int)c->request->status == 200))
    return -1;

  else
  {
    if((signed int)c->type == evhtp_type_server)
    {
      if((signed int)c->htp->disable_100_cont == 0)
      {
        const char *return_value_evhtp_kv_find_5;
        return_value_evhtp_kv_find_5=evhtp_kv_find(c->request->headers_in, "Expect");
        if(return_value_evhtp_kv_find_5 == ((const char *)NULL))
          return 0;

        struct evbuffer *return_value_bufferevent_get_output_6;
        return_value_bufferevent_get_output_6=bufferevent_get_output(c->bev);
        unsigned char return_value_htparser_get_major_7;
        return_value_htparser_get_major_7=htparser_get_major(p);
        unsigned char return_value_htparser_get_minor_8;
        return_value_htparser_get_minor_8=htparser_get_minor(p);
        evbuffer_add_printf(return_value_bufferevent_get_output_6, "HTTP/%c.%c 100 Continue\r\n\r\n", (unsigned char)(48 + (signed int)return_value_htparser_get_major_7), (unsigned char)(48 + (signed int)return_value_htparser_get_minor_8));
      }

    }

    return 0;
  }
}

// _evhtp_request_parser_headers_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1089
static signed int _evhtp_request_parser_headers_start(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  c->request->status=_evhtp_headers_start_hook(c->request);
  if(!((signed int)c->request->status == 200))
    return -1;

  else
    return 0;
}

// _evhtp_request_parser_host
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1337
static signed int _evhtp_request_parser_host(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  struct evhtp_authority_s *authority;
  signed int return_value__evhtp_require_uri_2;
  return_value__evhtp_require_uri_2=_evhtp_require_uri(c);
  if(!(return_value__evhtp_require_uri_2 == 0))
    return -1;

  else
  {
    authority = c->request->uri->authority;
    void *return_value_malloc_3;
    return_value_malloc_3=malloc(len + (unsigned long int)1);
    authority->hostname = (char *)return_value_malloc_3;
    if(authority->hostname == ((char *)NULL))
    {
      c->request->status = (unsigned short int)2;
      return -1;
    }

    else
    {
      memcpy((void *)authority->hostname, (const void *)data, len);
      authority->hostname[(signed long int)len] = (char)0;
      return 0;
    }
  }
}

// _evhtp_request_parser_hostname
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1275
static signed int _evhtp_request_parser_hostname(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  struct evhtp_s *evhtp;
  struct evhtp_s *evhtp_vhost;
  if((signed int)c->vhost_via_sni == 1)
  {
    if(!(c->ssl == ((struct ssl_st *)NULL)))
    {
      const char *host;
      host=SSL_get_servername(c->ssl, 0);
      c->request->status=_evhtp_hostname_hook(c->request, host);
      if(!((signed int)c->request->status == 200))
        return -1;

      return 0;
    }

  }

  evhtp = c->htp;
  do
    if(!(evhtp->lock == ((union anonymous_8 *)NULL)))
      pthread_mutex_lock(evhtp->lock);

  while((_Bool)0);
  evhtp_vhost=_evhtp_request_find_vhost(evhtp, data);
  if(!(evhtp_vhost == ((struct evhtp_s *)NULL)))
  {
    do
      if(!(evhtp_vhost->lock == ((union anonymous_8 *)NULL)))
        pthread_mutex_lock(evhtp_vhost->lock);

    while((_Bool)0);
    c->htp = evhtp_vhost;
    c->request->htp = evhtp_vhost;
    _evhtp_request_set_callbacks(c->request);
    do
      if(!(evhtp_vhost->lock == ((union anonymous_8 *)NULL)))
        pthread_mutex_unlock(evhtp_vhost->lock);

    while((_Bool)0);
  }

  do
    if(!(evhtp->lock == ((union anonymous_8 *)NULL)))
      pthread_mutex_unlock(evhtp->lock);

  while((_Bool)0);
  c->request->status=_evhtp_hostname_hook(c->request, data);
  if(!((signed int)c->request->status == 200))
    return -1;

  else
    return 0;
}

// _evhtp_request_parser_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1386
static signed int _evhtp_request_parser_path(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  struct evhtp_path_s *path;
  signed int return_value__evhtp_require_uri_2;
  return_value__evhtp_require_uri_2=_evhtp_require_uri(c);
  if(!(return_value__evhtp_require_uri_2 == 0))
    return -1;

  else
  {
    path=_evhtp_path_new(data, len);
    if(path == ((struct evhtp_path_s *)NULL))
    {
      c->request->status = (unsigned short int)2;
      return -1;
    }

    else
    {
      c->request->uri->path = path;
      c->request->uri->scheme=htparser_get_scheme(p);
      c->request->method=htparser_get_method(p);
      do
        if(!(c->htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_lock(c->htp->lock);

      while((_Bool)0);
      _evhtp_request_set_callbacks(c->request);
      do
        if(!(c->htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(c->htp->lock);

      while((_Bool)0);
      c->request->status=_evhtp_path_hook(c->request, path);
      if(!((signed int)c->request->status == 200))
        return -1;

      else
        return 0;
    }
  }
}

// _evhtp_request_parser_port
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1361
static signed int _evhtp_request_parser_port(struct htparser *p, const char *data, unsigned long int len)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  struct evhtp_authority_s *authority;
  char *endptr;
  unsigned long int port;
  signed int return_value__evhtp_require_uri_2;
  return_value__evhtp_require_uri_2=_evhtp_require_uri(c);
  if(!(return_value__evhtp_require_uri_2 == 0))
    return -1;

  else
  {
    authority = c->request->uri->authority;
    port=strtoul(data, &endptr, 10);
    if(port >= 65536ul || !((unsigned long int)(endptr - data) == len))
    {
      c->request->status = (unsigned short int)2;
      return -1;
    }

    else
    {
      authority->port = (unsigned short int)port;
      return 0;
    }
  }
}

// _evhtp_request_parser_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 994
static signed int _evhtp_request_parser_start(struct htparser *p)
{
  struct evhtp_connection_s *c;
  void *return_value_htparser_get_userdata_1;
  return_value_htparser_get_userdata_1=htparser_get_userdata(p);
  c = (struct evhtp_connection_s *)return_value_htparser_get_userdata_1;
  if((signed int)c->type == evhtp_type_client)
    return 0;

  else
    if((signed int)c->paused == 1)
      return -1;

    else
      if(!(c->request == ((struct evhtp_request_s *)NULL)))
      {
        if((signed int)c->request->finished == 1)
        {
          _evhtp_request_free(c->request);
          goto __CPROVER_DUMP_L4;
        }

        return -1;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        c->request=_evhtp_request_new(c);
        if(c->request == ((struct evhtp_request_s *)NULL))
          return -1;

        else
          return 0;
      }
}

// _evhtp_request_set_callbacks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1179
static inline signed int _evhtp_request_set_callbacks(struct evhtp_request_s *request)
{
  struct evhtp_s *evhtp;
  struct evhtp_connection_s *conn;
  struct evhtp_uri_s *uri;
  struct evhtp_path_s *path;
  struct evhtp_hooks_s *hooks;
  struct evhtp_callback_s *callback;
  void (*cb)(struct evhtp_request_s *, void *);
  void *cbarg;
  if(request == ((struct evhtp_request_s *)NULL))
    return -1;

  else
  {
    evhtp = request->htp;
    if(evhtp == ((struct evhtp_s *)NULL))
      return -1;

    else
    {
      conn = request->conn;
      if(conn == ((struct evhtp_connection_s *)NULL))
        return -1;

      else
      {
        uri = request->uri;
        if(uri == ((struct evhtp_uri_s *)NULL))
          return -1;

        else
        {
          path = uri->path;
          if(path == ((struct evhtp_path_s *)NULL))
            return -1;

          else
          {
            hooks = (struct evhtp_hooks_s *)(void *)0;
            callback = (struct evhtp_callback_s *)(void *)0;
            cb = (void (*)(struct evhtp_request_s *, void *))(void *)0;
            cbarg = (void *)0;
            callback=_evhtp_callback_find(evhtp->callbacks, path->full, &path->matched_soff, &path->matched_eoff);
            if(!(callback == ((struct evhtp_callback_s *)NULL)))
            {
              cb = callback->cb;
              cbarg = callback->cbarg;
              hooks = callback->hooks;
            }

            else
            {
              callback=_evhtp_callback_find(evhtp->callbacks, path->path, &path->matched_soff, &path->matched_eoff);
              if(!(callback == ((struct evhtp_callback_s *)NULL)))
              {
                cb = callback->cb;
                cbarg = callback->cbarg;
                hooks = callback->hooks;
              }

              else
              {
                cb = evhtp->defaults.cb;
                cbarg = evhtp->defaults.cbarg;
                path->matched_soff = (unsigned int)0;
                unsigned long int return_value_strlen_1;
                return_value_strlen_1=strlen(path->full);
                path->matched_eoff = (unsigned int)return_value_strlen_1;
              }
            }
            if(path->match_start == ((char *)NULL))
            {
              unsigned long int return_value_strlen_2;
              return_value_strlen_2=strlen(path->full);
              void *return_value_calloc_3;
              return_value_calloc_3=calloc(return_value_strlen_2 + (unsigned long int)1, (unsigned long int)1);
              path->match_start = (char *)return_value_calloc_3;
              do
                if(path->match_start == ((char *)NULL))
                {
                  fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_set_callbacks", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1237);
                  fflush(stderr);
                  abort();
                }

              while((_Bool)0);
            }

            if(path->match_end == ((char *)NULL))
            {
              unsigned long int return_value_strlen_4;
              return_value_strlen_4=strlen(path->full);
              void *return_value_calloc_5;
              return_value_calloc_5=calloc(return_value_strlen_4 + (unsigned long int)1, (unsigned long int)1);
              path->match_end = (char *)return_value_calloc_5;
              do
                if(path->match_end == ((char *)NULL))
                {
                  fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_set_callbacks", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1242);
                  fflush(stderr);
                  abort();
                }

              while((_Bool)0);
            }

            if(!(path->matched_soff == 1U))
            {
              if(!(path->matched_eoff == path->matched_soff))
                memcpy((void *)path->match_start, (void *)(path->full + (signed long int)path->matched_soff), (unsigned long int)(path->matched_eoff - path->matched_soff));

              else
              {
                unsigned long int return_value_strlen_6;
                return_value_strlen_6=strlen((const char *)(path->full + (signed long int)path->matched_soff));
                memcpy((void *)path->match_start, (void *)(path->full + (signed long int)path->matched_soff), return_value_strlen_6);
              }
              unsigned long int return_value_strlen_7;
              return_value_strlen_7=strlen(path->full);
              memcpy((void *)path->match_end, (void *)(path->full + (signed long int)path->matched_eoff), return_value_strlen_7 - (unsigned long int)path->matched_eoff);
            }

            if(!(hooks == ((struct evhtp_hooks_s *)NULL)))
            {
              if(request->hooks == ((struct evhtp_hooks_s *)NULL))
              {
                void *return_value_malloc_8;
                return_value_malloc_8=malloc(sizeof(struct evhtp_hooks_s) /*240ul*/ );
                request->hooks = (struct evhtp_hooks_s *)return_value_malloc_8;
                do
                  if(request->hooks == ((struct evhtp_hooks_s *)NULL))
                  {
                    fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_request_set_callbacks", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1262);
                    fflush(stderr);
                    abort();
                  }

                while((_Bool)0);
              }

              memcpy((void *)request->hooks, (const void *)hooks, sizeof(struct evhtp_hooks_s) /*240ul*/ );
            }

            request->cb = cb;
            request->cbarg = cbarg;
            return 0;
          }
        }
      }
    }
  }
}

// _evhtp_require_uri
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1327
static signed int _evhtp_require_uri(struct evhtp_connection_s *c)
{
  if(!(c == ((struct evhtp_connection_s *)NULL)))
  {
    if(!(c->request == ((struct evhtp_request_s *)NULL)))
    {
      if(c->request->uri == ((struct evhtp_uri_s *)NULL))
      {
        c->request->uri=_evhtp_uri_new();
        do
          if(c->request->uri == ((struct evhtp_uri_s *)NULL))
          {
            fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"_evhtp_require_uri", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 1330);
            fflush(stderr);
            abort();
          }

        while((_Bool)0);
      }

    }

  }

  return 0;
}

// _evhtp_run_in_thread
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2145
static void _evhtp_run_in_thread(struct evthr *thr, void *arg, void *shared)
{
  struct evhtp_s *htp = (struct evhtp_s *)shared;
  struct evhtp_connection_s *connection = (struct evhtp_connection_s *)arg;
  connection->evbase=evthr_get_base(thr);
  connection->thread = thr;
  signed int return_value__evhtp_connection_accept_1;
  return_value__evhtp_connection_accept_1=_evhtp_connection_accept(connection->evbase, connection);
  if(!(return_value__evhtp_connection_accept_1 >= 0))
    evhtp_connection_free(connection);

  else
  {
    signed int return_value__evhtp_run_post_accept_2;
    return_value__evhtp_run_post_accept_2=_evhtp_run_post_accept(htp, connection);
    if(!(return_value__evhtp_run_post_accept_2 >= 0))
      evhtp_connection_free(connection);

  }
}

// _evhtp_run_post_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2125
static signed int _evhtp_run_post_accept(struct evhtp_s *htp, struct evhtp_connection_s *connection)
{
  void *args;
  unsigned short int res;
  if(htp->defaults.post_accept == ((unsigned short int (*)(struct evhtp_connection_s *, void *))NULL))
    return 0;

  else
  {
    args = htp->defaults.post_accept_cbarg;
    res=htp->defaults.post_accept(connection, args);
    if(!((signed int)res == 200))
      return -1;

    else
      return 0;
  }
}

// _evhtp_run_pre_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1980
static signed int _evhtp_run_pre_accept(struct evhtp_s *htp, struct evhtp_connection_s *conn)
{
  void *args;
  unsigned short int res;
  if(htp->defaults.pre_accept == ((unsigned short int (*)(struct evhtp_connection_s *, void *))NULL))
    return 0;

  else
  {
    args = htp->defaults.pre_accept_cbarg;
    res=htp->defaults.pre_accept(conn, args);
    if(!((signed int)res == 200))
      return -1;

    else
      return 0;
  }
}

// _evhtp_should_parse_query_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 1529
static signed int _evhtp_should_parse_query_body(struct evhtp_request_s *req)
{
  const char *content_type;
  _Bool tmp_if_expr_1;
  if(req == ((struct evhtp_request_s *)NULL))
    return 0;

  else
  {
    if(req->uri == ((struct evhtp_uri_s *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = req->uri->query != (struct evhtp_kvs_s *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 0;

    else
    {
      unsigned long int return_value_htparser_get_content_length_2;
      return_value_htparser_get_content_length_2=htparser_get_content_length(req->conn->parser);
      if(return_value_htparser_get_content_length_2 == 0ul)
        return 0;

      else
      {
        unsigned long int return_value_htparser_get_content_length_3;
        return_value_htparser_get_content_length_3=htparser_get_content_length(req->conn->parser);
        unsigned long int return_value_evbuffer_get_length_4;
        return_value_evbuffer_get_length_4=evbuffer_get_length(req->buffer_in);
        if(!(return_value_htparser_get_content_length_3 == return_value_evbuffer_get_length_4))
          return 0;

        else
        {
          content_type=evhtp_kv_find(req->headers_in, "content-type");
          if(content_type == ((const char *)NULL))
            return 0;

          else
          {
            signed int return_value_strncasecmp_5;
            return_value_strncasecmp_5=strncasecmp(content_type, "application/x-www-form-urlencoded", (unsigned long int)33);
            if(!(return_value_strncasecmp_5 == 0))
              return 0;

            else
              return 1;
          }
        }
      }
    }
  }
}

// _evhtp_ssl_add_scache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2255
static signed int _evhtp_ssl_add_scache_ent(struct ssl_st *ssl, struct ssl_session_st *sess)
{
  struct evhtp_connection_s *connection;
  struct evhtp_ssl_cfg_s *cfg;
  unsigned char *sid;
  signed int slen;
  void *return_value_SSL_get_ex_data_1;
  return_value_SSL_get_ex_data_1=SSL_get_ex_data(ssl, 0);
  connection = (struct evhtp_connection_s *)return_value_SSL_get_ex_data_1;
  cfg = connection->htp->ssl_cfg;
  sid = sess->session_id;
  slen = (signed int)sess->session_id_length;
  SSL_SESSION_set_timeout(sess, cfg->scache_timeout);
  if(!(cfg->scache_add == ((signed int (*)(struct evhtp_connection_s *, unsigned char *, signed int, struct ssl_session_st *))NULL)))
  {
    signed int return_value;
    return_value=cfg->scache_add(connection, sid, slen, sess);
    return return_value;
  }

  return 0;
}

// _evhtp_ssl_delete_scache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2237
static void _evhtp_ssl_delete_scache_ent(struct ssl_ctx_st *ctx, struct ssl_session_st *sess)
{
  struct evhtp_s *htp;
  struct evhtp_ssl_cfg_s *cfg;
  unsigned char *sid;
  unsigned int slen;
  void *return_value_SSL_CTX_get_ex_data_1;
  return_value_SSL_CTX_get_ex_data_1=SSL_CTX_get_ex_data(ctx, 0);
  htp = (struct evhtp_s *)return_value_SSL_CTX_get_ex_data_1;
  cfg = htp->ssl_cfg;
  sid = sess->session_id;
  slen = sess->session_id_length;
  if(!(cfg->scache_del == ((void (*)(struct evhtp_s *, unsigned char *, signed int))NULL)))
    cfg->scache_del(htp, sid, (signed int)slen);

}

// _evhtp_ssl_get_scache_ent
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2277
static struct ssl_session_st * _evhtp_ssl_get_scache_ent(struct ssl_st *ssl, unsigned char *sid, signed int sid_len, signed int *copy)
{
  struct evhtp_connection_s *connection;
  struct evhtp_ssl_cfg_s *cfg;
  struct ssl_session_st *sess;
  void *return_value_SSL_get_ex_data_1;
  return_value_SSL_get_ex_data_1=SSL_get_ex_data(ssl, 0);
  connection = (struct evhtp_connection_s *)return_value_SSL_get_ex_data_1;
  cfg = connection->htp->ssl_cfg;
  sess = (struct ssl_session_st *)(void *)0;
  if(!(cfg->scache_get == ((struct ssl_session_st * (*)(struct evhtp_connection_s *, unsigned char *, signed int))NULL)))
    sess=cfg->scache_get(connection, sid, sid_len);

  *copy = 0;
  return sess;
}

// _evhtp_ssl_get_thread_id
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2214
static unsigned long int _evhtp_ssl_get_thread_id(void)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  return (unsigned long int)return_value_pthread_self_1;
}

// _evhtp_ssl_servername
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2296
static signed int _evhtp_ssl_servername(struct ssl_st *ssl, signed int *unused, void *arg)
{
  const char *sname;
  struct evhtp_connection_s *connection;
  struct evhtp_s *evhtp;
  struct evhtp_s *evhtp_vhost;
  sname=SSL_get_servername(ssl, 0);
  _Bool tmp_if_expr_7;
  signed long int return_value_SSL_ctrl_6;
  if(sname == ((const char *)NULL))
    return 3;

  else
  {
    void *return_value_SSL_get_ex_data_1;
    return_value_SSL_get_ex_data_1=SSL_get_ex_data(ssl, 0);
    connection = (struct evhtp_connection_s *)return_value_SSL_get_ex_data_1;
    if(connection == ((struct evhtp_connection_s *)NULL))
      return 3;

    else
    {
      evhtp = connection->htp;
      if(evhtp == ((struct evhtp_s *)NULL))
        return 3;

      else
      {
        evhtp_vhost=_evhtp_request_find_vhost(evhtp, sname);
        if(!(evhtp_vhost == ((struct evhtp_s *)NULL)))
        {
          connection->htp = evhtp_vhost;
          connection->vhost_via_sni = (unsigned char)1;
          SSL_set_SSL_CTX(ssl, evhtp_vhost->ssl_ctx);
          signed long int return_value_SSL_CTX_ctrl_2;
          return_value_SSL_CTX_ctrl_2=SSL_CTX_ctrl(ssl->ctx, 32, (signed long int)0, (void *)0);
          SSL_ctrl(ssl, 32, return_value_SSL_CTX_ctrl_2, (void *)0);
          signed int return_value_SSL_get_verify_mode_5;
          return_value_SSL_get_verify_mode_5=SSL_get_verify_mode(ssl);
          if(return_value_SSL_get_verify_mode_5 == 0x00)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_SSL_ctrl_6=SSL_ctrl(ssl, 10, (signed long int)0, (void *)0);
            tmp_if_expr_7 = return_value_SSL_ctrl_6 == (signed long int)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
          {
            signed int return_value_SSL_CTX_get_verify_mode_3;
            return_value_SSL_CTX_get_verify_mode_3=SSL_CTX_get_verify_mode(ssl->ctx);
            signed int (*return_value_SSL_CTX_get_verify_callback_4)(signed int, struct x509_store_ctx_st *);
            return_value_SSL_CTX_get_verify_callback_4=SSL_CTX_get_verify_callback(ssl->ctx);
            SSL_set_verify(ssl, return_value_SSL_CTX_get_verify_mode_3, return_value_SSL_CTX_get_verify_callback_4);
          }

          return 0;
        }

        return 3;
      }
    }
  }
}

// _evhtp_ssl_thread_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2225
static void _evhtp_ssl_thread_lock(signed int mode, signed int type, const char *file, signed int line)
{
  if(!(type >= ssl_num_locks))
  {
    if(!((1 & mode) == 0))
      pthread_mutex_lock(&ssl_locks[(signed long int)type]);

    else
      pthread_mutex_unlock(&ssl_locks[(signed long int)type]);
  }

}

// _evhtp_thread_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3598
static void _evhtp_thread_init(struct evthr *thr, void *arg)
{
  struct evhtp_s *htp = (struct evhtp_s *)arg;
  if(!(htp->thread_init_cb == ((void (*)(struct evhtp_s *, struct evthr *, void *))NULL)))
    htp->thread_init_cb(htp, thr, htp->thread_init_cbarg);

}

// _evhtp_uri_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 848
static void _evhtp_uri_free(struct evhtp_uri_s *uri)
{
  if(!(uri == ((struct evhtp_uri_s *)NULL)))
  {
    do
    {
      evhtp_kvs_free(uri->query);
      uri->query = (struct evhtp_kvs_s *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      _evhtp_path_free(uri->path);
      uri->path = (struct evhtp_path_s *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      _evhtp_authority_free(uri->authority);
      uri->authority = (struct evhtp_authority_s *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)uri->fragment);
      uri->fragment = (unsigned char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)uri->query_raw);
      uri->query_raw = (unsigned char *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)uri);
      uri = (struct evhtp_uri_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// _evhtp_uri_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 790
static struct evhtp_uri_s * _evhtp_uri_new(void)
{
  struct evhtp_uri_s *uri;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct evhtp_uri_s) /*48ul*/ , (unsigned long int)1);
  uri = (struct evhtp_uri_s *)return_value_calloc_1;
  if(uri == ((struct evhtp_uri_s *)NULL))
    return (struct evhtp_uri_s *)(void *)0;

  else
  {
    uri->authority=_evhtp_authority_new();
    if(uri->authority == ((struct evhtp_authority_s *)NULL))
    {
      _evhtp_uri_free(uri);
      return (struct evhtp_uri_s *)(void *)0;
    }

    else
      return uri;
  }
}

// _evthr_loop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 95
static void * _evthr_loop(void *args)
{
  struct evthr *thread = (struct evthr *)args;
  _Bool tmp_if_expr_1;
  if(thread == ((struct evthr *)NULL))
    return (void *)0;

  else
  {
    if(thread == ((struct evthr *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = thread->thr == (unsigned long int *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      pthread_exit((void *)0);

    thread->evbase=event_base_new();
    thread->event=event_new(thread->evbase, thread->rdr, (signed short int)(0x02 | 0x10), _evthr_read_cmd, args);
    event_add(thread->event, (struct timeval *)(void *)0);
    pthread_mutex_lock(&thread->lock);
    if(!(thread->init_cb == ((void (*)(struct evthr *, void *))NULL)))
      thread->init_cb(thread, thread->arg);

    pthread_mutex_unlock(&thread->lock);
    event_base_loop(thread->evbase, 0);
    if((signed int)thread->err == 1)
      fprintf(stderr, "FATAL ERROR!\n");

    pthread_exit((void *)0);
  }
}

// _evthr_read_cmd
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 68
static void _evthr_read_cmd(signed int sock, signed short int which, void *args)
{
  struct evthr *thread;
  struct evthr_cmd cmd;
  signed int stopped;
  thread = (struct evthr *)args;
  if(!(thread == ((struct evthr *)NULL)))
  {
    stopped = 0;
    signed long int return_value_recv_1;
    return_value_recv_1=recv(sock, (void *)&cmd, sizeof(struct evthr_cmd) /*17ul*/ , 0);
    if((unsigned long int)return_value_recv_1 == sizeof(struct evthr_cmd) /*17ul*/ )
    {
      stopped = (signed int)cmd.stop;
      if(!(cmd.cb == ((void (*)(struct evthr *, void *, void *))NULL)))
        cmd.cb(thread, cmd.args, thread->arg);

    }

    if(stopped == 1)
      event_base_loopbreak(thread->evbase);

    goto __CPROVER_DUMP_L4;
  }


__CPROVER_DUMP_L4:
  ;
}

// _owned_eventcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 120
static void _owned_eventcb(struct bufferevent *bev, signed short int events, void *arg)
{
  bufferevent_free(bev);
}

// _owned_readcb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 114
static void _owned_readcb(struct bufferevent *bev, void *arg)
{
  struct evbuffer *return_value_bufferevent_get_input_1;
  return_value_bufferevent_get_input_1=bufferevent_get_input(bev);
  bufferevent_write_buffer(bev, return_value_bufferevent_get_input_1);
}

// create_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 155
static void create_callback(struct evhtp_request_s *r, void *arg)
{
  char *uri;
  char *nuri;
  unsigned long int urilen;
  uri = r->uri->path->match_start;
  urilen=strlen(uri);
  if(urilen == 0ul)
    evhtp_send_reply(r, (unsigned short int)400);

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(urilen + (unsigned long int)2, (unsigned long int)1);
    nuri = (char *)return_value_calloc_1;
    snprintf(nuri, urilen + (unsigned long int)2, "/%s", uri);
    evhtp_set_cb(r->htp, nuri, dynamic_cb, (void *)nuri);
    evhtp_send_reply(r, (unsigned short int)200);
  }
}

// dummy_check_issued_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 410
static signed int dummy_check_issued_cb(struct x509_store_ctx_st *ctx, struct x509_st *x, struct x509_st *issuer)
{
  return 1;
}

// dummy_ssl_verify_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 405
static signed int dummy_ssl_verify_callback(signed int ok, struct x509_store_ctx_st *x509_store)
{
  return 1;
}

// dynamic_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 147
static void dynamic_cb(struct evhtp_request_s *r, void *arg)
{
  const char *name = (const char *)arg;
  evbuffer_add_printf(r->buffer_out, "dynamic_cb = %s\n", name);
  evhtp_send_reply(r, (unsigned short int)200);
}

// evhtp_add_alias
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4082
signed int evhtp_add_alias(struct evhtp_s *evhtp, const char *name)
{
  struct evhtp_alias_s *alias;
  if(name == ((const char *)NULL) || evhtp == ((struct evhtp_s *)NULL))
    return -1;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct evhtp_alias_s) /*24ul*/ , (unsigned long int)1);
    alias = (struct evhtp_alias_s *)return_value_calloc_1;
    if(alias == ((struct evhtp_alias_s *)NULL))
      return -1;

    else
    {
      alias->alias=strdup(name);
      do
        if(alias->alias == ((char *)NULL))
        {
          fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_add_alias", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 4094);
          fflush(stderr);
          abort();
        }

      while((_Bool)0);
      do
      {
        alias->next.tqe_next = (struct evhtp_alias_s *)(void *)0;
        alias->next.tqe_prev = (&evhtp->aliases)->tqh_last;
        *(&evhtp->aliases)->tqh_last = alias;
        (&evhtp->aliases)->tqh_last = &alias->next.tqe_next;
      }
      while((_Bool)0);
      return 0;
    }
  }
}

// evhtp_add_vhost
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4118
signed int evhtp_add_vhost(struct evhtp_s *evhtp, const char *name, struct evhtp_s *vhost)
{
  if(name == ((const char *)NULL) || evhtp == ((struct evhtp_s *)NULL) || vhost == ((struct evhtp_s *)NULL))
    return -1;

  else
    if(!(vhost->vhosts.tqh_first == ((struct evhtp_s *)NULL)))
      return -1;

    else
    {
      vhost->server_name=strdup(name);
      if(vhost->server_name == ((char *)NULL))
        return -1;

      else
      {
        vhost->parent = evhtp;
        vhost->bev_flags = evhtp->bev_flags;
        vhost->max_body_size = evhtp->max_body_size;
        vhost->max_keepalive_requests = evhtp->max_keepalive_requests;
        vhost->recv_timeo = evhtp->recv_timeo;
        vhost->send_timeo = evhtp->send_timeo;
        do
        {
          vhost->next_vhost.tqe_next = (struct evhtp_s *)(void *)0;
          vhost->next_vhost.tqe_prev = (&evhtp->vhosts)->tqh_last;
          *(&evhtp->vhosts)->tqh_last = vhost;
          (&evhtp->vhosts)->tqh_last = &vhost->next_vhost.tqe_next;
        }
        while((_Bool)0);
        return 0;
      }
    }
}

// evhtp_bind_sockaddr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3182
signed int evhtp_bind_sockaddr(struct evhtp_s *htp, struct sockaddr *sa, unsigned long int sin_len, signed int backlog)
{
  signal(13, (void (*)(signed int))1);
  signed int fd;
  signed int on = 1;
  fd=socket((signed int)sa->sa_family, 1, 0);
  do
    if(fd == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      fprintf(stderr, "%s [%d] (%s:%s:%d)\n", return_value_strerror_2, *return_value___errno_location_3, (const void *)"evhtp_bind_sockaddr", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 3190);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  evutil_make_socket_closeonexec(fd);
  evutil_make_socket_nonblocking(fd);
  setsockopt(fd, 1, 9, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  setsockopt(fd, 1, 2, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if((signed int)sa->sa_family == 10)
  {
    signed int rc;
    rc=setsockopt(fd, 41, 26, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
    do
      if(rc == -1)
      {
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        char *return_value_strerror_5;
        return_value_strerror_5=strerror(*return_value___errno_location_4);
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        fprintf(stderr, "%s [%d] (%s:%s:%d)\n", return_value_strerror_5, *return_value___errno_location_6, (const void *)"evhtp_bind_sockaddr", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 3202);
        fflush(stderr);
        abort();
      }

    while((_Bool)0);
  }

  if(!(htp->enable_reuseport == 0))
    setsockopt(fd, 1, 15, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );

  if((signed int)htp->enable_nodelay == 1)
    setsockopt(fd, 6, 1, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );

  if((signed int)htp->enable_defer_accept == 1)
    setsockopt(fd, 6, 9, (void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );

  do
  {
    signed int return_value_bind_10;
    return_value_bind_10=bind(fd, sa, (unsigned int)sin_len);
    if(return_value_bind_10 == -1)
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      fprintf(stderr, "%s [%d] (%s:%s:%d)\n", return_value_strerror_8, *return_value___errno_location_9, (const void *)"evhtp_bind_sockaddr", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 3223);
      fflush(stderr);
      abort();
    }

  }
  while((_Bool)0);
  htp->server=evconnlistener_new(htp->evbase, _evhtp_accept_cb, (void *)htp, 1u << 1 | 1u << 3, backlog, fd);
  do
    if(htp->server == ((struct evconnlistener *)NULL))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(*return_value___errno_location_11);
      signed int *return_value___errno_location_13;
      return_value___errno_location_13=__errno_location();
      fprintf(stderr, "%s [%d] (%s:%s:%d)\n", return_value_strerror_12, *return_value___errno_location_13, (const void *)"evhtp_bind_sockaddr", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 3228);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  if(!(htp->ssl_ctx == ((struct ssl_ctx_st *)NULL)))
  {
    if(!(htp->vhosts.tqh_first == ((struct evhtp_s *)NULL)))
      SSL_CTX_callback_ctrl(htp->ssl_ctx, 53, (void (*)(void))_evhtp_ssl_servername);

  }

  return 0;
}

// evhtp_bind_socket
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 811
signed int evhtp_bind_socket(struct evhtp_s *htp, const char *baddr, unsigned short int port, signed int backlog)
{
  struct sockaddr_un sun;
  struct sockaddr_in6 sin6;
  struct sockaddr_in sin;
  struct sockaddr *sa;
  unsigned long int sin_len;
  memset((void *)&sin, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  signed int return_value_strncmp_5;
  return_value_strncmp_5=strncmp(baddr, "ipv6:", (unsigned long int)5);
  signed int return_value_strncmp_4;
  if(return_value_strncmp_5 == 0)
  {
    memset((void *)&sin6, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
    baddr = baddr + (signed long int)5;
    sin_len = sizeof(struct sockaddr_in6) /*28ul*/ ;
    sin6.sin6_port=htons(port);
    sin6.sin6_family = (unsigned short int)10;
    evutil_inet_pton(10, baddr, (void *)&sin6.sin6_addr);
    sa = (struct sockaddr *)&sin6;
  }

  else
  {
    return_value_strncmp_4=strncmp(baddr, "unix:", (unsigned long int)5);
    if(return_value_strncmp_4 == 0)
    {
      baddr = baddr + (signed long int)5;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(baddr);
      if(return_value_strlen_1 >= sizeof(char [108l]) /*108ul*/ )
        return -1;

      memset((void *)&sun, 0, sizeof(struct sockaddr_un) /*110ul*/ );
      sin_len = sizeof(struct sockaddr_un) /*110ul*/ ;
      sun.sun_family = (unsigned short int)1;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(baddr);
      strncpy(sun.sun_path, baddr, return_value_strlen_2);
      sa = (struct sockaddr *)&sun;
    }

    else
    {
      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(baddr, "ipv4:", (unsigned long int)5);
      if(return_value_strncmp_3 == 0)
        baddr = baddr + (signed long int)5;

      sin_len = sizeof(struct sockaddr_in) /*16ul*/ ;
      sin.sin_family = (unsigned short int)2;
      sin.sin_port=htons(port);
      sin.sin_addr.s_addr=inet_addr(baddr);
      sa = (struct sockaddr *)&sin;
    }
  }
  signed int return_value_evhtp_bind_sockaddr_6;
  return_value_evhtp_bind_sockaddr_6=evhtp_bind_sockaddr(htp, sa, sin_len, backlog);
  return return_value_evhtp_bind_sockaddr_6;
}

// evhtp_callback_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3365
void evhtp_callback_free(struct evhtp_callback_s *callback)
{
  if(!(callback == ((struct evhtp_callback_s *)NULL)))
    switch((signed int)callback->type)
    {
      case evhtp_callback_type_hash:
      {
        do
        {
          free((void *)callback->val.path);
          callback->val.path = (char *)(void *)0;
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L5;
      }
      case evhtp_callback_type_glob:
      {
        do
        {
          free((void *)callback->val.glob);
          callback->val.glob = (char *)(void *)0;
        }
        while((_Bool)0);
        goto __CPROVER_DUMP_L5;
      }
      case evhtp_callback_type_regex:
      {
        regfree(callback->val.regex);
        do
        {
          free((void *)callback->val.regex);
          callback->val.regex = (struct anonymous_5 *)(void *)0;
        }
        while((_Bool)0);
      }
      default:
      {

      __CPROVER_DUMP_L5:
        ;
        if(!(callback->hooks == ((struct evhtp_hooks_s *)NULL)))
          do
          {
            free((void *)callback->hooks);
            callback->hooks = (struct evhtp_hooks_s *)(void *)0;
          }
          while((_Bool)0);

        do
        {
          free((void *)callback);
          callback = (struct evhtp_callback_s *)(void *)0;
        }
        while((_Bool)0);
      }
    }

}

// evhtp_callback_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3325
struct evhtp_callback_s * evhtp_callback_new(const char *path, enum evhtp_callback_type type, void (*cb)(struct evhtp_request_s *, void *), void *arg)
{
  struct evhtp_callback_s *hcb;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct evhtp_callback_s) /*64ul*/ , (unsigned long int)1);
  hcb = (struct evhtp_callback_s *)return_value_calloc_1;
  do
    if(hcb == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_callback_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 3329);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  hcb->type = type;
  hcb->cb = cb;
  hcb->cbarg = arg;
  void *return_value_malloc_2;
  signed int return_value_regcomp_3;
  switch((signed int)type)
  {
    case evhtp_callback_type_hash:
    {
      hcb->hash=_evhtp_quick_hash(path);
      hcb->val.path=strdup(path);
      break;
    }
    case evhtp_callback_type_regex:
    {
      return_value_malloc_2=malloc(sizeof(struct anonymous_5) /*24ul*/ );
      hcb->val.regex = (struct anonymous_5 *)return_value_malloc_2;
      return_value_regcomp_3=regcomp(hcb->val.regex, (char *)path, 1 << 4);
      if(!(return_value_regcomp_3 == 0))
      {
        do
        {
          free((void *)hcb->val.regex);
          hcb->val.regex = (struct anonymous_5 *)(void *)0;
        }
        while((_Bool)0);
        do
        {
          free((void *)hcb);
          hcb = (struct evhtp_callback_s *)(void *)0;
        }
        while((_Bool)0);
        return (struct evhtp_callback_s *)(void *)0;
      }

      break;
    }
    case evhtp_callback_type_glob:
    {
      hcb->val.glob=strdup(path);
      break;
    }
    default:
    {
      do
      {
        free((void *)hcb);
        hcb = (struct evhtp_callback_s *)(void *)0;
      }
      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }
  }
  return hcb;
}

// evhtp_callbacks_add_callback
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3395
signed int evhtp_callbacks_add_callback(struct evhtp_callbacks_s *cbs, struct evhtp_callback_s *cb)
{
  do
  {
    cb->next.tqe_next = (struct evhtp_callback_s *)(void *)0;
    cb->next.tqe_prev = cbs->tqh_last;
    *cbs->tqh_last = cb;
    cbs->tqh_last = &cb->next.tqe_next;
  }
  while((_Bool)0);
  return 0;
}

// evhtp_callbacks_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3307
void evhtp_callbacks_free(struct evhtp_callbacks_s *callbacks)
{
  struct evhtp_callback_s *callback;
  struct evhtp_callback_s *tmp;
  _Bool tmp_if_expr_1;
  if(!(callbacks == ((struct evhtp_callbacks_s *)NULL)))
  {
    callback = callbacks->tqh_first;
    do
    {
      if(!(callback == ((struct evhtp_callback_s *)NULL)))
      {
        tmp = callback->next.tqe_next;
        tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      do
      {
        if(!(callback->next.tqe_next == ((struct evhtp_callback_s *)NULL)))
          callback->next.tqe_next->next.tqe_prev = callback->next.tqe_prev;

        else
          callbacks->tqh_last = callback->next.tqe_prev;
        *callback->next.tqe_prev = callback->next.tqe_next;
      }
      while((_Bool)0);
      do
      {
        evhtp_callback_free(callback);
        callback = (struct evhtp_callback_s *)(void *)0;
      }
      while((_Bool)0);
      callback = tmp;
    }
    while((_Bool)1);
    do
    {
      free((void *)callbacks);
      callbacks = (struct evhtp_callbacks_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// evhtp_connection_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4000
void evhtp_connection_free(struct evhtp_connection_s *connection)
{
  if(!(connection == ((struct evhtp_connection_s *)NULL)))
  {
    _evhtp_connection_fini_hook(connection);
    do
    {
      _evhtp_request_free(connection->request);
      connection->request = (struct evhtp_request_s *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)connection->parser);
      connection->parser = (struct htparser *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)connection->hooks);
      connection->hooks = (struct evhtp_hooks_s *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      free((void *)connection->saddr);
      connection->saddr = (struct sockaddr *)(void *)0;
    }
    while((_Bool)0);
    do
    {
      evbuffer_free(connection->scratch_buf);
      connection->scratch_buf = (struct evbuffer *)(void *)0;
    }
    while((_Bool)0);
    if(!(connection->resume_ev == ((struct event *)NULL)))
      do
      {
        event_free(connection->resume_ev);
        connection->resume_ev = (struct event *)(void *)0;
      }
      while((_Bool)0);

    if(!(connection->bev == ((struct bufferevent *)NULL)))
    {
      if(!(connection->ssl == ((struct ssl_st *)NULL)))
      {
        SSL_set_shutdown(connection->ssl, 2);
        SSL_shutdown(connection->ssl);
      }

      bufferevent_free(connection->bev);
    }

    do
    {
      free((void *)connection);
      connection = (struct evhtp_connection_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// evhtp_connection_get_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3912
struct bufferevent * evhtp_connection_get_bev(struct evhtp_connection_s *connection)
{
  return connection->bev;
}

// evhtp_connection_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4229
struct evhtp_connection_s * evhtp_connection_new(struct event_base *evbase, const char *addr, unsigned short int port)
{
  struct evhtp_connection_s *return_value_evhtp_connection_new_dns_1;
  return_value_evhtp_connection_new_dns_1=evhtp_connection_new_dns(evbase, (struct evdns_base *)(void *)0, addr, port);
  return return_value_evhtp_connection_new_dns_1;
}

// evhtp_connection_new_dns
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4234
struct evhtp_connection_s * evhtp_connection_new_dns(struct event_base *evbase, struct evdns_base *dns_base, const char *addr, unsigned short int port)
{
  struct evhtp_connection_s *conn;
  signed int err;
  do
    if(evbase == ((struct event_base *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"evbase != NULL", (const void *)"evhtp_connection_new_dns", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 4239);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  conn=_evhtp_connection_new((struct evhtp_s *)(void *)0, -1, (enum evhtp_type)evhtp_type_client);
  signed int return_value_inet_pton_1;
  if(conn == ((struct evhtp_connection_s *)NULL))
    return (struct evhtp_connection_s *)(void *)0;

  else
  {
    conn->evbase = evbase;
    conn->bev=bufferevent_socket_new(evbase, -1, 1);
    if(conn->bev == ((struct bufferevent *)NULL))
    {
      evhtp_connection_free(conn);
      return (struct evhtp_connection_s *)(void *)0;
    }

    else
    {
      bufferevent_enable(conn->bev, (signed short int)0x02);
      bufferevent_setcb(conn->bev, (void (*)(struct bufferevent *, void *))(void *)0, (void (*)(struct bufferevent *, void *))(void *)0, _evhtp_connection_eventcb, (void *)conn);
      if(!(dns_base == ((struct evdns_base *)NULL)))
        err=bufferevent_socket_connect_hostname(conn->bev, dns_base, 0, addr, (signed int)port);

      else
      {
        struct sockaddr_in sin4;
        struct sockaddr_in6 sin6;
        struct sockaddr *sin;
        signed int salen;
        signed int return_value_inet_pton_2;
        return_value_inet_pton_2=inet_pton(2, addr, (void *)&sin4.sin_addr);
        if(!(return_value_inet_pton_2 == 0))
        {
          sin4.sin_family = (unsigned short int)2;
          sin4.sin_port=htons(port);
          sin = (struct sockaddr *)&sin4;
          salen = (signed int)sizeof(struct sockaddr_in) /*16ul*/ ;
        }

        else
        {
          return_value_inet_pton_1=inet_pton(10, addr, (void *)&sin6.sin6_addr);
          if(!(return_value_inet_pton_1 == 0))
          {
            sin6.sin6_family = (unsigned short int)10;
            sin6.sin6_port=htons(port);
            sin = (struct sockaddr *)&sin6;
            salen = (signed int)sizeof(struct sockaddr_in6) /*28ul*/ ;
          }

          else
          {
            evhtp_connection_free(conn);
            return (struct evhtp_connection_s *)(void *)0;
          }
        }
        err=bufferevent_socket_connect(conn->bev, sin, salen);
      }
      if(!(err == 0))
        return (struct evhtp_connection_s *)(void *)0;

      else
        return conn;
    }
  }
}

// evhtp_connection_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2354
void evhtp_connection_pause(struct evhtp_connection_s *c)
{
  do
    if(c == ((struct evhtp_connection_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"c != NULL", (const void *)"evhtp_connection_pause", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2355);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  c->paused = (unsigned char)1;
  bufferevent_disable(c->bev, (signed short int)(0x02 | 0x04));
}

// evhtp_connection_resume
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2370
void evhtp_connection_resume(struct evhtp_connection_s *c)
{
  do
    if(c == ((struct evhtp_connection_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"c != NULL", (const void *)"evhtp_connection_resume", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2371);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  c->paused = (unsigned char)0;
  event_active(c->resume_ev, 0x04, (signed short int)1);
}

// evhtp_connection_set_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3949
void evhtp_connection_set_bev(struct evhtp_connection_s *conn, struct bufferevent *bev)
{
  conn->bev = bev;
}

// evhtp_connection_set_max_body_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3986
void evhtp_connection_set_max_body_size(struct evhtp_connection_s *c, unsigned long int len)
{
  if(len == 0ul)
    c->max_body_size = c->htp->max_body_size;

  else
    c->max_body_size = len;
}

// evhtp_connection_set_timeouts
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3974
inline void evhtp_connection_set_timeouts(struct evhtp_connection_s *c, struct timeval *rtimeo, struct timeval *wtimeo)
{
  if(!(c == ((struct evhtp_connection_s *)NULL)))
    bufferevent_set_timeouts(c->bev, rtimeo, wtimeo);

}

// evhtp_connection_ssl_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4299
struct evhtp_connection_s * evhtp_connection_ssl_new(struct event_base *evbase, const char *addr, unsigned short int port, struct ssl_ctx_st *ctx)
{
  struct evhtp_connection_s *conn;
  struct sockaddr_in sin;
  do
    if(evbase == ((struct event_base *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"evbase != NULL", (const void *)"evhtp_connection_ssl_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 4303);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  conn=_evhtp_connection_new((struct evhtp_s *)(void *)0, -1, (enum evhtp_type)evhtp_type_client);
  if(conn == ((struct evhtp_connection_s *)NULL))
    return (struct evhtp_connection_s *)(void *)0;

  else
  {
    sin.sin_family = (unsigned short int)2;
    sin.sin_addr.s_addr=inet_addr(addr);
    sin.sin_port=htons(port);
    conn->ssl=SSL_new(ctx);
    conn->evbase = evbase;
    conn->bev=bufferevent_openssl_socket_new(evbase, -1, conn->ssl, (enum bufferevent_ssl_state)BUFFEREVENT_SSL_CONNECTING, 1);
    bufferevent_enable(conn->bev, (signed short int)0x02);
    bufferevent_setcb(conn->bev, (void (*)(struct bufferevent *, void *))(void *)0, (void (*)(struct bufferevent *, void *))(void *)0, _evhtp_connection_eventcb, (void *)conn);
    bufferevent_socket_connect(conn->bev, (struct sockaddr *)&sin, (signed int)sizeof(struct sockaddr_in) /*16ul*/ );
    return conn;
  }
}

// evhtp_connection_take_ownership
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1272
struct bufferevent * evhtp_connection_take_ownership(struct evhtp_connection_s *connection)
{
  struct bufferevent *bev;
  bev=evhtp_connection_get_bev(connection);
  if(!(connection->hooks == ((struct evhtp_hooks_s *)NULL)))
    evhtp_unset_all_hooks(&connection->hooks);

  if(!(connection->request == ((struct evhtp_request_s *)NULL)))
  {
    if(!(connection->request->hooks == ((struct evhtp_hooks_s *)NULL)))
      evhtp_unset_all_hooks(&connection->request->hooks);

  }

  evhtp_connection_set_bev(connection, (struct bufferevent *)(void *)0);
  connection->owner = (unsigned char)0;
  bufferevent_disable(bev, (signed short int)0x02);
  bufferevent_setcb(bev, (void (*)(struct bufferevent *, void *))(void *)0, (void (*)(struct bufferevent *, void *))(void *)0, (void (*)(struct bufferevent *, signed short int, void *))(void *)0, (void *)0);
  return bev;
}

// evhtp_disable_100_continue
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4072
void evhtp_disable_100_continue(struct evhtp_s *htp)
{
  htp->disable_100_cont = (unsigned char)1;
}

// evhtp_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 564
void evhtp_free(struct evhtp_s *evhtp)
{
  struct evhtp_alias_s *evhtp_alias;
  struct evhtp_alias_s *tmp;
  _Bool tmp_if_expr_1;
  if(!(evhtp == ((struct evhtp_s *)NULL)))
  {
    if(!(evhtp->thr_pool == ((struct evthr_pool *)NULL)))
    {
      evthr_pool_stop(evhtp->thr_pool);
      evthr_pool_free(evhtp->thr_pool);
    }

    if(!(evhtp->ssl_ctx == ((struct ssl_ctx_st *)NULL)))
      SSL_CTX_free(evhtp->ssl_ctx);

    if(!(evhtp->server_name == ((char *)NULL)))
      do
      {
        free((void *)evhtp->server_name);
        evhtp->server_name = (char *)(void *)0;
      }
      while((_Bool)0);

    if(!(evhtp->callbacks == ((struct evhtp_callbacks_s *)NULL)))
      do
      {
        evhtp_callbacks_free(evhtp->callbacks);
        evhtp->callbacks = (struct evhtp_callbacks_s *)(void *)0;
      }
      while((_Bool)0);

    evhtp_alias = (&evhtp->aliases)->tqh_first;
    do
    {
      if(!(evhtp_alias == ((struct evhtp_alias_s *)NULL)))
      {
        tmp = evhtp_alias->next.tqe_next;
        tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      if(!(evhtp_alias->alias == ((char *)NULL)))
        do
        {
          free((void *)evhtp_alias->alias);
          evhtp_alias->alias = (char *)(void *)0;
        }
        while((_Bool)0);

      do
      {
        if(!(evhtp_alias->next.tqe_next == ((struct evhtp_alias_s *)NULL)))
          evhtp_alias->next.tqe_next->next.tqe_prev = evhtp_alias->next.tqe_prev;

        else
          (&evhtp->aliases)->tqh_last = evhtp_alias->next.tqe_prev;
        *evhtp_alias->next.tqe_prev = evhtp_alias->next.tqe_next;
      }
      while((_Bool)0);
      do
      {
        free((void *)evhtp_alias);
        evhtp_alias = (struct evhtp_alias_s *)(void *)0;
      }
      while((_Bool)0);
      evhtp_alias = tmp;
    }
    while((_Bool)1);
    if(!(evhtp->ssl_ctx == ((struct ssl_ctx_st *)NULL)))
      SSL_CTX_free(evhtp->ssl_ctx);

    do
    {
      free((void *)evhtp);
      evhtp = (struct evhtp_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// evhtp_get_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3584
struct evhtp_callback_s * evhtp_get_cb(struct evhtp_s *htp, const char *path)
{
  struct evhtp_callback_s *callback = htp->callbacks->tqh_first;
  for( ; !(callback == ((struct evhtp_callback_s *)NULL)); callback = callback->next.tqe_next)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(callback->val.path, path);
    if(return_value_strcmp_1 == 0)
      return callback;

  }
  return (struct evhtp_callback_s *)(void *)0;
}

// evhtp_header_key_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2410
struct evhtp_kv_s * evhtp_header_key_add(struct evhtp_kvs_s *headers, const char *key, char kalloc)
{
  struct evhtp_kv_s *header;
  header=evhtp_kv_new(key, (const char *)(void *)0, kalloc, (char)0);
  if(header == ((struct evhtp_kv_s *)NULL))
    return (struct evhtp_kv_s *)(void *)0;

  else
  {
    evhtp_kvs_add_kv(headers, header);
    return header;
  }
}

// evhtp_header_val_add
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2423
struct evhtp_kv_s * evhtp_header_val_add(struct evhtp_kvs_s *headers, const char *val, char valloc)
{
  struct evhtp_kv_s *header;
  if(val == ((const char *)NULL) || headers == ((struct evhtp_kvs_s *)NULL))
    return (struct evhtp_kv_s *)(void *)0;

  else
  {
    header = *((struct evhtp_kvs_s *)headers->tqh_last)->tqh_last;
    if(header == ((struct evhtp_kv_s *)NULL))
      return (struct evhtp_kv_s *)(void *)0;

    else
      if(!(header->val == ((char *)NULL)))
        return (struct evhtp_kv_s *)(void *)0;

      else
      {
        header->vlen=strlen(val);
        if((signed int)valloc == 1)
        {
          void *return_value_malloc_1;
          return_value_malloc_1=malloc(header->vlen + (unsigned long int)1);
          header->val = (char *)return_value_malloc_1;
          header->val[(signed long int)header->vlen] = (char)0;
          memcpy((void *)header->val, (const void *)val, header->vlen);
        }

        else
          header->val = (char *)val;
        header->v_heaped = valloc;
        return header;
      }
  }
}

// evhtp_is_hex_query_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2656
static inline signed int evhtp_is_hex_query_char(unsigned char ch)
{
  if((signed int)ch == 48 || (signed int)ch == 49 || (signed int)ch == 50 || (signed int)ch == 51 || (signed int)ch == 52 || (signed int)ch == 53 || (signed int)ch == 54 || (signed int)ch == 55 || (signed int)ch == 56 || (signed int)ch == 57 || (signed int)ch == 65 || (signed int)ch == 66 || (signed int)ch == 67 || (signed int)ch == 68 || (signed int)ch == 69 || (signed int)ch == 70 || (signed int)ch == 97 || (signed int)ch == 98 || (signed int)ch == 99 || (signed int)ch == 100 || (signed int)ch == 101 || (signed int)ch == 102)
    return 1;

  return 0;
}

// evhtp_kv_find
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2585
const char * evhtp_kv_find(struct evhtp_kvs_s *kvs, const char *key)
{
  struct evhtp_kv_s *kv;
  if(key == ((const char *)NULL) || kvs == ((struct evhtp_kvs_s *)NULL))
    return (const char *)(void *)0;

  else
  {
    kv = kvs->tqh_first;
    for( ; !(kv == ((struct evhtp_kv_s *)NULL)); kv = kv->next.tqe_next)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(kv->key, key);
      if(return_value_strcasecmp_1 == 0)
        return kv->val;

    }
    return (const char *)(void *)0;
  }
}

// evhtp_kv_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2518
void evhtp_kv_free(struct evhtp_kv_s *kv)
{
  if(!(kv == ((struct evhtp_kv_s *)NULL)))
  {
    if(!(kv->k_heaped == 0))
      do
      {
        free((void *)kv->key);
        kv->key = (char *)(void *)0;
      }
      while((_Bool)0);

    if(!(kv->v_heaped == 0))
      do
      {
        free((void *)kv->val);
        kv->val = (char *)(void *)0;
      }
      while((_Bool)0);

    do
    {
      free((void *)kv);
      kv = (struct evhtp_kv_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// evhtp_kv_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2466
struct evhtp_kv_s * evhtp_kv_new(const char *key, const char *val, char kalloc, char valloc)
{
  struct evhtp_kv_s *kv;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct evhtp_kv_s) /*56ul*/ );
  kv = (struct evhtp_kv_s *)return_value_malloc_1;
  do
    if(kv == ((struct evhtp_kv_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_kv_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2470);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  kv->k_heaped = kalloc;
  kv->v_heaped = valloc;
  kv->klen = (unsigned long int)0;
  kv->vlen = (unsigned long int)0;
  kv->key = (char *)(void *)0;
  kv->val = (char *)(void *)0;
  if(!(key == ((const char *)NULL)))
  {
    kv->klen=strlen(key);
    if((signed int)kalloc == 1)
    {
      char *evhtp_kv_new__1__2__1__s;
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(kv->klen + (unsigned long int)1);
      evhtp_kv_new__1__2__1__s = (char *)return_value_malloc_2;
      if(evhtp_kv_new__1__2__1__s == ((char *)NULL))
      {
        do
        {
          free((void *)kv);
          kv = (struct evhtp_kv_s *)(void *)0;
        }
        while((_Bool)0);
        return (struct evhtp_kv_s *)(void *)0;
      }

      memcpy((void *)evhtp_kv_new__1__2__1__s, (const void *)key, kv->klen);
      evhtp_kv_new__1__2__1__s[(signed long int)kv->klen] = (char)0;
      kv->key = evhtp_kv_new__1__2__1__s;
    }

    else
      kv->key = (char *)key;
  }

  if(!(val == ((const char *)NULL)))
  {
    kv->vlen=strlen(val);
    if((signed int)valloc == 1)
    {
      char *s;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(kv->vlen + (unsigned long int)1);
      s = (char *)return_value_malloc_3;
      s[(signed long int)kv->vlen] = (char)0;
      memcpy((void *)s, (const void *)val, kv->vlen);
      kv->val = s;
    }

    else
      kv->val = (char *)val;
  }

  return kv;
}

// evhtp_kv_rm_and_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2535
void evhtp_kv_rm_and_free(struct evhtp_kvs_s *kvs, struct evhtp_kv_s *kv)
{
  if(!(kv == ((struct evhtp_kv_s *)NULL)) && !(kvs == ((struct evhtp_kvs_s *)NULL)))
  {
    do
    {
      if(!(kv->next.tqe_next == ((struct evhtp_kv_s *)NULL)))
        kv->next.tqe_next->next.tqe_prev = kv->next.tqe_prev;

      else
        kvs->tqh_last = kv->next.tqe_prev;
      *kv->next.tqe_prev = kv->next.tqe_next;
    }
    while((_Bool)0);
    evhtp_kv_free(kv);
  }

}

// evhtp_kvs_add_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2619
void evhtp_kvs_add_kv(struct evhtp_kvs_s *kvs, struct evhtp_kv_s *kv)
{
  if(!(kv == ((struct evhtp_kv_s *)NULL)) && !(kvs == ((struct evhtp_kvs_s *)NULL)))
    do
    {
      kv->next.tqe_next = (struct evhtp_kv_s *)(void *)0;
      kv->next.tqe_prev = kvs->tqh_last;
      *kvs->tqh_last = kv;
      kvs->tqh_last = &kv->next.tqe_next;
    }
    while((_Bool)0);

}

// evhtp_kvs_add_kvs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2628
void evhtp_kvs_add_kvs(struct evhtp_kvs_s *dst, struct evhtp_kvs_s *src)
{
  if(!(dst == ((struct evhtp_kvs_s *)NULL)) && !(src == ((struct evhtp_kvs_s *)NULL)))
  {
    struct evhtp_kv_s *kv = src->tqh_first;
    for( ; !(kv == ((struct evhtp_kv_s *)NULL)); kv = kv->next.tqe_next)
    {
      struct evhtp_kv_s *return_value_evhtp_kv_new_1;
      return_value_evhtp_kv_new_1=evhtp_kv_new(kv->key, kv->val, kv->k_heaped, kv->v_heaped);
      evhtp_kvs_add_kv(dst, return_value_evhtp_kv_new_1);
    }
  }

}

// evhtp_kvs_find_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2602
struct evhtp_kv_s * evhtp_kvs_find_kv(struct evhtp_kvs_s *kvs, const char *key)
{
  struct evhtp_kv_s *kv;
  if(key == ((const char *)NULL) || kvs == ((struct evhtp_kvs_s *)NULL))
    return (struct evhtp_kv_s *)(void *)0;

  else
  {
    kv = kvs->tqh_first;
    for( ; !(kv == ((struct evhtp_kv_s *)NULL)); kv = kv->next.tqe_next)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(kv->key, key);
      if(return_value_strcasecmp_1 == 0)
        return kv;

    }
    return (struct evhtp_kv_s *)(void *)0;
  }
}

// evhtp_kvs_for_each
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1062
signed int evhtp_kvs_for_each(struct evhtp_kvs_s *kvs, signed int (*cb)(struct evhtp_kv_s *, void *), void *arg)
{
  struct evhtp_kv_s *kv;
  if(cb == ((signed int (*)(struct evhtp_kv_s *, void *))NULL) || kvs == ((struct evhtp_kvs_s *)NULL))
    return -1;

  else
  {
    kv = kvs->tqh_first;
    if(!(kv == ((struct evhtp_kv_s *)NULL)))
    {
      signed int res;
      res=cb(kv, arg);
      if(!(res == 0))
        return res;

      kv = kv->next.tqe_next;
    }

    return 0;
  }
}

// evhtp_kvs_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2546
void evhtp_kvs_free(struct evhtp_kvs_s *kvs)
{
  struct evhtp_kv_s *kv;
  struct evhtp_kv_s *save;
  if(!(kvs == ((struct evhtp_kvs_s *)NULL)))
  {
    kv = kvs->tqh_first;
    for( ; !(kv == ((struct evhtp_kv_s *)NULL)); kv = save)
    {
      save = kv->next.tqe_next;
      do
      {
        if(!(kv->next.tqe_next == ((struct evhtp_kv_s *)NULL)))
          kv->next.tqe_next->next.tqe_prev = kv->next.tqe_prev;

        else
          kvs->tqh_last = kv->next.tqe_prev;
        *kv->next.tqe_prev = kv->next.tqe_next;
      }
      while((_Bool)0);
      do
      {
        evhtp_kv_free(kv);
        kv = (struct evhtp_kv_s *)(void *)0;
      }
      while((_Bool)0);
    }
    do
    {
      free((void *)kvs);
      kvs = (struct evhtp_kvs_s *)(void *)0;
    }
    while((_Bool)0);
  }

}

// evhtp_kvs_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2454
struct evhtp_kvs_s * evhtp_kvs_new(void)
{
  struct evhtp_kvs_s *kvs;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct evhtp_kvs_s) /*16ul*/ );
  kvs = (struct evhtp_kvs_s *)return_value_malloc_1;
  do
    if(kvs == ((struct evhtp_kvs_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_kvs_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2458);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  do
  {
    kvs->tqh_first = (struct evhtp_kv_s *)(void *)0;
    kvs->tqh_last = &kvs->tqh_first;
  }
  while((_Bool)0);
  return kvs;
}

// evhtp_make_request
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4347
signed int evhtp_make_request(struct evhtp_connection_s *c, struct evhtp_request_s *r, enum htp_method meth, const char *uri)
{
  struct evbuffer *obuf;
  char *proto;
  obuf=bufferevent_get_output(c->bev);
  r->conn = c;
  c->request = r;
  if(!((signed int)r->proto == EVHTP_PROTO_10))
  {
    if((signed int)r->proto == EVHTP_PROTO_11)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    proto = "1.0";
    goto __CPROVER_DUMP_L3;
  }

__CPROVER_DUMP_L2:
  ;
  proto = "1.1";

__CPROVER_DUMP_L3:
  ;
  const char *return_value_htparser_get_methodstr_m_1;
  return_value_htparser_get_methodstr_m_1=htparser_get_methodstr_m(meth);
  evbuffer_add_printf(obuf, "%s %s HTTP/%s\r\n", return_value_htparser_get_methodstr_m_1, uri, proto);
  evhtp_kvs_for_each(r->headers_out, _evhtp_create_headers, (void *)obuf);
  evbuffer_add_reference(obuf, (const void *)"\r\n", (unsigned long int)2, (void (*)(const void *, unsigned long int, void *))(void *)0, (void *)0);
  unsigned long int return_value_evbuffer_get_length_2;
  return_value_evbuffer_get_length_2=evbuffer_get_length(r->buffer_out);
  if(!(return_value_evbuffer_get_length_2 == 0ul))
    evbuffer_add_buffer(obuf, r->buffer_out);

  return 0;
}

// evhtp_modp_sizetoa
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.h line 19
inline unsigned long int evhtp_modp_sizetoa(unsigned long int value, char *str)
{
  unsigned long int return_value_evhtp_modp_u64toa_1;
  return_value_evhtp_modp_u64toa_1=evhtp_modp_u64toa(value, str);
  return return_value_evhtp_modp_u64toa_1;
}

// evhtp_modp_u32toa
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.h line 29
unsigned long int evhtp_modp_u32toa(unsigned int value, char *str)
{
  char *wstr = str;
  char *tmp_post_1;
  do
  {
    tmp_post_1 = wstr;
    wstr = wstr + 1l;
    *tmp_post_1 = (char)((unsigned int)48 + value % (unsigned int)10);
    value = value / (unsigned int)10;
  }
  while(!(value == 0u));
  *wstr = (char)0;
  strreverse(str, wstr - (signed long int)1);
  return (unsigned long int)(wstr - str);
}

// evhtp_modp_u64toa
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.c line 29
unsigned long int evhtp_modp_u64toa(unsigned long int value, char *str)
{
  char *wstr = str;
  char *tmp_post_1;
  do
  {
    tmp_post_1 = wstr;
    wstr = wstr + 1l;
    *tmp_post_1 = (char)((unsigned long int)48 + value % (unsigned long int)10);
    value = value / (unsigned long int)10;
  }
  while(!(value == 0ul));
  *wstr = (char)0;
  strreverse(str, wstr - (signed long int)1);
  return (unsigned long int)(wstr - str);
}

// evhtp_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 563
struct evhtp_s * evhtp_new(struct event_base *evbase, void *arg)
{
  struct evhtp_s *htp;
  do
    if(evbase == ((struct event_base *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"evbase != NULL", (const void *)"evhtp_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 4156);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct evhtp_s) /*256ul*/ , (unsigned long int)1);
  htp = (struct evhtp_s *)return_value_calloc_1;
  do
    if(htp == ((struct evhtp_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 4159);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  htp->arg = arg;
  htp->evbase = evbase;
  htp->bev_flags = 1;
  htp->parser_flags = 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3;
  do
  {
    (&htp->vhosts)->tqh_first = (struct evhtp_s *)(void *)0;
    (&htp->vhosts)->tqh_last = &(&htp->vhosts)->tqh_first;
  }
  while((_Bool)0);
  do
  {
    (&htp->aliases)->tqh_first = (struct evhtp_alias_s *)(void *)0;
    (&htp->aliases)->tqh_last = &(&htp->aliases)->tqh_first;
  }
  while((_Bool)0);
  evhtp_set_gencb(htp, _evhtp_default_request_cb, (void *)htp);
  return htp;
}

// evhtp_parse_query
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3007
struct evhtp_kvs_s * evhtp_parse_query(const char *query, unsigned long int len)
{
  struct evhtp_kvs_s *return_value_evhtp_parse_query_wflags_1;
  return_value_evhtp_parse_query_wflags_1=evhtp_parse_query_wflags(query, len, 0);
  return return_value_evhtp_parse_query_wflags_1;
}

// evhtp_parse_query_wflags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2764
struct evhtp_kvs_s * evhtp_parse_query_wflags(const char *query, unsigned long int len, signed int flags)
{
  struct evhtp_kvs_s *query_args;
  enum anonymous_14 state;
  unsigned long int key_idx;
  unsigned long int val_idx;
  unsigned char ch;
  unsigned long int i;
  unsigned long int tmp_post_1;
  unsigned long int tmp_post_2;
  struct evhtp_kv_s *return_value_evhtp_kv_new_3;
  unsigned long int tmp_post_4;
  signed int return_value_evhtp_is_hex_query_char_6;
  unsigned long int tmp_post_5;
  unsigned long int tmp_post_7;
  signed int return_value_evhtp_is_hex_query_char_8;
  unsigned long int tmp_post_9;
  unsigned long int tmp_post_10;
  struct evhtp_kv_s *return_value_evhtp_kv_new_11;
  unsigned long int tmp_post_12;
  unsigned long int tmp_post_13;
  signed int return_value_evhtp_is_hex_query_char_15;
  unsigned long int tmp_post_14;
  unsigned long int tmp_post_16;
  signed int return_value_evhtp_is_hex_query_char_17;
  unsigned long int tmp_post_18;
  if(!(18446744073709551615UL + -(2ul + len) >= len))
    return (struct evhtp_kvs_s *)(void *)0;

  else
  {
    query_args=evhtp_kvs_new();
    state = (enum anonymous_14)s_query_start;
    key_idx = (unsigned long int)0;
    val_idx = (unsigned long int)0;
    const signed long int i_array_size0 = (signed long int)(len + (unsigned long int)1);
    char key_buf[i_array_size0];
    const signed long int key_buf_array_size0 = (signed long int)(len + (unsigned long int)1);
    char val_buf[key_buf_array_size0];
    i = (unsigned long int)0;
    for( ; !(i >= len); i = i + 1ul)
    {
      ch = (unsigned char)query[(signed long int)i];
      if(key_idx >= len || val_idx >= len)
        goto error;

      switch((signed int)state)
      {
        case s_query_start:
        {
          key_idx = (unsigned long int)0;
          val_idx = (unsigned long int)0;
          key_buf[(signed long int)0] = (char)0;
          val_buf[(signed long int)0] = (char)0;
          state = (enum anonymous_14)s_query_key;
        }
        case s_query_key:
        {
          switch((signed int)ch)
          {
            case 61:
            {
              state = (enum anonymous_14)s_query_val;
              break;
            }
            case 37:
            {
              tmp_post_1 = key_idx;
              key_idx = key_idx + 1ul;
              key_buf[(signed long int)tmp_post_1] = (char)ch;
              key_buf[(signed long int)key_idx] = (char)0;
              if((1 & flags) == 0)
                state = (enum anonymous_14)s_query_key_hex_1;

              break;
            }
            case 59:
              if((8 & flags) == 0)
              {
                tmp_post_2 = key_idx;
                key_idx = key_idx + 1ul;
                key_buf[(signed long int)tmp_post_2] = (char)ch;
                key_buf[(signed long int)key_idx] = (char)0;
                break;
              }

            case 38:
            {
              if((4 & flags) == 0)
                goto error;

              return_value_evhtp_kv_new_3=evhtp_kv_new(key_buf, (const char *)(void *)0, (char)1, (char)1);
              evhtp_kvs_add_kv(query_args, return_value_evhtp_kv_new_3);
              key_idx = (unsigned long int)0;
              val_idx = (unsigned long int)0;
              key_buf[(signed long int)0] = (char)0;
              val_buf[(signed long int)0] = (char)0;
              state = (enum anonymous_14)s_query_key;
              break;
            }
            default:
            {
              tmp_post_4 = key_idx;
              key_idx = key_idx + 1ul;
              key_buf[(signed long int)tmp_post_4] = (char)ch;
              key_buf[(signed long int)key_idx] = (char)0;
            }
          }
          break;
        }
        case s_query_key_hex_1:
        {
          return_value_evhtp_is_hex_query_char_6=evhtp_is_hex_query_char(ch);
          if(return_value_evhtp_is_hex_query_char_6 == 0)
          {
            if(2ul + key_idx >= len)
              goto error;

            key_buf[(signed long int)(key_idx - (unsigned long int)1)] = (char)37;
            tmp_post_5 = key_idx;
            key_idx = key_idx + 1ul;
            key_buf[(signed long int)tmp_post_5] = (char)ch;
            key_buf[(signed long int)key_idx] = (char)0;
            state = (enum anonymous_14)s_query_key;
            break;
          }

          tmp_post_7 = key_idx;
          key_idx = key_idx + 1ul;
          key_buf[(signed long int)tmp_post_7] = (char)ch;
          key_buf[(signed long int)key_idx] = (char)0;
          state = (enum anonymous_14)s_query_key_hex_2;
          break;
        }
        case s_query_key_hex_2:
        {
          return_value_evhtp_is_hex_query_char_8=evhtp_is_hex_query_char(ch);
          if(return_value_evhtp_is_hex_query_char_8 == 0)
            goto error;

          tmp_post_9 = key_idx;
          key_idx = key_idx + 1ul;
          key_buf[(signed long int)tmp_post_9] = (char)ch;
          key_buf[(signed long int)key_idx] = (char)0;
          state = (enum anonymous_14)s_query_key;
          break;
        }
        case s_query_val:
        {
          switch((signed int)ch)
          {
            case 59:
              if((8 & flags) == 0)
              {
                tmp_post_10 = val_idx;
                val_idx = val_idx + 1ul;
                val_buf[(signed long int)tmp_post_10] = (char)ch;
                val_buf[(signed long int)val_idx] = (char)0;
                break;
              }

            case 38:
            {
              return_value_evhtp_kv_new_11=evhtp_kv_new(key_buf, val_buf, (char)1, (char)1);
              evhtp_kvs_add_kv(query_args, return_value_evhtp_kv_new_11);
              key_idx = (unsigned long int)0;
              val_idx = (unsigned long int)0;
              key_buf[(signed long int)0] = (char)0;
              val_buf[(signed long int)0] = (char)0;
              state = (enum anonymous_14)s_query_key;
              break;
            }
            case 37:
            {
              tmp_post_12 = val_idx;
              val_idx = val_idx + 1ul;
              val_buf[(signed long int)tmp_post_12] = (char)ch;
              val_buf[(signed long int)val_idx] = (char)0;
              if((1 & flags) == 0)
                state = (enum anonymous_14)s_query_val_hex_1;

              break;
            }
            default:
            {
              tmp_post_13 = val_idx;
              val_idx = val_idx + 1ul;
              val_buf[(signed long int)tmp_post_13] = (char)ch;
              val_buf[(signed long int)val_idx] = (char)0;
            }
          }
          break;
        }
        case s_query_val_hex_1:
        {
          return_value_evhtp_is_hex_query_char_15=evhtp_is_hex_query_char(ch);
          if(return_value_evhtp_is_hex_query_char_15 == 0)
          {
            if(2ul + val_idx >= len)
              goto error;

            if(val_idx == 0ul)
              goto error;

            val_buf[(signed long int)(val_idx - (unsigned long int)1)] = (char)37;
            tmp_post_14 = val_idx;
            val_idx = val_idx + 1ul;
            val_buf[(signed long int)tmp_post_14] = (char)ch;
            val_buf[(signed long int)val_idx] = (char)0;
            state = (enum anonymous_14)s_query_val;
            break;
          }

          tmp_post_16 = val_idx;
          val_idx = val_idx + 1ul;
          val_buf[(signed long int)tmp_post_16] = (char)ch;
          val_buf[(signed long int)val_idx] = (char)0;
          state = (enum anonymous_14)s_query_val_hex_2;
          break;
        }
        case s_query_val_hex_2:
        {
          return_value_evhtp_is_hex_query_char_17=evhtp_is_hex_query_char(ch);
          if(return_value_evhtp_is_hex_query_char_17 == 0)
            goto error;

          tmp_post_18 = val_idx;
          val_idx = val_idx + 1ul;
          val_buf[(signed long int)tmp_post_18] = (char)ch;
          val_buf[(signed long int)val_idx] = (char)0;
          state = (enum anonymous_14)s_query_val;
          break;
        }
        default:
          goto error;
      }
    }
    if(!(key_idx == 0ul))
      do
      {
        if(!(val_idx == 0ul))
        {
          struct evhtp_kv_s *return_value_evhtp_kv_new_19;
          return_value_evhtp_kv_new_19=evhtp_kv_new(key_buf, val_buf, (char)1, (char)1);
          evhtp_kvs_add_kv(query_args, return_value_evhtp_kv_new_19);
          goto __CPROVER_DUMP_L31;
        }

        if((signed int)state >= s_query_val)
        {
          if((2 & flags) == 0)
            goto error;

          struct evhtp_kv_s *return_value_evhtp_kv_new_20;
          return_value_evhtp_kv_new_20=evhtp_kv_new(key_buf, "", (char)1, (char)1);
          evhtp_kvs_add_kv(query_args, return_value_evhtp_kv_new_20);
          break;
        }

        if((4 & flags) == 0)
          goto error;

        struct evhtp_kv_s *return_value_evhtp_kv_new_21;
        return_value_evhtp_kv_new_21=evhtp_kv_new(key_buf, (const char *)(void *)0, (char)1, (char)0);
        evhtp_kvs_add_kv(query_args, return_value_evhtp_kv_new_21);
      }
      while((_Bool)0);


  __CPROVER_DUMP_L31:
    ;
    return query_args;

  error:
    ;
    return (struct evhtp_kvs_s *)(void *)0;
  }
}

// evhtp_request_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4035
void evhtp_request_free(struct evhtp_request_s *request)
{
  _evhtp_request_free(request);
}

// evhtp_request_get_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3939
struct bufferevent * evhtp_request_get_bev(struct evhtp_request_s *request)
{
  struct bufferevent *return_value_evhtp_connection_get_bev_1;
  return_value_evhtp_connection_get_bev_1=evhtp_connection_get_bev(request->conn);
  return return_value_evhtp_connection_get_bev_1;
}

// evhtp_request_get_connection
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1209
struct evhtp_connection_s * evhtp_request_get_connection(struct evhtp_request_s *request)
{
  return request->conn;
}

// evhtp_request_get_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1192
enum htp_method evhtp_request_get_method(struct evhtp_request_s *r)
{
  do
    if(r == ((struct evhtp_request_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"r != NULL", (const void *)"evhtp_request_get_method", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2341);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  do
    if(r->conn == ((struct evhtp_connection_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"r->conn != NULL", (const void *)"evhtp_request_get_method", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2342);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  do
    if(r->conn->parser == ((struct htparser *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"r->conn->parser != NULL", (const void *)"evhtp_request_get_method", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2343);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  enum htp_method return_value_htparser_get_method_1;
  return_value_htparser_get_method_1=htparser_get_method(r->conn->parser);
  return return_value_htparser_get_method_1;
}

// evhtp_request_get_proto
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3969
enum evhtp_proto evhtp_request_get_proto(struct evhtp_request_s *request)
{
  return request->proto;
}

// evhtp_request_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4333
struct evhtp_request_s * evhtp_request_new(void (*cb)(struct evhtp_request_s *, void *), void *arg)
{
  struct evhtp_request_s *r;
  r=_evhtp_request_new((struct evhtp_connection_s *)(void *)0);
  do
    if(r == ((struct evhtp_request_s *)NULL))
    {
      fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_request_new", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 4337);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  r->cb = cb;
  r->cbarg = arg;
  r->proto = (enum evhtp_proto)EVHTP_PROTO_11;
  return r;
}

// evhtp_request_pause
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2388
void evhtp_request_pause(struct evhtp_request_s *request)
{
  do
    if(request == ((struct evhtp_request_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"request != NULL", (const void *)"evhtp_request_pause", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2389);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  request->status = (unsigned short int)1;
  evhtp_connection_pause(request->conn);
}

// evhtp_request_resume
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1199
void evhtp_request_resume(struct evhtp_request_s *request)
{
  do
    if(request == ((struct evhtp_request_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"request != NULL", (const void *)"evhtp_request_resume", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 2404);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  evhtp_connection_resume(request->conn);
}

// evhtp_request_set_bev
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3954
void evhtp_request_set_bev(struct evhtp_request_s *request, struct bufferevent *bev)
{
  evhtp_connection_set_bev(request->conn, bev);
}

// evhtp_request_set_keepalive
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3959
void evhtp_request_set_keepalive(struct evhtp_request_s *request, signed int val)
{
  request->keepalive = (unsigned char)(val > 0 ? 1 : 0);
}

// evhtp_request_set_max_body_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1308
void evhtp_request_set_max_body_size(struct evhtp_request_s *req, unsigned long int len)
{
  evhtp_connection_set_max_body_size(req->conn, len);
}

// evhtp_request_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4379
unsigned int evhtp_request_status(struct evhtp_request_s *r)
{
  unsigned int return_value_htparser_get_status_1;
  return_value_htparser_get_status_1=htparser_get_status(r->conn->parser);
  return return_value_htparser_get_status_1;
}

// evhtp_request_take_ownership
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3944
struct bufferevent * evhtp_request_take_ownership(struct evhtp_request_s *request)
{
  struct evhtp_connection_s *return_value_evhtp_request_get_connection_1;
  return_value_evhtp_request_get_connection_1=evhtp_request_get_connection(request);
  struct bufferevent *return_value_evhtp_connection_take_ownership_2;
  return_value_evhtp_connection_take_ownership_2=evhtp_connection_take_ownership(return_value_evhtp_request_get_connection_1);
  return return_value_evhtp_connection_take_ownership_2;
}

// evhtp_response_needs_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3064
signed int evhtp_response_needs_body(const unsigned short int code, const enum htp_method method)
{
  return (signed int)((signed int)code != 204 && (signed int)code != 304 && ((signed int)code < 100 || (signed int)code >= 200) && (signed int)method != htp_method_HEAD);
}

// evhtp_send_reply
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 857
void evhtp_send_reply(struct evhtp_request_s *request, unsigned short int code)
{
  struct evhtp_connection_s *c;
  struct evbuffer *reply_buf;
  c=evhtp_request_get_connection(request);
  request->finished = (unsigned char)1;
  reply_buf=_evhtp_create_reply(request, code);
  if(reply_buf == ((struct evbuffer *)NULL))
    evhtp_connection_free(request->conn);

  else
  {
    struct bufferevent *return_value_evhtp_connection_get_bev_1;
    return_value_evhtp_connection_get_bev_1=evhtp_connection_get_bev(c);
    bufferevent_write_buffer(return_value_evhtp_connection_get_bev_1, reply_buf);
    evbuffer_drain(reply_buf, (unsigned long int)-1);
  }
}

// evhtp_send_reply_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3031
void evhtp_send_reply_body(struct evhtp_request_s *request, struct evbuffer *buf)
{
  struct evhtp_connection_s *c = request->conn;
  bufferevent_write_buffer(c->bev, buf);
}

// evhtp_send_reply_chunk
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 891
void evhtp_send_reply_chunk(struct evhtp_request_s *request, struct evbuffer *buf)
{
  struct evbuffer *output;
  unsigned long int return_value_evbuffer_get_length_1;
  return_value_evbuffer_get_length_1=evbuffer_get_length(buf);
  if(!(return_value_evbuffer_get_length_1 == 0ul))
  {
    output=bufferevent_get_output(request->conn->bev);
    if((signed int)request->chunked == 1)
    {
      unsigned long int return_value_evbuffer_get_length_2;
      return_value_evbuffer_get_length_2=evbuffer_get_length(buf);
      evbuffer_add_printf(output, "%x\r\n", (unsigned int)return_value_evbuffer_get_length_2);
    }

    evhtp_send_reply_body(request, buf);
    if(!(request->chunked == 0))
      evbuffer_add(output, (const void *)"\r\n", (unsigned long int)2);

    bufferevent_flush(request->conn->bev, (signed short int)0x04, (enum bufferevent_flush_mode)BEV_FLUSH);
  }

}

// evhtp_send_reply_chunk_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 899
void evhtp_send_reply_chunk_end(struct evhtp_request_s *request)
{
  if((signed int)request->chunked == 1)
  {
    struct bufferevent *return_value_evhtp_request_get_bev_1;
    return_value_evhtp_request_get_bev_1=evhtp_request_get_bev(request);
    struct evbuffer *return_value_bufferevent_get_output_2;
    return_value_bufferevent_get_output_2=bufferevent_get_output(return_value_evhtp_request_get_bev_1);
    evbuffer_add(return_value_bufferevent_get_output_2, (const void *)"0\r\n\r\n", (unsigned long int)5);
  }

  evhtp_send_reply_end(request);
}

// evhtp_send_reply_chunk_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 882
void evhtp_send_reply_chunk_start(struct evhtp_request_s *request, unsigned short int code)
{
  struct evhtp_kv_s *content_len;
  signed int return_value_evhtp_response_needs_body_1;
  return_value_evhtp_response_needs_body_1=evhtp_response_needs_body(code, request->method);
  if(!(return_value_evhtp_response_needs_body_1 == 0))
  {
    content_len=evhtp_kvs_find_kv(request->headers_out, "Content-Length");
    switch((signed int)request->proto)
    {
      case EVHTP_PROTO_11:
      {
        evhtp_kv_rm_and_free(request->headers_out, content_len);
        request->chunked = (unsigned char)1;
        break;
      }
      case EVHTP_PROTO_10:
      {
        evhtp_kv_rm_and_free(request->headers_out, content_len);
        request->chunked = (unsigned char)1;
        break;
      }
      default:
        request->chunked = (unsigned char)0;
    }
  }

  else
    request->chunked = (unsigned char)0;
  if((signed int)request->chunked == 1)
  {
    struct evhtp_kv_s *return_value_evhtp_kv_new_2;
    return_value_evhtp_kv_new_2=evhtp_kv_new("Transfer-Encoding", "chunked", (char)0, (char)0);
    evhtp_kvs_add_kv(request->headers_out, return_value_evhtp_kv_new_2);
    unsigned long int return_value_evbuffer_get_length_5;
    return_value_evbuffer_get_length_5=evbuffer_get_length(request->buffer_out);
    if(return_value_evbuffer_get_length_5 >= 1ul)
    {
      char lstr[128l];
      signed int sres;
      unsigned long int return_value_evbuffer_get_length_3;
      return_value_evbuffer_get_length_3=evbuffer_get_length(request->buffer_out);
      sres=snprintf(lstr, sizeof(char [128l]) /*128ul*/ , "%x\r\n", (unsigned int)return_value_evbuffer_get_length_3);
      if((unsigned long int)sres >= sizeof(char [128l]) /*128ul*/  || !(sres >= 0))
        goto end;

      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(lstr);
      evbuffer_prepend(request->buffer_out, (const void *)lstr, return_value_strlen_4);
      evbuffer_add(request->buffer_out, (const void *)"\r\n", (unsigned long int)2);
    }

  }


end:
  ;
  evhtp_send_reply_start(request, code);
}

// evhtp_send_reply_end
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3040
void evhtp_send_reply_end(struct evhtp_request_s *request)
{
  request->finished = (unsigned char)1;
}

// evhtp_send_reply_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3013
void evhtp_send_reply_start(struct evhtp_request_s *request, unsigned short int code)
{
  struct evhtp_connection_s *c;
  struct evbuffer *reply_buf;
  c=evhtp_request_get_connection(request);
  reply_buf=_evhtp_create_reply(request, code);
  if(reply_buf == ((struct evbuffer *)NULL))
    evhtp_connection_free(c);

  else
  {
    bufferevent_write_buffer(c->bev, reply_buf);
    evbuffer_drain(reply_buf, (unsigned long int)-1);
  }
}

// evhtp_set_bev_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4062
void evhtp_set_bev_flags(struct evhtp_s *htp, signed int flags)
{
  htp->bev_flags = flags;
}

// evhtp_set_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 669
struct evhtp_callback_s * evhtp_set_cb(struct evhtp_s *htp, const char *path, void (*cb)(struct evhtp_request_s *, void *), void *arg)
{
  struct evhtp_callback_s *hcb;
  do
    if(!(htp->lock == ((union anonymous_8 *)NULL)))
      pthread_mutex_lock(htp->lock);

  while((_Bool)0);
  if(htp->callbacks == ((struct evhtp_callbacks_s *)NULL))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct evhtp_callbacks_s) /*16ul*/ , (unsigned long int)1);
    htp->callbacks = (struct evhtp_callbacks_s *)return_value_calloc_1;
    if(htp->callbacks == ((struct evhtp_callbacks_s *)NULL))
    {
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }

    do
    {
      htp->callbacks->tqh_first = (struct evhtp_callback_s *)(void *)0;
      htp->callbacks->tqh_last = &htp->callbacks->tqh_first;
    }
    while((_Bool)0);
  }

  hcb=evhtp_callback_new(path, (enum evhtp_callback_type)evhtp_callback_type_hash, cb, arg);
  if(hcb == ((struct evhtp_callback_s *)NULL))
  {
    do
      if(!(htp->lock == ((union anonymous_8 *)NULL)))
        pthread_mutex_unlock(htp->lock);

    while((_Bool)0);
    return (struct evhtp_callback_s *)(void *)0;
  }

  else
  {
    signed int return_value_evhtp_callbacks_add_callback_2;
    return_value_evhtp_callbacks_add_callback_2=evhtp_callbacks_add_callback(htp->callbacks, hcb);
    if(!(return_value_evhtp_callbacks_add_callback_2 == 0))
    {
      do
      {
        evhtp_callback_free(hcb);
        hcb = (struct evhtp_callback_s *)(void *)0;
      }
      while((_Bool)0);
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }

    else
    {
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return hcb;
    }
  }
}

// evhtp_set_gencb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 633
void evhtp_set_gencb(struct evhtp_s *htp, void (*cb)(struct evhtp_request_s *, void *), void *arg)
{
  htp->defaults.cb = cb;
  htp->defaults.cbarg = arg;
}

// evhtp_set_glob_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 702
struct evhtp_callback_s * evhtp_set_glob_cb(struct evhtp_s *htp, const char *pattern, void (*cb)(struct evhtp_request_s *, void *), void *arg)
{
  struct evhtp_callback_s *hcb;
  do
    if(!(htp->lock == ((union anonymous_8 *)NULL)))
      pthread_mutex_lock(htp->lock);

  while((_Bool)0);
  if(htp->callbacks == ((struct evhtp_callbacks_s *)NULL))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct evhtp_callbacks_s) /*16ul*/ , (unsigned long int)1);
    htp->callbacks = (struct evhtp_callbacks_s *)return_value_calloc_1;
    if(htp->callbacks == ((struct evhtp_callbacks_s *)NULL))
    {
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }

    do
    {
      htp->callbacks->tqh_first = (struct evhtp_callback_s *)(void *)0;
      htp->callbacks->tqh_last = &htp->callbacks->tqh_first;
    }
    while((_Bool)0);
  }

  hcb=evhtp_callback_new(pattern, (enum evhtp_callback_type)evhtp_callback_type_glob, cb, arg);
  if(hcb == ((struct evhtp_callback_s *)NULL))
  {
    do
      if(!(htp->lock == ((union anonymous_8 *)NULL)))
        pthread_mutex_unlock(htp->lock);

    while((_Bool)0);
    return (struct evhtp_callback_s *)(void *)0;
  }

  else
  {
    signed int return_value_evhtp_callbacks_add_callback_2;
    return_value_evhtp_callbacks_add_callback_2=evhtp_callbacks_add_callback(htp->callbacks, hcb);
    if(!(return_value_evhtp_callbacks_add_callback_2 == 0))
    {
      do
      {
        evhtp_callback_free(hcb);
        hcb = (struct evhtp_callback_s *)(void *)0;
      }
      while((_Bool)0);
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }

    else
    {
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return hcb;
    }
  }
}

// evhtp_set_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 772
signed int evhtp_set_hook(struct evhtp_hooks_s **hooks, enum evhtp_hook_type type, unsigned short int (*cb)(), void *arg)
{
  if(*hooks == ((struct evhtp_hooks_s *)NULL))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct evhtp_hooks_s) /*240ul*/ , (unsigned long int)1);
    *hooks = (struct evhtp_hooks_s *)return_value_calloc_1;
    if(*hooks == ((struct evhtp_hooks_s *)NULL))
      return -1;

  }

  switch((signed int)type)
  {
    case evhtp_hook_on_headers_start:
    {
      (*hooks)->on_headers_start = (unsigned short int (*)(struct evhtp_request_s *, void *))cb;
      (*hooks)->on_headers_start_arg = arg;
      break;
    }
    case evhtp_hook_on_header:
    {
      (*hooks)->on_header = (unsigned short int (*)(struct evhtp_request_s *, struct evhtp_kv_s *, void *))cb;
      (*hooks)->on_header_arg = arg;
      break;
    }
    case evhtp_hook_on_headers:
    {
      (*hooks)->on_headers = (unsigned short int (*)(struct evhtp_request_s *, struct evhtp_kvs_s *, void *))cb;
      (*hooks)->on_headers_arg = arg;
      break;
    }
    case evhtp_hook_on_path:
    {
      (*hooks)->on_path = (unsigned short int (*)(struct evhtp_request_s *, struct evhtp_path_s *, void *))cb;
      (*hooks)->on_path_arg = arg;
      break;
    }
    case evhtp_hook_on_read:
    {
      (*hooks)->on_read = (unsigned short int (*)(struct evhtp_request_s *, struct evbuffer *, void *))cb;
      (*hooks)->on_read_arg = arg;
      break;
    }
    case evhtp_hook_on_request_fini:
    {
      (*hooks)->on_request_fini = (unsigned short int (*)(struct evhtp_request_s *, void *))cb;
      (*hooks)->on_request_fini_arg = arg;
      break;
    }
    case evhtp_hook_on_connection_fini:
    {
      (*hooks)->on_connection_fini = (unsigned short int (*)(struct evhtp_connection_s *, void *))cb;
      (*hooks)->on_connection_fini_arg = arg;
      break;
    }
    case evhtp_hook_on_conn_error:
    {
      (*hooks)->on_connection_error = (unsigned short int (*)(struct evhtp_connection_s *, unsigned char, void *))cb;
      (*hooks)->on_connection_error_arg = arg;
      break;
    }
    case evhtp_hook_on_error:
    {
      (*hooks)->on_error = (void (*)(struct evhtp_request_s *, unsigned char, void *))cb;
      (*hooks)->on_error_arg = arg;
      break;
    }
    case evhtp_hook_on_new_chunk:
    {
      (*hooks)->on_new_chunk = (unsigned short int (*)(struct evhtp_request_s *, unsigned long int, void *))cb;
      (*hooks)->on_new_chunk_arg = arg;
      break;
    }
    case evhtp_hook_on_chunk_complete:
    {
      (*hooks)->on_chunk_fini = (unsigned short int (*)(struct evhtp_request_s *, void *))cb;
      (*hooks)->on_chunk_fini_arg = arg;
      break;
    }
    case evhtp_hook_on_chunks_complete:
    {
      (*hooks)->on_chunks_fini = (unsigned short int (*)(struct evhtp_request_s *, void *))cb;
      (*hooks)->on_chunks_fini_arg = arg;
      break;
    }
    case evhtp_hook_on_hostname:
    {
      (*hooks)->on_hostname = (unsigned short int (*)(struct evhtp_request_s *, const char *, void *))cb;
      (*hooks)->on_hostname_arg = arg;
      break;
    }
    case evhtp_hook_on_write:
    {
      (*hooks)->on_write = (unsigned short int (*)(struct evhtp_connection_s *, void *))cb;
      (*hooks)->on_write_arg = arg;
      break;
    }
    case evhtp_hook_on_event:
    {
      (*hooks)->on_event = (void (*)(struct evhtp_connection_s *, signed short int, void *))cb;
      (*hooks)->on_event_arg = arg;
      break;
    }
    default:
      return -1;
  }
  return 0;
}

// evhtp_set_max_body_size
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4067
void evhtp_set_max_body_size(struct evhtp_s *htp, unsigned long int len)
{
  htp->max_body_size = len;
}

// evhtp_set_max_keepalive_requests
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 1317
void evhtp_set_max_keepalive_requests(struct evhtp_s *htp, unsigned long int num)
{
  htp->max_keepalive_requests = num;
}

// evhtp_set_parser_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 592
void evhtp_set_parser_flags(struct evhtp_s *htp, signed int flags)
{
  htp->parser_flags = flags;
}

// evhtp_set_post_accept_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 657
void evhtp_set_post_accept_cb(struct evhtp_s *htp, unsigned short int (*cb)(struct evhtp_connection_s *, void *), void *arg)
{
  htp->defaults.post_accept = cb;
  htp->defaults.post_accept_cbarg = arg;
}

// evhtp_set_pre_accept_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 645
void evhtp_set_pre_accept_cb(struct evhtp_s *htp, unsigned short int (*cb)(struct evhtp_connection_s *, void *), void *arg)
{
  htp->defaults.pre_accept = cb;
  htp->defaults.pre_accept_cbarg = arg;
}

// evhtp_set_regex_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 684
struct evhtp_callback_s * evhtp_set_regex_cb(struct evhtp_s *htp, const char *pattern, void (*cb)(struct evhtp_request_s *, void *), void *arg)
{
  struct evhtp_callback_s *hcb;
  do
    if(!(htp->lock == ((union anonymous_8 *)NULL)))
      pthread_mutex_lock(htp->lock);

  while((_Bool)0);
  if(htp->callbacks == ((struct evhtp_callbacks_s *)NULL))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct evhtp_callbacks_s) /*16ul*/ , (unsigned long int)1);
    htp->callbacks = (struct evhtp_callbacks_s *)return_value_calloc_1;
    if(htp->callbacks == ((struct evhtp_callbacks_s *)NULL))
    {
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }

    do
    {
      htp->callbacks->tqh_first = (struct evhtp_callback_s *)(void *)0;
      htp->callbacks->tqh_last = &htp->callbacks->tqh_first;
    }
    while((_Bool)0);
  }

  hcb=evhtp_callback_new(pattern, (enum evhtp_callback_type)evhtp_callback_type_regex, cb, arg);
  if(hcb == ((struct evhtp_callback_s *)NULL))
  {
    do
      if(!(htp->lock == ((union anonymous_8 *)NULL)))
        pthread_mutex_unlock(htp->lock);

    while((_Bool)0);
    return (struct evhtp_callback_s *)(void *)0;
  }

  else
  {
    signed int return_value_evhtp_callbacks_add_callback_2;
    return_value_evhtp_callbacks_add_callback_2=evhtp_callbacks_add_callback(htp->callbacks, hcb);
    if(!(return_value_evhtp_callbacks_add_callback_2 == 0))
    {
      do
      {
        evhtp_callback_free(hcb);
        hcb = (struct evhtp_callback_s *)(void *)0;
      }
      while((_Bool)0);
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return (struct evhtp_callback_s *)(void *)0;
    }

    else
    {
      do
        if(!(htp->lock == ((union anonymous_8 *)NULL)))
          pthread_mutex_unlock(htp->lock);

      while((_Bool)0);
      return hcb;
    }
  }
}

// evhtp_set_timeouts
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 4040
void evhtp_set_timeouts(struct evhtp_s *htp, struct timeval *r_timeo, struct timeval *w_timeo)
{
  if(!(r_timeo == ((struct timeval *)NULL)))
    htp->recv_timeo = *r_timeo;

  if(!(w_timeo == ((struct timeval *)NULL)))
    htp->send_timeo = *w_timeo;

}

// evhtp_ssl_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 604
signed int evhtp_ssl_init(struct evhtp_s *htp, struct evhtp_ssl_cfg_s *cfg)
{
  signed long int cache_mode;
  _Bool tmp_if_expr_1;
  if(htp == ((struct evhtp_s *)NULL) || cfg == ((struct evhtp_ssl_cfg_s *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = cfg->pemfile == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  char *tmp_if_expr_4;
  signed long int tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    SSL_library_init();
    SSL_load_error_strings();
    RAND_poll();
    htp->ssl_cfg = cfg;
    const struct ssl_method_st *return_value_SSLv23_server_method_2;
    return_value_SSLv23_server_method_2=SSLv23_server_method();
    htp->ssl_ctx=SSL_CTX_new(return_value_SSLv23_server_method_2);
    do
      if(htp->ssl_ctx == ((struct ssl_ctx_st *)NULL))
      {
        fprintf(stderr, "Out of memory (%s:%s:%d)\n", (const void *)"evhtp_ssl_init", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c", 3784);
        fflush(stderr);
        abort();
      }

    while((_Bool)0);
    SSL_CTX_ctrl(htp->ssl_ctx, 32, 0x00000010L | 0x00020000L, (void *)0);
    SSL_CTX_set_timeout(htp->ssl_ctx, cfg->ssl_ctx_timeout);
    SSL_CTX_ctrl(htp->ssl_ctx, 32, cfg->ssl_opts, (void *)0);
    if(!(cfg->named_curve == ((char *)NULL)))
    {
      struct ec_key_st *ecdh = (struct ec_key_st *)(void *)0;
      signed int nid = 0;
      nid=OBJ_sn2nid(cfg->named_curve);
      if(nid == 0)
        fprintf(stderr, "ECDH initialization failed: unknown curve %s\n", cfg->named_curve);

      ecdh=EC_KEY_new_by_curve_name(nid);
      if(ecdh == ((struct ec_key_st *)NULL))
        fprintf(stderr, "ECDH initialization failed for curve %s\n", cfg->named_curve);

      SSL_CTX_ctrl(htp->ssl_ctx, 4, (signed long int)0, (void *)(char *)ecdh);
      EC_KEY_free(ecdh);
    }

    if(!(cfg->dhparams == ((char *)NULL)))
    {
      struct _IO_FILE *fh;
      struct dh_st *dh;
      fh=fopen(cfg->dhparams, "r");
      if(!(fh == ((struct _IO_FILE *)NULL)))
      {
        dh=PEM_read_DHparams(fh, (struct dh_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
        if(!(dh == ((struct dh_st *)NULL)))
        {
          SSL_CTX_ctrl(htp->ssl_ctx, 3, (signed long int)0, (void *)(char *)dh);
          DH_free(dh);
        }

        else
          fprintf(stderr, "DH initialization failed: unable to parse file %s\n", cfg->dhparams);
        fclose(fh);
      }

      else
        fprintf(stderr, "DH initialization failed: unable to open file %s\n", cfg->dhparams);
    }

    if(!(cfg->ciphers == ((char *)NULL)))
      SSL_CTX_set_cipher_list(htp->ssl_ctx, cfg->ciphers);

    SSL_CTX_load_verify_locations(htp->ssl_ctx, cfg->cafile, cfg->capath);
    struct x509_store_st *return_value_SSL_CTX_get_cert_store_3;
    return_value_SSL_CTX_get_cert_store_3=SSL_CTX_get_cert_store(htp->ssl_ctx);
    X509_STORE_set_flags(return_value_SSL_CTX_get_cert_store_3, (unsigned long int)cfg->store_flags);
    SSL_CTX_set_verify(htp->ssl_ctx, cfg->verify_peer, cfg->x509_verify_cb);
    if(!(cfg->x509_chk_issued_cb == ((signed int (*)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *))NULL)))
      htp->ssl_ctx->cert_store->check_issued = cfg->x509_chk_issued_cb;

    if(!(cfg->verify_depth == 0))
      SSL_CTX_set_verify_depth(htp->ssl_ctx, cfg->verify_depth);

    if(!((signed int)cfg->scache_type == evhtp_ssl_scache_type_disabled))
    {
      if((signed int)cfg->scache_type == evhtp_ssl_scache_type_internal)
        goto __CPROVER_DUMP_L18;

    }

    else
    {
      cache_mode = (signed long int)0x0000;
      goto __CPROVER_DUMP_L19;
    }

  __CPROVER_DUMP_L18:
    ;
    cache_mode = (signed long int)0x0002;

  __CPROVER_DUMP_L19:
    ;
    SSL_CTX_use_certificate_file(htp->ssl_ctx, cfg->pemfile, 1);
    if(!(cfg->privfile == ((char *)NULL)))
      tmp_if_expr_4 = cfg->privfile;

    else
      tmp_if_expr_4 = cfg->pemfile;
    SSL_CTX_use_PrivateKey_file(htp->ssl_ctx, tmp_if_expr_4, 1);
    SSL_CTX_set_session_id_context(htp->ssl_ctx, (const unsigned char *)(void *)&session_id_context, (unsigned int)sizeof(signed int) /*4ul*/ );
    SSL_CTX_set_ex_data(htp->ssl_ctx, 0, (void *)(char *)htp);
    SSL_CTX_ctrl(htp->ssl_ctx, 44, cache_mode, (void *)0);
    if(!(cache_mode == 0l))
    {
      if(!(cfg->scache_size == 0l))
        tmp_if_expr_5 = cfg->scache_size;

      else
        tmp_if_expr_5 = (signed long int)1024;
      SSL_CTX_ctrl(htp->ssl_ctx, 42, tmp_if_expr_5, (void *)0);
      if((signed int)cfg->scache_type == evhtp_ssl_scache_type_builtin)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)cfg->scache_type == evhtp_ssl_scache_type_user ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        SSL_CTX_sess_set_new_cb(htp->ssl_ctx, _evhtp_ssl_add_scache_ent);
        SSL_CTX_sess_set_get_cb(htp->ssl_ctx, _evhtp_ssl_get_scache_ent);
        SSL_CTX_sess_set_remove_cb(htp->ssl_ctx, _evhtp_ssl_delete_scache_ent);
        if(!(cfg->scache_init == ((void * (*)(struct evhtp_s *))NULL)))
          cfg->args=cfg->scache_init(htp);

      }

    }

    return 0;
  }
}

// evhtp_ssl_use_threads
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3734
signed int evhtp_ssl_use_threads(void)
{
  signed int i;
  if(ssl_locks_initialized == 1)
    return 0;

  else
  {
    ssl_locks_initialized = 1;
    ssl_num_locks=CRYPTO_num_locks();
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)ssl_num_locks * sizeof(union anonymous_8) /*40ul*/ );
    ssl_locks = (union anonymous_8 *)return_value_malloc_1;
    i = 0;
    for( ; !(i >= ssl_num_locks); i = i + 1)
      pthread_mutex_init(&ssl_locks[(signed long int)i], (const union anonymous_9 *)(void *)0);
    CRYPTO_set_id_callback(_evhtp_ssl_get_thread_id);
    CRYPTO_set_locking_callback(_evhtp_ssl_thread_lock);
    return 0;
  }
}

// evhtp_unbind_socket
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 819
void evhtp_unbind_socket(struct evhtp_s *htp)
{
  do
  {
    evconnlistener_free(htp->server);
    htp->server = (struct evconnlistener *)(void *)0;
  }
  while((_Bool)0);
}

// evhtp_unescape_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 2689
signed int evhtp_unescape_string(unsigned char **out, unsigned char *str, unsigned long int str_len)
{
  unsigned char *optr;
  unsigned char *sptr;
  unsigned char d;
  unsigned char ch;
  unsigned char c;
  unsigned long int i;
  enum unscape_state state;
  _Bool tmp_if_expr_1;
  if(out == ((unsigned char **)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *out == (unsigned char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  unsigned char *tmp_post_4;
  unsigned char *tmp_post_5;
  unsigned char *tmp_post_6;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    state = (enum unscape_state)unscape_state_start;
    optr = *out;
    sptr = str;
    d = (unsigned char)0;
    i = (unsigned long int)0;
    for( ; !(i >= str_len); i = i + 1ul)
    {
      tmp_post_2 = sptr;
      sptr = sptr + 1l;
      ch = *tmp_post_2;
      switch((signed int)state)
      {
        case unscape_state_start:
        {
          if((signed int)ch == 37)
          {
            state = (enum unscape_state)unscape_state_hex1;
            break;
          }

          tmp_post_3 = optr;
          optr = optr + 1l;
          *tmp_post_3 = ch;
          break;
        }
        case unscape_state_hex1:
        {
          if((signed int)ch >= 48 && !((signed int)ch >= 58))
          {
            d = (unsigned char)((signed int)ch - 48);
            state = (enum unscape_state)unscape_state_hex2;
            break;
          }

          c = (unsigned char)((signed int)ch | 0x20);
          if((signed int)c >= 97 && !((signed int)c >= 103))
          {
            d = (unsigned char)(((signed int)c - 97) + 10);
            state = (enum unscape_state)unscape_state_hex2;
            break;
          }

          state = (enum unscape_state)unscape_state_start;
          tmp_post_4 = optr;
          optr = optr + 1l;
          *tmp_post_4 = ch;
          break;
        }
        case unscape_state_hex2:
        {
          state = (enum unscape_state)unscape_state_start;
          if((signed int)ch >= 48 && !((signed int)ch >= 58))
          {
            ch = (unsigned char)((((signed int)d << 4) + (signed int)ch) - 48);
            tmp_post_5 = optr;
            optr = optr + 1l;
            *tmp_post_5 = ch;
          }

          else
          {
            c = (unsigned char)((signed int)ch | 0x20);
            if((signed int)c >= 97 && !((signed int)c >= 103))
            {
              ch = (unsigned char)(((((signed int)d << 4) + (signed int)c) - 97) + 10);
              tmp_post_6 = optr;
              optr = optr + 1l;
              *tmp_post_6 = ch;
            }

          }
        }
      }
    }
    return 0;
  }
}

// evhtp_unset_all_hooks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3483
signed int evhtp_unset_all_hooks(struct evhtp_hooks_s **hooks)
{
  signed int res = 0;
  signed int return_value_evhtp_unset_hook_1;
  return_value_evhtp_unset_hook_1=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_headers_start);
  if(!(return_value_evhtp_unset_hook_1 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_2;
  return_value_evhtp_unset_hook_2=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_header);
  if(!(return_value_evhtp_unset_hook_2 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_3;
  return_value_evhtp_unset_hook_3=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_headers);
  if(!(return_value_evhtp_unset_hook_3 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_4;
  return_value_evhtp_unset_hook_4=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_path);
  if(!(return_value_evhtp_unset_hook_4 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_5;
  return_value_evhtp_unset_hook_5=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_read);
  if(!(return_value_evhtp_unset_hook_5 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_6;
  return_value_evhtp_unset_hook_6=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_request_fini);
  if(!(return_value_evhtp_unset_hook_6 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_7;
  return_value_evhtp_unset_hook_7=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_connection_fini);
  if(!(return_value_evhtp_unset_hook_7 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_8;
  return_value_evhtp_unset_hook_8=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_conn_error);
  if(!(return_value_evhtp_unset_hook_8 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_9;
  return_value_evhtp_unset_hook_9=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_error);
  if(!(return_value_evhtp_unset_hook_9 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_10;
  return_value_evhtp_unset_hook_10=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_new_chunk);
  if(!(return_value_evhtp_unset_hook_10 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_11;
  return_value_evhtp_unset_hook_11=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_chunk_complete);
  if(!(return_value_evhtp_unset_hook_11 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_12;
  return_value_evhtp_unset_hook_12=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_chunks_complete);
  if(!(return_value_evhtp_unset_hook_12 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_13;
  return_value_evhtp_unset_hook_13=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_hostname);
  if(!(return_value_evhtp_unset_hook_13 == 0))
    res = res - 1;

  signed int return_value_evhtp_unset_hook_14;
  return_value_evhtp_unset_hook_14=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_write);
  if(!(return_value_evhtp_unset_hook_14 == 0))
    return -1;

  else
  {
    signed int return_value_evhtp_unset_hook_15;
    return_value_evhtp_unset_hook_15=evhtp_unset_hook(hooks, (enum evhtp_hook_type)evhtp_hook_on_event);
    if(!(return_value_evhtp_unset_hook_15 == 0))
      return -1;

    else
      return res;
  }
}

// evhtp_unset_hook
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3478
signed int evhtp_unset_hook(struct evhtp_hooks_s **hooks, enum evhtp_hook_type type)
{
  signed int return_value_evhtp_set_hook_1;
  return_value_evhtp_set_hook_1=evhtp_set_hook(hooks, type, (unsigned short int (*)())(void *)0, (void *)0);
  return return_value_evhtp_set_hook_1;
}

// evhtp_use_callback_locks
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 3628
signed int evhtp_use_callback_locks(struct evhtp_s *htp)
{
  if(htp == ((struct evhtp_s *)NULL))
    return -1;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(union anonymous_8) /*40ul*/ );
    htp->lock = (union anonymous_8 *)return_value_malloc_1;
    if(htp->lock == ((union anonymous_8 *)NULL))
      return -1;

    else
    {
      signed int return_value_pthread_mutex_init_2;
      return_value_pthread_mutex_init_2=pthread_mutex_init(htp->lock, (const union anonymous_9 *)(void *)0);
      return return_value_pthread_mutex_init_2;
    }
  }
}

// evhtp_use_threads
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/../evhtp.h line 848
signed int evhtp_use_threads(struct evhtp_s *htp, void (*init_cb)(struct evhtp_s *, struct evthr *, void *), signed int nthreads, void *arg)
{
  htp->thread_init_cb = init_cb;
  htp->thread_init_cbarg = arg;
  evhtp_ssl_use_threads();
  htp->thr_pool=evthr_pool_new(nthreads, _evhtp_thread_init, (void *)htp);
  if(htp->thr_pool == ((struct evthr_pool *)NULL))
    return -1;

  else
  {
    evthr_pool_start(htp->thr_pool);
    return 0;
  }
}

// evthr_defer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 138
enum evthr_res evthr_defer(struct evthr *thread, void (*cb)(struct evthr *, void *, void *), void *arg)
{
  struct evthr_cmd cmd = { .stop=(unsigned char)0, .args=arg, .cb=cb };
  signed long int return_value_send_1;
  return_value_send_1=send(thread->wdr, (const void *)&cmd, sizeof(struct evthr_cmd) /*17ul*/ , 0);
  if(!(return_value_send_1 >= 1l))
    return (enum evthr_res)EVTHR_RES_RETRY;

  else
    return (enum evthr_res)EVTHR_RES_OK;
}

// evthr_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 227
void evthr_free(struct evthr *thread)
{
  if(!(thread == ((struct evthr *)NULL)))
  {
    if(thread->rdr >= 1)
      close(thread->rdr);

    if(thread->wdr >= 1)
      close(thread->wdr);

    if(!(thread->thr == ((unsigned long int *)NULL)))
      free((void *)thread->thr);

    if(!(thread->event == ((struct event *)NULL)))
      event_free(thread->event);

    if(!(thread->evbase == ((struct event_base *)NULL)))
      event_base_free(thread->evbase);

    free((void *)thread);
  }

}

// evthr_get_aux
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 179
void * evthr_get_aux(struct evthr *thr)
{
  return thr->aux;
}

// evthr_get_base
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 37
struct event_base * evthr_get_base(struct evthr *thr)
{
  return thr->evbase;
}

// evthr_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 184
struct evthr * evthr_new(void (*init_cb)(struct evthr *, void *), void *args)
{
  struct evthr *thread;
  signed int fds[2l];
  signed int return_value_evutil_socketpair_1;
  return_value_evutil_socketpair_1=evutil_socketpair(1, 1, 0, fds);
  if(return_value_evutil_socketpair_1 == -1)
    return (struct evthr *)(void *)0;

  else
  {
    evutil_make_socket_nonblocking(fds[(signed long int)0]);
    evutil_make_socket_nonblocking(fds[(signed long int)1]);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc(sizeof(struct evthr) /*120ul*/ , (unsigned long int)1);
    thread = (struct evthr *)return_value_calloc_2;
    if(thread == ((struct evthr *)NULL))
      return (struct evthr *)(void *)0;

    else
    {
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(unsigned long int) /*8ul*/ );
      thread->thr = (unsigned long int *)return_value_malloc_3;
      thread->init_cb = init_cb;
      thread->arg = args;
      thread->rdr = fds[(signed long int)0];
      thread->wdr = fds[(signed long int)1];
      signed int return_value_pthread_mutex_init_4;
      return_value_pthread_mutex_init_4=pthread_mutex_init(&thread->lock, (const union anonymous_9 *)(void *)0);
      if(!(return_value_pthread_mutex_init_4 == 0))
      {
        evthr_free(thread);
        return (struct evthr *)(void *)0;
      }

      else
        return thread;
    }
  }
}

// evthr_pool_defer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 48
enum evthr_res evthr_pool_defer(struct evthr_pool *pool, void (*cb)(struct evthr *, void *, void *), void *arg)
{
  struct evthr *thr = (struct evthr *)(void *)0;
  if(pool == ((struct evthr_pool *)NULL))
    return (enum evthr_res)EVTHR_RES_FATAL;

  else
    if(cb == ((void (*)(struct evthr *, void *, void *))NULL))
      return (enum evthr_res)EVTHR_RES_NOCB;

    else
    {
      thr = (&pool->threads)->tqh_first;
      do
      {
        if(!(thr->next.tqe_next == ((struct evthr *)NULL)))
          thr->next.tqe_next->next.tqe_prev = thr->next.tqe_prev;

        else
          (&pool->threads)->tqh_last = thr->next.tqe_prev;
        *thr->next.tqe_prev = thr->next.tqe_next;
      }
      while((_Bool)0);
      do
      {
        thr->next.tqe_next = (struct evthr *)(void *)0;
        thr->next.tqe_prev = (&pool->threads)->tqh_last;
        *(&pool->threads)->tqh_last = thr;
        (&pool->threads)->tqh_last = &thr->next.tqe_next;
      }
      while((_Bool)0);
      enum evthr_res return_value_evthr_defer_1;
      return_value_evthr_defer_1=evthr_defer(thr, cb, arg);
      return return_value_evthr_defer_1;
    }
}

// evthr_pool_free
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 49
void evthr_pool_free(struct evthr_pool *pool)
{
  struct evthr *thread;
  struct evthr *save;
  _Bool tmp_if_expr_1;
  if(!(pool == ((struct evthr_pool *)NULL)))
  {
    thread = (&pool->threads)->tqh_first;
    do
    {
      if(!(thread == ((struct evthr *)NULL)))
      {
        save = thread->next.tqe_next;
        tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      do
      {
        if(!(thread->next.tqe_next == ((struct evthr *)NULL)))
          thread->next.tqe_next->next.tqe_prev = thread->next.tqe_prev;

        else
          (&pool->threads)->tqh_last = thread->next.tqe_prev;
        *thread->next.tqe_prev = thread->next.tqe_next;
      }
      while((_Bool)0);
      evthr_free(thread);
      thread = save;
    }
    while((_Bool)1);
    free((void *)pool);
  }

}

// evthr_pool_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 45
struct evthr_pool * evthr_pool_new(signed int nthreads, void (*init_cb)(struct evthr *, void *), void *shared)
{
  struct evthr_pool *pool;
  signed int i;
  if(nthreads == 0)
    return (struct evthr_pool *)(void *)0;

  else
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc(sizeof(struct evthr_pool) /*24ul*/ , (unsigned long int)1);
    pool = (struct evthr_pool *)return_value_calloc_1;
    if(pool == ((struct evthr_pool *)NULL))
      return (struct evthr_pool *)(void *)0;

    else
    {
      pool->nthreads = nthreads;
      do
      {
        (&pool->threads)->tqh_first = (struct evthr *)(void *)0;
        (&pool->threads)->tqh_last = &(&pool->threads)->tqh_first;
      }
      while((_Bool)0);
      i = 0;
      for( ; !(i >= nthreads); i = i + 1)
      {
        struct evthr *thread;
        thread=evthr_new(init_cb, shared);
        if(thread == ((struct evthr *)NULL))
        {
          evthr_pool_free(pool);
          return (struct evthr_pool *)(void *)0;
        }

        do
        {
          thread->next.tqe_next = (struct evthr *)(void *)0;
          thread->next.tqe_prev = (&pool->threads)->tqh_last;
          *(&pool->threads)->tqh_last = thread;
          (&pool->threads)->tqh_last = &thread->next.tqe_next;
        }
        while((_Bool)0);
      }
      return pool;
    }
  }
}

// evthr_pool_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 46
signed int evthr_pool_start(struct evthr_pool *pool)
{
  struct evthr *evthr = (struct evthr *)(void *)0;
  if(pool == ((struct evthr_pool *)NULL))
    return -1;

  else
  {
    evthr = (&pool->threads)->tqh_first;
    for( ; !(evthr == ((struct evthr *)NULL)); evthr = evthr->next.tqe_next)
    {
      signed int return_value_evthr_start_1;
      return_value_evthr_start_1=evthr_start(evthr);
      if(!(return_value_evthr_start_1 >= 0))
        return -1;

      usleep((unsigned int)5000);
    }
    return 0;
  }
}

// evthr_pool_stop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.h line 47
enum evthr_res evthr_pool_stop(struct evthr_pool *pool)
{
  struct evthr *thr;
  struct evthr *save;
  _Bool tmp_if_expr_1;
  if(pool == ((struct evthr_pool *)NULL))
    return (enum evthr_res)EVTHR_RES_FATAL;

  else
  {
    thr = (&pool->threads)->tqh_first;
    do
    {
      if(!(thr == ((struct evthr *)NULL)))
      {
        save = thr->next.tqe_next;
        tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      evthr_stop(thr);
      thr = save;
    }
    while((_Bool)1);
    return (enum evthr_res)EVTHR_RES_OK;
  }
}

// evthr_set_aux
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 174
void evthr_set_aux(struct evthr *thr, void *aux)
{
  thr->aux = aux;
}

// evthr_start
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 214
signed int evthr_start(struct evthr *thread)
{
  _Bool tmp_if_expr_1;
  if(thread == ((struct evthr *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = thread->thr == (unsigned long int *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return -1;

  else
  {
    signed int return_value_pthread_create_2;
    return_value_pthread_create_2=pthread_create(thread->thr, (const union pthread_attr_t *)(void *)0, _evthr_loop, (void *)thread);
    if(!(return_value_pthread_create_2 == 0))
      return -1;

    else
      return 0;
  }
}

// evthr_stop
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evthr.c line 153
enum evthr_res evthr_stop(struct evthr *thread)
{
  struct evthr_cmd cmd = { .stop=(unsigned char)1, .args=(void *)0, .cb=(void (*)(struct evthr *, void *, void *))(void *)0 };
  signed long int return_value_send_1;
  return_value_send_1=send(thread->wdr, (const void *)&cmd, sizeof(struct evthr_cmd) /*17ul*/ , 0);
  if(!(return_value_send_1 >= 0l))
    return (enum evthr_res)EVTHR_RES_RETRY;

  else
  {
    pthread_join(*thread->thr, (void **)(void *)0);
    return (enum evthr_res)EVTHR_RES_OK;
  }
}

// get_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 518
static enum htp_method get_method(const char *m, const unsigned long int sz)
{
  switch(sz)
  {
    case (const unsigned long int)3:
    {
      if(*((unsigned int *)m) == 5522759u)
        return (enum htp_method)htp_method_GET;

      if(*((unsigned int *)m) == 5526864u)
        return (enum htp_method)htp_method_PUT;

      goto __CPROVER_DUMP_L24;
    }
    case (const unsigned long int)4:
    {
      if((signed int)m[1l] == 79)
      {
        if(*((unsigned int *)m) == 1414745936u)
          return (enum htp_method)htp_method_POST;

        if(*((unsigned int *)m) == 1498435395u)
          return (enum htp_method)htp_method_COPY;

        if(*((unsigned int *)m) == 1163284301u)
          return (enum htp_method)htp_method_MOVE;

        if(*((unsigned int *)m) == 1262702412u)
          return (enum htp_method)htp_method_LOCK;

      }

      else
        if(*((unsigned int *)m) == 1145128264u)
          return (enum htp_method)htp_method_HEAD;

      goto __CPROVER_DUMP_L24;
    }
    case (const unsigned long int)5:
    {
      if(*((unsigned int *)m) == 1329810253u)
      {
        if((signed int)m[4l] == 76)
          return (enum htp_method)htp_method_MKCOL;

      }

      if(*((unsigned int *)m) == 1128354388u)
      {
        if((signed int)m[4l] == 69)
          return (enum htp_method)htp_method_TRACE;

      }

      if(*((unsigned int *)m) == 1129595216u)
      {
        if((signed int)m[4l] == 72)
          return (enum htp_method)htp_method_PATCH;

      }

      goto __CPROVER_DUMP_L24;
    }
    case (const unsigned long int)6:
    {
      if(*((unsigned int *)m) == 1162626372u)
      {
        if((65535u & ((unsigned int *)m)[1l]) == 17748u)
          return (enum htp_method)htp_method_DELETE;

      }

      if(*((unsigned int *)m) == 1330400853u)
      {
        if((65535u & ((unsigned int *)m)[1l]) == 19267u)
          return (enum htp_method)htp_method_UNLOCK;

      }

      goto __CPROVER_DUMP_L24;
    }
    case (const unsigned long int)7:
    {
      if(*((unsigned int *)m) == 1230262351u)
      {
        if(((unsigned int *)m)[1l] == 5459535u)
          return (enum htp_method)htp_method_OPTIONS;

      }

      if(*((unsigned int *)m) == 1313754947u)
      {
        if(((unsigned int *)m)[1l] == 5522245u)
          return (enum htp_method)htp_method_CONNECT;

      }

      goto __CPROVER_DUMP_L24;
    }
    case (const unsigned long int)8:
    {
      if(*((unsigned int *)m) == 1347375696u)
      {
        if(((unsigned int *)m)[1l] == 1145981254u)
          return (enum htp_method)htp_method_PROPFIND;

      }

      goto __CPROVER_DUMP_L24;
    }
    case (const unsigned long int)9:
      if(*((unsigned int *)m) == 1347375696u)
      {
        if(((unsigned int *)m)[1l] == 1129595216u)
        {
          if((signed int)m[8l] == 72)
            return (enum htp_method)htp_method_PROPPATCH;

        }

      }

    default:
    {

    __CPROVER_DUMP_L24:
      ;
      return (enum htp_method)htp_method_UNKNOWN;
    }
  }
}

// hook_args_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 298
static inline signed int hook_args_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->args == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->args(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_body_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 302
static inline signed int hook_body_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->body == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->body(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_hdr_key_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 300
static inline signed int hook_hdr_key_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->hdr_key == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->hdr_key(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_hdr_val_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 301
static inline signed int hook_hdr_val_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->hdr_val == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->hdr_val(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_host_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 295
static inline signed int hook_host_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->host == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->host(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_hostname_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 303
static inline signed int hook_hostname_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->hostname == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->hostname(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_method_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 293
static inline signed int hook_method_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->method == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->method(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_on_chunk_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 289
static inline signed int hook_on_chunk_complete_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_chunk_complete == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_chunk_complete(p);
      return return_value;
    }

  }

  return 0;
}

// hook_on_chunks_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 290
static inline signed int hook_on_chunks_complete_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_chunks_complete == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_chunks_complete(p);
      return return_value;
    }

  }

  return 0;
}

// hook_on_hdrs_begin_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 286
static inline signed int hook_on_hdrs_begin_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_hdrs_begin == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_hdrs_begin(p);
      return return_value;
    }

  }

  return 0;
}

// hook_on_hdrs_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 287
static inline signed int hook_on_hdrs_complete_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_hdrs_complete == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_hdrs_complete(p);
      return return_value;
    }

  }

  return 0;
}

// hook_on_msg_begin_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 285
static inline signed int hook_on_msg_begin_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_msg_begin == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_msg_begin(p);
      return return_value;
    }

  }

  return 0;
}

// hook_on_msg_complete_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 291
static inline signed int hook_on_msg_complete_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_msg_complete == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_msg_complete(p);
      return return_value;
    }

  }

  return 0;
}

// hook_on_new_chunk_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 288
static inline signed int hook_on_new_chunk_run(struct htparser *p, struct htparse_hooks *hooks)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->on_new_chunk == ((signed int (*)(struct htparser *))NULL)))
    {
      signed int return_value;
      return_value=hooks->on_new_chunk(p);
      return return_value;
    }

  }

  return 0;
}

// hook_path_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 297
static inline signed int hook_path_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->path == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->path(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_port_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 296
static inline signed int hook_port_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->port == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->port(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_scheme_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 294
static inline signed int hook_scheme_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->scheme == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->scheme(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// hook_uri_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 299
static inline signed int hook_uri_run(struct htparser *p, struct htparse_hooks *hooks, const char *s, unsigned long int l)
{

__CPROVER_DUMP_L1:
  ;
  if(!(hooks == ((struct htparse_hooks *)NULL)))
  {
    if(!(hooks->uri == ((signed int (*)(struct htparser *, const char *, unsigned long int))NULL)))
    {
      signed int return_value;
      return_value=hooks->uri(p, s, l);
      return return_value;
    }

  }

  return 0;
}

// htparser_get_bytes_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 477
unsigned long int htparser_get_bytes_read(struct htparser *p)
{
  return p->bytes_read;
}

// htparser_get_content_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 109
unsigned long int htparser_get_content_length(struct htparser *p)
{
  return p->orig_content_len;
}

// htparser_get_content_pending
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 467
unsigned long int htparser_get_content_pending(struct htparser *p)
{
  return p->content_len;
}

// htparser_get_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 112
enum htpparse_error htparser_get_error(struct htparser *p)
{
  return p->error;
}

// htparser_get_major
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 105
unsigned char htparser_get_major(struct htparser *p)
{
  return p->major;
}

// htparser_get_method
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 100
enum htp_method htparser_get_method(struct htparser *p)
{
  return p->method;
}

// htparser_get_methodstr
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 427
const char * htparser_get_methodstr(struct htparser *p)
{
  const char *return_value_htparser_get_methodstr_m_1;
  return_value_htparser_get_methodstr_m_1=htparser_get_methodstr_m(p->method);
  return return_value_htparser_get_methodstr_m_1;
}

// htparser_get_methodstr_m
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 102
const char * htparser_get_methodstr_m(enum htp_method meth)
{
  if((signed int)meth >= htp_method_UNKNOWN)
    return (const char *)(void *)0;

  else
    return method_strmap[(signed long int)meth];
}

// htparser_get_minor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 106
unsigned char htparser_get_minor(struct htparser *p)
{
  return p->minor;
}

// htparser_get_multipart
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 107
unsigned char htparser_get_multipart(struct htparser *p)
{
  return p->multipart;
}

// htparser_get_scheme
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 99
enum htp_scheme htparser_get_scheme(struct htparser *p)
{
  return p->scheme;
}

// htparser_get_status
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 108
unsigned int htparser_get_status(struct htparser *p)
{
  return p->status;
}

// htparser_get_strerror
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 373
const char * htparser_get_strerror(struct htparser *p)
{
  enum htpparse_error e;
  e=htparser_get_error(p);
  if((signed int)e >= 14)
    return "htparse_no_such_error";

  else
    return errstr_map[(signed long int)e];
}

// htparser_get_total_bytes_read
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 482
unsigned long int htparser_get_total_bytes_read(struct htparser *p)
{
  return p->total_bytes_read;
}

// htparser_get_userdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 114
void * htparser_get_userdata(struct htparser *p)
{
  return p->userdata;
}

// htparser_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 116
void htparser_init(struct htparser *p, enum htp_type type)
{
  memset((void *)p, 0, 124ul);
  p->buf[(signed long int)0] = (char)0;
  p->state = (enum parser_state)s_start;
  p->error = (enum htpparse_error)htparse_error_none;
  p->method = (enum htp_method)htp_method_UNKNOWN;
  p->type = type;
}

// htparser_new
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 117
struct htparser * htparser_new(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct htparser) /*8320ul*/ );
  return (struct htparser *)return_value_malloc_1;
}

// htparser_run
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 97
unsigned long int htparser_run(struct htparser *p, struct htparse_hooks *hooks, const char *data, unsigned long int len)
{
  unsigned char ch;
  char c;
  unsigned long int i;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  p->error = (enum htpparse_error)htparse_error_none;
  p->bytes_read = (unsigned long int)0;
  i = (unsigned long int)0;
  unsigned int tmp_post_1;
  unsigned int tmp_post_2;
  unsigned int tmp_post_3;
  signed int return_value_is_host_char_4;
  unsigned int tmp_post_5;
  unsigned int tmp_post_6;
  unsigned int tmp_post_7;
  unsigned int tmp_post_8;
  unsigned int tmp_post_9;
  unsigned int tmp_post_10;
  unsigned int tmp_post_11;
  unsigned int tmp_post_12;
  signed int return_value_is_host_char_14;
  unsigned int tmp_post_13;
  unsigned int tmp_post_15;
  unsigned int tmp_post_16;
  unsigned int tmp_post_17;
  unsigned int tmp_post_18;
  unsigned int tmp_post_19;
  unsigned int tmp_post_20;
  unsigned int tmp_post_21;
  unsigned int tmp_post_22;
  unsigned int tmp_post_23;
  unsigned int tmp_post_24;
  unsigned int tmp_post_25;
  unsigned int tmp_post_26;
  unsigned int tmp_post_27;
  unsigned int tmp_post_28;
  unsigned int tmp_post_29;
  unsigned int tmp_post_30;
  unsigned int tmp_post_31;
  unsigned int tmp_post_32;
  signed int return_value_strcasecmp_33;
  signed int return_value_strcasecmp_34;
  signed int return_value_strcasecmp_35;
  signed int return_value_strcasecmp_36;
  signed int return_value_strcasecmp_37;
  signed int return_value_strcasecmp_38;
  unsigned int tmp_post_39;
  unsigned int tmp_post_40;
  unsigned int tmp_post_41;
  signed int return_value_hook_hostname_run_42;
  char A_case;
  char C_case;
  const char *S_buf;
  const char *htparser_run__1__3__1__3__67__2__1__6__S_buf;
  const char *htparser_run__1__3__1__3__67__2__1__8__S_buf;
  unsigned int tmp_post_43;
  unsigned int tmp_post_44;
  unsigned long int tmp_if_expr_45;
  signed int return_value_hook_on_chunk_complete_run_46;
  unsigned long int tmp_if_expr_47;
  for( ; !(i >= len); i = i + 1ul)
  {
    signed int res;
    signed int err;
    ch = (unsigned char)data[(signed long int)i];

  __CPROVER_DUMP_L4:
    ;
    if((unsigned long int)p->buf_idx >= sizeof(char [8192l]) /*8192ul*/ )
    {
      p->error = (enum htpparse_error)htparse_error_too_big;
      return i + (unsigned long int)1;
    }

    p->total_bytes_read = p->total_bytes_read + (unsigned long int)1;
    p->bytes_read = p->bytes_read + (unsigned long int)1;
    switch((signed int)p->state)
    {
      case s_start:
      {

      __CPROVER_DUMP_L6:
        ;
        if(ch == 10 || ch == 13)
          break;

        if(!((signed int)ch == 95) && ((signed int)ch >= 91 || !((signed int)ch >= 65)))
        {
          p->error = (enum htpparse_error)htparse_error_inval_reqline;
          return i + (unsigned long int)1;
        }

        p->flags = (enum parser_flags)0;
        p->error = (enum htpparse_error)htparse_error_none;
        p->method = (enum htp_method)htp_method_UNKNOWN;
        p->multipart = (unsigned char)0;
        p->major = (unsigned char)0;
        p->minor = (unsigned char)0;
        p->content_len = (unsigned long int)0;
        p->orig_content_len = (unsigned long int)0;
        p->status = (unsigned int)0;
        p->status_count = (unsigned int)0;
        p->scheme_offset = (char *)(void *)0;
        p->host_offset = (char *)(void *)0;
        p->port_offset = (char *)(void *)0;
        p->path_offset = (char *)(void *)0;
        p->args_offset = (char *)(void *)0;
        res=hook_on_msg_begin_run(p, hooks);
        tmp_post_1 = p->buf_idx;
        p->buf_idx = p->buf_idx + 1u;
        p->buf[(signed long int)tmp_post_1] = (char)ch;
        p->buf[(signed long int)p->buf_idx] = (char)0;
        if((signed int)p->type == htp_type_request)
          p->state = (enum parser_state)s_method;

        else
          if((signed int)p->type == htp_type_response && (signed int)ch == 72)
            p->state = (enum parser_state)s_http_H;

          else
          {
            p->error = (enum htpparse_error)htparse_error_inval_reqline;
            return i + (unsigned long int)1;
          }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_method:
      {

      __CPROVER_DUMP_L12:
        ;
        while((_Bool)1)
        {
          if((signed int)ch == 32)
          {
            p->method=get_method(p->buf, (const unsigned long int)p->buf_idx);
            res=hook_method_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_spaces_before_uri;
            if(!(res == 0))
            {
              p->error = (enum htpparse_error)htparse_error_user;
              return i + (unsigned long int)1;
            }

            goto __CPROVER_DUMP_L18;
          }

          else
          {
            if(!((signed int)ch == 95) && ((signed int)ch >= 91 || !((signed int)ch >= 65)))
            {
              p->error = (enum htpparse_error)htparse_error_inval_method;
              return i + (unsigned long int)1;
            }

            tmp_post_2 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_2] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
          }
          i = i + 1ul;
          ch = (unsigned char)data[(signed long int)i];
          if(i >= len)
            break;

        }

      __CPROVER_DUMP_L18:
        ;
        break;
      }
      case s_spaces_before_uri:
      {

      __CPROVER_DUMP_L19:
        ;
        if((signed int)p->method == htp_method_CONNECT)
        {
          switch((signed int)ch)
          {
            case 32:
              break;
            case 91:
            {
              tmp_post_3 = p->buf_idx;
              p->buf_idx = p->buf_idx + 1u;
              p->buf[(signed long int)tmp_post_3] = (char)ch;
              p->buf[(signed long int)p->buf_idx] = (char)0;
              p->host_offset = &p->buf[(signed long int)p->buf_idx];
              p->state = (enum parser_state)s_host_ipv6;
              break;
            }
            default:
            {
              return_value_is_host_char_4=is_host_char(ch);
              if(return_value_is_host_char_4 == 0)
              {
                p->error = (enum htpparse_error)htparse_error_inval_reqline;
                return i + (unsigned long int)1;
              }

              p->host_offset = &p->buf[(signed long int)p->buf_idx];
              tmp_post_5 = p->buf_idx;
              p->buf_idx = p->buf_idx + 1u;
              p->buf[(signed long int)tmp_post_5] = (char)ch;
              p->buf[(signed long int)p->buf_idx] = (char)0;
              p->state = (enum parser_state)s_host;
            }
          }
          break;
        }

        switch((signed int)ch)
        {
          case 32:
            break;
          case 47:
          {
            p->path_offset = &p->buf[(signed long int)p->buf_idx];
            tmp_post_6 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_6] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_after_slash_in_uri;
            break;
          }
          default:
          {
            c = (char)(unsigned char)((signed int)ch | 0x20);
            if((signed int)c >= 97 && !((signed int)c >= 123))
            {
              p->scheme_offset = &p->buf[(signed long int)p->buf_idx];
              tmp_post_7 = p->buf_idx;
              p->buf_idx = p->buf_idx + 1u;
              p->buf[(signed long int)tmp_post_7] = (char)ch;
              p->buf[(signed long int)p->buf_idx] = (char)0;
              p->state = (enum parser_state)s_schema;
            }

            else
            {
              p->error = (enum htpparse_error)htparse_error_inval_reqline;
              return i + (unsigned long int)1;
            }
          }
        }
        break;
      }
      case s_schema:
      {

      __CPROVER_DUMP_L31:
        ;
        c = (char)(unsigned char)((signed int)ch | 0x20);
        if((signed int)c >= 97 && !((signed int)c >= 123))
        {
          tmp_post_8 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_8] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          break;
        }

        if((signed int)ch == 58)
        {
          p->scheme = (enum htp_scheme)htp_scheme_unknown;
          switch(p->buf_idx)
          {
            case (unsigned int)3:
            {
              if(*((unsigned int *)p->scheme_offset) == 7369830u)
              {
                p->scheme = (enum htp_scheme)htp_scheme_ftp;
                break;
              }

              if(*((unsigned int *)p->scheme_offset) == 7562862u)
              {
                p->scheme = (enum htp_scheme)htp_scheme_nfs;
                break;
              }

              break;
            }
            case (unsigned int)4:
            {
              if(*((unsigned int *)p->scheme_offset) == 1886680168u)
              {
                p->scheme = (enum htp_scheme)htp_scheme_http;
                break;
              }

              break;
            }
            case (unsigned int)5:
              if(*((unsigned int *)p->scheme_offset) == 1886680168u)
              {
                if((signed int)p->scheme_offset[4l] == 115)
                  p->scheme = (enum htp_scheme)htp_scheme_https;

              }

          }
          res=hook_scheme_run(p, hooks, p->scheme_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->scheme_offset));
          tmp_post_9 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_9] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          p->state = (enum parser_state)s_schema_slash;
          if(!(res == 0))
          {
            p->error = (enum htpparse_error)htparse_error_user;
            return i + (unsigned long int)1;
          }

          goto __CPROVER_DUMP_L43;
        }

        p->error = (enum htpparse_error)htparse_error_inval_schema;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L43:
        ;
        break;
      }
      case s_schema_slash:
      {

      __CPROVER_DUMP_L44:
        ;
        if((signed int)ch == 47)
        {
          tmp_post_10 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_10] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          p->state = (enum parser_state)s_schema_slash_slash;
          goto __CPROVER_DUMP_L47;
        }

        p->error = (enum htpparse_error)htparse_error_inval_schema;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L47:
        ;
        break;
      }
      case s_schema_slash_slash:
      {

      __CPROVER_DUMP_L48:
        ;
        if((signed int)ch == 47)
        {
          tmp_post_11 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_11] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          p->host_offset = &p->buf[(signed long int)p->buf_idx];
          p->state = (enum parser_state)s_host;
          goto __CPROVER_DUMP_L51;
        }

        p->error = (enum htpparse_error)htparse_error_inval_schema;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L51:
        ;
        break;
      }
      case s_host:
      {
        if((signed int)ch == 91)
        {
          tmp_post_12 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_12] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          p->host_offset = &p->buf[(signed long int)p->buf_idx];
          p->state = (enum parser_state)s_host_ipv6;
          break;
        }

        return_value_is_host_char_14=is_host_char(ch);
        if(!(return_value_is_host_char_14 == 0))
        {
          tmp_post_13 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_13] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          break;
        }

        res=hook_host_run(p, hooks, p->host_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->host_offset));
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

      }
      case s_host_done:
      {
        res = 0;
        switch((signed int)ch)
        {
          case 58:
          {
            tmp_post_15 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_15] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->port_offset = &p->buf[(signed long int)p->buf_idx];
            p->state = (enum parser_state)s_port;
            break;
          }
          case 32:
          {
            if(i == 0ul)
            {
              p->error = (enum htpparse_error)htparse_error_inval_state;
              return i + (unsigned long int)1;
            }

            i = i - 1ul;
            ch = (unsigned char)47;
          }
          case 47:
          {
            p->path_offset = &p->buf[(signed long int)p->buf_idx];
            tmp_post_16 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_16] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_after_slash_in_uri;
            break;
          }
          default:
          {
            p->error = (enum htpparse_error)htparse_error_inval_schema;
            return i + (unsigned long int)1;
          }
        }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_host_ipv6:
      {
        c = (char)(unsigned char)((signed int)ch | 0x20);
        if((signed int)ch == 46 || (signed int)ch == 58 || (signed int)c >= 97 && !((signed int)c >= 103) || (signed int)ch >= 48 && !((signed int)ch >= 58))
        {
          tmp_post_17 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_17] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          break;
        }

        if((signed int)ch == 93)
        {
          res=hook_host_run(p, hooks, p->host_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->host_offset));
          if(!(res == 0))
          {
            p->error = (enum htpparse_error)htparse_error_user;
            return i + (unsigned long int)1;
          }

          tmp_post_18 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_18] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          p->state = (enum parser_state)s_host_done;
          goto __CPROVER_DUMP_L68;
        }

        p->error = (enum htpparse_error)htparse_error_inval_schema;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L68:
        ;
        break;
      }
      case s_port:
      {
        res = 0;
        if((signed int)ch >= 48 && !((signed int)ch >= 58))
        {
          tmp_post_19 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_19] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          break;
        }

        res=hook_port_run(p, hooks, p->port_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->port_offset));
        switch((signed int)ch)
        {
          case 32:
          {
            if(i == 0ul)
            {
              p->error = (enum htpparse_error)htparse_error_inval_state;
              return i + (unsigned long int)1;
            }

            i = i - 1ul;
            ch = (unsigned char)47;
          }
          case 47:
          {
            tmp_post_20 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_20] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->path_offset = &p->buf[(signed long int)(p->buf_idx - (unsigned int)1)];
            p->state = (enum parser_state)s_after_slash_in_uri;
            break;
          }
          default:
          {
            p->error = (enum htpparse_error)htparse_error_inval_reqline;
            return i + (unsigned long int)1;
          }
        }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_after_slash_in_uri:
      {

      __CPROVER_DUMP_L77:
        ;
        res = 0;
        if(!((usual[(signed long int)((signed int)ch >> 5)] & (unsigned int)(1 << (0x1f & (signed int)ch))) == 0u))
        {
          tmp_post_21 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_21] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          p->state = (enum parser_state)s_check_uri;
          break;
        }

        switch((signed int)ch)
        {
          case 32:
          {
            signed int htparser_run__1__3__1__3__32__1__r1;
            htparser_run__1__3__1__3__32__1__r1=hook_path_run(p, hooks, p->path_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->path_offset));
            signed int r2;
            r2=hook_uri_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
            p->state = (enum parser_state)s_http_09;
            p->buf_idx = (unsigned int)0;
            if(!(htparser_run__1__3__1__3__32__1__r1 == 0) || !(r2 == 0))
              res = 1;

            break;
          }
          case (signed int)(unsigned char)13:
          {
            p->minor = (unsigned char)9;
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->minor = (unsigned char)9;
            p->state = (enum parser_state)s_hdrline_start;
            break;
          }
          case 46:

          case 37:

          case 47:

          case 35:
          {
            tmp_post_22 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_22] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_uri;
            break;
          }
          case 63:
          {
            res=hook_path_run(p, hooks, p->path_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->path_offset));
            tmp_post_23 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_23] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->args_offset = &p->buf[(signed long int)p->buf_idx];
            p->state = (enum parser_state)s_uri;
            break;
          }
          default:
          {
            tmp_post_24 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_24] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_check_uri;
          }
        }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_check_uri:
      {
        res = 0;

      __CPROVER_DUMP_L89:
        ;
        while((_Bool)1)
        {
          if(!((usual[(signed long int)((signed int)ch >> 5)] & (unsigned int)(1 << (0x1f & (signed int)ch))) == 0u))
          {
            tmp_post_25 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_25] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
          }

          else
            break;
          i = i + 1ul;
          ch = (unsigned char)data[(signed long int)i];
          if(i >= len)
            break;

        }
        switch((signed int)ch)
        {
          case 32:
          {
            signed int r1 = 0;
            signed int htparser_run__1__3__1__3__35__1__r2 = 0;
            if(!(p->args_offset == ((char *)NULL)))
              r1=hook_args_run(p, hooks, p->args_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->args_offset));

            else
              r1=hook_path_run(p, hooks, p->path_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->path_offset));
            htparser_run__1__3__1__3__35__1__r2=hook_uri_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_http_09;
            if(!(r1 == 0) || !(htparser_run__1__3__1__3__35__1__r2 == 0))
              res = 1;

            break;
          }
          case 47:
          {
            tmp_post_26 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_26] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_after_slash_in_uri;
            break;
          }
          case (signed int)(unsigned char)13:
          {
            p->minor = (unsigned char)9;
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->minor = (unsigned char)9;
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_hdrline_start;
            break;
          }
          case 63:
          {
            res=hook_path_run(p, hooks, p->path_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->path_offset));
            tmp_post_27 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_27] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->args_offset = &p->buf[(signed long int)p->buf_idx];
            p->state = (enum parser_state)s_uri;
            break;
          }
          default:
          {
            tmp_post_28 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_28] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_uri;
          }
        }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_uri:
      {

      __CPROVER_DUMP_L104:
        ;
        res = 0;
        while((_Bool)1)
        {
          if(!((usual[(signed long int)((signed int)ch >> 5)] & (unsigned int)(1 << (0x1f & (signed int)ch))) == 0u))
          {
            tmp_post_29 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_29] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
          }

          else
            goto __CPROVER_DUMP_L108;
          i = i + 1ul;
          ch = (unsigned char)data[(signed long int)i];
          if(i >= len)
            break;

        }

      __CPROVER_DUMP_L108:
        ;
        switch((signed int)ch)
        {
          case 32:
          {
            signed int htparser_run__1__3__1__3__39__1__r1 = 0;
            signed int htparser_run__1__3__1__3__39__1__r2 = 0;
            if(!(p->args_offset == ((char *)NULL)))
              htparser_run__1__3__1__3__39__1__r1=hook_args_run(p, hooks, p->args_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->args_offset));

            else
              htparser_run__1__3__1__3__39__1__r1=hook_path_run(p, hooks, p->path_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->path_offset));
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_http_09;
            if(!(htparser_run__1__3__1__3__39__1__r1 == 0) || !(htparser_run__1__3__1__3__39__1__r2 == 0))
              res = 1;

            break;
          }
          case (signed int)(unsigned char)13:
          {
            p->minor = (unsigned char)9;
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->minor = (unsigned char)9;
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_hdrline_start;
            break;
          }
          case 63:
            if(p->args_offset == ((char *)NULL))
            {
              res=hook_path_run(p, hooks, p->path_offset, (unsigned long int)(&p->buf[(signed long int)p->buf_idx] - p->path_offset));
              tmp_post_30 = p->buf_idx;
              p->buf_idx = p->buf_idx + 1u;
              p->buf[(signed long int)tmp_post_30] = (char)ch;
              p->buf[(signed long int)p->buf_idx] = (char)0;
              p->args_offset = &p->buf[(signed long int)p->buf_idx];
              break;
            }

          default:
          {
            tmp_post_31 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_31] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
          }
        }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_http_09:
      {

      __CPROVER_DUMP_L119:
        ;
        switch((signed int)ch)
        {
          case 32:
            break;
          case (signed int)(unsigned char)13:
          {
            p->minor = (unsigned char)9;
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->minor = (unsigned char)9;
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_hdrline_start;
            break;
          }
          case 72:
          {
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_http_H;
            break;
          }
          default:
          {
            p->error = (enum htpparse_error)htparse_error_inval_proto;
            return i + (unsigned long int)1;
          }
        }
        break;
      }
      case s_http_H:
      {

      __CPROVER_DUMP_L126:
        ;
        if((signed int)ch == 84)
        {
          p->state = (enum parser_state)s_http_HT;
          goto __CPROVER_DUMP_L129;
        }

        p->error = (enum htpparse_error)htparse_error_inval_proto;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L129:
        ;
        break;
      }
      case s_http_HT:
      {
        if((signed int)ch == 84)
        {
          p->state = (enum parser_state)s_http_HTT;
          goto __CPROVER_DUMP_L133;
        }

        p->error = (enum htpparse_error)htparse_error_inval_proto;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L133:
        ;
        break;
      }
      case s_http_HTT:
      {
        if((signed int)ch == 80)
        {
          p->state = (enum parser_state)s_http_HTTP;
          goto __CPROVER_DUMP_L137;
        }

        p->error = (enum htpparse_error)htparse_error_inval_proto;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L137:
        ;
        break;
      }
      case s_http_HTTP:
      {
        if((signed int)ch == 47)
        {
          p->state = (enum parser_state)s_first_major_digit;
          goto __CPROVER_DUMP_L141;
        }

        p->error = (enum htpparse_error)htparse_error_inval_proto;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L141:
        ;
        break;
      }
      case s_first_major_digit:
      {
        if((signed int)ch >= 58 || !((signed int)ch >= 49))
        {
          p->error = (enum htpparse_error)htparse_error_inval_ver;
          return i + (unsigned long int)1;
        }

        p->major = (unsigned char)((signed int)ch - 48);
        p->state = (enum parser_state)s_major_digit;
        break;
      }
      case s_major_digit:
      {
        if((signed int)ch == 46)
        {
          p->state = (enum parser_state)s_first_minor_digit;
          break;
        }

        if((signed int)ch >= 58 || !((signed int)ch >= 48))
        {
          p->error = (enum htpparse_error)htparse_error_inval_ver;
          return i + (unsigned long int)1;
        }

        p->major = (unsigned char)(((signed int)p->major * 10 + (signed int)ch) - 48);
        break;
      }
      case s_first_minor_digit:
      {
        if((signed int)ch >= 58 || !((signed int)ch >= 48))
        {
          p->error = (enum htpparse_error)htparse_error_inval_ver;
          return i + (unsigned long int)1;
        }

        p->minor = (unsigned char)((signed int)ch - 48);
        p->state = (enum parser_state)s_minor_digit;
        break;
      }
      case s_minor_digit:
      {
        switch((signed int)ch)
        {
          case 32:
          {
            if((signed int)p->type == htp_type_request)
              p->state = (enum parser_state)s_spaces_after_digit;

            else
              if((signed int)p->type == htp_type_response)
                p->state = (enum parser_state)s_status;

            break;
          }
          case (signed int)(unsigned char)13:
          {
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->error = (enum htpparse_error)htparse_error_inval_reqline;
            return i + (unsigned long int)1;
          }
          default:
          {
            if((signed int)ch >= 58 || !((signed int)ch >= 48))
            {
              p->error = (enum htpparse_error)htparse_error_inval_ver;
              return i + (unsigned long int)1;
            }

            p->minor = (unsigned char)(((signed int)p->minor * 10 + (signed int)ch) - 48);
          }
        }
        break;
      }
      case s_status:
      {
        if((signed int)ch == 32)
        {
          if(!(p->status == 0u))
            p->state = (enum parser_state)s_status_text;

          break;
        }

        if((signed int)ch >= 58 || !((signed int)ch >= 48))
        {
          p->error = (enum htpparse_error)htparse_error_status;
          return i + (unsigned long int)1;
        }

        p->status = (p->status * (unsigned int)10 + (unsigned int)ch) - (unsigned int)48;
        p->status_count = p->status_count + 1u;
        if(p->status_count == 3u)
          p->state = (enum parser_state)s_space_after_status;

        break;
      }
      case s_space_after_status:
      {
        switch((signed int)ch)
        {
          case 32:
          {
            p->state = (enum parser_state)s_status_text;
            break;
          }
          case (signed int)(unsigned char)13:
          {
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->state = (enum parser_state)s_hdrline_start;
            break;
          }
          default:
          {
            p->error = (enum htpparse_error)htparse_error_generic;
            return i + (unsigned long int)1;
          }
        }
        break;
      }
      case s_status_text:
      {
        switch((signed int)ch)
        {
          case (signed int)(unsigned char)13:
          {
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
            p->state = (enum parser_state)s_hdrline_start;
        }
        break;
      }
      case s_spaces_after_digit:
      {
        switch((signed int)ch)
        {
          case 32:
            break;
          case (signed int)(unsigned char)13:
          {
            p->state = (enum parser_state)s_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->state = (enum parser_state)s_hdrline_start;
            break;
          }
          default:
          {
            p->error = (enum htpparse_error)htparse_error_inval_ver;
            return i + (unsigned long int)1;
          }
        }
        break;
      }
      case s_almost_done:
      {
        if((signed int)ch == 10)
        {
          if((signed int)p->type == htp_type_response)
          {
            if(p->status >= 100u)
            {
              if(!(p->status >= 200u))
              {
                res=hook_on_hdrs_begin_run(p, hooks);
                if(!(res == 0))
                {
                  p->error = (enum htpparse_error)htparse_error_user;
                  return i + (unsigned long int)1;
                }

                p->status = (unsigned int)0;
                p->status_count = (unsigned int)0;
                p->state = (enum parser_state)s_start;
                goto __CPROVER_DUMP_L185;
              }

            }

          }

          p->state = (enum parser_state)s_done;
          res=hook_on_hdrs_begin_run(p, hooks);
          if(!(res == 0))
          {
            p->error = (enum htpparse_error)htparse_error_user;
            return i + (unsigned long int)1;
          }

          goto __CPROVER_DUMP_L185;
        }

        p->error = (enum htpparse_error)htparse_error_inval_reqline;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L185:
        ;
        break;
      }
      case s_done:
      {
        switch((signed int)ch)
        {
          case (signed int)(unsigned char)13:
          {
            p->state = (enum parser_state)s_hdrline_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
            return i + (unsigned long int)1;
          default:
            goto hdrline_start;
        }
        break;
      }
      case s_hdrline_start:
      {
        do

          hdrline_start:
            ;
        while((_Bool)0);
        p->buf_idx = (unsigned int)0;
        switch((signed int)ch)
        {
          case (signed int)(unsigned char)13:
          {
            p->state = (enum parser_state)s_hdrline_hdr_almost_done;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->state = (enum parser_state)s_hdrline_hdr_done;
            break;
          }
          default:
          {
            tmp_post_32 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_32] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_hdrline_hdr_key;
          }
        }
        break;
      }
      case s_hdrline_hdr_key:
      {

      __CPROVER_DUMP_L196:
        ;
        while((_Bool)1)
        {
          if((signed int)ch == 58)
          {
            res=hook_hdr_key_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
            p->heval = (enum eval_hdr_val)eval_hdr_val_none;
            switch(p->buf_idx + (unsigned int)1)
            {
              case (unsigned int)5:
              {
                return_value_strcasecmp_33=strcasecmp(p->buf, "host");
                if(return_value_strcasecmp_33 == 0)
                  p->heval = (enum eval_hdr_val)eval_hdr_val_hostname;

                break;
              }
              case (unsigned int)11:
              {
                return_value_strcasecmp_34=strcasecmp(p->buf, "connection");
                if(return_value_strcasecmp_34 == 0)
                  p->heval = (enum eval_hdr_val)eval_hdr_val_connection;

                break;
              }
              case (unsigned int)13:
              {
                return_value_strcasecmp_35=strcasecmp(p->buf, "content-type");
                if(return_value_strcasecmp_35 == 0)
                  p->heval = (enum eval_hdr_val)eval_hdr_val_content_type;

                break;
              }
              case (unsigned int)15:
              {
                return_value_strcasecmp_36=strcasecmp(p->buf, "content-length");
                if(return_value_strcasecmp_36 == 0)
                  p->heval = (enum eval_hdr_val)eval_hdr_val_content_length;

                break;
              }
              case (unsigned int)17:
              {
                return_value_strcasecmp_37=strcasecmp(p->buf, "proxy-connection");
                if(return_value_strcasecmp_37 == 0)
                  p->heval = (enum eval_hdr_val)eval_hdr_val_proxy_connection;

                break;
              }
              case (unsigned int)18:
              {
                return_value_strcasecmp_38=strcasecmp(p->buf, "transfer-encoding");
                if(return_value_strcasecmp_38 == 0)
                  p->heval = (enum eval_hdr_val)eval_hdr_val_transfer_encoding;

              }
            }
            p->buf_idx = (unsigned int)0;
            p->state = (enum parser_state)s_hdrline_hdr_space_before_val;
            if(!(res == 0))
            {
              p->error = (enum htpparse_error)htparse_error_user;
              return i + (unsigned long int)1;
            }

            goto __CPROVER_DUMP_L217;
          }

          switch((signed int)ch)
          {
            case (signed int)(unsigned char)13:
            {
              p->state = (enum parser_state)s_hdrline_hdr_almost_done;
              break;
            }
            case (signed int)(unsigned char)10:
            {
              p->state = (enum parser_state)s_hdrline_hdr_done;
              break;
            }
            default:
            {
              tmp_post_39 = p->buf_idx;
              p->buf_idx = p->buf_idx + 1u;
              p->buf[(signed long int)tmp_post_39] = (char)ch;
              p->buf[(signed long int)p->buf_idx] = (char)0;
            }
          }
          if(!((signed int)p->state == s_hdrline_hdr_key))
            break;

          i = i + 1ul;
          ch = (unsigned char)data[(signed long int)i];
          if(i >= len)
            break;

        }

      __CPROVER_DUMP_L217:
        ;
        break;
      }
      case s_hdrline_hdr_space_before_val:
      {

      __CPROVER_DUMP_L218:
        ;
        switch((signed int)ch)
        {
          case 32:
            break;
          case (signed int)(unsigned char)13:
          {
            tmp_post_40 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_40] = (char)32;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_hdrline_hdr_val;
            i = i - 1ul;
            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->error = (enum htpparse_error)htparse_error_inval_hdr;
            return i + (unsigned long int)1;
          }
          default:
          {
            tmp_post_41 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_41] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_hdrline_hdr_val;
          }
        }
        break;
      }
      case s_hdrline_hdr_val:
      {
        err = 0;
        res = 0;

      __CPROVER_DUMP_L225:
        ;
        while((_Bool)1)
        {
          if(ch == 13)
          {
            switch((signed int)p->heval)
            {
              case eval_hdr_val_none:
                break;
              case eval_hdr_val_hostname:
              {
                return_value_hook_hostname_run_42=hook_hostname_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
                if(!(return_value_hook_hostname_run_42 == 0))
                {
                  p->state = (enum parser_state)s_hdrline_hdr_almost_done;
                  p->error = (enum htpparse_error)htparse_error_user;
                  return i + (unsigned long int)1;
                }

                break;
              }
              case eval_hdr_val_content_length:
              {
                p->content_len=str_to_uint64(p->buf, (unsigned long int)p->buf_idx, &err);
                p->orig_content_len = p->content_len;

              __CPROVER_DUMP_L230:
                ;
                if(err == 1)
                {
                  p->error = (enum htpparse_error)htparse_error_too_big;
                  return i + (unsigned long int)1;
                }

                break;
              }
              case eval_hdr_val_connection:
                switch((signed int)p->buf[(signed long int)0])
                {
                  case 75:

                  case 107:
                  {
                    if(!(p->buf_idx == 10u))
                      goto __CPROVER_DUMP_L239;

                    A_case = (char)((signed int)p->buf[(signed long int)5] == 65 ? 65 : 97);
                    S_buf = (const char *)(p->buf + (signed long int)1);
                    if(*((unsigned int *)S_buf) == 762340709u)
                    {
                      if(((unsigned int *)S_buf)[1l] == (1986620416u | (unsigned int)(signed int)A_case))
                      {
                        if((signed int)S_buf[8l] == 101)
                          p->flags = p->flags | (enum parser_flags)parser_flag_connection_keep_alive;

                      }

                    }

                    goto __CPROVER_DUMP_L239;
                  }
                  case 99:

                  case 67:
                  {
                    if(!(p->buf_idx == 5u))
                      goto __CPROVER_DUMP_L239;

                    C_case = (char)((signed int)p->buf[(signed long int)0] == 67 ? 67 : 99);
                    S_buf = (const char *)p->buf;
                    if(*((unsigned int *)S_buf) == (1936681984u | (unsigned int)(signed int)C_case))
                    {
                      if((signed int)S_buf[4l] == 101)
                        p->flags = p->flags | (enum parser_flags)parser_flag_connection_close;

                    }

                  }
                  default:
                  {

                  __CPROVER_DUMP_L239:
                    ;
                    goto __CPROVER_DUMP_L250;
                  }
                }
              case eval_hdr_val_transfer_encoding:
              {
                if(!(p->buf_idx == 7u))
                  break;

                if(!((signed int)p->buf[0l] == 67) && !((signed int)p->buf[0l] == 99))
                  goto __CPROVER_DUMP_L244;

                if(p->buf_idx == 7u)
                {
                  htparser_run__1__3__1__3__67__2__1__6__S_buf = (const char *)(p->buf + (signed long int)1);
                  if(*((unsigned int *)htparser_run__1__3__1__3__67__2__1__6__S_buf) == 1802401128u)
                  {
                    if((65535u & ((unsigned int *)htparser_run__1__3__1__3__67__2__1__6__S_buf)[1l]) == 25701u)
                      p->flags = p->flags | (enum parser_flags)parser_flag_chunked;

                  }

                }


              __CPROVER_DUMP_L244:
                ;
                break;
              }
              case eval_hdr_val_content_type:
              {
                if(!(p->buf_idx == 9u))
                  break;

                if(!((signed int)p->buf[0l] == 77) && !((signed int)p->buf[0l] == 109))
                  goto __CPROVER_DUMP_L248;

                htparser_run__1__3__1__3__67__2__1__8__S_buf = (const char *)(p->buf + (signed long int)1);
                if(*((unsigned int *)htparser_run__1__3__1__3__67__2__1__8__S_buf) == 1769237621u)
                {
                  if(((unsigned int *)htparser_run__1__3__1__3__67__2__1__8__S_buf)[1l] == 1953653104u)
                    p->multipart = (unsigned char)1;

                }


              __CPROVER_DUMP_L248:
                ;
                break;
              }
              case eval_hdr_val_proxy_connection:

              default:
                ;
            }

          __CPROVER_DUMP_L250:
            ;
            p->state = (enum parser_state)s_hdrline_hdr_almost_done;
            break;
          }

          if((signed int)ch == 10)
          {
            p->error = (enum htpparse_error)htparse_error_inval_hdr;
            return i + (unsigned long int)1;
          }

          tmp_post_43 = p->buf_idx;
          p->buf_idx = p->buf_idx + 1u;
          p->buf[(signed long int)tmp_post_43] = (char)ch;
          p->buf[(signed long int)p->buf_idx] = (char)0;
          if(!((signed int)p->state == s_hdrline_hdr_val))
            break;

          i = i + 1ul;
          ch = (unsigned char)data[(signed long int)i];
          if(i >= len)
            break;

        }
        break;
      }
      case s_hdrline_hdr_almost_done:
      {

      __CPROVER_DUMP_L255:
        ;
        res = 0;
        if((signed int)ch == 10)
        {
          if(!((parser_flag_trailing & (signed int)p->flags) == 0))
          {
            res=hook_on_msg_complete_run(p, hooks);
            p->state = (enum parser_state)s_start;
            goto __CPROVER_DUMP_L259;
          }

          p->state = (enum parser_state)s_hdrline_hdr_done;
          goto __CPROVER_DUMP_L259;
        }

        p->error = (enum htpparse_error)htparse_error_inval_hdr;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L259:
        ;
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_hdrline_hdr_done:
      {

      __CPROVER_DUMP_L261:
        ;
        switch((signed int)ch)
        {
          case (signed int)(unsigned char)13:
          {
            res=hook_hdr_val_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
            p->state = (enum parser_state)s_hdrline_almost_done;
            if(!(res == 0))
            {
              p->error = (enum htpparse_error)htparse_error_user;
              return i + (unsigned long int)1;
            }

            break;
          }
          case (signed int)(unsigned char)10:
          {
            p->error = (enum htpparse_error)htparse_error_inval_hdr;
            return i + (unsigned long int)1;
          }
          case 9:
          {
            p->state = (enum parser_state)s_hdrline_hdr_val;
            break;
          }
          default:
          {
            res=hook_hdr_val_run(p, hooks, p->buf, (unsigned long int)p->buf_idx);
            p->buf_idx = (unsigned int)0;
            tmp_post_44 = p->buf_idx;
            p->buf_idx = p->buf_idx + 1u;
            p->buf[(signed long int)tmp_post_44] = (char)ch;
            p->buf[(signed long int)p->buf_idx] = (char)0;
            p->state = (enum parser_state)s_hdrline_hdr_key;
            if(!(res == 0))
            {
              p->error = (enum htpparse_error)htparse_error_user;
              return i + (unsigned long int)1;
            }

          }
        }
        break;
      }
      case s_hdrline_almost_done:
      {

      __CPROVER_DUMP_L268:
        ;
        res = 0;
        if((signed int)ch == 10)
        {
          res=hook_on_hdrs_complete_run(p, hooks);
          if(!(res == 0))
          {
            p->error = (enum htpparse_error)htparse_error_user;
            return i + (unsigned long int)1;
          }

          p->buf_idx = (unsigned int)0;

        __CPROVER_DUMP_L271:
          ;
          if(!((parser_flag_trailing & (signed int)p->flags) == 0))
          {
            res=hook_on_msg_complete_run(p, hooks);
            p->state = (enum parser_state)s_start;
          }

          else
            if(!((parser_flag_chunked & (signed int)p->flags) == 0))
              p->state = (enum parser_state)s_chunk_size_start;

            else
              if(p->content_len >= 1ul)
                p->state = (enum parser_state)s_body_read;

              else
                if(p->content_len == 0ul)
                {
                  res=hook_on_msg_complete_run(p, hooks);
                  p->state = (enum parser_state)s_start;
                }

                else
                  p->state = (enum parser_state)s_hdrline_done;
          if(!(res == 0))
          {
            p->error = (enum htpparse_error)htparse_error_user;
            return i + (unsigned long int)1;
          }

          goto __CPROVER_DUMP_L279;
        }

        p->error = (enum htpparse_error)htparse_error_inval_hdr;
        return i + (unsigned long int)1;

      __CPROVER_DUMP_L279:
        ;
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_hdrline_done:
      {

      __CPROVER_DUMP_L281:
        ;
        res = 0;
        if(!((parser_flag_trailing & (signed int)p->flags) == 0))
        {
          res=hook_on_msg_complete_run(p, hooks);
          p->state = (enum parser_state)s_start;
          break;
        }

        else
          if(!((parser_flag_chunked & (signed int)p->flags) == 0))
          {
            p->state = (enum parser_state)s_chunk_size_start;
            i = i - 1ul;
          }

          else
            if(p->content_len >= 1ul)
            {
              p->state = (enum parser_state)s_body_read;
              i = i - 1ul;
            }

            else
              if(p->content_len == 0ul)
              {
                res=hook_on_msg_complete_run(p, hooks);
                p->state = (enum parser_state)s_start;
              }

        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_chunk_size_start:
      {
        c = unhex[(signed long int)(unsigned char)ch];
        if((signed int)c == -1)
        {
          p->error = (enum htpparse_error)htparse_error_inval_chunk_sz;
          return i + (unsigned long int)1;
        }

        p->content_len = (unsigned long int)c;
        p->state = (enum parser_state)s_chunk_size;
        break;
      }
      case s_chunk_size:
      {
        if(ch == 13)
        {
          p->state = (enum parser_state)s_chunk_size_almost_done;
          break;
        }

        c = unhex[(signed long int)(unsigned char)ch];
        if((signed int)c == -1)
        {
          p->error = (enum htpparse_error)htparse_error_inval_chunk_sz;
          return i + (unsigned long int)1;
        }

        p->content_len = p->content_len * (unsigned long int)16;
        p->content_len = p->content_len + (unsigned long int)c;
        break;
      }
      case s_chunk_size_almost_done:
      {
        res = 0;
        if(!(ch == 10))
        {
          p->error = (enum htpparse_error)htparse_error_inval_chunk_sz;
          return i + (unsigned long int)1;
        }

        p->orig_content_len = p->content_len;
        if(p->content_len == 0ul)
        {
          res=hook_on_chunks_complete_run(p, hooks);
          p->flags = p->flags | (enum parser_flags)parser_flag_trailing;
          p->state = (enum parser_state)s_hdrline_start;
        }

        else
        {
          res=hook_on_new_chunk_run(p, hooks);
          p->state = (enum parser_state)s_chunk_data;
        }
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_chunk_data:
      {
        res = 0;
        const char *htparser_run__1__3__1__3__89__pp = &data[(signed long int)i];
        const char *htparser_run__1__3__1__3__89__pe = (const char *)(data + (signed long int)len);
        unsigned long int to_read;
        if(!((unsigned long int)(htparser_run__1__3__1__3__89__pe - htparser_run__1__3__1__3__89__pp) >= p->content_len))
          tmp_if_expr_45 = (unsigned long int)(htparser_run__1__3__1__3__89__pe - htparser_run__1__3__1__3__89__pp);

        else
          tmp_if_expr_45 = p->content_len;
        to_read = tmp_if_expr_45;
        if(to_read >= 1ul)
        {
          res=hook_body_run(p, hooks, htparser_run__1__3__1__3__89__pp, to_read);
          i = i + (to_read - (unsigned long int)1);
        }

        if(to_read == p->content_len)
          p->state = (enum parser_state)s_chunk_data_almost_done;

        p->content_len = p->content_len - to_read;
        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_chunk_data_almost_done:
      {
        if(!(ch == 13))
        {
          p->error = (enum htpparse_error)htparse_error_inval_chunk;
          return i + (unsigned long int)1;
        }

        p->state = (enum parser_state)s_chunk_data_done;
        break;
      }
      case s_chunk_data_done:
      {
        if(!(ch == 10))
        {
          p->error = (enum htpparse_error)htparse_error_inval_chunk;
          return i + (unsigned long int)1;
        }

        p->orig_content_len = (unsigned long int)0;
        p->state = (enum parser_state)s_chunk_size_start;
        return_value_hook_on_chunk_complete_run_46=hook_on_chunk_complete_run(p, hooks);
        if(!(return_value_hook_on_chunk_complete_run_46 == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      case s_body_read:
      {
        res = 0;
        const char *pp = &data[(signed long int)i];
        const char *pe = (const char *)(data + (signed long int)len);
        unsigned long int htparser_run__1__3__1__3__94__to_read;
        if(!((unsigned long int)(pe - pp) >= p->content_len))
          tmp_if_expr_47 = (unsigned long int)(pe - pp);

        else
          tmp_if_expr_47 = p->content_len;
        htparser_run__1__3__1__3__94__to_read = tmp_if_expr_47;
        if(htparser_run__1__3__1__3__94__to_read >= 1ul)
        {
          res=hook_body_run(p, hooks, pp, htparser_run__1__3__1__3__94__to_read);
          i = i + (htparser_run__1__3__1__3__94__to_read - (unsigned long int)1);
          p->content_len = p->content_len - htparser_run__1__3__1__3__94__to_read;
        }

        if(p->content_len == 0ul)
        {
          res=hook_on_msg_complete_run(p, hooks);
          p->state = (enum parser_state)s_start;
        }

        if(!(res == 0))
        {
          p->error = (enum htpparse_error)htparse_error_user;
          return i + (unsigned long int)1;
        }

        break;
      }
      default:
      {

      __CPROVER_DUMP_L314:
        ;
        p->error = (enum htpparse_error)htparse_error_inval_state;
        return i + (unsigned long int)1;
      }
    }
    if((signed int)p->state == s_start)
      return i + (unsigned long int)1;

  }
  return i;
}

// htparser_set_major
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 103
void htparser_set_major(struct htparser *p, unsigned char major)
{
  p->major = major;
}

// htparser_set_minor
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 104
void htparser_set_minor(struct htparser *p, unsigned char minor)
{
  p->minor = minor;
}

// htparser_set_userdata
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 115
void htparser_set_userdata(struct htparser *p, void *ud)
{
  p->userdata = ud;
}

// htparser_should_keep_alive
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.h line 98
signed int htparser_should_keep_alive(struct htparser *p)
{
  _Bool tmp_if_expr_1;
  if((signed int)p->major >= 1)
    tmp_if_expr_1 = (signed int)p->minor > 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(!((parser_flag_connection_close & (signed int)p->flags) == 0))
      return 0;

    else
      return 1;
  }

  else
    if(!((parser_flag_connection_keep_alive & (signed int)p->flags) == 0))
      return 1;

    else
      return 0;
  return 0;
}

// is_host_char
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 503
static signed int is_host_char(unsigned char ch)
{
  char c = (char)(unsigned char)((signed int)ch | 0x20);
  if((signed int)c >= 97 && !((signed int)c >= 123))
    return 1;

  else
    if((signed int)ch == 45 || (signed int)ch == 46 || (signed int)ch >= 48 && !((signed int)ch >= 58))
      return 1;

    else
      return 0;
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 509
signed int main(signed int argc, char **argv)
{
  struct event *ev_sigint;
  struct event_base *evbase = (struct event_base *)(void *)0;
  struct evhtp_s *htp = (struct evhtp_s *)(void *)0;
  struct evhtp_callback_s *cb_1 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_2 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_3 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_4 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_5 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_6 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_7 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_8 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_9 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_10 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_11 = (struct evhtp_callback_s *)(void *)0;
  struct evhtp_callback_s *cb_12 = (struct evhtp_callback_s *)(void *)0;
  signed int return_value_parse_args_1;
  return_value_parse_args_1=parse_args(argc, argv);
  if(!(return_value_parse_args_1 >= 0))
    exit(1);

  signed long int return_value_time_2;
  return_value_time_2=time((signed long int *)(void *)0);
  srand((unsigned int)return_value_time_2);
  evbase=event_base_new();
  htp=evhtp_new(evbase, (void *)0);
  evhtp_set_parser_flags(htp, 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3);
  evhtp_set_max_keepalive_requests(htp, max_keepalives);
  htp->enable_reuseport = (unsigned char)1;
  cb_1=evhtp_set_cb(htp, "/ref", test_default_cb, (void *)"fjdkls");
  do
    if(cb_1 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_1 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 548);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_2=evhtp_set_cb(htp, "/foo", test_foo_cb, (void *)"bar");
  do
    if(cb_2 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_2 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 551);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_3=evhtp_set_cb(htp, "/foo/", test_foo_cb, (void *)"bar");
  do
    if(cb_3 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_3 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 554);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_4=evhtp_set_cb(htp, "/bar", test_bar_cb, (void *)"baz");
  do
    if(cb_4 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_4 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 557);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_5=evhtp_set_cb(htp, "/500", test_500_cb, (void *)"500");
  do
    if(cb_5 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_5 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 560);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_6=evhtp_set_regex_cb(htp, "^(/anything/).*", test_regex, (void *)0);
  do
    if(cb_6 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_6 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 564);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_7=evhtp_set_cb(htp, "/pause", test_pause_cb, (void *)0);
  do
    if(cb_7 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_7 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 567);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_8=evhtp_set_regex_cb(htp, "^/create/(.*)", create_callback, (void *)0);
  do
    if(cb_8 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_8 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 570);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_9=evhtp_set_glob_cb(htp, "*/glob/*", test_glob_cb, (void *)0);
  do
    if(cb_9 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_9 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 573);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_10=evhtp_set_cb(htp, "/max_body_size", test_max_body, (void *)0);
  do
    if(cb_10 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_10 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 576);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_11=evhtp_set_cb(htp, "/chunkme", test_chunking, (void *)0);
  do
    if(cb_11 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_11 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 580);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  cb_12=evhtp_set_cb(htp, "/ownme", test_ownership, (void *)0);
  do
    if(cb_12 == ((struct evhtp_callback_s *)NULL))
    {
      fprintf(stderr, "Assertion failed: %s (%s:%s:%d)\n", (const void *)"cb_12 != NULL", (const void *)"main", (const void *)"/srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c", 586);
      fflush(stderr);
      abort();
    }

  while((_Bool)0);
  evhtp_set_hook(&cb_7->hooks, (enum evhtp_hook_type)evhtp_hook_on_path, (unsigned short int (*)())pause_init_cb, (void *)0);
  evhtp_set_hook(&cb_6->hooks, (enum evhtp_hook_type)evhtp_hook_on_headers, (unsigned short int (*)())test_regex_hdrs_cb, (void *)0);
  evhtp_set_hook(&cb_10->hooks, (enum evhtp_hook_type)evhtp_hook_on_headers, (unsigned short int (*)())set_max_body, (void *)0);
  evhtp_set_gencb(htp, test_default_cb, (void *)"foobarbaz");
  evhtp_set_pre_accept_cb(htp, test_pre_accept, (void *)&bind_port);
  evhtp_set_post_accept_cb(htp, set_my_connection_handlers, (void *)0);
  if(!(ssl_pem == ((char *)NULL)))
  {
    struct evhtp_ssl_cfg_s scfg = { .pemfile=ssl_pem, .privfile=ssl_pem, .cafile=ssl_ca, .capath=ssl_capath,
    .ciphers="RC4+RSA:HIGH:+MEDIUM:+LOW", .named_curve=((char *)NULL),
    .dhparams=((char *)NULL), .ssl_opts=0x01000000L,
    .ssl_ctx_timeout=(signed long int)(60 * 60 * 48), .verify_peer=0x01,
    .verify_depth=42, .x509_verify_cb=dummy_ssl_verify_callback,
    .x509_chk_issued_cb=dummy_check_issued_cb,
    .store_flags=0l,
    .scache_type=(enum evhtp_ssl_scache_type)evhtp_ssl_scache_type_internal, .scache_timeout=(signed long int)1024,
    .scache_size=(signed long int)1024,
    .scache_init=(void * (*)(struct evhtp_s *))(void *)0, .scache_add=(signed int (*)(struct evhtp_connection_s *, unsigned char *, signed int, struct ssl_session_st *))(void *)0,
    .scache_get=(struct ssl_session_st * (*)(struct evhtp_connection_s *, unsigned char *, signed int))(void *)0,
    .scache_del=(void (*)(struct evhtp_s *, unsigned char *, signed int))(void *)0,
    .args=NULL };
    evhtp_ssl_init(htp, &scfg);
  }

  if(!(use_threads == 0))
    evhtp_use_threads(htp, (void (*)(struct evhtp_s *, struct evthr *, void *))(void *)0, num_threads, (void *)0);

  signed int return_value_evhtp_bind_socket_5;
  return_value_evhtp_bind_socket_5=evhtp_bind_socket(htp, bind_addr, bind_port, backlog);
  if(!(return_value_evhtp_bind_socket_5 >= 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    char *return_value_strerror_4;
    return_value_strerror_4=strerror(*return_value___errno_location_3);
    fprintf(stderr, "Could not bind socket: %s\n", return_value_strerror_4);
    exit(-1);
  }

  ev_sigint=event_new(evbase, 2, (signed short int)(0x08 | 0x10), sigint, (void *)evbase);
  event_add(ev_sigint, (struct timeval *)(void *)0);
  event_base_loop(evbase, 0);
  event_free(ev_sigint);
  evhtp_unbind_socket(htp);
  evhtp_free(htp);
  event_base_free(evbase);
  return 0;
}

// output_header
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 261
static signed int output_header(struct evhtp_kv_s *header, void *arg)
{
  struct evbuffer *buf = (struct evbuffer *)arg;
  evbuffer_add_printf(buf, "print_kvs() key = '%s', val = '%s'\n", header->key, header->val);
  return 0;
}

// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 439
signed int parse_args(signed int argc, char **argv)
{
  signed int c;
  signed int return_value_atoi_1;
  signed long long int return_value_atoll_2;
  signed long long int return_value_atoll_3;
  signed long long int return_value_atoll_4;
  do
  {
    c=getopt(argc, argv, optstr);
    if(c == -1)
      break;

    switch(c)
    {
      case 104:
      {
        printf("Usage: %s [opts]\n%s", argv[(signed long int)0], help);
        return -1;
      }
      case 78:
      {
        ext_body=strdup(optarg);
        break;
      }
      case 97:
      {
        bind_addr=strdup(optarg);
        break;
      }
      case 112:
      {
        return_value_atoi_1=atoi(optarg);
        bind_port = (unsigned short int)return_value_atoi_1;
        break;
      }
      case 116:
      {
        use_threads = 1;
        break;
      }
      case 110:
      {
        num_threads=atoi(optarg);
        break;
      }
      case 115:
      {
        ssl_pem=strdup(optarg);
        break;
      }
      case 99:
      {
        ssl_ca=strdup(optarg);
        break;
      }
      case 67:
      {
        ssl_capath=strdup(optarg);
        break;
      }
      case 108:
      {
        return_value_atoll_2=atoll(optarg);
        bw_limit = (unsigned long int)return_value_atoll_2;
        break;
      }
      case 109:
      {
        return_value_atoll_3=atoll(optarg);
        max_keepalives = (unsigned long int)return_value_atoll_3;
        break;
      }
      case 98:
      {
        return_value_atoll_4=atoll(optarg);
        backlog = (signed int)return_value_atoll_4;
        break;
      }
      default:
      {
        printf("Unknown opt %s\n", optarg);
        return -1;
      }
    }
  }
  while((_Bool)1);
  if(num_threads == 0 && !(use_threads == 0))
    num_threads = 4;

  return 0;
}

// pause_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 47
static unsigned short int pause_cb(struct evhtp_request_s *request, struct evhtp_kv_s *header, void *arg)
{
  struct pauser *pause = (struct pauser *)arg;
  signed int s;
  signed int return_value_rand_1;
  return_value_rand_1=rand();
  s = return_value_rand_1 % 1000000;
  printf("pause_cb(%p) pause == %p, timer_ev = %p\n", request->conn, pause, pause->timer_ev);
  printf("pause_cb(%p) k=%s, v=%s timer_ev = %p\n", request->conn, header->key, header->val, pause->timer_ev);
  printf("pause_cb(%p) setting to %ld usec sleep timer_ev = %p\n", request->conn, (signed long int)s, pause->timer_ev);
  pause->tv->tv_sec = (signed long int)0;
  pause->tv->tv_usec = (signed long int)s;
  signed int return_value_event_pending_2;
  return_value_event_pending_2=event_pending(pause->timer_ev, (signed short int)0x01, (struct timeval *)(void *)0);
  if(!(return_value_event_pending_2 == 0))
    event_del(pause->timer_ev);

  event_add(pause->timer_ev, pause->tv);
  return (unsigned short int)1;
}

// pause_connection_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 71
static unsigned short int pause_connection_fini(struct evhtp_connection_s *connection, void *arg)
{
  printf("pause_connection_fini(%p)\n", connection);
  return (unsigned short int)200;
}

// pause_init_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 91
static unsigned short int pause_init_cb(struct evhtp_request_s *req, struct evhtp_path_s *path, void *arg)
{
  struct event_base *evbase = req->conn->evbase;
  struct pauser *pause;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc(sizeof(struct pauser) /*24ul*/ , (unsigned long int)1);
  pause = (struct pauser *)return_value_calloc_1;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc(sizeof(struct timeval) /*16ul*/ , (unsigned long int)1);
  pause->tv = (struct timeval *)return_value_calloc_2;
  pause->timer_ev=event_new(evbase, -1, (signed short int)0, resume_request_timer, (void *)pause);
  pause->request = req;
  evhtp_set_hook(&req->hooks, (enum evhtp_hook_type)evhtp_hook_on_header, (unsigned short int (*)())pause_cb, (void *)pause);
  evhtp_set_hook(&req->hooks, (enum evhtp_hook_type)evhtp_hook_on_request_fini, (unsigned short int (*)())pause_request_fini, (void *)pause);
  evhtp_set_hook(&req->conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_connection_fini, (unsigned short int (*)())pause_connection_fini, (void *)0);
  return (unsigned short int)200;
}

// pause_request_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 78
static unsigned short int pause_request_fini(struct evhtp_request_s *request, void *arg)
{
  struct pauser *pause = (struct pauser *)arg;
  printf("pause_request_fini() req=%p, c=%p\n", request, request->conn);
  event_free(pause->timer_ev);
  free((void *)pause->tv);
  free((void *)pause);
  return (unsigned short int)200;
}

// print_chunk_complete
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 315
static unsigned short int print_chunk_complete(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_printf(req->buffer_out, "ended a single chunk\n");
  return (unsigned short int)200;
}

// print_chunks_complete
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 322
static unsigned short int print_chunks_complete(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_printf(req->buffer_out, "all chunks read\n");
  return (unsigned short int)200;
}

// print_data
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 296
static unsigned short int print_data(struct evhtp_request_s *req, struct evbuffer *buf, void *arg)
{
  unsigned long int return_value_evbuffer_get_length_1;
  return_value_evbuffer_get_length_1=evbuffer_get_length(buf);
  evbuffer_add_printf(req->buffer_out, "got %zu bytes of data\n", return_value_evbuffer_get_length_1);
  evbuffer_drain(buf, (unsigned long int)-1);
  return (unsigned short int)200;
}

// print_kv
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 252
static unsigned short int print_kv(struct evhtp_request_s *req, struct evhtp_kv_s *hdr, void *arg)
{
  evbuffer_add_printf(req->buffer_out, "print_kv() key = '%s', val = '%s'\n", hdr->key, hdr->val);
  return (unsigned short int)200;
}

// print_kvs
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 270
static unsigned short int print_kvs(struct evhtp_request_s *req, struct evhtp_kvs_s *hdrs, void *arg)
{
  evhtp_kvs_for_each(hdrs, output_header, (void *)req->buffer_out);
  return (unsigned short int)200;
}

// print_new_chunk_len
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 308
static unsigned short int print_new_chunk_len(struct evhtp_request_s *req, unsigned long int len, void *arg)
{
  evbuffer_add_printf(req->buffer_out, "started new chunk, %ldu bytes\n", len);
  return (unsigned short int)200;
}

// print_path
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 276
static unsigned short int print_path(struct evhtp_request_s *req, struct evhtp_path_s *path, void *arg)
{
  if(!(ext_body == ((char *)NULL)))
    evbuffer_add_printf(req->buffer_out, "ext_body: '%s'\n", ext_body);

  enum htp_method return_value_evhtp_request_get_method_1;
  return_value_evhtp_request_get_method_1=evhtp_request_get_method(req);
  evbuffer_add_printf(req->buffer_out, "print_path() full        = '%s'\n             path        = '%s'\n             file        = '%s'\n             match start = '%s'\n             match_end   = '%s'\n             methno      = '%d'\n", path->full, path->path, path->file, path->match_start, path->match_end, return_value_evhtp_request_get_method_1);
  return (unsigned short int)200;
}

// resume_request_timer
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 37
static void resume_request_timer(signed int sock, signed short int which, void *arg)
{
  struct pauser *pause = (struct pauser *)arg;
  printf("resume_request_timer(%p) timer_ev = %p\n", pause->request->conn, pause->timer_ev);
  fflush(stdout);
  evhtp_request_resume(pause->request);
}

// set_max_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 337
static unsigned short int set_max_body(struct evhtp_request_s *req, struct evhtp_kvs_s *hdrs, void *arg)
{
  evhtp_request_set_max_body_size(req, (unsigned long int)1024);
  return (unsigned short int)200;
}

// set_my_connection_handlers
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 376
static unsigned short int set_my_connection_handlers(struct evhtp_connection_s *conn, void *arg)
{
  struct timeval tick;
  struct ev_token_bucket_cfg *tcfg = (struct ev_token_bucket_cfg *)(void *)0;
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_header, (unsigned short int (*)())print_kv, (void *)"foo");
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_headers, (unsigned short int (*)())print_kvs, (void *)"bar");
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_path, (unsigned short int (*)())print_path, (void *)"baz");
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_read, (unsigned short int (*)())print_data, (void *)"derp");
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_new_chunk, (unsigned short int (*)())print_new_chunk_len, (void *)0);
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_chunk_complete, (unsigned short int (*)())print_chunk_complete, (void *)0);
  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_chunks_complete, (unsigned short int (*)())print_chunks_complete, (void *)0);
  if(bw_limit >= 1ul)
  {
    tick.tv_sec = (signed long int)0;
    tick.tv_usec = (signed long int)(500 * 100);
    tcfg=ev_token_bucket_cfg_new(bw_limit, bw_limit, bw_limit, bw_limit, &tick);
    bufferevent_set_rate_limit(conn->bev, tcfg);
  }

  evhtp_set_hook(&conn->hooks, (enum evhtp_hook_type)evhtp_hook_on_request_fini, (unsigned short int (*)())test_fini, (void *)tcfg);
  return (unsigned short int)200;
}

// sigint
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 504
static void sigint(signed int sig, signed short int why, void *data)
{
  event_base_loopexit((struct event_base *)data, (struct timeval *)(void *)0);
}

// status_code_to_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp.c line 142
static const char * status_code_to_str(unsigned short int code)
{
  switch((signed int)code)
  {
    case 200:
      return "OK";
    case 300:
      return "Redirect";
    case 400:
      return "Bad Request";
    case 404:
      return "Not Found";
    case 500:
      return "Internal Server Error";
    case 100:
      return "Continue";
    case 403:
      return "Forbidden";
    case 101:
      return "Switching Protocols";
    case 301:
      return "Moved Permanently";
    case 102:
      return "Processing";
    case 122:
      return "URI Too Long";
    case 201:
      return "Created";
    case 202:
      return "Accepted";
    case 203:
      return "No Auth Info";
    case 204:
      return "No Content";
    case 205:
      return "Reset Content";
    case 206:
      return "Partial Content";
    case 207:
      return "Multi-Status";
    case 226:
      return "IM Used";
    case 302:
      return "Found";
    case 303:
      return "See Other";
    case 304:
      return "Not Modified";
    case 305:
      return "Use Proxy";
    case 306:
      return "Switch Proxy";
    case 307:
      return "Temporary Redirect";
    case 401:
      return "Unauthorized";
    case 402:
      return "Payment Required";
    case 405:
      return "Not Allowed";
    case 406:
      return "Not Acceptable";
    case 407:
      return "Proxy Authentication Required";
    case 408:
      return "Request Timeout";
    case 409:
      return "Conflict";
    case 410:
      return "Gone";
    case 411:
      return "Length Required";
    case 412:
      return "Precondition Failed";
    case 413:
      return "Entity Too Large";
    case 414:
      return "Request-URI Too Long";
    case 415:
      return "Unsupported Media Type";
    case 416:
      return "Requested Range Not Satisfiable";
    case 417:
      return "Expectation Failed";
    case 418:
      return "I'm a teapot";
    case 501:
      return "Not Implemented";
    case 502:
      return "Bad Gateway";
    case 503:
      return "Service Unavailable";
    case 504:
      return "Gateway Timeout";
    case 505:
      return "HTTP Version Not Supported";
    case 509:
      return "Bandwidth Limit Exceeded";
    default:
      return "UNKNOWN";
  }
}

// str_to_uint64
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/htparse.c line 307
static inline unsigned long int str_to_uint64(char *str, unsigned long int n, signed int *err)
{
  unsigned long int value;
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; !(n == 0ul); n = n - 1ul)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((1 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)str[-1l + (signed long int)n]]) == 0)
      break;

  }
  unsigned long int tmp_post_2;
  _Bool tmp_if_expr_3;
  if(n >= 21ul)
  {
    *err = 1;
    return (unsigned long int)0;
  }

  else
  {
    value = (unsigned long int)0;
    do
    {
      tmp_post_2 = n;
      n = n - 1ul;
      if(tmp_post_2 == 0ul)
        break;

      unsigned long int check;
      if(!((signed int)*str >= 48))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)*str > 57 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        *err = 1;
        return (unsigned long int)0;
      }

      check = value * (unsigned long int)10 + (unsigned long int)((signed int)*str - 48);
      if(value >= check && !(value == 0ul))
      {
        *err = 1;
        return (unsigned long int)0;
      }

      value = check;
      str = str + 1l;
    }
    while((_Bool)1);
    return value;
  }
}

// strreverse
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/evhtp_numtoa.c line 20
static inline void strreverse(char *begin, char *end)
{
  char aux;
  char *tmp_post_1;
  char *tmp_post_2;
  for( ; !(begin >= end); *tmp_post_2 = aux)
  {
    aux = *end;
    tmp_post_1 = end;
    end = end - 1l;
    *tmp_post_1 = *begin;
    tmp_post_2 = begin;
    begin = begin + 1l;
  }
}

// test_500_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 186
static void test_500_cb(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_reference(req->buffer_out, (const void *)"test_500_cb\n", (unsigned long int)12, (void (*)(const void *, unsigned long int, void *))(void *)0, (void *)0);
  evhtp_send_reply(req, (unsigned short int)500);
}

// test_bar_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 232
static void test_bar_cb(struct evhtp_request_s *req, void *arg)
{
  evhtp_send_reply(req, (unsigned short int)200);
}

// test_chunking
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 210
static void test_chunking(struct evhtp_request_s *req, void *arg)
{
  const char *chunk_str;
  struct evbuffer *buf;
  signed int i = 0;
  buf=evbuffer_new();
  evhtp_send_reply_chunk_start(req, (unsigned short int)200);
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = i;
    i = i + 1;
    chunk_str = chunk_strings[(signed long int)tmp_post_1];
    if(chunk_str == ((const char *)NULL))
      break;

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(chunk_str);
    evbuffer_add(buf, (const void *)chunk_str, return_value_strlen_2);
    evhtp_send_reply_chunk(req, buf);
    evbuffer_drain(buf, (unsigned long int)-1);
  }
  while((_Bool)1);
  evhtp_send_reply_chunk_end(req);
  evbuffer_free(buf);
}

// test_default_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 243
static void test_default_cb(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_reference(req->buffer_out, (const void *)"test_default_cb\n", (unsigned long int)16, (void (*)(const void *, unsigned long int, void *))(void *)0, (void *)0);
  evhtp_send_reply(req, (unsigned short int)200);
}

// test_fini
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 355
static unsigned short int test_fini(struct evhtp_request_s *r, void *arg)
{
  struct ev_token_bucket_cfg *tcfg = (struct ev_token_bucket_cfg *)arg;
  if(!(tcfg == ((struct ev_token_bucket_cfg *)NULL)))
    ev_token_bucket_cfg_free(tcfg);

  return (unsigned short int)200;
}

// test_foo_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 178
static void test_foo_cb(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_reference(req->buffer_out, (const void *)"test_foo_cb\n", (unsigned long int)12, (void (*)(const void *, unsigned long int, void *))(void *)0, (void *)0);
  evhtp_send_reply(req, (unsigned short int)200);
}

// test_glob_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 237
static void test_glob_cb(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add(req->buffer_out, (const void *)"test_glob_cb\n", (unsigned long int)13);
  evhtp_send_reply(req, (unsigned short int)200);
}

// test_max_body
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 194
static void test_max_body(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_reference(req->buffer_out, (const void *)"test_max_body\n", (unsigned long int)14, (void (*)(const void *, unsigned long int, void *))(void *)0, (void *)0);
  evhtp_send_reply(req, (unsigned short int)200);
}

// test_ownership
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 125
static void test_ownership(struct evhtp_request_s *request, void *arg)
{
  struct evhtp_connection_s *conn;
  conn=evhtp_request_get_connection(request);
  struct bufferevent *bev;
  bev=evhtp_connection_take_ownership(conn);
  bufferevent_enable(bev, (signed short int)0x02);
  bufferevent_setcb(bev, _owned_readcb, (void (*)(struct bufferevent *, void *))(void *)0, _owned_eventcb, (void *)0);
}

// test_pause_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 108
static void test_pause_cb(struct evhtp_request_s *request, void *arg)
{
  printf("test_pause_cb(%p)\n", request->conn);
  evhtp_send_reply(request, (unsigned short int)200);
}

// test_pre_accept
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 344
static unsigned short int test_pre_accept(struct evhtp_connection_s *c, void *arg)
{
  unsigned short int port = *((unsigned short int *)arg);
  if((signed int)port >= 10001)
    return (unsigned short int)0;

  else
    return (unsigned short int)200;
}

// test_regex
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 137
static void test_regex(struct evhtp_request_s *req, void *arg)
{
  evbuffer_add_printf(req->buffer_out, "start = '%s', end = '%s\n", req->uri->path->match_start, req->uri->path->match_end);
  evhtp_send_reply(req, (unsigned short int)200);
}

// test_regex_hdrs_cb
// file /srv/jenkins-slave/workspace/sid-goto-cc-libevhtp/libevhtp-1.2.11/examples/test.c line 330
static unsigned short int test_regex_hdrs_cb(struct evhtp_request_s *req, struct evhtp_kvs_s *hdrs, void *arg)
{
  return (unsigned short int)200;
}

