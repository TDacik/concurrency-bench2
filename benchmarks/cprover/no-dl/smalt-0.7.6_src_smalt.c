// tag-#anon#UN[ARR32{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$1;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-EString_
// file elib.h line 222
struct EString_;

// tag-GETMATEPAIRARG_
// file resultpairs.c line 354
struct GETMATEPAIRARG_;

// tag-GETPROPERMATEPAIRARG_
// file resultpairs.c line 256
struct GETPROPERMATEPAIRARG_;

// tag-OPTDOC_
// file menu.c line 87
struct OPTDOC_;

// tag-RMAPBUFF_
// file rmap.c line 130
struct RMAPBUFF_;

// tag-RMAPCAND_
// file rmap.c line 111
struct RMAPCAND_;

// tag-RMAPINFO_
// file rmap.c line 142
struct RMAPINFO_;

// tag-RMAPPROF_
// file rmap.c line 147
struct RMAPPROF_;

// tag-RMap_
// file rmap.h line 77
struct RMap_;

// tag-SETUPOFFSIVALARG_
// file resultpairs.c line 189
struct SETUPOFFSIVALARG_;

// tag-ScorePenalties_
// file score.h line 114
struct ScorePenalties_;

// tag-SmaltArgBlock_
// file smalt.c line 159
struct SmaltArgBlock_;

// tag-TASKDOC_
// file menu.c line 95
struct TASKDOC_;

// tag-VARLST_
// file menu.c line 655
struct VARLST_;

// tag-V_IVAL_
// file interval.h line 51
struct V_IVAL_;

// tag-V_int32_t_
// file insert.c line 64
struct V_int32_t_;

// tag-_ALIBAND
// file alignment.c line 88
struct _ALIBAND;

// tag-_ALICPLX
// file alignment.c line 81
struct _ALICPLX;

// tag-_ALIMETA
// file alignment.c line 127
struct _ALIMETA;

// tag-_ALIRESULT
// file alignment.c line 149
struct _ALIRESULT;

// tag-_ALITRACK
// file alignment.c line 111
struct _ALITRACK;

// tag-_ARGBUFF
// file threads.c line 99
struct _ARGBUFF;

// tag-_AliBuffer
// file alibuffer.h line 40
struct _AliBuffer;

// tag-_AliRsltSet
// file alignment.h line 60
struct _AliRsltSet;

// tag-_BLOCK
// file diffstr.c line 93
struct _BLOCK;

// tag-_BUFFARG
// file threads.c line 89
struct _BUFFARG;

// tag-_BamBam_AlignmentPut
// file /usr/include/bambamc/BamBam_BamAlignmentPut.h line 30
struct _BamBam_AlignmentPut;

// tag-_BamBam_BamHeaderInfo
// file /usr/include/bambamc/BamBam_BamHeaderInfo.h line 28
struct _BamBam_BamHeaderInfo;

// tag-_BamBam_BamSingleAlignment
// file /usr/include/bambamc/BamBam_BamSingleAlignment.h line 51
struct _BamBam_BamSingleAlignment;

// tag-_BamBam_BamWriter
// file /usr/include/bambamc/BamBam_BamWriter.h line 26
struct _BamBam_BamWriter;

// tag-_BamBam_BgzfCompressor
// file /usr/include/bambamc/BamBam_BgzfCompressor.h line 50
struct _BamBam_BgzfCompressor;

// tag-_BamBam_CharBuffer
// file /usr/include/bambamc/BamBam_CharBuffer.h line 31
struct _BamBam_CharBuffer;

// tag-_BamBam_FastQRead
// file /usr/include/bambamc/BamBam_FastQRead.h line 25
struct _BamBam_FastQRead;

// tag-_BamBam_List
// file /usr/include/bambamc/BamBam_List.h line 27
struct _BamBam_List;

// tag-_BamBam_ListNode
// file /usr/include/bambamc/BamBam_ListNode.h line 30
struct _BamBam_ListNode;

// tag-_DiffBlocks
// file diffstr.h line 127
struct _DiffBlocks;

// tag-_DiffStr
// file diffstr.h line 137
struct _DiffStr;

// tag-_DiffView
// file diffstr.h line 130
struct _DiffView;

// tag-_ErrMsg
// file elib.h line 147
struct _ErrMsg;

// tag-_FILTERIVAL
// file hashhit.c line 238
struct _FILTERIVAL;

// tag-_HITREGION
// file segment.c line 195
struct _HITREGION;

// tag-_HashHitFilter
// file hashhit.h line 84
struct _HashHitFilter;

// tag-_HashHitInfo
// file hashhit.h line 82
struct _HashHitInfo;

// tag-_HashHitList
// file hashhit.h line 83
struct _HashHitList;

// tag-_HashTable
// file hashidx.h line 74
struct _HashTable;

// tag-_INDEXMENU
// file menu.c line 708
struct _INDEXMENU;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_IVAL
// file interval.c line 45
struct _IVAL;

// tag-_InFmtReader
// file infmt.h line 59
struct _InFmtReader;

// tag-_InsHist
// file insert.h line 46
struct _InsHist;

// tag-_InsSample
// file insert.h line 45
struct _InsSample;

// tag-_MAPMENU
// file menu.c line 713
struct _MAPMENU;

// tag-_MATEPAIR
// file resultpairs.c line 78
struct _MATEPAIR;

// tag-_MESSAGE
// file elib.c line 50
struct _MESSAGE;

// tag-_MenuOpt
// file menu.h line 121
struct _MenuOpt;

// tag-_OFFSIVAL
// file resultpairs.c line 97
struct _OFFSIVAL;

// tag-_OUFMT
// file menu.c line 703
struct _OUFMT;

// tag-_REPALI
// file report.c line 126
struct _REPALI;

// tag-_REPNAMBUF
// file report.c line 120
struct _REPNAMBUF;

// tag-_REPPAIR
// file report.c line 141
struct _REPPAIR;

// tag-_REPSTR
// file report.c line 113
struct _REPSTR;

// tag-_RESULT
// file results.h line 123
struct _RESULT;

// tag-_Report
// file report.h line 94
struct _Report;

// tag-_ReportWriter
// file report.h line 95
struct _ReportWriter;

// tag-_ResultFilter
// file results.h line 129
struct _ResultFilter;

// tag-_ResultPairs
// file resultpairs.h line 93
struct _ResultPairs;

// tag-_ResultSet
// file results.h line 126
struct _ResultSet;

// tag-_SEED
// file hashhit.c line 148
struct _SEED;

// tag-_SEED$link1
// file segment.c line 162
struct _SEED$0;

// tag-_SEGCAND
// file segment.c line 239
struct _SEGCAND;

// tag-_SEGMENT
// file segment.c line 206
struct _SEGMENT;

// tag-_SEQSEQ
// file sequence.c line 106
struct _SEQSEQ;

// tag-_ScoreMatrix
// file score.h line 118
struct _ScoreMatrix;

// tag-_ScoreProfile
// file score.h line 121
struct _ScoreProfile;

// tag-_SegAliCands
// file segment.h line 78
struct _SegAliCands;

// tag-_SegLst
// file segment.h line 77
struct _SegLst;

// tag-_SegLst$link1
// file segment.h line 77
struct _SegLst;

// tag-_SegQMask
// file segment.h line 76
struct _SegQMask;

// tag-_SeqCodec
// file sequence.h line 123
struct _SeqCodec;

// tag-_SeqFastq
// file sequence.h line 127
struct _SeqFastq;

// tag-_SeqIO
// file sequence.h line 125
struct _SeqIO;

// tag-_SeqSet
// file sequence.h line 129
struct _SeqSet;

// tag-_SmaltIOBuffArg
// file smalt.c line 144
struct _SmaltIOBuffArg;

// tag-_SmaltInput
// file smalt.c line 179
struct _SmaltInput;

// tag-_SmaltMapArgs
// file smalt.c line 167
struct _SmaltMapArgs;

// tag-_SmaltMapConst
// file smalt.c line 106
struct _SmaltMapConst;

// tag-_SmaltOutput
// file smalt.c line 189
struct _SmaltOutput;

// tag-_THREADARG
// file threads.c line 131
struct _THREADARG;

// tag-_THREADTASK
// file threads.c line 117
struct _THREADTASK;

// tag-_Threads
// file threads.c line 141
struct _Threads;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_bambamc_alignment_validity
// file /usr/include/bambamc/BamBam_BamSingleAlignment.h line 28
enum _bambamc_alignment_validity { bambamc_alignment_validity_ok=0, bambamc_alignment_validity_block_too_small=1, bambamc_alignment_validity_queryname_extends_over_block=2, bambamc_alignment_validity_queryname_length_inconsistent=3, bambamc_alignment_validity_cigar_extends_over_block=4, bambamc_alignment_validity_sequence_extends_over_block=5, bambamc_alignment_validity_quality_extends_over_block=6, bambamc_alignment_validity_cigar_is_inconsistent_with_sequence_length=7, bambamc_alignment_validity_unknown_cigar_op=8, bambamc_alignment_validity_queryname_contains_illegal_symbols=9, bambamc_alignment_validity_queryname_empty=10, bambamc_alignment_validity_invalid_mapping_position=11, bambamc_alignment_validity_invalid_next_mapping_position=12, bambamc_alignment_validity_invalid_tlen=13, bambamc_alignment_validity_invalid_quality_value=14, bambamc_alignment_validity_invalid_refseq=15, bambamc_alignment_validity_invalid_next_refseq=16, bambamc_alignment_validity_invalid_auxiliary_data=17, bambamc_alignment_valididy_record_length_negative=18 };

// tag-_optflags
// file menu.c line 751
struct _optflags;

// tag-gzFile_s
// file /usr/include/zlib.h line 1224
struct gzFile_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// BamBam_AllocBamCollator
// file /usr/include/bambamc/BamBam_BamCollatorInterface.h line 26
extern signed int BamBam_AllocBamCollator(const char *, const char *, const char *, const signed int);
// BamBam_BamHeaderInfo_AddChromosome
// file /usr/include/bambamc/BamBam_BamHeaderInfo.h line 40
extern signed int BamBam_BamHeaderInfo_AddChromosome(struct _BamBam_BamHeaderInfo *, const char *, unsigned long int);
// BamBam_BamHeaderInfo_Delete
// file /usr/include/bambamc/BamBam_BamHeaderInfo.h line 38
extern struct _BamBam_BamHeaderInfo * BamBam_BamHeaderInfo_Delete(struct _BamBam_BamHeaderInfo *);
// BamBam_BamHeaderInfo_New
// file /usr/include/bambamc/BamBam_BamHeaderInfo.h line 39
extern struct _BamBam_BamHeaderInfo * BamBam_BamHeaderInfo_New(const char *, const char *, const char *);
// BamBam_BamWriter_Commit
// file /usr/include/bambamc/BamBam_BamWriter.h line 63
extern signed int BamBam_BamWriter_Commit(struct _BamBam_BamWriter *);
// BamBam_BamWriter_Delete
// file /usr/include/bambamc/BamBam_BamWriter.h line 32
extern struct _BamBam_BamWriter * BamBam_BamWriter_Delete(struct _BamBam_BamWriter *, signed int *);
// BamBam_BamWriter_New
// file /usr/include/bambamc/BamBam_BamWriter.h line 33
extern struct _BamBam_BamWriter * BamBam_BamWriter_New(struct _BamBam_BamHeaderInfo *, const char *, signed int);
// BamBam_BamWriter_PutAlignment
// file /usr/include/bambamc/BamBam_BamWriter.h line 37
extern signed int BamBam_BamWriter_PutAlignment(struct _BamBam_BamWriter *, const signed int, const signed int, const unsigned long int, const signed int, const unsigned long int, const char *, const char *, const char *, const char *, const signed int, const signed int);
// BamBam_BamWriter_PutAuxNumber
// file /usr/include/bambamc/BamBam_BamWriter.h line 62
extern signed int BamBam_BamWriter_PutAuxNumber(struct _BamBam_BamWriter *, const char *, const char, const void *);
// BamBam_FreeBamCollator
// file /usr/include/bambamc/BamBam_BamCollatorInterface.h line 27
extern void BamBam_FreeBamCollator(const signed int);
// BamBam_ReadPair
// file /usr/include/bambamc/BamBam_BamCollatorInterface.h line 28
extern signed int BamBam_ReadPair(const signed int, struct _BamBam_FastQRead *, struct _BamBam_FastQRead *, void **, void **, const char);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// _mm_adds_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1041
static inline __gcc_v2di _mm_adds_epi16(__gcc_v2di __A, __gcc_v2di __B);
// _mm_adds_epu8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1047
static inline __gcc_v2di _mm_adds_epu8(__gcc_v2di __A, __gcc_v2di __B);
// _mm_cmpeq_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1298
static inline __gcc_v2di _mm_cmpeq_epi16(__gcc_v2di __A, __gcc_v2di __B);
// _mm_cmpeq_epi8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1292
static inline __gcc_v2di _mm_cmpeq_epi8(__gcc_v2di __A, __gcc_v2di __B);
// _mm_cmpgt_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1334
static inline __gcc_v2di _mm_cmpgt_epi16(__gcc_v2di __A, __gcc_v2di __B);
// _mm_load_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 690
static inline __gcc_v2di _mm_load_si128(const __gcc_v2di *__P);
// _mm_max_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1366
static inline __gcc_v2di _mm_max_epi16(__gcc_v2di __A, __gcc_v2di __B);
// _mm_max_epu8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1372
static inline __gcc_v2di _mm_max_epu8(__gcc_v2di __A, __gcc_v2di __B);
// _mm_movemask_epi8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1390
static inline signed int _mm_movemask_epi8(__gcc_v2di __A);
// _mm_or_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1280
static inline __gcc_v2di _mm_or_si128(__gcc_v2di __A, __gcc_v2di __B);
// _mm_setzero_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 753
static inline __gcc_v2di _mm_setzero_si128(void);
// _mm_slli_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1137
static inline __gcc_v2di _mm_slli_epi16(__gcc_v2di __A, signed int __B);
// _mm_store_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 708
static inline void _mm_store_si128(__gcc_v2di *__P, __gcc_v2di __B);
// _mm_subs_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1089
static inline __gcc_v2di _mm_subs_epi16(__gcc_v2di __A, __gcc_v2di __B);
// _mm_subs_epu8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1095
static inline __gcc_v2di _mm_subs_epu8(__gcc_v2di __A, __gcc_v2di __B);
// addALIMETAtoRsltSet
// file alignment.c line 1277
static signed int addALIMETAtoRsltSet(struct _AliRsltSet *p);
// addCandsFast
// file segment.c line 1140
static signed int addCandsFast(struct _SEGCAND **candr, unsigned int *maxcover, unsigned int *max2ndcover, struct _SEGMENT * const segmr, struct _SEED$0 * const seedr, struct _HITREGION * const hregr, unsigned char *maskp, unsigned int qlen, unsigned char ktup, unsigned char nskip, unsigned char is_reverse, unsigned int mincover, unsigned int mincover_noindel, signed int seqidx);
// addCandsFromSortedSegments
// file segment.c line 1225
static signed int addCandsFromSortedSegments(struct _SEGCAND **candr, struct _SEGMENT *segmr, unsigned int nseg, const unsigned int *segmidx, struct _SEED$0 * const seedr, struct _HITREGION * const hregr, unsigned int hridx, unsigned int mincov_noindel, unsigned char ktup, unsigned char nskip, char is_reverse);
// addNoIndelCandsFromSegmentSeeds
// file segment.c line 1284
static signed int addNoIndelCandsFromSegmentSeeds(struct _SEGCAND **candr, unsigned int *max_cover, struct _SEGMENT *segmr, struct _SEED$0 * const seedr, struct _HITREGION * const hregr, unsigned int mincover, unsigned char ktup, unsigned char nskip, char is_reverse);
// addPairResultsToReport
// file resultpairs.c line 1008
static signed int addPairResultsToReport(struct _Report *rep, const unsigned char mapflg, unsigned char repmateflg, const struct _RESULT *rp, signed short int mapqA, const struct _ResultSet *rsrp, const struct _RESULT *mp, signed short int mapqB, const struct _ResultSet *rsmp);
// aliBufferCreate
// file alibuffer.h line 46
struct _AliBuffer * aliBufferCreate(signed int blocksiz);
// aliBufferDelete
// file alibuffer.h line 52
void aliBufferDelete(struct _AliBuffer *p);
// aliBufferInit
// file alibuffer.h line 56
signed int aliBufferInit(struct _AliBuffer *p, unsigned int qlen);
// aliRsltSetCreate
// file alignment.h line 86
struct _AliRsltSet * aliRsltSetCreate(const struct _ScoreMatrix *smp, signed short int blksz, signed short int diffblksz, signed int track_blksz, signed int track_thresh);
// aliRsltSetDelete
// file alignment.h line 102
void aliRsltSetDelete(struct _AliRsltSet *p);
// aliRsltSetFetchData
// file alignment.h line 114
signed int aliRsltSetFetchData(const struct _AliRsltSet *arp, signed short int idx, signed int *score, signed int *ps_start, signed int *ps_end, signed int *us_start, signed int *us_end, const struct _DiffStr **dfsp);
// aliRsltSetGetSize
// file alignment.h line 110
signed short int aliRsltSetGetSize(const struct _AliRsltSet *arp);
// aliRsltSetReset
// file alignment.h line 106
void aliRsltSetReset(struct _AliRsltSet *p);
// aliScoreDiffStr
// file alignment.h line 67
signed int aliScoreDiffStr(signed int *swscor, const char *unprofiled_seqp, signed int unprofiled_seqlen, unsigned int profiled_offs, const unsigned char *diffstrp, signed int diffstrlen, const struct _ScoreProfile *scpp);
// aliSmiWatInBand
// file alignment.h line 134
signed int aliSmiWatInBand(struct _AliRsltSet *rssp, struct _AliBuffer *bufp, const struct _ScoreProfile *profp, const char *unprofiled_seqp, signed int unprofiled_seqlen, signed int l_edge, signed int r_edge, signed int profiled_left, signed int profiled_right, signed int unprofiled_left, signed int unprofiled_right, signed int minscore, signed int minscorlen);
// aliSmiWatInBandFast
// file alignment.h line 164
signed int aliSmiWatInBandFast(signed int *maxswscor, struct _AliBuffer *bufp, const struct _ScoreProfile *profp, const char *unprofiled_seqp, signed int unprofiled_seqlen, signed int l_edge, signed int r_edge, signed int profiled_left, signed int profiled_right, signed int unprofiled_left, signed int unprofiled_right);
// alignRMAPCANDFull
// file rmap.c line 790
static signed int alignRMAPCANDFull(struct _ResultSet *rsp, struct _AliRsltSet *alirsp, struct _AliBuffer *alibufp, struct _SeqFastq *sqbufp, signed int min_swatscor, signed int scorlen_min, signed int bandwidth_min, unsigned short int rmapflag, const struct _ScoreProfile *profp, const struct _ScoreProfile *profRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, struct RMAPCAND_ * const candr);
// alignSmiWatBand
// file alignment.c line 788
static signed int alignSmiWatBand(struct _ALITRACK *bktp, struct _AliBuffer *bufp, const struct _ALIBAND *bandp, const struct _ScoreProfile *profp, const char *usqp);
// alignSmiWatBandFast
// file alignment.c line 1029
static signed int alignSmiWatBandFast(signed int *maxswscor, struct _AliBuffer * const bufp, const struct _ALIBAND * const bandp, const struct _ScoreProfile * const profp, const char * const usqp);
// alignSmiWatBandRecursive
// file alignment.c line 1300
static signed int alignSmiWatBandRecursive(struct _AliRsltSet *rssp, struct _AliBuffer *bufp, const struct _ScoreProfile *q_profp, signed int q_len, const char *s_seqp, signed int s_len, signed int l_edge, signed int r_edge, signed int q_left, signed int q_right, signed int s_left, signed int s_right, const signed int minscore, const signed int minscorlen);
// alignSmiWatByteStriped
// file swsimd.c line 656
static signed int alignSmiWatByteStriped(unsigned char *maxscor, const struct _AliBuffer *abp, const struct _ScoreProfile *spp, const char *usqp, signed int uslen);
// alignSmiWatShortStriped
// file swsimd.c line 443
static signed int alignSmiWatShortStriped(unsigned short int *maxscor, const struct _AliBuffer *abp, const struct _ScoreProfile *spp, const char *usqp, signed int uslen);
// appendMangledToCompressedSeq
// file sequence.c line 932
static signed int appendMangledToCompressedSeq(struct _SEQSEQ *top, const struct _SEQSEQ *fromp, char withTerm);
// appendSeqSegment
// file sequence.c line 832
static signed int appendSeqSegment(struct _SEQSEQ *top, unsigned int *tcpos, unsigned char *ntc, const struct _SEQSEQ *fromp, unsigned int start, unsigned int length, char reverse, char withTerm, const struct _SeqCodec *codep);
// arrayCreate
// file array.h line 49
void * arrayCreate(unsigned long int elemsiz, unsigned long int blocksiz, const char *nam, signed int lin);
// arrayRealloc
// file array.h line 51
void * arrayRealloc(void *p, unsigned long int new_nelem, char is_final, const char *nam, signed int lin);
// assignPhredScaledMappingScoreToRandomDraw
// file results.c line 214
static signed int assignPhredScaledMappingScoreToRandomDraw(signed int samplesiz);
// assignProbabilityToPairs
// file resultpairs.c line 753
static signed int assignProbabilityToPairs(struct _MATEPAIR *mpr, double *psum, double *marga, double *margb, unsigned char pairflg, const struct _InsHist *ihistp);
// assignSequenceIndex
// file results.c line 1695
static signed int assignSequenceIndex(struct _ResultSet *rsp, struct _SeqFastq *sbufp, const struct _ScoreProfile *scpp, const struct _ScoreProfile *scpRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// blankALICPLX
// file alignment.c line 258
static void blankALICPLX(struct _ALICPLX *p);
// blankHitList
// file hashhit.c line 1224
void blankHitList(struct _HashHitList *hlp);
// blankRMAPBUFF
// file rmap.c line 1139
static void blankRMAPBUFF(struct RMAPBUFF_ *rmp);
// blankSeq
// file sequence.c line 757
static void blankSeq(struct _SEQSEQ *sp);
// buildHashIndex
// file smalt.c line 338
static signed int buildHashIndex(struct _ErrMsg *errmsgp, const struct _MenuOpt *menup);
// calcIndelFreeMincover
// file segment.c line 360
static unsigned int calcIndelFreeMincover(unsigned int slen, unsigned char ktup, unsigned char nskip);
// calcKernelBandWidth
// file insert.c line 136
static signed int calcKernelBandWidth(signed int n, signed int iqr);
// calcKtupOffs
// file hashidx.c line 325
static unsigned int calcKtupOffs(unsigned char *ktupoffs, unsigned int offs, signed long int sx, unsigned char nskip, const struct _SeqSet *ssp);
// calcMaxWordNumPerKey
// file hashidx.c line 429
static signed int calcMaxWordNumPerKey(unsigned int *nkey_zero, const struct _HashTable *htp);
// calcMinKtup
// file rmap.c line 240
static unsigned int calcMinKtup(unsigned int *mincover, const struct _HashTable *htp);
// calcPhredScaledMappingQuality
// file results.c line 1143
static signed int calcPhredScaledMappingQuality(signed short int qsegx, const struct _ResultSet *rsetp, const struct _SeqFastq *sqp);
// calcPhredScaledMappingQualityPerQuerySegment
// file results.c line 1415
static signed int calcPhredScaledMappingQualityPerQuerySegment(struct _ResultSet *rsetp, const struct _SeqFastq *sqp);
// calcRESULTid
// file results.c line 567
static signed int calcRESULTid(const struct _RESULT *rp, const struct _ResultSet *rsp);
// calcSegmentBoundaries
// file segment.c line 635
static void calcSegmentBoundaries(unsigned int *qs, unsigned int *qe, unsigned int *rs, unsigned int *re, const struct _SEGMENT *sgp, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip, unsigned char is_reverse);
// calcSegmentOverlap
// file segment.c line 587
static signed int calcSegmentOverlap(const struct _SEGMENT *sgAp, const struct _SEGMENT *sgBp, struct _SEED$0 * const seedr);
// calcTotalHitNumStats
// file rmap.c line 1086
static unsigned int calcTotalHitNumStats(const struct RMAPINFO_ *rmrp, unsigned int *nhit_tot);
// calcTotalNumberOfHits
// file rmap.c line 1079
static unsigned int calcTotalNumberOfHits(const struct RMAPINFO_ *rmrp, signed int ktuple_maxhit);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// checkArgBlockReadNo
// file smalt.c line 966
static signed int checkArgBlockReadNo(const void *thargp, const void *buffargp);
// checkCodec
// file sequence.c line 266
static signed int checkCodec(struct _SeqCodec *codep);
// checkForRepeats
// file hashhit.c line 325
static unsigned char checkForRepeats(signed long int word, signed long int *tdrf);
// checkHashDefaults
// file menu.c line 1165
static signed int checkHashDefaults(struct _MenuOpt *menup, const struct _optflags *optflp);
// checkHashWithCollisions
// file hashidx.c line 370
static signed int checkHashWithCollisions(const struct _HashTable *htp, const struct _SeqSet *ssp, unsigned long int word, signed long int seqidx, unsigned long int basidx);
// checkMapDefaults
// file menu.c line 1183
static signed int checkMapDefaults(struct _MenuOpt *menup, const struct _optflags *optflp);
// checkPerfectHash
// file hashidx.c line 339
static signed int checkPerfectHash(const struct _HashTable *htp, const struct _SeqSet *ssp, unsigned long int word, signed long int seqidx, unsigned long int basidx);
// checkQuickHashIndexWithCollisions
// file hashidx.c line 698
static signed int checkQuickHashIndexWithCollisions(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// checkQuickPerfectHashIndex
// file hashidx.c line 658
static signed int checkQuickPerfectHashIndex(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// checkReads
// file smalt.c line 1432
static signed int checkReads(struct _ErrMsg *errmsgp, const struct _MenuOpt *menup);
// checkSampleDefaults
// file menu.c line 1228
static signed int checkSampleDefaults(struct _MenuOpt *menup, const struct _optflags *optflp);
// checkSeqNtSymbolsAreLetters
// file sequence.c line 1617
static signed int checkSeqNtSymbolsAreLetters(const struct _SEQSEQ *sp);
// checkWordsInSeqSet
// file hashidx.c line 606
static signed int checkWordsInSeqSet(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, signed int (*checkfunc)(const struct _HashTable *, const struct _SeqSet *, unsigned long int, signed long int, unsigned long int));
// checkWordsInSeqSet::checkfunc$object
//
signed int checkfunc$object(const struct _HashTable *, const struct _SeqSet *, unsigned long int, signed long int, unsigned long int);
// cleanupALIMETA
// file alignment.c line 554
static void cleanupALIMETA(struct _ALIMETA *p);
// cleanupALITRACK
// file alignment.c line 431
static void cleanupALITRACK(struct _ALITRACK *p);
// cleanupARGBUFF
// file threads.c line 373
static void cleanupARGBUFF(struct _ARGBUFF *fifop);
// cleanupArgBlock
// file smalt.c line 908
static signed int cleanupArgBlock(struct _ErrMsg *errmsgp, void *p);
// cleanupIOBuffArg
// file smalt.c line 778
static signed int cleanupIOBuffArg(struct _ErrMsg *errmsgp, struct _SmaltIOBuffArg *argp);
// cleanupInput
// file smalt.c line 691
static signed int cleanupInput(struct _ErrMsg *errmsgp, void *inp);
// cleanupMapArgs
// file smalt.c line 1065
static signed int cleanupMapArgs(struct _ErrMsg *errmsgp, void *p);
// cleanupMapConst
// file smalt.c line 428
static void cleanupMapConst(struct _SmaltMapConst *macop);
// cleanupREPSTR
// file report.c line 394
static void cleanupREPSTR(struct _REPSTR *rsp);
// cleanupSmaltOutput
// file smalt.c line 659
static signed int cleanupSmaltOutput(struct _ErrMsg *errmsgp, void *op);
// cmpArgBlockReadNo
// file smalt.c line 985
static signed int cmpArgBlockReadNo(const void *buffargAp, const void *buffargBp);
// cmpFILTERIVAL
// file hashhit.c line 1911
static signed int cmpFILTERIVAL(const void *this, const void *other);
// cmpIVAL
// file interval.c line 62
static signed int cmpIVAL(const void *a, const void *b);
// cmpMATEPAIRbyProbDescending
// file resultpairs.c line 519
static signed int cmpMATEPAIRbyProbDescending(const void *ap, const void *bp);
// cmpOFFSIVAL
// file resultpairs.c line 423
static signed int cmpOFFSIVAL(const void *a, const void *b);
// cmpPairNamStr
// file sequence.c line 222
static signed int cmpPairNamStr(const char *ap, const char *bp, unsigned long int maxlen);
// cmpRes
// file results.c line 450
static signed int cmpRes(const void *p1, const void *p2);
// cmpResOutput
// file results.c line 478
static signed int cmpResOutput(const void *p1, const void *p2);
// cmpResSegLen
// file results.c line 525
static signed int cmpResSegLen(const void *p1, const void *p2);
// cmpResSegSW
// file results.c line 509
static signed int cmpResSegSW(const void *p1, const void *p2);
// collectHitInfo
// file hashhit.c line 480
static signed int collectHitInfo(struct _HashHitInfo *hip, unsigned char is_reverse, unsigned int maxhit_per_tuple, unsigned char basqual_threshold, unsigned int seq_start, unsigned int seq_end, const struct _SeqFastq *seqp, const struct _HashTable *htp);
// collectHits
// file rmap.c line 273
static signed int collectHits(struct _SegAliCands *sacp, unsigned char with_seqidx, struct _SegLst *slp, struct _HashHitList *hlp, struct _SegQMask *qmp, unsigned int n_hit_max, unsigned int n_ktup_min, unsigned int cover_min, const struct _HashHitInfo *hip, const struct _HashTable *htp, const struct _SeqSet *ssp);
// collectHitsFromInterVal
// file rmap.c line 438
static signed int collectHitsFromInterVal(struct _SegAliCands *sacp, struct _SegLst *slp, struct _HashHitList *hlp, struct _SegQMask *qmp, unsigned int n_hit_max, unsigned int n_ktup_min, unsigned int cover_min, const struct _HashHitInfo *hip, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivr);
// collectWords
// file hashidx.c line 223
static signed int collectWords(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr);
// complementAsciiSeqInPlace
// file sequence.c line 1323
static signed int complementAsciiSeqInPlace(struct _SEQSEQ *sp, const struct _SeqCodec *codep);
// compressSeq
// file sequence.c line 1360
static signed int compressSeq(struct _SEQSEQ *sp);
// convertInputFormat
// file smalt.c line 247
static unsigned char convertInputFormat(unsigned char form);
// convertOutputFormat
// file smalt.c line 209
static unsigned char convertOutputFormat(unsigned char *modiflg, unsigned char form, const struct _MenuOpt *mp);
// copyReadNamStrToREPSTR
// file report.c line 434
static signed int copyReadNamStrToREPSTR(struct _REPSTR *rsp, unsigned char is_stripped, const char *namp);
// copyReadNameToREPSTR
// file report.c line 463
static signed int copyReadNameToREPSTR(struct _REPSTR *rsp, unsigned char is_stripped, const struct _SeqFastq *sqp);
// copySAMheaderCommandLineToREPSTR
// file report.c line 473
static signed int copySAMheaderCommandLineToREPSTR(struct _REPSTR *rsp, const char *prognam, const char *progversion, signed int narg, char * const *argv);
// countCollisionKey
// file hashidx.c line 206
static signed int countCollisionKey(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr);
// countPerfectKey
// file hashidx.c line 191
static signed int countPerfectKey(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr);
// countWords
// file hashidx.c line 265
static signed int countWords(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr);
// createALICPLX
// file alignment.c line 238
static struct _ALICPLX * createALICPLX(const struct _ScoreMatrix *smp);
// createREPNAMBUF
// file report.c line 528
static struct _REPNAMBUF * createREPNAMBUF(void);
// createRMAPBUFF
// file rmap.c line 1114
static struct RMAPBUFF_ * createRMAPBUFF(const struct _ScoreMatrix *scormtxp);
// createRMAPINFO
// file rmap.c line 1010
static struct RMAPINFO_ * createRMAPINFO(const struct _HashTable *htp);
// createRMAPPROF
// file rmap.c line 944
static struct RMAPPROF_ * createRMAPPROF(const struct _SeqCodec * const codecp);
// createSeq
// file sequence.c line 716
static struct _SEQSEQ * createSeq(unsigned int blocksize);
// cropSeq
// file sequence.c line 805
static signed int cropSeq(struct _SEQSEQ *sp, unsigned int s, unsigned int e);
// curtailSeqAtFirstSpace
// file sequence.c line 1148
static unsigned int curtailSeqAtFirstSpace(struct _SEQSEQ *sp);
// decodeSeq
// file sequence.c line 1552
static signed int decodeSeq(struct _SEQSEQ *sp, const struct _SeqCodec *codep);
// decodeSeqAsStandardNt
// file sequence.c line 1565
static signed int decodeSeqAsStandardNt(struct _SEQSEQ *dep, const struct _SEQSEQ *sp, unsigned long int start, unsigned long int length, const struct _SeqCodec *codep, char as_rcp);
// defineHitRegions
// file segment.c line 396
static signed int defineHitRegions(struct _HITREGION **idxr, signed int *n_added, unsigned short int *max_dshift, unsigned int min_ktup, const struct _HashHitList *hhlp);
// deleteALICPLX
// file alignment.c line 230
static void deleteALICPLX(struct _ALICPLX *p);
// deleteREPNAMBUF
// file report.c line 518
static void deleteREPNAMBUF(struct _REPNAMBUF *p);
// deleteRMAPBUFF
// file rmap.c line 1098
static void deleteRMAPBUFF(struct RMAPBUFF_ *rmp);
// deleteRMAPINFO
// file rmap.c line 1001
static void deleteRMAPINFO(struct RMAPINFO_ *rmp);
// deleteRMAPPROF
// file rmap.c line 934
static void deleteRMAPPROF(struct RMAPPROF_ *p);
// deleteSeq
// file sequence.c line 708
static void deleteSeq(struct _SEQSEQ *sp);
// derriveSEGCAND
// file segment.c line 929
static signed int derriveSEGCAND(struct _SEGCAND *candp, signed int segix_start, signed int nseg, struct _SEGMENT *segmbasp, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip, unsigned int cover, unsigned int mincover_noindel, unsigned int hregix, unsigned char is_reverse);
// diffBlocksCreate
// file diffstr.h line 157
struct _DiffBlocks * diffBlocksCreate(signed int blksz);
// diffBlocksDelete
// file diffstr.h line 162
void diffBlocksDelete(struct _DiffBlocks *p);
// diffBlocksGetLen
// file diffstr.h line 170
signed int diffBlocksGetLen(signed int *unprof_start, signed int *prof_start, signed int blkno, const struct _DiffBlocks *p);
// diffBlocksGetNumber
// file diffstr.h line 166
signed int diffBlocksGetNumber(const struct _DiffBlocks *p);
// diffStrAdd
// file diffstr.h line 222
signed int diffStrAdd(struct _DiffStr *top, const unsigned char *fcp, signed int len);
// diffStrAppend
// file diffstr.h line 229
signed int diffStrAppend(struct _DiffStr *top, const struct _DiffStr *fromp);
// diffStrAsView
// file diffstr.h line 418
signed int diffStrAsView(struct _DiffView *dvp, const unsigned char *dstrp, char outform, signed int clip_start, signed int clip_end, char is_softclipped);
// diffStrCalcAliLen
// file diffstr.h line 251
signed int diffStrCalcAliLen(signed int *matchnum, const unsigned char *diffstrp);
// diffStrCalcSeqLen
// file diffstr.c line 898
signed int diffStrCalcSeqLen(signed int *len_prof, signed int *len_unprof, const unsigned char *diffstrp);
// diffStrCleanUp
// file diffstr.h line 206
void diffStrCleanUp(struct _DiffStr *p);
// diffStrCopy
// file diffstr.c line 795
signed int diffStrCopy(struct _DiffStr *dfsp, const unsigned char *diffstrp);
// diffStrCreate
// file diffstr.h line 191
struct _DiffStr * diffStrCreate(signed int blocksiz);
// diffStrCreateView
// file diffstr.h line 405
struct _DiffView * diffStrCreateView(signed int blksz);
// diffStrCrop
// file diffstr.c line 1260
signed int diffStrCrop(unsigned char *diffstrp, signed int *dstrlen, signed int start_unprof_target, signed int end_unprof_target, signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof);
// diffStrDelete
// file diffstr.h line 196
void diffStrDelete(struct _DiffStr *dfsp);
// diffStrDeleteView
// file diffstr.h line 410
void diffStrDeleteView(struct _DiffView *p);
// diffStrFetchSegment
// file diffstr.c line 1352
signed int diffStrFetchSegment(struct _DiffStr *dfsp, const unsigned char *diffstrp, signed int start_unprof_target, signed int end_unprof_target, signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof);
// diffStrFindBlocks
// file diffstr.h line 181
signed int diffStrFindBlocks(struct _DiffBlocks *dbp, const unsigned char *diffstrp);
// diffStrGenerateFromMismatches
// file diffstr.h line 279
signed int diffStrGenerateFromMismatches(signed int *dlen, unsigned char *diffstrp, const signed int *mmpos, signed int mmnum, signed int qlen);
// diffStrGetDiffStats
// file diffstr.c line 954
signed int diffStrGetDiffStats(signed int *n_sub, signed int *n_ins, signed int *n_del, const unsigned char *diffstrp);
// diffStrGetLevenshteinDistance
// file diffstr.h line 397
signed int diffStrGetLevenshteinDistance(const unsigned char *diffstrp);
// diffStrGetViewStr
// file diffstr.h line 414
const char * diffStrGetViewStr(const struct _DiffView *p);
// diffStrInit
// file diffstr.h line 200
signed int diffStrInit(struct _DiffStr *p, signed int blocksiz);
// diffStrParsePlain
// file diffstr.c line 1126
signed int diffStrParsePlain(struct _DiffStr *dfsp, const char *rawstrp);
// diffStrParseSimul
// file diffstr.c line 1169
signed int diffStrParseSimul(struct _DiffStr *dfsp, signed int *clip_start, signed int *clip_end, unsigned char isSAMCIGAR, const char *rawstrp);
// diffStrPrintf
// file diffstr.h line 291
signed int diffStrPrintf(struct _IO_FILE *fp, const unsigned char *diffstrp, char outform, signed int clip_start, signed int clip_end, char is_softclipped);
// diffStrPrintfStr
// file diffstr.c line 1084
signed int diffStrPrintfStr(char *sp, signed int *nchar, const unsigned char *diffstrp, char outform, signed int clip_start, signed int clip_end, char is_softclipped);
// diffStrRealloc
// file diffstr.h line 210
signed int diffStrRealloc(struct _DiffStr *dfsp, signed int n_new);
// diffStrReverse
// file diffstr.c line 850
signed int diffStrReverse(struct _DiffStr *dfsp, const unsigned char *diffstrp);
// diffStrScore
// file diffstr.c line 1459
signed int diffStrScore(const unsigned char *diffstrp, signed int *swscor, signed short int match, signed short int mismatch, signed short int gapopen, signed short int gapextend);
// diffStrSegment
// file diffstr.h line 373
signed int diffStrSegment(struct _DiffStr *dfsp, const unsigned char *diffstrp, signed int start_unprof_target, signed int end_unprof_target, signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// doAllWordsInSeqSet
// file hashidx.c line 533
static signed int doAllWordsInSeqSet(unsigned int *tuplectrp, struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivp, const struct _SeqCodec *codecp, signed int (*keyfunc)(const struct _HashTable *, unsigned long int, unsigned int));
// doAllWordsInSeqSet::keyfunc$object
//
signed int keyfunc$object(const struct _HashTable *, unsigned long int, unsigned int);
// doWordsInSeq
// file hashidx.c line 465
static signed int doWordsInSeq(unsigned int *tuplectr, unsigned char *ktup_offs, const struct _SeqFastq *sqp, const struct _HashTable *htp, signed int (*keyfunc)(const struct _HashTable *, unsigned long int, unsigned int));
// doWordsInSeq::keyfunc$object
//
signed int keyfunc$object(const struct _HashTable *, unsigned long int, unsigned int);
// drand48
// file /usr/include/stdlib.h line 389
extern double drand48(void);
// drawPairAtRandomByProbability
// file resultpairs.c line 726
static struct _MATEPAIR * drawPairAtRandomByProbability(struct _MATEPAIR * const mpr);
// eStringAppend
// file elib.h line 243
signed int eStringAppend(struct EString_ *esp, const char *strp, const char *progfil, signed int line);
// eStringCreate
// file elib.h line 240
struct EString_ * eStringCreate(signed int blksz, const char *progfil, signed int line);
// eStringDelete
// file elib.h line 241
void eStringDelete(struct EString_ **esp, const char *progfil, signed int line);
// eStringInit
// file elib.h line 239
char * eStringInit(struct EString_ *esp, signed int blksz, const char *progfil, signed int line);
// eStringResize
// file elib.c line 594
signed int eStringResize(struct EString_ *esp, unsigned long int newlen, const char *progfil, signed int line);
// ecalloc
// file elib.h line 190
void * ecalloc(unsigned long int nobj, unsigned long int size, const char *progfil, signed int line);
// efclose
// file elib.h line 195
signed int efclose(struct _IO_FILE *fp, const char *progfil, signed int line);
// efopen
// file elib.h line 193
struct _IO_FILE * efopen(const char *filnam, const char *mode, const char *progfil, signed int line);
// emalloc
// file elib.h line 189
void * emalloc(unsigned long int size, const char *progfil, signed int line);
// encodeSeq
// file sequence.c line 1338
static signed int encodeSeq(struct _SEQSEQ *sp, const struct _SeqCodec *codep);
// erealloc
// file elib.h line 191
void * erealloc(void *objp, unsigned long int size, unsigned long int size_old, const char *progfil, signed int line);
// ereallocp
// file elib.h line 192
void * ereallocp(void **objp, unsigned long int size, const char *progfil, signed int line);
// errMsgAdd
// file elib.h line 166
void errMsgAdd(struct _ErrMsg *emp, const char *message, const char *progfil, signed int linenum, signed int errcode, unsigned char level);
// errMsgCreate
// file elib.h line 154
struct _ErrMsg * errMsgCreate(const char *progfil, signed int linenum);
// errMsgEnd
// file elib.h line 157
void errMsgEnd(struct _ErrMsg *p);
// errMsgFlush
// file elib.c line 395
void errMsgFlush(struct _IO_FILE *fp, struct _ErrMsg *emp);
// errMsgSetCurrentReadName
// file elib.h line 160
void errMsgSetCurrentReadName(struct _ErrMsg *emp, const char *namp);
// errMsgSetCurrentReadNumber
// file elib.h line 163
void errMsgSetCurrentReadNumber(struct _ErrMsg *emp, unsigned long int rno);
// errMsgString
// file elib.c line 82
const char * errMsgString(signed int errcode);
// estrcat
// file elib.c line 530
char * estrcat(const char *str1, const char *str2, const char *progfil, signed int line);
// estrcpy
// file elib.h line 196
char * estrcpy(const char *str, const char *progfil, signed int line);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exitArgumentRangeError
// file menu.c line 861
static void exitArgumentRangeError(const char *option, signed long int minval, signed long int maxval);
// exitOptionError
// file menu.c line 840
static void exitOptionError(const char *option, const char *expl);
// exitPairedReadError
// file menu.c line 852
static void exitPairedReadError(const char *option);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// extendCand
// file segment.c line 1097
static signed int extendCand(struct _SEGCAND *sgcp, struct _SEGMENT *segmr, struct _HITREGION * const hregr, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filioOpenForReading
// file filio.h line 72
struct _IO_FILE * filioOpenForReading(signed int *errcode, unsigned char *is_endianid, unsigned int *siz, unsigned char *typ, unsigned int *version, unsigned int *headsiz, unsigned int *header, const char *filnam, const char *filext);
// filioOpenForWriting
// file filio.h line 55
struct _IO_FILE * filioOpenForWriting(signed int *errcode, unsigned int siz, unsigned char typ, unsigned int version, unsigned int headsiz, const unsigned int *header, const char *filnam, const char *filext);
// filioSwapEndian
// file filio.h line 93
void filioSwapEndian(unsigned int *p, unsigned int len);
// fillHitListFromHitInfoSegment
// file hashhit.c line 1417
static signed int fillHitListFromHitInfoSegment(struct _HashHitList *hlp, unsigned int segpos_lo, unsigned int segpos_hi, unsigned int maxhit_per_tuple, unsigned char use_short_hitinfo, const struct _HashHitInfo *hip, const struct _HashTable *htp, const struct _HashHitFilter *hhfp);
// fillRMAPBUFF
// file rmap.c line 1153
static signed int fillRMAPBUFF(struct RMAPBUFF_ *bufp, const struct RMAPINFO_ *rmrp, unsigned char with_seqidx, signed int ktuple_maxhit, unsigned int min_ktup, unsigned int min_cover, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivr);
// finaliseSeq
// file sequence.c line 768
static signed int finaliseSeq(struct _SEQSEQ *sp);
// findInsHistMax
// file insert.c line 230
static signed int findInsHistMax(const struct _InsHist *pHist, signed int *count_max, signed int *range_min, signed int *range_max);
// findProperMATEPAIR
// file resultpairs.c line 529
static signed int findProperMATEPAIR(struct _ResultPairs * const pairp, const struct _ResultSet *rsp, signed int swscor_min, const struct _OFFSIVAL * const oivr, unsigned char pairlibcode, signed int maxnum);
// findREPALI
// file report.c line 545
static signed int findREPALI(const struct _REPALI *rar, signed int *idxp, unsigned int q_start, unsigned int q_end, unsigned char rmatflg, unsigned int s_start, unsigned int s_end, signed long int s_idx);
// findSplitReads
// file results.c line 1436
static signed int findSplitReads(struct _RESULT * const *rspp);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintAlignment
// file report.c line 248
static signed int fprintAlignment(struct _IO_FILE *fp, struct _SeqFastq *sbufp, struct _SeqFastq *qbufp, const struct _SeqFastq *sqp, unsigned short int linwidth, const struct _DiffStr *dfsp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct _REPALI *rp);
// fprintCommandLine
// file menu.c line 1674
static void fprintCommandLine(struct _IO_FILE *fp, signed int argc, char **argv);
// fprintHashOptions
// file menu.c line 1651
static signed int fprintHashOptions(struct _IO_FILE *fp, const struct _MenuOpt *menup);
// fprintMapOptions
// file menu.c line 1662
static signed int fprintMapOptions(struct _IO_FILE *fp, const struct _MenuOpt *menup);
// fprintREPALIcigar
// file report.c line 711
static signed int fprintREPALIcigar(struct _IO_FILE *fp, const struct _REPALI *rp, signed short int mapscor, struct _REPSTR *q_namp, const struct _SeqFastq *q_sqp, const char *q_namext, const char *s_nam, const unsigned char *diffstr, unsigned char pairflg);
// fprintREPALIgff2
// file report.c line 648
static signed int fprintREPALIgff2(struct _IO_FILE *fp, const struct _REPALI *rp, struct _REPSTR *q_namp, const struct _SeqFastq *q_sqp, const char *q_namext, const char *s_nam, const struct _DiffBlocks *dfblkp);
// fprintREPALIsam
// file report.c line 762
static signed int fprintREPALIsam(struct _IO_FILE *fp, struct _SeqFastq *sqbufp, struct _REPSTR *readnamp, signed short int mapscor, const struct _REPALI *rrp, const unsigned char *diffstr, const struct _SeqFastq *q_sqp, const char *refnam, const struct _REPALI *rmp, const char *mate_refnam, signed int isize, unsigned char pairflg, unsigned char oumodiflg, const struct _SeqCodec *codecp);
// fprintREPALIssaha
// file report.c line 579
static signed int fprintREPALIssaha(struct _IO_FILE *fp, const struct _REPALI *rp, signed short int mapscor, struct _REPSTR *q_namp, const struct _SeqFastq *q_sqp, const char *q_namext, const char *s_nam, unsigned int s_len, const unsigned char *diffstr, unsigned char pairflg);
// fprintReadNameAndNumber
// file elib.c line 282
static void fprintReadNameAndNumber(struct _IO_FILE *fp, const char *rnam, unsigned long int rno);
// fprintScoreMatrix
// file score.c line 175
static void fprintScoreMatrix(struct _IO_FILE *fp, const struct _ScoreMatrix *amp, const struct _SeqCodec *scp);
// fprintSeqFastqHeader
// file sequence.c line 1631
static signed int fprintSeqFastqHeader(void *top, unsigned char is_gzipped, const struct _SEQSEQ *sp, signed int prompt);
// fprintSeqFastqSequence
// file sequence.c line 1677
static signed int fprintSeqFastqSequence(void *top, unsigned char is_gzipped, const struct _SEQSEQ *sp, signed short int linewidth);
// fprintTaskDoc
// file menu.c line 790
static void fprintTaskDoc(struct _IO_FILE *oufp, const struct TASKDOC_ *tdocp, unsigned char isLong);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fprintfDiffStrPlain
// file diffstr.c line 276
static void fprintfDiffStrPlain(struct _IO_FILE *fp, const unsigned char *dstrp);
// fprintfDiffStrRaw
// file diffstr.c line 250
static void fprintfDiffStrRaw(struct _IO_FILE *fp, const unsigned char *dstrp);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// generateOFFSIVAL
// file resultpairs.c line 445
static signed int generateOFFSIVAL(struct _OFFSIVAL **oivr, signed int d_min, signed int d_max, const struct _ResultSet *rsp);
// getFilterIdForRead
// file results.c line 2552
static unsigned int getFilterIdForRead(const struct _ResultFilter *rfp, const struct _SeqFastq *sqp);
// getHitInfoMaxRank
// file hashhit.c line 769
static signed int getHitInfoMaxRank(unsigned int *n, unsigned int mincover, unsigned int maxcover, unsigned int maxhit, const struct _HashHitInfo *hip);
// getMATEPAIRcbf_InnerLoop
// file resultpairs.c line 365
static signed int getMATEPAIRcbf_InnerLoop(signed int *errcode, void *argp, const struct _RESULT *rp);
// getMATEPAIRcbf_OuterLoop
// file resultpairs.c line 407
static signed int getMATEPAIRcbf_OuterLoop(signed int *errcode, void *argp, const struct _RESULT *rp);
// getMapLabelFromFlag
// file report.c line 217
static char getMapLabelFromFlag(unsigned char mateflg, unsigned char pairflg);
// getNumberOfTopSwatRESULTs
// file results.c line 839
static unsigned char getNumberOfTopSwatRESULTs(signed short int *n_best, struct _RESULT **rspp);
// getProperMATEPAIRcbf
// file resultpairs.c line 265
static signed int getProperMATEPAIRcbf(signed int *errcode, void *argp, const struct _RESULT *rp);
// getSAMPLEQuartiles
// file insert.c line 148
static signed int getSAMPLEQuartiles(signed int *med, signed int *qlo, signed int *qhi, struct V_int32_t_ *pSample);
// gzclose
// file /usr/include/zlib.h line 1511
extern signed int gzclose(struct gzFile_s *);
// gzeof
// file /usr/include/zlib.h line 1475
extern signed int gzeof(struct gzFile_s *);
// gzgetc
// file /usr/include/zlib.h line 1391
extern signed int gzgetc(struct gzFile_s *);
// gzgets
// file /usr/include/zlib.h line 1372
extern char * gzgets(struct gzFile_s *, char *, signed int);
// gzopen
// file /usr/include/zlib.h line 1725
extern struct gzFile_s * gzopen(const char *, const char *);
// gzputc
// file /usr/include/zlib.h line 1385
extern signed int gzputc(struct gzFile_s *, signed int);
// gzputs
// file /usr/include/zlib.h line 1364
extern signed int gzputs(struct gzFile_s *, const char *);
// gzrewind
// file /usr/include/zlib.h line 1447
extern signed int gzrewind(struct gzFile_s *);
// gzungetc
// file /usr/include/zlib.h line 1400
extern signed int gzungetc(signed int, struct gzFile_s *);
// hash32mix
// file hashidx.c line 163
static unsigned int hash32mix(unsigned int a);
// hashAddToHitFilter
// file hashhit.c line 1974
signed int hashAddToHitFilter(struct _HashHitFilter *hhfp, unsigned int lo, unsigned int hi);
// hashBlankHitList
// file hashhit.h line 179
void hashBlankHitList(struct _HashHitList *hlp);
// hashCalcHitInfoCoverDeficit
// file hashhit.c line 1096
unsigned int hashCalcHitInfoCoverDeficit(const struct _HashHitInfo *hip);
// hashCalcHitInfoNumberOfHits
// file hashhit.h line 150
unsigned int hashCalcHitInfoNumberOfHits(const struct _HashHitInfo *hhip, unsigned int maxhit_per_tuple);
// hashCalcHitListCoverDeficit
// file hashhit.c line 1883
unsigned int hashCalcHitListCoverDeficit(const struct _HashHitList *hlp);
// hashCheckHitList
// file hashhit.c line 1790
signed int hashCheckHitList(const struct _HashHitList *hlp, const struct _SeqFastq *seqp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codep);
// hashCollectHitInfo
// file hashhit.h line 98
signed int hashCollectHitInfo(struct _HashHitInfo *hhip, unsigned char is_reverse, unsigned char basq_thresh, unsigned int seq_start, unsigned int seq_end, const struct _SeqFastq *seqp, const struct _HashTable *htp);
// hashCollectHitInfoShort
// file hashhit.h line 119
signed int hashCollectHitInfoShort(struct _HashHitInfo *hhip, unsigned char is_reverse, unsigned int maxhit_per_tuple, unsigned int maxhit_total, unsigned char basq_thresh, const struct _SeqFastq *seqp, const struct _HashTable *htp);
// hashCollectHitsForSegment
// file hashhit.h line 206
signed int hashCollectHitsForSegment(struct _HashHitList *hlp, unsigned long int segmoffs_lo, unsigned long int segmoffs_hi, unsigned int nhit_max, unsigned char use_short_hitinfo, const struct _HashHitInfo *hhip, const struct _HashTable *htp, const struct _HashHitFilter *hhfp);
// hashCollectHitsUsingCutoff
// file hashhit.h line 249
signed int hashCollectHitsUsingCutoff(struct _HashHitList *hlp, unsigned int max_nhit_per_tup, const struct _HashTable *htp, const struct _HashHitInfo *hip);
// hashCreateHitFilter
// file hashhit.c line 1942
struct _HashHitFilter * hashCreateHitFilter(signed short int blocksiz);
// hashCreateHitInfo
// file hashhit.h line 90
struct _HashHitInfo * hashCreateHitInfo(signed int blksz, const struct _HashTable *htp);
// hashCreateHitList
// file hashhit.h line 172
struct _HashHitList * hashCreateHitList(signed int maxnhits);
// hashDeleteHitFilter
// file hashhit.c line 1960
void hashDeleteHitFilter(struct _HashHitFilter *p);
// hashDeleteHitInfo
// file hashhit.h line 94
void hashDeleteHitInfo(struct _HashHitInfo *p);
// hashDeleteHitList
// file hashhit.h line 176
void hashDeleteHitList(struct _HashHitList *hlp);
// hashGetHitListData
// file hashhit.c line 1867
const unsigned long int * hashGetHitListData(signed int *nhits, char *is_reverse, unsigned int *qlen, unsigned char *ktup, unsigned char *nskip, const char **qmask, const struct _HashHitList *hlp);
// hashHitInfoCalcHitNumbers
// file hashhit.h line 161
unsigned int hashHitInfoCalcHitNumbers(const struct _HashHitInfo *hhip, unsigned int *nhit_rank);
// hashPrintHitList
// file hashhit.c line 1771
void hashPrintHitList(const struct _HashHitList *hlp, struct _IO_FILE *fp);
// hashPruneHitFilter
// file hashhit.c line 1988
void hashPruneHitFilter(struct _HashHitFilter *hhfp);
// hashResetHitFilter
// file hashhit.c line 1968
void hashResetHitFilter(struct _HashHitFilter *p);
// hashSortHitInfo
// file hashhit.c line 1082
signed int hashSortHitInfo(struct _HashHitInfo *hhip);
// hashTableCheckExtensive
// file hashidx.c line 1000
signed int hashTableCheckExtensive(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// hashTableCheckQuick
// file hashidx.c line 1008
signed int hashTableCheckQuick(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// hashTableCmp
// file hashidx.c line 1087
signed int hashTableCmp(const struct _HashTable *ap, const struct _HashTable *bp);
// hashTableCreate
// file hashidx.h line 80
struct _HashTable * hashTableCreate(unsigned char wordlen, unsigned char nskip, unsigned char nbits_key, unsigned char nbits_perf, unsigned char typ);
// hashTableDelete
// file hashidx.h line 92
void hashTableDelete(struct _HashTable *htp);
// hashTableFetchHitPositions
// file hashidx.c line 1194
unsigned int hashTableFetchHitPositions(unsigned int **posp, const struct _HashTable *htp, unsigned int posidx);
// hashTableGetKtupLen
// file hashidx.h line 145
unsigned char hashTableGetKtupLen(const struct _HashTable *htp, unsigned char *nskip);
// hashTableGetKtupleHits
// file hashidx.c line 1147
unsigned int hashTableGetKtupleHits(unsigned int **posp, unsigned int *posidx, const struct _HashTable *htp, unsigned long int word);
// hashTableGetMaxPos
// file hashidx.c line 1025
unsigned int hashTableGetMaxPos(const struct _HashTable *htp);
// hashTablePrintStats
// file hashidx.h line 155
void hashTablePrintStats(struct _IO_FILE *fp, const struct _HashTable *htp);
// hashTableRead
// file hashidx.h line 188
struct _HashTable * hashTableRead(signed int *errcode, const char *filnam);
// hashTableReset
// file hashidx.h line 95
void hashTableReset(struct _HashTable *htp, unsigned char nskip);
// hashTableSetUp
// file hashidx.h line 101
signed int hashTableSetUp(struct _HashTable *htp, struct _SeqFastq *sqbufp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivp, const struct _SeqCodec *codecp, unsigned int *npos_max, char verbose);
// hashTableWrite
// file hashidx.h line 184
signed int hashTableWrite(const char *filnam, const struct _HashTable *htp);
// infmtCheckReads
// file infmt.h line 101
signed int infmtCheckReads(struct _InFmtReader *ifrp, struct _SeqFastq *sqbufAp, struct _SeqFastq *sqbufBp, signed long int *seqnum, unsigned int *maxseqlen, unsigned int *maxnamlen, struct _ErrMsg *errmsgp);
// infmtCreateReader
// file infmt.h line 65
struct _InFmtReader * infmtCreateReader(signed int *errcode, const char *filnamA, const char *filnamB, const char *tmpdir, const unsigned char fmt);
// infmtDeleteReader
// file infmt.h line 85
void infmtDeleteReader(struct _InFmtReader *p);
// infmtGetReaderStatus
// file infmt.h line 89
signed int infmtGetReaderStatus(const struct _InFmtReader *ifrp);
// infmtRead
// file infmt.h line 93
signed int infmtRead(struct _InFmtReader *ifrp, struct _SeqFastq *sfqAp, struct _SeqFastq *sfqBp, unsigned char *isPair);
// infmtReset
// file infmt.h line 119
signed int infmtReset(struct _InFmtReader *ifrp);
// initALIBAND
// file alignment.c line 310
static signed int initALIBAND(struct _ALIBAND *abp, signed int l_edge, signed int r_edge, signed int q_left, signed int q_right, signed int q_len, signed int s_left, signed int s_right, signed int s_len);
// initALIMETA
// file alignment.c line 568
static signed int initALIMETA(struct _ALIMETA *p, signed short int dfstr_blksz);
// initALITRACK
// file alignment.c line 439
static signed int initALITRACK(struct _ALITRACK *p, unsigned long int blksz, unsigned long int n_alloc_thresh);
// initARGBUFF
// file threads.c line 347
static signed int initARGBUFF(struct _ARGBUFF *fifop, unsigned char buftyp);
// initArgBlock
// file smalt.c line 882
static signed int initArgBlock(void *ap, const void *ip, signed short int argno);
// initBAMHeader
// file report.c line 1303
static signed int initBAMHeader(struct _BamBam_BamWriter **bamwriterpp, struct _BamBam_BamHeaderInfo **headinfopp, struct _REPSTR *sbufp, const char *prognam, const char *progversion, signed int narg, char * const *argv, const char *filnamp, const struct _SeqSet *ssp);
// initHashOptions
// file menu.c line 1106
static signed int initHashOptions(struct _MenuOpt *menup);
// initHitList
// file hashhit.c line 1262
static signed int initHitList(struct _HashHitList *hlp, const struct _HashHitInfo *hip);
// initIOBuffArg
// file smalt.c line 739
static signed int initIOBuffArg(struct _SmaltIOBuffArg *argp, unsigned char prep_paired);
// initInput
// file smalt.c line 674
static signed int initInput(void *ip, const void *mp, signed short int threadno);
// initMapArgs
// file smalt.c line 1039
static signed int initMapArgs(void *ap, const void *ip, signed short int threadno);
// initMapConst
// file smalt.c line 443
static signed int initMapConst(struct _SmaltMapConst *smcp, const struct _MenuOpt *menup);
// initMapOptions
// file menu.c line 1122
static signed int initMapOptions(struct _MenuOpt *menup);
// initREPSTR
// file report.c line 403
static signed int initREPSTR(struct _REPSTR *rsp, signed int blksz);
// initRMAPINFO
// file rmap.c line 1027
static signed int initRMAPINFO(struct RMAPINFO_ *rmp, unsigned char min_basqval, unsigned int seq_start, unsigned int seq_end, const struct _SeqFastq *readp, const struct _HashTable *htp);
// initRMAPINFOshort
// file rmap.c line 1046
static signed int initRMAPINFOshort(struct RMAPINFO_ *rmp, signed int maxhit_per_tuple, unsigned char min_basqval, const struct _SeqFastq *readp, const struct _HashTable *htp);
// initRepeatFilter
// file hashhit.c line 342
static void initRepeatFilter(signed long int *tdrf);
// initSmaltOutput
// file smalt.c line 627
static signed int initSmaltOutput(void *op, const void *mp, signed short int threadno);
// insAddSample
// file insert.h line 69
signed int insAddSample(struct _InsSample *pInsSample, signed int insertsiz);
// insCreateHisto
// file insert.c line 305
struct _InsHist * insCreateHisto(signed int iLen);
// insCreateSample
// file insert.h line 52
struct _InsSample * insCreateSample(signed int blksz);
// insDeleteHisto
// file insert.h line 100
void insDeleteHisto(struct _InsHist *p);
// insDeleteSample
// file insert.h line 57
void insDeleteSample(struct _InsSample *pInsSample);
// insGetHistoCount
// file insert.c line 531
signed int insGetHistoCount(signed int *totnum, signed int insiz, unsigned char is_smooth, const struct _InsHist *pHist);
// insGetHistoCountCumulative
// file insert.h line 136
signed int insGetHistoCountCumulative(signed int *totnum, signed int insiz, unsigned char is_smooth, const struct _InsHist *pHist);
// insGetHistoData
// file insert.h line 144
unsigned long int insGetHistoData(signed int *lo, signed int *hi, signed int *n_bins, const struct _InsHist *pHist);
// insGetHistoProb
// file insert.c line 516
double insGetHistoProb(signed int insiz, const struct _InsHist *pHist);
// insGetHistoQuartiles
// file insert.c line 567
signed int insGetHistoQuartiles(signed int *qlo, signed int *qhi, const struct _InsHist *pHist);
// insGetSample
// file insert.h line 81
unsigned long int insGetSample(signed int **pSample, signed int *readival, const struct _InsSample *pInsSample);
// insIsInSample
// file insert.c line 215
signed int insIsInSample(const struct _InsSample *pInsSample, unsigned long int readno);
// insMakeHistoFromSample
// file insert.h line 96
struct _InsHist * insMakeHistoFromSample(const struct _InsSample *pInsSample);
// insPrintHisto
// file insert.h line 158
signed int insPrintHisto(struct _IO_FILE *fp, signed int linwidth, unsigned char is_smooth, const struct _InsHist *pHist);
// insReadHisto
// file insert.h line 173
struct _InsHist * insReadHisto(signed int *errcode, const char *filnam);
// insSeedHistoNormal
// file insert.c line 433
void insSeedHistoNormal(struct _InsHist *pHist, signed int mean, signed int std, signed int num);
// insSetSamplingInterval
// file insert.h line 61
void insSetSamplingInterval(struct _InsSample *pInsSample, unsigned long int nreads, signed int nrskip);
// insSmoothHisto
// file insert.c line 472
signed int insSmoothHisto(struct _InsHist *pHist);
// insUpdateHisto
// file insert.c line 462
void insUpdateHisto(struct _InsHist *pHist, signed int insiz);
// insWriteHisto
// file insert.h line 166
signed int insWriteHisto(struct _IO_FILE *fp, unsigned char is_smooth, const struct _InsHist *pHist);
// interValAppend
// file interval.h line 66
signed int interValAppend(struct V_IVAL_ *p, unsigned int lo, unsigned int hi, signed long int sx, unsigned short int flag);
// interValBlank
// file interval.h line 63
void interValBlank(struct V_IVAL_ *p);
// interValCreate
// file interval.h line 57
struct V_IVAL_ * interValCreate(signed int blksz);
// interValDelete
// file interval.h line 60
void interValDelete(struct V_IVAL_ *p);
// interValGet
// file interval.h line 80
signed int interValGet(unsigned int *lo, unsigned int *hi, signed long int *sx, unsigned short int *flg, signed int idx, const struct V_IVAL_ *p);
// interValNum
// file interval.h line 77
signed int interValNum(const struct V_IVAL_ *p);
// interValPrune
// file interval.h line 74
void interValPrune(struct V_IVAL_ *p);
// isIdenticalResult
// file results.c line 556
static signed int isIdenticalResult(const struct _RESULT *ap, const struct _RESULT *bp);
// labelComplementarySegments
// file results.c line 707
static signed int labelComplementarySegments(struct _ResultSet *rsp, const signed short int min_overlap_percent);
// loadArgBlock
// file smalt.c line 930
static signed int loadArgBlock(struct _ErrMsg *errmsgp, void *thargp, void *bufargp);
// loadIOBuffArg
// file smalt.c line 795
static signed int loadIOBuffArg(struct _ErrMsg *errmsgp, struct _SmaltInput *inp, struct _SmaltIOBuffArg *argp);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log10
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 112
extern double log10(double);
// make3BitMangledCodec
// file sequence.c line 287
static signed int make3BitMangledCodec(struct _SeqCodec *codp);
// makeMetaFromTrack
// file alignment.c line 628
static signed int makeMetaFromTrack(struct _ALIMETA *metap, struct _ALICPLX *cplxp, const struct _ALITRACK *tp, const struct _ALIBAND *bp, const struct _ScoreProfile *qp, const char *unprofiled_seq);
// makeRMAPCANDfromSegment
// file rmap.c line 535
static signed int makeRMAPCANDfromSegment(struct RMAPCAND_ *cp, struct _SeqFastq *sqbufp, unsigned int *coverp, unsigned int qlen, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, unsigned int i, const struct _SegAliCands *sacp);
// makeRMAPPROFfromRead
// file rmap.c line 976
static signed int makeRMAPPROFfromRead(struct RMAPPROF_ *prp, const struct _SeqFastq *readp, const struct _ScoreMatrix *scormtxp, const struct _SeqCodec *codecp);
// makeSeedsFromHits
// file segment.c line 455
static signed int makeSeedsFromHits(struct _SEED$0 **seedr, struct _HITREGION * const idxr, signed int reg_start, signed int nreg, const struct _HashHitList *hhlp);
// makeSegmentsFromSeeds
// file segment.c line 535
static signed int makeSegmentsFromSeeds(struct _SEGMENT **segmr, unsigned int *maxcover, struct _HITREGION * const hregr, unsigned int reg_start, unsigned int nreg, struct _SEED$0 * const seedr, unsigned char nskip);
// makeStripedProfileFromSequence
// file score.c line 438
static signed int makeStripedProfileFromSequence(struct _ScoreProfile *app, const char *seq_basp, unsigned int length, const struct _ScoreMatrix *amp);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mapReads
// file smalt.c line 1316
static signed int mapReads(struct _ErrMsg *errmsgp, const struct _MenuOpt *menup);
// mapReads::1::checkf$object
//
signed int checkf$object(const void *, const void *);
// mapReads::1::cmpf$object
//
signed int cmpf$object(const void *, const void *);
// mapSecondary
// file rmap.c line 1435
static signed int mapSecondary(struct _ErrMsg *errmsgp, struct RMAPBUFF_ *bufp, struct _ResultSet *rssp, struct RMAPINFO_ *rmrp, const struct RMAPPROF_ *rmprp, struct _SeqFastq *readp, signed int ktuple_maxhit, unsigned int min_cover, signed int min_swatscor, signed int min_swatscor_below_max, unsigned char min_basqval, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// mapSingleRead
// file rmap.c line 1228
static signed int mapSingleRead(struct _ErrMsg *errmsgp, struct RMAPBUFF_ *bufp, struct _ResultSet *rssp, const struct RMAPINFO_ *rmrp, const struct RMAPPROF_ *rprofp, struct _SeqFastq *readp, signed int ktuple_maxhit, unsigned int min_cover, signed int min_swatscor, signed int min_swatscor_below_max, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct V_IVAL_ *ivr);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menuCreate
// file menu.h line 127
struct _MenuOpt * menuCreate(void);
// menuDelete
// file menu.h line 130
void menuDelete(struct _MenuOpt *mp);
// menuGetCommandLine
// file menu.h line 151
char ** menuGetCommandLine(const struct _MenuOpt *mp, signed int *argc);
// menuGetFileNames
// file menu.h line 243
signed int menuGetFileNames(const struct _MenuOpt *mp, const char **filnam1p, const char **filnam2p);
// menuGetFlags
// file menu.h line 236
unsigned short int menuGetFlags(const struct _MenuOpt *menup);
// menuGetHashParams
// file menu.h line 158
signed int menuGetHashParams(const struct _MenuOpt *mp, const char **hashnamp, unsigned char *kmer, unsigned char *nskip);
// menuGetMapInputFormat
// file menu.h line 212
signed int menuGetMapInputFormat(const struct _MenuOpt *menup, unsigned char *infmt, const char **tmpdirnam);
// menuGetMapParams
// file menu.h line 166
signed int menuGetMapParams(const struct _MenuOpt *menup, const char **hashnamp, signed int *nhitmax_tuple, double *tupcovmin, signed short int *minscore, signed short int *scorediff, unsigned char *minbasq, double *minidentity, signed int *randseed, signed int *readskip, signed int *insert_min, signed int *insert_max, unsigned char *outform, const char **outfilnam, const char **insfilnam, unsigned char *pairtyp);
// menuGetMapPenaltyScores
// file menu.h line 222
unsigned char menuGetMapPenaltyScores(const struct _MenuOpt *menup, signed char *match, signed char *subst, signed char *gap_open, signed char *gap_ext);
// menuGetNumberOfThreads
// file menu.h line 240
signed short int menuGetNumberOfThreads(const struct _MenuOpt *menup);
// menuGetProgramName
// file menu.h line 154
const char * menuGetProgramName(const char **version);
// menuGetSubProgTyp
// file menu.h line 147
char menuGetSubProgTyp(const struct _MenuOpt *mp);
// menuParseCommandLine
// file menu.h line 133
signed int menuParseCommandLine(struct _MenuOpt *menu, signed int argc, char **argv);
// menuParseCommandLine::1::check_fn$object
//
signed int check_fn$object(struct _MenuOpt *, const struct _optflags *);
// menuParseCommandLine::1::parse_fn$object
//
signed int parse_fn$object(struct _MenuOpt *, struct _optflags *, signed int, char **);
// menuPrint
// file menu.c line 1851
void menuPrint(struct _IO_FILE *fp, const struct _MenuOpt *menup);
// menuPrintWallClockTime
// file menu.h line 251
void menuPrintWallClockTime(struct _IO_FILE *fp, signed long int time_start, signed long int time_stop, const char *headerp);
// menuTestMapOutputFormatFlags
// file menu.h line 204
signed int menuTestMapOutputFormatFlags(const struct _MenuOpt *menup, const unsigned char outform, const unsigned char flags);
// mkeyQSortSuffix
// file sort.c line 132
static void mkeyQSortSuffix(const char *hstrp, unsigned int *sfxidxp, unsigned int nsfx, signed short int depth, signed short int maxdepth);
// mksort
// file sort.c line 44
static void mksort(const char **x, signed int n, signed int depth, signed int maxdepth);
// openINFMTReaderAsFASTQ
// file infmt.c line 66
static signed int openINFMTReaderAsFASTQ(struct _InFmtReader *p, const char *filnamA, const char *filnamB, unsigned char doTest, signed int *errcode_test);
// openINFMTReaderAsSAMBAM
// file infmt.c line 94
static signed int openINFMTReaderAsSAMBAM(struct _InFmtReader *p, const char *filnam, const char *tmpdir, unsigned char is_sam);
// outputArgBlock
// file smalt.c line 1003
static signed int outputArgBlock(struct _ErrMsg *errmsgp, void *thargp, void *buffargp);
// outputHisto
// file smalt.c line 1288
static signed int outputHisto(struct _ErrMsg *errmsgp);
// outputIOBuffArg
// file smalt.c line 838
static signed int outputIOBuffArg(struct _ErrMsg *errmsgp, struct _SmaltOutput *dop, struct _SmaltIOBuffArg *argp);
// parseHashOptions
// file menu.c line 1255
static signed int parseHashOptions(struct _MenuOpt *menup, struct _optflags *optflp, signed int narg, char **argp);
// parseListOfKeyValueAssignments
// file menu.c line 875
static void parseListOfKeyValueAssignments(signed char *vals, unsigned char *bitfld, struct EString_ *estrbufp, const struct VARLST_ *lst, signed short int nelem, const char *listp);
// parseMapOptions
// file menu.c line 1297
static signed int parseMapOptions(struct _MenuOpt *menup, struct _optflags *optflp, signed int narg, char **argp);
// parseOption
// file menu.c line 1036
static signed short int parseOption(void *optarg, const char *optnam, char optyp, signed int narg, char * const *argp);
// parseOutputFormat
// file menu.c line 985
static void parseOutputFormat(struct _OUFMT *oufmt, struct EString_ *estrbufp, const char *optstr, const char *formatp);
// parseSamParams
// file menu.c line 937
static void parseSamParams(unsigned char *samflg, const char *formatp, const char *optstr);
// parseSampleOptions
// file menu.c line 1553
static signed int parseSampleOptions(struct _MenuOpt *menup, struct _optflags *optflp, signed int narg, char **argp);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// prepSample
// file smalt.c line 1253
static signed int prepSample(struct _ErrMsg *errmsgp, const struct _SmaltMapConst *common_args);
// printBlurb
// file menu.c line 820
static void printBlurb(struct _IO_FILE *oufp);
// printSEGCAND
// file segment.c line 918
static signed int printSEGCAND(struct _IO_FILE *fp, const struct _SEGCAND *scp);
// printSeed
// file segment.c line 378
static void printSeed(struct _IO_FILE *fp, const struct _SEED$0 *sp, char is_reverse, unsigned char nskip, unsigned char ktup);
// printWord
// file hashidx.c line 174
static char * printWord(char *buff, unsigned long int word, unsigned char len);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// processArgBlock
// file smalt.c line 1221
static signed int processArgBlock(struct _ErrMsg *errmsgp, void *targp, void *bufargp);
// processMapArgs
// file smalt.c line 1083
static signed int processMapArgs(struct _ErrMsg *errmsgp, struct _SmaltMapArgs *map, struct _SmaltIOBuffArg *brgp);
// propagateMapQualAsProb
// file results.c line 1355
static signed int propagateMapQualAsProb(signed short int qsegx, const struct _ResultSet *rsetp);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pullARGBUFF
// file threads.c line 281
static signed int pullARGBUFF(struct _BUFFARG **argp, struct _ARGBUFF *fifop);
// pullTHREADARGInternalBuffer
// file threads.c line 489
static struct _BUFFARG * pullTHREADARGInternalBuffer(struct _THREADARG *thargp, signed int (*checkf)(const void *, const void *), void *tdatap);
// pullTHREADARGInternalBuffer::checkf$object
//
signed int checkf$object(const void *, const void *);
// pushARGBUFF
// file threads.c line 227
static signed int pushARGBUFF(struct _ARGBUFF *fifop, struct _BUFFARG *argp);
// pushTHREADARGInternalBuffer
// file threads.c line 442
static void pushTHREADARGInternalBuffer(struct _THREADARG *thargp, struct _BUFFARG *argp, signed int (*cmpf)(const void *, const void *));
// pushTHREADARGInternalBuffer::cmpf$object
//
signed int cmpf$object(const void *, const void *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// readCompressedSeq
// file sequence.c line 1436
static signed int readCompressedSeq(struct _SEQSEQ *sp, struct _IO_FILE *fp);
// readCompressedSeqOfKnownLength
// file sequence.c line 1475
static signed int readCompressedSeqOfKnownLength(struct _SEQSEQ *sp, struct _IO_FILE *fp, unsigned long int length);
// readHeader
// file filio.c line 79
static signed int readHeader(unsigned int *filsiz, unsigned char *filtyp, unsigned int *version, unsigned char *is_endianid, unsigned int *headsiz, struct _IO_FILE *fp);
// readHeader$link1
// file sequence.c line 1056
static signed int readHeader$link1(struct _SEQSEQ *sp, struct gzFile_s *fp$link1, signed int *prompt, char *bufp);
// readQual
// file sequence.c line 1743
static signed int readQual(struct _SeqFastq *sqp, struct _SeqIO *ifp);
// readSeq
// file sequence.c line 1163
static signed int readSeq(struct _SEQSEQ *sp, struct gzFile_s *fp, signed int *prompt);
// readSeqFast
// file sequence.c line 1229
static signed int readSeqFast(struct _SEQSEQ *sp, struct gzFile_s *fp, signed int *prompt, char *bufp, unsigned int minlen);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reallocDiffBlocks
// file diffstr.c line 598
static signed int reallocDiffBlocks(struct _DiffBlocks *p, signed int n_blks);
// reallocHashHitInfo
// file hashhit.c line 418
static signed int reallocHashHitInfo(struct _HashHitInfo *p, unsigned int newlen);
// reallocHitFilter
// file hashhit.c line 1925
static signed int reallocHitFilter(struct _HashHitFilter *hhfp, signed short int siz);
// reallocHitList
// file hashhit.c line 1233
static signed int reallocHitList(struct _HashHitList *hlp, unsigned long int newsiz);
// reallocQMask
// file segment.c line 674
static signed int reallocQMask(struct _SegQMask *p, unsigned int newsiz);
// reallocQmask
// file hashhit.c line 1250
static signed int reallocQmask(struct _HashHitList *hlp, unsigned int seqlen);
// reallocREPSTR
// file report.c line 417
static signed int reallocREPSTR(struct _REPSTR *rsp, unsigned long int newlen);
// reallocRsltSet
// file alignment.c line 1239
static signed int reallocRsltSet(struct _AliRsltSet *arp, signed short int newsiz);
// reallocScalarProfile
// file score.c line 398
static signed int reallocScalarProfile(struct _ScoreProfile *app, signed int newlen);
// reallocSeqBlocks
// file sequence.c line 744
static signed int reallocSeqBlocks(struct _SEQSEQ *sp, unsigned long int minsize);
// reallocSeqSet
// file sequence.c line 2236
static signed int reallocSeqSet(struct _SeqSet *ssp, signed long int num);
// reallocSeqSetName
// file sequence.c line 2257
static signed int reallocSeqSetName(struct _SeqSet *ssp, unsigned long int len);
// reallocSortArrays
// file segment.c line 1437
static signed int reallocSortArrays(struct _SegAliCands *sacp, unsigned int num);
// reallocView
// file diffstr.c line 133
static signed int reallocView(struct _DiffView *dvp, unsigned long int newsiz);
// reportAddMap
// file report.h line 154
signed int reportAddMap(struct _Report *rep, signed int pairid, signed int swatscor, signed short int mapscor, unsigned int q_start, unsigned int q_end, unsigned int s_start, unsigned int s_end, signed long int s_idx, const unsigned char *dstrp, signed int dfslen, signed int insiz, unsigned char mateflg, unsigned char pairflg);
// reportBlank
// file report.h line 145
void reportBlank(struct _Report *p);
// reportCreate
// file report.h line 135
struct _Report * reportCreate(signed int blksz);
// reportCreateWriter
// file report.h line 100
struct _ReportWriter * reportCreateWriter(signed int *errcode, const char * const filnam, const unsigned char outform, const unsigned char modiflg, const struct _SeqSet *ssp, const char *prognam, const char *progversion, char * const *cmdlin_argv, signed int cmdlin_narg);
// reportDelete
// file report.h line 141
void reportDelete(struct _Report *p);
// reportDeleteWriter
// file report.h line 123
void reportDeleteWriter(struct _ReportWriter *p);
// reportFixMultiplePrimary
// file report.h line 177
void reportFixMultiplePrimary(struct _Report *rep);
// reportGetWriterStream
// file report.h line 127
struct _IO_FILE * reportGetWriterStream(const struct _ReportWriter *p);
// reportNextPairID
// file report.h line 149
signed int reportNextPairID(struct _Report *rep);
// reportWrite
// file report.h line 184
signed int reportWrite(const struct _ReportWriter *wrp, const struct _SeqFastq *readp, const struct _SeqFastq *matep, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct _Report *rep);
// resetPairs
// file resultpairs.c line 717
static void resetPairs(struct _ResultPairs *p);
// resultCalcInsertSize
// file results.c line 938
unsigned char resultCalcInsertSize(signed int *isiz, unsigned char samspec, const struct _RESULT *ap, const struct _RESULT *bp);
// resultConvertProbabilityToMappingScore
// file results.c line 292
signed short int resultConvertProbabilityToMappingScore(double p);
// resultGetData
// file results.c line 875
signed int resultGetData(unsigned int *qs, unsigned int *qe, unsigned int *rs, unsigned int *re, signed long int *rx, signed int *swscor, unsigned short int *flag, const struct _RESULT *rp);
// resultGetFragmentNo
// file results.c line 905
signed short int resultGetFragmentNo(const struct _RESULT *rp);
// resultGetMapQualScore
// file results.c line 923
signed int resultGetMapQualScore(double *prob, unsigned short int *flag, const struct _RESULT * const rp);
// resultGetSWRank
// file results.c line 910
signed short int resultGetSWRank(const struct _RESULT *rp);
// resultGetStatusFlag
// file results.c line 915
unsigned short int resultGetStatusFlag(const struct _RESULT *rp);
// resultSetAdd2ndaryResultsToReport
// file results.c line 2249
signed int resultSetAdd2ndaryResultsToReport(struct _Report *rep, unsigned char mateflg, unsigned char rsltflg, const struct _ResultSet *rsp);
// resultSetAddFromAli
// file results.c line 1852
signed int resultSetAddFromAli(struct _ResultSet *rsp, const struct _AliRsltSet *arsp, unsigned int soffs, unsigned int qoffs, unsigned int qlen, signed long int seqidx, char is_reverse);
// resultSetAddMisMatch
// file results.c line 1944
signed int resultSetAddMisMatch(struct _ResultSet *rsp, const signed int *mmoffs, signed int mmnum, unsigned int qoffs, signed int len, unsigned int soffs, signed long int sidx, char is_rcpl, signed int swatscor);
// resultSetAddPairToReport
// file resultpairs.h line 152
signed int resultSetAddPairToReport(struct _Report *rep, const struct _InsHist *ihistp, const struct _ResultPairs *pairp, unsigned char pairflg, unsigned char rsltouflg, const struct _ResultSet *rsrp, const struct _ResultSet *rsmp);
// resultSetAddResultToReport
// file results.c line 2209
signed int resultSetAddResultToReport(struct _Report *rep, signed int pairid, signed short int mapscor, unsigned char mateflg, unsigned char pairflg, signed int isize, const struct _RESULT *rp, const struct _ResultSet *rsp);
// resultSetAddToReport
// file results.h line 518
signed int resultSetAddToReport(struct _Report *rep, unsigned char rsltflg, const struct _ResultSet *rsp);
// resultSetAlignmentStats
// file results.c line 1837
void resultSetAlignmentStats(struct _ResultSet *rsp, signed int n_ali_done, signed int n_ali_tot, signed short int max_depth, unsigned int n_hits_used, unsigned int n_hits_tot);
// resultSetAlignmentWasCurtailed
// file results.c line 1847
unsigned char resultSetAlignmentWasCurtailed(const struct _ResultSet *rsp);
// resultSetBlank
// file results.c line 2066
void resultSetBlank(struct _ResultSet *rsp);
// resultSetBlankPairs
// file resultpairs.c line 1103
void resultSetBlankPairs(struct _ResultPairs *p);
// resultSetCreate
// file results.c line 1781
struct _ResultSet * resultSetCreate(signed int blocksiz, signed int blocksiz_diffstr);
// resultSetCreateFilter
// file results.h line 621
struct _ResultFilter * resultSetCreateFilter(void);
// resultSetCreatePairs
// file resultpairs.c line 1073
struct _ResultPairs * resultSetCreatePairs(signed short int blksz);
// resultSetDelete
// file results.c line 1819
void resultSetDelete(struct _ResultSet *rsp);
// resultSetDeleteFilter
// file results.h line 625
void resultSetDeleteFilter(struct _ResultFilter *p);
// resultSetDeletePairs
// file resultpairs.c line 1094
void resultSetDeletePairs(struct _ResultPairs *p);
// resultSetDo
// file results.c line 2179
signed int resultSetDo(void *argp, signed int (*cbf)(signed int *, void *, const struct _RESULT *), const struct _ResultSet *rsp);
// resultSetDo::cbf$object
//
signed int cbf$object(signed int *, void *, const struct _RESULT *);
// resultSetFilterData
// file results.h line 629
void resultSetFilterData(struct _ResultFilter *p, signed int sw_abs, signed int sw_rel, double id_abs);
// resultSetFilterResults
// file results.c line 2592
signed int resultSetFilterResults(const struct _ResultSet *rsp, const struct _ResultFilter *rsfp, const struct _SeqFastq *sqp);
// resultSetFindPairs
// file resultpairs.c line 1116
signed int resultSetFindPairs(struct _ResultPairs *pairp, unsigned char pairflg, unsigned char pairlibcode, signed int dmin, signed int dmax, const struct _ResultSet *rsltAp, const struct _ResultSet *rsltBp);
// resultSetFindProperPairs
// file resultpairs.c line 1162
signed int resultSetFindProperPairs(struct _ResultPairs *pairp, signed int dist_lo, signed int dist_hi, signed int maxnum, signed int swscor_min, unsigned char pairlibcode, const struct _ResultSet *rsltAp, const struct _ResultSet *rsltBp);
// resultSetGetMapQualAsProb
// file results.c line 2427
double resultSetGetMapQualAsProb(double *pp2, signed short int *nn1, signed short int *nn2, const struct _ResultSet *rsp);
// resultSetGetMappingScore
// file results.c line 2416
signed int resultSetGetMappingScore(const struct _ResultSet *rsp, signed int *swscor);
// resultSetGetMaxSwat
// file results.c line 2163
signed int resultSetGetMaxSwat(const struct _ResultSet *rsp, signed int *maxswat_2nd);
// resultSetGetNumberOfPairs
// file resultpairs.c line 1216
signed int resultSetGetNumberOfPairs(signed int *n_proper, const struct _ResultPairs *pairp);
// resultSetGetNumberOfResultsInSegment
// file results.c line 2105
signed int resultSetGetNumberOfResultsInSegment(signed int segx, const struct _ResultSet *rsp);
// resultSetGetNumberOfSegments
// file results.c line 2081
signed int resultSetGetNumberOfSegments(signed short int *nres, signed short int *nseg, const struct _ResultSet *rsp);
// resultSetGetRankDepth
// file results.c line 2399
unsigned char resultSetGetRankDepth(const struct _ResultSet *rsp, signed short int *depth, signed short int *rank);
// resultSetGetResultByRank
// file results.c line 2146
signed int resultSetGetResultByRank(const struct _RESULT **rpp, signed int rank, const struct _ResultSet *rsp);
// resultSetGetResultBySWrank
// file results.c line 2169
struct _RESULT * resultSetGetResultBySWrank(const struct _ResultSet *rsp, signed short int rank);
// resultSetGetResultInSegment
// file results.c line 2118
signed int resultSetGetResultInSegment(const struct _RESULT **rpp, signed int segx, signed int resx, const struct _ResultSet *rsp);
// resultSetGetScorStats
// file results.c line 2374
signed int resultSetGetScorStats(const struct _ResultSet *rsp, signed int *scor_max, signed short int *num_max, signed int *scor_2ndmax, signed short int *num_2ndmax);
// resultSetGetTopResult
// file results.c line 2516
struct _RESULT * resultSetGetTopResult(unsigned char *is_multi, const unsigned char is_randsel, const struct _ResultSet *rsp);
// resultSetInferInsertSize
// file results.h line 572
signed int resultSetInferInsertSize(signed int *isiz, unsigned char samspec, const struct _ResultSet *rsrp, const struct _ResultSet *rsmp);
// resultSetPrintDebugInfo
// file results.c line 2348
void resultSetPrintDebugInfo(struct _IO_FILE *fp, const struct _ResultSet *rsp);
// resultSetSortAndAssignSequence
// file results.c line 2022
signed int resultSetSortAndAssignSequence(struct _ResultSet *rsp, struct _SeqFastq *sbufp, unsigned char search_split, const struct _SeqFastq *sqp, const struct _ScoreProfile *scpp, const struct _ScoreProfile *scpRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// resultSetTestOverlap
// file results.c line 2485
unsigned char resultSetTestOverlap(const struct _ResultSet *rs1p, signed int overlap_percent, const struct _ResultSet *rs2p);
// resultSetUpdateFromSegment
// file results.c line 2003
void resultSetUpdateFromSegment(struct _ResultSet *rsp, signed short int start_idx, signed short int end_idx, unsigned int soffs, unsigned int qoffs, char is_reverse);
// reverseComplementSeq
// file sequence.c line 1009
static signed int reverseComplementSeq(struct _SEQSEQ *sp, const struct _SeqCodec *codecp);
// reverseSeqInPlace
// file sequence.c line 1306
static signed int reverseSeqInPlace(struct _SEQSEQ *sp);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rmapBlank
// file rmap.c line 1620
void rmapBlank(struct RMap_ *rmp);
// rmapCreate
// file rmap.h line 83
struct RMap_ * rmapCreate(const struct _HashTable *htp, const struct _SeqCodec *codecp, const struct _SeqSet *ssp, const struct _ScoreMatrix *scormtxp, unsigned short int rmapflg);
// rmapDelete
// file rmap.h line 94
void rmapDelete(struct RMap_ *rmp);
// rmapGetData
// file rmap.h line 102
void rmapGetData(const struct _ResultSet **rslt_readp, const struct _ResultSet **rslt_matep, const struct _ResultPairs **pairp, struct _SeqFastq **sbufAp, struct _SeqFastq **sbufBp, const struct RMap_ *rmp);
// rmapPair
// file rmap.h line 175
signed int rmapPair(struct _ErrMsg *errmsgp, struct RMap_ *rmp, struct _SeqFastq *readp, struct _SeqFastq *matep, unsigned char *pairflgp, signed int d_min, signed int d_max, unsigned char pairlibcode, signed int ktuple_maxhit, unsigned int mincov_read, unsigned int mincov_mate, signed int min_swatscor, unsigned char min_basqval, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _ScoreMatrix *scormtxp, const struct _ResultFilter *rsfp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// rmapSingle
// file rmap.h line 127
signed int rmapSingle(struct _ErrMsg *errmsgp, struct RMap_ *rmp, struct _SeqFastq *readp, signed int ktuple_maxhit, unsigned int min_cover, signed int min_swatscor, signed int min_swatscor_below_max, unsigned char min_basqval, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _ScoreMatrix *scormtxp, const struct _ResultFilter *rsfp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// scaleALICPLX
// file alignment.c line 268
static signed int scaleALICPLX(signed int *adj_score, signed int orig_score, const struct _ALICPLX *cplxp);
// scorIsAboveFractMax
// file rmap.c line 178
static unsigned char scorIsAboveFractMax(signed int scor_read, signed int scor_mate, float fract, const struct _SeqFastq *readp, const struct _SeqFastq *matep);
// scoreCreateMatrix
// file score.h line 165
struct _ScoreMatrix * scoreCreateMatrix(const struct _SeqCodec *scp, const struct ScorePenalties_ *penp);
// scoreCreateProfile
// file score.h line 208
struct _ScoreProfile * scoreCreateProfile(signed int blocksize, const struct _SeqCodec *codep, unsigned char mod);
// scoreDeleteMatrix
// file score.h line 168
void scoreDeleteMatrix(struct _ScoreMatrix *amp);
// scoreDeleteProfile
// file score.h line 216
void scoreDeleteProfile(struct _ScoreProfile *app);
// scoreGetDefaults
// file score.c line 337
signed short int scoreGetDefaults(signed short int *mismatch, signed short int *gapinit, signed short int *gapext);
// scoreGetPenalties
// file score.c line 114
signed short int scoreGetPenalties(const struct ScorePenalties_ *p, signed short int *mismatch, signed short int *gapinit, signed short int *gapext);
// scoreGetProfile
// file score.h line 227
signed char * const * scoreGetProfile(signed short int *alphabetsiz, unsigned int *seqlen, signed char *gap_init, signed char *gap_ext, const struct _ScoreProfile *spp);
// scoreGetStripedProfile
// file score.c line 699
const void * scoreGetStripedProfile(signed short int *alphabetsiz, unsigned int *seqlen, unsigned short int *gap_init, unsigned short int *gap_ext, unsigned short int *bias, signed int *segsiz, char mod, const struct _ScoreProfile *spp);
// scoreMakeProfileFromSequence
// file score.h line 219
signed int scoreMakeProfileFromSequence(struct _ScoreProfile *app, const struct _SeqFastq *sqp, const struct _ScoreMatrix *amp);
// scoreMatrixCalcLambda
// file score.c line 252
double scoreMatrixCalcLambda(const struct _ScoreMatrix *smp);
// scoreMatrixGetAlphabetSize
// file score.c line 242
signed short int scoreMatrixGetAlphabetSize(const struct _ScoreMatrix *smp);
// scoreMatrixGetAvgSubstScores
// file score.c line 296
signed char scoreMatrixGetAvgSubstScores(signed char *matchscor, const struct _ScoreMatrix *smp);
// scoreMatrixGetMinSubstScore
// file score.c line 279
signed char scoreMatrixGetMinSubstScore(const struct _ScoreMatrix *smp);
// scorePairsSimple
// file resultpairs.c line 828
static signed int scorePairsSimple(const struct _RESULT **ap, const struct _RESULT **bp, signed short int *mapqA, signed short int *mapqB, unsigned char *mapflg, signed int *nmax, struct _MATEPAIR *mpr, unsigned char pairflg, const struct _InsHist *ihistp, unsigned char rsltouflg, const struct _ResultSet *rsrp, const struct _ResultSet *rsmp);
// scorePenaltiesCreate
// file score.h line 140
struct ScorePenalties_ * scorePenaltiesCreate(void);
// scorePenaltiesDelete
// file score.h line 143
void scorePenaltiesDelete(struct ScorePenalties_ *p);
// scorePrintMatrix
// file score.c line 345
signed int scorePrintMatrix(const struct _ScoreMatrix *amp, const struct _SeqCodec *scp);
// scoreProfileGetAvgPenalties
// file score.h line 241
signed short int scoreProfileGetAvgPenalties(signed short int *mismatch_avg, signed short int *gap_init, signed short int *gap_ext, const struct _ScoreProfile *spp);
// scoreRMAPCAND
// file rmap.c line 588
static signed int scoreRMAPCAND(struct RMAPCAND_ **csr, signed int *max1scor, signed int *max2scor, struct _SeqFastq *sqbufp, struct _AliBuffer *alibufp, unsigned short int rmapflag, unsigned char nskip, const struct _ScoreProfile *profp, const struct _ScoreProfile *profRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct _SegAliCands *sacp);
// scoreSetPenalty
// file score.h line 146
signed int scoreSetPenalty(struct ScorePenalties_ *p, signed short int typ, signed short int penalty);
// scrollDIFFSTRStartEnd
// file diffstr.c line 413
static signed int scrollDIFFSTRStartEnd(signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof, unsigned char *count_start, unsigned char *count_end, unsigned char *typ_start, signed int *idx_start, signed int *idx_end, signed int start_unprof_target, signed int end_unprof_target, const unsigned char *diffstrp);
// scrollDiffStr
// file diffstr.c line 369
static signed int scrollDiffStr(unsigned char *dfsp, signed int pos_uprof_target, unsigned char isEnd, signed int *pos_uprof, signed int *pos_prof, signed int *dfs_offs);
// scrollToHeaderLine
// file sequence.c line 192
static signed int scrollToHeaderLine(struct gzFile_s *fp, signed int *prompt, char *bufp);
// segAliCandsAdd
// file segment.c line 1559
signed int segAliCandsAdd(struct _SegAliCands *sacp, const struct _SegLst *sglp);
// segAliCandsAddFast
// file segment.c line 1530
signed int segAliCandsAddFast(struct _SegAliCands *sacp, struct _SegQMask *qmp, const struct _SegLst *sglp, unsigned int mincover, signed int seqidx);
// segAliCandsAddNoIndel
// file segment.c line 1599
signed int segAliCandsAddNoIndel(struct _SegAliCands *sacp, const struct _SegLst *sglp);
// segAliCandsBlank
// file segment.h line 156
void segAliCandsBlank(struct _SegAliCands *sacp);
// segAliCandsCalcSegmentOffsets
// file segment.h line 265
signed int segAliCandsCalcSegmentOffsets(unsigned int *qs, unsigned int *qe, unsigned long int *rs, unsigned long int *re, signed int *band_l, signed int *band_r, unsigned int *qs_directmatch, signed int *ro_directmatch, signed long int *seqidx, unsigned char *bitflags, unsigned int *cover, signed short int edgelen, unsigned int qlen, const struct _SeqSet *ssp, unsigned int scidx, const struct _SegAliCands *sacp);
// segAliCandsCreate
// file segment.h line 150
struct _SegAliCands * segAliCandsCreate(signed int blocksiz);
// segAliCandsDelete
// file segment.h line 153
void segAliCandsDelete(struct _SegAliCands *sacp);
// segAliCandsGetNumberOfSegments
// file segment.h line 233
unsigned int segAliCandsGetNumberOfSegments(const struct _SegAliCands *sacp, unsigned int *max_cover, unsigned int *max2nd_cover, unsigned int *cover_deficitF, unsigned int *cover_deficitR, unsigned int *n_mincover);
// segAliCandsGetSegment
// file segment.c line 1787
const struct _SEGCAND * segAliCandsGetSegment(const struct _SegAliCands *sacp, unsigned int idx);
// segAliCandsGetSegmentData
// file segment.c line 1844
signed int segAliCandsGetSegmentData(unsigned int *qs, unsigned int *qe, unsigned int *rs, unsigned int *re, unsigned int scidx, const struct _SegAliCands *sacp);
// segAliCandsPrint
// file segment.c line 1792
void segAliCandsPrint(struct _IO_FILE *fp, unsigned int max_depth, const struct _SegAliCands *sacp);
// segAliCandsPrintRaw
// file segment.c line 1805
void segAliCandsPrintRaw(struct _IO_FILE *fp, signed short int max_depth, const struct _SegAliCands *sacp);
// segAliCandsPrintSegment
// file segment.c line 1832
signed int segAliCandsPrintSegment(struct _IO_FILE *fp, unsigned int scidx, const struct _SegAliCands *sacp);
// segAliCandsStats
// file segment.h line 189
signed int segAliCandsStats(struct _SegAliCands *sacp, unsigned int min_cover_below_max, const struct _HashHitInfo *hhiFp, const struct _HashHitInfo *hhiRp, unsigned int target_depth, unsigned int max_depth, unsigned char is_sensitive);
// segLstAddHits
// file segment.c line 812
signed int segLstAddHits(struct _SegLst *sglp, unsigned int min_ktup, const struct _HashHitList *hhlp);
// segLstBlank
// file segment.c line 752
void segLstBlank(struct _SegLst *sp);
// segLstCreate
// file segment.c line 721
struct _SegLst * segLstCreate(signed int blocksiz);
// segLstDelete
// file segment.c line 742
void segLstDelete(struct _SegLst *sp);
// segLstFetchSeed
// file segment.c line 875
signed int segLstFetchSeed(unsigned int *q_offs, unsigned int *s_offs, unsigned int idx, const struct _SegLst *sp);
// segLstFillHits
// file segment.c line 763
signed int segLstFillHits(struct _SegLst *sglp, unsigned int min_ktup, const struct _HashHitList *hhlp);
// segLstGetStats
// file segment.c line 866
unsigned char segLstGetStats(const struct _SegLst *sp, unsigned int *nhreg, unsigned int *nseed, unsigned int *nseg);
// segLstPrintSeeds
// file segment.c line 896
void segLstPrintSeeds(struct _IO_FILE *fp, const struct _SegLst *sglp);
// segQMaskCreate
// file segment.h line 83
struct _SegQMask * segQMaskCreate(signed int qblksz);
// segQMaskDelete
// file segment.h line 86
void segQMaskDelete(struct _SegQMask *sqmp);
// selectHashTyp
// file smalt.c line 268
static signed int selectHashTyp(unsigned char *typ, unsigned char *nbits_key, unsigned char *nbits_perf, unsigned char wordlen, unsigned char nskip, const struct _SeqSet *ssp);
// sem_init
// file /usr/include/semaphore.h line 36
extern signed int sem_init(union anonymous$1 *, signed int, unsigned int);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous$1 *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous$1 *);
// seqCodecCreate
// file sequence.h line 137
struct _SeqCodec * seqCodecCreate(void);
// seqCodecCreateFromAlphabet
// file sequence.c line 353
struct _SeqCodec * seqCodecCreateFromAlphabet(const char *alphabet, unsigned char code_unknown);
// seqCodecDecodeString
// file sequence.c line 431
void seqCodecDecodeString(char *cp, const struct _SeqCodec *codp);
// seqCodecDelete
// file sequence.h line 150
void seqCodecDelete(struct _SeqCodec *codp);
// seqCodecEncodeString
// file sequence.c line 424
void seqCodecEncodeString(char *cp, const struct _SeqCodec *codp);
// seqCodecFindBaseClass
// file sequence.h line 168
char seqCodecFindBaseClass(char c, const struct _SeqCodec *codecp);
// seqCodecGetAlphabet
// file sequence.h line 153
const char * seqCodecGetAlphabet(const struct _SeqCodec *codp, signed short int *length);
// seqCodecGetDecoder
// file sequence.c line 417
const char * seqCodecGetDecoder(const struct _SeqCodec *codp, signed short int *size);
// seqCodecGetEncoder
// file sequence.c line 410
const unsigned char * seqCodecGetEncoder(const struct _SeqCodec *codp, signed short int *size);
// seqCodecType
// file sequence.h line 175
char seqCodecType(const struct _SeqCodec *codecp);
// seqFastqAppendSegment
// file sequence.h line 266
signed int seqFastqAppendSegment(struct _SeqFastq *top, const struct _SeqFastq *fromp, unsigned int start, unsigned int length, char reverse, const struct _SeqCodec *codep);
// seqFastqBlank
// file sequence.h line 232
void seqFastqBlank(struct _SeqFastq *p);
// seqFastqCheck
// file sequence.h line 245
signed int seqFastqCheck(const struct _SeqFastq *sqp);
// seqFastqCompress
// file sequence.c line 2155
signed int seqFastqCompress(struct _SeqFastq *sqp);
// seqFastqCreate
// file sequence.h line 223
struct _SeqFastq * seqFastqCreate(signed int blocksize, char type);
// seqFastqCurtailSeqName
// file sequence.c line 2135
void seqFastqCurtailSeqName(struct _SeqFastq *sfqp);
// seqFastqDecode
// file sequence.h line 350
signed int seqFastqDecode(struct _SeqFastq *sqp, const struct _SeqCodec *codep);
// seqFastqDecodeAsStandardNt
// file sequence.c line 2214
signed int seqFastqDecodeAsStandardNt(struct _SeqFastq *dep, const struct _SeqFastq *sqp, unsigned int start, unsigned int length, const struct _SeqCodec *codep, char as_rcp);
// seqFastqDelete
// file sequence.h line 229
void seqFastqDelete(struct _SeqFastq *sqp);
// seqFastqEncode
// file sequence.h line 347
signed int seqFastqEncode(struct _SeqFastq *sqp, const struct _SeqCodec *codep);
// seqFastqFind
// file sequence.c line 1992
signed int seqFastqFind(struct _SeqFastq *sqp, const char *nam, struct _SeqIO *ifp);
// seqFastqFreeUnusedMem
// file sequence.c line 1815
void seqFastqFreeUnusedMem(struct _SeqFastq *sqp);
// seqFastqGetConstQualityFactors
// file sequence.h line 326
const char * seqFastqGetConstQualityFactors(const struct _SeqFastq *sfqp, unsigned int *length, char *code);
// seqFastqGetConstSequence
// file sequence.h line 316
const char * seqFastqGetConstSequence(const struct _SeqFastq *sfqp, unsigned int *length, char *codtyp);
// seqFastqGetQualName
// file sequence.c line 2140
const char * seqFastqGetQualName(const struct _SeqFastq *sfqp);
// seqFastqGetQualityFactors
// file sequence.c line 2117
char * seqFastqGetQualityFactors(struct _SeqFastq *sfqp, unsigned int *length, char *code);
// seqFastqGetSeqName
// file sequence.h line 336
const char * seqFastqGetSeqName(const struct _SeqFastq *sfqp);
// seqFastqGetSequence
// file sequence.h line 323
char * seqFastqGetSequence(struct _SeqFastq *sfqp, unsigned int *length, char *codtyp);
// seqFastqRead
// file sequence.h line 285
signed int seqFastqRead(struct _SeqFastq *sqp, struct _SeqIO *ifp);
// seqFastqReadCompressedBinary
// file sequence.c line 2190
signed int seqFastqReadCompressedBinary(struct _SeqFastq *sqp, struct _IO_FILE *fp, const char *label);
// seqFastqReadCompressedBinaryOfKnownLength
// file sequence.c line 2201
signed int seqFastqReadCompressedBinaryOfKnownLength(struct _SeqFastq *sqp, struct _IO_FILE *fp, unsigned int len, const char *label);
// seqFastqReverse
// file sequence.c line 1952
signed int seqFastqReverse(struct _SeqFastq *sqp, const struct _SeqCodec *codecp);
// seqFastqSetAscii
// file sequence.h line 248
signed int seqFastqSetAscii(struct _SeqFastq *sqp, const char *name, const char *seqp, const char *name_qual, const char *qualp);
// seqFastqSetQual
// file sequence.h line 260
signed int seqFastqSetQual(struct _SeqFastq *sqp, const char qval);
// seqFastqSetType
// file sequence.c line 1836
signed int seqFastqSetType(struct _SeqFastq *sqp, char type);
// seqFastqUncompress
// file sequence.c line 2162
signed int seqFastqUncompress(struct _SeqFastq *ucp, const struct _SeqFastq *sqp, unsigned int start, unsigned int length, const struct _SeqCodec *codep, char as_rcp);
// seqFastqWrite
// file sequence.c line 2023
signed int seqFastqWrite(struct _SeqIO *ofp, const struct _SeqFastq *sqp, signed short int linewidth);
// seqFastqWriteCompressedToFile
// file sequence.c line 2067
signed int seqFastqWriteCompressedToFile(struct _IO_FILE *fp, const struct _SeqFastq *sqp);
// seqIOCheckReads
// file sequence.h line 197
signed int seqIOCheckReads(struct _ErrMsg *errmsgp, struct _SeqFastq *sqbufp, struct _SeqIO *sfp, struct _SeqFastq *sqbufBp, struct _SeqIO *sfBp, signed long int *seqnum, unsigned int *maxseqlen, unsigned int *maxnamlen);
// seqIOReset
// file sequence.h line 193
signed int seqIOReset(struct _SeqIO *p);
// seqIOclose
// file sequence.h line 194
signed int seqIOclose(struct _SeqIO *p);
// seqIOopen
// file sequence.h line 183
struct _SeqIO * seqIOopen(signed int *errcode, const char *filnam, char mode, unsigned long int buffsize);
// seqIOstatus
// file sequence.h line 195
signed int seqIOstatus(struct _SeqIO *p);
// seqSetAddFromFastqFile
// file sequence.h line 450
signed int seqSetAddFromFastqFile(struct _ErrMsg *errmsg, struct _SeqSet *ssp, struct _SeqFastq *sqbufp, const struct _SeqCodec *codecp, const char *filnam, char verbose);
// seqSetAddSequence
// file sequence.c line 2330
signed int seqSetAddSequence(struct _SeqSet *ssp, const struct _SeqFastq *sqp);
// seqSetBlank
// file sequence.c line 2323
void seqSetBlank(struct _SeqSet *ssp);
// seqSetCompress
// file sequence.c line 2436
signed int seqSetCompress(struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// seqSetCreate
// file sequence.h line 412
struct _SeqSet * seqSetCreate(signed int blocksiz, unsigned char flags);
// seqSetDelete
// file sequence.h line 420
void seqSetDelete(struct _SeqSet *ssp);
// seqSetFetchSegment
// file sequence.h line 463
signed int seqSetFetchSegment(struct _SeqFastq *sqp, unsigned long int *offs_start, unsigned long int *offs_end, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// seqSetFetchSegmentBySequence
// file sequence.h line 482
signed int seqSetFetchSegmentBySequence(struct _SeqFastq *sqp, signed long int seqidx, unsigned int offs, unsigned int len, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// seqSetGetIndexAndOffset
// file sequence.h line 498
signed int seqSetGetIndexAndOffset(signed long int *seqidx, unsigned int *seqoffs, unsigned long int offs, const struct _SeqSet *ssp);
// seqSetGetOffsets
// file sequence.h line 456
signed long int seqSetGetOffsets(const struct _SeqSet *ssp, const unsigned long int **soffs);
// seqSetGetSeqDatByIndex
// file sequence.h line 509
unsigned int seqSetGetSeqDatByIndex(unsigned long int *offs, const char **name, signed long int seqidx, const struct _SeqSet *ssp);
// seqSetGetSeqNumAndTotLen
// file sequence.h line 519
signed long int seqSetGetSeqNumAndTotLen(unsigned long int *totseqlen, const struct _SeqSet *ssp);
// seqSetReadBinFil
// file sequence.h line 444
struct _SeqSet * seqSetReadBinFil(signed int *errcode, const char *filnam);
// seqSetWriteBinFil
// file sequence.h line 438
signed int seqSetWriteBinFil(const struct _SeqSet *ssp, const char *filnam);
// setInSampleIntervalInput
// file smalt.c line 725
static void setInSampleIntervalInput(struct _SmaltInput *inargp, const struct _InsSample *isamp);
// setKeyPos
// file hashidx.c line 197
static signed int setKeyPos(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr);
// setMemALITRACK
// file alignment.c line 454
static signed int setMemALITRACK(struct _ALITRACK *btrkp, struct _ALIBAND *bandp);
// setScoreMatrix
// file score.c line 138
static signed int setScoreMatrix(struct _ScoreMatrix *amp, const struct _SeqCodec *scp, const struct ScorePenalties_ *penp);
// setSeq
// file sequence.c line 780
static signed int setSeq(struct _SEQSEQ *sp, const char *cp);
// setWordPos
// file hashidx.c line 295
static signed int setWordPos(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr);
// setupFineHashTable
// file rmap.c line 495
static signed int setupFineHashTable(struct _HashTable *htfinep, struct _SeqFastq *sqbfp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivr, const struct _HashTable *htp, const struct _SeqCodec *codecp);
// setupInterValFromResultSet
// file rmap.c line 354
static signed int setupInterValFromResultSet(struct V_IVAL_ *ivr, signed int dmin, signed int dmax, const struct _SeqFastq *readp, const struct _SeqFastq *matep, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _ResultSet *rsp);
// setupOFFSIVALcbf
// file resultpairs.c line 195
static signed int setupOFFSIVALcbf(signed int *errcode, void *argp, const struct _RESULT *rp);
// signOffARGBUFF
// file threads.c line 395
static signed int signOffARGBUFF(struct _ARGBUFF *fifop);
// signOnARGBUFF
// file threads.c line 381
static signed int signOnARGBUFF(struct _ARGBUFF *fifop);
// smoothGauss
// file insert.c line 253
static signed int smoothGauss(signed int *targetp, double *Kp, signed int bw, const signed int *sourcep, signed int n);
// sort2UINTarraysByQuickSort
// file sort.c line 233
signed int sort2UINTarraysByQuickSort(signed int n, unsigned int *arr, unsigned int *brr);
// sortAndPrune
// file results.c line 759
static signed int sortAndPrune(struct _ResultSet *rsp);
// sortBySegmentAndSWscor
// file results.c line 669
static signed int sortBySegmentAndSWscor(struct _ResultSet *rsp);
// sortMultiKey
// file sort.c line 595
void sortMultiKey(const char **x, signed int num, signed int maxdepth);
// sortSufficesByMultiKeyQuickSort
// file sort.c line 607
void sortSufficesByMultiKeyQuickSort(const char *hstrp, unsigned int *sfxidxp, unsigned int nsfx, signed short int startdepth, signed short int maxdepth);
// sortUINT32arrayByQuickSort
// file sort.c line 333
signed int sortUINT32arrayByQuickSort(signed int n, unsigned int *arr);
// sortUINT64andUINT32ArraysByQuickSort
// file sort.h line 50
signed int sortUINT64andUINT32ArraysByQuickSort(signed int n, unsigned long int *arr, unsigned int *brr);
// sortUINT64arrayByQuickSort
// file sort.c line 415
signed int sortUINT64arrayByQuickSort(signed int n, unsigned long int *arr);
// sort_int32_t_quicksort
// file insert.c line 134
static signed int sort_int32_t_quicksort(struct V_int32_t_ *p);
// splitMultiSpan
// file results.c line 1472
static signed int splitMultiSpan(struct _RESULT **resr, const unsigned int residx, struct _DiffStr *diffstrbufp, struct _DiffStr *diffstrp, struct _SeqFastq *sqbufp, signed long int so, signed long int eo, const struct _ScoreProfile *scpp, const struct _ScoreProfile *scpRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sprintfDiffStrPlain
// file diffstr.c line 286
static signed int sprintfDiffStrPlain(char *sp, const unsigned char *dstrp);
// sprintfDiffStrRaw
// file diffstr.c line 262
static signed int sprintfDiffStrRaw(char *sp, const unsigned char *dstrp);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// srand48
// file /usr/include/stdlib.h line 403
extern void srand48(signed long int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strMessageLevel
// file elib.c line 268
static const char * strMessageLevel(unsigned char level);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// sumQualOverMisMatch
// file results.c line 232
static signed int sumQualOverMisMatch(signed int *qualsum_ali, unsigned char with_nonali, const char *qualstrp, const unsigned int slen, unsigned int pos_start, unsigned int pos_end, const unsigned char *dstrp);
// swSIMDAlignStriped
// file swsimd.h line 47
signed int swSIMDAlignStriped(signed int *maxscor, const struct _AliBuffer *abp, const struct _ScoreProfile *profp, const char *unprofiled_seqp, signed int unprofiled_seqlen);
// testProperPair
// file resultpairs.c line 135
static unsigned char testProperPair(signed int isize, unsigned char iflag, signed int dmin, signed int dmax, unsigned char libcode);
// threadsCleanup
// file threads.h line 125
void threadsCleanup(void);
// threadsGetMem
// file threads.h line 142
void * threadsGetMem(unsigned char task_typ);
// threadsInit
// file threads.h line 93
signed int threadsInit(void);
// threadsRun
// file threads.h line 137
signed int threadsRun(void);
// threadsSetTask
// file threads.h line 97
signed int threadsSetTask(unsigned char task_typ, signed short int n_threads, signed int (*initf)(void *, const void *, signed short int), const void *initargp, signed int (*procf)(struct _ErrMsg *, void *, void *), signed int (*cleanf)(struct _ErrMsg *, void *), signed int (*checkf)(const void *, const void *), signed int (*cmpf)(const void *, const void *), unsigned long int argsz);
// threadsSetTask::checkf$object
//
signed int checkf$object(const void *, const void *);
// threadsSetTask::cleanf$object
//
signed int cleanf$object(struct _ErrMsg *, void *);
// threadsSetTask::cmpf$object
//
signed int cmpf$object(const void *, const void *);
// threadsSetTask::initf$object
//
signed int initf$object(void *, const void *, signed short int);
// threadsSetTask::procf$object
//
signed int procf$object(struct _ErrMsg *, void *, void *);
// threadsSetUp
// file threads.h line 116
signed int threadsSetUp(signed int n_buffarg_factor);
// threadsStart
// file threads.c line 945
signed int threadsStart(void);
// threadsStop
// file threads.c line 968
void threadsStop(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// tprocf
// file threads.c line 548
static void * tprocf(void *p);
// transferParamFromSegLst
// file segment.c line 1457
static signed int transferParamFromSegLst(struct _SegAliCands *sacp, const struct _SegLst *sglp);
// uncompressSeq
// file sequence.c line 1499
static signed int uncompressSeq(struct _SEQSEQ *ucp, unsigned int *tcpos, unsigned char *ntc, const struct _SEQSEQ *sp, unsigned long int start, unsigned long int length, const struct _SeqCodec *codep);
// updateCandBoundaries
// file segment.c line 1061
static signed int updateCandBoundaries(struct _SEGCAND *sgcp, const struct _SEGMENT *segmp, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip);
// updateInsertBoundariesFromSample
// file smalt.c line 417
static void updateInsertBoundariesFromSample(struct _SmaltMapConst *macop, const struct _InsHist *ihp);
// writeCigarToFile
// file diffstr.c line 159
static inline signed int writeCigarToFile(void *top, unsigned char cigtyp, char typc, signed int ctr);
// writeCigarToStr
// file diffstr.c line 167
static inline signed int writeCigarToStr(void *top, unsigned char cigtyp, char typc, signed int ctr);
// writeCompressedSeq
// file sequence.c line 1426
static signed int writeCompressedSeq(struct _IO_FILE *fp, struct _SEQSEQ *sp);
// writeDiffStrCIGAR
// file diffstr.c line 298
static signed int writeDiffStrCIGAR(void * const top, signed int *nchar, unsigned char cgt, const unsigned char *diffstr, signed int clip_start, signed int clip_end, signed int (*writerp)(void *, unsigned char, char, signed int));
// writeDiffStrCIGAR::writerp$object
//
signed int writerp$object(void *, unsigned char, char, signed int);
// writeHeader
// file filio.c line 55
static signed int writeHeader(unsigned int filsiz, unsigned char filtyp, unsigned int version, unsigned int headsiz, struct _IO_FILE *fp);
// writeREPALI
// file report.c line 1083
static signed int writeREPALI(struct _IO_FILE *fp, struct _BamBam_BamWriter *bamwriterp, struct _DiffView *dvp, const struct _REPALI *rp, const struct _DiffStr *rdfsp, const struct _SeqFastq *q_sqp, const struct _SeqSet *ssp, const char *namext, unsigned char outform, unsigned char oumodiflg, struct _DiffBlocks *dfblkp, unsigned char pairflg, signed int isize, const struct _REPALI *rsltmp, struct _SeqFastq *sqbufp, struct _REPNAMBUF *nambufp, const struct _SeqCodec *codecp);
// writeREPALIbam
// file report.c line 917
static signed int writeREPALIbam(struct _BamBam_BamWriter *bamwriterp, struct _SeqFastq *sqbufp, struct _REPSTR *readnamp, struct _DiffView *dvp, signed short int mapscor, const struct _REPALI *rrp, const unsigned char *diffstr, const struct _SeqFastq *q_sqp, const struct _REPALI *rmp, signed int isize, unsigned char pairflg, unsigned char oumodiflg, const struct _SeqCodec *codecp);
// writeReportForRead
// file report.c line 1486
static signed int writeReportForRead(const struct _ReportWriter *wrp, const struct _REPALI *ralip, const struct _SeqFastq *readp, const struct _DiffStr *rdfsp, const struct _REPALI *malip, signed int isize, unsigned char pairflg, const struct _SeqSet *ssp, const struct _SeqCodec *codecp);
// writeSAMHeaderf
// file report.c line 1266
static signed int writeSAMHeaderf(struct _IO_FILE *oufp, const struct _SeqSet *ssp, const char *prognam, const char *progversion, signed int narg, char * const *argv);

union anonymous$1
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct EString_
{
  // strp
  char *strp;
  // len
  unsigned long int len;
  // allocsz
  unsigned long int allocsz;
  // blksz
  signed int blksz;
};

struct GETMATEPAIRARG_
{
  // max_rankA
  signed short int max_rankA;
  // max_rankB
  signed short int max_rankB;
  // pairflg
  unsigned char pairflg;
  // pairlibcode
  unsigned char pairlibcode;
  // ap
  const struct _RESULT *ap;
  // rsltAp
  const struct _ResultSet *rsltAp;
  // rsltBp
  const struct _ResultSet *rsltBp;
  // pairp
  struct _ResultPairs *pairp;
};

struct GETPROPERMATEPAIRARG_
{
  // ivalx
  signed short int ivalx;
  // max_rank
  signed short int max_rank;
  // maxnum
  signed int maxnum;
  // swscor_min
  signed int swscor_min;
  // pairlibcode
  unsigned char pairlibcode;
  // oivr
  const struct _OFFSIVAL *oivr;
  // pairp
  struct _ResultPairs *pairp;
};

struct OPTDOC_
{
  // ochr
  char ochr;
  // otyp
  unsigned char otyp;
  // vnam
  const char *vnam;
  // sdesc
  const char *sdesc;
  // ldesc
  const char *ldesc;
};

struct RMAPBUFF_
{
  // sqbfp
  struct _SeqFastq *sqbfp;
  // qbfp
  struct _SeqFastq *qbfp;
  // hhlp
  struct _HashHitList *hhlp;
  // sglp
  struct _SegLst *sglp;
  // sacp
  struct _SegAliCands *sacp;
  // candr
  struct RMAPCAND_ *candr;
  // alibufp
  struct _AliBuffer *alibufp;
  // alirsltp
  struct _AliRsltSet *alirsltp;
  // qmp
  struct _SegQMask *qmp;
};

struct RMAPCAND_
{
  // flags
  unsigned short int flags;
  // qe
  unsigned int qe;
  // qs
  unsigned int qs;
  // rs
  unsigned long int rs;
  // re
  unsigned long int re;
  // band_l
  signed int band_l;
  // band_r
  signed int band_r;
  // sqidx
  signed long int sqidx;
  // dqo
  unsigned int dqo;
  // dro
  signed int dro;
  // swscor
  signed int swscor;
};

struct RMAPINFO_
{
  // hhiFp
  struct _HashHitInfo *hhiFp;
  // hhiRp
  struct _HashHitInfo *hhiRp;
};

struct RMAPPROF_
{
  // readRCp
  struct _SeqFastq *readRCp;
  // scorprofp
  struct _ScoreProfile *scorprofp;
  // scorprofRCp
  struct _ScoreProfile *scorprofRCp;
};

struct RMap_
{
  // bfp
  struct RMAPBUFF_ *bfp;
  // prp
  struct RMAPPROF_ *prp;
  // pmp
  struct RMAPPROF_ *pmp;
  // mrp
  struct RMAPINFO_ *mrp;
  // mmp
  struct RMAPINFO_ *mmp;
  // mr2p
  struct RMAPINFO_ *mr2p;
  // mm2p
  struct RMAPINFO_ *mm2p;
  // ivr
  struct V_IVAL_ *ivr;
  // rsrp
  struct _ResultSet *rsrp;
  // rsmp
  struct _ResultSet *rsmp;
  // pairp
  struct _ResultPairs *pairp;
  // mflyp
  struct RMAPINFO_ *mflyp;
  // htflyp
  struct _HashTable *htflyp;
};

struct SETUPOFFSIVALARG_
{
  // max_rank
  signed short int max_rank;
  // dmin
  unsigned int dmin;
  // dmax
  unsigned int dmax;
  // oivr
  struct _OFFSIVAL *oivr;
};

struct ScorePenalties_
{
  // penalty
  signed char penalty[4l];
};

struct SmaltArgBlock_
{
  // argno
  signed short int argno;
  // n_iobf
  signed short int n_iobf;
  // n_alloc
  signed short int n_alloc;
  // iobfp
  struct _SmaltIOBuffArg *iobfp;
};

struct TASKDOC_
{
  // synopsis
  const char *synopsis;
  // description
  const char *description;
  // optdoc
  const struct OPTDOC_ *optdoc;
};

struct VARLST_
{
  // varnam
  const char *varnam;
  // typ
  unsigned char typ;
  // val
  signed char val;
  // max
  signed char max;
  // min
  signed char min;
};

struct V_IVAL_
{
  // n
  unsigned long int n;
  // n_alloc
  unsigned long int n_alloc;
  // n_blksz
  unsigned long int n_blksz;
  // vp
  struct _IVAL *vp;
};

struct V_int32_t_
{
  // n
  unsigned long int n;
  // n_alloc
  unsigned long int n_alloc;
  // n_blksz
  unsigned long int n_blksz;
  // vp
  signed int *vp;
};

struct _ALIBAND
{
  // band_width
  signed int band_width;
  // l_edge_orig
  signed int l_edge_orig;
  // r_edge_orig
  signed int r_edge_orig;
  // l_edge
  signed int l_edge;
  // r_edge
  signed int r_edge;
  // s_left_orig
  signed int s_left_orig;
  // s_left
  signed int s_left;
  // s_len
  signed int s_len;
  // s_totlen
  signed int s_totlen;
  // q_left_orig
  signed int q_left_orig;
  // q_left
  signed int q_left;
  // q_len
  signed int q_len;
  // q_totlen
  signed int q_totlen;
};

struct _ALICPLX
{
  // countp
  signed int *countp;
  // n_types
  signed short int n_types;
  // lambda
  double lambda;
};

struct _DiffStr
{
  // dstrp
  unsigned char *dstrp;
  // len
  signed int len;
  // n_alloc
  signed int n_alloc;
  // blksz
  signed int blksz;
};

struct _ALIMETA
{
  // prof_start
  signed int prof_start;
  // prof_end
  signed int prof_end;
  // nonprof_start
  signed int nonprof_start;
  // nonprof_end
  signed int nonprof_end;
  // score
  signed int score;
  // dfs
  struct _DiffStr dfs;
};

struct _ALIRESULT
{
  // score
  signed int score;
  // qs
  signed int qs;
  // qe
  signed int qe;
  // rs
  signed int rs;
  // re
  signed int re;
  // diffstr
  struct _DiffStr diffstr;
};

struct _ALITRACK
{
  // max_i
  signed int max_i;
  // max_j
  signed int max_j;
  // max_scor
  signed int max_scor;
  // bdp
  unsigned char *bdp;
  // blksz
  unsigned long int blksz;
  // n_alloc
  unsigned long int n_alloc;
  // n_alloc_thresh
  unsigned long int n_alloc_thresh;
};

struct _ARGBUFF
{
  // nThreadsPushing
  signed int nThreadsPushing;
  // firstp
  struct _BUFFARG *firstp;
  // lastp
  struct _BUFFARG *lastp;
  // sema
  union anonymous$1 sema;
  // mutex
  union anonymous mutex;
  // buftyp
  unsigned char buftyp;
};

struct _AliBuffer
{
  // qlen_max
  signed int qlen_max;
  // datap
  unsigned char *datap;
  // baseHp
  signed int *baseHp;
  // baseEp
  signed int *baseEp;
  // allocsiz
  unsigned long int allocsiz;
  // blocksiz
  signed int blocksiz;
  // H1v
  __gcc_v2di *H1v;
  // H2v
  __gcc_v2di *H2v;
  // Ev
  __gcc_v2di *Ev;
};

struct _AliRsltSet
{
  // rsp
  struct _ALIRESULT *rsp;
  // nres
  signed short int nres;
  // n_alloc
  signed short int n_alloc;
  // blksz
  signed short int blksz;
  // dfblksz
  signed short int dfblksz;
  // cplxp
  struct _ALICPLX *cplxp;
  // meta
  struct _ALIMETA meta;
  // track
  struct _ALITRACK track;
};

struct _BLOCK
{
  // unprof_start
  signed int unprof_start;
  // prof_start
  signed int prof_start;
  // len
  signed int len;
};

struct _BUFFARG
{
  // argno
  signed short int argno;
  // thisp
  void *thisp;
  // nextp
  struct _BUFFARG *nextp;
};

struct _BamBam_AlignmentPut
{
  // charbuffer
  struct _BamBam_CharBuffer *charbuffer;
  // calignment
  struct _BamBam_BamSingleAlignment *calignment;
};

struct _BamBam_BamHeaderInfo
{
  // version
  char *version;
  // sortorder
  char *sortorder;
  // plaintext
  char *plaintext;
  // chrlist
  struct _BamBam_List *chrlist;
  // cb
  struct _BamBam_CharBuffer *cb;
};

struct _BamBam_BamSingleAlignment
{
  // data
  unsigned char *data;
  // dataav
  unsigned int dataav;
  // dataused
  unsigned int dataused;
  // query
  char *query;
  // queryspace
  signed int queryspace;
  // qual
  char *qual;
  // qualspace
  signed int qualspace;
  // cigar
  char *cigar;
  // cigarspace
  signed int cigarspace;
  // valid
  enum _bambamc_alignment_validity valid;
  // auxbuffer
  struct _BamBam_CharBuffer *auxbuffer;
};

struct _BamBam_BamWriter
{
  // aput
  struct _BamBam_AlignmentPut *aput;
  // bgzf
  struct _BamBam_BgzfCompressor *bgzf;
};

struct _BamBam_BgzfCompressor
{
  // file
  struct _IO_FILE *file;
  // closefile
  struct _IO_FILE *closefile;
  // level
  signed int level;
  // inbuffer
  unsigned char *inbuffer;
  // inbufferfill
  unsigned int inbufferfill;
  // outbuffer
  unsigned char *outbuffer;
};

struct _BamBam_CharBuffer
{
  // buffer
  unsigned char *buffer;
  // buffersize
  unsigned long int buffersize;
  // bufferfill
  unsigned long int bufferfill;
};

struct _BamBam_FastQRead
{
  // name
  const char *name;
  // namelength
  unsigned int namelength;
  // seq
  const char *seq;
  // seqlength
  unsigned int seqlength;
  // qual
  const char *qual;
};

struct _BamBam_List
{
  // first
  struct _BamBam_ListNode *first;
  // last
  struct _BamBam_ListNode *last;
};

struct _BamBam_ListNode
{
  // next
  struct _BamBam_ListNode *next;
  // entry
  void *entry;
  // bamBamListFreeFunction
  void (*bamBamListFreeFunction)(void *);
  // bamBamListPrintFunction
  void (*bamBamListPrintFunction)(struct _IO_FILE *, const void *);
};

struct _DiffBlocks
{
  // blkp
  struct _BLOCK *blkp;
  // nblk
  signed int nblk;
  // n_alloc
  signed int n_alloc;
  // ablksz
  signed int ablksz;
};

struct _DiffView
{
  // strp
  char *strp;
  // strlen
  unsigned long int strlen;
  // n_alloc
  unsigned long int n_alloc;
  // blksz
  signed int blksz;
};

struct _MESSAGE
{
  // textp
  char *textp;
  // filnamp
  char *filnamp;
  // readnamp
  char *readnamp;
  // readno
  unsigned long int readno;
  // linno
  signed int linno;
  // num
  signed short int num;
  // code
  signed int code;
  // level
  signed short int level;
};

struct _ErrMsg
{
  // messages
  struct _MESSAGE messages[10l];
  // mspace
  char mspace[512l];
  // currReadNam
  char currReadNam[64l];
  // currReadNo
  unsigned long int currReadNo;
  // num
  signed short int num;
  // usedSpace
  signed short int usedSpace;
};

struct _FILTERIVAL
{
  // upper
  unsigned int upper;
  // lower
  unsigned int lower;
};

struct _HITREGION
{
  // idx
  unsigned int idx;
  // num
  signed int num;
};

struct _HashHitFilter
{
  // ivp
  struct _FILTERIVAL *ivp;
  // num
  signed short int num;
  // n_alloc
  signed short int n_alloc;
  // blocksiz
  signed short int blocksiz;
};

struct _HashHitInfo
{
  // status
  unsigned char status;
  // qlen
  unsigned int qlen;
  // qmaskp
  unsigned char *qmaskp;
  // qbufp
  unsigned char *qbufp;
  // ktup
  unsigned char ktup;
  // nskip
  unsigned char nskip;
  // n_seeds
  unsigned int n_seeds;
  // seedp
  struct _SEED *seedp;
  // sidxp
  unsigned int *sidxp;
  // nhitqual_sortkeyp
  unsigned int *nhitqual_sortkeyp;
  // n_alloc
  unsigned long int n_alloc;
  // blksz
  signed int blksz;
  // coverp
  unsigned int *coverp;
  // framep
  unsigned int **framep;
  // countp
  unsigned int *countp;
  // seed_rank
  unsigned int seed_rank;
};

struct _HashHitList
{
  // status
  unsigned char status;
  // nhits
  signed int nhits;
  // nhits_max
  signed int nhits_max;
  // nhits_alloc
  signed int nhits_alloc;
  // nhits_blksz
  signed int nhits_blksz;
  // sqdat
  unsigned long int *sqdat;
  // ktup
  unsigned char ktup;
  // nskip
  unsigned char nskip;
  // qlen
  unsigned int qlen;
  // qmask
  char *qmask;
  // qmask_alloc
  unsigned long int qmask_alloc;
};

struct _HashTable
{
  // typ
  unsigned char typ;
  // status
  unsigned char status;
  // wordlen
  unsigned char wordlen;
  // nskip
  unsigned char nskip;
  // nbits_key
  unsigned char nbits_key;
  // nbits_lo
  unsigned char nbits_lo;
  // nkeys
  unsigned int nkeys;
  // keymask
  unsigned long int keymask;
  // keymask_lo
  unsigned int keymask_lo;
  // keymask_hi
  unsigned int keymask_hi;
  // keymod
  unsigned int keymod;
  // wordmask
  unsigned long int wordmask;
  // wordmask_lo
  unsigned long int wordmask_lo;
  // wordmask_hi
  unsigned long int wordmask_hi;
  // idx
  unsigned int *idx;
  // pos
  unsigned int *pos;
  // npos
  unsigned int npos;
  // npos_alloc
  unsigned long int npos_alloc;
  // maxpos
  unsigned int maxpos;
  // wordidx
  unsigned int *wordidx;
  // posidx
  unsigned int *posidx;
  // nwords
  unsigned int nwords;
  // wordctr
  unsigned int *wordctr;
};

struct _INDEXMENU
{
  // kmer
  unsigned char kmer;
  // skip
  unsigned char skip;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _IVAL
{
  // lo
  unsigned int lo;
  // hi
  unsigned int hi;
  // flg
  unsigned short int flg;
  // sx
  signed long int sx;
};

struct _InFmtReader
{
  // errcode
  signed int errcode;
  // fmt
  unsigned char fmt;
  // sfAp
  struct _SeqIO *sfAp;
  // sfBp
  struct _SeqIO *sfBp;
  // fid
  signed int fid;
  // rbufA
  struct _BamBam_FastQRead rbufA;
  // rbufB
  struct _BamBam_FastQRead rbufB;
};

struct _InsHist
{
  // status
  unsigned char status;
  // pCounts
  signed int *pCounts;
  // pSmoothCounts
  signed int *pSmoothCounts;
  // pKernelBuf
  double *pKernelBuf;
  // iSpan
  signed int iSpan;
  // iInSizLo
  signed int iInSizLo;
  // iInSizHi
  signed int iInSizHi;
  // iScalFac
  signed int iScalFac;
  // iNum
  unsigned long int iNum;
  // median
  signed int median;
  // quart_lo
  signed int quart_lo;
  // quart_hi
  signed int quart_hi;
};

struct _InsSample
{
  // pSample
  struct V_int32_t_ *pSample;
  // readival
  signed int readival;
};

struct _OUFMT
{
  // typ
  unsigned char typ;
  // flags
  unsigned char flags;
};

struct _MAPMENU
{
  // oufmt
  struct _OUFMT oufmt;
  // inform
  unsigned char inform;
  // nthread
  signed short int nthread;
  // penalties
  signed char penalties[4l];
  // penaltyflags
  unsigned char penaltyflags;
  // ncut
  signed int ncut;
  // maxhit
  signed int maxhit;
  // mincover
  double mincover;
  // target_depth
  signed short int target_depth;
  // minscore
  signed short int minscore;
  // randseed_repeat
  signed int randseed_repeat;
  // scorediff
  signed short int scorediff;
  // minbasq
  unsigned char minbasq;
  // minidentity
  double minidentity;
  // diskuse
  char diskuse;
  // insert_range
  signed int insert_range[2l];
  // oufilnam
  char *oufilnam;
  // insfilnam
  char *insfilnam;
  // tmpdirnam
  char *tmpdirnam;
  // readskip
  signed int readskip;
  // mapqmin
  signed int mapqmin;
  // pairtyp
  unsigned char pairtyp;
  // flags
  unsigned short int flags;
};

struct _MATEPAIR
{
  // ap
  const struct _RESULT *ap;
  // bp
  const struct _RESULT *bp;
  // ins
  signed int ins;
  // flag
  unsigned char flag;
  // mapflg
  unsigned char mapflg;
  // mscor
  signed int mscor;
  // combiscor
  unsigned int combiscor;
  // cls
  unsigned char cls;
  // pbf
  double pbf;
};

struct _MenuOpt
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // subprog
  char subprog;
  // paramp
  void *paramp;
  // indir
  char *indir;
  // ninfil
  signed int ninfil;
  // filnams
  char **filnams;
  // estrbuf
  struct EString_ estrbuf;
};

struct _OFFSIVAL
{
  // rp
  const struct _RESULT *rp;
  // status
  unsigned short int status;
  // sidx
  signed long int sidx;
  // lower
  unsigned int lower;
  // upper
  unsigned int upper;
};

struct _REPALI
{
  // was_output
  unsigned char was_output;
  // status
  unsigned char status;
  // swatscor
  signed int swatscor;
  // mapscor
  signed short int mapscor;
  // q_start
  unsigned int q_start;
  // q_end
  unsigned int q_end;
  // q_idx
  signed long int q_idx;
  // s_start
  unsigned int s_start;
  // s_end
  unsigned int s_end;
  // s_idx
  signed long int s_idx;
  // dfo
  signed int dfo;
};

struct _REPSTR
{
  // strp
  char *strp;
  // strl
  unsigned long int strl;
  // n_alloc
  unsigned long int n_alloc;
  // blksz
  signed int blksz;
};

struct _REPNAMBUF
{
  // ref_nam
  struct _REPSTR ref_nam;
  // mref_nam
  struct _REPSTR mref_nam;
  // q_nam
  struct _REPSTR q_nam;
};

struct _REPPAIR
{
  // pairflg
  unsigned char pairflg;
  // isize
  signed int isize;
  // iA
  signed int iA;
  // iB
  signed int iB;
};

struct _RESULT
{
  // serialno
  signed short int serialno;
  // status
  unsigned short int status;
  // swatscor
  signed int swatscor;
  // mapscor
  signed int mapscor;
  // prob
  double prob;
  // q_start
  unsigned int q_start;
  // q_end
  unsigned int q_end;
  // s_start
  unsigned long int s_start;
  // s_end
  unsigned long int s_end;
  // sidx
  signed long int sidx;
  // stroffs
  signed int stroffs;
  // strlen
  signed int strlen;
  // rsltx
  signed short int rsltx;
  // qsegx
  signed short int qsegx;
  // swrank
  signed short int swrank;
};

struct _Report
{
  // pairr
  struct _REPPAIR *pairr;
  // arAr
  struct _REPALI *arAr;
  // arBr
  struct _REPALI *arBr;
  // dfs
  struct _DiffStr dfs;
};

struct _ReportWriter
{
  // oufmt
  unsigned char oufmt;
  // modflg
  unsigned char modflg;
  // linwidth
  signed short int linwidth;
  // qbufp
  struct _SeqFastq *qbufp;
  // sbufp
  struct _SeqFastq *sbufp;
  // dfblkp
  struct _DiffBlocks *dfblkp;
  // namext
  char namext[16l];
  // namext_mate
  char namext_mate[16l];
  // nambufp
  struct _REPNAMBUF *nambufp;
  // filnam
  char *filnam;
  // oufp
  struct _IO_FILE *oufp;
  // dvp
  struct _DiffView *dvp;
  // headinfop
  struct _BamBam_BamHeaderInfo *headinfop;
  // bamwriterp
  struct _BamBam_BamWriter *bamwriterp;
};

struct _ResultFilter
{
  // min_swscor
  signed int min_swscor;
  // min_swscor_below_max
  signed int min_swscor_below_max;
  // min_identity
  double min_identity;
};

struct _ResultPairs
{
  // status
  unsigned char status;
  // ivr
  struct _OFFSIVAL *ivr;
  // mpr
  struct _MATEPAIR *mpr;
  // n_proper
  signed int n_proper;
  // n_within
  signed int n_within;
  // dmin
  signed int dmin;
  // dmax
  signed int dmax;
};

struct _ResultSet
{
  // status
  unsigned char status;
  // resr
  struct _RESULT *resr;
  // diffstrp
  struct _DiffStr *diffstrp;
  // swatscor_max
  signed int swatscor_max;
  // swatscor_2ndmax
  signed int swatscor_2ndmax;
  // sortr
  struct _RESULT **sortr;
  // segsrtr
  struct _RESULT **segsrtr;
  // segnor
  signed short int *segnor;
  // sortidxr
  unsigned int *sortidxr;
  // sortkeyr
  unsigned long int *sortkeyr;
  // diffstrbufp
  struct _DiffStr *diffstrbufp;
  // n_ali_done
  signed int n_ali_done;
  // n_ali_tot
  signed int n_ali_tot;
  // n_ali_max
  signed short int n_ali_max;
  // n_hits_used
  unsigned int n_hits_used;
  // n_hits_tot
  unsigned int n_hits_tot;
  // qsegno
  signed short int qsegno;
};

struct _SEED
{
  // posidx
  unsigned int posidx;
  // nhits
  unsigned int nhits;
  // cix
  unsigned int cix;
  // qoffs
  unsigned int qoffs;
};

struct _SEED$0
{
  // sqo
  unsigned long int sqo;
  // len
  signed int len;
};

struct _SEGCAND
{
  // qs
  unsigned int qs;
  // qe
  unsigned int qe;
  // rs
  unsigned int rs;
  // re
  unsigned int re;
  // shiftoffs
  signed short int shiftoffs;
  // shift2mm
  signed short int shift2mm;
  // srange
  signed short int srange;
  // cover
  unsigned int cover;
  // flag
  unsigned char flag;
  // segix
  unsigned int segix;
  // nseg
  signed int nseg;
  // hregix
  unsigned int hregix;
  // seqidx
  signed int seqidx;
};

struct _SEGMENT
{
  // ix
  unsigned int ix;
  // nseed
  signed int nseed;
  // cover
  unsigned int cover;
};

struct _SEQSEQ
{
  // code
  char code;
  // basep
  char *basep;
  // block_size
  signed int block_size;
  // size
  unsigned long int size;
  // alloc_size
  unsigned long int alloc_size;
  // nbit_symb
  char nbit_symb;
};

struct _ScoreMatrix
{
  // gap_init
  signed char gap_init;
  // gap_ext
  signed char gap_ext;
  // score
  signed char **score;
  // alphabetsiz
  signed short int alphabetsiz;
};

struct _ScoreProfile
{
  // mod
  unsigned char mod;
  // alphabetsiz
  signed short int alphabetsiz;
  // allocsiz
  unsigned int allocsiz;
  // blocksiz
  unsigned int blocksiz;
  // length
  unsigned int length;
  // score
  signed char **score;
  // striped_datap
  void *striped_datap;
  // striped_nalloc
  unsigned long int striped_nalloc;
  // striped_bytep
  __gcc_v2di *striped_bytep;
  // striped_shortp
  __gcc_v2di *striped_shortp;
  // bias
  signed short int bias;
  // match_avg
  signed char match_avg;
  // mismatch_avg
  signed char mismatch_avg;
  // gap_init
  signed char gap_init;
  // gap_ext
  signed char gap_ext;
};

struct _SegAliCands
{
  // candr
  struct _SEGCAND *candr;
  // sort_keys
  unsigned int *sort_keys;
  // sort_idx
  unsigned int *sort_idx;
  // n_alloc
  unsigned int n_alloc;
  // alloc_blksz
  unsigned int alloc_blksz;
  // n_sort
  unsigned int n_sort;
  // max_cover
  unsigned int max_cover;
  // max2nd_cover
  unsigned int max2nd_cover;
  // cover_deficit
  unsigned int cover_deficit[2l];
  // n_mincover
  unsigned int n_mincover;
  // nskip
  unsigned char nskip;
  // ktup
  unsigned char ktup;
};

struct _SegLst
{
  // hregr
  struct _HITREGION *hregr;
  // seedr
  struct _SEED$0 *seedr;
  // segmr
  struct _SEGMENT *segmr;
  // dshift_cutoff
  unsigned short int dshift_cutoff;
  // nskip
  unsigned char nskip;
  // ktup
  unsigned char ktup;
  // flags
  unsigned char flags;
  // qlen
  unsigned int qlen;
  // maxcover
  unsigned int maxcover;
};

struct _SegQMask
{
  // maskp
  unsigned char *maskp;
  // n_alloc
  unsigned long int n_alloc;
  // blksiz
  signed int blksiz;
};

struct _SeqCodec
{
  // typ
  char typ;
  // alphlen
  unsigned char alphlen;
  // alphabet
  char alphabet[7l];
  // codtab
  unsigned char codtab[256l];
  // decodtab
  char decodtab[256l];
  // codtab_complement
  unsigned char codtab_complement[4l];
};

struct _SeqFastq
{
  // type
  char type;
  // headp
  struct _SEQSEQ *headp;
  // datap
  struct _SEQSEQ *datap;
  // qheadp
  struct _SEQSEQ *qheadp;
  // qualp
  struct _SEQSEQ *qualp;
};

struct _SeqIO
{
  // flags
  unsigned char flags;
  // mode
  char mode;
  // filnam
  char *filnam;
  // fp
  void *fp;
  // fmode
  char fmode[4l];
  // bufsize
  unsigned long int bufsize;
  // status
  signed int status;
  // linbufp
  char *linbufp;
};

struct _SeqSet
{
  // statusflag
  unsigned char statusflag;
  // sqp
  struct _SEQSEQ *sqp;
  // qqp
  struct _SEQSEQ *qqp;
  // n_seq
  signed long int n_seq;
  // sop
  unsigned long int *sop;
  // n_alloc
  signed long int n_alloc;
  // blocksiz
  signed int blocksiz;
  // namebasep
  char *namebasep;
  // namoffs
  unsigned long int *namoffs;
  // nam_alloc
  unsigned long int nam_alloc;
  // nam_blocksiz
  signed int nam_blocksiz;
  // sxp
  signed long int *sxp;
};

struct _SmaltIOBuffArg
{
  // readno
  unsigned long int readno;
  // isPaired
  unsigned char isPaired;
  // readp
  struct _SeqFastq *readp;
  // matep
  struct _SeqFastq *matep;
  // isiz
  signed int isiz;
  // pairflg
  unsigned char pairflg;
  // rep
  struct _Report *rep;
};

struct _SmaltInput
{
  // errcode
  signed int errcode;
  // threadno
  signed short int threadno;
  // menuflg
  unsigned short int menuflg;
  // rctr
  unsigned long int rctr;
  // pctr
  unsigned long int pctr;
  // rival
  signed int rival;
  // ifrp
  struct _InFmtReader *ifrp;
};

struct _SmaltMapArgs
{
  // threadno
  signed short int threadno;
  // smconstp
  const struct _SmaltMapConst *smconstp;
  // rmp
  struct RMap_ *rmp;
  // errcode
  signed int errcode;
};

struct _SmaltMapConst
{
  // menuflg
  unsigned short int menuflg;
  // subprogtyp
  char subprogtyp;
  // inform
  unsigned char inform;
  // rmapflg
  unsigned short int rmapflg;
  // rsltouflg
  unsigned char rsltouflg;
  // oufilnam
  const char *oufilnam;
  // outform
  unsigned char outform;
  // oumodflg
  unsigned char oumodflg;
  // codecp
  struct _SeqCodec *codecp;
  // scorpltyp
  struct ScorePenalties_ *scorpltyp;
  // scormtxp
  struct _ScoreMatrix *scormtxp;
  // htp
  struct _HashTable *htp;
  // ssp
  struct _SeqSet *ssp;
  // rfp
  struct _ResultFilter *rfp;
  // ihp
  struct _InsHist *ihp;
  // insert_min
  signed int insert_min;
  // insert_max
  signed int insert_max;
  // nhitmax_tuple
  signed int nhitmax_tuple;
  // min_swatscor
  signed int min_swatscor;
  // swatscordiff
  signed int swatscordiff;
  // minbasq
  unsigned char minbasq;
  // tupcovmin
  double tupcovmin;
  // readskip
  signed int readskip;
  // pairtyp
  unsigned char pairtyp;
  // ifrp
  struct _InFmtReader *ifrp;
  // prognam
  const char *prognam;
  // progversion
  const char *progversion;
  // cmdlin_narg
  signed int cmdlin_narg;
  // cmdlin_argv
  char **cmdlin_argv;
  // threadblksz
  signed short int threadblksz;
};

struct _SmaltOutput
{
  // threadno
  signed short int threadno;
  // next_readno
  unsigned long int next_readno;
  // smcp
  const struct _SmaltMapConst *smcp;
  // isamp
  struct _InsSample *isamp;
  // writerp
  struct _ReportWriter *writerp;
};

struct _THREADARG
{
  // threadno
  signed short int threadno;
  // flags
  unsigned char flags;
  // task
  unsigned char task;
  // p
  void *p;
  // buflstp
  struct _BUFFARG *buflstp;
  // errmsgp
  struct _ErrMsg *errmsgp;
  // exit_code
  signed int exit_code;
};

struct _THREADTASK
{
  // status
  unsigned char status;
  // n_threads
  signed short int n_threads;
  // initf
  signed int (*initf)(void *, const void *, signed short int);
  // initargp
  const void *initargp;
  // procf
  signed int (*procf)(struct _ErrMsg *, void *, void *);
  // cleanf
  signed int (*cleanf)(struct _ErrMsg *, void *);
  // checkf
  signed int (*checkf)(const void *, const void *);
  // cmpf
  signed int (*cmpf)(const void *, const void *);
  // argsz
  unsigned long int argsz;
  // fromx
  unsigned char fromx;
  // tox
  unsigned char tox;
};

struct _Threads
{
  // status
  unsigned char status;
  // n_threads
  signed short int n_threads;
  // tasks
  struct _THREADTASK tasks[4l];
  // threadp
  unsigned long int *threadp;
  // n_targ
  signed short int n_targ;
  // targp
  struct _THREADARG *targp;
  // n_buffargs
  signed short int n_buffargs;
  // buffargp
  struct _BUFFARG *buffargp;
  // memp
  void *memp;
  // buff
  struct _ARGBUFF buff[3l];
};

struct _optflags
{
  // kmer
  unsigned int kmer : 1;
  // skip
  unsigned int skip : 1;
  // ncut
  unsigned int ncut : 1;
  // mincover
  unsigned int mincover : 1;
  // minscore
  unsigned int minscore : 1;
  // maxhit
  unsigned int maxhit : 1;
  // scorediff
  unsigned int scorediff : 1;
  // oufilnam
  unsigned int oufilnam : 1;
  // insfilnam
  unsigned int insfilnam : 1;
  // insertmax
  unsigned int insertmax : 1;
  // insertmin
  unsigned int insertmin : 1;
  // randrepeat
  unsigned int randrepeat : 1;
  // minbasq
  unsigned int minbasq : 1;
  // minidentity
  unsigned int minidentity : 1;
  // mapqmin
  unsigned int mapqmin : 1;
  // readskip
  unsigned int readskip : 1;
  // pairtyp
  unsigned int pairtyp : 1;
  // penalties
  unsigned int penalties : 1;
};

struct gzFile_s
{
  // have
  unsigned int have;
  // next
  unsigned char *next;
  // pos
  signed long int pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};


// BAMBAM_FILTYP_BAM
// file infmt.c line 56
static const char BAMBAM_FILTYP_BAM[4l] = { 'b', 'a', 'm', 0 };
// BAMBAM_FILTYP_SAM
// file infmt.c line 57
static const char BAMBAM_FILTYP_SAM[4l] = { 's', 'a', 'm', 0 };
// BAMBAM_TMPDIR_DEFAULT
// file infmt.c line 58
static const char BAMBAM_TMPDIR_DEFAULT[2l] = { '.', 0 };
// BIAS
// file swsimd.c line 49
static signed short int BIAS = (signed short int)((signed int)(signed short int)1 << 15);
// CIGAR_EXTF
// file diffstr.c line 65
static const char CIGAR_EXTF[5l] = { '%', 'd', '%', 'c', 0 };
// CIGAR_FORM
// file diffstr.c line 64
static const char CIGAR_FORM[7l] = { '%', 'c', ' ', '%', 'd', ' ', 0 };
// CODEC_ALPHABET
// file sequence.c line 101
static const char CODEC_ALPHABET[7l] = { 'A', 'C', 'G', 'T', 'X', 'N', 0 };
// CUMULPROB_IMPROPER
// file resultpairs.c line 123
static const double CUMULPROB_IMPROPER = 1e-4;
// CUMULPROB_PROPER_OUTSIDE
// file resultpairs.c line 122
static const double CUMULPROB_PROPER_OUTSIDE = 3e-3;
// DIFFSTR_NULLSTR
// file diffstr.c line 71
static const char DIFFSTR_NULLSTR[2l] = { '*', 0 };
// DIFFSTR_SYMBOLS
// file diffstr.c line 66
static const char DIFFSTR_SYMBOLS[5l] = { 'M', 'D', 'I', 'S', 0 };
// DIFFSTR_SYMBOLS_X
// file diffstr.c line 69
static const char DIFFSTR_SYMBOLS_X[5l] = { 'M', 'D', 'I', 'X', 0 };
// ERRMSG_FORMAT
// file elib.c line 70
const char ERRMSG_FORMAT[22l] = { '[', '%', 'i', ']', ' ', '%', 's', ':', '%', 'd', ' ', '%', 's', ':', ' ', '%', 's', ' ', '%', 's', '\n', 0 };
// HASHTABFIL_NAMEXT
// file hashidx.c line 61
static const char HASHTABFIL_NAMEXT[4l] = { 's', 'm', 'i', 0 };
// HASHTABFIL_WRITERRMSG
// file hashidx.c line 62
static const char HASHTABFIL_WRITERRMSG[29l] = { 'w', 'h', 'e', 'n', ' ', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'h', 'a', 's', 'h', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'f', 'i', 'l', 'e', 0 };
// IOFIL_FORMAT
// file insert.c line 91
static const char IOFIL_FORMAT[7l] = { '%', 'i', ' ', '%', 'i', '\n', 0 };
// IOFIL_HEADER
// file insert.c line 86
static const char IOFIL_HEADER[35l] = { '#', ' ', 'S', 'M', 'A', 'L', 'T', ' ', 'h', 'i', 's', 't', 'o', 'g', 'r', 'a', 'm', ' ', 'o', 'f', ' ', 'i', 'n', 's', 'e', 'r', 't', ' ', 's', 'i', 'z', 'e', 's', '\n', 0 };
// IOFIL_KEY_END
// file insert.c line 90
static const char IOFIL_KEY_END[10l] = { 'H', 'I', 'S', 'T', 'O', '_', 'E', 'N', 'D', 0 };
// IOFIL_KEY_FORMAT
// file insert.c line 88
static const char IOFIL_KEY_FORMAT[111l] = { 'H', 'I', 'S', 'T', 'O', '_', 'B', 'I', 'N', 'N', 'U', 'M', ' ', '%', 'i', '\n', 'H', 'I', 'S', 'T', 'O', '_', 'S', 'C', 'A', 'L', 'F', 'A', 'C', ' ', '%', 'i', '\n', 'H', 'I', 'S', 'T', 'O', '_', 'I', 'N', 'S', 'I', 'Z', 'L', 'O', ' ', '%', 'i', '\n', 'H', 'I', 'S', 'T', 'O', '_', 'I', 'N', 'S', 'I', 'Z', 'H', 'I', ' ', '%', 'i', '\n', 'H', 'I', 'S', 'T', 'O', '_', 'T', 'O', 'T', 'N', 'U', 'M', ' ', '%', 'l', 'l', 'u', '\n', 'H', 'I', 'S', 'T', 'O', '_', 'Q', 'U', 'A', 'R', 'T', 'I', 'L', 'E', 'S', ' ', '%', 'i', ' ', '%', 'i', ' ', '%', 'i', '\n', 0 };
// IOFIL_KEY_START
// file insert.c line 87
static const char IOFIL_KEY_START[12l] = { 'H', 'I', 'S', 'T', 'O', '_', 'S', 'T', 'A', 'R', 'T', 0 };
// LN0P25
// file alignment.c line 71
static const double LN0P25 = -1.386294;
// MENU_COPYRIGHT_NOTICE
// file menu.c line 67
static const char MENU_COPYRIGHT_NOTICE[47l] = { 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '(', 'C', ')', ' ', '2', '0', '1', '0', ' ', '-', ' ', '2', '0', '1', '4', ' ', 'G', 'e', 'n', 'o', 'm', 'e', ' ', 'R', 'e', 's', 'e', 'a', 'r', 'c', 'h', ' ', 'L', 't', 'd', '.', 0 };
// MENU_DEFAULTS_MINCOVER
// file menu.c line 625
static const double MENU_DEFAULTS_MINCOVER = 0.0;
// MENU_DEFAULTS_MINIDENTITY
// file menu.c line 626
static const double MENU_DEFAULTS_MINIDENTITY = 0.0;
// MENU_OPTDOC_INDEX
// file menu.c line 132
static const struct OPTDOC_ MENU_OPTDOC_INDEX[4l] = { { .ochr=(char)72, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Print more extensive help on options.", .ldesc="     Print these instructions.\n" },
    { .ochr=(char)107, .otyp=(unsigned char)2, .vnam="wordlen",
    .sdesc="Length of the k-mer words indexed.", .ldesc="     Specifies the word length. <wordlen> is an integer within the limits\n     2 < wordlen <= 20. The default word length is 13.\n" },
    { .ochr=(char)115, .otyp=(unsigned char)2, .vnam="stepsiz",
    .sdesc="Sample every <stepsiz>-th k-mer word (stride).", .ldesc="     Specifies how many bases are skipped between indexed words. With '-s 1'\n     every k-mer word along the reference sequences is indexed. With '-s 2'\n     every other word is indexed etc. By default the step size is set equal\n     to the word length (tiling words).\n" },
    { .ochr=(char)0, .otyp=(unsigned char)0, .vnam=((const char *)NULL),
    .sdesc=((const char *)NULL), .ldesc=((const char *)NULL) } };
// MENU_OPTDOC_MAP
// file menu.c line 206
static const struct OPTDOC_ MENU_OPTDOC_MAP[23l] = { { .ochr=(char)97, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Add explicit alignments to output.", .ldesc="     Output explicit alignments along with the mapping coordinates.\n" },
    { .ochr=(char)99, .otyp=(unsigned char)2, .vnam="mincover",
    .sdesc="Threshold of the number of bases covered by k-mer seeds.", .ldesc="     Only consider mappings where the k-mer word seeds cover the query read to\n     a minimum extent. If <mincover> is an integer or floating point > 1.0, at\n     least this many bases of the read must be covered by k-mer word seeds. If\n     <mincover> is a floating point <= 1.0, it specifies the fraction of the\n     query read length that must be covered by k-mer word seeds. This option\n     is only valid in conjunction with the '-x' flag.\n" },
    { .ochr=(char)100, .otyp=(unsigned char)2, .vnam="scordiff",
    .sdesc="Threshold of the Smith-Waterman score relative to best.", .ldesc="     Set a threshold of the Smith-Waterman alignment score relative to the\n     maximum score. When mapping single reads, all alignments are reported\n     that have Smith-Waterman scores within <scorediff> of the maximum.\n     Mappings with lower scores are skipped. If <scorediff> is set to to a\n     value < 0, all alignments are printed that have scores above the\n     threshold specified with the '-m <minscor>' option.\n     For paired reads, only a value of 0 is supported. With the option '-d 0'\n     all aligments (pairings) with the best score are output. By default \n     (without the option '-d 0') single reads/mates with multiple best mappings\n     are reported as 'not mapped'.\n" },
    { .ochr=(char)102, .otyp=(unsigned char)1, .vnam="ouform",
    .sdesc="Output format [sam(default)|bam|cigar|gff|ssaha].\n           Ext: [sam|bam]:nohead,x,clip.", .ldesc="     Specifies the output format. <ouform> can be either 'sam'(default), 'bam',\n     'cigar', 'gff' or 'ssaha'. Optional extension '[sam|bam]:nohead,x,clip'\n     (see manual).\n" },
    { .ochr=(char)70, .otyp=(unsigned char)1, .vnam="inform",
    .sdesc="Input format [fastq (default)|sam|bam].", .ldesc="     Specifies the input format. <inform> can be either 'fastq' (default),\n     'sam' or 'bam' (see: samtools.sourceforge.net).\n" },
    { .ochr=(char)103, .otyp=(unsigned char)1, .vnam="insfil",
    .sdesc="Reads insert size distribution from file (see 'sample' task).", .ldesc="     Use the distribution of insert sizes stored in the file <insfil>. This\n     file is in ASCII format and can be generated using the 'sample' task see\n     'smalt sample -H' for help).\n" },
    { .ochr=(char)72, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Print more extensive help on options.", .ldesc="     Print these instructions.\n" },
    { .ochr=(char)105, .otyp=(unsigned char)2, .vnam="insert_max",
    .sdesc="Maximum insert size for paired reads (default: 500).", .ldesc="     Maximum insert size (only in paired-end mode). The default is 500.\n" },
    { .ochr=(char)106, .otyp=(unsigned char)2, .vnam="insert_min",
    .sdesc="Minimum insert size for paired reads (default: 0).", .ldesc="     Minimum insert size (only in paired-end mode). The default is 0.\n" },
    { .ochr=(char)108, .otyp=(unsigned char)1, .vnam="pairtyp",
    .sdesc="Type of paired read library [pe|mp|pp] (default: pe).", .ldesc="     Type of read pair library. <pairtyp> can be either 'pe', i.e. for\n     the Illumina paired-end library for short inserts (|--> <--|). 'mp'\n     for the Illumina mate-pair library for long inserts (<--| |-->) or\n     'pp' for mates sequenced on the same strand (|--> |-->). 'pe' is the\n     default.\n" },
    { .ochr=(char)109, .otyp=(unsigned char)2, .vnam="minscor",
    .sdesc="Threshold of alignment score.", .ldesc="     Sets an absolute threshold of the Smith-Waterman scores. Mappings with\n     scores below that threshold will not be reported. The default is\n     <minscor> = <wordlen> + <stepsiz> - 1.\n" },
    { .ochr=(char)110, .otyp=(unsigned char)2, .vnam="nthreads",
    .sdesc="Number of threads.", .ldesc="     Run smalt using mutiple threads. <nthread> is the number of additional\n     threads forked. The order of the reads in the input files is not preserved\n     for the output unless '-O' is also specified.\n" },
    { .ochr=(char)111, .otyp=(unsigned char)1, .vnam="oufilnam",
    .sdesc="Write aligments to specified file (default: stdout).", .ldesc="     Write mapping output (e.g. SAM lines) to a separate file. If this option\n     is not specified, mappings are written to standard output.\n" },
    { .ochr=(char)79, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Preserve the order of the reads in the output (with '-n').", .ldesc="     Output mappings in the order of the reads in the input files when using\n     multiple threads (option '-n <nthreads>').\n\n" },
    { .ochr=(char)112, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Report split alignments.", .ldesc="     Report partial alignments if they are complementary on the read (split\n     reads).\n" },
    { .ochr=(char)113, .otyp=(unsigned char)2, .vnam="minbasq",
    .sdesc="Base quality threshold <= 10 (default 0).", .ldesc="     Sets a base quality threshold (0 <= minbasq <= 10, default 0).\n     K-mer words of the read with nucleotides that have a base quality below\n     this threshold are not looked up in the hash index.\n" },
    { .ochr=(char)114, .otyp=(unsigned char)2, .vnam="seed",
    .sdesc="Random assignment of degen. mappings (mark 'unmapped' if < 0).", .ldesc="     If <seed> >= 0 report an alignment selected at random where there are\n     multiple mappings with the same best alignment score. With <seed> = 0\n     (default) a seed is derived from the current calendar time. If <seed>\n     < 0 reads with multiple best mappings are reported as 'not mapped'.\n" },
    { .ochr=(char)83, .otyp=(unsigned char)1, .vnam="scorspec",
    .sdesc="Set alignment penalties,\n           e.g 'match=1,mismatch=-2,gapopen=-4,gapext=-3' (default).", .ldesc="     Specify alignment penalty scores for a match or mismatch (substitution),\n     or for opening or extending a gap. <scorspec> is a comma speparated\n     list of integer assigments to one or more of the following variables:\n     match, subst, gapopen, gapext, i.e. 'gapopen=-5,gapext=-4' (no spaces\n     allowed in <scorespec>). Default:'match=1,subst=-2,gapopen=-4,gapext=-3'\n" },
    { .ochr=(char)84, .otyp=(unsigned char)1, .vnam="tmpdir",
    .sdesc="Write temporary files do specified directory.", .ldesc="     Write temporary files to directory <tmpdir> (used with input files in\n     SAM/BAM format).\n" },
    { .ochr=(char)119, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Use complexity weighted Smith-Waterman scores.", .ldesc="     Smith-Waterman scores are complexity weighted.\n" },
    { .ochr=(char)120, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Exhaustive search for alignments (at the cost of speed).", .ldesc="     This flag triggers a more exhaustive search for alignments at the cost\n     of speed. In paired-end mode each mate is mapped independently.(By\n     default the mate with fewer hits in the hash index is mapped first and\n     the vicinity is searched for mappings of its mate.)\n" },
    { .ochr=(char)121, .otyp=(unsigned char)4, .vnam="minid",
    .sdesc="Identity threshold (default: 0).", .ldesc="     Sets an identity threshold for a mapping to be reported (default: 0).\n     <minid> specifies the number of exactly matching nucleotides either as\n     a positive integer or as a fraction of the read length (<= 1.0).\n" },
    { .ochr=(char)0, .otyp=(unsigned char)0, .vnam=((const char *)NULL),
    .sdesc=((const char *)NULL), .ldesc=((const char *)NULL) } };
// MENU_OPTDOC_SAMPLE
// file menu.c line 496
static const struct OPTDOC_ MENU_OPTDOC_SAMPLE[9l] = { { .ochr=(char)72, .otyp=(unsigned char)0, .vnam="",
    .sdesc="Print more extensive help on options.", .ldesc="     Print these instructions.\n" },
    { .ochr=(char)70, .otyp=(unsigned char)1, .vnam="inform",
    .sdesc="Input format [fastq (default)|sam|bam].", .ldesc="     Specifies the input format. <inform> can be either 'fastq' (default),\n     'sam' or 'bam' (see: samtools.sourceforge.net).\n" },
    { .ochr=(char)109, .otyp=(unsigned char)2, .vnam="minscor",
    .sdesc="Threshold of the alingment score.", .ldesc="     Sets an absolute threshold of the Smith-Waterman scores. Mappings with\n     scores below that threshold will not be reported. The default is\n     <minscor> = <wordlen> + <stepsiz> - 1.\n" },
    { .ochr=(char)110, .otyp=(unsigned char)2, .vnam="nthreads",
    .sdesc="Run multi-threaded with this number of threads.", .ldesc="    Run in multi-threaded mode. <nthread> is the number of threads forked.\n" },
    { .ochr=(char)111, .otyp=(unsigned char)1, .vnam="oufilnam",
    .sdesc="Write output to specified file (default: stdout).", .ldesc="     Write mapping output (e.g. SAM lines) to a separate file. If this option\n     is not specified, mappings are written to standard output.\n" },
    { .ochr=(char)113, .otyp=(unsigned char)2, .vnam="minbasq",
    .sdesc="Base quality threshold <= 10 (default 0).", .ldesc="     Sets a base quality threshold (0 <= minbasq <= 10, default 0).\n     K-mer words of the read with nucleotides that have a base quality below\n     this threshold are not looked up in the hash index.\n" },
    { .ochr=(char)84, .otyp=(unsigned char)1, .vnam="tmpdir",
    .sdesc="Write temporary files to specified directory.", .ldesc="     Write temporary files to directory <tmpdir> (used with input files in\n     SAM/BAM format).\n" },
    { .ochr=(char)117, .otyp=(unsigned char)2, .vnam="nreads",
    .sdesc="Map only every <nreads>-th read pair (default 100).", .ldesc="     Map only every <nreads>-th read pair (default 100).\n" },
    { .ochr=(char)0, .otyp=(unsigned char)0, .vnam=((const char *)NULL),
    .sdesc=((const char *)NULL), .ldesc=((const char *)NULL) } };
// MENU_PENALTY_LST
// file menu.c line 671
static const struct VARLST_ MENU_PENALTY_LST[5l] = { { .varnam="match", .typ=(unsigned char)0, .val=(signed char)1,
    .max=(signed char)127, .min=(signed char)0 },
    { .varnam="subst", .typ=(unsigned char)1, .val=(signed char)-2,
    .max=(signed char)0, .min=(signed char)-127 },
    { .varnam="gapopen", .typ=(unsigned char)2, .val=(signed char)-4,
    .max=(signed char)0, .min=(signed char)-127 },
    { .varnam="gapext", .typ=(unsigned char)3, .val=(signed char)-3,
    .max=(signed char)0, .min=(signed char)-127 },
    { .varnam=((const char *)NULL), .typ=(unsigned char)0, .val=(signed char)0,
    .max=(signed char)0, .min=(signed char)0 } };
// MENU_PROGNAM
// file menu.c line 59
static const char MENU_PROGNAM[58l] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', 'M', 'A', 'L', 'T', ' ', '-', ' ', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 'M', 'a', 'p', 'p', 'i', 'n', 'g', ' ', 'a', 'n', 'd', ' ', 'A', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', ' ', 'T', 'o', 'o', 'l', 0 };
// MENU_PROGNAM_SHORT
// file menu.c line 58
static const char MENU_PROGNAM_SHORT[6l] = { 's', 'm', 'a', 'l', 't', 0 };
// MENU_PROGNAM_VERSION_FMT
// file menu.c line 61
static const char MENU_PROGNAM_VERSION_FMT[44l] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '(', 'v', 'e', 'r', 's', 'i', 'o', 'n', ':', ' ', '%', 's', ')', '\n', 0 };
// MENU_RELEASE_AUTHORS
// file menu.c line 65
static const char MENU_RELEASE_AUTHORS[17l] = { 'H', 'a', 'n', 'n', 'e', 's', ' ', 'P', 'o', 'n', 's', 't', 'i', 'n', 'g', 'l', 0 };
// MENU_RELEASE_BUGREPORT
// file menu.c line 66
static const char MENU_RELEASE_BUGREPORT[17l] = { 'h', 'p', '3', '@', 's', 'a', 'n', 'g', 'e', 'r', '.', 'a', 'c', '.', 'u', 'k', 0 };
// MENU_RELEASE_DATE
// file menu.c line 64
static const char MENU_RELEASE_DATE[11l] = { '2', '1', '-', '0', '3', '-', '2', '0', '1', '4', 0 };
// MENU_RELEASE_VERSION
// file menu.c line 63
static const char MENU_RELEASE_VERSION[6l] = { '0', '.', '7', '.', '6', 0 };
// MENU_SHORT_DESCRIPTION
// file menu.c line 105
static const char MENU_SHORT_DESCRIPTION[394l] = { ' ', ' ', 'S', 'm', 'a', 'l', 't', ' ', 'i', 's', ' ', 'a', ' ', 'p', 'a', 'i', 'r', 'w', 'i', 's', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 'a', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', ' ', 'p', 'r', 'o', 'g', 'r', 'a', 'm', ' ', 'd', 'e', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'm', 'a', 'p', 'p', 'i', 'n', 'g', ' ', 'o', 'f', '\n', ' ', ' ', 'D', 'N', 'A', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'i', 'n', 'g', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'o', 'n', 't', 'o', ' ', 'g', 'e', 'n', 'o', 'm', 'i', 'c', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's', '.', '\n', ' ', ' ', 'R', 'u', 'n', 'n', 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 's', 'o', 'f', 't', 'w', 'a', 'r', 'e', ' ', 'i', 'n', 'v', 'o', 'l', 'v', 'e', 's', ' ', 't', 'w', 'o', ' ', 's', 't', 'e', 'p', 's', '.', ' ', 'F', 'i', 'r', 's', 't', ',', ' ', 'a', 'n', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 's', 'h', 'o', 'r', 't', ' ', 'w', 'o', 'r', 'd', 's', '\n', ' ', ' ', 'h', 'a', 's', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'b', 'u', 'i', 'l', 't', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 's', 'e', 't', ' ', 'o', 'f', ' ', 'g', 'e', 'n', 'o', 'm', 'i', 'c', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's', ' ', '(', 'i', 's', 's', 'u', 'e', ' ', '\n', ' ', ' ', '\'', 's', 'm', 'a', 'l', 't', ' ', 'i', 'n', 'd', 'e', 'x', ' ', '-', 'H', '\'', ' ', 'f', 'o', 'r', ' ', 'h', 'e', 'l', 'p', ')', '.', ' ', 'T', 'h', 'e', 'n', ' ', 't', 'h', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'i', 'n', 'g', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'a', 'r', 'e', ' ', 'm', 'a', 'p', 'p', 'e', 'd', ' ', 'o', 'n', 't', 'o', ' ', 't', 'h', 'e', '\n', ' ', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', '(', '\'', 's', 'm', 'a', 'l', 't', ' ', 'm', 'a', 'p', ' ', '-', 'H', '\'', ' ', 'f', 'o', 'r', ' ', 'h', 'e', 'l', 'p', ')', '.', '\n', '\n', 0 };
// MENU_TASKDOC_CHECK
// file menu.c line 483
static const struct TASKDOC_ MENU_TASKDOC_CHECK = { .synopsis="  smalt check <query_file> [<mate_file>]", .description="  Check FASTA/FASTQ read files. If <mate_file> is specified, the reads are\n  in pairs.\n",
    .optdoc=(const struct OPTDOC_ *)(void *)0 };
// MENU_TASKDOC_INDEX
// file menu.c line 162
static const struct TASKDOC_ MENU_TASKDOC_INDEX;
// MENU_TASKDOC_INDEX
// file menu.c line 162
static const struct TASKDOC_ MENU_TASKDOC_INDEX = { .synopsis="  smalt index [-k <wordlen>] [-s <stepsiz>]  <index_name> <reference_file>\n", .description="  Generates an index of k-mer words for the genomic reference sequences. The\n  words are of fixed length <wordlen> and are sampled at equidistant steps\n  <stepsiz> bases apart. The reference sequences are provided in a single\n  file <reference_file> in FASTA or FASTQ format.\n  Two binary files are output. The file <index_name>.sma contains the \n  reference sequences in compressed form. The file <index_name>.smi contains\n  the k-mer word index.\n",
    .optdoc=MENU_OPTDOC_INDEX };
// MENU_TASKDOC_MAP
// file menu.c line 455
static const struct TASKDOC_ MENU_TASKDOC_MAP;
// MENU_TASKDOC_MAP
// file menu.c line 455
static const struct TASKDOC_ MENU_TASKDOC_MAP = { .synopsis="  smalt map [OPTIONS] <index_name> <query_file> [<mate_file>]", .description="  Map query reads onto the reference sequences. The reads are provided in\n  FASTA/FASTQ format or in SAM/BAM format in the file <query_file>. If the\n  name of a second file <mate_file> is specified, both files are in\n  FASTA/FASTQ format and reads are mapped in pairs. If <query_file> is in\n  SAM/BAM format, single reads and paired reads can be mixed.\n\n  The reference sequences and k-mer word index are read from the binary\n  files <index_name>.sma and <index_name>.smi which must have been created\n  by the 'index' task (type 'smalt index -H' for help).\n",
    .optdoc=MENU_OPTDOC_MAP };
// MENU_TASKDOC_SAMPLE
// file menu.c line 581
static const struct TASKDOC_ MENU_TASKDOC_SAMPLE;
// MENU_TASKDOC_SAMPLE
// file menu.c line 581
static const struct TASKDOC_ MENU_TASKDOC_SAMPLE = { .synopsis="  smalt sample [OPTIONS] <index_name> <query_file> [<mate_file>]", .description="  Sample insert size distribution for paired reads. A subset of the read\n  pairs is aligned with a reference in order to derrive the distribution of\n  insert sizes. The reference sequences and index are read from the files\n  <index_name>.sma and <index_name>.smi created by the 'index' task (type\n  'smalt index -H' for help).\n",
    .optdoc=MENU_OPTDOC_SAMPLE };
// MENU_USAGE_MAP_HEADER
// file menu.c line 181
static const char MENU_USAGE_MAP_HEADER[642l] = { 'S', 'Y', 'N', 'O', 'P', 'S', 'I', 'S', ':', '\n', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 'm', 'a', 'p', ' ', '[', 'O', 'P', 'T', 'I', 'O', 'N', 'S', ']', ' ', '<', 'i', 'n', 'd', 'e', 'x', '_', 'n', 'a', 'm', 'e', '>', ' ', '<', 'q', 'u', 'e', 'r', 'y', '_', 'f', 'i', 'l', 'e', '>', ' ', '[', '<', 'm', 'a', 't', 'e', '_', 'f', 'i', 'l', 'e', '>', ']', 'D', 'E', 'S', 'C', 'R', 'I', 'P', 'T', 'I', 'O', 'N', ':', '\n', ' ', ' ', 'M', 'a', 'p', ' ', 'q', 'u', 'e', 'r', 'y', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'o', 'n', 't', 'o', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's', '.', ' ', 'T', 'h', 'e', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'a', 'r', 'e', ' ', 'p', 'r', 'o', 'v', 'i', 'd', 'e', 'd', ' ', 'i', 'n', '\n', ' ', ' ', 'F', 'A', 'S', 'T', 'A', '/', 'F', 'A', 'S', 'T', 'Q', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'o', 'r', ' ', 'i', 'n', ' ', 'S', 'A', 'M', '/', 'B', 'A', 'M', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'f', 'i', 'l', 'e', ' ', '<', 'q', 'u', 'e', 'r', 'y', '_', 'f', 'i', 'l', 'e', '>', '.', ' ', 'I', 'f', ' ', 't', 'h', 'e', '\n', ' ', ' ', 'n', 'a', 'm', 'e', ' ', 'o', 'f', ' ', 'a', ' ', 's', 'e', 'c', 'o', 'n', 'd', ' ', 'f', 'i', 'l', 'e', ' ', '<', 'm', 'a', 't', 'e', '_', 'f', 'i', 'l', 'e', '>', ' ', 'i', 's', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ',', ' ', 'b', 'o', 't', 'h', ' ', 'f', 'i', 'l', 'e', 's', ' ', 'a', 'r', 'e', ' ', 'i', 'n', '\n', ' ', ' ', 'F', 'A', 'S', 'T', 'A', '/', 'F', 'A', 'S', 'T', 'Q', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'a', 'r', 'e', ' ', 'm', 'a', 'p', 'p', 'e', 'd', ' ', 'i', 'n', ' ', 'p', 'a', 'i', 'r', 's', '.', ' ', 'I', 'f', ' ', '<', 'q', 'u', 'e', 'r', 'y', '_', 'f', 'i', 'l', 'e', '>', ' ', 'i', 's', ' ', 'i', 'n', '\n', ' ', ' ', 'S', 'A', 'M', '/', 'B', 'A', 'M', ' ', 'f', 'o', 'r', 'm', 'a', 't', ',', ' ', 's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'a', 'n', 'd', ' ', 'p', 'a', 'i', 'r', 'e', 'd', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'm', 'i', 'x', 'e', 'd', '.', '\n', '\n', ' ', ' ', 'T', 'h', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's', ' ', 'a', 'n', 'd', ' ', 'k', '-', 'm', 'e', 'r', ' ', 'w', 'o', 'r', 'd', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'a', 'r', 'e', ' ', 'r', 'e', 'a', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'b', 'i', 'n', 'a', 'r', 'y', '\n', ' ', ' ', 'f', 'i', 'l', 'e', 's', ' ', '<', 'i', 'n', 'd', 'e', 'x', '_', 'n', 'a', 'm', 'e', '>', '.', 's', 'm', 'a', ' ', 'a', 'n', 'd', ' ', '<', 'i', 'n', 'd', 'e', 'x', '_', 'n', 'a', 'm', 'e', '>', '.', 's', 'm', 'i', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'm', 'u', 's', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'b', 'e', 'e', 'n', ' ', 'c', 'r', 'e', 'a', 't', 'e', 'd', '\n', ' ', ' ', 'b', 'y', ' ', 't', 'h', 'e', ' ', '\'', 'i', 'n', 'd', 'e', 'x', '\'', ' ', 't', 'a', 's', 'k', ' ', '(', 't', 'y', 'p', 'e', ' ', '\'', 's', 'm', 'a', 'l', 't', ' ', 'i', 'n', 'd', 'e', 'x', ' ', '-', 'H', '\'', ' ', 'f', 'o', 'r', ' ', 'h', 'e', 'l', 'p', ')', '.', '\n', 0 };
// MENU_USAGE_SUMMARY
// file menu.c line 113
static const char MENU_USAGE_SUMMARY[499l] = { 'S', 'Y', 'N', 'O', 'P', 'S', 'I', 'S', ':', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', '<', 't', 'a', 's', 'k', '>', ' ', '[', 'T', 'A', 'S', 'K', '_', 'O', 'P', 'T', 'I', 'O', 'N', 'S', ']', ' ', '[', '<', 'i', 'n', 'd', 'e', 'x', '_', 'n', 'a', 'm', 'e', '>', ' ', '<', 'f', 'i', 'l', 'e', '_', 'n', 'a', 'm', 'e', '_', 'A', '>', ' ', '[', '<', 'f', 'i', 'l', 'e', '_', 'n', 'a', 'm', 'e', '_', 'B', '>', ']', ']', '\n', '\n', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 't', 'a', 's', 'k', 's', ':', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 'c', 'h', 'e', 'c', 'k', ' ', ' ', ' ', '-', ' ', 'c', 'h', 'e', 'c', 'k', 's', ' ', 'F', 'A', 'S', 'T', 'A', '/', 'F', 'A', 'S', 'T', 'Q', ' ', 'i', 'n', 'p', 'u', 't', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 'h', 'e', 'l', 'p', ' ', ' ', ' ', ' ', '-', ' ', 'p', 'r', 'i', 'n', 't', 's', ' ', 'a', ' ', 'b', 'r', 'i', 'e', 'f', ' ', 's', 'u', 'm', 'm', 'a', 'r', 'y', ' ', 'o', 'f', ' ', 't', 'h', 'i', 's', ' ', 's', 'o', 'f', 't', 'w', 'a', 'r', 'e', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 'i', 'n', 'd', 'e', 'x', ' ', ' ', ' ', '-', ' ', 'b', 'u', 'i', 'l', 'd', 's', ' ', 'a', 'n', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'f', ' ', 'k', '-', 'm', 'e', 'r', ' ', 'w', 'o', 'r', 'd', 's', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 'm', 'a', 'p', ' ', ' ', ' ', ' ', ' ', '-', ' ', 'm', 'a', 'p', 's', ' ', 's', 'i', 'n', 'g', 'l', 'e', ' ', 'o', 'r', ' ', 'p', 'a', 'i', 'r', 'e', 'd', ' ', 'r', 'e', 'a', 'd', 's', ' ', 'o', 'n', 't', 'o', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 's', 'a', 'm', 'p', 'l', 'e', ' ', ' ', '-', ' ', 's', 'a', 'm', 'p', 'l', 'e', ' ', 'i', 'n', 's', 'e', 'r', 't', ' ', 's', 'i', 'z', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i', 'r', 'e', 'd', ' ', 'r', 'e', 'a', 'd', 's', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', '-', ' ', 'p', 'r', 'i', 'n', 't', 's', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', '\n', '\n', 'H', 'e', 'l', 'p', ' ', 'o', 'n', ' ', 'i', 'n', 'd', 'i', 'v', 'i', 'd', 'u', 'a', 'l', ' ', 't', 'a', 's', 'k', 's', ':', '\n', ' ', ' ', ' ', ' ', 's', 'm', 'a', 'l', 't', ' ', '<', 't', 'a', 's', 'k', '>', ' ', '-', 'H', '\n', '\n', 0 };
// MINFRACT_MAXSCOR_2ND
// file rmap.c line 173
static const float MINFRACT_MAXSCOR_2ND = (const float)0.8;
// MINLOGARG
// file results.c line 103
static const double MINLOGARG = 1E-7;
// MINLOGARG$link1
// file resultpairs.c line 121
static const double MINLOGARG$link1 = 1E-7;
// OPTION_TYPSTR
// file menu.c line 79
static const char *OPTION_TYPSTR[5l] = { "", "STR", "INT", "INT,INT", "FLT" };
// OUFMT_ALIGN
// file report.c line 202
static const char OUFMT_ALIGN[78l] = { ' ', ' ', ' ', ' ', 'Q', 'U', 'E', 'R', 'Y', ':', ' ', '%', '1', '0', 'i', ' ', '%', 's', ' ', '%', '-', '1', '0', 'i', '\n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '%', 's', '\n', 'R', 'E', 'F', 'E', 'R', 'E', 'N', 'C', 'E', ':', ' ', '%', '1', '0', 'i', ' ', '%', 's', ' ', '%', '-', '1', '0', 'i', '\n', '\n', '\n', 0 };
// OUFMT_BAM_NULLSTR
// file report.c line 199
static const char OUFMT_BAM_NULLSTR[1l] = { 0 };
// OUFMT_CIGAR
// file report.c line 201
static const char OUFMT_CIGAR[44l] = { 'c', 'i', 'g', 'a', 'r', ':', '%', 'c', ':', '%', '2', '.', '2', 'd', ' ', '%', 's', '%', 's', ' ', '%', 'u', ' ', '%', 'u', ' ', '%', 'c', ' ', '%', 's', ' ', '%', 'u', ' ', '%', 'u', ' ', '+', ' ', '%', 'd', ' ', 0 };
// OUFMT_FILNAM_STDOUT
// file report.c line 184
static const char OUFMT_FILNAM_STDOUT[2l] = { '-', 0 };
// OUFMT_GFF2
// file report.c line 207
static const char OUFMT_GFF2[62l] = { 'g', 'f', 'f', ':', ' ', '%', 's', '%', 's', '\t', 'S', 'M', 'A', 'L', 'T', '\t', 's', 'i', 'm', 'i', 'l', 'a', 'r', 'i', 't', 'y', '\t', '%', 'd', '\t', '%', 'd', '\t', '%', 'd', '\t', '%', 'c', '\t', '.', '\t', 'S', 'u', 'b', 'j', 'e', 'c', 't', ' ', '"', '%', 's', '"', ' ', '%', 'd', ' ', '%', 'd', ';', '\t', 0 };
// OUFMT_GFF2_ALIBLOCK
// file report.c line 210
static const char OUFMT_GFF2_ALIBLOCK[17l] = { ' ', 'A', 'l', 'i', 'g', 'n', ' ', '%', 'd', ' ', '%', 'd', ' ', '%', 'd', ';', 0 };
// OUFMT_GFF2_NULLSTR
// file report.c line 211
static const char OUFMT_GFF2_NULLSTR[1l] = { 0 };
// OUFMT_LISTSEP
// file menu.c line 649
static const char OUFMT_LISTSEP[2l] = { ',', 0 };
// OUFMT_PARSEP
// file menu.c line 648
static const char OUFMT_PARSEP[2l] = { ',', 0 };
// OUFMT_SAM_AFTER
// file report.c line 194
static const char OUFMT_SAM_AFTER[33l] = { '\t', '%', 's', '\t', '%', 'i', '\t', '%', 'i', '\t', '%', 's', '\t', '%', 's', '\t', 'N', 'M', ':', 'i', ':', '%', 'i', '\t', 'A', 'S', ':', 'i', ':', '%', 'i', '\n', 0 };
// OUFMT_SAM_BEFORE
// file report.c line 192
static const char OUFMT_SAM_BEFORE[18l] = { '%', 's', '\t', '%', 'h', 'u', '\t', '%', 's', '\t', '%', 'i', '\t', '%', 'h', 'i', '\t', 0 };
// OUFMT_SAM_NULLSTR
// file report.c line 198
static const char OUFMT_SAM_NULLSTR[2l] = { '*', 0 };
// OUFMT_SSAHA
// file report.c line 206
static const char OUFMT_SSAHA[70l] = { 'a', 'l', 'i', 'g', 'n', 'm', 'e', 'n', 't', ':', '%', 'c', ':', '%', '2', '.', '2', 'd', ' ', '%', '-', '5', 'd', ' ', '%', 's', '%', 's', ' ', '%', 's', ' ', '%', '8', 'u', ' ', '%', '8', 'u', ' ', '%', '9', 'u', ' ', '%', '9', 'u', ' ', ' ', ' ', '%', 'c', ' ', '%', '7', 'd', ' ', '%', '5', '.', '2', 'f', ' ', '%', 'u', ' ', '%', 'u', '\n', 0 };
// OUFMT_TYPSEP
// file menu.c line 647
static const char OUFMT_TYPSEP[2l] = { ':', 0 };
// QUALSCOR_LOGBASE
// file results.c line 104
static const float QUALSCOR_LOGBASE = (const float)2.30259;
// READERRMSG
// file filio.c line 41
static const char READERRMSG[35l] = { 'w', 'h', 'e', 'n', ' ', 'r', 'e', 'a', 'd', 'i', 'n', 'g', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', 'o', 'f', ' ', 'b', 'i', 'n', 'a', 'r', 'y', ' ', 'f', 'i', 'l', 'e', 0 };
// READNAM_MATEXT_FR
// file sequence.c line 98
static const char READNAM_MATEXT_FR[2l][2l] = { { 'F', 0 }, { 'R', 0 } };
// READNAM_MATEXT_ILLUMINA
// file sequence.c line 97
static const char READNAM_MATEXT_ILLUMINA[2l][2l] = { { '1', 0 }, { '2', 0 } };
// READNAM_MATEXT_SEPARATOR
// file sequence.c line 96
static const char READNAM_MATEXT_SEPARATOR[3l] = { (const char)0, (const char)47, (const char)46 };
// SAMBAM_HEADER_VERSION
// file report.c line 180
static const char SAMBAM_HEADER_VERSION[4l] = { '1', '.', '4', 0 };
// SAMBAM_SORTORDER_UNKNOWN
// file report.c line 181
static const char SAMBAM_SORTORDER_UNKNOWN[8l] = { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0 };
// SAMFORM_HEADLINE
// file report.c line 187
static const char SAMFORM_HEADLINE[23l] = { '@', 'H', 'D', '\t', 'V', 'N', ':', '1', '.', '3', '\t', 'S', 'O', ':', 'u', 'n', 'k', 'n', 'o', 'w', 'n', '\n', 0 };
// SAMFORM_PROGLINE
// file report.c line 189
static const char SAMFORM_PROGLINE[26l] = { '@', 'P', 'G', '\t', 'I', 'D', ':', '%', 's', '\t', 'P', 'N', ':', '%', 's', '\t', 'V', 'N', ':', '%', 's', '\t', 'C', 'L', ':', 0 };
// SAMFORM_REFSEQLINE
// file report.c line 188
static const char SAMFORM_REFSEQLINE[17l] = { '@', 'S', 'Q', '\t', 'S', 'N', ':', '%', 's', '\t', 'L', 'N', ':', '%', 'u', '\n', 0 };
// SEQSET_FILNAMEXT
// file sequence.c line 100
static const char SEQSET_FILNAMEXT[4l] = { 's', 'm', 'a', 0 };
// Threads
// file threads.c line 154
static struct _Threads Threads;
// WRITERRMSG
// file filio.c line 40
static const char WRITERRMSG[35l] = { 'w', 'h', 'e', 'n', ' ', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', 'o', 'f', ' ', 'b', 'i', 'n', 'a', 'r', 'y', ' ', 'f', 'i', 'l', 'e', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// _mm_adds_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1041
static inline __gcc_v2di _mm_adds_epi16(__gcc_v2di __A, __gcc_v2di __B)
{
  __gcc_v8hi return_value___builtin_ia32_paddsw128$1;
  return_value___builtin_ia32_paddsw128$1=__builtin_ia32_paddsw128((__gcc_v8hi)__A, (__gcc_v8hi)__B);
  return (__gcc_v2di)return_value___builtin_ia32_paddsw128$1;
}

// _mm_adds_epu8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1047
static inline __gcc_v2di _mm_adds_epu8(__gcc_v2di __A, __gcc_v2di __B)
{
  __gcc_v16qi return_value___builtin_ia32_paddusb128$1;
  return_value___builtin_ia32_paddusb128$1=__builtin_ia32_paddusb128((__gcc_v16qi)__A, (__gcc_v16qi)__B);
  return (__gcc_v2di)return_value___builtin_ia32_paddusb128$1;
}

// _mm_cmpeq_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1298
static inline __gcc_v2di _mm_cmpeq_epi16(__gcc_v2di __A, __gcc_v2di __B)
{
  return (__gcc_v2di)((__gcc_v8hi)__A == (__gcc_v8hi)__B);
}

// _mm_cmpeq_epi8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1292
static inline __gcc_v2di _mm_cmpeq_epi8(__gcc_v2di __A, __gcc_v2di __B)
{
  return (__gcc_v2di)((__gcc_v16qi)__A == (__gcc_v16qi)__B);
}

// _mm_cmpgt_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1334
static inline __gcc_v2di _mm_cmpgt_epi16(__gcc_v2di __A, __gcc_v2di __B)
{
  return (__gcc_v2di)((__gcc_v8hi)__A > (__gcc_v8hi)__B);
}

// _mm_load_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 690
static inline __gcc_v2di _mm_load_si128(const __gcc_v2di *__P)
{
  return *__P;
}

// _mm_max_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1366
static inline __gcc_v2di _mm_max_epi16(__gcc_v2di __A, __gcc_v2di __B)
{
  __gcc_v8hi return_value___builtin_ia32_pmaxsw128$1;
  return_value___builtin_ia32_pmaxsw128$1=__builtin_ia32_pmaxsw128((__gcc_v8hi)__A, (__gcc_v8hi)__B);
  return (__gcc_v2di)return_value___builtin_ia32_pmaxsw128$1;
}

// _mm_max_epu8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1372
static inline __gcc_v2di _mm_max_epu8(__gcc_v2di __A, __gcc_v2di __B)
{
  __gcc_v16qi return_value___builtin_ia32_pmaxub128$1;
  return_value___builtin_ia32_pmaxub128$1=__builtin_ia32_pmaxub128((__gcc_v16qi)__A, (__gcc_v16qi)__B);
  return (__gcc_v2di)return_value___builtin_ia32_pmaxub128$1;
}

// _mm_movemask_epi8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1390
static inline signed int _mm_movemask_epi8(__gcc_v2di __A)
{
  signed int return_value___builtin_ia32_pmovmskb128$1;
  return_value___builtin_ia32_pmovmskb128$1=__builtin_ia32_pmovmskb128((__gcc_v16qi)__A);
  return return_value___builtin_ia32_pmovmskb128$1;
}

// _mm_or_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1280
static inline __gcc_v2di _mm_or_si128(__gcc_v2di __A, __gcc_v2di __B)
{
  return (__gcc_v2di)((unsigned long long int __attribute__((vector_size (2l*sizeof(unsigned long long int)))))__A | (unsigned long long int __attribute__((vector_size (2l*sizeof(unsigned long long int)))))__B);
}

// _mm_setzero_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 753
static inline __gcc_v2di _mm_setzero_si128(void)
{
  return (__gcc_v2di)(__gcc_v4si){ 0, 0, 0, 0 };
}

// _mm_slli_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1137
static inline __gcc_v2di _mm_slli_epi16(__gcc_v2di __A, signed int __B)
{
  __gcc_v8hi return_value___builtin_ia32_psllwi128$1;
  return_value___builtin_ia32_psllwi128$1=__builtin_ia32_psllwi128((__gcc_v8hi)__A, __B);
  return (__gcc_v2di)return_value___builtin_ia32_psllwi128$1;
}

// _mm_store_si128
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 708
static inline void _mm_store_si128(__gcc_v2di *__P, __gcc_v2di __B)
{
  *__P = __B;
}

// _mm_subs_epi16
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1089
static inline __gcc_v2di _mm_subs_epi16(__gcc_v2di __A, __gcc_v2di __B)
{
  __gcc_v8hi return_value___builtin_ia32_psubsw128$1;
  return_value___builtin_ia32_psubsw128$1=__builtin_ia32_psubsw128((__gcc_v8hi)__A, (__gcc_v8hi)__B);
  return (__gcc_v2di)return_value___builtin_ia32_psubsw128$1;
}

// _mm_subs_epu8
// file /usr/lib/gcc/x86_64-linux-gnu/5/include/emmintrin.h line 1095
static inline __gcc_v2di _mm_subs_epu8(__gcc_v2di __A, __gcc_v2di __B)
{
  __gcc_v16qi return_value___builtin_ia32_psubusb128$1;
  return_value___builtin_ia32_psubusb128$1=__builtin_ia32_psubusb128((__gcc_v16qi)__A, (__gcc_v16qi)__B);
  return (__gcc_v2di)return_value___builtin_ia32_psubusb128$1;
}

// addALIMETAtoRsltSet
// file alignment.c line 1277
static signed int addALIMETAtoRsltSet(struct _AliRsltSet *p)
{
  signed int errcode;
  struct _ALIRESULT *arp;
  struct _ALIMETA *mp = &p->meta;
  if((signed int)p->nres >= (signed int)p->n_alloc)
  {
    errcode=reallocRsltSet(p, (signed short int)((signed int)p->nres + 1));
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    arp = p->rsp + (signed long int)p->nres;
    arp->score = mp->score;
    arp->qs = mp->prof_start;
    arp->qe = mp->prof_end;
    arp->rs = mp->nonprof_start;
    arp->re = mp->nonprof_end;
    diffStrReverse(&arp->diffstr, mp->dfs.dstrp);
    p->nres = p->nres + 1;
    return 0;
  }
}

// addCandsFast
// file segment.c line 1140
static signed int addCandsFast(struct _SEGCAND **candr, unsigned int *maxcover, unsigned int *max2ndcover, struct _SEGMENT * const segmr, struct _SEED$0 * const seedr, struct _HITREGION * const hregr, unsigned char *maskp, unsigned int qlen, unsigned char ktup, unsigned char nskip, unsigned char is_reverse, unsigned int mincover, unsigned int mincover_noindel, signed int seqidx)
{
  signed int errcode;
  unsigned int r;
  unsigned int nreg;
  signed int i;
  signed int j;
  unsigned int cover;
  unsigned int cover_new;
  struct _SEGMENT *segmentp;
  struct _SEGMENT *sgp;
  const struct _HITREGION *hitregp;
  struct _SEGCAND *cdp;
  nreg = (unsigned int)((unsigned long int *)hregr)[(signed long int)-1];
  r = (unsigned int)0;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  for( ; !(r >= nreg); r = r + 1u)
  {
    hitregp = hregr + (signed long int)r;
    segmentp = segmr + (signed long int)hitregp->idx;
    i = 0;
    for( ; !(i >= hitregp->num); i = j)
    {
      sgp = segmentp + (signed long int)i;
      signed int l;
      signed int q;
      unsigned char *ucp;
      const struct _SEED$0 *sep = seedr + (signed long int)sgp->ix;
      memset((void *)maskp, 0, (unsigned long int)qlen);
      l = sgp->nseed;
      for( ; l >= 1; sep = sep + 1l)
      {
        ucp = maskp + (signed long int)(sep->sqo & (unsigned long int)2147483647);
        q = 0;
        for( ; !(q >= sep->len); q = q + 1)
          ucp[(signed long int)q] = (unsigned char)1;
        l = l - 1;
      }
      cover = sgp->cover;
      sgp = sgp + 1l;
      j = i + 1;
      for( ; !(j >= hitregp->num); sgp = sgp + 1l)
      {
        if(!(sgp->nseed >= 0))
          break;

        signed int addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$l;
        signed int addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q;
        unsigned char *addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$ucp;
        const struct _SEED$0 *addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$sep = seedr + (signed long int)sgp->ix;
        cover_new = (unsigned int)0;
        addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$l = sgp->nseed;
        for( ; addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$l >= 1; addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$sep = addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$sep + 1l)
        {
          addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$ucp = maskp + (signed long int)(addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$sep->sqo & (unsigned long int)2147483647);
          addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q = 0;
          for( ; !(addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q >= addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$sep->len); addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q = addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q + 1)
            if(addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$ucp[(signed long int)addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q] == 0)
            {
              cover_new = cover_new + 1u;
              addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$ucp[(signed long int)addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$q] = (unsigned char)1;
            }

          addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$l = addCandsFast$$1$$1$$1$$1$$1$$2$$1$$1$$l - 1;
        }
        if(!(cover_new << 1 >= sgp->cover))
        {
          if(cover >= mincover)
            break;

        }

        cover = cover + cover_new;
        j = j + 1;
      }
      if(cover >= mincover)
      {
        if(((unsigned long int *)*candr)[-1l] >= ((unsigned long int *)*candr)[-2l])
        {
          void *return_value_arrayRealloc$1;
          return_value_arrayRealloc$1=arrayRealloc((void *)*candr, (unsigned long int)0, (char)0, "segment.c", 1198);
          cdp = (struct _SEGCAND *)return_value_arrayRealloc$1;
          if(!(cdp == ((struct _SEGCAND *)NULL)))
          {
            *candr = cdp;
            tmp_post$2 = ((unsigned long int *)*candr)[(signed long int)-1];
            ((unsigned long int *)*candr)[(signed long int)-1] = ((unsigned long int *)*candr)[(signed long int)-1] + 1ul;
            cdp = *candr + (signed long int)tmp_post$2;
          }

        }

        else
        {
          tmp_post$3 = ((unsigned long int *)*candr)[(signed long int)-1];
          ((unsigned long int *)*candr)[(signed long int)-1] = ((unsigned long int *)*candr)[(signed long int)-1] + 1ul;
          cdp = *candr + (signed long int)tmp_post$3;
        }
        if(cdp == ((struct _SEGCAND *)NULL))
          return 2;

        errcode=derriveSEGCAND(cdp, i, j - i, segmentp, seedr, ktup, nskip, cover, mincover_noindel, r, is_reverse);
        if(!(errcode == 0))
          return errcode;

        cdp->seqidx = seqidx;
        if(!(*max2ndcover >= cover))
        {
          if(!(*maxcover >= cover))
          {
            *max2ndcover = *maxcover;
            *maxcover = cover;
          }

          else
            if(!(cover == *maxcover))
              *max2ndcover = cover;

        }

      }

    }
  }
  return 0;
}

// addCandsFromSortedSegments
// file segment.c line 1225
static signed int addCandsFromSortedSegments(struct _SEGCAND **candr, struct _SEGMENT *segmr, unsigned int nseg, const unsigned int *segmidx, struct _SEED$0 * const seedr, struct _HITREGION * const hregr, unsigned int hridx, unsigned int mincov_noindel, unsigned char ktup, unsigned char nskip, char is_reverse)
{
  signed int errcode = 0;
  unsigned int i;
  unsigned int sgx;
  struct _SEGMENT *sgp;
  struct _SEGCAND *cdp;
  i = nseg;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  for( ; i >= 1u; i = i - 1u)
  {
    sgx = segmidx[(signed long int)(i - (unsigned int)1)];
    sgp = segmr + (signed long int)sgx;
    if(sgp->nseed >= 1)
    {
      if(((unsigned long int *)*candr)[-1l] >= ((unsigned long int *)*candr)[-2l])
      {
        void *return_value_arrayRealloc$1;
        return_value_arrayRealloc$1=arrayRealloc((void *)*candr, (unsigned long int)0, (char)0, "segment.c", 1261);
        cdp = (struct _SEGCAND *)return_value_arrayRealloc$1;
        if(!(cdp == ((struct _SEGCAND *)NULL)))
        {
          *candr = cdp;
          tmp_post$2 = ((unsigned long int *)*candr)[(signed long int)-1];
          ((unsigned long int *)*candr)[(signed long int)-1] = ((unsigned long int *)*candr)[(signed long int)-1] + 1ul;
          cdp = *candr + (signed long int)tmp_post$2;
        }

      }

      else
      {
        tmp_post$3 = ((unsigned long int *)*candr)[(signed long int)-1];
        ((unsigned long int *)*candr)[(signed long int)-1] = ((unsigned long int *)*candr)[(signed long int)-1] + 1ul;
        cdp = *candr + (signed long int)tmp_post$3;
      }
      if(cdp == ((struct _SEGCAND *)NULL))
        return 2;

      calcSegmentBoundaries(&cdp->qs, &cdp->qe, &cdp->rs, &cdp->re, sgp, seedr, ktup, nskip, (unsigned char)is_reverse);
      if(!(is_reverse == 0))
        cdp->flag = (unsigned char)1;

      cdp->shiftoffs = (signed short int)0;
      cdp->shift2mm = cdp->shiftoffs;
      cdp->srange = (signed short int)0;
      cdp->cover = sgp->cover;
      if(sgp->cover >= mincov_noindel)
        cdp->flag = cdp->flag | (unsigned char)4;

      cdp->segix = sgx;
      cdp->nseg = 1;
      cdp->hregix = hridx;
      cdp->seqidx = -1;
      sgp->nseed = sgp->nseed * -1;
      errcode=extendCand(cdp, segmr, hregr, seedr, ktup, nskip);
      if(!(errcode == 0))
        return errcode;

    }

  }
  return errcode;
}

// addNoIndelCandsFromSegmentSeeds
// file segment.c line 1284
static signed int addNoIndelCandsFromSegmentSeeds(struct _SEGCAND **candr, unsigned int *max_cover, struct _SEGMENT *segmr, struct _SEED$0 * const seedr, struct _HITREGION * const hregr, unsigned int mincover, unsigned char ktup, unsigned char nskip, char is_reverse)
{
  signed int s;
  signed int nseg = (signed int)((unsigned long int *)hregr)[(signed long int)-1];
  unsigned int i;
  unsigned int end_i;
  unsigned int cover;
  struct _SEGCAND *cdp;
  s = 0;
  _Bool tmp_if_expr$1;
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$4;
  for( ; !(s >= nseg); s = s + 1)
  {
    i = (hregr + (signed long int)s)->idx;
    end_i = i + (unsigned int)(hregr + (signed long int)s)->num;
    for( ; !(i >= end_i); i = i + 1u)
    {
      cover = (segmr + (signed long int)i)->cover;
      if(!(cover >= mincover))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (segmr + (signed long int)i)->nseed < 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$1)
      {
        if(!(*max_cover >= cover))
          *max_cover = cover;

        if(((unsigned long int *)*candr)[-1l] >= ((unsigned long int *)*candr)[-2l])
        {
          void *return_value_arrayRealloc$2;
          return_value_arrayRealloc$2=arrayRealloc((void *)*candr, (unsigned long int)0, (char)0, "segment.c", 1308);
          cdp = (struct _SEGCAND *)return_value_arrayRealloc$2;
          if(!(cdp == ((struct _SEGCAND *)NULL)))
          {
            *candr = cdp;
            tmp_post$3 = ((unsigned long int *)*candr)[(signed long int)-1];
            ((unsigned long int *)*candr)[(signed long int)-1] = ((unsigned long int *)*candr)[(signed long int)-1] + 1ul;
            cdp = *candr + (signed long int)tmp_post$3;
          }

        }

        else
        {
          tmp_post$4 = ((unsigned long int *)*candr)[(signed long int)-1];
          ((unsigned long int *)*candr)[(signed long int)-1] = ((unsigned long int *)*candr)[(signed long int)-1] + 1ul;
          cdp = *candr + (signed long int)tmp_post$4;
        }
        if(cdp == ((struct _SEGCAND *)NULL))
          return 2;

        calcSegmentBoundaries(&cdp->qs, &cdp->qe, &cdp->rs, &cdp->re, segmr + (signed long int)i, seedr, ktup, nskip, (unsigned char)is_reverse);
        if(!(is_reverse == 0))
          cdp->flag = (unsigned char)1;

        cdp->shiftoffs = (signed short int)0;
        cdp->srange = (signed short int)0;
        cdp->cover = cover;
        cdp->segix = i;
        cdp->nseg = 1;
        cdp->hregix = (unsigned int)s;
        cdp->seqidx = -1;
        (segmr + (signed long int)i)->nseed = (segmr + (signed long int)i)->nseed * -1;
      }

    }
  }
  return 0;
}

// addPairResultsToReport
// file resultpairs.c line 1008
static signed int addPairResultsToReport(struct _Report *rep, const unsigned char mapflg, unsigned char repmateflg, const struct _RESULT *rp, signed short int mapqA, const struct _ResultSet *rsrp, const struct _RESULT *mp, signed short int mapqB, const struct _ResultSet *rsmp)
{
  signed int errcode;
  signed int isize = 0;
  signed int pairID;
  pairID=reportNextPairID(rep);
  unsigned char reppairflg = (unsigned char)0;
  unsigned char rmAflg;
  unsigned char rmBflg;
  unsigned short int return_value_resultGetStatusFlag$2;
  unsigned short int return_value_resultGetStatusFlag$1;
  if(!(pairID >= 0))
    return 2;

  else
  {
    repmateflg = repmateflg | (unsigned char)4;
    if(!((1 & (signed int)mapflg) == 0) && !(mp == ((const struct _RESULT *)NULL)) && !(rp == ((const struct _RESULT *)NULL)))
    {
      return_value_resultGetStatusFlag$2=resultGetStatusFlag(rp);
      if((16 & (signed int)return_value_resultGetStatusFlag$2) == 0)
      {
        return_value_resultGetStatusFlag$1=resultGetStatusFlag(mp);
        if((16 & (signed int)return_value_resultGetStatusFlag$1) == 0)
        {
          reppairflg = reppairflg | (unsigned char)1;
          if(!((2 & (signed int)mapflg) == 0))
          {
            reppairflg = reppairflg | (unsigned char)2;
            resultCalcInsertSize(&isize, (unsigned char)1, rp, mp);
            if(!((8 & (signed int)mapflg) == 0))
              reppairflg = reppairflg | (unsigned char)8;

            if(!((4 & (signed int)mapflg) == 0))
              reppairflg = reppairflg | (unsigned char)4;

          }

        }

      }

    }

    rmAflg = (unsigned char)((signed int)repmateflg & ~8);
    if(!((32 & (signed int)mapflg) == 0))
      rmAflg = rmAflg | (unsigned char)64;

    errcode=resultSetAddResultToReport(rep, pairID, mapqA, rmAflg, reppairflg, isize, rp, rsrp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      rmBflg = (unsigned char)((signed int)repmateflg | 8);
      if(!((64 & (signed int)mapflg) == 0))
        rmBflg = rmBflg | (unsigned char)64;

      errcode=resultSetAddResultToReport(rep, pairID, mapqB, rmBflg, reppairflg, isize, mp, rsmp);
      if(!(errcode == 0))
        return errcode;

      else
        return 0;
    }
  }
}

// aliBufferCreate
// file alibuffer.h line 46
struct _AliBuffer * aliBufferCreate(signed int blocksiz)
{
  struct _AliBuffer *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _AliBuffer) /*72ul*/ , "alibuffer.c", 52);
  p = (struct _AliBuffer *)return_value_ecalloc$1;
  if(p == ((struct _AliBuffer *)NULL))
    return ((struct _AliBuffer *)NULL);

  else
  {
    if(!(blocksiz >= 1))
      blocksiz = 256;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blocksiz, sizeof(unsigned char) /*1ul*/ , "alibuffer.c", 57);
    p->datap = (unsigned char *)return_value_ecalloc$2;
    if(p->datap == ((unsigned char *)NULL))
    {
      aliBufferDelete(p);
      return ((struct _AliBuffer *)NULL);
    }

    else
    {
      p->allocsiz = (unsigned long int)blocksiz;
      p->blocksiz = blocksiz;
      p->qlen_max = 0;
      return p;
    }
  }
}

// aliBufferDelete
// file alibuffer.h line 52
void aliBufferDelete(struct _AliBuffer *p)
{
  if(!(p == ((struct _AliBuffer *)NULL)))
    free((void *)p->datap);

  free((void *)p);
}

// aliBufferInit
// file alibuffer.h line 56
signed int aliBufferInit(struct _AliBuffer *p, unsigned int qlen)
{
  unsigned int newlen;
  unsigned long int siz;
  unsigned long int newsiz;
  signed int nvec;
  const signed int nvecelem = 8;
  if((unsigned int)p->qlen_max >= qlen)
    return 0;

  else
    if(qlen >= 2147483648u)
      return 36;

    else
    {
      newlen = ((qlen + (unsigned int)p->blocksiz) - (unsigned int)1) / (unsigned int)p->blocksiz;
      newlen = newlen * (unsigned int)p->blocksiz;
      if(newlen >= 2147483648u)
        newlen = (unsigned int)0x7fffffff;

      siz = ((unsigned long int)(15 + 1) + (unsigned long int)(newlen + (unsigned int)1) * sizeof(signed int) /*4ul*/ ) * (unsigned long int)2;
      nvec = (signed int)(((newlen + (unsigned int)nvecelem) - (unsigned int)1) / (unsigned int)nvecelem);
      newsiz = (unsigned long int)(1 + 3 * nvec) * sizeof(__gcc_v2di) /*16ul*/ ;
      if(!(siz >= newsiz))
        siz = newsiz;

      if(!(p->allocsiz >= siz))
      {
        void *hp;
        newsiz = ((siz + (unsigned long int)p->blocksiz) - (unsigned long int)1) / (unsigned long int)p->blocksiz;
        newsiz = newsiz * (unsigned long int)p->blocksiz;
        hp=erealloc((void *)p->datap, newsiz * sizeof(unsigned char) /*1ul*/ , (unsigned long int)0, "alibuffer.c", 120);
        if(hp == NULL)
          return 2;

        p->datap = (unsigned char *)hp;
        p->allocsiz = newsiz;
      }

      p->baseHp = (signed int *)((unsigned long int)p->datap + (unsigned long int)15 & ~((unsigned long int)15));
      p->baseEp = p->baseHp + (signed long int)newlen + (signed long int)1;
      p->baseEp = (signed int *)((unsigned long int)p->baseEp + (unsigned long int)15 & ~((unsigned long int)15));
      p->H1v = (__gcc_v2di *)((unsigned long int)p->datap + (unsigned long int)15 & ~((unsigned long int)15));
      p->H2v = p->H1v + (signed long int)nvec;
      p->Ev = p->H2v + (signed long int)nvec;
      p->qlen_max = (signed int)newlen;
      return 0;
    }
}

// aliRsltSetCreate
// file alignment.h line 86
struct _AliRsltSet * aliRsltSetCreate(const struct _ScoreMatrix *smp, signed short int blksz, signed short int diffblksz, signed int track_blksz, signed int track_thresh)
{
  signed int errcode = 0;
  signed short int i;
  struct _AliRsltSet *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _AliRsltSet) /*120ul*/ , "alignment.c", 1448);
  p = (struct _AliRsltSet *)return_value_ecalloc$1;
  _Bool tmp_if_expr$3;
  if(p == ((struct _AliRsltSet *)NULL))
    return (struct _AliRsltSet *)(void *)0;

  else
  {
    if(!((signed int)blksz >= 1))
      blksz = (signed short int)16;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blksz, sizeof(struct _ALIRESULT) /*48ul*/ , "alignment.c", 1454);
    p->rsp = (struct _ALIRESULT *)return_value_ecalloc$2;
    if(p->rsp == ((struct _ALIRESULT *)NULL))
    {
      aliRsltSetDelete(p);
      return ((struct _AliRsltSet *)NULL);
    }

    else
    {
      i = (signed short int)0;
      for( ; !((signed int)i >= (signed int)blksz); i = i + 1)
      {
        errcode=diffStrInit(&(p->rsp + (signed long int)i)->diffstr, (signed int)diffblksz);
        if(!(errcode == 0))
          break;

      }
      if(!(errcode == 0))
      {
        aliRsltSetDelete(p);
        return ((struct _AliRsltSet *)NULL);
      }

      else
      {
        p->blksz = blksz;
        p->n_alloc = p->blksz;
        if(!(smp == ((const struct _ScoreMatrix *)NULL)))
        {
          p->cplxp=createALICPLX(smp);
          if(p->cplxp == ((struct _ALICPLX *)NULL))
          {
            aliRsltSetDelete(p);
            return ((struct _AliRsltSet *)NULL);
          }

        }

        else
          p->cplxp = ((struct _ALICPLX *)NULL);
        errcode=initALITRACK(&p->track, (unsigned long int)track_blksz, (unsigned long int)track_thresh);
        if(!(errcode == 0))
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          errcode=initALIMETA(&p->meta, diffblksz);
          tmp_if_expr$3 = errcode != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          aliRsltSetDelete(p);
          p = ((struct _AliRsltSet *)NULL);
        }

        return p;
      }
    }
  }
}

// aliRsltSetDelete
// file alignment.h line 102
void aliRsltSetDelete(struct _AliRsltSet *p)
{
  signed short int i;
  if(!(p == ((struct _AliRsltSet *)NULL)))
  {
    deleteALICPLX(p->cplxp);
    p->cplxp = ((struct _ALICPLX *)NULL);
    cleanupALIMETA(&p->meta);
    cleanupALITRACK(&p->track);
    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)p->n_alloc); i = i + 1)
      diffStrCleanUp(&(p->rsp + (signed long int)i)->diffstr);
    free((void *)p->rsp);
  }

  free((void *)p);
}

// aliRsltSetFetchData
// file alignment.h line 114
signed int aliRsltSetFetchData(const struct _AliRsltSet *arp, signed short int idx, signed int *score, signed int *ps_start, signed int *ps_end, signed int *us_start, signed int *us_end, const struct _DiffStr **dfsp)
{
  const struct _ALIRESULT *rp;
  if((signed int)idx >= (signed int)arp->nres)
    return -1;

  else
  {
    rp = arp->rsp + (signed long int)idx;
    if(!(score == ((signed int *)NULL)))
      *score = rp->score;

    if(!(ps_start == ((signed int *)NULL)))
      *ps_start = rp->qs;

    if(!(ps_end == ((signed int *)NULL)))
      *ps_end = rp->qe;

    if(!(us_start == ((signed int *)NULL)))
      *us_start = rp->rs;

    if(!(us_end == ((signed int *)NULL)))
      *us_end = rp->re;

    if(!(dfsp == ((const struct _DiffStr **)NULL)))
      *dfsp = &rp->diffstr;

    return 0;
  }
}

// aliRsltSetGetSize
// file alignment.h line 110
signed short int aliRsltSetGetSize(const struct _AliRsltSet *arp)
{
  return arp->nres;
}

// aliRsltSetReset
// file alignment.h line 106
void aliRsltSetReset(struct _AliRsltSet *p)
{
  signed short int i = (signed short int)0;
  for( ; !((signed int)p->nres >= (signed int)i); i = i + 1)
    (p->rsp + (signed long int)i)->diffstr.len = 0;
  p->nres = (signed short int)0;
  blankALICPLX(p->cplxp);
}

// aliScoreDiffStr
// file alignment.h line 67
signed int aliScoreDiffStr(signed int *swscor, const char *unprofiled_seqp, signed int unprofiled_seqlen, unsigned int profiled_offs, const unsigned char *diffstrp, signed int diffstrlen, const struct _ScoreProfile *scpp)
{
  signed int i;
  unsigned int profiled_len;
  signed int rs;
  signed char gap_init;
  signed char gap_ext;
  unsigned char is_open = (unsigned char)0;
  unsigned char j;
  unsigned char count;
  unsigned char typ;
  signed char * const *scorepp;
  scorepp=scoreGetProfile((signed short int *)(void *)0, &profiled_len, &gap_init, &gap_ext, scpp);
  *swscor = 0;
  rs = 0;
  i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  signed int tmp_post$4;
  unsigned int tmp_post$5;
  do
  {
    if(!(i >= diffstrlen))
      tmp_if_expr$1 = diffstrp[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    typ = (unsigned char)((signed int)diffstrp[(signed long int)i] >> 6);
    count = (unsigned char)((signed int)diffstrp[(signed long int)i] & 63);
    if((signed int)typ == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if((signed int)typ == 3)
        tmp_if_expr$2 = diffstrp[(signed long int)(i + 1)] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      count = count + 1;

    if((signed int)count >= 1)
    {
      is_open = (unsigned char)0;
      j = (unsigned char)0;
      for( ; !((signed int)j >= (signed int)count); j = j + 1)
      {
        tmp_post$4 = rs;
        rs = rs + 1;
        tmp_post$5 = profiled_offs;
        profiled_offs = profiled_offs + 1u;
        *swscor = *swscor + (signed int)scorepp[(signed long int)((signed int)unprofiled_seqp[(signed long int)tmp_post$4] & 7)][(signed long int)tmp_post$5];
        if(!(unprofiled_seqlen >= rs) || !(profiled_len >= profiled_offs))
          return 47;

      }
    }

    if((signed int)typ == 1 || (signed int)typ == 2)
    {
      if(!(is_open == 0))
        *swscor = *swscor - (signed int)gap_ext;

      else
      {
        *swscor = *swscor - (signed int)gap_init;
        is_open = (unsigned char)1;
      }
      if((signed int)typ == 2)
      {
        profiled_offs = profiled_offs + 1u;
        if(!(profiled_len >= profiled_offs))
          return 47;

      }

      else
      {
        rs = rs + 1;
        if(!(unprofiled_seqlen >= rs))
          return 47;

      }
    }

    i = i + 1;
  }
  while((_Bool)1);
  return diffstrp[(signed long int)i] != 0 ? 59 : 0;
}

// aliSmiWatInBand
// file alignment.h line 134
signed int aliSmiWatInBand(struct _AliRsltSet *rssp, struct _AliBuffer *bufp, const struct _ScoreProfile *profp, const char *unprofiled_seqp, signed int unprofiled_seqlen, signed int l_edge, signed int r_edge, signed int profiled_left, signed int profiled_right, signed int unprofiled_left, signed int unprofiled_right, signed int minscore, signed int minscorlen)
{
  unsigned int qlen;
  signed short int matchscor;
  matchscor=scoreProfileGetAvgPenalties((signed short int *)(void *)0, (signed short int *)(void *)0, (signed short int *)(void *)0, profp);
  if(!(minscore >= 1) || !((signed int)matchscor >= 1))
    return 47;

  else
  {
    if(!(minscorlen * (signed int)matchscor >= minscore))
      minscorlen = minscore / (signed int)matchscor;

    if(!(minscorlen >= 5))
      return 47;

    else
    {
      scoreGetProfile((signed short int *)(void *)0, &qlen, (signed char *)(void *)0, (signed char *)(void *)0, profp);
      if(qlen >= 2147483648u)
        return 36;

      else
      {
        signed int return_value_alignSmiWatBandRecursive$1;
        return_value_alignSmiWatBandRecursive$1=alignSmiWatBandRecursive(rssp, bufp, profp, (signed int)qlen, unprofiled_seqp, unprofiled_seqlen, l_edge, r_edge, profiled_left, profiled_right, unprofiled_left, unprofiled_right, minscore, minscorlen);
        return return_value_alignSmiWatBandRecursive$1;
      }
    }
  }
}

// aliSmiWatInBandFast
// file alignment.h line 164
signed int aliSmiWatInBandFast(signed int *maxswscor, struct _AliBuffer *bufp, const struct _ScoreProfile *profp, const char *unprofiled_seqp, signed int unprofiled_seqlen, signed int l_edge, signed int r_edge, signed int profiled_left, signed int profiled_right, signed int unprofiled_left, signed int unprofiled_right)
{
  signed int errcode;
  unsigned int qlen;
  struct _ALIBAND band;
  scoreGetProfile((signed short int *)(void *)0, &qlen, (signed char *)(void *)0, (signed char *)(void *)0, profp);
  errcode=initALIBAND(&band, l_edge, r_edge, profiled_left, profiled_right, (signed int)qlen, unprofiled_left, unprofiled_right, unprofiled_seqlen);
  if(!(errcode == 0))
    return errcode;

  else
  {
    errcode=alignSmiWatBandFast(maxswscor, bufp, &band, profp, unprofiled_seqp);
    return errcode;
  }
}

// alignRMAPCANDFull
// file rmap.c line 790
static signed int alignRMAPCANDFull(struct _ResultSet *rsp, struct _AliRsltSet *alirsp, struct _AliBuffer *alibufp, struct _SeqFastq *sqbufp, signed int min_swatscor, signed int scorlen_min, signed int bandwidth_min, unsigned short int rmapflag, const struct _ScoreProfile *profp, const struct _ScoreProfile *profRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, struct RMAPCAND_ * const candr)
{
  signed int i;
  signed int errcode = 0;
  signed int band_l;
  signed int band_r;
  signed int bw;
  const char *unprofiled_seqp;
  const signed int scrlen = (const signed int)((unsigned long int *)candr)[(signed long int)-1];
  unsigned int unprofiled_seqlen;
  unsigned int profiled_seqlen;
  unsigned long int rs;
  unsigned long int re;
  signed int swatscor_2ndmax = 0;
  i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  signed long int tmp_if_expr$5;
  for( ; !(i >= scrlen); i = i + 1)
  {
    const struct _ScoreProfile *scprofp = (const struct _ScoreProfile *)(void *)0;
    struct RMAPCAND_ *cp = candr + (signed long int)i;
    if(!((2 & (signed int)cp->flags) == 0))
    {
      if(cp->swscor >= min_swatscor)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(cp->re >= cp->rs))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = cp->re - cp->rs > (unsigned long int)0x7fffffff ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        return 48;

      re = cp->re;
      rs = cp->rs;
      if(cp->sqidx == -1l)
      {
        errcode=seqSetFetchSegment(sqbufp, &rs, &re, ssp, codecp);
        if(!(errcode == 0))
          return errcode;

        cp->rs = rs;
        cp->re = re;
      }

      else
      {
        errcode=seqSetFetchSegmentBySequence(sqbufp, cp->sqidx, (unsigned int)rs, (unsigned int)((re - rs) + (unsigned long int)1), ssp, codecp);
        if(!(errcode == 0))
          return errcode;

      }
      errcode=seqFastqEncode(sqbufp, codecp);
      if(!(errcode == 0))
        return errcode;

      if(!((1 & (signed int)cp->flags) == 0))
        scprofp = profRCp;

      else
        scprofp = profp;
      unprofiled_seqp=seqFastqGetConstSequence(sqbufp, &unprofiled_seqlen, (char *)(void *)0);
      scoreGetProfile((signed short int *)(void *)0, &profiled_seqlen, (signed char *)(void *)0, (signed char *)(void *)0, scprofp);
      if(unprofiled_seqlen >= 2147483648u)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (unsigned long int)unprofiled_seqlen != (cp->re - cp->rs) + (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = cp->qs > cp->qe ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = cp->qe >= profiled_seqlen ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        return 47;

      if(!((2 & (signed int)rmapflag) == 0))
      {
        resultSetGetMaxSwat(rsp, &swatscor_2ndmax);
        if(!(min_swatscor >= swatscor_2ndmax))
          min_swatscor = swatscor_2ndmax;

      }

      aliRsltSetReset(alirsp);
      bw = cp->band_r - cp->band_l;
      if(!(bw >= bandwidth_min))
      {
        bw = ((bandwidth_min - bw) + 1) / 2;
        band_l = cp->band_l - bw;
        band_r = cp->band_r + bw;
      }

      else
      {
        band_l = cp->band_l;
        band_r = cp->band_r;
      }
      errcode=aliSmiWatInBand(alirsp, alibufp, scprofp, unprofiled_seqp, (signed int)unprofiled_seqlen, band_l, band_r, (signed int)cp->qs, (signed int)cp->qe, 0, (signed int)unprofiled_seqlen - 1, min_swatscor, scorlen_min);
      if(errcode == 0)
      {
        if(cp->sqidx == -1l)
          tmp_if_expr$5 = (signed long int)-1;

        else
          tmp_if_expr$5 = cp->sqidx;
        errcode=resultSetAddFromAli(rsp, alirsp, (unsigned int)cp->rs, (unsigned int)0, profiled_seqlen, tmp_if_expr$5, (char)((signed int)cp->flags & 1));
      }

      if(!(errcode == 0))
        break;

    }
  }
  return errcode;
}

// alignSmiWatBand
// file alignment.c line 788
static signed int alignSmiWatBand(struct _ALITRACK *bktp, struct _AliBuffer *bufp, const struct _ALIBAND *bandp, const struct _ScoreProfile *profp, const char *usqp)
{
  signed int errcode;
  signed int delta_band_start;
  signed int delta_band_end;
  signed int i;
  signed int j;
  signed int j_curr_start;
  signed int j_curr_len;
  signed int max_i = 0;
  signed int max_j = 0;
  signed int max_scor = 0;
  const signed char *rowscorp;
  signed char * const *scorpp;
  signed char gap_ext;
  signed char gap_init;
  unsigned char *dirp;
  signed int H;
  signed int F;
  signed int tmp;
  signed int currH;
  signed int *Hp;
  signed int *Ep;
  scorpp=scoreGetProfile((signed short int *)(void *)0, (unsigned int *)(void *)0, &gap_init, &gap_ext, profp);
  signed int tmp_post$1;
  if(bandp->q_len >= bufp->qlen_max)
  {
    errcode=aliBufferInit(bufp, (unsigned int)bandp->q_len);
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(bandp->l_edge >= bandp->q_left))
    {
      delta_band_start = bandp->q_left - bandp->l_edge;
      j_curr_start = bandp->q_left;
    }

    else
    {
      delta_band_start = 0;
      j_curr_start = bandp->l_edge;
    }
    j_curr_len = bandp->r_edge + 1;
    delta_band_end = 0;
    currH = 0;
    H = currH;
    dirp = bktp->bdp + (signed long int)delta_band_start;
    Hp = bufp->baseHp;
    Ep = bufp->baseEp;
    j = j_curr_start;
    for( ; !(j >= bandp->q_len); j = j + 1)
    {
      Ep[(signed long int)j] = 0;
      Hp[(signed long int)j] = Ep[(signed long int)j];
    }
    i = bandp->s_left;
    for( ; !(i >= bandp->s_len); i = i + 1)
    {
      F = 0;
      rowscorp = scorpp[(signed long int)((signed int)usqp[(signed long int)i] & 7)];
      j = j_curr_start;
      for( ; !(j >= j_curr_len); dirp = dirp + 1l)
      {
        H = currH + (signed int)rowscorp[(signed long int)j];
        currH = Hp[(signed long int)j];
        if(F >= 1)
        {
          if(Ep[(signed long int)j] >= 1)
          {
            if(!(Ep[(signed long int)j] >= H))
            {
              if(!(F >= H))
              {
                Hp[(signed long int)j] = H;
                F = F - (signed int)gap_ext;
                Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
                *dirp = (unsigned char)3;
                if(!((signed int)gap_init >= H))
                {
                  if(!(max_scor >= H))
                  {
                    max_i = i;
                    max_j = j;
                    max_scor = H;
                  }

                  tmp = H - (signed int)gap_init;
                  if(!(F >= tmp))
                    F = tmp;

                  if(!(Ep[(signed long int)j] >= tmp))
                    Ep[(signed long int)j] = tmp;

                }

              }

              else
              {
                Hp[(signed long int)j] = F;
                F = F - (signed int)gap_ext;
                Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
                *dirp = (unsigned char)2;
              }
            }

            else
            {
              if(Ep[(signed long int)j] >= F)
              {
                Hp[(signed long int)j] = Ep[(signed long int)j];
                *dirp = (unsigned char)1;
              }

              else
              {
                Hp[(signed long int)j] = F;
                *dirp = (unsigned char)2;
              }
              Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
              F = F - (signed int)gap_ext;
            }
          }

          else
            if(!(F >= H))
            {
              Hp[(signed long int)j] = H;
              F = F - (signed int)gap_ext;
              *dirp = (unsigned char)3;
              if(!((signed int)gap_init >= H))
              {
                if(!(max_scor >= H))
                {
                  max_i = i;
                  max_j = j;
                  max_scor = H;
                }

                Ep[(signed long int)j] = H - (signed int)gap_init;
                if(!(F >= Ep[(signed long int)j]))
                  F = Ep[(signed long int)j];

              }

            }

            else
            {
              Hp[(signed long int)j] = F;
              F = F - (signed int)gap_ext;
              *dirp = (unsigned char)2;
            }
        }

        else
          if(Ep[(signed long int)j] >= 1)
          {
            if(!(Ep[(signed long int)j] >= H))
            {
              Hp[(signed long int)j] = H;
              Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
              *dirp = (unsigned char)3;
              if(!((signed int)gap_init >= H))
              {
                if(!(max_scor >= H))
                {
                  max_i = i;
                  max_j = j;
                  max_scor = H;
                }

                F = H - (signed int)gap_init;
                if(!(Ep[(signed long int)j] >= F))
                  Ep[(signed long int)j] = F;

              }

            }

            else
            {
              Hp[(signed long int)j] = Ep[(signed long int)j];
              Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
              *dirp = (unsigned char)1;
            }
          }

          else
            if(H >= 1)
            {
              Hp[(signed long int)j] = H;
              *dirp = (unsigned char)3;
              if(!((signed int)gap_init >= H))
              {
                if(!(max_scor >= H))
                {
                  max_i = i;
                  max_j = j;
                  max_scor = H;
                }

                Ep[(signed long int)j] = H - (signed int)gap_init;
                F = Ep[(signed long int)j];
              }

            }

            else
            {
              Hp[(signed long int)j] = 0;
              *dirp = (unsigned char)0;
            }
        j = j + 1;
      }
      if(delta_band_start >= 1)
      {
        currH = 0;
        delta_band_start = delta_band_start - 1;
        dirp = dirp + (signed long int)delta_band_start;
      }

      else
      {
        currH = Hp[(signed long int)j_curr_start];
        j_curr_start = j_curr_start + 1;
      }
      if(!(j_curr_len >= bandp->q_len))
        j_curr_len = j_curr_len + 1;

      else
      {
        tmp_post$1 = delta_band_end;
        delta_band_end = delta_band_end + 1;
        dirp = dirp + (signed long int)tmp_post$1;
      }
    }
    bktp->max_i = max_i;
    bktp->max_j = max_j;
    bktp->max_scor = max_scor;
    return 0;
  }
}

// alignSmiWatBandFast
// file alignment.c line 1029
static signed int alignSmiWatBandFast(signed int *maxswscor, struct _AliBuffer * const bufp, const struct _ALIBAND * const bandp, const struct _ScoreProfile * const profp, const char * const usqp)
{
  signed int errcode;
  signed int delta_band_start;
  signed int i;
  signed int j;
  signed int j_curr_start;
  signed int j_curr_len;
  signed int max_scor = 0;
  const signed char *rowscorp;
  signed char * const *scorpp;
  signed char gap_ext;
  signed char gap_init;
  signed int H;
  signed int F;
  signed int tmp;
  signed int currH;
  signed int *Hp;
  signed int *Ep;
  *maxswscor = 0;
  scorpp=scoreGetProfile((signed short int *)(void *)0, (unsigned int *)(void *)0, &gap_init, &gap_ext, profp);
  if(bandp->q_len >= bufp->qlen_max)
  {
    errcode=aliBufferInit(bufp, (unsigned int)bandp->q_len);
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(bandp->l_edge >= bandp->q_left))
    {
      delta_band_start = bandp->q_left - bandp->l_edge;
      j_curr_start = bandp->q_left;
    }

    else
    {
      delta_band_start = 0;
      j_curr_start = bandp->l_edge;
    }
    j_curr_len = bandp->r_edge + 1;
    currH = 0;
    H = currH;
    Hp = bufp->baseHp;
    Ep = bufp->baseEp;
    j = j_curr_start;
    for( ; !(j >= bandp->q_len); j = j + 1)
    {
      Ep[(signed long int)j] = 0;
      Hp[(signed long int)j] = Ep[(signed long int)j];
    }
    i = bandp->s_left;
    for( ; !(i >= bandp->s_len); i = i + 1)
    {
      F = 0;
      rowscorp = scorpp[(signed long int)((signed int)usqp[(signed long int)i] & 7)];
      j = j_curr_start;
      for( ; !(j >= j_curr_len); j = j + 1)
      {
        H = currH + (signed int)rowscorp[(signed long int)j];
        currH = Hp[(signed long int)j];
        if(F >= 1)
        {
          if(Ep[(signed long int)j] >= 1)
          {
            if(!(Ep[(signed long int)j] >= H))
            {
              if(!(F >= H))
              {
                Hp[(signed long int)j] = H;
                F = F - (signed int)gap_ext;
                Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
                if(!((signed int)gap_init >= H))
                {
                  if(!(max_scor >= H))
                    max_scor = H;

                  tmp = H - (signed int)gap_init;
                  if(!(F >= tmp))
                    F = tmp;

                  if(!(Ep[(signed long int)j] >= tmp))
                    Ep[(signed long int)j] = tmp;

                }

              }

              else
              {
                Hp[(signed long int)j] = F;
                F = F - (signed int)gap_ext;
                Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
              }
            }

            else
            {
              if(Ep[(signed long int)j] >= F)
                Hp[(signed long int)j] = Ep[(signed long int)j];

              else
                Hp[(signed long int)j] = F;
              Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
              F = F - (signed int)gap_ext;
            }
          }

          else
            if(!(F >= H))
            {
              Hp[(signed long int)j] = H;
              F = F - (signed int)gap_ext;
              if(!((signed int)gap_init >= H))
              {
                if(!(max_scor >= H))
                  max_scor = H;

                Ep[(signed long int)j] = H - (signed int)gap_init;
                if(!(F >= Ep[(signed long int)j]))
                  F = Ep[(signed long int)j];

              }

            }

            else
            {
              Hp[(signed long int)j] = F;
              F = F - (signed int)gap_ext;
            }
        }

        else
          if(Ep[(signed long int)j] >= 1)
          {
            if(!(Ep[(signed long int)j] >= H))
            {
              Hp[(signed long int)j] = H;
              Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
              if(!((signed int)gap_init >= H))
              {
                if(!(max_scor >= H))
                  max_scor = H;

                F = H - (signed int)gap_init;
                if(!(Ep[(signed long int)j] >= F))
                  Ep[(signed long int)j] = F;

              }

            }

            else
            {
              Hp[(signed long int)j] = Ep[(signed long int)j];
              Ep[(signed long int)j] = Ep[(signed long int)j] - (signed int)gap_ext;
            }
          }

          else
            if(H >= 1)
            {
              Hp[(signed long int)j] = H;
              if(!((signed int)gap_init >= H))
              {
                if(!(max_scor >= H))
                  max_scor = H;

                Ep[(signed long int)j] = H - (signed int)gap_init;
                F = Ep[(signed long int)j];
              }

            }

            else
              Hp[(signed long int)j] = 0;
      }
      if(delta_band_start >= 1)
        currH = 0;

      else
      {
        currH = Hp[(signed long int)j_curr_start];
        j_curr_start = j_curr_start + 1;
      }
      if(!(j_curr_len >= bandp->q_len))
        j_curr_len = j_curr_len + 1;

    }
    *maxswscor = max_scor;
    return 0;
  }
}

// alignSmiWatBandRecursive
// file alignment.c line 1300
static signed int alignSmiWatBandRecursive(struct _AliRsltSet *rssp, struct _AliBuffer *bufp, const struct _ScoreProfile *q_profp, signed int q_len, const char *s_seqp, signed int s_len, signed int l_edge, signed int r_edge, signed int q_left, signed int q_right, signed int s_left, signed int s_right, const signed int minscore, const signed int minscorlen)
{
  signed int errcode = 0;
  signed int s_start;
  signed int s_end;
  struct _ALIBAND band;
  if(!(minscorlen >= 2))
    return 47;

  else
  {
    signed int return_value_initALIBAND$1;
    return_value_initALIBAND$1=initALIBAND(&band, l_edge, r_edge, q_left, q_right, q_len, s_left, s_right, s_len);
    if(!(return_value_initALIBAND$1 == 0))
      return 0;

    else
    {
      errcode=setMemALITRACK(&rssp->track, &band);
      if(!(errcode == 0))
        return errcode;

      else
      {
        errcode=alignSmiWatBand(&rssp->track, bufp, &band, q_profp, s_seqp);
        if(!(errcode == 0))
          return errcode;

        else
          if(!(rssp->track.max_scor >= minscore))
            return 0;

          else
          {
            errcode=makeMetaFromTrack(&rssp->meta, rssp->cplxp, &rssp->track, &band, q_profp, s_seqp);
            if(!(errcode == 0))
              return errcode;

            else
              if(!(1 + rssp->meta.prof_end >= rssp->meta.prof_start + minscorlen))
                return 0;

              else
              {
                s_start = rssp->meta.nonprof_start;
                s_end = rssp->meta.nonprof_end;
                if(rssp->meta.score >= minscore)
                {
                  errcode=addALIMETAtoRsltSet(rssp);
                  if(errcode == 0)
                    goto __CPROVER_DUMP_L8;

                  return errcode;
                }

                else
                {

                __CPROVER_DUMP_L8:
                  ;
                  if(!(minscorlen + s_left >= s_start))
                  {
                    errcode=alignSmiWatBandRecursive(rssp, bufp, q_profp, q_len, s_seqp, s_len, l_edge, r_edge, q_left, q_right, s_left, s_start - 1, minscore, minscorlen);
                    if(errcode == 0)
                      goto __CPROVER_DUMP_L9;

                    return errcode;
                  }

                  else
                  {

                  __CPROVER_DUMP_L9:
                    ;
                    if(!(s_end + minscorlen >= s_right))
                    {
                      errcode=alignSmiWatBandRecursive(rssp, bufp, q_profp, q_len, s_seqp, s_len, l_edge, r_edge, q_left, q_right, s_end + 1, s_right, minscore, minscorlen);
                      if(errcode == 0)
                        goto __CPROVER_DUMP_L10;

                      return errcode;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      return 0;
                    }
                  }
                }
              }
          }
      }
    }
  }
}

// alignSmiWatByteStriped
// file swsimd.c line 656
static signed int alignSmiWatByteStriped(unsigned char *maxscor, const struct _AliBuffer *abp, const struct _ScoreProfile *spp, const char *usqp, signed int uslen)
{
  signed int errcode;
  signed int i;
  signed int j;
  signed int score = 0;
  signed int intval;
  signed int segsiz;
  signed int cmpval = 0;
  unsigned short int gap_init;
  unsigned short int gap_ext;
  unsigned short int bias = (unsigned short int)0;
  const __gcc_v2di *vScorep;
  const __gcc_v2di *vProfp;
  __gcc_v2di vH;
  __gcc_v2di vE;
  __gcc_v2di vF;
  __gcc_v2di vMax;
  __gcc_v2di vBias;
  __gcc_v2di vZero;
  __gcc_v2di vGapI;
  __gcc_v2di vGapE;
  __gcc_v2di vTmp;
  __gcc_v2di *vp;
  __gcc_v2di *vEp = abp->Ev;
  __gcc_v2di *vHSp = abp->H1v;
  __gcc_v2di *vHLp = abp->H2v;
  *maxscor = (unsigned char)0;
  if(vEp == ((__gcc_v2di *)NULL) || vHLp == ((__gcc_v2di *)NULL) || vHSp == ((__gcc_v2di *)NULL))
    return 47;

  else
  {
    const void *return_value_scoreGetStripedProfile$1;
    return_value_scoreGetStripedProfile$1=scoreGetStripedProfile((signed short int *)(void *)0, (unsigned int *)(void *)0, &gap_init, &gap_ext, &bias, &segsiz, (char)2, spp);
    vProfp = (const __gcc_v2di *)return_value_scoreGetStripedProfile$1;
    if(vProfp == ((const __gcc_v2di *)NULL))
      return 66;

    else
    {
      vBias=_mm_setzero_si128();
      intval = (signed int)bias << 8 | (signed int)bias & 255;
      __gcc_v8hi return_value___builtin_ia32_vec_set_v8hi$2;
      return_value___builtin_ia32_vec_set_v8hi$2=__builtin_ia32_vec_set_v8hi((__gcc_v8hi)(__gcc_v2di)vBias, (signed int)intval, (signed int)0);
      vBias = (__gcc_v2di)return_value___builtin_ia32_vec_set_v8hi$2;
      __gcc_v8hi return_value___builtin_ia32_pshuflw$3;
      return_value___builtin_ia32_pshuflw$3=__builtin_ia32_pshuflw((__gcc_v8hi)(__gcc_v2di)vBias, (signed int)0);
      vBias = (__gcc_v2di)return_value___builtin_ia32_pshuflw$3;
      __gcc_v4si return_value___builtin_ia32_pshufd$4;
      return_value___builtin_ia32_pshufd$4=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)vBias, (signed int)0);
      vBias = (__gcc_v2di)return_value___builtin_ia32_pshufd$4;
      vGapI=_mm_setzero_si128();
      intval = (signed int)gap_init << 8 | (signed int)gap_init & 255;
      __gcc_v8hi return_value___builtin_ia32_vec_set_v8hi$5;
      return_value___builtin_ia32_vec_set_v8hi$5=__builtin_ia32_vec_set_v8hi((__gcc_v8hi)(__gcc_v2di)vGapI, (signed int)intval, (signed int)0);
      vGapI = (__gcc_v2di)return_value___builtin_ia32_vec_set_v8hi$5;
      __gcc_v8hi return_value___builtin_ia32_pshuflw$6;
      return_value___builtin_ia32_pshuflw$6=__builtin_ia32_pshuflw((__gcc_v8hi)(__gcc_v2di)vGapI, (signed int)0);
      vGapI = (__gcc_v2di)return_value___builtin_ia32_pshuflw$6;
      __gcc_v4si return_value___builtin_ia32_pshufd$7;
      return_value___builtin_ia32_pshufd$7=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)vGapI, (signed int)0);
      vGapI = (__gcc_v2di)return_value___builtin_ia32_pshufd$7;
      vGapE=_mm_setzero_si128();
      intval = (signed int)gap_ext << 8 | (signed int)gap_ext & 255;
      __gcc_v8hi return_value___builtin_ia32_vec_set_v8hi$8;
      return_value___builtin_ia32_vec_set_v8hi$8=__builtin_ia32_vec_set_v8hi((__gcc_v8hi)(__gcc_v2di)vGapE, (signed int)intval, (signed int)0);
      vGapE = (__gcc_v2di)return_value___builtin_ia32_vec_set_v8hi$8;
      __gcc_v8hi return_value___builtin_ia32_pshuflw$9;
      return_value___builtin_ia32_pshuflw$9=__builtin_ia32_pshuflw((__gcc_v8hi)(__gcc_v2di)vGapE, (signed int)0);
      vGapE = (__gcc_v2di)return_value___builtin_ia32_pshuflw$9;
      __gcc_v4si return_value___builtin_ia32_pshufd$10;
      return_value___builtin_ia32_pshufd$10=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)vGapE, (signed int)0);
      vGapE = (__gcc_v2di)return_value___builtin_ia32_pshufd$10;
      vMax=_mm_setzero_si128();
      vZero=_mm_setzero_si128();
      i = 0;
      for( ; !(i >= segsiz); i = i + 1)
      {
        _mm_store_si128(vEp + (signed long int)i, vZero);
        _mm_store_si128(vHSp + (signed long int)i, vZero);
      }
      i = 0;
      for( ; !(i >= uslen); i = i + 1)
      {
        vScorep = vProfp + (signed long int)(((signed int)usqp[(signed long int)i] & 7) * segsiz);
        vF=_mm_setzero_si128();
        vH=_mm_load_si128((vHSp + (signed long int)segsiz) - (signed long int)1);
        __gcc_v2di return_value___builtin_ia32_pslldqi128$11;
        return_value___builtin_ia32_pslldqi128$11=__builtin_ia32_pslldqi128((__gcc_v2di)vH, (signed int)1 * 8);
        vH = (__gcc_v2di)return_value___builtin_ia32_pslldqi128$11;
        vp = vHLp;
        vHLp = vHSp;
        vHSp = vp;
        j = 0;
        for( ; !(j >= segsiz); j = j + 1)
        {
          vE=_mm_load_si128(vEp + (signed long int)j);
          vTmp=_mm_load_si128(vScorep + (signed long int)j);
          vH=_mm_adds_epu8(vH, vTmp);
          vH=_mm_subs_epu8(vH, vBias);
          vMax=_mm_max_epu8(vMax, vH);
          vH=_mm_max_epu8(vH, vE);
          vH=_mm_max_epu8(vH, vF);
          _mm_store_si128(vHSp + (signed long int)j, vH);
          vH=_mm_subs_epu8(vH, vGapI);
          vE=_mm_subs_epu8(vE, vGapE);
          vE=_mm_max_epu8(vE, vH);
          vF=_mm_subs_epu8(vF, vGapE);
          vF=_mm_max_epu8(vF, vH);
          _mm_store_si128(vEp + (signed long int)j, vE);
          vH=_mm_load_si128(vHLp + (signed long int)j);
        }
        j = 0;
        vH=_mm_load_si128(vHSp + (signed long int)j);
        __gcc_v2di return_value___builtin_ia32_pslldqi128$12;
        return_value___builtin_ia32_pslldqi128$12=__builtin_ia32_pslldqi128((__gcc_v2di)vF, (signed int)1 * 8);
        vF = (__gcc_v2di)return_value___builtin_ia32_pslldqi128$12;
        vTmp=_mm_subs_epu8(vH, vGapI);
        vTmp=_mm_subs_epu8(vF, vTmp);
        vTmp=_mm_cmpeq_epi8(vTmp, vZero);
        cmpval=_mm_movemask_epi8(vTmp);
        while(!(cmpval == 0xffff))
        {
          vE=_mm_load_si128(vEp + (signed long int)j);
          vH=_mm_max_epu8(vH, vF);
          _mm_store_si128(vHSp + (signed long int)j, vH);
          vH=_mm_subs_epu8(vH, vGapI);
          vE=_mm_max_epu8(vE, vH);
          _mm_store_si128(vEp + (signed long int)j, vE);
          vF=_mm_subs_epu8(vF, vGapE);
          j = j + 1;
          if(j >= segsiz)
          {
            j = 0;
            __gcc_v2di return_value___builtin_ia32_pslldqi128$13;
            return_value___builtin_ia32_pslldqi128$13=__builtin_ia32_pslldqi128((__gcc_v2di)vF, (signed int)1 * 8);
            vF = (__gcc_v2di)return_value___builtin_ia32_pslldqi128$13;
          }

          vH=_mm_load_si128(vHSp + (signed long int)j);
          vTmp=_mm_subs_epu8(vH, vGapI);
          vTmp=_mm_subs_epu8(vF, vTmp);
          vTmp=_mm_cmpeq_epi8(vTmp, vZero);
          cmpval=_mm_movemask_epi8(vTmp);
        }
      }
      __gcc_v2di return_value___builtin_ia32_psrldqi128$14;
      return_value___builtin_ia32_psrldqi128$14=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)8 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$14;
      vMax=_mm_max_epu8(vMax, vTmp);
      __gcc_v2di return_value___builtin_ia32_psrldqi128$15;
      return_value___builtin_ia32_psrldqi128$15=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)4 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$15;
      vMax=_mm_max_epu8(vMax, vTmp);
      __gcc_v2di return_value___builtin_ia32_psrldqi128$16;
      return_value___builtin_ia32_psrldqi128$16=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)2 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$16;
      vMax=_mm_max_epu8(vMax, vTmp);
      __gcc_v2di return_value___builtin_ia32_psrldqi128$17;
      return_value___builtin_ia32_psrldqi128$17=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)1 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$17;
      vMax=_mm_max_epu8(vMax, vTmp);
      unsigned int return_value___builtin_ia32_vec_ext_v8hi$18;
      return_value___builtin_ia32_vec_ext_v8hi$18=__builtin_ia32_vec_ext_v8hi((__gcc_v8hi)(__gcc_v2di)vMax, (signed int)0);
      score = (signed int)(unsigned short int)return_value___builtin_ia32_vec_ext_v8hi$18;
      score = score & 255;
      if(score + (signed int)bias >= 1)
        errcode = 41;

      else
      {
        errcode = 0;
        *maxscor = (unsigned char)score;
      }
      return errcode;
    }
  }
}

// alignSmiWatShortStriped
// file swsimd.c line 443
static signed int alignSmiWatShortStriped(unsigned short int *maxscor, const struct _AliBuffer *abp, const struct _ScoreProfile *spp, const char *usqp, signed int uslen)
{
  signed int errcode;
  signed int i;
  signed int j;
  signed int segsiz;
  signed int score;
  signed int cmpval;
  signed short int tmp;
  unsigned short int gap_init;
  unsigned short int gap_ext;
  const __gcc_v2di *vScorep;
  const __gcc_v2di *vProfp;
  __gcc_v2di vH;
  __gcc_v2di vE;
  __gcc_v2di vF;
  __gcc_v2di vMax;
  __gcc_v2di vMin;
  __gcc_v2di vGapI;
  __gcc_v2di vGapE;
  __gcc_v2di vTmp;
  __gcc_v2di *vp;
  __gcc_v2di *vEp = abp->Ev;
  __gcc_v2di *vHSp = abp->H1v;
  __gcc_v2di *vHLp = abp->H2v;
  *maxscor = (unsigned short int)0;
  if(vEp == ((__gcc_v2di *)NULL) || vHLp == ((__gcc_v2di *)NULL) || vHSp == ((__gcc_v2di *)NULL))
    return 47;

  else
  {
    const void *return_value_scoreGetStripedProfile$1;
    return_value_scoreGetStripedProfile$1=scoreGetStripedProfile((signed short int *)(void *)0, (unsigned int *)(void *)0, &gap_init, &gap_ext, (unsigned short int *)(void *)0, &segsiz, (char)4, spp);
    vProfp = (const __gcc_v2di *)return_value_scoreGetStripedProfile$1;
    if(vProfp == ((const __gcc_v2di *)NULL))
      return 66;

    else
    {
      vGapI=_mm_setzero_si128();
      __gcc_v8hi return_value___builtin_ia32_vec_set_v8hi$2;
      return_value___builtin_ia32_vec_set_v8hi$2=__builtin_ia32_vec_set_v8hi((__gcc_v8hi)(__gcc_v2di)vGapI, (signed int)gap_init, (signed int)0);
      vGapI = (__gcc_v2di)return_value___builtin_ia32_vec_set_v8hi$2;
      __gcc_v8hi return_value___builtin_ia32_pshuflw$3;
      return_value___builtin_ia32_pshuflw$3=__builtin_ia32_pshuflw((__gcc_v8hi)(__gcc_v2di)vGapI, (signed int)0);
      vGapI = (__gcc_v2di)return_value___builtin_ia32_pshuflw$3;
      __gcc_v4si return_value___builtin_ia32_pshufd$4;
      return_value___builtin_ia32_pshufd$4=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)vGapI, (signed int)0);
      vGapI = (__gcc_v2di)return_value___builtin_ia32_pshufd$4;
      vGapE=_mm_setzero_si128();
      __gcc_v8hi return_value___builtin_ia32_vec_set_v8hi$5;
      return_value___builtin_ia32_vec_set_v8hi$5=__builtin_ia32_vec_set_v8hi((__gcc_v8hi)(__gcc_v2di)vGapE, (signed int)gap_ext, (signed int)0);
      vGapE = (__gcc_v2di)return_value___builtin_ia32_vec_set_v8hi$5;
      __gcc_v8hi return_value___builtin_ia32_pshuflw$6;
      return_value___builtin_ia32_pshuflw$6=__builtin_ia32_pshuflw((__gcc_v8hi)(__gcc_v2di)vGapE, (signed int)0);
      vGapE = (__gcc_v2di)return_value___builtin_ia32_pshuflw$6;
      __gcc_v4si return_value___builtin_ia32_pshufd$7;
      return_value___builtin_ia32_pshufd$7=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)vGapE, (signed int)0);
      vGapE = (__gcc_v2di)return_value___builtin_ia32_pshufd$7;
      vMax=_mm_setzero_si128();
      vMax=_mm_cmpeq_epi16(vMax, vMax);
      vMax=_mm_slli_epi16(vMax, 15);
      __gcc_v4si return_value___builtin_ia32_pshufd$8;
      return_value___builtin_ia32_pshufd$8=__builtin_ia32_pshufd((__gcc_v4si)(__gcc_v2di)vMax, (signed int)0);
      vMin = (__gcc_v2di)return_value___builtin_ia32_pshufd$8;
      __gcc_v2di return_value___builtin_ia32_psrldqi128$9;
      return_value___builtin_ia32_psrldqi128$9=__builtin_ia32_psrldqi128((__gcc_v2di)vMin, (signed int)14 * 8);
      vMin = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$9;
      i = 0;
      for( ; !(i >= segsiz); i = i + 1)
      {
        _mm_store_si128(vEp + (signed long int)i, vMax);
        _mm_store_si128(vHSp + (signed long int)i, vMax);
      }
      i = 0;
      for( ; !(i >= uslen); i = i + 1)
      {
        vScorep = vProfp + (signed long int)(((signed int)usqp[(signed long int)i] & 7) * segsiz);
        vF=_mm_setzero_si128();
        vF=_mm_cmpeq_epi16(vF, vF);
        vF=_mm_slli_epi16(vF, 15);
        vH=_mm_load_si128((vHSp + (signed long int)segsiz) - (signed long int)1);
        __gcc_v2di return_value___builtin_ia32_pslldqi128$10;
        return_value___builtin_ia32_pslldqi128$10=__builtin_ia32_pslldqi128((__gcc_v2di)vH, (signed int)2 * 8);
        vH = (__gcc_v2di)return_value___builtin_ia32_pslldqi128$10;
        vH=_mm_or_si128(vH, vMin);
        vp = vHLp;
        vHLp = vHSp;
        vHSp = vp;
        j = 0;
        for( ; !(j >= segsiz); j = j + 1)
        {
          vE=_mm_load_si128(vEp + (signed long int)j);
          vTmp=_mm_load_si128(vScorep + (signed long int)j);
          vH=_mm_adds_epi16(vH, vTmp);
          vMax=_mm_max_epi16(vMax, vH);
          vH=_mm_max_epi16(vH, vE);
          vH=_mm_max_epi16(vH, vF);
          _mm_store_si128(vHSp + (signed long int)j, vH);
          vH=_mm_subs_epi16(vH, vGapI);
          vE=_mm_subs_epi16(vE, vGapE);
          vE=_mm_max_epi16(vE, vH);
          vF=_mm_subs_epi16(vF, vGapE);
          vF=_mm_max_epi16(vF, vH);
          _mm_store_si128(vEp + (signed long int)j, vE);
          vH=_mm_load_si128(vHLp + (signed long int)j);
        }
        j = 0;
        vH=_mm_load_si128(vHSp + (signed long int)j);
        __gcc_v2di return_value___builtin_ia32_pslldqi128$11;
        return_value___builtin_ia32_pslldqi128$11=__builtin_ia32_pslldqi128((__gcc_v2di)vF, (signed int)2 * 8);
        vF = (__gcc_v2di)return_value___builtin_ia32_pslldqi128$11;
        vF=_mm_or_si128(vF, vMin);
        vTmp=_mm_subs_epi16(vH, vGapI);
        vTmp=_mm_cmpgt_epi16(vF, vTmp);
        cmpval=_mm_movemask_epi8(vTmp);
        while(!(cmpval == 0x0000))
        {
          vE=_mm_load_si128(vEp + (signed long int)j);
          vH=_mm_max_epi16(vH, vF);
          _mm_store_si128(vHSp + (signed long int)j, vH);
          vH=_mm_subs_epi16(vH, vGapI);
          vE=_mm_max_epi16(vE, vH);
          _mm_store_si128(vEp + (signed long int)j, vE);
          vF=_mm_subs_epi16(vF, vGapE);
          j = j + 1;
          if(j >= segsiz)
          {
            j = 0;
            __gcc_v2di return_value___builtin_ia32_pslldqi128$12;
            return_value___builtin_ia32_pslldqi128$12=__builtin_ia32_pslldqi128((__gcc_v2di)vF, (signed int)2 * 8);
            vF = (__gcc_v2di)return_value___builtin_ia32_pslldqi128$12;
            vF=_mm_or_si128(vF, vMin);
          }

          vH=_mm_load_si128(vHSp + (signed long int)j);
          vTmp=_mm_subs_epi16(vH, vGapI);
          vTmp=_mm_cmpgt_epi16(vF, vTmp);
          cmpval=_mm_movemask_epi8(vTmp);
        }
      }
      __gcc_v2di return_value___builtin_ia32_psrldqi128$13;
      return_value___builtin_ia32_psrldqi128$13=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)8 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$13;
      vMax=_mm_max_epi16(vMax, vTmp);
      __gcc_v2di return_value___builtin_ia32_psrldqi128$14;
      return_value___builtin_ia32_psrldqi128$14=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)4 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$14;
      vMax=_mm_max_epi16(vMax, vTmp);
      __gcc_v2di return_value___builtin_ia32_psrldqi128$15;
      return_value___builtin_ia32_psrldqi128$15=__builtin_ia32_psrldqi128((__gcc_v2di)vMax, (signed int)2 * 8);
      vTmp = (__gcc_v2di)return_value___builtin_ia32_psrldqi128$15;
      vMax=_mm_max_epi16(vMax, vTmp);
      unsigned int return_value___builtin_ia32_vec_ext_v8hi$16;
      return_value___builtin_ia32_vec_ext_v8hi$16=__builtin_ia32_vec_ext_v8hi((__gcc_v8hi)(__gcc_v2di)vMax, (signed int)0);
      tmp = (signed short int)(signed int)(unsigned short int)return_value___builtin_ia32_vec_ext_v8hi$16;
      score = (signed int)tmp - (signed int)BIAS;
      if(score >= 1)
        errcode = 41;

      else
        if(!(score >= 0))
          errcode = 47;

        else
        {
          errcode = 0;
          *maxscor = (unsigned short int)score;
        }
      return errcode;
    }
  }
}

// appendMangledToCompressedSeq
// file sequence.c line 932
static signed int appendMangledToCompressedSeq(struct _SEQSEQ *top, const struct _SEQSEQ *fromp, char withTerm)
{
  const char *fsp;
  signed int nsu;
  unsigned long int n_alloc;
  unsigned long int i;
  unsigned long int offset;
  unsigned long int totsiz;
  unsigned long int n_unit;
  unsigned int to_unit;
  unsigned int *tsp = (unsigned int *)top->basep;
  signed int return_value_reallocSeqBlocks$1;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  if(!((signed int)fromp->code == 1))
    return 22;

  else
  {
    offset = top->size / (unsigned long int)10;
    nsu = (signed int)((offset + (unsigned long int)1) * (unsigned long int)10 - top->size);
    totsiz = top->size + fromp->size;
    if(!(top->size >= 1ul))
    {
      top->code = (char)2;
      top->nbit_symb = (char)3;
      to_unit = (unsigned int)0;
    }

    else
    {
      if(!((signed int)top->code == 2))
        return 22;

      to_unit = tsp[(signed long int)offset] >> (nsu - 1) * 3;
      if(!((7u & to_unit) == 7u))
        return 47;

      if(!(withTerm == 0))
      {
        totsiz = totsiz + 1ul;
        nsu = nsu - 1;
        if(!(nsu >= 1))
        {
          nsu = 10;
          offset = offset + 1ul;
          to_unit = (unsigned int)0;
        }

      }

      else
        to_unit = to_unit >> 3;
    }
    n_unit = totsiz / (unsigned long int)10 + (unsigned long int)1;
    n_alloc = n_unit * (unsigned long int)10;
    if(n_alloc >= top->alloc_size)
    {
      return_value_reallocSeqBlocks$1=reallocSeqBlocks(top, n_alloc);
      if(return_value_reallocSeqBlocks$1 == 0)
        goto __CPROVER_DUMP_L8;

      return 2;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      fsp = fromp->basep;
      tsp = (unsigned int *)top->basep;
      i = (unsigned long int)0;
      for( ; !(i >= fromp->size); i = i + 1ul)
      {
        to_unit = (to_unit << 3) + (unsigned int)((signed int)fsp[(signed long int)i] & 7);
        nsu = nsu - 1;
        if(!(nsu >= 1))
        {
          tmp_post$2 = offset;
          offset = offset + 1ul;
          tsp[(signed long int)tmp_post$2] = to_unit;
          nsu = 10;
          to_unit = (unsigned int)0;
        }

      }
      to_unit = (to_unit << 3) + (unsigned int)7;
      nsu = nsu - 1;
      if(!(nsu >= 0))
        return 47;

      else
      {
        to_unit = to_unit << nsu * 3;
        tmp_post$3 = offset;
        offset = offset + 1ul;
        tsp[(signed long int)tmp_post$3] = to_unit;
        if(!(offset == n_unit))
          return 28;

        else
        {
          top->size = totsiz;
          return 0;
        }
      }
    }
  }
}

// appendSeqSegment
// file sequence.c line 832
static signed int appendSeqSegment(struct _SEQSEQ *top, unsigned int *tcpos, unsigned char *ntc, const struct _SEQSEQ *fromp, unsigned int start, unsigned int length, char reverse, char withTerm, const struct _SeqCodec *codep)
{
  char *hp;
  unsigned char uc;
  const char *cp;
  unsigned int i;
  unsigned char nt = (unsigned char)0;
  unsigned long int totsize;
  _Bool tmp_if_expr$1;
  char *tmp_post$3;
  unsigned char tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  unsigned char tmp_post$7;
  char *tmp_post$8;
  unsigned char tmp_post$9;
  char *tmp_post$10;
  const char *tmp_post$11;
  unsigned char tmp_post$12;
  char *tmp_post$13;
  const char *tmp_post$14;
  if((signed int)fromp->code == 2)
    return 22;

  else
    if(!(fromp->size >= (unsigned long int)start))
      return 29;

    else
    {
      if(length == 0u)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (unsigned long int)(start + length) > fromp->size ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        length = (unsigned int)(fromp->size - (unsigned long int)start);

      if(!(withTerm == 0))
      {
        if(top->size >= 1ul)
          top->size = top->size + 1ul;

      }

      if(top->size + (unsigned long int)length >= 18446744073709551615ul)
        return 73;

      else
      {
        totsize = (unsigned long int)length + top->size;
        if(!(top->alloc_size >= 1ul + totsize))
        {
          signed int return_value_reallocSeqBlocks$2;
          return_value_reallocSeqBlocks$2=reallocSeqBlocks(top, totsize);
          if(!(return_value_reallocSeqBlocks$2 == 0))
            return 2;

        }

        hp = top->basep + (signed long int)top->size;
        cp = fromp->basep + (signed long int)start;
        if(!(reverse == 0))
        {
          cp = cp + (signed long int)(length - (unsigned int)1);
          if(!(codep == ((const struct _SeqCodec *)NULL)))
          {
            if((signed int)fromp->code == 1)
            {
              i = (unsigned int)0;
              for( ; !(i >= length); cp = cp - 1l)
              {
                if(!((4 & (signed int)*cp) == 0))
                {
                  tmp_post$3 = hp;
                  hp = hp + 1l;
                  *tmp_post$3 = *cp;
                  if((signed int)*cp == 7)
                  {
                    if(!(tcpos == ((unsigned int *)NULL)) && !((signed int)nt >= 8))
                    {
                      tmp_post$4 = nt;
                      nt = nt + 1;
                      tcpos[(signed long int)tmp_post$4] = i;
                    }

                  }

                }

                else
                {
                  tmp_post$5 = hp;
                  hp = hp + 1l;
                  *tmp_post$5 = (char)codep->codtab_complement[(signed long int)((signed int)*cp & 3)];
                }
                i = i + 1u;
              }
            }

            else
            {
              i = (unsigned int)0;
              for( ; !(i >= length); cp = cp - 1l)
              {
                uc = codep->codtab[(signed long int)(signed int)*cp];
                if(!((4 & (signed int)uc) == 0))
                {
                  tmp_post$6 = hp;
                  hp = hp + 1l;
                  *tmp_post$6 = *cp;
                  if((signed int)uc == 7)
                  {
                    if(!(tcpos == ((unsigned int *)NULL)) && !((signed int)nt >= 8))
                    {
                      tmp_post$7 = nt;
                      nt = nt + 1;
                      tcpos[(signed long int)tmp_post$7] = i;
                    }

                  }

                }

                else
                {
                  tmp_post$8 = hp;
                  hp = hp + 1l;
                  *tmp_post$8 = codep->decodtab[(signed long int)codep->codtab_complement[(signed long int)((signed int)uc & 3)]];
                }
                i = i + 1u;
              }
            }
          }

          else
          {
            i = (unsigned int)0;
            for( ; !(i >= length); i = i + 1u)
            {
              if(*cp == 0)
              {
                if(!(tcpos == ((unsigned int *)NULL)))
                {
                  if(!((signed int)nt >= 8))
                  {
                    tmp_post$9 = nt;
                    nt = nt + 1;
                    tcpos[(signed long int)tmp_post$9] = i;
                  }

                }

              }

              tmp_post$10 = hp;
              hp = hp + 1l;
              tmp_post$11 = cp;
              cp = cp - 1l;
              *tmp_post$10 = *tmp_post$11;
            }
          }
        }

        else
        {
          i = (unsigned int)0;
          for( ; !(i >= length); i = i + 1u)
          {
            if(*cp == 0)
            {
              if(!(tcpos == ((unsigned int *)NULL)))
              {
                if(!((signed int)nt >= 8))
                {
                  tmp_post$12 = nt;
                  nt = nt + 1;
                  tcpos[(signed long int)tmp_post$12] = i;
                }

              }

            }

            tmp_post$13 = hp;
            hp = hp + 1l;
            tmp_post$14 = cp;
            cp = cp + 1l;
            *tmp_post$13 = *tmp_post$14;
          }
        }
        *hp = (char)0;
        top->size = top->size + (unsigned long int)i;
        top->code = fromp->code;
        top->nbit_symb = fromp->nbit_symb;
        if(!(ntc == ((unsigned char *)NULL)))
          *ntc = nt;

        return 0;
      }
    }
}

// arrayCreate
// file array.h line 49
void * arrayCreate(unsigned long int elemsiz, unsigned long int blocksiz, const char *nam, signed int lin)
{
  unsigned long int headsiz = (unsigned long int)4 * sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int blksz;
  unsigned long int *p;
  if(!(elemsiz >= 1ul))
    return (void *)0;

  else
  {
    blksz = blocksiz > (unsigned long int)0 ? ((elemsiz * blocksiz - (unsigned long int)1) / (unsigned long int)4096 + (unsigned long int)1) * (unsigned long int)4096 : (unsigned long int)4096;
    void *return_value_ecalloc$1;
    return_value_ecalloc$1=ecalloc((unsigned long int)1, blksz, nam, lin);
    p = (unsigned long int *)return_value_ecalloc$1;
    if(p == ((unsigned long int *)NULL))
      return (void *)0;

    else
    {
      p = p + (signed long int)4;
      p[(signed long int)-1] = (unsigned long int)0;
      p[(signed long int)-2] = (blksz - headsiz) / elemsiz;
      p[(signed long int)-3] = elemsiz;
      p[(signed long int)-4] = blksz;
      return (void *)p;
    }
  }
}

// arrayRealloc
// file array.h line 51
void * arrayRealloc(void *p, unsigned long int new_nelem, char is_final, const char *nam, signed int lin)
{
  unsigned long int *newp = (unsigned long int *)(void *)0;
  unsigned long int *headp = (unsigned long int *)p;
  unsigned long int headsiz = (unsigned long int)4 * sizeof(unsigned long int) /*8ul*/ ;
  unsigned long int newsiz;
  unsigned long int blocksiz = headp[(signed long int)-4];
  unsigned long int elsiz = headp[(signed long int)-3];
  if(new_nelem >= 1ul)
  {
    if(!(new_nelem >= headp[-2l]))
      return p;

    newsiz = ((headsiz + new_nelem * elsiz + blocksiz) - (unsigned long int)1) / blocksiz;
    newsiz = newsiz * blocksiz;
  }

  else
    if(!(is_final == 0))
      newsiz = headsiz + headp[(signed long int)-1] * elsiz;

    else
    {
      newsiz = ((headsiz + (headp[(signed long int)-2] + (unsigned long int)1) * elsiz) - (unsigned long int)1) / blocksiz + (unsigned long int)1;
      newsiz = newsiz * blocksiz;
    }
  void *return_value_erealloc$1;
  return_value_erealloc$1=erealloc((void *)(headp - (signed long int)4), newsiz, (unsigned long int)0, nam, lin);
  newp = (unsigned long int *)return_value_erealloc$1;
  if(newp == ((unsigned long int *)NULL))
    return (void *)newp;

  else
  {
    newp = newp + (signed long int)4;
    newp[(signed long int)-2] = (newsiz - headsiz) / elsiz;
    return (void *)newp;
  }
}

// assignPhredScaledMappingScoreToRandomDraw
// file results.c line 214
static signed int assignPhredScaledMappingScoreToRandomDraw(signed int samplesiz)
{
  signed int mapq;
  if(samplesiz >= 10 || !(samplesiz >= 1))
    mapq = 0;

  else
    if(samplesiz == 1)
      mapq = 3 + 1;

    else
    {
      double return_value_log10$1;
      return_value_log10$1=log10((double)(samplesiz - 1) / (double)samplesiz);
      mapq = (signed int)((double)-10 * return_value_log10$1 + .499);
      if(mapq >= 4)
        mapq = 3;

      else
        if(!(mapq >= 0))
          mapq = 0;

    }
  return mapq;
}

// assignProbabilityToPairs
// file resultpairs.c line 753
static signed int assignProbabilityToPairs(struct _MATEPAIR *mpr, double *psum, double *marga, double *margb, unsigned char pairflg, const struct _InsHist *ihistp)
{
  signed int i;
  signed int n_pairs = (signed int)((unsigned long int *)mpr)[(signed long int)-1];
  const double prob_improper = CUMULPROB_IMPROPER;
  const double prob_proper = 1.0 - CUMULPROB_IMPROPER;
  const double prob_out = CUMULPROB_PROPER_OUTSIDE;
  const double prob_in = 1.0 - CUMULPROB_PROPER_OUTSIDE;
  const double prob_allout = prob_improper + prob_proper * prob_out;
  signed int tmp_if_expr$1;
  if(!(n_pairs >= 1))
    return 0;

  else
  {
    *psum = MINLOGARG$link1;
    *margb = 0.0;
    *marga = *margb;
    i = 0;
    for( ; !(i >= n_pairs); i = i + 1)
    {
      double pa;
      double pb;
      double iab;
      unsigned short int flga;
      unsigned short int flgb;
      struct _MATEPAIR *mp = mpr + (signed long int)i;
      resultGetMapQualScore(&pa, &flga, mp->ap);
      resultGetMapQualScore(&pb, &flgb, mp->bp);
      if(!((4 & (signed int)pairflg) == 0))
      {
        if(pa > pb)
          pa = pb;

      }

      else
        if(!((8 & (signed int)pairflg) == 0))
        {
          if(pb > pa)
            pb = pa;

        }

      if(!((4 & (signed int)mp->mapflg) == 0))
      {
        iab = prob_proper;
        if(!((8 & (signed int)mp->mapflg) == 0))
        {
          if(ihistp == ((const struct _InsHist *)NULL) || !(n_pairs >= 2))
            iab = iab * prob_in;

          else
          {
            signed int count;
            signed int totnum;
            double p;
            if(!(mp->ins >= 0))
              tmp_if_expr$1 = -1 * mp->ins;

            else
              tmp_if_expr$1 = mp->ins;
            count=insGetHistoCountCumulative(&totnum, tmp_if_expr$1, (unsigned char)1, ihistp);
            if(!(totnum >= 1))
            {
              totnum = 1;
              count = 1;
            }

            p = (double)count / (double)totnum;
            if(p >= 0.5)
              iab = 0.5 - p / (double)2;

            iab = iab * (p * prob_in + prob_out);
          }
        }

        else
          iab = iab * prob_out;
      }

      else
        iab = prob_improper;
      mp->pbf = pa * pb * iab;
      *psum = *psum + mp->pbf;
      if(!((256 & (signed int)flga) == 0))
      {
        double s = (1.0 - pa) * prob_allout * pb;
        *margb = *margb + s;
        *psum = *psum + s;
      }

      if(!((256 & (signed int)flgb) == 0))
      {
        double assignProbabilityToPairs$$1$$1$$1$$6$$s = pa * prob_allout * (1.0 - pb);
        *marga = *marga + assignProbabilityToPairs$$1$$1$$1$$6$$s;
        *psum = *psum + assignProbabilityToPairs$$1$$1$$1$$6$$s;
      }

    }
    return 0;
  }
}

// assignSequenceIndex
// file results.c line 1695
static signed int assignSequenceIndex(struct _ResultSet *rsp, struct _SeqFastq *sbufp, const struct _ScoreProfile *scpp, const struct _ScoreProfile *scpRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode = 0;
  signed short int i;
  signed short int ctr;
  signed short int nres = (signed short int)((unsigned long int *)rsp->resr)[(signed long int)-1];
  const unsigned long int *ofp;
  signed long int s;
  signed long int e;
  signed long int nseq;
  nseq=seqSetGetOffsets(ssp, &ofp);
  ((unsigned long int *)rsp->sortidxr)[(signed long int)-1] = (unsigned long int)0;
  ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1] = (unsigned long int)0;
  i = (signed short int)0;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$5;
  unsigned long int tmp_post$6;
  for( ; !((signed int)i >= (signed int)nres); i = i + 1)
  {
    struct _RESULT *rp = rsp->resr + (signed long int)i;
    if(!((1 & (signed int)rp->status) == 0))
    {
      if(!(rp->sidx >= 0l))
      {
        unsigned int *sip;
        unsigned long int *skp;
        rsp->sortidxr[(signed long int)((unsigned long int *)rsp->sortidxr)[(signed long int)-1]] = (unsigned int)i;
        if(((unsigned long int *)rsp->sortidxr)[-1l] >= ((unsigned long int *)rsp->sortidxr)[-2l])
        {
          void *return_value_arrayRealloc$1;
          return_value_arrayRealloc$1=arrayRealloc((void *)rsp->sortidxr, (unsigned long int)0, (char)0, "results.c", 1719);
          sip = (unsigned int *)return_value_arrayRealloc$1;
          if(!(sip == ((unsigned int *)NULL)))
          {
            rsp->sortidxr = sip;
            tmp_post$2 = ((unsigned long int *)rsp->sortidxr)[(signed long int)-1];
            ((unsigned long int *)rsp->sortidxr)[(signed long int)-1] = ((unsigned long int *)rsp->sortidxr)[(signed long int)-1] + 1ul;
            sip = rsp->sortidxr + (signed long int)tmp_post$2;
          }

        }

        else
        {
          tmp_post$3 = ((unsigned long int *)rsp->sortidxr)[(signed long int)-1];
          ((unsigned long int *)rsp->sortidxr)[(signed long int)-1] = ((unsigned long int *)rsp->sortidxr)[(signed long int)-1] + 1ul;
          sip = rsp->sortidxr + (signed long int)tmp_post$3;
        }
        rsp->sortkeyr[(signed long int)((unsigned long int *)rsp->sortkeyr)[(signed long int)-1]] = rp->s_start;
        if(rsp->sortkeyr[-1l] >= rsp->sortkeyr[-2l])
        {
          void *return_value_arrayRealloc$4;
          return_value_arrayRealloc$4=arrayRealloc((void *)rsp->sortkeyr, (unsigned long int)0, (char)0, "results.c", 1721);
          skp = (unsigned long int *)return_value_arrayRealloc$4;
          if(!(skp == ((unsigned long int *)NULL)))
          {
            rsp->sortkeyr = skp;
            tmp_post$5 = ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1];
            ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1] = ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1] + 1ul;
            skp = rsp->sortkeyr + (signed long int)tmp_post$5;
          }

        }

        else
        {
          tmp_post$6 = ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1];
          ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1] = ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1] + 1ul;
          skp = rsp->sortkeyr + (signed long int)tmp_post$6;
        }
        if(sip == ((unsigned int *)NULL) || skp == ((unsigned long int *)NULL))
          return 2;

      }

    }

  }
  ctr = (signed short int)((unsigned long int *)rsp->sortidxr)[(signed long int)-1];
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if((signed int)ctr >= 2)
  {
    errcode=sortUINT64andUINT32ArraysByQuickSort((signed int)ctr, rsp->sortkeyr, rsp->sortidxr);
    if(errcode == 0)
      goto __CPROVER_DUMP_L11;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L11:
    ;
    s = (signed long int)0;
    i = (signed short int)0;
    for( ; !(s >= nseq) && !((signed int)i >= (signed int)ctr); i = i + 1)
    {
      struct _RESULT *assignSequenceIndex$$1$$3$$1$$rp = rsp->resr + (signed long int)rsp->sortidxr[(signed long int)i];
      if(!((9 & (signed int)assignSequenceIndex$$1$$3$$1$$rp->status) == 0))
      {
        do
        {
          if(!(s >= nseq))
            tmp_if_expr$7 = assignSequenceIndex$$1$$3$$1$$rp->s_start > ofp[s + (signed long int)1] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          if(!tmp_if_expr$7)
            break;

          s = s + 1l;
        }
        while((_Bool)1);
        e = s + (signed long int)1;
        do
        {
          if(!(e >= nseq))
            tmp_if_expr$8 = assignSequenceIndex$$1$$3$$1$$rp->s_end > ofp[e] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$8 = (_Bool)0;
          if(!tmp_if_expr$8)
            break;

          e = e + 1l;
        }
        while((_Bool)1);
        if(!(ofp[e] >= assignSequenceIndex$$1$$3$$1$$rp->s_end))
          return 47;

        if(!(1l + s >= e))
        {
          errcode=splitMultiSpan(&rsp->resr, rsp->sortidxr[(signed long int)i], rsp->diffstrbufp, rsp->diffstrp, sbufp, s, e, scpp, scpRCp, ssp, codecp);
          assignSequenceIndex$$1$$3$$1$$rp = rsp->resr + (signed long int)rsp->sortidxr[(signed long int)i];
          assignSequenceIndex$$1$$3$$1$$rp->status = assignSequenceIndex$$1$$3$$1$$rp->status & (unsigned short int)~1;
          if(!(errcode == 0))
            return errcode;

        }

        else
        {
          assignSequenceIndex$$1$$3$$1$$rp->sidx = s;
          assignSequenceIndex$$1$$3$$1$$rp->s_start = assignSequenceIndex$$1$$3$$1$$rp->s_start - ofp[s];
          assignSequenceIndex$$1$$3$$1$$rp->s_end = assignSequenceIndex$$1$$3$$1$$rp->s_end - ofp[s];
          assignSequenceIndex$$1$$3$$1$$rp->status = assignSequenceIndex$$1$$3$$1$$rp->status & (unsigned short int)~8;
        }
      }

    }
    rsp->status = rsp->status & (unsigned char)~4;
    rsp->status = rsp->status | (unsigned char)1;
    ((unsigned long int *)rsp->sortkeyr)[(signed long int)-1] = (unsigned long int)0;
    ((unsigned long int *)rsp->sortidxr)[(signed long int)-1] = (unsigned long int)0;
    return errcode;
  }
}

// blankALICPLX
// file alignment.c line 258
static void blankALICPLX(struct _ALICPLX *p)
{
  signed short int i;
  if(!(p == ((struct _ALICPLX *)NULL)))
  {
    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)p->n_types); i = i + 1)
      p->countp[(signed long int)i] = 0;
  }

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// blankHitList
// file hashhit.c line 1224
void blankHitList(struct _HashHitList *hlp)
{
  if(!(hlp == ((struct _HashHitList *)NULL)))
  {
    hlp->nhits = 0;
    hlp->status = (unsigned char)0;
    memset((void *)hlp->qmask, 4, (unsigned long int)hlp->qlen);
  }

}

// blankRMAPBUFF
// file rmap.c line 1139
static void blankRMAPBUFF(struct RMAPBUFF_ *rmp)
{
  if(!(rmp == ((struct RMAPBUFF_ *)NULL)))
  {
    seqFastqBlank(rmp->sqbfp);
    if(!(rmp->qbfp == ((struct _SeqFastq *)NULL)))
      seqFastqBlank(rmp->qbfp);

    hashBlankHitList(rmp->hhlp);
    segLstBlank(rmp->sglp);
    segAliCandsBlank(rmp->sacp);
    ((unsigned long int *)rmp->candr)[(signed long int)-1] = (unsigned long int)0;
    aliRsltSetReset(rmp->alirsltp);
  }

}

// blankSeq
// file sequence.c line 757
static void blankSeq(struct _SEQSEQ *sp)
{
  if(!(sp == ((struct _SEQSEQ *)NULL)))
  {
    if(!(sp->basep == ((char *)NULL)))
      sp->basep[(signed long int)0] = (char)0;

    sp->size = (unsigned long int)0;
    sp->code = (char)0;
    sp->nbit_symb = (char)8;
  }

}

// buildHashIndex
// file smalt.c line 338
static signed int buildHashIndex(struct _ErrMsg *errmsgp, const struct _MenuOpt *menup)
{
  signed int errcode;
  const char is_verbose = (const char)1;
  unsigned char ktup;
  unsigned char nskip;
  unsigned char nbits_key;
  unsigned char nbits_perf;
  unsigned char typ;
  const char *hashnam;
  const char *filnam;
  struct _HashTable *htp;
  struct _SeqCodec *codecp;
  struct _SeqFastq *sqbufp;
  struct _SeqSet *ssp;
  menuGetFileNames(menup, &filnam, (const char **)(void *)0);
  errcode=menuGetHashParams(menup, &hashnam, &ktup, &nskip);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "smalt.c", 352, errcode, (unsigned char)2);

  codecp=seqCodecCreate();
  if(codecp == ((struct _SeqCodec *)NULL))
    errMsgAdd(errmsgp, "", "smalt.c", 355, 2, (unsigned char)2);

  sqbufp=seqFastqCreate(67108864, (char)0);
  if(sqbufp == ((struct _SeqFastq *)NULL))
    errMsgAdd(errmsgp, "", "smalt.c", 358, 2, (unsigned char)2);

  ssp=seqSetCreate(67108864, (unsigned char)2);
  if(ssp == ((struct _SeqSet *)NULL))
    errMsgAdd(errmsgp, "", "smalt.c", 361, 2, (unsigned char)2);

  if(!(is_verbose == 0))
    fprintf(stderr, "# Reading sequences ...\n");

  seqSetAddFromFastqFile(errmsgp, ssp, sqbufp, codecp, filnam, (char)0);
  if(!(is_verbose == 0))
    fprintf(stderr, "# Writing sequence set ...\n");

  errcode=seqSetWriteBinFil(ssp, hashnam);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "smalt.c", 377, errcode, (unsigned char)2);

  errcode=selectHashTyp(&typ, &nbits_key, &nbits_perf, ktup, nskip, ssp);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "smalt.c", 380, errcode, (unsigned char)2);

  if(!(is_verbose == 0))
  {
    if((signed int)typ == 0)
      fprintf(stderr, "# Setting up perfect hash index ...\n");

    else
      fprintf(stderr, "# Setting up hash index with collisions ...\n");
    fprintf(stderr, "# word length = %i bases, skip step = %i bases ...\n", (signed int)ktup, (signed int)nskip);
    if(!((signed int)typ == 0))
      fprintf(stderr, "# number of bits for key = %i with %i perfect bits\n", (signed int)nbits_key, (signed int)nbits_perf);

  }

  htp=hashTableCreate(ktup, nskip, nbits_key, nbits_perf, typ);
  if(htp == ((struct _HashTable *)NULL))
    errMsgAdd(errmsgp, "", "smalt.c", 393, 2, (unsigned char)2);

  errcode=hashTableSetUp(htp, sqbufp, ssp, (const struct V_IVAL_ *)(void *)0, codecp, (unsigned int *)(void *)0, is_verbose);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "smalt.c", 397, errcode, (unsigned char)2);

  if(!(is_verbose == 0))
    hashTablePrintStats(stderr, htp);

  if(!(is_verbose == 0))
    fprintf(stderr, "# Writing table to file ... \n");

  errcode=hashTableWrite(hashnam, htp);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "smalt.c", 405, errcode, (unsigned char)2);

  hashTableDelete(htp);
  seqSetDelete(ssp);
  seqFastqDelete(sqbufp);
  seqCodecDelete(codecp);
  return 0;
}

// calcIndelFreeMincover
// file segment.c line 360
static unsigned int calcIndelFreeMincover(unsigned int slen, unsigned char ktup, unsigned char nskip)
{
  unsigned short int diffcover_1mm = (unsigned short int)(((signed int)ktup + (signed int)nskip) - 1);
  unsigned short int diffcover_2mm = (unsigned short int)((signed int)diffcover_1mm << 1);
  unsigned int mincover;
  if(slen >= (unsigned int)(signed int)diffcover_2mm + (unsigned int)(signed int)ktup)
    mincover = slen - (unsigned int)diffcover_2mm;

  else
    if(slen >= (unsigned int)(signed int)diffcover_1mm + (unsigned int)(signed int)ktup)
      mincover = slen - (unsigned int)diffcover_1mm;

    else
      mincover = (unsigned int)ktup;
  return mincover;
}

// calcKernelBandWidth
// file insert.c line 136
static signed int calcKernelBandWidth(signed int n, signed int iqr)
{
  signed int tmp_if_expr$2;
  double return_value_pow$1;
  if(n >= 1)
  {
    return_value_pow$1=pow((double)n, -0.2);
    tmp_if_expr$2 = (signed int)((0.9 * return_value_pow$1 * (double)iqr) / 1.34);
  }

  else
    tmp_if_expr$2 = 0;
  return tmp_if_expr$2;
}

// calcKtupOffs
// file hashidx.c line 325
static unsigned int calcKtupOffs(unsigned char *ktupoffs, unsigned int offs, signed long int sx, unsigned char nskip, const struct _SeqSet *ssp)
{
  unsigned long int soffs;
  unsigned int tc;
  seqSetGetSeqDatByIndex(&soffs, (const char **)(void *)0, sx, ssp);
  tc = (unsigned int)((soffs + (unsigned long int)offs) / (unsigned long int)nskip);
  if(!(ktupoffs == ((unsigned char *)NULL)))
    *ktupoffs = (unsigned char)((soffs + (unsigned long int)offs) - (unsigned long int)(tc * (unsigned int)nskip));

  return tc;
}

// calcMaxWordNumPerKey
// file hashidx.c line 429
static signed int calcMaxWordNumPerKey(unsigned int *nkey_zero, const struct _HashTable *htp)
{
  unsigned int k;
  signed int nw;
  signed int maxnw = 0;
  unsigned int nzero = (unsigned int)0;
  k = (unsigned int)0;
  for( ; !(k >= htp->nkeys); k = k + 1u)
  {
    nw = (signed int)(htp->idx[(signed long int)(k + (unsigned int)1)] - htp->idx[(signed long int)k]);
    if(!(maxnw >= nw))
      maxnw = nw;

    else
      if(nw == 0)
        nzero = nzero + 1u;

  }
  if(!(nkey_zero == ((unsigned int *)NULL)))
    *nkey_zero = nzero;

  return maxnw;
}

// calcMinKtup
// file rmap.c line 240
static unsigned int calcMinKtup(unsigned int *mincover, const struct _HashTable *htp)
{
  unsigned char nskip;
  unsigned char ktup;
  ktup=hashTableGetKtupLen(htp, &nskip);
  unsigned int minktup;
  unsigned int tmp_if_expr$1;
  if(*mincover >= (unsigned int)(signed int)ktup + (unsigned int)(signed int)nskip)
    tmp_if_expr$1 = (*mincover - (unsigned int)ktup) / (unsigned int)nskip;

  else
    tmp_if_expr$1 = (unsigned int)1;
  minktup = tmp_if_expr$1;
  *mincover = (minktup - (unsigned int)1) * (unsigned int)nskip + (unsigned int)ktup;
  return minktup;
}

// calcPhredScaledMappingQuality
// file results.c line 1143
static signed int calcPhredScaledMappingQuality(signed short int qsegx, const struct _ResultSet *rsetp, const struct _SeqFastq *sqp)
{
  signed int errcode;
  signed short int i;
  signed short int i_min;
  signed short int n;
  signed short int n_swatscor_2nd = (signed short int)0;
  unsigned int slen;
  unsigned int seglen;
  unsigned int seglen_1st;
  const char *qualstrp;
  struct _RESULT *tmpp;
  signed int qn;
  signed int swatscor_1st;
  signed int swatscor_2nd;
  signed int mapscor;
  signed int maxmapscor;
  double fs;
  double fa;
  signed int qvalsum_1st = 0;
  signed int qvalsum_2nd = 0;
  signed int qvalsum_ali;
  const unsigned char *dstrp = rsetp->diffstrp->dstrp;
  struct _RESULT **rspp;
  _Bool tmp_if_expr$1;
  if((8 & (signed int)rsetp->status) == 0 || !((signed int)qsegx >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)qsegx >= (signed int)rsetp->qsegno ? (_Bool)1 : (_Bool)0;
  double tmp_if_expr$3;
  double return_value_log$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$1)
    return 47;

  else
  {
    rspp = rsetp->segsrtr + (signed long int)rsetp->segnor[(signed long int)qsegx];
    n = (signed short int)((signed int)rsetp->segnor[(signed long int)((signed int)qsegx + 1)] - (signed int)rsetp->segnor[(signed long int)qsegx]);
    if(!((signed int)n >= 1))
      return 0;

    else
    {
      swatscor_1st = rspp[(signed long int)0]->swatscor;
      if(!(swatscor_1st >= 1))
      {
        rspp[(signed long int)0]->mapscor = 0;
        return 0;
      }

      else
      {
        fs = (double)rsetp->n_hits_used / (double)(rsetp->n_hits_tot + (unsigned int)3);
        fa = (double)rsetp->n_ali_done / (double)(rsetp->n_ali_tot + 3);
        if(fs > fa)
          fs = fa;

        if(fs > MINLOGARG)
        {
          return_value_log$2=log(fs);
          tmp_if_expr$3 = ((double)-10 * return_value_log$2) / (double)QUALSCOR_LOGBASE;
        }

        else
          tmp_if_expr$3 = (double)60;
        fs = tmp_if_expr$3;
        maxmapscor = fs < (double)60 ? 60 - (signed int)fs : 0;
        if((signed int)n >= 2)
        {
          swatscor_2nd = rspp[(signed long int)1]->swatscor;
          i = (signed short int)2;
          do
          {
            if(!((signed int)i >= (signed int)n))
              tmp_if_expr$4 = rspp[(signed long int)i]->swatscor == swatscor_2nd ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(!tmp_if_expr$4)
              break;

            i = i + 1;
          }
          while((_Bool)1);
          n_swatscor_2nd = (signed short int)((signed int)i - 1);
          double return_value_log$5;
          return_value_log$5=log((double)n_swatscor_2nd);
          qn = (signed int)(((double)10 * return_value_log$5) / (double)QUALSCOR_LOGBASE);
        }

        else
        {
          swatscor_2nd = 0;
          n_swatscor_2nd = (signed short int)0;
          qn = 0;
        }
        if(swatscor_2nd == swatscor_1st && (signed int)n >= 2)
        {
          qsort((void *)rspp, (unsigned long int)((signed int)n_swatscor_2nd + 1), sizeof(struct _RESULT *) /*8ul*/ , cmpResSegLen);
          seglen_1st = rspp[(signed long int)0]->q_end - rspp[(signed long int)0]->q_start;
          seglen = rspp[(signed long int)1]->q_end - rspp[(signed long int)1]->q_start;
          if(seglen_1st == seglen)
          {
            qualstrp=seqFastqGetConstQualityFactors(sqp, &slen, (char *)(void *)0);
            if(!(qualstrp == ((const char *)NULL)))
            {
              errcode=sumQualOverMisMatch(&qvalsum_1st, (unsigned char)0, qualstrp, slen, rspp[(signed long int)0]->q_start, rspp[(signed long int)0]->q_end, dstrp + (signed long int)rspp[(signed long int)0]->stroffs);
              if(!(errcode == 0))
                return errcode;

              errcode=sumQualOverMisMatch(&qvalsum_2nd, (unsigned char)0, qualstrp, slen, rspp[(signed long int)1]->q_start, rspp[(signed long int)1]->q_end, dstrp + (signed long int)rspp[(signed long int)1]->stroffs);
              if(!(errcode == 0))
                return errcode;

              i_min = (signed short int)1;
              i = (signed short int)2;
              do
              {
                if(!((signed int)i >= (signed int)n))
                  tmp_if_expr$6 = rspp[(signed long int)i]->swatscor == swatscor_1st ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$6 = (_Bool)0;
                if(!tmp_if_expr$6)
                  break;

                seglen = rspp[(signed long int)i]->q_end - rspp[(signed long int)i]->q_start;
                if(!(seglen >= seglen_1st))
                  break;

                errcode=sumQualOverMisMatch(&qvalsum_ali, (unsigned char)0, qualstrp, slen, rspp[(signed long int)i]->q_start, rspp[(signed long int)i]->q_end, dstrp + (signed long int)rspp[(signed long int)i]->stroffs);
                if(!(errcode == 0))
                  return errcode;

                if(!(qvalsum_ali >= qvalsum_2nd))
                {
                  qvalsum_2nd = qvalsum_ali;
                  i_min = i;
                }

                i = i + 1;
              }
              while((_Bool)1);
              if(!(qvalsum_2nd >= qvalsum_1st))
              {
                tmpp = rspp[(signed long int)i_min];
                rspp[(signed long int)i_min] = rspp[(signed long int)0];
                rspp[(signed long int)0] = tmpp;
                mapscor = 4;
              }

              else
                mapscor = qvalsum_1st == qvalsum_2nd ? 0 : 4;
            }

            else
              mapscor = 0;
          }

          else
            mapscor = 4;
          if(!(mapscor >= 1))
            qsort((void *)rspp, (unsigned long int)((signed int)n_swatscor_2nd + 1), sizeof(struct _RESULT *) /*8ul*/ , cmpResOutput);

        }

        else
        {
          unsigned int qlen;
          seqFastqGetConstSequence(sqp, &qlen, (char *)(void *)0);
          double return_value_exp$7;
          return_value_exp$7=exp(((double)(swatscor_2nd - swatscor_1st) * (double)10) / (double)qlen);
          mapscor = (signed int)((double)60 * ((double)1 - return_value_exp$7) - (double)qn);
          if(mapscor >= 0)
            mapscor = mapscor + 4;

          if(!(maxmapscor >= mapscor))
            mapscor = maxmapscor;

        }
        if(mapscor >= 61)
          mapscor = 60;

        else
          if(!(mapscor >= 0))
            mapscor = 0;

        rspp[(signed long int)0]->mapscor = mapscor;
        i = (signed short int)1;
        for( ; !((signed int)i >= (signed int)n); i = i + 1)
          rspp[(signed long int)i]->mapscor = 0;
        return 0;
      }
    }
  }
}

// calcPhredScaledMappingQualityPerQuerySegment
// file results.c line 1415
static signed int calcPhredScaledMappingQualityPerQuerySegment(struct _ResultSet *rsetp, const struct _SeqFastq *sqp)
{
  signed int errcode = 0;
  signed short int qsegx;
  if((8 & (signed int)rsetp->status) == 0)
    return 47;

  else
  {
    qsegx = (signed short int)0;
    for( ; !((signed int)qsegx >= (signed int)rsetp->qsegno); qsegx = qsegx + 1)
    {
      errcode=calcPhredScaledMappingQuality(qsegx, rsetp, sqp);
      if(!(errcode == 0))
        return errcode;

      errcode=propagateMapQualAsProb(qsegx, rsetp);
      if(!(errcode == 0))
        return errcode;

    }
    if(errcode == 0)
      rsetp->status = rsetp->status | (unsigned char)16;

    return errcode;
  }
}

// calcRESULTid
// file results.c line 567
static signed int calcRESULTid(const struct _RESULT *rp, const struct _ResultSet *rsp)
{
  signed int matchnum = 0;
  diffStrCalcAliLen(&matchnum, rsp->diffstrp->dstrp + (signed long int)rp->stroffs);
  return matchnum;
}

// calcSegmentBoundaries
// file segment.c line 635
static void calcSegmentBoundaries(unsigned int *qs, unsigned int *qe, unsigned int *rs, unsigned int *re, const struct _SEGMENT *sgp, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip, unsigned char is_reverse)
{
  const struct _SEED$0 *seed_startp = seedr + (signed long int)sgp->ix;
  const struct _SEED$0 *seed_endp = (seed_startp + (signed long int)sgp->nseed) - (signed long int)1;
  *qs = (unsigned int)(seed_startp->sqo & (unsigned long int)2147483647);
  *qe = (unsigned int)(((seed_endp->sqo & (unsigned long int)2147483647) + (unsigned long int)seed_endp->len) - (unsigned long int)1);
  if(!(is_reverse == 0))
  {
    *rs = (unsigned int)((seed_endp->sqo >> 31) - (seed_endp->sqo & (unsigned long int)2147483647) / (unsigned long int)nskip & (unsigned long int)-1);
    *rs = *rs - (unsigned int)((seed_endp->len - (signed int)ktup) / (signed int)nskip);
    *re = (unsigned int)((seed_startp->sqo >> 31) - (unsigned long int)(*qs / (unsigned int)nskip) & (unsigned long int)-1);
  }

  else
  {
    *rs = (unsigned int)((seed_startp->sqo >> 31) + (unsigned long int)(*qs / (unsigned int)nskip) & (unsigned long int)-1);
    *re = (unsigned int)((seed_endp->sqo >> 31) + (seed_endp->sqo & (unsigned long int)2147483647) / (unsigned long int)nskip & (unsigned long int)-1);
    *re = *re + (unsigned int)((seed_endp->len - (signed int)ktup) / (signed int)nskip);
  }
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// calcSegmentOverlap
// file segment.c line 587
static signed int calcSegmentOverlap(const struct _SEGMENT *sgAp, const struct _SEGMENT *sgBp, struct _SEED$0 * const seedr)
{
  unsigned int qa_start;
  unsigned int qb_start;
  unsigned int qa_end;
  unsigned int qb_end;
  signed int a;
  signed int b;
  unsigned int overlap = (unsigned int)0;
  qb_start = (unsigned int)((seedr + (signed long int)0)->sqo & (unsigned long int)2147483647);
  b = 0;
  a = b;
  for( ; !(a >= sgAp->nseed); overlap = overlap + (qa_end < qb_end ? qa_end : (qb_end - (unsigned int)(qa_start > qb_start) != 0u ? qa_start : qb_start)))
  {
    if(b >= sgBp->nseed)
      break;

    qa_start = (unsigned int)((seedr + (signed long int)a)->sqo & (unsigned long int)2147483647);
    qa_end = qa_start + (unsigned int)(seedr + (signed long int)a)->len;
    qb_start = (unsigned int)((seedr + (signed long int)b)->sqo & (unsigned long int)2147483647);
    qb_end = qb_start + (unsigned int)(seedr + (signed long int)b)->len;
    a = a + 1;
    for( ; qb_start >= qa_end; a = a + 1)
    {
      qa_start = (unsigned int)((seedr + (signed long int)a)->sqo & (unsigned long int)2147483647);
      qa_end = qa_start + (unsigned int)(seedr + (signed long int)a)->len;
    }
    b = b + 1;
    for( ; qa_start >= qb_end; b = b + 1)
    {
      qb_start = (unsigned int)((seedr + (signed long int)b)->sqo & (unsigned long int)2147483647);
      qb_end = qb_start + (unsigned int)(seedr + (signed long int)b)->len;
    }
  }
  return (signed int)overlap;
}

// calcTotalHitNumStats
// file rmap.c line 1086
static unsigned int calcTotalHitNumStats(const struct RMAPINFO_ *rmrp, unsigned int *nhit_tot)
{
  unsigned int nhitF_rank;
  unsigned int nhitR_rank;
  unsigned int nhitF;
  nhitF=hashHitInfoCalcHitNumbers(rmrp->hhiFp, &nhitF_rank);
  unsigned int nhitR;
  nhitR=hashHitInfoCalcHitNumbers(rmrp->hhiRp, &nhitR_rank);
  *nhit_tot = nhitF + nhitR;
  return nhitF_rank + nhitR_rank;
}

// calcTotalNumberOfHits
// file rmap.c line 1079
static unsigned int calcTotalNumberOfHits(const struct RMAPINFO_ *rmrp, signed int ktuple_maxhit)
{
  unsigned int hitnum;
  hitnum=hashCalcHitInfoNumberOfHits(rmrp->hhiFp, (unsigned int)ktuple_maxhit);
  unsigned int return_value_hashCalcHitInfoNumberOfHits$1;
  return_value_hashCalcHitInfoNumberOfHits$1=hashCalcHitInfoNumberOfHits(rmrp->hhiRp, (unsigned int)ktuple_maxhit);
  return (unsigned int)(hitnum + return_value_hashCalcHitInfoNumberOfHits$1);
}

// checkArgBlockReadNo
// file smalt.c line 966
static signed int checkArgBlockReadNo(const void *thargp, const void *buffargp)
{
  const struct _SmaltOutput *dop = (struct _SmaltOutput *)thargp;
  const struct SmaltArgBlock_ *blockp = (struct SmaltArgBlock_ *)buffargp;
  unsigned long int readno;
  /* assertion thargp != ((void *)0) */
  assert(thargp != (void *)0);
  /* assertion buffargp != ((void *)0) */
  assert(buffargp != (void *)0);
  /* assertion blockp->iobfp != ((void *)0) */
  assert(blockp->iobfp != (struct _SmaltIOBuffArg *)(void *)0);
  readno = blockp->iobfp->readno;
  _Bool tmp_if_expr$1;
  if((signed int)blockp->n_iobf >= 1)
    tmp_if_expr$1 = readno <= dop->next_readno ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// checkCodec
// file sequence.c line 266
static signed int checkCodec(struct _SeqCodec *codep)
{
  signed int errcode = 0;
  const char bases[53l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 0 };
  const char *bp = bases;
  signed int return_value_toupper$1;
  _Bool tmp_if_expr$2;
  for( ; !(*bp == 0); bp = bp + 1l)
  {
    signed int return_value_toupper$3;
    return_value_toupper$3=toupper((signed int)*bp);
    if(!(return_value_toupper$3 == (signed int)codep->decodtab[(signed long int)codep->codtab[(signed long int)(unsigned char)*bp]]))
    {
      return_value_toupper$1=toupper((signed int)*bp);
      if(!(return_value_toupper$1 == 85))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)codep->decodtab[(signed long int)codep->codtab[(signed long int)(unsigned char)*bp]] != 84 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        errcode = -1;
        break;
      }

    }

  }
  if(!(errcode == 0))
    printf("ERROR in code table for base: %c, code: %d, decode: %c\n", *bp, codep->codtab[(signed long int)(signed char)*bp], codep->decodtab[(signed long int)codep->codtab[(signed long int)(unsigned char)*bp]]);

  return errcode;
}

// checkForRepeats
// file hashhit.c line 325
static unsigned char checkForRepeats(signed long int word, signed long int *tdrf)
{
  unsigned char isRepeat = (unsigned char)0;
  unsigned char i = (unsigned char)0;
  for( ; !((signed int)i >= 4); i = i + 1)
    if(word == tdrf[(signed long int)i])
    {
      isRepeat = (unsigned char)1;
      break;
    }

  memmove((void *)(tdrf + (signed long int)1), (const void *)tdrf, (unsigned long int)(4 - 1) * sizeof(signed long int) /*8ul*/ );
  tdrf[(signed long int)0] = word;
  return isRepeat;
}

// checkHashDefaults
// file menu.c line 1165
static signed int checkHashDefaults(struct _MenuOpt *menup, const struct _optflags *optflp)
{
  struct _INDEXMENU *ip;
  if(!((signed int)menup->subprog == 1))
    return -1;

  else
  {
    ip = (struct _INDEXMENU *)menup->paramp;
    if(optflp->skip == 0u)
      ip->skip = ip->kmer;

    if(!(menup->ninfil == 2))
      exitOptionError((const char *)(void *)0, "Expected name of an input file containing the genomic reference sequencesin FASTA/FASTQ format.");

    return 0;
  }
}

// checkHashWithCollisions
// file hashidx.c line 370
static signed int checkHashWithCollisions(const struct _HashTable *htp, const struct _SeqSet *ssp, unsigned long int word, signed long int seqidx, unsigned long int basidx)
{
  signed int errcode = 0;
  unsigned char flag_found = (unsigned char)0;
  unsigned int key;
  unsigned int key_hi;
  unsigned int word_hi;
  unsigned int pivot;
  unsigned int b;
  unsigned int a;
  unsigned int i;
  unsigned int i_end;
  unsigned int *posp;
  unsigned long int po;
  unsigned int offs;
  signed long int si = (signed long int)0;
  word_hi = (unsigned int)((word & htp->wordmask_hi) >> (signed int)htp->nbits_lo);
  unsigned int return_value_hash32mix$1;
  return_value_hash32mix$1=hash32mix(word_hi);
  key_hi = return_value_hash32mix$1 % htp->keymod;
  key = (unsigned int)((unsigned long int)(key_hi << (signed int)htp->nbits_lo) + (word & htp->wordmask_lo));
  b = htp->idx[(signed long int)(key + (unsigned int)1)];
  _Bool tmp_if_expr$2;
  if(!(b >= 1u))
    return 69;

  else
  {
    a = htp->idx[(signed long int)key];
    b = b - 1u;
    while(!(a >= b))
    {
      pivot = a + b >> 1;
      if(!(htp->wordidx[(signed long int)pivot] >= word_hi))
        a = pivot + (unsigned int)1;

      else
        b = pivot;
    }
    if(!(b >= a))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = htp->wordidx[(signed long int)b] != word_hi ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 69;

    else
    {
      posp = htp->pos + (signed long int)htp->posidx[(signed long int)b];
      if(!(htp->posidx[(signed long int)(1u + b)] >= htp->posidx[(signed long int)b]))
        return 21;

      else
      {
        i_end = htp->posidx[(signed long int)(b + (unsigned int)1)] - htp->posidx[(signed long int)b];
        i = (unsigned int)0;
        for( ; !(i >= i_end); i = i + 1u)
        {
          po = (unsigned long int)(posp[(signed long int)i] * (unsigned int)htp->nskip);
          errcode=seqSetGetIndexAndOffset(&si, &offs, po, ssp);
          if(!(errcode == 0))
            return errcode;

          if(si == seqidx && po == basidx + (unsigned long int)offs)
          {
            flag_found = (unsigned char)1;
            break;
          }

        }
        if(flag_found == 0)
        {
          printf("HASH at seqidx %lli, basidx %lu failed with key %u, pos %u, seqidx %llii, offset %u\n", (signed long long int)seqidx, (unsigned long int)basidx, key, *posp, (signed long long int)si, (unsigned int)offs);
          errcode = 21;
        }

        return errcode;
      }
    }
  }
}

// checkMapDefaults
// file menu.c line 1183
static signed int checkMapDefaults(struct _MenuOpt *menup, const struct _optflags *optflp)
{
  struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  _Bool tmp_if_expr$1;
  if(!((signed int)menup->subprog == 2))
    return -1;

  else
  {
    if(!(menup->ninfil >= 2))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = menup->ninfil > 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      exitOptionError((const char *)(void *)0, "Expected one or two file names.");

    if((signed int)mp->inform == 1)
    {
      if(menup->ninfil == 3)
        mp->flags = mp->flags | (unsigned short int)16;

      else
      {
        mp->pairtyp = (unsigned char)1;
        if(!(optflp->insertmax == 0u))
          exitPairedReadError("-i");

        if(!(optflp->insertmin == 0u))
          exitPairedReadError("-j");

        if(!(optflp->pairtyp == 0u))
          exitPairedReadError("-l");

      }
    }

    if(!(mp->insert_range[1l] >= mp->insert_range[0l]))
    {
      signed int tmp = mp->insert_range[(signed long int)0];
      mp->insert_range[(signed long int)0] = mp->insert_range[(signed long int)1];
      mp->insert_range[(signed long int)1] = tmp;
    }

    if(optflp->scorediff == 0u)
      mp->scorediff = (signed short int)0;

    if(optflp->pairtyp == 0u)
      mp->pairtyp = (unsigned char)2;

    if(!(mp->maxhit >= 2 * mp->ncut))
      mp->maxhit = 2 * mp->ncut;

    if(!((signed int)mp->scorediff == 0))
      mp->flags = mp->flags & (unsigned short int)~4096;

    if(!(optflp->mincover == 0u))
    {
      if((512 & (signed int)mp->flags) == 0)
        exitOptionError("-c", "can only be used in combination with the '-x' flag.");

    }

    return 0;
  }
}

// checkPerfectHash
// file hashidx.c line 339
static signed int checkPerfectHash(const struct _HashTable *htp, const struct _SeqSet *ssp, unsigned long int word, signed long int seqidx, unsigned long int basidx)
{
  signed int errcode = 0;
  unsigned char flag_found = (unsigned char)0;
  signed long int si = (signed long int)0;
  unsigned int key = (unsigned int)(word & htp->wordmask);
  unsigned int *posp = htp->pos + (signed long int)htp->idx[(signed long int)key];
  unsigned int *endposp = htp->pos + (signed long int)htp->idx[(signed long int)(key + (unsigned int)1)];
  unsigned int offs;
  unsigned long int po;
  for( ; !(posp >= endposp); posp = posp + 1l)
  {
    po = (unsigned long int)(*posp * (unsigned int)htp->nskip);
    errcode=seqSetGetIndexAndOffset(&si, &offs, po, ssp);
    if(!(errcode == 0))
      return errcode;

    if(si == seqidx && po == basidx + (unsigned long int)offs)
    {
      flag_found = (unsigned char)1;
      break;
    }

  }
  if(flag_found == 0)
  {
    printf("HASH at seqidx %lli, basidx %lu failed with key %u, pos %u, seqidx %lli, offset %u\n", (signed long long int)seqidx, (unsigned long int)basidx, key, *posp, (signed long long int)si, (unsigned int)offs);
    errcode = 21;
  }

  return errcode;
}

// checkQuickHashIndexWithCollisions
// file hashidx.c line 698
static signed int checkQuickHashIndexWithCollisions(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  char codtyp;
  char word[22l];
  unsigned char i;
  const char *pData;
  const char *cp;
  unsigned int seqlen;
  unsigned int iha;
  unsigned int ipos;
  unsigned long int offset;
  unsigned long int offset_end;
  unsigned int key;
  unsigned long int keyword;
  key = (unsigned int)0;
  _Bool tmp_if_expr$1;
  const char *tmp_post$2;
  for( ; !(key >= htp->nkeys); key = key + 1u)
  {
    iha = htp->idx[(signed long int)key];
    for( ; !(iha >= htp->idx[(signed long int)(1u + key)]); iha = iha + 1u)
    {
      keyword = ((unsigned long int)htp->wordidx[(signed long int)iha] << (signed int)htp->nbits_lo) + ((unsigned long int)key & htp->wordmask_lo);
      ipos = htp->posidx[(signed long int)iha];
      for( ; !(ipos >= htp->posidx[(signed long int)(1u + iha)]); ipos = ipos + 1u)
      {
        offset = (unsigned long int)(htp->pos[(signed long int)ipos] * (unsigned int)htp->nskip);
        offset_end = (offset + (unsigned long int)htp->wordlen) - (unsigned long int)1;
        errcode=seqSetFetchSegment(sqbufp, &offset, &offset_end, ssp, codecp);
        if(!(errcode == 0))
          return errcode;

        pData=seqFastqGetConstSequence(sqbufp, &seqlen, &codtyp);
        if((signed int)codtyp == 0)
        {
          errcode=seqFastqEncode(sqbufp, codecp);
          if(!(errcode == 0))
            return errcode;

          pData=seqFastqGetConstSequence(sqbufp, &seqlen, &codtyp);
        }

        if(pData == ((const char *)NULL))
          return -1;

        if(!((signed int)codtyp == 1))
          return 22;

        i = htp->wordlen;
        cp = pData;
        do
        {
          if((signed int)i >= 1)
            tmp_if_expr$1 = *cp != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          tmp_post$2 = cp;
          cp = cp + 1l;
          i = i - 1;
          if(!((unsigned long int)(3 & (signed int)*tmp_post$2) == (3ul & keyword >> ((signed int)i << 1))))
          {
            seqFastqDecode(sqbufp, codecp);
            pData=seqFastqGetConstSequence(sqbufp, &seqlen, &codtyp);
            printWord(word, keyword, htp->wordlen);
            printf("HASH (collisions) %d failed with word %s (refseq %s), pos %u, offset %llu\n", key, (const void *)word, pData, ipos, (unsigned long long int)offset);
            return 21;
          }

        }
        while((_Bool)1);
      }
    }
  }
  return 0;
}

// checkQuickPerfectHashIndex
// file hashidx.c line 658
static signed int checkQuickPerfectHashIndex(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  char codtyp;
  unsigned char i;
  const char *datap;
  const char *cp;
  unsigned int seqlen;
  unsigned long int offset;
  unsigned long int offset_end;
  unsigned int key;
  unsigned int *p;
  unsigned int *endp;
  key = (unsigned int)0;
  _Bool tmp_if_expr$1;
  const char *tmp_post$2;
  for( ; !(key >= htp->nkeys); key = key + 1u)
  {
    endp = htp->pos + (signed long int)htp->idx[(signed long int)(key + (unsigned int)1)];
    p = htp->pos + (signed long int)htp->idx[(signed long int)key];
    for( ; !(p >= endp); p = p + 1l)
    {
      offset = (unsigned long int)(*p * (unsigned int)htp->nskip);
      offset_end = (offset + (unsigned long int)htp->wordlen) - (unsigned long int)1;
      errcode=seqSetFetchSegment(sqbufp, &offset, &offset_end, ssp, codecp);
      if(!(errcode == 0))
        return errcode;

      datap=seqFastqGetConstSequence(sqbufp, &seqlen, &codtyp);
      if((signed int)codtyp == 0)
      {
        errcode=seqFastqEncode(sqbufp, codecp);
        if(!(errcode == 0))
          return errcode;

        datap=seqFastqGetConstSequence(sqbufp, &seqlen, &codtyp);
      }

      if(datap == ((const char *)NULL))
        return -1;

      if(!((signed int)codtyp == 1))
        return 22;

      i = htp->wordlen;
      cp = datap;
      do
      {
        if((signed int)i >= 1)
          tmp_if_expr$1 = *cp != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        tmp_post$2 = cp;
        cp = cp + 1l;
        i = i - 1;
        if(!((3u & (unsigned int)(signed int)*tmp_post$2) == (3u & key >> ((signed int)i << 1))))
        {
          printf("HASH (perfect) failed with key %d, pos %u, offset %lu\n", key, *p, (unsigned long int)offset);
          return 21;
        }

      }
      while((_Bool)1);
    }
  }
  return 0;
}

// checkReads
// file smalt.c line 1432
static signed int checkReads(struct _ErrMsg *errmsgp, const struct _MenuOpt *menup)
{
  signed int errcode = 0;
  const char *filnamA;
  const char *filnamB;
  struct _InFmtReader *ifrp;
  struct _SeqFastq *readp = (struct _SeqFastq *)(void *)0;
  struct _SeqFastq *matep = (struct _SeqFastq *)(void *)0;
  signed int nfil;
  nfil=menuGetFileNames(menup, &filnamA, &filnamB);
  signed long int n_reads = (signed long int)0;
  if(nfil >= 4 || !(nfil >= 1))
    errMsgAdd(errmsgp, "", "smalt.c", 1442, 47, (unsigned char)2);

  readp=seqFastqCreate(0, (char)0);
  if(readp == ((struct _SeqFastq *)NULL))
    errMsgAdd(errmsgp, "", "smalt.c", 1445, 2, (unsigned char)2);

  if(!(filnamB == ((const char *)NULL)))
  {
    matep=seqFastqCreate(0, (char)0);
    if(matep == ((struct _SeqFastq *)NULL))
      errMsgAdd(errmsgp, "", "smalt.c", 1449, 2, (unsigned char)2);

  }

  ifrp=infmtCreateReader(&errcode, filnamA, filnamB, (const char *)(void *)0, (const unsigned char)1);
  if(!(ifrp == ((struct _InFmtReader *)NULL)))
  {
    errcode=infmtCheckReads(ifrp, readp, matep, &n_reads, (unsigned int *)(void *)0, (unsigned int *)(void *)0, errmsgp);
    infmtDeleteReader(ifrp);
  }

  seqFastqDelete(matep);
  seqFastqDelete(readp);
  fprintf(stderr, "# checked %llu %s: ", (unsigned long long int)n_reads, matep == (struct _SeqFastq *)(void *)0 ? "reads" : "read pairs");
  if(errcode == 76)
    fprintf(stderr, "ok, but mate names don't match.\n");

  else
    if(!(errcode == 0))
      fprintf(stderr, "failure.\n");

    else
      fprintf(stderr, "ok.\n");
  return errcode;
}

// checkSampleDefaults
// file menu.c line 1228
static signed int checkSampleDefaults(struct _MenuOpt *menup, const struct _optflags *optflp)
{
  struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  if(!((signed int)menup->subprog == 4))
    return -1;

  else
  {
    if((signed int)mp->inform == 1)
    {
      if(!(menup->ninfil == 3))
        exitOptionError((const char *)(void *)0, "Expected an index name and 2 file names.");

      mp->flags = mp->flags | (unsigned short int)16;
    }

    mp->flags = mp->flags | (unsigned short int)512;
    mp->scorediff = (signed short int)0;
    if(!(mp->maxhit >= 2 * mp->ncut))
      mp->maxhit = 2 * mp->ncut;

    mp->flags = mp->flags & (unsigned short int)~4096;
    if(optflp->readskip == 0u)
      mp->readskip = 100;

    if(optflp->mapqmin == 0u)
      mp->mapqmin = 20;

    return 0;
  }
}

// checkSeqNtSymbolsAreLetters
// file sequence.c line 1617
static signed int checkSeqNtSymbolsAreLetters(const struct _SEQSEQ *sp)
{
  signed int errcode = 0;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  if((signed int)sp->code == 0)
  {
    unsigned long int i = (unsigned long int)0;
    i = (unsigned long int)0;
    do
    {
      if(!(i >= sp->size))
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        tmp_if_expr$2 = ((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)sp->basep[(signed long int)i]] & (signed int)(unsigned short int)1024) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      i = i + 1ul;
    }
    while((_Bool)1);
    if(!(i >= sp->size))
      errcode = 85;

  }

  return errcode;
}

// checkWordsInSeqSet
// file hashidx.c line 606
static signed int checkWordsInSeqSet(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, signed int (*checkfunc)(const struct _HashTable *, const struct _SeqSet *, unsigned long int, signed long int, unsigned long int))
{
  signed int errcode = 0;
  char codtyp;
  const char *datap;
  unsigned char ktup_i;
  unsigned char n_nonstdnt;
  unsigned int seqlen;
  unsigned long int basidx;
  signed long int seqidx;
  signed long int n_seq;
  unsigned long int word;
  n_seq=seqSetGetOffsets(ssp, (const unsigned long int **)(void *)0);
  ktup_i = (unsigned char)0;
  seqidx = (signed long int)0;
  const char *tmp_post$1;
  for( ; errcode == 0 && !(seqidx >= n_seq); seqidx = seqidx + 1l)
  {
    printf("Checking sequence %lli ...\n", (signed long long int)seqidx);
    errcode=seqSetFetchSegmentBySequence(sqbufp, seqidx, (unsigned int)0, (unsigned int)0, ssp, codecp);
    if(!(errcode == 0))
      return errcode;

    datap=seqFastqGetConstSequence(sqbufp, &seqlen, &codtyp);
    if((signed int)codtyp == 0)
    {
      errcode=seqFastqEncode(sqbufp, codecp);
      if(!(errcode == 0))
        return errcode;

    }

    else
      if(!((signed int)codtyp == 1))
        return 22;

    if(!(seqlen >= (unsigned int)htp->wordlen))
      return 30;

    word = (unsigned long int)0LL;
    basidx = (unsigned long int)ktup_i;
    ktup_i = ktup_i + htp->wordlen;
    n_nonstdnt = (unsigned char)0;
    while(!(*datap == 0))
    {
      if(!(errcode == 0))
        break;

      if(!((4 & (signed int)*datap) == 0))
        n_nonstdnt = htp->wordlen;

      else
        if(!(n_nonstdnt == 0))
          n_nonstdnt = n_nonstdnt - 1;

      tmp_post$1 = datap;
      datap = datap + 1l;
      word = (word << 2) + (unsigned long int)((signed int)*tmp_post$1 & 3);
      ktup_i = ktup_i - 1;
      if(!((signed int)ktup_i >= 1))
      {
        if(n_nonstdnt == 0)
          errcode=checkfunc(htp, ssp, word, seqidx, basidx);

        ktup_i = htp->nskip;
        basidx = basidx + (unsigned long int)htp->nskip;
      }

    }
    ktup_i = (unsigned char)(((signed int)htp->wordlen - (signed int)ktup_i) % (signed int)htp->nskip);
    if(!(ktup_i == 0))
      ktup_i = (unsigned char)((signed int)htp->nskip - (signed int)ktup_i);

  }
  return errcode;
}

// cleanupALIMETA
// file alignment.c line 554
static void cleanupALIMETA(struct _ALIMETA *p)
{
  diffStrCleanUp(&p->dfs);
}

// cleanupALITRACK
// file alignment.c line 431
static void cleanupALITRACK(struct _ALITRACK *p)
{
  if(!(p == ((struct _ALITRACK *)NULL)))
  {
    free((void *)p->bdp);
    p->bdp = ((unsigned char *)NULL);
  }

}

// cleanupARGBUFF
// file threads.c line 373
static void cleanupARGBUFF(struct _ARGBUFF *fifop)
{
  pthread_mutex_destroy(&fifop->mutex);
}

// cleanupArgBlock
// file smalt.c line 908
static signed int cleanupArgBlock(struct _ErrMsg *errmsgp, void *p)
{
  signed int errcode = 0;
  signed short int i;
  struct SmaltArgBlock_ *blockp = (struct SmaltArgBlock_ *)p;
  /* assertion p != ((void *)0) */
  assert(p != (void *)0);
  i = (signed short int)0;
  for( ; errcode == 0 && !((signed int)i >= (signed int)blockp->n_alloc); i = i + 1)
    errcode=cleanupIOBuffArg(errmsgp, blockp->iobfp + (signed long int)i);
  if(errcode == 0)
  {
    free((void *)blockp->iobfp);
    blockp->iobfp = (struct _SmaltIOBuffArg *)(void *)0;
    blockp->n_iobf = (signed short int)0;
    blockp->n_alloc = (signed short int)0;
  }

  return errcode;
}

// cleanupIOBuffArg
// file smalt.c line 778
static signed int cleanupIOBuffArg(struct _ErrMsg *errmsgp, struct _SmaltIOBuffArg *argp)
{
  if(argp == ((struct _SmaltIOBuffArg *)NULL))
    errMsgAdd(errmsgp, "", "smalt.c", 781, 15, (unsigned char)2);

  else
  {
    seqFastqDelete(argp->readp);
    seqFastqDelete(argp->matep);
    reportDelete(argp->rep);
  }
  return 0;
}

// cleanupInput
// file smalt.c line 691
static signed int cleanupInput(struct _ErrMsg *errmsgp, void *inp)
{
  struct _SmaltInput *inargp = (struct _SmaltInput *)inp;
  signed int errcode;
  errcode=infmtGetReaderStatus(inargp->ifrp);
  if(!((4 & (signed int)inargp->menuflg) == 0))
  {
    if(inargp->pctr >= 1ul)
    {
      fprintf(stderr, "# Processed %llu read pairs", (unsigned long long int)inargp->pctr);
      if(!(inargp->pctr >= inargp->rctr))
        fprintf(stderr, "\n# and %llu single reads.\n", (unsigned long long int)(inargp->rctr - inargp->pctr));

      else
        fprintf(stderr, ".\n");
    }

    else
      fprintf(stderr, "# Processed %llu single reads.\n", (unsigned long long int)inargp->rctr);
  }

  if(!(errcode == 0) && !(errcode == 10))
  {
    inargp->errcode = errcode;
    errMsgAdd(errmsgp, "", "smalt.c", 714, errcode, (unsigned char)2);
  }

  inargp->ifrp = (struct _InFmtReader *)(void *)0;
  inargp->rctr = (unsigned long int)0LL;
  inargp->pctr = (unsigned long int)0LL;
  inargp->rival = 0;
  inargp->errcode = errcode;
  return inargp->errcode;
}

// cleanupMapArgs
// file smalt.c line 1065
static signed int cleanupMapArgs(struct _ErrMsg *errmsgp, void *p)
{
  signed int errcode = 0;
  if(p == NULL)
    errMsgAdd(errmsgp, "", "smalt.c", 1069, 15, (unsigned char)2);

  else
  {
    struct _SmaltMapArgs *argp = (struct _SmaltMapArgs *)p;
    rmapDelete(argp->rmp);
  }
  return errcode;
}

// cleanupMapConst
// file smalt.c line 428
static void cleanupMapConst(struct _SmaltMapConst *macop)
{
  infmtDeleteReader(macop->ifrp);
  hashTableDelete(macop->htp);
  seqSetDelete(macop->ssp);
  scoreDeleteMatrix(macop->scormtxp);
  scorePenaltiesDelete(macop->scorpltyp);
  seqCodecDelete(macop->codecp);
  resultSetDeleteFilter(macop->rfp);
  insDeleteHisto(macop->ihp);
  macop->htp = (struct _HashTable *)(void *)0;
  macop->ssp = (struct _SeqSet *)(void *)0;
  macop->codecp = (struct _SeqCodec *)(void *)0;
}

// cleanupREPSTR
// file report.c line 394
static void cleanupREPSTR(struct _REPSTR *rsp)
{
  if(!(rsp == ((struct _REPSTR *)NULL)))
  {
    free((void *)rsp->strp);
    rsp->strp = (char *)(void *)0;
    rsp->n_alloc = (unsigned long int)0;
    rsp->strl = rsp->n_alloc;
  }

}

// cleanupSmaltOutput
// file smalt.c line 659
static signed int cleanupSmaltOutput(struct _ErrMsg *errmsgp, void *op)
{
  signed int errcode = 0;
  struct _SmaltOutput *dop = (struct _SmaltOutput *)op;
  insDeleteSample(dop->isamp);
  dop->isamp = (struct _InsSample *)(void *)0;
  reportDeleteWriter(dop->writerp);
  dop->writerp = (struct _ReportWriter *)(void *)0;
  return errcode;
}

// cmpArgBlockReadNo
// file smalt.c line 985
static signed int cmpArgBlockReadNo(const void *buffargAp, const void *buffargBp)
{
  const struct SmaltArgBlock_ *bfAp = (const struct SmaltArgBlock_ *)buffargAp;
  const struct SmaltArgBlock_ *bfBp = (const struct SmaltArgBlock_ *)buffargBp;
  signed int rv = 0;
  _Bool tmp_if_expr$1;
  if(!(buffargAp == NULL))
    tmp_if_expr$1 = bfAp->iobfp != (struct _SmaltIOBuffArg *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion buffargAp != ((void *)0) && bfAp->iobfp != ((void *)0) */
  assert(tmp_if_expr$1);
  _Bool tmp_if_expr$2;
  if(!(buffargBp == NULL))
    tmp_if_expr$2 = bfBp->iobfp != (struct _SmaltIOBuffArg *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  /* assertion buffargBp != ((void *)0) && bfBp->iobfp != ((void *)0) */
  assert(tmp_if_expr$2);
  if(!(bfAp->iobfp->readno >= bfBp->iobfp->readno))
    rv = -1;

  else
    if(!(bfBp->iobfp->readno >= bfAp->iobfp->readno))
      rv = 1;

  return rv;
}

// cmpFILTERIVAL
// file hashhit.c line 1911
static signed int cmpFILTERIVAL(const void *this, const void *other)
{
  unsigned int a = ((const struct _FILTERIVAL *)this)->lower;
  unsigned int b = ((const struct _FILTERIVAL *)other)->lower;
  if(!(a >= b))
    return -1;

  else
    if(!(b >= a))
      return 1;

    else
      return 0;
}

// cmpIVAL
// file interval.c line 62
static signed int cmpIVAL(const void *a, const void *b)
{
  const struct _IVAL *ap = (struct _IVAL *)a;
  const struct _IVAL *bp = (struct _IVAL *)b;
  if(!(ap->sx >= bp->sx))
    return -1;

  else
    if(!(bp->sx >= ap->sx))
      return 1;

    else
      if(!(ap->lo >= bp->lo))
        return -1;

      else
        if(!(bp->lo >= ap->lo))
          return 1;

        else
          if(!(ap->hi >= bp->hi))
            return -1;

          else
            if(!(bp->hi >= ap->hi))
              return 1;

            else
              return 0;
}

// cmpMATEPAIRbyProbDescending
// file resultpairs.c line 519
static signed int cmpMATEPAIRbyProbDescending(const void *ap, const void *bp)
{
  const double a = ((struct _MATEPAIR *)ap)->pbf;
  const double b = ((struct _MATEPAIR *)bp)->pbf;
  if(a > b)
    return -1;

  else
    if(a < b)
      return 1;

    else
      return 0;
}

// cmpOFFSIVAL
// file resultpairs.c line 423
static signed int cmpOFFSIVAL(const void *a, const void *b)
{
  const struct _OFFSIVAL *ap = (struct _OFFSIVAL *)a;
  const struct _OFFSIVAL *bp = (struct _OFFSIVAL *)b;
  if(!(ap->sidx >= bp->sidx))
    return -1;

  else
    if(!(bp->sidx >= ap->sidx))
      return 1;

    else
      if(!((4 & (signed int)ap->status) >= (4 & (signed int)bp->status)))
        return 1;

      else
        if(!((4 & (signed int)bp->status) >= (4 & (signed int)ap->status)))
          return -1;

        else
          if(!(ap->lower >= bp->lower))
            return -1;

          else
            if(!(bp->lower >= ap->lower))
              return 1;

            else
              return 0;
}

// cmpPairNamStr
// file sequence.c line 222
static signed int cmpPairNamStr(const char *ap, const char *bp, unsigned long int maxlen)
{
  signed int i;
  signed int rv = 0;
  unsigned char isMate1;
  unsigned char isMate2;
  const char *extstr[2l];
  unsigned long int s = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  do
  {
    if(!(s >= maxlen))
      tmp_if_expr$1 = ap[(signed long int)s] == bp[(signed long int)s] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (signed int)ap[(signed long int)s] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    s = s + 1ul;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  const unsigned short int **return_value___ctype_b_loc$8;
  if(!(ap[(signed long int)s] == bp[(signed long int)s]))
  {
    rv = (signed int)ap[(signed long int)s] > (signed int)bp[(signed long int)s] ? 1 : -1;
    if(s >= 1ul)
    {
      i = 1;
      for( ; !(rv == 0) && !(i >= 3); i = i + 1)
        if(ap[-1l + (signed long int)s] == READNAM_MATEXT_SEPARATOR[(signed long int)i])
        {
          extstr[(signed long int)0] = (const char *)(void *)0;
          switch(i)
          {
            case 0:
              break;
            case 1:
            {
              extstr[(signed long int)0] = READNAM_MATEXT_ILLUMINA[(signed long int)0];
              extstr[(signed long int)1] = READNAM_MATEXT_ILLUMINA[(signed long int)1];
              break;
            }
            case 2:
            {
              extstr[(signed long int)0] = READNAM_MATEXT_FR[(signed long int)0];
              extstr[(signed long int)1] = READNAM_MATEXT_FR[(signed long int)1];
            }
          }
          if(!(extstr[0l] == ((const char *)NULL)))
          {
            ap = ap + (signed long int)s;
            do
            {
              if(*ap == *extstr[0l])
                tmp_if_expr$3 = (signed int)*extstr[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(!tmp_if_expr$3)
                break;

              ap = ap + 1l;
              extstr[(signed long int)0] = extstr[(signed long int)0] + 1l;
            }
            while((_Bool)1);
            if((signed int)*extstr[0l] == 0)
            {
              if((signed int)*ap == 0)
                tmp_if_expr$5 = (_Bool)1;

              else
              {
                return_value___ctype_b_loc$4=__ctype_b_loc();
                tmp_if_expr$5 = ((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*ap] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$6 = (_Bool)0;
            isMate1 = (unsigned char)tmp_if_expr$6;
            bp = bp + (signed long int)s;
            do
            {
              if(*bp == *extstr[1l])
                tmp_if_expr$7 = (signed int)*extstr[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7 = (_Bool)0;
              if(!tmp_if_expr$7)
                break;

              bp = bp + 1l;
              extstr[(signed long int)1] = extstr[(signed long int)1] + 1l;
            }
            while((_Bool)1);
            if((signed int)*extstr[1l] == 0)
            {
              if((signed int)*bp == 0)
                tmp_if_expr$9 = (_Bool)1;

              else
              {
                return_value___ctype_b_loc$8=__ctype_b_loc();
                tmp_if_expr$9 = ((signed int)(*return_value___ctype_b_loc$8)[(signed long int)(signed int)*bp] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$10 = (_Bool)0;
            isMate2 = (unsigned char)tmp_if_expr$10;
            if(!(isMate1 == 0) && !(isMate2 == 0))
              rv = 0;

          }

        }

    }

  }

  return rv;
}

// cmpRes
// file results.c line 450
static signed int cmpRes(const void *p1, const void *p2)
{
  const struct _RESULT *ap = *((struct _RESULT **)p1);
  const struct _RESULT *bp = *((struct _RESULT **)p2);
  unsigned int da;
  unsigned int db;
  if(!(ap->sidx >= bp->sidx))
    return -1;

  else
    if(!(bp->sidx >= ap->sidx))
      return 1;

    else
      if(!((4 & (signed int)ap->status) >= (4 & (signed int)bp->status)))
        return -1;

      else
        if(!((4 & (signed int)bp->status) >= (4 & (signed int)ap->status)))
          return 1;

        else
          if(!(ap->s_start >= bp->s_start))
            return -1;

          else
            if(!(bp->s_start >= ap->s_start))
              return 1;

            else
            {
              da = ap->q_end - ap->q_start;
              db = (unsigned int)(bp->s_end - bp->s_start);
              if(!(db >= da))
                return -1;

              else
                if(!(da >= db))
                  return 1;

                else
                  return 0;
            }
}

// cmpResOutput
// file results.c line 478
static signed int cmpResOutput(const void *p1, const void *p2)
{
  const struct _RESULT *ap = *((struct _RESULT **)p1);
  const struct _RESULT *bp = *((struct _RESULT **)p2);
  unsigned int da;
  unsigned int db;
  if(!(bp->swatscor >= ap->swatscor))
    return -1;

  else
    if(!(ap->swatscor >= bp->swatscor))
      return 1;

    else
      if(!((4 & (signed int)ap->status) >= (4 & (signed int)bp->status)))
        return -1;

      else
        if(!((4 & (signed int)bp->status) >= (4 & (signed int)ap->status)))
          return 1;

        else
          if(!(ap->sidx >= bp->sidx))
            return -1;

          else
            if(!(bp->sidx >= ap->sidx))
              return 1;

            else
              if(!(ap->s_start >= bp->s_start))
                return -1;

              else
                if(!(bp->s_start >= ap->s_start))
                  return 1;

                else
                {
                  da = ap->q_end - ap->q_start;
                  db = bp->q_end - bp->q_start;
                  if(!(db >= da))
                    return -1;

                  else
                    if(!(da >= db))
                      return 1;

                    else
                      return 0;
                }
}

// cmpResSegLen
// file results.c line 525
static signed int cmpResSegLen(const void *p1, const void *p2)
{
  const struct _RESULT *ap = *((struct _RESULT **)p1);
  const struct _RESULT *bp = *((struct _RESULT **)p2);
  unsigned int da;
  unsigned int db;
  if(!(bp->swatscor >= ap->swatscor))
    return -1;

  else
    if(!(ap->swatscor >= bp->swatscor))
      return 1;

    else
    {
      da = ap->q_end - ap->q_start;
      db = bp->q_end - bp->q_start;
      if(!(db >= da))
        return -1;

      else
        if(!(da >= db))
          return 1;

        else
          if(!((4 & (signed int)ap->status) >= (4 & (signed int)bp->status)))
            return -1;

          else
            if(!((4 & (signed int)bp->status) >= (4 & (signed int)ap->status)))
              return 1;

            else
              if(!(ap->sidx >= bp->sidx))
                return -1;

              else
                if(!(bp->sidx >= ap->sidx))
                  return 1;

                else
                  if(!(ap->s_start >= bp->s_start))
                    return -1;

                  else
                    if(!(bp->s_start >= ap->s_start))
                      return 1;

                    else
                      return 0;
    }
}

// cmpResSegSW
// file results.c line 509
static signed int cmpResSegSW(const void *p1, const void *p2)
{
  const struct _RESULT *ap = *((struct _RESULT **)p1);
  const struct _RESULT *bp = *((struct _RESULT **)p2);
  if(!((signed int)ap->qsegx >= (signed int)bp->qsegx))
    return -1;

  else
    if(!((signed int)bp->qsegx >= (signed int)ap->qsegx))
      return 1;

    else
      if(!(bp->swatscor >= ap->swatscor))
        return -1;

      else
        if(!(ap->swatscor >= bp->swatscor))
          return 1;

        else
          return 0;
}

// collectHitInfo
// file hashhit.c line 480
static signed int collectHitInfo(struct _HashHitInfo *hip, unsigned char is_reverse, unsigned int maxhit_per_tuple, unsigned char basqual_threshold, unsigned int seq_start, unsigned int seq_end, const struct _SeqFastq *seqp, const struct _HashTable *htp)
{
  signed int errcode = 0;
  char codtyp;
  unsigned char nskip;
  unsigned char non_stdnt = (unsigned char)0;
  unsigned int s;
  unsigned int seqlen;
  unsigned int seedctr;
  unsigned int tuplectr;
  const char *datap;
  datap=seqFastqGetConstSequence(seqp, &seqlen, &codtyp);
  unsigned char *qmaskp;
  const unsigned char *qualp;
  const char *return_value_seqFastqGetConstQualityFactors$1;
  return_value_seqFastqGetConstQualityFactors$1=seqFastqGetConstQualityFactors(seqp, (unsigned int *)(void *)0, (char *)(void *)0);
  qualp = (const unsigned char *)return_value_seqFastqGetConstQualityFactors$1;
  unsigned char ktup;
  ktup=hashTableGetKtupLen(htp, &nskip);
  const unsigned char minqval = (const unsigned char)((signed int)basqual_threshold + 33);
  const unsigned char ktup_rc_addpos = (const unsigned char)((signed int)ktup - 1 << 1);
  unsigned long int ktup_word = (unsigned long int)0LL;
  const unsigned long int wordmask = ((unsigned long int)1 << ((signed int)ktup << 1)) - (unsigned long int)1;
  struct _SEED *sp;
  unsigned int posidx;
  unsigned int nhits;
  signed long int tr_filter[4l];
  hip->status = (unsigned char)0;
  _Bool tmp_if_expr$2;
  if((signed int)ktup >= 32)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ktup != hip->ktup ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = nskip != hip->nskip ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  if(tmp_if_expr$3)
    return 47;

  else
    if(33 + (signed int)(signed short int)basqual_threshold >= 256)
      return 67;

    else
      if(!((signed int)codtyp == 1))
        return 22;

      else
        if(!(seqlen >= (unsigned int)ktup))
          return 30;

        else
          if((unsigned long int)seqlen >= hip->n_alloc)
          {
            errcode=reallocHashHitInfo(hip, seqlen + (unsigned int)1);
            if(errcode == 0)
              goto __CPROVER_DUMP_L9;

            return errcode;
          }

          else
          {

          __CPROVER_DUMP_L9:
            ;
            if(!(is_reverse == 0))
              hip->status = hip->status | (unsigned char)1;

            hip->qlen = seqlen;
            if(seq_end >= seqlen)
              seq_end = seqlen - (unsigned int)1;

            if(!(seq_end >= seq_start + (unsigned int)ktup + 4294967295u))
            {
              seq_start = (unsigned int)0;
              seq_end = seqlen - (unsigned int)1;
            }

            qmaskp = hip->qmaskp;
            s = (unsigned int)0;
            for( ; !(s >= seq_start); s = s + 1u)
              qmaskp[(signed long int)s] = (unsigned char)4;
            initRepeatFilter(tr_filter);
            hip->n_seeds = (unsigned int)0;
            seedctr = hip->n_seeds;
            s = seq_start;
            tuplectr = s;
            for( ; !(s >= seq_start + (unsigned int)ktup + 4294967295u); s = s + 1u)
            {
              if(!((4 & (signed int)datap[(signed long int)s]) == 0))
                tmp_if_expr$5 = (_Bool)1;

              else
              {
                if(!(qualp == ((const unsigned char *)NULL)))
                  tmp_if_expr$4 = (signed int)qualp[(signed long int)s] < (signed int)minqval ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$4 = (_Bool)0;
                tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$5)
                non_stdnt = ktup;

              else
                if(!(non_stdnt == 0))
                  non_stdnt = non_stdnt - 1;

              if(!(is_reverse == 0))
                ktup_word = (ktup_word >> 2) + ((unsigned long int)(((signed int)datap[(signed long int)s] ^ 3) & 3) << (signed int)ktup_rc_addpos);

              else
                ktup_word = (ktup_word << 2) + (unsigned long int)((signed int)datap[(signed long int)s] & 3);
            }
            for( ; seq_end >= s; s = s + 1u)
            {
              if(!((4 & (signed int)datap[(signed long int)s]) == 0))
                tmp_if_expr$7 = (_Bool)1;

              else
              {
                if(!(qualp == ((const unsigned char *)NULL)))
                  tmp_if_expr$6 = (signed int)qualp[(signed long int)s] < (signed int)minqval ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$6 = (_Bool)0;
                tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$7)
                non_stdnt = ktup;

              else
                if(!(non_stdnt == 0))
                  non_stdnt = non_stdnt - 1;

              if(!(is_reverse == 0))
                ktup_word = (ktup_word >> 2) + ((unsigned long int)(((signed int)datap[(signed long int)s] ^ 3) & 3) << (signed int)ktup_rc_addpos);

              else
                ktup_word = (ktup_word << 2) + (unsigned long int)((signed int)datap[(signed long int)s] & 3);
              if(!(non_stdnt == 0))
                qmaskp[(signed long int)tuplectr] = (unsigned char)5;

              else
              {
                unsigned char return_value_checkForRepeats$8;
                return_value_checkForRepeats$8=checkForRepeats((signed long int)(ktup_word & wordmask), tr_filter);
                if(!(return_value_checkForRepeats$8 == 0))
                  qmaskp[(signed long int)tuplectr] = (unsigned char)3;

                else
                {
                  nhits=hashTableGetKtupleHits((unsigned int **)(void *)0, &posidx, htp, ktup_word);
                  if(!(nhits >= 1u))
                    qmaskp[(signed long int)tuplectr] = (unsigned char)4;

                  else
                    if(maxhit_per_tuple >= 1u && !(maxhit_per_tuple >= nhits))
                      qmaskp[(signed long int)tuplectr] = (unsigned char)2;

                    else
                    {
                      hip->nhitqual_sortkeyp[(signed long int)seedctr] = nhits;
                      qmaskp[(signed long int)tuplectr] = (unsigned char)1;
                      sp = hip->seedp + (signed long int)seedctr;
                      sp->posidx = posidx;
                      sp->nhits = nhits;
                      sp->cix = (unsigned int)0;
                      sp->qoffs = tuplectr;
                      hip->sidxp[(signed long int)seedctr] = seedctr;
                      seedctr = seedctr + 1u;
                    }
                }
              }
              tuplectr = tuplectr + 1u;
            }
            for( ; !(tuplectr >= hip->qlen); tuplectr = tuplectr + 1u)
              qmaskp[(signed long int)tuplectr] = (unsigned char)0;
            hip->n_seeds = seedctr;
            return 0;
          }
}

// collectHits
// file rmap.c line 273
static signed int collectHits(struct _SegAliCands *sacp, unsigned char with_seqidx, struct _SegLst *slp, struct _HashHitList *hlp, struct _SegQMask *qmp, unsigned int n_hit_max, unsigned int n_ktup_min, unsigned int cover_min, const struct _HashHitInfo *hip, const struct _HashTable *htp, const struct _SeqSet *ssp)
{
  signed int errcode = 0;
  if(!(with_seqidx == 0))
  {
    signed long int s;
    const unsigned long int *soffsp;
    signed long int nseq;
    nseq=seqSetGetOffsets(ssp, &soffsp);
    s = (signed long int)0;
    for( ; !(s >= nseq); s = s + 1l)
    {
      hashBlankHitList(hlp);
      errcode=hashCollectHitsForSegment(hlp, soffsp[s], soffsp[s + (signed long int)1], n_hit_max, (unsigned char)1, hip, htp, (const struct _HashHitFilter *)(void *)0);
      if(!(errcode == 0))
        break;

      segLstBlank(slp);
      errcode=segLstFillHits(slp, n_ktup_min, hlp);
      if(!(errcode == 0))
        break;

      errcode=segAliCandsAddFast(sacp, qmp, slp, cover_min, (signed int)s);
      if(!(errcode == 0))
        break;

    }
  }

  else
  {
    errcode=hashCollectHitsUsingCutoff(hlp, n_hit_max, htp, hip);
    if(errcode == 0)
    {
      segLstBlank(slp);
      errcode=segLstFillHits(slp, n_ktup_min, hlp);
      if(errcode == 0)
        errcode=segAliCandsAddFast(sacp, qmp, slp, cover_min, -1);

    }

  }
  return errcode;
}

// collectHitsFromInterVal
// file rmap.c line 438
static signed int collectHitsFromInterVal(struct _SegAliCands *sacp, struct _SegLst *slp, struct _HashHitList *hlp, struct _SegQMask *qmp, unsigned int n_hit_max, unsigned int n_ktup_min, unsigned int cover_min, const struct _HashHitInfo *hip, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivr)
{
  signed int errcode = 0;
  signed int i;
  signed int niv;
  niv=interValNum(ivr);
  unsigned int lo;
  unsigned int hi;
  signed long int sx;
  const unsigned long int *soffsp;
  unsigned long int offs;
  seqSetGetOffsets(ssp, &soffsp);
  i = 0;
  for( ; !(i >= niv); i = i + 1)
  {
    errcode=interValGet(&lo, &hi, &sx, (unsigned short int *)(void *)0, i, ivr);
    if(!(errcode == 0))
      break;

    hashBlankHitList(hlp);
    offs = soffsp[sx];
    errcode=hashCollectHitsForSegment(hlp, offs + (unsigned long int)lo, offs + (unsigned long int)hi + (unsigned long int)1, n_hit_max, (unsigned char)0, hip, htp, (const struct _HashHitFilter *)(void *)0);
    if(!(errcode == 0))
      break;

    segLstBlank(slp);
    errcode=segLstFillHits(slp, n_ktup_min, hlp);
    if(!(errcode == 0))
      break;

    errcode=segAliCandsAddFast(sacp, qmp, slp, cover_min, (signed int)sx);
    if(!(errcode == 0))
      break;

  }
  return errcode;
}

// collectWords
// file hashidx.c line 223
static signed int collectWords(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr)
{
  unsigned int key;
  unsigned int key_hi;
  unsigned int word_hi;
  unsigned int *iwp;
  word_hi = (unsigned int)((word & htp->wordmask_hi) >> (signed int)htp->nbits_lo);
  unsigned int return_value_hash32mix$1;
  return_value_hash32mix$1=hash32mix(word_hi);
  key_hi = return_value_hash32mix$1 % htp->keymod;
  key = (unsigned int)((unsigned long int)(key_hi << (signed int)htp->nbits_lo) + (word & htp->wordmask_lo));
  iwp = htp->pos + (signed long int)htp->idx[(signed long int)key];
  _Bool tmp_if_expr$4;
  unsigned int tmp_post$2;
  unsigned int tmp_post$3;
  if(htp->wordctr[(signed long int)key] == 0u)
  {
    htp->wordctr[(signed long int)key] = (unsigned int)1;
    iwp[(signed long int)0] = word_hi;
  }

  else
  {
    unsigned int pivot;
    unsigned int b;
    unsigned int a = (unsigned int)0;
    b = htp->wordctr[(signed long int)key] - (unsigned int)1;
    while(!(a >= b))
    {
      pivot = a + b >> 1;
      if(!(iwp[(signed long int)pivot] >= word_hi))
        a = pivot + (unsigned int)1;

      else
        b = pivot;
    }
    if(!(b >= a))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = iwp[(signed long int)b] < word_hi ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      tmp_post$2 = htp->wordctr[(signed long int)key];
      htp->wordctr[(signed long int)key] = htp->wordctr[(signed long int)key] + 1u;
      iwp[(signed long int)tmp_post$2] = word_hi;
    }

    else
      if(!(word_hi >= iwp[(signed long int)b]))
      {
        tmp_post$3 = htp->wordctr[(signed long int)key];
        htp->wordctr[(signed long int)key] = htp->wordctr[(signed long int)key] + 1u;
        a = tmp_post$3;
        for( ; !(b >= a); a = a - 1u)
          iwp[(signed long int)a] = iwp[(signed long int)(a - (unsigned int)1)];
        iwp[(signed long int)b] = word_hi;
      }

  }
  return 0;
}

// complementAsciiSeqInPlace
// file sequence.c line 1323
static signed int complementAsciiSeqInPlace(struct _SEQSEQ *sp, const struct _SeqCodec *codep)
{
  char *cp;
  unsigned char c;
  signed int tmp_if_expr$1;
  if(!((signed int)sp->code == 0))
    return 22;

  else
  {
    cp = sp->basep;
    for( ; !(*cp == 0); cp = cp + 1l)
    {
      c = (unsigned char)codep->codtab[(signed long int)(signed int)*cp];
      if(!((4 & (signed int)c) == 0))
        tmp_if_expr$1 = 78;

      else
        tmp_if_expr$1 = (signed int)codep->alphabet[(signed long int)(~((signed int)c) & 3)];
      *cp = (char)tmp_if_expr$1;
    }
    return 0;
  }
}

// compressSeq
// file sequence.c line 1360
static signed int compressSeq(struct _SEQSEQ *sp)
{
  char *fromp;
  char *hp;
  signed int nsu;
  unsigned int *top;
  unsigned int to_unit;
  unsigned long int unit_ctr;
  unsigned long int i;
  unsigned int *tmp_post$2;
  unsigned int *tmp_post$3;
  if(!((signed int)sp->code == 1))
    return 22;

  else
  {
    if(!(sp->alloc_size >= 5ul))
    {
      void *return_value_erealloc$1;
      return_value_erealloc$1=erealloc((void *)sp->basep, (unsigned long int)(4 + 1) * sizeof(char) /*1ul*/ , (unsigned long int)0, "sequence.c", 1379);
      hp = (char *)return_value_erealloc$1;
      if(hp == ((char *)NULL))
        return 2;

      sp->basep = hp;
      sp->alloc_size = (unsigned long int)(4 + 1);
    }

    sp->code = (char)2;
    sp->nbit_symb = (char)3;
    top = (unsigned int *)sp->basep;
    unit_ctr = (unsigned long int)1;
    fromp = sp->basep;
    i = (unsigned long int)0;
    nsu = 10 - 1;
    to_unit = (unsigned int)0;
    for( ; !(i >= sp->size); i = i + 1ul)
    {
      if(!(fromp[(signed long int)i] == 0))
        to_unit = to_unit + (((unsigned int)fromp[(signed long int)i] & (unsigned int)7) << nsu * 3);

      else
        to_unit = to_unit + ((unsigned int)7 << nsu * 3);
      nsu = nsu - 1;
      if(!(nsu >= 0))
      {
        tmp_post$2 = top;
        top = top + 1l;
        *tmp_post$2 = to_unit;
        to_unit = (unsigned int)0;
        nsu = 10 - 1;
        unit_ctr = unit_ctr + 1ul;
      }

    }
    to_unit = to_unit + ((unsigned int)7 << nsu * 3);
    tmp_post$3 = top;
    top = top + 1l;
    *tmp_post$3 = to_unit;
    if(!(unit_ctr == sp->size / 10ul + 1ul))
      return 28;

    else
    {
      void *return_value_erealloc$4;
      return_value_erealloc$4=erealloc((void *)sp->basep, (unit_ctr * (unsigned long int)4 + (unsigned long int)1) * sizeof(char) /*1ul*/ , (unsigned long int)0, "sequence.c", 1416);
      hp = (char *)return_value_erealloc$4;
      if(hp == ((char *)NULL))
        return 2;

      else
      {
        sp->basep = hp;
        sp->alloc_size = unit_ctr * (unsigned long int)4;
        hp[(signed long int)sp->alloc_size] = (char)0;
        sp->code = (char)2;
        return 0;
      }
    }
  }
}

// convertInputFormat
// file smalt.c line 247
static unsigned char convertInputFormat(unsigned char form)
{
  unsigned char rv;
  switch((signed int)form)
  {
    case 1:
    {
      rv = (unsigned char)1;
      break;
    }
    case 2:
    {
      rv = (unsigned char)2;
      break;
    }
    case 3:
    {
      rv = (unsigned char)3;
      break;
    }
    case 0:

    default:
      rv = (unsigned char)0;
  }
  return rv;
}

// convertOutputFormat
// file smalt.c line 209
static unsigned char convertOutputFormat(unsigned char *modiflg, unsigned char form, const struct _MenuOpt *mp)
{
  char rv;
  signed int return_value_menuTestMapOutputFormatFlags$1;
  signed int return_value_menuTestMapOutputFormatFlags$2;
  signed int return_value_menuTestMapOutputFormatFlags$3;
  signed int return_value_menuTestMapOutputFormatFlags$4;
  signed int return_value_menuTestMapOutputFormatFlags$5;
  signed int return_value_menuTestMapOutputFormatFlags$6;
  switch((signed int)form)
  {
    case 0:
    {
      rv = (char)0;
      break;
    }
    case 1:
    {
      rv = (char)2;
      return_value_menuTestMapOutputFormatFlags$1=menuTestMapOutputFormatFlags(mp, form, (const unsigned char)2);
      if(return_value_menuTestMapOutputFormatFlags$1 == 0)
        *modiflg = *modiflg | (unsigned char)2;

      return_value_menuTestMapOutputFormatFlags$2=menuTestMapOutputFormatFlags(mp, form, (const unsigned char)1);
      if(!(return_value_menuTestMapOutputFormatFlags$2 == 0))
        *modiflg = *modiflg | (unsigned char)4;

      return_value_menuTestMapOutputFormatFlags$3=menuTestMapOutputFormatFlags(mp, form, (const unsigned char)4);
      if(!(return_value_menuTestMapOutputFormatFlags$3 == 0))
        *modiflg = *modiflg | (unsigned char)8;

      break;
    }
    case 2:
    {
      rv = (char)3;
      return_value_menuTestMapOutputFormatFlags$4=menuTestMapOutputFormatFlags(mp, form, (const unsigned char)2);
      if(return_value_menuTestMapOutputFormatFlags$4 == 0)
        *modiflg = *modiflg | (unsigned char)2;

      return_value_menuTestMapOutputFormatFlags$5=menuTestMapOutputFormatFlags(mp, form, (const unsigned char)1);
      if(!(return_value_menuTestMapOutputFormatFlags$5 == 0))
        *modiflg = *modiflg | (unsigned char)4;

      return_value_menuTestMapOutputFormatFlags$6=menuTestMapOutputFormatFlags(mp, form, (const unsigned char)4);
      if(!(return_value_menuTestMapOutputFormatFlags$6 == 0))
        *modiflg = *modiflg | (unsigned char)8;

      break;
    }
    case 3:
    {
      rv = (char)1;
      break;
    }
    case 4:
    {
      rv = (char)4;
      break;
    }
    default:
      rv = (char)0;
  }
  return (unsigned char)rv;
}

// copyReadNamStrToREPSTR
// file report.c line 434
static signed int copyReadNamStrToREPSTR(struct _REPSTR *rsp, unsigned char is_stripped, const char *namp)
{
  signed int errcode = 0;
  signed int i;
  signed int c;
  i = 0;
  for( ; !(i >= 0x7fffffff); i = i + 1)
  {
    c = (signed int)namp[(signed long int)i];
    if(c == 0)
      break;

    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)c]) == 0))
      break;

    if(1ul + (unsigned long int)i >= rsp->n_alloc)
    {
      errcode=reallocREPSTR(rsp, (unsigned long int)(i + 1));
      if(!(errcode == 0))
        break;

    }

    rsp->strp[(signed long int)i] = (char)c;
  }
  _Bool tmp_if_expr$2;
  if(i >= 3 && !(is_stripped == 0))
  {
    if((signed int)rsp->strp[(signed long int)(i + -2)] == 47)
    {
      if((signed int)rsp->strp[(signed long int)(i + -1)] == 49)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)rsp->strp[(signed long int)(i - 1)] == 50 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        i = i - 2;

    }

  }

  rsp->strp[(signed long int)i] = (char)0;
  rsp->strl = (unsigned long int)i;
  return i < 0x7fffffff ? errcode : 81;
}

// copyReadNameToREPSTR
// file report.c line 463
static signed int copyReadNameToREPSTR(struct _REPSTR *rsp, unsigned char is_stripped, const struct _SeqFastq *sqp)
{
  const char *namp;
  const char *tmp_if_expr$2;
  const char *return_value_seqFastqGetSeqName$1;
  if(sqp == ((const struct _SeqFastq *)NULL))
    tmp_if_expr$2 = OUFMT_SAM_NULLSTR;

  else
  {
    return_value_seqFastqGetSeqName$1=seqFastqGetSeqName(sqp);
    tmp_if_expr$2 = return_value_seqFastqGetSeqName$1;
  }
  namp = tmp_if_expr$2;
  signed int return_value_copyReadNamStrToREPSTR$3;
  return_value_copyReadNamStrToREPSTR$3=copyReadNamStrToREPSTR(rsp, is_stripped, namp);
  return return_value_copyReadNamStrToREPSTR$3;
}

// copySAMheaderCommandLineToREPSTR
// file report.c line 473
static signed int copySAMheaderCommandLineToREPSTR(struct _REPSTR *rsp, const char *prognam, const char *progversion, signed int narg, char * const *argv)
{
  signed int errcode = 0;
  signed int i;
  signed int nc;
  unsigned long int maxlen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(SAMFORM_PROGLINE);
  maxlen = return_value_strlen$1 + (unsigned long int)1;
  rsp->strp[(signed long int)0] = (char)0;
  rsp->strl = (unsigned long int)0;
  unsigned long int return_value_strlen$2;
  if(argv == ((char * const *)NULL) || !(narg >= 1))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= narg); i = i + 1)
    {
      return_value_strlen$2=strlen(argv[(signed long int)i]);
      maxlen = maxlen + return_value_strlen$2 + (unsigned long int)1;
    }
    if(!(rsp->n_alloc >= maxlen))
    {
      errcode=reallocREPSTR(rsp, maxlen);
      if(errcode == 0)
        goto __CPROVER_DUMP_L4;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      nc=sprintf(rsp->strp, SAMFORM_PROGLINE, prognam, prognam, progversion);
      if(!(nc >= 1))
        return 11;

      else
      {
        rsp->strl = rsp->strl + (unsigned long int)nc;
        nc=sprintf(rsp->strp + (signed long int)rsp->strl, "%s", argv[(signed long int)0]);
        if(!(nc >= 1))
          return 11;

        else
        {
          rsp->strl = rsp->strl + (unsigned long int)nc;
          i = 1;
          for( ; !(i >= narg); i = i + 1)
          {
            nc=sprintf(rsp->strp + (signed long int)rsp->strl, " %s", argv[(signed long int)i]);
            if(!(nc >= 1))
              return 11;

            rsp->strl = rsp->strl + (unsigned long int)nc;
          }
          nc=sprintf(rsp->strp + (signed long int)rsp->strl, "\n");
          if(!(nc >= 1))
            return 11;

          else
          {
            rsp->strl = rsp->strl + (unsigned long int)nc;
            return 0;
          }
        }
      }
    }
  }
}

// countCollisionKey
// file hashidx.c line 206
static signed int countCollisionKey(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr)
{
  unsigned int key;
  unsigned int key_hi;
  unsigned int word_hi = (unsigned int)((word & htp->wordmask_hi) >> (signed int)htp->nbits_lo);
  unsigned int return_value_hash32mix$1;
  return_value_hash32mix$1=hash32mix(word_hi);
  key_hi = return_value_hash32mix$1 % htp->keymod;
  key = (unsigned int)((unsigned long int)(key_hi << (signed int)htp->nbits_lo) + (word & htp->wordmask_lo));
  htp->idx[(signed long int)key] = htp->idx[(signed long int)key] + 1u;
  return 0;
}

// countPerfectKey
// file hashidx.c line 191
static signed int countPerfectKey(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr)
{
  htp->idx[(signed long int)(word & htp->wordmask)] = htp->idx[(signed long int)(word & htp->wordmask)] + 1u;
  return 0;
}

// countWords
// file hashidx.c line 265
static signed int countWords(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr)
{
  unsigned int key;
  unsigned int key_hi;
  unsigned int word_hi;
  unsigned int pivot;
  unsigned int b;
  unsigned int a;
  word_hi = (unsigned int)((word & htp->wordmask_hi) >> (signed int)htp->nbits_lo);
  unsigned int return_value_hash32mix$1;
  return_value_hash32mix$1=hash32mix(word_hi);
  key_hi = return_value_hash32mix$1 % htp->keymod;
  key = (unsigned int)((unsigned long int)(key_hi << (signed int)htp->nbits_lo) + (word & htp->wordmask_lo));
  b = htp->idx[(signed long int)(key + (unsigned int)1)];
  _Bool tmp_if_expr$2;
  if(!(b >= 1u))
    return 69;

  else
  {
    a = htp->idx[(signed long int)key];
    b = b - 1u;
    while(!(a >= b))
    {
      pivot = a + b >> 1;
      if(!(htp->wordidx[(signed long int)pivot] >= word_hi))
        a = pivot + (unsigned int)1;

      else
        b = pivot;
    }
    if(!(b >= a))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = htp->wordidx[(signed long int)b] != word_hi ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 69;

    else
    {
      htp->posidx[(signed long int)b] = htp->posidx[(signed long int)b] + 1u;
      return 0;
    }
  }
}

// createALICPLX
// file alignment.c line 238
static struct _ALICPLX * createALICPLX(const struct _ScoreMatrix *smp)
{
  struct _ALICPLX *p;
  signed short int alphabetsiz;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ALICPLX) /*24ul*/ , "alignment.c", 243);
  p = (struct _ALICPLX *)return_value_ecalloc$1;
  if(!(p == ((struct _ALICPLX *)NULL)))
  {
    alphabetsiz=scoreMatrixGetAlphabetSize(smp);
    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)alphabetsiz, sizeof(signed int) /*4ul*/ , "alignment.c", 246);
    p->countp = (signed int *)return_value_ecalloc$2;
    if(p->countp == ((signed int *)NULL))
    {
      deleteALICPLX(p);
      p = ((struct _ALICPLX *)NULL);
    }

    else
    {
      p->n_types = alphabetsiz;
      p->lambda=scoreMatrixCalcLambda(smp);
    }
  }

  return p;
}

// createREPNAMBUF
// file report.c line 528
static struct _REPNAMBUF * createREPNAMBUF(void)
{
  struct _REPNAMBUF *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _REPNAMBUF) /*96ul*/ , "report.c", 531);
  p = (struct _REPNAMBUF *)return_value_ecalloc$1;
  _Bool tmp_if_expr$3;
  signed int return_value_initREPSTR$2;
  if(p == ((struct _REPNAMBUF *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_initREPSTR$2=initREPSTR(&p->ref_nam, 0);
    tmp_if_expr$3 = return_value_initREPSTR$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_initREPSTR$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_initREPSTR$4=initREPSTR(&p->mref_nam, 0);
    tmp_if_expr$5 = return_value_initREPSTR$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_initREPSTR$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_initREPSTR$6=initREPSTR(&p->q_nam, 0);
    tmp_if_expr$7 = return_value_initREPSTR$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    deleteREPNAMBUF(p);
    p = (struct _REPNAMBUF *)(void *)0;
  }

  return p;
}

// createRMAPBUFF
// file rmap.c line 1114
static struct RMAPBUFF_ * createRMAPBUFF(const struct _ScoreMatrix *scormtxp)
{
  struct RMAPBUFF_ *rmp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct RMAPBUFF_) /*72ul*/ , "rmap.c", 1118);
  rmp = (struct RMAPBUFF_ *)return_value_ecalloc$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(rmp == ((struct RMAPBUFF_ *)NULL))
    return ((struct RMAPBUFF_ *)NULL);

  else
  {
    rmp->sqbfp=seqFastqCreate(0, (char)2);
    rmp->qbfp=seqFastqCreate(0, (char)2);
    rmp->hhlp=hashCreateHitList(16384);
    rmp->sglp=segLstCreate(65536);
    rmp->sacp=segAliCandsCreate(32768);
    void *return_value_arrayCreate$2;
    return_value_arrayCreate$2=arrayCreate(sizeof(struct RMAPCAND_) /*64ul*/ , (unsigned long int)512, "rmap.c", 1126);
    rmp->candr = (struct RMAPCAND_ *)return_value_arrayCreate$2;
    rmp->alibufp=aliBufferCreate(0);
    rmp->alirsltp=aliRsltSetCreate(scormtxp, (signed short int)0, (signed short int)0, 0, 0);
    rmp->qmp=segQMaskCreate(0);
    if(!(rmp->hhlp == ((struct _HashHitList *)NULL)))
      tmp_if_expr$3 = rmp->sglp != ((struct _SegLst *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = rmp->sacp != ((struct _SegAliCands *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = rmp->candr != ((struct RMAPCAND_ *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = rmp->alibufp != ((struct _AliBuffer *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = rmp->alirsltp != ((struct _AliRsltSet *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = rmp->qmp != ((struct _SegQMask *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(!tmp_if_expr$8)
    {
      deleteRMAPBUFF(rmp);
      rmp = ((struct RMAPBUFF_ *)NULL);
    }

    return rmp;
  }
}

// createRMAPINFO
// file rmap.c line 1010
static struct RMAPINFO_ * createRMAPINFO(const struct _HashTable *htp)
{
  struct RMAPINFO_ *rmp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct RMAPINFO_) /*16ul*/ , "rmap.c", 1013);
  rmp = (struct RMAPINFO_ *)return_value_ecalloc$1;
  _Bool tmp_if_expr$2;
  if(rmp == ((struct RMAPINFO_ *)NULL))
    return ((struct RMAPINFO_ *)NULL);

  else
  {
    rmp->hhiFp=hashCreateHitInfo(1024, htp);
    rmp->hhiRp=hashCreateHitInfo(1024, htp);
    if(!(rmp->hhiFp == ((struct _HashHitInfo *)NULL)))
      tmp_if_expr$2 = rmp->hhiRp != ((struct _HashHitInfo *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
    {
      deleteRMAPINFO(rmp);
      rmp = ((struct RMAPINFO_ *)NULL);
    }

    return rmp;
  }
}

// createRMAPPROF
// file rmap.c line 944
static struct RMAPPROF_ * createRMAPPROF(const struct _SeqCodec * const codecp)
{
  struct RMAPPROF_ *p;
  const unsigned char mode = (const unsigned char)(1 | 2 | 4);
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct RMAPPROF_) /*24ul*/ , "rmap.c", 958);
  p = (struct RMAPPROF_ *)return_value_ecalloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(p == ((struct RMAPPROF_ *)NULL))
    return (struct RMAPPROF_ *)(void *)0;

  else
  {
    p->readRCp=seqFastqCreate(0, (char)2);
    p->scorprofp=scoreCreateProfile(0, codecp, mode);
    p->scorprofRCp=scoreCreateProfile(0, codecp, mode);
    if(p->readRCp == ((struct _SeqFastq *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (struct _ScoreProfile *)(void *)0 == p->scorprofp ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (struct _ScoreProfile *)(void *)0 == p->scorprofRCp ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      deleteRMAPPROF(p);
      p = (struct RMAPPROF_ *)(void *)0;
    }

    return p;
  }
}

// createSeq
// file sequence.c line 716
static struct _SEQSEQ * createSeq(unsigned int blocksize)
{
  struct _SEQSEQ *sp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SEQSEQ) /*48ul*/ , "sequence.c", 724);
  sp = (struct _SEQSEQ *)return_value_ecalloc$1;
  if(sp == ((struct _SEQSEQ *)NULL))
    return (struct _SEQSEQ *)(void *)0;

  else
  {
    if(!(blocksize >= 1u))
      blocksize = (unsigned int)256;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blocksize, sizeof(char) /*1ul*/ , "sequence.c", 729);
    sp->basep = (char *)return_value_ecalloc$2;
    if(sp->basep == ((char *)NULL))
    {
      deleteSeq(sp);
      return (struct _SEQSEQ *)(void *)0;
    }

    else
    {
      sp->code = (char)0;
      *sp->basep = (char)0;
      sp->block_size = (signed int)blocksize;
      sp->alloc_size = (unsigned long int)sp->block_size;
      sp->size = (unsigned long int)0;
      sp->nbit_symb = (char)8;
      return sp;
    }
  }
}

// cropSeq
// file sequence.c line 805
static signed int cropSeq(struct _SEQSEQ *sp, unsigned int s, unsigned int e)
{
  char *tmp_post$1;
  if((signed int)sp->code == 2)
    return 22;

  else
    if(!(e >= s))
      return 29;

    else
      if(!(sp->size >= 2ul))
        return 0;

      else
      {
        if((unsigned long int)e >= sp->size)
          e = (unsigned int)(sp->size - (unsigned long int)1);

        sp->size = (unsigned long int)((e - s) + (unsigned int)1);
        if(s >= 1u)
        {
          char *cp = sp->basep;
          for( ; e >= s; s = s + 1u)
          {
            tmp_post$1 = cp;
            cp = cp + 1l;
            *tmp_post$1 = sp->basep[(signed long int)s];
          }
        }

        sp->basep[(signed long int)(e + (unsigned int)1)] = (char)0;
        return 0;
      }
}

// curtailSeqAtFirstSpace
// file sequence.c line 1148
static unsigned int curtailSeqAtFirstSpace(struct _SEQSEQ *sp)
{
  unsigned int i = (unsigned int)0;
  for( ; !((unsigned long int)i >= sp->size); i = i + 1u)
    if((signed int)sp->basep[(signed long int)i] == 32)
    {
      sp->basep[(signed long int)i] = (char)0;
      sp->size = (unsigned long int)i;
      break;
    }

  return (unsigned int)sp->size;
}

// decodeSeq
// file sequence.c line 1552
static signed int decodeSeq(struct _SEQSEQ *sp, const struct _SeqCodec *codep)
{
  unsigned char *cp;
  if(!((signed int)sp->code == 1))
    return 22;

  else
  {
    cp = (unsigned char *)sp->basep;
    for( ; !(*cp == 0); cp = cp + 1l)
      *cp = (unsigned char)codep->decodtab[(signed long int)*cp];
    sp->code = (char)0;
    return 0;
  }
}

// decodeSeqAsStandardNt
// file sequence.c line 1565
static signed int decodeSeqAsStandardNt(struct _SEQSEQ *dep, const struct _SEQSEQ *sp, unsigned long int start, unsigned long int length, const struct _SeqCodec *codep, char as_rcp)
{
  char *bufp;
  unsigned char c;
  const unsigned char *fromp;
  const unsigned char *endp;
  _Bool tmp_if_expr$1;
  signed int return_value_reallocSeqBlocks$2;
  char *tmp_post$3;
  signed int tmp_if_expr$4;
  char *tmp_post$5;
  const unsigned char *tmp_post$6;
  if(!((signed int)sp->code == 1))
    return 22;

  else
    if(!(sp->size >= start))
      return 29;

    else
    {
      if(length == 0ul)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = length > sp->size ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        length = sp->size - start;

      if(!(dep->alloc_size >= 1ul + length))
      {
        return_value_reallocSeqBlocks$2=reallocSeqBlocks(dep, length + (unsigned long int)1);
        if(return_value_reallocSeqBlocks$2 == 0)
          goto __CPROVER_DUMP_L6;

        return 2;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        bufp = dep->basep;
        if(!(as_rcp == 0))
        {
          endp = (unsigned char *)sp->basep + (signed long int)start;
          fromp = endp + (signed long int)length;
          for( ; !(endp >= fromp); *tmp_post$3 = (char)tmp_if_expr$4)
          {
            fromp = fromp - 1l;
            c = *fromp;
            tmp_post$3 = bufp;
            bufp = bufp + 1l;
            if(!((4 & (signed int)c) == 0))
              tmp_if_expr$4 = 78;

            else
              tmp_if_expr$4 = (signed int)codep->alphabet[(signed long int)(~((signed int)c) & 3)];
          }
        }

        else
        {
          fromp = (unsigned char *)sp->basep + (signed long int)start;
          endp = fromp + (signed long int)length;
          for( ; !(fromp >= endp); *tmp_post$5 = codep->alphabet[(signed long int)((signed int)*tmp_post$6 & 7)])
          {
            tmp_post$5 = bufp;
            bufp = bufp + 1l;
            tmp_post$6 = fromp;
            fromp = fromp + 1l;
          }
        }
        *bufp = (char)0;
        dep->size = length;
        dep->code = (char)0;
        return 0;
      }
    }
}

// defineHitRegions
// file segment.c line 396
static signed int defineHitRegions(struct _HITREGION **idxr, signed int *n_added, unsigned short int *max_dshift, unsigned int min_ktup, const struct _HashHitList *hhlp)
{
  unsigned char ktup;
  unsigned char nskip;
  signed int i;
  signed int j;
  signed int nhits;
  unsigned int ds;
  unsigned long int dsthresh;
  unsigned int qlen;
  unsigned long int n0;
  struct _HITREGION *sp;
  const unsigned long int *shdat;
  shdat=hashGetHitListData(&nhits, (char *)(void *)0, &qlen, &ktup, &nskip, (const char **)(void *)0, hhlp);
  if(!(n_added == ((signed int *)NULL)))
  {
    n0 = ((unsigned long int *)*idxr)[(signed long int)-1];
    *n_added = 0;
  }

  else
  {
    ((unsigned long int *)*idxr)[(signed long int)-1] = (unsigned long int)0;
    n0 = (unsigned long int)0;
  }
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  if(!(nhits >= 1))
    return 0;

  else
  {
    *max_dshift = (unsigned short int)(((signed int)ktup * 3) / (signed int)nskip);
    ds = (qlen - (unsigned int)ktup) / (unsigned int)nskip + (unsigned int)1;
    if(!(ds >= (unsigned int)*max_dshift))
      *max_dshift = (unsigned short int)ds;

    dsthresh = (unsigned long int)*max_dshift << 31;
    i = 0;
    for( ; !(i >= nhits); i = j)
    {
      j = i + 1;
      for( ; !(j >= nhits); j = j + 1)
        if(shdat[(signed long int)j] + -shdat[(signed long int)(j + -1)] >= dsthresh)
          break;

      if((unsigned int)j + -((unsigned int)i) >= min_ktup)
      {
        if(((unsigned long int *)*idxr)[-1l] >= ((unsigned long int *)*idxr)[-2l])
        {
          void *return_value_arrayRealloc$1;
          return_value_arrayRealloc$1=arrayRealloc((void *)*idxr, (unsigned long int)0, (char)0, "segment.c", 437);
          sp = (struct _HITREGION *)return_value_arrayRealloc$1;
          if(!(sp == ((struct _HITREGION *)NULL)))
          {
            *idxr = sp;
            tmp_post$2 = ((unsigned long int *)*idxr)[(signed long int)-1];
            ((unsigned long int *)*idxr)[(signed long int)-1] = ((unsigned long int *)*idxr)[(signed long int)-1] + 1ul;
            sp = *idxr + (signed long int)tmp_post$2;
          }

        }

        else
        {
          tmp_post$3 = ((unsigned long int *)*idxr)[(signed long int)-1];
          ((unsigned long int *)*idxr)[(signed long int)-1] = ((unsigned long int *)*idxr)[(signed long int)-1] + 1ul;
          sp = *idxr + (signed long int)tmp_post$3;
        }
        if(sp == ((struct _HITREGION *)NULL))
          return 2;

        sp->idx = (unsigned int)i;
        sp->num = j - i;
      }

    }
    if(!(n_added == ((signed int *)NULL)))
    {
      n0 = ((unsigned long int *)*idxr)[(signed long int)-1] - n0;
      if(n0 >= 2147483648ul)
        return 48;

      *n_added = (signed int)n0;
    }

    return 0;
  }
}

// deleteALICPLX
// file alignment.c line 230
static void deleteALICPLX(struct _ALICPLX *p)
{
  if(!(p == ((struct _ALICPLX *)NULL)))
    free((void *)p->countp);

  free((void *)p);
}

// deleteREPNAMBUF
// file report.c line 518
static void deleteREPNAMBUF(struct _REPNAMBUF *p)
{
  if(!(p == ((struct _REPNAMBUF *)NULL)))
  {
    cleanupREPSTR(&p->q_nam);
    cleanupREPSTR(&p->mref_nam);
    cleanupREPSTR(&p->ref_nam);
  }

  free((void *)p);
}

// deleteRMAPBUFF
// file rmap.c line 1098
static void deleteRMAPBUFF(struct RMAPBUFF_ *rmp)
{
  if(!(rmp == ((struct RMAPBUFF_ *)NULL)))
  {
    seqFastqDelete(rmp->sqbfp);
    seqFastqDelete(rmp->qbfp);
    hashDeleteHitList(rmp->hhlp);
    segLstDelete(rmp->sglp);
    segAliCandsDelete(rmp->sacp);
    free((void *)((unsigned long int *)rmp->candr - (signed long int)4));
    rmp->candr = (struct RMAPCAND_ *)(void *)0;
    aliBufferDelete(rmp->alibufp);
    aliRsltSetDelete(rmp->alirsltp);
    segQMaskDelete(rmp->qmp);
  }

  free((void *)rmp);
}

// deleteRMAPINFO
// file rmap.c line 1001
static void deleteRMAPINFO(struct RMAPINFO_ *rmp)
{
  if(!(rmp == ((struct RMAPINFO_ *)NULL)))
  {
    hashDeleteHitInfo(rmp->hhiFp);
    hashDeleteHitInfo(rmp->hhiRp);
  }

  free((void *)rmp);
}

// deleteRMAPPROF
// file rmap.c line 934
static void deleteRMAPPROF(struct RMAPPROF_ *p)
{
  if(!(p == ((struct RMAPPROF_ *)NULL)))
  {
    scoreDeleteProfile(p->scorprofRCp);
    scoreDeleteProfile(p->scorprofp);
    seqFastqDelete(p->readRCp);
  }

  free((void *)p);
}

// deleteSeq
// file sequence.c line 708
static void deleteSeq(struct _SEQSEQ *sp)
{
  if(!(sp == ((struct _SEQSEQ *)NULL)))
    free((void *)sp->basep);

  free((void *)sp);
}

// derriveSEGCAND
// file segment.c line 929
static signed int derriveSEGCAND(struct _SEGCAND *candp, signed int segix_start, signed int nseg, struct _SEGMENT *segmbasp, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip, unsigned int cover, unsigned int mincover_noindel, unsigned int hregix, unsigned char is_reverse)
{
  signed int n;
  unsigned int qs;
  unsigned int qe;
  unsigned int rs;
  unsigned int re;
  unsigned long int shift_range;
  unsigned char flag = (unsigned char)0;
  signed long int shift_min;
  signed long int shift_start;
  signed long int diff_shift;
  signed long int shift_2mm;
  unsigned int maxcover;
  struct _SEGMENT *segmp;
  struct _SEGMENT *segmentp = segmbasp + (signed long int)segix_start;
  unsigned long int offbit = (unsigned long int)1 << 31 + 1;
  if(!(segmentp->nseed >= 0))
    return 47;

  else
  {
    calcSegmentBoundaries(&candp->qs, &candp->qe, &candp->rs, &candp->re, segmentp, seedr, ktup, nskip, is_reverse);
    segmentp->nseed = segmentp->nseed * -1;
    shift_min = (signed long int)((seedr + (signed long int)segmentp->ix)->sqo >> 31);
    shift_2mm = shift_min;
    maxcover = segmentp->cover;
    segmp = segmentp + (signed long int)1;
    n = 1;
    for( ; !(n >= nseg); segmp = segmp + 1l)
    {
      if(!(segmp->nseed >= 0))
        return 47;

      calcSegmentBoundaries(&qs, &qe, &rs, &re, segmp, seedr, ktup, nskip, is_reverse);
      if(!(maxcover >= segmp->cover))
      {
        shift_2mm = (signed long int)((seedr + (signed long int)segmp->ix)->sqo >> 31);
        maxcover = segmp->cover;
      }

      segmp->nseed = segmp->nseed * -1;
      if(!(qs >= candp->qs))
        candp->qs = qs;

      if(!(candp->qe >= qe))
        candp->qe = qe;

      if(!(rs >= candp->rs))
        candp->rs = rs;

      if(!(candp->re >= re))
        candp->re = re;

      n = n + 1;
    }
    segmp = segmp - 1l;
    if(!(is_reverse == 0))
    {
      flag = flag | (unsigned char)1;
      shift_start = (signed long int)candp->rs + (signed long int)(((candp->qe - (unsigned int)ktup) + (unsigned int)1) / (unsigned int)nskip);
    }

    else
      shift_start = (signed long int)(((unsigned long int)(signed long int)candp->rs | offbit) - (unsigned long int)(candp->qs / (unsigned int)nskip));
    shift_range = (unsigned long int)((signed long int)((seedr + (signed long int)segmp->ix)->sqo >> 31) - shift_min);
    diff_shift = shift_min - shift_start;
    if(shift_range >= 32768ul)
      return 48;

    else
      if(diff_shift >= 32768l || !(diff_shift >= -32768l))
        return 48;

      else
      {
        candp->shiftoffs = (signed short int)diff_shift;
        if(maxcover >= mincover_noindel)
        {
          signed long int ds_2mm = shift_2mm - shift_start;
          flag = flag | (unsigned char)4;
          if(ds_2mm >= 32768l || !(ds_2mm >= -32768l))
            return 48;

          candp->shift2mm = (signed short int)ds_2mm;
        }

        else
          candp->shift2mm = (signed short int)0;
        candp->flag = flag;
        candp->srange = (signed short int)shift_range;
        candp->cover = cover;
        candp->nseg = nseg;
        candp->hregix = hregix;
        candp->seqidx = -1;
        return 0;
      }
  }
}

// diffBlocksCreate
// file diffstr.h line 157
struct _DiffBlocks * diffBlocksCreate(signed int blksz)
{
  struct _DiffBlocks *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _DiffBlocks) /*24ul*/ , "diffstr.c", 621);
  p = (struct _DiffBlocks *)return_value_ecalloc$1;
  if(!(p == ((struct _DiffBlocks *)NULL)))
  {
    p->nblk = 0;
    if(!(blksz >= 1))
      blksz = 64;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blksz, sizeof(struct _BLOCK) /*12ul*/ , "diffstr.c", 625);
    p->blkp = (struct _BLOCK *)return_value_ecalloc$2;
    if(p->blkp == ((struct _BLOCK *)NULL))
    {
      diffBlocksDelete(p);
      p = (struct _DiffBlocks *)(void *)0;
    }

    else
    {
      p->ablksz = blksz;
      p->n_alloc = p->ablksz;
    }
  }

  return p;
}

// diffBlocksDelete
// file diffstr.h line 162
void diffBlocksDelete(struct _DiffBlocks *p)
{
  if(!(p == ((struct _DiffBlocks *)NULL)))
    free((void *)p->blkp);

  free((void *)p);
}

// diffBlocksGetLen
// file diffstr.h line 170
signed int diffBlocksGetLen(signed int *unprof_start, signed int *prof_start, signed int blkno, const struct _DiffBlocks *p)
{
  signed int rv = 0;
  if(blkno >= 0 && !(blkno >= p->nblk))
  {
    struct _BLOCK *bp = p->blkp + (signed long int)blkno;
    if(!(unprof_start == ((signed int *)NULL)))
      *unprof_start = bp->unprof_start;

    if(!(prof_start == ((signed int *)NULL)))
      *prof_start = bp->prof_start;

    rv = bp->len;
  }

  else
  {
    if(!(unprof_start == ((signed int *)NULL)))
      *unprof_start = 0;

    if(!(prof_start == ((signed int *)NULL)))
      *prof_start = 0;

  }
  return rv;
}

// diffBlocksGetNumber
// file diffstr.h line 166
signed int diffBlocksGetNumber(const struct _DiffBlocks *p)
{
  return p->nblk;
}

// diffStrAdd
// file diffstr.h line 222
signed int diffStrAdd(struct _DiffStr *top, const unsigned char *fcp, signed int len)
{
  signed int l;
  signed int errcode = 0;
  unsigned long int newlen = (unsigned long int)(top->len + (len > 0 ? len : 0));
  unsigned char *tcp;
  unsigned char *tmp_post$1;
  const unsigned char *tmp_post$2;
  if(fcp == ((const unsigned char *)NULL) || !(len >= 1))
    return 0;

  else
    if(newlen >= 2147483648ul)
      return 48;

    else
      if(!(top->n_alloc >= (signed int)newlen))
      {
        errcode=diffStrRealloc(top, (signed int)newlen);
        if(errcode == 0)
          goto __CPROVER_DUMP_L3;

        return errcode;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        tcp = top->dstrp + (signed long int)top->len;
        l = 0;
        for( ; !(l >= len); l = l + 1)
        {
          tmp_post$1 = tcp;
          tcp = tcp + 1l;
          tmp_post$2 = fcp;
          fcp = fcp + 1l;
          *tmp_post$1 = *tmp_post$2;
        }
        top->len = (signed int)newlen;
        if(newlen >= 1ul)
        {
          if(!((signed int)top->dstrp[-1l + (signed long int)newlen] == 0))
            errcode = 47;

        }

        return errcode;
      }
}

// diffStrAppend
// file diffstr.h line 229
signed int diffStrAppend(struct _DiffStr *top, const struct _DiffStr *fromp)
{
  signed int return_value_diffStrAdd$1;
  return_value_diffStrAdd$1=diffStrAdd(top, fromp->dstrp, fromp->len);
  return return_value_diffStrAdd$1;
}

// diffStrAsView
// file diffstr.h line 418
signed int diffStrAsView(struct _DiffView *dvp, const unsigned char *dstrp, char outform, signed int clip_start, signed int clip_end, char is_softclipped)
{
  signed int errcode = 0;
  signed int i;
  signed int len = 0;
  unsigned long int maxlen;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= 0x7fffffff))
      tmp_if_expr$1 = dstrp[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i >= 0x7fffffff)
    return 48;

  else
  {
    maxlen = (unsigned long int)i * (unsigned long int)5 + (unsigned long int)(2 * 13);
    if(maxlen >= dvp->n_alloc)
    {
      errcode=reallocView(dvp, maxlen + (unsigned long int)1);
      if(errcode == 0)
        goto __CPROVER_DUMP_L6;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      errcode=diffStrPrintfStr(dvp->strp, &len, dstrp, outform, clip_start, clip_end, is_softclipped);
      if(errcode == 0 && !(maxlen >= (unsigned long int)len))
        errcode = 47;

      return errcode;
    }
  }
}

// diffStrCalcAliLen
// file diffstr.h line 251
signed int diffStrCalcAliLen(signed int *matchnum, const unsigned char *diffstrp)
{
  unsigned char typ = (unsigned char)0;
  unsigned char count;
  signed int l;
  signed int m;
  const signed int maxl = 0x7fffffff - 61;
  if(!(matchnum == ((signed int *)NULL)))
    *matchnum = 0;

  m = 0;
  l = m;
  for( ; !(*diffstrp == 0) && !(l >= maxl); diffstrp = diffstrp + 1l)
  {
    typ = (unsigned char)((signed int)diffstrp[(signed long int)0] >> 6);
    count = (unsigned char)((signed int)diffstrp[(signed long int)0] & 63);
    if((signed int)typ == 0)
      m = m + (signed int)count + 1;

    else
      m = m + (signed int)count;
    l = l + (signed int)count + 1;
  }
  if(!(matchnum == ((signed int *)NULL)))
    *matchnum = m;

  if((signed int)typ == 3)
  {
    if(*diffstrp == 0)
      l = l - 1;

  }

  return *diffstrp != 0 ? 0 : l;
}

// diffStrCalcSeqLen
// file diffstr.c line 898
signed int diffStrCalcSeqLen(signed int *len_prof, signed int *len_unprof, const unsigned char *diffstrp)
{
  signed int errcode = 0;
  unsigned char typ = (unsigned char)0;
  unsigned char count;
  signed int pl = 0;
  signed int ul = 0;
  const signed int maxlen = 0x7fffffff - 61;
  for( ; !(*diffstrp == 0) && !(pl >= maxlen) && !(ul >= maxlen); diffstrp = diffstrp + 1l)
  {
    typ = (unsigned char)((signed int)diffstrp[(signed long int)0] >> 6);
    count = (unsigned char)((signed int)diffstrp[(signed long int)0] & 63);
    if((signed int)typ == 2)
    {
      ul = ul + (signed int)count;
      pl = pl + (signed int)count + 1;
    }

    else
      if((signed int)typ == 1)
      {
        ul = ul + (signed int)count + 1;
        pl = pl + (signed int)count;
      }

      else
      {
        ul = ul + (signed int)count + 1;
        pl = pl + (signed int)count + 1;
      }
  }
  if(*diffstrp == 0)
  {
    if((signed int)typ == 3)
    {
      ul = ul - 1;
      pl = pl - 1;
    }

  }

  else
    errcode = 59;
  if(!(len_prof == ((signed int *)NULL)))
    *len_prof = pl;

  if(!(len_unprof == ((signed int *)NULL)))
    *len_unprof = ul;

  return errcode;
}

// diffStrCleanUp
// file diffstr.h line 206
void diffStrCleanUp(struct _DiffStr *p)
{
  if(!(p == ((struct _DiffStr *)NULL)))
  {
    free((void *)p->dstrp);
    p->dstrp = (unsigned char *)(void *)0;
    p->blksz = 0;
    p->n_alloc = p->blksz;
    p->len = p->n_alloc;
  }

}

// diffStrCopy
// file diffstr.c line 795
signed int diffStrCopy(struct _DiffStr *dfsp, const unsigned char *diffstrp)
{
  signed int errcode;
  signed short int l;
  const unsigned char *dstrp = diffstrp;
  unsigned char *ucp;
  l = (signed short int)0;
  for( ; !(diffstrp[(signed long int)l] == 0); l = l + 1)
    if((signed int)l >= 0x7fff)
      return 48;

  unsigned char *tmp_post$1;
  const unsigned char *tmp_post$2;
  if((signed int)l >= dfsp->n_alloc)
  {
    errcode=diffStrRealloc(dfsp, (signed int)l);
    if(errcode == 0)
      goto __CPROVER_DUMP_L4;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    dfsp->len = (signed int)l + 1;
    ucp = dfsp->dstrp;
    for( ; (signed int)l >= 0; l = l - 1)
    {
      tmp_post$1 = ucp;
      ucp = ucp + 1l;
      tmp_post$2 = dstrp;
      dstrp = dstrp + 1l;
      *tmp_post$1 = *tmp_post$2;
    }
    return 0;
  }
}

// diffStrCreate
// file diffstr.h line 191
struct _DiffStr * diffStrCreate(signed int blocksiz)
{
  struct _DiffStr *dfsp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _DiffStr) /*24ul*/ , "diffstr.c", 720);
  dfsp = (struct _DiffStr *)return_value_ecalloc$1;
  signed int return_value_diffStrInit$2;
  if(!(dfsp == ((struct _DiffStr *)NULL)))
  {
    return_value_diffStrInit$2=diffStrInit(dfsp, blocksiz);
    if(!(return_value_diffStrInit$2 == 0))
    {
      diffStrDelete(dfsp);
      dfsp = ((struct _DiffStr *)NULL);
    }

  }

  return dfsp;
}

// diffStrCreateView
// file diffstr.h line 405
struct _DiffView * diffStrCreateView(signed int blksz)
{
  struct _DiffView *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _DiffView) /*32ul*/ , "diffstr.c", 1519);
  p = (struct _DiffView *)return_value_ecalloc$1;
  if(!(p == ((struct _DiffView *)NULL)))
  {
    if(!(blksz >= 1))
      blksz = 256;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blksz, sizeof(char) /*1ul*/ , "diffstr.c", 1523);
    p->strp = (char *)return_value_ecalloc$2;
    if(p->strp == ((char *)NULL))
    {
      diffStrDeleteView(p);
      p = (struct _DiffView *)(void *)0;
    }

    else
    {
      p->n_alloc = (unsigned long int)blksz;
      p->blksz = blksz;
      p->strlen = (unsigned long int)0;
      p->strp[(signed long int)0] = (char)0;
    }
  }

  return p;
}

// diffStrCrop
// file diffstr.c line 1260
signed int diffStrCrop(unsigned char *diffstrp, signed int *dstrlen, signed int start_unprof_target, signed int end_unprof_target, signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof)
{
  signed int errcode;
  unsigned char count;
  unsigned char typ;
  unsigned char count_over;
  signed int j;
  signed int is;
  signed int ie;
  signed int dd;
  *dstrlen = 0;
  *end_unprof = 0;
  *start_unprof = *end_unprof;
  *end_prof = 0;
  *start_prof = *end_prof;
  errcode=scrollDiffStr(diffstrp, start_unprof_target, (unsigned char)0, start_unprof, start_prof, &is);
  signed int tmp_post$1;
  _Bool tmp_if_expr$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  if(!(errcode == 0))
    return errcode;

  else
  {
    errcode=scrollDiffStr(diffstrp, end_unprof_target, (unsigned char)1, end_unprof, end_prof, &ie);
    if(!(errcode == 0))
      return errcode;

    else
    {
      typ = (unsigned char)((signed int)diffstrp[(signed long int)is] >> 6);
      count = (unsigned char)((signed int)diffstrp[(signed long int)is] & 63);
      if((signed int)typ == 0)
        count = count + 1;

      if(!(*start_unprof >= start_unprof_target))
        return 47;

      else
      {
        if(!(*start_unprof >= start_unprof_target + (signed int)count))
          count = (unsigned char)(*start_unprof - start_unprof_target);

        *start_unprof = *start_unprof - (signed int)count;
        *start_prof = *start_prof - (signed int)count;
        j = 0;
        if(!(is >= ie))
        {
          if((signed int)typ == 0 && !((signed int)count >= 2) || !((signed int)count >= 1))
            count_over = count;

          else
          {
            if((signed int)typ == 0)
              count = count - 1;

            tmp_post$1 = j;
            j = j + 1;
            diffstrp[(signed long int)tmp_post$1] = (unsigned char)((signed int)count + ((signed int)(unsigned char)typ << 6));
            count_over = (unsigned char)0;
          }
          is = is + 1;
          do
          {
            if(!(is >= ie))
              tmp_if_expr$2 = diffstrp[(signed long int)is] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(!tmp_if_expr$2)
              break;

            typ = (unsigned char)((signed int)diffstrp[(signed long int)is] >> 6);
            count = (unsigned char)((signed int)diffstrp[(signed long int)is] & 63);
            count = (unsigned char)((signed int)count + (signed int)count_over);
            if((signed int)count >= 62)
            {
              tmp_post$3 = j;
              j = j + 1;
              diffstrp[(signed long int)tmp_post$3] = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
              count = count - (unsigned char)(61 + 1);
              count_over = (unsigned char)0;
            }

            if((signed int)typ == 0 && !((signed int)count >= 1))
              count_over = (unsigned char)1;

            else
            {
              tmp_post$4 = j;
              j = j + 1;
              diffstrp[(signed long int)tmp_post$4] = (unsigned char)((signed int)count + ((signed int)(unsigned char)typ << 6));
            }
            is = is + 1;
          }
          while((_Bool)1);
          typ = (unsigned char)((signed int)diffstrp[(signed long int)ie] >> 6);
          count = (unsigned char)((signed int)diffstrp[(signed long int)ie] & 63);
          count = (unsigned char)((signed int)count + (signed int)count_over);
          if((signed int)typ == 0)
            count = count + 1;

        }

        if(!(*end_unprof >= 1 + end_unprof_target))
        {
          if(!(61 + *end_unprof >= end_unprof_target))
            return 59;

          count = (unsigned char)((end_unprof_target + 1) - *end_unprof);
        }

        else
        {
          if(!(1 + end_unprof_target + (signed int)count >= *end_unprof))
            return 59;

          dd = (signed int)(*end_unprof - end_unprof_target);
          count = (unsigned char)(((signed int)count + 1) - dd);
          *end_unprof = *end_unprof - dd;
          *end_prof = *end_prof - dd;
        }
        tmp_post$5 = j;
        j = j + 1;
        diffstrp[(signed long int)tmp_post$5] = (unsigned char)((signed int)count + ((signed int)(unsigned char)3 << 6));
        diffstrp[(signed long int)j] = (unsigned char)(0 + ((signed int)(unsigned char)0 << 6));
        *dstrlen = j + 1;
        return 0;
      }
    }
  }
}

// diffStrDelete
// file diffstr.h line 196
void diffStrDelete(struct _DiffStr *dfsp)
{
  diffStrCleanUp(dfsp);
  free((void *)dfsp);
}

// diffStrDeleteView
// file diffstr.h line 410
void diffStrDeleteView(struct _DiffView *p)
{
  if(!(p == ((struct _DiffView *)NULL)))
    free((void *)p->strp);

  free((void *)p);
}

// diffStrFetchSegment
// file diffstr.c line 1352
signed int diffStrFetchSegment(struct _DiffStr *dfsp, const unsigned char *diffstrp, signed int start_unprof_target, signed int end_unprof_target, signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof)
{
  signed int errcode;
  errcode=diffStrCopy(dfsp, diffstrp);
  if(!(errcode == 0))
    return errcode;

  else
  {
    signed int return_value_diffStrCrop$1;
    return_value_diffStrCrop$1=diffStrCrop(dfsp->dstrp, &dfsp->len, start_unprof_target, end_unprof_target, start_unprof, end_unprof, start_prof, end_prof);
    return return_value_diffStrCrop$1;
  }
}

// diffStrFindBlocks
// file diffstr.h line 181
signed int diffStrFindBlocks(struct _DiffBlocks *dbp, const unsigned char *diffstrp)
{
  signed int u = 0;
  signed int p = 0;
  signed int l = 0;
  unsigned char count = (unsigned char)0;
  unsigned char typ = (unsigned char)0;
  dbp->nblk = 0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  if(diffstrp == ((const unsigned char *)NULL))
    return 0;

  else
  {
    for( ; !(*diffstrp == 0); diffstrp = diffstrp + 1l)
    {
      typ = (unsigned char)((signed int)diffstrp[(signed long int)0] >> 6);
      count = (unsigned char)((signed int)diffstrp[(signed long int)0] & 63);
      l = l + (signed int)count;
      if((signed int)typ == 2)
      {
        if(l >= 1)
        {
          struct _BLOCK *bp;
          if(dbp->nblk >= dbp->n_alloc)
          {
            signed int errcode;
            errcode=reallocDiffBlocks(dbp, dbp->nblk + 1);
            if(!(errcode == 0))
              return errcode;

          }

          tmp_post$1 = dbp->nblk;
          dbp->nblk = dbp->nblk + 1;
          bp = dbp->blkp + (signed long int)tmp_post$1;
          bp->unprof_start = u;
          bp->prof_start = p;
          bp->len = l;
          u = u + l;
          p = p + l;
          l = 0;
        }

        p = p + 1;
      }

      else
        if((signed int)typ == 1)
        {
          if(l >= 1)
          {
            struct _BLOCK *diffStrFindBlocks$$1$$1$$1$$2$$1$$bp;
            if(dbp->nblk >= dbp->n_alloc)
            {
              signed int diffStrFindBlocks$$1$$1$$1$$2$$1$$1$$errcode;
              diffStrFindBlocks$$1$$1$$1$$2$$1$$1$$errcode=reallocDiffBlocks(dbp, dbp->nblk + 1);
              if(!(diffStrFindBlocks$$1$$1$$1$$2$$1$$1$$errcode == 0))
                return diffStrFindBlocks$$1$$1$$1$$2$$1$$1$$errcode;

            }

            tmp_post$2 = dbp->nblk;
            dbp->nblk = dbp->nblk + 1;
            diffStrFindBlocks$$1$$1$$1$$2$$1$$bp = dbp->blkp + (signed long int)tmp_post$2;
            diffStrFindBlocks$$1$$1$$1$$2$$1$$bp->unprof_start = u;
            diffStrFindBlocks$$1$$1$$1$$2$$1$$bp->prof_start = p;
            diffStrFindBlocks$$1$$1$$1$$2$$1$$bp->len = l;
            u = u + l;
            p = p + l;
            l = 0;
          }

          u = u + 1;
        }

        else
          l = l + 1;
    }
    if(!((signed int)typ == 3))
      return 59;

    else
    {
      l = l - 1;
      if(l >= 1)
      {
        struct _BLOCK *diffStrFindBlocks$$1$$2$$bp;
        if(dbp->nblk >= dbp->n_alloc)
        {
          signed int diffStrFindBlocks$$1$$2$$1$$errcode;
          diffStrFindBlocks$$1$$2$$1$$errcode=reallocDiffBlocks(dbp, dbp->nblk + 1);
          if(!(diffStrFindBlocks$$1$$2$$1$$errcode == 0))
            return diffStrFindBlocks$$1$$2$$1$$errcode;

        }

        tmp_post$3 = dbp->nblk;
        dbp->nblk = dbp->nblk + 1;
        diffStrFindBlocks$$1$$2$$bp = dbp->blkp + (signed long int)tmp_post$3;
        diffStrFindBlocks$$1$$2$$bp->unprof_start = u;
        diffStrFindBlocks$$1$$2$$bp->prof_start = p;
        diffStrFindBlocks$$1$$2$$bp->len = l;
        u = u + l;
        p = p + l;
        l = 0;
      }

      return 0;
    }
  }
}

// diffStrGenerateFromMismatches
// file diffstr.h line 279
signed int diffStrGenerateFromMismatches(signed int *dlen, unsigned char *diffstrp, const signed int *mmpos, signed int mmnum, signed int qlen)
{
  signed int i;
  signed int j;
  signed int n;
  signed int ntot;
  signed int supos;
  unsigned char *dcp = (unsigned char *)(void *)0;
  if(!(dlen == ((signed int *)NULL)))
    *dlen = 0;

  if(!(diffstrp == ((unsigned char *)NULL)))
    dcp = diffstrp;

  signed int tmp_if_expr$1;
  if(!(mmnum >= 1))
  {
    n = (qlen - 1) / 61;
    supos = qlen;
  }

  else
  {
    if(*mmpos >= 1)
      tmp_if_expr$1 = (mmpos[(signed long int)0] - 1) / 61;

    else
      tmp_if_expr$1 = 0;
    n = tmp_if_expr$1;
    supos = mmpos[(signed long int)0];
  }
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  if(!(dcp == ((unsigned char *)NULL)))
  {
    j = 0;
    for( ; !(j >= n); j = j + 1)
    {
      tmp_post$2 = dcp;
      dcp = dcp + 1l;
      *tmp_post$2 = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
    }
    tmp_post$3 = dcp;
    dcp = dcp + 1l;
    *tmp_post$3 = (unsigned char)((supos - n * 61) + 1 + ((signed int)(unsigned char)3 << 6));
  }

  ntot = n + 1;
  unsigned char *tmp_post$4;
  unsigned char *tmp_post$5;
  unsigned char *tmp_post$6;
  unsigned char *tmp_post$7;
  if(mmnum >= 1)
  {
    i = 1;
    for( ; !(i >= mmnum); i = i + 1)
    {
      if(mmpos[(signed long int)(i + -1)] >= mmpos[(signed long int)i])
        return 47;

      n = (signed int)((mmpos[(signed long int)i] - mmpos[(signed long int)(i - 1)]) - 1) / 61;
      if(!(dcp == ((unsigned char *)NULL)))
      {
        j = 0;
        for( ; !(j >= n); j = j + 1)
        {
          tmp_post$4 = dcp;
          dcp = dcp + 1l;
          *tmp_post$4 = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
        }
        tmp_post$5 = dcp;
        dcp = dcp + 1l;
        *tmp_post$5 = (unsigned char)(((mmpos[(signed long int)i] - mmpos[(signed long int)(i - 1)]) - n * 61) + ((signed int)(unsigned char)3 << 6));
      }

      ntot = ntot + n + 1;
    }
    if(!(mmpos[(signed long int)(i + -1)] == qlen + -1))
    {
      n = (signed int)((qlen - mmpos[(signed long int)(i - 1)]) - 1) / 61;
      if(!(dcp == ((unsigned char *)NULL)))
      {
        j = 0;
        for( ; !(j >= n); j = j + 1)
        {
          tmp_post$6 = dcp;
          dcp = dcp + 1l;
          *tmp_post$6 = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
        }
        tmp_post$7 = dcp;
        dcp = dcp + 1l;
        *tmp_post$7 = (unsigned char)(((qlen - mmpos[(signed long int)(i - 1)]) - n * 61) + ((signed int)(unsigned char)3 << 6));
      }

      ntot = ntot + n + 1;
    }

  }

  unsigned char *tmp_post$8;
  if(!(dcp == ((unsigned char *)NULL)))
  {
    tmp_post$8 = dcp;
    dcp = dcp + 1l;
    *tmp_post$8 = (unsigned char)(0 + ((signed int)(unsigned char)0 << 6));
  }

  if(!(dlen == ((signed int *)NULL)))
    *dlen = ntot + 1;

  return 0;
}

// diffStrGetDiffStats
// file diffstr.c line 954
signed int diffStrGetDiffStats(signed int *n_sub, signed int *n_ins, signed int *n_del, const unsigned char *diffstrp)
{
  signed int ni = 0;
  signed int nd = 0;
  signed int ns = 0;
  signed int errcode = 0;
  unsigned char typ = (unsigned char)0;
  if(!(n_sub == ((signed int *)NULL)))
    *n_sub = 0;

  if(!(n_ins == ((signed int *)NULL)))
    *n_ins = 0;

  if(!(n_del == ((signed int *)NULL)))
    *n_del = 0;

  _Bool tmp_if_expr$1;
  do
  {
    if(errcode == 0)
      tmp_if_expr$1 = *diffstrp != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    typ = (unsigned char)((signed int)diffstrp[(signed long int)0] >> 6);
    if((signed int)typ == 2)
    {
      if(ni == 0x7fffffff)
        errcode = 48;

      else
        ni = ni + 1;
    }

    else
      if((signed int)typ == 1)
      {
        if(nd == 0x7fffffff)
          errcode = 48;

        else
          nd = nd + 1;
      }

      else
        if((signed int)typ == 3)
        {
          if(!(diffstrp + 1l == ((const unsigned char *)NULL)))
          {
            if(ns == 0x7fffffff)
              errcode = 48;

            else
              ns = ns + 1;
          }

        }

    diffstrp = diffstrp + 1l;
  }
  while((_Bool)1);
  if(errcode == 0 && (!(diffstrp == ((const unsigned char *)NULL)) || !((signed int)typ == 3)))
    errcode = 59;

  if(!(n_sub == ((signed int *)NULL)))
    *n_sub = ns;

  if(!(n_ins == ((signed int *)NULL)))
    *n_ins = ni;

  if(!(n_del == ((signed int *)NULL)))
    *n_del = nd;

  return errcode;
}

// diffStrGetLevenshteinDistance
// file diffstr.h line 397
signed int diffStrGetLevenshteinDistance(const unsigned char *diffstrp)
{
  unsigned char typ = (unsigned char)0;
  signed int i;
  signed int ed = 0;
  i = 0;
  for( ; !(diffstrp[(signed long int)i] == 0) && !(i >= 0x7fffffff); i = i + 1)
  {
    typ = (unsigned char)((signed int)diffstrp[(signed long int)i] >> 6);
    if(!((signed int)typ == 0))
      ed = ed + 1;

  }
  if((signed int)typ == 3 && ed >= 1 && !(i >= 0x7fffffff))
    ed = ed - 1;

  return ed;
}

// diffStrGetViewStr
// file diffstr.h line 414
const char * diffStrGetViewStr(const struct _DiffView *p)
{
  return p->strp;
}

// diffStrInit
// file diffstr.h line 200
signed int diffStrInit(struct _DiffStr *p, signed int blocksiz)
{
  p->blksz = 0;
  p->n_alloc = p->blksz;
  p->len = p->n_alloc;
  p->dstrp = (unsigned char *)(void *)0;
  if(!(blocksiz >= 1))
    blocksiz = 256;

  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)blocksiz, sizeof(unsigned char) /*1ul*/ , "diffstr.c", 740);
  p->dstrp = (unsigned char *)return_value_ecalloc$1;
  if(p->dstrp == ((unsigned char *)NULL))
    return 2;

  else
  {
    p->blksz = blocksiz;
    p->n_alloc = p->blksz;
    return 0;
  }
}

// diffStrParsePlain
// file diffstr.c line 1126
signed int diffStrParsePlain(struct _DiffStr *dfsp, const char *rawstrp)
{
  signed int errcode;
  signed int c;
  signed short int i;
  unsigned char code;
  signed int count;
  char numbuf[7l];
  const char *cp;
  dfsp->len = 0;
  cp = rawstrp;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    if(!(*cp == 0))
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      tmp_if_expr$2 = ((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*cp] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    cp = cp + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  signed int tmp_post$5;
  _Bool tmp_if_expr$7;
  signed int return_value_toupper$6;
  signed int tmp_post$8;
  for( ; !(*cp == 0); cp = cp + (signed long int)((signed int)i + 1))
  {
    i = (signed short int)0;
    do
    {
      if(!(cp[(signed long int)i] == 0) && !((signed int)i >= 6))
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)cp[(signed long int)i]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      numbuf[(signed long int)i] = cp[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    if((signed int)i >= 6)
      return 59;

    numbuf[(signed long int)i] = (char)0;
    count=atoi(numbuf);
    for( ; count >= 62; count = count - 61)
    {
      if(1 + dfsp->len >= dfsp->n_alloc)
      {
        errcode=diffStrRealloc(dfsp, dfsp->len + 1);
        if(!(errcode == 0))
          return errcode;

      }

      tmp_post$5 = dfsp->len;
      dfsp->len = dfsp->len + 1;
      dfsp->dstrp[(signed long int)tmp_post$5] = (unsigned char)((0 << 6) + (signed int)(unsigned char)(61 & 63));
    }
    c=toupper((signed int)cp[(signed long int)i]);
    code = (unsigned char)0;
    do
    {
      if(!(DIFFSTR_SYMBOLS[(signed long int)code] == 0))
      {
        return_value_toupper$6=toupper((signed int)DIFFSTR_SYMBOLS[(signed long int)code]);
        tmp_if_expr$7 = c != return_value_toupper$6 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$7 = (_Bool)0;
      if(!tmp_if_expr$7)
        break;

      code = code + 1;
    }
    while((_Bool)1);
    if(DIFFSTR_SYMBOLS[(signed long int)code] == 0)
      break;

    if(1 + dfsp->len >= dfsp->n_alloc)
    {
      errcode=diffStrRealloc(dfsp, dfsp->len + 1);
      if(!(errcode == 0))
        return errcode;

    }

    tmp_post$8 = dfsp->len;
    dfsp->len = dfsp->len + 1;
    dfsp->dstrp[(signed long int)tmp_post$8] = (unsigned char)(((signed int)code << 6) + (signed int)(unsigned char)(count & 63));
  }
  signed int tmp_post$9;
  if(1 + dfsp->len >= dfsp->n_alloc)
  {
    errcode=diffStrRealloc(dfsp, dfsp->len + 1);
    if(errcode == 0)
      goto __CPROVER_DUMP_L20;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L20:
    ;
    tmp_post$9 = dfsp->len;
    dfsp->len = dfsp->len + 1;
    dfsp->dstrp[(signed long int)tmp_post$9] = (unsigned char)0;
    return 0;
  }
}

// diffStrParseSimul
// file diffstr.c line 1169
signed int diffStrParseSimul(struct _DiffStr *dfsp, signed int *clip_start, signed int *clip_end, unsigned char isSAMCIGAR, const char *rawstrp)
{
  signed int errcode = 0;
  signed int i;
  signed int count;
  signed int curr_count = 0;
  const char *cp;
  char numbuf[7l];
  unsigned char code;
  *clip_start = 0;
  *clip_end = 0;
  cp = rawstrp;
  _Bool tmp_if_expr$2;
  const unsigned short int **return_value___ctype_b_loc$1;
  do
  {
    if(!(*cp == 0))
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      tmp_if_expr$2 = ((signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*cp] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    cp = cp + 1l;
  }
  while((_Bool)1);
  dfsp->len = 0;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  signed int tmp_post$12;
  while(!(*cp == 0))
  {
    if(!(errcode == 0))
      break;

    unsigned char isClip = (unsigned char)0;
    i = 0;
    do
    {
      if(!(cp[(signed long int)i] == 0) && !(i >= 6))
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)cp[(signed long int)i]] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      numbuf[(signed long int)i] = cp[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    if(i >= 6)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(cp[(signed long int)i] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      return 59;

    numbuf[(signed long int)i] = (char)0;
    count=atoi(numbuf);
    cp = cp + (signed long int)i;
    if(*cp == 0)
      return 59;

    if(!(isSAMCIGAR == 0))
    {
      code = (unsigned char)0;
      do
      {
        if(!(DIFFSTR_SYMBOLS_X[(signed long int)code] == 0))
          tmp_if_expr$6 = *cp != DIFFSTR_SYMBOLS_X[(signed long int)code] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(!tmp_if_expr$6)
          break;

        code = code + 1;
      }
      while((_Bool)1);
      if(DIFFSTR_SYMBOLS_X[(signed long int)code] == 0)
      {
        if((signed int)*cp == 72)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)*cp == 83 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
        {
          if(dfsp->len == 0)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = *clip_start == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
          {
            *clip_start = count;
            isClip = (unsigned char)1;
          }

          else
            if(*clip_end == 0)
            {
              *clip_end = count;
              isClip = (unsigned char)1;
            }

            else
              errcode = 59;
        }

        else
          errcode = 59;
      }

    }

    else
    {
      code = (unsigned char)0;
      do
      {
        if(!(DIFFSTR_SYMBOLS[(signed long int)code] == 0))
          tmp_if_expr$9 = *cp != DIFFSTR_SYMBOLS[(signed long int)code] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(!tmp_if_expr$9)
          break;

        code = code + 1;
      }
      while((_Bool)1);
      if(DIFFSTR_SYMBOLS[(signed long int)code] == 0)
        errcode = 59;

    }
    if(!(errcode == 0))
      break;

    if(!(isClip == 0))
    {
      if(*clip_end >= 1)
      {
        if(!(cp[1l] == 0))
          errcode = 59;

      }

    }

    else
      if((signed int)code == 0)
      {
        curr_count = curr_count + count;
        for( ; curr_count >= 63; curr_count = curr_count - (61 + 1))
        {
          if(1 + dfsp->len >= dfsp->n_alloc)
          {
            errcode=diffStrRealloc(dfsp, dfsp->len + 1);
            if(!(errcode == 0))
              return errcode;

          }

          tmp_post$10 = dfsp->len;
          dfsp->len = dfsp->len + 1;
          dfsp->dstrp[(signed long int)tmp_post$10] = (unsigned char)(((signed int)(unsigned char)0 << 6) + (signed int)(unsigned char)61);
        }
      }

      else
        do
        {
          tmp_post$11 = count;
          count = count - 1;
          if(!(tmp_post$11 >= 1))
            break;

          if(1 + dfsp->len >= dfsp->n_alloc)
          {
            errcode=diffStrRealloc(dfsp, dfsp->len + 1);
            if(!(errcode == 0))
              return errcode;

          }

          tmp_post$12 = dfsp->len;
          dfsp->len = dfsp->len + 1;
          dfsp->dstrp[(signed long int)tmp_post$12] = (unsigned char)(((signed int)code << 6) + (curr_count & 63));
          curr_count = 0;
        }
        while((_Bool)1);
    cp = cp + 1l;
  }
  signed int tmp_post$13;
  if(curr_count >= 1)
  {
    if(1 + dfsp->len >= dfsp->n_alloc)
    {
      errcode=diffStrRealloc(dfsp, dfsp->len + 1);
      if(!(errcode == 0))
        return errcode;

    }

    tmp_post$13 = dfsp->len;
    dfsp->len = dfsp->len + 1;
    dfsp->dstrp[(signed long int)tmp_post$13] = (unsigned char)(((signed int)(unsigned char)3 << 6) + (curr_count & 63));
  }

  signed int tmp_post$14;
  if(1 + dfsp->len >= dfsp->n_alloc)
  {
    errcode=diffStrRealloc(dfsp, dfsp->len + 1);
    if(errcode == 0)
      goto __CPROVER_DUMP_L44;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L44:
    ;
    tmp_post$14 = dfsp->len;
    dfsp->len = dfsp->len + 1;
    dfsp->dstrp[(signed long int)tmp_post$14] = (unsigned char)0;
    return errcode;
  }
}

// diffStrPrintf
// file diffstr.h line 291
signed int diffStrPrintf(struct _IO_FILE *fp, const unsigned char *diffstrp, char outform, signed int clip_start, signed int clip_end, char is_softclipped)
{
  signed int errcode = 0;
  unsigned char cgt = (unsigned char)(is_softclipped != 0 ? 4 : 0);
  signed int nchar = 0;
  switch((signed int)outform)
  {
    case 0:
    {
      fprintfDiffStrRaw(fp, diffstrp);
      break;
    }
    case 1:
    {
      fprintfDiffStrPlain(fp, diffstrp);
      break;
    }
    case 2:
    {
      errcode=writeDiffStrCIGAR((void *)fp, &nchar, (unsigned char)1, diffstrp, 0, 0, writeCigarToFile);
      break;
    }
    case 3:
    {
      errcode=writeDiffStrCIGAR((void *)fp, &nchar, (unsigned char)((signed int)cgt | 2 | 1), diffstrp, clip_start, clip_end, writeCigarToFile);
      break;
    }
    case 4:
    {
      errcode=writeDiffStrCIGAR((void *)fp, &nchar, (unsigned char)((signed int)cgt | 2), diffstrp, clip_start, clip_end, writeCigarToFile);
      break;
    }
    default:
      errcode = 47;
  }
  return errcode;
}

// diffStrPrintfStr
// file diffstr.c line 1084
signed int diffStrPrintfStr(char *sp, signed int *nchar, const unsigned char *diffstrp, char outform, signed int clip_start, signed int clip_end, char is_softclipped)
{
  signed int errcode = 0;
  unsigned char cgt = (unsigned char)(is_softclipped != 0 ? 4 : 0);
  *nchar = 0;
  switch((signed int)outform)
  {
    case 0:
    {
      *nchar=sprintfDiffStrRaw(sp, diffstrp);
      break;
    }
    case 1:
    {
      *nchar=sprintfDiffStrPlain(sp, diffstrp);
      break;
    }
    case 2:
    {
      errcode=writeDiffStrCIGAR((void *)sp, nchar, (unsigned char)0, diffstrp, 0, 0, writeCigarToStr);
      break;
    }
    case 3:
    {
      errcode=writeDiffStrCIGAR((void *)sp, nchar, (unsigned char)((signed int)cgt | 2 | 1), diffstrp, clip_start, clip_end, writeCigarToStr);
      break;
    }
    case 4:
    {
      errcode=writeDiffStrCIGAR((void *)sp, nchar, (unsigned char)((signed int)cgt | 2), diffstrp, clip_start, clip_end, writeCigarToStr);
      break;
    }
    default:
      errcode = 47;
  }
  return errcode;
}

// diffStrRealloc
// file diffstr.h line 210
signed int diffStrRealloc(struct _DiffStr *dfsp, signed int n_new)
{
  signed int errcode;
  unsigned long int nsiz;
  unsigned char *hp;
  if(dfsp->dstrp == ((unsigned char *)NULL))
    return 15;

  else
    if(dfsp->dstrp == ((unsigned char *)NULL))
    {
      errcode=diffStrInit(dfsp, 0);
      if(errcode == 0)
        goto __CPROVER_DUMP_L2;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(n_new == 0)
        nsiz = (unsigned long int)(dfsp->n_alloc + dfsp->blksz);

      else
        nsiz = (unsigned long int)(((n_new + dfsp->blksz) - 1) / dfsp->blksz) * (unsigned long int)dfsp->blksz;
      if(nsiz >= 2147483648ul)
        return 48;

      else
      {
        void *return_value_erealloc$1;
        return_value_erealloc$1=erealloc((void *)dfsp->dstrp, nsiz * sizeof(unsigned char) /*1ul*/ , (unsigned long int)0, "diffstr.c", 784);
        hp = (unsigned char *)return_value_erealloc$1;
        if(hp == ((unsigned char *)NULL))
          return 2;

        else
        {
          dfsp->dstrp = hp;
          dfsp->n_alloc = (signed int)nsiz;
          if(!(dfsp->n_alloc >= dfsp->len))
            dfsp->len = dfsp->n_alloc;

          return 0;
        }
      }
    }
}

// diffStrReverse
// file diffstr.c line 850
signed int diffStrReverse(struct _DiffStr *dfsp, const unsigned char *diffstrp)
{
  signed int errcode;
  unsigned char typ;
  unsigned char count;
  unsigned char count_prev;
  signed short int l;
  signed short int u = (signed short int)0;
  unsigned char *ucp;
  l = (signed short int)0;
  for( ; !(diffstrp[(signed long int)l] == 0); l = l + 1)
    if((signed int)l >= 0x7fff)
      return 48;

  signed short int tmp_post$1;
  signed short int tmp_post$2;
  signed short int tmp_post$3;
  signed short int tmp_post$4;
  if((signed int)l >= dfsp->n_alloc)
  {
    errcode=diffStrRealloc(dfsp, (signed int)l + 1);
    if(errcode == 0)
      goto __CPROVER_DUMP_L4;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    l = l - 1;
    typ = (unsigned char)((signed int)diffstrp[(signed long int)l] >> 6);
    count_prev = (unsigned char)((signed int)diffstrp[(signed long int)l] & 63);
    if(!((signed int)typ == 3))
      return 59;

    else
    {
      ucp = dfsp->dstrp;
      l = l - 1;
      for( ; (signed int)l >= 0; l = l - 1)
      {
        typ = (unsigned char)((signed int)diffstrp[(signed long int)l] >> 6);
        count = (unsigned char)((signed int)diffstrp[(signed long int)l] & 63);
        if((signed int)typ == 0)
        {
          count_prev = (unsigned char)((signed int)count_prev + (signed int)count + 1);
          if((signed int)count_prev >= 62)
          {
            tmp_post$1 = u;
            u = u + 1;
            ucp[(signed long int)tmp_post$1] = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
            count_prev = count_prev - (unsigned char)(61 + 1);
          }

        }

        else
        {
          tmp_post$2 = u;
          u = u + 1;
          ucp[(signed long int)tmp_post$2] = (unsigned char)((signed int)count_prev + ((signed int)(unsigned char)typ << 6));
          count_prev = count;
        }
      }
      tmp_post$3 = u;
      u = u + 1;
      ucp[(signed long int)tmp_post$3] = (unsigned char)((signed int)count_prev + ((signed int)(unsigned char)3 << 6));
      tmp_post$4 = u;
      u = u + 1;
      ucp[(signed long int)tmp_post$4] = (unsigned char)(0 + ((signed int)(unsigned char)0 << 6));
      dfsp->len = (signed int)u;
      return 0;
    }
  }
}

// diffStrScore
// file diffstr.c line 1459
signed int diffStrScore(const unsigned char *diffstrp, signed int *swscor, signed short int match, signed short int mismatch, signed short int gapopen, signed short int gapextend)
{
  signed int errcode = 0;
  unsigned char count;
  unsigned char typ = (unsigned char)0;
  unsigned char is_gap_open = (unsigned char)0;
  signed int i;
  signed int maxi;
  if((signed int)gapopen >= 1 || (signed int)mismatch >= 1 || !((signed int)gapextend >= (signed int)gapopen) || !((signed int)match >= 1))
    return 47;

  else
  {
    maxi = 0x7fffffff - (61 + 1) * (signed int)match;
    *swscor = 0;
    i = 0;
    for( ; !(diffstrp[(signed long int)i] == 0) && !(i >= maxi); i = i + 1)
    {
      typ = (unsigned char)((signed int)diffstrp[(signed long int)i] >> 6);
      count = (unsigned char)((signed int)diffstrp[(signed long int)i] & 63);
      if((signed int)typ == 3)
      {
        *swscor = *swscor + (signed int)match * (signed int)count + (signed int)mismatch;
        is_gap_open = (unsigned char)0;
      }

      else
        if((signed int)typ == 0)
        {
          *swscor = *swscor + (signed int)match * ((signed int)count + 1);
          is_gap_open = (unsigned char)0;
        }

        else
          if(!(is_gap_open == 0) && !((signed int)count >= 1))
            *swscor = *swscor + (signed int)gapextend;

          else
          {
            *swscor = *swscor + (signed int)match * (signed int)count + (signed int)gapopen;
            is_gap_open = (unsigned char)1;
          }
    }
    if(!(diffstrp[(signed long int)i] == 0) || !((signed int)typ == 3))
      errcode = 59;

    else
      *swscor = *swscor - (signed int)mismatch;
    return errcode;
  }
}

// diffStrSegment
// file diffstr.h line 373
signed int diffStrSegment(struct _DiffStr *dfsp, const unsigned char *diffstrp, signed int start_unprof_target, signed int end_unprof_target, signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof)
{
  signed int errcode;
  signed int i;
  signed int idx_start;
  signed int idx_end;
  signed int maxsiz;
  signed int nmatch;
  unsigned char count;
  unsigned char nmatch_start;
  unsigned char nmatch_end;
  unsigned char typ;
  unsigned char typ_start;
  dfsp->len = 0;
  nmatch_end = (unsigned char)0;
  nmatch_start = nmatch_end;
  nmatch = (signed int)nmatch_start;
  errcode=scrollDIFFSTRStartEnd(start_unprof, end_unprof, start_prof, end_prof, &nmatch_start, &nmatch_end, &typ_start, &idx_start, &idx_end, start_unprof_target, end_unprof_target, diffstrp);
  signed int tmp_post$1;
  _Bool tmp_if_expr$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  signed int tmp_post$7;
  if(!(errcode == 0))
    return errcode;

  else
  {
    maxsiz = (idx_end - idx_start) + 5;
    if(!(dfsp->n_alloc >= maxsiz))
    {
      errcode=diffStrRealloc(dfsp, maxsiz);
      if(errcode == 0)
        goto __CPROVER_DUMP_L2;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      nmatch = 0;
      if(idx_start == idx_end)
      {
        typ = (unsigned char)((signed int)diffstrp[(signed long int)idx_start] >> 6);
        count = (unsigned char)((signed int)diffstrp[(signed long int)idx_start] & 63);
        if((signed int)typ == 0)
          count = count + 1;

        nmatch_end = (unsigned char)(((signed int)nmatch_end + (signed int)nmatch_start) - (signed int)count);
      }

      else
      {
        if((signed int)typ_start == 0)
          nmatch = (signed int)nmatch_start;

        else
          if((signed int)nmatch_start >= 1)
          {
            tmp_post$1 = dfsp->len;
            dfsp->len = dfsp->len + 1;
            dfsp->dstrp[(signed long int)tmp_post$1] = (unsigned char)((signed int)nmatch_start + ((signed int)(unsigned char)typ_start << 6));
            nmatch = 0;
          }

        if(!(1 + idx_start >= idx_end))
        {
          i = idx_start + 1;
          do
          {
            if(!(i >= idx_end))
              tmp_if_expr$2 = (signed int)diffstrp[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(!tmp_if_expr$2)
              break;

            typ = (unsigned char)((signed int)diffstrp[(signed long int)i] >> 6);
            count = (unsigned char)((signed int)diffstrp[(signed long int)i] & 63);
            nmatch = nmatch + (signed int)count;
            if((signed int)typ == 0)
              nmatch = nmatch + 1;

            else
            {
              for( ; nmatch >= 62; nmatch = nmatch - (61 + 1))
              {
                tmp_post$3 = dfsp->len;
                dfsp->len = dfsp->len + 1;
                dfsp->dstrp[(signed long int)tmp_post$3] = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
                if(dfsp->len >= dfsp->n_alloc)
                  return 32;

              }
              tmp_post$4 = dfsp->len;
              dfsp->len = dfsp->len + 1;
              dfsp->dstrp[(signed long int)tmp_post$4] = (unsigned char)(nmatch + ((signed int)(unsigned char)typ << 6));
              if(dfsp->len >= dfsp->n_alloc)
                return 32;

              nmatch = 0;
            }
            i = i + 1;
          }
          while((_Bool)1);
        }

      }
      nmatch = nmatch + (signed int)nmatch_end;
      for( ; nmatch >= 63; nmatch = nmatch - (61 + 1))
      {
        tmp_post$5 = dfsp->len;
        dfsp->len = dfsp->len + 1;
        dfsp->dstrp[(signed long int)tmp_post$5] = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
        if(dfsp->len >= dfsp->n_alloc)
          return 32;

      }
      if(!(dfsp->n_alloc >= 2 + dfsp->len))
        return 32;

      else
      {
        tmp_post$6 = dfsp->len;
        dfsp->len = dfsp->len + 1;
        dfsp->dstrp[(signed long int)tmp_post$6] = (unsigned char)(nmatch + ((signed int)(unsigned char)3 << 6));
        tmp_post$7 = dfsp->len;
        dfsp->len = dfsp->len + 1;
        dfsp->dstrp[(signed long int)tmp_post$7] = (unsigned char)(0 + ((signed int)(unsigned char)0 << 6));
        return 0;
      }
    }
  }
}

// doAllWordsInSeqSet
// file hashidx.c line 533
static signed int doAllWordsInSeqSet(unsigned int *tuplectrp, struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivp, const struct _SeqCodec *codecp, signed int (*keyfunc)(const struct _HashTable *, unsigned long int, unsigned int))
{
  signed int errcode = 0;
  char cod;
  unsigned char tupleoffs = (unsigned char)0;
  signed long int i;
  signed long int n_seq;
  n_seq=seqSetGetOffsets(ssp, (const unsigned long int **)(void *)0);
  unsigned int seqlen;
  if(!(n_seq >= 1l))
    return 37;

  else
  {
    *tuplectrp = (unsigned int)0;
    if(!(ivp == ((const struct V_IVAL_ *)NULL)))
    {
      signed int n;
      signed int ivn;
      ivn=interValNum(ivp);
      unsigned int lo;
      unsigned int hi;
      unsigned int sl;
      signed long int sx;
      n = 0;
      for( ; errcode == 0 && !(n >= ivn); n = n + 1)
      {
        errcode=interValGet(&lo, &hi, &sx, (unsigned short int *)(void *)0, (signed int)n, ivp);
        if(!(errcode == 0))
          return errcode;

        *tuplectrp=calcKtupOffs(&tupleoffs, lo, sx, htp->nskip, ssp);
        sl = (hi - lo) + (unsigned int)1;
        if(sl >= (unsigned int)htp->wordlen)
        {
          errcode=seqSetFetchSegmentBySequence(sqbufp, sx, lo, sl, ssp, codecp);
          if(!(errcode == 0))
            return errcode;

          seqFastqGetConstSequence(sqbufp, &seqlen, &cod);
          if(!(seqlen == sl))
            return 47;

          if(seqlen >= 2147483648u)
            return 36;

          if((signed int)cod == 0)
          {
            errcode=seqFastqEncode(sqbufp, codecp);
            if(!(errcode == 0))
              return errcode;

          }

          errcode=doWordsInSeq(tuplectrp, &tupleoffs, sqbufp, htp, keyfunc);
        }

      }
    }

    else
    {
      i = (signed long int)0;
      for( ; errcode == 0 && !(i >= n_seq); i = i + 1l)
      {
        errcode=seqSetFetchSegmentBySequence(sqbufp, i, (unsigned int)0, (unsigned int)0, ssp, codecp);
        if(!(errcode == 0))
          return errcode;

        seqFastqGetConstSequence(sqbufp, &seqlen, &cod);
        if((signed int)cod == 0)
        {
          errcode=seqFastqEncode(sqbufp, codecp);
          if(!(errcode == 0))
            return errcode;

        }

        if(seqlen >= 2147483648u)
          errcode = 36;

        if(errcode == 0)
          errcode=doWordsInSeq(tuplectrp, &tupleoffs, sqbufp, htp, keyfunc);

      }
    }
    return errcode;
  }
}

// doWordsInSeq
// file hashidx.c line 465
static signed int doWordsInSeq(unsigned int *tuplectr, unsigned char *ktup_offs, const struct _SeqFastq *sqp, const struct _HashTable *htp, signed int (*keyfunc)(const struct _HashTable *, unsigned long int, unsigned int))
{
  char codtyp;
  const char *datap;
  unsigned char ktup_i;
  unsigned char non_stdnt;
  unsigned int seqlen;
  unsigned long int word;
  const char *tmp_post$1;
  if((signed int)*ktup_offs >= (signed int)htp->nskip)
    return 29;

  else
  {
    datap=seqFastqGetConstSequence(sqp, &seqlen, &codtyp);
    if(!((signed int)codtyp == 1))
      return 22;

    else
      if(!(seqlen >= (unsigned int)htp->wordlen))
        return 30;

      else
      {
        word = (unsigned long int)0;
        ktup_i = (unsigned char)((signed int)htp->wordlen + (signed int)*ktup_offs);
        non_stdnt = (unsigned char)0;
        while(!(*datap == 0))
        {
          if(!((4 & (signed int)*datap) == 0))
            non_stdnt = htp->wordlen;

          else
            if(!(non_stdnt == 0))
              non_stdnt = non_stdnt - 1;

          tmp_post$1 = datap;
          datap = datap + 1l;
          word = (word << 2) + (unsigned long int)((signed int)*tmp_post$1 & 3);
          ktup_i = ktup_i - 1;
          if(!((signed int)ktup_i >= 1))
          {
            if(non_stdnt == 0)
              keyfunc(htp, word, *tuplectr);

            *tuplectr = *tuplectr + 1u;
            ktup_i = htp->nskip;
          }

        }
        *ktup_offs = (unsigned char)(((signed int)htp->wordlen - (signed int)ktup_i) % (signed int)htp->nskip);
        if(!(*ktup_offs == 0))
          *ktup_offs = (unsigned char)((signed int)htp->nskip - (signed int)*ktup_offs);

        *tuplectr = *tuplectr + (unsigned int)((((signed int)htp->wordlen - (signed int)ktup_i) + (signed int)*ktup_offs) / (signed int)htp->nskip);
        return 0;
      }
  }
}

// drawPairAtRandomByProbability
// file resultpairs.c line 726
static struct _MATEPAIR * drawPairAtRandomByProbability(struct _MATEPAIR * const mpr)
{
  signed int i;
  const signed int n_pairs = (const signed int)((unsigned long int *)mpr)[(signed long int)-1];
  double pthresh;
  double s = 0.0;
  struct _MATEPAIR *mp = (struct _MATEPAIR *)(void *)0;
  i = 0;
  for( ; !(i >= n_pairs); i = i + 1)
    s = s + (mpr + (signed long int)i)->pbf;
  double return_value_drand48$1;
  return_value_drand48$1=drand48();
  pthresh = return_value_drand48$1 * s;
  s = 0.0;
  i = 0;
  for( ; !(i >= n_pairs); i = i + 1)
  {
    s = s + (mpr + (signed long int)i)->pbf;
    if(s + MINLOGARG$link1 > pthresh)
    {
      mp = mpr + (signed long int)i;
      break;
    }

  }
  if(mp == ((struct _MATEPAIR *)NULL) && n_pairs >= 1)
    mp = (mpr + (signed long int)n_pairs) - (signed long int)1;

  return mp;
}

// eStringAppend
// file elib.h line 243
signed int eStringAppend(struct EString_ *esp, const char *strp, const char *progfil, signed int line)
{
  signed int errcode = 0;
  unsigned long int slen;
  slen=strlen(strp);
  if(esp->len + slen >= esp->allocsz)
  {
    errcode=eStringResize(esp, esp->len + slen + (unsigned long int)1, progfil, line);
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    strcpy(esp->strp + (signed long int)esp->len, strp);
    esp->len=strlen(esp->strp);
    return errcode;
  }
}

// eStringCreate
// file elib.h line 240
struct EString_ * eStringCreate(signed int blksz, const char *progfil, signed int line)
{
  struct EString_ *esp;
  void *return_value_emalloc$1;
  return_value_emalloc$1=emalloc(sizeof(struct EString_) /*32ul*/ , progfil, line);
  esp = (struct EString_ *)return_value_emalloc$1;
  char *return_value_eStringInit$2;
  if(!(esp == ((struct EString_ *)NULL)))
  {
    return_value_eStringInit$2=eStringInit(esp, blksz, progfil, line);
    if(return_value_eStringInit$2 == ((char *)NULL))
    {
      eStringDelete(&esp, progfil, line);
      esp = (struct EString_ *)(void *)0;
    }

  }

  return esp;
}

// eStringDelete
// file elib.h line 241
void eStringDelete(struct EString_ **esp, const char *progfil, signed int line)
{
  _Bool tmp_if_expr$1;
  if(esp == ((struct EString_ **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (struct EString_ *)(void *)0 == *esp ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    fprintf(stderr, "ERROR: eStringDelete on NULL pointer in %s, line %i\n", progfil, line);

  else
  {
    free((void *)(*esp)->strp);
    (*esp)->strp = (char *)(void *)0;
  }
  if(!(esp == ((struct EString_ **)NULL)))
  {
    free((void *)*esp);
    *esp = (struct EString_ *)(void *)0;
  }

}

// eStringInit
// file elib.h line 239
char * eStringInit(struct EString_ *esp, signed int blksz, const char *progfil, signed int line)
{
  if(esp == ((struct EString_ *)NULL))
    return (char *)(void *)0;

  else
  {
    esp->len = (unsigned long int)0;
    esp->allocsz = (unsigned long int)0;
    esp->blksz = blksz < 1 ? 128 : blksz;
    void *return_value_emalloc$1;
    return_value_emalloc$1=emalloc((unsigned long int)esp->blksz, progfil, line);
    esp->strp = (char *)return_value_emalloc$1;
    if(!(esp->strp == ((char *)NULL)))
    {
      esp->strp[(signed long int)0] = (char)0;
      esp->allocsz = (unsigned long int)blksz;
    }

    return esp->strp;
  }
}

// eStringResize
// file elib.c line 594
signed int eStringResize(struct EString_ *esp, unsigned long int newlen, const char *progfil, signed int line)
{
  signed int errcode = 0;
  unsigned long int newsz;
  char *hp;
  if(esp == ((struct EString_ *)NULL))
  {
    fprintf(stderr, "ERROR: resize EString on NULL pointer in %s, line %i\n", progfil, line);
    errcode = 15;
  }

  else
    if(!(newlen >= 1ul))
    {
      fprintf(stderr, "ERROR: resize EString to size 0 in %s, line %i\n", progfil, line);
      errcode = 29;
    }

    else
      if(!(esp->blksz >= 1))
      {
        fprintf(stderr, "ERROR: EString has zero blocksize %s, line %i\n", progfil, line);
        errcode = 47;
      }

      else
      {
        newsz = ((newlen + (unsigned long int)esp->blksz) - (unsigned long int)1) / (unsigned long int)esp->blksz;
        newsz = newsz * (unsigned long int)esp->blksz;
        void *return_value_erealloc$1;
        return_value_erealloc$1=erealloc((void *)esp->strp, newsz, (unsigned long int)0, progfil, line);
        hp = (char *)return_value_erealloc$1;
        if(hp == ((char *)NULL))
        {
          fprintf(stderr, "ERROR: EString memory re-allocation failed in %s, line %i\n", progfil, line);
          errcode = 2;
        }

        else
        {
          esp->strp = hp;
          esp->allocsz = newsz;
        }
      }
  return errcode;
}

// ecalloc
// file elib.h line 190
void * ecalloc(unsigned long int nobj, unsigned long int size, const char *progfil, signed int line)
{
  void *p;
  p=calloc(nobj, size);
  if(p == NULL)
    fprintf(stderr, "ERROR: calloc(%lu, %lu) failed in %s, line %i\n", (unsigned long int)nobj, (unsigned long int)size, progfil, line);

  return p;
}

// efclose
// file elib.h line 195
signed int efclose(struct _IO_FILE *fp, const char *progfil, signed int line)
{
  signed int rv = 0;
  signed int return_value_fclose$2;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_ferror$1;
    return_value_ferror$1=ferror(fp);
    if(!(return_value_ferror$1 == 0))
    {
      fprintf(stderr, "ERROR when closing file in %s, line %i\n", progfil, line);
      perror("Error message from <stdlib>:\n");
      rv = 50;
    }

    if(!(fp == stderr) && !(fp == stdout))
    {
      return_value_fclose$2=fclose(fp);
      if(!(return_value_fclose$2 == 0))
        rv = 50;

    }

  }

  return rv;
}

// efopen
// file elib.h line 193
struct _IO_FILE * efopen(const char *filnam, const char *mode, const char *progfil, signed int line)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  _Bool tmp_if_expr$1;
  if((signed int)*filnam == 45)
    tmp_if_expr$1 = (signed int)filnam[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    if((signed int)*mode == 119)
      fp = stdout;

    else
      if((signed int)*mode == 114)
        fp = stdin;

  }

  else
    fp=fopen(filnam, mode);
  if(fp == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "ERROR: fopen (%s, \"%s\") failed in %s, line %i\n", filnam, mode, progfil, line);

  return fp;
}

// emalloc
// file elib.h line 189
void * emalloc(unsigned long int size, const char *progfil, signed int line)
{
  void *p;
  p=malloc(size);
  if(p == NULL)
    fprintf(stderr, "ERROR: malloc(%lu) failed in %s, line %i\n", (unsigned long int)size, progfil, line);

  return p;
}

// encodeSeq
// file sequence.c line 1338
static signed int encodeSeq(struct _SEQSEQ *sp, const struct _SeqCodec *codep)
{
  char *cp;
  unsigned int i;
  if(!((signed int)sp->code == 0))
    return (signed int)sp->code == 1 ? 0 : 22;

  else
  {
    cp = sp->basep;
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= sp->size); i = i + 1u)
      if(!(cp[(signed long int)i] == 0))
        cp[(signed long int)i] = (char)codep->codtab[(signed long int)(signed int)cp[(signed long int)i]];

    sp->code = (char)1;
    return 0;
  }
}

// erealloc
// file elib.h line 191
void * erealloc(void *objp, unsigned long int size, unsigned long int size_old, const char *progfil, signed int line)
{
  void *p;
  if(size == size_old)
    p = objp;

  else
  {
    p=realloc(objp, size);
    if(p == NULL)
      fprintf(stderr, "ERROR: realloc(%p, %lu) failed in %s, line %i\n", objp, (unsigned long int)size, progfil, line);

    else
      if(size_old >= 1ul && !(size_old >= size))
        memset((void *)((char *)p + (signed long int)size_old), 0, size - size_old);

  }
  return p;
}

// ereallocp
// file elib.h line 192
void * ereallocp(void **objp, unsigned long int size, const char *progfil, signed int line)
{
  void *p;
  p=realloc(*objp, size);
  if(p == NULL)
    fprintf(stderr, "ERROR: realloc(%p, %lu) failed in %s, line %i\n", *objp, (unsigned long int)size, progfil, line);

  else
    *objp = p;
  return p;
}

// errMsgAdd
// file elib.h line 166
void errMsgAdd(struct _ErrMsg *emp, const char *message, const char *progfil, signed int linenum, signed int errcode, unsigned char level)
{
  signed short int maxfree;
  signed short int n;
  struct _MESSAGE *mp;
  signed int tmp_if_expr$1;
  signed short int tmp_post$4;
  signed short int tmp_post$5;
  signed short int tmp_post$6;
  _Bool tmp_if_expr$7;
  if(emp == ((struct _ErrMsg *)NULL) || (signed int)level == 2)
  {
    if(!(emp == ((struct _ErrMsg *)NULL)))
      tmp_if_expr$1 = (signed int)emp->num;

    else
      tmp_if_expr$1 = 0;
    const char *return_value_strMessageLevel$2;
    return_value_strMessageLevel$2=strMessageLevel((unsigned char)2);
    const char *return_value_errMsgString$3;
    return_value_errMsgString$3=errMsgString(errcode);
    fprintf(stderr, ERRMSG_FORMAT, tmp_if_expr$1, progfil, linenum, return_value_strMessageLevel$2, return_value_errMsgString$3, message != ((const char *)NULL) ? message : "");
    if(!(emp == ((struct _ErrMsg *)NULL)))
    {
      fprintReadNameAndNumber(stderr, emp->currReadNam, emp->currReadNo);
      errMsgFlush(stderr, emp);
      exit(1);
    }

  }

  else
  {
    mp = emp->messages + (signed long int)emp->num;
    mp->code = errcode;
    mp->linno = linenum;
    mp->num = emp->num;
    mp->level = (signed short int)((signed int)level < 5 ? (signed int)level : 1);
    if(!((signed int)emp->usedSpace >= 512))
    {
      mp->filnamp = emp->mspace + (signed long int)emp->usedSpace;
      maxfree = (signed short int)((512 - (signed int)emp->usedSpace) - 1);
      n = (signed short int)0;
      for( ; !(progfil[(signed long int)n] == 0) && !((signed int)n >= (signed int)maxfree); n = n + 1)
        mp->filnamp[(signed long int)n] = progfil[(signed long int)n];
      tmp_post$4 = n;
      n = n + 1;
      mp->filnamp[(signed long int)tmp_post$4] = (char)0;
      emp->usedSpace = emp->usedSpace + n;
    }

    else
      mp->filnamp = (char *)(void *)0;
    if(!((signed int)emp->usedSpace >= 512))
    {
      mp->textp = emp->mspace + (signed long int)emp->usedSpace;
      maxfree = (signed short int)((512 - (signed int)emp->usedSpace) - 1);
      n = (signed short int)0;
      for( ; !(message[(signed long int)n] == 0) && !((signed int)n >= (signed int)maxfree); n = n + 1)
        mp->textp[(signed long int)n] = message[(signed long int)n];
      tmp_post$5 = n;
      n = n + 1;
      mp->textp[(signed long int)tmp_post$5] = (char)0;
      emp->usedSpace = emp->usedSpace + n;
    }

    else
      mp->textp = (char *)(void *)0;
    if(!((signed int)emp->usedSpace >= 512))
    {
      mp->readnamp = emp->mspace + (signed long int)emp->usedSpace;
      maxfree = (signed short int)((512 - (signed int)emp->usedSpace) - 1);
      n = (signed short int)0;
      for( ; !(emp->currReadNam[(signed long int)n] == 0) && !((signed int)n >= (signed int)maxfree); n = n + 1)
        mp->readnamp[(signed long int)n] = emp->currReadNam[(signed long int)n];
      tmp_post$6 = n;
      n = n + 1;
      mp->readnamp[(signed long int)tmp_post$6] = (char)0;
      emp->usedSpace = emp->usedSpace + n;
    }

    else
      mp->readnamp = (char *)(void *)0;
    emp->num = emp->num + 1;
    if((signed int)emp->num >= 10)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)emp->usedSpace + 32 > 512 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      errMsgFlush(stderr, emp);
      exit(1);
    }

  }
}

// errMsgCreate
// file elib.h line 154
struct _ErrMsg * errMsgCreate(const char *progfil, signed int linenum)
{
  signed int i;
  struct _ErrMsg *p;
  void *return_value_emalloc$1;
  return_value_emalloc$1=emalloc(sizeof(struct _ErrMsg) /*1072ul*/ , progfil, linenum);
  p = (struct _ErrMsg *)return_value_emalloc$1;
  if(p == ((struct _ErrMsg *)NULL))
    exit(1);

  p->num = (signed short int)0;
  i = 0;
  for( ; !(i >= 10); i = i + 1)
    p->messages[(signed long int)i].level = (signed short int)0;
  p->currReadNam[(signed long int)0] = (char)0;
  p->currReadNo = (unsigned long int)0;
  p->usedSpace = (signed short int)0;
  p->mspace[(signed long int)0] = (char)0;
  return p;
}

// errMsgEnd
// file elib.h line 157
void errMsgEnd(struct _ErrMsg *p)
{
  if(!(p == ((struct _ErrMsg *)NULL)))
  {
    if((signed int)p->num >= 1)
      errMsgFlush(stdout, p);

  }

  free((void *)p);
}

// errMsgFlush
// file elib.c line 395
void errMsgFlush(struct _IO_FILE *fp, struct _ErrMsg *emp)
{
  signed short int tmp_post$1;
  char *tmp_if_expr$4;
  if(!(emp == ((struct _ErrMsg *)NULL)))
  {
    struct _MESSAGE *mp;
    do
    {
      tmp_post$1 = emp->num;
      emp->num = emp->num - 1;
      if(tmp_post$1 == 0)
        break;

      mp = emp->messages + (signed long int)emp->num;
      const char *return_value_strMessageLevel$2;
      return_value_strMessageLevel$2=strMessageLevel((unsigned char)mp->level);
      const char *return_value_errMsgString$3;
      return_value_errMsgString$3=errMsgString(mp->code);
      if(!(mp->textp == ((char *)NULL)))
        tmp_if_expr$4 = mp->textp;

      else
        tmp_if_expr$4 = "";
      fprintf(fp, ERRMSG_FORMAT, mp->num, mp->filnamp, mp->linno, return_value_strMessageLevel$2, return_value_errMsgString$3, tmp_if_expr$4);
      fprintReadNameAndNumber(fp, mp->readnamp, mp->readno);
    }
    while((_Bool)1);
  }

}

// errMsgSetCurrentReadName
// file elib.h line 160
void errMsgSetCurrentReadName(struct _ErrMsg *emp, const char *namp)
{
  strncpy(emp->currReadNam, namp, (unsigned long int)64);
  emp->currReadNam[(signed long int)(64 - 1)] = (char)0;
}

// errMsgSetCurrentReadNumber
// file elib.h line 163
void errMsgSetCurrentReadNumber(struct _ErrMsg *emp, unsigned long int rno)
{
  emp->currReadNo = rno;
}

// errMsgString
// file elib.c line 82
const char * errMsgString(signed int errcode)
{
  switch(errcode)
  {
    case 0:
      return "success";
    case -1:
      return "failure";
    case 2:
      return "memory allocation failed";
    case 3:
      return "unexpected end of file";
    case 4:
      return "unknown SeqIO type";
    case 5:
      return "wrong file type";
    case 6:
      return "wrong FASTQ/FASTA format";
    case 7:
      return "wrong or missing FASTQ prompt";
    case 8:
      return "wrong I/O mode";
    case 9:
      return "could not open file";
    case 10:
      return "end of file";
    case 11:
      return "could not write to file";
    case 12:
      return "attempt to write to file opened for reading";
    case 13:
      return "attempt to read from file opened for writing";
    case 14:
      return "could not read from file";
    case 15:
      return "unexpected NULL pointer";
    case 16:
      return "hashed word length too long";
    case 17:
      return "maximum number of k-mer positions exceeded";
    case 18:
      return "sequence type cannot be hashed";
    case 19:
      return "cannot add sequence to hash table because table is already set up";
    case 20:
      return "invalid function argument";
    case 21:
      return "broken hash table";
    case 22:
      return "wrong type of sequence encoding";
    case 23:
      return "list of hits not yet sorted - sequence indices not assigned";
    case 24:
      return "integer outside the range of integer type";
    case 25:
      return "Read hash files are inconsistent";
    case 26:
      return "expected sequences represented as character strings";
    case 27:
      return "couldn't set I/O buffer size";
    case 28:
      return "inconsistency resulting from sequence compression";
    case 29:
      return "arguments outside expected range";
    case 30:
      return "sequence too short to be hashed";
    case 31:
      return "command line format error";
    case 32:
      return "hit boundary of allocated memory";
    case 33:
      return "error in file format";
    case 34:
      return "sort stack overflow";
    case 35:
      return "hit list does not have required status";
    case 36:
      return "sequence too long";
    case 37:
      return "no sequence to be hashed";
    case 38:
      return "quality factor and base sequence lengths differ";
    case 39:
      return "wrong sequence type";
    case 40:
      return "rounding error when calculating frequency sums";
    case 41:
      return "Smith-Waterman score overflow";
    case 42:
      return "Alignment score exceeds target while back tracking";
    case 43:
      return "Mutation count inconsistent in diff string";
    case 44:
      return "Inconsistency when calculating Smith-Waterman scores";
    case 45:
      return "inconsistent query length between forward and reverse complement hit lists";
    case 46:
      return "Match list does not have correct status";
    case 47:
      return "assertion failed";
    case 48:
      return "integer overflow";
    case 49:
      return "setting file position when error occured";
    case 50:
      return "file input/output error";
    case 51:
      return "error when parsing command line";
    case 52:
      return "file written under different endianess - conversion failed";
    case 53:
      return "The two FASTA/FASTQ input file have different numbers of reads";
    case 54:
      return "file name too long";
    case 55:
      return "wrong size of file type specific header in binary file";
    case 56:
      return "wrong version of binary file format";
    case 57:
      return "sequence too long";
    case 58:
      return "sequence index missing";
    case 59:
      return "inconsistent diff-string";
    case 60:
      return "sequence offset greater than sequence length";
    case 61:
      return "termination of iterative calls";
    case 62:
      return "complexity weighted score exceeds unweighted score";
    case 63:
      return "thread returned error";
    case 64:
      return "HashHitInfo has wrong status";
    case 65:
      return "K-mer statistics insufficient for binning";
    case 66:
      return "inconsistency in striping format for Smith-Waterman using SSE2";
    case 67:
      return "invalid FASTQ base quality value";
    case 68:
      return "fetched only part of segment requested from sequence set";
    case 69:
      return "word on not found in hash index";
    case 70:
      return "thread stack overflow";
    case 71:
      return "file size too big";
    case 72:
      return "sampling step size to small for total length of reference sequences";
    case 73:
      return "total number of nucleotides in sequence set exceeds limit";
    case 74:
      return "number of pairs exceeds limit";
    case 75:
      return "Found no match";
    case 76:
      return "Read names don't match as expected for a read pair";
    case 77:
      return "Number of reads differs in the two input files for paired reads";
    case 78:
      return "Early termination triggered by debugging code";
    case 79:
      return "Termination signal for thread";
    case 80:
      return "could not pull thread argument from buffer (check not fulfilled)";
    case 81:
      return "Sequence name too long";
    case 82:
      return "Number of positions in hash index caused integer overflow";
    case 83:
      return "Unrecognised sequence input format";
    case 84:
      return "Unrecognised sequence output format";
    case 85:
      return "Nucleotide symbol is not a letter";
    case 86:
      return "Number of sequences exceeds limit";
    case 87:
      return "bambamc library returns error";
    case 88:
      return "named semaphore could not be opened";
    default:
      return "unknown error code";
  }
}

// estrcat
// file elib.c line 530
char * estrcat(const char *str1, const char *str2, const char *progfil, signed int line)
{
  char *cp;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(str2);
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
  cp = (char *)return_value_malloc$3;
  if(!(cp == ((char *)NULL)))
  {
    strcpy(cp, str1);
    strcat(cp, str2);
  }

  else
    fprintf(stderr, "ERROR: estrcat() failed in %s, line %i\n", progfil, line);
  return cp;
}

// estrcpy
// file elib.h line 196
char * estrcpy(const char *str, const char *progfil, signed int line)
{
  char *cp;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
  cp = (char *)return_value_malloc$2;
  if(!(cp == ((char *)NULL)))
    strcpy(cp, str);

  else
    fprintf(stderr, "ERROR: estrcpy() failed in %s, line %i\n", progfil, line);
  return cp;
}

// exitArgumentRangeError
// file menu.c line 861
static void exitArgumentRangeError(const char *option, signed long int minval, signed long int maxval)
{
  printf("Command line error: ");
  if(!(option == ((const char *)NULL)))
  {
    printf("option '%s' requires as argument integer values ", option);
    if(!(minval >= maxval))
      printf("between %li and %li", minval, maxval);

    else
      printf(">= %li", minval);
  }

  exit(1);
}

// exitOptionError
// file menu.c line 840
static void exitOptionError(const char *option, const char *expl)
{
  printf("Command line error: ");
  if(!(option == ((const char *)NULL)))
    printf("option '%s' ", option);

  if(!(expl == ((const char *)NULL)))
    printf("%s", expl);

  printf("\n");
  exit(1);
}

// exitPairedReadError
// file menu.c line 852
static void exitPairedReadError(const char *option)
{
  printf("Command line error: ");
  if(!(option == ((const char *)NULL)))
    printf("option '%s' ", option);

  printf("implies paired read mapping for which 2 read files are expected as input.\n");
  exit(1);
}

// extendCand
// file segment.c line 1097
static signed int extendCand(struct _SEGCAND *sgcp, struct _SEGMENT *segmr, struct _HITREGION * const hregr, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip)
{
  signed int errcode;
  signed int ovl;
  unsigned int i;
  unsigned int endix;
  struct _SEGMENT *sip;
  struct _SEGMENT *sap = segmr + (signed long int)sgcp->segix;
  struct _HITREGION *hregp = hregr + (signed long int)sgcp->hregix;
  endix = hregp->idx + (unsigned int)hregp->num;
  _Bool tmp_if_expr$1;
  if(!(sap->ix >= hregp->idx))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sap->ix >= endix ? (_Bool)1 : (_Bool)0;
  unsigned int tmp_if_expr$2;
  unsigned int tmp_if_expr$3;
  if(tmp_if_expr$1)
    return 47;

  else
  {
    i = sgcp->segix - (unsigned int)1;
    for( ; i >= hregp->idx; i = i - 1u)
    {
      sip = segmr + (signed long int)i;
      if(!(sip->nseed >= 0))
        break;

      ovl=calcSegmentOverlap(sip, sap, seedr);
      if(!((signed int)!(sip->cover >= sap->cover) >= ovl))
        tmp_if_expr$2 = sip->cover;

      else
        tmp_if_expr$2 = sap->cover / (unsigned int)2;
      if(!(tmp_if_expr$2 == 0u))
        break;

      errcode=updateCandBoundaries(sgcp, sip, seedr, ktup, nskip);
      if(!(errcode == 0))
        return errcode;

      sip->nseed = sip->nseed * -1;
    }
    i = sgcp->segix + (unsigned int)1;
    for( ; !(i >= endix); i = i - 1u)
    {
      sip = segmr + (signed long int)i;
      if(!(sip->nseed >= 0))
        break;

      ovl=calcSegmentOverlap(sip, sap, seedr);
      if(!((signed int)!(sip->cover >= sap->cover) >= ovl))
        tmp_if_expr$3 = sip->cover;

      else
        tmp_if_expr$3 = sap->cover / (unsigned int)2;
      if(!(tmp_if_expr$3 == 0u))
        break;

      errcode=updateCandBoundaries(sgcp, sip, seedr, ktup, nskip);
      if(!(errcode == 0))
        return errcode;

      sip->nseed = sip->nseed * -1;
    }
    return 0;
  }
}

// filioOpenForReading
// file filio.h line 72
struct _IO_FILE * filioOpenForReading(signed int *errcode, unsigned char *is_endianid, unsigned int *siz, unsigned char *typ, unsigned int *version, unsigned int *headsiz, unsigned int *header, const char *filnam, const char *filext)
{
  char fnam[4096l];
  unsigned long int namlen;
  unsigned long int extlen;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(filext == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(filext);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  extlen = tmp_if_expr$2;
  unsigned long int nrobj;
  unsigned int filsiz = (unsigned int)0;
  unsigned int hs = (unsigned int)0;
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  _Bool tmp_if_expr$3;
  if(filnam == ((const char *)NULL))
  {
    *errcode = 15;
    return fp;
  }

  else
  {
    *errcode = 0;
    namlen=strlen(filnam);
    if(2ul + extlen + namlen >= 4097ul)
      *errcode = 54;

    strcpy(fnam, filnam);
    if(extlen >= 1ul)
    {
      fnam[(signed long int)namlen] = (char)46;
      fnam[(signed long int)(namlen + (unsigned long int)1)] = (char)0;
      strcat(fnam, filext);
      fnam[(signed long int)(namlen + extlen + (unsigned long int)1)] = (char)0;
    }

    else
      fnam[(signed long int)namlen] = (char)0;
    fp=fopen(fnam, "rb");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      *errcode = 9;
      return ((struct _IO_FILE *)NULL);
    }

    else
    {
      *errcode=readHeader(&filsiz, typ, version, is_endianid, &hs, fp);
      if(!(*errcode == 0))
      {
        fclose(fp);
        return ((struct _IO_FILE *)NULL);
      }

      else
      {
        if(!(filsiz >= 12u))
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = hs > *headsiz ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          *errcode = 55;
          fclose(fp);
          return ((struct _IO_FILE *)NULL);
        }

        else
        {
          *siz = filsiz - (unsigned int)12;
          nrobj=fread((void *)header, sizeof(unsigned int) /*4ul*/ , (unsigned long int)hs, fp);
          *headsiz = hs;
          if(!(nrobj == (unsigned long int)hs))
          {
            signed int return_value_ferror$4;
            return_value_ferror$4=ferror(fp);
            if(!(return_value_ferror$4 == 0))
              perror(READERRMSG);

            fclose(fp);
            *errcode = 14;
            fp = ((struct _IO_FILE *)NULL);
          }

          if(is_endianid == ((unsigned char *)NULL))
            filioSwapEndian(header, hs);

          return fp;
        }
      }
    }
  }
}

// filioOpenForWriting
// file filio.h line 55
struct _IO_FILE * filioOpenForWriting(signed int *errcode, unsigned int siz, unsigned char typ, unsigned int version, unsigned int headsiz, const unsigned int *header, const char *filnam, const char *filext)
{
  char fnam[4096l];
  unsigned long int namlen;
  namlen=strlen(filnam);
  unsigned long int extlen;
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(filext == ((const char *)NULL)))
  {
    return_value_strlen$1=strlen(filext);
    tmp_if_expr$2 = return_value_strlen$1;
  }

  else
    tmp_if_expr$2 = (unsigned long int)0;
  extlen = tmp_if_expr$2;
  struct _IO_FILE *fp = ((struct _IO_FILE *)NULL);
  *errcode = 0;
  if(1ul + extlen + namlen >= 4097ul)
    *errcode = 54;

  strcpy(fnam, filnam);
  if(!(filext == ((const char *)NULL)))
  {
    fnam[(signed long int)namlen] = (char)46;
    fnam[(signed long int)(namlen + (unsigned long int)1)] = (char)0;
    strcat(fnam, filext);
    fnam[(signed long int)(namlen + extlen + (unsigned long int)1)] = (char)0;
  }

  else
    fnam[(signed long int)namlen] = (char)0;
  fp=fopen(fnam, "wb");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    *errcode = 9;
    return ((struct _IO_FILE *)NULL);
  }

  else
  {
    *errcode=writeHeader(siz + (unsigned int)12, typ, version, headsiz, fp);
    if(!(*errcode == 0))
    {
      fclose(fp);
      return ((struct _IO_FILE *)NULL);
    }

    else
    {
      fwrite((const void *)header, sizeof(unsigned int) /*4ul*/ , (unsigned long int)headsiz, fp);
      signed int return_value_ferror$3;
      return_value_ferror$3=ferror(fp);
      if(!(return_value_ferror$3 == 0))
      {
        perror(WRITERRMSG);
        fclose(fp);
        *errcode = 11;
        fp = ((struct _IO_FILE *)NULL);
      }

      return fp;
    }
  }
}

// filioSwapEndian
// file filio.h line 93
void filioSwapEndian(unsigned int *p, unsigned int len)
{
  char *cp;
  char tmp;
  unsigned int *tmp_post$1;
  do
  {
    len = len - 1u;
    if(!(len >= 1u))
      break;

    tmp_post$1 = p;
    p = p + 1l;
    cp = (char *)tmp_post$1;
    tmp = cp[(signed long int)1];
    cp[(signed long int)1] = cp[(signed long int)4];
    cp[(signed long int)4] = tmp;
    tmp = cp[(signed long int)2];
    cp[(signed long int)2] = cp[(signed long int)3];
    cp[(signed long int)3] = tmp;
  }
  while((_Bool)1);
}

// fillHitListFromHitInfoSegment
// file hashhit.c line 1417
static signed int fillHitListFromHitInfoSegment(struct _HashHitList *hlp, unsigned int segpos_lo, unsigned int segpos_hi, unsigned int maxhit_per_tuple, unsigned char use_short_hitinfo, const struct _HashHitInfo *hip, const struct _HashTable *htp, const struct _HashHitFilter *hhfp)
{
  signed int errcode;
  const unsigned char is_reverse = (const unsigned char)((signed int)hip->status & 1);
  const unsigned char nskip = hip->nskip;
  unsigned int nhits;
  unsigned int nh;
  unsigned int i;
  unsigned int k;
  signed short int j;
  unsigned int n;
  unsigned int tuplectr;
  unsigned int n_seeds;
  _Bool tmp_if_expr$1;
  if(!(use_short_hitinfo == 0))
    tmp_if_expr$1 = hip->seed_rank > (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  unsigned int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = hip->seed_rank;

  else
    tmp_if_expr$2 = hip->n_seeds;
  n_seeds = tmp_if_expr$2;
  struct _SEED *seedp;
  unsigned int *posp;
  unsigned long int *sqdatp;
  const unsigned long int offbit = (unsigned long int)1 << 31 + 1;
  unsigned char * const qmaskp = hip->qmaskp;
  const struct _FILTERIVAL *ivalp = ((const struct _FILTERIVAL *)NULL);
  errcode=initHitList(hlp, hip);
  unsigned int tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(!(errcode == 0))
    return errcode;

  else
  {
    n = (unsigned int)0;
    for( ; !(n >= n_seeds); n = n + 1u)
    {
      if(!(use_short_hitinfo == 0))
        tmp_if_expr$3 = hip->sidxp[(signed long int)n];

      else
        tmp_if_expr$3 = n;
      seedp = hip->seedp + (signed long int)tmp_if_expr$3;
      if(maxhit_per_tuple >= 1u)
      {
        if(maxhit_per_tuple >= hip->nhitqual_sortkeyp[(signed long int)n])
          goto __CPROVER_DUMP_L9;

        qmaskp[(signed long int)seedp->qoffs] = (unsigned char)2;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        nhits=hashTableFetchHitPositions(&posp, htp, seedp->posidx);
        if(seedp->cix >= nhits)
        {
          if(!(posp[(signed long int)(nhits + 4294967295u)] >= segpos_lo))
            goto __CPROVER_DUMP_L37;

          seedp->cix = (unsigned int)0;
        }

        if(!(segpos_lo >= posp[(signed long int)seedp->cix]))
          seedp->cix = (unsigned int)0;

        posp = posp + (signed long int)seedp->cix;
        nh = nhits - seedp->cix;
        i = (unsigned int)0;
        do
        {
          if(!(i >= nh))
            tmp_if_expr$4 = posp[(signed long int)i] < segpos_lo ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(!tmp_if_expr$4)
            break;

          i = i + 1u;
        }
        while((_Bool)1);
        nh = nh - i;
        seedp->cix = seedp->cix + i;
        posp = posp + (signed long int)i;
        if(!((unsigned int)hlp->nhits_alloc >= nh + (unsigned int)hlp->nhits))
        {
          if(maxhit_per_tuple >= 1u)
            return 32;

          qmaskp[(signed long int)seedp->qoffs] = (unsigned char)2;
        }

        else
        {
          tuplectr = seedp->qoffs;
          sqdatp = hlp->sqdat + (signed long int)hlp->nhits;
          k = (unsigned int)0;
          if(!(hhfp == ((const struct _HashHitFilter *)NULL)))
          {
            i = (unsigned int)0;
            j = (signed short int)0;
            do
            {
              if(!(i >= nh))
                tmp_if_expr$5 = posp[(signed long int)i] < segpos_hi ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$5 = (_Bool)0;
              if(!tmp_if_expr$5)
                break;

              ivalp = hhfp->ivp + (signed long int)j;
              if(posp[(signed long int)i] >= ivalp->lower)
              {
                do
                {
                  if(!(ivalp->upper >= posp[(signed long int)i]))
                    tmp_if_expr$6 = (signed int)j < (signed int)hhfp->num ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$6 = (_Bool)0;
                  if(!tmp_if_expr$6)
                    break;

                  ivalp = hhfp->ivp + (signed long int)j;
                  j = j + 1;
                }
                while((_Bool)1);
                if((signed int)j >= (signed int)hhfp->num)
                  break;

                if(posp[(signed long int)i] >= ivalp->lower)
                {
                  if(!(is_reverse == 0))
                    sqdatp[(signed long int)k] = ((unsigned long int)posp[(signed long int)i] + (unsigned long int)(tuplectr / (unsigned int)nskip) << 31) + (unsigned long int)tuplectr;

                  else
                    sqdatp[(signed long int)k] = (((unsigned long int)posp[(signed long int)i] | offbit) - (unsigned long int)(tuplectr / (unsigned int)nskip) << 31) + (unsigned long int)tuplectr;
                  k = k + 1u;
                }

              }

              i = i + 1u;
            }
            while((_Bool)1);
          }

          else
          {
            i = (unsigned int)0;
            do
            {
              if(!(i >= nh))
                tmp_if_expr$7 = posp[(signed long int)i] < segpos_hi ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$7 = (_Bool)0;
              if(!tmp_if_expr$7)
                break;

              if(!(is_reverse == 0))
                sqdatp[(signed long int)i] = ((unsigned long int)posp[(signed long int)i] + (unsigned long int)(tuplectr / (unsigned int)nskip) << 31) + (unsigned long int)tuplectr;

              else
                sqdatp[(signed long int)i] = (((unsigned long int)posp[(signed long int)i] | offbit) - (unsigned long int)(tuplectr / (unsigned int)nskip) << 31) + (unsigned long int)tuplectr;
              i = i + 1u;
            }
            while((_Bool)1);
            k = i;
          }
          seedp->cix = seedp->cix + i;
          hlp->nhits = hlp->nhits + (signed int)k;
        }
      }

    __CPROVER_DUMP_L37:
      ;
    }
    return 0;
  }
}

// fillRMAPBUFF
// file rmap.c line 1153
static signed int fillRMAPBUFF(struct RMAPBUFF_ *bufp, const struct RMAPINFO_ *rmrp, unsigned char with_seqidx, signed int ktuple_maxhit, unsigned int min_ktup, unsigned int min_cover, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivr)
{
  signed int errcode;
  blankRMAPBUFF(bufp);
  if(!(ivr == ((const struct V_IVAL_ *)NULL)))
  {
    errcode=collectHitsFromInterVal(bufp->sacp, bufp->sglp, bufp->hhlp, bufp->qmp, (unsigned int)ktuple_maxhit, min_ktup, min_cover, rmrp->hhiFp, htp, ssp, ivr);
    if(errcode == 0)
      errcode=collectHitsFromInterVal(bufp->sacp, bufp->sglp, bufp->hhlp, bufp->qmp, (unsigned int)ktuple_maxhit, min_ktup, min_cover, rmrp->hhiRp, htp, ssp, ivr);

  }

  else
  {
    errcode=collectHits(bufp->sacp, with_seqidx, bufp->sglp, bufp->hhlp, bufp->qmp, (unsigned int)ktuple_maxhit, min_ktup, min_cover, rmrp->hhiFp, htp, ssp);
    if(errcode == 0)
      errcode=collectHits(bufp->sacp, with_seqidx, bufp->sglp, bufp->hhlp, bufp->qmp, (unsigned int)ktuple_maxhit, min_ktup, min_cover, rmrp->hhiRp, htp, ssp);

  }
  return errcode;
}

// finaliseSeq
// file sequence.c line 768
static signed int finaliseSeq(struct _SEQSEQ *sp)
{
  char *hp;
  if(sp->basep == ((char *)NULL))
    return 0;

  else
  {
    void *return_value_erealloc$1;
    return_value_erealloc$1=erealloc((void *)sp->basep, (sp->size + (unsigned long int)1) * sizeof(char) /*1ul*/ , (unsigned long int)0, "sequence.c", 773);
    hp = (char *)return_value_erealloc$1;
    if(hp == ((char *)NULL))
      return 2;

    else
    {
      sp->basep = hp;
      sp->alloc_size = sp->size + (unsigned long int)1;
      return 0;
    }
  }
}

// findInsHistMax
// file insert.c line 230
static signed int findInsHistMax(const struct _InsHist *pHist, signed int *count_max, signed int *range_min, signed int *range_max)
{
  signed int i;
  *count_max = 0;
  *range_max = *count_max;
  *range_min = *range_max;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= pHist->iSpan))
      tmp_if_expr$1 = pHist->pCounts[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  if(i >= pHist->iSpan)
    return -1;

  else
  {
    *range_max = i;
    *range_min = *range_max;
    *count_max = pHist->pCounts[(signed long int)i];
    for( ; !(i >= pHist->iSpan); i = i + 1)
      if(pHist->pCounts[(signed long int)i] >= 1)
      {
        *range_max = i;
        if(!(*count_max >= pHist->pCounts[(signed long int)i]))
          *count_max = pHist->pCounts[(signed long int)i];

      }

    return 0;
  }
}

// findProperMATEPAIR
// file resultpairs.c line 529
static signed int findProperMATEPAIR(struct _ResultPairs * const pairp, const struct _ResultSet *rsp, signed int swscor_min, const struct _OFFSIVAL * const oivr, unsigned char pairlibcode, signed int maxnum)
{
  signed int errcode;
  signed short int nres;
  struct GETPROPERMATEPAIRARG_ arg;
  ((unsigned long int *)pairp->mpr)[(signed long int)-1] = (unsigned long int)0;
  errcode=resultSetGetNumberOfSegments(&nres, (signed short int *)(void *)0, rsp);
  if(!(errcode == 0))
    return errcode;

  else
    if(!((signed int)nres >= 1))
      return 0;

    else
    {
      if(!(maxnum >= 1))
        maxnum = 1;

      signed int return_value_resultSetGetMaxSwat$1;
      return_value_resultSetGetMaxSwat$1=resultSetGetMaxSwat(rsp, (signed int *)(void *)0);
      if(!(return_value_resultSetGetMaxSwat$1 >= swscor_min))
        return 0;

      else
      {
        arg.ivalx = (signed short int)0;
        arg.max_rank = (signed short int)0;
        arg.maxnum = maxnum;
        arg.swscor_min = swscor_min;
        arg.pairlibcode = pairlibcode;
        arg.oivr = oivr;
        arg.pairp = pairp;
        errcode=resultSetDo((void *)&arg, getProperMATEPAIRcbf, rsp);
        return errcode;
      }
    }
}

// findREPALI
// file report.c line 545
static signed int findREPALI(const struct _REPALI *rar, signed int *idxp, unsigned int q_start, unsigned int q_end, unsigned char rmatflg, unsigned int s_start, unsigned int s_end, signed long int s_idx)
{
  const unsigned long int n = ((unsigned long int *)rar)[(signed long int)-1];
  const unsigned char mask = (const unsigned char)(2 | 8);
  signed int i;
  *idxp = -1;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!(n >= 1ul))
    return -1;

  else
    if(n >= 2147483648ul)
      return 48;

    else
    {
      i = (signed int)n - 1;
      do
      {
        if(i >= 0)
        {
          if(!(s_start == (rar + (signed long int)i)->s_start))
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = s_end != (rar + (signed long int)i)->s_end ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = s_idx != (rar + (signed long int)i)->s_idx ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = q_start != (rar + (signed long int)i)->q_start ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = q_end != (rar + (signed long int)i)->q_end ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = ((signed int)rmatflg & (signed int)mask) != ((signed int)(rar + (signed long int)i)->status & (signed int)mask) ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(!tmp_if_expr$6)
          break;

        i = i - 1;
      }
      while((_Bool)1);
      *idxp = i;
      return i < 0 ? -1 : 0;
    }
}

// findSplitReads
// file results.c line 1436
static signed int findSplitReads(struct _RESULT * const *rspp)
{
  signed short int i;
  signed short int j;
  signed short int n = (signed short int)((unsigned long int *)rspp)[(signed long int)-1];
  signed int swatscor_1st = rspp[(signed long int)0]->swatscor;
  signed short int n_split = (signed short int)0;
  struct _RESULT *ap;
  struct _RESULT *bp;
  i = (signed short int)0;
  _Bool tmp_if_expr$1;
  for( ; !((signed int)i >= (signed int)n); i = i + 1)
  {
    ap = rspp[(signed long int)i];
    if(!(ap->swatscor >= swatscor_1st))
      break;

    j = (signed short int)((signed int)i + 1);
    for( ; !((signed int)j >= (signed int)n); j = j + 1)
    {
      bp = rspp[(signed long int)j];
      if(!((signed int)bp->rsltx >= 0))
      {
        if(!(ap->q_end >= bp->q_start))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = ap->q_start > bp->q_end ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          bp->rsltx = i;
          ap->status = ap->status | (unsigned short int)64;
          n_split = n_split + 1;
          break;
        }

      }

    }
  }
  return (signed int)n_split;
}

// fprintAlignment
// file report.c line 248
static signed int fprintAlignment(struct _IO_FILE *fp, struct _SeqFastq *sbufp, struct _SeqFastq *qbufp, const struct _SeqFastq *sqp, unsigned short int linwidth, const struct _DiffStr *dfsp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct _REPALI *rp)
{
  signed int errcode;
  char cod;
  char qbuf[120l];
  char dbuf[120l];
  char sbuf[120l];
  char q_bastyp;
  char s_bastyp;
  const char *qcp;
  const char *scp;
  unsigned char k;
  unsigned char typ;
  unsigned char count;
  unsigned short int j;
  unsigned int s;
  unsigned int q;
  unsigned int len;
  unsigned int qlen;
  unsigned int slen;
  unsigned int q_linstart;
  unsigned int s_linstart;
  const unsigned char *ucp;
  const unsigned char *diffstrp = dfsp->dstrp + (signed long int)rp->dfo;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  unsigned char tmp_post$7;
  unsigned int tmp_post$5;
  unsigned int tmp_post$6;
  unsigned int tmp_post$8;
  unsigned int tmp_post$9;
  unsigned int tmp_post$10;
  unsigned int tmp_post$11;
  unsigned int tmp_if_expr$12;
  unsigned int tmp_if_expr$13;
  if(rp == ((const struct _REPALI *)NULL))
    return 47;

  else
  {
    char return_value_seqCodecType$1;
    return_value_seqCodecType$1=seqCodecType(codecp);
    if(!((signed int)return_value_seqCodecType$1 == 0))
      return 47;

    else
    {
      seqFastqGetConstSequence(sqp, &qlen, &cod);
      if(!(rp->q_start >= 1u))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = rp->q_start > rp->q_end ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = rp->q_end > qlen ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        return 47;

      else
      {
        if((signed int)linwidth >= 120)
          linwidth = (unsigned short int)(120 - 1);

        else
          if(!((signed int)linwidth >= 1))
            linwidth = (unsigned short int)60;

        seqFastqBlank(qbufp);
        if(!((2 & (signed int)rp->status) == 0))
        {
          errcode=seqFastqAppendSegment(qbufp, sqp, rp->q_start - (unsigned int)1, (rp->q_end - rp->q_start) + (unsigned int)1, (char)1, codecp);
          if(!(errcode == 0))
            return errcode;

        }

        else
        {
          errcode=seqFastqAppendSegment(qbufp, sqp, rp->q_start - (unsigned int)1, (rp->q_end - rp->q_start) + (unsigned int)1, (char)0, (const struct _SeqCodec *)(void *)0);
          if(!(errcode == 0))
            return errcode;

        }
        if((signed int)cod == 1)
        {
          errcode=seqFastqDecode(qbufp, codecp);
          if(errcode == 0)
            goto __CPROVER_DUMP_L13;

          return errcode;
        }

        else
        {

        __CPROVER_DUMP_L13:
          ;
          qcp=seqFastqGetConstSequence(qbufp, &qlen, &cod);
          if(!((signed int)cod == 0))
            return 22;

          else
          {
            if(!(rp->s_start >= 1u))
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = rp->s_start > rp->s_end ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$4)
              return 47;

            else
            {
              len = (rp->s_end - rp->s_start) + (unsigned int)1;
              if(!(rp->s_idx >= 0l))
                return 58;

              else
              {
                errcode=seqSetFetchSegmentBySequence(sbufp, rp->s_idx, (unsigned int)rp->s_start - (unsigned int)1, len, ssp, codecp);
                if(!(errcode == 0))
                  return errcode;

                else
                {
                  scp=seqFastqGetConstSequence(sbufp, &slen, (char *)(void *)0);
                  if(!(slen == len))
                    return 47;

                  else
                  {
                    ucp = diffstrp;
                    s_linstart = (unsigned int)0;
                    q_linstart = s_linstart;
                    typ = (unsigned char)((signed int)*ucp >> 6);
                    count = (unsigned char)((signed int)*ucp & 63);
                    k = (unsigned char)0;
                    s = (unsigned int)0;
                    q = s;
                    for( ; qlen >= q && slen >= s && !(*ucp == 0); j = (unsigned short int)0)
                    {
                      j = (unsigned short int)0;
                      for( ; qlen >= q && slen >= s && !((signed int)j >= (signed int)linwidth); j = j + 1)
                      {
                        tmp_post$7 = k;
                        k = k + 1;
                        if(!((signed int)tmp_post$7 >= (signed int)count))
                        {
                          tmp_post$5 = q;
                          q = q + 1u;
                          qbuf[(signed long int)j] = qcp[(signed long int)tmp_post$5];
                          dbuf[(signed long int)j] = (char)32;
                          tmp_post$6 = s;
                          s = s + 1u;
                          sbuf[(signed long int)j] = scp[(signed long int)tmp_post$6];
                        }

                        else
                        {
                          k = (unsigned char)0;
                          ucp = ucp + 1l;
                          if((signed int)typ == 0)
                          {
                            tmp_post$8 = q;
                            q = q + 1u;
                            qbuf[(signed long int)j] = qcp[(signed long int)tmp_post$8];
                            dbuf[(signed long int)j] = (char)32;
                            tmp_post$9 = s;
                            s = s + 1u;
                            sbuf[(signed long int)j] = scp[(signed long int)tmp_post$9];
                          }

                          else
                            if((signed int)typ == 3)
                            {
                              qbuf[(signed long int)j] = qcp[(signed long int)q];
                              sbuf[(signed long int)j] = scp[(signed long int)s];
                              if(!(*ucp == 0))
                              {
                                q_bastyp=seqCodecFindBaseClass(qcp[(signed long int)q], codecp);
                                s_bastyp=seqCodecFindBaseClass(scp[(signed long int)s], codecp);
                                if((signed int)q_bastyp == 3 || (signed int)s_bastyp == 3)
                                  dbuf[(signed long int)j] = (char)33;

                                else
                                  if((signed int)q_bastyp == 0 || (signed int)s_bastyp == 0)
                                    dbuf[(signed long int)j] = (char)63;

                                  else
                                    if(q_bastyp == s_bastyp)
                                      dbuf[(signed long int)j] = (char)105;

                                    else
                                      dbuf[(signed long int)j] = (char)118;
                                q = q + 1u;
                                s = s + 1u;
                              }

                              else
                                dbuf[(signed long int)j] = (char)32;
                            }

                            else
                              if((signed int)typ == 1)
                              {
                                qbuf[(signed long int)j] = (char)45;
                                dbuf[(signed long int)j] = (char)45;
                                tmp_post$10 = s;
                                s = s + 1u;
                                sbuf[(signed long int)j] = scp[(signed long int)tmp_post$10];
                              }

                              else
                                if((signed int)typ == 2)
                                {
                                  tmp_post$11 = q;
                                  q = q + 1u;
                                  qbuf[(signed long int)j] = qcp[(signed long int)tmp_post$11];
                                  dbuf[(signed long int)j] = (char)45;
                                  sbuf[(signed long int)j] = (char)45;
                                }

                          if(*ucp == 0)
                            break;

                          typ = (unsigned char)((signed int)*ucp >> 6);
                          count = (unsigned char)((signed int)*ucp & 63);
                        }
                      }
                      sbuf[(signed long int)j] = (char)0;
                      dbuf[(signed long int)j] = sbuf[(signed long int)j];
                      qbuf[(signed long int)j] = dbuf[(signed long int)j];
                      if(!((2 & (signed int)rp->status) == 0))
                        tmp_if_expr$12 = rp->q_end - q_linstart;

                      else
                        tmp_if_expr$12 = rp->q_start + q_linstart;
                      if(!((2 & (signed int)rp->status) == 0))
                        tmp_if_expr$13 = (rp->q_end - q) + (unsigned int)1;

                      else
                        tmp_if_expr$13 = (rp->q_start + q) - (unsigned int)1;
                      fprintf(fp, OUFMT_ALIGN, tmp_if_expr$12, (const void *)qbuf, tmp_if_expr$13, (const void *)dbuf, (unsigned int)(signed int)rp->s_start + s_linstart, (const void *)sbuf, ((unsigned int)(signed int)rp->s_start + s) - (unsigned int)1);
                      s_linstart = s;
                      q_linstart = q;
                    }
                    return *ucp != 0 ? 59 : 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// fprintCommandLine
// file menu.c line 1674
static void fprintCommandLine(struct _IO_FILE *fp, signed int argc, char **argv)
{
  signed int i;
  fprintf(fp, "# Command line: ");
  i = 0;
  for( ; !(i >= argc); i = i + 1)
    fprintf(fp, " %s", argv[(signed long int)i]);
  fprintf(fp, "\n");
}

// fprintHashOptions
// file menu.c line 1651
static signed int fprintHashOptions(struct _IO_FILE *fp, const struct _MenuOpt *menup)
{
  const struct _INDEXMENU *ip = (struct _INDEXMENU *)menup->paramp;
  if(!((signed int)menup->subprog == 1))
    return 47;

  else
  {
    fprintf(fp, "# [-k] kmer: %d\n", ip->kmer);
    fprintf(fp, "# [-s] skip: %d\n", ip->skip);
    return 0;
  }
}

// fprintMapOptions
// file menu.c line 1662
static signed int fprintMapOptions(struct _IO_FILE *fp, const struct _MenuOpt *menup)
{
  const struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  if(!((signed int)menup->subprog == 2))
    return 47;

  else
  {
    fprintf(fp, "# ncut: %d\n", mp->ncut);
    fprintf(fp, "# maxhit: %d\n", mp->maxhit);
    return 0;
  }
}

// fprintREPALIcigar
// file report.c line 711
static signed int fprintREPALIcigar(struct _IO_FILE *fp, const struct _REPALI *rp, signed short int mapscor, struct _REPSTR *q_namp, const struct _SeqFastq *q_sqp, const char *q_namext, const char *s_nam, const unsigned char *diffstr, unsigned char pairflg)
{
  signed int errcode;
  signed int swatscor;
  unsigned int qs;
  unsigned int qe;
  unsigned long int rs;
  unsigned long int re;
  char sensechr;
  char flagchr;
  errcode=copyReadNameToREPSTR(q_namp, (unsigned char)0, q_sqp);
  _Bool tmp_if_expr$1;
  if(!(errcode == 0))
    return errcode;

  else
  {
    if(!(rp == ((const struct _REPALI *)NULL)))
      tmp_if_expr$1 = ((signed int)rp->status & 1) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(!((2 & (signed int)rp->status) == 0))
      {
        qs = rp->q_end;
        qe = rp->q_start;
        sensechr = (char)45;
      }

      else
      {
        qs = rp->q_start;
        qe = rp->q_end;
        sensechr = (char)43;
      }
      rs = (unsigned long int)rp->s_start;
      re = (unsigned long int)rp->s_end;
      swatscor = rp->swatscor;
      flagchr=getMapLabelFromFlag(rp->status, pairflg);
    }

    else
    {
      re = (unsigned long int)0;
      rs = re;
      qe = (unsigned int)rs;
      qs = qe;
      sensechr = (char)42;
      s_nam = OUFMT_SAM_NULLSTR;
      swatscor = 0;
      mapscor = (signed short int)0;
      flagchr = (char)(((signed int)rp->status & 64) != 0 ? 82 : 78);
    }
    fprintf(fp, OUFMT_CIGAR, flagchr, (signed int)mapscor > 99 ? 99 : (signed int)mapscor, q_namp->strp, q_namext, qs, qe, sensechr, s_nam, (unsigned int)rs, (unsigned int)re, swatscor);
    errcode=diffStrPrintf(fp, diffstr, (char)2, 0, 0, (char)0);
    fprintf(fp, "\n");
    return errcode;
  }
}

// fprintREPALIgff2
// file report.c line 648
static signed int fprintREPALIgff2(struct _IO_FILE *fp, const struct _REPALI *rp, struct _REPSTR *q_namp, const struct _SeqFastq *q_sqp, const char *q_namext, const char *s_nam, const struct _DiffBlocks *dfblkp)
{
  signed int errcode;
  signed int swatscor;
  signed int b;
  signed int blkn;
  blkn=diffBlocksGetNumber(dfblkp);
  unsigned int qs;
  unsigned int qe;
  unsigned int qlen;
  unsigned long int rs;
  unsigned long int re;
  char sensechr;
  unsigned char isReverse;
  _Bool tmp_if_expr$1;
  if(!(rp == ((const struct _REPALI *)NULL)))
    tmp_if_expr$1 = ((signed int)rp->status & 2) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  isReverse = (unsigned char)tmp_if_expr$1;
  errcode=copyReadNameToREPSTR(q_namp, (unsigned char)0, q_sqp);
  _Bool tmp_if_expr$2;
  if(!(errcode == 0))
    return errcode;

  else
  {
    seqFastqGetConstSequence(q_sqp, &qlen, (char *)(void *)0);
    if(!(rp == ((const struct _REPALI *)NULL)))
      tmp_if_expr$2 = ((signed int)rp->status & 1) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(!(isReverse == 0))
      {
        qs = rp->q_end;
        qe = rp->q_start;
        sensechr = (char)45;
      }

      else
      {
        qs = rp->q_start;
        qe = rp->q_end;
        sensechr = (char)43;
      }
      rs = (unsigned long int)rp->s_start;
      re = (unsigned long int)rp->s_end;
      swatscor = rp->swatscor;
    }

    else
    {
      re = (unsigned long int)0;
      rs = re;
      qe = (unsigned int)rs;
      qs = qe;
      sensechr = (char)42;
      s_nam = OUFMT_GFF2_NULLSTR;
      swatscor = 0;
    }
    fprintf(fp, OUFMT_GFF2, q_namp->strp, q_namext, (unsigned int)qs, (unsigned int)qe, swatscor, sensechr, s_nam, (unsigned int)rs, (unsigned int)re);
    b = 0;
    for( ; !(b >= blkn); b = b + 1)
    {
      signed int q0 = 0;
      signed int r0 = 0;
      signed int len;
      len=diffBlocksGetLen(&r0, &q0, b, dfblkp);
      if(!(len >= 1))
        break;

      if(!(isReverse == 0))
        q0 = (signed int)((rp->q_end - rp->q_start) - (unsigned int)q0);

      fprintf(fp, OUFMT_GFF2_ALIBLOCK, q0 + 1, r0 + 1, len);
    }
    if(b == 0)
      fprintf(fp, OUFMT_GFF2_ALIBLOCK, 0, 0, 0);

    fprintf(fp, "\n");
    return errcode;
  }
}

// fprintREPALIsam
// file report.c line 762
static signed int fprintREPALIsam(struct _IO_FILE *fp, struct _SeqFastq *sqbufp, struct _REPSTR *readnamp, signed short int mapscor, const struct _REPALI *rrp, const unsigned char *diffstr, const struct _SeqFastq *q_sqp, const char *refnam, const struct _REPALI *rmp, const char *mate_refnam, signed int isize, unsigned char pairflg, unsigned char oumodiflg, const struct _SeqCodec *codecp)
{
  signed int errcode;
  signed int editdist = 0;
  signed int clip_start = 0;
  signed int clip_end = 0;
  char cod;
  unsigned int qlen;
  unsigned short int samflg = (unsigned short int)0;
  const char *seqstr;
  const char *qualstr;
  const char *ms_nam = mate_refnam;
  const char *s_nam = refnam;
  signed int swatscor;
  unsigned int pos = (unsigned int)0;
  unsigned int mpos = (unsigned int)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(rrp == ((const struct _REPALI *)NULL))
    return 47;

  else
    if(sqbufp == ((struct _SeqFastq *)NULL))
      return 15;

    else
    {
      seqFastqBlank(sqbufp);
      errcode=copyReadNameToREPSTR(readnamp, (unsigned char)1, q_sqp);
      if(!(errcode == 0))
        return errcode;

      else
      {
        seqFastqGetConstSequence(q_sqp, &qlen, &cod);
        if(!((4 & (signed int)rrp->status) == 0))
        {
          samflg = samflg | (unsigned short int)1;
          if(!((8 & (signed int)rrp->status) == 0))
          {
            samflg = samflg | (unsigned short int)128;
            isize = isize * -1;
          }

          else
            samflg = samflg | (unsigned short int)64;
          if(!(rmp == ((const struct _REPALI *)NULL)))
            tmp_if_expr$1 = ((signed int)rmp->status & 1) != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
          {
            mpos = (unsigned int)rmp->s_start;
            if(!((2 & (signed int)rmp->status) == 0))
              samflg = samflg | (unsigned short int)32;

          }

          else
          {
            samflg = samflg | (unsigned short int)8;
            isize = 0;
            mpos = (unsigned int)0;
            ms_nam = OUFMT_SAM_NULLSTR;
          }
        }

        else
          ms_nam = OUFMT_SAM_NULLSTR;
        if(!((1 & (signed int)rrp->status) == 0))
        {
          unsigned char isReverse = (unsigned char)(((signed int)rrp->status & 2) != 0 ? 1 : 0);
          unsigned int qseg_start;
          unsigned int qseg_len;
          if(!((2 & (signed int)oumodiflg) == 0))
          {
            qseg_start = (unsigned int)0;
            qseg_len = qlen;
          }

          else
          {
            qseg_start = rrp->q_start - (unsigned int)1;
            qseg_len = (rrp->q_end - rrp->q_start) + (unsigned int)1;
          }
          errcode=seqFastqAppendSegment(sqbufp, q_sqp, qseg_start, qseg_len, (char)isReverse, isReverse != 0 ? codecp : (const struct _SeqCodec *)(void *)0);
          if(!(errcode == 0))
            return errcode;

          if((signed int)cod == 1)
          {
            errcode=seqFastqDecode(sqbufp, codecp);
            if(!(errcode == 0))
              return errcode;

          }

          seqstr=seqFastqGetConstSequence(sqbufp, (unsigned int *)(void *)0, &cod);
          if(!((signed int)cod == 0))
            return 22;

          qualstr=seqFastqGetConstQualityFactors(sqbufp, (unsigned int *)(void *)0, (char *)(void *)0);
          pos = (unsigned int)rrp->s_start;
          if(!(qlen >= rrp->q_end))
            return 47;

          if(!(isReverse == 0))
          {
            samflg = samflg | (unsigned short int)16;
            clip_start = (signed int)(qlen - rrp->q_end);
            clip_end = (signed int)(rrp->q_start - (unsigned int)1);
          }

          else
          {
            clip_start = (signed int)(rrp->q_start - (unsigned int)1);
            clip_end = (signed int)(qlen - rrp->q_end);
          }
          if(!((4 & (signed int)pairflg) == 0) && !((8 & (signed int)pairflg) == 0))
            samflg = samflg | (unsigned short int)2;

          if(!((32 & (signed int)rrp->status) == 0))
            samflg = samflg | (unsigned short int)256;

          swatscor = rrp->swatscor;
        }

        else
        {
          if(!((2 & (signed int)oumodiflg) == 0))
          {
            errcode=seqFastqAppendSegment(sqbufp, q_sqp, (unsigned int)0, (unsigned int)0, (char)0, (const struct _SeqCodec *)(void *)0);
            if(!(errcode == 0))
              return errcode;

            if((signed int)cod == 1)
            {
              errcode=seqFastqDecode(sqbufp, codecp);
              if(!(errcode == 0))
                return errcode;

            }

            seqstr=seqFastqGetConstSequence(sqbufp, (unsigned int *)(void *)0, &cod);
            if(!((signed int)cod == 0))
              return 22;

            qualstr=seqFastqGetConstQualityFactors(sqbufp, (unsigned int *)(void *)0, (char *)(void *)0);
          }

          else
          {
            seqstr = OUFMT_SAM_NULLSTR;
            qualstr = OUFMT_SAM_NULLSTR;
          }
          samflg = samflg | (unsigned short int)4;
          s_nam = OUFMT_SAM_NULLSTR;
          swatscor = 0;
          isize = 0;
        }
        if(qualstr == ((const char *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = !(qualstr[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          qualstr = OUFMT_SAM_NULLSTR;

        fprintf(fp, OUFMT_SAM_BEFORE, readnamp->strp, samflg, s_nam, pos, mapscor);
        if(!((1 & (signed int)rrp->status) == 0))
        {
          errcode=diffStrPrintf(fp, diffstr, (char)(((signed int)oumodiflg & 8) != 0 ? 4 : 3), clip_start, clip_end, (char)(((signed int)oumodiflg & 2) != 0));
          if(errcode == 0)
            editdist=diffStrGetLevenshteinDistance(diffstr);

        }

        else
          fprintf(fp, OUFMT_SAM_NULLSTR);
        fprintf(fp, OUFMT_SAM_AFTER, ms_nam, mpos, isize, seqstr, qualstr, editdist, swatscor);
        return errcode;
      }
    }
}

// fprintREPALIssaha
// file report.c line 579
static signed int fprintREPALIssaha(struct _IO_FILE *fp, const struct _REPALI *rp, signed short int mapscor, struct _REPSTR *q_namp, const struct _SeqFastq *q_sqp, const char *q_namext, const char *s_nam, unsigned int s_len, const unsigned char *diffstr, unsigned char pairflg)
{
  signed int errcode;
  signed int swatscor;
  unsigned int qs;
  unsigned int qe;
  unsigned int qlen;
  unsigned long int rs;
  unsigned long int re;
  signed int matchlen = 0;
  signed int alilen = 0;
  char sensechr;
  char flagchr;
  double idfrac = .0;
  errcode=copyReadNameToREPSTR(q_namp, (unsigned char)0, q_sqp);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(errcode == 0))
    return errcode;

  else
  {
    seqFastqGetConstSequence(q_sqp, &qlen, (char *)(void *)0);
    if(!(rp == ((const struct _REPALI *)NULL)))
      tmp_if_expr$2 = ((signed int)rp->status & 1) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(!((2 & (signed int)rp->status) == 0))
      {
        qs = rp->q_end;
        qe = rp->q_start;
        sensechr = (char)67;
      }

      else
      {
        qs = rp->q_start;
        qe = rp->q_end;
        sensechr = (char)70;
      }
      rs = (unsigned long int)rp->s_start;
      re = (unsigned long int)rp->s_end;
      swatscor = rp->swatscor;
      flagchr=getMapLabelFromFlag(rp->status, pairflg);
      if(!(diffstr == ((const unsigned char *)NULL)))
      {
        alilen=diffStrCalcAliLen(&matchlen, diffstr);
        idfrac = alilen > 0 ? ((double)100 * (double)matchlen) / (double)alilen : .0;
      }

    }

    else
    {
      re = (unsigned long int)0;
      rs = re;
      qe = (unsigned int)rs;
      qs = qe;
      sensechr = (char)42;
      s_nam = OUFMT_SAM_NULLSTR;
      s_len = (unsigned int)0;
      swatscor = 0;
      mapscor = (signed short int)0;
      if(!(rp == ((const struct _REPALI *)NULL)))
        tmp_if_expr$1 = ((signed int)rp->status & 64) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      flagchr = (char)(tmp_if_expr$1 ? 82 : 78);
      idfrac = .0;
    }
    fprintf(fp, OUFMT_SSAHA, flagchr, (signed int)mapscor > 99 ? 99 : (signed int)mapscor, swatscor, q_namp->strp, q_namext, s_nam, (unsigned int)qs, (unsigned int)qe, (unsigned int)rs, (unsigned int)re, sensechr, matchlen, idfrac, qlen, s_len);
    return errcode;
  }
}

// fprintReadNameAndNumber
// file elib.c line 282
static void fprintReadNameAndNumber(struct _IO_FILE *fp, const char *rnam, unsigned long int rno)
{
  _Bool tmp_if_expr$1;
  if(!(rnam == ((const char *)NULL)))
    tmp_if_expr$1 = rnam[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(rno >= 2ul || tmp_if_expr$1)
  {
    fprintf(fp, "  when processing read");
    if(rno >= 2ul)
      fprintf(fp, " No. %llu", (unsigned long long int)rno);

    if(!(rnam == ((const char *)NULL)))
    {
      if(!(*rnam == 0))
        fprintf(fp, " '%s'", rnam);

    }

    fprintf(fp, "\n");
  }

}

// fprintScoreMatrix
// file score.c line 175
static void fprintScoreMatrix(struct _IO_FILE *fp, const struct _ScoreMatrix *amp, const struct _SeqCodec *scp)
{
  signed short int i;
  signed short int j;
  signed short int alphabetsiz;
  const char *alphabet;
  alphabet=seqCodecGetAlphabet(scp, &alphabetsiz);
  fprintf(fp, "== Alignment matrix ==\n   ");
  j = (signed short int)0;
  for( ; !((signed int)j >= (signed int)alphabetsiz); j = j + 1)
    fprintf(fp, "  %c ", alphabet[(signed long int)j]);
  fprintf(fp, "\n");
  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)alphabetsiz); i = i + 1)
  {
    fprintf(fp, " %c ", alphabet[(signed long int)i]);
    j = (signed short int)0;
    for( ; !((signed int)j >= (signed int)alphabetsiz); j = j + 1)
      fprintf(fp, "%3i ", amp->score[(signed long int)i][(signed long int)j]);
    fprintf(fp, "\n");
  }
  fprintf(fp, "Gap opening score:   %3i\n", amp->gap_init);
  fprintf(fp, "Gap extension score: %3i\n", amp->gap_ext);
  fprintf(fp, "== End of alignment matrix ==\n");
}

// fprintSeqFastqHeader
// file sequence.c line 1631
static signed int fprintSeqFastqHeader(void *top, unsigned char is_gzipped, const struct _SEQSEQ *sp, signed int prompt)
{
  struct gzFile_s *gzfp = is_gzipped != 0 ? (struct gzFile_s *)top : (struct gzFile_s *)(void *)0;
  struct _IO_FILE *fp = is_gzipped != 0 ? (struct _IO_FILE *)(void *)0 : (struct _IO_FILE *)top;
  signed int tmp_if_expr$3;
  signed int return_value_gzputc$1;
  signed int return_value_fputc$2;
  if(!(is_gzipped == 0))
  {
    return_value_gzputc$1=gzputc(gzfp, prompt);
    tmp_if_expr$3 = (signed int)(return_value_gzputc$1 == -1);
  }

  else
  {
    return_value_fputc$2=fputc(prompt, fp);
    tmp_if_expr$3 = (signed int)(return_value_fputc$2 == -1);
  }
  if(!(tmp_if_expr$3 == 0))
    return 11;

  else
  {
    if(!(sp == ((const struct _SEQSEQ *)NULL)))
    {
      if(!((signed int)sp->code == 0))
        return 22;

      if(!(is_gzipped == 0))
        gzputs(gzfp, sp->basep);

      else
        fputs(sp->basep, fp);
    }

    if(!(is_gzipped == 0))
      gzputc(gzfp, 10);

    else
      fputc(10, fp);
    return 0;
  }
}

// fprintSeqFastqSequence
// file sequence.c line 1677
static signed int fprintSeqFastqSequence(void *top, unsigned char is_gzipped, const struct _SEQSEQ *sp, signed short int linewidth)
{
  char buf[81l];
  unsigned long int pos;
  struct gzFile_s *gzfp = (struct gzFile_s *)(is_gzipped != 0 ? top : (void *)0);
  struct _IO_FILE *fp = is_gzipped != 0 ? (struct _IO_FILE *)(void *)0 : (struct _IO_FILE *)top;
  if(!((signed int)sp->code == 0))
    return 22;

  else
  {
    if((signed int)linewidth >= 81)
      linewidth = (signed short int)80;

    if(!((signed int)linewidth >= 1))
    {
      if(!(is_gzipped == 0))
      {
        gzputs(gzfp, sp->basep);
        signed int return_value_gzputc$1;
        return_value_gzputc$1=gzputc(gzfp, 10);
        if(return_value_gzputc$1 == -1)
          return 11;

      }

      else
      {
        fputs(sp->basep, fp);
        signed int return_value_fputc$2;
        return_value_fputc$2=fputc(10, fp);
        if(return_value_fputc$2 == -1)
          return 11;

      }
    }

    else
    {
      pos = (unsigned long int)0;
      for( ; !(pos >= sp->size); pos = pos + (unsigned long int)linewidth)
      {
        strncpy(buf, sp->basep + (signed long int)pos, (unsigned long int)linewidth);
        buf[(signed long int)linewidth] = (char)0;
        if(!(is_gzipped == 0))
        {
          gzputs(gzfp, buf);
          signed int return_value_gzputc$3;
          return_value_gzputc$3=gzputc(gzfp, 10);
          if(return_value_gzputc$3 == -1)
            return 11;

        }

        else
        {
          fputs(buf, fp);
          signed int return_value_fputc$4;
          return_value_fputc$4=fputc(10, fp);
          if(return_value_fputc$4 == -1)
            return 11;

        }
      }
    }
    return 0;
  }
}

// fprintTaskDoc
// file menu.c line 790
static void fprintTaskDoc(struct _IO_FILE *oufp, const struct TASKDOC_ *tdocp, unsigned char isLong)
{
  if(!(tdocp == ((const struct TASKDOC_ *)NULL)))
  {
    if(!(tdocp->synopsis == ((const char *)NULL)))
      fprintf(oufp, "\nSYNOPSIS:\n%s\n", tdocp->synopsis);

    if(!(isLong == 0))
    {
      if(!(tdocp->description == ((const char *)NULL)))
        fprintf(oufp, "\nDESCRIPTION:\n%s\n", tdocp->description);

    }

    if(!(tdocp->optdoc == ((const struct OPTDOC_ *)NULL)))
    {
      const struct OPTDOC_ *odp;
      fprintf(oufp, "\nOPTIONS:\n");
      odp = tdocp->optdoc;
      for( ; !((signed int)odp->ochr == 0); odp = odp + 1l)
      {
        fprintf(oufp, "  -%c", odp->ochr);
        if(!(isLong == 0))
        {
          if(!((signed int)odp->otyp == 0))
            fprintf(oufp, " <%s [%s]>\n", odp->vnam, OPTION_TYPSTR[(signed long int)odp->otyp]);

          fprintf(oufp, "%s\n", odp->ldesc);
        }

        else
          if(!((signed int)odp->otyp == 0))
            fprintf(oufp, " [%s] %s\n", OPTION_TYPSTR[(signed long int)odp->otyp], odp->sdesc);

          else
            fprintf(oufp, "       %s\n", odp->sdesc);
      }
    }

    if(isLong == 0)
      fprintf(oufp, "\n");

  }

}

// fprintfDiffStrPlain
// file diffstr.c line 276
static void fprintfDiffStrPlain(struct _IO_FILE *fp, const unsigned char *dstrp)
{
  const unsigned char *ucp;
  if(!(dstrp == ((const unsigned char *)NULL)))
  {
    ucp = dstrp;
    for( ; !(*ucp == 0); ucp = ucp + 1l)
      fprintf(fp, "%c%i", DIFFSTR_SYMBOLS[(signed long int)((signed int)*ucp >> 6)], (signed short int)((signed int)*ucp & 63));
  }

}

// fprintfDiffStrRaw
// file diffstr.c line 250
static void fprintfDiffStrRaw(struct _IO_FILE *fp, const unsigned char *dstrp)
{
  const unsigned char *ucp;
  fprintf(fp, "(");
  if(!(dstrp == ((const unsigned char *)NULL)))
  {
    ucp = dstrp;
    for( ; !(*ucp == 0); ucp = ucp + 1l)
      fprintf(fp, "%c:%2.2hi|", DIFFSTR_SYMBOLS[(signed long int)((signed int)*ucp >> 6)], (signed short int)((signed int)*ucp & 63));
  }

  fprintf(fp, "M:00)\n");
}

// generateOFFSIVAL
// file resultpairs.c line 445
static signed int generateOFFSIVAL(struct _OFFSIVAL **oivr, signed int d_min, signed int d_max, const struct _ResultSet *rsp)
{
  signed int errcode;
  struct SETUPOFFSIVALARG_ arg;
  resultSetGetNumberOfResultsInSegment(0, rsp);
  ((unsigned long int *)*oivr)[(signed long int)-1] = (unsigned long int)0;
  signed int return_value_resultSetGetNumberOfResultsInSegment$1;
  return_value_resultSetGetNumberOfResultsInSegment$1=resultSetGetNumberOfResultsInSegment(0, rsp);
  if(!(return_value_resultSetGetNumberOfResultsInSegment$1 >= 1))
    return 0;

  else
  {
    arg.dmin = (unsigned int)((unsigned int)(d_min < 0) != 0u ? 0 : d_min);
    arg.dmax = (unsigned int)((unsigned int)(d_max < 0) != 0u ? 0 : d_max);
    if(!(arg.dmax >= arg.dmin))
      return 47;

    else
    {
      arg.oivr = *oivr;
      arg.max_rank = (signed short int)0;
      errcode=resultSetDo((void *)&arg, setupOFFSIVALcbf, rsp);
      if(!(errcode == 0))
        return errcode;

      else
      {
        *oivr = arg.oivr;
        qsort((void *)*oivr, ((unsigned long int *)*oivr)[(signed long int)-1], sizeof(struct _OFFSIVAL) /*32ul*/ , cmpOFFSIVAL);
        return 0;
      }
    }
  }
}

// getFilterIdForRead
// file results.c line 2552
static unsigned int getFilterIdForRead(const struct _ResultFilter *rfp, const struct _SeqFastq *sqp)
{
  unsigned int rlen;
  unsigned int id = (unsigned int)0;
  if(!(rfp == ((const struct _ResultFilter *)NULL)))
  {
    if(rfp->min_identity <= 1.0 && !(sqp == ((const struct _SeqFastq *)NULL)))
    {
      seqFastqGetConstSequence(sqp, &rlen, (char *)(void *)0);
      id = (unsigned int)(rfp->min_identity * (double)rlen);
    }

    else
      id = (unsigned int)rfp->min_identity;
  }

  return id;
}

// getHitInfoMaxRank
// file hashhit.c line 769
static signed int getHitInfoMaxRank(unsigned int *n, unsigned int mincover, unsigned int maxcover, unsigned int maxhit, const struct _HashHitInfo *hip)
{
  signed short int f;
  const unsigned char nskip = hip->nskip;
  const unsigned char ktup = hip->ktup;
  const unsigned long int qmem = (unsigned long int)hip->qlen * sizeof(unsigned char) /*1ul*/ ;
  unsigned char *qbufp = hip->qbufp;
  unsigned int *ixp;
  unsigned int i;
  unsigned int imax;
  unsigned int nmax;
  unsigned int ntot;
  unsigned int cover;
  unsigned int tmp_post$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  unsigned int tmp_if_expr$4;
  if(!(hip->n_seeds >= 1u) || !(maxcover >= mincover))
    return 47;

  else
    if(hip->n_seeds >= 2u)
    {
      if(!((2 & (signed int)hip->status) == 0))
        goto __CPROVER_DUMP_L2;

      return 64;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      f = (signed short int)0;
      for( ; !((signed int)f >= (signed int)nskip); f = f + 1)
        hip->countp[(signed long int)f] = (unsigned int)0;
      i = (unsigned int)0;
      for( ; !(i >= hip->n_seeds); i = i + 1u)
      {
        unsigned int ix = hip->sidxp[(signed long int)i];
        f = (signed short int)((hip->seedp + (signed long int)ix)->qoffs % (unsigned int)nskip);
        tmp_post$1 = hip->countp[(signed long int)f];
        hip->countp[(signed long int)f] = hip->countp[(signed long int)f] + 1u;
        hip->framep[(signed long int)f][(signed long int)tmp_post$1] = i;
      }
      nmax = (unsigned int)0;
      ntot = hip->nhitqual_sortkeyp[(signed long int)0];
      i = (unsigned int)1;
      for( ; hip->n_seeds >= i && maxhit >= ntot; i = i + 1u)
        ntot = ntot + hip->nhitqual_sortkeyp[(signed long int)i];
      nmax = i - (unsigned int)1;
      *n = nmax;
      f = (signed short int)0;
      for( ; !((signed int)f >= (signed int)nskip); f = f + 1)
      {
        imax = hip->countp[(signed long int)f];
        if(!(imax == 0u))
        {
          memset((void *)qbufp, 0, qmem);
          cover = (unsigned int)0;
          ixp = hip->framep[(signed long int)f];
          i = (unsigned int)0;
          do
          {
            if(maxcover >= cover && !(i >= imax))
            {
              if(!(cover >= mincover))
                tmp_if_expr$2 = (_Bool)1;

              else
                tmp_if_expr$2 = ixp[(signed long int)i] <= *n ? (_Bool)1 : (_Bool)0;
              tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$3 = (_Bool)0;
            if(!tmp_if_expr$3)
              break;

            unsigned int getHitInfoMaxRank$$1$$4$$1$$1$$1$$ix = hip->sidxp[(signed long int)ixp[(signed long int)i]];
            const struct _SEED *sp = hip->seedp + (signed long int)getHitInfoMaxRank$$1$$4$$1$$1$$1$$ix;
            unsigned int q = sp->qoffs;
            for( ; !(q >= sp->qoffs + (unsigned int)ktup + 4294967295u); q = q + 1u)
              if(qbufp[(signed long int)q] == 0)
              {
                qbufp[(signed long int)q] = (unsigned char)1;
                cover = cover + 1u;
              }

            i = i + 1u;
          }
          while((_Bool)1);
          if(i >= 1u)
          {
            if(!(nmax >= ixp[(signed long int)(i + 4294967295u)]))
              nmax = ixp[(signed long int)(i - (unsigned int)1)];

          }

        }

      }
      if(!(nmax >= 3u))
      {
        if(hip->n_seeds >= 4u)
          tmp_if_expr$4 = (unsigned int)3;

        else
          tmp_if_expr$4 = hip->n_seeds;
        *n = tmp_if_expr$4;
      }

      else
        *n = nmax;
      return 0;
    }
}

// getMATEPAIRcbf_InnerLoop
// file resultpairs.c line 365
static signed int getMATEPAIRcbf_InnerLoop(signed int *errcode, void *argp, const struct _RESULT *rp)
{
  struct GETMATEPAIRARG_ *p = (struct GETMATEPAIRARG_ *)argp;
  struct _ResultPairs *pairp = p->pairp;
  struct _MATEPAIR *mp;
  signed short int return_value_resultGetSWRank$1;
  return_value_resultGetSWRank$1=resultGetSWRank(rp);
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$4;
  if(!((signed int)p->max_rankB >= (signed int)return_value_resultGetSWRank$1))
    return 1;

  else
  {
    if(((unsigned long int *)pairp->mpr)[-1l] >= ((unsigned long int *)pairp->mpr)[-2l])
    {
      void *return_value_arrayRealloc$2;
      return_value_arrayRealloc$2=arrayRealloc((void *)pairp->mpr, (unsigned long int)0, (char)0, "resultpairs.c", 374);
      mp = (struct _MATEPAIR *)return_value_arrayRealloc$2;
      if(!(mp == ((struct _MATEPAIR *)NULL)))
      {
        pairp->mpr = mp;
        tmp_post$3 = ((unsigned long int *)pairp->mpr)[(signed long int)-1];
        ((unsigned long int *)pairp->mpr)[(signed long int)-1] = ((unsigned long int *)pairp->mpr)[(signed long int)-1] + 1ul;
        mp = pairp->mpr + (signed long int)tmp_post$3;
      }

    }

    else
    {
      tmp_post$4 = ((unsigned long int *)pairp->mpr)[(signed long int)-1];
      ((unsigned long int *)pairp->mpr)[(signed long int)-1] = ((unsigned long int *)pairp->mpr)[(signed long int)-1] + 1ul;
      mp = pairp->mpr + (signed long int)tmp_post$4;
    }
    if(mp == ((struct _MATEPAIR *)NULL))
    {
      *errcode = 2;
      return 2;
    }

    else
    {
      mp->ap = p->ap;
      mp->bp = rp;
      mp->flag = (unsigned char)0;
      mp->ins = 0;
      mp->mapflg = (unsigned char)1;
      mp->mscor = 0;
      mp->flag=resultCalcInsertSize(&mp->ins, (unsigned char)1, mp->ap, mp->bp);
      if(!((4 & (signed int)mp->flag) == 0))
      {
        unsigned char return_value_testProperPair$5;
        return_value_testProperPair$5=testProperPair(mp->ins, mp->flag, pairp->dmin, pairp->dmax, p->pairlibcode);
        mp->mapflg = (unsigned char)((signed int)mp->mapflg | (signed int)return_value_testProperPair$5);
        if(!((8 & (signed int)mp->mapflg) == 0))
        {
          pairp->n_within = pairp->n_within + 1;
          if(!((4 & (signed int)mp->mapflg) == 0))
            pairp->n_proper = pairp->n_proper + 1;

        }

        mp->mapflg = mp->mapflg | (unsigned char)2;
      }

      if(((unsigned long int *)pairp->mpr)[-1l] >= 8192ul)
      {
        pairp->status = pairp->status | (unsigned char)8;
        return 2;
      }

      else
        return 0;
    }
  }
}

// getMATEPAIRcbf_OuterLoop
// file resultpairs.c line 407
static signed int getMATEPAIRcbf_OuterLoop(signed int *errcode, void *argp, const struct _RESULT *rp)
{
  struct GETMATEPAIRARG_ *p = (struct GETMATEPAIRARG_ *)argp;
  signed short int return_value_resultGetSWRank$1;
  return_value_resultGetSWRank$1=resultGetSWRank(rp);
  if(!((signed int)p->max_rankA >= (signed int)return_value_resultGetSWRank$1))
    return 1;

  else
  {
    p->ap = rp;
    *errcode=resultSetDo(argp, getMATEPAIRcbf_InnerLoop, p->rsltBp);
    return *errcode != 0 ? 2 : 0;
  }
}

// getMapLabelFromFlag
// file report.c line 217
static char getMapLabelFromFlag(unsigned char mateflg, unsigned char pairflg)
{
  char flagchr;
  if(!((1 & (signed int)mateflg) == 0))
  {
    if(!((32 & (signed int)mateflg) == 0))
      flagchr = (char)80;

    else
      if(!((1 & (signed int)pairflg) == 0))
      {
        if(!((2 & (signed int)pairflg) == 0))
        {
          if(!((4 & (signed int)pairflg) == 0))
            flagchr = (char)(((signed int)pairflg & 8) != 0 ? 65 : 66);

          else
            flagchr = (char)67;
        }

        else
          flagchr = (char)68;
      }

      else
        flagchr = (char)83;
  }

  else
    if(!((64 & (signed int)mateflg) == 0))
      flagchr = (char)82;

    else
      flagchr = (char)78;
  return flagchr;
}

// getNumberOfTopSwatRESULTs
// file results.c line 839
static unsigned char getNumberOfTopSwatRESULTs(signed short int *n_best, struct _RESULT **rspp)
{
  unsigned char rv;
  signed short int nb;
  signed short int n = (signed short int)((unsigned long int *)rspp)[(signed long int)-1];
  nb = n;
  _Bool tmp_if_expr$1;
  if(!((signed int)n >= 2))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = rspp[(signed long int)1]->swatscor != rspp[(signed long int)0]->swatscor ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    rv = (unsigned char)1;

  else
    rv = (unsigned char)0;
  if((signed int)n >= 3)
  {
    signed int scorthresh = rspp[(signed long int)1]->swatscor;
    signed short int i = (signed short int)2;
    for( ; !((signed int)i >= (signed int)n); i = i + 1)
      if(!(rspp[(signed long int)i]->swatscor == scorthresh))
        break;

    nb = i;
  }

  if(!(n_best == ((signed short int *)NULL)))
    *n_best = nb;

  return rv;
}

// getProperMATEPAIRcbf
// file resultpairs.c line 265
static signed int getProperMATEPAIRcbf(signed int *errcode, void *argp, const struct _RESULT *rp)
{
  unsigned int s_start;
  unsigned int s_end;
  unsigned int q_start;
  unsigned int q_end;
  signed long int sidx;
  signed int nival;
  signed int swscor;
  unsigned short int status;
  struct GETPROPERMATEPAIRARG_ *p = (struct GETPROPERMATEPAIRARG_ *)argp;
  struct _ResultPairs * const pairp = p->pairp;
  signed short int return_value_resultGetSWRank$1;
  return_value_resultGetSWRank$1=resultGetSWRank(rp);
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$4;
  signed int tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(!((signed int)p->max_rank >= (signed int)return_value_resultGetSWRank$1))
    return 1;

  else
  {
    *errcode=resultGetData(&q_start, &q_end, &s_start, &s_end, &sidx, &swscor, &status, rp);
    if(!(*errcode == 0))
      return 2;

    else
      if(!(swscor >= p->swscor_min))
        return 1;

      else
      {
        nival = (signed int)((unsigned long int *)p->oivr)[(signed long int)-1];
        if(nival >= 32768)
        {
          *errcode = 47;
          return 2;
        }

        else
        {
          if((signed int)p->ivalx >= nival)
            p->ivalx = (signed short int)0;

          for( ; !((signed int)p->ivalx >= nival); p->ivalx = p->ivalx + 1)
          {
            signed int isiz;
            unsigned int r0;
            struct _MATEPAIR *mp;
            const struct _OFFSIVAL *ivp = p->oivr + (signed long int)p->ivalx;
            if(!(sidx >= ivp->sidx))
              break;

            if(ivp->sidx >= sidx)
            {
              if(!((4 & (signed int)status) == 0))
              {
                if(!((4 & (signed int)ivp->status) == 0))
                  goto __CPROVER_DUMP_L25;

                r0 = (s_end + q_start) - (unsigned int)2;
              }

              else
              {
                if((4 & (signed int)ivp->status) == 0)
                  goto __CPROVER_DUMP_L25;

                r0 = s_start - q_start;
              }
              if(ivp->upper >= r0)
              {
                if(!(r0 >= ivp->lower))
                  break;

                if(ivp->rp == ((const struct _RESULT *)NULL))
                {
                  *errcode = 47;
                  return 2;
                }

                if(((unsigned long int *)pairp->mpr)[-1l] >= ((unsigned long int *)pairp->mpr)[-2l])
                {
                  void *return_value_arrayRealloc$2;
                  return_value_arrayRealloc$2=arrayRealloc((void *)pairp->mpr, (unsigned long int)0, (char)0, "resultpairs.c", 329);
                  mp = (struct _MATEPAIR *)return_value_arrayRealloc$2;
                  if(!(mp == ((struct _MATEPAIR *)NULL)))
                  {
                    pairp->mpr = mp;
                    tmp_post$3 = ((unsigned long int *)pairp->mpr)[(signed long int)-1];
                    ((unsigned long int *)pairp->mpr)[(signed long int)-1] = ((unsigned long int *)pairp->mpr)[(signed long int)-1] + 1ul;
                    mp = pairp->mpr + (signed long int)tmp_post$3;
                  }

                }

                else
                {
                  tmp_post$4 = ((unsigned long int *)pairp->mpr)[(signed long int)-1];
                  ((unsigned long int *)pairp->mpr)[(signed long int)-1] = ((unsigned long int *)pairp->mpr)[(signed long int)-1] + 1ul;
                  mp = pairp->mpr + (signed long int)tmp_post$4;
                }
                if(mp == ((struct _MATEPAIR *)NULL))
                {
                  *errcode = 2;
                  return 2;
                }

                memset((void *)mp, 0, sizeof(struct _MATEPAIR) /*48ul*/ );
                mp->ap = ivp->rp;
                mp->bp = rp;
                mp->flag=resultCalcInsertSize(&mp->ins, (unsigned char)1, ivp->rp, rp);
                mp->mapflg=testProperPair(mp->ins, mp->flag, pairp->dmin, pairp->dmax, p->pairlibcode);
                mp->mapflg = mp->mapflg | (unsigned char)(1 | 2);
                mp->mscor = 0;
                if(!(mp->ins >= 0))
                  tmp_if_expr$5 = -1 * mp->ins;

                else
                  tmp_if_expr$5 = mp->ins;
                isiz = tmp_if_expr$5;
                if(!(isiz >= pairp->dmin))
                  tmp_if_expr$6 = (_Bool)1;

                else
                  tmp_if_expr$6 = isiz > pairp->dmax ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$6)
                  ((unsigned long int *)pairp->mpr)[(signed long int)-1] = ((unsigned long int *)pairp->mpr)[(signed long int)-1] - 1ul;

                if(((unsigned long int *)pairp->mpr)[-1l] >= (unsigned long int)p->maxnum)
                {
                  *errcode = 74;
                  return 2;
                }

              }

            }


          __CPROVER_DUMP_L25:
            ;
          }
          return 0;
        }
      }
  }
}

// getSAMPLEQuartiles
// file insert.c line 148
static signed int getSAMPLEQuartiles(signed int *med, signed int *qlo, signed int *qhi, struct V_int32_t_ *pSample)
{
  signed int errcode;
  errcode=sort_int32_t_quicksort(pSample);
  if(!(errcode == 0))
  {
    if(!(med == ((signed int *)NULL)))
      *med = 0;

    if(!(qlo == ((signed int *)NULL)))
      *qlo = 0;

    if(!(qhi == ((signed int *)NULL)))
      *qhi = 0;

  }

  else
  {
    if(!(med == ((signed int *)NULL)))
      *med = pSample->vp[(signed long int)(unsigned long int)((double)pSample->n * .5)];

    if(!(qlo == ((signed int *)NULL)))
      *qlo = pSample->vp[(signed long int)(unsigned long int)((double)pSample->n * .25)];

    if(!(qhi == ((signed int *)NULL)))
      *qhi = pSample->vp[(signed long int)(unsigned long int)((double)pSample->n * .75)];

  }
  return errcode;
}

// hash32mix
// file hashidx.c line 163
static unsigned int hash32mix(unsigned int a)
{
  a = a + (unsigned int)0x7ed55d16 + (a << 12);
  a = a ^ 0xc761c23c ^ a >> 19;
  a = a + (unsigned int)0x165667b1 + (a << 5);
  a = a + 0xd3a2646c ^ a << 9;
  a = a + 0xfd7046c5 + (a << 3);
  a = a ^ 0xb55a4f09 ^ a >> 16;
  return a;
}

// hashAddToHitFilter
// file hashhit.c line 1974
signed int hashAddToHitFilter(struct _HashHitFilter *hhfp, unsigned int lo, unsigned int hi)
{
  signed int errcode;
  struct _FILTERIVAL *hp;
  signed short int tmp_post$1;
  if((signed int)hhfp->num >= (signed int)hhfp->n_alloc)
  {
    errcode=reallocHitFilter(hhfp, (signed short int)((signed int)hhfp->num + 1));
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tmp_post$1 = hhfp->num;
    hhfp->num = hhfp->num + 1;
    hp = hhfp->ivp + (signed long int)tmp_post$1;
    hp->upper = hi;
    hp->lower = lo;
    return 0;
  }
}

// hashBlankHitList
// file hashhit.h line 179
void hashBlankHitList(struct _HashHitList *hlp)
{
  blankHitList(hlp);
}

// hashCalcHitInfoCoverDeficit
// file hashhit.c line 1096
unsigned int hashCalcHitInfoCoverDeficit(const struct _HashHitInfo *hip)
{
  unsigned char s;
  const unsigned char nskip = hip->nskip;
  unsigned int i;
  unsigned int deficit;
  unsigned int d;
  const unsigned char * const qmaskp = hip->qmaskp;
  const unsigned char ktup = hip->ktup;
  _Bool tmp_if_expr$1;
  if(!((4 & (signed int)hip->status) == 0))
  {
    unsigned int cover;
    unsigned int maxcover = (unsigned int)0;
    unsigned int *ixp;
    unsigned int ix;
    unsigned int imax;
    unsigned int q;
    unsigned char *qbufp = hip->qbufp;
    const unsigned long int qmem = (unsigned long int)hip->qlen * sizeof(unsigned char) /*1ul*/ ;
    const struct _SEED *sp;
    d = hip->qlen;
    s = (unsigned char)0;
    for( ; !((signed int)s >= (signed int)nskip); s = s + 1)
    {
      imax = hip->countp[(signed long int)s];
      if(!(imax == 0u))
      {
        memset((void *)qbufp, 0, qmem);
        cover = (unsigned int)0;
        ixp = hip->framep[(signed long int)s];
        i = (unsigned int)0;
        do
        {
          if(!(i >= imax))
            tmp_if_expr$1 = ixp[(signed long int)i] < hip->seed_rank ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          ix = hip->sidxp[(signed long int)ixp[(signed long int)i]];
          sp = hip->seedp + (signed long int)ix;
          q = sp->qoffs;
          for( ; !(q >= sp->qoffs + (unsigned int)ktup); q = q + 1u)
            if(qbufp[(signed long int)q] == 0)
            {
              qbufp[(signed long int)q] = (unsigned char)1;
              cover = cover + 1u;
            }

          i = i + 1u;
        }
        while((_Bool)1);
        if(!(cover >= d))
          d = cover;

        if(!(maxcover >= cover))
          maxcover = cover;

      }

    }
    deficit = (maxcover - d) + (unsigned int)1;
  }

  else
  {
    unsigned char ctr;
    unsigned char k = (unsigned char)((signed int)hip->ktup / (signed int)nskip);
    if((signed int)k >= 1)
      k = k - 1;

    deficit = (unsigned int)0;
    s = (unsigned char)0;
    for( ; !((signed int)s >= (signed int)nskip); s = s + 1)
    {
      d = (unsigned int)0;
      ctr = (unsigned char)0;
      i = (unsigned int)s;
      for( ; !(i >= hip->qlen); i = i + (unsigned int)nskip)
        if((signed int)qmaskp[(signed long int)i] == 1)
          ctr = k;

        else
          if(!(ctr == 0))
            ctr = ctr - 1;

          else
            d = d + (unsigned int)nskip;
      if(!(deficit >= d))
        deficit = d;

    }
  }
  return deficit;
}

// hashCalcHitInfoNumberOfHits
// file hashhit.h line 150
unsigned int hashCalcHitInfoNumberOfHits(const struct _HashHitInfo *hhip, unsigned int maxhit_per_tuple)
{
  unsigned int i;
  unsigned int nhit;
  unsigned int hnum = (unsigned int)0;
  unsigned int hcutoff = maxhit_per_tuple < (unsigned int)1 ? (unsigned int)0 : maxhit_per_tuple;
  if(!(hcutoff == 0u))
  {
    i = (unsigned int)0;
    for( ; !(i >= hhip->n_seeds); i = i + 1u)
    {
      nhit = hhip->nhitqual_sortkeyp[(signed long int)i];
      if(hcutoff >= nhit)
        hnum = hnum + nhit;

    }
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= hhip->n_seeds); i = i + 1u)
      hnum = hnum + hhip->nhitqual_sortkeyp[(signed long int)i];
  }
  return hnum;
}

// hashCalcHitListCoverDeficit
// file hashhit.c line 1883
unsigned int hashCalcHitListCoverDeficit(const struct _HashHitList *hlp)
{
  unsigned int i;
  unsigned int d;
  unsigned int deficit;
  unsigned char s;
  unsigned char ctr;
  unsigned char nskip = hlp->nskip;
  unsigned char k = (unsigned char)((signed int)hlp->ktup / (signed int)nskip);
  const char *qmaskp = hlp->qmask;
  if((signed int)k >= 1)
    k = k - 1;

  deficit = (unsigned int)0;
  s = (unsigned char)0;
  for( ; !((signed int)s >= (signed int)nskip); s = s + 1)
  {
    d = (unsigned int)0;
    ctr = (unsigned char)0;
    i = (unsigned int)s;
    for( ; !(i >= hlp->qlen); i = i + (unsigned int)nskip)
      if((signed int)qmaskp[(signed long int)i] == 1)
        ctr = k;

      else
        if(!(ctr == 0))
          ctr = ctr - 1;

        else
          d = d + (unsigned int)nskip;
    if(!(deficit >= d))
      deficit = d;

  }
  return deficit;
}

// hashCheckHitList
// file hashhit.c line 1790
signed int hashCheckHitList(const struct _HashHitList *hlp, const struct _SeqFastq *seqp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codep)
{
  char code;
  unsigned char k;
  unsigned char ktup;
  unsigned char nskip;
  const char *query_datap;
  const char *qdp;
  const char *sdp;
  unsigned int querylen;
  unsigned int qoffs;
  unsigned long int soffs;
  unsigned long int soffs_end;
  unsigned long int sqdat;
  signed int j;
  signed int errcode;
  struct _SeqFastq *ucp = (struct _SeqFastq *)(void *)0;
  const char *tmp_post$1;
  const char *tmp_post$2;
  const char *tmp_post$3;
  const char *tmp_post$4;
  if((2 & (signed int)hlp->status) == 0)
    return 35;

  else
  {
    ucp=seqFastqCreate(0, (char)1);
    if(ucp == ((struct _SeqFastq *)NULL))
      return 2;

    else
    {
      ktup=hashTableGetKtupLen(htp, &nskip);
      if((unsigned int)ktup >= hlp->qlen)
        return 47;

      else
      {
        query_datap=seqFastqGetConstSequence(seqp, &querylen, &code);
        if(!(querylen == hlp->qlen))
          return 47;

        else
          if(!((signed int)code == 1))
            return 22;

          else
          {
            j = 0;
            for( ; !(j >= hlp->nhits); j = j + 1)
            {
              sqdat = hlp->sqdat[(signed long int)j];
              qoffs = (unsigned int)(sqdat & (unsigned long int)2147483647);
              if(!((1 & (signed int)hlp->status) == 0))
                soffs = (sqdat >> 31) - (unsigned long int)(qoffs / (unsigned int)nskip);

              else
                soffs = (sqdat >> 31) + (unsigned long int)(qoffs / (unsigned int)nskip) & (unsigned long int)-1;
              soffs = soffs * (unsigned long int)nskip;
              if(qoffs >= querylen)
              {
                printf("Wrong base offsets. qoffs %u , soffs %llu\n", qoffs, (unsigned long long int)soffs);
                return -1;
              }

              soffs_end = (soffs + (unsigned long int)ktup) - (unsigned long int)1;
              errcode=seqSetFetchSegment(ucp, &soffs, &soffs_end, ssp, codep);
              if(!(errcode == 0))
                return errcode;

              sdp=seqFastqGetConstSequence(ucp, (unsigned int *)(void *)0, &code);
              if((signed int)code == 0)
              {
                errcode=seqFastqEncode(ucp, codep);
                if(!(errcode == 0))
                  return errcode;

                sdp=seqFastqGetConstSequence(ucp, (unsigned int *)(void *)0, &code);
              }

              if(!((signed int)code == 1))
                return 22;

              if(!((1 & (signed int)hlp->status) == 0))
              {
                qdp = (query_datap + (signed long int)qoffs + (signed long int)ktup) - (signed long int)1;
                k = (unsigned char)0;
                for( ; !((signed int)k >= (signed int)ktup); k = k + 1)
                {
                  tmp_post$1 = qdp;
                  qdp = qdp - 1l;
                  tmp_post$2 = sdp;
                  sdp = sdp + 1l;
                  if(!((3 & (signed int)*tmp_post$1) == ((3 ^ (signed int)*tmp_post$2) & 3)))
                    return -1;

                }
              }

              else
              {
                qdp = query_datap + (signed long int)qoffs;
                k = (unsigned char)0;
                for( ; !((signed int)k >= (signed int)ktup); k = k + 1)
                {
                  tmp_post$3 = qdp;
                  qdp = qdp + 1l;
                  tmp_post$4 = sdp;
                  sdp = sdp + 1l;
                  if(!((3 & (signed int)*tmp_post$3) == (3 & (signed int)*tmp_post$4)))
                    return -1;

                }
              }
            }
            seqFastqDelete(ucp);
            return 0;
          }
      }
    }
  }
}

// hashCollectHitInfo
// file hashhit.h line 98
signed int hashCollectHitInfo(struct _HashHitInfo *hhip, unsigned char is_reverse, unsigned char basq_thresh, unsigned int seq_start, unsigned int seq_end, const struct _SeqFastq *seqp, const struct _HashTable *htp)
{
  signed int errcode;
  errcode=collectHitInfo(hhip, is_reverse, (unsigned int)0, basq_thresh, seq_start, seq_end, seqp, htp);
  hhip->seed_rank = (unsigned int)0;
  return errcode;
}

// hashCollectHitInfoShort
// file hashhit.h line 119
signed int hashCollectHitInfoShort(struct _HashHitInfo *hhip, unsigned char is_reverse, unsigned int maxhit_per_tuple, unsigned int maxhit_total, unsigned char basq_thresh, const struct _SeqFastq *seqp, const struct _HashTable *htp)
{
  signed int errcode;
  unsigned int slen;
  unsigned int mincover;
  unsigned int maxcover;
  errcode=collectHitInfo(hhip, is_reverse, maxhit_per_tuple, basq_thresh, (unsigned int)0, (unsigned int)0, seqp, htp);
  if(!(errcode == 0))
    return errcode;

  else
    if(!(hhip->n_seeds >= 2u))
    {
      hhip->status = hhip->status | (unsigned char)2;
      hhip->seed_rank = hhip->n_seeds;
      return 0;
    }

    else
    {
      errcode=sort2UINTarraysByQuickSort((signed int)hhip->n_seeds, hhip->nhitqual_sortkeyp, hhip->sidxp);
      if(!(errcode == 0))
        return errcode;

      else
      {
        hhip->status = hhip->status | (unsigned char)2;
        hhip->seed_rank = (unsigned int)0;
        seqFastqGetConstSequence(seqp, &slen, (char *)(void *)0);
        mincover = (unsigned int)(2 * (signed int)hhip->ktup + (signed int)hhip->nskip);
        maxcover = (slen * (unsigned int)80) / (unsigned int)100;
        if(!(maxcover >= (unsigned int)(signed int)hhip->ktup + (unsigned int)(signed int)hhip->nskip))
          maxcover = (unsigned int)((signed int)hhip->ktup + (signed int)hhip->nskip);

        else
          if(!(slen + -((unsigned int)hhip->nskip) >= maxcover))
            maxcover = slen - (unsigned int)hhip->nskip;

        if(!(maxcover >= mincover))
        {
          mincover = (unsigned int)0;
          maxcover = slen;
        }

        errcode=getHitInfoMaxRank(&hhip->seed_rank, mincover, maxcover, maxhit_total, hhip);
        if(!(errcode == 0))
          return errcode;

        else
        {
          hhip->status = hhip->status | (unsigned char)4;
          return 0;
        }
      }
    }
}

// hashCollectHitsForSegment
// file hashhit.h line 206
signed int hashCollectHitsForSegment(struct _HashHitList *hlp, unsigned long int segmoffs_lo, unsigned long int segmoffs_hi, unsigned int nhit_max, unsigned char use_short_hitinfo, const struct _HashHitInfo *hhip, const struct _HashTable *htp, const struct _HashHitFilter *hhfp)
{
  signed int errcode = 0;
  unsigned char nskip;
  hashTableGetKtupLen(htp, &nskip);
  segmoffs_lo = segmoffs_lo / (unsigned long int)nskip;
  segmoffs_hi = segmoffs_hi / (unsigned long int)nskip;
  do
  {
    errcode=fillHitListFromHitInfoSegment(hlp, (unsigned int)segmoffs_lo, (unsigned int)segmoffs_hi, nhit_max, use_short_hitinfo, hhip, htp, hhfp);
    nhit_max = nhit_max / (unsigned int)2;
  }
  while(errcode == 32 && nhit_max >= 17u);
  if(!(errcode == 0) && !(errcode == 32))
    return errcode;

  else
  {
    errcode=sortUINT64arrayByQuickSort(hlp->nhits, hlp->sqdat);
    if(errcode == 0)
      hlp->status = hlp->status | (unsigned char)2;

    return errcode;
  }
}

// hashCollectHitsUsingCutoff
// file hashhit.h line 249
signed int hashCollectHitsUsingCutoff(struct _HashHitList *hlp, unsigned int max_nhit_per_tup, const struct _HashTable *htp, const struct _HashHitInfo *hip)
{
  signed int errcode;
  unsigned int j;
  unsigned int nhits;
  unsigned char reached_ceiling = (unsigned char)0;
  unsigned int *posp;
  unsigned int nh;
  unsigned int i;
  unsigned int q;
  unsigned int qo;
  unsigned int n_seeds;
  unsigned int tmp_if_expr$1;
  if(!(hip->seed_rank == 0u))
    tmp_if_expr$1 = hip->seed_rank;

  else
    tmp_if_expr$1 = hip->n_seeds;
  n_seeds = tmp_if_expr$1;
  const unsigned long int offbit = (unsigned long int)1 << 31 + 1;
  unsigned long int *dp;
  const struct _SEED *sp;
  errcode=initHitList(hlp, hip);
  if(!(errcode == 0))
    return errcode;

  else
  {
    do
    {
      reached_ceiling = (unsigned char)0;
      blankHitList(hlp);
      if(!((1 & (signed int)hip->status) == 0))
        hlp->status = hlp->status | (unsigned char)1;

      i = (unsigned int)0;
      for( ; !(i >= n_seeds); i = i + 1u)
      {
        nh = hip->nhitqual_sortkeyp[(signed long int)i];
        if(nh >= 1u)
        {
          sp = hip->seedp + (signed long int)hip->sidxp[(signed long int)i];
          q = sp->qoffs;
          if(max_nhit_per_tup >= 1u && !(max_nhit_per_tup >= nh))
            hlp->qmask[(signed long int)q] = (char)2;

          else
          {
            if(nh + (unsigned int)hlp->nhits >= 2147483648u)
              return 48;

            if(!(hlp->nhits_max >= (signed int)nh + (signed int)(unsigned int)hlp->nhits))
            {
              reached_ceiling = (unsigned char)1;
              break;
            }

            nhits=hashTableFetchHitPositions(&posp, htp, sp->posidx);
            if(!(nh == nhits))
              return 47;

            hlp->qmask[(signed long int)q] = (char)1;
            qo = q / (unsigned int)hlp->nskip;
            dp = hlp->sqdat + (signed long int)hlp->nhits;
            if(!((1 & (signed int)hlp->status) == 0))
            {
              j = (unsigned int)0;
              for( ; !(j >= nhits); j = j + 1u)
                dp[(signed long int)j] = ((unsigned long int)posp[(signed long int)j] + (unsigned long int)qo << 31) + (unsigned long int)q;
            }

            else
            {
              j = (unsigned int)0;
              for( ; !(j >= nhits); j = j + 1u)
                dp[(signed long int)j] = (((unsigned long int)posp[(signed long int)j] | offbit) - (unsigned long int)qo << 31) + (unsigned long int)q;
            }
            hlp->nhits = hlp->nhits + (signed int)nhits;
          }
        }

      }
      max_nhit_per_tup = max_nhit_per_tup / (unsigned int)2;
    }
    while(max_nhit_per_tup >= 17u && !(reached_ceiling == 0));
    errcode=sortUINT64arrayByQuickSort(hlp->nhits, hlp->sqdat);
    if(errcode == 0)
      hlp->status = hlp->status | (unsigned char)2;

    return errcode;
  }
}

// hashCreateHitFilter
// file hashhit.c line 1942
struct _HashHitFilter * hashCreateHitFilter(signed short int blocksiz)
{
  struct _HashHitFilter *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _HashHitFilter) /*16ul*/ , "hashhit.c", 1945);
  p = (struct _HashHitFilter *)return_value_ecalloc$1;
  if(p == ((struct _HashHitFilter *)NULL))
    return ((struct _HashHitFilter *)NULL);

  else
  {
    if(!((signed int)blocksiz >= 1))
      blocksiz = (signed short int)1024;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blocksiz, sizeof(struct _FILTERIVAL) /*8ul*/ , "hashhit.c", 1949);
    p->ivp = (struct _FILTERIVAL *)return_value_ecalloc$2;
    if(p->ivp == ((struct _FILTERIVAL *)NULL))
    {
      hashDeleteHitFilter(p);
      p = ((struct _HashHitFilter *)NULL);
    }

    else
    {
      p->n_alloc = blocksiz;
      p->blocksiz = blocksiz;
    }
    return p;
  }
}

// hashCreateHitInfo
// file hashhit.h line 90
struct _HashHitInfo * hashCreateHitInfo(signed int blksz, const struct _HashTable *htp)
{
  unsigned char o;
  struct _HashHitInfo *p;
  unsigned int *sp;
  signed int dblk;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _HashHitInfo) /*104ul*/ , "hashhit.c", 906);
  p = (struct _HashHitInfo *)return_value_ecalloc$1;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  if(p == ((struct _HashHitInfo *)NULL))
    return ((struct _HashHitInfo *)NULL);

  else
  {
    if(!(blksz >= 1))
      blksz = 512;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blksz, sizeof(unsigned char) /*1ul*/ , "hashhit.c", 910);
    p->qmaskp = (unsigned char *)return_value_ecalloc$2;
    void *return_value_ecalloc$3;
    return_value_ecalloc$3=ecalloc((unsigned long int)blksz, sizeof(unsigned char) /*1ul*/ , "hashhit.c", 911);
    p->qbufp = (unsigned char *)return_value_ecalloc$3;
    void *return_value_ecalloc$4;
    return_value_ecalloc$4=ecalloc((unsigned long int)blksz, sizeof(unsigned int) /*4ul*/ , "hashhit.c", 912);
    p->sidxp = (unsigned int *)return_value_ecalloc$4;
    void *return_value_ecalloc$5;
    return_value_ecalloc$5=ecalloc((unsigned long int)blksz, sizeof(unsigned int) /*4ul*/ , "hashhit.c", 913);
    p->nhitqual_sortkeyp = (unsigned int *)return_value_ecalloc$5;
    void *return_value_ecalloc$6;
    return_value_ecalloc$6=ecalloc((unsigned long int)blksz, sizeof(struct _SEED) /*16ul*/ , "hashhit.c", 914);
    p->seedp = (struct _SEED *)return_value_ecalloc$6;
    if(!(p->qmaskp == ((unsigned char *)NULL)))
      tmp_if_expr$7 = p->qbufp != ((unsigned char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = p->sidxp != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = p->nhitqual_sortkeyp != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = p->seedp != ((struct _SEED *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(!tmp_if_expr$10)
    {
      hashDeleteHitInfo(p);
      return ((struct _HashHitInfo *)NULL);
    }

    else
    {
      p->blksz = blksz;
      p->n_alloc = (unsigned long int)blksz;
      p->ktup=hashTableGetKtupLen(htp, &p->nskip);
      void *return_value_ecalloc$11;
      return_value_ecalloc$11=ecalloc((unsigned long int)p->nskip, sizeof(unsigned int) /*4ul*/ , "hashhit.c", 945);
      p->coverp = (unsigned int *)return_value_ecalloc$11;
      void *return_value_ecalloc$12;
      return_value_ecalloc$12=ecalloc((unsigned long int)p->nskip, sizeof(unsigned int *) /*8ul*/ , "hashhit.c", 946);
      p->framep = (unsigned int **)return_value_ecalloc$12;
      void *return_value_ecalloc$13;
      return_value_ecalloc$13=ecalloc((unsigned long int)p->nskip, sizeof(unsigned int) /*4ul*/ , "hashhit.c", 947);
      p->countp = (unsigned int *)return_value_ecalloc$13;
      void *return_value_ecalloc$14;
      return_value_ecalloc$14=ecalloc((unsigned long int)(blksz + (signed int)p->nskip), sizeof(unsigned int) /*4ul*/ , "hashhit.c", 948);
      sp = (unsigned int *)return_value_ecalloc$14;
      if(!(p->coverp == ((unsigned int *)NULL)))
        tmp_if_expr$15 = p->framep != ((unsigned int **)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$15 = (_Bool)0;
      if(tmp_if_expr$15)
        tmp_if_expr$16 = p->countp != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$16 = (_Bool)0;
      if(sp == ((unsigned int *)NULL) || !tmp_if_expr$16)
      {
        hashDeleteHitInfo(p);
        return ((struct _HashHitInfo *)NULL);
      }

      else
      {
        p->framep[(signed long int)0] = sp;
        dblk = blksz / (signed int)p->nskip + 1;
        o = (unsigned char)1;
        for( ; !((signed int)o >= (signed int)p->nskip); o = o + 1)
          p->framep[(signed long int)o] = sp + (signed long int)((signed int)o * dblk);
        return p;
      }
    }
  }
}

// hashCreateHitList
// file hashhit.h line 172
struct _HashHitList * hashCreateHitList(signed int maxnhits)
{
  struct _HashHitList *hlp = ((struct _HashHitList *)NULL);
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _HashHitList) /*56ul*/ , "hashhit.c", 1557);
  hlp = (struct _HashHitList *)return_value_ecalloc$1;
  _Bool tmp_if_expr$4;
  if(!(hlp == ((struct _HashHitList *)NULL)))
  {
    if(!(maxnhits >= 8192))
      maxnhits = 8192;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)maxnhits, sizeof(unsigned long int) /*8ul*/ , "hashhit.c", 1560);
    hlp->sqdat = (unsigned long int *)return_value_ecalloc$2;
    void *return_value_ecalloc$3;
    return_value_ecalloc$3=ecalloc((unsigned long int)512, sizeof(char) /*1ul*/ , "hashhit.c", 1561);
    hlp->qmask = (char *)return_value_ecalloc$3;
    if(!(hlp->sqdat == ((unsigned long int *)NULL)))
      tmp_if_expr$4 = hlp->qmask != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      hlp->nhits = 0;
      hlp->nhits_max = maxnhits;
      hlp->nhits_alloc = maxnhits;
      hlp->nhits_blksz = 16384;
      hlp->qmask_alloc = (unsigned long int)512;
      hlp->qlen = (unsigned int)0;
      hlp->status = (unsigned char)0;
    }

    else
    {
      hashDeleteHitList(hlp);
      hlp = (struct _HashHitList *)(void *)0;
    }
  }

  return hlp;
}

// hashDeleteHitFilter
// file hashhit.c line 1960
void hashDeleteHitFilter(struct _HashHitFilter *p)
{
  if(!(p == ((struct _HashHitFilter *)NULL)))
    free((void *)p->ivp);

  free((void *)p);
}

// hashDeleteHitInfo
// file hashhit.h line 94
void hashDeleteHitInfo(struct _HashHitInfo *p)
{
  if(!(p == ((struct _HashHitInfo *)NULL)))
  {
    free((void *)p->qmaskp);
    free((void *)p->qbufp);
    free((void *)p->sidxp);
    free((void *)p->nhitqual_sortkeyp);
    free((void *)p->seedp);
    free((void *)p->coverp);
    free((void *)p->countp);
    if(!(p->framep == ((unsigned int **)NULL)))
      free((void *)p->framep[(signed long int)0]);

    free((void *)p->framep);
  }

  free((void *)p);
}

// hashDeleteHitList
// file hashhit.h line 176
void hashDeleteHitList(struct _HashHitList *hlp)
{
  if(!(hlp == ((struct _HashHitList *)NULL)))
  {
    free((void *)hlp->sqdat);
    free((void *)hlp->qmask);
  }

  free((void *)hlp);
}

// hashGetHitListData
// file hashhit.c line 1867
const unsigned long int * hashGetHitListData(signed int *nhits, char *is_reverse, unsigned int *qlen, unsigned char *ktup, unsigned char *nskip, const char **qmask, const struct _HashHitList *hlp)
{
  if(!(nhits == ((signed int *)NULL)))
    *nhits = hlp->nhits;

  if(!(is_reverse == ((char *)NULL)))
    *is_reverse = (char)(((signed int)hlp->status & 1) != 0);

  if(!(qlen == ((unsigned int *)NULL)))
    *qlen = hlp->qlen;

  if(!(ktup == ((unsigned char *)NULL)))
    *ktup = hlp->ktup;

  if(!(qmask == ((const char **)NULL)))
    *qmask = hlp->qmask;

  if(!(nskip == ((unsigned char *)NULL)))
    *nskip = hlp->nskip;

  return hlp->sqdat;
}

// hashHitInfoCalcHitNumbers
// file hashhit.h line 161
unsigned int hashHitInfoCalcHitNumbers(const struct _HashHitInfo *hhip, unsigned int *nhit_rank)
{
  unsigned int i;
  unsigned int ns;
  unsigned int nr = (unsigned int)0;
  unsigned int tmp_if_expr$1;
  if(hhip->seed_rank >= 1u)
    tmp_if_expr$1 = hhip->seed_rank;

  else
    tmp_if_expr$1 = hhip->n_seeds;
  ns = tmp_if_expr$1;
  i = (unsigned int)0;
  for( ; !(i >= ns); i = i + 1u)
    nr = nr + hhip->nhitqual_sortkeyp[(signed long int)i];
  *nhit_rank = nr;
  for( ; !(i >= hhip->n_seeds); i = i + 1u)
    nr = nr + hhip->nhitqual_sortkeyp[(signed long int)i];
  return nr;
}

// hashPrintHitList
// file hashhit.c line 1771
void hashPrintHitList(const struct _HashHitList *hlp, struct _IO_FILE *fp)
{
  signed int i;
  unsigned int qo;
  unsigned int so;
  fprintf(fp, "=-= List (%s) of %d hits: =-=\n", ((signed int)hlp->status & 1) != 0 ? "reverse" : "forward", hlp->nhits);
  fprintf(fp, " hit_num | qoffs | ktupno offs | shift | \n");
  i = 0;
  for( ; !(i >= hlp->nhits); i = i + 1)
  {
    qo = (unsigned int)(hlp->sqdat[(signed long int)i] & (unsigned long int)2147483647);
    if(!((1 & (signed int)hlp->status) == 0))
      so = (unsigned int)((hlp->sqdat[(signed long int)i] >> 31) - (unsigned long int)(qo / (unsigned int)hlp->nskip));

    else
      so = (unsigned int)((hlp->sqdat[(signed long int)i] >> 31) + (unsigned long int)(qo / (unsigned int)hlp->nskip) & (unsigned long int)-1);
    fprintf(fp, "%d %u %u %llu\n", i, qo, so & (unsigned int)-1, (unsigned long long int)(hlp->sqdat[(signed long int)i] >> 31));
  }
  fprintf(fp, "=-= End of list =-=\n\n");
}

// hashPruneHitFilter
// file hashhit.c line 1988
void hashPruneHitFilter(struct _HashHitFilter *hhfp)
{
  signed short int i;
  signed short int j;
  struct _FILTERIVAL *ivp = hhfp->ivp;
  qsort((void *)ivp, (unsigned long int)hhfp->num, sizeof(struct _FILTERIVAL) /*8ul*/ , cmpFILTERIVAL);
  i = (signed short int)0;
  j = (signed short int)1;
  for( ; !((signed int)j >= (signed int)hhfp->num); j = j + 1)
    if(!((ivp + (signed long int)j)->lower >= (ivp + (signed long int)i)->upper))
    {
      if(!((ivp + (signed long int)i)->upper >= (ivp + (signed long int)j)->upper))
        (ivp + (signed long int)i)->upper = (ivp + (signed long int)j)->upper;

    }

    else
    {
      i = i + 1;
      if(!((signed int)i >= (signed int)j))
        ivp[(signed long int)i] = ivp[(signed long int)j];

    }
  hhfp->num = (signed short int)((signed int)i < (signed int)j ? (signed int)i + 1 : (signed int)j);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// hashResetHitFilter
// file hashhit.c line 1968
void hashResetHitFilter(struct _HashHitFilter *p)
{
  p->num = (signed short int)0;
}

// hashSortHitInfo
// file hashhit.c line 1082
signed int hashSortHitInfo(struct _HashHitInfo *hhip)
{
  signed int errcode = 0;
  if(hhip->n_seeds >= 2u)
  {
    if((2 & (signed int)hhip->status) == 0)
    {
      errcode=sort2UINTarraysByQuickSort((signed int)hhip->n_seeds, hhip->nhitqual_sortkeyp, hhip->sidxp);
      if(errcode == 0)
        hhip->status = hhip->status | (unsigned char)2;

    }

  }

  return errcode;
}

// hashTableCheckExtensive
// file hashidx.c line 1000
signed int hashTableCheckExtensive(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int tmp_if_expr$3;
  signed int return_value_checkWordsInSeqSet$1;
  signed int return_value_checkWordsInSeqSet$2;
  if((signed int)htp->typ == 0)
  {
    return_value_checkWordsInSeqSet$1=checkWordsInSeqSet(sqbufp, htp, ssp, codecp, checkPerfectHash);
    tmp_if_expr$3 = return_value_checkWordsInSeqSet$1;
  }

  else
  {
    return_value_checkWordsInSeqSet$2=checkWordsInSeqSet(sqbufp, htp, ssp, codecp, checkHashWithCollisions);
    tmp_if_expr$3 = return_value_checkWordsInSeqSet$2;
  }
  return tmp_if_expr$3;
}

// hashTableCheckQuick
// file hashidx.c line 1008
signed int hashTableCheckQuick(struct _SeqFastq *sqbufp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int tmp_if_expr$3;
  signed int return_value_checkQuickPerfectHashIndex$1;
  signed int return_value_checkQuickHashIndexWithCollisions$2;
  if(!((signed int)htp->status == 2))
    return -1;

  else
  {
    if((signed int)htp->typ == 0)
    {
      return_value_checkQuickPerfectHashIndex$1=checkQuickPerfectHashIndex(sqbufp, htp, ssp, codecp);
      tmp_if_expr$3 = return_value_checkQuickPerfectHashIndex$1;
    }

    else
    {
      return_value_checkQuickHashIndexWithCollisions$2=checkQuickHashIndexWithCollisions(sqbufp, htp, ssp, codecp);
      tmp_if_expr$3 = return_value_checkQuickHashIndexWithCollisions$2;
    }
    return tmp_if_expr$3;
  }
}

// hashTableCmp
// file hashidx.c line 1087
signed int hashTableCmp(const struct _HashTable *ap, const struct _HashTable *bp)
{
  unsigned int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  if(!(ap->nkeys == bp->nkeys))
  {
    printf("Tables have different key length: (A) %d, (b) %d\n", ap->wordlen, bp->wordlen);
    return -1;
  }

  else
    if(!(ap->nskip == bp->nskip))
    {
      printf("Tables have different skip step size: (A) %d, (b) %d\n", ap->nskip, bp->nskip);
      return -1;
    }

    else
    {
      if(!(ap->typ == bp->typ))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = ap->status != bp->status ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        printf("Tables differ in type or status.\n");
        return -1;
      }

      else
      {
        i = (unsigned int)0;
        for( ; !(i >= ap->nkeys); i = i + 1u)
          if(!(ap->idx[(signed long int)i] == bp->idx[(signed long int)i]))
            return -1;

        i = (unsigned int)0;
        for( ; !(i >= ap->npos); i = i + 1u)
          if(!(ap->pos[(signed long int)i] == bp->pos[(signed long int)i]))
            return -1;

        if((signed int)ap->typ == 0)
          return 0;

        else
        {
          if(!(ap->nbits_key == bp->nbits_key))
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = ap->nbits_lo != bp->nbits_lo ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = ap->keymask != bp->keymask ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = ap->keymask_lo != bp->keymask_lo ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = ap->keymask_hi != bp->keymask_hi ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = ap->keymod != bp->keymod ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = ap->wordmask != bp->wordmask ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
            tmp_if_expr$8 = (_Bool)1;

          else
            tmp_if_expr$8 = ap->wordmask_lo != bp->wordmask_lo ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$8)
            tmp_if_expr$9 = (_Bool)1;

          else
            tmp_if_expr$9 = ap->wordmask_hi != bp->wordmask_hi ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$9)
            return -1;

          else
            if(!(ap->nwords == bp->nwords))
            {
              printf("Tables differ in the number of words: (A) %u, (B) %u.\n", ap->nwords, bp->nwords);
              return -1;
            }

            else
            {
              i = (unsigned int)0;
              for( ; !(i >= ap->nwords); i = i + 1u)
              {
                if(!(ap->wordidx[(signed long int)i] == bp->wordidx[(signed long int)i]))
                  tmp_if_expr$10 = (_Bool)1;

                else
                  tmp_if_expr$10 = ap->posidx[(signed long int)i] != bp->posidx[(signed long int)i] ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$10)
                  return -1;

              }
              return 0;
            }
        }
      }
    }
}

// hashTableCreate
// file hashidx.h line 80
struct _HashTable * hashTableCreate(unsigned char wordlen, unsigned char nskip, unsigned char nbits_key, unsigned char nbits_perf, unsigned char typ)
{
  struct _HashTable *htp;
  if((signed int)wordlen >= 22)
    return (struct _HashTable *)(void *)0;

  else
  {
    if((signed int)typ == 0)
    {
      nbits_key = (unsigned char)((signed int)wordlen << 1);
      nbits_perf = (unsigned char)0;
    }

    if((signed int)nbits_key >= 33 || (signed int)nbits_perf >= (signed int)nbits_key || !((32 + (signed int)nbits_perf) / 2 >= (signed int)wordlen))
      return (struct _HashTable *)(void *)0;

    else
    {
      void *return_value_ecalloc$1;
      return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _HashTable) /*136ul*/ , "hashidx.c", 770);
      htp = (struct _HashTable *)return_value_ecalloc$1;
      if(htp == ((struct _HashTable *)NULL))
        return (struct _HashTable *)(void *)0;

      else
      {
        if((signed int)typ == 0)
          nbits_key = (unsigned char)((signed int)wordlen << 1);

        htp->typ = typ;
        htp->status = (unsigned char)0;
        htp->wordlen = wordlen;
        htp->nskip = nskip;
        htp->nbits_key = nbits_key;
        htp->nbits_lo = nbits_perf;
        htp->nkeys = (unsigned int)1 << (signed int)nbits_key;
        htp->keymask = (unsigned long int)(htp->nkeys - (unsigned int)1);
        htp->keymask_lo = ((unsigned int)1 << (signed int)nbits_perf) - (unsigned int)1;
        htp->wordmask = ((unsigned long int)1 << ((signed int)wordlen << 1)) - (unsigned long int)1;
        htp->wordmask_lo = ((unsigned long int)1 << (signed int)nbits_perf) - (unsigned long int)1;
        htp->wordmask_hi = ~htp->wordmask_lo & htp->wordmask;
        htp->keymod = (unsigned int)((unsigned long int)1 << (signed int)nbits_key - (signed int)nbits_perf);
        htp->pos = (unsigned int *)(void *)0;
        htp->npos_alloc = (unsigned long int)0;
        htp->npos = (unsigned int)htp->npos_alloc;
        htp->wordidx = (unsigned int *)(void *)0;
        htp->wordctr = (unsigned int *)(void *)0;
        void *return_value_ecalloc$2;
        return_value_ecalloc$2=ecalloc((unsigned long int)(htp->nkeys + (unsigned int)2), sizeof(unsigned int) /*4ul*/ , "hashidx.c", 794);
        htp->idx = (unsigned int *)return_value_ecalloc$2;
        if(htp->idx == ((unsigned int *)NULL))
        {
          hashTableDelete(htp);
          return (struct _HashTable *)(void *)0;
        }

        else
          return htp;
      }
    }
  }
}

// hashTableDelete
// file hashidx.h line 92
void hashTableDelete(struct _HashTable *htp)
{
  if(!(htp == ((struct _HashTable *)NULL)))
  {
    free((void *)htp->idx);
    free((void *)htp->pos);
    free((void *)htp->wordidx);
    free((void *)htp->wordctr);
  }

  free((void *)htp);
}

// hashTableFetchHitPositions
// file hashidx.c line 1194
unsigned int hashTableFetchHitPositions(unsigned int **posp, const struct _HashTable *htp, unsigned int posidx)
{
  unsigned int nhits = (unsigned int)0;
  *posp = (unsigned int *)(void *)0;
  if((signed int)htp->typ == 0)
  {
    if(!(posidx >= htp->nkeys))
    {
      nhits = htp->idx[(signed long int)(posidx + (unsigned int)1)] - htp->idx[(signed long int)posidx];
      *posp = htp->pos + (signed long int)htp->idx[(signed long int)posidx];
    }

  }

  else
    if(!(posidx >= htp->npos))
    {
      nhits = htp->posidx[(signed long int)(posidx + (unsigned int)1)] - htp->posidx[(signed long int)posidx];
      *posp = htp->pos + (signed long int)htp->posidx[(signed long int)posidx];
    }

  return nhits;
}

// hashTableGetKtupLen
// file hashidx.h line 145
unsigned char hashTableGetKtupLen(const struct _HashTable *htp, unsigned char *nskip)
{
  if(!(nskip == ((unsigned char *)NULL)))
    *nskip = htp->nskip;

  return htp->wordlen;
}

// hashTableGetKtupleHits
// file hashidx.c line 1147
unsigned int hashTableGetKtupleHits(unsigned int **posp, unsigned int *posidx, const struct _HashTable *htp, unsigned long int word)
{
  unsigned int key;
  unsigned int nhits = (unsigned int)0;
  if((signed int)htp->typ == 0)
  {
    key = (unsigned int)(word & htp->wordmask);
    if(!(posidx == ((unsigned int *)NULL)))
      *posidx = key;

    if(!(key >= htp->nkeys))
    {
      nhits = htp->idx[(signed long int)(key + (unsigned int)1)] - htp->idx[(signed long int)key];
      if(!(posp == ((unsigned int **)NULL)))
        *posp = htp->pos + (signed long int)htp->idx[(signed long int)key];

    }

  }

  else
  {
    unsigned int key_hi;
    unsigned int word_hi;
    unsigned int pivot;
    unsigned int b;
    unsigned int a;
    word_hi = (unsigned int)((word & htp->wordmask_hi) >> (signed int)htp->nbits_lo);
    unsigned int return_value_hash32mix$1;
    return_value_hash32mix$1=hash32mix(word_hi);
    key_hi = return_value_hash32mix$1 % htp->keymod;
    key = (unsigned int)((unsigned long int)(key_hi << (signed int)htp->nbits_lo) + (word & htp->wordmask_lo));
    b = htp->idx[(signed long int)(key + (unsigned int)1)];
    if(!(b >= 1u))
      return (unsigned int)0;

    a = htp->idx[(signed long int)key];
    b = b - 1u;
    while(!(a >= b))
    {
      pivot = a + b >> 1;
      if(!(htp->wordidx[(signed long int)pivot] >= word_hi))
        a = pivot + (unsigned int)1;

      else
        b = pivot;
    }
    if(a == b)
    {
      if(htp->wordidx[(signed long int)b] == word_hi)
      {
        nhits = htp->posidx[(signed long int)(b + (unsigned int)1)] - htp->posidx[(signed long int)b];
        if(!(posidx == ((unsigned int *)NULL)))
          *posidx = b;

        if(!(posp == ((unsigned int **)NULL)))
          *posp = htp->pos + (signed long int)htp->posidx[(signed long int)b];

      }

    }

  }
  return nhits;
}

// hashTableGetMaxPos
// file hashidx.c line 1025
unsigned int hashTableGetMaxPos(const struct _HashTable *htp)
{
  return htp->maxpos;
}

// hashTablePrintStats
// file hashidx.h line 155
void hashTablePrintStats(struct _IO_FILE *fp, const struct _HashTable *htp)
{
  unsigned int maxperkey = (unsigned int)0;
  unsigned int nkey_zero;
  fprintf(fp, "# =-=-=-=-= Hash Index Stats =-=-=-=-=\n");
  if((signed int)htp->typ == 0)
    fprintf(fp, "# Perfect hash index.\n");

  else
    fprintf(fp, "# Hash index with collisions.\n");
  fprintf(fp, "# Word length:              %-d bases\n", htp->wordlen);
  fprintf(fp, "# Skip step:                %-d bases\n", htp->nskip);
  fprintf(fp, "# Number of hash keys:      %u\n", htp->nkeys);
  fprintf(fp, "# Number of word positions: %u\n", htp->npos);
  if((signed int)htp->typ == 1)
  {
    signed int return_value_calcMaxWordNumPerKey$1;
    return_value_calcMaxWordNumPerKey$1=calcMaxWordNumPerKey(&nkey_zero, htp);
    maxperkey = (unsigned int)return_value_calcMaxWordNumPerKey$1;
    fprintf(fp, "# Number of different words:        %u\n", htp->nwords);
    fprintf(fp, "# Maximum number of words per key:  %i\n", maxperkey);
    fprintf(fp, "# Number of keys without words:     %u\n", nkey_zero);
  }

  fprintf(fp, "# =-=-= End of Hash Index Stats =-=-=\n");
}

// hashTableRead
// file hashidx.h line 188
struct _HashTable * hashTableRead(signed int *errcode, const char *filnam)
{
  unsigned char is_endianid;
  unsigned char typ;
  unsigned char hashtyp;
  unsigned char nbits_perf;
  unsigned char nbits_key;
  unsigned int header[8l];
  unsigned int totsiz;
  unsigned int version;
  unsigned int headsiz = (unsigned int)8;
  unsigned long int nr;
  struct _HashTable *htp = (struct _HashTable *)(void *)0;
  struct _IO_FILE *fp;
  fp=filioOpenForReading(errcode, &is_endianid, &totsiz, &typ, &version, &headsiz, header, filnam, HASHTABFIL_NAMEXT);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!(*errcode == 0))
    return ((struct _HashTable *)NULL);

  else
  {
    if(!((signed int)typ == 2))
      *errcode = 5;

    else
      if(!(version == 2u) && !(version == 3u))
        *errcode = 56;

      else
        if(headsiz >= 9u)
          *errcode = 33;

    if(!(*errcode == 0))
    {
      fclose(fp);
      return ((struct _HashTable *)NULL);
    }

    else
    {
      if(header[0l] >= 22u)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = header[(signed long int)1] > (unsigned int)255 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        if(version == 3u)
        {
          if(header[5l] >= 33u)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = header[(signed long int)6] >= header[(signed long int)5] ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
      {
        *errcode = 33;
        fclose(fp);
        return ((struct _HashTable *)NULL);
      }

      else
      {
        if(version == 3u)
        {
          hashtyp = (unsigned char)header[(signed long int)4];
          nbits_key = (unsigned char)header[(signed long int)5];
          nbits_perf = (unsigned char)header[(signed long int)6];
        }

        else
        {
          hashtyp = (unsigned char)0;
          nbits_key = (unsigned char)header[(signed long int)0];
          nbits_perf = (unsigned char)0;
        }
        htp=hashTableCreate((unsigned char)header[(signed long int)0], (unsigned char)header[(signed long int)1], nbits_key, nbits_perf, hashtyp);
        if(htp == ((struct _HashTable *)NULL))
          *errcode = 2;

        else
        {
          htp->npos = header[(signed long int)2];
          htp->maxpos = header[(signed long int)3];
          void *return_value_ecalloc$5;
          return_value_ecalloc$5=ecalloc((unsigned long int)htp->npos, sizeof(unsigned int) /*4ul*/ , "hashidx.c", 1308);
          htp->pos = (unsigned int *)return_value_ecalloc$5;
          if(htp->pos == ((unsigned int *)NULL))
            *errcode = 2;

          else
            if(!((signed int)htp->typ == 0))
            {
              if(!(version == 3u))
                *errcode = 33;

              else
              {
                htp->nwords = header[(signed long int)7];
                void *return_value_ecalloc$6;
                return_value_ecalloc$6=ecalloc((unsigned long int)((htp->nwords + (unsigned int)1) * (unsigned int)2), sizeof(unsigned int) /*4ul*/ , "hashidx.c", 1316);
                htp->wordidx = (unsigned int *)return_value_ecalloc$6;
                if(htp->wordidx == ((unsigned int *)NULL))
                  *errcode = 2;

                else
                  htp->posidx = htp->wordidx + (signed long int)htp->nwords + (signed long int)1;
              }
            }

        }
        if(!(*errcode == 0))
        {
          fclose(fp);
          return ((struct _HashTable *)NULL);
        }

        else
        {
          nr=fread((void *)htp->idx, sizeof(unsigned int) /*4ul*/ , (unsigned long int)(htp->nkeys + (unsigned int)1), fp);
          if(nr == (unsigned long int)(1u + htp->nkeys))
          {
            nr=fread((void *)htp->pos, sizeof(unsigned int) /*4ul*/ , (unsigned long int)htp->npos, fp);
            if(nr == (unsigned long int)htp->npos)
            {
              if(!((signed int)htp->typ == 0))
              {
                nr=fread((void *)htp->wordidx, sizeof(unsigned int) /*4ul*/ , (unsigned long int)((unsigned int)2 * htp->nwords + (unsigned int)1), fp);
                if(!(nr == (unsigned long int)(2u * htp->nwords + 1u)))
                  *errcode = 33;

              }

            }

            else
              *errcode = 33;
          }

          else
            *errcode = 33;
          signed int return_value_ferror$7;
          return_value_ferror$7=ferror(fp);
          if(!(return_value_ferror$7 == 0))
            *errcode = 14;

          if(is_endianid == 0)
          {
            if(*errcode == 0)
            {
              filioSwapEndian(htp->idx, htp->nkeys + (unsigned int)1);
              filioSwapEndian(htp->pos, htp->npos);
              filioSwapEndian(htp->wordidx, (unsigned int)2 * (htp->nwords + (unsigned int)1));
            }

          }

          fclose(fp);
          if(*errcode == 0)
            htp->status = (unsigned char)2;

          return htp;
        }
      }
    }
  }
}

// hashTableReset
// file hashidx.h line 95
void hashTableReset(struct _HashTable *htp, unsigned char nskip)
{
  if((signed int)nskip >= 1)
    htp->nskip = nskip;

  if(!((signed int)htp->status == 0))
  {
    memset((void *)htp->idx, 0, (unsigned long int)(htp->nkeys + (unsigned int)2) * sizeof(unsigned int) /*4ul*/ );
    htp->status = (unsigned char)0;
  }

}

// hashTableSetUp
// file hashidx.h line 101
signed int hashTableSetUp(struct _HashTable *htp, struct _SeqFastq *sqbufp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivp, const struct _SeqCodec *codecp, unsigned int *npos_max, char verbose)
{
  signed int errcode = 0;
  unsigned int w;
  unsigned int i;
  unsigned int i_end;
  unsigned long int k;
  unsigned int tuplectr = (unsigned int)0;
  unsigned long int npos;
  _Bool tmp_if_expr$1;
  if((signed int)htp->status == 0)
  {
    unsigned long int totlen;
    seqSetGetSeqNumAndTotLen(&totlen, ssp);
    if(!((signed int)htp->nskip >= 1))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (totlen + (unsigned long int)1) / (unsigned long int)htp->nskip > (unsigned long int)-1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return 47;

  }

  else
    hashTableReset(htp, (unsigned char)0);
  if(!(verbose == 0))
  {
    if((signed int)htp->typ == 0)
      fprintf(stderr, "# Counting k-tuple occurrences ...\n");

    else
      fprintf(stderr, "# Counting keys ...\n");
  }

  htp->idx = htp->idx + (signed long int)2;
  errcode=doAllWordsInSeqSet(&tuplectr, sqbufp, htp, ssp, ivp, codecp, (signed int)htp->typ == 0 ? countPerfectKey : countCollisionKey);
  htp->idx = htp->idx - (signed long int)2;
  _Bool tmp_if_expr$3;
  if(!(errcode == 0))
    return errcode;

  else
  {
    htp->idx[(signed long int)1] = (unsigned int)0;
    htp->idx[(signed long int)0] = htp->idx[(signed long int)1];
    npos = (unsigned long int)0;
    k = (unsigned long int)2;
    for( ; (unsigned long int)(1u + htp->nkeys) >= k; k = k + 1ul)
    {
      npos = npos + (unsigned long int)htp->idx[(signed long int)k];
      htp->idx[(signed long int)k] = (unsigned int)npos;
    }
    if(npos >= 4294967296ul)
      return 82;

    else
    {
      if(!(npos_max == ((unsigned int *)NULL)))
      {
        if(*npos_max >= 1u)
        {
          if(!((unsigned long int)*npos_max >= npos))
          {
            *npos_max = (unsigned int)npos;
            return 17;
          }

        }

        *npos_max = (unsigned int)npos;
      }

      if(htp->pos == ((unsigned int *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = npos > htp->npos_alloc ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        unsigned long int n_alloc = (npos + (unsigned long int)1) / (unsigned long int)8192 + (unsigned long int)1;
        n_alloc = n_alloc * (unsigned long int)8192;
        if(htp->pos == ((unsigned int *)NULL))
        {
          void *return_value_ecalloc$2;
          return_value_ecalloc$2=ecalloc(n_alloc, sizeof(unsigned int) /*4ul*/ , "hashidx.c", 895);
          htp->pos = (unsigned int *)return_value_ecalloc$2;
          if(htp->pos == ((unsigned int *)NULL))
            return 2;

        }

        else
        {
          void *hp;
          hp=erealloc((void *)htp->pos, n_alloc * sizeof(unsigned int) /*4ul*/ , (unsigned long int)0, "hashidx.c", 898);
          if(hp == NULL)
            return 2;

          htp->pos = (unsigned int *)hp;
        }
        htp->npos_alloc = n_alloc;
      }

      htp->npos = (unsigned int)(unsigned long int)npos;
      if((signed int)htp->typ == 0)
      {
        if(!(verbose == 0))
          fprintf(stderr, "# Setting the k-tuple positions in index ...\n");

        htp->idx = htp->idx + 1l;
        errcode=doAllWordsInSeqSet(&tuplectr, sqbufp, htp, ssp, ivp, codecp, setKeyPos);
        if(!(errcode == 0))
          return errcode;

        htp->idx = htp->idx - 1l;
        htp->idx[(signed long int)0] = (unsigned int)0;
      }

      else
      {
        free((void *)htp->wordctr);
        void *return_value_ecalloc$4;
        return_value_ecalloc$4=ecalloc((unsigned long int)htp->nkeys, sizeof(unsigned int) /*4ul*/ , "hashidx.c", 919);
        htp->wordctr = (unsigned int *)return_value_ecalloc$4;
        if(htp->wordctr == ((unsigned int *)NULL))
          return 2;

        if(!(verbose == 0))
          fprintf(stderr, "# Counting k-tuples ...\n");

        htp->idx = htp->idx + 1l;
        errcode=doAllWordsInSeqSet(&tuplectr, sqbufp, htp, ssp, ivp, codecp, collectWords);
        htp->idx = htp->idx - 1l;
        if(!(errcode == 0))
          return errcode;

        if(!(verbose == 0))
          fprintf(stderr, "# Allocating k-tuple arrays ...\n");

        w = (unsigned int)0;
        k = (unsigned long int)0;
        for( ; !(k >= (unsigned long int)htp->nkeys); k = k + 1ul)
          w = w + htp->wordctr[(signed long int)k];
        htp->nwords = w;
        free((void *)htp->wordidx);
        void *return_value_ecalloc$5;
        return_value_ecalloc$5=ecalloc((unsigned long int)((unsigned int)2 * (w + (unsigned int)2)), sizeof(unsigned int) /*4ul*/ , "hashidx.c", 941);
        htp->wordidx = (unsigned int *)return_value_ecalloc$5;
        if(htp->wordidx == ((unsigned int *)NULL))
          return 2;

        htp->posidx = htp->wordidx + (signed long int)w + (signed long int)2;
        w = (unsigned int)0;
        htp->idx[(signed long int)0] = (unsigned int)0;
        k = (unsigned long int)0;
        for( ; !(k >= (unsigned long int)htp->nkeys); k = k + 1ul)
        {
          i = htp->idx[(signed long int)(k + (unsigned long int)1)];
          i_end = i + htp->wordctr[(signed long int)k];
          htp->idx[(signed long int)(k + (unsigned long int)1)] = htp->idx[(signed long int)k] + htp->wordctr[(signed long int)k];
          for( ; !(i >= i_end); w = w + 1u)
          {
            htp->wordidx[(signed long int)w] = htp->pos[(signed long int)i];
            i = i + 1u;
          }
        }
        if(!(w == htp->nwords))
          return 47;

        free((void *)htp->wordctr);
        htp->wordctr = (unsigned int *)(void *)0;
        if(!(verbose == 0))
          fprintf(stderr, "# Counting k-tuple occurrences ...\n");

        htp->posidx = htp->posidx + (signed long int)2;
        errcode=doAllWordsInSeqSet(&tuplectr, sqbufp, htp, ssp, ivp, codecp, countWords);
        htp->posidx = htp->posidx - (signed long int)2;
        if(!(errcode == 0))
          return errcode;

        htp->posidx[(signed long int)1] = (unsigned int)0;
        htp->posidx[(signed long int)0] = htp->posidx[(signed long int)1];
        w = (unsigned int)2;
        for( ; !(w >= htp->nwords); w = w + 1u)
          htp->posidx[(signed long int)(w + (unsigned int)1)] = htp->posidx[(signed long int)(w + (unsigned int)1)] + htp->posidx[(signed long int)w];
        if(!(verbose == 0))
          fprintf(stderr, "# Setting the k-tuple positions in index ...\n");

        htp->posidx = htp->posidx + 1l;
        errcode=doAllWordsInSeqSet(&tuplectr, sqbufp, htp, ssp, ivp, codecp, setWordPos);
        htp->posidx = htp->posidx - 1l;
        if(!(errcode == 0))
          return errcode;

      }
      htp->maxpos = tuplectr > (unsigned int)0 ? tuplectr - (unsigned int)1 : (unsigned int)0;
      htp->status = (unsigned char)2;
      if(!(verbose == 0))
        fprintf(stderr, "# Hash table is set up.\n");

      return errcode;
    }
  }
}

// hashTableWrite
// file hashidx.h line 184
signed int hashTableWrite(const char *filnam, const struct _HashTable *htp)
{
  signed int errcode;
  unsigned int header[8l];
  unsigned long int totsiz;
  struct _IO_FILE *fp;
  header[(signed long int)0] = (unsigned int)htp->wordlen;
  header[(signed long int)1] = (unsigned int)htp->nskip;
  header[(signed long int)2] = htp->npos;
  header[(signed long int)3] = htp->maxpos;
  header[(signed long int)4] = (unsigned int)htp->typ;
  header[(signed long int)5] = (unsigned int)htp->nbits_key;
  header[(signed long int)6] = (unsigned int)htp->nbits_lo;
  header[(signed long int)7] = htp->nwords;
  totsiz = (unsigned long int)(htp->npos + htp->nkeys + (unsigned int)1);
  if(!((signed int)htp->typ == 0))
    totsiz = totsiz + (unsigned long int)((htp->nwords + (unsigned int)1) * (unsigned int)2);

  if(totsiz >= 4294967296ul)
    return 48;

  else
  {
    fp=filioOpenForWriting(&errcode, (unsigned int)totsiz, (unsigned char)2, (unsigned int)3, (unsigned int)8, header, filnam, HASHTABFIL_NAMEXT);
    if(!(errcode == 0))
      return errcode;

    else
    {
      fwrite((const void *)htp->idx, sizeof(unsigned int) /*4ul*/ , (unsigned long int)(htp->nkeys + (unsigned int)1), fp);
      fwrite((const void *)htp->pos, sizeof(unsigned int) /*4ul*/ , (unsigned long int)htp->npos, fp);
      if(!((signed int)htp->typ == 0))
      {
        fwrite((const void *)htp->wordidx, sizeof(unsigned int) /*4ul*/ , (unsigned long int)(htp->nwords + (unsigned int)1), fp);
        fwrite((const void *)htp->posidx, sizeof(unsigned int) /*4ul*/ , (unsigned long int)(htp->nwords + (unsigned int)1), fp);
      }

      signed int return_value_ferror$1;
      return_value_ferror$1=ferror(fp);
      if(!(return_value_ferror$1 == 0))
      {
        perror(HASHTABFIL_WRITERRMSG);
        errcode = 11;
      }

      fclose(fp);
      return errcode;
    }
  }
}

// infmtCheckReads
// file infmt.h line 101
signed int infmtCheckReads(struct _InFmtReader *ifrp, struct _SeqFastq *sqbufAp, struct _SeqFastq *sqbufBp, signed long int *seqnum, unsigned int *maxseqlen, unsigned int *maxnamlen, struct _ErrMsg *errmsgp)
{
  signed int errcode = 0;
  if(!(seqnum == ((signed long int *)NULL)))
    *seqnum = (signed long int)0;

  if(!(maxseqlen == ((unsigned int *)NULL)))
    *maxseqlen = (unsigned int)0;

  if(!(maxnamlen == ((unsigned int *)NULL)))
    *maxnamlen = (unsigned int)0;

  if((signed int)ifrp->fmt == 1)
    errcode=seqIOCheckReads(errmsgp, sqbufAp, ifrp->sfAp, sqbufBp, ifrp->sfBp, seqnum, maxseqlen, maxnamlen);

  return errcode;
}

// infmtCreateReader
// file infmt.h line 65
struct _InFmtReader * infmtCreateReader(signed int *errcode, const char *filnamA, const char *filnamB, const char *tmpdir, const unsigned char fmt)
{
  struct _InFmtReader *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _InFmtReader) /*112ul*/ , "infmt.c", 121);
  p = (struct _InFmtReader *)return_value_ecalloc$1;
  _Bool tmp_if_expr$2;
  if(p == ((struct _InFmtReader *)NULL))
    return p;

  else
  {
    p->errcode = 0;
    p->fmt = (unsigned char)0;
    if(tmpdir == ((const char *)NULL))
      tmpdir = BAMBAM_TMPDIR_DEFAULT;

    p->fid = -1;
    if((signed int)fmt == 0)
    {
      signed int errcode_test = 0;
      *errcode=openINFMTReaderAsFASTQ(p, filnamA, filnamB, (unsigned char)1, &errcode_test);
      if(*errcode == 0 && errcode_test == 0)
        p->fmt = (unsigned char)1;

      else
      {
        if(*errcode == 0)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = 6 == *errcode ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          *errcode=openINFMTReaderAsSAMBAM(p, filnamA, tmpdir, (unsigned char)0);
          if(*errcode == 0)
            p->fmt = (unsigned char)3;

          else
            *errcode = 83;
        }

      }
    }

    else
      if((signed int)fmt == 1)
      {
        *errcode=openINFMTReaderAsFASTQ(p, filnamA, filnamB, (unsigned char)0, (signed int *)(void *)0);
        if(*errcode == 0)
          p->fmt = (unsigned char)1;

      }

      else
        if((signed int)fmt == 3)
        {
          *errcode=openINFMTReaderAsSAMBAM(p, filnamA, tmpdir, (unsigned char)0);
          if(*errcode == 0)
            p->fmt = (unsigned char)3;

        }

        else
          if((signed int)fmt == 2)
          {
            *errcode=openINFMTReaderAsSAMBAM(p, filnamA, tmpdir, (unsigned char)1);
            if(*errcode == 0)
              p->fmt = (unsigned char)2;

          }

          else
            *errcode = 83;
    if(!(*errcode == 0))
    {
      infmtDeleteReader(p);
      p = (struct _InFmtReader *)(void *)0;
    }

    return p;
  }
}

// infmtDeleteReader
// file infmt.h line 85
void infmtDeleteReader(struct _InFmtReader *p)
{
  if(!(p == ((struct _InFmtReader *)NULL)))
  {
    seqIOclose(p->sfAp);
    seqIOclose(p->sfBp);
    if(p->fid >= 0)
      BamBam_FreeBamCollator(p->fid);

  }

  free((void *)p);
}

// infmtGetReaderStatus
// file infmt.h line 89
signed int infmtGetReaderStatus(const struct _InFmtReader *ifrp)
{
  return ifrp->errcode;
}

// infmtRead
// file infmt.h line 93
signed int infmtRead(struct _InFmtReader *ifrp, struct _SeqFastq *sfqAp, struct _SeqFastq *sfqBp, unsigned char *isPair)
{
  signed int errcode;
  signed int typ;
  void *dummyA;
  void *dummyB;
  *isPair = (unsigned char)0;
  seqFastqBlank(sfqAp);
  seqFastqBlank(sfqBp);
  switch((signed int)ifrp->fmt)
  {
    case 1:
    {
      errcode=seqFastqRead(sfqAp, ifrp->sfAp);
      if(errcode == 0)
      {
        if(!(ifrp->sfBp == ((struct _SeqIO *)NULL)))
        {
          if(!(sfqBp == ((struct _SeqFastq *)NULL)))
          {
            errcode=seqFastqRead(sfqBp, ifrp->sfBp);
            if(errcode == 0)
            {
              signed int erc;
              erc=seqIOstatus(ifrp->sfBp);
              *isPair = (unsigned char)1;
              if(!(erc == 0))
              {
                if(erc == 10)
                {
                  signed int return_value_seqIOstatus$1;
                  return_value_seqIOstatus$1=seqIOstatus(ifrp->sfAp);
                  if(return_value_seqIOstatus$1 == 10)
                    ifrp->errcode = 10;

                  else
                    errcode = 53;
                }

                else
                  errcode = erc;
              }

            }

          }

        }

      }

      if(errcode == 0)
      {
        signed int infmtRead$$1$$1$$2$$erc;
        infmtRead$$1$$1$$2$$erc=seqIOstatus(ifrp->sfAp);
        if(!(infmtRead$$1$$1$$2$$erc == 0))
        {
          if(ifrp->errcode == 0)
            ifrp->errcode = infmtRead$$1$$1$$2$$erc;

          if(!(infmtRead$$1$$1$$2$$erc == 10))
            errcode = infmtRead$$1$$1$$2$$erc;

        }

      }

      break;
    }
    case 2:

    case 3:
    {
      typ=BamBam_ReadPair(ifrp->fid, &ifrp->rbufA, &ifrp->rbufB, &dummyA, &dummyB, (const char)0);
      if(typ == -1)
        errcode = 10;

      else
        if(typ == 4)
          errcode=seqFastqSetAscii(sfqAp, ifrp->rbufB.name, ifrp->rbufB.seq, "", ifrp->rbufB.qual);

        else
        {
          errcode=seqFastqSetAscii(sfqAp, ifrp->rbufA.name, ifrp->rbufA.seq, "", ifrp->rbufA.qual);
          if(errcode == 0 && typ == 2 && !(sfqBp == ((struct _SeqFastq *)NULL)))
          {
            if(ifrp->rbufB.seqlength >= 1u)
            {
              errcode=seqFastqSetAscii(sfqBp, ifrp->rbufB.name, ifrp->rbufB.seq, "", ifrp->rbufB.qual);
              if(errcode == 0)
                *isPair = (unsigned char)1;

            }

          }

        }
      if(!(errcode == 0))
        ifrp->errcode = errcode;

      break;
    }
    default:
      errcode = 83;
  }
  if(errcode == 0)
    errcode=seqFastqCheck(sfqAp);

  if(errcode == 0 && !(sfqBp == ((struct _SeqFastq *)NULL)))
    errcode=seqFastqCheck(sfqBp);

  return errcode;
}

// infmtReset
// file infmt.h line 119
signed int infmtReset(struct _InFmtReader *ifrp)
{
  signed int errcode = 0;
  if((signed int)ifrp->fmt == 1)
  {
    errcode=seqIOReset(ifrp->sfAp);
    if(errcode == 0)
    {
      if(!(ifrp->sfBp == ((struct _SeqIO *)NULL)))
        errcode=seqIOReset(ifrp->sfBp);

    }

  }

  return errcode;
}

// initALIBAND
// file alignment.c line 310
static signed int initALIBAND(struct _ALIBAND *abp, signed int l_edge, signed int r_edge, signed int q_left, signed int q_right, signed int q_len, signed int s_left, signed int s_right, signed int s_len)
{
  abp->s_len = s_right < 0 || s_right >= s_len ? s_len : s_right + 1;
  abp->q_len = q_right < 0 || q_right >= q_len ? q_len : q_right + 1;
  abp->s_totlen = s_len;
  abp->q_totlen = q_len;
  _Bool tmp_if_expr$1;
  if(s_left >= 1)
    tmp_if_expr$1 = s_left < abp->s_len ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  abp->s_left_orig = tmp_if_expr$1 ? s_left : 0;
  abp->s_left = abp->s_left_orig;
  _Bool tmp_if_expr$2;
  if(q_left >= 1)
    tmp_if_expr$2 = q_left < abp->q_len ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  abp->q_left_orig = tmp_if_expr$2 ? q_left : 0;
  abp->q_left = abp->q_left_orig;
  abp->l_edge = l_edge;
  abp->l_edge_orig = abp->l_edge;
  abp->r_edge = r_edge;
  abp->r_edge_orig = abp->r_edge;
  abp->band_width = (r_edge - l_edge) + 1;
  _Bool tmp_if_expr$3;
  if(!(abp->band_width >= 1))
  {
    abp->band_width = 0;
    abp->l_edge = abp->q_left;
    abp->r_edge = abp->q_len - 1;
  }

  else
  {
    if(!(abp->q_len >= abp->l_edge_orig + abp->s_len))
      abp->s_len = abp->q_len - abp->l_edge_orig;

    abp->l_edge = abp->l_edge + abp->s_left;
    if(abp->l_edge >= abp->q_len)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = abp->r_edge_orig + abp->s_len <= abp->q_left ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      return -1;

    abp->r_edge = abp->r_edge + abp->s_left;
    if(!(abp->r_edge >= abp->q_left))
    {
      abp->s_left = abp->s_left + (abp->q_left - abp->r_edge);
      abp->l_edge = abp->l_edge + (abp->q_left - abp->r_edge);
      abp->r_edge = abp->q_left;
    }

    if(!(abp->q_len + -1 >= abp->r_edge))
      abp->r_edge = abp->q_len - 1;

  }
  abp->band_width = (abp->r_edge - abp->l_edge) + 1;
  return abp->band_width >= 0 ? 0 : -1;
}

// initALIMETA
// file alignment.c line 568
static signed int initALIMETA(struct _ALIMETA *p, signed short int dfstr_blksz)
{
  signed int errcode;
  errcode=diffStrInit(&p->dfs, (signed int)dfstr_blksz);
  if(!(errcode == 0))
    cleanupALIMETA(p);

  return errcode;
}

// initALITRACK
// file alignment.c line 439
static signed int initALITRACK(struct _ALITRACK *p, unsigned long int blksz, unsigned long int n_alloc_thresh)
{
  if(!(blksz >= 1ul))
    blksz = (unsigned long int)32768;

  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc(blksz, sizeof(unsigned char) /*1ul*/ , "alignment.c", 442);
  p->bdp = (unsigned char *)return_value_ecalloc$1;
  if(p->bdp == ((unsigned char *)NULL))
    return 2;

  else
  {
    p->blksz = blksz;
    p->n_alloc = p->blksz;
    p->n_alloc_thresh = n_alloc_thresh < (unsigned long int)1 ? (unsigned long int)1048576 : n_alloc_thresh;
    p->max_j = 0;
    p->max_i = p->max_j;
    p->max_scor = 0;
    return 0;
  }
}

// initARGBUFF
// file threads.c line 347
static signed int initARGBUFF(struct _ARGBUFF *fifop, unsigned char buftyp)
{
  signed int errcode;
  sem_init(&fifop->sema, 0, (unsigned int)0);
  fifop->buftyp = buftyp;
  pthread_mutex_init(&fifop->mutex, (const union anonymous$0 *)(void *)0);
  errcode=pushARGBUFF(fifop, (struct _BUFFARG *)(void *)0);
  return errcode;
}

// initArgBlock
// file smalt.c line 882
static signed int initArgBlock(void *ap, const void *ip, signed short int argno)
{
  signed int errcode = 0;
  signed short int i;
  struct SmaltArgBlock_ *blockp = (struct SmaltArgBlock_ *)ap;
  const struct _SmaltMapConst *mcp = (const struct _SmaltMapConst *)ip;
  unsigned char prep_paired;
  _Bool tmp_if_expr$1;
  if(!((64 & (signed int)mcp->rmapflg) == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)mcp->inform == 2 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)mcp->inform == 3 ? (_Bool)1 : (_Bool)0;
  prep_paired = (unsigned char)tmp_if_expr$2;
  blockp->argno = argno;
  blockp->n_iobf = (signed short int)0;
  void *return_value_ecalloc$3;
  return_value_ecalloc$3=ecalloc((unsigned long int)mcp->threadblksz, sizeof(struct _SmaltIOBuffArg) /*48ul*/ , "smalt.c", 894);
  blockp->iobfp = (struct _SmaltIOBuffArg *)return_value_ecalloc$3;
  if(blockp->iobfp == ((struct _SmaltIOBuffArg *)NULL))
  {
    errcode = 2;
    blockp->n_alloc = (signed short int)0;
  }

  else
    blockp->n_alloc = mcp->threadblksz;
  i = (signed short int)0;
  for( ; errcode == 0 && !((signed int)i >= (signed int)blockp->n_alloc); i = i + 1)
    errcode=initIOBuffArg(blockp->iobfp + (signed long int)i, prep_paired);
  return errcode;
}

// initBAMHeader
// file report.c line 1303
static signed int initBAMHeader(struct _BamBam_BamWriter **bamwriterpp, struct _BamBam_BamHeaderInfo **headinfopp, struct _REPSTR *sbufp, const char *prognam, const char *progversion, signed int narg, char * const *argv, const char *filnamp, const struct _SeqSet *ssp)
{
  signed int errcode = 0;
  signed long int s;
  signed long int nseq;
  if(ssp == ((const struct _SeqSet *)NULL))
    return 47;

  else
  {
    errcode=copySAMheaderCommandLineToREPSTR(sbufp, prognam, progversion, narg, argv);
    if(!(errcode == 0))
      return errcode;

    else
    {
      *headinfopp=BamBam_BamHeaderInfo_New(SAMBAM_HEADER_VERSION, SAMBAM_SORTORDER_UNKNOWN, sbufp->strp);
      if(*headinfopp == ((struct _BamBam_BamHeaderInfo *)NULL))
        return 2;

      else
      {
        nseq=seqSetGetOffsets(ssp, (const unsigned long int **)(void *)0);
        s = (signed long int)0;
        for( ; !(s >= nseq); s = s + 1l)
        {
          const char *chrnam;
          unsigned int chrlen;
          chrlen=seqSetGetSeqDatByIndex((unsigned long int *)(void *)0, &chrnam, s, ssp);
          errcode=copyReadNamStrToREPSTR(sbufp, (unsigned char)0, chrnam);
          if(!(errcode == 0))
            break;

          signed int return_value_BamBam_BamHeaderInfo_AddChromosome$1;
          return_value_BamBam_BamHeaderInfo_AddChromosome$1=BamBam_BamHeaderInfo_AddChromosome(*headinfopp, sbufp->strp, (unsigned long int)chrlen);
          if(!(return_value_BamBam_BamHeaderInfo_AddChromosome$1 == 0))
          {
            errcode = 87;
            break;
          }

        }
        if(!(errcode == 0))
          return errcode;

        else
        {
          *bamwriterpp=BamBam_BamWriter_New(*headinfopp, filnamp, 1);
          return (struct _BamBam_BamWriter *)(void *)0 == *bamwriterpp ? 2 : 0;
        }
      }
    }
  }
}

// initHashOptions
// file menu.c line 1106
static signed int initHashOptions(struct _MenuOpt *menup)
{
  struct _INDEXMENU *ip;
  free(menup->paramp);
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _INDEXMENU) /*2ul*/ , "menu.c", 1110);
  ip = (struct _INDEXMENU *)return_value_ecalloc$1;
  if(ip == ((struct _INDEXMENU *)NULL))
    return 2;

  else
  {
    menup->subprog = (char)1;
    menup->paramp = (void *)ip;
    ip = (struct _INDEXMENU *)menup->paramp;
    ip->kmer = (unsigned char)13;
    ip->skip = (unsigned char)6;
    return 0;
  }
}

// initHitList
// file hashhit.c line 1262
static signed int initHitList(struct _HashHitList *hlp, const struct _HashHitInfo *hip)
{
  signed int errcode;
  unsigned long int target_size;
  double return_value_log$1;
  return_value_log$1=log((double)hip->qlen);
  target_size = (unsigned long int)((double)hip->qlen * return_value_log$1 * (double)32);
  hlp->qlen = hip->qlen;
  hlp->ktup = hip->ktup;
  hlp->nskip = hip->nskip;
  if(target_size >= 2147483648ul)
    target_size = (unsigned long int)2147483647;

  else
    if(!(target_size >= 8192ul))
      target_size = (unsigned long int)8192;

  if(target_size >= 2147483648ul)
    target_size = (unsigned long int)0x7fffffff;

  if(!(hlp->nhits_alloc >= (signed int)target_size))
  {
    errcode=reallocHitList(hlp, target_size);
    if(errcode == 0)
      goto __CPROVER_DUMP_L4;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if((unsigned long int)hip->qlen >= hlp->qmask_alloc)
    {
      errcode=reallocQmask(hlp, hip->qlen);
      if(errcode == 0)
        goto __CPROVER_DUMP_L5;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      hlp->nhits_max = (signed int)target_size;
      blankHitList(hlp);
      if(!((1 & (signed int)hip->status) == 0))
        hlp->status = hlp->status | (unsigned char)1;

      return 0;
    }
  }
}

// initIOBuffArg
// file smalt.c line 739
static signed int initIOBuffArg(struct _SmaltIOBuffArg *argp, unsigned char prep_paired)
{
  signed int errcode = 0;
  argp->readp=seqFastqCreate(0, (char)0);
  if(argp->readp == ((struct _SeqFastq *)NULL))
    errcode = 2;

  if(errcode == 0 && !(prep_paired == 0))
  {
    argp->matep=seqFastqCreate(0, (char)0);
    if(argp->matep == ((struct _SeqFastq *)NULL))
      errcode = 2;

  }

  else
    argp->matep = (struct _SeqFastq *)(void *)0;
  if(errcode == 0)
  {
    argp->rep=reportCreate(0);
    if(argp->rep == ((struct _Report *)NULL))
      errcode = 2;

  }

  argp->readno = (unsigned long int)0LL;
  argp->isiz = 0;
  argp->pairflg = (unsigned char)0;
  return errcode;
}

// initInput
// file smalt.c line 674
static signed int initInput(void *ip, const void *mp, signed short int threadno)
{
  struct _SmaltInput *inargp = (struct _SmaltInput *)ip;
  const struct _SmaltMapConst *mcp = (const struct _SmaltMapConst *)mp;
  inargp->threadno = threadno;
  inargp->errcode = 0;
  inargp->menuflg = mcp->menuflg;
  inargp->rctr = (unsigned long int)0LL;
  inargp->pctr = (unsigned long int)0LL;
  inargp->rival = 0;
  inargp->ifrp = mcp->ifrp;
  return inargp->errcode;
}

// initMapArgs
// file smalt.c line 1039
static signed int initMapArgs(void *ap, const void *ip, signed short int threadno)
{
  struct _SmaltMapArgs *map = (struct _SmaltMapArgs *)ap;
  const struct _SmaltMapConst *mcp = (const struct _SmaltMapConst *)ip;
  unsigned short int rmapflg = mcp->rmapflg;
  _Bool tmp_if_expr$1;
  if((signed int)mcp->inform == 2)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)mcp->inform == 3 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    rmapflg = rmapflg | (unsigned short int)64;

  map->rmp=rmapCreate(mcp->htp, mcp->codecp, mcp->ssp, mcp->scormtxp, rmapflg);
  if(map->rmp == ((struct RMap_ *)NULL))
    return 2;

  else
  {
    map->smconstp = mcp;
    map->threadno = threadno;
    map->errcode = 0;
    return 0;
  }
}

// initMapConst
// file smalt.c line 443
static signed int initMapConst(struct _SmaltMapConst *smcp, const struct _MenuOpt *menup)
{
  signed int errcode;
  signed int seed;
  signed short int min_swatscor;
  signed short int swatscordiff;
  double idmin;
  const char *indexnam;
  const char *insfilnam;
  const char *filnamA;
  const char *filnamB;
  const char *tmpdir;
  unsigned char menuoutform;
  unsigned char informat;
  unsigned char pairtyp = (unsigned char)0;
  signed int ninfil;
  signed short int nthreads = (signed short int)0;
  unsigned char fmt;
  memset((void *)smcp, 0, sizeof(struct _SmaltMapConst) /*168ul*/ );
  smcp->subprogtyp=menuGetSubProgTyp(menup);
  smcp->cmdlin_argv=menuGetCommandLine(menup, &smcp->cmdlin_narg);
  smcp->prognam=menuGetProgramName(&smcp->progversion);
  nthreads=menuGetNumberOfThreads(menup);
  if((signed int)nthreads >= 241)
    nthreads = (signed short int)240;

  smcp->threadblksz = (signed short int)((signed int)nthreads > 0 ? (signed int)nthreads * 32 : 1);
  errcode=menuGetMapParams(menup, &indexnam, &smcp->nhitmax_tuple, &smcp->tupcovmin, &min_swatscor, &swatscordiff, &smcp->minbasq, &idmin, &seed, &smcp->readskip, &smcp->insert_min, &smcp->insert_max, &menuoutform, &smcp->oufilnam, &insfilnam, &pairtyp);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  if(!(errcode == 0))
    return errcode;

  else
  {
    smcp->menuflg=menuGetFlags(menup);
    smcp->swatscordiff = (signed int)swatscordiff;
    smcp->rfp=resultSetCreateFilter();
    errcode=menuGetMapInputFormat(menup, &smcp->inform, (const char **)(void *)0);
    if(!(errcode == 0))
      return errcode;

    else
      if(smcp->rfp == ((struct _ResultFilter *)NULL))
        return 2;

      else
      {
        resultSetFilterData(smcp->rfp, (signed int)min_swatscor, (signed int)swatscordiff, idmin);
        smcp->outform=convertOutputFormat(&smcp->oumodflg, menuoutform, menup);
        if(!((128 & (signed int)smcp->menuflg) == 0))
          smcp->oumodflg = smcp->oumodflg | (unsigned char)1;

        if(swatscordiff == 0)
        {
          smcp->rsltouflg = smcp->rsltouflg | (unsigned char)1;
          smcp->rmapflg = smcp->rmapflg | (unsigned short int)2;
          if((2048 & (signed int)smcp->menuflg) == 0)
          {
            smcp->rsltouflg = smcp->rsltouflg | (unsigned char)2;
            if(!((4096 & (signed int)smcp->menuflg) == 0))
            {
              smcp->rsltouflg = smcp->rsltouflg | (unsigned char)8;
              if(!(seed >= 1))
              {
                signed long int return_value_time$1;
                return_value_time$1=time(((signed long int *)NULL));
                srand48(return_value_time$1);
              }

              else
                srand48((signed long int)seed);
            }

          }

        }

        if(!((256 & (signed int)smcp->menuflg) == 0))
        {
          smcp->rmapflg = smcp->rmapflg | (unsigned short int)(8 | 32 | 128);
          smcp->rsltouflg = smcp->rsltouflg | (unsigned char)4;
        }

        if(!((2 & (signed int)smcp->menuflg) == 0))
          smcp->rmapflg = smcp->rmapflg | (unsigned short int)1;

        if(!((16 & (signed int)smcp->menuflg) == 0))
        {
          if((signed int)smcp->inform == 1)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = (signed int)smcp->inform == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            smcp->rmapflg = smcp->rmapflg | (unsigned short int)64;

        }

        if((signed int)pairtyp == 2)
          smcp->pairtyp = (unsigned char)1;

        else
          if((signed int)pairtyp == 3)
            smcp->pairtyp = (unsigned char)2;

          else
            if((signed int)pairtyp == 4)
              smcp->pairtyp = (unsigned char)3;

            else
              if((signed int)pairtyp == 0)
                smcp->pairtyp = (unsigned char)4;

              else
                return 51;
        if(!((512 & (signed int)smcp->menuflg) == 0))
          smcp->rmapflg = smcp->rmapflg | (unsigned short int)(32 | 128 | 4);

        smcp->scorpltyp=scorePenaltiesCreate();
        if(smcp->scorpltyp == ((struct ScorePenalties_ *)NULL))
          return 2;

        else
        {
          unsigned char return_value_menuGetMapPenaltyScores$3;
          return_value_menuGetMapPenaltyScores$3=menuGetMapPenaltyScores(menup, (signed char *)(void *)0, (signed char *)(void *)0, (signed char *)(void *)0, (signed char *)(void *)0);
          if(!((signed int)return_value_menuGetMapPenaltyScores$3 == 0))
          {
            signed char match;
            signed char subst;
            signed char gap_open;
            signed char gap_ext;
            unsigned char bitflg;
            bitflg=menuGetMapPenaltyScores(menup, &match, &subst, &gap_open, &gap_ext);
            if(!((0x1 & (signed int)bitflg) == 0))
              scoreSetPenalty(smcp->scorpltyp, (signed short int)0, (signed short int)match);

            if(!((0x2 & (signed int)bitflg) == 0))
              scoreSetPenalty(smcp->scorpltyp, (signed short int)1, (signed short int)subst);

            if(!((0x4 & (signed int)bitflg) == 0))
              scoreSetPenalty(smcp->scorpltyp, (signed short int)2, (signed short int)gap_open);

            if(!((0x8 & (signed int)bitflg) == 0))
              scoreSetPenalty(smcp->scorpltyp, (signed short int)3, (signed short int)gap_ext);

          }

          smcp->codecp=seqCodecCreate();
          if(smcp->codecp == ((struct _SeqCodec *)NULL))
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            smcp->scormtxp=scoreCreateMatrix(smcp->codecp, smcp->scorpltyp);
            tmp_if_expr$4 = !(smcp->scormtxp != ((struct _ScoreMatrix *)NULL)) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
            return 2;

          else
          {
            if(!(insfilnam == ((const char *)NULL)))
            {
              if(!((4 & (signed int)smcp->menuflg) == 0))
                fprintf(stderr, "# Reading distribution of insert sizes from file ...\n");

              smcp->ihp=insReadHisto(&errcode, insfilnam);
              if(!(errcode == 0))
              {
                smcp->ihp = (struct _InsHist *)(void *)0;
                return errcode;
              }

              if(!((4 & (signed int)smcp->menuflg) == 0))
              {
                fprintf(stderr, "# Sampled histogram\n");
                insPrintHisto(stdout, 80, (unsigned char)0, smcp->ihp);
                fprintf(stderr, "# Smoothed histogram\n");
                insPrintHisto(stdout, 80, (unsigned char)1, smcp->ihp);
              }

              updateInsertBoundariesFromSample(smcp, smcp->ihp);
            }

            ninfil=menuGetFileNames(menup, &filnamA, &filnamB);
            if(!(ninfil >= 1))
              return 47;

            else
            {
              errcode=menuGetMapInputFormat(menup, &informat, &tmpdir);
              if(!(errcode == 0))
                return errcode;

              else
              {
                fmt=convertInputFormat(informat);
                if(!((4 & (signed int)smcp->menuflg) == 0))
                  fprintf(stderr, "# Opening read %s ...\n", ninfil == 2 ? "file" : "files");

                smcp->ifrp=infmtCreateReader(&errcode, filnamA, filnamB, tmpdir, fmt);
                if(!(errcode == 0))
                  return errcode;

                else
                {
                  if(!((4 & (signed int)smcp->menuflg) == 0))
                    fprintf(stderr, "# Reading reference sequences ...\n");

                  smcp->ssp=seqSetReadBinFil(&errcode, indexnam);
                  if(!(errcode == 0))
                    return errcode;

                  else
                  {
                    signed long int return_value_seqSetGetOffsets$5;
                    return_value_seqSetGetOffsets$5=seqSetGetOffsets(smcp->ssp, (const unsigned long int **)(void *)0);
                    if(!(return_value_seqSetGetOffsets$5 >= 512l))
                      smcp->rmapflg = smcp->rmapflg | (unsigned short int)16;

                    if(!((4 & (signed int)smcp->menuflg) == 0))
                      fprintf(stderr, "# Reading hash table ...\n");

                    smcp->htp=hashTableRead(&errcode, indexnam);
                    if(!(errcode == 0))
                      return errcode;

                    else
                    {
                      if(!((1024 & (signed int)smcp->menuflg) == 0))
                        smcp->min_swatscor = (signed int)min_swatscor;

                      else
                      {
                        unsigned char nskip = (unsigned char)0;
                        unsigned char ktup;
                        ktup=hashTableGetKtupLen(smcp->htp, &nskip);
                        smcp->min_swatscor = ((signed int)ktup + (signed int)nskip) - 1;
                      }
                      if(!((4 & (signed int)smcp->menuflg) == 0))
                        hashTablePrintStats(stderr, smcp->htp);

                      return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
  }
}

// initMapOptions
// file menu.c line 1122
static signed int initMapOptions(struct _MenuOpt *menup)
{
  struct _MAPMENU *mp;
  signed int i;
  free(menup->paramp);
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _MAPMENU) /*112ul*/ , "menu.c", 1127);
  mp = (struct _MAPMENU *)return_value_ecalloc$1;
  if(mp == ((struct _MAPMENU *)NULL))
    return 2;

  else
    if(!((signed int)menup->subprog == 2))
    {
      if((signed int)menup->subprog == 4)
        goto __CPROVER_DUMP_L2;

      return 47;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      menup->paramp = (void *)mp;
      mp = (struct _MAPMENU *)menup->paramp;
      mp->oufmt.typ = (unsigned char)1;
      mp->oufmt.flags = (unsigned char)1;
      mp->inform = (unsigned char)1;
      mp->nthread = (signed short int)0;
      i = 0;
      for( ; !(i >= 4); i = i + 1)
        mp->penalties[(signed long int)i] = MENU_PENALTY_LST[(signed long int)i].val;
      mp->ncut = 10000;
      mp->maxhit = 100000;
      mp->mincover = MENU_DEFAULTS_MINCOVER;
      mp->minscore = (signed short int)18;
      mp->target_depth = (signed short int)500;
      mp->scorediff = (signed short int)0;
      mp->flags = (unsigned short int)(4 | 4096);
      mp->diskuse = (char)0;
      mp->oufilnam = (char *)(void *)0;
      mp->insfilnam = (char *)(void *)0;
      mp->tmpdirnam = (char *)(void *)0;
      mp->insert_range[(signed long int)0] = 0;
      mp->insert_range[(signed long int)1] = 500;
      mp->randseed_repeat = 0;
      mp->minbasq = (unsigned char)0;
      mp->minidentity = MENU_DEFAULTS_MINIDENTITY;
      mp->readskip = 0;
      mp->mapqmin = 0;
      mp->pairtyp = (unsigned char)0;
      return 0;
    }
}

// initREPSTR
// file report.c line 403
static signed int initREPSTR(struct _REPSTR *rsp, signed int blksz)
{
  if(rsp == ((struct _REPSTR *)NULL))
    return 47;

  else
  {
    if(!(blksz >= 1))
      blksz = 512;

    rsp->blksz = blksz;
    rsp->strl = (unsigned long int)0;
    rsp->n_alloc = (unsigned long int)0;
    void *return_value_ecalloc$1;
    return_value_ecalloc$1=ecalloc((unsigned long int)blksz, sizeof(char) /*1ul*/ , "report.c", 410);
    rsp->strp = (char *)return_value_ecalloc$1;
    if(rsp->strp == ((char *)NULL))
      return 2;

    else
    {
      rsp->n_alloc = (unsigned long int)blksz;
      rsp->strp[(signed long int)0] = (char)0;
      return 0;
    }
  }
}

// initRMAPINFO
// file rmap.c line 1027
static signed int initRMAPINFO(struct RMAPINFO_ *rmp, unsigned char min_basqval, unsigned int seq_start, unsigned int seq_end, const struct _SeqFastq *readp, const struct _HashTable *htp)
{
  signed int errcode;
  errcode=hashCollectHitInfo(rmp->hhiFp, (unsigned char)0, min_basqval, seq_start, seq_end, readp, htp);
  if(errcode == 0)
    errcode=hashCollectHitInfo(rmp->hhiRp, (unsigned char)1, min_basqval, seq_start, seq_end, readp, htp);

  return errcode;
}

// initRMAPINFOshort
// file rmap.c line 1046
static signed int initRMAPINFOshort(struct RMAPINFO_ *rmp, signed int maxhit_per_tuple, unsigned char min_basqval, const struct _SeqFastq *readp, const struct _HashTable *htp)
{
  signed int errcode;
  errcode=hashCollectHitInfoShort(rmp->hhiFp, (unsigned char)0, (unsigned int)maxhit_per_tuple, (unsigned int)16384, min_basqval, readp, htp);
  if(errcode == 0)
    errcode=hashCollectHitInfoShort(rmp->hhiRp, (unsigned char)1, (unsigned int)maxhit_per_tuple, (unsigned int)16384, min_basqval, readp, htp);

  return errcode;
}

// initRepeatFilter
// file hashhit.c line 342
static void initRepeatFilter(signed long int *tdrf)
{
  unsigned char i = (unsigned char)0;
  for( ; !((signed int)i >= 4); i = i + 1)
    tdrf[(signed long int)i] = (signed long int)(-((signed int)i) - 1);
}

// initSmaltOutput
// file smalt.c line 627
static signed int initSmaltOutput(void *op, const void *mp, signed short int threadno)
{
  signed int errcode = 0;
  struct _SmaltOutput *dop = (struct _SmaltOutput *)op;
  const struct _SmaltMapConst *mcp = (const struct _SmaltMapConst *)mp;
  dop->threadno = threadno;
  dop->writerp=reportCreateWriter(&errcode, mcp->oufilnam, mcp->outform, mcp->oumodflg, mcp->ssp, mcp->prognam, mcp->progversion, mcp->cmdlin_argv, mcp->cmdlin_narg);
  _Bool tmp_if_expr$1;
  if(errcode == 0)
    tmp_if_expr$1 = 4 == (signed int)mcp->subprogtyp ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    dop->isamp=insCreateSample(2048);
    if(dop->isamp == ((struct _InsSample *)NULL))
      errcode = 2;

  }

  else
    dop->isamp = (struct _InsSample *)(void *)0;
  if(errcode == 0)
  {
    dop->next_readno = (unsigned long int)0;
    dop->smcp = mcp;
  }

  return errcode;
}

// insAddSample
// file insert.h line 69
signed int insAddSample(struct _InsSample *pInsSample, signed int insertsiz)
{
  unsigned long int tmp_post$1;
  do
  {
    if(pInsSample->pSample->n >= pInsSample->pSample->n_alloc)
    {
      unsigned long int siz = (unsigned long int)((pInsSample->pSample->n + pInsSample->pSample->n_blksz) / pInsSample->pSample->n_blksz) * pInsSample->pSample->n_blksz;
      void *hp;
      hp=erealloc((void *)pInsSample->pSample->vp, siz * sizeof(signed int) /*4ul*/ , (unsigned long int)0, "insert.c", 210);
      if(hp == NULL)
        return 2;

      pInsSample->pSample->vp = (signed int *)hp;
      pInsSample->pSample->n_alloc = siz;
    }

    tmp_post$1 = pInsSample->pSample->n;
    pInsSample->pSample->n = pInsSample->pSample->n + 1ul;
    pInsSample->pSample->vp[(signed long int)tmp_post$1] = insertsiz;
  }
  while((_Bool)0);
  return 0;
}

// insCreateHisto
// file insert.c line 305
struct _InsHist * insCreateHisto(signed int iLen)
{
  struct _InsHist *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _InsHist) /*72ul*/ , "insert.c", 309);
  p = (struct _InsHist *)return_value_ecalloc$1;
  if(!(iLen >= 1))
    iLen = 128;

  _Bool tmp_if_expr$4;
  if(!(p == ((struct _InsHist *)NULL)))
  {
    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)(2 * iLen), sizeof(signed int) /*4ul*/ , "insert.c", 314);
    p->pCounts = (signed int *)return_value_ecalloc$2;
    void *return_value_ecalloc$3;
    return_value_ecalloc$3=ecalloc((unsigned long int)iLen, sizeof(double) /*8ul*/ , "insert.c", 315);
    p->pKernelBuf = (double *)return_value_ecalloc$3;
    if(!(p->pCounts == ((signed int *)NULL)))
      tmp_if_expr$4 = p->pKernelBuf != ((double *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      p->pSmoothCounts = p->pCounts + (signed long int)iLen;
      p->iSpan = iLen;
      p->iScalFac = 1;
      p->status = (unsigned char)0;
    }

    else
    {
      insDeleteHisto(p);
      p = (struct _InsHist *)(void *)0;
    }
  }

  return p;
}

// insCreateSample
// file insert.h line 52
struct _InsSample * insCreateSample(signed int blksz)
{
  struct _InsSample *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _InsSample) /*16ul*/ , "insert.c", 170);
  p = (struct _InsSample *)return_value_ecalloc$1;
  _Bool tmp_if_expr$4;
  void *return_value_ecalloc$3;
  if(!(p == ((struct _InsSample *)NULL)))
  {
    do
    {
      unsigned long int siz = (unsigned long int)((unsigned long int)(blksz < 1) != 0ul ? 256 : blksz);
      void *return_value_ecalloc$2;
      return_value_ecalloc$2=ecalloc((unsigned long int)1, sizeof(struct V_int32_t_) /*32ul*/ , "insert.c", 172);
      p->pSample = (struct V_int32_t_ *)return_value_ecalloc$2;
      if(!(p->pSample == ((struct V_int32_t_ *)NULL)))
      {
        return_value_ecalloc$3=ecalloc(siz, sizeof(signed int) /*4ul*/ , "insert.c", 172);
        p->pSample->vp = (signed int *)return_value_ecalloc$3;
        tmp_if_expr$4 = (signed int *)(void *)0 != p->pSample->vp ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        p->pSample->n_blksz = siz;
        p->pSample->n_alloc = p->pSample->n_blksz;
        p->pSample->n = (unsigned long int)0;
      }

      else
        do
        {
          if(!(p->pSample == ((struct V_int32_t_ *)NULL)))
            free((void *)p->pSample->vp);

          free((void *)p->pSample);
          p->pSample = (struct V_int32_t_ *)(void *)0;
        }
        while((_Bool)0);
    }
    while((_Bool)0);
    if(p->pSample == ((struct V_int32_t_ *)NULL))
    {
      insDeleteSample(p);
      p = (struct _InsSample *)(void *)0;
    }

    else
      p->readival = 0;
  }

  return p;
}

// insDeleteHisto
// file insert.h line 100
void insDeleteHisto(struct _InsHist *p)
{
  if(!(p == ((struct _InsHist *)NULL)))
  {
    free((void *)p->pCounts);
    free((void *)p->pKernelBuf);
  }

  free((void *)p);
}

// insDeleteSample
// file insert.h line 57
void insDeleteSample(struct _InsSample *pInsSample)
{
  if(!(pInsSample == ((struct _InsSample *)NULL)))
    do
    {
      if(!(pInsSample->pSample == ((struct V_int32_t_ *)NULL)))
        free((void *)pInsSample->pSample->vp);

      free((void *)pInsSample->pSample);
      pInsSample->pSample = (struct V_int32_t_ *)(void *)0;
    }
    while((_Bool)0);

  free((void *)pInsSample);
}

// insGetHistoCount
// file insert.c line 531
signed int insGetHistoCount(signed int *totnum, signed int insiz, unsigned char is_smooth, const struct _InsHist *pHist)
{
  signed int idx;
  signed int rv = 0;
  _Bool tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if(insiz >= pHist->iInSizLo)
  {
    if(pHist->iInSizHi >= insiz)
    {
      if(!(insiz >= pHist->iInSizLo))
        idx = 0;

      else
        if(!(pHist->iInSizHi >= insiz))
          idx = pHist->iSpan - 1;

        else
        {
          idx = (insiz - pHist->iInSizLo) / pHist->iScalFac;
          if(idx >= pHist->iSpan)
            idx = pHist->iSpan - 1;

        }
      if(!(is_smooth == 0))
        tmp_if_expr$1 = (signed int)pHist->status == 2 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = pHist->pSmoothCounts[(signed long int)idx];

      else
        tmp_if_expr$2 = pHist->pCounts[(signed long int)idx];
      rv = tmp_if_expr$2;
    }

  }

  if(!(totnum == ((signed int *)NULL)))
    *totnum = (signed int)pHist->iNum;

  return rv;
}

// insGetHistoCountCumulative
// file insert.h line 136
signed int insGetHistoCountCumulative(signed int *totnum, signed int insiz, unsigned char is_smooth, const struct _InsHist *pHist)
{
  signed int i;
  signed int idx;
  signed int ccount = 0;
  _Bool tmp_if_expr$1;
  if(!(is_smooth == 0))
    tmp_if_expr$1 = (signed int)pHist->status == 2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  is_smooth = (unsigned char)tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if(insiz >= pHist->iInSizLo)
  {
    if(pHist->iInSizHi >= insiz)
    {
      if(!(insiz >= pHist->iInSizLo))
        idx = 0;

      else
        if(!(pHist->iInSizHi >= insiz))
          idx = pHist->iSpan - 1;

        else
        {
          idx = (insiz - pHist->iInSizLo) / pHist->iScalFac;
          if(idx >= pHist->iSpan)
            idx = pHist->iSpan - 1;

        }
      i = 0;
      for( ; idx >= i; i = i + 1)
      {
        if(!(is_smooth == 0))
          tmp_if_expr$2 = pHist->pSmoothCounts[(signed long int)i];

        else
          tmp_if_expr$2 = pHist->pCounts[(signed long int)i];
        ccount = ccount + tmp_if_expr$2;
      }
    }

  }

  if(!(totnum == ((signed int *)NULL)))
    *totnum = (signed int)pHist->iNum;

  return ccount;
}

// insGetHistoData
// file insert.h line 144
unsigned long int insGetHistoData(signed int *lo, signed int *hi, signed int *n_bins, const struct _InsHist *pHist)
{
  if(!(lo == ((signed int *)NULL)))
    *lo = pHist->iInSizLo;

  if(!(hi == ((signed int *)NULL)))
    *hi = pHist->iInSizHi;

  if(!(n_bins == ((signed int *)NULL)))
    *n_bins = pHist->iSpan;

  return pHist->iNum;
}

// insGetHistoProb
// file insert.c line 516
double insGetHistoProb(signed int insiz, const struct _InsHist *pHist)
{
  double prob = 0.0;
  double tmp_if_expr$1;
  if(insiz >= pHist->iInSizLo)
  {
    if(pHist->iInSizHi >= insiz)
    {
      if(pHist->iNum >= 1ul)
      {
        signed int idx = (signed int)(insiz - pHist->iInSizLo) / pHist->iScalFac;
        if((signed int)pHist->status == 2)
          tmp_if_expr$1 = (double)pHist->pSmoothCounts[(signed long int)idx];

        else
          tmp_if_expr$1 = (double)pHist->pCounts[(signed long int)idx];
        prob = tmp_if_expr$1;
        prob = prob / (double)pHist->iNum;
      }

    }

  }

  return prob;
}

// insGetHistoQuartiles
// file insert.c line 567
signed int insGetHistoQuartiles(signed int *qlo, signed int *qhi, const struct _InsHist *pHist)
{
  if(!(qlo == ((signed int *)NULL)))
    *qlo = pHist->quart_lo;

  if(!(qhi == ((signed int *)NULL)))
    *qhi = pHist->quart_hi;

  return pHist->median;
}

// insGetSample
// file insert.h line 81
unsigned long int insGetSample(signed int **pSample, signed int *readival, const struct _InsSample *pInsSample)
{
  if(!(pSample == ((signed int **)NULL)))
    *pSample = pInsSample->pSample->vp;

  if(!(readival == ((signed int *)NULL)))
    *readival = pInsSample->readival;

  return pInsSample->pSample->n;
}

// insIsInSample
// file insert.c line 215
signed int insIsInSample(const struct _InsSample *pInsSample, unsigned long int readno)
{
  _Bool tmp_if_expr$1;
  if(pInsSample == ((const struct _InsSample *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = readno % (unsigned long int)pInsSample->readival == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// insMakeHistoFromSample
// file insert.h line 96
struct _InsHist * insMakeHistoFromSample(const struct _InsSample *pInsSample)
{
  signed int med;
  signed int qlo;
  signed int qhi;
  signed int iRange;
  signed int scf;
  struct _InsHist *pInsHisto = (struct _InsHist *)(void *)0;
  signed int errcode;
  errcode=getSAMPLEQuartiles(&med, &qlo, &qhi, pInsSample->pSample);
  iRange = (qhi - qlo) * 3 * 2;
  if(errcode == 0)
  {
    signed int ns = (signed int)pInsSample->pSample->n;
    signed int nbins;
    double return_value_sqrt$1;
    return_value_sqrt$1=sqrt((double)ns);
    nbins = (signed int)((double)3 * return_value_sqrt$1);
    if(!(nbins >= 16))
      nbins = 16;

    else
      if(nbins >= 1029)
        nbins = 1028;

    scf = iRange / nbins;
    if(!(scf >= 1))
    {
      nbins = iRange;
      scf = 1;
    }

    else
      iRange = scf * nbins;
    pInsHisto=insCreateHisto(nbins);
    if(!(pInsHisto == ((struct _InsHist *)NULL)))
    {
      signed int i;
      signed int idx;
      signed int *p = pInsSample->pSample->vp;
      pInsHisto->iScalFac = scf;
      pInsHisto->iInSizLo = med - iRange / 2;
      pInsHisto->iInSizHi = (pInsHisto->iInSizLo + iRange) - 1;
      pInsHisto->median = med;
      pInsHisto->quart_lo = qlo;
      pInsHisto->quart_hi = qhi;
      idx = 0;
      for( ; !(idx >= pInsHisto->iSpan); idx = idx + 1)
        pInsHisto->pCounts[(signed long int)idx] = 0;
      i = 0;
      for( ; !(i >= ns); i = i + 1)
        if(p[(signed long int)i] >= pInsHisto->iInSizLo)
        {
          if(pInsHisto->iInSizHi >= p[(signed long int)i])
          {
            if(!(p[(signed long int)i] >= pInsHisto->iInSizLo))
              idx = 0;

            else
              if(!(pInsHisto->iInSizHi >= p[(signed long int)i]))
                idx = pInsHisto->iSpan - 1;

              else
              {
                idx = (p[(signed long int)i] - pInsHisto->iInSizLo) / pInsHisto->iScalFac;
                if(idx >= pInsHisto->iSpan)
                  idx = pInsHisto->iSpan - 1;

              }
            pInsHisto->pCounts[(signed long int)idx] = pInsHisto->pCounts[(signed long int)idx] + 1;
            pInsHisto->iNum = pInsHisto->iNum + 1ul;
          }

        }

      errcode=insSmoothHisto(pInsHisto);
      if(!(errcode == 0))
      {
        insDeleteHisto(pInsHisto);
        pInsHisto = (struct _InsHist *)(void *)0;
      }

    }

  }

  return pInsHisto;
}

// insPrintHisto
// file insert.h line 158
signed int insPrintHisto(struct _IO_FILE *fp, signed int linwidth, unsigned char is_smooth, const struct _InsHist *pHist)
{
  signed int errcode = 0;
  signed int i;
  signed int max_count;
  signed int range_min;
  signed int range_max;
  double wf;
  _Bool tmp_if_expr$1;
  if(pHist == ((const struct _InsHist *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    errcode=findInsHistMax(pHist, &max_count, &range_min, &range_max);
    tmp_if_expr$1 = errcode != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$3;
  signed int return_value_fputc$4;
  if(tmp_if_expr$1)
  {
    fprintf(fp, "# Histogram of insert sizes is empty.\n");
    return -1;
  }

  else
  {
    if(!(is_smooth == 0))
      tmp_if_expr$2 = (signed int)pHist->status == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    is_smooth = (unsigned char)tmp_if_expr$2;
    wf = (double)linwidth / (double)max_count;
    if(wf > 1.0)
      wf = 1.0;

    i = range_min;
    for( ; range_max >= i; i = i + 1)
    {
      signed int j;
      signed int col_idx;
      if(!(is_smooth == 0))
        tmp_if_expr$3 = pHist->pSmoothCounts[(signed long int)i];

      else
        tmp_if_expr$3 = pHist->pCounts[(signed long int)i];
      col_idx = (signed int)((double)tmp_if_expr$3 * wf);
      fprintf(fp, "#%5i ", (signed int)(pHist->iInSizLo + i * pHist->iScalFac));
      j = 0;
      for( ; !(j >= col_idx); j = j + 1)
      {
        return_value_fputc$4=fputc(42, fp);
        if(!(return_value_fputc$4 == 42))
          return 11;

      }
      fputc(10, fp);
    }
    return errcode;
  }
}

// insReadHisto
// file insert.h line 173
struct _InsHist * insReadHisto(signed int *errcode, const char *filnam)
{
  char linbufp[128l];
  unsigned char has_start;
  unsigned char has_end;
  signed int isiz;
  signed int count;
  signed int linctr;
  signed int qlo;
  signed int qhi;
  signed int med;
  signed int binnum;
  signed int scalfac;
  signed int insizlo;
  signed int insizhi;
  unsigned long long int totnum;
  unsigned long int slen;
  struct _InsHist *ihp = (struct _InsHist *)(void *)0;
  struct _IO_FILE *fp;
  fp=efopen(filnam, "r", "insert.c", 641);
  char *return_value_fgets$1;
  _Bool tmp_if_expr$4;
  signed int return_value_fscanf$3;
  char *return_value_fgets$5;
  signed int tmp_post$8;
  _Bool tmp_if_expr$9;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    *errcode = 50;
    return (struct _InsHist *)(void *)0;
  }

  else
  {
    *errcode = 0;
    has_end = (unsigned char)0;
    has_start = has_end;
    slen=strlen(IOFIL_KEY_START);
    do
    {
      return_value_fgets$1=fgets(linbufp, 128 - 1, fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      signed int return_value_strncmp$2;
      return_value_strncmp$2=strncmp(IOFIL_KEY_START, linbufp, slen);
      if(return_value_strncmp$2 == 0)
      {
        has_start = (unsigned char)1;
        break;
      }

    }
    while((_Bool)1);
    if(has_start == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_fscanf$3=fscanf(fp, IOFIL_KEY_FORMAT, &binnum, &scalfac, &insizlo, &insizhi, &totnum, &qlo, &med, &qhi);
      tmp_if_expr$4 = return_value_fscanf$3 != 8 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      *errcode = 33;
      efclose(fp, "insert.c", 661);
      return (struct _InsHist *)(void *)0;
    }

    else
    {
      ihp=insCreateHisto(binnum);
      if(ihp == ((struct _InsHist *)NULL))
      {
        *errcode = 2;
        efclose(fp, "insert.c", 667);
      }

      ihp->iScalFac = scalfac;
      ihp->iInSizLo = insizlo;
      ihp->iInSizHi = insizhi;
      ihp->median = med;
      ihp->quart_lo = qlo;
      ihp->quart_hi = qhi;
      ihp->iNum = (unsigned long int)0;
      linctr = 0;
      slen=strlen(IOFIL_KEY_END);
      do
      {
        return_value_fgets$5=fgets(linbufp, 128 - 1, fp);
        if(return_value_fgets$5 == ((char *)NULL))
          break;

        signed int return_value_strncmp$6;
        return_value_strncmp$6=strncmp(IOFIL_KEY_END, linbufp, slen);
        if(return_value_strncmp$6 == 0)
        {
          has_end = (unsigned char)1;
          break;
        }

        signed int return_value_sscanf$7;
        return_value_sscanf$7=sscanf(linbufp, IOFIL_FORMAT, &isiz, &count);
        if(!(return_value_sscanf$7 == 2))
          break;

        if(!(isiz == linctr * scalfac + insizlo))
          break;

        if(linctr >= binnum)
          break;

        tmp_post$8 = linctr;
        linctr = linctr + 1;
        ihp->pCounts[(signed long int)tmp_post$8] = count;
        ihp->iNum = ihp->iNum + (unsigned long int)count;
      }
      while((_Bool)1);
      if(has_end == 0)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = ihp->iNum != totnum ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        *errcode = 33;
        efclose(fp, "insert.c", 696);
      }

      else
        *errcode=efclose(fp, "insert.c", 698);
      if(*errcode == 0)
        *errcode=insSmoothHisto(ihp);

      return ihp;
    }
  }
}

// insSeedHistoNormal
// file insert.c line 433
void insSeedHistoNormal(struct _InsHist *pHist, signed int mean, signed int std, signed int num)
{
  signed int i;
  signed int margin;
  signed int lo = mean - 3 * std;
  signed int hi = mean + 3 * std;
  double x;
  double y;
  double d = (double)((hi - lo) + 1) / (double)pHist->iSpan;
  double var2 = (double)2 * (double)std * (double)std;
  double norm;
  norm=sqrt(var2 * 3.14159265358979323846);
  if(d >= 1.0)
    pHist->iScalFac = (signed int)d;

  else
  {
    pHist->iScalFac = 1;
    margin = (signed int)((double)pHist->iSpan / d - (double)pHist->iSpan);
    lo = lo - margin / 2;
    hi = (lo + pHist->iSpan + margin) - 1;
  }
  pHist->iInSizLo = lo;
  pHist->iInSizHi = hi;
  i = 0;
  for( ; !(i >= pHist->iSpan); i = i + 1)
  {
    x = ((double)pHist->iInSizLo + d * (double)i) - (double)mean;
    double return_value_exp$1;
    return_value_exp$1=exp((-x * x) / var2);
    y = return_value_exp$1 / norm;
    pHist->pCounts[(signed long int)i] = (signed int)(y * (double)num + 0.4999);
  }
  pHist->iNum = (unsigned long int)num;
  pHist->status = (unsigned char)1;
}

// insSetSamplingInterval
// file insert.h line 61
void insSetSamplingInterval(struct _InsSample *pInsSample, unsigned long int nreads, signed int nrskip)
{
  unsigned long int n = nreads / (unsigned long int)4098;
  if(!(n >= 1ul))
    pInsSample->readival = 1;

  else
    if(n >= 2147483648ul)
      pInsSample->readival = 0x7fffffff;

    else
      pInsSample->readival = (signed int)n;
  if(!(nrskip >= pInsSample->readival))
  {
    if(nrskip >= 1)
      pInsSample->readival = nrskip;

  }

}

// insSmoothHisto
// file insert.c line 472
signed int insSmoothHisto(struct _InsHist *pHist)
{
  signed int errcode;
  signed int i;
  signed int th;
  signed int kbw;
  signed int iqr = 0;
  signed int tmp_post$1;
  if(!(pHist->iNum >= 2ul))
    return -1;

  else
  {
    if(pHist->iSpan >= 4)
    {
      signed int n = 0;
      signed int q = 0;
      unsigned int quart[3l];
      th = (signed int)(pHist->iNum / (unsigned long int)4);
      i = 0;
      for( ; !(q >= 3) && !(i >= pHist->iSpan); i = i + 1)
      {
        n = n + pHist->pCounts[(signed long int)i];
        if(!(th >= n))
        {
          tmp_post$1 = q;
          q = q + 1;
          quart[(signed long int)tmp_post$1] = (unsigned int)i;
          n = n - pHist->pCounts[(signed long int)i] / 2;
          th = (signed int)((pHist->iNum * (unsigned long int)q) / (unsigned long int)4);
        }

      }
      if(q >= 3)
        iqr = (signed int)(quart[(signed long int)2] - quart[(signed long int)0]);

    }

    kbw=calcKernelBandWidth((signed int)pHist->iNum, iqr);
    if(!(kbw >= 3))
      kbw = 3;

    errcode=smoothGauss(pHist->pSmoothCounts, pHist->pKernelBuf, kbw, pHist->pCounts, pHist->iSpan);
    if(errcode == 0)
      pHist->status = (unsigned char)2;

    return errcode;
  }
}

// insUpdateHisto
// file insert.c line 462
void insUpdateHisto(struct _InsHist *pHist, signed int insiz)
{
  signed int idx = (insiz - pHist->iInSizLo) / pHist->iScalFac;
  if(idx >= 0)
  {
    if(!(idx >= pHist->iSpan))
    {
      pHist->pCounts[(signed long int)idx] = pHist->pCounts[(signed long int)idx] + 1;
      pHist->iNum = pHist->iNum + 1ul;
    }

  }

}

// insWriteHisto
// file insert.h line 166
signed int insWriteHisto(struct _IO_FILE *fp, unsigned char is_smooth, const struct _InsHist *pHist)
{
  signed int i;
  signed int *cp;
  unsigned long int totnum = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  signed int *tmp_if_expr$2;
  if(pHist == ((const struct _InsHist *)NULL))
    return -1;

  else
  {
    if(!(is_smooth == 0))
      tmp_if_expr$1 = (signed int)pHist->status == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    is_smooth = (unsigned char)tmp_if_expr$1;
    if(!(is_smooth == 0))
      tmp_if_expr$2 = pHist->pSmoothCounts;

    else
      tmp_if_expr$2 = pHist->pCounts;
    cp = tmp_if_expr$2;
    i = 0;
    for( ; !(i >= pHist->iSpan); i = i + 1)
      totnum = totnum + (unsigned long int)cp[(signed long int)i];
    if(is_smooth == 0)
    {
      if(totnum == pHist->iNum)
        goto __CPROVER_DUMP_L8;

      return 47;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      fprintf(fp, "%s", (const void *)IOFIL_HEADER);
      fprintf(fp, "%s\n", (const void *)IOFIL_KEY_START);
      fprintf(fp, IOFIL_KEY_FORMAT, pHist->iSpan, pHist->iScalFac, pHist->iInSizLo, pHist->iInSizHi, (unsigned long long int)totnum, pHist->quart_lo, pHist->median, pHist->quart_hi);
      i = 0;
      for( ; !(i >= pHist->iSpan); i = i + 1)
        fprintf(fp, IOFIL_FORMAT, pHist->iInSizLo + i * pHist->iScalFac, cp[(signed long int)i]);
      fprintf(fp, "%s\n", (const void *)IOFIL_KEY_END);
      return 0;
    }
  }
}

// interValAppend
// file interval.h line 66
signed int interValAppend(struct V_IVAL_ *p, unsigned int lo, unsigned int hi, signed long int sx, unsigned short int flag)
{
  struct _IVAL *ivp;
  _Bool tmp_if_expr$3;
  void *return_value_ereallocp$1;
  _Bool tmp_if_expr$2;
  struct _IVAL *tmp_if_expr$5;
  unsigned long int tmp_post$4;
  if(!(hi >= lo))
    return 47;

  else
  {
    if(!(p->n >= p->n_alloc))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_ereallocp$1=ereallocp((void **)&p->vp, (unsigned long int)((p->n + p->n_blksz) / p->n_blksz) * p->n_blksz * sizeof(struct _IVAL) /*24ul*/ , "interval.c", 105);
      if(!(return_value_ereallocp$1 == NULL))
      {
        p->n_alloc = (unsigned long int)((p->n + p->n_blksz) / p->n_blksz) * p->n_blksz;
        tmp_if_expr$2 = p->n_alloc > p->n ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      tmp_post$4 = p->n;
      p->n = p->n + 1ul;
      tmp_if_expr$5 = p->vp + (signed long int)tmp_post$4;
    }

    else
      tmp_if_expr$5 = (struct _IVAL *)(void *)0;
    ivp = tmp_if_expr$5;
    if(ivp == ((struct _IVAL *)NULL))
      return 2;

    else
    {
      ivp->hi = hi;
      ivp->lo = lo;
      ivp->sx = sx;
      ivp->flg = flag;
      if(p->n >= 2147483648ul)
        return 48;

      else
        return 0;
    }
  }
}

// interValBlank
// file interval.h line 63
void interValBlank(struct V_IVAL_ *p)
{
  p->n = (unsigned long int)0;
}

// interValCreate
// file interval.h line 57
struct V_IVAL_ * interValCreate(signed int blksz)
{
  struct V_IVAL_ *p;
  if(!(blksz >= 1))
    blksz = 256;

  _Bool tmp_if_expr$3;
  void *return_value_ecalloc$2;
  do
  {
    unsigned long int siz = (unsigned long int)((unsigned long int)(blksz < 1) != 0ul ? 256 : blksz);
    void *return_value_ecalloc$1;
    return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct V_IVAL_) /*32ul*/ , "interval.c", 84);
    p = (struct V_IVAL_ *)return_value_ecalloc$1;
    if(!(p == ((struct V_IVAL_ *)NULL)))
    {
      return_value_ecalloc$2=ecalloc(siz, sizeof(struct _IVAL) /*24ul*/ , "interval.c", 84);
      p->vp = (struct _IVAL *)return_value_ecalloc$2;
      tmp_if_expr$3 = (struct _IVAL *)(void *)0 != p->vp ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      p->n_blksz = siz;
      p->n_alloc = p->n_blksz;
      p->n = (unsigned long int)0;
    }

    else
      do
      {
        if(!(p == ((struct V_IVAL_ *)NULL)))
          free((void *)p->vp);

        free((void *)p);
        p = (struct V_IVAL_ *)(void *)0;
      }
      while((_Bool)0);
  }
  while((_Bool)0);
  return p;
}

// interValDelete
// file interval.h line 60
void interValDelete(struct V_IVAL_ *p)
{
  do
  {
    if(!(p == ((struct V_IVAL_ *)NULL)))
      free((void *)p->vp);

    free((void *)p);
    p = (struct V_IVAL_ *)(void *)0;
  }
  while((_Bool)0);
}

// interValGet
// file interval.h line 80
signed int interValGet(unsigned int *lo, unsigned int *hi, signed long int *sx, unsigned short int *flg, signed int idx, const struct V_IVAL_ *p)
{
  const struct _IVAL *ivp;
  struct _IVAL *tmp_if_expr$1;
  if(!((unsigned long int)idx >= p->n))
    tmp_if_expr$1 = p->vp + (signed long int)idx;

  else
    tmp_if_expr$1 = (struct _IVAL *)(void *)0;
  ivp = tmp_if_expr$1;
  if(ivp == ((const struct _IVAL *)NULL))
    return 29;

  else
    if(!(ivp->hi >= ivp->lo))
      return 47;

    else
    {
      if(!(lo == ((unsigned int *)NULL)))
        *lo = ivp->lo;

      if(!(hi == ((unsigned int *)NULL)))
        *hi = ivp->hi;

      if(!(sx == ((signed long int *)NULL)))
        *sx = ivp->sx;

      if(!(flg == ((unsigned short int *)NULL)))
        *flg = ivp->flg;

      return 0;
    }
}

// interValNum
// file interval.h line 77
signed int interValNum(const struct V_IVAL_ *p)
{
  return (signed int)p->n;
}

// interValPrune
// file interval.h line 74
void interValPrune(struct V_IVAL_ *p)
{
  signed int i;
  signed int j;
  signed int niv = (signed int)p->n;
  struct _IVAL *ivp = p->vp;
  _Bool tmp_if_expr$1;
  if(niv >= 1)
  {
    qsort((void *)ivp, (unsigned long int)niv, sizeof(struct _IVAL) /*24ul*/ , cmpIVAL);
    i = 0;
    j = 1;
    for( ; !(j >= niv); j = j + 1)
    {
      if((ivp + (signed long int)j)->sx == (ivp + (signed long int)i)->sx)
        tmp_if_expr$1 = (ivp + (signed long int)j)->lo <= (ivp + (signed long int)i)->hi ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(!((ivp + (signed long int)i)->hi >= (ivp + (signed long int)j)->hi))
          (ivp + (signed long int)i)->hi = (ivp + (signed long int)j)->hi;

      }

      else
      {
        i = i + 1;
        if(!(i >= j))
          ivp[(signed long int)i] = ivp[(signed long int)j];

      }
    }
    p->n = (unsigned long int)(i + 1);
  }

}

// isIdenticalResult
// file results.c line 556
static signed int isIdenticalResult(const struct _RESULT *ap, const struct _RESULT *bp)
{
  _Bool tmp_if_expr$1;
  if(!(ap->s_start == bp->s_start))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ap->s_end != bp->s_end ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ap->q_start != bp->q_start ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = ap->q_end != bp->q_end ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = ap->swatscor != bp->swatscor ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = ap->sidx != bp->sidx ? (_Bool)1 : (_Bool)0;
  return tmp_if_expr$5 ? 0 : 1;
}

// labelComplementarySegments
// file results.c line 707
static signed int labelComplementarySegments(struct _ResultSet *rsp, const signed short int min_overlap_percent)
{
  signed int errcode = 0;
  struct _RESULT **rspp = rsp->sortr;
  signed short int i;
  signed short int i_start;
  signed short int n = (signed short int)((unsigned long int *)rspp)[(signed long int)-1];
  const double min_overlap_frac = (double)min_overlap_percent / (double)100;
  if(!((signed int)n >= 1))
    return 0;

  else
    if((signed int)n >= 2)
    {
      if((4 & (signed int)rsp->status) == 0)
        return 47;

    }

  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)n); i = i + 1)
    rspp[(signed long int)i]->qsegx = (signed short int)-1;
  i_start = (signed short int)0;
  rsp->qsegno = (signed short int)0;
  _Bool tmp_if_expr$1;
  do
  {
    struct _RESULT *r1p = rspp[(signed long int)i_start];
    unsigned int l1 = r1p->q_end - r1p->q_start;
    r1p->qsegx = rsp->qsegno;
    if((signed int)i_start >= 0x7fff)
      return 48;

    i = (signed short int)((signed int)i_start + 1);
    i_start = (signed short int)0;
    for( ; !((signed int)i >= (signed int)n); i = i + 1)
    {
      struct _RESULT *r2p = rspp[(signed long int)i];
      if(!((signed int)r2p->qsegx >= 0))
      {
        unsigned int l2 = r2p->q_end - r2p->q_start;
        unsigned int min_overlap = (unsigned int)((double)(l1 < l2 ? l1 : l2) * min_overlap_frac);
        if(!(r1p->q_start + min_overlap >= r2p->q_end))
          tmp_if_expr$1 = r2p->q_start + min_overlap < r1p->q_end ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          r2p->qsegx = rsp->qsegno;

        else
          if((signed int)i_start == 0)
            i_start = i;

      }

    }
    if((signed int)rsp->qsegno == 0x7fff)
      errcode = 48;

    rsp->qsegno = rsp->qsegno + 1;
  }
  while(!((signed int)i_start == 0));
  if(errcode == 0)
  {
    errcode=sortBySegmentAndSWscor(rsp);
    if(errcode == 0)
      rsp->status = rsp->status | (unsigned char)8;

  }

  return errcode;
}

// loadArgBlock
// file smalt.c line 930
static signed int loadArgBlock(struct _ErrMsg *errmsgp, void *thargp, void *bufargp)
{
  signed int errcode = 0;
  signed short int i;
  struct _SmaltInput *inp = (struct _SmaltInput *)thargp;
  struct SmaltArgBlock_ *blockp = (struct SmaltArgBlock_ *)bufargp;
  /* assertion bufargp != ((void *)0) */
  assert(bufargp != (void *)0);
  blockp->n_iobf = (signed short int)0;
  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)blockp->n_alloc); i = i + 1)
  {
    errcode=loadIOBuffArg(errmsgp, inp, blockp->iobfp + (signed long int)i);
    if(!(errcode == 0))
      break;

  }
  blockp->n_iobf = i;
  return 10 == errcode && (signed int)i > 0 ? 0 : errcode;
}

// loadIOBuffArg
// file smalt.c line 795
static signed int loadIOBuffArg(struct _ErrMsg *errmsgp, struct _SmaltInput *inp, struct _SmaltIOBuffArg *argp)
{
  signed int errcode = 0;
  /* assertion inp */
  assert(inp != ((struct _SmaltInput *)NULL));
  /* assertion argp */
  assert(argp != ((struct _SmaltIOBuffArg *)NULL));
  errcode=infmtRead(inp->ifrp, argp->readp, argp->matep, &argp->isPaired);
  if(!(errcode == 0) && !(errcode == 10))
    errMsgAdd(errmsgp, "", "smalt.c", 807, errcode, (unsigned char)2);

  while(errcode == 0)
  {
    if(!(inp->rival >= 1))
      break;

    if(inp->pctr % (unsigned long int)inp->rival == 0ul)
      break;

    errcode=infmtRead(inp->ifrp, argp->readp, argp->matep, &argp->isPaired);
    if(errcode == 0)
    {
      if(!(argp->isPaired == 0))
        inp->pctr = inp->pctr + 1ul;

      inp->rctr = inp->rctr + 1ul;
    }

  }
  argp->readno = inp->rctr;
  argp->isiz = 0;
  argp->pairflg = (unsigned char)0;
  reportBlank(argp->rep);
  if(errcode == 0)
  {
    if(!(argp->isPaired == 0))
      inp->pctr = inp->pctr + 1ul;

    inp->rctr = inp->rctr + 1ul;
  }

  return errcode;
}

// main
// file smalt.c line 1482
signed int main(signed int argc, char **argv)
{
  signed int errcode = -1;
  signed long int time_start;
  signed long int time_stop;
  struct _MenuOpt *menup;
  menup=menuCreate();
  struct _ErrMsg *errmsg = ((struct _ErrMsg *)NULL);
  errmsg=errMsgCreate("smalt.c", 1489);
  if(menup == ((struct _MenuOpt *)NULL))
    errMsgAdd(errmsg, "", "smalt.c", 1492, 2, (unsigned char)2);

  errcode=menuParseCommandLine(menup, argc, argv);
  if(errcode == 0)
  {
    char return_value_menuGetSubProgTyp$1;
    return_value_menuGetSubProgTyp$1=menuGetSubProgTyp(menup);
    switch((signed int)return_value_menuGetSubProgTyp$1)
    {
      case 1:
      {
        time(&time_start);
        buildHashIndex(errmsg, menup);
        time(&time_stop);
        menuPrintWallClockTime(stderr, time_start, time_stop, (const char *)(void *)0);
        break;
      }
      case 3:
      {
        errcode=checkReads(errmsg, menup);
        if(errcode == 76)
          errcode = 0;

        break;
      }
      case 4:

      case 2:
      {
        time(&time_start);
        mapReads(errmsg, menup);
        time(&time_stop);
        menuPrintWallClockTime(stderr, time_start, time_stop, (const char *)(void *)0);
        break;
      }
      case 5:
        break;
      case 6:
        break;
      default:
        errMsgAdd(errmsg, "unknown subprogram", "smalt.c", 1528, 31, (unsigned char)2);
    }
  }

  if(!(errcode == 0) && !(errcode == 51))
    errMsgAdd(errmsg, "", "smalt.c", 1533, errcode, (unsigned char)2);

  menuDelete(menup);
  errMsgEnd(errmsg);
  errmsg = (struct _ErrMsg *)(void *)0;
  return errcode;
}

// make3BitMangledCodec
// file sequence.c line 287
static signed int make3BitMangledCodec(struct _SeqCodec *codp)
{
  signed int i;
  signed int offs;
  unsigned char cu;
  unsigned char a;
  codp->typ = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(CODEC_ALPHABET);
  codp->alphlen = (unsigned char)return_value_strlen$1;
  _Bool tmp_if_expr$3;
  if((signed int)codp->alphlen >= 8)
    return 47;

  else
  {
    strcpy(codp->alphabet, CODEC_ALPHABET);
    i = 1;
    for( ; !(i >= 256); i = i + 1)
    {
      signed int return_value_toupper$2;
      return_value_toupper$2=toupper(i);
      cu = (unsigned char)return_value_toupper$2;
      if((signed int)cu == 85)
        cu = (unsigned char)84;

      offs = ((signed int)cu - (signed int)65) + 1;
      if(offs >= 1 && !(offs >= 32))
      {
        a = (unsigned char)0;
        do
        {
          if(!((signed int)a >= 4))
            tmp_if_expr$3 = (signed int)cu != (signed int)codp->alphabet[(signed long int)a] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          a = a + 1;
        }
        while((_Bool)1);
        if((signed int)a >= 4)
          a = (unsigned char)5;

        else
          codp->codtab_complement[(signed long int)(~((signed int)a) & 3)] = (unsigned char)((signed int)a + ((signed int)(unsigned char)offs << 3));
        codp->codtab[(signed long int)i] = (unsigned char)((signed int)a + ((signed int)(unsigned char)offs << 3));
        codp->decodtab[(signed long int)codp->codtab[(signed long int)i]] = (char)cu;
      }

      else
      {
        a = (unsigned char)5;
        offs = ((signed int)codp->alphabet[(signed long int)a] - (signed int)codp->alphabet[(signed long int)0]) + 1;
        codp->codtab[(signed long int)i] = (unsigned char)((signed int)a + ((signed int)(unsigned char)offs << 3));
      }
    }
    codp->codtab[(signed long int)0] = (unsigned char)7;
    codp->decodtab[(signed long int)7] = (char)0;
    return 0;
  }
}

// makeMetaFromTrack
// file alignment.c line 628
static signed int makeMetaFromTrack(struct _ALIMETA *metap, struct _ALICPLX *cplxp, const struct _ALITRACK *tp, const struct _ALIBAND *bp, const struct _ScoreProfile *qp, const char *unprofiled_seq)
{
  signed int errcode = 0;
  unsigned char is_gap_open = (unsigned char)0;
  unsigned char nmatch;
  signed int i;
  signed int j;
  signed int s;
  signed int checksum_score = 0;
  const unsigned char *dp;
  signed char score_gap_open;
  signed char score_gap_ext;
  signed char * const *scorepp;
  scorepp=scoreGetProfile((signed short int *)(void *)0, (unsigned int *)(void *)0, &score_gap_open, &score_gap_ext, qp);
  struct _DiffStr * const dfsp = &metap->dfs;
  dfsp->len = 0;
  nmatch = (unsigned char)0;
  if(!(cplxp == ((struct _ALICPLX *)NULL)))
    blankALICPLX(cplxp);

  i = tp->max_i - bp->s_left;
  dp = (tp->bdp + (signed long int)(i * (bp->band_width - 1)) + (signed long int)tp->max_j) - (signed long int)bp->l_edge;
  i = tp->max_i;
  j = tp->max_j;
  i = tp->max_i;
  j = tp->max_j;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  do
  {
    if(i >= bp->s_left)
      tmp_if_expr$1 = j >= bp->q_left ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = *dp != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    if((signed int)*dp == 3)
    {
      s = (signed int)scorepp[(signed long int)((signed int)unprofiled_seq[(signed long int)i] & 7)][(signed long int)j];
      if(s >= 1)
      {
        if((signed int)nmatch >= 62)
        {
          if(dfsp->len >= dfsp->n_alloc)
          {
            errcode=diffStrRealloc(dfsp, dfsp->len + 1);
            if(!(errcode == 0))
              return errcode;

          }

          tmp_post$3 = dfsp->len;
          dfsp->len = dfsp->len + 1;
          dfsp->dstrp[(signed long int)tmp_post$3] = (unsigned char)(61 + ((signed int)(unsigned char)0 << 6));
          nmatch = nmatch - (unsigned char)61;
        }

        else
          nmatch = nmatch + 1;
      }

      else
      {
        if(dfsp->len >= dfsp->n_alloc)
        {
          errcode=diffStrRealloc(dfsp, dfsp->len + 1);
          if(!(errcode == 0))
            return errcode;

        }

        tmp_post$4 = dfsp->len;
        dfsp->len = dfsp->len + 1;
        dfsp->dstrp[(signed long int)tmp_post$4] = (unsigned char)((signed int)nmatch + ((signed int)(unsigned char)3 << 6));
        nmatch = (unsigned char)0;
      }
      checksum_score = checksum_score + s;
      if(!(cplxp == ((struct _ALICPLX *)NULL)))
        cplxp->countp[(signed long int)((signed int)unprofiled_seq[(signed long int)i] & 7)] = cplxp->countp[(signed long int)((signed int)unprofiled_seq[(signed long int)i] & 7)] + 1;

      is_gap_open = (unsigned char)0;
      dp = dp - (signed long int)bp->band_width;
      i = i - 1;
      j = j - 1;
    }

    else
    {
      if(!(is_gap_open == 0))
        checksum_score = checksum_score - (signed int)score_gap_ext;

      else
      {
        checksum_score = checksum_score - (signed int)score_gap_open;
        is_gap_open = (unsigned char)1;
      }
      if(!((1 & (signed int)*dp) == 0))
      {
        if(dfsp->len >= dfsp->n_alloc)
        {
          errcode=diffStrRealloc(dfsp, dfsp->len + 1);
          if(!(errcode == 0))
            return errcode;

        }

        tmp_post$5 = dfsp->len;
        dfsp->len = dfsp->len + 1;
        dfsp->dstrp[(signed long int)tmp_post$5] = (unsigned char)((signed int)nmatch + ((signed int)(unsigned char)1 << 6));
        nmatch = (unsigned char)0;
        dp = dp - (signed long int)(bp->band_width - 1);
        i = i - 1;
      }

      else
      {
        if((2 & (signed int)*dp) == 0)
          return 47;

        if(dfsp->len >= dfsp->n_alloc)
        {
          errcode=diffStrRealloc(dfsp, dfsp->len + 1);
          if(!(errcode == 0))
            return errcode;

        }

        tmp_post$6 = dfsp->len;
        dfsp->len = dfsp->len + 1;
        dfsp->dstrp[(signed long int)tmp_post$6] = (unsigned char)((signed int)nmatch + ((signed int)(unsigned char)2 << 6));
        nmatch = (unsigned char)0;
        dp = dp - 1l;
        j = j - 1;
      }
    }
  }
  while((_Bool)1);
  signed int tmp_post$7;
  signed int tmp_post$8;
  if(dfsp->len >= dfsp->n_alloc)
  {
    errcode=diffStrRealloc(dfsp, dfsp->len + 1);
    if(errcode == 0)
      goto __CPROVER_DUMP_L23;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L23:
    ;
    tmp_post$7 = dfsp->len;
    dfsp->len = dfsp->len + 1;
    dfsp->dstrp[(signed long int)tmp_post$7] = (unsigned char)((signed int)nmatch + ((signed int)(unsigned char)3 << 6));
    if(dfsp->len >= dfsp->n_alloc)
    {
      errcode=diffStrRealloc(dfsp, dfsp->len + 1);
      if(errcode == 0)
        goto __CPROVER_DUMP_L24;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L24:
      ;
      tmp_post$8 = dfsp->len;
      dfsp->len = dfsp->len + 1;
      dfsp->dstrp[(signed long int)tmp_post$8] = (unsigned char)(0 + ((signed int)(unsigned char)0 << 6));
      metap->nonprof_start = i + 1;
      metap->nonprof_end = tp->max_i;
      metap->prof_start = j + 1;
      metap->prof_end = tp->max_j;
      if(!(checksum_score == tp->max_scor))
        errcode = 44;

      else
        if(!(cplxp == ((struct _ALICPLX *)NULL)))
          errcode=scaleALICPLX(&checksum_score, tp->max_scor, cplxp);

      metap->score = checksum_score;
      return errcode;
    }
  }
}

// makeRMAPCANDfromSegment
// file rmap.c line 535
static signed int makeRMAPCANDfromSegment(struct RMAPCAND_ *cp, struct _SeqFastq *sqbufp, unsigned int *coverp, unsigned int qlen, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, unsigned int i, const struct _SegAliCands *sacp)
{
  signed int errcode;
  unsigned char bitflags;
  unsigned long int rs;
  unsigned long int re;
  errcode=segAliCandsCalcSegmentOffsets(&cp->qs, &cp->qe, &cp->rs, &cp->re, &cp->band_l, &cp->band_r, &cp->dqo, &cp->dro, &cp->sqidx, &bitflags, coverp, (signed short int)0, qlen, ssp, i, sacp);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(errcode == 0))
    return errcode;

  else
  {
    if(cp->qe >= 2147483648u)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = cp->re < cp->rs ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = cp->re - cp->rs > (unsigned long int)0x7fffffff ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 48;

    else
    {
      cp->flags = (unsigned short int)(((signed int)bitflags & 1) != 0 ? 1 : 0);
      cp->swscor = 0;
      re = cp->re;
      rs = cp->rs;
      if(cp->sqidx == -1l)
      {
        errcode=seqSetFetchSegment(sqbufp, &rs, &re, ssp, codecp);
        if(!(errcode == 0))
          return errcode;

        cp->rs = rs;
        cp->re = re;
      }

      else
      {
        errcode=seqSetFetchSegmentBySequence(sqbufp, cp->sqidx, (unsigned int)rs, (unsigned int)((re - rs) + (unsigned long int)1), ssp, codecp);
        if(!(errcode == 0))
          return errcode;

      }
      errcode=seqFastqEncode(sqbufp, codecp);
      return errcode;
    }
  }
}

// makeRMAPPROFfromRead
// file rmap.c line 976
static signed int makeRMAPPROFfromRead(struct RMAPPROF_ *prp, const struct _SeqFastq *readp, const struct _ScoreMatrix *scormtxp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  seqFastqBlank(prp->readRCp);
  errcode=seqFastqAppendSegment(prp->readRCp, readp, (unsigned int)0, (unsigned int)0, (char)1, codecp);
  if(errcode == 0)
    errcode=scoreMakeProfileFromSequence(prp->scorprofp, readp, scormtxp);

  if(errcode == 0)
    errcode=scoreMakeProfileFromSequence(prp->scorprofRCp, prp->readRCp, scormtxp);

  return errcode;
}

// makeSeedsFromHits
// file segment.c line 455
static signed int makeSeedsFromHits(struct _SEED$0 **seedr, struct _HITREGION * const idxr, signed int reg_start, signed int nreg, const struct _HashHitList *hhlp)
{
  unsigned char ktup;
  unsigned char nskip;
  signed int s;
  unsigned int lastq;
  unsigned int qo;
  unsigned int qoffs;
  unsigned int i;
  unsigned int j;
  unsigned int end_idx;
  struct _SEED$0 *sdp;
  unsigned long int shift;
  const unsigned long int *shdat;
  shdat=hashGetHitListData((signed int *)(void *)0, (char *)(void *)0, (unsigned int *)(void *)0, &ktup, &nskip, (const char **)(void *)0, hhlp);
  if(nreg == 0)
  {
    ((unsigned long int *)*seedr)[(signed long int)-1] = (unsigned long int)0;
    reg_start = 0;
    nreg = (signed int)((unsigned long int *)idxr)[(signed long int)-1];
  }

  s = reg_start;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  for( ; !(s >= nreg); s = s + 1)
  {
    i = (idxr + (signed long int)s)->idx;
    end_idx = i + (unsigned int)(idxr + (signed long int)s)->num;
    (idxr + (signed long int)s)->idx = (unsigned int)((unsigned long int *)*seedr)[(signed long int)-1];
    for( ; !(i >= end_idx); i = j)
    {
      if(((unsigned long int *)*seedr)[-1l] >= ((unsigned long int *)*seedr)[-2l])
      {
        void *return_value_arrayRealloc$1;
        return_value_arrayRealloc$1=arrayRealloc((void *)*seedr, (unsigned long int)0, (char)0, "segment.c", 494);
        sdp = (struct _SEED$0 *)return_value_arrayRealloc$1;
        if(!(sdp == ((struct _SEED$0 *)NULL)))
        {
          *seedr = sdp;
          tmp_post$2 = ((unsigned long int *)*seedr)[(signed long int)-1];
          ((unsigned long int *)*seedr)[(signed long int)-1] = ((unsigned long int *)*seedr)[(signed long int)-1] + 1ul;
          sdp = *seedr + (signed long int)tmp_post$2;
        }

      }

      else
      {
        tmp_post$3 = ((unsigned long int *)*seedr)[(signed long int)-1];
        ((unsigned long int *)*seedr)[(signed long int)-1] = ((unsigned long int *)*seedr)[(signed long int)-1] + 1ul;
        sdp = *seedr + (signed long int)tmp_post$3;
      }
      if(sdp == ((struct _SEED$0 *)NULL))
        return 2;

      sdp->sqo = shdat[(signed long int)i];
      shift = sdp->sqo & ~((unsigned long int)2147483647);
      qoffs = (unsigned int)(sdp->sqo & (unsigned long int)2147483647);
      lastq = qoffs + (unsigned int)ktup;
      j = i + (unsigned int)1;
      for( ; !(j >= end_idx); j = j + 1u)
      {
        if(!((18446744071562067968ul & shdat[(signed long int)j]) == shift))
          break;

        qo = (unsigned int)(shdat[(signed long int)j] & (unsigned long int)2147483647);
        if(!((qo + -qoffs) % (unsigned int)nskip == 0u) || !(lastq >= qo))
          break;

        lastq = qo + (unsigned int)ktup;
      }
      sdp->len = (signed int)(lastq - qoffs);
    }
    (idxr + (signed long int)s)->num = (signed int)(((unsigned long int *)*seedr)[(signed long int)-1] - (unsigned long int)(idxr + (signed long int)s)->idx);
  }
  return 0;
}

// makeSegmentsFromSeeds
// file segment.c line 535
static signed int makeSegmentsFromSeeds(struct _SEGMENT **segmr, unsigned int *maxcover, struct _HITREGION * const hregr, unsigned int reg_start, unsigned int nreg, struct _SEED$0 * const seedr, unsigned char nskip)
{
  unsigned int r;
  unsigned int i;
  unsigned int j;
  unsigned int end_i;
  unsigned int d;
  struct _SEGMENT *sgp;
  unsigned int qoffs;
  unsigned long int shift;
  if(nreg == 0u)
  {
    ((unsigned long int *)*segmr)[(signed long int)-1] = (unsigned long int)0;
    reg_start = (unsigned int)0;
    nreg = (unsigned int)((unsigned long int *)hregr)[(signed long int)-1];
  }

  *maxcover = (unsigned int)0;
  r = reg_start;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  _Bool tmp_if_expr$4;
  for( ; !(r >= nreg); r = r + 1u)
  {
    i = (hregr + (signed long int)r)->idx;
    end_i = i + (unsigned int)(hregr + (signed long int)r)->num;
    (hregr + (signed long int)r)->idx = (unsigned int)((unsigned long int *)*segmr)[(signed long int)-1];
    (hregr + (signed long int)r)->num = 0;
    for( ; !(i >= end_i); i = j)
    {
      if(((unsigned long int *)*segmr)[-1l] >= ((unsigned long int *)*segmr)[-2l])
      {
        void *return_value_arrayRealloc$1;
        return_value_arrayRealloc$1=arrayRealloc((void *)*segmr, (unsigned long int)0, (char)0, "segment.c", 559);
        sgp = (struct _SEGMENT *)return_value_arrayRealloc$1;
        if(!(sgp == ((struct _SEGMENT *)NULL)))
        {
          *segmr = sgp;
          tmp_post$2 = ((unsigned long int *)*segmr)[(signed long int)-1];
          ((unsigned long int *)*segmr)[(signed long int)-1] = ((unsigned long int *)*segmr)[(signed long int)-1] + 1ul;
          sgp = *segmr + (signed long int)tmp_post$2;
        }

      }

      else
      {
        tmp_post$3 = ((unsigned long int *)*segmr)[(signed long int)-1];
        ((unsigned long int *)*segmr)[(signed long int)-1] = ((unsigned long int *)*segmr)[(signed long int)-1] + 1ul;
        sgp = *segmr + (signed long int)tmp_post$3;
      }
      if(sgp == ((struct _SEGMENT *)NULL))
        return 2;

      (hregr + (signed long int)r)->num = (hregr + (signed long int)r)->num + 1;
      sgp->ix = i;
      sgp->cover = (unsigned int)(seedr + (signed long int)i)->len;
      shift = (seedr + (signed long int)i)->sqo & ~((unsigned long int)2147483647);
      qoffs = (unsigned int)((seedr + (signed long int)i)->sqo & (unsigned long int)2147483647);
      j = i + (unsigned int)1;
      for( ; !(j >= end_i); j = j + 1u)
      {
        if(!((18446744071562067968ul & (seedr + (signed long int)j)->sqo) == shift))
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (((seedr + (signed long int)j)->sqo & (unsigned long int)2147483647) - (unsigned long int)qoffs) % (unsigned long int)nskip != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
          break;

        sgp->cover = sgp->cover + (unsigned int)(seedr + (signed long int)j)->len;
      }
      d = j - i;
      if(d >= 2147483648u)
        return 48;

      sgp->nseed = (signed int)d;
      if(!(*maxcover >= sgp->cover))
        *maxcover = sgp->cover;

    }
  }
  return 0;
}

// makeStripedProfileFromSequence
// file score.c line 438
static signed int makeStripedProfileFromSequence(struct _ScoreProfile *app, const char *seq_basp, unsigned int length, const struct _ScoreMatrix *amp)
{
  unsigned long int len;
  unsigned long int n_alloc_striped;
  unsigned long int lenBYT = (unsigned long int)(((signed int)app->mod & 2) != 0 ? ((length + (unsigned int)16) - (unsigned int)1) / (unsigned int)16 : (unsigned int)0);
  app->striped_shortp = ((__gcc_v2di *)NULL);
  app->striped_bytep = app->striped_shortp;
  len = lenBYT + (unsigned long int)(((signed int)app->mod & 4) != 0 ? ((length + (unsigned int)8) - (unsigned int)1) / (unsigned int)8 : (unsigned int)0);
  n_alloc_striped = (unsigned long int)1 + len * (unsigned long int)app->alphabetsiz;
  if(!((2 & (signed int)app->mod) == 0))
  {
    if(!((4 & (signed int)app->mod) == 0))
      n_alloc_striped = n_alloc_striped + (unsigned long int)1;

  }

  n_alloc_striped = n_alloc_striped * sizeof(__gcc_v2di) /*16ul*/ ;
  if(!(app->striped_nalloc >= n_alloc_striped))
  {
    void *hp;
    n_alloc_striped = ((n_alloc_striped + (unsigned long int)app->blocksiz) - (unsigned long int)1) / (unsigned long int)app->blocksiz;
    n_alloc_striped = n_alloc_striped * (unsigned long int)app->blocksiz;
    if(app->striped_datap == NULL)
      hp=emalloc(n_alloc_striped, "score.c", 496);

    else
      hp=erealloc(app->striped_datap, n_alloc_striped * 1ul, (unsigned long int)0, "score.c", 498);
    if(hp == NULL)
      return 2;

    app->striped_datap = hp;
    app->striped_nalloc = n_alloc_striped;
  }

  if(!((2 & (signed int)app->mod) == 0))
  {
    app->striped_bytep = (__gcc_v2di *)((unsigned long int)app->striped_datap + (unsigned long int)15 & ~((unsigned long int)15));
    signed char return_value_scoreMatrixGetMinSubstScore$1;
    return_value_scoreMatrixGetMinSubstScore$1=scoreMatrixGetMinSubstScore(amp);
    app->bias = (signed short int)return_value_scoreMatrixGetMinSubstScore$1;
    if(!((4 & (signed int)app->mod) == 0))
      app->striped_shortp = app->striped_bytep + (signed long int)(lenBYT * (unsigned long int)app->alphabetsiz);

  }

  else
    if(!((4 & (signed int)app->mod) == 0))
      app->striped_shortp = (__gcc_v2di *)((unsigned long int)app->striped_datap + (unsigned long int)15 & ~((unsigned long int)15));

  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  if(!((2 & (signed int)app->mod) == 0))
  {
    signed short int makeStripedProfileFromSequence$$1$$4$$i;
    unsigned int makeStripedProfileFromSequence$$1$$4$$segsiz;
    unsigned int makeStripedProfileFromSequence$$1$$4$$segbyt;
    unsigned char *makeStripedProfileFromSequence$$1$$4$$sprofp = (unsigned char *)app->striped_bytep;
    makeStripedProfileFromSequence$$1$$4$$segsiz = ((length + (unsigned int)16) - (unsigned int)1) / (unsigned int)16;
    makeStripedProfileFromSequence$$1$$4$$segbyt = makeStripedProfileFromSequence$$1$$4$$segsiz * (unsigned int)16;
    makeStripedProfileFromSequence$$1$$4$$i = (signed short int)0;
    for( ; !((signed int)makeStripedProfileFromSequence$$1$$4$$i >= (signed int)app->alphabetsiz); makeStripedProfileFromSequence$$1$$4$$i = makeStripedProfileFromSequence$$1$$4$$i + 1)
    {
      unsigned int makeStripedProfileFromSequence$$1$$4$$1$$1$$j;
      const signed char *sp = amp->score[(signed long int)makeStripedProfileFromSequence$$1$$4$$i];
      makeStripedProfileFromSequence$$1$$4$$1$$1$$j = (unsigned int)0;
      for( ; !(makeStripedProfileFromSequence$$1$$4$$1$$1$$j >= makeStripedProfileFromSequence$$1$$4$$segsiz); makeStripedProfileFromSequence$$1$$4$$1$$1$$j = makeStripedProfileFromSequence$$1$$4$$1$$1$$j + 1u)
      {
        unsigned int k = makeStripedProfileFromSequence$$1$$4$$1$$1$$j;
        for( ; !(k >= length); k = k + makeStripedProfileFromSequence$$1$$4$$segsiz)
        {
          tmp_post$2 = makeStripedProfileFromSequence$$1$$4$$sprofp;
          makeStripedProfileFromSequence$$1$$4$$sprofp = makeStripedProfileFromSequence$$1$$4$$sprofp + 1l;
          *tmp_post$2 = (unsigned char)((signed int)(unsigned char)sp[(signed long int)((signed int)seq_basp[(signed long int)k] & 7)] - (signed int)app->bias);
        }
        for( ; !(k >= makeStripedProfileFromSequence$$1$$4$$segbyt); k = k + makeStripedProfileFromSequence$$1$$4$$segsiz)
        {
          tmp_post$3 = makeStripedProfileFromSequence$$1$$4$$sprofp;
          makeStripedProfileFromSequence$$1$$4$$sprofp = makeStripedProfileFromSequence$$1$$4$$sprofp + 1l;
          *tmp_post$3 = (unsigned char)0;
        }
      }
    }
  }

  signed short int *tmp_post$4;
  signed short int *tmp_post$5;
  if(!((4 & (signed int)app->mod) == 0))
  {
    signed short int i;
    unsigned int segsiz;
    unsigned int segbyt;
    signed short int *sprofp = (signed short int *)app->striped_shortp;
    segsiz = ((length + (unsigned int)8) - (unsigned int)1) / (unsigned int)8;
    segbyt = segsiz * (unsigned int)8;
    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)app->alphabetsiz); i = i + 1)
    {
      unsigned int j;
      const signed char *makeStripedProfileFromSequence$$1$$5$$1$$1$$sp = amp->score[(signed long int)i];
      j = (unsigned int)0;
      for( ; !(j >= segsiz); j = j + 1u)
      {
        unsigned int makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k = j;
        for( ; !(makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k >= length); makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k = makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k + segsiz)
        {
          tmp_post$4 = sprofp;
          sprofp = sprofp + 1l;
          *tmp_post$4 = (signed short int)((signed int)(signed short int)makeStripedProfileFromSequence$$1$$5$$1$$1$$sp[(signed long int)((signed int)seq_basp[(signed long int)makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k] & 7)] - 0);
        }
        for( ; !(makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k >= segbyt); makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k = makeStripedProfileFromSequence$$1$$5$$1$$1$$1$$1$$k + segsiz)
        {
          tmp_post$5 = sprofp;
          sprofp = sprofp + 1l;
          *tmp_post$5 = (signed short int)0;
        }
      }
    }
  }

  return 0;
}

// mapReads
// file smalt.c line 1316
static signed int mapReads(struct _ErrMsg *errmsgp, const struct _MenuOpt *menup)
{
  signed int errcode = 0;
  unsigned char is_verbose;
  signed short int nthreads;
  nthreads=menuGetNumberOfThreads(menup);
  struct _SmaltMapConst common_args;
  signed int (*checkf)(const void *, const void *) = (signed int (*)(const void *, const void *))(void *)0;
  signed int (*cmpf)(const void *, const void *) = (signed int (*)(const void *, const void *))(void *)0;
  signed int arg_fac = 2;
  signed long int time_start;
  signed long int time_setup;
  signed long int time_stop;
  errcode=threadsInit();
  unsigned short int return_value_menuGetFlags$1;
  if(!(errcode == 0))
  {
    errMsgAdd(errmsgp, "", "smalt.c", 1333, errcode, (unsigned char)2);
    return errcode;
  }

  else
  {
    if(!((signed int)nthreads >= 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1337, 47, (unsigned char)2);

    if((signed int)nthreads >= 241)
      nthreads = (signed short int)240;

    time(&time_start);
    errcode=initMapConst(&common_args, menup);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1347, errcode, (unsigned char)2);

    time(&time_setup);
    errcode=threadsSetTask((unsigned char)0, (signed short int)0, initArgBlock, (const void *)&common_args, (signed int (*)(struct _ErrMsg *, void *, void *))(void *)0, cleanupArgBlock, (signed int (*)(const void *, const void *))(void *)0, (signed int (*)(const void *, const void *))(void *)0, sizeof(struct SmaltArgBlock_) /*16ul*/ );
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1359, errcode, (unsigned char)2);

    errcode=threadsSetTask((unsigned char)1, (signed short int)((signed int)nthreads > 0 ? 1 : 0), initInput, (const void *)&common_args, loadArgBlock, cleanupInput, (signed int (*)(const void *, const void *))(void *)0, (signed int (*)(const void *, const void *))(void *)0, sizeof(struct _SmaltInput) /*40ul*/ );
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1367, errcode, (unsigned char)2);

    errcode=threadsSetTask((unsigned char)2, nthreads, initMapArgs, (const void *)&common_args, processArgBlock, cleanupMapArgs, (signed int (*)(const void *, const void *))(void *)0, (signed int (*)(const void *, const void *))(void *)0, sizeof(struct _SmaltMapArgs) /*32ul*/ );
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1375, errcode, (unsigned char)2);

    if((signed int)nthreads >= 1)
    {
      return_value_menuGetFlags$1=menuGetFlags(menup);
      if(!((16384 & (signed int)return_value_menuGetFlags$1) == 0))
      {
        checkf = checkArgBlockReadNo;
        cmpf = cmpArgBlockReadNo;
        arg_fac = 4;
      }

    }

    errcode=threadsSetTask((unsigned char)3, (signed short int)0, initSmaltOutput, (const void *)&common_args, outputArgBlock, cleanupSmaltOutput, checkf, cmpf, sizeof(struct _SmaltOutput) /*40ul*/ );
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1389, errcode, (unsigned char)2);

    errcode=threadsSetUp(arg_fac);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "smalt.c", 1392, errcode, (unsigned char)2);

    is_verbose = (unsigned char)(((signed int)common_args.menuflg & 4) != 0);
    char return_value_menuGetSubProgTyp$2;
    return_value_menuGetSubProgTyp$2=menuGetSubProgTyp(menup);
    if((signed int)return_value_menuGetSubProgTyp$2 == 4)
    {
      errcode=prepSample(errmsgp, &common_args);
      common_args.rmapflg = common_args.rmapflg | (unsigned short int)(2 | 4);
      if(!(is_verbose == 0))
        fprintf(stderr, "# Sampling insert size distribution ...\n");

    }

    else
      if(!(is_verbose == 0))
        fprintf(stderr, "# Processing query reads ...\n");

    errcode=threadsRun();
    if(!(errcode == 0) && !(errcode == 10))
      errMsgAdd(errmsgp, "", "smalt.c", 1408, errcode, (unsigned char)2);

    outputHisto(errmsgp);
    threadsCleanup();
    time(&time_stop);
    cleanupMapConst(&common_args);
    menuPrintWallClockTime(stderr, time_start, time_setup, "Time spent setting up hash index");
    menuPrintWallClockTime(stderr, time_setup, time_stop, "Time spent mapping reads");
    return errcode;
  }
}

// mapSecondary
// file rmap.c line 1435
static signed int mapSecondary(struct _ErrMsg *errmsgp, struct RMAPBUFF_ *bufp, struct _ResultSet *rssp, struct RMAPINFO_ *rmrp, const struct RMAPPROF_ *rmprp, struct _SeqFastq *readp, signed int ktuple_maxhit, unsigned int min_cover, signed int min_swatscor, signed int min_swatscor_below_max, unsigned char min_basqval, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  unsigned int qs;
  unsigned int qe;
  unsigned int qlen;
  unsigned char ktup;
  unsigned char nskip;
  const struct _RESULT *rp;
  ktup=hashTableGetKtupLen(htp, &nskip);
  seqFastqGetConstSequence(readp, &qlen, (char *)(void *)0);
  errcode=resultSetGetResultInSegment(&rp, 0, 0, rssp);
  if(!(errcode == 0))
  {
    if(errcode == -1)
      return 0;

    else
      errMsgAdd(errmsgp, "", "rmap.c", 1464, errcode, (unsigned char)2);
  }

  errcode=resultGetData(&qs, &qe, (unsigned int *)(void *)0, (unsigned int *)(void *)0, (signed long int *)(void *)0, (signed int *)(void *)0, (unsigned short int *)(void *)0, rp);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "rmap.c", 1468, errcode, (unsigned char)2);

  if(!(qe >= qs) || !(qlen >= qe))
    errMsgAdd(errmsgp, "", "rmap.c", 1471, 47, (unsigned char)2);

  if(!(qlen >= qe + qs))
  {
    qe = qs > (unsigned int)1 ? qs - (unsigned int)2 : (unsigned int)0;
    qs = (unsigned int)0;
  }

  else
  {
    qs = qe;
    qe = qlen - (unsigned int)1;
  }
  if(!(1u + qe >= qs + (unsigned int)ktup + (unsigned int)nskip))
    return 0;

  else
  {
    errcode=initRMAPINFO(rmrp, min_basqval, qs, qe, readp, htp);
    if(errcode == 30)
      return 0;

    else
    {
      if(!(errcode == 0))
        errMsgAdd(errmsgp, "", "rmap.c", 1488, errcode, (unsigned char)2);

      mapSingleRead(errmsgp, bufp, rssp, rmrp, rmprp, readp, ktuple_maxhit, min_cover, min_swatscor, min_swatscor_below_max, target_depth, max_depth, rmapflg, htp, ssp, codecp, (const struct V_IVAL_ *)(void *)0);
      return errcode;
    }
  }
}

// mapSingleRead
// file rmap.c line 1228
static signed int mapSingleRead(struct _ErrMsg *errmsgp, struct RMAPBUFF_ *bufp, struct _ResultSet *rssp, const struct RMAPINFO_ *rmrp, const struct RMAPPROF_ *rprofp, struct _SeqFastq *readp, signed int ktuple_maxhit, unsigned int min_cover, signed int min_swatscor, signed int min_swatscor_below_max, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct V_IVAL_ *ivr)
{
  signed int errcode;
  char cod;
  unsigned int rlen;
  unsigned int mincov_below_max;
  unsigned char nskip;
  unsigned char ktup;
  ktup=hashTableGetKtupLen(htp, &nskip);
  signed int scorlen_min = (signed int)ktup + (signed int)nskip;
  signed short int mismatchscor;
  signed short int gapinitscor;
  signed short int gapextscor;
  signed short int matchscor;
  matchscor=scoreProfileGetAvgPenalties(&mismatchscor, &gapinitscor, &gapextscor, rprofp->scorprofp);
  signed short int mismatchdiff = (signed short int)((signed int)matchscor - (signed int)mismatchscor);
  signed int bandwidth_min;
  unsigned int min_ktup;
  min_ktup=calcMinKtup(&min_cover, htp);
  signed int max1scor = 0;
  signed int max2scor = 0;
  signed int maxscor_perfect;
  unsigned int nseg;
  unsigned int nseg_tot;
  unsigned int nhit;
  unsigned int nhit_tot;
  if((signed int)gapextscor >= 0 || (signed int)mismatchscor >= 0 || !((signed int)mismatchdiff >= 0))
    errMsgAdd(errmsgp, "", "rmap.c", 1267, 47, (unsigned char)2);

  seqFastqGetConstSequence(readp, &rlen, &cod);
  if(!(rlen >= (unsigned int)ktup))
    return 30;

  else
  {
    if(rlen * (unsigned int)matchscor >= 2147483648u)
      errMsgAdd(errmsgp, "", "rmap.c", 1279, 48, (unsigned char)2);

    maxscor_perfect = (signed int)(rlen * (unsigned int)matchscor);
    if(!(min_swatscor_below_max >= 0))
      mincov_below_max = rlen - (unsigned int)1;

    else
    {
      mincov_below_max = (unsigned int)(min_swatscor_below_max / (signed int)mismatchdiff) * (unsigned int)nskip;
      if(!((2 & (signed int)rmapflg) == 0) || !(mincov_below_max >= (unsigned int)ktup))
        mincov_below_max = (unsigned int)((signed int)ktup + 2 * ((signed int)nskip - 1));

    }
    errcode=fillRMAPBUFF(bufp, rmrp, (unsigned char)((signed int)rmapflg & 16), ktuple_maxhit, min_ktup, min_cover, htp, ssp, ivr);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 1313, errcode, (unsigned char)2);

    errcode=aliBufferInit(bufp->alibufp, rlen);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 1316, errcode, (unsigned char)2);

    errcode=segAliCandsStats(bufp->sacp, mincov_below_max, rmrp->hhiFp, rmrp->hhiRp, (unsigned int)target_depth, (unsigned int)max_depth, (unsigned char)((signed int)rmapflg & 128));
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 1327, errcode, (unsigned char)2);

    nseg=segAliCandsGetNumberOfSegments(bufp->sacp, (unsigned int *)(void *)0, (unsigned int *)(void *)0, (unsigned int *)(void *)0, (unsigned int *)(void *)0, &nseg_tot);
    if(nseg >= 2147483648u || nseg_tot >= 2147483648u)
      errMsgAdd(errmsgp, "", "rmap.c", 1335, 47, (unsigned char)2);

    nhit=calcTotalHitNumStats(rmrp, &nhit_tot);
    resultSetAlignmentStats(rssp, (signed int)nseg, (signed int)nseg_tot, max_depth, nhit, nhit_tot);
    if((signed int)cod == 0)
    {
      errcode=seqFastqEncode(readp, codecp);
      if(!(errcode == 0))
        errMsgAdd(errmsgp, "", "rmap.c", 1345, errcode, (unsigned char)2);

    }

    errcode=scoreRMAPCAND(&bufp->candr, &max1scor, &max2scor, bufp->sqbfp, bufp->alibufp, rmapflg, nskip, rprofp->scorprofp, rprofp->scorprofRCp, ssp, codecp, bufp->sacp);
    if(!(errcode == 0) && (!((16 & (signed int)rmapflg) == 0) || !(errcode == 60)))
      errMsgAdd(errmsgp, "", "rmap.c", 1371, errcode, (unsigned char)2);

    if(!(maxscor_perfect >= max1scor))
      errMsgAdd(errmsgp, "", "rmap.c", 1374, 47, (unsigned char)2);

    if(!(max1scor >= 1))
      return 0;

    else
    {
      bandwidth_min = (maxscor_perfect - max1scor) / (-1 * (signed int)gapextscor);
      if(min_swatscor_below_max >= max1scor)
        min_swatscor_below_max = max1scor;

      if(max2scor >= 1 && !(max2scor >= min_swatscor))
        min_swatscor = max2scor;

      if(min_swatscor_below_max >= 0)
      {
        signed int minswc = max2scor > 0 ? max2scor : max1scor;
        if(!((2 & (signed int)rmapflg) == 0))
        {
          if(!(min_swatscor >= minswc))
            min_swatscor = minswc;

        }

        else
          if(!(min_swatscor + min_swatscor_below_max >= max1scor))
          {
            min_swatscor = max1scor - min_swatscor_below_max;
            if(!(minswc >= min_swatscor))
              min_swatscor = minswc;

          }

      }

      if((signed int)matchscor >= 1 && !(scorlen_min * (signed int)matchscor >= min_swatscor))
        scorlen_min = min_swatscor / (signed int)matchscor;

      errcode=alignRMAPCANDFull(rssp, bufp->alirsltp, bufp->alibufp, bufp->sqbfp, min_swatscor, scorlen_min, bandwidth_min, rmapflg, rprofp->scorprofp, rprofp->scorprofRCp, ssp, codecp, bufp->candr);
      if(!(errcode == 0))
        errMsgAdd(errmsgp, "", "rmap.c", 1417, errcode, (unsigned char)2);

      errcode=resultSetSortAndAssignSequence(rssp, bufp->sqbfp, (unsigned char)0, readp, rprofp->scorprofp, rprofp->scorprofRCp, ssp, codecp);
      if(!(errcode == 0))
        errMsgAdd(errmsgp, "", "rmap.c", 1430, errcode, (unsigned char)2);

      return errcode;
    }
  }
}

// menuCreate
// file menu.h line 127
struct _MenuOpt * menuCreate(void)
{
  struct _MenuOpt *mp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _MenuOpt) /*88ul*/ , "menu.c", 1690);
  mp = (struct _MenuOpt *)return_value_ecalloc$1;
  if(!(mp == ((struct _MenuOpt *)NULL)))
  {
    char *return_value_eStringInit$2;
    return_value_eStringInit$2=eStringInit(&mp->estrbuf, 0, "menu.c", 1692);
    if(return_value_eStringInit$2 == ((char *)NULL))
    {
      menuDelete(mp);
      mp = (struct _MenuOpt *)(void *)0;
    }

    mp->indir = (char *)(void *)0;
  }

  return mp;
}

// menuDelete
// file menu.h line 130
void menuDelete(struct _MenuOpt *mp)
{
  _Bool tmp_if_expr$1;
  if(!(mp == ((struct _MenuOpt *)NULL)))
  {
    free((void *)mp->estrbuf.strp);
    memset((void *)&mp->estrbuf, 0, sizeof(struct EString_) /*32ul*/ );
    if((signed int)mp->subprog == 2)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)mp->subprog == 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      struct _MAPMENU *p = (struct _MAPMENU *)mp->paramp;
      free((void *)p->oufilnam);
      free((void *)p->insfilnam);
      free((void *)p->tmpdirnam);
    }

    free(mp->paramp);
    free((void *)mp->indir);
  }

  free((void *)mp);
}

// menuGetCommandLine
// file menu.h line 151
char ** menuGetCommandLine(const struct _MenuOpt *mp, signed int *argc)
{
  if(!(argc == ((signed int *)NULL)))
    *argc = mp->argc;

  return mp->argv;
}

// menuGetFileNames
// file menu.h line 243
signed int menuGetFileNames(const struct _MenuOpt *mp, const char **filnam1p, const char **filnam2p)
{
  if(!(filnam1p == ((const char **)NULL)))
    *filnam1p = ((const char *)NULL);

  if(!(filnam2p == ((const char **)NULL)))
    *filnam2p = ((const char *)NULL);

  _Bool tmp_if_expr$1;
  if((signed int)mp->subprog == 2)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)mp->subprog == 4 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(!(filnam1p == ((const char **)NULL)))
    {
      if(mp->ninfil >= 2)
        *filnam1p = mp->filnams[(signed long int)1];

    }

    if(!(filnam2p == ((const char **)NULL)))
    {
      if(mp->ninfil >= 3)
        *filnam2p = mp->filnams[(signed long int)2];

    }

  }

  else
    if((signed int)mp->subprog == 1)
    {
      if(!(filnam1p == ((const char **)NULL)))
      {
        if(mp->ninfil >= 2)
          *filnam1p = mp->filnams[(signed long int)1];

      }

    }

    else
      if((signed int)mp->subprog == 3)
      {
        if(!(filnam1p == ((const char **)NULL)))
        {
          if(mp->ninfil >= 1)
            *filnam1p = mp->filnams[(signed long int)0];

        }

        if(!(filnam2p == ((const char **)NULL)))
        {
          if(mp->ninfil >= 2)
            *filnam2p = mp->filnams[(signed long int)1];

        }

      }

  return mp->ninfil;
}

// menuGetFlags
// file menu.h line 236
unsigned short int menuGetFlags(const struct _MenuOpt *menup)
{
  unsigned short int flags = (unsigned short int)0;
  _Bool tmp_if_expr$1;
  if(!(menup == ((const struct _MenuOpt *)NULL)))
  {
    if(!(menup->paramp == NULL))
    {
      if((signed int)menup->subprog == 2)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)menup->subprog == 4 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        flags = ((const struct _MAPMENU *)menup->paramp)->flags;

    }

  }

  return flags;
}

// menuGetHashParams
// file menu.h line 158
signed int menuGetHashParams(const struct _MenuOpt *mp, const char **hashnamp, unsigned char *kmer, unsigned char *nskip)
{
  const struct _INDEXMENU *ip = (struct _INDEXMENU *)mp->paramp;
  char *tmp_if_expr$1;
  if(!((signed int)mp->subprog == 1))
    return -1;

  else
  {
    if(!(kmer == ((unsigned char *)NULL)))
      *kmer = ip->kmer;

    if(!(nskip == ((unsigned char *)NULL)))
      *nskip = ip->skip;

    if(!(hashnamp == ((const char **)NULL)))
    {
      if(mp->ninfil >= 1)
        tmp_if_expr$1 = mp->filnams[(signed long int)0];

      else
        tmp_if_expr$1 = (char *)(void *)0;
      *hashnamp = tmp_if_expr$1;
    }

    return 0;
  }
}

// menuGetMapInputFormat
// file menu.h line 212
signed int menuGetMapInputFormat(const struct _MenuOpt *menup, unsigned char *infmt, const char **tmpdirnam)
{
  const struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  if(!((signed int)menup->subprog == 2))
  {
    if((signed int)menup->subprog == 4)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(infmt == ((unsigned char *)NULL)))
      *infmt = mp->inform;

    if(!(tmpdirnam == ((const char **)NULL)))
      *tmpdirnam = mp->tmpdirnam;

    return 0;
  }
}

// menuGetMapParams
// file menu.h line 166
signed int menuGetMapParams(const struct _MenuOpt *menup, const char **hashnamp, signed int *nhitmax_tuple, double *tupcovmin, signed short int *minscore, signed short int *scorediff, unsigned char *minbasq, double *minidentity, signed int *randseed, signed int *readskip, signed int *insert_min, signed int *insert_max, unsigned char *outform, const char **outfilnam, const char **insfilnam, unsigned char *pairtyp)
{
  const struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  char *tmp_if_expr$3;
  if(!((signed int)menup->subprog == 2))
  {
    if((signed int)menup->subprog == 4)
      goto __CPROVER_DUMP_L1;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(hashnamp == ((const char **)NULL)))
    {
      if((signed int)menup->subprog == 4)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = 2 == (signed int)menup->subprog ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = menup->ninfil > 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = menup->filnams[(signed long int)0];

      else
        tmp_if_expr$3 = (char *)(void *)0;
      *hashnamp = tmp_if_expr$3;
    }

    if(!(nhitmax_tuple == ((signed int *)NULL)))
      *nhitmax_tuple = mp->ncut;

    if(!(tupcovmin == ((double *)NULL)))
      *tupcovmin = mp->mincover;

    if(!(minscore == ((signed short int *)NULL)))
      *minscore = mp->minscore;

    if(!(scorediff == ((signed short int *)NULL)))
      *scorediff = mp->scorediff;

    if(!(minbasq == ((unsigned char *)NULL)))
      *minbasq = mp->minbasq;

    if(!(minidentity == ((double *)NULL)))
      *minidentity = mp->minidentity;

    if(!(randseed == ((signed int *)NULL)))
      *randseed = mp->randseed_repeat;

    if(!(readskip == ((signed int *)NULL)))
      *readskip = mp->readskip;

    if(!(insert_min == ((signed int *)NULL)))
      *insert_min = mp->insert_range[(signed long int)0];

    if(!(insert_max == ((signed int *)NULL)))
      *insert_max = mp->insert_range[(signed long int)1];

    if(!(outform == ((unsigned char *)NULL)))
      *outform = mp->oufmt.typ;

    if(!(outfilnam == ((const char **)NULL)))
      *outfilnam = mp->oufilnam;

    if(!(insfilnam == ((const char **)NULL)))
      *insfilnam = mp->insfilnam;

    if(!(pairtyp == ((unsigned char *)NULL)))
      *pairtyp = mp->pairtyp;

    return 0;
  }
}

// menuGetMapPenaltyScores
// file menu.h line 222
unsigned char menuGetMapPenaltyScores(const struct _MenuOpt *menup, signed char *match, signed char *subst, signed char *gap_open, signed char *gap_ext)
{
  const struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  if(!((signed int)menup->subprog == 2))
  {
    if((signed int)menup->subprog == 4)
      goto __CPROVER_DUMP_L1;

    return (unsigned char)-1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(match == ((signed char *)NULL)))
      *match = mp->penalties[(signed long int)0];

    if(!(subst == ((signed char *)NULL)))
      *subst = mp->penalties[(signed long int)1];

    if(!(gap_open == ((signed char *)NULL)))
      *gap_open = mp->penalties[(signed long int)2];

    if(!(gap_ext == ((signed char *)NULL)))
      *gap_ext = mp->penalties[(signed long int)3];

    return mp->penaltyflags;
  }
}

// menuGetNumberOfThreads
// file menu.h line 240
signed short int menuGetNumberOfThreads(const struct _MenuOpt *menup)
{
  const struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  return mp->nthread;
}

// menuGetProgramName
// file menu.h line 154
const char * menuGetProgramName(const char **version)
{
  if(!(version == ((const char **)NULL)))
    *version = MENU_RELEASE_VERSION;

  return MENU_PROGNAM_SHORT;
}

// menuGetSubProgTyp
// file menu.h line 147
char menuGetSubProgTyp(const struct _MenuOpt *mp)
{
  return mp->subprog;
}

// menuParseCommandLine
// file menu.h line 133
signed int menuParseCommandLine(struct _MenuOpt *menu, signed int argc, char **argv)
{
  char *subprognam = (char *)(void *)0;
  signed int ntokens = 0;
  struct _optflags optfl;
  const struct TASKDOC_ *taskdocp = (const struct TASKDOC_ *)(void *)0;
  menu->argc = argc;
  menu->argv = argv;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  _Bool tmp_if_expr$7;
  signed int return_value;
  if(!(argc >= 2))
  {
    fprintf(stdout, "\n%s\n", (const void *)MENU_PROGNAM);
    fprintf(stdout, MENU_PROGNAM_VERSION_FMT, (const void *)MENU_RELEASE_VERSION);
    fprintf(stdout, MENU_USAGE_SUMMARY);
    return 51;
  }

  else
  {
    memset((void *)&optfl, 0, sizeof(struct _optflags) /*4ul*/ );
    subprognam = argv[(signed long int)1];
    signed int return_value_strcmp$6;
    return_value_strcmp$6=strcmp(subprognam, "index");
    static signed int (*check_fn)(struct _MenuOpt *, const struct _optflags *) = (signed int (*)(struct _MenuOpt *, const struct _optflags *))(void *)0;
    static signed int (*parse_fn)(struct _MenuOpt *, struct _optflags *, signed int, char **) = (signed int (*)(struct _MenuOpt *, struct _optflags *, signed int, char **))(void *)0;
    if(return_value_strcmp$6 == 0)
    {
      taskdocp = &MENU_TASKDOC_INDEX;
      if(argc >= 3)
      {
        if((signed int)*argv[2l] == 45)
        {
          if((signed int)argv[2l][1l] == 72)
          {
            menu->subprog = (char)5;
            fprintTaskDoc(stdout, taskdocp, (unsigned char)1);
            return 0;
          }

        }

      }

      menu->subprog = (char)1;
      fprintCommandLine(stderr, argc, argv);
      initHashOptions(menu);
      parse_fn = parseHashOptions;
      check_fn = checkHashDefaults;
    }

    else
    {
      return_value_strcmp$5=strcmp(subprognam, "map");
      if(return_value_strcmp$5 == 0)
      {
        taskdocp = &MENU_TASKDOC_MAP;
        if(argc >= 3)
        {
          if((signed int)*argv[2l] == 45)
          {
            if((signed int)argv[2l][1l] == 72)
            {
              menu->subprog = (char)5;
              fprintf(stdout, MENU_USAGE_MAP_HEADER);
              fprintTaskDoc(stdout, taskdocp, (unsigned char)1);
              return 0;
            }

          }

        }

        menu->subprog = (char)2;
        fprintCommandLine(stderr, argc, argv);
        initMapOptions(menu);
        parse_fn = parseMapOptions;
        check_fn = checkMapDefaults;
      }

      else
      {
        return_value_strcmp$4=strcmp(subprognam, "check");
        if(return_value_strcmp$4 == 0)
        {
          menu->subprog = (char)3;
          taskdocp = &MENU_TASKDOC_CHECK;
          if(argc >= 3)
          {
            if((signed int)*argv[2l] == 45)
            {
              if((signed int)argv[2l][1l] == 72)
              {
                menu->subprog = (char)5;
                fprintTaskDoc(stdout, taskdocp, (unsigned char)1);
                return 0;
              }

            }

          }

          fprintCommandLine(stderr, argc, argv);
        }

        else
        {
          return_value_strcmp$3=strcmp(subprognam, "sample");
          if(return_value_strcmp$3 == 0)
          {
            menu->subprog = (char)4;
            taskdocp = &MENU_TASKDOC_SAMPLE;
            if(argc >= 3)
            {
              if((signed int)*argv[2l] == 45)
              {
                if((signed int)argv[2l][1l] == 72)
                {
                  menu->subprog = (char)5;
                  fprintTaskDoc(stdout, taskdocp, (unsigned char)1);
                  return 0;
                }

              }

            }

            fprintCommandLine(stderr, argc, argv);
            initMapOptions(menu);
            parse_fn = parseSampleOptions;
            check_fn = checkSampleDefaults;
          }

          else
          {
            return_value_strcmp$2=strcmp(subprognam, "help");
            if(return_value_strcmp$2 == 0)
            {
              menu->subprog = (char)5;
              fprintf(stdout, "\n%s\n\n", (const void *)MENU_PROGNAM);
              fprintf(stdout, MENU_USAGE_SUMMARY);
              fprintf(stdout, "DESCRIPTION:\n%s", (const void *)MENU_SHORT_DESCRIPTION);
              return 0;
            }

            else
            {
              return_value_strcmp$1=strcmp(subprognam, "version");
              if(return_value_strcmp$1 == 0)
              {
                menu->subprog = (char)6;
                printBlurb(stdout);
                return 0;
              }

              else
              {
                menu->subprog = (char)0;
                printf("ERROR: unknown task switch %s\n\n", subprognam);
                fprintf(stdout, MENU_USAGE_SUMMARY);
                return 51;
              }
            }
          }
        }
      }
    }
    if((signed int)menu->subprog == 0)
      exitOptionError(subprognam, "not yet implemented.");

    argc = argc - 2;
    argv = argv + (signed long int)2;
    menu->ninfil = 0;
    while(argc >= 1)
      if((signed int)*(*argv) == 45)
      {
        if(menu->ninfil >= 1)
          exitOptionError(argv[(signed long int)0], "occurs after file name.");

        if(!(parse_fn == ((signed int (*)(struct _MenuOpt *, struct _optflags *, signed int, char **))NULL)))
          ntokens=parse_fn(menu, &optfl, argc, argv);

        if(!(ntokens >= 1))
        {
          if(ntokens == -3)
            exitOptionError(argv[(signed long int)0], "unknown.");

          return -1;
        }

        argc = argc - ntokens;
        argv = argv + (signed long int)ntokens;
      }

      else
      {
        if(!(menu->ninfil >= 1))
          menu->filnams = argv;

        menu->ninfil = menu->ninfil + 1;
        argv = argv + 1l;
        argc = argc - 1;
      }
    if(!(menu->ninfil >= 2))
    {
      if((signed int)menu->subprog == 3)
        tmp_if_expr$7 = menu->ninfil == 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(!tmp_if_expr$7)
      {
        fprintf(stdout, "no input files specified.\n");
        fprintTaskDoc(stdout, taskdocp, (unsigned char)0);
        exit(1);
      }

    }

    if(menu->ninfil >= 4)
      exitOptionError((const char *)(void *)0, "too many input files specified.");

    if(!(check_fn == ((signed int (*)(struct _MenuOpt *, const struct _optflags *))NULL)))
    {
      return_value=check_fn(menu, &optfl);
      return -1;
    }

    else
      return 0;
  }
}

// menuPrint
// file menu.c line 1851
void menuPrint(struct _IO_FILE *fp, const struct _MenuOpt *menup)
{
  fprintf(fp, "\n========= Menue =========\nSubprogram: ");
  switch((signed int)menup->subprog)
  {
    case 1:
    {
      fprintf(fp, "index\n");
      fprintHashOptions(fp, menup);
      break;
    }
    case 2:
    {
      fprintf(fp, "map\n");
      fprintMapOptions(fp, menup);
      break;
    }
    case 0:

    default:
      fprintf(fp, "unknown\n");
  }
  fprintf(fp, "\nFiles\n");
  char *tmp_if_expr$1;
  if(!(menup->indir == ((char *)NULL)))
    tmp_if_expr$1 = menup->indir;

  else
    tmp_if_expr$1 = "-";
  fprintf(fp, "dir: %s\n", tmp_if_expr$1);
  fprintf(fp, "infil: %d\n", menup->ninfil);
  fprintf(fp, "====== End of Menue =====\n");
}

// menuPrintWallClockTime
// file menu.h line 251
void menuPrintWallClockTime(struct _IO_FILE *fp, signed long int time_start, signed long int time_stop, const char *headerp)
{
  double secs;
  secs=difftime(time_stop, time_start);
  signed short int days = (signed short int)(secs / (double)86400);
  signed short int hours = (signed short int)((secs - (double)((signed int)days * 86400)) / (double)3600);
  signed short int mins = (signed short int)(((secs - (double)((signed int)days * 86400)) - (double)((signed int)hours * 3600)) / (double)60);
  double seconds = ((secs - (double)((signed int)days * 86400)) - (double)((signed int)hours * 3600)) - (double)((signed int)mins * 60);
  if(headerp == ((const char *)NULL))
    fprintf(fp, "# %s: Total elapsed wall clock time: ", (const void *)MENU_PROGNAM_SHORT);

  else
    fprintf(fp, "# %s: %s:", (const void *)MENU_PROGNAM_SHORT, headerp);
  if((signed int)days >= 1)
    fprintf(fp, "%hi days ", days);

  if((signed int)hours >= 1)
    fprintf(fp, "%hi hours ", hours);

  if((signed int)mins >= 1)
    fprintf(fp, "%hi minutes and ", mins);

  fprintf(fp, "%g seconds\n", seconds);
}

// menuTestMapOutputFormatFlags
// file menu.h line 204
signed int menuTestMapOutputFormatFlags(const struct _MenuOpt *menup, const unsigned char outform, const unsigned char flags)
{
  const struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  _Bool tmp_if_expr$1;
  if(!((signed int)menup->subprog == 2))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = mp->oufmt.typ != outform ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
    return (signed int)(((signed int)mp->oufmt.flags & (signed int)flags) == (signed int)flags);
}

// mkeyQSortSuffix
// file sort.c line 132
static void mkeyQSortSuffix(const char *hstrp, unsigned int *sfxidxp, unsigned int nsfx, signed short int depth, signed short int maxdepth)
{
  signed short int r;
  signed short int v;
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  unsigned int m;
  unsigned int *ip;
  unsigned int *jp;
  unsigned int k;
  unsigned int tmp;
  unsigned int tmp_post$2;
  unsigned int tmp_post$3;
  if(nsfx >= 2u)
  {
    signed int return_value_rand$1;
    return_value_rand$1=rand();
    a = (unsigned int)return_value_rand$1 % nsfx;
    tmp = sfxidxp[(signed long int)0];
    sfxidxp[(signed long int)0] = sfxidxp[(signed long int)a];
    sfxidxp[(signed long int)a] = tmp;
    v = (signed short int)hstrp[(signed long int)(sfxidxp[(signed long int)0] + (unsigned int)depth)];
    b = (unsigned int)1;
    a = b;
    d = nsfx - (unsigned int)1;
    c = d;

  __CPROVER_DUMP_L2:
    ;
    for( ; (_Bool)1; c = c - 1u)
    {
      if(c >= b)
      {
        r = (signed short int)((signed int)(signed short int)hstrp[(signed long int)(sfxidxp[(signed long int)b] + (unsigned int)depth)] - (signed int)v);
        if(!((signed int)r >= 1))
        {
          if(r == 0)
          {
            tmp = sfxidxp[(signed long int)a];
            sfxidxp[(signed long int)a] = sfxidxp[(signed long int)b];
            sfxidxp[(signed long int)b] = tmp;
            a = a + 1u;
          }

          b = b + 1u;
          goto __CPROVER_DUMP_L2;
        }

      }

      for( ; c >= b; c = c - 1u)
      {
        r = (signed short int)((signed int)(signed short int)hstrp[(signed long int)(sfxidxp[(signed long int)c] + (unsigned int)depth)] - (signed int)v);
        if(!((signed int)r >= 0))
          break;

        if(r == 0)
        {
          tmp = sfxidxp[(signed long int)c];
          sfxidxp[(signed long int)c] = sfxidxp[(signed long int)d];
          sfxidxp[(signed long int)d] = tmp;
          d = d - 1u;
        }

      }
      if(!(c >= b))
        break;

      tmp = sfxidxp[(signed long int)b];
      sfxidxp[(signed long int)b] = sfxidxp[(signed long int)c];
      sfxidxp[(signed long int)c] = tmp;
      b = b + 1u;
    }
    m = a < b - a ? a : b - a;
    ip = sfxidxp + (signed long int)0;
    jp = sfxidxp + (signed long int)(b - m);
    k = m;
    do
    {
      tmp_post$2 = k;
      k = k - 1u;
      if(!(tmp_post$2 >= 1u))
        break;

      tmp = *ip;
      *ip = *jp;
      *jp = tmp;
      ip = ip + 1l;
      jp = jp + 1l;
    }
    while((_Bool)1);
    m = d - c < (nsfx - d) - (unsigned int)1 ? d - c : (nsfx - d) - (unsigned int)1;
    ip = sfxidxp + (signed long int)b;
    jp = sfxidxp + (signed long int)(nsfx - m);
    k = m;
    do
    {
      tmp_post$3 = k;
      k = k - 1u;
      if(!(tmp_post$3 >= 1u))
        break;

      tmp = *ip;
      *ip = *jp;
      *jp = tmp;
      ip = ip + 1l;
      jp = jp + 1l;
    }
    while((_Bool)1);
    m = b - a;
    mkeyQSortSuffix(hstrp, sfxidxp, m, depth, maxdepth);
    if(!((signed int)(signed short int)hstrp[(signed long int)(sfxidxp[(signed long int)m] + (unsigned int)depth)] == 0))
    {
      if(!((signed int)depth >= (signed int)maxdepth))
        mkeyQSortSuffix(hstrp, sfxidxp + (signed long int)m, ((a + nsfx) - d) - (unsigned int)1, (signed short int)((signed int)depth + 1), maxdepth);

    }

    m = d - c;
    mkeyQSortSuffix(hstrp, (sfxidxp + (signed long int)nsfx) - (signed long int)m, m, depth, maxdepth);
  }

}

// mksort
// file sort.c line 44
static void mksort(const char **x, signed int n, signed int depth, signed int maxdepth)
{
  signed int a;
  signed int b;
  signed int c;
  signed int d;
  signed int i;
  signed int j;
  signed int k;
  signed int r;
  signed int v;
  const char *tmp;
  signed int tmp_post$2;
  signed int tmp_post$3;
  if(n >= 2)
  {
    signed int return_value_rand$1;
    return_value_rand$1=rand();
    a = return_value_rand$1 % n;
    tmp = x[(signed long int)0];
    x[(signed long int)0] = x[(signed long int)a];
    x[(signed long int)a] = tmp;
    v = (signed int)x[(signed long int)0][(signed long int)depth];
    b = 1;
    a = b;
    d = n - 1;
    c = d;

  __CPROVER_DUMP_L2:
    ;
    for( ; (_Bool)1; c = c - 1)
    {
      if(c >= b)
      {
        r = (signed int)x[(signed long int)b][(signed long int)depth] - v;
        if(!(r >= 1))
        {
          if(r == 0)
          {
            tmp = x[(signed long int)a];
            x[(signed long int)a] = x[(signed long int)b];
            x[(signed long int)b] = tmp;
            a = a + 1;
          }

          b = b + 1;
          goto __CPROVER_DUMP_L2;
        }

      }

      for( ; c >= b; c = c - 1)
      {
        r = (signed int)x[(signed long int)c][(signed long int)depth] - v;
        if(!(r >= 0))
          break;

        if(r == 0)
        {
          tmp = x[(signed long int)c];
          x[(signed long int)c] = x[(signed long int)d];
          x[(signed long int)d] = tmp;
          d = d - 1;
        }

      }
      if(!(c >= b))
        break;

      tmp = x[(signed long int)b];
      x[(signed long int)b] = x[(signed long int)c];
      x[(signed long int)c] = tmp;
      b = b + 1;
    }
    r = a < b - a ? a : b - a;
    i = 0;
    j = b - r;
    k = r;
    do
    {
      tmp_post$2 = k;
      k = k - 1;
      if(!(tmp_post$2 >= 1))
        break;

      tmp = x[(signed long int)i];
      x[(signed long int)i] = x[(signed long int)j];
      x[(signed long int)j] = tmp;
      i = i + 1;
      j = j + 1;
    }
    while((_Bool)1);
    r = d - c < (n - d) - 1 ? d - c : (n - d) - 1;
    i = b;
    j = n - r;
    k = r;
    do
    {
      tmp_post$3 = k;
      k = k - 1;
      if(!(tmp_post$3 >= 1))
        break;

      tmp = x[(signed long int)i];
      x[(signed long int)i] = x[(signed long int)j];
      x[(signed long int)j] = tmp;
      i = i + 1;
      j = j + 1;
    }
    while((_Bool)1);
    r = b - a;
    mksort(x, r, depth, maxdepth);
    if(!((signed int)x[(signed long int)r][(signed long int)depth] == 0))
    {
      if(!(depth >= maxdepth))
        mksort(x + (signed long int)r, ((a + n) - d) - 1, depth + 1, maxdepth);

    }

    r = d - c;
    mksort((x + (signed long int)n) - (signed long int)r, r, depth, maxdepth);
  }

}

// openINFMTReaderAsFASTQ
// file infmt.c line 66
static signed int openINFMTReaderAsFASTQ(struct _InFmtReader *p, const char *filnamA, const char *filnamB, unsigned char doTest, signed int *errcode_test)
{
  signed int errcode = 0;
  p->sfAp=seqIOopen(&errcode, filnamA, (char)0, (unsigned long int)0);
  if(errcode == 0 && !(filnamB == ((const char *)NULL)))
    p->sfBp=seqIOopen(&errcode, filnamB, (char)0, (unsigned long int)0);

  if(errcode == 0 && !(doTest == 0))
  {
    struct _SeqFastq *rp;
    rp=seqFastqCreate(0, (char)0);
    *errcode_test=seqFastqRead(rp, p->sfAp);
    errcode=seqIOReset(p->sfAp);
    if(errcode == 0)
    {
      if(*errcode_test == 0)
      {
        if(!(filnamB == ((const char *)NULL)))
        {
          *errcode_test=seqFastqRead(rp, p->sfBp);
          errcode=seqIOReset(p->sfBp);
        }

      }

    }

    seqFastqDelete(rp);
  }

  return errcode;
}

// openINFMTReaderAsSAMBAM
// file infmt.c line 94
static signed int openINFMTReaderAsSAMBAM(struct _InFmtReader *p, const char *filnam, const char *tmpdir, unsigned char is_sam)
{
  signed int errcode = 0;
  const char *tmp_if_expr$1;
  if(!(is_sam == 0))
    tmp_if_expr$1 = BAMBAM_FILTYP_SAM;

  else
    tmp_if_expr$1 = BAMBAM_FILTYP_BAM;
  const char *tmp_if_expr$2;
  if(!(tmpdir == ((const char *)NULL)))
    tmp_if_expr$2 = tmpdir;

  else
    tmp_if_expr$2 = BAMBAM_TMPDIR_DEFAULT;
  p->fid=BamBam_AllocBamCollator(filnam, tmp_if_expr$1, tmp_if_expr$2, 1);
  if(!(p->fid >= 0))
    errcode = 9;

  return errcode;
}

// outputArgBlock
// file smalt.c line 1003
static signed int outputArgBlock(struct _ErrMsg *errmsgp, void *thargp, void *buffargp)
{
  signed int errcode = 0;
  signed short int i;
  struct _SmaltOutput *dop = (struct _SmaltOutput *)thargp;
  struct SmaltArgBlock_ *blockp = (struct SmaltArgBlock_ *)buffargp;
  /* assertion buffargp != ((void *)0) */
  assert(buffargp != (void *)0);
  i = (signed short int)0;
  for( ; errcode == 0 && !((signed int)i >= (signed int)blockp->n_iobf); i = i + 1)
    errcode=outputIOBuffArg(errmsgp, dop, blockp->iobfp + (signed long int)i);
  return errcode;
}

// outputHisto
// file smalt.c line 1288
static signed int outputHisto(struct _ErrMsg *errmsgp)
{
  signed int errcode = 0;
  struct _SmaltOutput *dop;
  void *return_value_threadsGetMem$1;
  return_value_threadsGetMem$1=threadsGetMem((unsigned char)3);
  dop = (struct _SmaltOutput *)return_value_threadsGetMem$1;
  if(!(dop->isamp == ((struct _InsSample *)NULL)))
  {
    struct _InsHist *ihistp;
    ihistp=insMakeHistoFromSample(dop->isamp);
    struct _IO_FILE *oufp;
    oufp=reportGetWriterStream(dop->writerp);
    if(oufp == ((struct _IO_FILE *)NULL))
    {
      errcode = 47;
      errMsgAdd(errmsgp, "", "smalt.c", 1297, errcode, (unsigned char)2);
    }

    fprintf(oufp, "# Sampled histogram\n");
    insPrintHisto(oufp, 80, (unsigned char)0, ihistp);
    fprintf(oufp, "# Smoothed histogram\n");
    insPrintHisto(oufp, 80, (unsigned char)1, ihistp);
    errcode=insWriteHisto(oufp, (unsigned char)0, ihistp);
    if(!(errcode == 0))
    {
      if(!(ihistp == ((struct _InsHist *)NULL)) || !(errcode == -1))
        errMsgAdd(errmsgp, "", "smalt.c", 1305, errcode, (unsigned char)2);

    }

    insDeleteHisto(ihistp);
  }

  return errcode;
}

// outputIOBuffArg
// file smalt.c line 838
static signed int outputIOBuffArg(struct _ErrMsg *errmsgp, struct _SmaltOutput *dop, struct _SmaltIOBuffArg *argp)
{
  signed int errcode = 0;
  const struct _SmaltMapConst *smcp;
  /* assertion dop != ((void *)0) */
  assert(dop != (struct _SmaltOutput *)(void *)0);
  /* assertion argp != ((void *)0) */
  assert(argp != (struct _SmaltIOBuffArg *)(void *)0);
  smcp = dop->smcp;
  /* assertion dop->smcp != ((void *)0) */
  assert(dop->smcp != (const struct _SmaltMapConst *)(void *)0);
  if(!((64 & (signed int)argp->pairflg) == 0))
  {
    if((signed int)smcp->subprogtyp == 4)
    {
      if(!(dop->isamp == ((struct _InsSample *)NULL)))
        insAddSample(dop->isamp, argp->isiz);

    }

  }

  dop->next_readno = argp->readno + (unsigned long int)1;
  _Bool tmp_if_expr$1;
  if(!((2048 & (signed int)smcp->menuflg) == 0))
  {
    if((signed int)smcp->outform == 2)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)smcp->outform == 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      reportFixMultiplePrimary(argp->rep);

  }

  errcode=reportWrite(dop->writerp, argp->readp, argp->matep, smcp->ssp, smcp->codecp, argp->rep);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "smalt.c", 872, errcode, (unsigned char)2);

  return errcode;
}

// parseHashOptions
// file menu.c line 1255
static signed int parseHashOptions(struct _MenuOpt *menup, struct _optflags *optflp, signed int narg, char **argp)
{
  signed int n;
  signed int iv;
  struct _INDEXMENU *ip = (struct _INDEXMENU *)menup->paramp;
  signed short int return_value_parseOption$1;
  signed short int return_value_parseOption$2;
  signed short int return_value_parseOption$3;
  if(!((signed int)menup->subprog == 1))
    return -3;

  else
  {
    switch((signed int)argp[(signed long int)0][(signed long int)1])
    {
      case 68:
      {
        return_value_parseOption$1=parseOption((void *)&menup->indir, "-D", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$1;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a directory name as argument.");

        break;
      }
      case 107:
      {
        return_value_parseOption$2=parseOption((void *)&iv, "-k", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$2;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 21 || !(iv >= 3))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)3, (signed long int)20);

          ip->kmer = (unsigned char)(char)iv;
          optflp->kmer = (unsigned int)1;
        }

        break;
      }
      case 115:
      {
        return_value_parseOption$3=parseOption((void *)&iv, "-s", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$3;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 128 || !(iv >= 1))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)1, (signed long int)127);

          ip->skip = (unsigned char)(char)iv;
          optflp->skip = (unsigned int)1;
        }

        break;
      }
      default:
        n = -3;
    }
    return n;
  }
}

// parseListOfKeyValueAssignments
// file menu.c line 875
static void parseListOfKeyValueAssignments(signed char *vals, unsigned char *bitfld, struct EString_ *estrbufp, const struct VARLST_ *lst, signed short int nelem, const char *listp)
{
  char *parkey;
  char *liststr;
  signed short int i;
  *bitfld = (unsigned char)0;
  estrbufp->strp[(signed long int)0] = (char)0;
  estrbufp->len = (unsigned long int)0;
  signed int return_value_eStringAppend$1;
  return_value_eStringAppend$1=eStringAppend(&(*estrbufp), listp, "menu.c", 885);
  if(!(return_value_eStringAppend$1 == 0))
    exit(1);

  liststr = estrbufp->strp;
  parkey=strtok(liststr, OUFMT_LISTSEP);
  char *tmp_post$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  while(!(parkey == ((char *)NULL)))
  {
    char *value;
    char *cp;
    signed int ival = 0;
    value = parkey;
    for( ; !(*value == 0); value = value + 1l)
      if((signed int)*value == 61)
      {
        tmp_post$2 = value;
        value = value + 1l;
        *tmp_post$2 = (char)0;
        break;
      }

    cp = value;
    if((signed int)*cp == 43)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)*cp == 45 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      cp = cp + 1l;

    do
    {
      if(!(*cp == 0))
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        tmp_if_expr$5 = ((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*cp] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      cp = cp + 1l;
    }
    while((_Bool)1);
    if(!((signed int)*cp == 0))
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = 0 == (signed int)*value ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
    {
      printf("Error: wrong format string %s.\n", parkey);
      exit(1);
    }

    ival=atoi(value);
    if(ival >= 256)
    {
      printf("Error: wrong format string %s.\n", parkey);
      exit(1);
    }

    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)nelem); i = i + 1)
    {
      signed int return_value_strcmp$8;
      return_value_strcmp$8=strcmp(parkey, (lst + (signed long int)i)->varnam);
      if(return_value_strcmp$8 == 0)
      {
        if(!(ival >= (signed int)(lst + (signed long int)i)->min))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = ival > (signed int)(lst + (signed long int)i)->max ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
        {
          printf("Error: value %s=%hi is outside the range [%hi,%hi].\n", parkey, ival, (signed short int)(lst + (signed long int)i)->min, (signed short int)(lst + (signed long int)i)->max);
          exit(1);
        }

        vals[(signed long int)i] = (signed char)(unsigned char)ival;
        *bitfld = (unsigned char)((signed int)*bitfld | (signed int)(unsigned char)1 << (signed int)i);
        value = value - 1l;
        *value = (char)61;
        break;
      }

    }
    if(i == nelem)
    {
      printf("Error: Keyword '%s' not recognised in list of penalty assignments.\n", parkey);
      exit(1);
    }

    parkey=strtok((char *)(void *)0, OUFMT_PARSEP);
  }
}

// parseMapOptions
// file menu.c line 1297
static signed int parseMapOptions(struct _MenuOpt *menup, struct _optflags *optflp, signed int narg, char **argp)
{
  signed int n;
  signed int iv;
  signed int okflg = 1;
  signed int iserr = 0;
  double fv;
  struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  signed short int return_value_parseOption$1;
  signed short int return_value_parseOption$2;
  signed short int return_value_parseOption$3;
  signed short int return_value_parseOption$4;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed short int return_value_parseOption$10;
  signed short int return_value_parseOption$11;
  signed short int return_value_parseOption$12;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed short int return_value_parseOption$17;
  signed short int return_value_parseOption$18;
  signed short int return_value_parseOption$19;
  signed short int return_value_parseOption$20;
  signed short int return_value_parseOption$21;
  signed short int return_value_parseOption$22;
  signed short int return_value_parseOption$23;
  signed int return_value_strcmp$24;
  signed short int return_value_parseOption$25;
  signed short int return_value_parseOption$26;
  signed short int return_value_parseOption$27;
  signed short int return_value_parseOption$28;
  if(!((signed int)menup->subprog == 2))
    return -3;

  else
  {
    switch((signed int)argp[(signed long int)0][(signed long int)1])
    {
      case 97:
      {
        return_value_parseOption$1=parseOption((void *)0, "-a", (char)0, narg, argp);
        n = (signed int)return_value_parseOption$1;
        if(!(n == -3))
          mp->flags = mp->flags | (unsigned short int)128;

        break;
      }
      case 68:
      {
        return_value_parseOption$2=parseOption((void *)&menup->indir, "-D", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$2;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a directory name as argument.");

        break;
      }
      case 99:
      {
        return_value_parseOption$3=parseOption((void *)&fv, "-c", (char)4, narg, argp);
        n = (signed int)return_value_parseOption$3;
        if(!(n == -3))
        {
          if(fv < -0.000000 || n == -1 || fv > 32767.000000)
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fff);

          mp->mincover = fv;
          optflp->mincover = (unsigned int)1;
        }

        break;
      }
      case 100:
      {
        return_value_parseOption$4=parseOption((void *)&iv, "-d", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$4;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 32768 || !(iv >= -32768))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)(-0x7fff - 1), (signed long int)0x7fff);

          mp->scorediff = (signed short int)iv;
          optflp->scorediff = (unsigned int)1;
          mp->flags = mp->flags | (unsigned short int)2048;
        }

        break;
      }
      case 102:
      {
        n = 2;
        iserr = 0;
        return_value_strcmp$5=strcmp(argp[(signed long int)0], "-f");
        if(!(return_value_strcmp$5 == 0))
          n = -3;

        else
          if(!(narg >= 2))
          {
            n = -1;
            exitOptionError(argp[(signed long int)0], "requires an output format [cigar|sam|samsoft|ssaha|gff] as argument.");
          }

          else
            parseOutputFormat(&mp->oufmt, &menup->estrbuf, argp[(signed long int)0], argp[(signed long int)1]);
        break;
      }
      case 70:
      {
        iserr = 0;
        return_value_strcmp$9=strcmp(argp[(signed long int)0], "-F");
        if(!(return_value_strcmp$9 == 0))
          n = -3;

        else
          if(!(narg >= 2))
          {
            n = -1;
            iserr = 1;
            exitOptionError(argp[(signed long int)0], "requires an input format [fastq|sam|bam] as argument.");
          }

          else
          {
            n = 2;
            signed int return_value_strcmp$8;
            return_value_strcmp$8=strcmp(argp[(signed long int)1], "fastq");
            if(return_value_strcmp$8 == 0)
              mp->inform = (unsigned char)1;

            else
            {
              return_value_strcmp$7=strcmp(argp[(signed long int)1], "sam");
              if(return_value_strcmp$7 == 0)
                mp->inform = (unsigned char)2;

              else
              {
                return_value_strcmp$6=strcmp(argp[(signed long int)1], "bam");
                if(return_value_strcmp$6 == 0)
                  mp->inform = (unsigned char)3;

                else
                  iserr = 1;
              }
            }
          }
        if(!(iserr == 0))
          exitOptionError(argp[(signed long int)0], "requires an input format [fastq|sam|bam] as argument.");

        break;
      }
      case 103:
      {
        return_value_parseOption$10=parseOption((void *)&mp->insfilnam, "-g", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$10;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a file name as argument.");

        break;
      }
      case 105:
      {
        return_value_parseOption$11=parseOption((void *)&iv, "-i", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$11;
        if(!(n == -3))
        {
          if(n == -1 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fffffff);

          mp->insert_range[(signed long int)1] = iv;
          optflp->insertmax = (unsigned int)1;
        }

        break;
      }
      case 106:
      {
        return_value_parseOption$12=parseOption((void *)&iv, "-j", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$12;
        if(!(n == -3))
        {
          if(n == -1 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fffffff);

          mp->insert_range[(signed long int)0] = iv;
          optflp->insertmin = (unsigned int)1;
        }

        break;
      }
      case 108:
      {
        okflg = 1;
        return_value_strcmp$16=strcmp(argp[(signed long int)0], "-l");
        if(!(return_value_strcmp$16 == 0))
          n = -3;

        else
          if(!(narg >= 2))
          {
            n = -1;
            okflg = 0;
          }

          else
          {
            n = 2;
            signed int return_value_strcmp$15;
            return_value_strcmp$15=strcmp(argp[(signed long int)1], "pe");
            if(return_value_strcmp$15 == 0)
            {
              mp->flags = mp->flags & (unsigned short int)~8192;
              mp->pairtyp = (unsigned char)2;
              optflp->pairtyp = (unsigned int)1;
            }

            else
            {
              return_value_strcmp$14=strcmp(argp[(signed long int)1], "mp");
              if(return_value_strcmp$14 == 0)
              {
                mp->flags = mp->flags | (unsigned short int)8192;
                mp->pairtyp = (unsigned char)3;
                optflp->pairtyp = (unsigned int)1;
              }

              else
              {
                return_value_strcmp$13=strcmp(argp[(signed long int)1], "pp");
                if(return_value_strcmp$13 == 0)
                {
                  mp->flags = mp->flags & (unsigned short int)~8192;
                  mp->pairtyp = (unsigned char)4;
                  optflp->pairtyp = (unsigned int)1;
                }

                else
                  okflg = 0;
              }
            }
          }
        if(okflg == 0)
          exitOptionError(argp[(signed long int)0], "requires a read pair library type [pe|mp|pp] as argument.");

        break;
      }
      case 109:
      {
        return_value_parseOption$17=parseOption((void *)&iv, "-m", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$17;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 32768 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fff);

          mp->minscore = (signed short int)iv;
          optflp->minscore = (unsigned int)1;
          mp->flags = mp->flags | (unsigned short int)1024;
        }

        break;
      }
      case 110:
      {
        return_value_parseOption$18=parseOption((void *)&iv, "-n", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$18;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 32768 || !(iv >= 1))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fff);

          mp->nthread = (signed short int)iv;
        }

        break;
      }
      case 111:
      {
        return_value_parseOption$19=parseOption((void *)&mp->oufilnam, "-o", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$19;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a file name as argument.");

        break;
      }
      case 79:
      {
        return_value_parseOption$20=parseOption((void *)0, "-O", (char)0, narg, argp);
        n = (signed int)return_value_parseOption$20;
        if(!(n == -3))
          mp->flags = mp->flags | (unsigned short int)16384;

        break;
      }
      case 112:
      {
        return_value_parseOption$21=parseOption((void *)0, "-p", (char)0, narg, argp);
        n = (signed int)return_value_parseOption$21;
        if(!(n == -3))
          mp->flags = mp->flags | (unsigned short int)256;

        break;
      }
      case 113:
      {
        return_value_parseOption$22=parseOption((void *)&iv, "-q", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$22;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 11 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)10);

          mp->minbasq = (unsigned char)iv;
          optflp->minbasq = (unsigned int)1;
        }

        break;
      }
      case 114:
      {
        return_value_parseOption$23=parseOption((void *)&iv, "-r", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$23;
        if(!(n == -3))
        {
          if(n == -1)
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fffffff);

          if(!(iv >= 0))
            mp->flags = mp->flags & (unsigned short int)~4096;

          else
          {
            mp->randseed_repeat = iv;
            optflp->randrepeat = (unsigned int)1;
            mp->flags = mp->flags | (unsigned short int)4096;
          }
        }

        break;
      }
      case 83:
      {
        n = 2;
        iserr = 0;
        return_value_strcmp$24=strcmp(argp[(signed long int)0], "-S");
        if(!(return_value_strcmp$24 == 0))
          n = -3;

        else
          if(!(narg >= 2))
          {
            n = -1;
            exitOptionError(argp[(signed long int)0], "requires list of assignments as argument (eg. 'mismatch=-2,gapopen=-5,gapext=-4').");
          }

          else
          {
            parseListOfKeyValueAssignments(mp->penalties, &mp->penaltyflags, &menup->estrbuf, MENU_PENALTY_LST, (signed short int)4, argp[(signed long int)1]);
            optflp->penalties = (unsigned int)1;
          }
        break;
      }
      case 84:
      {
        return_value_parseOption$25=parseOption((void *)&mp->tmpdirnam, "-T", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$25;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a directory name as argument.");

        break;
      }
      case 119:
      {
        return_value_parseOption$26=parseOption((void *)0, "-w", (char)0, narg, argp);
        n = (signed int)return_value_parseOption$26;
        if(!(n == -3))
          mp->flags = mp->flags | (unsigned short int)2;

        break;
      }
      case 120:
      {
        return_value_parseOption$27=parseOption((void *)0, "-x", (char)0, narg, argp);
        n = (signed int)return_value_parseOption$27;
        if(!(n == -3))
          mp->flags = mp->flags | (unsigned short int)512;

        break;
      }
      case 121:
      {
        return_value_parseOption$28=parseOption((void *)&fv, "-y", (char)4, narg, argp);
        n = (signed int)return_value_parseOption$28;
        if(!(n == -3))
        {
          if(fv < -0.000000 || n == -1 || fv > 32767.000000)
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fff);

          mp->minidentity = fv;
          optflp->minidentity = (unsigned int)1;
        }

        break;
      }
      default:
        n = -3;
    }
    return n;
  }
}

// parseOption
// file menu.c line 1036
static signed short int parseOption(void *optarg, const char *optnam, char optyp, signed int narg, char * const *argp)
{
  signed short int rv;
  char *cp;
  char **strpp;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(argp[(signed long int)0], optnam);
  char *tmp_post$2;
  if(!(return_value_strcmp$1 == 0))
    return (signed short int)-3;

  else
  {
    switch((signed int)optyp)
    {
      case 1:
      {
        if(!(narg >= 2))
          rv = (signed short int)-1;

        else
        {
          strpp = (char **)optarg;
          free((void *)*strpp);
          *strpp=estrcpy(argp[(signed long int)1], "menu.c", 1056);
          rv = (signed short int)(*strpp != ((char *)NULL) ? 2 : -2);
        }
        break;
      }
      case 2:
      {
        if(!(narg >= 2))
          rv = (signed short int)-1;

        else
        {
          *((signed int *)optarg)=atoi(argp[(signed long int)1]);
          rv = (signed short int)2;
        }
        break;
      }
      case 3:
      {
        if(!(narg >= 2))
          rv = (signed short int)-1;

        else
        {
          cp = argp[(signed long int)1];
          for( ; !(*cp == 0); cp = cp + 1l)
            if((signed int)*cp == 44)
            {
              tmp_post$2 = cp;
              cp = cp + 1l;
              *tmp_post$2 = (char)0;
              break;
            }

          if(!(*cp == 0))
          {
            *((signed int *)optarg)=atoi(argp[(signed long int)1]);
            ((signed int *)optarg)[(signed long int)1]=atoi(cp);
            rv = (signed short int)2;
          }

          else
            rv = (signed short int)-4;
        }
        break;
      }
      case 4:
      {
        if(!(narg >= 2))
          rv = (signed short int)-1;

        else
        {
          *((double *)optarg)=atof(argp[(signed long int)1]);
          rv = (signed short int)2;
        }
        break;
      }
      case 0:
      {
        rv = (signed short int)1;
        break;
      }
      default:
        rv = (signed short int)-3;
    }
    return rv;
  }
}

// parseOutputFormat
// file menu.c line 985
static void parseOutputFormat(struct _OUFMT *oufmt, struct EString_ *estrbufp, const char *optstr, const char *formatp)
{
  unsigned char is_err = (unsigned char)0;
  estrbufp->strp[(signed long int)0] = (char)0;
  estrbufp->len = (unsigned long int)0;
  signed int return_value_eStringAppend$1;
  return_value_eStringAppend$1=eStringAppend(&(*estrbufp), formatp, "menu.c", 990);
  if(!(return_value_eStringAppend$1 == 0))
    exit(1);

  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  if(formatp == ((const char *)NULL))
    is_err = (unsigned char)1;

  else
  {
    char *fmtstr = estrbufp->strp;
    char *fmtkey;
    fmtkey=strtok(fmtstr, OUFMT_TYPSEP);
    signed int return_value_strcmp$7;
    return_value_strcmp$7=strcmp(fmtkey, "cigar");
    if(return_value_strcmp$7 == 0)
      oufmt->typ = (unsigned char)0;

    else
    {
      return_value_strcmp$6=strcmp(fmtkey, "sam");
      if(return_value_strcmp$6 == 0)
      {
        char *par;
        par=strtok((char *)(void *)0, OUFMT_TYPSEP);
        oufmt->typ = (unsigned char)1;
        parseSamParams(&oufmt->flags, par, optstr);
      }

      else
      {
        return_value_strcmp$5=strcmp(fmtkey, "samsoft");
        if(return_value_strcmp$5 == 0)
        {
          oufmt->typ = (unsigned char)1;
          oufmt->flags = (unsigned char)1;
        }

        else
        {
          return_value_strcmp$4=strcmp(fmtkey, "bam");
          if(return_value_strcmp$4 == 0)
          {
            char *parseOutputFormat$$1$$2$$4$$par;
            parseOutputFormat$$1$$2$$4$$par=strtok((char *)(void *)0, OUFMT_TYPSEP);
            oufmt->typ = (unsigned char)2;
            parseSamParams(&oufmt->flags, parseOutputFormat$$1$$2$$4$$par, optstr);
          }

          else
          {
            return_value_strcmp$3=strcmp(fmtkey, "ssaha");
            if(return_value_strcmp$3 == 0)
              oufmt->typ = (unsigned char)3;

            else
            {
              return_value_strcmp$2=strcmp(fmtkey, "gff");
              if(return_value_strcmp$2 == 0)
                oufmt->typ = (unsigned char)4;

              else
                is_err = (unsigned char)1;
            }
          }
        }
      }
    }
  }
  if(!(is_err == 0))
    exitOptionError(optstr, "requires an output format [sam|bam|cigar|ssaha|gff] as argument.");

}

// parseSamParams
// file menu.c line 937
static void parseSamParams(unsigned char *samflg, const char *formatp, const char *optstr)
{
  unsigned char is_err = (unsigned char)0;
  char *parkey;
  char *fmtstr;
  struct EString_ *estrbufp;
  estrbufp=eStringCreate(0, "menu.c", 945);
  if(estrbufp == ((struct EString_ *)NULL))
    exit(1);

  *samflg = (unsigned char)1;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  if(!(formatp == ((const char *)NULL)))
  {
    estrbufp->strp[(signed long int)0] = (char)0;
    estrbufp->len = (unsigned long int)0;
    signed int return_value_eStringAppend$1;
    return_value_eStringAppend$1=eStringAppend(&(*estrbufp), formatp, "menu.c", 954);
    if(!(return_value_eStringAppend$1 == 0))
    {
      eStringDelete(&estrbufp, "menu.c", 955);
      exit(1);
    }

    fmtstr = estrbufp->strp;
    parkey=strtok(fmtstr, OUFMT_PARSEP);
    while(is_err == 0 && !(parkey == ((char *)NULL)))
    {
      signed int return_value_strcmp$6;
      return_value_strcmp$6=strcmp(parkey, "nohead");
      if(return_value_strcmp$6 == 0)
        *samflg = *samflg & (unsigned char)~1;

      else
      {
        return_value_strcmp$5=strcmp(parkey, "clip");
        if(return_value_strcmp$5 == 0)
          *samflg = *samflg | (unsigned char)2;

        else
        {
          return_value_strcmp$2=strcmp(parkey, "x");
          if(return_value_strcmp$2 == 0)
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            return_value_strcmp$3=strcmp(parkey, "X");
            tmp_if_expr$4 = !(return_value_strcmp$3 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
            *samflg = *samflg | (unsigned char)4;

          else
          {
            is_err = (unsigned char)1;
            break;
          }
        }
      }
      parkey=strtok((char *)(void *)0, OUFMT_PARSEP);
    }
    eStringDelete(&estrbufp, "menu.c", 976);
    if(!(is_err == 0))
    {
      printf("Error: Keyword '%s' not recognised in format specification (%s sam).\n", parkey, optstr);
      exit(1);
    }

  }

}

// parseSampleOptions
// file menu.c line 1553
static signed int parseSampleOptions(struct _MenuOpt *menup, struct _optflags *optflp, signed int narg, char **argp)
{
  signed int n;
  signed int iv;
  struct _MAPMENU *mp = (struct _MAPMENU *)menup->paramp;
  signed int iserr;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  signed short int return_value_parseOption$5;
  signed short int return_value_parseOption$6;
  signed short int return_value_parseOption$7;
  signed short int return_value_parseOption$8;
  signed short int return_value_parseOption$9;
  signed short int return_value_parseOption$10;
  signed short int return_value_parseOption$11;
  if(!((signed int)menup->subprog == 4))
    return -3;

  else
  {
    switch((signed int)argp[(signed long int)0][(signed long int)1])
    {
      case 70:
      {
        iserr = 0;
        return_value_strcmp$4=strcmp(argp[(signed long int)0], "-F");
        if(!(return_value_strcmp$4 == 0))
          n = -3;

        else
          if(!(narg >= 2))
          {
            n = -1;
            iserr = 1;
            exitOptionError(argp[(signed long int)0], "requires an input format [fastq|sam|bam] as argument.");
          }

          else
          {
            n = 2;
            signed int return_value_strcmp$3;
            return_value_strcmp$3=strcmp(argp[(signed long int)1], "fastq");
            if(return_value_strcmp$3 == 0)
              mp->inform = (unsigned char)1;

            else
            {
              return_value_strcmp$2=strcmp(argp[(signed long int)1], "sam");
              if(return_value_strcmp$2 == 0)
                mp->inform = (unsigned char)2;

              else
              {
                return_value_strcmp$1=strcmp(argp[(signed long int)1], "bam");
                if(return_value_strcmp$1 == 0)
                  mp->inform = (unsigned char)3;

                else
                  iserr = 1;
              }
            }
          }
        if(!(iserr == 0))
          exitOptionError(argp[(signed long int)0], "requires an input format [fastq|sam|bam] as argument.");

        break;
      }
      case 109:
      {
        return_value_parseOption$5=parseOption((void *)&iv, "-m", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$5;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 32768 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fff);

          mp->minscore = (signed short int)iv;
          optflp->minscore = (unsigned int)1;
          mp->flags = mp->flags | (unsigned short int)1024;
        }

        break;
      }
      case 110:
      {
        return_value_parseOption$6=parseOption((void *)&iv, "-n", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$6;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 32768 || !(iv >= 1))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fff);

          mp->nthread = (signed short int)iv;
        }

        break;
      }
      case 111:
      {
        return_value_parseOption$7=parseOption((void *)&mp->oufilnam, "-o", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$7;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a file name as argument.");

        break;
      }
      case 113:
      {
        return_value_parseOption$8=parseOption((void *)&iv, "-q", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$8;
        if(!(n == -3))
        {
          if(n == -1 || iv >= 11 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)10);

          mp->minbasq = (unsigned char)iv;
          optflp->minbasq = (unsigned int)1;
        }

        break;
      }
      case 116:
      {
        return_value_parseOption$9=parseOption((void *)&iv, "-t", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$9;
        if(!(n == -3))
        {
          if(n == -1 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fffffff);

          mp->mapqmin = iv;
          optflp->mapqmin = (unsigned int)1;
        }

        break;
      }
      case 84:
      {
        return_value_parseOption$10=parseOption((void *)&mp->tmpdirnam, "-T", (char)1, narg, argp);
        n = (signed int)return_value_parseOption$10;
        if(n == -1)
          exitOptionError(argp[(signed long int)0], "requires a directory name as argument.");

        break;
      }
      case 117:
      {
        return_value_parseOption$11=parseOption((void *)&iv, "-u", (char)2, narg, argp);
        n = (signed int)return_value_parseOption$11;
        if(!(n == -3))
        {
          if(n == -1 || !(iv >= 0))
            exitArgumentRangeError(argp[(signed long int)0], (signed long int)0, (signed long int)0x7fffffff);

          mp->readskip = iv;
          optflp->readskip = (unsigned int)1;
        }

        break;
      }
      default:
        n = -3;
    }
    return n;
  }
}

// prepSample
// file smalt.c line 1253
static signed int prepSample(struct _ErrMsg *errmsgp, const struct _SmaltMapConst *common_args)
{
  signed int errcode = 0;
  signed long int nreads = (signed long int)0;
  struct _SmaltInput *input_args;
  void *return_value_threadsGetMem$1;
  return_value_threadsGetMem$1=threadsGetMem((unsigned char)1);
  input_args = (struct _SmaltInput *)return_value_threadsGetMem$1;
  struct SmaltArgBlock_ *blockp;
  void *return_value_threadsGetMem$2;
  return_value_threadsGetMem$2=threadsGetMem((unsigned char)0);
  blockp = (struct SmaltArgBlock_ *)return_value_threadsGetMem$2;
  struct _SmaltOutput *dop;
  void *return_value_threadsGetMem$3;
  return_value_threadsGetMem$3=threadsGetMem((unsigned char)3);
  dop = (struct _SmaltOutput *)return_value_threadsGetMem$3;
  struct _SmaltIOBuffArg *iobfp;
  /* assertion common_args != ((void *)0) */
  assert(common_args != (const struct _SmaltMapConst *)(void *)0);
  /* assertion input_args != ((void *)0) */
  assert(input_args != (struct _SmaltInput *)(void *)0);
  /* assertion blockp != ((void *)0) */
  assert(blockp != (struct SmaltArgBlock_ *)(void *)0);
  /* assertion dop != ((void *)0) */
  assert(dop != (struct _SmaltOutput *)(void *)0);
  iobfp = blockp->iobfp;
  /* assertion iobfp != ((void *)0) */
  assert(iobfp != (struct _SmaltIOBuffArg *)(void *)0);
  errcode=infmtCheckReads(input_args->ifrp, iobfp->readp, iobfp->matep, &nreads, (unsigned int *)(void *)0, (unsigned int *)(void *)0, errmsgp);
  if(!(errcode == 0) && !(errcode == 76))
    return errcode;

  else
  {
    if(!((4 & (signed int)common_args->menuflg) == 0))
      fprintf(stderr, "# Check of read pairs ok ...\n# Mate names %s ...\n", errcode == 76 ? "don't match" : "match");

    infmtReset(input_args->ifrp);
    insSetSamplingInterval(dop->isamp, (unsigned long int)nreads, common_args->readskip);
    setInSampleIntervalInput(input_args, dop->isamp);
    return errcode;
  }
}

// printBlurb
// file menu.c line 820
static void printBlurb(struct _IO_FILE *oufp)
{
  fprintf(oufp, "\n%s\n", (const void *)MENU_PROGNAM);
  fprintf(oufp, "Version: %s\n", (const void *)MENU_RELEASE_VERSION);
  fprintf(oufp, "Date:    %s\n", (const void *)MENU_RELEASE_DATE);
  fprintf(oufp, "Author:  %s (%s)\n\n", (const void *)MENU_RELEASE_AUTHORS, (const void *)MENU_RELEASE_BUGREPORT);
  fprintf(oufp, "%s\n\n", (const void *)MENU_COPYRIGHT_NOTICE);
}

// printSEGCAND
// file segment.c line 918
static signed int printSEGCAND(struct _IO_FILE *fp, const struct _SEGCAND *scp)
{
  signed int nchar;
  nchar=fprintf(fp, "SEGCAND qs = %u, qe = %u, rs = %u, re = %u, shiftoffs = %hi, seqidx = %i, srange = %hi, cover = %u, strand = %c, shift2mm = %hi, mmali = %hi\n", scp->qs, scp->qe, scp->rs, scp->re, scp->shiftoffs, scp->seqidx, scp->srange, scp->cover, ((signed int)scp->flag & 1) != 0 ? 82 : 70, scp->shift2mm, (signed short int)((signed int)scp->flag & 4));
  return nchar > 0 ? 0 : -1;
}

// printSeed
// file segment.c line 378
static void printSeed(struct _IO_FILE *fp, const struct _SEED$0 *sp, char is_reverse, unsigned char nskip, unsigned char ktup)
{
  unsigned int qo = (unsigned int)(sp->sqo & (unsigned long int)2147483647);
  unsigned long int so;
  unsigned long int shift = sp->sqo >> 31;
  if(!(is_reverse == 0))
  {
    so = shift - (unsigned long int)(qo / (unsigned int)nskip);
    so = (so * (unsigned long int)nskip + (unsigned long int)ktup) - (unsigned long int)sp->len;
  }

  else
  {
    so = shift + (unsigned long int)(qo / (unsigned int)nskip) & (unsigned long int)-1;
    so = so * (unsigned long int)nskip;
  }
  fprintf(fp, "SEED shift = %llu, s = %llu, q = %u, l = %i, strand = %i\n", (unsigned long long int)shift, (unsigned long long int)so, qo, sp->len, (signed int)is_reverse);
}

// printWord
// file hashidx.c line 174
static char * printWord(char *buff, unsigned long int word, unsigned char len)
{
  const char alphabet[5l] = { 'A', 'C', 'G', 'T', 0 };
  unsigned char i = len;
  for( ; (signed int)i >= 1; i = i - 1)
  {
    buff[(signed long int)((signed int)i - 1)] = alphabet[(signed long int)(word & (unsigned long int)3)];
    word = word >> 2;
  }
  buff[(signed long int)len] = (char)0;
  return buff;
}

// processArgBlock
// file smalt.c line 1221
static signed int processArgBlock(struct _ErrMsg *errmsgp, void *targp, void *bufargp)
{
  signed int errcode = 0;
  signed short int i;
  struct _SmaltMapArgs *map = (struct _SmaltMapArgs *)targp;
  struct SmaltArgBlock_ *blockp = (struct SmaltArgBlock_ *)bufargp;
  i = (signed short int)0;
  for( ; errcode == 0 && !((signed int)i >= (signed int)blockp->n_iobf); i = i + 1)
    errcode=processMapArgs(errmsgp, map, blockp->iobfp + (signed long int)i);
  return errcode;
}

// processMapArgs
// file smalt.c line 1083
static signed int processMapArgs(struct _ErrMsg *errmsgp, struct _SmaltMapArgs *map, struct _SmaltIOBuffArg *brgp)
{
  signed int errcode;
  unsigned char is_frac;
  unsigned int covermin_tuple;
  const struct _ResultSet *rsltp;
  const struct _SmaltMapConst *macop;
  struct _SeqFastq *readp;
  struct _SeqFastq *matep;
  /* assertion map != ((void *)0) */
  assert(map != (struct _SmaltMapArgs *)(void *)0);
  /* assertion brgp != ((void *)0) */
  assert(brgp != (struct _SmaltIOBuffArg *)(void *)0);
  macop = map->smconstp;
  /* assertion macop != ((void *)0) */
  assert(macop != (const struct _SmaltMapConst *)(void *)0);
  readp = brgp->readp;
  matep = brgp->matep;
  errMsgSetCurrentReadNumber(errmsgp, brgp->readno + (unsigned long int)1);
  const char *return_value_seqFastqGetSeqName$1;
  return_value_seqFastqGetSeqName$1=seqFastqGetSeqName(readp);
  errMsgSetCurrentReadName(errmsgp, return_value_seqFastqGetSeqName$1);
  signed int return_value_resultSetInferInsertSize$2;
  if(macop->tupcovmin < 0.000000)
    return 47;

  else
  {
    errcode=seqFastqEncode(readp, macop->codecp);
    if(!(errcode == 0))
    {
      errMsgAdd(errmsgp, "", "smalt.c", 1111, errcode, (unsigned char)2);
      return errcode;
    }

    else
    {
      if(macop->tupcovmin < 1.01)
      {
        unsigned int readlen;
        seqFastqGetConstSequence(readp, &readlen, (char *)(void *)0);
        if(readlen >= 2147483648u)
          errMsgAdd(errmsgp, "", "smalt.c", 1119, 48, (unsigned char)2);

        covermin_tuple = (unsigned int)(macop->tupcovmin * (double)readlen);
        if(!(readlen >= covermin_tuple))
          covermin_tuple = readlen;

        is_frac = (unsigned char)1;
      }

      else
      {
        is_frac = (unsigned char)0;
        covermin_tuple = (unsigned int)macop->tupcovmin;
      }
      if(!(brgp->isPaired == 0))
      {
        unsigned int covermin_tuple_mate;
        const struct _ResultSet *rslt_matep;
        const struct _ResultPairs *pairp;
        errcode=seqFastqEncode(matep, macop->codecp);
        if(!(errcode == 0))
        {
          errMsgAdd(errmsgp, "", "smalt.c", 1135, errcode, (unsigned char)2);
          return errcode;
        }

        if(!(is_frac == 0))
        {
          unsigned int matelen;
          seqFastqGetConstSequence(matep, &matelen, (char *)(void *)0);
          if(matelen >= 2147483648u)
            errMsgAdd(errmsgp, "", "smalt.c", 1143, 48, (unsigned char)2);

          covermin_tuple_mate = (unsigned int)(macop->tupcovmin * (double)matelen);
          if(!(matelen >= covermin_tuple_mate))
            covermin_tuple_mate = matelen;

        }

        else
          covermin_tuple_mate = covermin_tuple;
        rmapPair(errmsgp, map->rmp, readp, matep, &brgp->pairflg, macop->insert_min, macop->insert_max, macop->pairtyp, macop->nhitmax_tuple, (unsigned int)(signed int)covermin_tuple, (unsigned int)(signed int)covermin_tuple_mate, macop->min_swatscor, macop->minbasq, (signed short int)512, (signed short int)2048, (unsigned short int)((signed int)macop->rmapflg | 64), macop->scormtxp, macop->rfp, macop->htp, macop->ssp, macop->codecp);
        rmapGetData(&rsltp, &rslt_matep, &pairp, (struct _SeqFastq **)(void *)0, (struct _SeqFastq **)(void *)0, map->rmp);
        errcode=resultSetAddPairToReport(brgp->rep, macop->ihp, pairp, brgp->pairflg, macop->rsltouflg, rsltp, rslt_matep);
        if(!(errcode == 0))
          errMsgAdd(errmsgp, "", "smalt.c", 1178, errcode, (unsigned char)2);

        if((signed int)macop->subprogtyp == 4)
        {
          return_value_resultSetInferInsertSize$2=resultSetInferInsertSize(&brgp->isiz, (unsigned char)1, rsltp, rslt_matep);
          if(return_value_resultSetInferInsertSize$2 == 0)
            brgp->pairflg = brgp->pairflg | (unsigned char)64;

        }

      }

      else
      {
        rmapSingle(errmsgp, map->rmp, readp, macop->nhitmax_tuple, covermin_tuple, (signed int)macop->min_swatscor, macop->swatscordiff, macop->minbasq, (signed short int)512, (signed short int)2048, (unsigned short int)((signed int)macop->rmapflg & ~4), macop->scormtxp, macop->rfp, macop->htp, macop->ssp, macop->codecp);
        rmapGetData(&rsltp, (const struct _ResultSet **)(void *)0, (const struct _ResultPairs **)(void *)0, (struct _SeqFastq **)(void *)0, (struct _SeqFastq **)(void *)0, map->rmp);
        errcode=resultSetAddToReport(brgp->rep, macop->rsltouflg, rsltp);
        if(!(errcode == 0))
          errMsgAdd(errmsgp, "", "smalt.c", 1216, errcode, (unsigned char)2);

      }
      return errcode;
    }
  }
}

// propagateMapQualAsProb
// file results.c line 1355
static signed int propagateMapQualAsProb(signed short int qsegx, const struct _ResultSet *rsetp)
{
  signed short int i;
  signed short int ns;
  signed short int nn;
  signed short int n1 = (signed short int)0;
  signed short int n2 = (signed short int)0;
  double p1 = 0.0;
  double p2 = 0.0;
  struct _RESULT **rspp;
  _Bool tmp_if_expr$1;
  if((8 & (signed int)rsetp->status) == 0 || !((signed int)qsegx >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)qsegx >= (signed int)rsetp->qsegno ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$1)
    return 47;

  else
  {
    rspp = rsetp->segsrtr + (signed long int)rsetp->segnor[(signed long int)qsegx];
    nn = (signed short int)((signed int)rsetp->segnor[(signed long int)((signed int)qsegx + 1)] - (signed int)rsetp->segnor[(signed long int)qsegx]);
    if(!((signed int)nn >= 1))
      return 0;

    else
    {
      i = (signed short int)1;
      do
      {
        if(!((signed int)i >= (signed int)nn))
          tmp_if_expr$2 = rspp[(signed long int)i]->swatscor == rspp[(signed long int)0]->swatscor ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      n1 = i;
      if(!((signed int)i >= (signed int)nn))
      {
        i = i + 1;
        do
        {
          if(!((signed int)i >= (signed int)nn))
            tmp_if_expr$3 = rspp[(signed long int)i]->swatscor == rspp[(signed long int)n1]->swatscor ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          i = i + 1;
        }
        while((_Bool)1);
        n2 = (signed short int)((signed int)i - (signed int)n1);
      }

      if((signed int)n1 == 1)
      {
        signed int isc = rspp[(signed long int)0]->mapscor;
        if(!(isc >= 0))
          isc = 0;

        p2=exp((double)(-QUALSCOR_LOGBASE * (float)isc) / (double)10);
        p1 = 1.0 - p2;
        if((signed int)n2 >= 2)
          p2 = p2 / (double)n2;

      }

      else
        if((signed int)n1 >= 2)
        {
          p1 = 1.0 / (double)n1;
          p2 = p1;
        }

      i = (signed short int)0;
      for( ; !((signed int)i >= (signed int)n1); i = i + 1)
        rspp[(signed long int)i]->prob = p1;
      if((signed int)n1 + (signed int)n2 >= 32768)
        return 48;

      else
      {
        ns = (signed short int)((signed int)n1 + (signed int)n2);
        for( ; !((signed int)i >= (signed int)ns); i = i + 1)
          rspp[(signed long int)i]->prob = p2;
        for( ; !((signed int)i >= (signed int)nn); i = i + 1)
          rspp[(signed long int)i]->prob = 0.0;
        if((signed int)n1 == 1 && (signed int)n2 == 0)
          rspp[(signed long int)0]->status = rspp[(signed long int)0]->status | (unsigned short int)256;

        return 0;
      }
    }
  }
}

// pullARGBUFF
// file threads.c line 281
static signed int pullARGBUFF(struct _BUFFARG **argp, struct _ARGBUFF *fifop)
{
  signed int errcode = 0;
  sem_wait(&fifop->sema);
  pthread_mutex_lock(&fifop->mutex);
  *argp = fifop->firstp;
  if(*argp == ((struct _BUFFARG *)NULL))
  {
    if(!(fifop->nThreadsPushing >= 1))
      errcode = 79;

    else
      if(!(fifop->lastp == ((struct _BUFFARG *)NULL)))
        errcode = 47;

  }

  else
    if(fifop->firstp == fifop->lastp)
    {
      if(!((*argp)->nextp == ((struct _BUFFARG *)NULL)))
        errcode = 47;

      fifop->lastp = (struct _BUFFARG *)(void *)0;
      fifop->firstp = fifop->lastp;
    }

    else
    {
      fifop->firstp = (*argp)->nextp;
      (*argp)->nextp = (struct _BUFFARG *)(void *)0;
    }
  pthread_mutex_unlock(&fifop->mutex);
  if(errcode == 79)
    sem_post(&fifop->sema);

  return errcode;
}

// pullTHREADARGInternalBuffer
// file threads.c line 489
static struct _BUFFARG * pullTHREADARGInternalBuffer(struct _THREADARG *thargp, signed int (*checkf)(const void *, const void *), void *tdatap)
{
  struct _BUFFARG *argp = thargp->buflstp;
  _Bool tmp_if_expr$1;
  signed int return_value;
  if(!(argp == ((struct _BUFFARG *)NULL)))
  {
    if(checkf == ((signed int (*)(const void *, const void *))NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      return_value=checkf(tdatap, argp->thisp);
      tmp_if_expr$1 = return_value != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$1)
    {
      thargp->buflstp = argp->nextp;
      argp->nextp = (struct _BUFFARG *)(void *)0;
    }

    else
      argp = (struct _BUFFARG *)(void *)0;
  }

  return argp;
}

// pushARGBUFF
// file threads.c line 227
static signed int pushARGBUFF(struct _ARGBUFF *fifop, struct _BUFFARG *argp)
{
  signed int errcode = 0;
  if(argp == ((struct _BUFFARG *)NULL))
  {
    pthread_mutex_lock(&fifop->mutex);
    fifop->lastp = (struct _BUFFARG *)(void *)0;
    fifop->firstp = fifop->lastp;
    fifop->nThreadsPushing = 0;
    pthread_mutex_unlock(&fifop->mutex);
  }

  else
  {
    argp->nextp = (struct _BUFFARG *)(void *)0;
    pthread_mutex_lock(&fifop->mutex);
    if(fifop->firstp == ((struct _BUFFARG *)NULL))
    {
      if(!(fifop->lastp == ((struct _BUFFARG *)NULL)))
        errcode = 47;

      fifop->lastp = argp;
      fifop->firstp = fifop->lastp;
    }

    else
      if(fifop->lastp == ((struct _BUFFARG *)NULL))
        errcode = 15;

      else
      {
        fifop->lastp->nextp = argp;
        fifop->lastp = argp;
      }
    pthread_mutex_unlock(&fifop->mutex);
    sem_post(&fifop->sema);
  }
  return errcode;
}

// pushTHREADARGInternalBuffer
// file threads.c line 442
static void pushTHREADARGInternalBuffer(struct _THREADARG *thargp, struct _BUFFARG *argp, signed int (*cmpf)(const void *, const void *))
{
  struct _BUFFARG *hp = thargp->buflstp;
  _Bool tmp_if_expr$2;
  signed int return_value_1;
  if(cmpf == ((signed int (*)(const void *, const void *))NULL) || hp == ((struct _BUFFARG *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_1=cmpf(argp->thisp, hp->thisp);
    tmp_if_expr$2 = return_value_1 <= 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$1;
  signed int return_value;
  if(tmp_if_expr$2)
  {
    argp->nextp = hp;
    thargp->buflstp = argp;
  }

  else
  {
    struct _BUFFARG *lp = hp->nextp;
    do
    {
      if(!(lp == ((struct _BUFFARG *)NULL)))
      {
        return_value=cmpf(argp->thisp, lp->thisp);
        tmp_if_expr$1 = return_value > 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      hp = lp;
      lp = lp->nextp;
    }
    while((_Bool)1);
    argp->nextp = lp;
    hp->nextp = argp;
  }
}

// readCompressedSeq
// file sequence.c line 1436
static signed int readCompressedSeq(struct _SEQSEQ *sp, struct _IO_FILE *fp)
{
  char is_terminated;
  unsigned int *cp;
  signed short int i;
  unsigned long int bytctr;
  unsigned long int nbytes_uint32_t = sizeof(unsigned int) /*4ul*/ ;
  unsigned long int l;
  is_terminated = (char)0;
  l = (unsigned long int)0;
  bytctr = (unsigned long int)0;
  cp = (unsigned int *)sp->basep;
  for( ; is_terminated == 0 && !(l >= 18446744073709551615ul); bytctr = bytctr + nbytes_uint32_t)
  {
    if(bytctr >= sp->alloc_size + -nbytes_uint32_t)
    {
      signed int return_value_reallocSeqBlocks$1;
      return_value_reallocSeqBlocks$1=reallocSeqBlocks(sp, bytctr + nbytes_uint32_t);
      if(!(return_value_reallocSeqBlocks$1 == 0))
        return 2;

      cp = (unsigned int *)(sp->basep + (signed long int)bytctr);
    }

    unsigned long int return_value_fread$2;
    return_value_fread$2=fread((void *)cp, nbytes_uint32_t, (unsigned long int)1, fp);
    if(!(return_value_fread$2 == 1ul))
      break;

    i = (signed short int)(10 - 1);
    for( ; (signed int)i >= 0; i = i - 1)
    {
      if((7u & *cp >> 3 * (signed int)i) == 7u)
      {
        is_terminated = (char)1;
        break;
      }

      l = l + 1ul;
    }
    cp = cp + 1l;
  }
  sp->size = l;
  sp->code = (char)2;
  if(is_terminated == 0)
    return 33;

  else
    return is_terminated != 0 ? 0 : 33;
}

// readCompressedSeqOfKnownLength
// file sequence.c line 1475
static signed int readCompressedSeqOfKnownLength(struct _SEQSEQ *sp, struct _IO_FILE *fp, unsigned long int length)
{
  signed int errcode;
  unsigned int *cp;
  unsigned long int n_units = (unsigned long int)length / (unsigned long int)10 + (unsigned long int)1;
  signed short int termoffs;
  errcode=reallocSeqBlocks(sp, n_units * (unsigned long int)4);
  if(!(errcode == 0))
    return errcode;

  else
  {
    unsigned long int return_value_fread$1;
    return_value_fread$1=fread((void *)sp->basep, (unsigned long int)4, n_units, fp);
    if(!(return_value_fread$1 == n_units))
      return 33;

    else
    {
      termoffs = (signed short int)((n_units * (unsigned long int)10 - length) - (unsigned long int)1);
      cp = (unsigned int *)sp->basep;
      if(!((7u & cp[-1l + (signed long int)n_units] >> 3 * (signed int)termoffs) == 7u))
        return 33;

      else
      {
        sp->size = length;
        sp->code = (char)2;
        return 0;
      }
    }
  }
}

// readHeader
// file filio.c line 79
static signed int readHeader(unsigned int *filsiz, unsigned char *filtyp, unsigned int *version, unsigned char *is_endianid, unsigned int *headsiz, struct _IO_FILE *fp)
{
  unsigned int header[12l];
  unsigned long int nrobj;
  nrobj=fread((void *)header, sizeof(unsigned int) /*4ul*/ , (unsigned long int)12, fp);
  if(!(nrobj == 12ul))
  {
    signed int return_value_ferror$1;
    return_value_ferror$1=ferror(fp);
    if(!(return_value_ferror$1 == 0))
      perror(READERRMSG);

    return 14;
  }

  if(!(header[0l] == 1931551091u))
    return 5;

  else
  {
    *is_endianid = (unsigned char)(header[(signed long int)1] == (unsigned int)1849133593);
    if(is_endianid == ((unsigned char *)NULL))
    {
      filioSwapEndian(header, (unsigned int)12);
      if(header[1l] == 1849133593u)
        goto __CPROVER_DUMP_L4;

      return 52;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      *filsiz = header[(signed long int)2];
      *filtyp = (unsigned char)(header[(signed long int)3] & (unsigned int)255);
      *version = header[(signed long int)4];
      *headsiz = header[(signed long int)5];
      return 0;
    }
  }
}

// readHeader$link1
// file sequence.c line 1056
static signed int readHeader$link1(struct _SEQSEQ *sp, struct gzFile_s *fp$link1, signed int *prompt, char *bufp)
{
  signed int errcode = 0;
  char *cp;
  char *top;
  char *nextp;
  unsigned char was_space = (unsigned char)1;
  unsigned char eol_flag = (unsigned char)0;
  unsigned int i;
  blankSeq(sp);
  sp->code = (char)0;
  sp->nbit_symb = (char)8;
  *prompt = (signed int)0;
  top = sp->basep;
  nextp = bufp;
  i = (unsigned int)0;
  _Bool tmp_if_expr$1;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$3;
  signed int return_value_reallocSeqBlocks$5;
  char *tmp_post$6;
  while(eol_flag == 0 && !(nextp == ((char *)NULL)))
  {
    cp = nextp;
    for( ; eol_flag == 0 && !(*cp == 0); cp = cp + 1l)
    {
      if(!(was_space == 0))
      {
        const unsigned short int **return_value___ctype_b_loc$2;
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*cp]) == 0))
        {
          if((signed int)*cp == 10)
            tmp_if_expr$1 = *prompt != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          eol_flag = (unsigned char)tmp_if_expr$1;
          goto __CPROVER_DUMP_L14;
        }

        if(*prompt == 0)
        {
          if(!((signed int)*cp == 62))
          {
            if(!((signed int)*cp == 64))
            {
              if(!((signed int)*cp == 43))
                return 6;

            }

          }

          *prompt = (signed int)*cp;
          goto __CPROVER_DUMP_L14;
        }

        was_space = (unsigned char)0;
      }

      else
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*cp]) == 0))
        {
          if((signed int)*cp == 10)
            tmp_if_expr$3 = *prompt != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          eol_flag = (unsigned char)tmp_if_expr$3;
          if(!(eol_flag == 0))
            goto __CPROVER_DUMP_L14;

          was_space = (unsigned char)1;
        }

      }
      if((unsigned long int)(1u + i) >= sp->alloc_size)
      {
        return_value_reallocSeqBlocks$5=reallocSeqBlocks(sp, (unsigned long int)(i + (unsigned int)2));
        if(!(return_value_reallocSeqBlocks$5 == 0))
          return 2;

      }

      top = sp->basep + (signed long int)i;
      tmp_post$6 = top;
      top = top + 1l;
      *tmp_post$6 = *cp;
      i = i + 1u;
      if(i >= 4294967295u)
        return 36;


    __CPROVER_DUMP_L14:
      ;
    }
    nextp=gzgets(fp$link1, bufp, 1024);
  }
  if(i >= 1u && !(was_space == 0))
  {
    top = top - 1l;
    i = i - 1u;
  }

  *top = (char)0;
  sp->size = (unsigned long int)i;
  if(nextp == ((char *)NULL))
  {
    signed int return_value_gzeof$7;
    return_value_gzeof$7=gzeof(fp$link1);
    errcode = return_value_gzeof$7 != 0 ? 10 : 50;
  }

  return errcode;
}

// readQual
// file sequence.c line 1743
static signed int readQual(struct _SeqFastq *sqp, struct _SeqIO *ifp)
{
  signed int this_prompt;
  signed int tmp_if_expr$1;
  if(sqp->qheadp == ((struct _SEQSEQ *)NULL))
  {
    sqp->qheadp=createSeq((unsigned int)sqp->headp->block_size);
    if(!(sqp->qheadp == ((struct _SEQSEQ *)NULL)))
      goto __CPROVER_DUMP_L1;

    return 2;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    ifp->status=readHeader$link1(sqp->qheadp, (struct gzFile_s *)ifp->fp, &this_prompt, ifp->linbufp);
    if(!(ifp->status == 0))
      return ifp->status;

    else
      if(!(this_prompt == 43))
      {
        ifp->status = 6;
        return ifp->status;
      }

      else
        if(sqp->qualp == ((struct _SEQSEQ *)NULL))
        {
          sqp->qualp=createSeq((unsigned int)sqp->datap->block_size);
          if(!(sqp->qualp == ((struct _SEQSEQ *)NULL)))
            goto __CPROVER_DUMP_L4;

          ifp->status = 2;
          return ifp->status;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(sqp->datap->size >= 18446744073709551615ul)
            return 6;

          else
          {
            ifp->status=readSeqFast(sqp->qualp, (struct gzFile_s *)ifp->fp, &this_prompt, ifp->linbufp, (unsigned int)sqp->datap->size);
            sqp->type = (char)2;
            if(ifp->status == 10)
              tmp_if_expr$1 = 0;

            else
              tmp_if_expr$1 = ifp->status;
            return tmp_if_expr$1;
          }
        }
  }
}

// readSeq
// file sequence.c line 1163
static signed int readSeq(struct _SEQSEQ *sp, struct gzFile_s *fp, signed int *prompt)
{
  char *cp;
  signed int c;
  unsigned char was_newline = (unsigned char)0;
  unsigned int i;
  blankSeq(sp);
  sp->code = (char)0;
  sp->nbit_symb = (char)8;
  *prompt = 0;
  cp = sp->basep;
  i = (unsigned int)0;
  signed int tmp_if_expr$3;
  unsigned char *tmp_post$1;
  signed int return_value_gzgetc$2;
  if(!(fp->have == 0u))
  {
    fp->have = fp->have - 1u;
    fp->pos = fp->pos + 1l;
    tmp_post$1 = fp->next;
    fp->next = fp->next + 1l;
    tmp_if_expr$3 = (signed int)*tmp_post$1;
  }

  else
  {
    return_value_gzgetc$2=gzgetc(fp);
    tmp_if_expr$3 = return_value_gzgetc$2;
  }
  c = tmp_if_expr$3;
  signed int return_value_reallocSeqBlocks$8;
  char *tmp_post$9;
  signed int tmp_if_expr$6;
  unsigned char *tmp_post$4;
  signed int return_value_gzgetc$5;
  for( ; !(c == -1) && !(i >= 4294967295u); c = tmp_if_expr$6)
  {
    const unsigned short int **return_value___ctype_b_loc$7;
    return_value___ctype_b_loc$7=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)c]) == 0))
    {
      if(c == 10)
        was_newline = (unsigned char)1;

    }

    else
    {
      if(!(was_newline == 0) && (c == 43 || c == 62 || c == 64))
      {
        *prompt = c;
        gzungetc(c, fp);
        break;
      }

      if((unsigned long int)(1u + i) >= sp->alloc_size)
      {
        return_value_reallocSeqBlocks$8=reallocSeqBlocks(sp, (unsigned long int)(i + (unsigned int)2));
        if(!(return_value_reallocSeqBlocks$8 == 0))
          return 2;

      }

      cp = sp->basep + (signed long int)i;
      tmp_post$9 = cp;
      cp = cp + 1l;
      *tmp_post$9 = (char)c;
      i = i + 1u;
    }
    if(!(fp->have == 0u))
    {
      fp->have = fp->have - 1u;
      fp->pos = fp->pos + 1l;
      tmp_post$4 = fp->next;
      fp->next = fp->next + 1l;
      tmp_if_expr$6 = (signed int)*tmp_post$4;
    }

    else
    {
      return_value_gzgetc$5=gzgetc(fp);
      tmp_if_expr$6 = return_value_gzgetc$5;
    }
  }
  *cp = (char)0;
  sp->size = (unsigned long int)i;
  return c == -1 ? 10 : 0;
}

// readSeqFast
// file sequence.c line 1229
static signed int readSeqFast(struct _SEQSEQ *sp, struct gzFile_s *fp, signed int *prompt, char *bufp, unsigned int minlen)
{
  signed int errcode = 0;
  char *top;
  char *cp;
  char *nextp;
  unsigned char was_newline = (unsigned char)0;
  unsigned char eos_flag = (unsigned char)0;
  unsigned int i;
  blankSeq(sp);
  sp->code = (char)0;
  sp->nbit_symb = (char)8;
  *prompt = 0;
  top = sp->basep;
  i = (unsigned int)0;
  nextp = bufp;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  signed int return_value_reallocSeqBlocks$4;
  char *tmp_post$5;
  _Bool tmp_if_expr$1;
  do
  {
    cp = nextp;
    for( ; eos_flag == 0 && !(*cp == 0); cp = cp + 1l)
    {
      const unsigned short int **return_value___ctype_b_loc$6;
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*cp]) == 0))
        was_newline = (unsigned char)((signed int)*cp == 10);

      else
      {
        if(!(was_newline == 0))
        {
          if(i >= minlen)
          {
            if((signed int)*cp == 62)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = (signed int)*cp == 64 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = (signed int)*cp == 43 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
            {
              *prompt = (signed int)*cp;
              eos_flag = (unsigned char)1;
              goto __CPROVER_DUMP_L12;
            }

          }

          was_newline = (unsigned char)0;
        }

        if((unsigned long int)(1u + i) >= sp->alloc_size)
        {
          return_value_reallocSeqBlocks$4=reallocSeqBlocks(sp, (unsigned long int)(i + (unsigned int)2));
          if(!(return_value_reallocSeqBlocks$4 == 0))
            return 2;

        }

        top = sp->basep + (signed long int)i;
        tmp_post$5 = top;
        top = top + 1l;
        *tmp_post$5 = *cp;
        i = i + 1u;
      }

    __CPROVER_DUMP_L12:
      ;
    }
    if(eos_flag == 0)
    {
      nextp=gzgets(fp, bufp, 1024);
      tmp_if_expr$1 = nextp != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
  }
  while(tmp_if_expr$1);
  *top = (char)0;
  signed int return_value_gzeof$7;
  sp->size = (unsigned long int)i;
  if(nextp == ((char *)NULL))
  {
    return_value_gzeof$7=gzeof(fp);
    errcode = return_value_gzeof$7 != 0 ? 10 : 50;
  }

  return errcode;
}

// reallocDiffBlocks
// file diffstr.c line 598
static signed int reallocDiffBlocks(struct _DiffBlocks *p, signed int n_blks)
{
  unsigned long int newsz = (unsigned long int)(((n_blks + p->ablksz) - 1) / p->ablksz);
  void *hp;
  newsz = newsz * (unsigned long int)p->ablksz;
  if(newsz >= 2147483648ul)
    return 48;

  else
  {
    hp=erealloc((void *)p->blkp, newsz * sizeof(struct _BLOCK) /*12ul*/ , (unsigned long int)0, "diffstr.c", 605);
    if(hp == NULL)
      return 2;

    else
    {
      p->blkp = (struct _BLOCK *)hp;
      p->n_alloc = (signed int)newsz;
      return 0;
    }
  }
}

// reallocHashHitInfo
// file hashhit.c line 418
static signed int reallocHashHitInfo(struct _HashHitInfo *p, unsigned int newlen)
{
  void *hp;
  unsigned char o;
  unsigned long int siz;
  unsigned long int dblk;
  if(!(newlen >= 1u))
    return 29;

  else
  {
    siz = (unsigned long int)(((newlen + (unsigned int)p->blksz) - (unsigned int)1) / (unsigned int)p->blksz);
    siz = siz * (unsigned long int)p->blksz;
    hp=erealloc((void *)p->qmaskp, siz * sizeof(unsigned char) /*1ul*/ , (unsigned long int)0, "hashhit.c", 432);
    if(hp == NULL)
      return 2;

    else
    {
      p->qmaskp = (unsigned char *)hp;
      hp=erealloc((void *)p->qbufp, siz * sizeof(unsigned char) /*1ul*/ , (unsigned long int)0, "hashhit.c", 436);
      if(hp == NULL)
        return 2;

      else
      {
        p->qbufp = (unsigned char *)hp;
        hp=erealloc((void *)p->sidxp, siz * sizeof(unsigned int) /*4ul*/ , (unsigned long int)0, "hashhit.c", 440);
        if(hp == NULL)
          return 2;

        else
        {
          p->sidxp = (unsigned int *)hp;
          hp=erealloc((void *)p->nhitqual_sortkeyp, siz * sizeof(unsigned int) /*4ul*/ , (unsigned long int)0, "hashhit.c", 444);
          if(hp == NULL)
            return 2;

          else
          {
            p->nhitqual_sortkeyp = (unsigned int *)hp;
            hp=erealloc((void *)p->seedp, siz * sizeof(struct _SEED) /*16ul*/ , (unsigned long int)0, "hashhit.c", 448);
            if(hp == NULL)
              return 2;

            else
            {
              p->seedp = (struct _SEED *)hp;
              hp=erealloc((void *)p->framep[(signed long int)0], (siz + (unsigned long int)p->nskip) * sizeof(unsigned int) /*4ul*/ , (unsigned long int)0, "hashhit.c", 468);
              if(hp == NULL)
                return 2;

              else
              {
                p->framep[(signed long int)0] = (unsigned int *)hp;
                dblk = siz / (unsigned long int)p->nskip + (unsigned long int)1;
                o = (unsigned char)1;
                for( ; !((signed int)o >= (signed int)p->nskip); o = o + 1)
                  p->framep[(signed long int)o] = p->framep[(signed long int)0] + (signed long int)((unsigned long int)o * dblk);
                p->n_alloc = siz;
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// reallocHitFilter
// file hashhit.c line 1925
static signed int reallocHitFilter(struct _HashHitFilter *hhfp, signed short int siz)
{
  unsigned long int nsiz;
  void *hp;
  if(!((signed int)siz >= 1))
    return 29;

  else
  {
    nsiz = (unsigned long int)((((signed int)siz - 1) / (signed int)hhfp->blocksiz + 1) * (signed int)hhfp->blocksiz);
    if(nsiz >= 32768ul)
      return 48;

    else
    {
      hp=erealloc((void *)hhfp->ivp, nsiz * sizeof(struct _FILTERIVAL) /*8ul*/ , (unsigned long int)0, "hashhit.c", 1933);
      if(hp == NULL)
        return 2;

      else
      {
        hhfp->ivp = (struct _FILTERIVAL *)hp;
        hhfp->n_alloc = (signed short int)nsiz;
        return 0;
      }
    }
  }
}

// reallocHitList
// file hashhit.c line 1233
static signed int reallocHitList(struct _HashHitList *hlp, unsigned long int newsiz)
{
  unsigned long int nsiz = ((newsiz + (unsigned long int)hlp->nhits_blksz) - (unsigned long int)1) / (unsigned long int)hlp->nhits_blksz;
  void *hp;
  nsiz = nsiz * (unsigned long int)hlp->nhits_blksz;
  if(nsiz >= 2147483648ul)
    return 48;

  else
  {
    hp=erealloc((void *)hlp->sqdat, nsiz * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)0, "hashhit.c", 1242);
    if(hp == NULL)
      return 2;

    else
    {
      hlp->sqdat = (unsigned long int *)hp;
      hlp->nhits_alloc = (signed int)nsiz;
      return 0;
    }
  }
}

// reallocQMask
// file segment.c line 674
static signed int reallocQMask(struct _SegQMask *p, unsigned int newsiz)
{
  unsigned long int nsz = (unsigned long int)(((newsiz - (unsigned int)1) / (unsigned int)p->blksiz + (unsigned int)1) * (unsigned int)p->blksiz);
  unsigned char *hp;
  void *return_value_erealloc$1;
  return_value_erealloc$1=erealloc((void *)p->maskp, nsz * sizeof(unsigned char) /*1ul*/ , (unsigned long int)0, "segment.c", 678);
  hp = (unsigned char *)return_value_erealloc$1;
  if(hp == ((unsigned char *)NULL))
    return 2;

  else
  {
    p->maskp = hp;
    p->n_alloc = nsz;
    return 0;
  }
}

// reallocQmask
// file hashhit.c line 1250
static signed int reallocQmask(struct _HashHitList *hlp, unsigned int seqlen)
{
  unsigned long int nsiz = (unsigned long int)(((unsigned int)(seqlen / (unsigned int)512) + (unsigned int)1) * (unsigned int)512);
  char *qmaskp;
  void *return_value_erealloc$1;
  return_value_erealloc$1=erealloc((void *)hlp->qmask, nsiz, (unsigned long int)0, "hashhit.c", 1253);
  qmaskp = (char *)return_value_erealloc$1;
  if(qmaskp == ((char *)NULL))
    return 2;

  else
  {
    hlp->qmask = qmaskp;
    hlp->qmask_alloc = nsiz;
    hlp->qlen = seqlen;
    return 0;
  }
}

// reallocREPSTR
// file report.c line 417
static signed int reallocREPSTR(struct _REPSTR *rsp, unsigned long int newlen)
{
  signed int errcode = 2;
  unsigned long int newsz = ((newlen + (unsigned long int)rsp->blksz) - (unsigned long int)1) / (unsigned long int)rsp->blksz;
  void *hp;
  newsz = newsz * (unsigned long int)rsp->blksz;
  hp=erealloc((void *)rsp->strp, newsz * sizeof(char) /*1ul*/ , (unsigned long int)0, "report.c", 424);
  if(!(hp == NULL))
  {
    rsp->strp = (char *)hp;
    rsp->n_alloc = newsz;
    errcode = 0;
  }

  return errcode;
}

// reallocRsltSet
// file alignment.c line 1239
static signed int reallocRsltSet(struct _AliRsltSet *arp, signed short int newsiz)
{
  signed int errcode = 0;
  void *hp;
  signed short int i;
  unsigned long int ns = (unsigned long int)((((signed int)newsiz + (signed int)arp->blksz) - 1) / (signed int)arp->blksz);
  if(!((signed int)newsiz >= 0))
    return 47;

  else
  {
    ns = ns * (unsigned long int)arp->blksz;
    if(ns >= 32768ul)
      return 48;

    else
      if(!((signed int)(signed short int)ns >= (signed int)newsiz))
        return 47;

      else
      {
        i = (signed short int)ns;
        for( ; !((signed int)i >= (signed int)arp->n_alloc); i = i + 1)
          diffStrCleanUp(&(arp->rsp + (signed long int)i)->diffstr);
        hp=erealloc((void *)arp->rsp, ns * sizeof(struct _ALIRESULT) /*48ul*/ , (unsigned long int)0, "alignment.c", 1260);
        if(hp == NULL)
          return 2;

        else
        {
          arp->rsp = (struct _ALIRESULT *)hp;
          i = arp->n_alloc;
          for( ; !((signed int)i >= (signed int)(signed short int)ns); i = i + 1)
          {
            errcode=diffStrInit(&(arp->rsp + (signed long int)i)->diffstr, (signed int)arp->dfblksz);
            if(!(errcode == 0))
              break;

          }
          arp->n_alloc = (signed short int)ns;
          if(!((signed int)arp->n_alloc >= (signed int)arp->nres))
            arp->nres = arp->n_alloc;

          return errcode;
        }
      }
  }
}

// reallocScalarProfile
// file score.c line 398
static signed int reallocScalarProfile(struct _ScoreProfile *app, signed int newlen)
{
  signed short int i;
  void *hp;
  unsigned int newsiz = (unsigned int)((signed int)((unsigned int)(newlen + 1) / app->blocksiz) + 1) * app->blocksiz;
  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)app->alphabetsiz); i = i + 1)
  {
    hp=erealloc((void *)app->score[(signed long int)i], (unsigned long int)newsiz * sizeof(signed char) /*1ul*/ , (unsigned long int)0, "score.c", 404);
    if(hp == NULL)
      return 2;

    app->score[(signed long int)i] = (signed char *)hp;
  }
  app->allocsiz = newsiz;
  return 0;
}

// reallocSeqBlocks
// file sequence.c line 744
static signed int reallocSeqBlocks(struct _SEQSEQ *sp, unsigned long int minsize)
{
  unsigned long int newsiz = minsize / (unsigned long int)sp->block_size + (unsigned long int)1;
  newsiz = newsiz * (unsigned long int)sp->block_size;
  char *hp;
  void *return_value_erealloc$1;
  return_value_erealloc$1=erealloc((void *)sp->basep, newsiz * sizeof(char) /*1ul*/ , (unsigned long int)0, "sequence.c", 748);
  hp = (char *)return_value_erealloc$1;
  if(hp == ((char *)NULL))
    return 2;

  else
  {
    sp->basep = hp;
    sp->alloc_size = newsiz;
    return 0;
  }
}

// reallocSeqSet
// file sequence.c line 2236
static signed int reallocSeqSet(struct _SeqSet *ssp, signed long int num)
{
  unsigned long int nsiz;
  void *hp;
  if(!(num >= 1l))
    return 29;

  else
  {
    nsiz = (unsigned long int)(((num - (signed long int)1) / (signed long int)ssp->blocksiz + (signed long int)1) * (signed long int)ssp->blocksiz);
    if(nsiz >= 2147483647ul)
      return 48;

    else
    {
      hp=erealloc((void *)ssp->sop, nsiz * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)0, "sequence.c", 2244);
      if(hp == NULL)
        return 2;

      else
      {
        ssp->sop = (unsigned long int *)hp;
        hp=erealloc((void *)ssp->namoffs, nsiz * sizeof(unsigned long int) /*8ul*/ , (unsigned long int)0, "sequence.c", 2248);
        if(hp == NULL)
          return 2;

        else
        {
          ssp->namoffs = (unsigned long int *)hp;
          ssp->n_alloc = (signed long int)nsiz;
          return 0;
        }
      }
    }
  }
}

// reallocSeqSetName
// file sequence.c line 2257
static signed int reallocSeqSetName(struct _SeqSet *ssp, unsigned long int len)
{
  unsigned long int nsiz;
  char *hp;
  if(!(len >= 1ul))
    return 29;

  else
  {
    nsiz = ((len - (unsigned long int)1) / (unsigned long int)ssp->nam_blocksiz + (unsigned long int)1) * (unsigned long int)ssp->nam_blocksiz;
    if(nsiz >= 2147483648ul)
      return 48;

    else
    {
      void *return_value_erealloc$1;
      return_value_erealloc$1=erealloc((void *)ssp->namebasep, nsiz * sizeof(char) /*1ul*/ , (unsigned long int)0, "sequence.c", 2269);
      hp = (char *)return_value_erealloc$1;
      if(hp == ((char *)NULL))
        return 2;

      else
      {
        ssp->namebasep = hp;
        ssp->nam_alloc = nsiz;
        return 0;
      }
    }
  }
}

// reallocSortArrays
// file segment.c line 1437
static signed int reallocSortArrays(struct _SegAliCands *sacp, unsigned int num)
{
  unsigned long int newsiz = (unsigned long int)(((num - (unsigned int)1) / sacp->alloc_blksz + (unsigned int)1) * sacp->alloc_blksz);
  void *hp;
  if(newsiz >= 4294967296ul)
    return 48;

  else
  {
    hp=erealloc((void *)sacp->sort_keys, newsiz * sizeof(unsigned int) /*4ul*/ , (unsigned long int)0, "segment.c", 1444);
    if(hp == NULL)
      return 2;

    else
    {
      sacp->sort_keys = (unsigned int *)hp;
      hp=erealloc((void *)sacp->sort_idx, newsiz * sizeof(unsigned int) /*4ul*/ , (unsigned long int)0, "segment.c", 1448);
      if(hp == NULL)
        return 2;

      else
      {
        sacp->sort_idx = (unsigned int *)hp;
        sacp->n_alloc = (unsigned int)newsiz;
        return 0;
      }
    }
  }
}

// reallocView
// file diffstr.c line 133
static signed int reallocView(struct _DiffView *dvp, unsigned long int newsiz)
{
  signed int errcode = 0;
  newsiz = ((newsiz + (unsigned long int)dvp->blksz) - (unsigned long int)1) / (unsigned long int)dvp->blksz;
  newsiz = newsiz * (unsigned long int)dvp->blksz;
  if(!(newsiz == dvp->n_alloc))
  {
    void *hp;
    hp=erealloc((void *)dvp->strp, newsiz * sizeof(char) /*1ul*/ , (unsigned long int)0, "diffstr.c", 141);
    if(hp == NULL)
      errcode = 2;

    else
    {
      dvp->strp = (char *)hp;
      dvp->n_alloc = newsiz;
    }
  }

  return errcode;
}

// reportAddMap
// file report.h line 154
signed int reportAddMap(struct _Report *rep, signed int pairid, signed int swatscor, signed short int mapscor, unsigned int q_start, unsigned int q_end, unsigned int s_start, unsigned int s_end, signed long int s_idx, const unsigned char *dstrp, signed int dfslen, signed int insiz, unsigned char mateflg, unsigned char pairflg)
{
  signed int errcode = 0;
  signed int errc = 0;
  signed int idx = -1;
  struct _REPALI *rp = (struct _REPALI *)(void *)0;
  struct _REPPAIR *pp = (struct _REPPAIR *)(void *)0;
  if(dstrp == ((const unsigned char *)NULL) || !(dfslen >= 1))
    mateflg = mateflg & (unsigned char)~1;

  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$5;
  unsigned long int tmp_post$6;
  if(pairid >= 0 && !((4 & (signed int)mateflg) == 0))
  {
    if((unsigned long int)pairid >= ((unsigned long int *)rep->pairr)[-1l])
      return 29;

    pp = rep->pairr + (signed long int)pairid;
    if((signed int)pp->pairflg == 0)
    {
      pp->pairflg = pairflg;
      goto __CPROVER_DUMP_L4;
    }

    if(pp->pairflg == pairflg)
      goto __CPROVER_DUMP_L4;

    return 47;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!((8 & (signed int)mateflg) == 0) && !(pp == ((struct _REPPAIR *)NULL)))
    {
      if(pp->iA >= 0)
      {
        if(!(insiz == pp->isize))
          return 47;

        errc=findREPALI(rep->arBr, &idx, q_start, q_end, mateflg, s_start, s_end, s_idx);
        if(errc == -1)
        {
          pp->iB = (signed int)((unsigned long int *)rep->arBr)[(signed long int)-1];
          if(((unsigned long int *)rep->arBr)[-1l] >= ((unsigned long int *)rep->arBr)[-2l])
          {
            void *return_value_arrayRealloc$1;
            return_value_arrayRealloc$1=arrayRealloc((void *)rep->arBr, (unsigned long int)0, (char)0, "report.c", 1637);
            rp = (struct _REPALI *)return_value_arrayRealloc$1;
            if(!(rp == ((struct _REPALI *)NULL)))
            {
              rep->arBr = rp;
              tmp_post$2 = ((unsigned long int *)rep->arBr)[(signed long int)-1];
              ((unsigned long int *)rep->arBr)[(signed long int)-1] = ((unsigned long int *)rep->arBr)[(signed long int)-1] + 1ul;
              rp = rep->arBr + (signed long int)tmp_post$2;
            }

          }

          else
          {
            tmp_post$3 = ((unsigned long int *)rep->arBr)[(signed long int)-1];
            ((unsigned long int *)rep->arBr)[(signed long int)-1] = ((unsigned long int *)rep->arBr)[(signed long int)-1] + 1ul;
            rp = rep->arBr + (signed long int)tmp_post$3;
          }
          if(rp == ((struct _REPALI *)NULL))
            errcode = 2;

        }

        else
          if(errc == 0)
          {
            pp->iB = idx;
            rp = rep->arBr + (signed long int)idx;
          }

          else
            errcode = errc;
      }

      else
        pp->isize = insiz;
    }

    else
    {
      struct _REPALI **arp = &rep->arAr;
      if(pp == ((struct _REPPAIR *)NULL))
      {
        if(!((8 & (signed int)mateflg) == 0))
          arp = &rep->arBr;

      }

      else
        if(pp->iB >= 0)
        {
          if(!(insiz == pp->isize))
            return 47;

        }

        else
          pp->isize = insiz;
      errc=findREPALI(*arp, &idx, q_start, q_end, mateflg, s_start, s_end, s_idx);
      if(errc == -1)
      {
        if(!(pp == ((struct _REPPAIR *)NULL)))
          pp->iA = (signed int)((unsigned long int *)rep->arAr)[(signed long int)-1];

        if(((unsigned long int *)*arp)[-1l] >= ((unsigned long int *)*arp)[-2l])
        {
          void *return_value_arrayRealloc$4;
          return_value_arrayRealloc$4=arrayRealloc((void *)*arp, (unsigned long int)0, (char)0, "report.c", 1672);
          rp = (struct _REPALI *)return_value_arrayRealloc$4;
          if(!(rp == ((struct _REPALI *)NULL)))
          {
            *arp = rp;
            tmp_post$5 = ((unsigned long int *)*arp)[(signed long int)-1];
            ((unsigned long int *)*arp)[(signed long int)-1] = ((unsigned long int *)*arp)[(signed long int)-1] + 1ul;
            rp = *arp + (signed long int)tmp_post$5;
          }

        }

        else
        {
          tmp_post$6 = ((unsigned long int *)*arp)[(signed long int)-1];
          ((unsigned long int *)*arp)[(signed long int)-1] = ((unsigned long int *)*arp)[(signed long int)-1] + 1ul;
          rp = *arp + (signed long int)tmp_post$6;
        }
        if(rp == ((struct _REPALI *)NULL))
          errcode = 2;

      }

      else
        if(errc == 0)
        {
          if(pp == ((struct _REPPAIR *)NULL))
            rp = (struct _REPALI *)(void *)0;

          else
          {
            pp->iA = idx;
            rp = *arp + (signed long int)idx;
          }
        }

        else
          errcode = errc;
    }
    if(errcode == 0 && !(rp == ((struct _REPALI *)NULL)))
    {
      rp->status = mateflg;
      rp->dfo = (&rep->dfs)->len;
      if(!((1 & (signed int)mateflg) == 0))
      {
        rp->swatscor = swatscor;
        rp->mapscor = mapscor;
        rp->q_start = q_start;
        rp->q_end = q_end;
        rp->s_start = s_start;
        rp->s_end = s_end;
        rp->s_idx = s_idx;
        errcode=diffStrAdd(&rep->dfs, dstrp, dfslen);
      }

      else
      {
        rp->swatscor = 0;
        rp->mapscor = (signed short int)0;
        rp->q_start = (unsigned int)0;
        rp->q_end = (unsigned int)0;
        rp->s_start = (unsigned int)0;
        rp->s_end = (unsigned int)0;
        rp->s_idx = (signed long int)0;
      }
    }

    return errcode;
  }
}

// reportBlank
// file report.h line 145
void reportBlank(struct _Report *p)
{
  if(!(p == ((struct _Report *)NULL)))
  {
    ((unsigned long int *)p->pairr)[(signed long int)-1] = (unsigned long int)0;
    ((unsigned long int *)p->arAr)[(signed long int)-1] = (unsigned long int)0;
    ((unsigned long int *)p->arBr)[(signed long int)-1] = (unsigned long int)0;
    (&p->dfs)->len = 0;
  }

}

// reportCreate
// file report.h line 135
struct _Report * reportCreate(signed int blksz)
{
  struct _Report *p;
  void *return_value_ecalloc$8;
  return_value_ecalloc$8=ecalloc((unsigned long int)1, sizeof(struct _Report) /*48ul*/ , "report.c", 1547);
  p = (struct _Report *)return_value_ecalloc$8;
  _Bool tmp_if_expr$3;
  void *return_value_arrayCreate$2;
  _Bool tmp_if_expr$5;
  void *return_value_arrayCreate$4;
  _Bool tmp_if_expr$7;
  signed int return_value_diffStrInit$6;
  if(!(p == ((struct _Report *)NULL)))
  {
    if(!(blksz >= 1))
      blksz = 256;

    void *return_value_arrayCreate$1;
    return_value_arrayCreate$1=arrayCreate(sizeof(struct _REPPAIR) /*16ul*/ , (unsigned long int)blksz, "report.c", 1549);
    p->pairr = (struct _REPPAIR *)return_value_arrayCreate$1;
    if(p->pairr == ((struct _REPPAIR *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_arrayCreate$2=arrayCreate(sizeof(struct _REPALI) /*56ul*/ , (unsigned long int)blksz, "report.c", 1550);
      p->arAr = (struct _REPALI *)return_value_arrayCreate$2;
      tmp_if_expr$3 = (struct _REPALI *)(void *)0 == p->arAr ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_arrayCreate$4=arrayCreate(sizeof(struct _REPALI) /*56ul*/ , (unsigned long int)blksz, "report.c", 1551);
      p->arBr = (struct _REPALI *)return_value_arrayCreate$4;
      tmp_if_expr$5 = (struct _REPALI *)(void *)0 == p->arBr ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_diffStrInit$6=diffStrInit(&p->dfs, 0);
      tmp_if_expr$7 = return_value_diffStrInit$6 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      reportDelete(p);
      p = (struct _Report *)(void *)0;
    }

  }

  return p;
}

// reportCreateWriter
// file report.h line 100
struct _ReportWriter * reportCreateWriter(signed int *errcode, const char * const filnam, const unsigned char outform, const unsigned char modiflg, const struct _SeqSet *ssp, const char *prognam, const char *progversion, char * const *cmdlin_argv, signed int cmdlin_narg)
{
  signed int errc = 0;
  struct _ReportWriter *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ReportWriter) /*112ul*/ , "report.c", 1373);
  p = (struct _ReportWriter *)return_value_ecalloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(p == ((struct _ReportWriter *)NULL))
  {
    *errcode = 2;
    return p;
  }

  else
  {
    if(filnam == ((const char *)NULL))
      p->filnam=estrcpy(OUFMT_FILNAM_STDOUT, "report.c", 1380);

    else
      p->filnam=estrcpy(filnam, "report.c", 1382);
    if(p->filnam == ((char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      p->qbufp=seqFastqCreate(0, (char)2);
      tmp_if_expr$2 = (struct _SeqFastq *)(void *)0 == p->qbufp ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      p->sbufp=seqFastqCreate(0, (char)1);
      tmp_if_expr$3 = (struct _SeqFastq *)(void *)0 == p->sbufp ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      p->nambufp=createREPNAMBUF();
      tmp_if_expr$4 = (struct _REPNAMBUF *)(void *)0 == p->nambufp ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      errc = 2;

    else
      if((signed int)outform == 4)
      {
        p->dfblkp=diffBlocksCreate(0);
        if(p->dfblkp == ((struct _DiffBlocks *)NULL))
          errc = 2;

        else
          p->dfblkp = (struct _DiffBlocks *)(void *)0;
      }

    p->oufmt = outform;
    p->modflg = modiflg;
    p->linwidth = (signed short int)60;
    p->namext[(signed long int)0] = (char)0;
    p->namext_mate[(signed long int)0] = (char)0;
    p->dfblkp = (struct _DiffBlocks *)(void *)0;
    if(errc == 0)
    {
      if((signed int)outform == 3)
      {
        p->oufp = stdout;
        errc=initBAMHeader(&p->bamwriterp, &p->headinfop, &p->nambufp->ref_nam, prognam, progversion, cmdlin_narg, cmdlin_argv, p->filnam, ssp);
        if(errc == 0)
        {
          p->dvp=diffStrCreateView(0);
          if(p->dvp == ((struct _DiffView *)NULL))
            errc = 2;

        }

      }

      else
      {
        p->headinfop = (struct _BamBam_BamHeaderInfo *)(void *)0;
        p->bamwriterp = (struct _BamBam_BamWriter *)(void *)0;
        p->dvp = (struct _DiffView *)(void *)0;
        if(filnam == ((const char *)NULL))
          p->oufp = stdout;

        else
        {
          p->oufp=efopen(p->filnam, "w", "report.c", 1425);
          if(p->oufp == ((struct _IO_FILE *)NULL))
            errc = 9;

        }
        if((signed int)outform == 2 && !((4 & (signed int)modiflg) == 0))
        {
          if(ssp == ((const struct _SeqSet *)NULL))
            errc = 47;

          else
            errc=writeSAMHeaderf(p->oufp, ssp, prognam, progversion, cmdlin_narg, cmdlin_argv);
        }

      }
    }

    if(!(errc == 0))
    {
      reportDeleteWriter(p);
      p = (struct _ReportWriter *)(void *)0;
    }

    *errcode = errc;
    return p;
  }
}

// reportDelete
// file report.h line 141
void reportDelete(struct _Report *p)
{
  if(!(p == ((struct _Report *)NULL)))
  {
    free((void *)((unsigned long int *)p->pairr - (signed long int)4));
    p->pairr = (struct _REPPAIR *)(void *)0;
    free((void *)((unsigned long int *)p->arAr - (signed long int)4));
    p->arAr = (struct _REPALI *)(void *)0;
    free((void *)((unsigned long int *)p->arBr - (signed long int)4));
    p->arBr = (struct _REPALI *)(void *)0;
    diffStrCleanUp(&p->dfs);
  }

  free((void *)p);
}

// reportDeleteWriter
// file report.h line 123
void reportDeleteWriter(struct _ReportWriter *p)
{
  signed int deleteStatus = 0;
  if(!(p == ((struct _ReportWriter *)NULL)))
  {
    free((void *)p->filnam);
    if(!(p->oufp == ((struct _IO_FILE *)NULL)))
    {
      if(!(p->oufp == stdout))
        efclose(p->oufp, "report.c", 1462);

    }

    diffBlocksDelete(p->dfblkp);
    seqFastqDelete(p->sbufp);
    seqFastqDelete(p->qbufp);
    deleteREPNAMBUF(p->nambufp);
    diffStrDeleteView(p->dvp);
    if(!(p->bamwriterp == ((struct _BamBam_BamWriter *)NULL)))
      BamBam_BamWriter_Delete(p->bamwriterp, &deleteStatus);

    if(!(p->headinfop == ((struct _BamBam_BamHeaderInfo *)NULL)))
      BamBam_BamHeaderInfo_Delete(p->headinfop);

  }

  free((void *)p);
}

// reportFixMultiplePrimary
// file report.h line 177
void reportFixMultiplePrimary(struct _Report *rep)
{
  signed int n;
  signed int np = (signed int)((unsigned long int *)rep->pairr)[(signed long int)-1];
  signed int na = (signed int)((unsigned long int *)rep->arAr)[(signed long int)-1];
  signed int nb = (signed int)((unsigned long int *)rep->arBr)[(signed long int)-1];
  signed int n_primary_A = 0;
  signed int n_primary_B = 0;
  n = 0;
  for( ; !(n >= np) && (!(n_primary_A >= 2) || !(n_primary_B >= 2)); n = n + 1)
  {
    struct _REPPAIR *pp = rep->pairr + (signed long int)n;
    if(!((16 & (signed int)(rep->arAr + (signed long int)pp->iA)->status) == 0))
      n_primary_A = n_primary_A + 1;

    if(!((16 & (signed int)(rep->arAr + (signed long int)pp->iB)->status) == 0))
      n_primary_B = n_primary_B + 1;

  }
  if(!(n_primary_A >= 2))
  {
    if(n_primary_A >= 1)
      n_primary_A = 0;

    n = 0;
    for( ; !(n >= na) && !(n_primary_A >= 2); n = n + 1)
      if(!((16 & (signed int)(rep->arAr + (signed long int)n)->status) == 0))
        n_primary_A = n_primary_A + 1;

  }

  if(!(n_primary_B >= 2))
  {
    if(n_primary_B >= 1)
      n_primary_B = 0;

    n = 0;
    for( ; !(n >= nb) && !(n_primary_B >= 2); n = n + 1)
      if(!((16 & (signed int)(rep->arBr + (signed long int)n)->status) == 0))
        n_primary_B = n_primary_B + 1;

  }

  if(n_primary_A >= 2)
  {
    n = 0;
    for( ; !(n >= na); n = n + 1)
      (rep->arAr + (signed long int)n)->status = (rep->arAr + (signed long int)n)->status & (unsigned char)~16;
  }

  if(n_primary_B >= 2)
  {
    n = 0;
    for( ; !(n >= nb); n = n + 1)
      (rep->arBr + (signed long int)n)->status = (rep->arBr + (signed long int)n)->status & (unsigned char)~16;
  }

  goto __CPROVER_DUMP_L17;

__CPROVER_DUMP_L17:
  ;
}

// reportGetWriterStream
// file report.h line 127
struct _IO_FILE * reportGetWriterStream(const struct _ReportWriter *p)
{
  return p->oufp;
}

// reportNextPairID
// file report.h line 149
signed int reportNextPairID(struct _Report *rep)
{
  signed int pairid = (signed int)((unsigned long int *)rep->pairr)[(signed long int)-1];
  struct _REPPAIR *pp;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  if(((unsigned long int *)rep->pairr)[-1l] >= ((unsigned long int *)rep->pairr)[-2l])
  {
    void *return_value_arrayRealloc$1;
    return_value_arrayRealloc$1=arrayRealloc((void *)rep->pairr, (unsigned long int)0, (char)0, "report.c", 1586);
    pp = (struct _REPPAIR *)return_value_arrayRealloc$1;
    if(!(pp == ((struct _REPPAIR *)NULL)))
    {
      rep->pairr = pp;
      tmp_post$2 = ((unsigned long int *)rep->pairr)[(signed long int)-1];
      ((unsigned long int *)rep->pairr)[(signed long int)-1] = ((unsigned long int *)rep->pairr)[(signed long int)-1] + 1ul;
      pp = rep->pairr + (signed long int)tmp_post$2;
    }

  }

  else
  {
    tmp_post$3 = ((unsigned long int *)rep->pairr)[(signed long int)-1];
    ((unsigned long int *)rep->pairr)[(signed long int)-1] = ((unsigned long int *)rep->pairr)[(signed long int)-1] + 1ul;
    pp = rep->pairr + (signed long int)tmp_post$3;
  }
  if(pp == ((struct _REPPAIR *)NULL))
    pairid = -1;

  else
    if(!(rep->pairr + (signed long int)pairid == ((struct _REPPAIR *)NULL)))
    {
      (rep->pairr + (signed long int)pairid)->pairflg = (unsigned char)0;
      (rep->pairr + (signed long int)pairid)->isize = 0;
      (rep->pairr + (signed long int)pairid)->iB = -1;
      (rep->pairr + (signed long int)pairid)->iA = (rep->pairr + (signed long int)pairid)->iB;
    }

  return pairid;
}

// reportWrite
// file report.h line 184
signed int reportWrite(const struct _ReportWriter *wrp, const struct _SeqFastq *readp, const struct _SeqFastq *matep, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct _Report *rep)
{
  signed int errcode = 0;
  signed int n;
  signed int na = (signed int)((unsigned long int *)rep->arAr)[(signed long int)-1];
  signed int nb = (signed int)((unsigned long int *)rep->arBr)[(signed long int)-1];
  signed int np = (signed int)((unsigned long int *)rep->pairr)[(signed long int)-1];
  unsigned char pairflg;
  struct _REPALI *ap = (struct _REPALI *)(void *)0;
  struct _REPALI *bp = (struct _REPALI *)(void *)0;
  n = 0;
  for( ; !(n >= na); n = n + 1)
    (rep->arAr + (signed long int)n)->was_output = (unsigned char)0;
  n = 0;
  for( ; !(n >= nb); n = n + 1)
    (rep->arBr + (signed long int)n)->was_output = (unsigned char)0;
  n = 0;
  for( ; !(n >= np); n = n + 1)
  {
    struct _REPPAIR *pp = rep->pairr + (signed long int)n;
    ap = rep->arAr + (signed long int)pp->iA;
    bp = rep->arBr + (signed long int)pp->iB;
    ap->was_output = (unsigned char)1;
    bp->was_output = (unsigned char)1;
    errcode=writeReportForRead(wrp, ap, readp, &rep->dfs, bp, pp->isize, pp->pairflg, ssp, codecp);
    if(!(errcode == 0))
      break;

    errcode=writeReportForRead(wrp, bp, matep, &rep->dfs, ap, pp->isize, pp->pairflg, ssp, codecp);
    if(!(errcode == 0))
      break;

  }
  if(!(errcode == 0))
    return errcode;

  else
  {
    if(n >= 1)
      pairflg = (rep->pairr + (signed long int)0)->pairflg;

    else
      pairflg = (unsigned char)0;
    n = 0;
    for( ; errcode == 0 && !(n >= na); n = n + 1)
    {
      ap = rep->arAr + (signed long int)n;
      if((rep->arAr + (signed long int)n)->was_output == 0)
        errcode=writeReportForRead(wrp, ap, readp, &rep->dfs, (const struct _REPALI *)(void *)0, 0, pairflg, ssp, codecp);

    }
    if(!(errcode == 0))
      return errcode;

    else
    {
      n = 0;
      for( ; errcode == 0 && !(n >= nb); n = n + 1)
      {
        bp = rep->arBr + (signed long int)n;
        if((rep->arBr + (signed long int)n)->was_output == 0)
          errcode=writeReportForRead(wrp, bp, matep, &rep->dfs, (const struct _REPALI *)(void *)0, 0, pairflg, ssp, codecp);

      }
      return errcode;
    }
  }
}

// resetPairs
// file resultpairs.c line 717
static void resetPairs(struct _ResultPairs *p)
{
  ((unsigned long int *)p->mpr)[(signed long int)-1] = (unsigned long int)0;
  ((unsigned long int *)p->ivr)[(signed long int)-1] = (unsigned long int)0;
  p->status = (unsigned char)0;
  p->n_proper = 0;
  p->n_within = 0;
}

// resultCalcInsertSize
// file results.c line 938
unsigned char resultCalcInsertSize(signed int *isiz, unsigned char samspec, const struct _RESULT *ap, const struct _RESULT *bp)
{
  unsigned char flag = (unsigned char)0;
  if(!((4 & (signed int)ap->status) == 0))
    flag = flag | (unsigned char)1;

  if(!((4 & (signed int)bp->status) == 0))
    flag = flag | (unsigned char)2;

  if(!(bp->s_start >= ap->s_start))
    flag = flag | (unsigned char)8;

  _Bool tmp_if_expr$1;
  if(!(ap->sidx >= 0l))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = bp->sidx < (signed long int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    flag = flag | (unsigned char)16;

  else
    if(ap->sidx == bp->sidx)
      flag = flag | (unsigned char)4;

  unsigned long int tmp_if_expr$2;
  unsigned long int tmp_if_expr$3;
  if(!(isiz == ((signed int *)NULL)))
  {
    unsigned long int rA;
    unsigned long int rB;
    if((signed int)samspec == 1)
    {
      if(!(ap->s_start >= bp->s_start))
        tmp_if_expr$2 = ap->s_start;

      else
        tmp_if_expr$2 = bp->s_start;
      rA = tmp_if_expr$2;
      if(!(ap->s_end >= bp->s_end))
        tmp_if_expr$3 = bp->s_end;

      else
        tmp_if_expr$3 = ap->s_end;
      rB = tmp_if_expr$3;
      *isiz = (signed int)(rA + (unsigned long int)0x7fffffff > rB || rA < rB + (unsigned long int)0x7fffffff ? (rB - rA) + (unsigned long int)1 : (unsigned long int)0);
      if(!((8 & (signed int)flag) == 0))
        *isiz = *isiz * -1;

    }

    else
    {
      if(!((4 & (signed int)ap->status) == 0))
        rA = ap->s_end + (unsigned long int)ap->q_start;

      else
        rA = (ap->s_start - (unsigned long int)ap->q_start) + (unsigned long int)1;
      if(!((4 & (signed int)bp->status) == 0))
        rB = bp->s_end + (unsigned long int)bp->q_start;

      else
        rB = (bp->s_start - (unsigned long int)bp->q_start) + (unsigned long int)1;
      *isiz = (signed int)(rA + (unsigned long int)0x7fffffff > rB || rA < rB + (unsigned long int)0x7fffffff ? rB - rA : (unsigned long int)0);
    }
  }

  return flag;
}

// resultConvertProbabilityToMappingScore
// file results.c line 292
signed short int resultConvertProbabilityToMappingScore(double p)
{
  signed short int ms;
  double m;
  double isc = 1.0 - p;
  if(isc < MINLOGARG)
    isc = MINLOGARG;

  double return_value_log10$1;
  return_value_log10$1=log10(isc);
  m = (double)-10 * return_value_log10$1;
  if(m > 60.000000)
    ms = (signed short int)60;

  else
    if(m < 0.000000)
      ms = (signed short int)0;

    else
      ms = (signed short int)m;
  return ms;
}

// resultGetData
// file results.c line 875
signed int resultGetData(unsigned int *qs, unsigned int *qe, unsigned int *rs, unsigned int *re, signed long int *rx, signed int *swscor, unsigned short int *flag, const struct _RESULT *rp)
{
  signed int errcode;
  if(rp == ((const struct _RESULT *)NULL))
  {
    if(!(qs == ((unsigned int *)NULL)))
      *qs = (unsigned int)0;

    if(!(qe == ((unsigned int *)NULL)))
      *qe = (unsigned int)0;

    if(!(rs == ((unsigned int *)NULL)))
      *rs = (unsigned int)0;

    if(!(re == ((unsigned int *)NULL)))
      *re = (unsigned int)0;

    if(!(rx == ((signed long int *)NULL)))
      *rx = (signed long int)0;

    if(!(swscor == ((signed int *)NULL)))
      *swscor = 0;

    if(!(flag == ((unsigned short int *)NULL)))
      flag = ((unsigned short int *)NULL);

    errcode = 15;
  }

  else
  {
    if(!(qs == ((unsigned int *)NULL)))
      *qs = rp->q_start;

    if(!(qe == ((unsigned int *)NULL)))
      *qe = rp->q_end;

    if(!(rs == ((unsigned int *)NULL)))
      *rs = (unsigned int)rp->s_start;

    if(!(re == ((unsigned int *)NULL)))
      *re = (unsigned int)rp->s_end;

    if(!(rx == ((signed long int *)NULL)))
      *rx = rp->sidx;

    if(!(swscor == ((signed int *)NULL)))
      *swscor = rp->swatscor;

    if(!(flag == ((unsigned short int *)NULL)))
      *flag = rp->status;

    errcode = 0;
  }
  return errcode;
}

// resultGetFragmentNo
// file results.c line 905
signed short int resultGetFragmentNo(const struct _RESULT *rp)
{
  return rp->qsegx;
}

// resultGetMapQualScore
// file results.c line 923
signed int resultGetMapQualScore(double *prob, unsigned short int *flag, const struct _RESULT * const rp)
{
  signed int mapq = 0;
  signed int tmp_if_expr$1;
  if(!(rp == ((const struct _RESULT *)NULL)))
  {
    if(!(rp->mapscor >= 0))
      tmp_if_expr$1 = 0;

    else
      tmp_if_expr$1 = rp->mapscor;
    mapq = tmp_if_expr$1;
    if(!(prob == ((double *)NULL)))
      *prob = rp->prob;

    if(!(flag == ((unsigned short int *)NULL)))
      *flag = rp->status;

  }

  else
  {
    if(!(prob == ((double *)NULL)))
      *prob = 0.0;

    if(!(flag == ((unsigned short int *)NULL)))
      *flag = (unsigned short int)0;

  }
  return mapq;
}

// resultGetSWRank
// file results.c line 910
signed short int resultGetSWRank(const struct _RESULT *rp)
{
  return rp->swrank;
}

// resultGetStatusFlag
// file results.c line 915
unsigned short int resultGetStatusFlag(const struct _RESULT *rp)
{
  unsigned short int flg = (unsigned short int)0;
  if(!(rp == ((const struct _RESULT *)NULL)))
    flg = rp->status;

  return flg;
}

// resultSetAdd2ndaryResultsToReport
// file results.c line 2249
signed int resultSetAdd2ndaryResultsToReport(struct _Report *rep, unsigned char mateflg, unsigned char rsltflg, const struct _ResultSet *rsp)
{
  signed int errcode = 0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(rsp == ((const struct _ResultSet *)NULL)))
  {
    signed short int qsegx = (signed short int)0;
    for( ; !((signed int)qsegx >= (signed int)rsp->qsegno); qsegx = qsegx + 1)
    {
      signed short int r = rsp->segnor[(signed long int)qsegx];
      signed int swscor = 0;
      for( ; !((signed int)r >= (signed int)rsp->segnor[(signed long int)(1 + (signed int)qsegx)]); r = r + 1)
      {
        struct _RESULT *rp = rsp->segsrtr[(signed long int)r];
        if((16 & (signed int)rp->status) == 0)
        {
          if(!((512 & (signed int)rp->status) == 0))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            if(!(rp->swatscor >= swscor))
            {
              if(!((1 & (signed int)rsltflg) == 0))
                tmp_if_expr$1 = (_Bool)1;

              else
                tmp_if_expr$1 = ((signed int)rp->status & 32) != 0 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$2 = (_Bool)0;
            tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
            break;

          errcode=resultSetAddResultToReport(rep, -1, (signed short int)0, mateflg, (unsigned char)0, 0, rp, rsp);
          if(!(errcode == 0))
            return errcode;

          rp->status = rp->status | (unsigned short int)512;
          swscor = rp->swatscor;
        }

      }
    }
  }

  return errcode;
}

// resultSetAddFromAli
// file results.c line 1852
signed int resultSetAddFromAli(struct _ResultSet *rsp, const struct _AliRsltSet *arsp, unsigned int soffs, unsigned int qoffs, unsigned int qlen, signed long int seqidx, char is_reverse)
{
  signed int errcode = 0;
  unsigned char is_new;
  signed short int i;
  signed short int nres;
  nres=aliRsltSetGetSize(arsp);
  signed int qs;
  signed int qe;
  signed int rs;
  signed int re;
  struct _RESULT *rp;
  const struct _DiffStr *dfsp;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$5;
  unsigned long int tmp_post$6;
  _Bool tmp_if_expr$8;
  signed int return_value_isIdenticalResult$7;
  if(!((signed int)nres >= 1))
    return 0;

  else
  {
    if(((unsigned long int *)rsp->resr)[-1l] >= ((unsigned long int *)rsp->resr)[-2l])
    {
      void *return_value_arrayRealloc$1;
      return_value_arrayRealloc$1=arrayRealloc((void *)rsp->resr, (unsigned long int)0, (char)0, "results.c", 1875);
      rp = (struct _RESULT *)return_value_arrayRealloc$1;
      if(!(rp == ((struct _RESULT *)NULL)))
      {
        rsp->resr = rp;
        tmp_post$2 = ((unsigned long int *)rsp->resr)[(signed long int)-1];
        ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] + 1ul;
        rp = rsp->resr + (signed long int)tmp_post$2;
      }

    }

    else
    {
      tmp_post$3 = ((unsigned long int *)rsp->resr)[(signed long int)-1];
      ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] + 1ul;
      rp = rsp->resr + (signed long int)tmp_post$3;
    }
    if(rp == ((struct _RESULT *)NULL))
      return 2;

    else
    {
      memset((void *)rp, 0, sizeof(struct _RESULT) /*72ul*/ );
      is_new = (unsigned char)0;
      rp->status = (unsigned short int)0;
      rsp->status = (unsigned char)0;
      i = (signed short int)0;
      for( ; !((signed int)i >= (signed int)nres); i = i + 1)
      {
        if(!(is_new == 0))
        {
          if(((unsigned long int *)rsp->resr)[-1l] >= ((unsigned long int *)rsp->resr)[-2l])
          {
            void *return_value_arrayRealloc$4;
            return_value_arrayRealloc$4=arrayRealloc((void *)rsp->resr, (unsigned long int)0, (char)0, "results.c", 1886);
            rp = (struct _RESULT *)return_value_arrayRealloc$4;
            if(!(rp == ((struct _RESULT *)NULL)))
            {
              rsp->resr = rp;
              tmp_post$5 = ((unsigned long int *)rsp->resr)[(signed long int)-1];
              ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] + 1ul;
              rp = rsp->resr + (signed long int)tmp_post$5;
            }

          }

          else
          {
            tmp_post$6 = ((unsigned long int *)rsp->resr)[(signed long int)-1];
            ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] + 1ul;
            rp = rsp->resr + (signed long int)tmp_post$6;
          }
          if(rp == ((struct _RESULT *)NULL))
            return 2;

          is_new = (unsigned char)0;
          rp->status = (unsigned short int)0;
        }

        errcode=aliRsltSetFetchData(arsp, i, &rp->swatscor, &qs, &qe, &rs, &re, &dfsp);
        if(!(errcode == 0))
          break;

        if(!(is_reverse == 0))
        {
          rp->q_start = (qoffs + qlen) - (unsigned int)qe;
          rp->q_end = (qoffs + qlen) - (unsigned int)qs;
        }

        else
        {
          rp->q_start = (unsigned int)qs + qoffs + (unsigned int)1;
          rp->q_end = (unsigned int)qe + qoffs + (unsigned int)1;
        }
        rp->s_start = (unsigned long int)(soffs + (unsigned int)rs + (unsigned int)1);
        rp->s_end = (unsigned long int)(soffs + (unsigned int)re + (unsigned int)1);
        rp->sidx = seqidx;
        rp->swrank = (signed short int)0;
        if(seqidx == -1l)
          rp->status = rp->status | (unsigned short int)8;

        if(!(((unsigned long int *)rsp->resr)[-1l] >= 2ul))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_isIdenticalResult$7=isIdenticalResult(rp, rp - (signed long int)1);
          tmp_if_expr$8 = !(return_value_isIdenticalResult$7 != 0) ? (_Bool)1 : (_Bool)0;
        }
        is_new = (unsigned char)tmp_if_expr$8;
        if(!(is_new == 0))
        {
          rp->stroffs = rsp->diffstrp->len;
          rp->strlen = dfsp->len;
          errcode=diffStrAppend(rsp->diffstrp, dfsp);
          if(!(errcode == 0))
            return errcode;

          if(!(rsp->swatscor_2ndmax >= rp->swatscor))
          {
            if(!(rsp->swatscor_max >= rp->swatscor))
            {
              rsp->swatscor_2ndmax = rsp->swatscor_max;
              rsp->swatscor_max = rp->swatscor;
            }

            else
              if(!(rp->swatscor >= rsp->swatscor_max))
                rsp->swatscor_2ndmax = rp->swatscor;

          }

          rp->status = rp->status | (unsigned short int)1;
          if(!(is_reverse == 0))
            rp->status = rp->status | (unsigned short int)4;

          rp->mapscor = 0;
          rp->rsltx = (signed short int)-1;
          rp->qsegx = (signed short int)-1;
        }

        else
        {
          ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] - 1ul;
          if(((unsigned long int *)rsp->resr)[-1l] == 0ul)
            rsp->status = (unsigned char)0;

        }
      }
      return errcode;
    }
  }
}

// resultSetAddMisMatch
// file results.c line 1944
signed int resultSetAddMisMatch(struct _ResultSet *rsp, const signed int *mmoffs, signed int mmnum, unsigned int qoffs, signed int len, unsigned int soffs, signed long int sidx, char is_rcpl, signed int swatscor)
{
  signed int errcode;
  signed int diffstrlen;
  unsigned long int newlen;
  signed int nl;
  struct _RESULT *rp;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  if(!(len >= 1))
    return -1;

  else
  {
    errcode=diffStrGenerateFromMismatches(&diffstrlen, (unsigned char *)(void *)0, mmoffs, mmnum, len);
    if(!(errcode == 0))
      return errcode;

    else
    {
      newlen = (unsigned long int)(rsp->diffstrp->len + diffstrlen + 1);
      if(newlen >= 2147483648ul)
        return 48;

      else
      {
        nl = (signed int)newlen;
        if(!(rsp->diffstrp->n_alloc >= nl))
        {
          errcode=diffStrRealloc(rsp->diffstrp, nl);
          if(errcode == 0)
            goto __CPROVER_DUMP_L4;

          return errcode;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(((unsigned long int *)rsp->resr)[-1l] >= ((unsigned long int *)rsp->resr)[-2l])
          {
            void *return_value_arrayRealloc$1;
            return_value_arrayRealloc$1=arrayRealloc((void *)rsp->resr, (unsigned long int)0, (char)0, "results.c", 1967);
            rp = (struct _RESULT *)return_value_arrayRealloc$1;
            if(!(rp == ((struct _RESULT *)NULL)))
            {
              rsp->resr = rp;
              tmp_post$2 = ((unsigned long int *)rsp->resr)[(signed long int)-1];
              ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] + 1ul;
              rp = rsp->resr + (signed long int)tmp_post$2;
            }

          }

          else
          {
            tmp_post$3 = ((unsigned long int *)rsp->resr)[(signed long int)-1];
            ((unsigned long int *)rsp->resr)[(signed long int)-1] = ((unsigned long int *)rsp->resr)[(signed long int)-1] + 1ul;
            rp = rsp->resr + (signed long int)tmp_post$3;
          }
          if(rp == ((struct _RESULT *)NULL))
            return 2;

          else
          {
            memset((void *)rp, 0, sizeof(struct _RESULT) /*72ul*/ );
            rp->status = (unsigned short int)1;
            if(!(is_rcpl == 0))
              rp->status = rp->status | (unsigned short int)4;

            rp->q_start = qoffs + (unsigned int)1;
            rp->q_end = qoffs + (unsigned int)len;
            rp->s_start = (unsigned long int)(soffs + (unsigned int)1);
            rp->s_end = (unsigned long int)(soffs + (unsigned int)len);
            rp->sidx = sidx;
            rp->swrank = (signed short int)0;
            if(sidx == -1l)
              rp->status = rp->status | (unsigned short int)8;

            rp->swatscor = swatscor;
            if(!(rsp->swatscor_2ndmax >= rp->swatscor))
            {
              if(!(rsp->swatscor_max >= rp->swatscor))
              {
                rsp->swatscor_2ndmax = rsp->swatscor_max;
                rsp->swatscor_max = rp->swatscor;
              }

              else
                if(!(rp->swatscor >= rsp->swatscor_max))
                  rsp->swatscor_2ndmax = rp->swatscor;

            }

            rp->mapscor = 0;
            rp->rsltx = (signed short int)-1;
            rp->qsegx = (signed short int)-1;
            rp->stroffs = rsp->diffstrp->len;
            rp->strlen = diffstrlen;
            errcode=diffStrGenerateFromMismatches(&diffstrlen, rsp->diffstrp->dstrp + (signed long int)rp->stroffs, mmoffs, mmnum, len);
            if(!(errcode == 0))
              return errcode;

            else
            {
              rsp->diffstrp->len = rsp->diffstrp->len + diffstrlen;
              rsp->status = (unsigned char)0;
              return 0;
            }
          }
        }
      }
    }
  }
}

// resultSetAddPairToReport
// file resultpairs.h line 152
signed int resultSetAddPairToReport(struct _Report *rep, const struct _InsHist *ihistp, const struct _ResultPairs *pairp, unsigned char pairflg, unsigned char rsltouflg, const struct _ResultSet *rsrp, const struct _ResultSet *rsmp)
{
  signed int errcode = 0;
  signed int n_max = 0;
  signed short int mapqA;
  signed short int mapqB;
  unsigned char mapflg = (unsigned char)0;
  unsigned char repmateflg = (unsigned char)4;
  const struct _RESULT *ap = (const struct _RESULT *)(void *)0;
  const struct _RESULT *bp = (const struct _RESULT *)(void *)0;
  errcode=scorePairsSimple(&ap, &bp, &mapqA, &mapqB, &mapflg, &n_max, pairp->mpr, pairflg, ihistp, rsltouflg, rsrp, rsmp);
  _Bool tmp_if_expr$1;
  if(!(errcode == 0))
    return errcode;

  else
  {
    if((8 & (signed int)rsltouflg) == 0 && n_max >= 2 && !((2 & (signed int)rsltouflg) == 0))
    {
      unsigned char isMultiA;
      unsigned char isMultiB;
      ap=resultSetGetTopResult(&isMultiA, (const unsigned char)0, rsrp);
      bp=resultSetGetTopResult(&isMultiB, (const unsigned char)0, rsmp);
      if(isMultiA == 0)
      {
        bp = (const struct _RESULT *)(void *)0;
        mapflg = mapflg | (unsigned char)64;
      }

      else
        if(isMultiB == 0)
        {
          ap = (const struct _RESULT *)(void *)0;
          mapflg = mapflg | (unsigned char)32;
        }

        else
        {
          mapflg = mapflg | (unsigned char)(32 | 64);
          ap = (const struct _RESULT *)(void *)0;
          bp = (const struct _RESULT *)(void *)0;
        }
    }

    errcode=addPairResultsToReport(rep, mapflg, (unsigned char)((signed int)repmateflg | 16), ap, mapqA, rsrp, bp, mapqB, rsmp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      if((2 & (signed int)rsltouflg) == 0 && (8 & (signed int)rsltouflg) == 0 && !((96 & (signed int)mapflg) == 0))
      {
        signed int i = 0;
        for( ; !(i >= n_max); i = i + 1)
        {
          struct _MATEPAIR *mp = pairp->mpr + (signed long int)i;
          if(!(mp->ap == ap))
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = mp->bp != bp ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
          {
            unsigned char mflg = (unsigned char)((signed int)mp->mapflg | (signed int)mapflg & (32 | 64));
            errcode=addPairResultsToReport(rep, mflg, (unsigned char)((signed int)repmateflg | 16), mp->ap, mapqA, rsrp, mp->bp, mapqB, rsmp);
            if(!(errcode == 0))
              return errcode;

          }

        }
      }

      if(!((1 & (signed int)rsltouflg) == 0) && !((4 & (signed int)rsltouflg) == 0))
      {
        errcode=resultSetAdd2ndaryResultsToReport(rep, (unsigned char)((signed int)repmateflg | 32), rsltouflg, rsrp);
        if(!(errcode == 0))
          return errcode;

        errcode=resultSetAdd2ndaryResultsToReport(rep, (unsigned char)((signed int)repmateflg | 32 | 8), rsltouflg, rsmp);
        if(errcode == 0)
          goto __CPROVER_DUMP_L15;

        return errcode;
      }

      else
      {

      __CPROVER_DUMP_L15:
        ;
        return errcode;
      }
    }
  }
}

// resultSetAddResultToReport
// file results.c line 2209
signed int resultSetAddResultToReport(struct _Report *rep, signed int pairid, signed short int mapscor, unsigned char mateflg, unsigned char pairflg, signed int isize, const struct _RESULT *rp, const struct _ResultSet *rsp)
{
  signed int errcode;
  _Bool tmp_if_expr$2;
  if(rp == ((const struct _RESULT *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ((signed int)rp->status & 16) != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$1;
  if(tmp_if_expr$2)
    errcode=reportAddMap(rep, pairid, 0, (signed short int)0, (unsigned int)0, (unsigned int)0, (unsigned int)0, (unsigned int)0, (signed long int)0, (const unsigned char *)(void *)0, 0, 0, mateflg, pairflg);

  else
  {
    unsigned char *dstrp = rsp->diffstrp->dstrp + (signed long int)rp->stroffs;
    mateflg = mateflg | (unsigned char)1;
    if(!((4 & (signed int)rp->status) == 0))
      mateflg = mateflg | (unsigned char)2;

    if(!(pairid >= 0))
      tmp_if_expr$1 = rp->mapscor;

    else
      tmp_if_expr$1 = (signed int)mapscor;
    errcode=reportAddMap(rep, pairid, rp->swatscor, (signed short int)tmp_if_expr$1, rp->q_start, rp->q_end, (unsigned int)rp->s_start, (unsigned int)rp->s_end, rp->sidx, dstrp, rp->strlen, isize, mateflg, pairflg);
  }
  return errcode;
}

// resultSetAddToReport
// file results.h line 518
signed int resultSetAddToReport(struct _Report *rep, unsigned char rsltflg, const struct _ResultSet *rsp)
{
  signed int errcode = 0;
  signed short int i;
  signed short int nsort = (signed short int)((unsigned long int *)rsp->sortr)[(signed long int)-1];
  struct _RESULT *rp;
  struct _RESULT *tmp_if_expr$1;
  if(!((signed int)nsort >= 1))
    tmp_if_expr$1 = (struct _RESULT *)(void *)0;

  else
    tmp_if_expr$1 = rsp->sortr[(signed long int)0];
  rp = tmp_if_expr$1;
  unsigned char mateflg = (unsigned char)0;
  if(!(rp == ((struct _RESULT *)NULL)))
  {
    signed short int ns = (signed short int)0;
    unsigned char is_single;
    is_single=getNumberOfTopSwatRESULTs(&ns, rsp->sortr);
    if(rp->mapscor == 0)
    {
      if(is_single == 0)
      {
        if((signed int)ns >= 2)
        {
          if(!((1 & (signed int)rsltflg) == 0))
          {
            if((4 & (signed int)rsltflg) == 0)
            {
              mateflg = mateflg | (unsigned char)64;
              if(!((8 & (signed int)rsltflg) == 0))
              {
                signed short int r;
                double return_value_drand48$2;
                return_value_drand48$2=drand48();
                r = (signed short int)(return_value_drand48$2 * (double)ns);
                rp = rsp->sortr[(signed long int)r];
                if(!(rp == ((struct _RESULT *)NULL)))
                  rp->mapscor=assignPhredScaledMappingScoreToRandomDraw((signed int)ns);

              }

              else
                if(!((2 & (signed int)rsltflg) == 0))
                  rp = (struct _RESULT *)(void *)0;

            }

          }

        }

      }

    }

  }

  errcode=resultSetAddResultToReport(rep, -1, (signed short int)0, (unsigned char)((signed int)mateflg | 16), (unsigned char)0, 0, rp, rsp);
  if(!(errcode == 0))
    return errcode;

  else
  {
    if(!(rp == ((struct _RESULT *)NULL)))
      rp->status = rp->status | (unsigned short int)512;

    if((4 & (signed int)rsltflg) == 0 && !((2 & (signed int)rsltflg) == 0))
      return 0;

    else
    {
      i = (signed short int)1;
      for( ; !((signed int)i >= (signed int)nsort); i = i + 1)
      {
        rp = rsp->sortr[(signed long int)i];
        if(!((1 & (signed int)rsltflg) == 0))
        {
          if(!(rp->swatscor >= rsp->sortr[(signed long int)((signed int)i + -1)]->swatscor))
            break;

        }

        if((48 & (signed int)rp->status) == 0)
        {
          errcode=resultSetAddResultToReport(rep, -1, (signed short int)0, mateflg, (unsigned char)0, 0, rp, rsp);
          if(!(errcode == 0))
            return errcode;

          rp->status = rp->status | (unsigned short int)512;
        }

      }
      if(!((1 & (signed int)rsltflg) == 0) && !((4 & (signed int)rsltflg) == 0))
        errcode=resultSetAdd2ndaryResultsToReport(rep, (unsigned char)((signed int)mateflg | 32), rsltflg, rsp);

      return errcode;
    }
  }
}

// resultSetAlignmentStats
// file results.c line 1837
void resultSetAlignmentStats(struct _ResultSet *rsp, signed int n_ali_done, signed int n_ali_tot, signed short int max_depth, unsigned int n_hits_used, unsigned int n_hits_tot)
{
  rsp->n_ali_done = n_ali_done;
  rsp->n_ali_tot = n_ali_tot;
  rsp->n_ali_max = max_depth;
  rsp->n_hits_used = n_hits_used;
  rsp->n_hits_tot = n_hits_tot;
}

// resultSetAlignmentWasCurtailed
// file results.c line 1847
unsigned char resultSetAlignmentWasCurtailed(const struct _ResultSet *rsp)
{
  _Bool tmp_if_expr$1;
  if(!((signed int)rsp->n_ali_max >= rsp->n_ali_tot))
    tmp_if_expr$1 = rsp->n_ali_done >= (signed int)rsp->n_ali_max ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (unsigned char)tmp_if_expr$1;
}

// resultSetBlank
// file results.c line 2066
void resultSetBlank(struct _ResultSet *rsp)
{
  ((unsigned long int *)rsp->resr)[(signed long int)-1] = (unsigned long int)0;
  ((unsigned long int *)rsp->sortr)[(signed long int)-1] = (unsigned long int)0;
  rsp->diffstrp->len = 0;
  rsp->swatscor_max = 0;
  rsp->swatscor_2ndmax = 0;
  rsp->n_ali_done = 0;
  rsp->n_ali_tot = 0;
  rsp->n_hits_used = (unsigned int)0;
  rsp->n_hits_tot = (unsigned int)0;
  rsp->qsegno = (signed short int)0;
  rsp->status = (unsigned char)0;
}

// resultSetBlankPairs
// file resultpairs.c line 1103
void resultSetBlankPairs(struct _ResultPairs *p)
{
  if(!(p == ((struct _ResultPairs *)NULL)))
  {
    ((unsigned long int *)p->ivr)[(signed long int)-1] = (unsigned long int)0;
    ((unsigned long int *)p->mpr)[(signed long int)-1] = (unsigned long int)0;
    p->status = (unsigned char)0;
    p->n_proper = 0;
    p->n_within = 0;
    p->dmin = 0;
    p->dmax = 0;
  }

}

// resultSetCreate
// file results.c line 1781
struct _ResultSet * resultSetCreate(signed int blocksiz, signed int blocksiz_diffstr)
{
  struct _ResultSet *rsp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ResultSet) /*104ul*/ , "results.c", 1785);
  rsp = (struct _ResultSet *)return_value_ecalloc$1;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  if(rsp == ((struct _ResultSet *)NULL))
    return (struct _ResultSet *)(void *)0;

  else
  {
    if(!(blocksiz >= 1))
      blocksiz = 256;

    if(!(blocksiz_diffstr >= 1))
      blocksiz = 4096;

    void *return_value_arrayCreate$2;
    return_value_arrayCreate$2=arrayCreate(sizeof(struct _RESULT) /*72ul*/ , (unsigned long int)blocksiz, "results.c", 1791);
    rsp->resr = (struct _RESULT *)return_value_arrayCreate$2;
    void *return_value_arrayCreate$3;
    return_value_arrayCreate$3=arrayCreate(sizeof(struct _RESULT *) /*8ul*/ , (unsigned long int)blocksiz, "results.c", 1792);
    rsp->sortr = (struct _RESULT **)return_value_arrayCreate$3;
    void *return_value_arrayCreate$4;
    return_value_arrayCreate$4=arrayCreate(sizeof(struct _RESULT *) /*8ul*/ , (unsigned long int)blocksiz, "results.c", 1793);
    rsp->segsrtr = (struct _RESULT **)return_value_arrayCreate$4;
    void *return_value_arrayCreate$5;
    return_value_arrayCreate$5=arrayCreate(sizeof(unsigned int) /*4ul*/ , (unsigned long int)blocksiz, "results.c", 1794);
    rsp->sortidxr = (unsigned int *)return_value_arrayCreate$5;
    void *return_value_arrayCreate$6;
    return_value_arrayCreate$6=arrayCreate(sizeof(unsigned long int) /*8ul*/ , (unsigned long int)blocksiz, "results.c", 1795);
    rsp->sortkeyr = (unsigned long int *)return_value_arrayCreate$6;
    void *return_value_arrayCreate$7;
    return_value_arrayCreate$7=arrayCreate(sizeof(signed short int) /*2ul*/ , (unsigned long int)32, "results.c", 1796);
    rsp->segnor = (signed short int *)return_value_arrayCreate$7;
    rsp->diffstrp=diffStrCreate(blocksiz_diffstr);
    rsp->diffstrbufp=diffStrCreate(256);
    if(!(rsp->resr == ((struct _RESULT *)NULL)))
      tmp_if_expr$8 = rsp->sortr != ((struct _RESULT **)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = rsp->segsrtr != ((struct _RESULT **)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = rsp->segnor != ((signed short int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
      tmp_if_expr$11 = rsp->sortidxr != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$11 = (_Bool)0;
    if(tmp_if_expr$11)
      tmp_if_expr$12 = rsp->sortidxr != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$12 = (_Bool)0;
    if(tmp_if_expr$12)
      tmp_if_expr$13 = rsp->diffstrp != ((struct _DiffStr *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$13 = (_Bool)0;
    if(tmp_if_expr$13)
      tmp_if_expr$14 = rsp->diffstrbufp != ((struct _DiffStr *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$14 = (_Bool)0;
    if(!tmp_if_expr$14)
    {
      resultSetDelete(rsp);
      rsp = ((struct _ResultSet *)NULL);
    }

    else
      rsp->status = (unsigned char)0;
    return rsp;
  }
}

// resultSetCreateFilter
// file results.h line 621
struct _ResultFilter * resultSetCreateFilter(void)
{
  struct _ResultFilter *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ResultFilter) /*16ul*/ , "results.c", 2574);
  p = (struct _ResultFilter *)return_value_ecalloc$1;
  return p;
}

// resultSetCreatePairs
// file resultpairs.c line 1073
struct _ResultPairs * resultSetCreatePairs(signed short int blksz)
{
  struct _ResultPairs *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ResultPairs) /*40ul*/ , "resultpairs.c", 1077);
  p = (struct _ResultPairs *)return_value_ecalloc$1;
  _Bool tmp_if_expr$4;
  if(p == ((struct _ResultPairs *)NULL))
    return ((struct _ResultPairs *)NULL);

  else
  {
    if(!((signed int)blksz >= 1))
      blksz = (signed short int)256;

    void *return_value_arrayCreate$2;
    return_value_arrayCreate$2=arrayCreate(sizeof(struct _OFFSIVAL) /*32ul*/ , (unsigned long int)blksz, "resultpairs.c", 1081);
    p->ivr = (struct _OFFSIVAL *)return_value_arrayCreate$2;
    void *return_value_arrayCreate$3;
    return_value_arrayCreate$3=arrayCreate(sizeof(struct _MATEPAIR) /*48ul*/ , (unsigned long int)blksz, "resultpairs.c", 1082);
    p->mpr = (struct _MATEPAIR *)return_value_arrayCreate$3;
    if(!(p->ivr == ((struct _OFFSIVAL *)NULL)))
      tmp_if_expr$4 = p->mpr != ((struct _MATEPAIR *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      resultSetBlankPairs(p);

    else
    {
      resultSetDeletePairs(p);
      p = ((struct _ResultPairs *)NULL);
    }
    return p;
  }
}

// resultSetDelete
// file results.c line 1819
void resultSetDelete(struct _ResultSet *rsp)
{
  if(!(rsp == ((struct _ResultSet *)NULL)))
  {
    free((void *)((unsigned long int *)rsp->resr - (signed long int)4));
    rsp->resr = (struct _RESULT *)(void *)0;
    free((void *)((unsigned long int *)rsp->sortr - (signed long int)4));
    rsp->sortr = (struct _RESULT **)(void *)0;
    free((void *)((unsigned long int *)rsp->segsrtr - (signed long int)4));
    rsp->segsrtr = (struct _RESULT **)(void *)0;
    free((void *)((unsigned long int *)rsp->sortidxr - (signed long int)4));
    rsp->sortidxr = (unsigned int *)(void *)0;
    free((void *)((unsigned long int *)rsp->sortkeyr - (signed long int)4));
    rsp->sortkeyr = (unsigned long int *)(void *)0;
    free((void *)((unsigned long int *)rsp->segnor - (signed long int)4));
    rsp->segnor = (signed short int *)(void *)0;
    diffStrDelete(rsp->diffstrp);
    diffStrDelete(rsp->diffstrbufp);
  }

  free((void *)rsp);
}

// resultSetDeleteFilter
// file results.h line 625
void resultSetDeleteFilter(struct _ResultFilter *p)
{
  free((void *)p);
}

// resultSetDeletePairs
// file resultpairs.c line 1094
void resultSetDeletePairs(struct _ResultPairs *p)
{
  if(!(p == ((struct _ResultPairs *)NULL)))
  {
    free((void *)((unsigned long int *)p->ivr - (signed long int)4));
    p->ivr = (struct _OFFSIVAL *)(void *)0;
    free((void *)((unsigned long int *)p->mpr - (signed long int)4));
    p->mpr = (struct _MATEPAIR *)(void *)0;
  }

  free((void *)p);
}

// resultSetDo
// file results.c line 2179
signed int resultSetDo(void *argp, signed int (*cbf)(signed int *, void *, const struct _RESULT *), const struct _ResultSet *rsp)
{
  signed int errcode;
  signed int errc = 0;
  signed short int s;
  signed short int nseg;
  signed short int nres;
  errcode=resultSetGetNumberOfSegments(&nres, &nseg, rsp);
  _Bool tmp_if_expr$1;
  if(!(errcode == 0))
    return errcode;

  else
    if(!((signed int)nres >= 1))
      return 0;

    else
    {
      if(!((4 & (signed int)rsp->status) == 0))
        tmp_if_expr$1 = ((signed int)rsp->status & 8) != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        return 47;

      else
      {
        s = (signed short int)0;
        for( ; !(errc == 2) && !((signed int)s >= (signed int)nseg); s = s + 1)
        {
          signed short int r = rsp->segnor[(signed long int)s];
          if(!((signed int)r >= (signed int)rsp->segnor[(signed long int)(1 + (signed int)s)]))
          {
            errc=cbf(&errcode, argp, rsp->segsrtr[(signed long int)r]);
            if(!(errcode == 0))
              return errcode;

            if(errc == 0)
              r = r + 1;

          }

        }
        return errcode;
      }
    }
}

// resultSetFilterData
// file results.h line 629
void resultSetFilterData(struct _ResultFilter *p, signed int sw_abs, signed int sw_rel, double id_abs)
{
  if(!(p == ((struct _ResultFilter *)NULL)))
  {
    p->min_swscor = sw_abs;
    p->min_swscor_below_max = sw_rel;
    p->min_identity = id_abs;
  }

}

// resultSetFilterResults
// file results.c line 2592
signed int resultSetFilterResults(const struct _ResultSet *rsp, const struct _ResultFilter *rsfp, const struct _SeqFastq *sqp)
{
  signed short int i;
  signed short int n = (signed short int)((unsigned long int *)rsp->sortr)[(signed long int)-1];
  signed int maxswscor;
  signed int minabsswscor;
  signed int minrelswscor;
  struct _RESULT *rp;
  unsigned int idthresh;
  idthresh=getFilterIdForRead(rsfp, sqp);
  signed int minid = 0;
  _Bool tmp_if_expr$2;
  signed int return_value_calcRESULTid$1;
  if(!((signed int)n >= 1))
    return 0;

  else
    if(idthresh >= 2147483648u)
      return 48;

    else
    {
      minid = (signed int)idthresh;
      maxswscor = rsp->sortr[(signed long int)0]->swatscor;
      minabsswscor = rsfp->min_swscor;
      minrelswscor = 0;
      if(rsfp->min_swscor_below_max >= 0)
      {
        if(!(rsfp->min_swscor_below_max + minabsswscor >= maxswscor))
          minrelswscor = maxswscor - rsfp->min_swscor_below_max;

      }

      i = (signed short int)0;
      for( ; !((signed int)i >= (signed int)n); i = i + 1)
      {
        rp = rsp->sortr[(signed long int)i];
        if(!(rp->swatscor >= minabsswscor))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_calcRESULTid$1=calcRESULTid(rp, rsp);
          tmp_if_expr$2 = return_value_calcRESULTid$1 < minid ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
          rp->status = rp->status | (unsigned short int)16;

        else
          if(!(rp->swatscor >= minrelswscor))
            rp->status = rp->status | (unsigned short int)32;

      }
      return 0;
    }
}

// resultSetFindPairs
// file resultpairs.c line 1116
signed int resultSetFindPairs(struct _ResultPairs *pairp, unsigned char pairflg, unsigned char pairlibcode, signed int dmin, signed int dmax, const struct _ResultSet *rsltAp, const struct _ResultSet *rsltBp)
{
  signed int errcode;
  unsigned char isSingleA;
  unsigned char isSingleB;
  struct GETMATEPAIRARG_ arg;
  resetPairs(pairp);
  ((unsigned long int *)pairp->mpr)[(signed long int)-1] = (unsigned long int)0;
  pairp->n_proper = 0;
  pairp->n_within = 0;
  pairp->status = (unsigned char)0;
  if(!(dmax >= dmin))
  {
    pairp->dmin = dmax;
    pairp->dmax = dmin;
  }

  else
  {
    pairp->dmin = dmin;
    pairp->dmax = dmax;
  }
  isSingleA=resultSetGetRankDepth(rsltAp, (signed short int *)(void *)0, &arg.max_rankA);
  isSingleB=resultSetGetRankDepth(rsltBp, (signed short int *)(void *)0, &arg.max_rankB);
  if(!((8 & (signed int)pairflg) == 0) && !(isSingleA == 0))
    arg.max_rankA = (signed short int)0;

  else
    if(!((4 & (signed int)pairflg) == 0) && !(isSingleB == 0))
      arg.max_rankB = (signed short int)0;

  arg.pairflg = pairflg;
  arg.pairlibcode = pairlibcode;
  arg.ap = (const struct _RESULT *)(void *)0;
  arg.rsltAp = rsltAp;
  arg.rsltBp = rsltBp;
  arg.pairp = pairp;
  errcode=resultSetDo((void *)&arg, getMATEPAIRcbf_OuterLoop, rsltAp);
  if(errcode == 0)
  {
    pairp->status = pairp->status | (unsigned char)(2 | 16 | 64);
    pairp->status = pairp->status & (unsigned char)~32;
  }

  return errcode;
}

// resultSetFindProperPairs
// file resultpairs.c line 1162
signed int resultSetFindProperPairs(struct _ResultPairs *pairp, signed int dist_lo, signed int dist_hi, signed int maxnum, signed int swscor_min, unsigned char pairlibcode, const struct _ResultSet *rsltAp, const struct _ResultSet *rsltBp)
{
  signed int errcode;
  signed short int nresA;
  signed short int nresB;
  resultSetGetNumberOfSegments(&nresA, (signed short int *)(void *)0, rsltAp);
  resultSetGetNumberOfSegments(&nresB, (signed short int *)(void *)0, rsltBp);
  if(!((signed int)nresA >= 1) || !((signed int)nresB >= 1))
  {
    resetPairs(pairp);
    return 0;
  }

  else
  {
    errcode=generateOFFSIVAL(&pairp->ivr, dist_lo, dist_hi, rsltAp);
    if(errcode == 0)
    {
      pairp->status = pairp->status | (unsigned char)1;
      if(!(swscor_min >= 1))
      {
        signed int sw2ndmax = 0;
        signed int swmax;
        swmax=resultSetGetMaxSwat(rsltBp, &sw2ndmax);
        swscor_min = sw2ndmax > 0 ? sw2ndmax : swmax;
      }

      if(!(dist_hi >= dist_lo))
      {
        pairp->dmin = dist_hi;
        pairp->dmax = dist_lo;
      }

      else
      {
        pairp->dmin = dist_lo;
        pairp->dmax = dist_hi;
      }
      errcode=findProperMATEPAIR(pairp, rsltBp, swscor_min, pairp->ivr, pairlibcode, maxnum);
      pairp->n_proper = (signed int)((unsigned long int *)pairp->mpr)[(signed long int)-1];
      if(errcode == 74)
      {
        pairp->status = pairp->status | (unsigned char)8;
        errcode = 0;
      }

      pairp->status = pairp->status | (unsigned char)(2 | 4 | 64);
      pairp->status = pairp->status & (unsigned char)~(32 | 16);
    }

    return errcode;
  }
}

// resultSetGetMapQualAsProb
// file results.c line 2427
double resultSetGetMapQualAsProb(double *pp2, signed short int *nn1, signed short int *nn2, const struct _ResultSet *rsp)
{
  signed short int n1;
  signed short int n2;
  double p1 = 0.0;
  double p2 = 0.0;
  resultSetGetScorStats(rsp, (signed int *)(void *)0, &n1, (signed int *)(void *)0, &n2);
  if((signed int)n1 == 1)
  {
    signed int isc = rsp->sortr[(signed long int)0]->mapscor;
    if(!(isc >= 0))
      isc = 0;

    p2=exp((double)(-QUALSCOR_LOGBASE * (float)isc) / (double)10);
    p1 = 1.0 - p2;
    if((signed int)n2 >= 2)
      p2 = p2 / (double)n2;

  }

  else
    if((signed int)n1 >= 2)
    {
      p1 = 1.0 / (double)n1;
      p2 = p1;
    }

  if(!(pp2 == ((double *)NULL)))
    *pp2 = p2;

  if(!(nn1 == ((signed short int *)NULL)))
    *nn1 = n1;

  if(!(nn2 == ((signed short int *)NULL)))
    *nn2 = n2;

  return p1;
}

// resultSetGetMappingScore
// file results.c line 2416
signed int resultSetGetMappingScore(const struct _ResultSet *rsp, signed int *swscor)
{
  if(!(((unsigned long int *)rsp->sortr)[-1l] >= 1ul))
  {
    if(!(swscor == ((signed int *)NULL)))
      *swscor = 0;

    return 0;
  }

  else
  {
    if(!(swscor == ((signed int *)NULL)))
      *swscor = rsp->sortr[(signed long int)0]->swatscor;

    return rsp->sortr[(signed long int)0]->mapscor;
  }
}

// resultSetGetMaxSwat
// file results.c line 2163
signed int resultSetGetMaxSwat(const struct _ResultSet *rsp, signed int *maxswat_2nd)
{
  if(!(maxswat_2nd == ((signed int *)NULL)))
    *maxswat_2nd = rsp->swatscor_2ndmax;

  return rsp->swatscor_max;
}

// resultSetGetNumberOfPairs
// file resultpairs.c line 1216
signed int resultSetGetNumberOfPairs(signed int *n_proper, const struct _ResultPairs *pairp)
{
  if(!(n_proper == ((signed int *)NULL)))
    *n_proper = pairp->n_proper;

  return (signed int)((unsigned long int *)pairp->mpr)[(signed long int)-1];
}

// resultSetGetNumberOfResultsInSegment
// file results.c line 2105
signed int resultSetGetNumberOfResultsInSegment(signed int segx, const struct _ResultSet *rsp)
{
  signed int nres = 0;
  if(segx >= 0 && !(rsp == ((const struct _ResultSet *)NULL)))
  {
    if(!(1ul + (unsigned long int)segx >= ((unsigned long int *)rsp->segnor)[-1l]))
    {
      nres = (signed int)rsp->segnor[(signed long int)(segx + 1)] - (signed int)rsp->segnor[(signed long int)segx];
      if(!(nres >= 0))
        nres = 0;

    }

  }

  return nres;
}

// resultSetGetNumberOfSegments
// file results.c line 2081
signed int resultSetGetNumberOfSegments(signed short int *nres, signed short int *nseg, const struct _ResultSet *rsp)
{
  signed int errcode = 0;
  _Bool tmp_if_expr$1;
  if(rsp == ((const struct _ResultSet *)NULL))
    errcode = 15;

  else
  {
    if(((unsigned long int *)rsp->sortr)[-1l] >= 32768ul)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ((unsigned long int *)rsp->segnor)[(signed long int)-1] > (unsigned long int)0x7fff ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      errcode = 48;

    else
      if(!(((unsigned long int *)rsp->sortr)[-1l] >= 1ul))
      {
        if(!(nres == ((signed short int *)NULL)))
          *nres = (signed short int)0;

        if(!(nseg == ((signed short int *)NULL)))
          *nseg = (signed short int)0;

      }

      else
        if(!(((unsigned long int *)rsp->segnor)[-1l] >= 2ul))
          errcode = 47;

        else
        {
          if(!(nres == ((signed short int *)NULL)))
            *nres = (signed short int)((unsigned long int *)rsp->sortr)[(signed long int)-1];

          if(!(nseg == ((signed short int *)NULL)))
          {
            *nseg = (signed short int)(((unsigned long int *)rsp->segnor)[(signed long int)-1] - (unsigned long int)1);
            if(!((signed int)*nseg >= 0))
              *nseg = (signed short int)0;

          }

        }
  }
  return errcode;
}

// resultSetGetRankDepth
// file results.c line 2399
unsigned char resultSetGetRankDepth(const struct _ResultSet *rsp, signed short int *depth, signed short int *rank)
{
  signed short int n_max;
  signed short int n_2ndmax;
  resultSetGetScorStats(rsp, (signed int *)(void *)0, &n_max, (signed int *)(void *)0, &n_2ndmax);
  if(!((signed int)n_max >= 2))
  {
    if(!(depth == ((signed short int *)NULL)))
      *depth = (signed short int)((signed int)n_max + (signed int)n_2ndmax);

    if(!(rank == ((signed short int *)NULL)))
      *rank = (signed short int)1;

  }

  else
  {
    if(!(depth == ((signed short int *)NULL)))
      *depth = n_max;

    if(!(rank == ((signed short int *)NULL)))
      *rank = (signed short int)0;

  }
  return (unsigned char)((signed int)n_max == 1);
}

// resultSetGetResultByRank
// file results.c line 2146
signed int resultSetGetResultByRank(const struct _RESULT **rpp, signed int rank, const struct _ResultSet *rsp)
{
  signed int errcode = 0;
  *rpp = (const struct _RESULT *)(void *)0;
  _Bool tmp_if_expr$1;
  if(rsp == ((const struct _ResultSet *)NULL))
    errcode = 15;

  else
    if((4 & (signed int)rsp->status) == 0)
      errcode = 47;

    else
    {
      if(!(rank >= 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (unsigned long int)rank >= ((unsigned long int *)rsp->sortr)[(signed long int)-1] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        errcode = 29;

      else
        *rpp = rsp->sortr[(signed long int)rank];
    }
  return errcode;
}

// resultSetGetResultBySWrank
// file results.c line 2169
struct _RESULT * resultSetGetResultBySWrank(const struct _ResultSet *rsp, signed short int rank)
{
  struct _RESULT *rp = (struct _RESULT *)(void *)0;
  if((signed int)rank >= 0 && !(rsp == ((const struct _ResultSet *)NULL)))
  {
    if(!((unsigned long int)rank >= ((unsigned long int *)rsp->sortr)[-1l]))
      rp = rsp->sortr[(signed long int)rank];

  }

  return rp;
}

// resultSetGetResultInSegment
// file results.c line 2118
signed int resultSetGetResultInSegment(const struct _RESULT **rpp, signed int segx, signed int resx, const struct _ResultSet *rsp)
{
  signed int errcode = 0;
  *rpp = (const struct _RESULT *)(void *)0;
  _Bool tmp_if_expr$1;
  if(rsp == ((const struct _ResultSet *)NULL))
    errcode = 15;

  else
    if(!(((unsigned long int *)rsp->sortr)[-1l] >= 1ul))
      errcode = -1;

    else
      if((8 & (signed int)rsp->status) == 0)
        errcode = 47;

      else
      {
        if(!(resx >= 0) || !(segx >= 0))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (unsigned long int)segx + (unsigned long int)1 >= ((unsigned long int *)rsp->segnor)[(signed long int)-1] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          errcode = 29;

        else
        {
          signed int xs = (signed int)rsp->segnor[(signed long int)segx];
          signed int xe = (signed int)rsp->segnor[(signed long int)(segx + 1)];
          if(!(xe >= xs))
            errcode = 47;

          else
            if(resx >= xe + -xs)
              errcode = 29;

            else
              *rpp = rsp->segsrtr[(signed long int)(xs + resx)];
        }
      }
  return errcode;
}

// resultSetGetScorStats
// file results.c line 2374
signed int resultSetGetScorStats(const struct _ResultSet *rsp, signed int *scor_max, signed short int *num_max, signed int *scor_2ndmax, signed short int *num_2ndmax)
{
  signed short int i;
  signed short int j;
  signed short int nsort = (signed short int)((unsigned long int *)rsp->sortr)[(signed long int)-1];
  if(!(num_2ndmax == ((signed short int *)NULL)) || !(num_max == ((signed short int *)NULL)))
  {
    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)nsort); i = i + 1)
      if(!(rsp->sortr[(signed long int)i]->swatscor >= rsp->swatscor_max))
        break;

    if(!(num_max == ((signed short int *)NULL)))
      *num_max = i;

    if(!(num_2ndmax == ((signed short int *)NULL)))
    {
      j = i;
      for( ; !((signed int)j >= (signed int)nsort); j = j + 1)
        if(!(rsp->sortr[(signed long int)i]->swatscor >= rsp->swatscor_2ndmax))
          break;

      *num_2ndmax = (signed short int)((signed int)j - (signed int)i);
    }

  }

  if(!(scor_max == ((signed int *)NULL)))
    *scor_max = rsp->swatscor_max;

  if(!(scor_2ndmax == ((signed int *)NULL)))
    *scor_2ndmax = rsp->swatscor_2ndmax;

  return (signed int)((unsigned long int *)rsp->resr)[(signed long int)-1];
}

// resultSetGetTopResult
// file results.c line 2516
struct _RESULT * resultSetGetTopResult(unsigned char *is_multi, const unsigned char is_randsel, const struct _ResultSet *rsp)
{
  signed short int ntop;
  unsigned char is_single;
  is_single=getNumberOfTopSwatRESULTs(&ntop, rsp->sortr);
  struct _RESULT *toprp = (struct _RESULT *)(void *)0;
  *is_multi = (unsigned char)0;
  if((signed int)ntop >= 1)
  {
    if(!(is_single == 0))
    {
      toprp = rsp->sortr[(signed long int)0];
      if(!(toprp->mapscor >= 1))
        *is_multi = (unsigned char)1;

    }

    else
      *is_multi = (unsigned char)1;
    if(!(*is_multi == 0))
    {
      if(!(is_randsel == 0))
      {
        signed short int rsltx;
        double return_value_drand48$1;
        return_value_drand48$1=drand48();
        rsltx = (signed short int)(return_value_drand48$1 * (double)ntop);
        toprp = rsp->sortr[(signed long int)rsltx];
        toprp->mapscor=assignPhredScaledMappingScoreToRandomDraw((signed int)ntop);
      }

    }

  }

  return toprp;
}

// resultSetInferInsertSize
// file results.h line 572
signed int resultSetInferInsertSize(signed int *isiz, unsigned char samspec, const struct _ResultSet *rsrp, const struct _ResultSet *rsmp)
{
  signed int errcode = -1;
  *isiz = 0;
  if(((unsigned long int *)rsrp->sortr)[-1l] >= 1ul)
  {
    if(((unsigned long int *)rsmp->sortr)[-1l] >= 1ul)
    {
      const struct _RESULT *rp = rsrp->sortr[(signed long int)0];
      const struct _RESULT *mp = rsmp->sortr[(signed long int)0];
      if(rp->mapscor >= 20)
      {
        if(mp->mapscor >= 20)
        {
          if(!(rp->sidx >= 0l))
            errcode = 47;

          else
          {
            unsigned char flg;
            flg=resultCalcInsertSize(isiz, samspec, rp, mp);
            if((signed int)flg == 1)
              *isiz = *isiz * -1;

            errcode = 0;
          }
        }

      }

    }

  }

  return errcode;
}

// resultSetPrintDebugInfo
// file results.c line 2348
void resultSetPrintDebugInfo(struct _IO_FILE *fp, const struct _ResultSet *rsp)
{
  signed short int i;
  signed short int nres = (signed short int)((unsigned long int *)rsp->resr)[(signed long int)-1];
  const unsigned char *ucp;
  const char *cp;
  const struct _RESULT *rp;
  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)nres); i = i + 1)
  {
    rp = rsp->resr + (signed long int)i;
    fprintf(fp, "PAIR_START %d\n", (signed int)i + 1);
    fprintf(fp, "PAIR_SEGMENT_A %u %u\n", rp->q_start - (unsigned int)1, rp->q_end - (unsigned int)1);
    fprintf(fp, "PAIR_SEGMENT_B %llu %llu\n", (unsigned long long int)rp->s_start - (unsigned long int)1, (unsigned long long int)rp->s_end - (unsigned long int)1);
    fprintf(fp, "PAIR_DIFFS");
    ucp = rsp->diffstrp->dstrp + (signed long int)rp->stroffs;
    for( ; !(*ucp == 0); ucp = ucp + 1l)
      fprintf(fp, " %u", (unsigned int)*ucp);
    fprintf(fp, "\n");
    fprintf(fp, "PAIR_DIFFS_B");
    cp = (char *)rsp->diffstrp->dstrp + (signed long int)rp->stroffs;
    for( ; !(*cp == 0); cp = cp + 1l)
      fprintf(fp, " %i", (signed int)*cp);
    fprintf(fp, "\n");
  }
  fprintf(fp, "PAIR_END\n");
}

// resultSetSortAndAssignSequence
// file results.c line 2022
signed int resultSetSortAndAssignSequence(struct _ResultSet *rsp, struct _SeqFastq *sbufp, unsigned char search_split, const struct _SeqFastq *sqp, const struct _ScoreProfile *scpp, const struct _ScoreProfile *scpRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  errcode=assignSequenceIndex(rsp, sbufp, scpp, scpRCp, ssp, codecp);
  if(!(errcode == 0))
    return errcode;

  else
  {
    errcode=sortAndPrune(rsp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      rsp->qsegno = (signed short int)0;
      if(((unsigned long int *)rsp->sortr)[-1l] >= 1ul)
      {
        errcode=labelComplementarySegments(rsp, (const signed short int)80);
        if(!(errcode == 0))
          return errcode;

        errcode=calcPhredScaledMappingQualityPerQuerySegment(rsp, sqp);
        if(!(errcode == 0))
          return errcode;

        if(!(search_split == 0))
          findSplitReads(rsp->sortr);

      }

      return 0;
    }
  }
}

// resultSetTestOverlap
// file results.c line 2485
unsigned char resultSetTestOverlap(const struct _ResultSet *rs1p, signed int overlap_percent, const struct _ResultSet *rs2p)
{
  unsigned char isOverlap = (unsigned char)0;
  signed int i;
  signed int rl1 = (signed int)((unsigned long int *)rs1p->sortr)[(signed long int)-1];
  signed int rl2 = (signed int)((unsigned long int *)rs2p->sortr)[(signed long int)-1];
  unsigned int minlen;
  unsigned int seg2len;
  unsigned int overlaplen;
  const struct _RESULT *r1p;
  const struct _RESULT *r2p;
  if(!(rl1 >= 1) || !(rl2 >= 1))
    return (unsigned char)0;

  else
  {
    r1p = rs1p->sortr[(signed long int)0];
    minlen = (r1p->q_end - r1p->q_start) + (unsigned int)1;
    i = 0;
    for( ; isOverlap == 0 && !(i >= rl2); i = i + 1)
    {
      r2p = rs2p->sortr[(signed long int)i];
      if(!(r2p->swatscor >= rs2p->swatscor_2ndmax))
        break;

      seg2len = (r2p->q_end - r2p->q_start) + (unsigned int)1;
      overlaplen = seg2len < minlen ? seg2len : minlen;
      overlaplen = (overlaplen * (unsigned int)overlap_percent) / (unsigned int)100;
      if(!(r1p->q_start + overlaplen >= r2p->q_end))
      {
        if(!(r2p->q_start + overlaplen >= r1p->q_end))
          isOverlap = (unsigned char)1;

      }

    }
    return isOverlap;
  }
}

// resultSetUpdateFromSegment
// file results.c line 2003
void resultSetUpdateFromSegment(struct _ResultSet *rsp, signed short int start_idx, signed short int end_idx, unsigned int soffs, unsigned int qoffs, char is_reverse)
{
  signed short int i;
  struct _RESULT *rp;
  i = start_idx;
  for( ; !((signed int)i >= (signed int)end_idx); i = i + 1)
  {
    rp = rsp->resr + (signed long int)i;
    if(!((2 & (signed int)rp->status) == 0))
    {
      rp->s_start = rp->s_start + (unsigned long int)soffs;
      rp->s_end = rp->s_end + (unsigned long int)soffs;
      rp->q_start = rp->q_start + qoffs;
      rp->q_end = rp->q_end + qoffs;
      if(!(is_reverse == 0))
        rp->status = rp->status | (unsigned short int)4;

      rp->status = rp->status & (unsigned short int)~2;
    }

  }
}

// reverseComplementSeq
// file sequence.c line 1009
static signed int reverseComplementSeq(struct _SEQSEQ *sp, const struct _SeqCodec *codecp)
{
  unsigned char uc;
  char *cp = sp->basep;
  char *ep = (cp + (signed long int)sp->size) - (signed long int)1;
  char tmp;
  signed int tmp_if_expr$1;
  char *tmp_post$2;
  signed int tmp_if_expr$3;
  char *tmp_post$4;
  signed int tmp_if_expr$5;
  char *tmp_post$6;
  signed int tmp_if_expr$7;
  char *tmp_post$8;
  char *tmp_post$9;
  char *tmp_post$10;
  if((signed int)sp->code == 2)
    return 22;

  else
  {
    if(!(codecp == ((const struct _SeqCodec *)NULL)))
    {
      if((signed int)sp->code == 1)
      {
        for( ; !(cp >= ep); *tmp_post$4 = tmp)
        {
          if(!((4 & (signed int)*cp) == 0))
            tmp_if_expr$1 = (signed int)*cp;

          else
            tmp_if_expr$1 = (signed int)codecp->codtab_complement[(signed long int)((signed int)*cp & 3)];
          tmp = (char)tmp_if_expr$1;
          tmp_post$2 = cp;
          cp = cp + 1l;
          if(!((4 & (signed int)*ep) == 0))
            tmp_if_expr$3 = (signed int)*ep;

          else
            tmp_if_expr$3 = (signed int)codecp->codtab_complement[(signed long int)((signed int)*ep & 3)];
          *tmp_post$2 = (char)tmp_if_expr$3;
          tmp_post$4 = ep;
          ep = ep - 1l;
        }
        if(cp == ep)
        {
          if((4 & (signed int)*cp) == 0)
            *cp = (char)codecp->codtab_complement[(signed long int)((signed int)*cp & 3)];

        }

      }

      else
      {
        for( ; !(cp >= ep); *tmp_post$8 = tmp)
        {
          uc = codecp->codtab[(signed long int)(signed int)*cp];
          if(!((4 & (signed int)uc) == 0))
            tmp_if_expr$5 = (signed int)*cp;

          else
            tmp_if_expr$5 = (signed int)codecp->decodtab[(signed long int)codecp->codtab_complement[(signed long int)((signed int)uc & 3)]];
          tmp = (char)tmp_if_expr$5;
          uc = codecp->codtab[(signed long int)(signed int)*ep];
          tmp_post$6 = cp;
          cp = cp + 1l;
          if(!((4 & (signed int)uc) == 0))
            tmp_if_expr$7 = (signed int)*ep;

          else
            tmp_if_expr$7 = (signed int)codecp->decodtab[(signed long int)codecp->codtab_complement[(signed long int)((signed int)uc & 3)]];
          *tmp_post$6 = (char)tmp_if_expr$7;
          tmp_post$8 = ep;
          ep = ep - 1l;
        }
        if(cp == ep)
        {
          uc = codecp->codtab[(signed long int)(signed int)*cp];
          if((4 & (signed int)uc) == 0)
            *cp = codecp->decodtab[(signed long int)codecp->codtab_complement[(signed long int)((signed int)uc & 3)]];

        }

      }
    }

    else
      for( ; !(cp >= ep); *tmp_post$10 = tmp)
      {
        tmp = *cp;
        tmp_post$9 = cp;
        cp = cp + 1l;
        *tmp_post$9 = *ep;
        tmp_post$10 = ep;
        ep = ep - 1l;
      }
    return 0;
  }
}

// reverseSeqInPlace
// file sequence.c line 1306
static signed int reverseSeqInPlace(struct _SEQSEQ *sp)
{
  char *cp;
  char *tp;
  char tmp;
  char *tmp_post$1;
  char *tmp_post$2;
  if((signed int)sp->code == 2)
    return 22;

  else
  {
    cp = sp->basep;
    tp = (cp + (signed long int)sp->size) - (signed long int)1;
    for( ; !(cp >= tp); *tmp_post$2 = tmp)
    {
      tmp = *cp;
      tmp_post$1 = cp;
      cp = cp + 1l;
      *tmp_post$1 = *tp;
      tmp_post$2 = tp;
      tp = tp - 1l;
    }
    return 0;
  }
}

// rmapBlank
// file rmap.c line 1620
void rmapBlank(struct RMap_ *rmp)
{
  if(!(rmp == ((struct RMap_ *)NULL)))
  {
    blankRMAPBUFF(rmp->bfp);
    resultSetBlank(rmp->rsrp);
    if(!(rmp->rsmp == ((struct _ResultSet *)NULL)))
      resultSetBlank(rmp->rsmp);

    if(!(rmp->ivr == ((struct V_IVAL_ *)NULL)))
      interValBlank(rmp->ivr);

    if(!(rmp->pairp == ((struct _ResultPairs *)NULL)))
      resultSetBlankPairs(rmp->pairp);

  }

}

// rmapCreate
// file rmap.h line 83
struct RMap_ * rmapCreate(const struct _HashTable *htp, const struct _SeqCodec *codecp, const struct _SeqSet *ssp, const struct _ScoreMatrix *scormtxp, unsigned short int rmapflg)
{
  unsigned char okflg = (unsigned char)0;
  unsigned long int totlen;
  struct RMap_ *rmp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct RMap_) /*104ul*/ , "rmap.c", 1518);
  rmp = (struct RMap_ *)return_value_ecalloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(rmp == ((struct RMap_ *)NULL))
    return ((struct RMap_ *)NULL);

  else
  {
    seqSetGetSeqNumAndTotLen(&totlen, ssp);
    rmp->bfp=createRMAPBUFF(((signed int)rmapflg & 1) != 0 ? scormtxp : (const struct _ScoreMatrix *)(void *)0);
    rmp->prp=createRMAPPROF(codecp);
    rmp->mrp=createRMAPINFO(htp);
    rmp->rsrp=resultSetCreate(0, 0);
    if(!(rmp->bfp == ((struct RMAPBUFF_ *)NULL)))
      tmp_if_expr$2 = rmp->prp != (struct RMAPPROF_ *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = rmp->mrp != (struct RMAPINFO_ *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = rmp->rsrp != (struct _ResultSet *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    okflg = (unsigned char)tmp_if_expr$4;
    if(!((64 & (signed int)rmapflg) == 0) && !(okflg == 0))
    {
      unsigned char nskip = (unsigned char)1;
      rmp->pmp=createRMAPPROF(codecp);
      rmp->mmp=createRMAPINFO(htp);
      rmp->rsmp=resultSetCreate(0, 0);
      rmp->ivr=interValCreate(1028);
      rmp->pairp=resultSetCreatePairs((signed short int)0);
      if(!(okflg == 0))
      {
        rmp->htflyp=hashTableCreate((unsigned char)5, nskip, (unsigned char)0, (unsigned char)0, (unsigned char)0);
        if(!(rmp->htflyp == ((struct _HashTable *)NULL)))
          rmp->mflyp=createRMAPINFO(rmp->htflyp);

        if(!(rmp->mmp == ((struct RMAPINFO_ *)NULL)))
          tmp_if_expr$5 = rmp->rsmp != (struct _ResultSet *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = rmp->ivr != (struct V_IVAL_ *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = rmp->htflyp != (struct _HashTable *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = rmp->pairp != (struct _ResultPairs *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        okflg = (unsigned char)tmp_if_expr$8;
      }

    }

    else
    {
      rmp->pmp = (struct RMAPPROF_ *)(void *)0;
      rmp->mmp = (struct RMAPINFO_ *)(void *)0;
      rmp->rsmp = (struct _ResultSet *)(void *)0;
      rmp->ivr = (struct V_IVAL_ *)(void *)0;
      rmp->pairp = (struct _ResultPairs *)(void *)0;
      rmp->htflyp = (struct _HashTable *)(void *)0;
      rmp->mflyp = (struct RMAPINFO_ *)(void *)0;
    }
    if(!((8 & (signed int)rmapflg) == 0) && !(okflg == 0))
    {
      rmp->mr2p=createRMAPINFO(htp);
      okflg = (unsigned char)((struct RMAPINFO_ *)(void *)0 != rmp->mr2p);
      if(!((64 & (signed int)rmapflg) == 0) && !(okflg == 0))
      {
        rmp->mm2p=createRMAPINFO(htp);
        okflg = (unsigned char)((struct RMAPINFO_ *)(void *)0 != rmp->mm2p);
      }

      else
        rmp->mm2p = (struct RMAPINFO_ *)(void *)0;
    }

    else
    {
      rmp->mr2p = (struct RMAPINFO_ *)(void *)0;
      rmp->mm2p = (struct RMAPINFO_ *)(void *)0;
    }
    if(okflg == 0)
    {
      rmapDelete(rmp);
      rmp = ((struct RMap_ *)NULL);
    }

    return rmp;
  }
}

// rmapDelete
// file rmap.h line 94
void rmapDelete(struct RMap_ *rmp)
{
  if(!(rmp == ((struct RMap_ *)NULL)))
  {
    deleteRMAPBUFF(rmp->bfp);
    deleteRMAPPROF(rmp->prp);
    deleteRMAPPROF(rmp->pmp);
    deleteRMAPINFO(rmp->mrp);
    deleteRMAPINFO(rmp->mr2p);
    deleteRMAPINFO(rmp->mmp);
    deleteRMAPINFO(rmp->mm2p);
    hashTableDelete(rmp->htflyp);
    deleteRMAPINFO(rmp->mflyp);
    interValDelete(rmp->ivr);
    resultSetDelete(rmp->rsrp);
    resultSetDelete(rmp->rsmp);
    resultSetDeletePairs(rmp->pairp);
  }

  free((void *)rmp);
}

// rmapGetData
// file rmap.h line 102
void rmapGetData(const struct _ResultSet **rslt_readp, const struct _ResultSet **rslt_matep, const struct _ResultPairs **pairp, struct _SeqFastq **sbufAp, struct _SeqFastq **sbufBp, const struct RMap_ *rmp)
{
  if(!(rslt_readp == ((const struct _ResultSet **)NULL)))
    *rslt_readp = rmp->rsrp;

  if(!(rslt_matep == ((const struct _ResultSet **)NULL)))
    *rslt_matep = rmp->rsmp;

  if(!(pairp == ((const struct _ResultPairs **)NULL)))
    *pairp = rmp->pairp;

  if(!(sbufAp == ((struct _SeqFastq **)NULL)))
    *sbufAp = rmp->bfp->sqbfp;

  if(!(sbufBp == ((struct _SeqFastq **)NULL)))
    *sbufBp = rmp->bfp->qbfp;

}

// rmapPair
// file rmap.h line 175
signed int rmapPair(struct _ErrMsg *errmsgp, struct RMap_ *rmp, struct _SeqFastq *readp, struct _SeqFastq *matep, unsigned char *pairflgp, signed int d_min, signed int d_max, unsigned char pairlibcode, signed int ktuple_maxhit, unsigned int mincov_read, unsigned int mincov_mate, signed int min_swatscor, unsigned char min_basqval, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _ScoreMatrix *scormtxp, const struct _ResultFilter *rsfp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  signed int errcode_read;
  signed int errcode_mate;
  signed int n_proper;
  signed int mapq1;
  signed int swscor1;
  signed int swscor2_restricted;
  unsigned char rare_mate;
  unsigned int mincov1;
  unsigned int mincov2;
  unsigned int nhit_read;
  unsigned int nhit_mate;
  struct RMAPBUFF_ *bufp = rmp->bfp;
  struct RMAPINFO_ *rr1p;
  struct RMAPINFO_ *rr2p;
  struct RMAPINFO_ *rmrp = rmp->mrp;
  struct RMAPINFO_ *rmmp = rmp->mmp;
  struct RMAPPROF_ *rp1p;
  struct RMAPPROF_ *rp2p;
  struct _ResultSet *rs1p;
  struct _ResultSet *rs2p;
  struct _ResultSet *rsrp = rmp->rsrp;
  struct _ResultSet *rsmp = rmp->rsmp;
  struct _SeqFastq *read1p;
  struct _SeqFastq *read2p;
  _Bool tmp_if_expr$1;
  if(!(rmmp == ((struct RMAPINFO_ *)NULL)))
    tmp_if_expr$1 = rmp->ivr != ((struct V_IVAL_ *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = rmp->pairp != ((struct _ResultPairs *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(!tmp_if_expr$2)
    errMsgAdd(errmsgp, "", "rmap.c", 1785, 47, (unsigned char)2);

  rmapBlank(rmp);
  *pairflgp = (unsigned char)1;
  errcode=makeRMAPPROFfromRead(rmp->prp, readp, scormtxp, codecp);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "rmap.c", 1801, errcode, (unsigned char)2);

  errcode=makeRMAPPROFfromRead(rmp->pmp, matep, scormtxp, codecp);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "rmap.c", 1804, errcode, (unsigned char)2);

  if(!((32 & (signed int)rmapflg) == 0))
  {
    errcode_read=initRMAPINFO(rmrp, min_basqval, (unsigned int)0, (unsigned int)0, readp, htp);
    if(!(errcode_read == 0))
    {
      if(!(errcode_read == 30))
        errMsgAdd(errmsgp, "", "rmap.c", 1811, errcode_read, (unsigned char)2);

    }

    errcode_mate=initRMAPINFO(rmmp, min_basqval, (unsigned int)0, (unsigned int)0, matep, htp);
    if(!(errcode_mate == 0))
    {
      if(!(errcode_mate == 30))
        errMsgAdd(errmsgp, "", "rmap.c", 1815, errcode_mate, (unsigned char)2);

    }

  }

  else
  {
    errcode_read=initRMAPINFOshort(rmrp, ktuple_maxhit, min_basqval, readp, htp);
    if(!(errcode_read == 0))
    {
      if(!(errcode_read == 30))
        errMsgAdd(errmsgp, "", "rmap.c", 1823, errcode_read, (unsigned char)2);

    }

    errcode_mate=initRMAPINFOshort(rmmp, ktuple_maxhit, min_basqval, matep, htp);
    if(!(errcode_mate == 0))
    {
      if(!(errcode_mate == 30))
        errMsgAdd(errmsgp, "", "rmap.c", 1830, errcode_mate, (unsigned char)2);

    }

  }
  _Bool tmp_if_expr$5;
  unsigned char return_value_scorIsAboveFractMax$4;
  if(!(errcode_mate == 0) && !(errcode_read == 0))
    return 0;

  else
  {
    if(!(errcode_read == 0))
      mapSingleRead(errmsgp, bufp, rmp->rsmp, rmmp, rmp->pmp, matep, ktuple_maxhit, mincov_mate, min_swatscor, 0, target_depth, max_depth, rmapflg, htp, ssp, codecp, (const struct V_IVAL_ *)(void *)0);

    if(!(errcode_mate == 0))
      mapSingleRead(errmsgp, bufp, rmp->rsrp, rmrp, rmp->prp, readp, ktuple_maxhit, mincov_read, min_swatscor, 0, target_depth, max_depth, rmapflg, htp, ssp, codecp, (const struct V_IVAL_ *)(void *)0);

    nhit_read=calcTotalNumberOfHits(rmrp, ktuple_maxhit);
    nhit_mate=calcTotalNumberOfHits(rmmp, ktuple_maxhit);
    if(!(nhit_mate >= nhit_read))
    {
      *pairflgp = *pairflgp | (unsigned char)2;
      rare_mate = (unsigned char)1;
      read1p = matep;
      read2p = readp;
      rr1p = rmmp;
      rr2p = rmrp;
      rs1p = rsmp;
      rs2p = rsrp;
      rp1p = rmp->pmp;
      rp2p = rmp->prp;
      mincov1 = mincov_mate;
      mincov2 = mincov_read;
    }

    else
    {
      rare_mate = (unsigned char)0;
      read1p = readp;
      read2p = matep;
      rr1p = rmrp;
      rr2p = rmmp;
      rs1p = rsrp;
      rs2p = rsmp;
      rp1p = rmp->prp;
      rp2p = rmp->pmp;
      mincov1 = mincov_read;
      mincov2 = mincov_mate;
    }
    mapSingleRead(errmsgp, bufp, rs1p, rr1p, rp1p, read1p, ktuple_maxhit, mincov1, min_swatscor, 0, target_depth, max_depth, rmapflg, htp, ssp, codecp, (const struct V_IVAL_ *)(void *)0);
    n_proper = 0;
    mapq1=resultSetGetMappingScore(rs1p, &swscor1);
    swscor2_restricted = 0;
    errcode=setupInterValFromResultSet(rmp->ivr, d_min, d_max, read1p, read2p, htp, ssp, rs1p);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 1937, errcode, (unsigned char)2);

    interValPrune(rmp->ivr);
    mapSingleRead(errmsgp, bufp, rs2p, rr2p, rp2p, read2p, ktuple_maxhit, mincov2, min_swatscor, 0, target_depth, max_depth, rmapflg, htp, ssp, codecp, rmp->ivr);
    errcode=resultSetFindProperPairs(rmp->pairp, d_min, d_max, 1028, 0, pairlibcode, rsrp, rsmp);
    if(!(errcode == 0) && !(errcode == 74))
      errMsgAdd(errmsgp, "", "rmap.c", 1961, errcode, (unsigned char)2);

    resultSetGetMappingScore(rs2p, &swscor2_restricted);
    resultSetGetNumberOfPairs(&n_proper, rmp->pairp);
    if(!((4 & (signed int)rmapflg) == 0) || !(mapq1 >= 20) || !(n_proper >= 1))
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_scorIsAboveFractMax$4=scorIsAboveFractMax(swscor2_restricted, swscor1, MINFRACT_MAXSCOR_2ND, read2p, read1p);
      tmp_if_expr$5 = !(return_value_scorIsAboveFractMax$4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      signed int mapq2;
      signed int swscor2;
      if(!(n_proper >= 1))
        resultSetBlank(rs2p);

      mapSingleRead(errmsgp, bufp, rs2p, rr2p, rp2p, read2p, ktuple_maxhit, mincov2, min_swatscor, 0, target_depth, max_depth, rmapflg, htp, ssp, codecp, (const struct V_IVAL_ *)(void *)0);
      mapq2=resultSetGetMappingScore(rs2p, &swscor2);
      if(mapq2 >= 21 || !(swscor1 >= swscor2) || !(swscor2_restricted >= swscor2))
      {
        signed int swscor1_2ndbest = 0;
        unsigned int rlen = (unsigned int)0;
        resultSetGetScorStats(rs1p, (signed int *)(void *)0, (signed short int *)(void *)0, &swscor1_2ndbest, (signed short int *)(void *)0);
        errcode=setupInterValFromResultSet(rmp->ivr, d_min, d_max, read2p, read1p, htp, ssp, rs2p);
        if(!(errcode == 0))
          errMsgAdd(errmsgp, "", "rmap.c", 2007, errcode, (unsigned char)2);

        interValPrune(rmp->ivr);
        seqFastqGetConstSequence(read1p, &rlen, (char *)(void *)0);
        unsigned char return_value_hashTableGetKtupLen$3;
        return_value_hashTableGetKtupLen$3=hashTableGetKtupLen(htp, (unsigned char *)(void *)0);
        if(rlen >= (unsigned int)return_value_hashTableGetKtupLen$3)
        {
          errcode=setupFineHashTable(rmp->htflyp, bufp->sqbfp, ssp, rmp->ivr, htp, codecp);
          if(!(errcode == 0) && !(errcode == 17))
            errMsgAdd(errmsgp, "", "rmap.c", 2016, errcode, (unsigned char)2);

          if(errcode == 0)
          {
            errcode=initRMAPINFO(rmp->mflyp, min_basqval, (unsigned int)0, (unsigned int)0, read1p, rmp->htflyp);
            if(!(errcode == 0))
            {
              if(!(errcode == 30))
                errMsgAdd(errmsgp, "", "rmap.c", 2023, errcode, (unsigned char)2);

            }

            mapSingleRead(errmsgp, bufp, rs1p, rmp->mflyp, rp1p, read1p, ktuple_maxhit, mincov1, swscor1_2ndbest, 0, target_depth, max_depth, rmapflg, rmp->htflyp, ssp, codecp, rmp->ivr);
          }

          else
          {
            errcode = 0;
            mapSingleRead(errmsgp, bufp, rs1p, rr1p, rp1p, read1p, ktuple_maxhit, mincov1, swscor1_2ndbest, 0, target_depth, max_depth, rmapflg, htp, ssp, codecp, rmp->ivr);
          }
        }

      }

    }

    else
      *pairflgp = (unsigned char)((signed int)*pairflgp | ((signed int)rare_mate == 0 ? 8 : 4));
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 2071, errcode, (unsigned char)2);

    if(!((8 & (signed int)rmapflg) == 0))
    {
      mapSecondary(errmsgp, bufp, rmp->rsrp, rmp->mr2p, rmp->prp, readp, ktuple_maxhit, mincov_read, min_swatscor, 0, min_basqval, target_depth, max_depth, rmapflg, htp, ssp, codecp);
      mapSecondary(errmsgp, bufp, rmp->rsmp, rmp->mm2p, rmp->pmp, matep, ktuple_maxhit, mincov_mate, min_swatscor, 0, min_basqval, target_depth, max_depth, rmapflg, htp, ssp, codecp);
    }

    errcode=resultSetFindPairs(rmp->pairp, *pairflgp, pairlibcode, d_min, d_max, rsrp, rsmp);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 2103, errcode, (unsigned char)2);

    errcode=resultSetFilterResults(rsrp, rsfp, readp);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 2106, errcode, (unsigned char)2);

    errcode=resultSetFilterResults(rsmp, rsfp, matep);
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 2109, errcode, (unsigned char)2);

    return errcode;
  }
}

// rmapSingle
// file rmap.h line 127
signed int rmapSingle(struct _ErrMsg *errmsgp, struct RMap_ *rmp, struct _SeqFastq *readp, signed int ktuple_maxhit, unsigned int min_cover, signed int min_swatscor, signed int min_swatscor_below_max, unsigned char min_basqval, signed short int target_depth, signed short int max_depth, unsigned short int rmapflg, const struct _ScoreMatrix *scormtxp, const struct _ResultFilter *rsfp, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  rmapBlank(rmp);
  errcode=makeRMAPPROFfromRead(rmp->prp, readp, scormtxp, codecp);
  if(!(errcode == 0))
    errMsgAdd(errmsgp, "", "rmap.c", 1681, errcode, (unsigned char)2);

  if(!((32 & (signed int)rmapflg) == 0))
    errcode=initRMAPINFO(rmp->mrp, min_basqval, (unsigned int)0, (unsigned int)0, readp, htp);

  else
    errcode=initRMAPINFOshort(rmp->mrp, ktuple_maxhit, min_basqval, readp, htp);
  if(!(errcode == 0) && !(errcode == 30))
    errMsgAdd(errmsgp, "", "rmap.c", 1696, errcode, (unsigned char)2);

  if(errcode == 0)
    mapSingleRead(errmsgp, rmp->bfp, rmp->rsrp, rmp->mrp, rmp->prp, readp, ktuple_maxhit, min_cover, min_swatscor, min_swatscor_below_max, target_depth, max_depth, rmapflg, htp, ssp, codecp, (const struct V_IVAL_ *)(void *)0);

  if(errcode == 0 && !((8 & (signed int)rmapflg) == 0))
    mapSecondary(errmsgp, rmp->bfp, rmp->rsrp, rmp->mr2p, rmp->prp, readp, ktuple_maxhit, min_cover, min_swatscor, min_swatscor_below_max, min_basqval, target_depth, max_depth, rmapflg, htp, ssp, codecp);

  if(!(errcode == 0) && !(errcode == 30))
    errMsgAdd(errmsgp, "", "rmap.c", 1731, errcode, (unsigned char)2);

  if(errcode == 0)
    errcode=resultSetFilterResults(rmp->rsrp, rsfp, readp);

  if(errcode == 30)
    errcode = 0;

  else
    if(!(errcode == 0))
      errMsgAdd(errmsgp, "", "rmap.c", 1739, errcode, (unsigned char)2);

  return errcode;
}

// scaleALICPLX
// file alignment.c line 268
static signed int scaleALICPLX(signed int *adj_score, signed int orig_score, const struct _ALICPLX *cplxp)
{
  signed int i;
  signed int t_counts;
  signed int n_letters;
  signed int count;
  double t_factor;
  double t_sum;
  n_letters = 0;
  t_sum = (double)n_letters;
  t_factor = t_sum;
  t_counts = (signed int)t_factor;
  i = t_counts;
  for( ; !(i >= (signed int)cplxp->n_types); i = i + 1)
  {
    count = cplxp->countp[(signed long int)i];
    if(!(count == 0))
    {
      double return_value_log$1;
      return_value_log$1=log((double)count);
      t_factor = t_factor + (double)count * return_value_log$1;
      t_sum = t_sum + (double)count * LN0P25;
      t_counts = t_counts + count;
      n_letters = n_letters + 1;
    }

  }
  double return_value_log$2;
  return_value_log$2=log((double)t_counts);
  t_factor = t_factor - (double)t_counts * return_value_log$2;
  t_sum = t_sum - t_factor;
  double return_value_log$3;
  return_value_log$3=log(n_letters > 4 ? 1. / (double)n_letters : .25);
  t_factor = t_factor / ((double)t_counts * return_value_log$3);
  *adj_score = (signed int)((double)orig_score + t_sum / cplxp->lambda + .999);
  if(!(orig_score >= *adj_score))
    return 62;

  else
  {
    if(!(*adj_score >= 0))
      *adj_score = 0;

    return 0;
  }
}

// scorIsAboveFractMax
// file rmap.c line 178
static unsigned char scorIsAboveFractMax(signed int scor_read, signed int scor_mate, float fract, const struct _SeqFastq *readp, const struct _SeqFastq *matep)
{
  unsigned int rlen;
  unsigned int mlen;
  seqFastqGetConstSequence(readp, &rlen, (char *)(void *)0);
  seqFastqGetConstSequence(matep, &mlen, (char *)(void *)0);
  return (unsigned char)((float)scor_read >= ((float)((unsigned int)scor_mate * rlen) * fract) / (float)mlen);
}

// scoreCreateMatrix
// file score.h line 165
struct _ScoreMatrix * scoreCreateMatrix(const struct _SeqCodec *scp, const struct ScorePenalties_ *penp)
{
  signed short int i;
  struct _ScoreMatrix *amp;
  if(scp == ((const struct _SeqCodec *)NULL))
    return (struct _ScoreMatrix *)(void *)0;

  else
  {
    void *return_value_ecalloc$1;
    return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ScoreMatrix) /*24ul*/ , "score.c", 208);
    amp = (struct _ScoreMatrix *)return_value_ecalloc$1;
    if(amp == ((struct _ScoreMatrix *)NULL))
      return (struct _ScoreMatrix *)(void *)0;

    else
    {
      void *return_value_ecalloc$2;
      return_value_ecalloc$2=ecalloc((unsigned long int)(7 + 1), sizeof(signed char *) /*8ul*/ , "score.c", 211);
      amp->score = (signed char **)return_value_ecalloc$2;
      if(amp->score == ((signed char **)NULL))
      {
        scoreDeleteMatrix(amp);
        return (struct _ScoreMatrix *)(void *)0;
      }

      else
      {
        i = (signed short int)0;
        for( ; !((signed int)i >= 8); i = i + 1)
        {
          void *return_value_ecalloc$3;
          return_value_ecalloc$3=ecalloc((unsigned long int)(7 + 1), sizeof(signed char) /*1ul*/ , "score.c", 217);
          amp->score[(signed long int)i] = (signed char *)return_value_ecalloc$3;
          if(amp->score[(signed long int)i] == ((signed char *)NULL))
          {
            scoreDeleteMatrix(amp);
            return (struct _ScoreMatrix *)(void *)0;
          }

        }
        setScoreMatrix(amp, scp, penp);
        return amp;
      }
    }
  }
}

// scoreCreateProfile
// file score.h line 208
struct _ScoreProfile * scoreCreateProfile(signed int blocksize, const struct _SeqCodec *codep, unsigned char mod)
{
  signed short int i;
  signed short int alphabetsiz;
  struct _ScoreProfile *app;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _ScoreProfile) /*64ul*/ , "score.c", 550);
  app = (struct _ScoreProfile *)return_value_ecalloc$1;
  if(app == ((struct _ScoreProfile *)NULL))
    return (struct _ScoreProfile *)(void *)0;

  else
  {
    seqCodecGetAlphabet(codep, &alphabetsiz);
    if(!(blocksize >= 1))
      blocksize = 256;

    if((7 & (signed int)mod) == 0)
      return (struct _ScoreProfile *)(void *)0;

    else
    {
      if(!((1 & (signed int)mod) == 0))
      {
        void *return_value_ecalloc$2;
        return_value_ecalloc$2=ecalloc((unsigned long int)alphabetsiz, sizeof(signed char *) /*8ul*/ , "score.c", 569);
        app->score = (signed char **)return_value_ecalloc$2;
        if(app->score == ((signed char **)NULL))
        {
          scoreDeleteProfile(app);
          return (struct _ScoreProfile *)(void *)0;
        }

        i = (signed short int)0;
        for( ; !((signed int)i >= (signed int)alphabetsiz); i = i + 1)
        {
          void *return_value_ecalloc$3;
          return_value_ecalloc$3=ecalloc((unsigned long int)blocksize, sizeof(signed char) /*1ul*/ , "score.c", 575);
          app->score[(signed long int)i] = (signed char *)return_value_ecalloc$3;
          if(app->score[(signed long int)i] == ((signed char *)NULL))
          {
            scoreDeleteProfile(app);
            return (struct _ScoreProfile *)(void *)0;
          }

        }
      }

      if(!((6 & (signed int)mod) == 0))
      {
        app->striped_datap=ecalloc((unsigned long int)blocksize, 1ul, "score.c", 590);
        if(app->striped_datap == NULL)
        {
          scoreDeleteProfile(app);
          return (struct _ScoreProfile *)(void *)0;
        }

        app->striped_nalloc = (unsigned long int)blocksize;
      }

      app->allocsiz = (unsigned int)blocksize;
      app->blocksiz = (unsigned int)blocksize;
      app->alphabetsiz = alphabetsiz;
      app->mod = mod;
      return app;
    }
  }
}

// scoreDeleteMatrix
// file score.h line 168
void scoreDeleteMatrix(struct _ScoreMatrix *amp)
{
  signed short int i;
  if(!(amp == ((struct _ScoreMatrix *)NULL)))
  {
    if(!(amp->score == ((signed char **)NULL)))
    {
      i = (signed short int)0;
      for( ; !((signed int)i >= 8); i = i + 1)
        free((void *)amp->score[(signed long int)i]);
      free((void *)amp->score);
    }

    free((void *)amp);
  }

}

// scoreDeleteProfile
// file score.h line 216
void scoreDeleteProfile(struct _ScoreProfile *app)
{
  signed short int i;
  if(!(app == ((struct _ScoreProfile *)NULL)))
  {
    if(!(app->score == ((signed char **)NULL)))
    {
      i = (signed short int)0;
      for( ; !((signed int)i >= (signed int)app->alphabetsiz); i = i + 1)
        free((void *)app->score[(signed long int)i]);
      free((void *)app->score);
    }

    free(app->striped_datap);
    free((void *)app);
  }

}

// scoreGetDefaults
// file score.c line 337
signed short int scoreGetDefaults(signed short int *mismatch, signed short int *gapinit, signed short int *gapext)
{
  if(!(mismatch == ((signed short int *)NULL)))
    *mismatch = (signed short int)-2;

  if(!(gapinit == ((signed short int *)NULL)))
    *gapinit = (signed short int)-4;

  if(!(gapext == ((signed short int *)NULL)))
    *gapext = (signed short int)-3;

  return (signed short int)1;
}

// scoreGetPenalties
// file score.c line 114
signed short int scoreGetPenalties(const struct ScorePenalties_ *p, signed short int *mismatch, signed short int *gapinit, signed short int *gapext)
{
  if(!(mismatch == ((signed short int *)NULL)))
    *mismatch = (signed short int)p->penalty[(signed long int)1];

  if(!(gapinit == ((signed short int *)NULL)))
    *gapinit = (signed short int)p->penalty[(signed long int)2];

  if(!(gapext == ((signed short int *)NULL)))
    *gapext = (signed short int)p->penalty[(signed long int)3];

  return (signed short int)p->penalty[(signed long int)0];
}

// scoreGetProfile
// file score.h line 227
signed char * const * scoreGetProfile(signed short int *alphabetsiz, unsigned int *seqlen, signed char *gap_init, signed char *gap_ext, const struct _ScoreProfile *spp)
{
  if(!(alphabetsiz == ((signed short int *)NULL)))
    *alphabetsiz = spp->alphabetsiz;

  if(!(seqlen == ((unsigned int *)NULL)))
    *seqlen = spp->length;

  if(!(gap_init == ((signed char *)NULL)))
    *gap_init = (signed char)(-1 * (signed int)spp->gap_init);

  if(!(gap_ext == ((signed char *)NULL)))
    *gap_ext = (signed char)(-1 * (signed int)spp->gap_ext);

  return spp->score;
}

// scoreGetStripedProfile
// file score.c line 699
const void * scoreGetStripedProfile(signed short int *alphabetsiz, unsigned int *seqlen, unsigned short int *gap_init, unsigned short int *gap_ext, unsigned short int *bias, signed int *segsiz, char mod, const struct _ScoreProfile *spp)
{
  const void *p = NULL;
  if(!(alphabetsiz == ((signed short int *)NULL)))
    *alphabetsiz = spp->alphabetsiz;

  if(!(seqlen == ((unsigned int *)NULL)))
    *seqlen = spp->length;

  if(!(gap_init == ((unsigned short int *)NULL)))
    *gap_init = (unsigned short int)((signed int)(unsigned short int)((signed int)spp->gap_init < 0 ? -1 : 1) * (signed int)spp->gap_init);

  if(!(gap_ext == ((unsigned short int *)NULL)))
    *gap_ext = (unsigned short int)((signed int)(unsigned short int)((signed int)spp->gap_ext < 0 ? -1 : 1) * (signed int)spp->gap_ext);

  signed int tmp_if_expr$1;
  if(!(bias == ((unsigned short int *)NULL)))
  {
    if(!((signed int)spp->bias >= 0))
      tmp_if_expr$1 = -1 * (signed int)spp->bias;

    else
      tmp_if_expr$1 = 0;
    *bias = (unsigned short int)tmp_if_expr$1;
  }

  if((signed int)mod == 2)
  {
    if(!(segsiz == ((signed int *)NULL)))
      *segsiz = (signed int)(((spp->length + (unsigned int)16) - (unsigned int)1) / (unsigned int)16);

    p = (const void *)spp->striped_bytep;
  }

  else
    if((signed int)mod == 4)
    {
      if(!(segsiz == ((signed int *)NULL)))
        *segsiz = (signed int)(((spp->length + (unsigned int)8) - (unsigned int)1) / (unsigned int)8);

      p = (const void *)spp->striped_shortp;
    }

  return p;
}

// scoreMakeProfileFromSequence
// file score.h line 219
signed int scoreMakeProfileFromSequence(struct _ScoreProfile *app, const struct _SeqFastq *sqp, const struct _ScoreMatrix *amp)
{
  signed int errcode;
  const char *cp;
  const char *seq_basp;
  char cod;
  signed short int i;
  unsigned int j;
  unsigned int length;
  signed char *sc;
  signed char *hp;
  seq_basp=seqFastqGetConstSequence(sqp, &length, &cod);
  signed char *tmp_post$1;
  const char *tmp_post$2;
  if(!((signed int)cod == 1))
    return 22;

  else
  {
    if(!((1 & (signed int)app->mod) == 0))
    {
      if(!(app->allocsiz + 4294967295u >= length))
      {
        errcode=reallocScalarProfile(app, (signed int)length);
        if(!(errcode == 0))
          return errcode;

      }

      i = (signed short int)0;
      for( ; !((signed int)i >= (signed int)app->alphabetsiz); i = i + 1)
      {
        cp = seq_basp;
        hp = app->score[(signed long int)i];
        sc = amp->score[(signed long int)i];
        j = length;
        for( ; j >= 1u && !(*cp == 0); j = j - 1u)
        {
          tmp_post$1 = hp;
          hp = hp + 1l;
          tmp_post$2 = cp;
          cp = cp + 1l;
          *tmp_post$1 = sc[(signed long int)((signed int)*tmp_post$2 & 7)];
        }
        *hp = (signed char)0;
      }
    }

    if(!((6 & (signed int)app->mod) == 0))
    {
      errcode=makeStripedProfileFromSequence(app, seq_basp, length, amp);
      if(errcode == 0)
        goto __CPROVER_DUMP_L7;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      app->length = length;
      app->mismatch_avg=scoreMatrixGetAvgSubstScores(&app->match_avg, amp);
      app->gap_init = amp->gap_init;
      app->gap_ext = amp->gap_ext;
      return 0;
    }
  }
}

// scoreMatrixCalcLambda
// file score.c line 252
double scoreMatrixCalcLambda(const struct _ScoreMatrix *smp)
{
  signed int i;
  signed int j;
  double lambda;
  double sum;
  double lambda_lower;
  double lambda_upper;
  lambda_lower = 0.0;
  lambda = 0.5;
  double return_value_exp$1;
  do
  {
    sum = (double)0;
    i = (signed int)sum;
    for( ; !(i >= 4); i = i + 1)
    {
      j = 0;
      for( ; !(j >= 4); j = j + 1)
      {
        return_value_exp$1=exp(lambda * (double)smp->score[(signed long int)i][(signed long int)j]);
        sum = sum + return_value_exp$1;
      }
    }
    sum = sum * 0.0625;
    if(sum >= 1.0)
      break;

    lambda_lower = lambda;
    lambda = lambda * 2.0;
  }
  while((_Bool)1);
  lambda_upper = lambda;
  double return_value_exp$2;
  while(lambda_upper + -lambda_lower > .00001)
  {
    lambda = (lambda_lower + lambda_upper) / 2.0;
    sum = (double)0;
    i = (signed int)sum;
    for( ; !(i >= 4); i = i + 1)
    {
      j = 0;
      for( ; !(j >= 4); j = j + 1)
      {
        return_value_exp$2=exp(lambda * (double)smp->score[(signed long int)i][(signed long int)j]);
        sum = sum + return_value_exp$2;
      }
    }
    sum = sum * 0.0625;
    if(sum >= 1.0)
      lambda_upper = lambda;

    else
      lambda_lower = lambda;
  }
  return lambda;
}

// scoreMatrixGetAlphabetSize
// file score.c line 242
signed short int scoreMatrixGetAlphabetSize(const struct _ScoreMatrix *smp)
{
  return smp->alphabetsiz;
}

// scoreMatrixGetAvgSubstScores
// file score.c line 296
signed char scoreMatrixGetAvgSubstScores(signed char *matchscor, const struct _ScoreMatrix *smp)
{
  signed short int i;
  signed short int j;
  signed int n_diag = 0;
  signed int n_offdiag = 0;
  const signed char *sp;
  signed int match = 0;
  signed int mismatch = 0;
  i = (signed short int)0;
  for( ; !((signed int)i >= 4); i = i + 1)
  {
    sp = smp->score[(signed long int)i];
    j = (signed short int)0;
    for( ; !((signed int)j >= 4); j = j + 1)
      if(!((signed int)sp[(signed long int)j] == 0))
      {
        if(i == j)
        {
          match = match + (signed int)sp[(signed long int)j];
          n_diag = n_diag + 1;
        }

        else
        {
          mismatch = mismatch + (signed int)sp[(signed long int)j];
          n_offdiag = n_offdiag + 1;
        }
      }

  }
  match = match / n_diag;
  if(match >= 128)
    match = 127;

  else
    if(!(match >= -127))
      match = -1 * 127;

  mismatch = mismatch / n_offdiag;
  if(mismatch >= 128)
    mismatch = 127;

  else
    if(!(mismatch >= -127))
      mismatch = -1 * 127;

  if(!(matchscor == ((signed char *)NULL)))
    *matchscor = (signed char)match;

  return (signed char)mismatch;
}

// scoreMatrixGetMinSubstScore
// file score.c line 279
signed char scoreMatrixGetMinSubstScore(const struct _ScoreMatrix *smp)
{
  signed short int i;
  signed short int j;
  const signed char *sp;
  signed char minscor = smp->score[(signed long int)0][(signed long int)0];
  i = (signed short int)0;
  for( ; !((signed int)i >= 8); i = i + 1)
  {
    sp = smp->score[(signed long int)i];
    j = (signed short int)0;
    for( ; !((signed int)j >= 8); j = j + 1)
      if(!((signed int)sp[(signed long int)j] >= (signed int)minscor))
        minscor = sp[(signed long int)j];

  }
  return minscor;
}

// scorePairsSimple
// file resultpairs.c line 828
static signed int scorePairsSimple(const struct _RESULT **ap, const struct _RESULT **bp, signed short int *mapqA, signed short int *mapqB, unsigned char *mapflg, signed int *nmax, struct _MATEPAIR *mpr, unsigned char pairflg, const struct _InsHist *ihistp, unsigned char rsltouflg, const struct _ResultSet *rsrp, const struct _ResultSet *rsmp)
{
  signed int errcode;
  signed int i;
  signed int n_pairs;
  double psum = MINLOGARG$link1;
  double marga = 0.0;
  double margb = 0.0;
  double maxprob = 0.0;
  struct _MATEPAIR *mp = (struct _MATEPAIR *)(void *)0;
  *bp = (const struct _RESULT *)(void *)0;
  *ap = *bp;
  *mapqB = (signed short int)0;
  *mapqA = *mapqB;
  *mapflg = (unsigned char)0;
  *nmax = 0;
  n_pairs = (signed int)((unsigned long int *)mpr)[(signed long int)-1];
  if(n_pairs == 0)
  {
    *ap=resultSetGetTopResult(mapflg, (unsigned char)(((signed int)rsltouflg & 8) != 0), rsrp);
    *bp=resultSetGetTopResult(mapflg, (unsigned char)(((signed int)rsltouflg & 8) != 0), rsmp);
    return 0;
  }

  else
  {
    errcode=assignProbabilityToPairs(mpr, &psum, &marga, &margb, pairflg, ihistp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      if(psum < MINLOGARG$link1)
        psum = MINLOGARG$link1;

      qsort((void *)mpr, (unsigned long int)n_pairs, sizeof(struct _MATEPAIR) /*48ul*/ , cmpMATEPAIRbyProbDescending);
      i = 1;
      for( ; !(i >= n_pairs); i = i + 1)
        if((mpr + (signed long int)i)->pbf + MINLOGARG$link1 < mpr->pbf)
          break;

      *nmax = i;
      mp = mpr;
      maxprob = mp->pbf / psum;
      if(maxprob <= 0.6 && n_pairs >= 2)
      {
        *mapflg = (unsigned char)(32 | 64);
        if(!((8 & (signed int)rsltouflg) == 0))
          mp=drawPairAtRandomByProbability(mpr);

        else
          if((2 & (signed int)rsltouflg) == 0)
            mp = mpr;

          else
            mp = (struct _MATEPAIR *)(void *)0;
      }

      if(mp == ((struct _MATEPAIR *)NULL))
        return 0;

      else
      {
        *ap = mp->ap;
        *bp = mp->bp;
        *mapflg = (unsigned char)((signed int)*mapflg | (signed int)mp->mapflg);
        i = 0;
        for( ; !(i >= n_pairs); i = i + 1)
        {
          if((mpr + (signed long int)i)->ap == mp->ap)
            marga = marga + (mpr + (signed long int)i)->pbf;

          if((mpr + (signed long int)i)->bp == mp->bp)
            margb = margb + (mpr + (signed long int)i)->pbf;

        }
        *mapqA=resultConvertProbabilityToMappingScore(marga / psum);
        *mapqB=resultConvertProbabilityToMappingScore(margb / psum);
        return 0;
      }
    }
  }
}

// scorePenaltiesCreate
// file score.h line 140
struct ScorePenalties_ * scorePenaltiesCreate(void)
{
  struct ScorePenalties_ *p;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct ScorePenalties_) /*4ul*/ , "score.c", 72);
  p = (struct ScorePenalties_ *)return_value_ecalloc$1;
  if(!(p == ((struct ScorePenalties_ *)NULL)))
  {
    p->penalty[(signed long int)0] = (signed char)1;
    p->penalty[(signed long int)1] = (signed char)-2;
    p->penalty[(signed long int)2] = (signed char)-4;
    p->penalty[(signed long int)3] = (signed char)-3;
  }

  else
  {
    scorePenaltiesDelete(p);
    p = (struct ScorePenalties_ *)(void *)0;
  }
  return p;
}

// scorePenaltiesDelete
// file score.h line 143
void scorePenaltiesDelete(struct ScorePenalties_ *p)
{
  free((void *)p);
}

// scorePrintMatrix
// file score.c line 345
signed int scorePrintMatrix(const struct _ScoreMatrix *amp, const struct _SeqCodec *scp)
{
  if(amp == ((const struct _ScoreMatrix *)NULL) || scp == ((const struct _SeqCodec *)NULL))
    return 15;

  else
  {
    fprintScoreMatrix(stdout, amp, scp);
    return 0;
  }
}

// scoreProfileGetAvgPenalties
// file score.h line 241
signed short int scoreProfileGetAvgPenalties(signed short int *mismatch_avg, signed short int *gap_init, signed short int *gap_ext, const struct _ScoreProfile *spp)
{
  if(!(mismatch_avg == ((signed short int *)NULL)))
    *mismatch_avg = (signed short int)spp->mismatch_avg;

  if(!(gap_init == ((signed short int *)NULL)))
    *gap_init = (signed short int)spp->gap_init;

  if(!(gap_ext == ((signed short int *)NULL)))
    *gap_ext = (signed short int)spp->gap_ext;

  return (signed short int)spp->match_avg;
}

// scoreRMAPCAND
// file rmap.c line 588
static signed int scoreRMAPCAND(struct RMAPCAND_ **csr, signed int *max1scor, signed int *max2scor, struct _SeqFastq *sqbufp, struct _AliBuffer *alibufp, unsigned short int rmapflag, unsigned char nskip, const struct _ScoreProfile *profp, const struct _ScoreProfile *profRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp, const struct _SegAliCands *sacp)
{
  signed int errcode = 0;
  struct RMAPCAND_ *hp;
  signed short int mismatchscor;
  signed short int gapinitscor;
  signed short int matchscor;
  matchscor=scoreProfileGetAvgPenalties(&mismatchscor, &gapinitscor, (signed short int *)(void *)0, profp);
  signed short int mmscordiff = (signed short int)((signed int)matchscor - (signed int)mismatchscor);
  unsigned int cover;
  unsigned int curr_min_cover;
  unsigned int max_cover;
  unsigned int min_cover;
  unsigned int dcov;
  unsigned int cdf;
  unsigned int cover_deficit[2l];
  unsigned int i;
  unsigned int qlen;
  unsigned int n_candseg;
  n_candseg=segAliCandsGetNumberOfSegments(sacp, &curr_min_cover, (unsigned int *)(void *)0, cover_deficit, cover_deficit + (signed long int)1, (unsigned int *)(void *)0);
  struct RMAPCAND_ *cp;
  unsigned char isSIMDAliCand;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(n_candseg >= 2147483648u || !((signed int)mmscordiff >= 1))
    return 47;

  else
  {
    if((unsigned long int)n_candseg >= ((unsigned long int *)*csr)[-2l])
    {
      void *return_value_arrayRealloc$1;
      return_value_arrayRealloc$1=arrayRealloc((void *)*csr, (unsigned long int)n_candseg, (char)0, "rmap.c", 640);
      hp = (struct RMAPCAND_ *)return_value_arrayRealloc$1;
      if(hp == ((struct RMAPCAND_ *)NULL))
        return 2;

      *csr = hp;
    }

    scoreGetProfile((signed short int *)(void *)0, &qlen, (signed char *)(void *)0, (signed char *)(void *)0, profp);
    if(qlen * (unsigned int)matchscor >= 2147483648u)
      return 48;

    else
    {
      *max1scor = 0;
      *max2scor = 0;
      min_cover = (unsigned int)0;
      max_cover = (unsigned int)0;
      cp = *csr;
      i = (unsigned int)0;
      for( ; !(i >= n_candseg); cp = cp + 1l)
      {
        const char *unprofiled_seqp = (const char *)(void *)0;
        unsigned int unprofiled_seqlen = (unsigned int)0;
        const struct _ScoreProfile *scprofp = (const struct _ScoreProfile *)(void *)0;
        errcode=makeRMAPCANDfromSegment(cp, sqbufp, &cover, qlen, ssp, codecp, i, sacp);
        if(!(errcode == 0))
          return errcode;

        if(!((1 & (signed int)cp->flags) == 0))
          scprofp = profRCp;

        else
          scprofp = profp;
        unprofiled_seqp=seqFastqGetConstSequence(sqbufp, &unprofiled_seqlen, (char *)(void *)0);
        if(unprofiled_seqlen >= 2147483648u)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (unsigned long int)unprofiled_seqlen != (cp->re - cp->rs) + (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return 47;

        if(qlen >= 32u)
          tmp_if_expr$3 = (unsigned int)(cp->band_r - cp->band_l) * (unsigned int)48 > qlen ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = cp->qs == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = cp->qe >= qlen - (unsigned int)1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        isSIMDAliCand = (unsigned char)tmp_if_expr$5;
        if(!(isSIMDAliCand == 0))
          errcode=swSIMDAlignStriped(&cp->swscor, alibufp, scprofp, unprofiled_seqp, (signed int)unprofiled_seqlen);

        if(errcode == 41 || isSIMDAliCand == 0)
        {
          if(cp->qs >= 2147483648u)
            return 47;

          errcode=aliSmiWatInBandFast(&cp->swscor, alibufp, scprofp, unprofiled_seqp, (signed int)unprofiled_seqlen, cp->band_l, cp->band_r, (signed int)cp->qs, (signed int)cp->qe, 0, (signed int)unprofiled_seqlen - 1);
        }

        if(!(errcode == 0))
          return errcode;

        cp->flags = cp->flags | (unsigned short int)2;
        cdf = cover_deficit[(signed long int)(((signed int)cp->flags & 1) != 0 ? 1 : 0)];
        if(!((2 & (signed int)rmapflag) == 0) && !(cdf + cover >= min_cover))
          break;

        if(!(*max2scor >= cp->swscor))
        {
          if(!(*max1scor >= cp->swscor))
          {
            *max2scor = *max1scor;
            *max1scor = cp->swscor;
            if(!(max_cover >= cdf + cover))
              max_cover = cover > cdf ? cover - cdf : (unsigned int)0;

          }

          else
            *max2scor = cp->swscor;
          dcov = (unsigned int)(((signed int)((*max1scor - *max2scor) / (signed int)mmscordiff) + 1) * (signed int)nskip);
          if(!(cdf + dcov + min_cover >= max_cover))
            min_cover = max_cover - dcov;

        }

        i = i + 1u;
      }
      ((unsigned long int *)*csr)[(signed long int)-1] = (unsigned long int)i;
      return 0;
    }
  }
}

// scoreSetPenalty
// file score.h line 146
signed int scoreSetPenalty(struct ScorePenalties_ *p, signed short int typ, signed short int penalty)
{
  signed int errcode = 0;
  if((signed int)typ >= 0 && !((signed int)typ >= 4))
  {
    signed char pnlty_min;
    signed char pnlty_max;
    if((signed int)typ == 0)
    {
      pnlty_min = (signed char)0;
      pnlty_max = (signed char)127;
    }

    else
    {
      pnlty_min = (signed char)(-1 * 127);
      pnlty_max = (signed char)0;
    }
    if((signed int)penalty >= (signed int)pnlty_min && (signed int)pnlty_max >= (signed int)penalty)
      p->penalty[(signed long int)typ] = (signed char)penalty;

    else
      errcode = 41;
  }

  else
    errcode = 41;
  return errcode;
}

// scrollDIFFSTRStartEnd
// file diffstr.c line 413
static signed int scrollDIFFSTRStartEnd(signed int *start_unprof, signed int *end_unprof, signed int *start_prof, signed int *end_prof, unsigned char *count_start, unsigned char *count_end, unsigned char *typ_start, signed int *idx_start, signed int *idx_end, signed int start_unprof_target, signed int end_unprof_target, const unsigned char *diffstrp)
{
  signed int i;
  signed int idx_last;
  signed int shift = 0;
  signed int shift_last = 0;
  signed int pos = 0;
  signed int pos_last;
  unsigned char count = (unsigned char)0;
  unsigned char count_add = (unsigned char)0;
  unsigned char typ = (unsigned char)0;
  i = 0;
  for( ; !((signed int)diffstrp[(signed long int)i] == 0) && !(i >= 0x7fffffff); i = i + 1)
  {
    typ = (unsigned char)((signed int)diffstrp[(signed long int)i] >> 6);
    count = (unsigned char)((signed int)diffstrp[(signed long int)i] & 63);
    shift_last = shift;
    if((signed int)typ == 0)
    {
      count = count + 1;
      count_add = (unsigned char)0;
    }

    else
      if((signed int)typ == 3)
        count_add = (unsigned char)1;

      else
        if((signed int)typ == 2)
        {
          shift = shift + 1;
          count_add = (unsigned char)0;
        }

        else
        {
          count_add = (unsigned char)1;
          shift = shift - 1;
        }
    pos = pos + (signed int)count;
    if((signed int)count >= 1 && !(start_unprof_target >= pos))
      break;

    pos = pos + (signed int)count_add;
  }
  if(i >= 0x7fffffff)
    return 59;

  else
    if((signed int)diffstrp[(signed long int)i] == 0)
      return -1;

    else
    {
      idx_last = i;
      *count_start = (unsigned char)(pos - start_unprof_target);
      if(!((signed int)count >= (signed int)*count_start))
        *count_start = count;

      *start_unprof = pos - (signed int)*count_start;
      *start_prof = *start_unprof + shift_last;
      pos_last = pos;
      pos = pos + (signed int)count_add;
      *idx_start = i;
      *typ_start = typ;
      if(!(end_unprof_target >= *start_unprof))
        return 75;

      else
        if(end_unprof_target >= pos)
        {
          i = i + 1;
          for( ; !((signed int)diffstrp[(signed long int)i] == 0) && !(i >= 0x7fffffff); i = i + 1)
          {
            typ = (unsigned char)((signed int)diffstrp[(signed long int)i] >> 6);
            count = (unsigned char)((signed int)diffstrp[(signed long int)i] & 63);
            if((signed int)count >= 1)
              shift_last = shift;

            if((signed int)typ == 0)
            {
              count = count + 1;
              count_add = (unsigned char)0;
            }

            else
              if((signed int)typ == 3)
                count_add = (unsigned char)1;

              else
                if((signed int)typ == 2)
                {
                  count_add = (unsigned char)0;
                  shift = shift + 1;
                }

                else
                {
                  count_add = (unsigned char)1;
                  shift = shift - 1;
                }
            pos = pos + (signed int)count;
            if((signed int)count >= 1)
            {
              pos_last = pos;
              idx_last = i;
            }

            pos = pos + (signed int)count_add;
            if(!(end_unprof_target >= pos))
              break;

          }
          if((signed int)diffstrp[(signed long int)i] == 0)
          {
            i = i - 1;
            goto __CPROVER_DUMP_L20;
          }

          if(!(i >= 0x7fffffff))
            goto __CPROVER_DUMP_L20;

          return 48;
        }

        else
        {

        __CPROVER_DUMP_L20:
          ;
          if(!(end_unprof_target >= pos_last))
          {
            *count_end = (unsigned char)((pos_last - end_unprof_target) - 1);
            if(!((signed int)count >= (signed int)*count_end))
              return 47;

            *count_end = (unsigned char)((signed int)count - (signed int)*count_end);
            *end_unprof = end_unprof_target;
            *idx_end = i;
          }

          else
          {
            typ = (unsigned char)((signed int)diffstrp[(signed long int)idx_last] >> 6);
            count = (unsigned char)((signed int)diffstrp[(signed long int)idx_last] & 63);
            if((signed int)typ == 0)
              count = count + 1;

            *count_end = count;
            *end_unprof = pos_last - 1;
            *idx_end = idx_last;
          }
          *end_prof = *end_unprof + shift_last;
          return 0;
        }
    }
}

// scrollDiffStr
// file diffstr.c line 369
static signed int scrollDiffStr(unsigned char *dfsp, signed int pos_uprof_target, unsigned char isEnd, signed int *pos_uprof, signed int *pos_prof, signed int *dfs_offs)
{
  signed int i;
  signed int ie;
  unsigned char count;
  unsigned char typ;
  signed int count_uprof;
  signed int count_prof;
  signed int count_uprof_lastmatch;
  signed int count_prof_lastmatch;
  count_prof = 0;
  count_uprof = count_prof;
  count_prof_lastmatch = 0;
  count_uprof_lastmatch = count_prof_lastmatch;
  ie = 0;
  i = 0;
  for( ; !(dfsp[(signed long int)i] == 0); i = i + 1)
  {
    typ = (unsigned char)((signed int)dfsp[(signed long int)i] >> 6);
    count = (unsigned char)((signed int)dfsp[(signed long int)i] & 63);
    if((signed int)typ == 0 || (signed int)typ == 3)
    {
      count_prof = count_prof + (signed int)count + 1;
      count_uprof = count_uprof + (signed int)count + 1;
    }

    else
      if((signed int)typ == 2)
      {
        count_prof = count_prof + (signed int)count + 1;
        count_uprof = count_uprof + (signed int)count;
      }

      else
      {
        count_prof = count_prof + (signed int)count;
        count_uprof = count_uprof + (signed int)count + 1;
      }
    if((signed int)typ == 3)
    {
      if(dfsp[(signed long int)(1 + i)] == 0)
      {
        count_uprof = count_uprof - 1;
        count_prof = count_prof - 1;
      }

    }

    if((signed int)count >= 1)
    {
      count_uprof_lastmatch = count_uprof;
      count_prof_lastmatch = count_prof;
      ie = i;
    }

    if(!(isEnd == 0) && !(pos_uprof_target >= count_uprof))
      break;

    if(!(pos_uprof_target >= count_uprof_lastmatch))
      break;

  }
  if(!(dfs_offs == ((signed int *)NULL)))
    *dfs_offs = ie;

  if(!(pos_prof == ((signed int *)NULL)))
    *pos_prof = count_prof_lastmatch;

  if(!(pos_uprof == ((signed int *)NULL)))
    *pos_uprof = count_uprof_lastmatch;

  return count_uprof < pos_uprof_target ? 59 : 0;
}

// scrollToHeaderLine
// file sequence.c line 192
static signed int scrollToHeaderLine(struct gzFile_s *fp, signed int *prompt, char *bufp)
{
  char *cp = bufp;
  *prompt = 0;
  _Bool tmp_if_expr$2;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*cp]) == 0))
    {
      cp = cp + 1l;
      goto __CPROVER_DUMP_L1;
    }

    if((signed int)*cp == 62)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*cp == 64 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      *prompt = (signed int)*cp;
      return 0;
    }

    cp=gzgets(fp, bufp, 1024);
  }
  while(!(cp == ((char *)NULL)));
  signed int return_value_gzeof$3;
  return_value_gzeof$3=gzeof(fp);
  return return_value_gzeof$3 != 0 ? 10 : 14;
}

// segAliCandsAdd
// file segment.c line 1559
signed int segAliCandsAdd(struct _SegAliCands *sacp, const struct _SegLst *sglp)
{
  signed int errcode = 0;
  unsigned int r;
  unsigned int nreg;
  unsigned int i;
  unsigned int i_end;
  unsigned int j;
  struct _HITREGION *hrp;
  unsigned int mincover_noindel;
  mincover_noindel=calcIndelFreeMincover(sglp->qlen, sglp->ktup, sglp->nskip);
  errcode=transferParamFromSegLst(sacp, sglp);
  if(!(errcode == 0))
    return errcode;

  else
  {
    nreg = (unsigned int)((unsigned long int *)sglp->hregr)[(signed long int)-1];
    r = (unsigned int)0;
    for( ; !(r >= nreg); r = r + 1u)
    {
      hrp = sglp->hregr + (signed long int)r;
      if(!(sacp->n_alloc >= (unsigned int)hrp->num))
      {
        errcode=reallocSortArrays(sacp, (unsigned int)hrp->num);
        if(!(errcode == 0))
          return errcode;

      }

      i_end = hrp->idx + (unsigned int)hrp->num;
      j = (unsigned int)0;
      i = hrp->idx;
      for( ; !(i >= i_end); j = j + 1u)
      {
        sacp->sort_keys[(signed long int)j] = (sglp->segmr + (signed long int)i)->cover;
        sacp->sort_idx[(signed long int)j] = i;
        i = i + 1u;
      }
      sacp->n_sort = j;
      errcode=sort2UINTarraysByQuickSort((signed int)sacp->n_sort, sacp->sort_keys, sacp->sort_idx);
      if(!(errcode == 0))
        return errcode;

      errcode=addCandsFromSortedSegments(&sacp->candr, sglp->segmr, sacp->n_sort, sacp->sort_idx, sglp->seedr, sglp->hregr, r, mincover_noindel, sglp->ktup, sglp->nskip, (char)((signed int)sglp->flags & 1));
      if(!(errcode == 0))
        return errcode;

    }
    return errcode;
  }
}

// segAliCandsAddFast
// file segment.c line 1530
signed int segAliCandsAddFast(struct _SegAliCands *sacp, struct _SegQMask *qmp, const struct _SegLst *sglp, unsigned int mincover, signed int seqidx)
{
  signed int errcode = 0;
  if((unsigned long int)sglp->qlen >= qmp->n_alloc)
  {
    errcode=reallocQMask(qmp, sglp->qlen + (unsigned int)1);
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    errcode=transferParamFromSegLst(sacp, sglp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      errcode=addCandsFast(&sacp->candr, &sacp->max_cover, &sacp->max2nd_cover, sglp->segmr, sglp->seedr, sglp->hregr, qmp->maskp, sglp->qlen, sglp->ktup, sglp->nskip, (unsigned char)((signed int)sglp->flags & 1), mincover, mincover, seqidx);
      return errcode;
    }
  }
}

// segAliCandsAddNoIndel
// file segment.c line 1599
signed int segAliCandsAddNoIndel(struct _SegAliCands *sacp, const struct _SegLst *sglp)
{
  signed int errcode = 0;
  unsigned int mincover;
  mincover=calcIndelFreeMincover(sglp->qlen, sglp->ktup, sglp->nskip);
  if(sglp->maxcover >= mincover)
  {
    errcode=transferParamFromSegLst(sacp, sglp);
    if(errcode == 0)
      errcode=addNoIndelCandsFromSegmentSeeds(&sacp->candr, &sacp->max_cover, sglp->segmr, sglp->seedr, sglp->hregr, mincover, sglp->ktup, sglp->nskip, (char)((signed int)sglp->flags & 1));

  }

  return errcode;
}

// segAliCandsBlank
// file segment.h line 156
void segAliCandsBlank(struct _SegAliCands *sacp)
{
  if(!(sacp == ((struct _SegAliCands *)NULL)))
  {
    ((unsigned long int *)sacp->candr)[(signed long int)-1] = (unsigned long int)0;
    sacp->n_sort = (unsigned int)0;
    sacp->max_cover = (unsigned int)0;
    sacp->max2nd_cover = (unsigned int)0;
    sacp->n_mincover = (unsigned int)0;
    sacp->nskip = (unsigned char)0;
    sacp->ktup = (unsigned char)0;
    sacp->cover_deficit[(signed long int)0] = (unsigned int)0;
    sacp->cover_deficit[(signed long int)1] = (unsigned int)0;
  }

}

// segAliCandsCalcSegmentOffsets
// file segment.h line 265
signed int segAliCandsCalcSegmentOffsets(unsigned int *qs, unsigned int *qe, unsigned long int *rs, unsigned long int *re, signed int *band_l, signed int *band_r, unsigned int *qs_directmatch, signed int *ro_directmatch, signed long int *seqidx, unsigned char *bitflags, unsigned int *cover, signed short int edgelen, unsigned int qlen, const struct _SeqSet *ssp, unsigned int scidx, const struct _SegAliCands *sacp)
{
  signed int bl;
  signed int br;
  signed int nseq;
  signed int band_offs;
  signed int ds;
  signed int q_edge_l;
  signed int q_edge_r;
  signed int r_edge_l;
  signed int r_edge_r;
  signed int edge_band;
  unsigned char nskip = sacp->nskip;
  unsigned char ktup = sacp->ktup;
  const unsigned long int *soffsp;
  unsigned long int roffs;
  unsigned long int rlen;
  const struct _SEGCAND *scandp;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(scidx >= sacp->n_sort)
    return -1;

  else
  {
    scandp = sacp->candr + (signed long int)sacp->sort_idx[(signed long int)scidx];
    *seqidx = (signed long int)scandp->seqidx;
    *bitflags = scandp->flag;
    *cover = scandp->cover;
    signed long int return_value_seqSetGetOffsets$1;
    return_value_seqSetGetOffsets$1=seqSetGetOffsets(ssp, &soffsp);
    nseq = (signed int)return_value_seqSetGetOffsets$1;
    if(!(scandp->seqidx >= 0))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = scandp->seqidx >= nseq ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      roffs = (unsigned long int)0;
      rlen = soffsp[(signed long int)nseq];
    }

    else
    {
      unsigned int return_value_seqSetGetSeqDatByIndex$2;
      return_value_seqSetGetSeqDatByIndex$2=seqSetGetSeqDatByIndex(&roffs, (const char **)(void *)0, (signed long int)scandp->seqidx, ssp);
      rlen = (unsigned long int)return_value_seqSetGetSeqDatByIndex$2;
    }
    *rs = (unsigned long int)scandp->rs * (unsigned long int)nskip;
    *re = ((unsigned long int)scandp->re * (unsigned long int)nskip + (unsigned long int)ktup) - (unsigned long int)1;
    if(!(*rs >= roffs))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = *re < *rs ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      return 47;

    else
    {
      *rs = *rs - roffs;
      *re = *re - roffs;
      if(*re >= rlen)
        return 47;

      else
      {
        if(!(scandp->qe >= scandp->qs))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = scandp->qs >= qlen ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          return 47;

        else
        {
          if(!((1 & (signed int)scandp->flag) == 0))
          {
            *qs = (qlen - scandp->qe) - (unsigned int)1;
            *qe = (qlen - scandp->qs) - (unsigned int)1;
          }

          else
          {
            *qs = scandp->qs;
            *qe = scandp->qe;
          }
          edge_band = (signed int)(qlen - scandp->cover) / 4;
          if(!((signed int)nskip >= edge_band))
          {
            if(!((signed int)(qlen >> 4) >= edge_band))
              edge_band = (signed int)(qlen >> 4);

            edge_band = edge_band - ((signed int)nskip - 1);
          }

          else
            edge_band = 0;
          br = (-((signed int)scandp->shiftoffs) + 1) * (signed int)nskip + edge_band + 1;
          bl = ((br - ((signed int)scandp->srange + 2) * (signed int)nskip) - 2 * edge_band) - 2;
          if(*qs >= (unsigned int)edgelen && (signed int)edgelen >= 1)
            tmp_if_expr$6 = (signed int)edgelen;

          else
            tmp_if_expr$6 = (signed int)*qs;
          q_edge_l = tmp_if_expr$6;
          if(qlen >= 1u + *qe + (unsigned int)edgelen && (signed int)edgelen >= 1)
            tmp_if_expr$7 = (signed int)edgelen;

          else
            tmp_if_expr$7 = (signed int)((qlen - *qe) - (unsigned int)1);
          q_edge_r = tmp_if_expr$7;
          *qs = *qs - (unsigned int)q_edge_l;
          *qe = *qe + (unsigned int)q_edge_r;
          r_edge_l = q_edge_l + br;
          r_edge_r = q_edge_r - bl;
          if(r_edge_l >= 1)
            tmp_if_expr$8 = *rs < (unsigned long int)r_edge_l ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$8 = (_Bool)0;
          if(tmp_if_expr$8)
          {
            r_edge_l = (signed int)*rs;
            *rs = (unsigned long int)0;
          }

          else
            *rs = *rs - (unsigned long int)r_edge_l;
          if(*re + (unsigned long int)r_edge_r >= rlen)
          {
            r_edge_r = (signed int)((rlen - *re) - (unsigned long int)1);
            *re = rlen - (unsigned long int)1;
          }

          else
            *re = *re + (unsigned long int)r_edge_r;
          if(!(*re >= *rs))
            return 47;

          else
          {
            band_offs = q_edge_l - r_edge_l;
            ds = (signed int)scandp->shift2mm * (signed int)nskip + band_offs;
            *band_l = (signed int)((unsigned int)(bl + band_offs) + *qs);
            *band_r = (signed int)((unsigned int)(br + band_offs) + *qs);
            if(!(ds >= 0))
            {
              *qs_directmatch = *qs - (unsigned int)ds;
              *ro_directmatch = 0;
            }

            else
            {
              *qs_directmatch = *qs;
              *ro_directmatch = ds;
            }
            return 0;
          }
        }
      }
    }
  }
}

// segAliCandsCreate
// file segment.h line 150
struct _SegAliCands * segAliCandsCreate(signed int blocksiz)
{
  struct _SegAliCands *sacp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SegAliCands) /*64ul*/ , "segment.c", 1478);
  sacp = (struct _SegAliCands *)return_value_ecalloc$1;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(sacp == ((struct _SegAliCands *)NULL))
    return ((struct _SegAliCands *)NULL);

  else
  {
    if(!(blocksiz >= 1))
      blocksiz = 65536;

    void *return_value_arrayCreate$2;
    return_value_arrayCreate$2=arrayCreate(sizeof(struct _SEGCAND) /*48ul*/ , (unsigned long int)blocksiz, "segment.c", 1484);
    sacp->candr = (struct _SEGCAND *)return_value_arrayCreate$2;
    void *return_value_ecalloc$3;
    return_value_ecalloc$3=ecalloc((unsigned long int)blocksiz, sizeof(unsigned int) /*4ul*/ , "segment.c", 1485);
    sacp->sort_keys = (unsigned int *)return_value_ecalloc$3;
    void *return_value_ecalloc$4;
    return_value_ecalloc$4=ecalloc((unsigned long int)blocksiz, sizeof(unsigned int) /*4ul*/ , "segment.c", 1486);
    sacp->sort_idx = (unsigned int *)return_value_ecalloc$4;
    if(!(sacp->candr == ((struct _SEGCAND *)NULL)))
      tmp_if_expr$5 = sacp->sort_keys != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = sacp->sort_idx != ((unsigned int *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      sacp->alloc_blksz = (unsigned int)blocksiz;
      sacp->n_alloc = sacp->alloc_blksz;
      sacp->max_cover = (unsigned int)0;
      sacp->max2nd_cover = (unsigned int)0;
      sacp->n_sort = (unsigned int)0;
      sacp->nskip = (unsigned char)0;
      sacp->ktup = (unsigned char)0;
      sacp->cover_deficit[(signed long int)0] = (unsigned int)0;
      sacp->cover_deficit[(signed long int)1] = (unsigned int)0;
    }

    else
    {
      segAliCandsDelete(sacp);
      sacp = ((struct _SegAliCands *)NULL);
    }
    return sacp;
  }
}

// segAliCandsDelete
// file segment.h line 153
void segAliCandsDelete(struct _SegAliCands *sacp)
{
  if(!(sacp == ((struct _SegAliCands *)NULL)))
  {
    free((void *)((unsigned long int *)sacp->candr - (signed long int)4));
    sacp->candr = (struct _SEGCAND *)(void *)0;
    free((void *)sacp->sort_keys);
    free((void *)sacp->sort_idx);
  }

  free((void *)sacp);
}

// segAliCandsGetNumberOfSegments
// file segment.h line 233
unsigned int segAliCandsGetNumberOfSegments(const struct _SegAliCands *sacp, unsigned int *max_cover, unsigned int *max2nd_cover, unsigned int *cover_deficitF, unsigned int *cover_deficitR, unsigned int *n_mincover)
{
  if(!(max_cover == ((unsigned int *)NULL)))
    *max_cover = sacp->max_cover;

  if(!(max2nd_cover == ((unsigned int *)NULL)))
    *max2nd_cover = sacp->max2nd_cover;

  if(!(cover_deficitF == ((unsigned int *)NULL)))
    *cover_deficitF = sacp->cover_deficit[(signed long int)0];

  if(!(cover_deficitR == ((unsigned int *)NULL)))
    *cover_deficitR = sacp->cover_deficit[(signed long int)1];

  if(!(n_mincover == ((unsigned int *)NULL)))
    *n_mincover = sacp->n_mincover;

  return sacp->n_sort;
}

// segAliCandsGetSegment
// file segment.c line 1787
const struct _SEGCAND * segAliCandsGetSegment(const struct _SegAliCands *sacp, unsigned int idx)
{
  struct _SEGCAND *tmp_if_expr$1;
  if(!(idx >= sacp->n_sort))
    tmp_if_expr$1 = sacp->candr + (signed long int)sacp->sort_idx[(signed long int)idx];

  else
    tmp_if_expr$1 = ((struct _SEGCAND *)NULL);
  return tmp_if_expr$1;
}

// segAliCandsGetSegmentData
// file segment.c line 1844
signed int segAliCandsGetSegmentData(unsigned int *qs, unsigned int *qe, unsigned int *rs, unsigned int *re, unsigned int scidx, const struct _SegAliCands *sacp)
{
  const struct _SEGCAND *scp;
  if((unsigned long int)scidx >= ((unsigned long int *)sacp->candr)[-1l])
    return 47;

  else
  {
    scp = sacp->candr + (signed long int)scidx;
    if(!(qs == ((unsigned int *)NULL)))
      *qs = scp->qs;

    if(!(qe == ((unsigned int *)NULL)))
      *qe = scp->qe;

    if(!(rs == ((unsigned int *)NULL)))
      *rs = scp->rs;

    if(!(re == ((unsigned int *)NULL)))
      *re = scp->re;

    return 0;
  }
}

// segAliCandsPrint
// file segment.c line 1792
void segAliCandsPrint(struct _IO_FILE *fp, unsigned int max_depth, const struct _SegAliCands *sacp)
{
  signed short int i;
  signed short int n_cand;
  unsigned int tmp_if_expr$1;
  if(!(max_depth >= sacp->n_sort))
    tmp_if_expr$1 = max_depth;

  else
    tmp_if_expr$1 = sacp->n_sort;
  n_cand = (signed short int)tmp_if_expr$1;
  printf("======= List of %hi candidate segments =======\n", n_cand);
  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)n_cand); i = i + 1)
  {
    fprintf(fp, "[%hi] %u: ", i, sacp->sort_idx[(signed long int)i]);
    printSEGCAND(fp, sacp->candr + (signed long int)sacp->sort_idx[(signed long int)i]);
  }
  printf("========= End of candidate segments ==========\n");
}

// segAliCandsPrintRaw
// file segment.c line 1805
void segAliCandsPrintRaw(struct _IO_FILE *fp, signed short int max_depth, const struct _SegAliCands *sacp)
{
  signed int n_cand = (signed int)((unsigned long int *)sacp->candr)[(signed long int)-1];
  signed short int i;
  signed short int i_end = (signed short int)((signed int)max_depth < n_cand ? (signed int)max_depth : n_cand);
  printf("======= List of %4i raw candidate segments =======\n", n_cand);
  i = (signed short int)0;
  for( ; !((signed int)i >= (signed int)i_end); i = i + 1)
  {
    fprintf(fp, "[%hi]", i);
    printSEGCAND(fp, sacp->candr + (signed long int)i);
  }
  printf("========== End of raw candidate segments ==========\n");
}

// segAliCandsPrintSegment
// file segment.c line 1832
signed int segAliCandsPrintSegment(struct _IO_FILE *fp, unsigned int scidx, const struct _SegAliCands *sacp)
{
  signed int errcode = 0;
  if(!(scidx >= sacp->n_sort))
  {
    const struct _SEGCAND *scp = sacp->candr + (signed long int)sacp->sort_idx[(signed long int)scidx];
    printSEGCAND(fp, scp);
  }

  else
    errcode = 47;
  return errcode;
}

// segAliCandsStats
// file segment.h line 189
signed int segAliCandsStats(struct _SegAliCands *sacp, unsigned int min_cover_below_max, const struct _HashHitInfo *hhiFp, const struct _HashHitInfo *hhiRp, unsigned int target_depth, unsigned int max_depth, unsigned char is_sensitive)
{
  signed int errcode;
  unsigned int i;
  unsigned int j;
  unsigned int n_cands = (unsigned int)((unsigned long int *)sacp->candr)[(signed long int)-1];
  unsigned char is_rev;
  unsigned char nskip = sacp->nskip;
  unsigned int min_cover;
  unsigned int cdf = (unsigned int)0;
  unsigned int cover_deficit_adjusted[2l];
  struct _SEGCAND *scp;
  if(max_depth >= 8001u || !(max_depth >= 1u))
    max_depth = (unsigned int)8000;

  if(!(target_depth >= 1u))
    target_depth = (unsigned int)200;

  if(!(max_depth >= target_depth))
    target_depth = max_depth;

  unsigned int tmp_if_expr$1;
  if(!(sacp->max_cover >= min_cover_below_max))
    tmp_if_expr$1 = (unsigned int)0;

  else
    tmp_if_expr$1 = sacp->max_cover - min_cover_below_max;
  min_cover = tmp_if_expr$1;
  if(!(sacp->max2nd_cover >= min_cover))
  {
    cdf = min_cover - sacp->max2nd_cover;
    min_cover = sacp->max2nd_cover;
  }

  sacp->cover_deficit[(signed long int)0]=hashCalcHitInfoCoverDeficit(hhiFp);
  sacp->cover_deficit[(signed long int)1]=hashCalcHitInfoCoverDeficit(hhiRp);
  i = (unsigned int)0;
  for( ; !(i >= 2u); i = i + 1u)
  {
    cover_deficit_adjusted[(signed long int)i] = sacp->cover_deficit[(signed long int)0];
    if(!(cdf >= cover_deficit_adjusted[(signed long int)i]))
      cover_deficit_adjusted[(signed long int)i] = cover_deficit_adjusted[(signed long int)i] - cdf;

    else
      cover_deficit_adjusted[(signed long int)i] = (unsigned int)0;
  }
  scp = sacp->candr;
  j = (unsigned int)0;
  i = j;
  for( ; !(i >= n_cands); i = i + 1u)
  {
    is_rev = (unsigned char)(((signed int)(scp + (signed long int)i)->flag & 1) != 0 ? 1 : 0);
    if(cover_deficit_adjusted[(signed long int)is_rev] + (scp + (signed long int)i)->cover >= min_cover)
    {
      if(j >= sacp->n_alloc)
      {
        errcode=reallocSortArrays(sacp, j + (unsigned int)1);
        if(!(errcode == 0))
          return errcode;

      }

      if(!(sacp->max_cover >= (scp + (signed long int)i)->cover))
        return 47;

      sacp->sort_keys[(signed long int)j] = sacp->max_cover - (scp + (signed long int)i)->cover;
      sacp->sort_idx[(signed long int)j] = i;
      j = j + 1u;
    }

  }
  errcode=sort2UINTarraysByQuickSort((signed int)j, sacp->sort_keys, sacp->sort_idx);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(errcode == 0))
    return errcode;

  else
  {
    sacp->n_mincover = j;
    if(!(target_depth >= j))
    {
      unsigned int maxj = j < max_depth ? j : max_depth;
      if(!(is_sensitive == 0))
      {
        j = target_depth;
        for( ; !(j >= maxj); j = j + 1u)
        {
          is_rev = (unsigned char)(((signed int)(scp + (signed long int)j)->flag & 1) != 0 ? 1 : 0);
          if(sacp->sort_keys[(signed long int)j] >= cover_deficit_adjusted[(signed long int)((1 & (signed int)(scp + (signed long int)j)->flag) == 0 ? 0 : 1)])
            break;

        }
        do
        {
          if(!(j >= sacp->n_mincover))
            tmp_if_expr$2 = sacp->sort_keys[(signed long int)j] < (unsigned int)nskip ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(!tmp_if_expr$2)
            break;

          j = j + 1u;
        }
        while((_Bool)1);
      }

      else
      {
        unsigned int cov = sacp->sort_keys[(signed long int)(j / (unsigned int)2)];
        if(!(cov >= (unsigned int)nskip))
          cov = (unsigned int)nskip;

        j = target_depth;
        do
        {
          if(!(j >= maxj))
            tmp_if_expr$3 = sacp->sort_keys[(signed long int)j] < cov ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          j = j + 1u;
        }
        while((_Bool)1);
      }
    }

    sacp->n_sort = j;
    return 0;
  }
}

// segLstAddHits
// file segment.c line 812
signed int segLstAddHits(struct _SegLst *sglp, unsigned int min_ktup, const struct _HashHitList *hhlp)
{
  signed int errcode;
  signed int nreg;
  char is_reverse;
  const char *qmask;
  unsigned long int reg_start;
  segLstBlank(sglp);
  hashGetHitListData((signed int *)(void *)0, &is_reverse, &sglp->qlen, &sglp->ktup, &sglp->nskip, &qmask, hhlp);
  sglp->flags = (unsigned char)(is_reverse != 0 ? 1 : 0);
  for( ; !(*qmask == 0); qmask = qmask + 1l)
    if(!((signed int)*qmask == 1))
    {
      if(!(min_ktup >= 2u))
        break;

      min_ktup = min_ktup - 1u;
    }

  reg_start = ((unsigned long int *)sglp->hregr)[(signed long int)-1];
  if(reg_start >= 2147483648ul)
    return 48;

  else
  {
    errcode=defineHitRegions(&sglp->hregr, &nreg, &sglp->dshift_cutoff, min_ktup, hhlp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      sglp->flags = sglp->flags | (unsigned char)2;
      errcode=makeSeedsFromHits(&sglp->seedr, sglp->hregr, (signed int)reg_start, nreg, hhlp);
      if(!(errcode == 0))
        return errcode;

      else
      {
        sglp->flags = sglp->flags | (unsigned char)4;
        errcode=makeSegmentsFromSeeds(&sglp->segmr, &sglp->maxcover, sglp->hregr, (unsigned int)(signed int)reg_start, (unsigned int)nreg, sglp->seedr, sglp->nskip);
        if(errcode == 0)
          sglp->flags = sglp->flags | (unsigned char)8;

        return errcode;
      }
    }
  }
}

// segLstBlank
// file segment.c line 752
void segLstBlank(struct _SegLst *sp)
{
  ((unsigned long int *)sp->seedr)[(signed long int)-1] = (unsigned long int)0;
  ((unsigned long int *)sp->segmr)[(signed long int)-1] = (unsigned long int)0;
  ((unsigned long int *)sp->hregr)[(signed long int)-1] = (unsigned long int)0;
  sp->dshift_cutoff = (unsigned short int)0;
  sp->ktup = (unsigned char)0;
  sp->nskip = sp->ktup;
  sp->flags = (unsigned char)0;
  sp->maxcover = (unsigned int)0;
}

// segLstCreate
// file segment.c line 721
struct _SegLst * segLstCreate(signed int blocksiz)
{
  struct _SegLst *sp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SegLst) /*40ul*/ , "segment.c", 725);
  sp = (struct _SegLst *)return_value_ecalloc$1;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(sp == ((struct _SegLst *)NULL))
    return ((struct _SegLst *)NULL);

  else
  {
    if(!(blocksiz >= 65536))
      blocksiz = 65536;

    void *return_value_arrayCreate$2;
    return_value_arrayCreate$2=arrayCreate(sizeof(struct _SEED$0) /*16ul*/ , (unsigned long int)blocksiz, "segment.c", 730);
    sp->seedr = (struct _SEED$0 *)return_value_arrayCreate$2;
    void *return_value_arrayCreate$3;
    return_value_arrayCreate$3=arrayCreate(sizeof(struct _SEGMENT) /*12ul*/ , (unsigned long int)blocksiz, "segment.c", 731);
    sp->segmr = (struct _SEGMENT *)return_value_arrayCreate$3;
    void *return_value_arrayCreate$4;
    return_value_arrayCreate$4=arrayCreate(sizeof(struct _HITREGION) /*8ul*/ , (unsigned long int)(blocksiz / 2), "segment.c", 732);
    sp->hregr = (struct _HITREGION *)return_value_arrayCreate$4;
    if(!(sp->hregr == ((struct _HITREGION *)NULL)))
      tmp_if_expr$5 = sp->seedr != ((struct _SEED$0 *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = sp->segmr != ((struct _SEGMENT *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(!tmp_if_expr$6)
    {
      segLstDelete(sp);
      sp = ((struct _SegLst *)NULL);
    }

    return sp;
  }
}

// segLstDelete
// file segment.c line 742
void segLstDelete(struct _SegLst *sp)
{
  if(!(sp == ((struct _SegLst *)NULL)))
  {
    free((void *)((unsigned long int *)sp->hregr - (signed long int)4));
    sp->hregr = (struct _HITREGION *)(void *)0;
    free((void *)((unsigned long int *)sp->segmr - (signed long int)4));
    sp->segmr = (struct _SEGMENT *)(void *)0;
    free((void *)((unsigned long int *)sp->seedr - (signed long int)4));
    sp->seedr = (struct _SEED$0 *)(void *)0;
  }

  free((void *)sp);
}

// segLstFetchSeed
// file segment.c line 875
signed int segLstFetchSeed(unsigned int *q_offs, unsigned int *s_offs, unsigned int idx, const struct _SegLst *sp)
{
  struct _SEED$0 *seedp;
  if((unsigned long int)idx >= ((unsigned long int *)sp->seedr)[-1l])
  {
    if(!(q_offs == ((unsigned int *)NULL)))
      *q_offs = (unsigned int)0;

    if(!(s_offs == ((unsigned int *)NULL)))
      *s_offs = (unsigned int)0;

    return 0;
  }

  else
  {
    seedp = sp->seedr + (signed long int)idx;
    if(!(q_offs == ((unsigned int *)NULL)))
      *q_offs = (unsigned int)(seedp->sqo & (unsigned long int)2147483647);

    if(!(s_offs == ((unsigned int *)NULL)))
    {
      if(!((1 & (signed int)sp->flags) == 0))
        *s_offs = (unsigned int)((seedp->sqo >> 31) - (seedp->sqo & (unsigned long int)2147483647) / (unsigned long int)sp->nskip);

      else
        *s_offs = (unsigned int)((seedp->sqo >> 31) + (seedp->sqo & (unsigned long int)2147483647) / (unsigned long int)sp->nskip & (unsigned long int)-1);
    }

    return seedp->len;
  }
}

// segLstFillHits
// file segment.c line 763
signed int segLstFillHits(struct _SegLst *sglp, unsigned int min_ktup, const struct _HashHitList *hhlp)
{
  signed int errcode;
  char is_reverse;
  const char *qmask;
  segLstBlank(sglp);
  hashGetHitListData((signed int *)(void *)0, &is_reverse, &sglp->qlen, &sglp->ktup, &sglp->nskip, &qmask, hhlp);
  sglp->flags = (unsigned char)(is_reverse != 0 ? 1 : 0);
  for( ; !(*qmask == 0); qmask = qmask + 1l)
    if(!((signed int)*qmask == 1))
    {
      if(!(min_ktup >= 2u))
        break;

      min_ktup = min_ktup - 1u;
    }

  errcode=defineHitRegions(&sglp->hregr, (signed int *)(void *)0, &sglp->dshift_cutoff, min_ktup, hhlp);
  if(!(errcode == 0))
    return errcode;

  else
  {
    sglp->flags = sglp->flags | (unsigned char)2;
    errcode=makeSeedsFromHits(&sglp->seedr, sglp->hregr, 0, 0, hhlp);
    if(!(errcode == 0))
      return errcode;

    else
    {
      sglp->flags = sglp->flags | (unsigned char)4;
      errcode=makeSegmentsFromSeeds(&sglp->segmr, &sglp->maxcover, sglp->hregr, (unsigned int)0, (unsigned int)0, sglp->seedr, sglp->nskip);
      if(errcode == 0)
        sglp->flags = sglp->flags | (unsigned char)8;

      return errcode;
    }
  }
}

// segLstGetStats
// file segment.c line 866
unsigned char segLstGetStats(const struct _SegLst *sp, unsigned int *nhreg, unsigned int *nseed, unsigned int *nseg)
{
  if(!(nhreg == ((unsigned int *)NULL)))
    *nhreg = (unsigned int)((unsigned long int *)sp->hregr)[(signed long int)-1];

  if(!(nseed == ((unsigned int *)NULL)))
    *nseed = (unsigned int)((unsigned long int *)sp->seedr)[(signed long int)-1];

  if(!(nseg == ((unsigned int *)NULL)))
    *nseg = (unsigned int)((unsigned long int *)sp->segmr)[(signed long int)-1];

  return (unsigned char)((signed int)sp->flags & 1);
}

// segLstPrintSeeds
// file segment.c line 896
void segLstPrintSeeds(struct _IO_FILE *fp, const struct _SegLst *sglp)
{
  unsigned int i;
  unsigned int n_seeds;
  struct _SEED$0 *sp;
  n_seeds = (unsigned int)((unsigned long int *)sglp->seedr)[(signed long int)-1];
  fprintf(fp, "=-=-=-=-= Seed List =-=-=-=-=\n");
  fprintf(fp, "%u Seeds\n", n_seeds);
  i = (unsigned int)0;
  for( ; !(i >= n_seeds); i = i + 1u)
  {
    sp = sglp->seedr + (signed long int)i;
    fprintf(fp, "[%i] ", i);
    printSeed(fp, sp, (char)((signed int)sglp->flags & 1), sglp->nskip, sglp->ktup);
  }
  fprintf(fp, "=-=-= End of Seed List =-=-=\n");
}

// segQMaskCreate
// file segment.h line 83
struct _SegQMask * segQMaskCreate(signed int qblksz)
{
  struct _SegQMask *sqmp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SegQMask) /*24ul*/ , "segment.c", 693);
  sqmp = (struct _SegQMask *)return_value_ecalloc$1;
  if(!(sqmp == ((struct _SegQMask *)NULL)))
  {
    if(!(qblksz >= 1024))
      qblksz = 1024;

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)qblksz, sizeof(unsigned char) /*1ul*/ , "segment.c", 697);
    sqmp->maskp = (unsigned char *)return_value_ecalloc$2;
    if(!(sqmp->maskp == ((unsigned char *)NULL)))
    {
      sqmp->n_alloc = (unsigned long int)qblksz;
      sqmp->blksiz = qblksz;
    }

    else
    {
      free((void *)sqmp);
      sqmp = ((struct _SegQMask *)NULL);
    }
  }

  return sqmp;
}

// segQMaskDelete
// file segment.h line 86
void segQMaskDelete(struct _SegQMask *sqmp)
{
  if(!(sqmp == ((struct _SegQMask *)NULL)))
    free((void *)sqmp->maskp);

  free((void *)sqmp);
}

// selectHashTyp
// file smalt.c line 268
static signed int selectHashTyp(unsigned char *typ, unsigned char *nbits_key, unsigned char *nbits_perf, unsigned char wordlen, unsigned char nskip, const struct _SeqSet *ssp)
{
  signed long int nseq;
  unsigned short int nbk = (unsigned short int)((signed int)wordlen << 1);
  unsigned long int ntup;
  const unsigned long int *offsp;
  unsigned long int nkey;
  *nbits_key = (unsigned char)0;
  *nbits_perf = (unsigned char)0;
  *typ = (unsigned char)0;
  if((signed int)nbk >= 64)
    return 16;

  else
  {
    if(!((signed int)nskip >= 1))
      nskip = (unsigned char)1;

    nseq=seqSetGetOffsets(ssp, &offsp);
    ntup = offsp[nseq] / (unsigned long int)nskip;
    nkey = (unsigned long int)1 << (signed int)nbk;
    if(ntup >= 4294967296ul)
      return 72;

    else
    {
      if(!(2ul * ntup >= nkey))
      {
        unsigned char last_b;
        unsigned char i;
        unsigned int t;
        *typ = (unsigned char)1;
        last_b = (unsigned char)((ntup & (unsigned long int)0x01) != 0ul ? 1 : 0);
        t = (unsigned int)ntup;
        i = (unsigned char)0;
        for( ; !((signed int)i >= 32); i = i + 1)
        {
          t = t >> 1;
          if(!((1u & t) == 0u))
            last_b = i;

        }
        if(!((1 & (signed int)last_b) == 0))
          *nbits_key = (unsigned char)((signed int)last_b + 1);

        else
          *nbits_key = last_b;
        if((signed int)nbk >= 33)
        {
          *nbits_perf = (unsigned char)((signed int)nbk - 32);
          if((signed int)*nbits_perf >= 11)
            return 16;

        }

        else
          *nbits_perf = (unsigned char)0;
        if((signed int)*nbits_key + (signed int)*nbits_perf >= 27)
          *nbits_key = (unsigned char)(26 - (signed int)*nbits_perf);

        if(!((signed int)*nbits_key >= 1 + (signed int)*nbits_perf))
          *nbits_key = (unsigned char)((signed int)*nbits_perf + 1);

        if((signed int)*nbits_key >= 27)
          *nbits_key = (unsigned char)26;

      }

      return 0;
    }
  }
}

// seqCodecCreate
// file sequence.h line 137
struct _SeqCodec * seqCodecCreate(void)
{
  signed int errcode;
  struct _SeqCodec *codp;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SeqCodec) /*525ul*/ , "sequence.c", 340);
  codp = (struct _SeqCodec *)return_value_ecalloc$1;
  _Bool tmp_if_expr$3;
  signed int return_value_checkCodec$2;
  if(codp == ((struct _SeqCodec *)NULL))
    return (struct _SeqCodec *)(void *)0;

  else
  {
    errcode=make3BitMangledCodec(codp);
    if(!(errcode == 0))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_checkCodec$2=checkCodec(codp);
      tmp_if_expr$3 = return_value_checkCodec$2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      seqCodecDelete(codp);
      codp = (struct _SeqCodec *)(void *)0;
    }

    return codp;
  }
}

// seqCodecCreateFromAlphabet
// file sequence.c line 353
struct _SeqCodec * seqCodecCreateFromAlphabet(const char *alphabet, unsigned char code_unknown)
{
  signed int i;
  signed int al;
  unsigned char cu;
  unsigned char a;
  unsigned long int alphsiz;
  alphsiz=strlen(alphabet);
  struct _SeqCodec *codp;
  signed int return_value_toupper$2;
  _Bool tmp_if_expr$4;
  if(alphsiz >= 8ul || (unsigned long int)code_unknown >= alphsiz || !(alphsiz >= 4ul))
    return (struct _SeqCodec *)(void *)0;

  else
  {
    al = (signed int)alphsiz;
    void *return_value_ecalloc$1;
    return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SeqCodec) /*525ul*/ , "sequence.c", 365);
    codp = (struct _SeqCodec *)return_value_ecalloc$1;
    if(codp == ((struct _SeqCodec *)NULL))
      return (struct _SeqCodec *)(void *)0;

    else
    {
      codp->typ = (char)1;
      strcpy(codp->alphabet, alphabet);
      codp->alphlen = (unsigned char)al;
      i = 0;
      for( ; !(i >= 256); i = i + 1)
        codp->decodtab[(signed long int)i] = alphabet[(signed long int)code_unknown];
      i = 0;
      for( ; !(i >= al); i = i + 1)
      {
        return_value_toupper$2=toupper((signed int)codp->alphabet[(signed long int)i]);
        codp->alphabet[(signed long int)i] = (char)return_value_toupper$2;
      }
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        signed int return_value_toupper$3;
        return_value_toupper$3=toupper(i);
        cu = (unsigned char)return_value_toupper$3;
        if((signed int)cu == 85)
          cu = (unsigned char)84;

        a = (unsigned char)0;
        do
        {
          if(!((signed int)a >= al))
            tmp_if_expr$4 = cu != (unsigned char)codp->alphabet[(signed long int)a] ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(!tmp_if_expr$4)
            break;

          a = a + 1;
        }
        while((_Bool)1);
        if(!((signed int)a >= al))
        {
          if(!((signed int)a >= 4))
            codp->codtab_complement[(signed long int)(~((signed int)a) & 3)] = (unsigned char)((signed int)a | 8);

          a = a | (unsigned char)8;
          codp->decodtab[(signed long int)a] = (char)cu;
        }

        else
          a = (unsigned char)((signed int)code_unknown | 8);
        codp->codtab[(signed long int)i] = a;
      }
      return codp;
    }
  }
}

// seqCodecDecodeString
// file sequence.c line 431
void seqCodecDecodeString(char *cp, const struct _SeqCodec *codp)
{
  char c;
  const char *decodp = codp->decodtab;
  for( ; !(*cp == 0); cp = cp + 1l)
  {
    c = decodp[(signed long int)(unsigned char)*cp];
    *cp = c;
  }
}

// seqCodecDelete
// file sequence.h line 150
void seqCodecDelete(struct _SeqCodec *codp)
{
  free((void *)codp);
}

// seqCodecEncodeString
// file sequence.c line 424
void seqCodecEncodeString(char *cp, const struct _SeqCodec *codp)
{
  const unsigned char *encodp = codp->codtab;
  for( ; !(*cp == 0); cp = cp + 1l)
    *cp = (char)encodp[(signed long int)(signed int)*cp];
}

// seqCodecFindBaseClass
// file sequence.h line 168
char seqCodecFindBaseClass(char c, const struct _SeqCodec *codecp)
{
  unsigned char cod = codecp->codtab[(signed long int)(signed int)c];
  char rv;
  if(!((0x04 & (signed int)cod) == 0))
  {
    if((7 & (signed int)cod) == 5)
      rv = (char)0;

    else
      rv = (char)3;
  }

  else
    if(!((0x01 & (signed int)cod) == 0))
      rv = (char)2;

    else
      rv = (char)1;
  return rv;
}

// seqCodecGetAlphabet
// file sequence.h line 153
const char * seqCodecGetAlphabet(const struct _SeqCodec *codp, signed short int *length)
{
  unsigned long int return_value_strlen$1;
  if(!(length == ((signed short int *)NULL)))
  {
    return_value_strlen$1=strlen(codp->alphabet);
    *length = (signed short int)return_value_strlen$1;
  }

  return codp->alphabet;
}

// seqCodecGetDecoder
// file sequence.c line 417
const char * seqCodecGetDecoder(const struct _SeqCodec *codp, signed short int *size)
{
  if(!(size == ((signed short int *)NULL)))
    *size = (signed short int)256;

  return codp->decodtab;
}

// seqCodecGetEncoder
// file sequence.c line 410
const unsigned char * seqCodecGetEncoder(const struct _SeqCodec *codp, signed short int *size)
{
  if(!(size == ((signed short int *)NULL)))
    *size = (signed short int)256;

  return codp->codtab;
}

// seqCodecType
// file sequence.h line 175
char seqCodecType(const struct _SeqCodec *codecp)
{
  return codecp->typ;
}

// seqFastqAppendSegment
// file sequence.h line 266
signed int seqFastqAppendSegment(struct _SeqFastq *top, const struct _SeqFastq *fromp, unsigned int start, unsigned int length, char reverse, const struct _SeqCodec *codep)
{
  signed int errcode;
  errcode=appendSeqSegment(top->datap, (unsigned int *)(void *)0, (unsigned char *)(void *)0, fromp->datap, start, length, reverse, (char)0, codep);
  _Bool tmp_if_expr$1;
  if(!(errcode == 0))
    return errcode;

  else
    if(top->headp->size == 0ul)
    {
      errcode=appendSeqSegment(top->headp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, fromp->headp, (unsigned int)0, (unsigned int)0, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);
      if(errcode == 0)
        goto __CPROVER_DUMP_L2;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if((signed int)top->type == 0)
        top->type = fromp->type;

      if(fromp->qualp == ((struct _SEQSEQ *)NULL))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = fromp->qualp->size < (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        return errcode;

      else
        if(top->qualp == ((struct _SEQSEQ *)NULL))
        {
          top->qualp=createSeq((unsigned int)top->datap->block_size);
          if(!(top->qualp == ((struct _SEQSEQ *)NULL)))
            goto __CPROVER_DUMP_L7;

          return 2;
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          errcode=appendSeqSegment(top->qualp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, fromp->qualp, start, length, reverse, (char)0, (const struct _SeqCodec *)(void *)0);
          if(!(errcode == 0))
            return errcode;

          else
          {
            top->type = (char)2;
            return top->qualp->size != top->datap->size ? 38 : 0;
          }
        }
    }
}

// seqFastqBlank
// file sequence.h line 232
void seqFastqBlank(struct _SeqFastq *p)
{
  if(!(p == ((struct _SeqFastq *)NULL)))
  {
    blankSeq(p->datap);
    blankSeq(p->qualp);
    blankSeq(p->headp);
    blankSeq(p->qheadp);
  }

}

// seqFastqCheck
// file sequence.h line 245
signed int seqFastqCheck(const struct _SeqFastq *sqp)
{
  _Bool tmp_if_expr$1;
  if(sqp == ((const struct _SeqFastq *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sqp->headp == (struct _SEQSEQ *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = sqp->datap == (struct _SEQSEQ *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    return -1;

  else
    if((signed int)sqp->type == 2)
    {
      if(sqp->qualp == ((struct _SEQSEQ *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = sqp->datap->size != sqp->qualp->size ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
        goto __CPROVER_DUMP_L8;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      signed int return_value_checkSeqNtSymbolsAreLetters$4;
      return_value_checkSeqNtSymbolsAreLetters$4=checkSeqNtSymbolsAreLetters(sqp->datap);
      return return_value_checkSeqNtSymbolsAreLetters$4;
    }
}

// seqFastqCompress
// file sequence.c line 2155
signed int seqFastqCompress(struct _SeqFastq *sqp)
{
  if(!((signed int)sqp->datap->code == 1))
    return 22;

  else
  {
    signed int return_value_compressSeq$1;
    return_value_compressSeq$1=compressSeq(sqp->datap);
    return return_value_compressSeq$1;
  }
}

// seqFastqCreate
// file sequence.h line 223
struct _SeqFastq * seqFastqCreate(signed int blocksize, char type)
{
  struct _SeqFastq *sqp = (struct _SeqFastq *)(void *)0;
  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SeqFastq) /*40ul*/ , "sequence.c", 1780);
  sqp = (struct _SeqFastq *)return_value_ecalloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(sqp == ((struct _SeqFastq *)NULL))
    return (struct _SeqFastq *)(void *)0;

  else
  {
    sqp->type = (char)((signed int)type == 1 || (signed int)type == 2 ? (signed int)type : 0);
    if(!(blocksize >= 1))
      blocksize = 256;

    sqp->headp=createSeq((unsigned int)128);
    if(sqp->headp == ((struct _SEQSEQ *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      sqp->datap=createSeq((unsigned int)blocksize);
      tmp_if_expr$2 = !(sqp->datap != ((struct _SEQSEQ *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      if((signed int)type == 2)
      {
        sqp->qualp=createSeq((unsigned int)blocksize);
        tmp_if_expr$3 = !(sqp->qualp != ((struct _SEQSEQ *)NULL)) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      seqFastqDelete(sqp);
      sqp = (struct _SeqFastq *)(void *)0;
    }

    return sqp;
  }
}

// seqFastqCurtailSeqName
// file sequence.c line 2135
void seqFastqCurtailSeqName(struct _SeqFastq *sfqp)
{
  curtailSeqAtFirstSpace(sfqp->headp);
}

// seqFastqDecode
// file sequence.h line 350
signed int seqFastqDecode(struct _SeqFastq *sqp, const struct _SeqCodec *codep)
{
  signed int return_value_decodeSeq$1;
  return_value_decodeSeq$1=decodeSeq(sqp->datap, codep);
  return return_value_decodeSeq$1;
}

// seqFastqDecodeAsStandardNt
// file sequence.c line 2214
signed int seqFastqDecodeAsStandardNt(struct _SeqFastq *dep, const struct _SeqFastq *sqp, unsigned int start, unsigned int length, const struct _SeqCodec *codep, char as_rcp)
{
  signed int errcode;
  seqFastqBlank(dep);
  errcode=decodeSeqAsStandardNt(dep->datap, sqp->datap, (unsigned long int)start, (unsigned long int)length, codep, as_rcp);
  if(errcode == 0)
  {
    if((signed int)dep->type == 2)
    {
      if((signed int)sqp->type == 2)
        errcode=appendSeqSegment(dep->qualp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, sqp->qualp, start, length, as_rcp, (char)0, (const struct _SeqCodec *)(void *)0);

      else
        errcode = 39;
    }

  }

  return errcode;
}

// seqFastqDelete
// file sequence.h line 229
void seqFastqDelete(struct _SeqFastq *sqp)
{
  if(!(sqp == ((struct _SeqFastq *)NULL)))
  {
    deleteSeq(sqp->headp);
    deleteSeq(sqp->datap);
    deleteSeq(sqp->qheadp);
    deleteSeq(sqp->qualp);
  }

  free((void *)sqp);
}

// seqFastqEncode
// file sequence.h line 347
signed int seqFastqEncode(struct _SeqFastq *sqp, const struct _SeqCodec *codep)
{
  signed int return_value_encodeSeq$1;
  return_value_encodeSeq$1=encodeSeq(sqp->datap, codep);
  return return_value_encodeSeq$1;
}

// seqFastqFind
// file sequence.c line 1992
signed int seqFastqFind(struct _SeqFastq *sqp, const char *nam, struct _SeqIO *ifp)
{
  signed int this_prompt = 43;
  signed int next_prompt;
  signed int cmp = 0;
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(!((signed int)ifp->mode == 0))
    return 13;

  else
  {
    do
    {
      ifp->status=scrollToHeaderLine((struct gzFile_s *)ifp->fp, &this_prompt, ifp->linbufp);
      if(!(ifp->status == 0))
        break;

      if(cmp == 0)
        break;

      ifp->status=readHeader$link1(sqp->headp, (struct gzFile_s *)ifp->fp, &this_prompt, ifp->linbufp);
      if(!(ifp->status == 0))
        break;

      curtailSeqAtFirstSpace(sqp->headp);
      cmp=strcmp(sqp->headp->basep, nam);
    }
    while((_Bool)1);
    if(!(ifp->status == 0))
      return ifp->status;

    else
      if(!(cmp == 0))
        return -1;

      else
      {
        ifp->status=readSeq(sqp->datap, (struct gzFile_s *)ifp->fp, &next_prompt);
        if(!(ifp->status == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)sqp->type == 1 ? (_Bool)1 : (_Bool)0;
        if(!(next_prompt == 43) || tmp_if_expr$2)
        {
          sqp->type = (char)1;
          if(ifp->status == 10)
            tmp_if_expr$1 = 0;

          else
            tmp_if_expr$1 = ifp->status;
          return tmp_if_expr$1;
        }

        else
        {
          signed int return_value_readQual$3;
          return_value_readQual$3=readQual(sqp, ifp);
          return return_value_readQual$3;
        }
      }
  }
}

// seqFastqFreeUnusedMem
// file sequence.c line 1815
void seqFastqFreeUnusedMem(struct _SeqFastq *sqp)
{
  if(!(sqp->headp == ((struct _SEQSEQ *)NULL)))
    finaliseSeq(sqp->headp);

  if(!(sqp->datap == ((struct _SEQSEQ *)NULL)))
    finaliseSeq(sqp->datap);

  if(!(sqp->qualp == ((struct _SEQSEQ *)NULL)))
    finaliseSeq(sqp->qualp);

  if(!(sqp->qheadp == ((struct _SEQSEQ *)NULL)))
    finaliseSeq(sqp->qheadp);

}

// seqFastqGetConstQualityFactors
// file sequence.h line 326
const char * seqFastqGetConstQualityFactors(const struct _SeqFastq *sfqp, unsigned int *length, char *code)
{
  if(sfqp == ((const struct _SeqFastq *)NULL))
    return (const char *)(void *)0;

  else
    if(sfqp->qualp == ((struct _SEQSEQ *)NULL))
    {
      if(!(length == ((unsigned int *)NULL)))
        *length = (unsigned int)0;

      return (const char *)(void *)0;
    }

    else
    {
      if(!(length == ((unsigned int *)NULL)))
      {
        if(!(sfqp->qualp->size >= 18446744073709551614ul))
          *length = (unsigned int)sfqp->qualp->size;

      }

      if(!(code == ((char *)NULL)))
        *code = sfqp->qualp->code;

      return sfqp->qualp->basep;
    }
}

// seqFastqGetConstSequence
// file sequence.h line 316
const char * seqFastqGetConstSequence(const struct _SeqFastq *sfqp, unsigned int *length, char *codtyp)
{
  if(sfqp == ((const struct _SeqFastq *)NULL))
  {
    if(!(length == ((unsigned int *)NULL)))
      *length = (unsigned int)0;

    return (const char *)(void *)0;
  }

  else
  {
    if(!(length == ((unsigned int *)NULL)))
    {
      if(!(sfqp->datap->size >= 18446744073709551614ul))
        *length = (unsigned int)sfqp->datap->size;

    }

    if(!(codtyp == ((char *)NULL)))
      *codtyp = sfqp->datap->code;

    return sfqp->datap->basep;
  }
}

// seqFastqGetQualName
// file sequence.c line 2140
const char * seqFastqGetQualName(const struct _SeqFastq *sfqp)
{
  char *tmp_if_expr$1;
  if(!(sfqp->qheadp == ((struct _SEQSEQ *)NULL)))
    tmp_if_expr$1 = sfqp->qheadp->basep;

  else
    tmp_if_expr$1 = (char *)(void *)0;
  return tmp_if_expr$1;
}

// seqFastqGetQualityFactors
// file sequence.c line 2117
char * seqFastqGetQualityFactors(struct _SeqFastq *sfqp, unsigned int *length, char *code)
{
  if(sfqp == ((struct _SeqFastq *)NULL))
    return (char *)(void *)0;

  else
    if(sfqp->qualp == ((struct _SEQSEQ *)NULL))
    {
      if(!(length == ((unsigned int *)NULL)))
        *length = (unsigned int)0;

      return (char *)(void *)0;
    }

    else
    {
      if(!(length == ((unsigned int *)NULL)))
      {
        if(!(sfqp->qualp->size >= 18446744073709551614ul))
          *length = (unsigned int)sfqp->qualp->size;

      }

      if(!(code == ((char *)NULL)))
        *code = sfqp->qualp->code;

      return sfqp->qualp->basep;
    }
}

// seqFastqGetSeqName
// file sequence.h line 336
const char * seqFastqGetSeqName(const struct _SeqFastq *sfqp)
{
  char *tmp_if_expr$1;
  if(!(sfqp == ((const struct _SeqFastq *)NULL)))
    tmp_if_expr$1 = sfqp->headp->basep;

  else
    tmp_if_expr$1 = (char *)(void *)0;
  return tmp_if_expr$1;
}

// seqFastqGetSequence
// file sequence.h line 323
char * seqFastqGetSequence(struct _SeqFastq *sfqp, unsigned int *length, char *codtyp)
{
  if(sfqp == ((struct _SeqFastq *)NULL))
  {
    if(!(length == ((unsigned int *)NULL)))
      *length = (unsigned int)0;

    return (char *)(void *)0;
  }

  else
  {
    if(!(length == ((unsigned int *)NULL)))
    {
      if(!(sfqp->datap->size >= 18446744073709551614ul))
        *length = (unsigned int)sfqp->datap->size;

    }

    if(!(codtyp == ((char *)NULL)))
      *codtyp = sfqp->datap->code;

    return sfqp->datap->basep;
  }
}

// seqFastqRead
// file sequence.h line 285
signed int seqFastqRead(struct _SeqFastq *sqp, struct _SeqIO *ifp)
{
  signed int errcode;
  signed int this_prompt = 43;
  signed int next_prompt;
  signed int tmp_if_expr$1;
  if(!((signed int)ifp->mode == 0))
    return 13;

  else
    if(!(ifp->status == 0))
      return ifp->status;

    else
    {
      while(this_prompt == 43)
      {
        ifp->status=readHeader$link1(sqp->headp, (struct gzFile_s *)ifp->fp, &this_prompt, ifp->linbufp);
        if(!(ifp->status == 0))
          return ifp->status;

        ifp->status=readSeqFast(sqp->datap, (struct gzFile_s *)ifp->fp, &next_prompt, ifp->linbufp, (unsigned int)0);
      }
      if(!(ifp->status == 0) || !(next_prompt == 43))
      {
        sqp->type = (char)1;
        if(ifp->status == 10)
          tmp_if_expr$1 = 0;

        else
          tmp_if_expr$1 = ifp->status;
        return tmp_if_expr$1;
      }

      else
      {
        errcode=readQual(sqp, ifp);
        if(errcode == 0)
        {
          if((signed int)sqp->type == 2)
          {
            if(!(sqp->datap->size == sqp->qualp->size))
              errcode = 6;

          }

        }

        return errcode;
      }
    }
}

// seqFastqReadCompressedBinary
// file sequence.c line 2190
signed int seqFastqReadCompressedBinary(struct _SeqFastq *sqp, struct _IO_FILE *fp, const char *label)
{
  signed int errcode;
  errcode=readCompressedSeq(sqp->datap, fp);
  if(errcode == 0 && !(label == ((const char *)NULL)))
    errcode=setSeq(sqp->headp, label);

  deleteSeq(sqp->qualp);
  sqp->qualp = (struct _SEQSEQ *)(void *)0;
  sqp->type = (char)1;
  return errcode;
}

// seqFastqReadCompressedBinaryOfKnownLength
// file sequence.c line 2201
signed int seqFastqReadCompressedBinaryOfKnownLength(struct _SeqFastq *sqp, struct _IO_FILE *fp, unsigned int len, const char *label)
{
  signed int errcode;
  errcode=readCompressedSeqOfKnownLength(sqp->datap, fp, (unsigned long int)len);
  if(errcode == 0 && !(label == ((const char *)NULL)))
    errcode=setSeq(sqp->headp, label);

  deleteSeq(sqp->qualp);
  sqp->qualp = (struct _SEQSEQ *)(void *)0;
  sqp->type = (char)1;
  return errcode;
}

// seqFastqReverse
// file sequence.c line 1952
signed int seqFastqReverse(struct _SeqFastq *sqp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  errcode=reverseComplementSeq(sqp->datap, codecp);
  if(errcode == 0)
  {
    if(!(sqp->qualp == ((struct _SEQSEQ *)NULL)))
    {
      if((signed int)sqp->type == 2)
        errcode=reverseComplementSeq(sqp->qualp, (const struct _SeqCodec *)(void *)0);

    }

  }

  return errcode;
}

// seqFastqSetAscii
// file sequence.h line 248
signed int seqFastqSetAscii(struct _SeqFastq *sqp, const char *name, const char *seqp, const char *name_qual, const char *qualp)
{
  signed int errcode;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(name == ((const char *)NULL)))
  {
    errcode=setSeq(sqp->headp, name);
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(seqp == ((const char *)NULL)))
    {
      errcode=setSeq(sqp->datap, seqp);
      if(errcode == 0)
        goto __CPROVER_DUMP_L2;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(name_qual == ((const char *)NULL)))
      {
        if(!(sqp->qheadp == ((struct _SEQSEQ *)NULL)))
          tmp_if_expr$1 = (_Bool)1;

        else
        {
          sqp->qheadp=createSeq((unsigned int)128);
          tmp_if_expr$1 = sqp->qheadp != ((struct _SEQSEQ *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$1)
          return 2;

        errcode=setSeq(sqp->qheadp, name_qual);
        if(errcode == 0)
          goto __CPROVER_DUMP_L6;

        return errcode;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        if(!(qualp == ((const char *)NULL)))
          tmp_if_expr$5 = (signed int)qualp[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          sqp->type = (char)2;
          if(!(sqp->qualp == ((struct _SEQSEQ *)NULL)))
            tmp_if_expr$2 = (_Bool)1;

          else
          {
            sqp->qualp=createSeq((unsigned int)sqp->datap->block_size);
            tmp_if_expr$2 = sqp->qualp != ((struct _SEQSEQ *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$2)
            return 2;

          errcode=setSeq(sqp->qualp, qualp);
          if(!(errcode == 0))
            return errcode;

          if(!(sqp->datap->size == sqp->qualp->size))
            return 38;

        }

        else
        {
          if(!((signed int)sqp->type == 2))
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = !(sqp->qualp != ((struct _SEQSEQ *)NULL)) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = sqp->datap->size != sqp->qualp->size ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            sqp->type = (char)1;

        }
        return 0;
      }
    }
  }
}

// seqFastqSetQual
// file sequence.h line 260
signed int seqFastqSetQual(struct _SeqFastq *sqp, const char qval)
{
  unsigned long int i;
  _Bool tmp_if_expr$1;
  if(!(sqp->qualp == ((struct _SEQSEQ *)NULL)))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    sqp->qualp=createSeq((unsigned int)sqp->datap->block_size);
    tmp_if_expr$1 = sqp->qualp != ((struct _SEQSEQ *)NULL) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  signed int return_value_reallocSeqBlocks$2;
  if(!tmp_if_expr$1)
    return 2;

  else
  {
    if(sqp->datap->size >= sqp->qualp->alloc_size)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_reallocSeqBlocks$2=reallocSeqBlocks(sqp->qualp, sqp->datap->size);
      tmp_if_expr$3 = return_value_reallocSeqBlocks$2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      return 2;

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= sqp->datap->size); i = i + 1ul)
        sqp->qualp->basep[(signed long int)i] = qval;
      sqp->qualp->basep[(signed long int)i] = (char)0;
      sqp->qualp->size = i;
      sqp->type = (char)2;
      return 0;
    }
  }
}

// seqFastqSetType
// file sequence.c line 1836
signed int seqFastqSetType(struct _SeqFastq *sqp, char type)
{
  signed int errcode = 0;
  if(!((signed int)type == 1) && !((signed int)type == 2))
    type = (char)0;

  if(!((signed int)type == 1))
  {
    if(sqp->qualp == ((struct _SEQSEQ *)NULL))
    {
      unsigned long int i = (unsigned long int)0LL;
      if(sqp->datap == ((struct _SEQSEQ *)NULL))
        return 47;

      sqp->qualp=createSeq((unsigned int)sqp->datap->block_size);
      if(sqp->qualp == ((struct _SEQSEQ *)NULL))
        return 2;

      if(!((unsigned long int)sqp->qualp->block_size >= sqp->datap->size))
      {
        errcode=reallocSeqBlocks(sqp->qualp, sqp->datap->size);
        if(errcode == 0)
          return errcode;

      }

      i = (unsigned long int)0;
      for( ; !(i >= sqp->datap->size); i = i + 1ul)
        sqp->qualp->basep[(signed long int)i] = (char)33;
    }

  }

  sqp->type = type;
  return errcode;
}

// seqFastqUncompress
// file sequence.c line 2162
signed int seqFastqUncompress(struct _SeqFastq *ucp, const struct _SeqFastq *sqp, unsigned int start, unsigned int length, const struct _SeqCodec *codep, char as_rcp)
{
  signed int errcode;
  errcode=uncompressSeq(ucp->datap, (unsigned int *)(void *)0, (unsigned char *)(void *)0, sqp->datap, (unsigned long int)start, (unsigned long int)length, codep);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(errcode == 0))
    return errcode;

  else
  {
    ucp->type = (char)1;
    blankSeq(ucp->headp);
    errcode=appendSeqSegment(ucp->headp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, sqp->headp, (unsigned int)0, (unsigned int)0, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);
    if(!(errcode == 0))
      return errcode;

    else
      if(!(as_rcp == 0))
      {
        errcode=reverseSeqInPlace(ucp->datap);
        if(!(errcode == 0))
          tmp_if_expr$1 = (_Bool)1;

        else
        {
          errcode=complementAsciiSeqInPlace(ucp->datap, codep);
          tmp_if_expr$1 = errcode != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$1)
          goto __CPROVER_DUMP_L5;

        return errcode;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(sqp->qualp == ((struct _SEQSEQ *)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = sqp->qualp->size <= (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return 0;

        else
        {
          if(!(ucp->qualp == ((struct _SEQSEQ *)NULL)))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            ucp->qualp=createSeq((unsigned int)sqp->qualp->block_size);
            tmp_if_expr$3 = ucp->qualp != ((struct _SEQSEQ *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$3)
            return 2;

          else
          {
            ucp->type = (char)2;
            blankSeq(ucp->qualp);
            errcode=appendSeqSegment(ucp->qualp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, sqp->qualp, start, length, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);
            if(errcode == 0 && !(as_rcp == 0))
              errcode=reverseSeqInPlace(ucp->qualp);

            return errcode;
          }
        }
      }
  }
}

// seqFastqWrite
// file sequence.c line 2023
signed int seqFastqWrite(struct _SeqIO *ofp, const struct _SeqFastq *sqp, signed short int linewidth)
{
  signed int cprompt;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(sqp == ((const struct _SeqFastq *)NULL))
    return -1;

  else
    if((signed int)ofp->mode == 0)
      return 12;

    else
      if(!(ofp->status == 0))
        return ofp->status;

      else
      {
        if((signed int)sqp->type == 1)
          cprompt = 62;

        else
          if((signed int)sqp->type == 2)
            cprompt = 64;

          else
            return 39;
        ofp->status=fprintSeqFastqHeader(ofp->fp, (unsigned char)(((signed int)ofp->flags & 2) != 0), sqp->headp, cprompt);
        if(ofp->status == 0)
          ofp->status=fprintSeqFastqSequence(ofp->fp, (unsigned char)(((signed int)ofp->flags & 2) != 0), sqp->datap, linewidth);

        if(!(ofp->status == 0))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)sqp->type != 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = sqp->qualp == (struct _SEQSEQ *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return ofp->status;

        else
        {
          ofp->status=fprintSeqFastqHeader(ofp->fp, (unsigned char)(((signed int)ofp->flags & 2) != 0), sqp->qheadp, 43);
          if(ofp->status == 0)
            ofp->status=fprintSeqFastqSequence(ofp->fp, (unsigned char)(((signed int)ofp->flags & 2) != 0), sqp->qualp, linewidth);

          return ofp->status;
        }
      }
}

// seqFastqWriteCompressedToFile
// file sequence.c line 2067
signed int seqFastqWriteCompressedToFile(struct _IO_FILE *fp, const struct _SeqFastq *sqp)
{
  if(sqp == ((const struct _SeqFastq *)NULL))
    return 15;

  else
  {
    signed int return_value_writeCompressedSeq$1;
    return_value_writeCompressedSeq$1=writeCompressedSeq(fp, sqp->datap);
    return return_value_writeCompressedSeq$1;
  }
}

// seqIOCheckReads
// file sequence.h line 197
signed int seqIOCheckReads(struct _ErrMsg *errmsgp, struct _SeqFastq *sqbufp, struct _SeqIO *sfp, struct _SeqFastq *sqbufBp, struct _SeqIO *sfBp, signed long int *seqnum, unsigned int *maxseqlen, unsigned int *maxnamlen)
{
  signed int errcode;
  unsigned long int snum;
  unsigned char isPaired = (unsigned char)(sqbufBp != (struct _SeqFastq *)(void *)0 && sfBp != (struct _SeqIO *)(void *)0);
  unsigned char namflg = (unsigned char)1;
  unsigned int mxnaml;
  unsigned int mxseql;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  unsigned long int tmp_if_expr$4;
  if(!((signed int)sfp->mode == 0))
    return -1;

  else
  {
    mxseql = (unsigned int)0;
    mxnaml = mxseql;
    snum = (unsigned long int)0;
    do
    {
      if(sfp->status == 0)
      {
        if(isPaired == 0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = !(sfp->status != 0) ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(snum >= 4294967295ul || !tmp_if_expr$2)
        break;

      errcode=seqFastqRead(sqbufp, sfp);
      errMsgSetCurrentReadNumber(errmsgp, snum);
      const char *return_value_seqFastqGetSeqName$3;
      return_value_seqFastqGetSeqName$3=seqFastqGetSeqName(sqbufp);
      errMsgSetCurrentReadName(errmsgp, return_value_seqFastqGetSeqName$3);
      if(!(errcode == 0))
      {
        if(!(errcode == 10))
          errMsgAdd(errmsgp, "", "sequence.c", 646, errcode, (unsigned char)2);

        return errcode;
      }

      if(!((unsigned long int)mxnaml >= sqbufp->headp->size))
        mxnaml = (unsigned int)sqbufp->headp->size;

      if(!((unsigned long int)mxseql >= sqbufp->datap->size))
        mxseql = (unsigned int)sqbufp->datap->size;

      if(!(sqbufp->qheadp == ((struct _SEQSEQ *)NULL)))
      {
        if(!((unsigned long int)mxnaml >= sqbufp->qheadp->size))
          mxnaml = (unsigned int)sqbufp->qheadp->size;

      }

      if(!(isPaired == 0))
      {
        errcode=seqFastqRead(sqbufBp, sfBp);
        if(!(errcode == 0))
          return errcode;

        if(!(namflg == 0))
        {
          unsigned long int maxlen;
          if(!(sqbufBp->headp->size >= sqbufp->headp->size))
            tmp_if_expr$4 = sqbufBp->headp->size;

          else
            tmp_if_expr$4 = sqbufp->headp->size;
          maxlen = tmp_if_expr$4;
          signed int return_value_cmpPairNamStr$5;
          return_value_cmpPairNamStr$5=cmpPairNamStr(sqbufp->headp->basep, sqbufBp->headp->basep, maxlen);
          if(!(return_value_cmpPairNamStr$5 == 0))
            namflg = (unsigned char)0;

        }

        if(!((unsigned long int)mxnaml >= sqbufBp->headp->size))
          mxnaml = (unsigned int)sqbufBp->headp->size;

        if(!((unsigned long int)mxseql >= sqbufBp->datap->size))
          mxseql = (unsigned int)sqbufBp->datap->size;

        if(!(sqbufBp->qheadp == ((struct _SEQSEQ *)NULL)))
        {
          if(!((unsigned long int)mxnaml >= sqbufBp->qheadp->size))
            mxnaml = (unsigned int)sqbufBp->qheadp->size;

        }

      }

      snum = snum + 1ul;
    }
    while((_Bool)1);
    if(snum >= 4294967295ul)
      return 48;

    else
    {
      if(!(seqnum == ((signed long int *)NULL)))
        *seqnum = (signed long int)snum;

      if(!(maxseqlen == ((unsigned int *)NULL)))
        *maxseqlen = (unsigned int)mxseql;

      if(!(maxnamlen == ((unsigned int *)NULL)))
        *maxnamlen = (unsigned int)mxnaml;

      if(sfBp == ((struct _SeqIO *)NULL))
      {
        if(sfp->status == 10)
          errcode = 0;

        else
          if(sfp->status == 0)
            errcode = 6;

          else
            errcode = sfp->status;
        return errcode;
      }

      else
      {
        if(sfp->status == 10)
        {
          if(sfBp->status == 10)
            errcode = 0;

          else
            if(sfBp->status == 0)
              errcode = 77;

            else
              errcode = sfBp->status;
        }

        else
          if(sfp->status == 0)
            errcode = 77;

          else
            errcode = sfp->status;
        return namflg != 0 ? errcode : 76;
      }
    }
  }
}

// seqIOReset
// file sequence.h line 193
signed int seqIOReset(struct _SeqIO *p)
{
  char *return_value_gzgets$2;
  signed int return_value_gzeof$1;
  char *return_value_fgets$4;
  signed int return_value_feof$3;
  if((signed int)p->mode == 0)
  {
    if(p->status == 0)
      goto __CPROVER_DUMP_L1;

    if(p->status == 10)
      goto __CPROVER_DUMP_L1;

    return p->status;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    p->status = 0;
    if(!((2 & (signed int)p->flags) == 0))
    {
      gzrewind((struct gzFile_s *)p->fp);
      if((signed int)p->mode == 0)
      {
        return_value_gzgets$2=gzgets((struct gzFile_s *)p->fp, p->linbufp, 1024);
        if(return_value_gzgets$2 == ((char *)NULL))
        {
          return_value_gzeof$1=gzeof((struct gzFile_s *)p->fp);
          p->status = return_value_gzeof$1 != 0 ? 10 : 14;
        }

      }

    }

    else
    {
      rewind((struct _IO_FILE *)p->fp);
      if((signed int)p->mode == 0)
      {
        return_value_fgets$4=fgets(p->linbufp, 1024, (struct _IO_FILE *)p->fp);
        if(return_value_fgets$4 == ((char *)NULL))
        {
          return_value_feof$3=feof((struct _IO_FILE *)p->fp);
          p->status = return_value_feof$3 != 0 ? 10 : 14;
        }

      }

    }
    return p->status;
  }
}

// seqIOclose
// file sequence.h line 194
signed int seqIOclose(struct _SeqIO *p)
{
  signed int errcode = 0;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(!(p == ((struct _SeqIO *)NULL)))
  {
    if(!(p->fp == NULL))
    {
      if(!((2 & (signed int)p->flags) == 0))
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = !(((signed int)p->flags & 1) != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        signed int return_value_gzclose$1;
        return_value_gzclose$1=gzclose((struct gzFile_s *)p->fp);
        if(!(return_value_gzclose$1 == 0))
          errcode = 50;

      }

      else
      {
        signed int return_value_fflush$2;
        return_value_fflush$2=fflush((struct _IO_FILE *)p->fp);
        if(!(return_value_fflush$2 == 0))
          errcode = 50;

        if(!((signed int)*p->filnam == 45))
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          if(!((signed int)p->filnam[1l] == 0))
          {
            return_value___ctype_b_loc$3=__ctype_b_loc();
            tmp_if_expr$4 = !(((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)p->filnam[(signed long int)1]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$4 = (_Bool)0;
          tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
          fclose((struct _IO_FILE *)p->fp);

      }
    }

    if(!(p->linbufp == ((char *)NULL)))
      free((void *)p->linbufp);

    free((void *)p->filnam);
  }

  free((void *)p);
  return errcode;
}

// seqIOopen
// file sequence.h line 183
struct _SeqIO * seqIOopen(signed int *errcode, const char *filnam, char mode, unsigned long int buffsize)
{
  struct _SeqIO *p = ((struct _SeqIO *)NULL);
  *errcode = 0;
  _Bool tmp_if_expr$1;
  if(filnam == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)filnam[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    tmp_if_expr$3 = ((signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)filnam[(signed long int)0]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    *errcode = 47;
    return (struct _SeqIO *)(void *)0;
  }

  else
  {
    void *return_value_ecalloc$4;
    return_value_ecalloc$4=ecalloc((unsigned long int)1, sizeof(struct _SeqIO) /*56ul*/ , "sequence.c", 478);
    p = (struct _SeqIO *)return_value_ecalloc$4;
    if(p == ((struct _SeqIO *)NULL))
    {
      *errcode = 2;
      return (struct _SeqIO *)(void *)0;
    }

    else
    {
      p->flags = (unsigned char)0;
      p->bufsize = buffsize != 0ul ? buffsize : (unsigned long int)8192;
      p->mode = mode;
      p->linbufp = (char *)(void *)0;
      switch((signed int)mode)
      {
        case 0:
          strcpy(p->fmode, "r");
        case 4:

        case 5:
        {
          p->flags = (unsigned char)2;
          break;
        }
        case 2:

        case 3:
        {
          p->flags = p->flags | (unsigned char)1;
          strcpy(p->fmode, "w");
          break;
        }
        default:
          *errcode = 8;
      }
      if(*errcode == 0)
      {
        p->filnam = (char *)(void *)0;
        p->filnam=estrcpy(filnam, "sequence.c", 508);
        if(p->filnam == ((char *)NULL))
          *errcode = 2;

      }

      if(*errcode == 0)
      {
        if((signed int)mode == 0 || (signed int)mode == 4)
        {
          struct gzFile_s *return_value_gzopen$5;
          return_value_gzopen$5=gzopen(p->filnam, p->fmode);
          p->fp = (void *)return_value_gzopen$5;
        }

        else
        {
          struct _IO_FILE *return_value_efopen$6;
          return_value_efopen$6=efopen(p->filnam, p->fmode, "sequence.c", 523);
          p->fp = (void *)return_value_efopen$6;
        }
        if(p->fp == NULL)
          *errcode = 9;

      }

      if(*errcode == 0)
      {
        if((signed int)mode == 0)
        {
          void *return_value_ecalloc$7;
          return_value_ecalloc$7=ecalloc((unsigned long int)(1024 + 1), sizeof(char) /*1ul*/ , "sequence.c", 536);
          p->linbufp = (char *)return_value_ecalloc$7;
          if(!(p->linbufp == ((char *)NULL)))
          {
            char *return_value_gzgets$8;
            return_value_gzgets$8=gzgets((struct gzFile_s *)p->fp, p->linbufp, 1024);
            if(return_value_gzgets$8 == ((char *)NULL))
              *errcode = 6;

          }

          else
            *errcode = 2;
        }

      }

      if(!(*errcode == 0))
      {
        seqIOclose(p);
        p = (struct _SeqIO *)(void *)0;
      }

      return p;
    }
  }
}

// seqIOstatus
// file sequence.h line 195
signed int seqIOstatus(struct _SeqIO *p)
{
  if(p == ((struct _SeqIO *)NULL))
    return 15;

  else
    return p->status;
}

// seqSetAddFromFastqFile
// file sequence.h line 450
signed int seqSetAddFromFastqFile(struct _ErrMsg *errmsg, struct _SeqSet *ssp, struct _SeqFastq *sqbufp, const struct _SeqCodec *codecp, const char *filnam, char verbose)
{
  signed int errcode = 0;
  signed long int sctr;
  struct _SeqIO *sfp;
  sfp=seqIOopen(&errcode, filnam, (char)0, (unsigned long int)0);
  if(!(errcode == 0))
  {
    seqIOclose(sfp);
    errMsgAdd(errmsg, "", "sequence.c", 2404, errcode, (unsigned char)2);
  }

  if(!(verbose == 0))
    printf("File %s opened for reading sequences in FASTA/FASTQ format ...\n", filnam);

  sctr = (signed long int)0;
  signed int return_value_seqIOstatus$1;
  signed long int tmp_post$2;
  do
  {
    return_value_seqIOstatus$1=seqIOstatus(sfp);
    if(!(return_value_seqIOstatus$1 == 0))
      break;

    if(!(verbose == 0))
    {
      tmp_post$2 = sctr;
      sctr = sctr + 1l;
      printf("Reading sequence %llu ...\n", (unsigned long long int)tmp_post$2);
    }

    errcode=seqFastqRead(sqbufp, sfp);
    if(!(errcode == 0))
      errMsgAdd(errmsg, "", "sequence.c", 2415, errcode, (unsigned char)2);

    errcode=seqFastqEncode(sqbufp, codecp);
    if(!(errcode == 0))
      errMsgAdd(errmsg, "", "sequence.c", 2417, errcode, (unsigned char)2);

    errcode=seqSetAddSequence(ssp, sqbufp);
    if(!(errcode == 0))
      errMsgAdd(errmsg, "", "sequence.c", 2419, errcode, (unsigned char)2);

  }
  while((_Bool)1);
  signed int return_value_seqIOstatus$5;
  return_value_seqIOstatus$5=seqIOstatus(sfp);
  signed int return_value_seqIOstatus$4;
  signed int return_value_seqIOstatus$3;
  if(!(return_value_seqIOstatus$5 == 0))
  {
    return_value_seqIOstatus$4=seqIOstatus(sfp);
    if(!(return_value_seqIOstatus$4 == 10))
    {
      return_value_seqIOstatus$3=seqIOstatus(sfp);
      errMsgAdd(errmsg, "", "sequence.c", 2423, return_value_seqIOstatus$3, (unsigned char)2);
    }

  }

  seqIOclose(sfp);
  if(!((4 & (signed int)ssp->statusflag) == 0))
  {
    if(ssp->sqp->size == ssp->qqp->size)
      goto __CPROVER_DUMP_L10;

    return 47;
  }

  else
  {

  __CPROVER_DUMP_L10:
    ;
    if(!(verbose == 0))
      printf("%llu sequences read from file %s\n", (unsigned long long int)sctr, filnam);

    return 0;
  }
}

// seqSetAddSequence
// file sequence.c line 2330
signed int seqSetAddSequence(struct _SeqSet *ssp, const struct _SeqFastq *sqp)
{
  signed int errcode;
  char *cp;
  unsigned long int namsiz;
  _Bool tmp_if_expr$1;
  unsigned long int tmp_if_expr$2;
  if((signed int)sqp->datap->code == 2)
    return 22;

  else
  {
    if(!((2 & (signed int)ssp->statusflag) == 0))
    {
      if(!((signed int)sqp->datap->code == 1))
        return 22;

    }

    else
      if(!(ssp->n_seq == 0l))
      {
        if(!(sqp->datap->code == ssp->sqp->code))
          return 22;

      }

    if(1l + ssp->n_seq >= -2l)
      return 86;

    else
      if(!((4 & (signed int)ssp->statusflag) == 0))
      {
        if(sqp->qualp == ((struct _SEQSEQ *)NULL))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)sqp->type != 2 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$1)
          goto __CPROVER_DUMP_L8;

        return 39;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if(!((2 & (signed int)ssp->statusflag) == 0))
          errcode=appendMangledToCompressedSeq(ssp->sqp, sqp->datap, (char)(((signed int)ssp->statusflag & 1) > 0));

        else
          errcode=appendSeqSegment(ssp->sqp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, sqp->datap, (unsigned int)0, (unsigned int)0, (char)0, (char)(((signed int)ssp->statusflag & 1) > 0), (const struct _SeqCodec *)(void *)0);
        if(!(errcode == 0))
          return errcode;

        else
          if(!((4 & (signed int)ssp->statusflag) == 0))
          {
            errcode=appendSeqSegment(ssp->qqp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, sqp->qualp, (unsigned int)0, (unsigned int)0, (char)0, (char)(((signed int)ssp->statusflag & 1) > 0), (const struct _SeqCodec *)(void *)0);
            if(errcode == 0)
              goto __CPROVER_DUMP_L12;

            return errcode;
          }

          else
          {

          __CPROVER_DUMP_L12:
            ;
            if(1l + ssp->n_seq >= ssp->n_alloc)
            {
              errcode=reallocSeqSet(ssp, ssp->n_seq + (signed long int)2);
              if(errcode == 0)
                goto __CPROVER_DUMP_L13;

              return errcode;
            }

            else
            {

            __CPROVER_DUMP_L13:
              ;
              ssp->sop[ssp->n_seq + (signed long int)1] = ssp->sop[ssp->n_seq] + sqp->datap->size;
              if(!((1 & (signed int)ssp->statusflag) == 0))
                ssp->sop[ssp->n_seq + (signed long int)1] = ssp->sop[ssp->n_seq + (signed long int)1] + 1ul;

              if(ssp->n_seq >= 1l)
                tmp_if_expr$2 = ssp->namoffs[ssp->n_seq];

              else
                tmp_if_expr$2 = (unsigned long int)0;
              namsiz = tmp_if_expr$2;
              if(sqp->headp->size + namsiz >= ssp->nam_alloc)
              {
                errcode=reallocSeqSetName(ssp, sqp->headp->size + namsiz + (unsigned long int)1);
                if(errcode == 0)
                  goto __CPROVER_DUMP_L17;

                return errcode;
              }

              else
              {

              __CPROVER_DUMP_L17:
                ;
                cp = ssp->namebasep + (signed long int)namsiz;
                strncpy(cp, sqp->headp->basep, sqp->headp->size);
                cp[(signed long int)sqp->headp->size] = (char)0;
                ssp->namoffs[ssp->n_seq + (signed long int)1] = namsiz + sqp->headp->size + (unsigned long int)1;
                ssp->n_seq = ssp->n_seq + 1l;
                return 0;
              }
            }
          }
      }
  }
}

// seqSetBlank
// file sequence.c line 2323
void seqSetBlank(struct _SeqSet *ssp)
{
  blankSeq(ssp->sqp);
  blankSeq(ssp->sqp);
  ssp->n_seq = (signed long int)0;
}

// seqSetCompress
// file sequence.c line 2436
signed int seqSetCompress(struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode = 0;
  if((2 & (signed int)ssp->statusflag) == 0)
  {
    if(!((signed int)ssp->sqp->code == 0))
      goto __CPROVER_DUMP_L1;

    errcode=encodeSeq(ssp->sqp, codecp);
    if(errcode == 0)
      goto __CPROVER_DUMP_L1;

    return errcode;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    errcode=compressSeq(ssp->sqp);
    if(errcode == 0)
      ssp->statusflag = ssp->statusflag | (unsigned char)2;

    return errcode;
  }
}

// seqSetCreate
// file sequence.h line 412
struct _SeqSet * seqSetCreate(signed int blocksiz, unsigned char flags)
{
  struct _SeqSet *ssp;
  if(!(blocksiz >= 1))
    blocksiz = 4096;

  void *return_value_ecalloc$1;
  return_value_ecalloc$1=ecalloc((unsigned long int)1, sizeof(struct _SeqSet) /*96ul*/ , "sequence.c", 2286);
  ssp = (struct _SeqSet *)return_value_ecalloc$1;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  if(ssp == ((struct _SeqSet *)NULL))
    return ((struct _SeqSet *)NULL);

  else
  {
    ssp->statusflag = flags;
    ssp->sqp=createSeq((unsigned int)blocksiz);
    if(!((4 & (signed int)flags) == 0))
      ssp->qqp=createSeq((unsigned int)blocksiz);

    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)blocksiz, sizeof(unsigned long int) /*8ul*/ , "sequence.c", 2294);
    ssp->sop = (unsigned long int *)return_value_ecalloc$2;
    void *return_value_ecalloc$3;
    return_value_ecalloc$3=ecalloc((unsigned long int)blocksiz, sizeof(unsigned long int) /*8ul*/ , "sequence.c", 2295);
    ssp->namoffs = (unsigned long int *)return_value_ecalloc$3;
    void *return_value_ecalloc$4;
    return_value_ecalloc$4=ecalloc((unsigned long int)1024, sizeof(char) /*1ul*/ , "sequence.c", 2296);
    ssp->namebasep = (char *)return_value_ecalloc$4;
    if(ssp->sqp == ((struct _SEQSEQ *)NULL))
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      if(!((4 & (signed int)flags) == 0))
        tmp_if_expr$5 = !(ssp->qqp != ((struct _SEQSEQ *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = !(ssp->sop != ((unsigned long int *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = !(ssp->namoffs != ((unsigned long int *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = !(ssp->namebasep != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$9)
    {
      seqSetDelete(ssp);
      return ((struct _SeqSet *)NULL);
    }

    else
    {
      ssp->nam_blocksiz = 1024;
      ssp->blocksiz = blocksiz;
      ssp->n_alloc = (signed long int)ssp->blocksiz;
      ssp->nam_alloc = (unsigned long int)ssp->nam_blocksiz;
      return ssp;
    }
  }
}

// seqSetDelete
// file sequence.h line 420
void seqSetDelete(struct _SeqSet *ssp)
{
  if(!(ssp == ((struct _SeqSet *)NULL)))
  {
    deleteSeq(ssp->sqp);
    deleteSeq(ssp->qqp);
    free((void *)ssp->sop);
    free((void *)ssp->namoffs);
    free((void *)ssp->namebasep);
    free((void *)ssp->sxp);
  }

  free((void *)ssp);
}

// seqSetFetchSegment
// file sequence.h line 463
signed int seqSetFetchSegment(struct _SeqFastq *sqp, unsigned long int *offs_start, unsigned long int *offs_end, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  unsigned char ntc = (unsigned char)0;
  unsigned char with_qual;
  _Bool tmp_if_expr$1;
  if(!((4 & (signed int)ssp->statusflag) == 0))
    tmp_if_expr$1 = (signed int)sqp->type == 2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  with_qual = (unsigned char)tmp_if_expr$1;
  unsigned int len;
  unsigned int os;
  unsigned int oe;
  unsigned int tcpos[8l];
  _Bool tmp_if_expr$2;
  if(*offs_start >= ssp->sop[ssp->n_seq])
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = *offs_start >= *offs_end ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = *offs_end >= ssp->sqp->size ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    return 29;

  else
  {
    len = (unsigned int)((*offs_end - *offs_start) + (unsigned long int)1);
    blankSeq(sqp->datap);
    if(!(with_qual == 0))
      blankSeq(sqp->qualp);

    if(!((2 & (signed int)ssp->statusflag) == 0))
      errcode=uncompressSeq(sqp->datap, tcpos, &ntc, ssp->sqp, *offs_start, (unsigned long int)len, codecp);

    else
      errcode=appendSeqSegment(sqp->datap, tcpos, &ntc, ssp->sqp, (unsigned int)*offs_start, len, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);
    if(!(errcode == 0))
      return errcode;

    else
    {
      if((signed int)ntc >= 1)
      {
        if((signed int)ntc == 1)
        {
          if(!(len / 2u >= tcpos[0l]))
          {
            os = (unsigned int)0;
            oe = tcpos[(signed long int)0] - (unsigned int)1;
          }

          else
          {
            os = tcpos[(signed long int)0] + (unsigned int)1;
            oe = len - (unsigned int)1;
          }
        }

        else
        {
          os = tcpos[(signed long int)0] + (unsigned int)1;
          oe = tcpos[(signed long int)1] - (unsigned int)1;
        }
        errcode=cropSeq(sqp->datap, os, oe);
        if(errcode == 0 && (signed int)ntc >= 4)
          errcode = 68;

        *offs_end = *offs_start + (unsigned long int)oe;
        *offs_start = *offs_start + (unsigned long int)os;
      }

      if(errcode == 0 && !(with_qual == 0))
      {
        len = (unsigned int)((*offs_end - *offs_start) + (unsigned long int)1);
        errcode=appendSeqSegment(sqp->qualp, tcpos, &ntc, ssp->qqp, (unsigned int)*offs_start, len, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);
      }

      return errcode;
    }
  }
}

// seqSetFetchSegmentBySequence
// file sequence.h line 482
signed int seqSetFetchSegmentBySequence(struct _SeqFastq *sqp, signed long int seqidx, unsigned int offs, unsigned int len, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  unsigned char with_qual;
  _Bool tmp_if_expr$1;
  if(!((4 & (signed int)ssp->statusflag) == 0))
    tmp_if_expr$1 = (signed int)sqp->type == 2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  with_qual = (unsigned char)tmp_if_expr$1;
  unsigned int slen;
  if(seqidx >= ssp->n_seq)
    return 29;

  else
  {
    slen = (unsigned int)(ssp->sop[seqidx + (signed long int)1] - ssp->sop[seqidx]);
    if(slen >= 1u)
    {
      if(!((1 & (signed int)ssp->statusflag) == 0))
        slen = slen - 1u;

    }

    if(offs >= slen)
      return 60;

    else
    {
      if(!(len >= 1u))
        len = slen;

      if(!(slen >= len + offs))
        len = slen - offs;

      blankSeq(sqp->datap);
      if(!(with_qual == 0))
        blankSeq(sqp->qualp);

      if(!((2 & (signed int)ssp->statusflag) == 0))
        errcode=uncompressSeq(sqp->datap, (unsigned int *)(void *)0, (unsigned char *)(void *)0, ssp->sqp, ssp->sop[seqidx] + (unsigned long int)offs, (unsigned long int)len, codecp);

      else
        errcode=appendSeqSegment(sqp->datap, (unsigned int *)(void *)0, (unsigned char *)(void *)0, ssp->sqp, (unsigned int)(ssp->sop[seqidx] + (unsigned long int)offs), len, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);
      if(errcode == 0 && !(with_qual == 0))
        errcode=appendSeqSegment(sqp->qualp, (unsigned int *)(void *)0, (unsigned char *)(void *)0, ssp->qqp, (unsigned int)(ssp->sop[seqidx] + (unsigned long int)offs), len, (char)0, (char)0, (const struct _SeqCodec *)(void *)0);

      return errcode;
    }
  }
}

// seqSetGetIndexAndOffset
// file sequence.h line 498
signed int seqSetGetIndexAndOffset(signed long int *seqidx, unsigned int *seqoffs, unsigned long int offs, const struct _SeqSet *ssp)
{
  signed long int s;
  signed long int a;
  signed long int b;
  if(offs >= ssp->sop[ssp->n_seq])
    return 29;

  else
    if(!(ssp->n_seq >= 1l))
      return -1;

    else
    {
      a = (signed long int)0;
      b = ssp->n_seq;
      while(!(a >= b + -1l))
      {
        s = (b + a) / (signed long int)2;
        if(!(offs >= ssp->sop[s]))
          b = s;

        else
          a = s;
      }
      if(!(seqidx == ((signed long int *)NULL)))
        *seqidx = a;

      if(!(seqoffs == ((unsigned int *)NULL)))
        *seqoffs = (unsigned int)ssp->sop[a];

      return 0;
    }
}

// seqSetGetOffsets
// file sequence.h line 456
signed long int seqSetGetOffsets(const struct _SeqSet *ssp, const unsigned long int **soffs)
{
  if(!(soffs == ((const unsigned long int **)NULL)))
    *soffs = ssp->sop;

  return ssp->n_seq;
}

// seqSetGetSeqDatByIndex
// file sequence.h line 509
unsigned int seqSetGetSeqDatByIndex(unsigned long int *offs, const char **name, signed long int seqidx, const struct _SeqSet *ssp)
{
  unsigned int slen;
  if(seqidx >= ssp->n_seq)
  {
    if(!(name == ((const char **)NULL)))
      *name = ((const char *)NULL);

    return (unsigned int)0;
  }

  else
  {
    if(!(name == ((const char **)NULL)))
      *name = ssp->namebasep + (signed long int)ssp->namoffs[seqidx];

    if(!(offs == ((unsigned long int *)NULL)))
      *offs = ssp->sop[seqidx];

    slen = (unsigned int)(ssp->sop[seqidx + (signed long int)1] - ssp->sop[seqidx]);
    return (((signed int)ssp->statusflag & 1) != 0 ? (slen > (unsigned int)0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? slen - (unsigned int)1 : slen;
  }
}

// seqSetGetSeqNumAndTotLen
// file sequence.h line 519
signed long int seqSetGetSeqNumAndTotLen(unsigned long int *totseqlen, const struct _SeqSet *ssp)
{
  if(!(totseqlen == ((unsigned long int *)NULL)))
  {
    *totseqlen = ssp->sop[ssp->n_seq];
    if(!((1 & (signed int)ssp->statusflag) == 0))
    {
      if(!((unsigned long int)ssp->n_seq >= *totseqlen))
        *totseqlen = *totseqlen - (unsigned long int)ssp->n_seq;

      else
        *totseqlen = (unsigned long int)0;
    }

  }

  return ssp->n_seq;
}

// seqSetReadBinFil
// file sequence.h line 444
struct _SeqSet * seqSetReadBinFil(signed int *errcode, const char *filnam)
{
  unsigned char is_endianid;
  unsigned char typ;
  unsigned int header[8l];
  unsigned int totsiz;
  unsigned int version;
  unsigned int headsiz = (unsigned int)8;
  signed long int i;
  signed long int seqnum_dat;
  unsigned int *seqlenp = (unsigned int *)(void *)0;
  unsigned long int seqsiz;
  unsigned long int namsiz;
  unsigned long int seqnum;
  unsigned long int j;
  unsigned int statusflg;
  struct _SeqSet *ssp = ((struct _SeqSet *)NULL);
  struct _IO_FILE *fp;
  fp=filioOpenForReading(errcode, &is_endianid, &totsiz, &typ, &version, &headsiz, header, filnam, SEQSET_FILNAMEXT);
  void *return_value_ecalloc$1;
  unsigned long int return_value_fread$2;
  signed long int tmp_post$3;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$5;
  signed int return_value_ferror$4;
  _Bool tmp_if_expr$9;
  signed int return_value_ferror$8;
  if(!(*errcode == 0))
    return ((struct _SeqSet *)NULL);

  else
    if(headsiz >= 9u || version >= 5u || !((signed int)typ == 1) || !(3u + version >= 4u) || !(headsiz >= 4u))
    {
      *errcode = 5;
      if(!(2u + version >= 4u))
        *errcode = 56;

      else
        if(!(headsiz == 8u))
          *errcode = 33;

      fclose(fp);
      return ((struct _SeqSet *)NULL);
    }

    else
    {
      if(version == 4u)
      {
        seqnum = ((unsigned long int)header[(signed long int)1] << 32) + (unsigned long int)header[(signed long int)0];
        namsiz = ((unsigned long int)header[(signed long int)3] << 32) + (unsigned long int)header[(signed long int)2];
        seqsiz = ((unsigned long int)header[(signed long int)5] << 32) + (unsigned long int)header[(signed long int)4];
        statusflg = header[(signed long int)6];
        if(seqnum >= 18446744073709551615ul)
          *errcode = 86;

        seqnum_dat = (signed long int)seqnum;
      }

      else
        if(version == 3u)
        {
          seqnum = (unsigned long int)header[(signed long int)0];
          namsiz = ((unsigned long int)header[(signed long int)2] << 32) + (unsigned long int)header[(signed long int)1];
          seqsiz = ((unsigned long int)header[(signed long int)4] << 32) + (unsigned long int)header[(signed long int)3];
          statusflg = header[(signed long int)5];
          if(seqnum >= 18446744073709551615ul)
            *errcode = 86;

          seqnum_dat = (signed long int)seqnum;
        }

        else
        {
          seqnum = (unsigned long int)header[(signed long int)0];
          namsiz = (unsigned long int)header[(signed long int)1];
          seqsiz = (unsigned long int)header[(signed long int)2];
          statusflg = header[(signed long int)3];
          if(1ul + seqnum >= 18446744073709551615ul)
            *errcode = 86;

          seqnum_dat = (signed long int)(seqnum + (unsigned long int)1);
        }
      if(!(*errcode == 0))
      {
        fclose(fp);
        return ((struct _SeqSet *)NULL);
      }

      else
        if(1ul + seqnum >= 18446744073709551615ul || statusflg >= 256u || namsiz >= 18446744073709551615ul || seqsiz >= 18446744073709551615ul || !(seqnum >= 1ul))
        {
          *errcode = 33;
          fclose(fp);
          return ((struct _SeqSet *)NULL);
        }

        else
        {
          if(1ul + seqnum >= 4097ul)
          {
            ssp=seqSetCreate(0, (unsigned char)statusflg);
            if(!(ssp == ((struct _SeqSet *)NULL)))
              *errcode=reallocSeqSet(ssp, (signed long int)(seqnum + (unsigned long int)1));

          }

          else
            ssp=seqSetCreate((signed int)(seqnum + (unsigned long int)1), (unsigned char)statusflg);
          if(ssp == ((struct _SeqSet *)NULL))
            *errcode = 2;

          if(*errcode == 0)
            *errcode=reallocSeqSetName(ssp, namsiz);

          if(*errcode == 0)
          {
            return_value_ecalloc$1=ecalloc((unsigned long int)seqnum_dat, sizeof(unsigned int) /*4ul*/ , "sequence.c", 2603);
            seqlenp = (unsigned int *)return_value_ecalloc$1;
            if(seqlenp == ((unsigned int *)NULL))
              *errcode = 2;

          }

          if(*errcode == 0)
          {
            return_value_fread$2=fread((void *)ssp->namebasep, sizeof(char) /*1ul*/ , namsiz, fp);
            if(!(return_value_fread$2 == namsiz))
              *errcode = 33;

          }

          if(!(*errcode == 0))
          {
            seqSetDelete(ssp);
            fclose(fp);
            return ((struct _SeqSet *)NULL);
          }

          else
          {
            ssp->namoffs[(signed long int)0] = (unsigned long int)0;
            i = (signed long int)1;
            j = (unsigned long int)0;
            for( ; (signed long int)seqnum >= i && !(j >= namsiz); j = j + 1ul)
              if(ssp->namebasep[(signed long int)j] == 0)
              {
                tmp_post$3 = i;
                i = i + 1l;
                ssp->namoffs[tmp_post$3] = j + (unsigned long int)1;
              }

            if(!(i + -1l == (signed long int)seqnum))
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = ssp->namoffs[(signed long int)seqnum] != namsiz ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
              *errcode = 47;

            else
            {
              unsigned long int return_value_fread$6;
              return_value_fread$6=fread((void *)seqlenp, sizeof(unsigned int) /*4ul*/ , (unsigned long int)seqnum_dat, fp);
              if(!(return_value_fread$6 == (unsigned long int)seqnum_dat))
                *errcode = 33;

              else
              {
                *errcode=readCompressedSeqOfKnownLength(ssp->sqp, fp, seqsiz);
                if(*errcode == 0)
                {
                  return_value_ferror$4=ferror(fp);
                  tmp_if_expr$5 = return_value_ferror$4 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$5 = (_Bool)0;
                if(tmp_if_expr$5)
                  *errcode = 14;

                else
                  if(is_endianid == 0)
                  {
                    unsigned long int nunit_seqsiz = seqsiz / (unsigned long int)10 + (unsigned long int)1;
                    if(!(nunit_seqsiz >= 4294967296ul))
                    {
                      filioSwapEndian(seqlenp, (unsigned int)seqnum_dat);
                      filioSwapEndian((unsigned int *)ssp->sqp->basep, (unsigned int)nunit_seqsiz);
                    }

                    else
                      *errcode = 33;
                  }

              }
              if(*errcode == 0)
              {
                if(version == 3u || version == 4u)
                {
                  ssp->sop[(signed long int)0] = (unsigned long int)0;
                  i = (signed long int)0;
                  for( ; !(i >= seqnum_dat); i = i + 1l)
                    ssp->sop[i + (signed long int)1] = ssp->sop[i] + (unsigned long int)seqlenp[i];
                }

                else
                {
                  i = (signed long int)0;
                  for( ; !(i >= seqnum_dat); i = i + 1l)
                    ssp->sop[i] = (unsigned long int)seqlenp[i];
                }
                if(!((4 & (signed int)ssp->statusflag) == 0))
                {
                  signed int return_value_reallocSeqBlocks$10;
                  return_value_reallocSeqBlocks$10=reallocSeqBlocks(ssp->qqp, seqsiz + (unsigned long int)1);
                  if(!(return_value_reallocSeqBlocks$10 == 0))
                    *errcode = 2;

                  else
                  {
                    unsigned long int return_value_fread$7;
                    return_value_fread$7=fread((void *)ssp->qqp->basep, sizeof(char) /*1ul*/ , seqsiz + (unsigned long int)1, fp);
                    if(!(return_value_fread$7 == 1ul + seqsiz))
                      tmp_if_expr$9 = (_Bool)1;

                    else
                    {
                      return_value_ferror$8=ferror(fp);
                      tmp_if_expr$9 = return_value_ferror$8 != 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$9)
                      *errcode = 14;

                    else
                    {
                      ssp->qqp->size = (unsigned long int)seqsiz;
                      if(!(ssp->sqp->size == ssp->qqp->size))
                        *errcode = 33;

                    }
                  }
                  if(*errcode == 0)
                  {
                    if(is_endianid == 0)
                      filioSwapEndian((unsigned int *)ssp->qqp->basep, (unsigned int)(seqsiz + (unsigned long int)1));

                  }

                }

              }

            }
            efclose(fp, "sequence.c", 2672);
            free((void *)seqlenp);
            ssp->n_seq = (signed long int)seqnum;
            if(!((2u & statusflg) == 0u))
              ssp->statusflag = ssp->statusflag | (unsigned char)2;

            return ssp;
          }
        }
    }
}

// seqSetWriteBinFil
// file sequence.h line 438
signed int seqSetWriteBinFil(const struct _SeqSet *ssp, const char *filnam)
{
  signed int errcode;
  struct _IO_FILE *fp;
  unsigned int headval[8l];
  unsigned int seqsiz;
  unsigned int *seqlenp;
  signed long int s;
  unsigned long int bigval;
  unsigned long int totsiz;
  unsigned long int seqnamsiz;
  signed int return_value_ferror$2;
  if(!(ssp->n_seq >= 1l))
    return -1;

  else
    if((2 & (signed int)ssp->statusflag) == 0)
      return 22;

    else
    {
      bigval = (unsigned long int)ssp->n_seq;
      headval[(signed long int)0] = (unsigned int)(bigval & (unsigned long int)-1);
      headval[(signed long int)1] = (unsigned int)(bigval >> 32);
      bigval = (unsigned long int)ssp->namoffs[ssp->n_seq];
      headval[(signed long int)2] = (unsigned int)(bigval & (unsigned long int)-1);
      headval[(signed long int)3] = (unsigned int)(bigval >> 32);
      bigval = (unsigned long int)ssp->sqp->size;
      headval[(signed long int)4] = (unsigned int)(bigval & (unsigned long int)-1);
      headval[(signed long int)5] = (unsigned int)(bigval >> 32);
      headval[(signed long int)6] = (unsigned int)ssp->statusflag;
      headval[(signed long int)7] = (unsigned int)0;
      seqnamsiz = (ssp->namoffs[ssp->n_seq] - (unsigned long int)1) / (unsigned long int)4 + (unsigned long int)1;
      seqsiz = (unsigned int)(ssp->sqp->size / (unsigned long int)10 + (unsigned long int)1);
      totsiz = (unsigned long int)((signed long int)((unsigned int)8 + seqsiz) + ssp->n_seq) + seqnamsiz;
      if(totsiz >= 4294967296ul)
        return 71;

      else
      {
        void *return_value_ecalloc$1;
        return_value_ecalloc$1=ecalloc((unsigned long int)ssp->n_seq, sizeof(unsigned int) /*4ul*/ , "sequence.c", 2485);
        seqlenp = (unsigned int *)return_value_ecalloc$1;
        if(seqlenp == ((unsigned int *)NULL))
          return 2;

        else
        {
          fp=filioOpenForWriting(&errcode, (unsigned int)totsiz, (unsigned char)1, (unsigned int)4, (unsigned int)8, headval, filnam, SEQSET_FILNAMEXT);
          if(!(errcode == 0))
          {
            efclose(fp, "sequence.c", 2493);
            return errcode;
          }

          else
          {
            fwrite((const void *)ssp->namebasep, sizeof(char) /*1ul*/ , ssp->namoffs[ssp->n_seq], fp);
            s = (signed long int)0;
            for( ; !(s >= ssp->n_seq); s = s + 1l)
              seqlenp[s] = (unsigned int)(ssp->sop[s + (signed long int)1] - ssp->sop[s]);
            fwrite((const void *)seqlenp, sizeof(unsigned int) /*4ul*/ , (unsigned long int)ssp->n_seq, fp);
            free((void *)seqlenp);
            seqlenp = (unsigned int *)(void *)0;
            errcode=writeCompressedSeq(fp, ssp->sqp);
            if(errcode == 0)
            {
              return_value_ferror$2=ferror(fp);
              if(!(return_value_ferror$2 == 0))
                errcode = 11;

            }

            if(errcode == 0)
            {
              if(!((4 & (signed int)ssp->statusflag) == 0))
              {
                if(!(ssp->sqp->size == ssp->qqp->size))
                  errcode = 47;

                else
                  fwrite((const void *)ssp->qqp->basep, sizeof(char) /*1ul*/ , ssp->qqp->size + (unsigned long int)1, fp);
              }

            }

            signed int return_value_efclose$3;
            return_value_efclose$3=efclose(fp, "sequence.c", 2518);
            return return_value_efclose$3;
          }
        }
      }
    }
}

// setInSampleIntervalInput
// file smalt.c line 725
static void setInSampleIntervalInput(struct _SmaltInput *inargp, const struct _InsSample *isamp)
{
  if(isamp == ((const struct _InsSample *)NULL))
    inargp->rival = 0;

  else
    insGetSample((signed int **)(void *)0, &inargp->rival, isamp);
}

// setKeyPos
// file hashidx.c line 197
static signed int setKeyPos(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr)
{
  unsigned int k = (unsigned int)(word & htp->wordmask);
  unsigned int tmp_post$1;
  if(htp->idx[(signed long int)(1u + k)] + -htp->idx[(signed long int)k] >= 1u)
  {
    tmp_post$1 = htp->idx[(signed long int)k];
    htp->idx[(signed long int)k] = htp->idx[(signed long int)k] + 1u;
    htp->pos[(signed long int)tmp_post$1] = tuplectr;
  }

  return 0;
}

// setMemALITRACK
// file alignment.c line 454
static signed int setMemALITRACK(struct _ALITRACK *btrkp, struct _ALIBAND *bandp)
{
  void *hp;
  unsigned long int newsiz;
  _Bool tmp_if_expr$1;
  if(bandp->s_left >= bandp->s_len)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = bandp->band_width < 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 47;

  else
  {
    newsiz = (unsigned long int)(bandp->band_width * (bandp->s_len - bandp->s_left));
    if(!(btrkp->n_alloc >= newsiz))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(!(btrkp->blksz + newsiz >= btrkp->n_alloc))
        tmp_if_expr$2 = btrkp->n_alloc > btrkp->n_alloc_thresh ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      newsiz = ((newsiz - (unsigned long int)1) / btrkp->blksz + (unsigned long int)1) * btrkp->blksz;
      hp=erealloc((void *)btrkp->bdp, newsiz * sizeof(unsigned char) /*1ul*/ , (unsigned long int)0, "alignment.c", 467);
      if(hp == NULL)
        return 2;

      btrkp->bdp = (unsigned char *)hp;
      btrkp->n_alloc = newsiz;
    }

    btrkp->max_j = 0;
    btrkp->max_i = btrkp->max_j;
    btrkp->max_scor = 0;
    return 0;
  }
}

// setScoreMatrix
// file score.c line 138
static signed int setScoreMatrix(struct _ScoreMatrix *amp, const struct _SeqCodec *scp, const struct ScorePenalties_ *penp)
{
  signed short int i;
  signed short int j;
  signed short int alphabetsiz;
  const char *alphabet;
  signed short int xmatch = (signed short int)((signed int)penp->penalty[(signed long int)1] - (signed int)penp->penalty[(signed long int)0]);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$1;
  if((signed int)xmatch >= 128 || !((signed int)xmatch >= -127))
    return 47;

  else
    if(amp == ((struct _ScoreMatrix *)NULL) || scp == ((const struct _SeqCodec *)NULL))
      return 15;

    else
    {
      alphabet=seqCodecGetAlphabet(scp, &alphabetsiz);
      if((signed int)alphabetsiz >= 9)
        return 47;

      else
      {
        amp->gap_init = penp->penalty[(signed long int)2];
        amp->gap_ext = penp->penalty[(signed long int)3];
        i = (signed short int)0;
        for( ; !((signed int)i >= 8); i = i + 1)
        {
          j = (signed short int)0;
          for( ; !((signed int)j >= 8); j = j + 1)
          {
            if((signed int)i >= (signed int)alphabetsiz || (signed int)j >= (signed int)alphabetsiz)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = (signed int)alphabet[(signed long int)i] == 78 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = (signed int)alphabet[(signed long int)j] == 78 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              amp->score[(signed long int)i][(signed long int)j] = (signed char)0;

            else
            {
              if((signed int)alphabet[(signed long int)i] == 88)
                tmp_if_expr$1 = (_Bool)1;

              else
                tmp_if_expr$1 = (signed int)alphabet[(signed long int)j] == 88 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$1)
                amp->score[(signed long int)i][(signed long int)j] = (signed char)xmatch;

              else
                if(j == i)
                  amp->score[(signed long int)i][(signed long int)j] = penp->penalty[(signed long int)0];

                else
                  amp->score[(signed long int)i][(signed long int)j] = penp->penalty[(signed long int)1];
            }
          }
        }
        amp->alphabetsiz = alphabetsiz;
        return 0;
      }
    }
}

// setSeq
// file sequence.c line 780
static signed int setSeq(struct _SEQSEQ *sp, const char *cp)
{
  char *hp;
  unsigned int i;
  const unsigned short int **return_value___ctype_b_loc$1;
  signed int return_value_reallocSeqBlocks$2;
  char *tmp_post$3;
  const char *tmp_post$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  if(cp == ((const char *)NULL))
    return 0;

  else
  {
    hp = sp->basep;
    for( ; !(*cp == 0); cp = cp + 1l)
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*cp]) == 0)
        break;

    }
    i = (unsigned int)0;
    for( ; !(*cp == 0) && !(i >= 4294967295u); i = i + 1u)
    {
      if((unsigned long int)(1u + i) >= sp->alloc_size)
      {
        return_value_reallocSeqBlocks$2=reallocSeqBlocks(sp, (unsigned long int)(i + (unsigned int)2));
        if(!(return_value_reallocSeqBlocks$2 == 0))
          return 2;

      }

      hp = sp->basep + (signed long int)i;
      tmp_post$3 = hp;
      hp = hp + 1l;
      tmp_post$4 = cp;
      cp = cp + 1l;
      *tmp_post$3 = *tmp_post$4;
    }
    for( ; i >= 1u; i = i - 1u)
    {
      return_value___ctype_b_loc$5=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)hp[-1l]]) == 0)
        break;

      hp = hp - 1l;
    }
    *hp = (char)0;
    if(i >= 4294967295u)
      return 36;

    else
    {
      sp->size = (unsigned long int)i;
      return 0;
    }
  }
}

// setWordPos
// file hashidx.c line 295
static signed int setWordPos(const struct _HashTable *htp, unsigned long int word, unsigned int tuplectr)
{
  unsigned int key;
  unsigned int key_hi;
  unsigned int word_hi;
  unsigned int pivot;
  unsigned int b;
  unsigned int a;
  word_hi = (unsigned int)((word & htp->wordmask_hi) >> (signed int)htp->nbits_lo);
  unsigned int return_value_hash32mix$1;
  return_value_hash32mix$1=hash32mix(word_hi);
  key_hi = return_value_hash32mix$1 % htp->keymod;
  key = (unsigned int)((unsigned long int)(key_hi << (signed int)htp->nbits_lo) + (word & htp->wordmask_lo));
  b = htp->idx[(signed long int)(key + (unsigned int)1)];
  _Bool tmp_if_expr$2;
  unsigned int tmp_post$3;
  if(!(b >= 1u))
    return 69;

  else
  {
    a = htp->idx[(signed long int)key];
    b = b - 1u;
    while(!(a >= b))
    {
      pivot = a + b >> 1;
      if(!(htp->wordidx[(signed long int)pivot] >= word_hi))
        a = pivot + (unsigned int)1;

      else
        b = pivot;
    }
    if(!(b >= a))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = htp->wordidx[(signed long int)b] != word_hi ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return 69;

    else
    {
      tmp_post$3 = htp->posidx[(signed long int)b];
      htp->posidx[(signed long int)b] = htp->posidx[(signed long int)b] + 1u;
      htp->pos[(signed long int)tmp_post$3] = tuplectr;
      return 0;
    }
  }
}

// setupFineHashTable
// file rmap.c line 495
static signed int setupFineHashTable(struct _HashTable *htfinep, struct _SeqFastq *sqbfp, const struct _SeqSet *ssp, const struct V_IVAL_ *ivr, const struct _HashTable *htp, const struct _SeqCodec *codecp)
{
  unsigned int npos_max = (unsigned int)134217728;
  signed int errcode;
  errcode=hashTableSetUp(htfinep, sqbfp, ssp, ivr, codecp, &npos_max, (char)0);
  if(errcode == 17)
  {
    signed int s = (signed int)(npos_max / (unsigned int)134217728 + (unsigned int)1);
    unsigned char nskip;
    unsigned char ktuplen;
    ktuplen=hashTableGetKtupLen(htp, &nskip);
    if(!(s >= (signed int)nskip) || !((signed int)ktuplen >= s))
    {
      hashTableReset(htfinep, (unsigned char)s);
      errcode=hashTableSetUp(htfinep, sqbfp, ssp, ivr, codecp, (unsigned int *)(void *)0, (char)0);
    }

  }

  if(errcode == 82)
    errcode = 17;

  return errcode;
}

// setupInterValFromResultSet
// file rmap.c line 354
static signed int setupInterValFromResultSet(struct V_IVAL_ *ivr, signed int dmin, signed int dmax, const struct _SeqFastq *readp, const struct _SeqFastq *matep, const struct _HashTable *htp, const struct _SeqSet *ssp, const struct _ResultSet *rsp)
{
  signed int errcode = 0;
  unsigned char nskip;
  unsigned char ktup;
  ktup=hashTableGetKtupLen(htp, &nskip);
  signed short int i;
  signed short int n;
  signed long int sx;
  unsigned int qs;
  unsigned int qe;
  unsigned int rs;
  unsigned int re;
  unsigned int delta;
  unsigned int rlen;
  unsigned int readlen;
  unsigned int matelen;
  signed long int tmp_lo;
  signed long int tmp_hi;
  unsigned short int status;
  signed long int nseq;
  nseq=seqSetGetOffsets(ssp, (const unsigned long int **)(void *)0);
  if(!(dmax >= dmin))
    return 29;

  else
  {
    seqFastqGetConstSequence(readp, &readlen, (char *)(void *)0);
    seqFastqGetConstSequence(matep, &matelen, (char *)(void *)0);
    delta = (unsigned int)(((signed long int)matelen * (signed long int)30) / (signed long int)100);
    resultSetGetScorStats(rsp, (signed int *)(void *)0, &n, (signed int *)(void *)0, (signed short int *)(void *)0);
    interValBlank(ivr);
    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)n); i = i + 1)
    {
      const struct _RESULT *rp;
      errcode=resultSetGetResultByRank(&rp, (signed int)i, rsp);
      if(!(errcode == 0))
        return errcode;

      errcode=resultGetData(&qs, &qe, &rs, &re, &sx, (signed int *)(void *)0, &status, rp);
      if(!(errcode == 0))
        return errcode;

      if(!(sx >= 0l) || (1 & (signed int)status) == 0 || sx >= nseq || rs >= re)
      {
        errcode = 47;
        break;
      }

      rlen=seqSetGetSeqDatByIndex((unsigned long int *)(void *)0, (const char **)(void *)0, sx, ssp);
      tmp_lo = (((signed long int)re + (signed long int)readlen) - (signed long int)qe) - (signed long int)dmax;
      if(tmp_lo >= (signed long int)rlen)
        tmp_lo = (signed long int)rlen - (signed long int)1;

      if(!(tmp_lo >= 1l))
        tmp_lo = (signed long int)0;

      tmp_hi = ((((signed long int)re + (signed long int)readlen + (signed long int)matelen + (signed long int)delta) - (signed long int)qe) - (signed long int)dmin) - (signed long int)ktup;
      if(tmp_hi >= (signed long int)rlen)
        tmp_hi = (signed long int)rlen - (signed long int)1;

      if(!(tmp_hi >= 1l))
        tmp_hi = (signed long int)0;

      if(tmp_hi >= tmp_lo)
      {
        errcode=interValAppend(ivr, (unsigned int)tmp_lo, (unsigned int)tmp_hi, sx, status);
        if(!(errcode == 0))
          break;

      }

      tmp_lo = (((signed long int)rs - (signed long int)qs) + (signed long int)dmin) - (signed long int)matelen;
      if(tmp_lo >= (signed long int)rlen)
        tmp_lo = (signed long int)rlen - (signed long int)1;

      if(!(tmp_lo >= 1l))
        tmp_lo = (signed long int)0;

      tmp_hi = ((((signed long int)rs - (signed long int)qs) + (signed long int)dmax) - (signed long int)ktup) + (signed long int)delta;
      if(tmp_hi >= (signed long int)rlen)
        tmp_hi = (signed long int)rlen - (signed long int)1;

      if(!(tmp_hi >= 1l))
        tmp_hi = (signed long int)0;

      if(tmp_hi >= tmp_lo)
      {
        errcode=interValAppend(ivr, (unsigned int)tmp_lo, (unsigned int)tmp_hi, sx, status);
        if(!(errcode == 0))
          break;

      }

    }
    return errcode;
  }
}

// setupOFFSIVALcbf
// file resultpairs.c line 195
static signed int setupOFFSIVALcbf(signed int *errcode, void *argp, const struct _RESULT *rp)
{
  unsigned int s_start;
  unsigned int s_end;
  unsigned int q_start;
  unsigned int q_end;
  signed long int sidx;
  unsigned short int status;
  unsigned int r0;
  struct _OFFSIVAL *ivp;
  struct SETUPOFFSIVALARG_ *p = (struct SETUPOFFSIVALARG_ *)argp;
  signed short int return_value_resultGetSWRank$1;
  return_value_resultGetSWRank$1=resultGetSWRank(rp);
  unsigned long int tmp_post$3;
  unsigned long int tmp_post$4;
  unsigned int tmp_if_expr$5;
  unsigned long int tmp_post$7;
  unsigned long int tmp_post$8;
  if(!((signed int)p->max_rank >= (signed int)return_value_resultGetSWRank$1))
    return 1;

  else
  {
    *errcode=resultGetData(&q_start, &q_end, &s_start, &s_end, &sidx, (signed int *)(void *)0, &status, rp);
    if(!(*errcode == 0))
      return 2;

    else
    {
      if(!((4 & (signed int)status) == 0))
        r0 = (s_end + q_start) - (unsigned int)2;

      else
        r0 = s_start - q_start;
      if(((unsigned long int *)p->oivr)[-1l] >= ((unsigned long int *)p->oivr)[-2l])
      {
        void *return_value_arrayRealloc$2;
        return_value_arrayRealloc$2=arrayRealloc((void *)p->oivr, (unsigned long int)0, (char)0, "resultpairs.c", 220);
        ivp = (struct _OFFSIVAL *)return_value_arrayRealloc$2;
        if(!(ivp == ((struct _OFFSIVAL *)NULL)))
        {
          p->oivr = ivp;
          tmp_post$3 = ((unsigned long int *)p->oivr)[(signed long int)-1];
          ((unsigned long int *)p->oivr)[(signed long int)-1] = ((unsigned long int *)p->oivr)[(signed long int)-1] + 1ul;
          ivp = p->oivr + (signed long int)tmp_post$3;
        }

      }

      else
      {
        tmp_post$4 = ((unsigned long int *)p->oivr)[(signed long int)-1];
        ((unsigned long int *)p->oivr)[(signed long int)-1] = ((unsigned long int *)p->oivr)[(signed long int)-1] + 1ul;
        ivp = p->oivr + (signed long int)tmp_post$4;
      }
      if(ivp == ((struct _OFFSIVAL *)NULL))
      {
        *errcode = 2;
        return 2;
      }

      else
      {
        ivp->rp = rp;
        ivp->sidx = sidx;
        ivp->status = status;
        if(r0 >= p->dmax)
        {
          ivp->upper = r0 - p->dmin;
          ivp->lower = r0 - p->dmax;
        }

        else
        {
          if(!(p->dmin >= r0))
            tmp_if_expr$5 = r0 - p->dmin;

          else
            tmp_if_expr$5 = (unsigned int)0;
          ivp->upper = tmp_if_expr$5;
          ivp->lower = (unsigned int)0;
        }
        if(((unsigned long int *)p->oivr)[-1l] >= ((unsigned long int *)p->oivr)[-2l])
        {
          void *return_value_arrayRealloc$6;
          return_value_arrayRealloc$6=arrayRealloc((void *)p->oivr, (unsigned long int)0, (char)0, "resultpairs.c", 236);
          ivp = (struct _OFFSIVAL *)return_value_arrayRealloc$6;
          if(!(ivp == ((struct _OFFSIVAL *)NULL)))
          {
            p->oivr = ivp;
            tmp_post$7 = ((unsigned long int *)p->oivr)[(signed long int)-1];
            ((unsigned long int *)p->oivr)[(signed long int)-1] = ((unsigned long int *)p->oivr)[(signed long int)-1] + 1ul;
            ivp = p->oivr + (signed long int)tmp_post$7;
          }

        }

        else
        {
          tmp_post$8 = ((unsigned long int *)p->oivr)[(signed long int)-1];
          ((unsigned long int *)p->oivr)[(signed long int)-1] = ((unsigned long int *)p->oivr)[(signed long int)-1] + 1ul;
          ivp = p->oivr + (signed long int)tmp_post$8;
        }
        if(ivp == ((struct _OFFSIVAL *)NULL))
        {
          *errcode = 2;
          return 2;
        }

        else
        {
          ivp->rp = rp;
          ivp->sidx = sidx;
          ivp->status = status;
          ivp->upper = r0 + p->dmax;
          ivp->lower = r0 + p->dmin;
          if((ivp + -1l)->upper >= ivp->lower)
          {
            (ivp - (signed long int)1)->upper = ivp->upper;
            ((unsigned long int *)p->oivr)[(signed long int)-1] = ((unsigned long int *)p->oivr)[(signed long int)-1] - 1ul;
          }

          return 0;
        }
      }
    }
  }
}

// signOffARGBUFF
// file threads.c line 395
static signed int signOffARGBUFF(struct _ARGBUFF *fifop)
{
  signed int n;
  pthread_mutex_lock(&fifop->mutex);
  fifop->nThreadsPushing = fifop->nThreadsPushing - 1;
  n = fifop->nThreadsPushing;
  pthread_mutex_unlock(&fifop->mutex);
  if(!(n >= 1))
    sem_post(&fifop->sema);

  return n;
}

// signOnARGBUFF
// file threads.c line 381
static signed int signOnARGBUFF(struct _ARGBUFF *fifop)
{
  signed int n;
  pthread_mutex_lock(&fifop->mutex);
  fifop->nThreadsPushing = fifop->nThreadsPushing + 1;
  n = fifop->nThreadsPushing;
  pthread_mutex_unlock(&fifop->mutex);
  return n;
}

// smoothGauss
// file insert.c line 253
static signed int smoothGauss(signed int *targetp, double *Kp, signed int bw, const signed int *sourcep, signed int n)
{
  signed int i;
  signed int j;
  signed int k;
  signed int jmax;
  double x;
  signed int cutoff = 3 * bw;
  signed int imax = 2 * cutoff + 1;
  double normfac;
  normfac=sqrt((double)2 * 3.14159265358979323846);
  double tt;
  if(!(n >= imax))
    bw = (n - 1) / (2 * 3);

  if(!(bw >= 3))
    bw = 3;

  cutoff = 3 * bw;
  imax = 2 * cutoff + 1;
  i = 0;
  for( ; !(i >= imax); i = i + 1)
  {
    x = (double)(i - cutoff) / (double)bw;
    double return_value_exp$1;
    return_value_exp$1=exp((-x * x) / (double)2);
    Kp[(signed long int)i] = return_value_exp$1 / normfac;
  }
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    targetp[(signed long int)i] = 0;
    if(!(cutoff >= i))
    {
      j = i - cutoff;
      k = 0;
    }

    else
    {
      j = 0;
      k = i;
    }
    if(!(cutoff + i >= n))
      jmax = i + cutoff;

    else
      jmax = n;
    tt = 0.0;
    for( ; !(j >= jmax); k = k + 1)
    {
      tt = tt + (double)sourcep[(signed long int)j] * Kp[(signed long int)k];
      j = j + 1;
    }
    targetp[(signed long int)i] = (signed int)(tt / (double)bw);
  }
  return 0;
}

// sort2UINTarraysByQuickSort
// file sort.c line 233
signed int sort2UINTarraysByQuickSort(signed int n, unsigned int *arr, unsigned int *brr)
{
  signed int i;
  signed int j;
  signed int i_left = 0;
  signed int i_middle;
  signed int i_right = n - 1;
  unsigned int partelem_a;
  unsigned int partelem_b;
  signed int index_stack[60l];
  signed int stack_size = 0;
  signed int errcode = 0;
  unsigned int temp;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  while((_Bool)1)
    if(!(i_right + -i_left >= 7))
    {
      j = i_left + 1;
      for( ; i_right >= j; j = j + 1)
      {
        partelem_a = arr[(signed long int)j];
        partelem_b = brr[(signed long int)j];
        i = j - 1;
        do
        {
          if(i >= i_left)
            tmp_if_expr$1 = arr[(signed long int)i] > partelem_a ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          arr[(signed long int)(i + 1)] = arr[(signed long int)i];
          brr[(signed long int)(i + 1)] = brr[(signed long int)i];
          i = i - 1;
        }
        while((_Bool)1);
        arr[(signed long int)(i + 1)] = partelem_a;
        brr[(signed long int)(i + 1)] = partelem_b;
      }
      if(stack_size == 0)
        return errcode;

      tmp_post$2 = stack_size;
      stack_size = stack_size - 1;
      i_right = index_stack[(signed long int)tmp_post$2];
      tmp_post$3 = stack_size;
      stack_size = stack_size - 1;
      i_left = index_stack[(signed long int)tmp_post$3];
    }

    else
    {
      i_middle = i_left + i_right >> 1;
      temp = arr[(signed long int)i_middle];
      arr[(signed long int)i_middle] = arr[(signed long int)(i_left + 1)];
      arr[(signed long int)(i_left + 1)] = temp;
      temp = brr[(signed long int)i_middle];
      brr[(signed long int)i_middle] = brr[(signed long int)(i_left + 1)];
      brr[(signed long int)(i_left + 1)] = temp;
      if(!(arr[(signed long int)i_right] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
        temp = brr[(signed long int)i_left];
        brr[(signed long int)i_left] = brr[(signed long int)i_right];
        brr[(signed long int)i_right] = temp;
      }

      if(!(arr[(signed long int)i_right] >= arr[(signed long int)(1 + i_left)]))
      {
        temp = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
        temp = brr[(signed long int)(i_left + 1)];
        brr[(signed long int)(i_left + 1)] = brr[(signed long int)i_right];
        brr[(signed long int)i_right] = temp;
      }

      if(!(arr[(signed long int)(1 + i_left)] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = temp;
        temp = brr[(signed long int)i_left];
        brr[(signed long int)i_left] = brr[(signed long int)(i_left + 1)];
        brr[(signed long int)(i_left + 1)] = temp;
      }

      i = i_left + 1;
      j = i_right;
      partelem_a = arr[(signed long int)(i_left + 1)];
      partelem_b = brr[(signed long int)(i_left + 1)];
      do
      {

      __CPROVER_DUMP_L13:
        ;
        i = i + 1;
        if(!(arr[(signed long int)i] >= partelem_a))
          goto __CPROVER_DUMP_L13;

        do
          j = j - 1;
        while(!(partelem_a >= arr[(signed long int)j]));
        if(!(j >= i))
          break;

        temp = arr[(signed long int)i];
        arr[(signed long int)i] = arr[(signed long int)j];
        arr[(signed long int)j] = temp;
        temp = brr[(signed long int)i];
        brr[(signed long int)i] = brr[(signed long int)j];
        brr[(signed long int)j] = temp;
      }
      while((_Bool)1);
      arr[(signed long int)(i_left + 1)] = arr[(signed long int)j];
      brr[(signed long int)(i_left + 1)] = brr[(signed long int)j];
      arr[(signed long int)j] = partelem_a;
      brr[(signed long int)j] = partelem_b;
      stack_size = stack_size + 2;
      if(stack_size >= 61)
        return 34;

      if(1 + i_right + -i >= j + -i_left)
      {
        index_stack[(signed long int)stack_size] = i_right;
        index_stack[(signed long int)(stack_size - 1)] = i;
        i_right = j - 1;
      }

      else
      {
        index_stack[(signed long int)stack_size] = j - 1;
        index_stack[(signed long int)(stack_size - 1)] = i_left;
        i_left = i;
      }
    }
}

// sortAndPrune
// file results.c line 759
static signed int sortAndPrune(struct _ResultSet *rsp)
{
  signed short int i;
  signed short int nres = (signed short int)((unsigned long int *)rsp->resr)[(signed long int)-1];
  struct _RESULT **dpp;
  struct _RESULT **prevpp;
  struct _RESULT **endpp;
  ((unsigned long int *)rsp->sortr)[(signed long int)-1] = (unsigned long int)0;
  i = (signed short int)0;
  unsigned long int tmp_post$2;
  unsigned long int tmp_post$3;
  for( ; !((signed int)i >= (signed int)nres); i = i + 1)
  {
    struct _RESULT *rp = rsp->resr + (signed long int)i;
    rp->serialno = i;
    rp->swrank = (signed short int)0;
    if(!((1 & (signed int)rp->status) == 0))
    {
      struct _RESULT **sortp;
      if(((unsigned long int *)rsp->sortr)[-1l] >= ((unsigned long int *)rsp->sortr)[-2l])
      {
        void *return_value_arrayRealloc$1;
        return_value_arrayRealloc$1=arrayRealloc((void *)rsp->sortr, (unsigned long int)0, (char)0, "results.c", 776);
        sortp = (struct _RESULT **)return_value_arrayRealloc$1;
        if(!(sortp == ((struct _RESULT **)NULL)))
        {
          rsp->sortr = sortp;
          tmp_post$2 = ((unsigned long int *)rsp->sortr)[(signed long int)-1];
          ((unsigned long int *)rsp->sortr)[(signed long int)-1] = ((unsigned long int *)rsp->sortr)[(signed long int)-1] + 1ul;
          sortp = rsp->sortr + (signed long int)tmp_post$2;
        }

      }

      else
      {
        tmp_post$3 = ((unsigned long int *)rsp->sortr)[(signed long int)-1];
        ((unsigned long int *)rsp->sortr)[(signed long int)-1] = ((unsigned long int *)rsp->sortr)[(signed long int)-1] + 1ul;
        sortp = rsp->sortr + (signed long int)tmp_post$3;
      }
      if(sortp == ((struct _RESULT **)NULL))
        return 2;

      *sortp = rp;
    }

  }
  rsp->status = rsp->status | (unsigned char)2;
  nres = (signed short int)((unsigned long int *)rsp->sortr)[(signed long int)-1];
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(!((signed int)nres >= 2))
  {
    rsp->status = rsp->status | (unsigned char)4;
    return 0;
  }

  else
  {
    qsort((void *)rsp->sortr, (unsigned long int)nres, sizeof(struct _RESULT *) /*8ul*/ , cmpRes);
    prevpp = rsp->sortr;
    endpp = rsp->sortr + (signed long int)nres;
    nres = (signed short int)1;
    dpp = rsp->sortr + (signed long int)1;
    for( ; !(dpp >= endpp); dpp = dpp + 1l)
    {
      if(!((*prevpp)->s_end >= (*dpp)->s_end))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (*dpp)->swatscor > (*prevpp)->swatscor ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (*dpp)->q_start < (*prevpp)->q_start ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (*dpp)->q_end > (*prevpp)->q_end ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (*dpp)->sidx != (*prevpp)->sidx ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = ((signed int)(*dpp)->status & 4) != ((signed int)(*prevpp)->status & 4) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
      {
        if((signed int)nres == 0x7fff)
          return 48;

        nres = nres + 1;
        prevpp = prevpp + 1l;
        if(!(prevpp >= dpp))
          *prevpp = *dpp;

      }

      else
        (*dpp)->status = (*dpp)->status & (unsigned short int)~1;
    }
    qsort((void *)rsp->sortr, (unsigned long int)nres, sizeof(struct _RESULT *) /*8ul*/ , cmpResOutput);
    ((unsigned long int *)rsp->sortr)[(signed long int)-1] = (unsigned long int)nres;
    if((signed int)nres >= 1)
    {
      struct _RESULT **rspp = rsp->sortr;
      rspp[(signed long int)0]->swrank = (signed short int)0;
      i = (signed short int)1;
      for( ; !((signed int)i >= (signed int)nres); i = i + 1)
      {
        if(!(rspp[(signed long int)((signed int)i + -1)]->swatscor >= rspp[(signed long int)i]->swatscor))
          return 47;

        if(!(rspp[(signed long int)i]->swatscor >= rspp[(signed long int)((signed int)i + -1)]->swatscor))
          rspp[(signed long int)i]->swrank = (signed short int)((signed int)rspp[(signed long int)((signed int)i - 1)]->swrank + 1);

        else
          rspp[(signed long int)i]->swrank = rspp[(signed long int)((signed int)i - 1)]->swrank;
      }
    }

    rsp->status = rsp->status | (unsigned char)4;
    return 0;
  }
}

// sortBySegmentAndSWscor
// file results.c line 669
static signed int sortBySegmentAndSWscor(struct _ResultSet *rsp)
{
  signed short int i;
  signed short int j;
  signed short int nres = (signed short int)((unsigned long int *)rsp->sortr)[(signed long int)-1];
  signed short int tmp_post$1;
  signed short int tmp_post$2;
  signed short int tmp_post$3;
  if(!((signed int)nres >= 1))
    return 0;

  else
  {
    if(!(((unsigned long int *)rsp->segsrtr)[-2l] >= (unsigned long int)nres))
    {
      void *sortBySegmentAndSWscor$$1$$1$$hp;
      sortBySegmentAndSWscor$$1$$1$$hp=arrayRealloc((void *)rsp->segsrtr, (unsigned long int)nres, (char)0, "results.c", 678);
      if(sortBySegmentAndSWscor$$1$$1$$hp == NULL)
        return 2;

      rsp->segsrtr = (struct _RESULT **)sortBySegmentAndSWscor$$1$$1$$hp;
    }

    if((unsigned long int)rsp->qsegno >= ((unsigned long int *)rsp->segnor)[-2l])
    {
      void *hp;
      hp=arrayRealloc((void *)rsp->segnor, (unsigned long int)((signed int)rsp->qsegno + 1), (char)0, "results.c", 684);
      if(hp == NULL)
        return 2;

      rsp->segnor = (signed short int *)hp;
    }

    i = (signed short int)0;
    for( ; !((signed int)i >= (signed int)nres); i = i + 1)
      rsp->segsrtr[(signed long int)i] = rsp->sortr[(signed long int)i];
    if((signed int)nres >= 2)
      qsort((void *)rsp->segsrtr, (unsigned long int)nres, sizeof(struct _RESULT *) /*8ul*/ , cmpResSegSW);

    ((unsigned long int *)rsp->segsrtr)[(signed long int)-1] = (unsigned long int)nres;
    j = (signed short int)0;
    tmp_post$1 = j;
    j = j + 1;
    rsp->segnor[(signed long int)tmp_post$1] = (signed short int)0;
    i = (signed short int)1;
    for( ; !((signed int)i >= (signed int)nres); i = i + 1)
    {
      if(!((signed int)rsp->segsrtr[(signed long int)i]->qsegx >= (signed int)rsp->segsrtr[(signed long int)((signed int)i + -1)]->qsegx))
        return 47;

      if(!((signed int)rsp->segsrtr[(signed long int)((signed int)i + -1)]->qsegx >= (signed int)rsp->segsrtr[(signed long int)i]->qsegx))
      {
        tmp_post$2 = j;
        j = j + 1;
        rsp->segnor[(signed long int)tmp_post$2] = i;
      }

    }
    tmp_post$3 = j;
    j = j + 1;
    rsp->segnor[(signed long int)tmp_post$3] = nres;
    ((unsigned long int *)rsp->segnor)[(signed long int)-1] = (unsigned long int)j;
    return (signed int)j == (signed int)rsp->qsegno + 1 ? 0 : 47;
  }
}

// sortMultiKey
// file sort.c line 595
void sortMultiKey(const char **x, signed int num, signed int maxdepth)
{
  mksort(x, num, 0, maxdepth);
}

// sortSufficesByMultiKeyQuickSort
// file sort.c line 607
void sortSufficesByMultiKeyQuickSort(const char *hstrp, unsigned int *sfxidxp, unsigned int nsfx, signed short int startdepth, signed short int maxdepth)
{
  mkeyQSortSuffix(hstrp, sfxidxp, nsfx, startdepth, maxdepth);
}

// sortUINT32arrayByQuickSort
// file sort.c line 333
signed int sortUINT32arrayByQuickSort(signed int n, unsigned int *arr)
{
  signed int i;
  signed int j;
  signed int i_left = 0;
  signed int i_middle;
  signed int i_right = n - 1;
  unsigned int partelem;
  signed int index_stack[60l];
  signed int stack_size = 0;
  signed int errcode = 0;
  unsigned int temp;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  while((_Bool)1)
    if(!(i_right + -i_left >= 7))
    {
      j = i_left + 1;
      for( ; i_right >= j; j = j + 1)
      {
        partelem = arr[(signed long int)j];
        i = j - 1;
        do
        {
          if(i >= i_left)
            tmp_if_expr$1 = arr[(signed long int)i] > partelem ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          arr[(signed long int)(i + 1)] = arr[(signed long int)i];
          i = i - 1;
        }
        while((_Bool)1);
        arr[(signed long int)(i + 1)] = partelem;
      }
      if(stack_size == 0)
        return errcode;

      tmp_post$2 = stack_size;
      stack_size = stack_size - 1;
      i_right = index_stack[(signed long int)tmp_post$2];
      tmp_post$3 = stack_size;
      stack_size = stack_size - 1;
      i_left = index_stack[(signed long int)tmp_post$3];
    }

    else
    {
      i_middle = i_left + i_right >> 1;
      temp = arr[(signed long int)i_middle];
      arr[(signed long int)i_middle] = arr[(signed long int)(i_left + 1)];
      arr[(signed long int)(i_left + 1)] = temp;
      if(!(arr[(signed long int)i_right] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
      }

      if(!(arr[(signed long int)i_right] >= arr[(signed long int)(1 + i_left)]))
      {
        temp = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
      }

      if(!(arr[(signed long int)(1 + i_left)] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = temp;
      }

      i = i_left + 1;
      j = i_right;
      partelem = arr[(signed long int)(i_left + 1)];
      do
      {

      __CPROVER_DUMP_L13:
        ;
        i = i + 1;
        if(!(arr[(signed long int)i] >= partelem))
          goto __CPROVER_DUMP_L13;

        do
          j = j - 1;
        while(!(partelem >= arr[(signed long int)j]));
        if(!(j >= i))
          break;

        temp = arr[(signed long int)i];
        arr[(signed long int)i] = arr[(signed long int)j];
        arr[(signed long int)j] = temp;
      }
      while((_Bool)1);
      arr[(signed long int)(i_left + 1)] = arr[(signed long int)j];
      arr[(signed long int)j] = partelem;
      stack_size = stack_size + 2;
      if(stack_size >= 61)
        return 34;

      if(1 + i_right + -i >= j + -i_left)
      {
        index_stack[(signed long int)stack_size] = i_right;
        index_stack[(signed long int)(stack_size - 1)] = i;
        i_right = j - 1;
      }

      else
      {
        index_stack[(signed long int)stack_size] = j - 1;
        index_stack[(signed long int)(stack_size - 1)] = i_left;
        i_left = i;
      }
    }
}

// sortUINT64andUINT32ArraysByQuickSort
// file sort.h line 50
signed int sortUINT64andUINT32ArraysByQuickSort(signed int n, unsigned long int *arr, unsigned int *brr)
{
  signed int i;
  signed int j;
  signed int i_left = 0;
  signed int i_middle;
  signed int i_right = n - 1;
  unsigned long int partelem_a;
  unsigned long int temp;
  unsigned int partelem_b;
  unsigned int temp2;
  signed int index_stack[60l];
  signed int stack_size = 0;
  signed int errcode = 0;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  while((_Bool)1)
    if(!(i_right + -i_left >= 7))
    {
      j = i_left + 1;
      for( ; i_right >= j; j = j + 1)
      {
        partelem_a = arr[(signed long int)j];
        partelem_b = brr[(signed long int)j];
        i = j - 1;
        do
        {
          if(i >= i_left)
            tmp_if_expr$1 = arr[(signed long int)i] > partelem_a ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          arr[(signed long int)(i + 1)] = arr[(signed long int)i];
          brr[(signed long int)(i + 1)] = brr[(signed long int)i];
          i = i - 1;
        }
        while((_Bool)1);
        arr[(signed long int)(i + 1)] = partelem_a;
        brr[(signed long int)(i + 1)] = partelem_b;
      }
      if(stack_size == 0)
        return errcode;

      tmp_post$2 = stack_size;
      stack_size = stack_size - 1;
      i_right = index_stack[(signed long int)tmp_post$2];
      tmp_post$3 = stack_size;
      stack_size = stack_size - 1;
      i_left = index_stack[(signed long int)tmp_post$3];
    }

    else
    {
      i_middle = i_left + i_right >> 1;
      temp = arr[(signed long int)i_middle];
      arr[(signed long int)i_middle] = arr[(signed long int)(i_left + 1)];
      arr[(signed long int)(i_left + 1)] = temp;
      temp2 = brr[(signed long int)i_middle];
      brr[(signed long int)i_middle] = brr[(signed long int)(i_left + 1)];
      brr[(signed long int)(i_left + 1)] = temp2;
      if(!(arr[(signed long int)i_right] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
        temp2 = brr[(signed long int)i_left];
        brr[(signed long int)i_left] = brr[(signed long int)i_right];
        brr[(signed long int)i_right] = temp2;
      }

      if(!(arr[(signed long int)i_right] >= arr[(signed long int)(1 + i_left)]))
      {
        temp = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
        temp2 = brr[(signed long int)(i_left + 1)];
        brr[(signed long int)(i_left + 1)] = brr[(signed long int)i_right];
        brr[(signed long int)i_right] = temp2;
      }

      if(!(arr[(signed long int)(1 + i_left)] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = temp;
        temp2 = brr[(signed long int)i_left];
        brr[(signed long int)i_left] = brr[(signed long int)(i_left + 1)];
        brr[(signed long int)(i_left + 1)] = temp2;
      }

      i = i_left + 1;
      j = i_right;
      partelem_a = arr[(signed long int)(i_left + 1)];
      partelem_b = brr[(signed long int)(i_left + 1)];
      do
      {

      __CPROVER_DUMP_L13:
        ;
        i = i + 1;
        if(!(arr[(signed long int)i] >= partelem_a))
          goto __CPROVER_DUMP_L13;

        do
          j = j - 1;
        while(!(partelem_a >= arr[(signed long int)j]));
        if(!(j >= i))
          break;

        temp = arr[(signed long int)i];
        arr[(signed long int)i] = arr[(signed long int)j];
        arr[(signed long int)j] = temp;
        temp2 = brr[(signed long int)i];
        brr[(signed long int)i] = brr[(signed long int)j];
        brr[(signed long int)j] = temp2;
      }
      while((_Bool)1);
      arr[(signed long int)(i_left + 1)] = arr[(signed long int)j];
      brr[(signed long int)(i_left + 1)] = brr[(signed long int)j];
      arr[(signed long int)j] = partelem_a;
      brr[(signed long int)j] = partelem_b;
      stack_size = stack_size + 2;
      if(stack_size >= 61)
        return 34;

      if(1 + i_right + -i >= j + -i_left)
      {
        index_stack[(signed long int)stack_size] = i_right;
        index_stack[(signed long int)(stack_size - 1)] = i;
        i_right = j - 1;
      }

      else
      {
        index_stack[(signed long int)stack_size] = j - 1;
        index_stack[(signed long int)(stack_size - 1)] = i_left;
        i_left = i;
      }
    }
}

// sortUINT64arrayByQuickSort
// file sort.c line 415
signed int sortUINT64arrayByQuickSort(signed int n, unsigned long int *arr)
{
  signed int i;
  signed int j;
  signed int i_left = 0;
  signed int i_middle;
  signed int i_right = n - 1;
  unsigned long int partelem;
  signed int index_stack[60l];
  signed int stack_size = 0;
  signed int errcode = 0;
  unsigned long int temp;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  while((_Bool)1)
    if(!(i_right + -i_left >= 7))
    {
      j = i_left + 1;
      for( ; i_right >= j; j = j + 1)
      {
        partelem = arr[(signed long int)j];
        i = j - 1;
        do
        {
          if(i >= i_left)
            tmp_if_expr$1 = arr[(signed long int)i] > partelem ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          arr[(signed long int)(i + 1)] = arr[(signed long int)i];
          i = i - 1;
        }
        while((_Bool)1);
        arr[(signed long int)(i + 1)] = partelem;
      }
      if(stack_size == 0)
        return errcode;

      tmp_post$2 = stack_size;
      stack_size = stack_size - 1;
      i_right = index_stack[(signed long int)tmp_post$2];
      tmp_post$3 = stack_size;
      stack_size = stack_size - 1;
      i_left = index_stack[(signed long int)tmp_post$3];
    }

    else
    {
      i_middle = i_left + i_right >> 1;
      temp = arr[(signed long int)i_middle];
      arr[(signed long int)i_middle] = arr[(signed long int)(i_left + 1)];
      arr[(signed long int)(i_left + 1)] = temp;
      if(!(arr[(signed long int)i_right] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
      }

      if(!(arr[(signed long int)i_right] >= arr[(signed long int)(1 + i_left)]))
      {
        temp = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = arr[(signed long int)i_right];
        arr[(signed long int)i_right] = temp;
      }

      if(!(arr[(signed long int)(1 + i_left)] >= arr[(signed long int)i_left]))
      {
        temp = arr[(signed long int)i_left];
        arr[(signed long int)i_left] = arr[(signed long int)(i_left + 1)];
        arr[(signed long int)(i_left + 1)] = temp;
      }

      i = i_left + 1;
      j = i_right;
      partelem = arr[(signed long int)(i_left + 1)];
      do
      {

      __CPROVER_DUMP_L13:
        ;
        i = i + 1;
        if(!(arr[(signed long int)i] >= partelem))
          goto __CPROVER_DUMP_L13;

        do
          j = j - 1;
        while(!(partelem >= arr[(signed long int)j]));
        if(!(j >= i))
          break;

        temp = arr[(signed long int)i];
        arr[(signed long int)i] = arr[(signed long int)j];
        arr[(signed long int)j] = temp;
      }
      while((_Bool)1);
      arr[(signed long int)(i_left + 1)] = arr[(signed long int)j];
      arr[(signed long int)j] = partelem;
      stack_size = stack_size + 2;
      if(stack_size >= 61)
        return 34;

      if(1 + i_right + -i >= j + -i_left)
      {
        index_stack[(signed long int)stack_size] = i_right;
        index_stack[(signed long int)(stack_size - 1)] = i;
        i_right = j - 1;
      }

      else
      {
        index_stack[(signed long int)stack_size] = j - 1;
        index_stack[(signed long int)(stack_size - 1)] = i_left;
        i_left = i;
      }
    }
}

// sort_int32_t_quicksort
// file insert.c line 134
static signed int sort_int32_t_quicksort(struct V_int32_t_ *p)
{
  signed int n = (signed int)p->n;
  signed int i;
  signed int j;
  signed int im;
  signed int il = 0;
  signed int ir = n - 1;
  signed int errcode = 0;
  signed int stksz = 0;
  signed int idxstk[60l];
  signed int el;
  signed int tmp;
  signed int *arr = p->vp;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  while((_Bool)1)
    if(!(ir + -il >= 7))
    {
      j = il + 1;
      for( ; ir >= j; j = j + 1)
      {
        el = arr[(signed long int)j];
        i = j - 1;
        do
        {
          if(i >= il)
            tmp_if_expr$1 = arr[(signed long int)i] > el ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(!tmp_if_expr$1)
            break;

          arr[(signed long int)(i + 1)] = arr[(signed long int)i];
          i = i - 1;
        }
        while((_Bool)1);
        arr[(signed long int)(i + 1)] = el;
      }
      if(stksz == 0)
        return errcode;

      tmp_post$2 = stksz;
      stksz = stksz - 1;
      ir = idxstk[(signed long int)tmp_post$2];
      tmp_post$3 = stksz;
      stksz = stksz - 1;
      il = idxstk[(signed long int)tmp_post$3];
    }

    else
    {
      im = il + ir >> 1;
      tmp = arr[(signed long int)im];
      arr[(signed long int)im] = arr[(signed long int)(il + 1)];
      arr[(signed long int)(il + 1)] = tmp;
      if(!(arr[(signed long int)ir] >= arr[(signed long int)il]))
      {
        tmp = arr[(signed long int)il];
        arr[(signed long int)il] = arr[(signed long int)ir];
        arr[(signed long int)ir] = tmp;
      }

      if(!(arr[(signed long int)ir] >= arr[(signed long int)(1 + il)]))
      {
        tmp = arr[(signed long int)(il + 1)];
        arr[(signed long int)(il + 1)] = arr[(signed long int)ir];
        arr[(signed long int)ir] = tmp;
      }

      if(!(arr[(signed long int)(1 + il)] >= arr[(signed long int)il]))
      {
        tmp = arr[(signed long int)il];
        arr[(signed long int)il] = arr[(signed long int)(il + 1)];
        arr[(signed long int)(il + 1)] = tmp;
      }

      i = il + 1;
      j = ir;
      el = arr[(signed long int)(il + 1)];
      do
      {

      __CPROVER_DUMP_L13:
        ;
        i = i + 1;
        if(!(arr[(signed long int)i] >= el))
          goto __CPROVER_DUMP_L13;

        do
          j = j - 1;
        while(!(el >= arr[(signed long int)j]));
        if(!(j >= i))
          break;

        tmp = arr[(signed long int)i];
        arr[(signed long int)i] = arr[(signed long int)j];
        arr[(signed long int)j] = tmp;
      }
      while((_Bool)1);
      arr[(signed long int)(il + 1)] = arr[(signed long int)j];
      arr[(signed long int)j] = el;
      stksz = stksz + 2;
      if(stksz >= 61)
        return 34;

      if(1 + ir + -i >= j + -il)
      {
        idxstk[(signed long int)stksz] = ir;
        idxstk[(signed long int)(stksz - 1)] = i;
        ir = j - 1;
      }

      else
      {
        idxstk[(signed long int)stksz] = j - 1;
        idxstk[(signed long int)(stksz - 1)] = il;
        il = i;
      }
    }
}

// splitMultiSpan
// file results.c line 1472
static signed int splitMultiSpan(struct _RESULT **resr, const unsigned int residx, struct _DiffStr *diffstrbufp, struct _DiffStr *diffstrp, struct _SeqFastq *sqbufp, signed long int so, signed long int eo, const struct _ScoreProfile *scpp, const struct _ScoreProfile *scpRCp, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  signed int i;
  signed int n;
  signed int idx;
  char code;
  char *seqstr;
  unsigned char isReverseComplement;
  signed int curr_start;
  signed int curr_end;
  signed int s_start;
  signed int s_end;
  signed int q_start;
  signed int q_end;
  const unsigned long int *ofp;
  signed long int nseq;
  nseq=seqSetGetOffsets(ssp, &ofp);
  struct _RESULT *rp;
  const struct _ScoreProfile *scprofp;
  unsigned int seqlen;
  unsigned int profiled_seqlen;
  unsigned int profiled_seqlenRC;
  scoreGetProfile((signed short int *)(void *)0, &profiled_seqlen, (signed char *)(void *)0, (signed char *)(void *)0, scpp);
  scoreGetProfile((signed short int *)(void *)0, &profiled_seqlenRC, (signed char *)(void *)0, (signed char *)(void *)0, scpRCp);
  _Bool tmp_if_expr$1;
  unsigned long int tmp_if_expr$2;
  unsigned long int tmp_post$4;
  unsigned long int tmp_post$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(!(profiled_seqlen == profiled_seqlenRC))
    return 47;

  else
  {
    if(so >= eo || (unsigned long int)residx >= ((unsigned long int *)*resr)[-1l] || !(nseq >= eo) || !(so >= 0l))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (*resr + (signed long int)residx)->s_start <= ofp[so] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return 47;

    else
    {
      rp = *resr + (signed long int)residx;
      isReverseComplement = (unsigned char)(((signed int)rp->status & 4) != 0);
      if(!(isReverseComplement == 0))
        scprofp = scpRCp;

      else
        scprofp = scpp;
      n = (signed int)(eo - so);
      i = 0;
      for( ; !(i >= n); i = i + 1)
      {
        struct _RESULT *hp;
        unsigned int q_start_0based_inprofil;
        idx = (signed int)(so + (signed long int)i);
        if(!(ofp[(signed long int)idx] >= rp->s_start))
          curr_start = 0;

        else
          curr_start = (signed int)((ofp[(signed long int)idx] - rp->s_start) + (unsigned long int)1);
        if(ofp[(signed long int)(1 + idx)] >= rp->s_end)
          tmp_if_expr$2 = rp->s_end;

        else
          tmp_if_expr$2 = ofp[(signed long int)(idx + 1)];
        curr_end = (signed int)(tmp_if_expr$2 - rp->s_start);
        errcode=diffStrSegment(diffstrbufp, diffstrp->dstrp + (signed long int)rp->stroffs, curr_start, curr_end, &s_start, &s_end, &q_start, &q_end);
        if(!(errcode == 0))
        {
          if(errcode == 75)
            goto __CPROVER_DUMP_L31;

          else
            return errcode;
        }

        if(((unsigned long int *)*resr)[-1l] >= ((unsigned long int *)*resr)[-2l])
        {
          void *return_value_arrayRealloc$3;
          return_value_arrayRealloc$3=arrayRealloc((void *)*resr, (unsigned long int)0, (char)0, "results.c", 1579);
          hp = (struct _RESULT *)return_value_arrayRealloc$3;
          if(!(hp == ((struct _RESULT *)NULL)))
          {
            *resr = hp;
            tmp_post$4 = ((unsigned long int *)*resr)[(signed long int)-1];
            ((unsigned long int *)*resr)[(signed long int)-1] = ((unsigned long int *)*resr)[(signed long int)-1] + 1ul;
            hp = *resr + (signed long int)tmp_post$4;
          }

        }

        else
        {
          tmp_post$5 = ((unsigned long int *)*resr)[(signed long int)-1];
          ((unsigned long int *)*resr)[(signed long int)-1] = ((unsigned long int *)*resr)[(signed long int)-1] + 1ul;
          hp = *resr + (signed long int)tmp_post$5;
        }
        if(hp == ((struct _RESULT *)NULL))
          return 2;

        rp = *resr + (signed long int)residx;
        *hp = *rp;
        hp->stroffs = diffstrp->len;
        hp->strlen = diffstrbufp->len;
        errcode=diffStrAppend(diffstrp, diffstrbufp);
        if(!(errcode == 0))
          return errcode;

        if(!(isReverseComplement == 0))
        {
          hp->q_start = rp->q_end - (unsigned int)q_end;
          hp->q_end = rp->q_end - (unsigned int)q_start;
          q_start_0based_inprofil = profiled_seqlen - hp->q_end;
        }

        else
        {
          hp->q_start = rp->q_start + (unsigned int)q_start;
          hp->q_end = rp->q_start + (unsigned int)q_end;
          q_start_0based_inprofil = hp->q_start - (unsigned int)1;
        }
        if(!(hp->q_end >= hp->q_start))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = hp->q_end > profiled_seqlen ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          return 47;

        hp->s_start = (rp->s_start + (unsigned long int)s_start) - ofp[(signed long int)idx];
        hp->s_end = (rp->s_start + (unsigned long int)s_end) - ofp[(signed long int)idx];
        if(!(hp->s_end >= hp->s_start))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = hp->s_end - hp->s_start >= (unsigned long int)0x7fffffff ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          return 48;

        hp->sidx = (signed long int)idx;
        hp->status = hp->status & (unsigned short int)~8;
        hp->status = hp->status | (unsigned short int)1;
        errcode=seqSetFetchSegmentBySequence(sqbufp, hp->sidx, (unsigned int)(hp->s_start - (unsigned long int)1), (unsigned int)(((unsigned long int)(unsigned int)hp->s_end - hp->s_start) + (unsigned long int)1), ssp, codecp);
        if(!(errcode == 0))
          return errcode;

        seqstr=seqFastqGetSequence(sqbufp, &seqlen, &code);
        if(!((signed int)code == 1))
        {
          errcode=seqFastqEncode(sqbufp, codecp);
          if(!(errcode == 0))
            return errcode;

        }

        if(seqlen >= 2147483648u)
          return 48;

        errcode=aliScoreDiffStr(&hp->swatscor, seqstr, (signed int)seqlen, q_start_0based_inprofil, diffstrp->dstrp + (signed long int)hp->stroffs, hp->strlen, scprofp);
        if(!(errcode == 0))
          return errcode;


      __CPROVER_DUMP_L31:
        ;
      }
      return 0;
    }
  }
}

// sprintfDiffStrPlain
// file diffstr.c line 286
static signed int sprintfDiffStrPlain(char *sp, const unsigned char *dstrp)
{
  const unsigned char *ucp;
  signed int nchar = 0;
  signed int return_value_sprintf$1;
  if(!(dstrp == ((const unsigned char *)NULL)))
  {
    ucp = dstrp;
    for( ; !(*ucp == 0); ucp = ucp + 1l)
    {
      return_value_sprintf$1=sprintf(sp + (signed long int)nchar, "%c%i", DIFFSTR_SYMBOLS[(signed long int)((signed int)*ucp >> 6)], (signed short int)((signed int)*ucp & 63));
      nchar = nchar + return_value_sprintf$1;
    }
  }

  return nchar;
}

// sprintfDiffStrRaw
// file diffstr.c line 262
static signed int sprintfDiffStrRaw(char *sp, const unsigned char *dstrp)
{
  const unsigned char *ucp;
  signed int nchar = 0;
  signed int return_value_sprintf$1;
  return_value_sprintf$1=sprintf(sp, "(");
  nchar = nchar + return_value_sprintf$1;
  signed int return_value_sprintf$2;
  if(!(dstrp == ((const unsigned char *)NULL)))
  {
    ucp = dstrp;
    for( ; !(*ucp == 0); ucp = ucp + 1l)
    {
      return_value_sprintf$2=sprintf(sp + (signed long int)nchar, "%c:%2.2hi|", DIFFSTR_SYMBOLS[(signed long int)((signed int)*ucp >> 6)], (signed short int)((signed int)*ucp & 63));
      nchar = nchar + return_value_sprintf$2;
    }
  }

  signed int return_value_sprintf$3;
  return_value_sprintf$3=sprintf(sp + (signed long int)nchar, "M:00)");
  nchar = nchar + return_value_sprintf$3;
  return nchar;
}

// strMessageLevel
// file elib.c line 268
static const char * strMessageLevel(unsigned char level)
{
  switch((signed int)level)
  {
    case 2:
      return "ERROR";
    case 3:
      return "WARNING";
    case 4:
      return "REPORT";
    default:
      return "UNKNOWN";
  }
}

// sumQualOverMisMatch
// file results.c line 232
static signed int sumQualOverMisMatch(signed int *qualsum_ali, unsigned char with_nonali, const char *qualstrp, const unsigned int slen, unsigned int pos_start, unsigned int pos_end, const unsigned char *dstrp)
{
  unsigned char q;
  unsigned int spos;
  unsigned int qs;
  unsigned char gap;
  unsigned char typ;
  const unsigned char *dp;
  if(!(pos_end >= pos_start))
    return 47;

  else
  {
    *qualsum_ali = 0;
    qs = (unsigned int)0;
    spos = pos_start > (unsigned int)0 ? pos_start - (unsigned int)1 : (unsigned int)0;
    dp = dstrp;
    for( ; !(*dp == 0); dp = dp + 1l)
    {
      typ = (unsigned char)((signed int)*dp >> 6);
      gap = (unsigned char)((signed int)*dp & 63);
      spos = spos + (unsigned int)gap;
      if(!((signed int)typ == 1))
      {
        if((signed int)typ == 3)
        {
          if(dp[1l] == 0)
            goto __CPROVER_DUMP_L6;

          if(spos >= slen || !(spos >= 1u))
            return 47;

          q = (unsigned char)qualstrp[(signed long int)spos];
          if(!((signed int)q >= 33))
            return 67;

          qs = qs + ((unsigned int)q - (unsigned int)33);
          if(qs >= 2147483648u)
            return 48;

        }

        spos = spos + 1u;
      }


    __CPROVER_DUMP_L6:
      ;
    }
    if(!(spos == pos_end))
      return 47;

    else
    {
      if(!(with_nonali == 0))
      {
        spos = (unsigned int)0;
        for( ; !(spos >= pos_start + 4294967295u); spos = spos + 1u)
        {
          q = (unsigned char)qualstrp[(signed long int)spos];
          if(!((signed int)q >= 33))
            return 67;

          qs = qs + ((unsigned int)q - (unsigned int)33);
          if(qs >= 2147483648u)
            return 48;

        }
        spos = pos_end;
        for( ; !(spos >= slen); spos = spos + 1u)
        {
          q = (unsigned char)qualstrp[(signed long int)spos];
          if(!((signed int)q >= 33))
            return 67;

          qs = qs + ((unsigned int)q - (unsigned int)33);
          if(qs >= 2147483648u)
            return 48;

        }
      }

      *qualsum_ali = (signed int)qs;
      return 0;
    }
  }
}

// swSIMDAlignStriped
// file swsimd.h line 47
signed int swSIMDAlignStriped(signed int *maxscor, const struct _AliBuffer *abp, const struct _ScoreProfile *profp, const char *unprofiled_seqp, signed int unprofiled_seqlen)
{
  signed int errcode;
  unsigned char bytscor;
  unsigned short int shortscor;
  *maxscor = 0;
  errcode=alignSmiWatByteStriped(&bytscor, abp, profp, unprofiled_seqp, unprofiled_seqlen);
  if(errcode == 41)
  {
    errcode=alignSmiWatShortStriped(&shortscor, abp, profp, unprofiled_seqp, unprofiled_seqlen);
    if(errcode == 0)
      *maxscor = (signed int)shortscor;

  }

  else
    if(errcode == 0)
      *maxscor = (signed int)bytscor;

  return errcode;
}

// testProperPair
// file resultpairs.c line 135
static unsigned char testProperPair(signed int isize, unsigned char iflag, signed int dmin, signed int dmax, unsigned char libcode)
{
  unsigned char mapflg = (unsigned char)0;
  if(!(isize >= 0))
  {
    if(isize >= -dmax && -dmin >= isize)
      mapflg = mapflg | (unsigned char)8;

    if((signed int)libcode == 4)
      mapflg = mapflg | (unsigned char)4;

    else
      if((signed int)libcode == 1)
      {
        if((2 & (signed int)iflag) == 0 && !((1 & (signed int)iflag) == 0) && !((8 & (signed int)iflag) == 0))
          mapflg = mapflg | (unsigned char)4;

      }

      else
        if((signed int)libcode == 2)
        {
          if((1 & (signed int)iflag) == 0 && !((2 & (signed int)iflag) == 0) && !((8 & (signed int)iflag) == 0))
            mapflg = mapflg | (unsigned char)4;

        }

        else
          if((signed int)libcode == 3)
          {
            if(!((1 & (signed int)iflag) == 0) && !((2 & (signed int)iflag) == 0) && !((8 & (signed int)iflag) == 0))
              mapflg = mapflg | (unsigned char)4;

          }

  }

  else
  {
    if(dmax >= isize && isize >= dmin)
      mapflg = mapflg | (unsigned char)8;

    if((signed int)libcode == 4)
      mapflg = mapflg | (unsigned char)4;

    else
      if((signed int)libcode == 1)
      {
        if((1 & (signed int)iflag) == 0 && (8 & (signed int)iflag) == 0 && !((2 & (signed int)iflag) == 0))
          mapflg = mapflg | (unsigned char)4;

      }

      else
        if((signed int)libcode == 2)
        {
          if((2 & (signed int)iflag) == 0 && (8 & (signed int)iflag) == 0 && !((1 & (signed int)iflag) == 0))
            mapflg = mapflg | (unsigned char)4;

        }

        else
          if((signed int)libcode == 3)
          {
            if((1 & (signed int)iflag) == 0 && (2 & (signed int)iflag) == 0 && (8 & (signed int)iflag) == 0)
              mapflg = mapflg | (unsigned char)4;

          }

  }
  return mapflg;
}

// threadsCleanup
// file threads.h line 125
void threadsCleanup(void)
{
  if(!((32 & (signed int)Threads.status) == 0))
  {
    signed short int i = (signed short int)0;
    if(!((signed int)i >= (signed int)Threads.n_buffargs))
    {
      struct _BUFFARG *bargp = Threads.buffargp + (signed long int)i;
      Threads.tasks[(signed long int)0].cleanf((struct _ErrMsg *)(void *)0, bargp->thisp);
      i = i + 1;
    }

    i = (signed short int)0;
    if(!((signed int)i >= (signed int)Threads.n_targ))
    {
      struct _THREADARG *targp = Threads.targp + (signed long int)i;
      Threads.tasks[(signed long int)targp->task].cleanf(targp->errmsgp, targp->p);
      errMsgEnd(targp->errmsgp);
      targp->errmsgp = (struct _ErrMsg *)(void *)0;
      i = i + 1;
    }

    i = (signed short int)0;
    for( ; !((signed int)i >= 3); i = i + 1)
      cleanupARGBUFF(Threads.buff + (signed long int)i);
    free(Threads.memp);
    free((void *)Threads.buffargp);
    free((void *)Threads.targp);
    free((void *)Threads.threadp);
  }

  Threads.status = (unsigned char)0;
}

// threadsGetMem
// file threads.h line 142
void * threadsGetMem(unsigned char task_typ)
{
  void *p = (void *)0;
  if(!((32 & (signed int)Threads.status) == 0))
  {
    if((signed int)task_typ == 0)
      p = (Threads.buffargp + (signed long int)0)->thisp;

    else
    {
      signed short int ntr = (signed short int)0;
      for( ; p == NULL && !((signed int)ntr >= (signed int)Threads.n_targ); ntr = ntr + 1)
        if((Threads.targp + (signed long int)ntr)->task == task_typ)
          p = (Threads.targp + (signed long int)ntr)->p;

    }
  }

  return p;
}

// threadsInit
// file threads.h line 93
signed int threadsInit(void)
{
  signed int errcode = 0;
  signed short int i;
  Threads.status = (unsigned char)0;
  Threads.threadp = (unsigned long int *)(void *)0;
  Threads.targp = (struct _THREADARG *)(void *)0;
  Threads.buffargp = (struct _BUFFARG *)(void *)0;
  i = (signed short int)0;
  for( ; errcode == 0 && !((signed int)i >= 3); i = i + 1)
  {
    unsigned char buftyp = (unsigned char)3;
    if((signed int)i == 0)
      buftyp = (unsigned char)0;

    else
      if((signed int)i == 1)
        buftyp = (unsigned char)1;

      else
        if((signed int)i == 2)
          buftyp = (unsigned char)2;

        else
          buftyp = (unsigned char)3;
    errcode=initARGBUFF(Threads.buff + (signed long int)i, buftyp);
  }
  Threads.status = Threads.status | (unsigned char)1;
  return errcode;
}

// threadsRun
// file threads.h line 137
signed int threadsRun(void)
{
  signed int errcode = 0;
  unsigned char has_nonthread = (unsigned char)1;
  threadsStart();
  while(errcode == 0 && !(has_nonthread == 0))
  {
    signed short int ntr;
    has_nonthread = (unsigned char)0;
    ntr = (signed short int)0;
    for( ; errcode == 0 && !((signed int)ntr >= (signed int)Threads.n_targ); ntr = ntr + 1)
    {
      struct _THREADARG *targp = Threads.targp + (signed long int)ntr;
      if(!((signed int)targp->threadno >= 0))
      {
        has_nonthread = (unsigned char)1;
        tprocf((void *)targp);
        errcode = targp->exit_code;
      }

    }
  }
  threadsStop();
  return 79 == errcode ? 0 : errcode;
}

// threadsSetTask
// file threads.h line 97
signed int threadsSetTask(unsigned char task_typ, signed short int n_threads, signed int (*initf)(void *, const void *, signed short int), const void *initargp, signed int (*procf)(struct _ErrMsg *, void *, void *), signed int (*cleanf)(struct _ErrMsg *, void *), signed int (*checkf)(const void *, const void *), signed int (*cmpf)(const void *, const void *), unsigned long int argsz)
{
  signed int errcode = 0;
  struct _THREADTASK *taskp = (struct _THREADTASK *)(void *)0;
  if((signed int)task_typ >= 4)
    return -1;

  else
    if((1 & (signed int)Threads.status) == 0)
      return 47;

    else
    {
      taskp = Threads.tasks + (signed long int)task_typ;
      taskp->n_threads = n_threads;
      taskp->initf = initf;
      taskp->initargp = initargp;
      taskp->procf = procf;
      taskp->cleanf = cleanf;
      taskp->checkf = checkf;
      taskp->cmpf = cmpf;
      taskp->argsz = argsz;
      taskp->status = (unsigned char)1;
      taskp->tox = (unsigned char)0;
      taskp->fromx = taskp->tox;
      switch((signed int)task_typ)
      {
        case 1:
        {
          taskp->fromx = (unsigned char)0;
          taskp->tox = (unsigned char)1;
          Threads.status = Threads.status | (unsigned char)4;
          break;
        }
        case 0:
        {
          taskp->n_threads = (signed short int)0;
          taskp->procf = (signed int (*)(struct _ErrMsg *, void *, void *))(void *)0;
          Threads.status = Threads.status | (unsigned char)16;
          break;
        }
        case 2:
        {
          taskp->fromx = (unsigned char)1;
          taskp->tox = (unsigned char)2;
          Threads.status = Threads.status | (unsigned char)2;
          break;
        }
        case 3:
        {
          taskp->fromx = (unsigned char)2;
          taskp->tox = (unsigned char)0;
          Threads.status = Threads.status | (unsigned char)8;
          break;
        }
        default:
          errcode = -1;
      }
      return errcode;
    }
}

// threadsSetUp
// file threads.h line 116
signed int threadsSetUp(signed int n_buffarg_factor)
{
  signed int errcode = 0;
  unsigned char testflg = (unsigned char)(1 | 2 | 4 | 8 | 16);
  unsigned char nta;
  signed short int i;
  signed short int nth;
  signed short int ntr;
  signed short int n_threads;
  signed short int n_targ;
  unsigned long int memsz;
  char *hp;
  if(!(n_buffarg_factor >= 1))
    n_buffarg_factor = 4;

  signed short int tmp_post$4;
  if(!((32 & (signed int)testflg) == 0) || !(((signed int)Threads.status & (signed int)testflg) == (signed int)testflg))
    return 47;

  else
  {
    Threads.n_threads = (signed short int)0;
    Threads.n_targ = (signed short int)0;
    memsz = (unsigned long int)0;
    nta = (unsigned char)0;
    for( ; !((signed int)nta >= 4); nta = nta + 1)
      if(!((signed int)nta == 0))
      {
        struct _THREADTASK *threadsSetUp$$1$$1$$1$$1$$taskp = Threads.tasks + (signed long int)nta;
        if(!((signed int)threadsSetUp$$1$$1$$1$$1$$taskp->n_threads >= 1))
        {
          Threads.n_targ = Threads.n_targ + (signed short int)1;
          memsz = memsz + threadsSetUp$$1$$1$$1$$1$$taskp->argsz;
        }

        else
        {
          if((signed int)threadsSetUp$$1$$1$$1$$1$$taskp->n_threads + (signed int)Threads.n_threads >= 32768)
            return 48;

          Threads.n_threads = (signed short int)((signed int)Threads.n_threads + (signed int)threadsSetUp$$1$$1$$1$$1$$taskp->n_threads);
          Threads.n_targ = (signed short int)((signed int)Threads.n_targ + (signed int)threadsSetUp$$1$$1$$1$$1$$taskp->n_threads);
          memsz = memsz + threadsSetUp$$1$$1$$1$$1$$taskp->argsz * (unsigned long int)threadsSetUp$$1$$1$$1$$1$$taskp->n_threads;
        }
      }

    Threads.n_buffargs = (signed short int)((signed int)Threads.n_threads > 0 ? (signed int)Threads.n_threads * n_buffarg_factor : 1);
    memsz = memsz + (unsigned long int)Threads.n_buffargs * Threads.tasks[(signed long int)0].argsz;
    if((signed int)Threads.n_threads >= 1)
    {
      void *return_value_ecalloc$1;
      return_value_ecalloc$1=ecalloc((unsigned long int)Threads.n_threads, sizeof(unsigned long int) /*8ul*/ , "threads.c", 837);
      Threads.threadp = (unsigned long int *)return_value_ecalloc$1;
      if(Threads.threadp == ((unsigned long int *)NULL))
        errcode = 2;

    }

    else
      Threads.threadp = (unsigned long int *)(void *)0;
    void *return_value_ecalloc$2;
    return_value_ecalloc$2=ecalloc((unsigned long int)Threads.n_targ, sizeof(struct _THREADARG) /*40ul*/ , "threads.c", 844);
    Threads.targp = (struct _THREADARG *)return_value_ecalloc$2;
    void *return_value_ecalloc$3;
    return_value_ecalloc$3=ecalloc((unsigned long int)Threads.n_buffargs, sizeof(struct _BUFFARG) /*24ul*/ , "threads.c", 845);
    Threads.buffargp = (struct _BUFFARG *)return_value_ecalloc$3;
    Threads.memp=ecalloc((unsigned long int)1, memsz, "threads.c", 846);
    if(Threads.memp == NULL || Threads.buffargp == ((struct _BUFFARG *)NULL) || Threads.targp == ((struct _THREADARG *)NULL))
      errcode = 2;

    n_threads = (signed short int)0;
    n_targ = (signed short int)0;
    hp = (char *)Threads.memp;
    nta = (unsigned char)0;
    nth = (signed short int)0;
    ntr = (signed short int)0;
    for( ; errcode == 0 && !((signed int)nta >= 4); nta = nta + 1)
      if(!((signed int)nta == 0))
      {
        struct _THREADTASK *taskp = Threads.tasks + (signed long int)nta;
        if(!((signed int)taskp->n_threads >= 1))
          n_targ = n_targ + 1;

        else
        {
          if((signed int)taskp->n_threads + (signed int)n_threads >= 32768)
            return 48;

          n_threads = (signed short int)((signed int)n_threads + (signed int)taskp->n_threads);
          n_targ = (signed short int)((signed int)n_targ + (signed int)taskp->n_threads);
        }
        for( ; errcode == 0 && !((signed int)ntr >= (signed int)n_targ); ntr = ntr + 1)
        {
          struct _THREADARG *targp = Threads.targp + (signed long int)ntr;
          targp->task = nta;
          targp->p = (void *)hp;
          targp->buflstp = (struct _BUFFARG *)(void *)0;
          hp = hp + (signed long int)taskp->argsz;
          if(!((signed int)taskp->n_threads >= 1))
          {
            targp->threadno = (signed short int)-1;
            targp->flags = (unsigned char)0;
          }

          else
          {
            tmp_post$4 = nth;
            nth = nth + 1;
            targp->threadno = tmp_post$4;
            targp->flags = (unsigned char)1;
          }
          targp->errmsgp=errMsgCreate("threads.c", 880);
          if(targp->errmsgp == ((struct _ErrMsg *)NULL))
            errcode = 2;

          else
            errcode=Threads.tasks[(signed long int)nta].initf(targp->p, taskp->initargp, targp->threadno);
        }
      }

    if(errcode == 0 && (!(Threads.n_targ == n_targ) || !(Threads.n_threads == n_threads)))
      errcode = 47;

    i = (signed short int)0;
    if(errcode == 0 && !((signed int)i >= (signed int)Threads.n_buffargs))
    {
      struct _BUFFARG *p = Threads.buffargp + (signed long int)i;
      p->thisp = (void *)hp;
      hp = hp + (signed long int)Threads.tasks[(signed long int)0].argsz;
      p->argno = i;
      p->nextp = (struct _BUFFARG *)(void *)0;
      errcode=Threads.tasks[(signed long int)0].initf(p->thisp, Threads.tasks[(signed long int)0].initargp, i);
      if(errcode == 0)
        errcode=pushARGBUFF(&Threads.buff[(signed long int)0], p);

      i = i + 1;
    }

    if(errcode == 0)
      Threads.status = Threads.status | (unsigned char)32;

    return errcode;
  }
}

// threadsStart
// file threads.c line 945
signed int threadsStart(void)
{
  signed int rv = 0;
  signed short int ntr;
  if((32 & (signed int)Threads.status) == 0)
    return 47;

  else
  {
    ntr = (signed short int)0;
    for( ; !((signed int)ntr >= (signed int)Threads.n_targ); ntr = ntr + 1)
    {
      struct _THREADARG *targp = Threads.targp + (signed long int)ntr;
      if((signed int)targp->threadno >= 0)
      {
        rv=pthread_create(Threads.threadp + (signed long int)targp->threadno, (const union pthread_attr_t *)(void *)0, tprocf, (void *)targp);
        if(!(rv == 0))
          errMsgAdd(targp->errmsgp, "", "threads.c", 960, 63, (unsigned char)2);

      }

    }
    if(rv == 0)
      Threads.status = Threads.status | (unsigned char)64;

    return rv;
  }
}

// threadsStop
// file threads.c line 968
void threadsStop(void)
{
  signed int nth = 0;
  for( ; !(nth >= (signed int)Threads.n_threads); nth = nth + 1)
    pthread_join(Threads.threadp[(signed long int)nth], (void **)(void *)0);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// tprocf
// file threads.c line 548
static void * tprocf(void *p)
{
  signed int errcode = 0;
  struct _BUFFARG *argp;
  struct _THREADARG *thargp = (struct _THREADARG *)p;
  struct _THREADTASK *taskp = Threads.tasks + (signed long int)thargp->task;
  struct _ARGBUFF *argbf_fromp = Threads.buff + (signed long int)taskp->fromx;
  struct _ARGBUFF *argbf_top = Threads.buff + (signed long int)taskp->tox;
  if((2 & (signed int)thargp->flags) == 0)
  {
    signOnARGBUFF(argbf_top);
    thargp->flags = thargp->flags | (unsigned char)2;
  }

  _Bool tmp_if_expr$1;
  do
  {
    errcode=pullARGBUFF(&argp, argbf_fromp);
    if(!(errcode == 0))
      break;

    if(argp == ((struct _BUFFARG *)NULL))
    {
      errcode = 47;
      break;
    }

    pushTHREADARGInternalBuffer(thargp, argp, taskp->cmpf);
    if(errcode == 0)
    {
      argp=pullTHREADARGInternalBuffer(thargp, taskp->checkf, thargp->p);
      if(!(argp == ((struct _BUFFARG *)NULL)))
      {
        errcode=taskp->procf(thargp->errmsgp, thargp->p, argp->thisp);
        if(errcode == 0)
          errcode=pushARGBUFF(argbf_top, argp);

      }

    }

    if(errcode == 0)
      tmp_if_expr$1 = (signed int)thargp->threadno >= 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
  }
  while(tmp_if_expr$1);
  if(!(errcode == 0))
  {
    signOffARGBUFF(argbf_top);
    thargp->flags = thargp->flags & (unsigned char)~2;
  }

  thargp->exit_code = errcode;
  return p;
}

// transferParamFromSegLst
// file segment.c line 1457
static signed int transferParamFromSegLst(struct _SegAliCands *sacp, const struct _SegLst *sglp)
{
  signed int errcode = 0;
  _Bool tmp_if_expr$1;
  if(((unsigned long int *)sacp->candr)[-1l] == 0ul)
  {
    sacp->ktup = sglp->ktup;
    sacp->nskip = sglp->nskip;
  }

  else
  {
    if(!(sglp->ktup == sacp->ktup))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = sglp->nskip != sacp->nskip ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      errcode = 47;

  }
  return errcode;
}

// uncompressSeq
// file sequence.c line 1499
static signed int uncompressSeq(struct _SEQSEQ *ucp, unsigned int *tcpos, unsigned char *ntc, const struct _SEQSEQ *sp, unsigned long int start, unsigned long int length, const struct _SeqCodec *codep)
{
  char *bufp;
  signed int nsu;
  unsigned char nt = (unsigned char)0;
  const unsigned int *fromp;
  unsigned long int ctr;
  unsigned long int offset;
  unsigned char code;
  _Bool tmp_if_expr$1;
  signed int return_value_reallocSeqBlocks$2;
  char *tmp_post$3;
  unsigned char tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  if(!((signed int)sp->code == 2))
    return 22;

  else
    if(!(sp->size >= start))
      return 29;

    else
    {
      if(length == 0ul)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = start + length > sp->size ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        length = sp->size - start;

      if(!(ucp->alloc_size >= 1ul + length))
      {
        return_value_reallocSeqBlocks$2=reallocSeqBlocks(ucp, length + (unsigned long int)1);
        if(return_value_reallocSeqBlocks$2 == 0)
          goto __CPROVER_DUMP_L6;

        return 2;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        bufp = ucp->basep;
        offset = start / (unsigned long int)10;
        nsu = (signed int)((offset + (unsigned long int)1) * (unsigned long int)10 - start);
        nsu = nsu - 1;
        fromp = (const unsigned int *)sp->basep + (signed long int)offset;
        ctr = (unsigned long int)0;
        for( ; !(ctr >= length); ctr = ctr + 1ul)
        {
          code = (unsigned char)(*fromp >> 3 * nsu & (unsigned int)7);
          nsu = nsu - 1;
          if(!(nsu >= 0))
          {
            fromp = fromp + 1l;
            nsu = 10 - 1;
          }

          if((signed int)code == 7)
          {
            tmp_post$3 = bufp;
            bufp = bufp + 1l;
            *tmp_post$3 = (char)0;
            if(!(tcpos == ((unsigned int *)NULL)) && !((signed int)nt >= 8))
            {
              tmp_post$4 = nt;
              nt = nt + 1;
              tcpos[(signed long int)tmp_post$4] = (unsigned int)ctr;
            }

          }

          else
            if(!((signed int)code >= (signed int)codep->alphlen))
            {
              tmp_post$5 = bufp;
              bufp = bufp + 1l;
              *tmp_post$5 = codep->alphabet[(signed long int)code];
            }

            else
            {
              tmp_post$6 = bufp;
              bufp = bufp + 1l;
              *tmp_post$6 = (char)78;
            }
        }
        *bufp = (char)0;
        ucp->size = ctr;
        ucp->code = (char)0;
        if(!(ntc == ((unsigned char *)NULL)))
          *ntc = nt;

        return 0;
      }
    }
}

// updateCandBoundaries
// file segment.c line 1061
static signed int updateCandBoundaries(struct _SEGCAND *sgcp, const struct _SEGMENT *segmp, struct _SEED$0 * const seedr, unsigned char ktup, unsigned char nskip)
{
  unsigned int qs;
  unsigned int qe;
  unsigned int rs;
  unsigned int re;
  signed long int shift0;
  signed long int shift;
  signed long int d_shift;
  calcSegmentBoundaries(&qs, &qe, &rs, &re, segmp, seedr, ktup, nskip, (unsigned char)((signed int)sgcp->flag & 1));
  shift0 = ((signed long int)sgcp->rs - (signed long int)(sgcp->qs / (unsigned int)nskip)) + (signed long int)sgcp->shiftoffs;
  shift = (signed long int)rs - (signed long int)(qs / (unsigned int)nskip);
  d_shift = shift - shift0;
  if(!(d_shift >= 0l))
  {
    if(!(d_shift >= -32768l))
      return 48;

    sgcp->shiftoffs = sgcp->shiftoffs + (signed short int)d_shift;
    sgcp->srange = sgcp->srange - (signed short int)d_shift;
    shift0 = shift;
  }

  else
    if(!((signed long int)sgcp->srange >= d_shift))
    {
      if(d_shift >= 32768l)
        return 48;

      sgcp->srange = (signed short int)d_shift;
    }

  if(!(qs >= sgcp->qs))
    sgcp->qs = qs;

  if(!(sgcp->qe >= qe))
    sgcp->qe = qe;

  if(!(rs >= sgcp->rs))
    sgcp->rs = rs;

  if(!(sgcp->re >= re))
    sgcp->re = re;

  shift = (signed long int)(sgcp->rs - sgcp->qs / (unsigned int)nskip);
  sgcp->shiftoffs = sgcp->shiftoffs + (signed short int)(shift0 - shift);
  return 0;
}

// updateInsertBoundariesFromSample
// file smalt.c line 417
static void updateInsertBoundariesFromSample(struct _SmaltMapConst *macop, const struct _InsHist *ihp)
{
  signed int lo;
  signed int hi;
  insGetHistoData(&lo, &hi, (signed int *)(void *)0, ihp);
  if(!(lo >= macop->insert_min))
    macop->insert_min = lo;

  if(!(macop->insert_max >= hi))
    macop->insert_max = hi;

  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// writeCigarToFile
// file diffstr.c line 159
static inline signed int writeCigarToFile(void *top, unsigned char cigtyp, char typc, signed int ctr)
{
  signed int tmp_if_expr$5;
  signed int tmp_if_expr$3;
  signed int return_value_fprintf$1;
  signed int return_value_fprintf$2;
  signed int return_value_fprintf$4;
  if(ctr >= 1)
  {
    if(!((2 & (signed int)cigtyp) == 0))
    {
      return_value_fprintf$1=fprintf((struct _IO_FILE *)top, CIGAR_EXTF, ctr, typc);
      tmp_if_expr$3 = return_value_fprintf$1;
    }

    else
    {
      return_value_fprintf$2=fprintf((struct _IO_FILE *)top, CIGAR_FORM, typc, ctr);
      tmp_if_expr$3 = return_value_fprintf$2;
    }
    tmp_if_expr$5 = tmp_if_expr$3;
  }

  else
  {
    return_value_fprintf$4=fprintf((struct _IO_FILE *)top, "%c", typc);
    tmp_if_expr$5 = return_value_fprintf$4;
  }
  return tmp_if_expr$5;
}

// writeCigarToStr
// file diffstr.c line 167
static inline signed int writeCigarToStr(void *top, unsigned char cigtyp, char typc, signed int ctr)
{
  signed int tmp_if_expr$5;
  signed int tmp_if_expr$3;
  signed int return_value_sprintf$1;
  signed int return_value_sprintf$2;
  signed int return_value_sprintf$4;
  if(ctr >= 1)
  {
    if(!((2 & (signed int)cigtyp) == 0))
    {
      return_value_sprintf$1=sprintf((char *)top, CIGAR_EXTF, ctr, typc);
      tmp_if_expr$3 = return_value_sprintf$1;
    }

    else
    {
      return_value_sprintf$2=sprintf((char *)top, CIGAR_FORM, typc, ctr);
      tmp_if_expr$3 = return_value_sprintf$2;
    }
    tmp_if_expr$5 = tmp_if_expr$3;
  }

  else
  {
    return_value_sprintf$4=sprintf((char *)top, "%c", typc);
    tmp_if_expr$5 = return_value_sprintf$4;
  }
  return tmp_if_expr$5;
}

// writeCompressedSeq
// file sequence.c line 1426
static signed int writeCompressedSeq(struct _IO_FILE *fp, struct _SEQSEQ *sp)
{
  unsigned long int n_unit;
  if(!((signed int)sp->code == 2))
    return 22;

  else
  {
    n_unit = sp->size / (unsigned long int)10 + (unsigned long int)1;
    unsigned long int return_value_fwrite$1;
    return_value_fwrite$1=fwrite((const void *)sp->basep, sizeof(unsigned int) /*4ul*/ , n_unit, fp);
    if(!(return_value_fwrite$1 == n_unit))
      return -1;

    else
      return 0;
  }
}

// writeDiffStrCIGAR
// file diffstr.c line 298
static signed int writeDiffStrCIGAR(void * const top, signed int *nchar, unsigned char cgt, const unsigned char *diffstr, signed int clip_start, signed int clip_end, signed int (*writerp)(void *, unsigned char, char, signed int))
{
  unsigned int count;
  unsigned int prev_count = (unsigned int)0;
  unsigned short int typ = (unsigned short int)0;
  unsigned short int prev_typ = (unsigned short int)0;
  signed int nc = 0;
  const unsigned char *ucp;
  const char clipchar = (char)(0 != ((signed int)cgt & 4) ? 83 : 72);
  if(diffstr == ((const unsigned char *)NULL))
  {
    signed int return_value;
    return_value=writerp((void *)(writeCigarToStr == (writerp) ? (char *)top + (signed long int)nc : (char *)top), cgt, DIFFSTR_NULLSTR[(signed long int)0], 0);
    nc = nc + return_value;
    *nchar = nc;
    return 0;
  }

  signed int return_value_1;
  signed int return_value_2;
  signed int return_value_3;
  signed int return_value_4;
  signed int return_value_5;
  if(*diffstr == 0)
    return -1;

  else
  {
    if(clip_start >= 1 && !((2 & (signed int)cgt) == 0))
    {
      return_value_1=writerp((void *)(writeCigarToStr == (writerp) ? (char *)top + (signed long int)nc : (char *)top), cgt, clipchar, clip_start);
      nc = nc + return_value_1;
    }

    ucp = diffstr;
    for( ; !(*ucp == 0); ucp = ucp + 1l)
    {
      typ = (unsigned short int)(unsigned char)((signed int)*ucp >> 6);
      count = (unsigned int)(unsigned char)((signed int)*ucp & 63);
      if((signed int)prev_typ == 0)
      {
        prev_count = prev_count + count;
        if((signed int)typ == 0 || (signed int)typ == 3 && !((1 & (signed int)cgt) == 0))
        {
          prev_count = prev_count + 1u;
          goto __CPROVER_DUMP_L12;
        }

      }

      else
        if(typ == prev_typ && !(count >= 1u))
        {
          prev_count = prev_count + 1u;
          goto __CPROVER_DUMP_L12;
        }

      if(prev_count >= 1u)
      {
        return_value_2=writerp((void *)(writeCigarToStr == (writerp) ? (char *)top + (signed long int)nc : (char *)top), cgt, DIFFSTR_SYMBOLS_X[(signed long int)prev_typ], (signed int)prev_count);
        nc = nc + return_value_2;
      }

      if((signed int)typ == 0 || (signed int)typ == 3 && !((1 & (signed int)cgt) == 0))
      {
        prev_count = count + (unsigned int)1;
        prev_typ = (unsigned short int)0;
      }

      else
      {
        if(count >= 1u && !((signed int)prev_typ == 0))
        {
          return_value_3=writerp((void *)(writeCigarToStr == (writerp) ? (char *)top + (signed long int)nc : (char *)top), cgt, DIFFSTR_SYMBOLS_X[(signed long int)0], (signed int)count);
          nc = nc + return_value_3;
        }

        prev_count = (unsigned int)1;
        prev_typ = typ;
      }

    __CPROVER_DUMP_L12:
      ;
    }
    if(!((signed int)typ == 3))
      return 59;

    else
    {
      if(prev_count >= 2u)
      {
        return_value_4=writerp((void *)(writeCigarToStr == (writerp) ? (char *)top + (signed long int)nc : (char *)top), cgt, DIFFSTR_SYMBOLS_X[(signed long int)(((signed int)cgt & 1) != 0 ? 0 : 3)], (signed int)(prev_count - (unsigned int)1));
        nc = nc + return_value_4;
      }

      if(clip_end >= 1 && !((2 & (signed int)cgt) == 0))
      {
        return_value_5=writerp((void *)(writeCigarToStr == (writerp) ? (char *)top + (signed long int)nc : (char *)top), cgt, clipchar, clip_end);
        nc = nc + return_value_5;
      }

      *nchar = *nchar + nc;
      return 0;
    }
  }
}

// writeHeader
// file filio.c line 55
static signed int writeHeader(unsigned int filsiz, unsigned char filtyp, unsigned int version, unsigned int headsiz, struct _IO_FILE *fp)
{
  signed int errcode = 0;
  signed short int i;
  unsigned int header[12l];
  header[(signed long int)0] = (unsigned int)1931551091;
  header[(signed long int)1] = (unsigned int)1849133593;
  header[(signed long int)2] = filsiz;
  header[(signed long int)3] = (unsigned int)filtyp;
  header[(signed long int)4] = version;
  header[(signed long int)5] = headsiz;
  i = (signed short int)6;
  for( ; !((signed int)i >= 12); i = i + 1)
    header[(signed long int)i] = (unsigned int)0;
  fwrite((const void *)header, sizeof(unsigned int) /*4ul*/ , (unsigned long int)12, fp);
  signed int return_value_ferror$1;
  return_value_ferror$1=ferror(fp);
  if(!(return_value_ferror$1 == 0))
  {
    errcode = 11;
    perror(WRITERRMSG);
  }

  return errcode;
}

// writeREPALI
// file report.c line 1083
static signed int writeREPALI(struct _IO_FILE *fp, struct _BamBam_BamWriter *bamwriterp, struct _DiffView *dvp, const struct _REPALI *rp, const struct _DiffStr *rdfsp, const struct _SeqFastq *q_sqp, const struct _SeqSet *ssp, const char *namext, unsigned char outform, unsigned char oumodiflg, struct _DiffBlocks *dfblkp, unsigned char pairflg, signed int isize, const struct _REPALI *rsltmp, struct _SeqFastq *sqbufp, struct _REPNAMBUF *nambufp, const struct _SeqCodec *codecp)
{
  signed int errcode = 0;
  signed short int mapscor = (signed short int)0;
  unsigned char is_mapped;
  _Bool tmp_if_expr$1;
  if(!(rp == ((const struct _REPALI *)NULL)))
    tmp_if_expr$1 = ((signed int)rp->status & 1) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  is_mapped = (unsigned char)tmp_if_expr$1;
  const char *s_nam;
  const char *m_snam;
  unsigned char *dstrp;
  unsigned int ref_len = (unsigned int)0;
  if(!(is_mapped == 0))
  {
    ref_len=seqSetGetSeqDatByIndex((unsigned long int *)(void *)0, &s_nam, rp->s_idx, ssp);
    dstrp = rdfsp->dstrp + (signed long int)rp->dfo;
  }

  else
  {
    ref_len = (unsigned int)0;
    s_nam = OUFMT_SAM_NULLSTR;
    dstrp = (unsigned char *)(void *)0;
  }
  errcode=copyReadNamStrToREPSTR(&nambufp->ref_nam, (unsigned char)0, s_nam);
  if(!(errcode == 0))
    return errcode;

  else
  {
    if(!(rp == ((const struct _REPALI *)NULL)))
    {
      mapscor = rp->mapscor;
      if(!(rsltmp == ((const struct _REPALI *)NULL)) && !(is_mapped == 0))
      {
        if(rp->s_idx == rsltmp->s_idx)
          pairflg = pairflg | (unsigned char)2;

      }

    }

    if(namext == ((const char *)NULL))
      namext = "";

    switch((signed int)outform)
    {
      case 0:
      {
        errcode=fprintREPALIcigar(fp, rp, mapscor, &nambufp->q_nam, q_sqp, namext, nambufp->ref_nam.strp, dstrp, pairflg);
        break;
      }
      case 1:
      {
        errcode=fprintREPALIssaha(fp, rp, mapscor, &nambufp->q_nam, q_sqp, namext, nambufp->ref_nam.strp, ref_len, dstrp, pairflg);
        break;
      }
      case 4:
      {
        errcode=diffStrFindBlocks(dfblkp, dstrp);
        if(errcode == 0)
          errcode=fprintREPALIgff2(fp, rp, &nambufp->q_nam, q_sqp, namext, nambufp->ref_nam.strp, dfblkp);

        break;
      }
      case 2:
      {
        if(!(rsltmp == ((const struct _REPALI *)NULL)))
          seqSetGetSeqDatByIndex((unsigned long int *)(void *)0, &m_snam, rsltmp->s_idx, ssp);

        else
          m_snam = OUFMT_SAM_NULLSTR;
        errcode=copyReadNamStrToREPSTR(&nambufp->mref_nam, (unsigned char)0, m_snam);
        if(errcode == 0)
          errcode=fprintREPALIsam(fp, sqbufp, &nambufp->q_nam, mapscor, rp, dstrp, q_sqp, nambufp->ref_nam.strp, rsltmp, nambufp->mref_nam.strp, isize, pairflg, oumodiflg, codecp);

        break;
      }
      case 3:
      {
        errcode=writeREPALIbam(bamwriterp, sqbufp, &nambufp->q_nam, dvp, mapscor, rp, dstrp, q_sqp, rsltmp, isize, pairflg, oumodiflg, codecp);
        break;
      }
      default:
        errcode = 84;
    }
    return errcode;
  }
}

// writeREPALIbam
// file report.c line 917
static signed int writeREPALIbam(struct _BamBam_BamWriter *bamwriterp, struct _SeqFastq *sqbufp, struct _REPSTR *readnamp, struct _DiffView *dvp, signed short int mapscor, const struct _REPALI *rrp, const unsigned char *diffstr, const struct _SeqFastq *q_sqp, const struct _REPALI *rmp, signed int isize, unsigned char pairflg, unsigned char oumodiflg, const struct _SeqCodec *codecp)
{
  signed int errcode;
  signed int errc;
  signed int editdist = 0;
  signed int clip_start = 0;
  signed int clip_end = 0;
  signed int s_idx = -1;
  signed int ms_idx = -1;
  char cod;
  signed int bamflg = 0;
  signed int swatscor = 0;
  unsigned int pos = (unsigned int)0;
  unsigned int mpos = (unsigned int)0;
  unsigned int qlen;
  const char *seqstr;
  const char *qualstr;
  const char *cigarstr;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  const char *tmp_if_expr$4;
  const char *return_value_diffStrGetViewStr$3;
  if(rrp == ((const struct _REPALI *)NULL))
    return 47;

  else
    if(sqbufp == ((struct _SeqFastq *)NULL))
      return 15;

    else
    {
      seqFastqBlank(sqbufp);
      errcode=copyReadNameToREPSTR(readnamp, (unsigned char)1, q_sqp);
      if(!(errcode == 0))
        return errcode;

      else
        if(rrp->s_idx >= 2147483648l)
          return 48;

        else
        {
          s_idx = (signed int)rrp->s_idx;
          seqFastqGetConstSequence(q_sqp, &qlen, &cod);
          if(!((4 & (signed int)rrp->status) == 0))
          {
            bamflg = bamflg | 1;
            if(!((8 & (signed int)rrp->status) == 0))
            {
              bamflg = bamflg | 128;
              isize = isize * -1;
            }

            else
              bamflg = bamflg | 64;
            if(!(rmp == ((const struct _REPALI *)NULL)))
              tmp_if_expr$1 = ((signed int)rmp->status & 1) != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            if(tmp_if_expr$1)
            {
              mpos = (unsigned int)rmp->s_start;
              if(rmp->s_idx >= 2147483648l)
                return 48;

              ms_idx = (signed int)rmp->s_idx;
              if(!((2 & (signed int)rmp->status) == 0))
                bamflg = bamflg | 32;

            }

            else
            {
              bamflg = bamflg | 8;
              isize = 0;
              mpos = (unsigned int)0;
              ms_idx = -1;
            }
          }

          else
            ms_idx = -1;
          if(!((1 & (signed int)rrp->status) == 0))
          {
            unsigned char isReverse = (unsigned char)(((signed int)rrp->status & 2) != 0 ? 1 : 0);
            errcode=seqFastqAppendSegment(sqbufp, q_sqp, (unsigned int)0, (unsigned int)0, (char)isReverse, isReverse != 0 ? codecp : (const struct _SeqCodec *)(void *)0);
            if(!(errcode == 0))
              return errcode;

            if((signed int)cod == 1)
            {
              errcode=seqFastqDecode(sqbufp, codecp);
              if(!(errcode == 0))
                return errcode;

            }

            seqstr=seqFastqGetConstSequence(sqbufp, (unsigned int *)(void *)0, &cod);
            if(!((signed int)cod == 0))
              return 22;

            qualstr=seqFastqGetConstQualityFactors(sqbufp, (unsigned int *)(void *)0, (char *)(void *)0);
            pos = (unsigned int)rrp->s_start;
            if(!(qlen >= rrp->q_end))
              return 47;

            if(!(isReverse == 0))
            {
              bamflg = bamflg | 16;
              clip_start = (signed int)(qlen - rrp->q_end);
              clip_end = (signed int)(rrp->q_start - (unsigned int)1);
            }

            else
            {
              clip_start = (signed int)(rrp->q_start - (unsigned int)1);
              clip_end = (signed int)(qlen - rrp->q_end);
            }
            if(!((4 & (signed int)pairflg) == 0) && !((8 & (signed int)pairflg) == 0))
              bamflg = bamflg | 2;

            if(!((32 & (signed int)rrp->status) == 0))
              bamflg = bamflg | 256;

            swatscor = rrp->swatscor;
          }

          else
          {
            errcode=seqFastqAppendSegment(sqbufp, q_sqp, (unsigned int)0, (unsigned int)0, (char)0, (const struct _SeqCodec *)(void *)0);
            if(!(errcode == 0))
              return errcode;

            if((signed int)cod == 1)
            {
              errcode=seqFastqDecode(sqbufp, codecp);
              if(!(errcode == 0))
                return errcode;

            }

            seqstr=seqFastqGetConstSequence(sqbufp, (unsigned int *)(void *)0, &cod);
            if(!((signed int)cod == 0))
              return 22;

            qualstr=seqFastqGetConstQualityFactors(sqbufp, (unsigned int *)(void *)0, (char *)(void *)0);
            bamflg = bamflg | 4;
            s_idx = -1;
            swatscor = 0;
            isize = 0;
          }
          if(qualstr == ((const char *)NULL))
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = !(qualstr[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
          {
            errcode=seqFastqSetQual(sqbufp, (const char)-1);
            if(!(errcode == 0))
              return errcode;

            qualstr=seqFastqGetConstQualityFactors(sqbufp, (unsigned int *)(void *)0, (char *)(void *)0);
          }

          if(!((1 & (signed int)rrp->status) == 0))
          {
            errcode=diffStrAsView(dvp, diffstr, (char)(((signed int)oumodiflg & 8) != 0 ? 4 : 3), clip_start, clip_end, (char)(((signed int)oumodiflg & 2) != 0));
            if(!(errcode == 0))
              tmp_if_expr$4 = OUFMT_BAM_NULLSTR;

            else
            {
              return_value_diffStrGetViewStr$3=diffStrGetViewStr(dvp);
              tmp_if_expr$4 = return_value_diffStrGetViewStr$3;
            }
            cigarstr = tmp_if_expr$4;
            if(errcode == 0)
              editdist=diffStrGetLevenshteinDistance(diffstr);

          }

          else
            cigarstr = OUFMT_BAM_NULLSTR;
          errc=BamBam_BamWriter_PutAlignment(bamwriterp, bamflg, s_idx, (unsigned long int)(pos > (unsigned int)0 ? pos - (unsigned int)1 : (unsigned int)0), ms_idx, (unsigned long int)(mpos > (unsigned int)0 ? mpos - (unsigned int)1 : (unsigned int)0), readnamp->strp, seqstr, qualstr, cigarstr, (signed int)mapscor, isize);
          if(errc == 0)
            errc=BamBam_BamWriter_PutAuxNumber(bamwriterp, "NM", (const char)105, (const void *)&editdist);

          if(errc == 0)
            errc=BamBam_BamWriter_PutAuxNumber(bamwriterp, "AS", (const char)105, (const void *)&swatscor);

          if(errc == 0)
            BamBam_BamWriter_Commit(bamwriterp);

          return errc != 0 ? 11 : errcode;
        }
    }
}

// writeReportForRead
// file report.c line 1486
static signed int writeReportForRead(const struct _ReportWriter *wrp, const struct _REPALI *ralip, const struct _SeqFastq *readp, const struct _DiffStr *rdfsp, const struct _REPALI *malip, signed int isize, unsigned char pairflg, const struct _SeqSet *ssp, const struct _SeqCodec *codecp)
{
  signed int errcode;
  errcode=writeREPALI(wrp->oufp, wrp->bamwriterp, wrp->dvp, ralip, rdfsp, readp, ssp, wrp->namext, wrp->oufmt, wrp->modflg, wrp->dfblkp, pairflg, isize, malip, wrp->qbufp, wrp->nambufp, codecp);
  if(!(errcode == 0))
    return errcode;

  else
    if(!((1 & (signed int)wrp->modflg) == 0))
    {
      if(ralip == ((const struct _REPALI *)NULL))
        goto __CPROVER_DUMP_L2;

      if((1 & (signed int)ralip->status) == 0)
        goto __CPROVER_DUMP_L2;

      errcode=fprintAlignment(wrp->oufp, wrp->sbufp, wrp->qbufp, readp, (unsigned short int)wrp->linwidth, rdfsp, ssp, codecp, ralip);
      if(errcode == 0)
        goto __CPROVER_DUMP_L2;

      return errcode;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return errcode;
    }
}

// writeSAMHeaderf
// file report.c line 1266
static signed int writeSAMHeaderf(struct _IO_FILE *oufp, const struct _SeqSet *ssp, const char *prognam, const char *progversion, signed int narg, char * const *argv)
{
  signed long int s;
  signed long int snum;
  snum=seqSetGetSeqNumAndTotLen((unsigned long int *)(void *)0, ssp);
  signed int i;
  char nambf[512l];
  signed int return_value_fprintf$1;
  return_value_fprintf$1=fprintf(oufp, SAMFORM_HEADLINE);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  signed int return_value_fprintf$8;
  if(!(return_value_fprintf$1 >= 1))
    return 11;

  else
  {
    s = (signed long int)0;
    for( ; !(s >= snum); s = s + 1l)
    {
      const char *namp;
      unsigned int sl;
      sl=seqSetGetSeqDatByIndex((unsigned long int *)(void *)0, &namp, s, ssp);
      i = 0;
      do
      {
        if(!(i >= 511))
          tmp_if_expr$2 = (signed int)namp[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          tmp_if_expr$4 = !(((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)namp[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        nambf[(signed long int)i] = namp[(signed long int)i];
        i = i + 1;
      }
      while((_Bool)1);
      nambf[(signed long int)i] = (char)0;
      signed int return_value_fprintf$5;
      return_value_fprintf$5=fprintf(oufp, SAMFORM_REFSEQLINE, (const void *)nambf, (unsigned int)sl);
      if(!(return_value_fprintf$5 >= 1))
        return 11;

    }
    signed int return_value_fprintf$6;
    return_value_fprintf$6=fprintf(oufp, SAMFORM_PROGLINE, prognam, prognam, progversion);
    if(!(return_value_fprintf$6 >= 0))
      return 11;

    else
    {
      if(narg >= 1 && !(argv == ((char * const *)NULL)))
      {
        signed int return_value_fprintf$7;
        return_value_fprintf$7=fprintf(oufp, "%s", argv[(signed long int)0]);
        if(!(return_value_fprintf$7 >= 0))
          return 11;

        i = 1;
        for( ; !(i >= narg); i = i + 1)
        {
          return_value_fprintf$8=fprintf(oufp, " %s", argv[(signed long int)i]);
          if(!(return_value_fprintf$8 >= 0))
            return 11;

        }
        signed int return_value_fprintf$9;
        return_value_fprintf$9=fprintf(oufp, "\n");
        if(!(return_value_fprintf$9 >= 0))
          return 11;

      }

      return 0;
    }
  }
}

