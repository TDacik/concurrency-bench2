// tag-#anon#ST[*{SYM#tag-list_head#}$SYM#tag-list_head#$'__val'|]
// file group.c line 31
struct anonymous$10;

// tag-#anon#ST[*{SYM#tag-recovery_info#}$SYM#tag-recovery_info#$'__val'|]
// file recovery.c line 76
struct anonymous$23;

// tag-#anon#ST[*{SYM#tag-vnode_info#}$SYM#tag-vnode_info#$'__val'|]
// file group.c line 30
struct anonymous$9;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$37;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$35;

// tag-#anon#ST[ARR1024{S8}$S8$'name'||ARR24{U8}$U8$'sha1'||U64'size'||U64'mtime'||U32'data_vid'||U32'nr_extent'||U64'oid'||U8'inlined'||U56'$pad0'|]
// file http/kv.c line 33
struct anonymous$27;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$1;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$8;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous$3;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$31;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$34;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$33;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$30;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$32;

// tag-#anon#ST[S32'val'|]
// file ../include/util.h line 240
struct anonymous$2;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$36;

// tag-#anon#ST[U32'__pad'||U32'nr_nodes'||ARR2{U32}$U32$'__reserved'||U64'store_size'||U64'store_free'|]
// file ../include/sheepdog_proto.h line 200
struct anonymous$17;

// tag-#anon#ST[U32'__pad'||U32'rsvd'||U32'vdi_id'||U32'attr_id'||U8'copies'||ARR3{U8}$U8$'reserved'|]
// file ../include/sheepdog_proto.h line 190
struct anonymous$16;

// tag-#anon#ST[U32'__pad'||U8'copies'||ARR3{U8}$U8$'reserved'||U64'offset'|]
// file ../include/sheepdog_proto.h line 184
struct anonymous$15;

// tag-#anon#ST[U32'__pad1'||U32'__pad2'||ARR20{U8}$U8$'digest'|]
// file ../include/sheepdog_proto.h line 207
struct anonymous$18;

// tag-#anon#ST[U32'old_vid'||U32'new_vid'||U8'copies'||U8'set_bitmap'||U8'copy_policy'||U8'$pad0'|]
// file ../include/sheepdog_proto.h line 162
struct anonymous$14;

// tag-#anon#ST[U64'oid'||U64'cow_oid'||U8'copies'||U8'copy_policy'||U8'ec_index'||U8'reserved'||U32'tgt_epoch'||U32'offset'||U32'__pad'|]
// file ../include/sheepdog_proto.h line 132
struct anonymous$11;

// tag-#anon#ST[U64'oid'||U64'ctime'||U8'copies'||U8'copy_policy'||U16'flags'||U32'tag'|]
// file ../include/sheepdog_proto.h line 154
struct anonymous$13;

// tag-#anon#ST[U64'val'|]
// file ../include/util.h line 204
struct anonymous$0;

// tag-#anon#ST[U64'vdi_size'||U32'base_vdi_id'||U8'copies'||U8'copy_policy'||U8'store_policy'||U8'reserved'||U32'snapid'||U32'$pad0'|]
// file ../include/sheepdog_proto.h line 143
struct anonymous$12;

// tag-#anon#UN[*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'ifu_broadaddr'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'ifu_dstaddr'|]
// file /usr/include/ifaddrs.h line 38
union anonymous$28;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$29;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$19;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$38;

// tag-#anon#UN[ARR4190208{U8}$U8$'data'||ARR0{SYM#tag-onode_extent#}$SYM#tag-onode_extent#$'o_extent'|]
// file http/kv.c line 47
union anonymous$26;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$21;

// tag-#anon#UN[ARR8{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous$24;

// tag-#anon#UN[SYM#tag-#anon#ST[ARR1024{S8}$S8$'name'||ARR24{U8}$U8$'sha1'||U64'size'||U64'mtime'||U32'data_vid'||U32'nr_extent'||U64'oid'||U8'inlined'||U56'$pad0'|]#'$anon0'||ARR4096{U8}$U8$'pad'|]
// file http/kv.c line 32
union anonymous$25;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$7;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous$4;

// tag-#anon#UN[SYM#tag-#anon#ST[U64'oid'||U64'cow_oid'||U8'copies'||U8'copy_policy'||U8'ec_index'||U8'reserved'||U32'tgt_epoch'||U32'offset'||U32'__pad'|]#'obj'||SYM#tag-#anon#ST[U64'vdi_size'||U32'base_vdi_id'||U8'copies'||U8'copy_policy'||U8'store_policy'||U8'reserved'||U32'snapid'||U32'$pad0'|]#'vdi'||SYM#tag-#anon#ST[U64'oid'||U64'ctime'||U8'copies'||U8'copy_policy'||U16'flags'||U32'tag'|]#'cluster'||SYM#tag-#anon#ST[U32'old_vid'||U32'new_vid'||U8'copies'||U8'set_bitmap'||U8'copy_policy'||U8'$pad0'|]#'vdi_state'||ARR8{U32}$U32$'__pad'|]
// file ../include/sheepdog_proto.h line 131
union anonymous$5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-#anon#UN[U32'result'||SYM#tag-#anon#ST[U32'__pad'||U8'copies'||ARR3{U8}$U8$'reserved'||U64'offset'|]#'obj'||SYM#tag-#anon#ST[U32'__pad'||U32'rsvd'||U32'vdi_id'||U32'attr_id'||U8'copies'||ARR3{U8}$U8$'reserved'|]#'vdi'||SYM#tag-#anon#ST[U32'__pad'||U32'nr_nodes'||ARR2{U32}$U32$'__reserved'||U64'store_size'||U64'store_free'|]#'node'||SYM#tag-#anon#ST[U32'__pad1'||U32'__pad2'||ARR20{U8}$U8$'digest'|]#'hash'||ARR8{U32}$U32$'__pad'|]
// file ../include/sheepdog_proto.h line 182
union anonymous$6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$20;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$22;

// tag-FCGX_Request
// file /usr/include/fcgiapp.h line 91
struct FCGX_Request;

// tag-FCGX_Stream
// file /usr/include/fcgiapp.h line 53
struct FCGX_Stream;

// tag-Params
// file /usr/include/fcgiapp.h line 101
struct Params;

// tag-REQUST_STATUS
// file sheep_priv.h line 80
enum REQUST_STATUS { REQUEST_INIT=0, REQUEST_QUEUED=1, REQUEST_DONE=2, REQUEST_DROPPED=3 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-__uatomic_dummy
// file /usr/include/urcu/uatomic.h line 37
struct __uatomic_dummy;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-areq_work
// file request.c line 605
struct areq_work;

// tag-btree_node_type
// file ../include/sheepdog_proto.h line 255
enum btree_node_type { BTREE_HEAD=1, BTREE_EXT=2, BTREE_IDX=3 };

// tag-bucket_iterater_arg
// file http/kv.c line 55
struct bucket_iterater_arg;

// tag-cache_deletion_work
// file ops.c line 162
struct cache_deletion_work;

// tag-cache_info
// file ../include/internal_proto.h line 229
struct cache_info;

// tag-client_info
// file sheep_priv.h line 66
struct client_info;

// tag-cluster_driver
// file cluster.h line 32
struct cluster_driver;

// tag-cluster_info
// file ../include/internal_proto.h line 160
struct cluster_info;

// tag-connection
// file ../include/net.h line 28
struct connection;

// tag-delete_arg
// file vdi.c line 815
struct delete_arg;

// tag-deletion_work
// file vdi.c line 761
struct deletion_work;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-disk
// file md.c line 20
struct disk;

// tag-epoch_log
// file ../include/internal_proto.h line 177
struct epoch_log;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-event_info
// file ../include/event.h line 7
struct event_info;

// tag-fec
// file ../include/fec.h line 68
struct fec;

// tag-find_path
// file sd_inode.c line 98
struct find_path;

// tag-forward_info
// file gateway.c line 309
struct forward_info;

// tag-forward_info_entry
// file gateway.c line 302
struct forward_info_entry;

// tag-free_desc
// file http/oalloc.c line 42
struct free_desc;

// tag-get_vdis_work
// file group.c line 19
struct get_vdis_work;

// tag-global_cache
// file object_cache.c line 37
struct global_cache;

// tag-header
// file http/oalloc.c line 37
struct header;

// tag-hlist_head
// file ../include/list.h line 159
struct hlist_head;

// tag-hlist_node
// file ../include/list.h line 160
struct hlist_node;

// tag-http_driver
// file http/http.h line 54
struct http_driver;

// tag-http_opcode
// file http/http.h line 19
enum http_opcode { HTTP_GET=1, HTTP_PUT=2, HTTP_POST=3, HTTP_DELETE=4, HTTP_HEAD=5 };

// tag-http_request
// file http/http.h line 45
struct http_request;

// tag-http_status
// file http/http.h line 27
enum http_status { UNKNOWN=0, OK=1, CREATED=2, ACCEPTED=3, NO_CONTENT=4, PARTIAL_CONTENT=5, BAD_REQUEST=6, UNAUTHORIZED=7, NOT_FOUND=8, METHOD_NOT_ALLOWED=9, CONFLICT=10, REQUEST_RANGE_NOT_SATISFIABLE=11, INTERNAL_SERVER_ERROR=12, NOT_IMPLEMENTED=13, SERVICE_UNAVAILABLE=14 };

// tag-http_work
// file http/http.c line 86
struct http_work;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-journal_descriptor
// file journal.c line 30
struct journal_descriptor;

// tag-journal_file
// file journal.c line 16
struct journal_file;

// tag-kv_bnode
// file http/kv.c line 19
struct kv_bnode;

// tag-kv_onode
// file http/kv.c line 31
struct kv_onode;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-list_head
// file ../include/list.h line 15
struct list_head;

// tag-list_node
// file ../include/list.h line 10
struct list_node;

// tag-listening_fd
// file request.c line 1033
struct listening_fd;

// tag-log_dst_type
// file ../include/logger.h line 33
enum log_dst_type { LOG_DST_DEFAULT=0, LOG_DST_STDOUT=1, LOG_DST_SYSLOG=2 };

// tag-log_format
// file logger.c line 100
struct log_format;

// tag-logarea
// file logger.c line 75
struct logarea;

// tag-logger_user_info
// file ../include/logger.h line 27
struct logger_user_info;

// tag-logmsg
// file logger.c line 86
struct logmsg;

// tag-md
// file md.c line 32
struct md;

// tag-md_info
// file ../include/internal_proto.h line 196
struct md_info;

// tag-md_work
// file md.c line 505
struct md_work;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-node_id
// file ../include/internal_proto.h line 138
struct node_id;

// tag-node_id_v0
// file migrate.c line 15
struct node_id_v0;

// tag-node_id_v1
// file migrate.c line 34
struct node_id_v1;

// tag-node_id_v2
// file migrate.c line 57
struct node_id_v2;

// tag-object_cache
// file object_cache.c line 46
struct object_cache;

// tag-object_cache_entry
// file object_cache.c line 42
struct object_cache_entry;

// tag-object_cache_info
// file ../include/internal_proto.h line 235
struct object_cache_info;

// tag-object_iterater_arg
// file http/kv.c line 455
struct object_iterater_arg;

// tag-objlist_cache
// file object_list_cache.c line 21
struct objlist_cache;

// tag-objlist_cache_entry
// file object_list_cache.c line 16
struct objlist_cache_entry;

// tag-objlist_deletion_work
// file object_list_cache.c line 30
struct objlist_deletion_work;

// tag-onode_extent
// file http/kv.c line 26
struct onode_extent;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-option_parser
// file ../include/option.h line 25
struct option_parser;

// tag-pfd_info
// file gateway.c line 345
struct pfd_info;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-process_path_arg
// file md.c line 378
struct process_path_arg;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-push_work
// file object_cache.c line 69
struct push_work;

// tag-rb_node
// file ../include/rbtree.h line 7
struct rb_node;

// tag-rb_root
// file ../include/rbtree.h line 15
struct rb_root;

// tag-reclaim_work
// file object_cache.c line 550
struct reclaim_work;

// tag-recovery_info
// file recovery.c line 51
struct recovery_info;

// tag-recovery_list_work
// file recovery.c line 27
struct recovery_list_work;

// tag-recovery_obj_work
// file recovery.c line 35
struct recovery_obj_work;

// tag-recovery_state
// file ../include/internal_proto.h line 221
struct recovery_state;

// tag-recovery_work
// file recovery.c line 16
struct recovery_work;

// tag-req_iter
// file gateway.c line 22
struct req_iter;

// tag-request
// file sheep_priv.h line 69
struct request;

// tag-request_iocb
// file sheep_priv.h line 87
struct request_iocb;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-rw_state
// file ../include/internal_proto.h line 215
enum rw_state { RW_PREPARE_LIST=0, RW_RECOVER_OBJ=1, RW_NOTIFY_COMPLETION=2 };

// tag-s_request
// file ../include/internal_proto.h line 244
struct s_request;

// tag-sd_cond
// file ../include/util.h line 344
struct sd_cond;

// tag-sd_extent
// file ../include/sheepdog_proto.h line 237
struct sd_extent;

// tag-sd_extent_header
// file ../include/sheepdog_proto.h line 249
struct sd_extent_header;

// tag-sd_extent_idx
// file ../include/sheepdog_proto.h line 242
struct sd_extent_idx;

// tag-sd_inode
// file ../include/sheepdog_proto.h line 217
struct sd_inode;

// tag-sd_md_info
// file ../include/internal_proto.h line 204
struct sd_md_info;

// tag-sd_mutex
// file ../include/util.h line 269
struct sd_mutex;

// tag-sd_node
// file ../include/internal_proto.h line 148
struct sd_node;

// tag-sd_node_v0
// file migrate.c line 20
struct sd_node_v0;

// tag-sd_node_v1
// file migrate.c line 39
struct sd_node_v1;

// tag-sd_node_v2
// file migrate.c line 65
struct sd_node_v2;

// tag-sd_op_template
// file sheep_priv.h line 97
struct sd_op_template;

// tag-sd_op_type
// file ops.c line 15
enum sd_op_type { SD_OP_TYPE_CLUSTER=1, SD_OP_TYPE_LOCAL=2, SD_OP_TYPE_PEER=3, SD_OP_TYPE_GATEWAY=4 };

// tag-sd_option
// file ../include/option.h line 17
struct sd_option;

// tag-sd_req
// file ../include/sheepdog_proto.h line 124
struct sd_req;

// tag-sd_rsp
// file ../include/sheepdog_proto.h line 175
struct sd_rsp;

// tag-sd_rw_lock
// file ../include/util.h line 401
struct sd_rw_lock;

// tag-sd_stat
// file ../include/internal_proto.h line 243
struct sd_stat;

// tag-sd_status
// file ../include/internal_proto.h line 131
enum sd_status { SD_STATUS_OK=1, SD_STATUS_WAIT=2, SD_STATUS_SHUTDOWN=3, SD_STATUS_KILLED=4 };

// tag-sd_vnode
// file ../include/sheep.h line 23
struct sd_vnode;

// tag-sembuf
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 41
struct sembuf;

// tag-semid_ds
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 38
struct semid_ds;

// tag-seminfo
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 72
struct seminfo;

// tag-semun
// file logger.c line 68
union semun;

// tag-sha1_ctx
// file ../include/sha1.h line 20
struct sha1_ctx;

// tag-sheepdog_config
// file config.c line 17
struct sheepdog_config;

// tag-sheepdog_config_v1
// file migrate.c line 46
struct sheepdog_config_v1;

// tag-sheepdog_vdi_attr
// file ../include/sheepdog_proto.h line 267
struct sheepdog_vdi_attr;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-signalfd_siginfo
// file /usr/include/x86_64-linux-gnu/sys/signalfd.h line 28
struct signalfd_siginfo;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-siocb
// file sheep_priv.h line 168
struct siocb;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sockfd
// file ../include/sockfd_cache.h line 7
struct sockfd;

// tag-sockfd_cache
// file sockfd_cache.c line 38
struct sockfd_cache;

// tag-sockfd_cache_entry
// file sockfd_cache.c line 69
struct sockfd_cache_entry;

// tag-sockfd_cache_fd
// file sockfd_cache.c line 64
struct sockfd_cache_fd;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statvfs
// file /usr/include/x86_64-linux-gnu/bits/statvfs.h line 29
struct statvfs;

// tag-store_driver
// file sheep_priv.h line 208
struct store_driver;

// tag-strbuf
// file ../include/strbuf.h line 12
struct strbuf;

// tag-system_info
// file sheep_priv.h line 119
struct system_info;

// tag-timer
// file ../include/event.h line 19
struct timer;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vdi_info
// file sheep_priv.h line 193
struct vdi_info;

// tag-vdi_iocb
// file sheep_priv.h line 178
struct vdi_iocb;

// tag-vdi_op_message
// file ../include/internal_proto.h line 190
struct vdi_op_message;

// tag-vdi_state
// file sheep_priv.h line 200
struct vdi_state;

// tag-vdi_state_entry
// file vdi.c line 14
struct vdi_state_entry;

// tag-vdisk
// file md.c line 26
struct vdisk;

// tag-vnode_info
// file ../include/sheep.h line 29
struct vnode_info;

// tag-work
// file ../include/work.h line 9
struct work;

// tag-work_queue
// file ../include/work.h line 19
struct work_queue;

// tag-wq_info
// file work.c line 43
struct wq_info;

// tag-wq_thread_control
// file ../include/work.h line 24
enum wq_thread_control { WQ_ORDERED=0, WQ_DYNAMIC=1, WQ_UNLIMITED=2 };

#ifndef NULL
#define NULL ((void*)0)
#endif

// FCGX_Accept_r
// file /usr/include/fcgiapp.h line 207
signed int FCGX_Accept_r(struct FCGX_Request *);
// FCGX_Finish_r
// file /usr/include/fcgiapp.h line 228
void FCGX_Finish_r(struct FCGX_Request *);
// FCGX_GetError
// file /usr/include/fcgiapp.h line 569
signed int FCGX_GetError(struct FCGX_Stream *);
// FCGX_GetParam
// file /usr/include/fcgiapp.h line 349
char * FCGX_GetParam(const char *, char **);
// FCGX_GetStr
// file /usr/include/fcgiapp.h line 402
signed int FCGX_GetStr(char *, signed int, struct FCGX_Stream *);
// FCGX_Init
// file /usr/include/fcgiapp.h line 142
signed int FCGX_Init(void);
// FCGX_InitRequest
// file /usr/include/fcgiapp.h line 175
signed int FCGX_InitRequest(struct FCGX_Request *, signed int, signed int);
// FCGX_OpenSocket
// file /usr/include/fcgiapp.h line 160
signed int FCGX_OpenSocket(const char *, signed int);
// FCGX_PutS
// file /usr/include/fcgiapp.h line 494
signed int FCGX_PutS(const char *, struct FCGX_Stream *);
// FCGX_PutStr
// file /usr/include/fcgiapp.h line 479
signed int FCGX_PutStr(const char *, signed int, struct FCGX_Stream *);
// FCGX_VFPrintF
// file /usr/include/fcgiapp.h line 512
signed int FCGX_VFPrintF(struct FCGX_Stream *, const char *, void **);
// INIT_LIST_HEAD
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD(struct list_head *list);
// INIT_LIST_HEAD$link1
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD$link1(struct list_head *list$link1);
// INIT_LIST_HEAD$link2
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD$link2(struct list_head *list$link2);
// INIT_LIST_HEAD$link3
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD$link3(struct list_head *list$link3);
// INIT_LIST_NODE
// file ../include/list.h line 33
static inline void INIT_LIST_NODE(struct list_node *list);
// INIT_RB_ROOT
// file ../include/rbtree.h line 37
static inline void INIT_RB_ROOT(struct rb_root *root);
// INIT_RB_ROOT$link1
// file ../include/rbtree.h line 37
static inline void INIT_RB_ROOT$link1(struct rb_root *root$link1);
// INIT_RB_ROOT$link2
// file ../include/rbtree.h line 37
static inline void INIT_RB_ROOT$link2(struct rb_root *root$link2);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __hlist_del
// file ../include/list.h line 186
static inline void __hlist_del(struct hlist_node *n);
// __list_add
// file ../include/list.h line 72
static inline void __list_add(struct list_node *new, struct list_node *prev, struct list_node *next);
// __list_add$link1
// file ../include/list.h line 72
static inline void __list_add$link1(struct list_node *new$link1, struct list_node *prev$link1, struct list_node *next$link1);
// __list_add$link2
// file ../include/list.h line 72
static inline void __list_add$link2(struct list_node *new$link2, struct list_node *prev$link2, struct list_node *next$link2);
// __list_add$link3
// file ../include/list.h line 72
static inline void __list_add$link3(struct list_node *new$link3, struct list_node *prev$link3, struct list_node *next$link3);
// __list_add$link4
// file ../include/list.h line 72
static inline void __list_add$link4(struct list_node *new$link4, struct list_node *prev$link4, struct list_node *next$link4);
// __list_del
// file ../include/list.h line 92
static inline void __list_del(struct list_node *prev, struct list_node *next);
// __list_del$link1
// file ../include/list.h line 92
static inline void __list_del$link1(struct list_node *prev$link1, struct list_node *next$link1);
// __list_del$link2
// file ../include/list.h line 92
static inline void __list_del$link2(struct list_node *prev$link2, struct list_node *next$link2);
// __list_del$link3
// file ../include/list.h line 92
static inline void __list_del$link3(struct list_node *prev$link3, struct list_node *next$link3);
// __list_del$link4
// file ../include/list.h line 92
static inline void __list_del$link4(struct list_node *prev$link4, struct list_node *next$link4);
// __list_del_entry
// file ../include/list.h line 98
static inline void __list_del_entry(struct list_node *entry);
// __list_del_entry$link1
// file ../include/list.h line 98
static inline void __list_del_entry$link1(struct list_node *entry$link1);
// __list_splice
// file ../include/list.h line 122
static inline void __list_splice(struct list_head *list, struct list_node *prev, struct list_node *next);
// __list_splice$link1
// file ../include/list.h line 122
static inline void __list_splice$link1(struct list_head *list$link1, struct list_node *prev$link1, struct list_node *next$link1);
// __rb_erase_color
// file rbtree.c line 124
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root);
// __rb_rotate_left
// file rbtree.c line 25
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root);
// __rb_rotate_right
// file rbtree.c line 47
static void __rb_rotate_right(struct rb_node *node, struct rb_root *root);
// __sd_dump_variable
// file ../include/logger.h line 53
signed int __sd_dump_variable(const char *var);
// __uatomic_add
// file /usr/include/urcu/uatomic.h line 357
static inline void __uatomic_add(void *addr, unsigned long int val, signed int len);
// __uatomic_add_return
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len);
// __uatomic_add_return$link1
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_add_return$link2
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// __uatomic_add_return$link3
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3);
// __uatomic_cmpxchg
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len);
// __uatomic_cmpxchg$link1
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1(void *addr$link1, unsigned long int old$link1, unsigned long int _new$link1, signed int len$link1);
// __uatomic_cmpxchg$link2
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2(void *addr$link2, unsigned long int old$link2, unsigned long int _new$link2, signed int len$link2);
// __uatomic_dec
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len);
// __uatomic_dec$link1
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec$link1(void *addr$link1, signed int len$link1);
// __uatomic_dec$link2
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec$link2(void *addr$link2, signed int len$link2);
// __uatomic_exchange
// file /usr/include/urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange(void *addr, unsigned long int val, signed int len);
// __uatomic_inc
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len);
// __uatomic_inc$link1
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc$link1(void *addr$link1, signed int len$link1);
// __uatomic_inc$link2
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc$link2(void *addr$link2, signed int len$link2);
// __uatomic_or
// file /usr/include/urcu/uatomic.h line 301
static inline void __uatomic_or(void *addr, unsigned long int val, signed int len);
// __uatomic_or$link1
// file /usr/include/urcu/uatomic.h line 301
static inline void __uatomic_or$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1);
// __uatomic_or$link2
// file /usr/include/urcu/uatomic.h line 301
static inline void __uatomic_or$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2);
// _addmul1
// file fec.c line 216
static void _addmul1(unsigned char *dst, const unsigned char *src, unsigned char c, unsigned long int sz);
// _init_mul_table
// file fec.c line 127
static void _init_mul_table(void);
// _invert_mat
// file fec.c line 278
static void _invert_mat(unsigned char *src, unsigned int d);
// _invert_vdm
// file fec.c line 386
static void _invert_vdm(unsigned char *src, unsigned int d);
// _matmul
// file fec.c line 255
static void _matmul(unsigned char *a, unsigned char *b, unsigned char *c, unsigned int dp, unsigned int d, unsigned int m);
// _pread
// file util.c line 168
static signed long int _pread(signed int fd, void *buf, unsigned long int len, signed long int offset);
// _pwrite
// file util.c line 179
static signed long int _pwrite(signed int fd, const void *buf, unsigned long int len, signed long int offset);
// _read
// file util.c line 106
static signed long int _read(signed int fd, void *buf, unsigned long int len);
// _write
// file util.c line 117
static signed long int _write(signed int fd, const void *buf, unsigned long int len);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$22, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_timer
// file event.c line 39
void add_timer(struct timer *t, unsigned int mseconds);
// add_to_dirty_list
// file object_cache.c line 259
static void add_to_dirty_list(struct object_cache_entry *entry);
// add_to_lru_cache
// file object_cache.c line 685
static void add_to_lru_cache(struct object_cache *oc, unsigned long int idx, _Bool create);
// add_vdi_state
// file sheep_priv.h line 304
signed int add_vdi_state(unsigned int vid, signed int nr_copies, _Bool snapshot, unsigned char cp);
// addr_to_str
// file ../include/net.h line 56
const char * addr_to_str(const unsigned char *addr, unsigned short int port);
// after
// file ../include/util.h line 52
static inline signed int after(unsigned int seq1, unsigned int seq2);
// alloc_cache_entry
// file object_cache.c line 671
static inline struct object_cache_entry * alloc_cache_entry(struct object_cache *oc, unsigned long int idx);
// alloc_inode
// file vdi.c line 225
static struct sd_inode * alloc_inode(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int *data_vdi_id);
// alloc_local_request
// file request.c line 512
static struct request * alloc_local_request(void *data, signed int data_length);
// alloc_old_vnode_info
// file group.c line 558
static struct vnode_info * alloc_old_vnode_info(void);
// alloc_request
// file request.c line 651
static struct request * alloc_request(struct client_info *ci, signed int data_length);
// alloc_vnode_info
// file group.c line 130
struct vnode_info * alloc_vnode_info(struct rb_root *nroot);
// atomic_create_and_write
// file ../include/util.h line 122
signed int atomic_create_and_write(const char *path, const char *buf, unsigned long int len, _Bool force_create);
// atomic_set_bit
// file ../include/bitops.h line 144
static inline void atomic_set_bit(signed int nr, unsigned long int *addr);
// atomic_set_bit$link1
// file ../include/bitops.h line 144
static inline void atomic_set_bit$link1(signed int nr$link1, unsigned long int *addr$link1);
// atomic_set_bit$link2
// file ../include/bitops.h line 144
static inline void atomic_set_bit$link2(signed int nr$link2, unsigned long int *addr$link2);
// background_push_done
// file object_cache.c line 234
static void background_push_done(struct work *work);
// backtrace
// file /usr/include/execinfo.h line 27
extern signed int backtrace(void **, signed int);
// backtrace_symbols
// file /usr/include/execinfo.h line 32
extern char ** backtrace_symbols(void * const *, signed int);
// backup_epoch
// file migrate.c line 166
static signed int backup_epoch(unsigned int epoch);
// backup_file
// file migrate.c line 114
static signed int backup_file(char *fname, char *suffix);
// backup_store
// file migrate.c line 183
static signed int backup_store(void);
// before
// file ../include/util.h line 47
static inline signed int before(unsigned int seq1, unsigned int seq2);
// binary_search
// file sd_inode.c line 222
static void * binary_search(void *first, void *last, void *key, unsigned long int obj_size, signed int (*cmp)(void *, void *));
// binary_search::cmp$object
//
signed int cmp$object(void *, void *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$22, unsigned int);
// block_sighup
// file logger.c line 130
static void block_sighup(void);
// bnode_create
// file http/kv.c line 276
static signed int bnode_create(struct kv_bnode *bnode, unsigned int account_vid);
// bnode_do_create
// file http/kv.c line 251
static signed int bnode_do_create(struct kv_bnode *bnode, struct sd_inode *inode, unsigned int idx);
// bnode_lookup
// file http/kv.c line 353
static signed int bnode_lookup(struct kv_bnode *bnode, unsigned int vid, const char *name);
// bnode_update
// file http/kv.c line 391
static signed int bnode_update(const char *account, const char *bucket, unsigned long int used, _Bool create);
// bsearch
// file /usr/include/stdlib.h line 754
extern void * bsearch(const void *, const void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// bucket_create
// file http/kv.c line 310
static signed int bucket_create(const char *account, unsigned int account_vid, const char *bucket);
// bucket_delete
// file http/kv.c line 424
static signed int bucket_delete(const char *account, unsigned int avid, const char *bucket);
// bucket_iterate_object
// file http/kv.c line 492
static signed int bucket_iterate_object(unsigned int bucket_vid, void (*cb)(const char *, void *), void *opaque);
// bucket_iterate_object::cb$object
//
void cb$object(const char *, void *);
// bucket_iterater
// file http/kv.c line 120
static void bucket_iterater(void *data, enum btree_node_type type, void *arg);
// build_decode_matrix_into_space
// file fec.c line 538
static void build_decode_matrix_into_space(struct fec * const code, const signed int * const idx, const unsigned int d, unsigned char * const matrix);
// build_long_options
// file ../include/option.h line 31
struct option * build_long_options(struct sd_option *sd_opts);
// build_short_options
// file ../include/option.h line 30
char * build_short_options(struct sd_option *sd_opts);
// bypass_object_cache
// file sheep_priv.h line 449
_Bool bypass_object_cache(struct request *req);
// cache_delete_done
// file ops.c line 175
static void cache_delete_done(struct work *work);
// cache_delete_work
// file ops.c line 167
static void cache_delete_work(struct work *work);
// cache_dir_parser
// file sheep.c line 305
static signed int cache_dir_parser(const char *s);
// cache_directio_parser
// file sheep.c line 297
static signed int cache_directio_parser(const char *s);
// cache_size_parser
// file sheep.c line 278
static signed int cache_size_parser(const char *s);
// calc_object_bmap
// file object_cache.c line 135
static unsigned long int calc_object_bmap(unsigned long int oid, unsigned long int len, signed long int offset);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_gdb
// file logger.c line 753
static _Bool check_gdb(void);
// check_host_env
// file sheep.c line 477
static void check_host_env(void);
// check_idx
// file sockfd_cache.c line 277
static inline void check_idx(signed int idx);
// check_path_len
// file store.c line 179
static inline signed int check_path_len(const char *path);
// check_recover_journal_file
// file journal.c line 248
static void check_recover_journal_file(const char *p);
// check_request_epoch
// file request.c line 147
static signed int check_request_epoch(struct request *req);
// check_stale_objects
// file plain_store.c line 505
static signed int check_stale_objects(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *arg);
// check_tmp_config
// file config.c line 47
static void check_tmp_config(void);
// chomp
// file ../include/util.h line 106
char * chomp(char *str);
// clean_journal_file
// file sheep_priv.h line 475
void clean_journal_file(const char *p);
// clean_vdi_state
// file vdi.c line 1251
void clean_vdi_state(void);
// clear_client_info
// file request.c line 872
static void clear_client_info(struct client_info *ci);
// clear_parent_child_vdi
// file vdi.c line 1024
static void clear_parent_child_vdi(unsigned int vid);
// client_handler
// file request.c line 931
static void client_handler(signed int fd, signed int events, void *data);
// clone_vdi
// file vdi.c line 301
static signed int clone_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int base_vid);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// cluster_cleanup
// file ops.c line 606
static signed int cluster_cleanup(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_ctime_check
// file group.c line 375
static _Bool cluster_ctime_check(struct cluster_info *cinfo);
// cluster_del_vdi
// file ops.c line 146
static signed int cluster_del_vdi(struct request *req);
// cluster_delete_cache
// file ops.c line 651
static signed int cluster_delete_cache(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_disable_recover
// file ops.c line 329
static signed int cluster_disable_recover(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_enable_recover
// file ops.c line 321
static signed int cluster_enable_recover(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_force_recover_main
// file ops.c line 566
static signed int cluster_force_recover_main(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_force_recover_work
// file ops.c line 530
static signed int cluster_force_recover_work(struct request *req);
// cluster_get_vdi_attr
// file ops.c line 336
static signed int cluster_get_vdi_attr(struct request *req);
// cluster_get_vdi_info
// file ops.c line 211
static signed int cluster_get_vdi_info(struct request *req);
// cluster_info_copy
// file group.c line 419
static void cluster_info_copy(struct cluster_info *dst, struct cluster_info *src);
// cluster_join_check
// file group.c line 867
static _Bool cluster_join_check(struct cluster_info *cinfo);
// cluster_make_fs
// file ops.c line 253
static signed int cluster_make_fs(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_new_vdi
// file ops.c line 76
static signed int cluster_new_vdi(struct request *req);
// cluster_notify_vdi_add
// file ops.c line 625
static signed int cluster_notify_vdi_add(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_notify_vdi_del
// file ops.c line 643
static signed int cluster_notify_vdi_del(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_op_done
// file group.c line 224
static void cluster_op_done(struct work *work);
// cluster_recovery_completion
// file ops.c line 662
static signed int cluster_recovery_completion(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_reweight
// file ops.c line 746
static signed int cluster_reweight(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_shutdown
// file ops.c line 303
static signed int cluster_shutdown(struct sd_req *req, struct sd_rsp *rsp, void *data);
// cluster_wait_check
// file group.c line 427
static enum sd_status cluster_wait_check(struct sd_node *joining, struct rb_root *nroot, unsigned long int nr_nodes, struct cluster_info *cinfo);
// conn_rx_off
// file ../include/net.h line 40
signed int conn_rx_off(struct connection *conn);
// conn_rx_on
// file ../include/net.h line 41
signed int conn_rx_on(struct connection *conn);
// conn_tx_off
// file ../include/net.h line 38
signed int conn_tx_off(struct connection *conn);
// conn_tx_on
// file ../include/net.h line 39
signed int conn_tx_on(struct connection *conn);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$22, unsigned int);
// connect_to
// file net.c line 137
signed int connect_to(const char *name, signed int port);
// connect_to_addr
// file ../include/net.h line 71
static inline signed int connect_to_addr(const unsigned char *addr, signed int port);
// convert_ecidx_xattr2path
// file migrate.c line 430
static signed int convert_ecidx_xattr2path(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *info, void *arg);
// count_data_objs
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs(struct sd_inode *inode);
// count_data_objs$link1
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs$link1(struct sd_inode *inode$link1);
// crash_handler
// file sheep.c line 265
static void crash_handler(signed int signo);
// crash_handler$link1
// file logger.c line 534
static void crash_handler$link1(signed int signo$link1);
// create_cache_object
// file object_cache.c line 752
static signed int create_cache_object(struct object_cache *oc, unsigned long int idx, void *buffer, unsigned long int buf_size);
// create_client
// file request.c line 894
static struct client_info * create_client(signed int fd, struct cluster_info *cluster);
// create_cluster
// file sheep_priv.h line 340
signed int create_cluster(signed int port, signed long int zone, signed int nr_vnodes, _Bool explicit_addr);
// create_dir_for
// file object_cache.c line 594
static signed int create_dir_for(unsigned int vid);
// create_journal_file
// file journal.c line 61
static signed int create_journal_file(const char *root, const char *name);
// create_listen_port
// file sheep_priv.h line 288
signed int create_listen_port(const char *bindaddr, signed int port);
// create_listen_port_fn
// file request.c line 1038
static signed int create_listen_port_fn(signed int fd, void *data);
// create_listen_ports
// file ../include/net.h line 51
signed int create_listen_ports(const char *bindaddr, signed int port, signed int (*callback)(signed int, void *), void *data);
// create_listen_ports::callback$object
//
signed int callback$object(signed int, void *);
// create_ordered_work_queue
// file ../include/work.h line 63
struct work_queue * create_ordered_work_queue(const char *name);
// create_pidfile
// file sheep.c line 194
static signed int create_pidfile(const char *filename);
// create_unix_domain_socket
// file ../include/net.h line 53
signed int create_unix_domain_socket(const char *unix_path, signed int (*callback)(signed int, void *), void *data);
// create_unix_domain_socket::callback$object
//
signed int callback$object(signed int, void *);
// create_vdi
// file vdi.c line 264
static signed int create_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid);
// create_vdisks
// file md.c line 90
static void create_vdisks(struct disk *disk);
// create_work_queue
// file ../include/work.h line 62
struct work_queue * create_work_queue(const char *name, enum wq_thread_control tc);
// create_work_queues
// file sheep.c line 439
static signed int create_work_queues(void);
// create_worker_threads
// file work.c line 249
static signed int create_worker_threads(struct wq_info *wi, unsigned long int nr_threads);
// data_is_missing
// file fec.c line 618
static inline _Bool data_is_missing(const unsigned char **dp, signed int d);
// data_oid_to_idx
// file ../include/sheepdog_proto.h line 430
static inline unsigned long int data_oid_to_idx(unsigned long int oid);
// data_oid_to_idx$link1
// file ../include/sheepdog_proto.h line 430
static inline unsigned long int data_oid_to_idx$link1(unsigned long int oid$link1);
// data_to_str
// file ../include/util.h line 110
const char * data_to_str(void *data, unsigned long int data_length);
// decode_prepare
// file fec.c line 591
static inline void decode_prepare(struct fec *ctx, const unsigned char **dp, const unsigned char **out, signed int *outidx);
// default_cleanup
// file plain_store.c line 196
signed int default_cleanup(void);
// default_create_and_write
// file plain_store.c line 346
signed int default_create_and_write(unsigned long int oid, struct siocb *iocb);
// default_exist
// file plain_store.c line 78
_Bool default_exist(unsigned long int oid, unsigned char ec_index);
// default_format
// file plain_store.c line 522
signed int default_format(void);
// default_get_hash
// file plain_store.c line 603
signed int default_get_hash(unsigned long int oid, unsigned int epoch, unsigned char *sha1);
// default_init
// file plain_store.c line 252
signed int default_init(void);
// default_link
// file plain_store.c line 416
signed int default_link(unsigned long int oid, unsigned int tgt_epoch);
// default_purge_obj
// file plain_store.c line 651
signed int default_purge_obj(void);
// default_read
// file plain_store.c line 298
signed int default_read(unsigned long int oid, struct siocb *iocb);
// default_read_from_path
// file plain_store.c line 266
static signed int default_read_from_path(unsigned long int oid, const char *path, struct siocb *iocb);
// default_remove_object
// file plain_store.c line 537
signed int default_remove_object(unsigned long int oid, unsigned char ec_index);
// default_update_epoch
// file plain_store.c line 516
signed int default_update_epoch(unsigned int epoch);
// default_write
// file plain_store.c line 119
signed int default_write(unsigned long int oid, struct siocb *iocb);
// del_from_dirty_list
// file object_cache.c line 251
static void del_from_dirty_list(struct object_cache_entry *entry);
// del_requeue_request
// file request.c line 18
static void del_requeue_request(struct request *req);
// delete_cb
// file vdi.c line 820
static void delete_cb(void *data, enum btree_node_type type, void *arg);
// delete_inode
// file vdi.c line 771
static signed int delete_inode(unsigned int vid);
// delete_one_vdi
// file vdi.c line 846
static signed int delete_one_vdi(unsigned int vdi_id);
// delete_vdis_done
// file vdi.c line 930
static void delete_vdis_done(struct work *work);
// delete_vdis_work
// file vdi.c line 915
static void delete_vdis_work(struct work *work);
// destroy_all_slots
// file sockfd_cache.c line 141
static inline void destroy_all_slots(struct sockfd_cache_entry *entry);
// destroy_client
// file request.c line 865
static void destroy_client(struct client_info *ci);
// dirfd
// file /usr/include/dirent.h line 223
extern signed int dirfd(struct __dirstream *);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// disk_cmp
// file md.c line 62
static signed int disk_cmp(struct disk *d1, struct disk *d2);
// do_background_push
// file object_cache.c line 222
static void do_background_push(struct work *work);
// do_epoch_log_read
// file store.c line 44
static signed int do_epoch_log_read(unsigned int epoch, struct sd_node *nodes, signed int len, signed long int *timestamp);
// do_event_loop
// file event.c line 190
static void do_event_loop(signed int timeout, _Bool sort_with_prio);
// do_get_vdis
// file group.c line 486
static void do_get_vdis(struct work *work);
// do_grow_fds
// file sockfd_cache.c line 247
static void do_grow_fds(struct work *work);
// do_nothing
// file util.c line 28
static void do_nothing(unsigned long int size);
// do_plug_unplug
// file md.c line 755
static signed int do_plug_unplug(char *disks, _Bool plug);
// do_process_main
// file sheep_priv.h line 423
signed int do_process_main(struct sd_op_template *op, struct sd_req *req, struct sd_rsp *rsp, void *data);
// do_process_work
// file sheep_priv.h line 422
void do_process_work(struct work *work);
// do_push_object
// file object_cache.c line 844
static void do_push_object(struct work *work);
// do_read
// file ../include/net.h line 42
signed int do_read(signed int sockfd, void *buf, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// do_read::need_retry$object
//
_Bool need_retry$object(unsigned int);
// do_reclaim
// file object_cache.c line 555
static void do_reclaim(struct work *work);
// do_reclaim_object
// file object_cache.c line 515
static void do_reclaim_object(struct object_cache *oc);
// do_recover
// file journal.c line 190
static signed int do_recover(signed int fd);
// do_recover_object
// file recovery.c line 509
static signed int do_recover_object(struct recovery_obj_work *row);
// do_write
// file net.c line 261
static signed int do_write(signed int sockfd, struct msghdr *msg, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// do_write::need_retry$object
//
_Bool need_retry$object(unsigned int);
// do_writev2
// file net.c line 587
signed int do_writev2(signed int fd, void *hdr, unsigned long int hdr_len, void *body, unsigned long int body_len);
// dolog
// file logger.c line 395
static void dolog(signed int prio, const char *func, signed int line, const char *fmt, void **ap);
// dump_btree
// file sd_inode.c line 209
static void dump_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode);
// dump_btree::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// dump_stack_frames
// file logger.c line 800
static signed int dump_stack_frames(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// early_log_init
// file ../include/logger.h line 39
void early_log_init(const char *format_name, struct logger_user_info *user_info);
// ec_decode
// file fec.c line 635
void ec_decode(struct fec *ctx, const unsigned char **input, const signed int *inidx, unsigned char *output, signed int idx);
// ec_decode_buffer
// file ../include/fec.h line 200
void ec_decode_buffer(struct fec *ctx, unsigned char **input, const signed int *in_idx, char *buf, signed int idx);
// ec_destroy
// file ../include/fec.h line 195
static inline void ec_destroy(struct fec *ctx);
// ec_destroy$link1
// file ../include/fec.h line 195
static inline void ec_destroy$link1(struct fec *ctx$link1);
// ec_encode
// file ../include/fec.h line 169
static inline void ec_encode(struct fec *ctx, const unsigned char **ds, unsigned char **ps);
// ec_encode$link1
// file ../include/fec.h line 169
static inline void ec_encode$link1(struct fec *ctx$link1, const unsigned char **ds$link1, unsigned char **ps$link1);
// ec_init
// file ../include/fec.h line 158
static inline struct fec * ec_init(signed int d, signed int dp);
// ec_init$link1
// file ../include/fec.h line 158
static inline struct fec * ec_init$link1(signed int d$link1, signed int dp$link1);
// ec_policy_to_dp
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp(unsigned char policy, signed int *d, signed int *p);
// ec_policy_to_dp$link1
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link1(unsigned char policy$link1, signed int *d$link1, signed int *p$link1);
// ec_policy_to_dp$link2
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link2(unsigned char policy$link2, signed int *d$link2, signed int *p$link2);
// ec_policy_to_dp$link3
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link3(unsigned char policy$link3, signed int *d$link3, signed int *p$link3);
// ec_policy_to_dp$link4
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link4(unsigned char policy$link4, signed int *d$link4, signed int *p$link4);
// enough_nodes_gathered
// file group.c line 395
static _Bool enough_nodes_gathered(struct cluster_info *cinfo, struct sd_node *joining, struct rb_root *nroot, unsigned long int nr_nodes);
// entry_idx
// file object_cache.c line 101
static inline unsigned long int entry_idx(struct object_cache_entry *entry);
// entry_in_use
// file object_cache.c line 161
static inline _Bool entry_in_use(struct object_cache_entry *entry);
// entry_is_dirty
// file object_cache.c line 90
static inline _Bool entry_is_dirty(struct object_cache_entry *entry);
// epoch_log_read
// file sheep_priv.h line 360
signed int epoch_log_read(unsigned int epoch, struct sd_node *nodes, signed int len);
// epoch_log_read_remote
// file group.c line 337
signed int epoch_log_read_remote(unsigned int epoch, struct sd_node *nodes, signed int len, signed long int *timestamp, struct vnode_info *vinfo);
// epoch_log_read_with_timestamp
// file store.c line 105
signed int epoch_log_read_with_timestamp(unsigned int epoch, struct sd_node *nodes, signed int len, signed long int *timestamp);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_event_cmp
// file event.c line 179
static signed int epoll_event_cmp(struct epoll_event *_a, struct epoll_event *_b);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// err_to_sderr
// file plain_store.c line 83
static signed int err_to_sderr(const char *path, unsigned long int oid, signed int err);
// event_cmp
// file event.c line 74
static signed int event_cmp(struct event_info *e1, struct event_info *e2);
// event_force_refresh
// file event.c line 174
void event_force_refresh(void);
// event_loop
// file ../include/event.h line 15
void event_loop(signed int timeout);
// event_loop_prio
// file event.c line 223
void event_loop_prio(signed int timeout);
// eventfd
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 34
extern signed int eventfd(unsigned int, signed int);
// eventfd_read
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 37
extern signed int eventfd_read(signed int, unsigned long int *);
// eventfd_write
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 40
extern signed int eventfd_write(signed int, unsigned long int);
// eventfd_xread
// file ../include/util.h line 103
signed int eventfd_xread(signed int efd);
// eventfd_xwrite
// file ../include/util.h line 104
void eventfd_xwrite(signed int efd, signed int value);
// exec_local_req
// file request.c line 550
signed int exec_local_req(struct sd_req *rq, void *data);
// exec_local_req_async
// file request.c line 632
signed int exec_local_req_async(struct sd_req *rq, void *data, struct request_iocb *iocb);
// exec_req
// file ../include/net.h line 49
signed int exec_req(signed int sockfd, struct sd_req *hdr, void *data, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// exec_req::need_retry$object
//
_Bool need_retry$object(unsigned int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// ext_in_range
// file sd_inode.c line 252
static _Bool ext_in_range(struct sd_extent_header *header, struct sd_extent *ext);
// extent_comp
// file sd_inode.c line 108
static signed int extent_comp(void *a, void *b);
// fallocate
// file /usr/include/x86_64-linux-gnu/bits/fcntl-linux.h line 407
extern signed int fallocate(signed int, signed int, signed long int, signed long int);
// fec_decode
// file fec.c line 555
void fec_decode(struct fec *code, const unsigned char * const * const inpkts, unsigned char * const * const outpkts, const signed int * const idx, unsigned long int sz);
// fec_encode
// file ../include/fec.h line 90
void fec_encode(struct fec *code, const unsigned char * const * const src, unsigned char * const * const fecs, const signed int * const block_nums, unsigned long int num_block_nums, unsigned long int sz);
// fec_free
// file ../include/fec.h line 80
void fec_free(struct fec *p);
// fec_new
// file ../include/fec.h line 79
struct fec * fec_new(unsigned short int d, unsigned short int dp);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fetch_object_list
// file recovery.c line 905
static unsigned long int * fetch_object_list(struct sd_node *e, unsigned int epoch, unsigned long int *nr_oids);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// ffsll
// file /usr/include/string.h line 528
extern signed int ffsll(signed long long int);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fill_delete_vid_array
// file vdi.c line 942
static signed int fill_delete_vid_array(struct deletion_work *dw, unsigned int root_vid);
// fill_vdi_info
// file vdi.c line 592
static signed int fill_vdi_info(unsigned long int left, unsigned long int right, struct vdi_iocb *iocb, struct vdi_info *info);
// fill_vdi_info_range
// file vdi.c line 537
static signed int fill_vdi_info_range(unsigned int left, unsigned int right, struct vdi_iocb *iocb, struct vdi_info *info);
// fill_vdi_state_list
// file vdi.c line 175
signed int fill_vdi_state_list(void *data);
// find_cdrv
// file cluster.h line 168
static inline struct cluster_driver * find_cdrv(const char *name);
// find_cdrv$link1
// file cluster.h line 168
static inline struct cluster_driver * find_cdrv$link1(const char *name$link1);
// find_free_idx
// file vdi.c line 253
static signed int find_free_idx(unsigned int *vdi_id, unsigned long int max_idx);
// find_hdrv
// file http/http.h line 77
static inline struct http_driver * find_hdrv(struct list_head *drivers, const char *name);
// find_next_bit
// file ../include/bitops.h line 93
static inline unsigned long int find_next_bit(const unsigned long int *addr, unsigned long int size, unsigned long int offset);
// find_next_zero_bit
// file ../include/bitops.h line 52
static inline unsigned long int find_next_zero_bit(const unsigned long int *addr, unsigned long int size, unsigned long int offset);
// find_object_cache
// file object_cache.c line 607
static struct object_cache * find_object_cache(unsigned int vid, _Bool create);
// find_store_driver
// file sheep_priv.h line 261
static inline struct store_driver * find_store_driver(const char *name);
// find_store_driver$link1
// file sheep_priv.h line 261
static inline struct store_driver * find_store_driver$link1(const char *name$link1);
// find_store_driver$link2
// file sheep_priv.h line 261
static inline struct store_driver * find_store_driver$link2(const char *name$link2);
// find_string_integer
// file md.c line 162
static signed long int find_string_integer(const char *str, const char *delimiter);
// finish_object_list
// file recovery.c line 877
static void finish_object_list(struct work *work);
// finish_one_entry
// file gateway.c line 322
static inline void finish_one_entry(struct forward_info *fi, signed int i);
// finish_one_entry_err
// file gateway.c line 328
static inline void finish_one_entry_err(struct forward_info *fi, signed int i);
// finish_recovery
// file recovery.c line 725
static inline void finish_recovery(struct recovery_info *rinfo);
// finish_requests
// file gateway.c line 197
static void finish_requests(struct request *req, struct req_iter *reqs, signed int nr_to_send);
// finish_schedule_oids
// file recovery.c line 758
static inline void finish_schedule_oids(struct recovery_info *rinfo);
// fls64
// file ../include/bitops.h line 184
static inline signed int fls64(unsigned long int x);
// fnv_64a_64
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64(unsigned long int oid, unsigned long int hval);
// fnv_64a_64$link1
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link1(unsigned long int oid$link1, unsigned long int hval$link1);
// fnv_64a_64$link2
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link2(unsigned long int oid$link2, unsigned long int hval$link2);
// fnv_64a_64$link3
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link3(unsigned long int oid$link3, unsigned long int hval$link3);
// fnv_64a_64$link4
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link4(unsigned long int oid$link4, unsigned long int hval$link4);
// fnv_64a_64$link5
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link5(unsigned long int oid$link5, unsigned long int hval$link5);
// fnv_64a_64$link6
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link6(unsigned long int oid$link6, unsigned long int hval$link6);
// fnv_64a_64$link7
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link7(unsigned long int oid$link7, unsigned long int hval$link7);
// fnv_64a_buf
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf(const void *buf, unsigned long int len, unsigned long int hval);
// fnv_64a_buf$link1
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link1(const void *buf$link1, unsigned long int len$link1, unsigned long int hval$link1);
// fnv_64a_buf$link2
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link2(const void *buf$link2, unsigned long int len$link2, unsigned long int hval$link2);
// fnv_64a_buf$link3
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link3(const void *buf$link3, unsigned long int len$link3, unsigned long int hval$link3);
// fnv_64a_buf$link4
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link4(const void *buf$link4, unsigned long int len$link4, unsigned long int hval$link4);
// for_each_epoch
// file migrate.c line 88
static void for_each_epoch(signed int (*func)(unsigned int));
// for_each_epoch::func$object
//
signed int func$object(unsigned int);
// for_each_obj_path
// file sheep_priv.h line 250
signed int for_each_obj_path(signed int (*func)(const char *));
// for_each_obj_path::func$object
//
signed int func$object(const char *);
// for_each_object_in_path
// file md.c line 177
static signed int for_each_object_in_path(const char *path, signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *), _Bool cleanup, struct vnode_info *vinfo, void *arg);
// for_each_object_in_path::func$object
//
signed int func$object(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *);
// for_each_object_in_stale
// file sheep_priv.h line 246
signed int for_each_object_in_stale(signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *), void *arg);
// for_each_object_in_stale::func$object
//
signed int func$object(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *);
// for_each_object_in_wd
// file sheep_priv.h line 243
signed int for_each_object_in_wd(signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *), _Bool cleanup, void *arg);
// for_each_object_in_wd::func$object
//
signed int func$object(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_thread_name
// file logger.c line 156
static const char * format_thread_name(char *str, unsigned long int size, const char *name, signed int idx);
// forward_info_advance
// file gateway.c line 458
static inline void forward_info_advance(struct forward_info *fi, struct node_id *nid, struct sockfd *sfd, void *buf);
// forward_info_find
// file gateway.c line 335
static inline struct forward_info_entry * forward_info_find(struct forward_info *fi, signed int fd);
// forward_info_init
// file gateway.c line 449
static inline void forward_info_init(struct forward_info *fi, unsigned long int nr_to_send);
// forward_info_update
// file gateway.c line 314
static inline void forward_info_update(struct forward_info *fi, signed int pos);
// forward_iov
// file net.c line 248
static void forward_iov(struct msghdr *msg, signed int len);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/malloc.h line 53
extern void free(void *);
// free_cache_entry
// file object_cache.c line 270
static inline void free_cache_entry(struct object_cache_entry *entry);
// free_cache_entry$link1
// file sockfd_cache.c line 149
static void free_cache_entry$link1(struct sockfd_cache_entry *entry$link1);
// free_desc_cmp
// file http/oalloc.c line 195
static signed int free_desc_cmp(struct free_desc *a, struct free_desc *b);
// free_local_request
// file request.c line 529
static void free_local_request(struct request *req);
// free_logarea
// file logger.c line 350
static void free_logarea(void);
// free_recovery_info
// file recovery.c line 664
static void free_recovery_info(struct recovery_info *rinfo);
// free_recovery_list_work
// file recovery.c line 649
static void free_recovery_list_work(struct recovery_list_work *rlw);
// free_recovery_obj_work
// file recovery.c line 657
static void free_recovery_obj_work(struct recovery_obj_work *row);
// free_recovery_work
// file recovery.c line 642
static void free_recovery_work(struct recovery_work *rw);
// free_request
// file request.c line 677
static void free_request(struct request *req);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// gateway_create_and_write_obj
// file gateway.c line 607
signed int gateway_create_and_write_obj(struct request *req);
// gateway_forward_request
// file gateway.c line 469
static signed int gateway_forward_request(struct request *req);
// gateway_handle_cow
// file gateway.c line 576
static signed int gateway_handle_cow(struct request *req);
// gateway_init_fwd_hdr
// file gateway.c line 15
static inline void gateway_init_fwd_hdr(struct sd_req *fwd, struct sd_req *hdr);
// gateway_op_done
// file request.c line 90
static void gateway_op_done(struct work *work);
// gateway_read_obj
// file gateway.c line 550
signed int gateway_read_obj(struct request *req);
// gateway_remove_obj
// file gateway.c line 623
signed int gateway_remove_obj(struct request *req);
// gateway_replication_read
// file gateway.c line 248
static signed int gateway_replication_read(struct request *req);
// gateway_to_peer_opcode
// file sheep_priv.h line 425
signed int gateway_to_peer_opcode(signed int opcode);
// gateway_write_obj
// file gateway.c line 563
signed int gateway_write_obj(struct request *req);
// gdb_cmd
// file logger.c line 760
static signed int gdb_cmd(const char *cmd);
// generate_gf
// file fec.c line 143
static void generate_gf(void);
// get_buffer_sha1
// file ../include/sha1.h line 35
void get_buffer_sha1(unsigned char *buf, unsigned int len, unsigned char *sha1);
// get_cache_block_size
// file object_cache.c line 127
static inline unsigned long int get_cache_block_size(unsigned long int oid);
// get_cache_entry
// file object_cache.c line 151
static inline void get_cache_entry(struct object_cache_entry *entry);
// get_cache_entry_from
// file object_cache.c line 968
static struct object_cache_entry * get_cache_entry_from(struct object_cache *cache, unsigned long int idx);
// get_cdrv_option
// file cluster.h line 184
static inline const char * get_cdrv_option(struct cluster_driver *cdrv, const char *arg);
// get_cluster_config
// file config.c line 61
static signed int get_cluster_config(struct cluster_info *cinfo);
// get_file_size
// file migrate.c line 75
static unsigned long int get_file_size(const char *path);
// get_free_slot
// file sockfd_cache.c line 94
static inline signed int get_free_slot(struct sockfd_cache_entry *entry);
// get_hdrv_option
// file http/http.h line 94
static inline const char * get_hdrv_option(struct http_driver *hdrv, const char *arg);
// get_latest_epoch
// file sheep_priv.h line 365
unsigned int get_latest_epoch(void);
// get_local_addr
// file net.c line 493
signed int get_local_addr(unsigned char *bytes);
// get_loglevel
// file ../include/logger.h line 121
signed int get_loglevel(void);
// get_msec_time
// file work.c line 194
static unsigned long int get_msec_time(void);
// get_node_space
// file sheep_priv.h line 352
signed int get_node_space(unsigned long int *space);
// get_nr_nodes
// file sheep.c line 426
static unsigned long int get_nr_nodes(void);
// get_obj_copy_number
// file vdi.c line 124
signed int get_obj_copy_number(unsigned long int oid, signed int nr_zones);
// get_obj_list
// file sheep_priv.h line 368
signed int get_obj_list(struct sd_req *hdr, struct sd_rsp *rsp, void *data);
// get_object_path
// file plain_store.c line 584
static signed int get_object_path(unsigned long int oid, unsigned int epoch, char *path, unsigned long int size);
// get_object_sha1
// file plain_store.c line 559
static signed int get_object_sha1(const char *path, unsigned char *sha1);
// get_objsize
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize(unsigned long int oid);
// get_objsize$link1
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize$link1(unsigned long int oid$link1);
// get_objsize$link2
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize$link2(unsigned long int oid$link2);
// get_objsize$link3
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize$link3(unsigned long int oid$link3);
// get_old_new_jfile
// file journal.c line 81
static signed int get_old_new_jfile(const char *p, signed int *old, signed int *new);
// get_old_new_path
// file md.c line 567
static signed int get_old_new_path(unsigned long int oid, unsigned int epoch, unsigned char ec_index, const char *path, char *old, char *new);
// get_path_free_size
// file md.c line 237
static unsigned long int get_path_free_size(const char *path, unsigned long int *used);
// get_recovery_state
// file sheep_priv.h line 374
void get_recovery_state(struct recovery_state *state);
// get_req_copy_number
// file sheep_priv.h line 303
signed int get_req_copy_number(struct request *req);
// get_sd_op
// file sheep_priv.h line 412
struct sd_op_template * get_sd_op(unsigned char opcode);
// get_seconds
// file http/kv.c line 730
static unsigned long int get_seconds(void);
// get_store_objsize
// file sheep_priv.h line 251
unsigned long int get_store_objsize(unsigned long int oid);
// get_store_path
// file plain_store.c line 42
signed int get_store_path(unsigned long int oid, unsigned char ec_index, char *path);
// get_store_stale_path
// file plain_store.c line 68
static signed int get_store_stale_path(unsigned long int oid, unsigned int epoch, unsigned char ec_index, char *path);
// get_store_tmp_path
// file plain_store.c line 55
static signed int get_store_tmp_path(unsigned long int oid, unsigned char ec_index, char *path);
// get_thread_name
// file logger.c line 745
void get_thread_name(char *name);
// get_total_object_size
// file md.c line 145
static signed int get_total_object_size(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *total);
// get_vdi_attr
// file vdi.c line 1181
signed int get_vdi_attr(struct sheepdog_vdi_attr *vattr, signed int data_len, unsigned int vid, unsigned int *attrid, unsigned long int create_time, _Bool wr, _Bool excl, _Bool delete);
// get_vdi_bitmap_range
// file vdi.c line 501
static signed int get_vdi_bitmap_range(const char *name, unsigned long int *left, unsigned long int *right);
// get_vdi_copy_number
// file sheep_priv.h line 300
signed int get_vdi_copy_number(unsigned int vid);
// get_vdi_copy_policy
// file sheep_priv.h line 301
signed int get_vdi_copy_policy(unsigned int vid);
// get_vdi_root
// file vdi.c line 985
static unsigned long int get_vdi_root(unsigned int vid, _Bool *cloned);
// get_vdis
// file group.c line 611
static void get_vdis(struct rb_root *nroot, struct sd_node *joined);
// get_vdis_done
// file group.c line 525
static void get_vdis_done(struct work *work);
// get_vdis_from
// file group.c line 454
static signed int get_vdis_from(struct sd_node *node);
// get_vnode_info
// file sheep_priv.h line 326
struct vnode_info * get_vnode_info(void);
// get_vnode_info_epoch
// file group.c line 155
struct vnode_info * get_vnode_info_epoch(unsigned int epoch, struct vnode_info *cur_vinfo);
// get_zones_nr_from
// file group.c line 34
static signed int get_zones_nr_from(struct rb_root *nroot);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, union anonymous$22, unsigned int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettid
// file ../include/util.h line 114
signed int gettid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getxattr
// file /usr/include/x86_64-linux-gnu/sys/xattr.h line 59
extern signed long int getxattr(const char *, const char *, void *, unsigned long int);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// grab_vnode_info
// file group.c line 70
struct vnode_info * grab_vnode_info(struct vnode_info *vnode_info);
// grow_fds_done
// file sockfd_cache.c line 270
static void grow_fds_done(struct work *work);
// has_enough_zones
// file request.c line 296
static _Bool has_enough_zones(struct request *req);
// has_process_main
// file sheep_priv.h line 421
_Bool has_process_main(struct sd_op_template *op);
// has_process_work
// file sheep_priv.h line 420
_Bool has_process_work(struct sd_op_template *op);
// has_scheduled_objects
// file recovery.c line 800
static _Bool has_scheduled_objects(struct recovery_info *rinfo);
// hash
// file object_cache.c line 95
static inline signed int hash(unsigned long int vid);
// hash_64
// file ../include/sheepdog_proto.h line 380
static inline unsigned long int hash_64(unsigned long int val, unsigned int bits);
// hash_vdi_attr
// file vdi.c line 1168
static unsigned int hash_vdi_attr(struct sheepdog_vdi_attr *attr);
// hlist_add_head
// file ../include/list.h line 202
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h);
// hlist_del
// file ../include/list.h line 195
static inline void hlist_del(struct hlist_node *n);
// hlist_empty
// file ../include/list.h line 181
static inline _Bool hlist_empty(struct hlist_head *h);
// http_end_request
// file http/http.c line 234
static void http_end_request(struct http_request *req);
// http_init
// file sheep_priv.h line 514
signed int http_init(const char *options);
// http_init_request
// file http/http.c line 210
static signed int http_init_request(struct http_request *req);
// http_main_loop
// file http/http.c line 309
static void * http_main_loop(void *ignored);
// http_new_request
// file http/http.c line 299
static inline struct http_request * http_new_request(signed int sockfd);
// http_opt_default_parser
// file http/http.c line 349
static signed int http_opt_default_parser(const char *s);
// http_opt_host_parser
// file http/http.c line 337
static signed int http_opt_host_parser(const char *s);
// http_opt_port_parser
// file http/http.c line 343
static signed int http_opt_port_parser(const char *s);
// http_queue_request
// file http/http.c line 289
static void http_queue_request(struct http_request *req);
// http_request_done
// file http/http.c line 283
static void http_request_done(struct work *work);
// http_request_error
// file http/http.c line 91
static inline void http_request_error(struct http_request *req);
// http_request_read
// file http/http.c line 111
signed int http_request_read(struct http_request *req, void *buf, signed int len);
// http_request_write
// file http/http.c line 103
signed int http_request_write(struct http_request *req, const void *buf, signed int len);
// http_request_writef
// file http/http.c line 128
signed int http_request_writef(struct http_request *req, const char *fmt, ...);
// http_request_writes
// file http/http.c line 119
signed int http_request_writes(struct http_request *req, const char *str);
// http_response_header
// file http/http.c line 221
void http_response_header(struct http_request *req, enum http_status status);
// http_run_request
// file http/http.c line 240
static void http_run_request(struct work *work);
// http_run_request::1::2::4::method$object
//
void method$object(struct http_request *);
// http_time
// file http/kv.c line 1167
static char * http_time(unsigned long int time_sec);
// hval_to_vdisk
// file md.c line 78
static struct vdisk * hval_to_vdisk(unsigned long int hval);
// idx_has_vdi_bit
// file object_cache.c line 122
static inline _Bool idx_has_vdi_bit(unsigned long int idx);
// idx_in_range
// file sd_inode.c line 261
static _Bool idx_in_range(struct sd_extent_header *header, struct sd_extent_idx *idx);
// idx_to_oid
// file object_cache.c line 283
static unsigned long int idx_to_oid(unsigned int vid, unsigned long int idx);
// inc_and_log_epoch
// file group.c line 539
signed int inc_and_log_epoch(void);
// index_comp
// file sd_inode.c line 122
static signed int index_comp(void *a, void *b);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// inetaddr_is_valid
// file ../include/net.h line 64
_Bool inetaddr_is_valid(char *addr);
// init_base_path
// file sheep_priv.h line 294
signed int init_base_path(const char *d);
// init_config_file
// file sheep_priv.h line 367
signed int init_config_file(void);
// init_config_path
// file sheep_priv.h line 366
void init_config_path(const char *base_path);
// init_disk_space
// file sheep_priv.h line 295
signed int init_disk_space(const char *base_path);
// init_epoch_path
// file store.c line 251
static signed int init_epoch_path(const char *base_path);
// init_erasure_buffer
// file gateway.c line 58
static void * init_erasure_buffer(struct request *req, signed int buf_len);
// init_event
// file ../include/event.h line 11
signed int init_event(signed int nr);
// init_fec
// file ../include/fec.h line 74
void init_fec(void);
// init_global_pathnames
// file sheep_priv.h line 293
signed int init_global_pathnames(const char *d, char *argp);
// init_logmsg
// file logger.c line 381
static void init_logmsg(struct logmsg *msg, struct timeval *tv, signed int prio, const char *func, signed int line);
// init_obj_path
// file store.c line 203
static signed int init_obj_path(const char *base_path, char *argp);
// init_objlist_and_vdi_bitmap
// file plain_store.c line 234
static signed int init_objlist_and_vdi_bitmap(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *arg);
// init_path_space
// file md.c line 263
static unsigned long int init_path_space(const char *path, _Bool purge);
// init_signal
// file sheep.c line 239
static signed int init_signal(void);
// init_store_driver
// file sheep_priv.h line 292
signed int init_store_driver(_Bool is_gateway);
// init_unix_domain_socket
// file sheep_priv.h line 289
signed int init_unix_domain_socket(const char *dir);
// init_vdi_state
// file plain_store.c line 207
static signed int init_vdi_state(unsigned long int oid, const char *wd, unsigned int epoch);
// init_work_queue
// file ../include/work.h line 61
signed int init_work_queue(unsigned long int (*get_nr_nodes)(void));
// init_work_queue::get_nr_nodes$object
//
unsigned long int get_nr_nodes$object(void);
// insert_ext_entry_nosearch
// file sd_inode.c line 290
static void insert_ext_entry_nosearch(struct sd_extent_header *header, struct sd_extent *ext, unsigned int idx, unsigned int vdi_id);
// insert_idx_entry
// file sd_inode.c line 314
static void insert_idx_entry(struct sd_extent_header *header, unsigned int idx, unsigned long int oid);
// insert_idx_entry_nosearch
// file sd_inode.c line 302
static void insert_idx_entry_nosearch(struct sd_extent_header *header, struct sd_extent_idx *idx_ext, unsigned int idx, unsigned long int oid);
// insert_new_node
// file sd_inode.c line 499
static signed int insert_new_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, struct find_path *path, unsigned int idx, unsigned int vdi_id);
// insert_new_node::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// insert_new_node::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// install_crash_handler
// file ../include/util.h line 112
signed int install_crash_handler(void (*handler)(signed int));
// install_crash_handler::handler$object
//
void handler$object(signed int);
// install_sighandler
// file ../include/util.h line 111
signed int install_sighandler(signed int signum, void (*handler)(signed int), _Bool once);
// install_sighandler::handler$object
//
void handler$object(signed int);
// invalid_node
// file recovery.c line 120
static _Bool invalid_node(struct sd_node *n, struct vnode_info *info);
// io_op_done
// file request.c line 40
static void io_op_done(struct work *work);
// iocb_is_aligned
// file plain_store.c line 18
static inline _Bool iocb_is_aligned(struct siocb *iocb);
// ionic_host_parser
// file sheep.c line 372
static signed int ionic_host_parser(const char *s);
// ionic_port_parser
// file sheep.c line 378
static signed int ionic_port_parser(const char *s);
// is_access_local
// file request.c line 24
static _Bool is_access_local(struct request *req, unsigned long int oid);
// is_aligned_to_pagesize
// file sheep_priv.h line 283
static inline _Bool is_aligned_to_pagesize(void *p);
// is_cluster_formatted
// file sheep_priv.h line 353
_Bool is_cluster_formatted(void);
// is_cluster_op
// file sheep_priv.h line 414
_Bool is_cluster_op(struct sd_op_template *op);
// is_data_obj
// file ../include/sheepdog_proto.h line 405
static inline _Bool is_data_obj(unsigned long int oid);
// is_ec_dentry
// file sheep_priv.h line 507
static inline _Bool is_ec_dentry(const char *dentry);
// is_erasure_oid
// file gateway.c line 182
_Bool is_erasure_oid(unsigned long int oid);
// is_force_op
// file sheep_priv.h line 418
_Bool is_force_op(struct sd_op_template *op);
// is_gateway_op
// file sheep_priv.h line 417
_Bool is_gateway_op(struct sd_op_template *op);
// is_local_op
// file sheep_priv.h line 415
_Bool is_local_op(struct sd_op_template *op);
// is_logging_op
// file sheep_priv.h line 419
_Bool is_logging_op(struct sd_op_template *op);
// is_meta_store
// file store.c line 190
static signed int is_meta_store(const char *path);
// is_numeric
// file util.c line 399
_Bool is_numeric(const char *s);
// is_peer_op
// file sheep_priv.h line 416
_Bool is_peer_op(struct sd_op_template *op);
// is_sheep_dead
// file logger.c line 529
static _Bool is_sheep_dead(signed int signo);
// is_stale_dentry
// file sheep_priv.h line 497
static inline _Bool is_stale_dentry(const char *dentry);
// is_stale_path
// file sheep_priv.h line 492
static inline _Bool is_stale_path(const char *path);
// is_stdout_console
// file ../include/util.h line 493
static inline _Bool is_stdout_console(void);
// is_tmp_dentry
// file sheep_priv.h line 502
static inline _Bool is_tmp_dentry(const char *dentry);
// is_vdi_attr_obj
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj(unsigned long int oid);
// is_vdi_attr_obj$link1
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link1(unsigned long int oid$link1);
// is_vdi_attr_obj$link2
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link2(unsigned long int oid$link2);
// is_vdi_attr_obj$link3
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link3(unsigned long int oid$link3);
// is_vdi_attr_obj$link4
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link4(unsigned long int oid$link4);
// is_vdi_btree_obj
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj(unsigned long int oid);
// is_vdi_btree_obj$link1
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link1(unsigned long int oid$link1);
// is_vdi_btree_obj$link2
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link2(unsigned long int oid$link2);
// is_vdi_btree_obj$link3
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link3(unsigned long int oid$link3);
// is_vdi_btree_obj$link4
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link4(unsigned long int oid$link4);
// is_vdi_obj
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj(unsigned long int oid);
// is_vdi_obj$link1
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link1(unsigned long int oid$link1);
// is_vdi_obj$link2
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link2(unsigned long int oid$link2);
// is_vdi_obj$link3
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link3(unsigned long int oid$link3);
// is_vdi_obj$link4
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link4(unsigned long int oid$link4);
// is_vdi_obj$link5
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link5(unsigned long int oid$link5);
// is_vmstate_obj
// file ../include/sheepdog_proto.h line 390
static inline _Bool is_vmstate_obj(unsigned long int oid);
// is_vmstate_obj$link1
// file ../include/sheepdog_proto.h line 390
static inline _Bool is_vmstate_obj$link1(unsigned long int oid$link1);
// is_xattr_enabled
// file ../include/util.h line 116
_Bool is_xattr_enabled(const char *path);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// jfile_enough_space
// file journal.c line 309
static inline _Bool jfile_enough_space(unsigned long int size);
// journal_commit_data_done
// file journal.c line 334
static void journal_commit_data_done(struct work *work);
// journal_commit_data_work
// file journal.c line 322
static void journal_commit_data_work(struct work *work);
// journal_dir_parser
// file sheep.c line 394
static signed int journal_dir_parser(const char *s);
// journal_entry_full_write
// file journal.c line 125
static _Bool journal_entry_full_write(struct journal_descriptor *jd);
// journal_file_init
// file sheep_priv.h line 474
signed int journal_file_init(const char *path, unsigned long int size, _Bool skip);
// journal_file_write
// file journal.c line 363
static signed int journal_file_write(struct journal_descriptor *jd, const char *buf);
// journal_remove_object
// file journal.c line 424
signed int journal_remove_object(unsigned long int oid);
// journal_size_parser
// file sheep.c line 400
static signed int journal_size_parser(const char *s);
// journal_skip_parser
// file sheep.c line 413
static signed int journal_skip_parser(const char *s);
// journal_write_store
// file journal.c line 409
signed int journal_write_store(unsigned long int oid, const char *buf, unsigned long int size, signed long int offset, _Bool create);
// kick_background_pusher
// file object_cache.c line 240
static void kick_background_pusher(struct object_cache *oc);
// kick_node_recover
// file group.c line 972
static void kick_node_recover(void);
// kick_recover
// file md.c line 510
static inline void kick_recover(void);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// kv_create_account
// file http/kv.c line 114
signed int kv_create_account(const char *account);
// kv_create_bucket
// file http/kv.c line 513
signed int kv_create_bucket(const char *account, const char *bucket);
// kv_create_hyper_volume
// file http/kv.c line 63
static signed int kv_create_hyper_volume(const char *name, unsigned int *vdi_id);
// kv_create_object
// file http/kv.c line 1032
signed int kv_create_object(struct http_request *req, const char *account, const char *bucket, const char *name);
// kv_delete_account
// file http/kv.c line 202
signed int kv_delete_account(struct http_request *req, const char *account);
// kv_delete_bucket
// file http/kv.c line 574
signed int kv_delete_bucket(const char *account, const char *bucket);
// kv_delete_object
// file http/kv.c line 1116
signed int kv_delete_object(const char *account, const char *bucket, const char *name);
// kv_iterate_bucket
// file http/kv.c line 598
signed int kv_iterate_bucket(const char *account, void (*cb)(const char *, void *), void *opaque);
// kv_iterate_bucket::cb$object
//
void cb$object(const char *, void *);
// kv_iterate_object
// file http/kv.c line 1148
signed int kv_iterate_object(const char *account, const char *bucket, void (*cb)(const char *, void *), void *opaque);
// kv_iterate_object::cb$object
//
void cb$object(const char *, void *);
// kv_read_account_meta
// file http/kv.c line 180
signed int kv_read_account_meta(struct http_request *req, const char *account);
// kv_read_bucket
// file http/kv.c line 542
signed int kv_read_bucket(struct http_request *req, const char *account, const char *bucket);
// kv_read_object
// file http/kv.c line 1090
signed int kv_read_object(struct http_request *req, const char *account, const char *bucket, const char *name);
// kv_read_object_meta
// file http/kv.c line 1176
signed int kv_read_object_meta(struct http_request *req, const char *account, const char *bucket, const char *name);
// kv_update_account
// file http/kv.c line 196
signed int kv_update_account(const char *account);
// kv_update_bucket
// file http/kv.c line 567
signed int kv_update_bucket(const char *account, const char *bucket);
// leave_cluster
// file sheep_priv.h line 342
signed int leave_cluster(void);
// lfind
// file /usr/include/search.h line 164
extern void * lfind(const void *, const void *, unsigned long int *, unsigned long int, signed int (*)(const void *, const void *));
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// list_add
// file ../include/list.h line 82
static inline void list_add(struct list_node *new, struct list_head *head);
// list_add_tail
// file ../include/list.h line 87
static inline void list_add_tail(struct list_node *new, struct list_head *head);
// list_add_tail$link1
// file ../include/list.h line 87
static inline void list_add_tail$link1(struct list_node *new$link1, struct list_head *head$link1);
// list_add_tail$link2
// file ../include/list.h line 87
static inline void list_add_tail$link2(struct list_node *new$link2, struct list_head *head$link2);
// list_add_tail$link3
// file ../include/list.h line 87
static inline void list_add_tail$link3(struct list_node *new$link3, struct list_head *head$link3);
// list_add_tail$link4
// file ../include/list.h line 87
static inline void list_add_tail$link4(struct list_node *new$link4, struct list_head *head$link4);
// list_del
// file ../include/list.h line 103
static inline void list_del(struct list_node *entry);
// list_del$link1
// file ../include/list.h line 103
static inline void list_del$link1(struct list_node *entry$link1);
// list_del$link2
// file ../include/list.h line 103
static inline void list_del$link2(struct list_node *entry$link2);
// list_del$link3
// file ../include/list.h line 103
static inline void list_del$link3(struct list_node *entry$link3);
// list_empty
// file ../include/list.h line 42
static inline _Bool list_empty(struct list_head *head);
// list_empty$link1
// file ../include/list.h line 42
static inline _Bool list_empty$link1(struct list_head *head$link1);
// list_empty$link2
// file ../include/list.h line 42
static inline _Bool list_empty$link2(struct list_head *head$link2);
// list_empty$link3
// file ../include/list.h line 42
static inline _Bool list_empty$link3(struct list_head *head$link3);
// list_empty$link4
// file ../include/list.h line 42
static inline _Bool list_empty$link4(struct list_head *head$link4);
// list_linked
// file ../include/list.h line 47
static inline _Bool list_linked(struct list_node *node);
// list_move_tail
// file ../include/list.h line 115
static inline void list_move_tail(struct list_node *list, struct list_head *head);
// list_move_tail$link1
// file ../include/list.h line 115
static inline void list_move_tail$link1(struct list_node *list$link1, struct list_head *head$link1);
// list_sort
// file util.c line 700
void list_sort(void *priv, struct list_head *head, signed int (*cmp)(void *, struct list_node *, struct list_node *));
// list_sort::cmp$object
//
signed int cmp$object(void *, struct list_node *, struct list_node *);
// list_splice_init
// file ../include/list.h line 136
static inline void list_splice_init(struct list_head *list, struct list_head *head);
// list_splice_init$link1
// file ../include/list.h line 136
static inline void list_splice_init$link1(struct list_head *list$link1, struct list_head *head$link1);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// listen_handler
// file request.c line 987
static void listen_handler(signed int listen_fd, signed int events, void *data);
// load_cache
// file object_cache.c line 1261
static signed int load_cache(void);
// load_cache_object
// file object_cache.c line 1214
static signed int load_cache_object(struct object_cache *cache);
// local_cache_purge
// file ops.c line 804
static signed int local_cache_purge(struct request *req);
// local_discard_obj
// file ops.c line 839
static signed int local_discard_obj(struct request *req);
// local_flush_and_del
// file ops.c line 872
static signed int local_flush_and_del(struct request *req);
// local_flush_vdi
// file ops.c line 827
static signed int local_flush_vdi(struct request *req);
// local_get_cache_info
// file ops.c line 793
static signed int local_get_cache_info(struct request *request);
// local_get_epoch
// file ops.c line 508
static signed int local_get_epoch(struct request *req);
// local_get_hash
// file ops.c line 781
static signed int local_get_hash(struct request *request);
// local_get_loglevel
// file ops.c line 991
static signed int local_get_loglevel(struct request *req);
// local_get_node_list
// file group.c line 175
signed int local_get_node_list(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_get_obj_list
// file ops.c line 503
static signed int local_get_obj_list(struct request *req);
// local_get_store_list
// file ops.c line 392
static signed int local_get_store_list(struct request *req);
// local_get_vdi_copies
// file ops.c line 412
static signed int local_get_vdi_copies(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_kill_node
// file ops.c line 914
static signed int local_kill_node(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_md_info
// file ops.c line 755
static signed int local_md_info(struct request *request);
// local_md_plug
// file ops.c line 765
static signed int local_md_plug(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_md_unplug
// file ops.c line 773
static signed int local_md_unplug(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_node_copy_index
// file recovery.c line 447
static unsigned char local_node_copy_index(struct vnode_info *vinfo, unsigned long int oid);
// local_op_done
// file request.c line 135
static void local_op_done(struct work *work);
// local_read_vdis
// file ops.c line 406
static signed int local_read_vdis(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_release_vdi
// file ops.c line 371
static signed int local_release_vdi(struct request *req);
// local_req_async_main
// file request.c line 621
static void local_req_async_main(struct work *work);
// local_req_async_work
// file request.c line 614
static void local_req_async_work(struct work *work);
// local_req_handler
// file request.c line 1079
static void local_req_handler(signed int listen_fd, signed int events, void *data);
// local_req_init
// file request.c line 578
struct request_iocb * local_req_init(void);
// local_req_wait
// file request.c line 592
signed int local_req_wait(struct request_iocb *iocb);
// local_request_init
// file sheep_priv.h line 390
void local_request_init(void);
// local_sd_stat
// file ops.c line 818
static signed int local_sd_stat(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_set_loglevel
// file ops.c line 1004
static signed int local_set_loglevel(struct request *req);
// local_stat_cluster
// file ops.c line 437
static signed int local_stat_cluster(struct request *req);
// local_stat_recovery
// file ops.c line 428
static signed int local_stat_recovery(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_stat_sheep
// file ops.c line 420
static signed int local_stat_sheep(struct request *req);
// local_trace_disable
// file ops.c line 885
static signed int local_trace_disable(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_trace_enable
// file ops.c line 879
static signed int local_trace_enable(struct sd_req *req, struct sd_rsp *rsp, void *data);
// local_trace_read_buf
// file ops.c line 899
static signed int local_trace_read_buf(struct request *request);
// local_trace_status
// file ops.c line 891
static signed int local_trace_status(struct sd_req *req, struct sd_rsp *rsp, void *data);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// lock_and_daemon
// file sheep.c line 517
static signed int lock_and_daemon(_Bool daemonize, const char *base_dir);
// lock_base_dir
// file sheep_priv.h line 296
signed int lock_base_dir(const char *d);
// lockf
// file /usr/include/fcntl.h line 221
extern signed int lockf(signed int, signed int, signed long int);
// log_close
// file ../include/logger.h line 43
void log_close(void);
// log_dir_parser
// file sheep.c line 336
static signed int log_dir_parser(const char *s);
// log_dst_parser
// file sheep.c line 356
static signed int log_dst_parser(const char *s);
// log_flush
// file logger.c line 494
static void log_flush(void);
// log_format_parser
// file sheep.c line 348
static signed int log_format_parser(const char *s);
// log_init
// file ../include/logger.h line 41
signed int log_init(const char *program_name, enum log_dst_type type, signed int level, char *outfile);
// log_level_parser
// file sheep.c line 320
static signed int log_level_parser(const char *s);
// log_syslog
// file logger.c line 360
static void log_syslog(struct logmsg *msg);
// log_write
// file ../include/logger.h line 45
void log_write(signed int prio, const char *func, signed int line, const char *fmt, ...);
// logarea_init
// file logger.c line 289
static signed int logarea_init(signed int size);
// logger
// file logger.c line 560
static void logger(char *log_dir, char *outfile);
// loglevel_str2num
// file ../include/logger.h line 98
static inline signed int loglevel_str2num(const char *str);
// lookup_event
// file event.c line 92
static struct event_info * lookup_event(signed int fd);
// lookup_path
// file object_cache.c line 706
static inline signed int lookup_path(char *path);
// lru_tree_insert
// file object_cache.c line 209
static struct object_cache_entry * lru_tree_insert(struct rb_root *root, struct object_cache_entry *new);
// lru_tree_search
// file object_cache.c line 214
static struct object_cache_entry * lru_tree_search(struct rb_root *root, unsigned long int idx);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// make_path
// file util.c line 554
void make_path(char *path, unsigned long int size, unsigned long int nr_segs, const char **segs);
// make_stale_dir
// file plain_store.c line 168
static signed int make_stale_dir(const char *path);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mallopt
// file /usr/include/malloc.h line 121
extern signed int mallopt(signed int, signed int);
// md_access
// file md.c line 556
static inline _Bool md_access(const char *path);
// md_add_disk
// file sheep_priv.h line 481
_Bool md_add_disk(const char *path, _Bool purge);
// md_check_and_move
// file md.c line 639
static signed int md_check_and_move(unsigned long int oid, unsigned int epoch, unsigned char ec_index, const char *path);
// md_del_disk
// file md.c line 744
static inline void md_del_disk(const char *path);
// md_do_recover
// file md.c line 518
static void md_do_recover(struct work *work);
// md_exist
// file sheep_priv.h line 485
_Bool md_exist(unsigned long int oid, unsigned char ec_index);
// md_get_info
// file sheep_priv.h line 487
unsigned int md_get_info(struct sd_md_info *info);
// md_get_object_dir
// file sheep_priv.h line 483
const char * md_get_object_dir(unsigned long int oid);
// md_get_object_dir_nolock
// file md.c line 356
static const char * md_get_object_dir_nolock(unsigned long int oid);
// md_get_size
// file sheep_priv.h line 490
unsigned long int md_get_size(unsigned long int *used);
// md_get_stale_path
// file sheep_priv.h line 486
signed int md_get_stale_path(unsigned long int oid, unsigned int epoch, unsigned char ec_index, char *path);
// md_handle_eio
// file sheep_priv.h line 484
signed int md_handle_eio(const char *fault_path);
// md_init_space
// file sheep_priv.h line 482
unsigned long int md_init_space(void);
// md_move_object
// file md.c line 606
static signed int md_move_object(unsigned long int oid, const char *old, const char *new);
// md_plug_disks
// file sheep_priv.h line 488
signed int md_plug_disks(char *disks);
// md_remove_disk
// file md.c line 342
static inline void md_remove_disk(struct disk *disk);
// md_unplug_disks
// file sheep_priv.h line 489
signed int md_unplug_disks(char *disks);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// mempcpy
// file /usr/include/string.h line 390
extern void * mempcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// merge
// file util.c line 616
static struct list_node * merge(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_node *a, struct list_node *b);
// merge::cmp$object
//
signed int cmp$object(void *, struct list_node *, struct list_node *);
// merge_and_restore_back_links
// file util.c line 646
static void merge_and_restore_back_links(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_head *head, struct list_node *a, struct list_node *b);
// merge_and_restore_back_links::cmp$object
//
signed int cmp$object(void *, struct list_node *, struct list_node *);
// migrate_from_v0_to_v1
// file migrate.c line 260
static signed int migrate_from_v0_to_v1(void);
// migrate_from_v1_to_v2
// file migrate.c line 385
static signed int migrate_from_v1_to_v2(void);
// migrate_from_v2_to_v3
// file migrate.c line 421
static signed int migrate_from_v2_to_v3(void);
// migrate_from_v3_to_v4
// file migrate.c line 475
static signed int migrate_from_v3_to_v4(void);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// modify_event
// file event.c line 148
signed int modify_event(signed int fd, unsigned int new_events);
// modnn
// file fec.c line 89
static unsigned char modnn(signed int x);
// move_object_to_stale_dir
// file plain_store.c line 474
static signed int move_object_to_stale_dir(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *arg);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// my_exe_path
// file ../include/util.h line 117
const char * my_exe_path(void);
// node_cmp
// file ../include/sheep.h line 196
static inline signed int node_cmp(struct sd_node *node1, struct sd_node *node2);
// node_cmp$link1
// file ../include/sheep.h line 196
static inline signed int node_cmp$link1(struct sd_node *node1$link1, struct sd_node *node2$link1);
// node_cmp$link2
// file ../include/sheep.h line 196
static inline signed int node_cmp$link2(struct sd_node *node1$link2, struct sd_node *node2$link2);
// node_eq
// file ../include/sheep.h line 202
static inline _Bool node_eq(struct sd_node *a, struct sd_node *b);
// node_eq$link1
// file ../include/sheep.h line 202
static inline _Bool node_eq$link1(struct sd_node *a$link1, struct sd_node *b$link1);
// node_id_cmp
// file ../include/sheep.h line 186
static inline signed int node_id_cmp(struct node_id *node1, struct node_id *node2);
// node_id_cmp$link1
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link1(struct node_id *node1$link1, struct node_id *node2$link1);
// node_id_cmp$link2
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link2(struct node_id *node1$link2, struct node_id *node2$link2);
// node_id_cmp$link3
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link3(struct node_id *node1$link3, struct node_id *node2$link3);
// node_id_cmp$link4
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link4(struct node_id *node1$link4, struct node_id *node2$link4);
// node_id_cmp$link5
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link5(struct node_id *node1$link5, struct node_id *node2$link5);
// node_id_cmp$link6
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link6(struct node_id *node1$link6, struct node_id *node2$link6);
// node_in_recovery
// file sheep_priv.h line 373
_Bool node_in_recovery(void);
// node_is_gateway_only
// file recovery.c line 92
static inline _Bool node_is_gateway_only(void);
// node_is_local
// file sheep_priv.h line 434
static inline _Bool node_is_local(struct sd_node *n);
// node_is_local$link1
// file sheep_priv.h line 434
static inline _Bool node_is_local$link1(struct sd_node *n$link1);
// node_size_varied
// file ops.c line 717
static _Bool node_size_varied(void);
// node_to_str
// file ../include/sheep.h line 244
static inline const char * node_to_str(struct sd_node *id);
// node_to_str$link1
// file ../include/sheep.h line 244
static inline const char * node_to_str$link1(struct sd_node *id$link1);
// node_to_str$link2
// file ../include/sheep.h line 244
static inline const char * node_to_str$link2(struct sd_node *id$link2);
// node_to_vnodes
// file ../include/sheep.h line 208
static inline void node_to_vnodes(struct sd_node *n, struct rb_root *vroot);
// nodes_to_buffer
// file ../include/sheep.h line 233
static inline void nodes_to_buffer(struct rb_root *nroot, void *buffer);
// nodes_to_buffer$link1
// file ../include/sheep.h line 233
static inline void nodes_to_buffer$link1(struct rb_root *nroot$link1, void *buffer$link1);
// nodes_to_buffer$link2
// file ../include/sheep.h line 233
static inline void nodes_to_buffer$link2(struct rb_root *nroot$link2, void *buffer$link2);
// nodes_to_vnodes
// file ../include/sheep.h line 225
static inline void nodes_to_vnodes(struct rb_root *nroot, struct rb_root *vroot);
// notify_recovery_completion_main
// file recovery.c line 718
static void notify_recovery_completion_main(struct work *work);
// notify_recovery_completion_work
// file recovery.c line 701
static void notify_recovery_completion_work(struct work *work);
// notify_vdi_add
// file vdi.c line 631
static signed int notify_vdi_add(unsigned int vdi_id, unsigned int nr_copies, unsigned int old_vid, unsigned char copy_policy);
// notify_vdi_deletion
// file vdi.c line 798
static signed int notify_vdi_deletion(unsigned int vdi_id);
// nr_online_disks
// file md.c line 46
static inline signed int nr_online_disks(void);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// oalloc_free
// file http/http.h line 153
signed int oalloc_free(unsigned int vid, unsigned long int start, unsigned long int count);
// oalloc_init
// file http/http.h line 154
signed int oalloc_init(unsigned int vid);
// oalloc_meta_length
// file http/oalloc.c line 47
static inline unsigned int oalloc_meta_length(struct header *hd);
// oalloc_new_finish
// file http/http.h line 152
signed int oalloc_new_finish(unsigned int vid, unsigned long int start, unsigned long int count);
// oalloc_new_prepare
// file http/http.h line 151
signed int oalloc_new_prepare(unsigned int vid, unsigned long int *start, unsigned long int count);
// obj_cmp
// file recovery.c line 84
static signed int obj_cmp(const unsigned long int *oid1, const unsigned long int *oid2);
// object_cache_cmp
// file object_cache.c line 106
static signed int object_cache_cmp(struct object_cache_entry *a, struct object_cache_entry *b);
// object_cache_delete
// file sheep_priv.h line 459
void object_cache_delete(unsigned int vid);
// object_cache_flush_and_del
// file sheep_priv.h line 458
signed int object_cache_flush_and_del(struct request *req);
// object_cache_flush_and_delete
// file object_cache.c line 1001
static signed int object_cache_flush_and_delete(struct object_cache *oc);
// object_cache_flush_vdi
// file sheep_priv.h line 457
signed int object_cache_flush_vdi(unsigned int vid);
// object_cache_format
// file sheep_priv.h line 448
void object_cache_format(void);
// object_cache_get_info
// file sheep_priv.h line 462
signed int object_cache_get_info(struct object_cache_info *info);
// object_cache_handle_request
// file sheep_priv.h line 452
signed int object_cache_handle_request(struct request *req);
// object_cache_init
// file sheep_priv.h line 460
signed int object_cache_init(const char *p);
// object_cache_lookup
// file object_cache.c line 721
static signed int object_cache_lookup(struct object_cache *oc, unsigned long int idx, _Bool create, _Bool writeback);
// object_cache_oid_to_idx
// file object_cache.c line 112
static inline unsigned long int object_cache_oid_to_idx(unsigned long int oid);
// object_cache_pull
// file object_cache.c line 802
static signed int object_cache_pull(struct object_cache *oc, unsigned long int idx);
// object_cache_push
// file object_cache.c line 893
static signed int object_cache_push(struct object_cache *oc);
// object_cache_read
// file sheep_priv.h line 455
signed int object_cache_read(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset);
// object_cache_remove
// file sheep_priv.h line 461
signed int object_cache_remove(unsigned long int oid);
// object_cache_try_to_reclaim
// file object_cache.c line 649
static void object_cache_try_to_reclaim(signed int delay);
// object_cache_write
// file sheep_priv.h line 453
signed int object_cache_write(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset, _Bool create);
// object_is_cached
// file sheep_priv.h line 450
_Bool object_is_cached(unsigned long int oid);
// object_iterater
// file http/kv.c line 461
static void object_iterater(void *data, enum btree_node_type type, void *arg);
// objlist_cache_cleanup
// file sheep_priv.h line 369
signed int objlist_cache_cleanup(unsigned int vid);
// objlist_cache_cmp
// file object_list_cache.c line 41
static signed int objlist_cache_cmp(struct objlist_cache_entry *a, struct objlist_cache_entry *b);
// objlist_cache_insert
// file object_list_cache.c line 77
signed int objlist_cache_insert(unsigned long int oid);
// objlist_cache_rb_insert
// file object_list_cache.c line 47
static struct objlist_cache_entry * objlist_cache_rb_insert(struct rb_root *root, struct objlist_cache_entry *new);
// objlist_cache_rb_remove
// file object_list_cache.c line 53
static signed int objlist_cache_rb_remove(struct rb_root *root, unsigned long int oid);
// objlist_cache_remove
// file sheep_priv.h line 395
void objlist_cache_remove(unsigned long int oid);
// objlist_deletion_done
// file object_list_cache.c line 172
static void objlist_deletion_done(struct work *work);
// objlist_deletion_work
// file object_list_cache.c line 135
static void objlist_deletion_work(struct work *work);
// oid_cmp
// file ../include/sheep.h line 181
static inline signed int oid_cmp(const unsigned long int *oid1, const unsigned long int *oid2);
// oid_in_prio_oids
// file recovery.c line 742
static inline _Bool oid_in_prio_oids(struct recovery_info *rinfo, unsigned long int oid);
// oid_in_recovery
// file sheep_priv.h line 372
_Bool oid_in_recovery(unsigned long int oid);
// oid_is_readonly
// file sheep_priv.h line 299
_Bool oid_is_readonly(unsigned long int oid);
// oid_stale
// file plain_store.c line 449
static _Bool oid_stale(unsigned long int oid, signed int ec_index, struct vnode_info *vinfo);
// oid_to_entry
// file object_cache.c line 985
static struct object_cache_entry * oid_to_entry(unsigned long int oid);
// oid_to_first_vnode
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode(unsigned long int oid, struct rb_root *root);
// oid_to_first_vnode$link1
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode$link1(unsigned long int oid$link1, struct rb_root *root$link1);
// oid_to_first_vnode$link2
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode$link2(unsigned long int oid$link2, struct rb_root *root$link2);
// oid_to_first_vnode$link3
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode$link3(unsigned long int oid$link3, struct rb_root *root$link3);
// oid_to_node
// file ../include/sheep.h line 99
static inline struct sd_node * oid_to_node(unsigned long int oid, struct rb_root *root, signed int copy_idx);
// oid_to_nodes
// file ../include/sheep.h line 108
static inline void oid_to_nodes(unsigned long int oid, struct rb_root *root, signed int nr_copies, struct sd_node **nodes);
// oid_to_vdisk
// file md.c line 85
static struct vdisk * oid_to_vdisk(unsigned long int oid);
// oid_to_vid
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid(unsigned long int oid);
// oid_to_vid$link1
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link1(unsigned long int oid$link1);
// oid_to_vid$link2
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link2(unsigned long int oid$link2);
// oid_to_vid$link3
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link3(unsigned long int oid$link3);
// oid_to_vid$link4
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link4(unsigned long int oid$link4);
// oid_to_vid$link5
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link5(unsigned long int oid$link5);
// oid_to_vid$link6
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link6(unsigned long int oid$link6);
// oid_to_vid$link7
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link7(unsigned long int oid$link7);
// oid_to_vnode
// file ../include/sheep.h line 89
static inline struct sd_vnode * oid_to_vnode(unsigned long int oid, struct rb_root *root, signed int copy_idx);
// oid_to_vnodes
// file ../include/sheep.h line 67
static inline void oid_to_vnodes(unsigned long int oid, struct rb_root *root, signed int nr_copies, struct sd_vnode **vnodes);
// oid_to_vnodes$link1
// file ../include/sheep.h line 67
static inline void oid_to_vnodes$link1(unsigned long int oid$link1, struct rb_root *root$link1, signed int nr_copies$link1, struct sd_vnode **vnodes$link1);
// oid_to_vnodes$link2
// file ../include/sheep.h line 67
static inline void oid_to_vnodes$link2(unsigned long int oid$link2, struct rb_root *root$link2, signed int nr_copies$link2, struct sd_vnode **vnodes$link2);
// oid_to_vnodes$link3
// file ../include/sheep.h line 67
static inline void oid_to_vnodes$link3(unsigned long int oid$link3, struct rb_root *root$link3, signed int nr_copies$link3, struct sd_vnode **vnodes$link3);
// onode_create
// file http/kv.c line 800
static signed int onode_create(struct kv_onode *onode, unsigned int bucket_vid);
// onode_delete
// file http/kv.c line 1008
static signed int onode_delete(struct kv_onode *onode);
// onode_do_create
// file http/kv.c line 766
static signed int onode_do_create(struct kv_onode *onode, struct sd_inode *inode, unsigned int idx, _Bool create);
// onode_free_data
// file http/kv.c line 847
static signed int onode_free_data(struct kv_onode *onode);
// onode_lookup
// file http/kv.c line 919
static signed int onode_lookup(struct kv_onode *onode, unsigned int ovid, const char *name);
// onode_populate_data
// file http/kv.c line 740
static signed int onode_populate_data(struct kv_onode *onode, struct http_request *req);
// onode_populate_extents
// file http/kv.c line 678
static signed int onode_populate_extents(struct kv_onode *onode, struct http_request *req);
// onode_read_data
// file http/kv.c line 963
static signed int onode_read_data(struct kv_onode *onode, struct http_request *req);
// onode_read_extents
// file http/kv.c line 861
static signed int onode_read_extents(struct kv_onode *onode, struct http_request *req);
// op_name
// file sheep_priv.h line 413
const char * op_name(struct sd_op_template *op);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// option_get_help
// file ../include/option.h line 32
const char * option_get_help(struct sd_option *sd_opts, signed int ch);
// option_parse
// file ../include/option.h line 33
signed int option_parse(char *arg, const char *delim, struct option_parser *parsers);
// option_parse_size
// file ../include/option.h line 34
signed int option_parse_size(const char *value, unsigned long int *ret);
// path_to_disk
// file md.c line 135
static struct disk * path_to_disk(const char *path);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// peer_create_and_write_obj
// file ops.c line 976
static signed int peer_create_and_write_obj(struct request *req);
// peer_read_obj
// file sheep_priv.h line 229
signed int peer_read_obj(struct request *req);
// peer_remove_obj
// file ops.c line 923
static signed int peer_remove_obj(struct request *req);
// peer_write_obj
// file ops.c line 960
static signed int peer_write_obj(struct request *req);
// pfd_info_init
// file gateway.c line 350
static inline void pfd_info_init(struct forward_info *fi, struct pfd_info *pi);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// post_cluster_del_vdi
// file ops.c line 183
static signed int post_cluster_del_vdi(struct sd_req *req, struct sd_rsp *rsp, void *data);
// post_cluster_new_vdi
// file ops.c line 121
static signed int post_cluster_new_vdi(struct sd_req *req, struct sd_rsp *rsp, void *data);
// pread
// file /usr/include/unistd.h line 376
extern signed long int pread(signed int, void *, unsigned long int, signed long int);
// prealloc
// file sheep_priv.h line 392
signed int prealloc(signed int fd, unsigned int size);
// prepare_cluster_msg
// file group.c line 198
static struct vdi_op_message * prepare_cluster_msg(struct request *req, unsigned long int *sizep);
// prepare_erasure_requests
// file gateway.c line 107
static struct req_iter * prepare_erasure_requests(struct request *req, signed int *nr);
// prepare_iocb
// file plain_store.c line 23
static signed int prepare_iocb(unsigned long int oid, struct siocb *iocb, _Bool create);
// prepare_object_list
// file recovery.c line 980
static void prepare_object_list(struct work *work);
// prepare_replication_requests
// file gateway.c line 29
static struct req_iter * prepare_replication_requests(struct request *req, signed int *nr);
// prepare_requests
// file gateway.c line 189
static struct req_iter * prepare_requests(struct request *req, signed int *nr);
// prepare_schedule_oid
// file recovery.c line 558
static inline void prepare_schedule_oid(unsigned long int oid);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pstrcpy
// file ../include/util.h line 105
void pstrcpy(char *buf, signed int buf_size, const char *str);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$7 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$7 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$7 *, const union anonymous$21 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$7 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$7 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$21 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 895
extern signed int pthread_rwlock_destroy(union anonymous$4 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous$4 *, const union anonymous$24 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous$4 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous$4 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous$4 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_yield
// file /usr/include/pthread.h line 471
extern signed int pthread_yield(void);
// purge_dir
// file plain_store.c line 180
static signed int purge_dir(const char *path);
// purge_directory
// file ../include/util.h line 108
signed int purge_directory(const char *dir_path);
// purge_stale_dir
// file plain_store.c line 188
static signed int purge_stale_dir(const char *path);
// push_cache_object
// file object_cache.c line 453
static signed int push_cache_object(unsigned int vid, unsigned long int idx, unsigned long int bmap, _Bool create);
// push_object_done
// file object_cache.c line 878
static void push_object_done(struct work *work);
// put_cache_entry
// file object_cache.c line 156
static inline void put_cache_entry(struct object_cache_entry *entry);
// put_request
// file sheep_priv.h line 397
void put_request(struct request *req);
// put_vnode_info
// file sheep_priv.h line 327
void put_vnode_info(struct vnode_info *vnode_info);
// pwrite
// file /usr/include/unistd.h line 384
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// queue_cluster_request
// file group.c line 297
void queue_cluster_request(struct request *req);
// queue_gateway_request
// file request.c line 303
static void queue_gateway_request(struct request *req);
// queue_local_request
// file request.c line 350
static void queue_local_request(struct request *req);
// queue_peer_request
// file request.c line 269
static void queue_peer_request(struct request *req);
// queue_recovery_work
// file recovery.c line 1072
static void queue_recovery_work(struct recovery_info *rinfo);
// queue_request
// file request.c line 425
static void queue_request(struct request *req);
// queue_work
// file ../include/work.h line 64
void queue_work(struct work_queue *q, struct work *work);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// rb_erase
// file ../include/rbtree.h line 57
void rb_erase(struct rb_node *node, struct rb_root *root);
// rb_first
// file ../include/rbtree.h line 62
struct rb_node * rb_first(struct rb_root *root);
// rb_init_node
// file ../include/rbtree.h line 48
static inline void rb_init_node(struct rb_node *rb);
// rb_insert_color
// file ../include/rbtree.h line 56
void rb_insert_color(struct rb_node *node, struct rb_root *root);
// rb_last
// file rbtree.c line 267
struct rb_node * rb_last(struct rb_root *root);
// rb_link_node
// file ../include/rbtree.h line 69
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link);
// rb_link_node$link1
// file ../include/rbtree.h line 69
static inline void rb_link_node$link1(struct rb_node *node$link1, struct rb_node *parent$link1, struct rb_node **rb_link$link1);
// rb_link_node$link2
// file ../include/rbtree.h line 69
static inline void rb_link_node$link2(struct rb_node *node$link2, struct rb_node *parent$link2, struct rb_node **rb_link$link2);
// rb_link_node$link3
// file ../include/rbtree.h line 69
static inline void rb_link_node$link3(struct rb_node *node$link3, struct rb_node *parent$link3, struct rb_node **rb_link$link3);
// rb_link_node$link4
// file ../include/rbtree.h line 69
static inline void rb_link_node$link4(struct rb_node *node$link4, struct rb_node *parent$link4, struct rb_node **rb_link$link4);
// rb_link_node$link5
// file ../include/rbtree.h line 69
static inline void rb_link_node$link5(struct rb_node *node$link5, struct rb_node *parent$link5, struct rb_node **rb_link$link5);
// rb_link_node$link6
// file ../include/rbtree.h line 69
static inline void rb_link_node$link6(struct rb_node *node$link6, struct rb_node *parent$link6, struct rb_node **rb_link$link6);
// rb_link_node$link7
// file ../include/rbtree.h line 69
static inline void rb_link_node$link7(struct rb_node *node$link7, struct rb_node *parent$link7, struct rb_node **rb_link$link7);
// rb_next
// file ../include/rbtree.h line 60
struct rb_node * rb_next(struct rb_node *node);
// rb_prev
// file rbtree.c line 311
struct rb_node * rb_prev(struct rb_node *node);
// rb_replace_node
// file rbtree.c line 339
void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);
// rb_set_color
// file ../include/rbtree.h line 31
static inline void rb_set_color(struct rb_node *rb, signed int color);
// rb_set_parent
// file ../include/rbtree.h line 27
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p);
// rb_set_parent$link1
// file ../include/rbtree.h line 27
static inline void rb_set_parent$link1(struct rb_node *rb$link1, struct rb_node *p$link1);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_account_meta
// file http/kv.c line 150
static signed int read_account_meta(const char *account, unsigned long int *bucket_count, unsigned long int *object_count, unsigned long int *used);
// read_backend_object
// file store.c line 400
signed int read_backend_object(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset);
// read_cache_object
// file object_cache.c line 383
static signed int read_cache_object(struct object_cache_entry *entry, void *buf, unsigned long int count, signed long int offset);
// read_cache_object_noupdate
// file object_cache.c line 310
static signed int read_cache_object_noupdate(unsigned int vid, unsigned long int idx, void *buf, unsigned long int count, signed long int offset);
// read_erasure_object
// file recovery.c line 158
static void * read_erasure_object(unsigned long int oid, unsigned char idx, struct recovery_obj_work *row);
// read_lock_cache
// file object_cache.c line 178
static inline void read_lock_cache(struct object_cache *oc);
// read_lock_entry
// file object_cache.c line 193
static inline void read_lock_entry(struct object_cache_entry *entry);
// read_vdis
// file vdi.c line 750
signed int read_vdis(char *data, signed int len, unsigned int *rsp_len);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// rebase_vdi
// file vdi.c line 433
static signed int rebase_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int base_vid, unsigned int cur_vid);
// rebuild_erasure_object
// file recovery.c line 403
static void * rebuild_erasure_object(unsigned long int oid, unsigned char idx, struct recovery_obj_work *row);
// recalculate_vnodes
// file group.c line 103
static void recalculate_vnodes(struct rb_root *nroot);
// reclaim_done
// file object_cache.c line 587
static void reclaim_done(struct work *work);
// recover_erasure_object
// file recovery.c line 478
static signed int recover_erasure_object(struct recovery_obj_work *row);
// recover_next_object
// file recovery.c line 805
static void recover_next_object(struct recovery_info *rinfo);
// recover_object_from
// file recovery.c line 226
static signed int recover_object_from(struct recovery_obj_work *row, struct sd_node *node, unsigned int tgt_epoch);
// recover_object_from_replica
// file recovery.c line 290
static signed int recover_object_from_replica(struct recovery_obj_work *row, struct vnode_info *old, unsigned int tgt_epoch);
// recover_object_main
// file recovery.c line 834
static void recover_object_main(struct work *work);
// recover_object_work
// file recovery.c line 519
static void recover_object_work(struct work *work);
// recover_replication_object
// file recovery.c line 357
static signed int recover_replication_object(struct recovery_obj_work *row);
// refcount_dec
// file ../include/util.h line 259
static inline signed int refcount_dec(struct anonymous$2 *rc);
// refcount_dec$link1
// file ../include/util.h line 259
static inline signed int refcount_dec$link1(struct anonymous$2 *rc$link1);
// refcount_dec$link2
// file ../include/util.h line 259
static inline signed int refcount_dec$link2(struct anonymous$2 *rc$link2);
// refcount_inc
// file ../include/util.h line 254
static inline signed int refcount_inc(struct anonymous$2 *rc);
// refcount_inc$link1
// file ../include/util.h line 254
static inline signed int refcount_inc$link1(struct anonymous$2 *rc$link1);
// refcount_inc$link2
// file ../include/util.h line 254
static inline signed int refcount_inc$link2(struct anonymous$2 *rc$link2);
// refcount_read
// file ../include/util.h line 249
static inline signed int refcount_read(struct anonymous$2 *rc);
// refcount_read$link1
// file ../include/util.h line 249
static inline signed int refcount_read$link1(struct anonymous$2 *rc$link1);
// refcount_read$link2
// file ../include/util.h line 249
static inline signed int refcount_read$link2(struct anonymous$2 *rc$link2);
// refcount_set
// file ../include/util.h line 244
static inline void refcount_set(struct anonymous$2 *rc, signed int val);
// refcount_set$link1
// file ../include/util.h line 244
static inline void refcount_set$link1(struct anonymous$2 *rc$link1, signed int val$link1);
// register_event
// file ../include/event.h line 30
static inline signed int register_event(signed int fd, void (*h)(signed int, signed int, void *), void *data);
// register_event$link1
// file ../include/event.h line 30
static inline signed int register_event$link1(signed int fd$link1, void (*h$link1)(signed int, signed int, void *), void *data$link1);
// register_event$link2
// file ../include/event.h line 30
static inline signed int register_event$link2(signed int fd$link2, void (*h$link2)(signed int, signed int, void *), void *data$link2);
// register_event$link3
// file ../include/event.h line 30
static inline signed int register_event$link3(signed int fd$link3, void (*h$link3)(signed int, signed int, void *), void *data$link3);
// register_event::h$link1$object
//
void h$link1$object(signed int, signed int, void *);
// register_event::h$link2$object
//
void h$link2$object(signed int, signed int, void *);
// register_event::h$link3$object
//
void h$link3$object(signed int, signed int, void *);
// register_event::h$object
//
void h$object(signed int, signed int, void *);
// register_event_prio
// file ../include/event.h line 12
signed int register_event_prio(signed int fd, void (*h)(signed int, signed int, void *), void *data, signed int prio);
// register_event_prio::h$object
//
void h$object(signed int, signed int, void *);
// remove_cache_object
// file object_cache.c line 291
static signed int remove_cache_object(struct object_cache *oc, unsigned long int idx);
// remove_epoch
// file ops.c line 237
static signed int remove_epoch(unsigned int epoch);
// remove_vdisks
// file md.c line 112
static void remove_vdisks(struct disk *disk);
// removexattr
// file /usr/include/x86_64-linux-gnu/sys/xattr.h line 92
extern signed int removexattr(const char *, const char *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// replay_journal_entry
// file journal.c line 136
static signed int replay_journal_entry(struct journal_descriptor *jd);
// request_in_recovery
// file request.c line 169
static _Bool request_in_recovery(struct request *req);
// request_init_operation
// file http/http.c line 141
static signed int request_init_operation(struct http_request *req);
// requeue_cluster_request
// file group.c line 791
static void requeue_cluster_request(void);
// requeue_request
// file request.c line 500
static void requeue_request(struct request *req);
// reraise_crash_signal
// file ../include/util.h line 113
void reraise_crash_signal(signed int signo, signed int status);
// resume_suspended_recovery
// file sheep_priv.h line 338
void resume_suspended_recovery(void);
// revalidate_node
// file sockfd_cache.c line 293
static inline signed int revalidate_node(struct node_id *nid);
// rintf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 279
extern float rintf(float);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// rmdir_r
// file ../include/util.h line 107
signed int rmdir_r(const char *dir_path);
// rollback_vnode_info
// file recovery.c line 97
static struct vnode_info * rollback_vnode_info(unsigned int *epoch, struct vnode_info *cur);
// rotate_log
// file logger.c line 453
static void rotate_log(void);
// run_next_rw
// file recovery.c line 674
static inline _Bool run_next_rw(void);
// rx_main
// file request.c line 764
static void rx_main(struct work *work);
// rx_work
// file request.c line 727
static void rx_work(struct work *work);
// same_zone
// file ../include/sheep.h line 44
static inline signed int same_zone(struct sd_vnode *v1, struct sd_vnode *v2);
// same_zone$link1
// file ../include/sheep.h line 44
static inline signed int same_zone$link1(struct sd_vnode *v1$link1, struct sd_vnode *v2$link1);
// same_zone$link2
// file ../include/sheep.h line 44
static inline signed int same_zone$link2(struct sd_vnode *v1$link2, struct sd_vnode *v2$link2);
// same_zone$link3
// file ../include/sheep.h line 44
static inline signed int same_zone$link3(struct sd_vnode *v1$link3, struct sd_vnode *v2$link3);
// scan_wd
// file md.c line 665
static signed int scan_wd(unsigned long int oid, unsigned int epoch, unsigned char ec_index);
// screen_object_list
// file recovery.c line 944
static void screen_object_list(struct recovery_list_work *rlw, unsigned long int *oids, unsigned long int nr_oids);
// sd_accept_handler
// file group.c line 893
void sd_accept_handler(struct sd_node *joined, struct rb_root *nroot, unsigned long int nr_nodes, const void *opaque);
// sd_backtrace
// file ../include/logger.h line 54
void sd_backtrace(void);
// sd_block_handler
// file group.c line 269
_Bool sd_block_handler(struct sd_node *sender);
// sd_cond_broadcast
// file ../include/util.h line 392
static inline signed int sd_cond_broadcast(struct sd_cond *cond);
// sd_cond_init
// file ../include/util.h line 348
static inline void sd_cond_init(struct sd_cond *cond);
// sd_cond_signal
// file ../include/util.h line 373
static inline signed int sd_cond_signal(struct sd_cond *cond);
// sd_cond_wait
// file ../include/util.h line 378
static inline signed int sd_cond_wait(struct sd_cond *cond, struct sd_mutex *mutex);
// sd_cond_wait$link1
// file ../include/util.h line 378
static inline signed int sd_cond_wait$link1(struct sd_cond *cond$link1, struct sd_mutex *mutex$link1);
// sd_delete_vdi
// file vdi.c line 1259
signed int sd_delete_vdi(const char *name);
// sd_destroy_cond
// file ../include/util.h line 361
static inline void sd_destroy_cond(struct sd_cond *cond);
// sd_destroy_mutex
// file ../include/util.h line 299
static inline void sd_destroy_mutex(struct sd_mutex *mutex);
// sd_destroy_rw_lock
// file ../include/util.h line 417
static inline void sd_destroy_rw_lock(struct sd_rw_lock *lock);
// sd_discard_object
// file store.c line 463
signed int sd_discard_object(unsigned long int oid);
// sd_hash
// file ../include/sheepdog_proto.h line 341
static inline unsigned long int sd_hash(const void *buf, unsigned long int len);
// sd_hash$link1
// file ../include/sheepdog_proto.h line 341
static inline unsigned long int sd_hash$link1(const void *buf$link1, unsigned long int len$link1);
// sd_hash$link2
// file ../include/sheepdog_proto.h line 341
static inline unsigned long int sd_hash$link2(const void *buf$link2, unsigned long int len$link2);
// sd_hash_64
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64(unsigned long int oid);
// sd_hash_64$link1
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link1(unsigned long int oid$link1);
// sd_hash_64$link2
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link2(unsigned long int oid$link2);
// sd_hash_64$link3
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link3(unsigned long int oid$link3);
// sd_hash_64$link4
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link4(unsigned long int oid$link4);
// sd_hash_64$link5
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link5(unsigned long int oid$link5);
// sd_hash_next
// file ../include/sheepdog_proto.h line 355
static inline unsigned long int sd_hash_next(unsigned long int hval);
// sd_hash_next$link1
// file ../include/sheepdog_proto.h line 355
static inline unsigned long int sd_hash_next$link1(unsigned long int hval$link1);
// sd_hash_oid
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid(unsigned long int oid);
// sd_hash_oid$link1
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link1(unsigned long int oid$link1);
// sd_hash_oid$link2
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link2(unsigned long int oid$link2);
// sd_hash_oid$link3
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link3(unsigned long int oid$link3);
// sd_hash_oid$link4
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link4(unsigned long int oid$link4);
// sd_hash_vdi
// file ../include/sheepdog_proto.h line 373
static inline unsigned int sd_hash_vdi(const char *name);
// sd_hash_vdi$link1
// file ../include/sheepdog_proto.h line 373
static inline unsigned int sd_hash_vdi$link1(const char *name$link1);
// sd_init_mutex
// file ../include/util.h line 273
static inline void sd_init_mutex(struct sd_mutex *mutex);
// sd_init_mutex$link1
// file ../include/util.h line 273
static inline void sd_init_mutex$link1(struct sd_mutex *mutex$link1);
// sd_init_mutex$link2
// file ../include/util.h line 273
static inline void sd_init_mutex$link2(struct sd_mutex *mutex$link2);
// sd_init_req
// file ../include/sheep.h line 37
static inline void sd_init_req(struct sd_req *req, unsigned char opcode);
// sd_init_req$link1
// file ../include/sheep.h line 37
static inline void sd_init_req$link1(struct sd_req *req$link1, unsigned char opcode$link1);
// sd_init_req$link2
// file ../include/sheep.h line 37
static inline void sd_init_req$link2(struct sd_req *req$link2, unsigned char opcode$link2);
// sd_init_req$link3
// file ../include/sheep.h line 37
static inline void sd_init_req$link3(struct sd_req *req$link3, unsigned char opcode$link3);
// sd_init_req$link4
// file ../include/sheep.h line 37
static inline void sd_init_req$link4(struct sd_req *req$link4, unsigned char opcode$link4);
// sd_init_req$link5
// file ../include/sheep.h line 37
static inline void sd_init_req$link5(struct sd_req *req$link5, unsigned char opcode$link5);
// sd_init_req$link6
// file ../include/sheep.h line 37
static inline void sd_init_req$link6(struct sd_req *req$link6, unsigned char opcode$link6);
// sd_init_req$link7
// file ../include/sheep.h line 37
static inline void sd_init_req$link7(struct sd_req *req$link7, unsigned char opcode$link7);
// sd_init_rw_lock
// file ../include/util.h line 405
static inline void sd_init_rw_lock(struct sd_rw_lock *lock);
// sd_inode_copy_vdis
// file ../include/sheepdog_proto.h line 289
extern void sd_inode_copy_vdis(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), unsigned int *data_vdi_id, unsigned char store_policy, unsigned char nr_copies, unsigned char copy_policy, struct sd_inode *newi);
// sd_inode_copy_vdis::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_copy_vdis::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_get_meta_size
// file sd_inode.c line 626
extern unsigned int sd_inode_get_meta_size(struct sd_inode *inode, unsigned long int size);
// sd_inode_get_vid
// file ../include/sheepdog_proto.h line 278
extern unsigned int sd_inode_get_vid(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx);
// sd_inode_get_vid::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_init
// file ../include/sheepdog_proto.h line 277
extern void sd_inode_init(void *data, signed int depth);
// sd_inode_set_vid
// file ../include/sheepdog_proto.h line 280
extern void sd_inode_set_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, unsigned int vdi_id);
// sd_inode_set_vid::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_set_vid::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_write
// file ../include/sheepdog_proto.h line 283
extern signed int sd_inode_write(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, signed int flags, _Bool create, _Bool direct);
// sd_inode_write::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_write_vid
// file ../include/sheepdog_proto.h line 285
extern signed int sd_inode_write_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, unsigned int idx, unsigned int vid, unsigned int value, signed int flags, _Bool create, _Bool direct);
// sd_inode_write_vid::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_join_handler
// file group.c line 748
_Bool sd_join_handler(struct sd_node *joining, struct rb_root *nroot, unsigned long int nr_nodes, void *opaque);
// sd_leave_handler
// file group.c line 922
void sd_leave_handler(struct sd_node *left, struct rb_root *nroot, unsigned long int nr_nodes);
// sd_lookup_vdi
// file vdi.c line 1277
signed int sd_lookup_vdi(const char *name, unsigned int *vid);
// sd_migrate_store
// file sheep_priv.h line 465
signed int sd_migrate_store(signed int from, signed int to);
// sd_mutex_lock
// file ../include/util.h line 311
static inline void sd_mutex_lock(struct sd_mutex *mutex);
// sd_mutex_lock$link1
// file ../include/util.h line 311
static inline void sd_mutex_lock$link1(struct sd_mutex *mutex$link1);
// sd_mutex_lock$link2
// file ../include/util.h line 311
static inline void sd_mutex_lock$link2(struct sd_mutex *mutex$link2);
// sd_mutex_lock$link3
// file ../include/util.h line 311
static inline void sd_mutex_lock$link3(struct sd_mutex *mutex$link3);
// sd_mutex_lock$link4
// file ../include/util.h line 311
static inline void sd_mutex_lock$link4(struct sd_mutex *mutex$link4);
// sd_mutex_trylock
// file ../include/util.h line 323
static inline signed int sd_mutex_trylock(struct sd_mutex *mutex);
// sd_mutex_trylock$link1
// file ../include/util.h line 323
static inline signed int sd_mutex_trylock$link1(struct sd_mutex *mutex$link1);
// sd_mutex_unlock
// file ../include/util.h line 328
static inline void sd_mutex_unlock(struct sd_mutex *mutex);
// sd_mutex_unlock$link1
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link1(struct sd_mutex *mutex$link1);
// sd_mutex_unlock$link2
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link2(struct sd_mutex *mutex$link2);
// sd_mutex_unlock$link3
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link3(struct sd_mutex *mutex$link3);
// sd_mutex_unlock$link4
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link4(struct sd_mutex *mutex$link4);
// sd_notify_handler
// file group.c line 700
void sd_notify_handler(struct sd_node *sender, void *data, unsigned long int data_len);
// sd_read_lock
// file ../include/util.h line 429
static inline void sd_read_lock(struct sd_rw_lock *lock);
// sd_read_lock$link1
// file ../include/util.h line 429
static inline void sd_read_lock$link1(struct sd_rw_lock *lock$link1);
// sd_read_lock$link2
// file ../include/util.h line 429
static inline void sd_read_lock$link2(struct sd_rw_lock *lock$link2);
// sd_read_lock$link3
// file ../include/util.h line 429
static inline void sd_read_lock$link3(struct sd_rw_lock *lock$link3);
// sd_read_lock$link4
// file ../include/util.h line 429
static inline void sd_read_lock$link4(struct sd_rw_lock *lock$link4);
// sd_read_object
// file store.c line 422
signed int sd_read_object(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset);
// sd_reconnect_handler
// file group.c line 856
signed int sd_reconnect_handler(void);
// sd_remove_object
// file store.c line 441
signed int sd_remove_object(unsigned long int oid);
// sd_rw_unlock
// file ../include/util.h line 457
static inline void sd_rw_unlock(struct sd_rw_lock *lock);
// sd_rw_unlock$link1
// file ../include/util.h line 457
static inline void sd_rw_unlock$link1(struct sd_rw_lock *lock$link1);
// sd_rw_unlock$link2
// file ../include/util.h line 457
static inline void sd_rw_unlock$link2(struct sd_rw_lock *lock$link2);
// sd_rw_unlock$link3
// file ../include/util.h line 457
static inline void sd_rw_unlock$link3(struct sd_rw_lock *lock$link3);
// sd_rw_unlock$link4
// file ../include/util.h line 457
static inline void sd_rw_unlock$link4(struct sd_rw_lock *lock$link4);
// sd_strerror
// file ../include/sheep.h line 119
static inline const char * sd_strerror(signed int err);
// sd_strerror$link1
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link1(signed int err$link1);
// sd_strerror$link2
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link2(signed int err$link2);
// sd_strerror$link3
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link3(signed int err$link3);
// sd_strerror$link4
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link4(signed int err$link4);
// sd_strerror$link5
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link5(signed int err$link5);
// sd_strerror$link6
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link6(signed int err$link6);
// sd_strerror$link7
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link7(signed int err$link7);
// sd_strerror$link8
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link8(signed int err$link8);
// sd_strerror$link9
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link9(signed int err$link9);
// sd_update_node_handler
// file group.c line 989
void sd_update_node_handler(struct sd_node *node);
// sd_write_lock
// file ../include/util.h line 445
static inline void sd_write_lock(struct sd_rw_lock *lock);
// sd_write_lock$link1
// file ../include/util.h line 445
static inline void sd_write_lock$link1(struct sd_rw_lock *lock$link1);
// sd_write_lock$link2
// file ../include/util.h line 445
static inline void sd_write_lock$link2(struct sd_rw_lock *lock$link2);
// sd_write_lock$link3
// file ../include/util.h line 445
static inline void sd_write_lock$link3(struct sd_rw_lock *lock$link3);
// sd_write_lock$link4
// file ../include/util.h line 445
static inline void sd_write_lock$link4(struct sd_rw_lock *lock$link4);
// sd_write_object
// file store.c line 362
signed int sd_write_object(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset, _Bool create);
// sdlog_help
// file sheep.c line 180
static void sdlog_help(void);
// search_erasure_object
// file recovery.c line 128
static signed int search_erasure_object(unsigned long int oid, unsigned char idx, struct rb_root *nroot, struct recovery_work *rw, unsigned int tgt_epoch, void *buf);
// search_ext_entry
// file sd_inode.c line 271
static struct sd_extent * search_ext_entry(struct sd_extent_header *header, unsigned int idx);
// search_idx_entry
// file sd_inode.c line 281
static struct sd_extent_idx * search_idx_entry(struct sd_extent_header *header, unsigned int idx);
// search_whole_btree
// file sd_inode.c line 392
static signed int search_whole_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, struct find_path *path);
// search_whole_btree::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// semctl
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 52
extern signed int semctl(signed int, signed int, signed int, ...);
// semget
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 55
extern signed int semget(signed int, signed int, signed int);
// semop
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 58
extern signed int semop(signed int, struct sembuf *, unsigned long int);
// send_join_request
// file group.c line 783
static signed int send_join_request(void);
// send_req
// file ../include/net.h line 47
signed int send_req(signed int sockfd, struct sd_req *hdr, void *data, unsigned int wlen, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// send_req::need_retry$object
//
_Bool need_retry$object(unsigned int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// set_bit_64
// file ../include/bitops.h line 139
static inline void set_bit_64(signed int nr, unsigned long int *addr);
// set_cluster_config
// file sheep_priv.h line 350
signed int set_cluster_config(struct cluster_info *cinfo);
// set_cluster_shutdown
// file sheep_priv.h line 355
signed int set_cluster_shutdown(_Bool down);
// set_keepalive
// file net.c line 467
signed int set_keepalive(signed int fd);
// set_loglevel
// file ../include/logger.h line 120
void set_loglevel(signed int new_loglevel);
// set_node_space
// file sheep_priv.h line 351
signed int set_node_space(unsigned long int space);
// set_nodelay
// file ../include/net.h line 59
signed int set_nodelay(signed int fd);
// set_object_sha1
// file plain_store.c line 573
static signed int set_object_sha1(const char *path, const unsigned char *sha1);
// set_rcv_timeout
// file net.c line 438
signed int set_rcv_timeout(signed int fd);
// set_snd_timeout
// file net.c line 427
signed int set_snd_timeout(signed int fd);
// set_thread_name
// file logger.c line 738
void set_thread_name(const char *name, _Bool show_idx);
// set_try_to_free_routine
// file util.c line 34
void (*set_try_to_free_routine(void (*routine)(unsigned long int)))(unsigned long int);
// set_try_to_free_routine::1::old$object
//
void old$object(unsigned long int);
// set_try_to_free_routine::routine$object
//
void routine$object(unsigned long int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_backend_store
// file group.c line 582
static void setup_backend_store(struct cluster_info *cinfo);
// setxattr
// file /usr/include/x86_64-linux-gnu/sys/xattr.h line 41
extern signed int setxattr(const char *, const char *, const void *, unsigned long int, signed int);
// sha1_final$object
//
void sha1_final$object(void *, unsigned char *);
// sha1_init$object
//
void sha1_init$object(void *);
// sha1_to_hex
// file ../include/sha1.h line 34
const char * sha1_to_hex(const unsigned char *sha1);
// sha1_update$object
//
void sha1_update$object(void *, const unsigned char *, unsigned int);
// sheep_bnode_reader
// file vdi.c line 39
signed int sheep_bnode_reader(unsigned long int oid, void **mem, unsigned int len, unsigned long int offset);
// sheep_bnode_writer
// file vdi.c line 32
signed int sheep_bnode_writer(unsigned long int oid, void *mem, unsigned int len, unsigned long int offset, unsigned int flags, signed int copies, signed int copy_policy, _Bool create, _Bool direct);
// sheep_exec_req
// file sheep_priv.h line 470
signed int sheep_exec_req(struct node_id *nid, struct sd_req *hdr, void *buf);
// sheep_need_retry
// file request.c line 1137
_Bool sheep_need_retry(unsigned int epoch);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$1 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$1 *);
// sighup_handler
// file sheep.c line 601
static void sighup_handler(signed int signum);
// sighup_handler$link1
// file logger.c line 555
static void sighup_handler$link1(signed int signo);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signal_handler
// file sheep.c line 221
static void signal_handler(signed int listen_fd, signed int events, void *data);
// signalfd
// file /usr/include/x86_64-linux-gnu/sys/signalfd.h line 53
extern signed int signalfd(signed int, const struct anonymous$1 *, signed int);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous$1 *, struct anonymous$1 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sleep_on_wait_queue
// file request.c line 85
static inline void sleep_on_wait_queue(struct request *req);
// slots_all_free
// file sockfd_cache.c line 132
static inline _Bool slots_all_free(struct sockfd_cache_entry *entry);
// snapshot_vdi
// file vdi.c line 365
static signed int snapshot_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int base_vid);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sockaddr_in_to_str
// file net.c line 394
char * sockaddr_in_to_str(struct sockaddr_in *sockaddr);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sockfd_cache_add
// file ../include/sockfd_cache.h line 11
void sockfd_cache_add(struct node_id *nid);
// sockfd_cache_add_group
// file ../include/sockfd_cache.h line 12
void sockfd_cache_add_group(struct rb_root *nroot);
// sockfd_cache_add_nolock
// file sockfd_cache.c line 190
static void sockfd_cache_add_nolock(struct node_id *nid);
// sockfd_cache_close
// file sockfd_cache.c line 381
static void sockfd_cache_close(struct node_id *nid, signed int idx);
// sockfd_cache_cmp
// file sockfd_cache.c line 75
static signed int sockfd_cache_cmp(struct sockfd_cache_entry *a, struct sockfd_cache_entry *b);
// sockfd_cache_del
// file ../include/sockfd_cache.h line 10
void sockfd_cache_del(struct node_id *nid, struct sockfd *sfd);
// sockfd_cache_del_node
// file ../include/sockfd_cache.h line 9
void sockfd_cache_del_node(struct node_id *nid);
// sockfd_cache_destroy
// file sockfd_cache.c line 162
static _Bool sockfd_cache_destroy(struct node_id *nid);
// sockfd_cache_get
// file ../include/sockfd_cache.h line 7
struct sockfd * sockfd_cache_get(struct node_id *nid);
// sockfd_cache_get_long
// file sockfd_cache.c line 313
static struct sockfd * sockfd_cache_get_long(struct node_id *nid);
// sockfd_cache_grab
// file sockfd_cache.c line 112
static struct sockfd_cache_entry * sockfd_cache_grab(struct node_id *nid, signed int *ret_idx);
// sockfd_cache_insert
// file sockfd_cache.c line 82
static struct sockfd_cache_entry * sockfd_cache_insert(struct sockfd_cache_entry *new);
// sockfd_cache_put
// file ../include/sockfd_cache.h line 8
void sockfd_cache_put(struct node_id *nid, struct sockfd *sfd);
// sockfd_cache_put_long
// file sockfd_cache.c line 365
static void sockfd_cache_put_long(struct node_id *nid, signed int idx);
// sockfd_cache_search
// file sockfd_cache.c line 87
static struct sockfd_cache_entry * sockfd_cache_search(struct node_id *nid);
// sockfd_init
// file ../include/sockfd_cache.h line 14
signed int sockfd_init(void);
// split_ext_node
// file sd_inode.c line 471
static void split_ext_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, struct find_path *path);
// split_ext_node::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// split_path
// file util.c line 525
signed int split_path(const char *path, unsigned long int nr_segs, char **segs);
// split_to_nodes
// file sd_inode.c line 335
static void split_to_nodes(struct sd_extent_header *src, struct sd_extent_header *left, struct sd_extent_header *right, signed int num);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_deletion
// file vdi.c line 1069
static signed int start_deletion(struct request *req, unsigned int vid);
// start_recovery
// file sheep_priv.h line 371
signed int start_recovery(struct vnode_info *cur_vinfo, struct vnode_info *old_vinfo, _Bool epoch_lifted);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stat_request_begin
// file request.c line 357
static inline void stat_request_begin(struct request *req);
// stat_request_end
// file request.c line 410
static inline void stat_request_end(struct request *req);
// stat_sheep
// file ops.c line 61
static signed int stat_sheep(unsigned long int *store_size, unsigned long int *store_free, unsigned int epoch);
// statvfs
// file /usr/include/x86_64-linux-gnu/sys/statvfs.h line 51
extern signed int statvfs(const char *, struct statvfs *);
// str_http_req
// file http/http.c line 75
const char * str_http_req(struct http_request *req);
// str_to_addr
// file ../include/net.h line 57
unsigned char * str_to_addr(const char *ipstr, unsigned char *addr);
// strbuf_add
// file ../include/strbuf.h line 81
void strbuf_add(struct strbuf *sb, const void *data, unsigned long int len);
// strbuf_addf
// file ../include/strbuf.h line 91
void strbuf_addf(struct strbuf *sb, const char *fmt, ...);
// strbuf_addstr
// file ../include/strbuf.h line 82
static inline void strbuf_addstr(struct strbuf *sb, const char *s);
// strbuf_attach
// file strbuf.c line 43
void strbuf_attach(struct strbuf *sb, void *buf, unsigned long int len, unsigned long int alloc);
// strbuf_avail
// file ../include/strbuf.h line 49
static inline unsigned long int strbuf_avail(struct strbuf *sb);
// strbuf_copyout
// file ../include/strbuf.h line 97
signed int strbuf_copyout(struct strbuf *sb, void *buf, unsigned long int len);
// strbuf_detach
// file strbuf.c line 36
char * strbuf_detach(struct strbuf *sb);
// strbuf_fread
// file strbuf.c line 129
unsigned long int strbuf_fread(struct strbuf *sb, unsigned long int size, struct _IO_FILE *f);
// strbuf_getline
// file strbuf.c line 184
signed int strbuf_getline(struct strbuf *sb, struct _IO_FILE *fp, signed int term);
// strbuf_getwholeline
// file strbuf.c line 163
static signed int strbuf_getwholeline(struct strbuf *sb, struct _IO_FILE *fp, signed int term);
// strbuf_grow
// file strbuf.c line 53
void strbuf_grow(struct strbuf *sb, unsigned long int extra);
// strbuf_init
// file strbuf.c line 16
void strbuf_init(struct strbuf *sb, unsigned long int hint);
// strbuf_insert
// file strbuf.c line 67
void strbuf_insert(struct strbuf *sb, unsigned long int pos, const void *data, unsigned long int len);
// strbuf_read
// file ../include/strbuf.h line 95
signed long int strbuf_read(struct strbuf *sb, signed int fd, unsigned long int hint);
// strbuf_release
// file ../include/strbuf.h line 43
void strbuf_release(struct strbuf *sb);
// strbuf_remove
// file strbuf.c line 96
void strbuf_remove(struct strbuf *sb, unsigned long int pos, unsigned long int len);
// strbuf_reset
// file strbuf.c line 29
void strbuf_reset(struct strbuf *sb);
// strbuf_rtrim
// file strbuf.c line 60
void strbuf_rtrim(struct strbuf *sb);
// strbuf_setlen
// file ../include/strbuf.h line 53
static inline void strbuf_setlen(struct strbuf *sb, unsigned long int len);
// strbuf_splice
// file strbuf.c line 77
void strbuf_splice(struct strbuf *sb, unsigned long int pos, unsigned long int len, const void *data, unsigned long int dlen);
// strbuf_stripout
// file strbuf.c line 201
signed int strbuf_stripout(struct strbuf *sb, void *buf, unsigned long int len);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strchrnul
// file /usr/include/string.h line 276
extern char * strchrnul(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// stropcode
// file http/http.c line 26
static inline const char * stropcode(enum http_opcode opcode);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strstatus
// file http/http.c line 45
static inline const char * strstatus(enum http_status status);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// submit_local_request
// file request.c line 535
static void submit_local_request(struct request *req);
// switch_journal_file
// file journal.c line 339
static void switch_journal_file(void);
// sync
// file /usr/include/unistd.h line 972
extern void sync(void);
// sys_epoch
// file sheep_priv.h line 278
static inline unsigned int sys_epoch(void);
// sys_epoch$link1
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link1(void);
// sys_epoch$link2
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link2(void);
// sys_epoch$link3
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link3(void);
// sys_epoch$link4
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link4(void);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// thread_process_path
// file md.c line 388
static void * thread_process_path(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timer_handler
// file event.c line 25
static void timer_handler(signed int fd, signed int events, void *data);
// timerfd_create
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 38
extern signed int timerfd_create(signed int, signed int);
// timerfd_settime
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 43
extern signed int timerfd_settime(signed int, signed int, struct itimerspec *, struct itimerspec *);
// tkill
// file util.c line 482
signed int tkill(signed int tid, signed int sig);
// trace_buffer_pop
// file trace/trace.h line 53
static inline signed int trace_buffer_pop(void *buf, unsigned int len);
// trace_clear_tid_map
// file work.c line 190
static inline void trace_clear_tid_map(signed int tid);
// trace_disable
// file trace/trace.h line 51
static inline signed int trace_disable(const char *name);
// trace_enable
// file trace/trace.h line 50
static inline signed int trace_enable(const char *name);
// trace_init
// file trace/trace.h line 49
static inline signed int trace_init(void);
// trace_set_tid_map
// file work.c line 189
static inline void trace_set_tid_map(signed int tid);
// trace_status
// file trace/trace.h line 52
static inline unsigned long int trace_status(char *buf);
// transfer_to_idx_root
// file sd_inode.c line 355
static void transfer_to_idx_root(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode);
// transfer_to_idx_root::writer$object
//
signed int writer$object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// traverse_btree
// file ../include/sheepdog_proto.h line 295
extern void traverse_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, void (*fn)(void *, enum btree_node_type, void *), void *arg);
// traverse_btree::fn$object
//
void fn$object(void *, enum btree_node_type, void *);
// traverse_btree::reader$object
//
signed int reader$object(unsigned long int, void **, unsigned int, unsigned long int);
// trim_last_slash
// file md.c line 128
static inline void trim_last_slash(char *path);
// try_to_free_routine$object
//
void try_to_free_routine$object(unsigned long int);
// tx_main
// file request.c line 830
static void tx_main(struct work *work);
// tx_work
// file request.c line 802
static void tx_work(struct work *work);
// uatomic_is_true
// file ../include/util.h line 206
static inline _Bool uatomic_is_true(struct anonymous$0 *val);
// uatomic_is_true$link1
// file ../include/util.h line 206
static inline _Bool uatomic_is_true$link1(struct anonymous$0 *val$link1);
// uatomic_is_true$link2
// file ../include/util.h line 206
static inline _Bool uatomic_is_true$link2(struct anonymous$0 *val$link2);
// uatomic_set_false
// file ../include/util.h line 217
static inline void uatomic_set_false(struct anonymous$0 *val);
// uatomic_set_false$link1
// file ../include/util.h line 217
static inline void uatomic_set_false$link1(struct anonymous$0 *val$link1);
// uatomic_set_false$link2
// file ../include/util.h line 217
static inline void uatomic_set_false$link2(struct anonymous$0 *val$link2);
// uatomic_set_true
// file ../include/util.h line 212
static inline _Bool uatomic_set_true(struct anonymous$0 *val);
// uatomic_set_true$link1
// file ../include/util.h line 212
static inline _Bool uatomic_set_true$link1(struct anonymous$0 *val$link1);
// uatomic_set_true$link2
// file ../include/util.h line 212
static inline _Bool uatomic_set_true$link2(struct anonymous$0 *val$link2);
// unblock_sighup
// file logger.c line 143
static void unblock_sighup(void);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unlinkat
// file /usr/include/unistd.h line 830
extern signed int unlinkat(signed int, const char *, signed int);
// unlock_cache
// file object_cache.c line 188
static inline void unlock_cache(struct object_cache *oc);
// unlock_entry
// file object_cache.c line 203
static inline void unlock_entry(struct object_cache_entry *entry);
// unregister_event
// file ../include/event.h line 13
void unregister_event(signed int fd);
// unregister_listening_fds
// file request.c line 1049
void unregister_listening_fds(void);
// update_and_merge_free_desc
// file http/oalloc.c line 200
static inline signed int update_and_merge_free_desc(char *meta, unsigned long int start, unsigned long int count, unsigned int vid);
// update_cluster_info
// file group.c line 638
static void update_cluster_info(struct cluster_info *cinfo, struct sd_node *joined, struct rb_root *nroot, unsigned long int nr_nodes);
// update_epoch_from_v0_to_v1
// file migrate.c line 203
static signed int update_epoch_from_v0_to_v1(unsigned int epoch);
// update_epoch_from_v1_to_v2
// file migrate.c line 311
static signed int update_epoch_from_v1_to_v2(unsigned int epoch);
// update_epoch_log
// file sheep_priv.h line 346
signed int update_epoch_log(unsigned int epoch, struct sd_node *nodes, unsigned long int nr_nodes);
// update_node_size
// file group.c line 960
static void update_node_size(struct sd_node *node);
// usage
// file sheep.c line 150
static void usage(signed int status);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// valloc
// file /usr/include/stdlib.h line 498
extern void * valloc(unsigned long int);
// vdi_create
// file vdi.c line 678
signed int vdi_create(struct vdi_iocb *iocb, unsigned int *new_vid);
// vdi_delete
// file vdi.c line 1153
signed int vdi_delete(struct vdi_iocb *iocb, struct request *req);
// vdi_exist
// file vdi.c line 201
signed int vdi_exist(unsigned int vid);
// vdi_flush
// file vdi.c line 652
static void vdi_flush(unsigned int vid);
// vdi_has_tag
// file vdi.c line 518
static inline _Bool vdi_has_tag(struct vdi_iocb *iocb);
// vdi_init_tag
// file ops.c line 134
static signed int vdi_init_tag(const char **tag, const char *buf, unsigned int len);
// vdi_is_deleted
// file vdi.c line 196
static inline _Bool vdi_is_deleted(struct sd_inode *inode);
// vdi_is_snapshot
// file ../include/sheepdog_proto.h line 465
static inline _Bool vdi_is_snapshot(struct sd_inode *inode);
// vdi_is_snapshot$link1
// file ../include/sheepdog_proto.h line 465
static inline _Bool vdi_is_snapshot$link1(struct sd_inode *inode$link1);
// vdi_lookup
// file vdi.c line 613
signed int vdi_lookup(struct vdi_iocb *iocb, struct vdi_info *info);
// vdi_read_write
// file http/kv.c line 632
static signed int vdi_read_write(unsigned int vid, char *data, unsigned long int length, signed long int offset, _Bool is_read);
// vdi_snapshot
// file vdi.c line 721
signed int vdi_snapshot(struct vdi_iocb *iocb, unsigned int *new_vid);
// vdi_state_cmp
// file vdi.c line 45
static signed int vdi_state_cmp(struct vdi_state_entry *a, struct vdi_state_entry *b);
// vdi_state_insert
// file vdi.c line 59
static struct vdi_state_entry * vdi_state_insert(struct rb_root *root, struct vdi_state_entry *new);
// vdi_state_search
// file vdi.c line 51
static struct vdi_state_entry * vdi_state_search(struct rb_root *root, unsigned int vid);
// vdi_tag_match
// file vdi.c line 525
static inline _Bool vdi_tag_match(struct vdi_iocb *iocb, struct sd_inode *inode);
// vdisk_cmp
// file md.c line 67
static signed int vdisk_cmp(struct vdisk *d1, struct vdisk *d2);
// vdisk_free
// file md.c line 106
static inline void vdisk_free(struct vdisk *v);
// vdisk_insert
// file md.c line 72
static struct vdisk * vdisk_insert(struct vdisk *new);
// vdisk_number
// file md.c line 57
static inline signed int vdisk_number(struct disk *disk);
// vid_is_snapshot
// file vdi.c line 65
static _Bool vid_is_snapshot(unsigned int vid);
// vid_to_attr_oid
// file ../include/sheepdog_proto.h line 450
static inline unsigned long int vid_to_attr_oid(unsigned int vid, unsigned int attrid);
// vid_to_btree_oid
// file ../include/sheepdog_proto.h line 455
static inline unsigned long int vid_to_btree_oid(unsigned int vid, unsigned int btreeid);
// vid_to_data_oid
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid(unsigned int vid, unsigned long int idx);
// vid_to_data_oid$link1
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid$link1(unsigned int vid$link1, unsigned long int idx$link1);
// vid_to_data_oid$link2
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid$link2(unsigned int vid$link2, unsigned long int idx$link2);
// vid_to_data_oid$link3
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid$link3(unsigned int vid$link3, unsigned long int idx$link3);
// vid_to_vdi_oid
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid(unsigned int vid);
// vid_to_vdi_oid$link1
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link1(unsigned int vid$link1);
// vid_to_vdi_oid$link2
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link2(unsigned int vid$link2);
// vid_to_vdi_oid$link3
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link3(unsigned int vid$link3);
// vid_to_vdi_oid$link4
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link4(unsigned int vid$link4);
// vid_to_vdi_oid$link5
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link5(unsigned int vid$link5);
// vnode_cmp
// file ../include/sheep.h line 50
static inline signed int vnode_cmp(struct sd_vnode *node1, struct sd_vnode *node2);
// vnode_cmp$link1
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link1(struct sd_vnode *node1$link1, struct sd_vnode *node2$link1);
// vnode_cmp$link2
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link2(struct sd_vnode *node1$link2, struct sd_vnode *node2$link2);
// vnode_cmp$link3
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link3(struct sd_vnode *node1$link3, struct sd_vnode *node2$link3);
// vnode_cmp$link4
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link4(struct sd_vnode *node1$link4, struct sd_vnode *node2$link4);
// vnode_is_local
// file sheep_priv.h line 429
static inline _Bool vnode_is_local(struct sd_vnode *v);
// vnode_is_local$link1
// file sheep_priv.h line 429
static inline _Bool vnode_is_local$link1(struct sd_vnode *v$link1);
// vnode_is_local$link2
// file sheep_priv.h line 429
static inline _Bool vnode_is_local$link2(struct sd_vnode *v$link2);
// vnode_is_local$link3
// file sheep_priv.h line 429
static inline _Bool vnode_is_local$link3(struct sd_vnode *v$link3);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// wait_forward_request
// file gateway.c line 366
static signed int wait_forward_request(struct forward_info *fi, struct request *req);
// wait_get_vdis_done
// file group.c line 626
void wait_get_vdis_done(void);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// wakeup_all_requests
// file request.c line 256
void wakeup_all_requests(void);
// wakeup_requests_on_epoch
// file request.c line 203
void wakeup_requests_on_epoch(void);
// wakeup_requests_on_oid
// file request.c line 240
void wakeup_requests_on_oid(unsigned long int oid);
// was_cluster_shutdowned
// file sheep_priv.h line 354
_Bool was_cluster_shutdowned(void);
// work_queue_empty
// file work.c line 445
_Bool work_queue_empty(struct work_queue *q);
// worker_routine
// file work.c line 313
static void * worker_routine(void *arg);
// worker_thread_request_done
// file work.c line 287
static void worker_thread_request_done(signed int fd, signed int events, void *data);
// wq_get_nr_nodes$object
//
unsigned long int wq_get_nr_nodes$object(void);
// wq_get_roof
// file work.c line 202
static inline unsigned long int wq_get_roof(struct wq_info *wi);
// wq_need_grow
// file work.c line 222
static _Bool wq_need_grow(struct wq_info *wi);
// wq_need_shrink
// file work.c line 238
static _Bool wq_need_shrink(struct wq_info *wi);
// wq_trace_init
// file work.c line 188
static inline signed int wq_trace_init(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_cache_object
// file object_cache.c line 401
static signed int write_cache_object(struct object_cache_entry *entry, void *buf, unsigned long int count, signed long int offset, _Bool create, _Bool writeback);
// write_cache_object_noupdate
// file object_cache.c line 347
static signed int write_cache_object_noupdate(unsigned int vid, unsigned long int idx, void *buf, unsigned long int count, signed long int offset);
// write_config
// file config.c line 33
static signed int write_config(void);
// write_lock_cache
// file object_cache.c line 183
static inline void write_lock_cache(struct object_cache *oc);
// write_lock_entry
// file object_cache.c line 198
static inline void write_lock_entry(struct object_cache_entry *entry);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xcalloc
// file ../include/util.h line 94
void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xfallocate
// file ../include/util.h line 101
signed int xfallocate(signed int fd, signed int mode, signed long int offset, signed long int len);
// xftruncate
// file ../include/util.h line 102
signed int xftruncate(signed int fd, signed long int length);
// xmalloc
// file ../include/util.h line 91
void * xmalloc(unsigned long int size);
// xmkdir
// file ../include/util.h line 100
signed int xmkdir(const char *pathname, unsigned int mode);
// xpread
// file ../include/util.h line 98
signed long int xpread(signed int fd, void *buf, unsigned long int count, signed long int offset);
// xpwrite
// file ../include/util.h line 99
signed long int xpwrite(signed int fd, const void *buf, unsigned long int count, signed long int offset);
// xread
// file ../include/util.h line 96
signed long int xread(signed int fd, void *buf, unsigned long int count);
// xrealloc
// file ../include/util.h line 93
void * xrealloc(void *ptr, unsigned long int size);
// xvalloc
// file ../include/util.h line 95
void * xvalloc(unsigned long int size);
// xwrite
// file ../include/util.h line 97
signed long int xwrite(signed int fd, const void *buf, unsigned long int count);
// xzalloc
// file ../include/util.h line 92
void * xzalloc(unsigned long int size);
// zalloc
// file ../include/util.h line 69
static inline void * zalloc(unsigned long int size);

struct anonymous$10
{
  // __val
  struct list_head *__val;
};

struct anonymous$23
{
  // __val
  struct recovery_info *__val;
};

struct anonymous$9
{
  // __val
  struct vnode_info *__val;
};

struct anonymous$37
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$35
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$27
{
  // name
  char name[1024l];
  // sha1
  unsigned char sha1[24l];
  // size
  unsigned long int size;
  // mtime
  unsigned long int mtime;
  // data_vid
  unsigned int data_vid;
  // nr_extent
  unsigned int nr_extent;
  // oid
  unsigned long int oid;
  // inlined
  unsigned char inlined;
};

struct anonymous$1
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$8
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$3
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous$31
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$34
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$33
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$32
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$36
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$38
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$31 _kill;
  // _timer
  struct anonymous$32 _timer;
  // _rt
  struct anonymous$33 _rt;
  // _sigchld
  struct anonymous$34 _sigchld;
  // _sigfault
  struct anonymous$35 _sigfault;
  // _sigpoll
  struct anonymous$36 _sigpoll;
  // _sigsys
  struct anonymous$37 _sigsys;
};

struct anonymous$30
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$38 _sifields;
};

struct anonymous$2
{
  // val
  signed int val;
};

struct anonymous$17
{
  // __pad
  unsigned int __pad;
  // nr_nodes
  unsigned int nr_nodes;
  // __reserved
  unsigned int __reserved[2l];
  // store_size
  unsigned long int store_size;
  // store_free
  unsigned long int store_free;
};

struct anonymous$16
{
  // __pad
  unsigned int __pad;
  // rsvd
  unsigned int rsvd;
  // vdi_id
  unsigned int vdi_id;
  // attr_id
  unsigned int attr_id;
  // copies
  unsigned char copies;
  // reserved
  unsigned char reserved[3l];
};

struct anonymous$15
{
  // __pad
  unsigned int __pad;
  // copies
  unsigned char copies;
  // reserved
  unsigned char reserved[3l];
  // offset
  unsigned long int offset;
};

struct anonymous$18
{
  // __pad1
  unsigned int __pad1;
  // __pad2
  unsigned int __pad2;
  // digest
  unsigned char digest[20l];
};

struct anonymous$14
{
  // old_vid
  unsigned int old_vid;
  // new_vid
  unsigned int new_vid;
  // copies
  unsigned char copies;
  // set_bitmap
  unsigned char set_bitmap;
  // copy_policy
  unsigned char copy_policy;
};

struct anonymous$11
{
  // oid
  unsigned long int oid;
  // cow_oid
  unsigned long int cow_oid;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // ec_index
  unsigned char ec_index;
  // reserved
  unsigned char reserved;
  // tgt_epoch
  unsigned int tgt_epoch;
  // offset
  unsigned int offset;
  // __pad
  unsigned int __pad;
};

struct anonymous$13
{
  // oid
  unsigned long int oid;
  // ctime
  unsigned long int ctime;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // flags
  unsigned short int flags;
  // tag
  unsigned int tag;
};

struct anonymous$0
{
  // val
  unsigned long int val;
};

struct anonymous$12
{
  // vdi_size
  unsigned long int vdi_size;
  // base_vdi_id
  unsigned int base_vdi_id;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // reserved
  unsigned char reserved;
  // snapid
  unsigned int snapid;
};

union anonymous$28
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous$29
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$30 *, void *);
};

union anonymous$19
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct onode_extent
{
  // start
  unsigned long int start;
  // count
  unsigned long int count;
};

union anonymous$26
{
  // data
  unsigned char data[4190208l];
  // o_extent
  struct onode_extent o_extent[0l];
};

union anonymous$21
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$24
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous$25
{
  // $anon0
  struct anonymous$27 $anon0;
  // pad
  unsigned char pad[4096l];
};

union anonymous$7
{
  // __data
  struct anonymous$8 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$4
{
  // __data
  struct anonymous$3 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

union anonymous$5
{
  // obj
  struct anonymous$11 obj;
  // vdi
  struct anonymous$12 vdi;
  // cluster
  struct anonymous$13 cluster;
  // vdi_state
  struct anonymous$14 vdi_state;
  // __pad
  unsigned int __pad[8l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$6
{
  // result
  unsigned int result;
  // obj
  struct anonymous$15 obj;
  // vdi
  struct anonymous$16 vdi;
  // node
  struct anonymous$17 node;
  // hash
  struct anonymous$18 hash;
  // __pad
  unsigned int __pad[8l];
};

union anonymous$20
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$22
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct FCGX_Request
{
  // requestId
  signed int requestId;
  // role
  signed int role;
  // in
  struct FCGX_Stream *in;
  // out
  struct FCGX_Stream *out;
  // err
  struct FCGX_Stream *err;
  // envp
  char **envp;
  // paramsPtr
  struct Params *paramsPtr;
  // ipcFd
  signed int ipcFd;
  // isBeginProcessed
  signed int isBeginProcessed;
  // keepConnection
  signed int keepConnection;
  // appStatus
  signed int appStatus;
  // nWriters
  signed int nWriters;
  // flags
  signed int flags;
  // listen_sock
  signed int listen_sock;
};

struct FCGX_Stream
{
  // rdNext
  unsigned char *rdNext;
  // wrNext
  unsigned char *wrNext;
  // stop
  unsigned char *stop;
  // stopUnget
  unsigned char *stopUnget;
  // isReader
  signed int isReader;
  // isClosed
  signed int isClosed;
  // wasFCloseCalled
  signed int wasFCloseCalled;
  // FCGI_errno
  signed int FCGI_errno;
  // fillBuffProc
  void (*fillBuffProc)(struct FCGX_Stream *);
  // emptyBuffProc
  void (*emptyBuffProc)(struct FCGX_Stream *, signed int);
  // data
  void *data;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __uatomic_dummy
{
  // v
  unsigned long int v[10l];
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct sd_req
{
  // proto_ver
  unsigned char proto_ver;
  // opcode
  unsigned char opcode;
  // flags
  unsigned short int flags;
  // epoch
  unsigned int epoch;
  // id
  unsigned int id;
  // data_length
  unsigned int data_length;
  // $anon0
  union anonymous$5 $anon0;
};

struct list_node
{
  // next
  struct list_node *next;
  // prev
  struct list_node *prev;
};

struct work
{
  // w_list
  struct list_node w_list;
  // fn
  void (*fn)(struct work *);
  // done
  void (*done)(struct work *);
};

struct areq_work
{
  // rq
  struct sd_req rq;
  // data
  void *data;
  // iocb
  struct request_iocb *iocb;
  // result
  signed int result;
  // work
  struct work work;
};

struct bucket_iterater_arg
{
  // opaque
  void *opaque;
  // cb
  void (*cb)(const char *, void *);
  // bucket_count
  unsigned long int bucket_count;
  // object_count
  unsigned long int object_count;
  // bytes_used
  unsigned long int bytes_used;
};

struct cache_deletion_work
{
  // vid
  unsigned int vid;
  // work
  struct work work;
};

struct cache_info
{
  // vid
  unsigned int vid;
  // dirty
  unsigned int dirty;
  // total
  unsigned int total;
};

struct connection
{
  // fd
  signed int fd;
  // events
  unsigned int events;
  // port
  unsigned short int port;
  // ipstr
  char ipstr[46l];
  // dead
  _Bool dead;
};

struct list_head
{
  // n
  struct list_node n;
};

struct client_info
{
  // conn
  struct connection conn;
  // rx_req
  struct request *rx_req;
  // rx_work
  struct work rx_work;
  // tx_req
  struct request *tx_req;
  // tx_work
  struct work tx_work;
  // done_reqs
  struct list_head done_reqs;
  // refcnt
  struct anonymous$2 refcnt;
};

struct cluster_driver
{
  // name
  const char *name;
  // init
  signed int (*init)(const char *);
  // get_local_addr
  signed int (*get_local_addr)(unsigned char *);
  // join
  signed int (*join)(struct sd_node *, void *, unsigned long int);
  // leave
  signed int (*leave)(void);
  // notify
  signed int (*notify)(void *, unsigned long int);
  // block
  signed int (*block)(void);
  // unblock
  signed int (*unblock)(void *, unsigned long int);
  // lock
  void (*lock)(unsigned long int);
  // unlock
  void (*unlock)(unsigned long int);
  // update_node
  signed int (*update_node)(struct sd_node *);
  // list
  struct list_node list;
};

struct rb_node
{
  // rb_parent_color
  unsigned long int rb_parent_color;
  // rb_right
  struct rb_node *rb_right;
  // rb_left
  struct rb_node *rb_left;
};

struct node_id
{
  // addr
  unsigned char addr[16l];
  // port
  unsigned short int port;
  // io_addr
  unsigned char io_addr[16l];
  // io_port
  unsigned short int io_port;
  // pad
  unsigned char pad[4l];
};

struct sd_node
{
  // rb
  struct rb_node rb;
  // nid
  struct node_id nid;
  // nr_vnodes
  unsigned short int nr_vnodes;
  // zone
  unsigned int zone;
  // space
  unsigned long int space;
};

struct cluster_info
{
  // proto_ver
  unsigned char proto_ver;
  // disable_recovery
  unsigned char disable_recovery;
  // nr_nodes
  signed short int nr_nodes;
  // epoch
  unsigned int epoch;
  // ctime
  unsigned long int ctime;
  // flags
  unsigned short int flags;
  // nr_copies
  unsigned char nr_copies;
  // copy_policy
  unsigned char copy_policy;
  // status
  enum sd_status status : 8;
  // __pad
  unsigned int __pad;
  // store
  unsigned char store[16l];
  // nodes
  struct sd_node nodes[6144l];
};

struct delete_arg
{
  // inode
  struct sd_inode *inode;
  // nr_deleted
  unsigned int *nr_deleted;
};

struct deletion_work
{
  // work
  struct work work;
  // target_vid
  unsigned int target_vid;
  // delete_vid_count
  signed int delete_vid_count;
  // delete_vid_array
  unsigned int *delete_vid_array;
  // finish_fd
  signed int finish_fd;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct disk
{
  // rb
  struct rb_node rb;
  // path
  char path[4096l];
  // space
  unsigned long int space;
};

struct epoch_log
{
  // ctime
  unsigned long int ctime;
  // time
  unsigned long int time;
  // epoch
  unsigned int epoch;
  // nr_nodes
  unsigned int nr_nodes;
  // disable_recovery
  unsigned char disable_recovery;
  // nr_copies
  unsigned char nr_copies;
  // copy_policy
  unsigned char copy_policy;
  // __pad
  unsigned char __pad[1l];
  // drv_name
  char drv_name[16l];
  // nodes
  struct sd_node nodes[6144l];
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct event_info
{
  // handler
  void (*handler)(signed int, signed int, void *);
  // fd
  signed int fd;
  // data
  void *data;
  // rb
  struct rb_node rb;
  // prio
  signed int prio;
};

struct fec
{
  // magic
  unsigned long int magic;
  // d
  unsigned short int d;
  // dp
  unsigned short int dp;
  // enc_matrix
  unsigned char *enc_matrix;
};

struct find_path
{
  // p_idx
  struct sd_extent_idx *p_idx;
  // p_ext
  struct sd_extent *p_ext;
  // p_ext_header
  struct sd_extent_header *p_ext_header;
  // depth
  signed int depth;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct forward_info_entry
{
  // pfd
  struct pollfd pfd;
  // nid
  struct node_id *nid;
  // sfd
  struct sockfd *sfd;
  // buf
  void *buf;
};

struct forward_info
{
  // ent
  struct forward_info_entry ent[6144l];
  // nr_sent
  signed int nr_sent;
};

struct free_desc
{
  // start
  unsigned long int start;
  // count
  unsigned long int count;
};

struct rb_root
{
  // rb_node
  struct rb_node *rb_node;
};

struct get_vdis_work
{
  // work
  struct work work;
  // vdi_inuse
  unsigned long int vdi_inuse[262144l];
  // joined
  struct sd_node joined;
  // nroot
  struct rb_root nroot;
};

struct global_cache
{
  // capacity
  unsigned int capacity;
  // in_reclaim
  struct anonymous$0 in_reclaim;
};

struct header
{
  // used
  unsigned long int used;
  // nr_free
  unsigned long int nr_free;
};

struct hlist_head
{
  // first
  struct hlist_node *first;
};

struct hlist_node
{
  // next
  struct hlist_node *next;
  // pprev
  struct hlist_node **pprev;
};

struct http_driver
{
  // name
  const char *name;
  // init
  signed int (*init)(const char *);
  // head
  void (*head)(struct http_request *);
  // get
  void (*get)(struct http_request *);
  // put
  void (*put)(struct http_request *);
  // post
  void (*post)(struct http_request *);
  // delete
  void (*delete)(struct http_request *);
  // list
  struct list_node list;
};

struct http_request
{
  // fcgx
  struct FCGX_Request fcgx;
  // uri
  char *uri;
  // opcode
  enum http_opcode opcode;
  // status
  enum http_status status;
  // data_length
  unsigned long int data_length;
  // offset
  unsigned long int offset;
};

struct http_work
{
  // work
  struct work work;
  // request
  struct http_request *request;
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous$28 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct in6_addr
{
  // __in6_u
  union anonymous$19 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

struct journal_descriptor
{
  // magic
  unsigned int magic;
  // flag
  unsigned short int flag;
  // reserved
  unsigned short int reserved;
  // oid
  unsigned long int oid;
  // offset
  unsigned long int offset;
  // size
  unsigned long int size;
  // create
  unsigned char create;
  // pad
  unsigned char pad[475l];
} __attribute__ ((__packed__));

struct journal_file
{
  // fd
  signed int fd;
  // pos
  signed long int pos;
  // commit_fd
  signed int commit_fd;
  // in_commit
  struct anonymous$0 in_commit;
};

struct kv_bnode
{
  // name
  char name[256l];
  // object_count
  unsigned long int object_count;
  // bytes_used
  unsigned long int bytes_used;
  // oid
  unsigned long int oid;
};

struct kv_onode
{
  // $anon0
  union anonymous$25 $anon0;
  // $anon1
  union anonymous$26 $anon1;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct listening_fd
{
  // fd
  signed int fd;
  // list
  struct list_node list;
};

struct log_format
{
  // name
  const char *name;
  // formatter
  signed int (*formatter)(char *, unsigned long int, struct logmsg *, _Bool);
  // list
  struct list_node list;
};

union semun
{
  // val
  signed int val;
  // buf
  struct semid_ds *buf;
  // array
  unsigned short int *array;
  // __buf
  struct seminfo *__buf;
};

struct logarea
{
  // active
  _Bool active;
  // tail
  char *tail;
  // start
  char *start;
  // end
  char *end;
  // semid
  signed int semid;
  // semarg
  union semun semarg;
  // fd
  signed int fd;
};

struct logger_user_info
{
  // port
  signed int port;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct logmsg
{
  // tv
  struct timeval tv;
  // prio
  signed int prio;
  // func
  char func[32l];
  // line
  signed int line;
  // worker_name
  char worker_name[20l];
  // worker_idx
  signed int worker_idx;
  // str_len
  unsigned long int str_len;
  // str
  char str[0l];
};

struct sd_rw_lock
{
  // rwlock
  union anonymous$4 rwlock;
};

struct md
{
  // vroot
  struct rb_root vroot;
  // root
  struct rb_root root;
  // lock
  struct sd_rw_lock lock;
  // space
  unsigned long int space;
  // nr_disks
  unsigned int nr_disks;
};

struct md_info
{
  // idx
  signed int idx;
  // free
  unsigned long int free;
  // used
  unsigned long int used;
  // path
  char path[4096l];
};

struct md_work
{
  // work
  struct work work;
  // path
  char path[4096l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct node_id_v0
{
  // addr
  unsigned char addr[16l];
  // port
  unsigned short int port;
};

struct node_id_v1
{
  // addr
  unsigned char addr[16l];
  // port
  unsigned short int port;
};

struct node_id_v2
{
  // addr
  unsigned char addr[16l];
  // port
  unsigned short int port;
  // io_addr
  unsigned char io_addr[16l];
  // io_port
  unsigned short int io_port;
  // pad
  unsigned char pad[4l];
};

struct sd_mutex
{
  // mutex
  union anonymous mutex;
};

struct object_cache
{
  // vid
  unsigned int vid;
  // push_count
  unsigned int push_count;
  // dirty_count
  unsigned int dirty_count;
  // total_count
  unsigned int total_count;
  // hash
  struct hlist_node hash;
  // lru_tree
  struct rb_root lru_tree;
  // lru_head
  struct list_head lru_head;
  // dirty_head
  struct list_head dirty_head;
  // push_efd
  signed int push_efd;
  // push_mutex
  struct sd_mutex push_mutex;
  // lock
  struct sd_rw_lock lock;
};

struct object_cache_entry
{
  // idx
  unsigned long int idx;
  // refcnt
  struct anonymous$2 refcnt;
  // bmap
  unsigned long int bmap;
  // oc
  struct object_cache *oc;
  // node
  struct rb_node node;
  // dirty_list
  struct list_node dirty_list;
  // lru_list
  struct list_node lru_list;
  // lock
  struct sd_rw_lock lock;
};

struct object_cache_info
{
  // size
  unsigned long int size;
  // used
  unsigned long int used;
  // caches
  struct cache_info caches[1024l];
  // count
  signed int count;
  // directio
  unsigned char directio;
};

struct object_iterater_arg
{
  // opaque
  void *opaque;
  // cb
  void (*cb)(const char *, void *);
  // count
  unsigned int count;
};

struct objlist_cache
{
  // tree_version
  signed int tree_version;
  // buf_version
  signed int buf_version;
  // cache_size
  signed int cache_size;
  // buf
  unsigned long int *buf;
  // root
  struct rb_root root;
  // lock
  struct sd_rw_lock lock;
};

struct objlist_cache_entry
{
  // oid
  unsigned long int oid;
  // node
  struct rb_node node;
};

struct objlist_deletion_work
{
  // vid
  unsigned int vid;
  // work
  struct work work;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct option_parser
{
  // option
  const char *option;
  // parser
  signed int (*parser)(const char *);
};

struct pfd_info
{
  // pfds
  struct pollfd pfds[6144l];
  // nr
  signed int nr;
};

struct process_path_arg
{
  // path
  const char *path;
  // vinfo
  struct vnode_info *vinfo;
  // func
  signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *);
  // cleanup
  _Bool cleanup;
  // opaque
  void *opaque;
  // result
  signed int result;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct push_work
{
  // work
  struct work work;
  // entry
  struct object_cache_entry *entry;
  // oc
  struct object_cache *oc;
};

struct reclaim_work
{
  // work
  struct work work;
  // delay
  signed int delay;
};

struct recovery_info
{
  // state
  enum rw_state state;
  // epoch
  unsigned int epoch;
  // tgt_epoch
  unsigned int tgt_epoch;
  // done
  unsigned long int done;
  // suspended
  _Bool suspended;
  // notify_complete
  _Bool notify_complete;
  // count
  unsigned long int count;
  // oids
  unsigned long int *oids;
  // prio_oids
  unsigned long int *prio_oids;
  // nr_prio_oids
  unsigned long int nr_prio_oids;
  // nr_scheduled_prio_oids
  unsigned long int nr_scheduled_prio_oids;
  // old_vinfo
  struct vnode_info *old_vinfo;
  // cur_vinfo
  struct vnode_info *cur_vinfo;
};

struct recovery_work
{
  // epoch
  unsigned int epoch;
  // tgt_epoch
  unsigned int tgt_epoch;
  // old_vinfo
  struct vnode_info *old_vinfo;
  // cur_vinfo
  struct vnode_info *cur_vinfo;
  // work
  struct work work;
};

struct recovery_list_work
{
  // base
  struct recovery_work base;
  // count
  unsigned long int count;
  // oids
  unsigned long int *oids;
};

struct recovery_obj_work
{
  // base
  struct recovery_work base;
  // oid
  unsigned long int oid;
  // stop
  _Bool stop;
  // local_epoch
  unsigned int local_epoch;
  // local_sha1
  unsigned char local_sha1[20l];
};

struct recovery_state
{
  // in_recovery
  unsigned char in_recovery;
  // state
  enum rw_state state;
  // nr_finished
  unsigned long int nr_finished;
  // nr_total
  unsigned long int nr_total;
};

struct req_iter
{
  // buf
  unsigned char *buf;
  // wlen
  unsigned int wlen;
  // dlen
  unsigned int dlen;
  // off
  unsigned long int off;
};

struct sd_rsp
{
  // proto_ver
  unsigned char proto_ver;
  // opcode
  unsigned char opcode;
  // flags
  unsigned short int flags;
  // epoch
  unsigned int epoch;
  // id
  unsigned int id;
  // data_length
  unsigned int data_length;
  // $anon0
  union anonymous$6 $anon0;
};

struct request
{
  // rq
  struct sd_req rq;
  // rp
  struct sd_rsp rp;
  // op
  struct sd_op_template *op;
  // data
  void *data;
  // data_length
  unsigned int data_length;
  // ci
  struct client_info *ci;
  // request_list
  struct list_node request_list;
  // pending_list
  struct list_node pending_list;
  // refcnt
  struct anonymous$2 refcnt;
  // local
  _Bool local;
  // local_req_efd
  signed int local_req_efd;
  // local_oid
  unsigned long int local_oid;
  // vinfo
  struct vnode_info *vinfo;
  // work
  struct work work;
  // status
  enum REQUST_STATUS status;
  // stat
  _Bool stat;
};

struct request_iocb
{
  // count
  unsigned int count;
  // efd
  signed int efd;
  // result
  signed int result;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct s_request
{
  // gway_active_nr
  unsigned long int gway_active_nr;
  // peer_active_nr
  unsigned long int peer_active_nr;
  // gway_total_nr
  unsigned long int gway_total_nr;
  // peer_total_nr
  unsigned long int peer_total_nr;
  // gway_total_rx
  unsigned long int gway_total_rx;
  // gway_total_tx
  unsigned long int gway_total_tx;
  // peer_total_rx
  unsigned long int peer_total_rx;
  // peer_total_tx
  unsigned long int peer_total_tx;
  // gway_total_remove_nr
  unsigned long int gway_total_remove_nr;
  // gway_total_read_nr
  unsigned long int gway_total_read_nr;
  // gway_total_write_nr
  unsigned long int gway_total_write_nr;
  // gway_total_flush_nr
  unsigned long int gway_total_flush_nr;
  // peer_total_remove_nr
  unsigned long int peer_total_remove_nr;
  // peer_total_read_nr
  unsigned long int peer_total_read_nr;
  // peer_total_write_nr
  unsigned long int peer_total_write_nr;
};

struct sd_cond
{
  // cond
  union anonymous$7 cond;
};

struct sd_extent
{
  // idx
  unsigned int idx;
  // vdi_id
  unsigned int vdi_id;
};

struct sd_extent_header
{
  // magic
  unsigned short int magic;
  // depth
  unsigned short int depth;
  // entries
  unsigned int entries;
};

struct sd_extent_idx
{
  // idx
  unsigned int idx;
  // oid
  unsigned long int oid;
};

struct sd_inode
{
  // name
  char name[256l];
  // tag
  char tag[256l];
  // create_time
  unsigned long int create_time;
  // snap_ctime
  unsigned long int snap_ctime;
  // vm_clock_nsec
  unsigned long int vm_clock_nsec;
  // vdi_size
  unsigned long int vdi_size;
  // vm_state_size
  unsigned long int vm_state_size;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // nr_copies
  unsigned char nr_copies;
  // block_size_shift
  unsigned char block_size_shift;
  // snap_id
  unsigned int snap_id;
  // vdi_id
  unsigned int vdi_id;
  // parent_vdi_id
  unsigned int parent_vdi_id;
  // child_vdi_id
  unsigned int child_vdi_id[1024l];
  // data_vdi_id
  unsigned int data_vdi_id[1048576l];
  // btree_counter
  unsigned int btree_counter;
};

struct sd_md_info
{
  // disk
  struct md_info disk[64l];
  // nr
  signed int nr;
};

struct sd_node_v0
{
  // nid
  struct node_id_v0 nid;
  // nr_vnodes
  unsigned short int nr_vnodes;
  // zone
  unsigned int zone;
};

struct sd_node_v1
{
  // nid
  struct node_id_v1 nid;
  // nr_vnodes
  unsigned short int nr_vnodes;
  // zone
  unsigned int zone;
  // space
  unsigned long int space;
};

struct sd_node_v2
{
  // nid
  struct node_id_v2 nid;
  // nr_vnodes
  unsigned short int nr_vnodes;
  // zone
  unsigned int zone;
  // space
  unsigned long int space;
};

struct sd_op_template
{
  // name
  const char *name;
  // type
  enum sd_op_type type;
  // force
  _Bool force;
  // is_admin_op
  _Bool is_admin_op;
  // process_work
  signed int (*process_work)(struct request *);
  // process_main
  signed int (*process_main)(struct sd_req *, struct sd_rsp *, void *);
};

struct sd_option
{
  // ch
  signed int ch;
  // name
  const char *name;
  // has_arg
  _Bool has_arg;
  // desc
  const char *desc;
  // help
  const char *help;
};

struct sd_stat
{
  // r
  struct s_request r;
};

struct sd_vnode
{
  // rb
  struct rb_node rb;
  // node
  struct sd_node *node;
  // hash
  unsigned long int hash;
};

struct sembuf
{
  // sem_num
  unsigned short int sem_num;
  // sem_op
  signed short int sem_op;
  // sem_flg
  signed short int sem_flg;
};

struct semid_ds
{
  // sem_perm
  struct ipc_perm sem_perm;
  // sem_otime
  signed long int sem_otime;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // sem_ctime
  signed long int sem_ctime;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
  // sem_nsems
  unsigned long int sem_nsems;
  // __glibc_reserved3
  unsigned long int __glibc_reserved3;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
};

struct seminfo
{
  // semmap
  signed int semmap;
  // semmni
  signed int semmni;
  // semmns
  signed int semmns;
  // semmnu
  signed int semmnu;
  // semmsl
  signed int semmsl;
  // semopm
  signed int semopm;
  // semume
  signed int semume;
  // semusz
  signed int semusz;
  // semvmx
  signed int semvmx;
  // semaem
  signed int semaem;
};

struct sha1_ctx
{
  // count
  unsigned long int count;
  // state
  unsigned int state[5l];
  // buffer
  unsigned char buffer[64l];
};

struct sheepdog_config
{
  // ctime
  unsigned long int ctime;
  // flags
  unsigned short int flags;
  // copies
  unsigned char copies;
  // store
  unsigned char store[16l];
  // shutdown
  unsigned char shutdown;
  // copy_policy
  unsigned char copy_policy;
  // __pad
  unsigned char __pad;
  // version
  unsigned short int version;
  // space
  unsigned long int space;
};

struct sheepdog_config_v1
{
  // ctime
  unsigned long int ctime;
  // flags
  unsigned short int flags;
  // copies
  unsigned char copies;
  // store
  unsigned char store[16l];
  // __pad
  unsigned char __pad[3l];
  // version
  unsigned short int version;
  // space
  unsigned long int space;
};

struct sheepdog_vdi_attr
{
  // name
  char name[256l];
  // tag
  char tag[256l];
  // ctime
  unsigned long int ctime;
  // snap_id
  unsigned int snap_id;
  // value_len
  unsigned int value_len;
  // key
  char key[256l];
  // value
  char value[65536l];
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$29 __sigaction_handler;
  // sa_mask
  struct anonymous$1 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct signalfd_siginfo
{
  // ssi_signo
  unsigned int ssi_signo;
  // ssi_errno
  signed int ssi_errno;
  // ssi_code
  signed int ssi_code;
  // ssi_pid
  unsigned int ssi_pid;
  // ssi_uid
  unsigned int ssi_uid;
  // ssi_fd
  signed int ssi_fd;
  // ssi_tid
  unsigned int ssi_tid;
  // ssi_band
  unsigned int ssi_band;
  // ssi_overrun
  unsigned int ssi_overrun;
  // ssi_trapno
  unsigned int ssi_trapno;
  // ssi_status
  signed int ssi_status;
  // ssi_int
  signed int ssi_int;
  // ssi_ptr
  unsigned long int ssi_ptr;
  // ssi_utime
  unsigned long int ssi_utime;
  // ssi_stime
  unsigned long int ssi_stime;
  // ssi_addr
  unsigned long int ssi_addr;
  // __pad
  unsigned char __pad[48l];
};

struct siocb
{
  // epoch
  unsigned int epoch;
  // buf
  void *buf;
  // length
  unsigned int length;
  // offset
  unsigned int offset;
  // ec_index
  unsigned char ec_index;
  // copy_policy
  unsigned char copy_policy;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sockfd
{
  // fd
  signed int fd;
  // idx
  signed int idx;
};

struct sockfd_cache
{
  // root
  struct rb_root root;
  // lock
  struct sd_rw_lock lock;
  // count
  signed int count;
};

struct sockfd_cache_entry
{
  // rb
  struct rb_node rb;
  // nid
  struct node_id nid;
  // fds
  struct sockfd_cache_fd *fds;
};

struct sockfd_cache_fd
{
  // fd
  signed int fd;
  // in_use
  struct anonymous$0 in_use;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statvfs
{
  // f_bsize
  unsigned long int f_bsize;
  // f_frsize
  unsigned long int f_frsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_favail
  unsigned long int f_favail;
  // f_fsid
  unsigned long int f_fsid;
  // f_flag
  unsigned long int f_flag;
  // f_namemax
  unsigned long int f_namemax;
  // __f_spare
  signed int __f_spare[6l];
};

struct store_driver
{
  // list
  struct list_node list;
  // name
  const char *name;
  // init
  signed int (*init)(void);
  // exist
  _Bool (*exist)(unsigned long int, unsigned char);
  // create_and_write
  signed int (*create_and_write)(unsigned long int, struct siocb *);
  // write
  signed int (*write)(unsigned long int, struct siocb *);
  // read
  signed int (*read)(unsigned long int, struct siocb *);
  // format
  signed int (*format)(void);
  // remove_object
  signed int (*remove_object)(unsigned long int, unsigned char);
  // get_hash
  signed int (*get_hash)(unsigned long int, unsigned int, unsigned char *);
  // link
  signed int (*link)(unsigned long int, unsigned int);
  // update_epoch
  signed int (*update_epoch)(unsigned int);
  // purge_obj
  signed int (*purge_obj)(void);
  // cleanup
  signed int (*cleanup)(void);
};

struct strbuf
{
  // alloc
  unsigned long int alloc;
  // len
  unsigned long int len;
  // eof
  signed int eof;
  // buf
  char *buf;
};

struct system_info
{
  // cdrv
  struct cluster_driver *cdrv;
  // cdrv_option
  const char *cdrv_option;
  // this_node
  struct sd_node this_node;
  // cinfo
  struct cluster_info cinfo;
  // disk_space
  unsigned long int disk_space;
  // vdi_inuse
  unsigned long int vdi_inuse[262144l];
  // local_req_efd
  signed int local_req_efd;
  // local_req_lock
  struct sd_mutex local_req_lock;
  // local_req_queue
  struct list_head local_req_queue;
  // req_wait_queue
  struct list_head req_wait_queue;
  // nr_outstanding_reqs
  signed int nr_outstanding_reqs;
  // gateway_only
  _Bool gateway_only;
  // nosync
  _Bool nosync;
  // net_wqueue
  struct work_queue *net_wqueue;
  // gateway_wqueue
  struct work_queue *gateway_wqueue;
  // io_wqueue
  struct work_queue *io_wqueue;
  // deletion_wqueue
  struct work_queue *deletion_wqueue;
  // recovery_wqueue
  struct work_queue *recovery_wqueue;
  // recovery_notify_wqueue
  struct work_queue *recovery_notify_wqueue;
  // block_wqueue
  struct work_queue *block_wqueue;
  // oc_reclaim_wqueue
  struct work_queue *oc_reclaim_wqueue;
  // oc_push_wqueue
  struct work_queue *oc_push_wqueue;
  // md_wqueue
  struct work_queue *md_wqueue;
  // areq_wqueue
  struct work_queue *areq_wqueue;
  // http_wqueue
  struct work_queue *http_wqueue;
  // enable_object_cache
  _Bool enable_object_cache;
  // object_cache_size
  unsigned int object_cache_size;
  // object_cache_directio
  _Bool object_cache_directio;
  // use_journal
  struct anonymous$0 use_journal;
  // backend_dio
  _Bool backend_dio;
  // upgrade
  _Bool upgrade;
  // stat
  struct sd_stat stat;
};

struct timer
{
  // callback
  void (*callback)(void *);
  // data
  void *data;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vdi_info
{
  // vid
  unsigned int vid;
  // snapid
  unsigned int snapid;
  // free_bit
  unsigned int free_bit;
  // create_time
  unsigned long int create_time;
};

struct vdi_iocb
{
  // name
  const char *name;
  // tag
  const char *tag;
  // data_len
  unsigned int data_len;
  // size
  unsigned long int size;
  // base_vid
  unsigned int base_vid;
  // snapid
  unsigned int snapid;
  // create_snapshot
  _Bool create_snapshot;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // nr_copies
  unsigned char nr_copies;
  // time
  unsigned long int time;
};

struct vdi_op_message
{
  // req
  struct sd_req req;
  // rsp
  struct sd_rsp rsp;
  // data
  unsigned char data[0l];
};

struct vdi_state
{
  // vid
  unsigned int vid;
  // nr_copies
  unsigned char nr_copies;
  // snapshot
  unsigned char snapshot;
  // copy_policy
  unsigned char copy_policy;
  // _pad
  unsigned char _pad;
};

struct vdi_state_entry
{
  // vid
  unsigned int vid;
  // nr_copies
  unsigned int nr_copies;
  // snapshot
  _Bool snapshot;
  // copy_policy
  unsigned char copy_policy;
  // node
  struct rb_node node;
};

struct vdisk
{
  // rb
  struct rb_node rb;
  // disk
  struct disk *disk;
  // hash
  unsigned long int hash;
};

struct vnode_info
{
  // vroot
  struct rb_root vroot;
  // nroot
  struct rb_root nroot;
  // nr_nodes
  signed int nr_nodes;
  // nr_zones
  signed int nr_zones;
  // refcnt
  struct anonymous$2 refcnt;
};

struct work_queue
{
  // wq_state
  signed int wq_state;
  // pending_list
  struct list_head pending_list;
};

struct wq_info
{
  // name
  const char *name;
  // finished_list
  struct list_head finished_list;
  // list
  struct list_node list;
  // finished_lock
  struct sd_mutex finished_lock;
  // startup_lock
  struct sd_mutex startup_lock;
  // pending_cond
  struct sd_cond pending_cond;
  // pending_lock
  struct sd_mutex pending_lock;
  // q
  struct work_queue q;
  // nr_threads
  unsigned long int nr_threads;
  // nr_queued_work
  unsigned long int nr_queued_work;
  // tm_end_of_protection
  unsigned long int tm_end_of_protection;
  // tc
  enum wq_thread_control tc;
};


// Pp
// file fec.c line 69
static const char * const Pp = "101110001";
// __sys
// file sheep.c line 275
static struct system_info __sys;
// bind_help
// file sheep.c line 26
static const char bind_help[277l] = { 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'b', ' ', '1', '9', '2', '.', '1', '6', '8', '.', '1', '.', '1', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 't', 'e', 'a', 'c', 'h', ' ', 's', 'h', 'e', 'e', 'p', ' ', 'l', 'i', 's', 't', 'e', 'n', ' ', 't', 'o', ' ', 'N', 'I', 'C', ' ', 'o', 'f', ' ', '1', '9', '2', '.', '1', '6', '8', '.', '1', '.', '1', '.', '\n', '\n', 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'b', ' ', '0', '.', '0', '.', '0', '.', '0', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 't', 'e', 'a', 'c', 'h', ' ', 's', 'h', 'e', 'e', 'p', ' ', 'l', 'i', 's', 't', 'e', 'n', ' ', 't', 'o', ' ', 'a', 'l', 'l', ' ', 't', 'h', 'e', ' ', 'N', 'I', 'C', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', '.', ' ', 'I', 't', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'f', 'u', 'l', '\n', 'w', 'h', 'e', 'n', ' ', 'y', 'o', 'u', ' ', 'w', 'a', 'n', 't', ' ', 's', 'h', 'e', 'e', 'p', ' ', 't', 'o', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', ' ', 'd', 'o', 'g', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 'a', 'n', 'd', ' ', 'p', 'o', 'r', 't', '.', '\n', 0 };
// cache_hashtable
// file object_cache.c line 86
static struct hlist_head cache_hashtable[32l];
// cache_help
// file sheep.c line 77
static const char cache_help[354l] = { 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ':', '\n', '\t', 's', 'i', 'z', 'e', '=', ':', ' ', 's', 'i', 'z', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'i', 'n', ' ', 'm', 'e', 'g', 'a', 'b', 'y', 'e', 's', '\n', '\t', 'd', 'i', 'r', '=', ':', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'a', 'c', 'h', 'e', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '$', 'S', 'T', 'O', 'R', 'E', '/', 'c', 'a', 'c', 'h', 'e', ')', '\n', '\t', 'd', 'i', 'r', 'e', 'c', 't', 'i', 'o', ':', ' ', 'u', 's', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'i', 'o', ' ', 'm', 'o', 'd', 'e', ' ', 'f', 'o', 'r', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 'I', 'O', ',', ' ', 'i', 'f', ' ', 'n', 'o', 't', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 'u', 's', 'e', ' ', 'b', 'u', 'f', 'f', 'e', 'r', 'e', 'd', ' ', 'I', 'O', '\n', '\n', 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'w', ' ', 's', 'i', 'z', 'e', '=', '2', '0', '0', 'G', ',', 'd', 'i', 'r', '=', '/', 'm', 'y', '_', 's', 's', 'd', ',', 'd', 'i', 'r', 'e', 'c', 't', 'i', 'o', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 'u', 's', 'e', ' ', '/', 'm', 'y', '_', 's', 's', 'd', ' ', 'a', 's', ' ', 't', 'h', 'e', ' ', 'c', 'a', 'c', 'h', 'e', ' ', 's', 't', 'o', 'r', 'a', 'g', 'e', ' ', 'w', 'i', 't', 'h', ' ', '2', '0', '0', 'G', ' ', 'a', 'l', 'l', 'o', 'c', 't', 'e', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e', '\n', 'c', 'a', 'c', 'h', 'e', ' ', 'i', 'n', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'i', 'o', ' ', 'm', 'o', 'd', 'e', '\n', 0 };
// cache_parsers
// file sheep.c line 311
static struct option_parser cache_parsers[4l];
// cache_parsers
// file sheep.c line 311
static struct option_parser cache_parsers[4l] = { { .option="size=", .parser=cache_size_parser },
    { .option="directio", .parser=cache_directio_parser },
    { .option="dir=", .parser=cache_dir_parser },
    { .option=(const char *)(void *)0, .parser=(signed int (*)(const char *))(void *)0 } };
// cluster_drivers
// file sheep.c line 23
struct list_head cluster_drivers;
// cluster_drivers
// file sheep.c line 23
struct list_head cluster_drivers = { .n={ .next=&cluster_drivers.n, .prev=&cluster_drivers.n } };
// cluster_help
// file sheep.c line 65
static const char cluster_help[482l] = { 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ':', '\n', '\t', 'l', 'o', 'c', 'a', 'l', ':', ' ', 'u', 's', 'e', ' ', 'l', 'o', 'c', 'a', 'l', ' ', 'd', 'r', 'i', 'v', 'e', 'r', '\n', '\t', 'c', 'o', 'r', 'o', 's', 'y', 'n', 'c', ':', ' ', 'u', 's', 'e', ' ', 'c', 'o', 'r', 'o', 's', 'y', 'n', 'c', ' ', 'd', 'r', 'i', 'v', 'e', 'r', '\n', '\t', 'z', 'o', 'o', 'k', 'e', 'e', 'p', 'e', 'r', ':', ' ', 'u', 's', 'e', ' ', 'z', 'o', 'o', 'k', 'e', 'e', 'p', 'e', 'r', ' ', 'd', 'r', 'i', 'v', 'e', 'r', ',', ' ', 'n', 'e', 'e', 'd', ' ', 'e', 'x', 't', 'r', 'a', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', '\n', '\n', '\t', 'z', 'o', 'o', 'k', 'e', 'e', 'p', 'e', 'r', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ':', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', '-', 'l', 'i', 's', 't', ',', 't', 'i', 'e', 'm', 'o', 'u', 't', '=', 'v', 'a', 'l', 'u', 'e', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'a', 's', ' ', '3', '0', '0', '0', ')', '\n', '\n', 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'c', ' ', 'z', 'o', 'o', 'k', 'e', 'e', 'p', 'e', 'r', ':', 'I', 'P', '1', ':', 'P', 'O', 'R', 'T', '1', ',', 'I', 'P', '2', ':', 'P', 'O', 'R', 'T', '2', ',', 'I', 'P', '3', ':', 'P', 'O', 'R', 'T', '3', ',', 't', 'i', 'm', 'e', 'o', 'u', 't', '=', '1', '0', '0', '0', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 'u', 's', 'e', ' ', '3', ' ', 'n', 'o', 'd', 'e', ' ', 'z', 'o', 'o', 'k', 'e', 'e', 'p', 'e', 'r', ' ', 'c', 'l', 'u', 's', 't', 'e', 'r', ',', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 'r', 'e', 'a', 'c', 'h', 'e', 'd', ' ', 'b', 'y', '\n', 'I', 'P', '1', ':', 'P', 'O', 'R', 'T', '1', ',', ' ', 'I', 'P', '2', ':', 'P', 'O', 'R', 'T', '2', ',', ' ', 'I', 'P', '3', ':', 'P', 'O', 'R', 'T', '3', ' ', 't', 'o', ' ', 'm', 'a', 'n', 'a', 'g', 'e', ' ', 'm', 'e', 'm', 'b', 'e', 'r', 's', 'h', 'i', 'p', ' ', 'a', 'n', 'd', ' ', 'b', 'r', 'o', 'a', 'd', 'c', 'a', 's', 't', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', '\n', 'a', 'n', 'd', ' ', 's', 'e', 't', ' ', 't', 'h', 'e', ' ', 't', 'i', 'm', 'e', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'n', 'o', 'd', 'e', ' ', 'h', 'e', 'a', 'r', 't', 'b', 'e', 'a', 't', ' ', 'a', 's', ' ', '1', '0', '0', '0', ' ', 'm', 'i', 'l', 'l', 'i', 's', 'e', 'c', 'o', 'n', 'd', 's', '\n', 0 };
// cluster_op_running
// file group.c line 196
static _Bool cluster_op_running;
// colorize
// file logger.c line 40
static _Bool colorize;
// commit_wq
// file journal.c line 59
static struct work_queue *commit_wq;
// config
// file config.c line 27
static struct sheepdog_config config;
// config_path
// file config.c line 29
char *config_path;
// current_rinfo
// file recovery.c line 76
static struct anonymous$23 current_rinfo;
// current_vnode_info
// file group.c line 30
static struct anonymous$9 current_vnode_info;
// def_open_flags
// file object_cache.c line 77
static signed int def_open_flags = 02;
// dst_type
// file logger.c line 123
static enum log_dst_type dst_type = (enum log_dst_type)1;
// ec_max_data_strip
// file vdi.c line 30
signed int ec_max_data_strip;
// efd
// file event.c line 22
static signed int efd;
// efd$link1
// file work.c line 68
static signed int efd$link1;
// epoch_path
// file store.c line 15
char *epoch_path;
// event_loop_refresh
// file event.c line 172
static _Bool event_loop_refresh;
// events
// file event.c line 71
static struct epoll_event *events;
// events_tree
// file event.c line 23
static struct rb_root events_tree = { .rb_node=(struct rb_node *)(void *)0 };
// fds_count
// file sockfd_cache.c line 62
static signed int fds_count = 8;
// fds_high_watermark
// file sockfd_cache.c line 243
static signed int fds_high_watermark = (8 * 3) / 4;
// fds_in_grow
// file sockfd_cache.c line 242
static struct anonymous$0 fds_in_grow;
// format
// file logger.c line 107
static struct log_format *format;
// gcache
// file object_cache.c line 75
static struct global_cache gcache;
// gf_exp
// file fec.c line 80
static unsigned char gf_exp[510l];
// gf_log
// file fec.c line 81
static signed int gf_log[256l];
// gf_mul_table
// file fec.c line 108
static unsigned char gf_mul_table[256l][256l];
// grow_wq
// file sockfd_cache.c line 245
static struct work_queue *grow_wq;
// hashtable_lock
// file object_cache.c line 82
static struct sd_rw_lock hashtable_lock[32l] = { { .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } },
    { .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } } };
// http_drivers
// file http/http.c line 23
struct list_head http_drivers;
// http_drivers
// file http/http.c line 23
struct list_head http_drivers = { .n={ .next=&http_drivers.n, .prev=&http_drivers.n } };
// http_enabled_drivers
// file http/http.c line 24
static struct list_head http_enabled_drivers;
// http_enabled_drivers
// file http/http.c line 24
static struct list_head http_enabled_drivers = { .n={ .next=&http_enabled_drivers.n, .prev=&http_enabled_drivers.n } };
// http_help
// file sheep.c line 46
static const char http_help[337l] = { 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ':', '\n', '\t', 'h', 'o', 's', 't', '=', ':', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'y', ' ', 'a', ' ', 'h', 'o', 's', 't', ' ', 't', 'o', ' ', 'c', 'o', 'm', 'm', 'u', 'n', 'i', 'c', 'a', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'h', 't', 't', 'p', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', ')', '\n', '\t', 'p', 'o', 'r', 't', '=', ':', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'y', ' ', 'a', ' ', 'p', 'o', 'r', 't', ' ', 't', 'o', ' ', 'c', 'o', 'm', 'm', 'u', 'n', 'i', 'c', 'a', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'h', 't', 't', 'p', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '8', '0', '0', '0', ')', '\n', '\t', 's', 'w', 'i', 'f', 't', ':', ' ', 'e', 'n', 'a', 'b', 'l', 'e', ' ', 's', 'w', 'i', 'f', 't', ' ', 'A', 'P', 'I', '\n', 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'r', ' ', 'h', 'o', 's', 't', '=', 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', ',', 'p', 'o', 'r', 't', '=', '7', '0', '0', '1', ',', 's', 'w', 'i', 'f', 't', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 'e', 'n', 'a', 'b', 'l', 'e', ' ', 'S', 'w', 'i', 'f', 't', ' ', 'A', 'P', 'I', ' ', 'a', 'n', 'd', ' ', 'u', 's', 'e', ' ', 'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', ':', '7', '0', '0', '1', ' ', 't', 'o', '\n', 'c', 'o', 'm', 'm', 'u', 'n', 'i', 'c', 'a', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'h', 't', 't', 'p', ' ', 's', 'e', 'r', 'v', 'e', 'r', '.', '\n', 0 };
// http_host
// file http/http.c line 20
static const char *http_host = "localhost";
// http_opt_parsers
// file http/http.c line 375
static struct option_parser http_opt_parsers[4l];
// http_opt_parsers
// file http/http.c line 375
static struct option_parser http_opt_parsers[4l] = { { .option="host=", .parser=http_opt_host_parser },
    { .option="port=", .parser=http_opt_port_parser },
    { .option="", .parser=http_opt_default_parser },
    { .option=(const char *)(void *)0, .parser=(signed int (*)(const char *))(void *)0 } };
// http_port
// file http/http.c line 21
static const char *http_port = "8000";
// http_sockfd
// file http/http.c line 307
static signed int http_sockfd;
// inverse
// file fec.c line 82
static unsigned char inverse[256l];
// io_addr
// file sheep.c line 371
static const char *io_addr;
// io_pt
// file sheep.c line 371
static const char *io_pt;
// ioaddr_help
// file sheep.c line 33
static const char ioaddr_help[199l] = { 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'i', ' ', 'h', 'o', 's', 't', '=', '1', '9', '2', '.', '1', '6', '8', '.', '1', '.', '1', ',', 'p', 'o', 'r', 't', '=', '7', '0', '0', '2', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'd', 'e', 'd', 'i', 'c', 'a', 't', 'e', 'd', ' ', 'I', 'O', ' ', 'N', 'I', 'C', ' ', 'o', 'f', ' ', '1', '9', '2', '.', '1', '6', '8', '.', '1', '.', '1', ':', '7', '0', '0', '2', ' ', 't', 'o', ' ', 't', 'r', 'a', 'n', 's', 'f', 'e', 'r', ' ', 'd', 'a', 't', 'a', '.', '\n', 'I', 'f', ' ', 'I', 'O', ' ', 'N', 'I', 'C', ' ', 'i', 's', ' ', 'd', 'o', 'w', 'n', ',', ' ', 's', 'h', 'e', 'e', 'p', ' ', 'w', 'i', 'l', 'l', ' ', 'f', 'a', 'l', 'l', 'b', 'a', 'c', 'k', ' ', 't', 'o', ' ', 'n', 'o', 'n', ' ', 'I', 'O', ' ', 'N', 'I', 'C', ' ', 't', 'o', ' ', 't', 'r', 'a', 'n', 's', 'f', 'e', 'r', ' ', 'd', 'a', 't', 'a', '.', '\n', 0 };
// ionic_parsers
// file sheep.c line 384
static struct option_parser ionic_parsers[3l];
// ionic_parsers
// file sheep.c line 384
static struct option_parser ionic_parsers[3l] = { { .option="host=", .parser=ionic_host_parser },
    { .option="port=", .parser=ionic_port_parser },
    { .option=(const char *)(void *)0, .parser=(signed int (*)(const char *))(void *)0 } };
// jfile
// file journal.c line 56
static struct journal_file jfile;
// jfile_fds
// file journal.c line 53
static signed int jfile_fds[2l];
// jfile_lock
// file journal.c line 57
static struct sd_mutex jfile_lock = { .mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// jfile_name
// file journal.c line 52
static const char *jfile_name[2l] = { "journal_file0", "journal_file1" };
// jfile_size
// file journal.c line 54
static unsigned long int jfile_size;
// journal_commit_mutex
// file journal.c line 314
static struct sd_mutex journal_commit_mutex = { .mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// journal_help
// file sheep.c line 38
static const char journal_help[281l] = { 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ':', '\n', '\t', 's', 'i', 'z', 'e', '=', ':', ' ', 's', 'i', 'z', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'j', 'o', 'u', 'r', 'n', 'a', 'l', ' ', 'i', 'n', ' ', 'm', 'e', 'g', 'a', 'b', 'y', 'e', 's', '\n', '\t', 'd', 'i', 'r', '=', ':', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'j', 'o', 'u', 'r', 'n', 'a', 'l', ' ', '(', 'd', 'e', 'f', 'a', 'u', 'l', 't', ':', ' ', '$', 'S', 'T', 'O', 'R', 'E', ')', '\n', '\t', 's', 'k', 'i', 'p', ':', ' ', 'i', 'f', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ',', ' ', 's', 'k', 'i', 'p', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'c', 'o', 'v', 'e', 'r', 'y', ' ', 'a', 't', ' ', 's', 't', 'a', 'r', 't', 'u', 'p', '\n', '\n', 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'j', ' ', 'd', 'i', 'r', '=', '/', 'j', 'o', 'u', 'r', 'n', 'a', 'l', ',', 's', 'i', 'z', 'e', '=', '1', 'G', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 'u', 's', 'e', ' ', '/', 'j', 'o', 'u', 'r', 'n', 'a', 'l', ' ', 'a', 's', ' ', 't', 'h', 'e', ' ', 'j', 'o', 'u', 'r', 'n', 'a', 'l', ' ', 's', 't', 'o', 'r', 'a', 'g', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', ' ', '1', 'G', '\n', 0 };
// journal_parsers
// file sheep.c line 419
static struct option_parser journal_parsers[4l];
// journal_parsers
// file sheep.c line 419
static struct option_parser journal_parsers[4l] = { { .option="dir=", .parser=journal_dir_parser },
    { .option="size=", .parser=journal_size_parser },
    { .option="skip", .parser=journal_skip_parser },
    { .option=(const char *)(void *)0, .parser=(signed int (*)(const char *))(void *)0 } };
// jpath
// file sheep.c line 390
static char jpath[4096l];
// jsize
// file sheep.c line 392
static unsigned long int jsize;
// jskip
// file sheep.c line 391
static _Bool jskip;
// la
// file logger.c line 112
static struct logarea *la;
// last_gathered_epoch
// file ops.c line 59
unsigned int last_gathered_epoch = (unsigned int)1;
// list_buffer_size
// file recovery.c line 82
static unsigned long int list_buffer_size = 1UL << 22;
// listening_fd_list
// file request.c line 1031
static struct list_head listening_fd_list;
// listening_fd_list
// file request.c line 1031
static struct list_head listening_fd_list = { .n={ .next=&listening_fd_list.n, .prev=&listening_fd_list.n } };
// log_buff
// file logger.c line 119
static char *log_buff;
// log_dst
// file sheep.c line 354
static const char *log_dst = "default";
// log_fd
// file logger.c line 109
static signed int log_fd = -1;
// log_format
// file sheep.c line 346
static const char *log_format = "server";
// log_formats
// file logger.c line 106
static struct list_head log_formats;
// log_formats
// file logger.c line 106
static struct list_head log_formats = { .n={ .next=&log_formats.n, .prev=&log_formats.n } };
// log_help
// file sheep.c line 87
static const char log_help[1001l] = { 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'l', ' ', 'd', 'i', 'r', '=', '/', 'v', 'a', 'r', '/', 'l', 'o', 'g', '/', ',', 'l', 'e', 'v', 'e', 'l', '=', 'd', 'e', 'b', 'u', 'g', ',', 'f', 'o', 'r', 'm', 'a', 't', '=', 's', 'e', 'r', 'v', 'e', 'r', ' ', '.', '.', '.', '\n', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ':', '\n', '\t', 'd', 'i', 'r', '=', ':', ' ', 'p', 'a', 't', 'h', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 's', 'h', 'e', 'e', 'p', '.', 'l', 'o', 'g', '\n', '\t', 'l', 'e', 'v', 'e', 'l', '=', ':', ' ', 'l', 'o', 'g', ' ', 'l', 'e', 'v', 'e', 'l', ' ', 'o', 'f', ' ', 's', 'h', 'e', 'e', 'p', '.', 'l', 'o', 'g', '\n', '\t', 'f', 'o', 'r', 'm', 'a', 't', '=', ':', ' ', 'l', 'o', 'g', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 't', 'y', 'p', 'e', '\n', '\t', 'd', 's', 't', '=', ':', ' ', 'l', 'o', 'g', ' ', 'd', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 't', 'y', 'p', 'e', '\n', '\n', 'i', 'f', ' ', 'd', 'i', 'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ',', ' ', 'u', 's', 'e', ' ', 'm', 'e', 't', 'a', 's', 't', 'o', 'r', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '\n', '\n', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'l', 'o', 'g', ' ', 'l', 'e', 'v', 'e', 'l', 's', ':', '\n', ' ', ' ', 'L', 'e', 'v', 'e', 'l', ' ', ' ', ' ', ' ', ' ', ' ', 'D', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n', '\n', ' ', ' ', 'e', 'm', 'e', 'r', 'g', ' ', ' ', ' ', ' ', ' ', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'h', 'a', 's', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ' ', 'a', 'n', 'd', ' ', 'i', 's', ' ', 'u', 'n', 'u', 's', 'a', 'b', 'l', 'e', '\n', ' ', ' ', 'a', 'l', 'e', 'r', 't', ' ', ' ', ' ', ' ', ' ', ' ', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 't', 'a', 'k', 'e', 'n', ' ', 'i', 'm', 'm', 'e', 'd', 'i', 'a', 't', 'e', 'l', 'y', '\n', ' ', ' ', 'c', 'r', 'i', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', '\n', ' ', ' ', 'e', 'r', 'r', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', '\n', ' ', ' ', 'w', 'a', 'r', 'n', 'i', 'n', 'g', ' ', ' ', ' ', ' ', 'w', 'a', 'r', 'n', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', '\n', ' ', ' ', 'n', 'o', 't', 'i', 'c', 'e', ' ', ' ', ' ', ' ', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'b', 'u', 't', ' ', 's', 'i', 'g', 'n', 'i', 'f', 'i', 'c', 'a', 'n', 't', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', '\n', ' ', ' ', 'i', 'n', 'f', 'o', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'n', 'o', 't', 'i', 'c', 'e', 's', '\n', ' ', ' ', 'd', 'e', 'b', 'u', 'g', ' ', ' ', ' ', ' ', ' ', ' ', 'd', 'e', 'b', 'u', 'g', 'g', 'i', 'n', 'g', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 's', '\n', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'l', 'o', 'g', ' ', 'l', 'e', 'v', 'e', 'l', ' ', 'i', 's', ' ', 'i', 'n', 'f', 'o', '\n', '\n', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'l', 'o', 'g', ' ', 'f', 'o', 'r', 'm', 'a', 't', ':', '\n', ' ', ' ', 'F', 'o', 'r', 'm', 'a', 't', 'T', 'y', 'p', 'e', ' ', ' ', ' ', ' ', ' ', ' ', 'D', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n', '\n', ' ', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'r', 'a', 'w', ' ', 'f', 'o', 'r', 'm', 'a', 't', '\n', ' ', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'r', 'a', 'w', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', 'w', 'i', 't', 'h', ' ', 't', 'i', 'm', 'e', 's', 't', 'a', 'm', 'p', '\n', ' ', ' ', 'j', 's', 'o', 'n', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'j', 's', 'o', 'n', ' ', 'f', 'o', 'r', 'm', 'a', 't', '\n', '\n', 'A', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'l', 'o', 'g', ' ', 'd', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ':', '\n', ' ', ' ', 'D', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'T', 'y', 'p', 'e', ' ', ' ', ' ', ' ', 'D', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n', '\n', ' ', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'd', 'e', 'd', 'i', 'c', 'a', 't', 'e', 'd', ' ', 'f', 'i', 'l', 'e', ' ', 'i', 'n', ' ', 'a', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', ' ', 'u', 's', 'e', 'd', ' ', 'b', 'y', ' ', 's', 'h', 'e', 'e', 'p', '\n', ' ', ' ', 's', 'y', 's', 'l', 'o', 'g', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 's', 'y', 's', 'l', 'o', 'g', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 's', 'y', 's', 't', 'e', 'm', '\n', ' ', ' ', 's', 't', 'd', 'o', 'u', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 's', 't', 'a', 'n', 'd', 'a', 'r', 'd', ' ', 'o', 'u', 't', 'p', 'u', 't', '\n', 0 };
// log_level
// file sheep.c line 318
static signed int log_level = 6;
// log_name
// file logger.c line 113
static const char *log_name;
// log_nowname
// file logger.c line 114
static char *log_nowname;
// log_parsers
// file sheep.c line 362
static struct option_parser log_parsers[5l];
// log_parsers
// file sheep.c line 362
static struct option_parser log_parsers[5l] = { { .option="level=", .parser=log_level_parser },
    { .option="dir=", .parser=log_dir_parser },
    { .option="format=", .parser=log_format_parser },
    { .option="dst=", .parser=log_dst_parser },
    { .option=(const char *)(void *)0, .parser=(signed int (*)(const char *))(void *)0 } };
// logdir
// file sheep.c line 334
static char *logdir;
// logger_pid
// file logger.c line 117
signed int logger_pid = -1;
// logger_user_info
// file logger.c line 63
static struct logger_user_info *logger_user_info;
// map_table
// file ops.c line 1447
static signed int map_table[5l] = { 0, 0xA3, 0xA4, 0xA5, 0xA6 };
// max_logsize
// file logger.c line 121
static signed long int max_logsize = (signed long int)(500 * 1024 * 1024);
// md
// file md.c line 40
static struct md md = { .vroot={ .rb_node=(struct rb_node *)(void *)0 }, .root={ .rb_node=(struct rb_node *)(void *)0 },
    .lock={ .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } },
    .space=0ul,
    .nr_disks=0u };
// migrate
// file migrate.c line 500
static signed int (*migrate[4l])(void);
// migrate
// file migrate.c line 500
static signed int (*migrate[4l])(void) = { migrate_from_v0_to_v1, migrate_from_v1_to_v2, migrate_from_v2_to_v3, migrate_from_v3_to_v4 };
// myaddr_help
// file sheep.c line 55
static const char myaddr_help[124l] = { 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'y', ' ', '1', '9', '2', '.', '1', '6', '8', '.', '1', '.', '1', ':', '7', '0', '0', '0', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 't', 'e', 'l', 'l', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'n', 'o', 'd', 'e', 's', ' ', 't', 'h', 'r', 'o', 'u', 'g', 'h', ' ', 'w', 'h', 'a', 't', ' ', 'a', 'd', 'd', 'r', 'e', 's', 's', ' ', 't', 'h', 'e', 'y', ' ', 'c', 'a', 'n', ' ', 't', 'a', 'l', 'k', ' ', 't', 'o', ' ', 't', 'h', 'i', 's', '\n', 's', 'h', 'e', 'e', 'p', '.', '\n', 0 };
// next_rinfo
// file recovery.c line 75
static struct recovery_info *next_rinfo;
// nr_events
// file event.c line 72
static signed int nr_events;
// nr_get_vdis_works
// file group.c line 28
static struct anonymous$2 nr_get_vdis_works;
// nr_nodes
// file work.c line 70
static unsigned long int nr_nodes = (unsigned long int)1;
// obj_list_cache
// file object_list_cache.c line 35
static struct objlist_cache obj_list_cache = { .tree_version=1, .buf_version=0, .cache_size=0, .buf=((unsigned long int *)NULL),
    .root={ .rb_node=(struct rb_node *)(void *)0 }, .lock={ .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } } };
// obj_path
// file store.c line 14
char *obj_path;
// object_cache_dir
// file object_cache.c line 76
static char object_cache_dir[4096l];
// ocpath
// file sheep.c line 303
static char ocpath[4096l];
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// pending_block_list
// file group.c line 31
static struct anonymous$10 pending_block_list;
// pending_notify_list
// file group.c line 32
static struct anonymous$10 pending_notify_list;
// program_name
// file sheep.c line 24
static const char program_name[6l] = { 's', 'h', 'e', 'e', 'p', 0 };
// sd_def_dmode
// file util.c line 25
unsigned int sd_def_dmode = (unsigned int)(0400 | 0200 | 0100 | 0400 >> 3 | 0200 >> 3 | 0100 >> 3);
// sd_def_fmode
// file util.c line 26
unsigned int sd_def_fmode = (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3);
// sd_log_level
// file logger.c line 115
signed int sd_log_level = 6;
// sd_ops
// file ops.c line 1020
static struct sd_op_template sd_ops[187l];
// sd_ops
// file ops.c line 1020
static struct sd_op_template sd_ops[187l] = { { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="CREATE_AND_WRITE_OBJ", .type=(enum sd_op_type)4, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=gateway_create_and_write_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="READ_OBJ", .type=(enum sd_op_type)4, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=gateway_read_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="WRITE_OBJ", .type=(enum sd_op_type)4, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=gateway_write_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="REMOVE_OBJ", .type=(enum sd_op_type)4, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=gateway_remove_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="DISCARD_OBJ", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_discard_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="NEW_VDI", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=cluster_new_vdi,
    .process_main=post_cluster_new_vdi },
    { .name="LOCK_VDI", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=cluster_get_vdi_info,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="RELEASE_VDI", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_release_vdi,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_VDI_INFO", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=cluster_get_vdi_info,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="READ_VDIS", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_read_vdis },
    { .name="FLUSH_VDI", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_flush_vdi,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="DEL_VDI", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=cluster_del_vdi,
    .process_main=post_cluster_del_vdi },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_NODE_LIST", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_get_node_list },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="MAKE_FS", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_make_fs },
    { .name="SHUTDOWN", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_shutdown },
    { .name="STAT_SHEEP", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_stat_sheep,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="STAT_CLUSTER", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=local_stat_cluster,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_VDI_ATTR", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=cluster_get_vdi_attr,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="FORCE_RECOVER", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)1, .process_work=cluster_force_recover_work,
    .process_main=cluster_force_recover_main },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_STORE_LIST", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=local_get_store_list,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="CLEANUP", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_cleanup },
    { .name="TRACE_STATUS", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_trace_status },
    { .name="TRACE_READ_BUF", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=local_trace_read_buf,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="STAT_RECOVERY", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_stat_recovery },
    { .name="DEL_CACHE", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_flush_and_del,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="NOTIFY_VDI_DEL", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_notify_vdi_del },
    { .name="KILL_NODE", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_kill_node },
    { .name="TRACE_ENABLE", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_trace_enable },
    { .name="TRACE_DISABLE", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_trace_disable },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_OBJ_LIST", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_get_obj_list,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_EPOCH", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_get_epoch,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="CREATE_AND_WRITE_PEER", .type=(enum sd_op_type)3, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=peer_create_and_write_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="READ_PEER", .type=(enum sd_op_type)3, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=peer_read_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="WRITE_PEER", .type=(enum sd_op_type)3, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=peer_write_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="REMOVE_PEER", .type=(enum sd_op_type)3, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=peer_remove_obj,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="ENABLE_RECOVER", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_enable_recover },
    { .name="DISABLE_RECOVER", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_disable_recover },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="GET_VDI_COPIES", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_get_vdi_copies },
    { .name="COMPLETE_RECOVERY", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_recovery_completion },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name=((const char *)NULL), .type=(enum sd_op_type)0, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="NOTIFY_VDI_ADD", .type=(enum sd_op_type)1, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_notify_vdi_add },
    { .name="DELETE_CACHE", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_delete_cache },
    { .name="MD_INFO", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_md_info,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="MD_PLUG_DISKS", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_md_plug },
    { .name="MD_UNPLUG_DISKS", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_md_unplug },
    { .name="GET_HASH", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_get_hash,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="REWEIGHT", .type=(enum sd_op_type)1, .force=(_Bool)0,
    .is_admin_op=(_Bool)1, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=cluster_reweight },
    { .name="GET_CACHE_INFO", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_get_cache_info,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="CACHE_PURGE", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=local_cache_purge,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="STAT", .type=(enum sd_op_type)2, .force=(_Bool)0,
    .is_admin_op=(_Bool)0, .process_work=((signed int (*)(struct request *))NULL),
    .process_main=local_sd_stat },
    { .name="GET_LOGLEVEL", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=local_get_loglevel,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) },
    { .name="SET_LOGLEVEL", .type=(enum sd_op_type)2, .force=(_Bool)1,
    .is_admin_op=(_Bool)0, .process_work=local_set_loglevel,
    .process_main=((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL) } };
// sd_store
// file store.c line 17
struct store_driver *sd_store;
// semkey
// file logger.c line 118
static signed int semkey;
// sha1_final
// file ../include/sha1.h line 32
void (*sha1_final)(void *, unsigned char *);
// sha1_init
// file ../include/sha1.h line 30
void (*sha1_init)(void *);
// sha1_update
// file ../include/sha1.h line 31
void (*sha1_update)(void *, const unsigned char *, unsigned int);
// sheep_options
// file sheep.c line 117
static struct sd_option sheep_options[18l];
// zone_help
// file sheep.c line 60
static const char zone_help[155l] = { 'E', 'x', 'a', 'm', 'p', 'l', 'e', ':', '\n', '\t', '$', ' ', 's', 'h', 'e', 'e', 'p', ' ', '-', 'z', ' ', '1', ' ', '.', '.', '.', '\n', 'T', 'h', 'i', 's', ' ', 't', 'r', 'i', 'e', 's', ' ', 't', 'o', ' ', 's', 'e', 't', ' ', 't', 'h', 'e', ' ', 'z', 'o', 'n', 'e', ' ', 'I', 'D', ' ', 'o', 'f', ' ', 't', 'h', 'i', 's', ' ', 's', 'h', 'e', 'e', 'p', ' ', 't', 'o', ' ', '1', ' ', 'a', 'n', 'd', ' ', 's', 'h', 'e', 'e', 'p', 'd', 'o', 'g', ' ', 'w', 'o', 'n', '\'', 't', ' ', 's', 't', 'o', 'r', 'e', '\n', 'm', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'o', 'n', 'e', ' ', 'c', 'o', 'p', 'y', ' ', 'o', 'f', ' ', 'a', 'n', 'y', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 'i', 'n', 't', 'o', ' ', 't', 'h', 'i', 's', ' ', 's', 'a', 'm', 'e', ' ', 'z', 'o', 'n', 'e', '\n', 0 };
// sheep_options
// file sheep.c line 117
static struct sd_option sheep_options[18l] = { { .ch=98, .name="bindaddr", .has_arg=(_Bool)1, .desc="specify IP address of interface to listen on",
    .help=bind_help },
    { .ch=99, .name="cluster", .has_arg=(_Bool)1, .desc="specify the cluster driver (default: corosync)",
    .help=cluster_help },
    { .ch=68, .name="directio", .has_arg=(_Bool)0, .desc="use direct IO for backend store",
    .help=((const char *)NULL) },
    { .ch=103, .name="gateway", .has_arg=(_Bool)0, .desc="make the progam run as a gateway mode",
    .help=((const char *)NULL) },
    { .ch=104, .name="help", .has_arg=(_Bool)0, .desc="display this help and exit",
    .help=((const char *)NULL) },
    { .ch=105, .name="ioaddr", .has_arg=(_Bool)1, .desc="use separate network card to handle IO requests (default: disabled)",
    .help=ioaddr_help },
    { .ch=106, .name="journal", .has_arg=(_Bool)1, .desc="use jouranl file to log all the write operations. (default: disabled)",
    .help=journal_help },
    { .ch=108, .name="log", .has_arg=(_Bool)1, .desc="specify the log level, the log directory and the log format(log level default: 6 [SDOG_INFO])",
    .help=log_help },
    { .ch=110, .name="nosync", .has_arg=(_Bool)0, .desc="drop O_SYNC for write of backend",
    .help=((const char *)NULL) },
    { .ch=112, .name="port", .has_arg=(_Bool)1, .desc="specify the TCP port on which to listen (default: 7000)",
    .help=((const char *)NULL) },
    { .ch=80, .name="pidfile", .has_arg=(_Bool)1, .desc="create a pid file",
    .help=((const char *)NULL) },
    { .ch=114, .name="http", .has_arg=(_Bool)1, .desc="enable http service. (default: disabled)",
    .help=http_help },
    { .ch=117, .name="upgrade", .has_arg=(_Bool)0, .desc="upgrade to the latest data layout",
    .help=((const char *)NULL) },
    { .ch=118, .name="version", .has_arg=(_Bool)0, .desc="show the version",
    .help=((const char *)NULL) },
    { .ch=119, .name="cache", .has_arg=(_Bool)1, .desc="enable object cache",
    .help=cache_help },
    { .ch=121, .name="myaddr", .has_arg=(_Bool)1, .desc="specify the address advertised to other sheep",
    .help=myaddr_help },
    { .ch=122, .name="zone", .has_arg=(_Bool)1, .desc="specify the zone id (default: determined by listen address)",
    .help=zone_help },
    { .ch=0, .name=(const char *)(void *)0, .has_arg=(_Bool)0, .desc=(const char *)(void *)0,
    .help=((const char *)NULL) } };
// sheep_pid
// file logger.c line 116
static signed int sheep_pid;
// sigfd
// file sheep.c line 219
static signed int sigfd;
// sockfd_cache
// file sockfd_cache.c line 44
static struct sockfd_cache sockfd_cache = { .root={ .rb_node=(struct rb_node *)(void *)0 }, .lock={ .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } },
    .count=0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// store_drivers
// file store.c line 18
struct list_head store_drivers;
// store_drivers
// file store.c line 18
struct list_head store_drivers = { .n={ .next=&store_drivers.n, .prev=&store_drivers.n } };
// sys
// file sheep.c line 276
struct system_info *sys;
// sys
// file sheep.c line 276
struct system_info *sys = &__sys;
// try_to_free_routine
// file util.c line 32
static void (*try_to_free_routine)(unsigned long int);
// try_to_free_routine
// file util.c line 32
static void (*try_to_free_routine)(unsigned long int) = do_nothing;
// vdi_state_lock
// file vdi.c line 23
static struct sd_rw_lock vdi_state_lock = { .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } };
// vdi_state_root
// file vdi.c line 22
static struct rb_root vdi_state_root = { .rb_node=(struct rb_node *)(void *)0 };
// wait_vdis_cond
// file group.c line 27
static struct sd_cond wait_vdis_cond = { .cond={ .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } } };
// wait_vdis_lock
// file group.c line 26
static struct sd_mutex wait_vdis_lock = { .mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// worker_idx
// file logger.c line 111
static signed int worker_idx;
// worker_name
// file logger.c line 110
static const char *worker_name;
// wq_get_nr_nodes
// file work.c line 71
static unsigned long int (*wq_get_nr_nodes)(void);
// wq_info_list
// file work.c line 69
static struct list_head wq_info_list;
// wq_info_list
// file work.c line 69
static struct list_head wq_info_list = { .n={ .next=&wq_info_list.n, .prev=&wq_info_list.n } };

// INIT_LIST_HEAD
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  list->n.next = &list->n;
  list->n.prev = &list->n;
}

// INIT_LIST_HEAD$link1
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD$link1(struct list_head *list$link1)
{
  list$link1->n.next = &list$link1->n;
  list$link1->n.prev = &list$link1->n;
}

// INIT_LIST_HEAD$link2
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD$link2(struct list_head *list$link2)
{
  list$link2->n.next = &list$link2->n;
  list$link2->n.prev = &list$link2->n;
}

// INIT_LIST_HEAD$link3
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD$link3(struct list_head *list$link3)
{
  list$link3->n.next = &list$link3->n;
  list$link3->n.prev = &list$link3->n;
}

// INIT_LIST_NODE
// file ../include/list.h line 33
static inline void INIT_LIST_NODE(struct list_node *list)
{
  list->next = (struct list_node *)(void *)0;
  list->prev = (struct list_node *)(void *)0;
}

// INIT_RB_ROOT
// file ../include/rbtree.h line 37
static inline void INIT_RB_ROOT(struct rb_root *root)
{
  root->rb_node = (struct rb_node *)(void *)0;
}

// INIT_RB_ROOT$link1
// file ../include/rbtree.h line 37
static inline void INIT_RB_ROOT$link1(struct rb_root *root$link1)
{
  root$link1->rb_node = (struct rb_node *)(void *)0;
}

// INIT_RB_ROOT$link2
// file ../include/rbtree.h line 37
static inline void INIT_RB_ROOT$link2(struct rb_root *root$link2)
{
  root$link2->rb_node = (struct rb_node *)(void *)0;
}

// __hlist_del
// file ../include/list.h line 186
static inline void __hlist_del(struct hlist_node *n)
{
  struct hlist_node *next = n->next;
  struct hlist_node **pprev = n->pprev;
  *pprev = next;
  if(!(next == ((struct hlist_node *)NULL)))
    next->pprev = pprev;

}

// __list_add
// file ../include/list.h line 72
static inline void __list_add(struct list_node *new, struct list_node *prev, struct list_node *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_add$link1
// file ../include/list.h line 72
static inline void __list_add$link1(struct list_node *new$link1, struct list_node *prev$link1, struct list_node *next$link1)
{
  next$link1->prev = new$link1;
  new$link1->next = next$link1;
  new$link1->prev = prev$link1;
  prev$link1->next = new$link1;
}

// __list_add$link2
// file ../include/list.h line 72
static inline void __list_add$link2(struct list_node *new$link2, struct list_node *prev$link2, struct list_node *next$link2)
{
  next$link2->prev = new$link2;
  new$link2->next = next$link2;
  new$link2->prev = prev$link2;
  prev$link2->next = new$link2;
}

// __list_add$link3
// file ../include/list.h line 72
static inline void __list_add$link3(struct list_node *new$link3, struct list_node *prev$link3, struct list_node *next$link3)
{
  next$link3->prev = new$link3;
  new$link3->next = next$link3;
  new$link3->prev = prev$link3;
  prev$link3->next = new$link3;
}

// __list_add$link4
// file ../include/list.h line 72
static inline void __list_add$link4(struct list_node *new$link4, struct list_node *prev$link4, struct list_node *next$link4)
{
  next$link4->prev = new$link4;
  new$link4->next = next$link4;
  new$link4->prev = prev$link4;
  prev$link4->next = new$link4;
}

// __list_del
// file ../include/list.h line 92
static inline void __list_del(struct list_node *prev, struct list_node *next)
{
  next->prev = prev;
  prev->next = next;
}

// __list_del$link1
// file ../include/list.h line 92
static inline void __list_del$link1(struct list_node *prev$link1, struct list_node *next$link1)
{
  next$link1->prev = prev$link1;
  prev$link1->next = next$link1;
}

// __list_del$link2
// file ../include/list.h line 92
static inline void __list_del$link2(struct list_node *prev$link2, struct list_node *next$link2)
{
  next$link2->prev = prev$link2;
  prev$link2->next = next$link2;
}

// __list_del$link3
// file ../include/list.h line 92
static inline void __list_del$link3(struct list_node *prev$link3, struct list_node *next$link3)
{
  next$link3->prev = prev$link3;
  prev$link3->next = next$link3;
}

// __list_del$link4
// file ../include/list.h line 92
static inline void __list_del$link4(struct list_node *prev$link4, struct list_node *next$link4)
{
  next$link4->prev = prev$link4;
  prev$link4->next = next$link4;
}

// __list_del_entry
// file ../include/list.h line 98
static inline void __list_del_entry(struct list_node *entry)
{
  __list_del$link2(entry->prev, entry->next);
}

// __list_del_entry$link1
// file ../include/list.h line 98
static inline void __list_del_entry$link1(struct list_node *entry$link1)
{
  __list_del$link3(entry$link1->prev, entry$link1->next);
}

// __list_splice
// file ../include/list.h line 122
static inline void __list_splice(struct list_head *list, struct list_node *prev, struct list_node *next)
{
  struct list_node *first = list->n.next;
  struct list_node *last = list->n.prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
}

// __list_splice$link1
// file ../include/list.h line 122
static inline void __list_splice$link1(struct list_head *list$link1, struct list_node *prev$link1, struct list_node *next$link1)
{
  struct list_node *first$link1 = list$link1->n.next;
  struct list_node *last$link1 = list$link1->n.prev;
  first$link1->prev = prev$link1;
  prev$link1->next = first$link1;
  last$link1->next = next$link1;
  next$link1->prev = last$link1;
}

// __rb_erase_color
// file rbtree.c line 124
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root)
{
  struct rb_node *other;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$5;
  while((_Bool)1)
  {
    if(!(node == ((struct rb_node *)NULL)))
    {
      if((1ul & node->rb_parent_color) == 0ul)
        goto __CPROVER_DUMP_L42;

    }

    if(node == root->rb_node)
      break;

    if(parent->rb_left == node)
    {
      other = parent->rb_right;
      if((1ul & other->rb_parent_color) == 0ul)
      {
        do
          other->rb_parent_color = other->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_left(parent, root);
        other = parent->rb_right;
      }

      if(other->rb_left == ((struct rb_node *)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        do
          other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = parent;
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      }

      else
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          do
            other->rb_left->rb_parent_color = other->rb_left->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          __rb_rotate_right(other, root);
          other = parent->rb_right;
        }

        rb_set_color(other, (signed int)(parent->rb_parent_color & (unsigned long int)1));
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          other->rb_right->rb_parent_color = other->rb_right->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        __rb_rotate_left(parent, root);
        node = root->rb_node;
        break;
      }
    }

    else
    {
      other = parent->rb_left;
      if((1ul & other->rb_parent_color) == 0ul)
      {
        do
          other->rb_parent_color = other->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_right(parent, root);
        other = parent->rb_left;
      }

      if(other->rb_left == ((struct rb_node *)NULL))
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
      {
        do
          other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = parent;
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      }

      else
      {
        if(other->rb_left == ((struct rb_node *)NULL))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          do
            other->rb_right->rb_parent_color = other->rb_right->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          __rb_rotate_left(other, root);
          other = parent->rb_left;
        }

        rb_set_color(other, (signed int)(parent->rb_parent_color & (unsigned long int)1));
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          other->rb_left->rb_parent_color = other->rb_left->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        __rb_rotate_right(parent, root);
        node = root->rb_node;
        break;
      }
    }
  }

__CPROVER_DUMP_L42:
  ;
  if(!(node == ((struct rb_node *)NULL)))
    do
      node->rb_parent_color = node->rb_parent_color | (unsigned long int)1;
    while((_Bool)0);

}

// __rb_rotate_left
// file rbtree.c line 25
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *right = node->rb_right;
  struct rb_node *parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  node->rb_right = right->rb_left;
  if(!(node->rb_right == ((struct rb_node *)NULL)))
    rb_set_parent$link1(right->rb_left, node);

  right->rb_left = node;
  rb_set_parent$link1(right, parent);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(node == parent->rb_left)
      parent->rb_left = right;

    else
      parent->rb_right = right;
  }

  else
    root->rb_node = right;
  rb_set_parent$link1(node, right);
}

// __rb_rotate_right
// file rbtree.c line 47
static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *left = node->rb_left;
  struct rb_node *parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  node->rb_left = left->rb_right;
  if(!(node->rb_left == ((struct rb_node *)NULL)))
    rb_set_parent$link1(left->rb_right, node);

  left->rb_right = node;
  rb_set_parent$link1(left, parent);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(node == parent->rb_right)
      parent->rb_right = left;

    else
      parent->rb_left = left;
  }

  else
    root->rb_node = left;
  rb_set_parent$link1(node, left);
}

// __sd_dump_variable
// file ../include/logger.h line 53
signed int __sd_dump_variable(const char *var)
{
  char cmd[256l];
  snprintf(cmd, sizeof(char [256l]) /*256ul*/ , "p %s", var);
  signed int return_value_gdb_cmd$1;
  return_value_gdb_cmd$1=gdb_cmd(cmd);
  return return_value_gdb_cmd$1;
}

// __uatomic_add
// file /usr/include/urcu/uatomic.h line 357
static inline void __uatomic_add(void *addr, unsigned long int val, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; addb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "iq"((unsigned char)val) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; addw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned short int)val) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; addl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned int)val) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; addq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "er"((unsigned long int)val) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_add_return
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len)
{
  unsigned char result;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result;
  unsigned int __uatomic_add_return$$1$$1$$3$$result;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result;
  switch(len)
  {
    case 1:
    {
      result = (unsigned char)val;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+q"(result) :  : "memory");
      return (unsigned long int)((signed int)result + (signed int)(unsigned char)val);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result = (unsigned short int)val;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return$$1$$1$$2$$result) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result + (signed int)(unsigned short int)val);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result = (unsigned int)val;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return$$1$$1$$3$$result) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result + (unsigned int)val);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result = val;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return$$1$$1$$4$$result) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result + (unsigned long int)val;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link1
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  unsigned char __uatomic_add_return$$1$$1$$1$$result$link1;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result$link1;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link1;
  unsigned long int result$link1;
  switch(len$link1)
  {
    case 1:
    {
      __uatomic_add_return$$1$$1$$1$$result$link1 = (unsigned char)val$link1;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+q"(__uatomic_add_return$$1$$1$$1$$result$link1) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$1$$result$link1 + (signed int)(unsigned char)val$link1);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result$link1 = (unsigned short int)val$link1;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+r"(__uatomic_add_return$$1$$1$$2$$result$link1) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result$link1 + (signed int)(unsigned short int)val$link1);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link1 = (unsigned int)val$link1;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link1) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link1 + (unsigned int)val$link1);
    }
    case 8:
    {
      result$link1 = val$link1;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link1)), "+r"(result$link1) :  : "memory");
      return result$link1 + (unsigned long int)val$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link2
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  unsigned char __uatomic_add_return$$1$$1$$1$$result$link2;
  unsigned short int result$link2;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link2;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result$link2;
  switch(len$link2)
  {
    case 1:
    {
      __uatomic_add_return$$1$$1$$1$$result$link2 = (unsigned char)val$link2;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+q"(__uatomic_add_return$$1$$1$$1$$result$link2) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$1$$result$link2 + (signed int)(unsigned char)val$link2);
    }
    case 2:
    {
      result$link2 = (unsigned short int)val$link2;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+r"(result$link2) :  : "memory");
      return (unsigned long int)((signed int)result$link2 + (signed int)(unsigned short int)val$link2);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link2 = (unsigned int)val$link2;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link2) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link2 + (unsigned int)val$link2);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result$link2 = val$link2;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link2)), "+r"(__uatomic_add_return$$1$$1$$4$$result$link2) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result$link2 + (unsigned long int)val$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_add_return$link3
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return$link3(void *addr$link3, unsigned long int val$link3, signed int len$link3)
{
  unsigned char result$link3;
  unsigned short int __uatomic_add_return$$1$$1$$2$$result$link3;
  unsigned int __uatomic_add_return$$1$$1$$3$$result$link3;
  unsigned long int __uatomic_add_return$$1$$1$$4$$result$link3;
  switch(len$link3)
  {
    case 1:
    {
      result$link3 = (unsigned char)val$link3;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+q"(result$link3) :  : "memory");
      return (unsigned long int)((signed int)result$link3 + (signed int)(unsigned char)val$link3);
    }
    case 2:
    {
      __uatomic_add_return$$1$$1$$2$$result$link3 = (unsigned short int)val$link3;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+r"(__uatomic_add_return$$1$$1$$2$$result$link3) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return$$1$$1$$2$$result$link3 + (signed int)(unsigned short int)val$link3);
    }
    case 4:
    {
      __uatomic_add_return$$1$$1$$3$$result$link3 = (unsigned int)val$link3;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+r"(__uatomic_add_return$$1$$1$$3$$result$link3) :  : "memory");
      return (unsigned long int)(__uatomic_add_return$$1$$1$$3$$result$link3 + (unsigned int)val$link3);
    }
    case 8:
    {
      __uatomic_add_return$$1$$1$$4$$result$link3 = val$link3;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr$link3)), "+r"(__uatomic_add_return$$1$$1$$4$$result$link3) :  : "memory");
      return __uatomic_add_return$$1$$1$$4$$result$link3 + (unsigned long int)val$link3;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result;
  unsigned long int result;
  switch(len)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result = (unsigned char)old;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "q"((unsigned char)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result = (unsigned short int)old;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned short int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result = (unsigned int)old;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result;
    }
    case 8:
    {
      result = old;
      asm("lock; cmpxchgq %2, %1" : "+a"(result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned long int)_new) : "memory");
      return result;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link1
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link1(void *addr$link1, unsigned long int old$link1, unsigned long int _new$link1, signed int len$link1)
{
  unsigned char result$link1;
  unsigned short int __uatomic_cmpxchg$$1$$1$$2$$result$link1;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link1;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link1;
  switch(len$link1)
  {
    case 1:
    {
      result$link1 = (unsigned char)old$link1;
      asm("lock; cmpxchgb %2, %1" : "+a"(result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "q"((unsigned char)_new$link1) : "memory");
      return (unsigned long int)result$link1;
    }
    case 2:
    {
      __uatomic_cmpxchg$$1$$1$$2$$result$link1 = (unsigned short int)old$link1;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$2$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "r"((unsigned short int)_new$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$2$$result$link1;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link1 = (unsigned int)old$link1;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "r"((unsigned int)_new$link1) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link1;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link1 = old$link1;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link1), "+m"(*((struct __uatomic_dummy *)addr$link1)) : "r"((unsigned long int)_new$link1) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link1;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg$link2
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg$link2(void *addr$link2, unsigned long int old$link2, unsigned long int _new$link2, signed int len$link2)
{
  unsigned char __uatomic_cmpxchg$$1$$1$$1$$result$link2;
  unsigned short int result$link2;
  unsigned int __uatomic_cmpxchg$$1$$1$$3$$result$link2;
  unsigned long int __uatomic_cmpxchg$$1$$1$$4$$result$link2;
  switch(len$link2)
  {
    case 1:
    {
      __uatomic_cmpxchg$$1$$1$$1$$result$link2 = (unsigned char)old$link2;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$1$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "q"((unsigned char)_new$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$1$$result$link2;
    }
    case 2:
    {
      result$link2 = (unsigned short int)old$link2;
      asm("lock; cmpxchgw %2, %1" : "+a"(result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "r"((unsigned short int)_new$link2) : "memory");
      return (unsigned long int)result$link2;
    }
    case 4:
    {
      __uatomic_cmpxchg$$1$$1$$3$$result$link2 = (unsigned int)old$link2;
      asm("lock; cmpxchgl %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$3$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "r"((unsigned int)_new$link2) : "memory");
      return (unsigned long int)__uatomic_cmpxchg$$1$$1$$3$$result$link2;
    }
    case 8:
    {
      __uatomic_cmpxchg$$1$$1$$4$$result$link2 = old$link2;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg$$1$$1$$4$$result$link2), "+m"(*((struct __uatomic_dummy *)addr$link2)) : "r"((unsigned long int)_new$link2) : "memory");
      return __uatomic_cmpxchg$$1$$1$$4$$result$link2;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_dec
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_dec$link1
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec$link1(void *addr$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_dec$link2
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec$link2(void *addr$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_exchange
// file /usr/include/urcu/uatomic.h line 115
static inline unsigned long int __uatomic_exchange(void *addr, unsigned long int val, signed int len)
{
  unsigned char result;
  unsigned short int __uatomic_exchange$$1$$1$$2$$result;
  unsigned int __uatomic_exchange$$1$$1$$3$$result;
  unsigned long int __uatomic_exchange$$1$$1$$4$$result;
  switch(len)
  {
    case 1:
    {
      asm("xchgb %0, %1" : "=q"(result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned char)val) : "memory");
      return (unsigned long int)result;
    }
    case 2:
    {
      asm("xchgw %0, %1" : "=r"(__uatomic_exchange$$1$$1$$2$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned short int)val) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$2$$result;
    }
    case 4:
    {
      asm("xchgl %0, %1" : "=r"(__uatomic_exchange$$1$$1$$3$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned int)val) : "memory");
      return (unsigned long int)__uatomic_exchange$$1$$1$$3$$result;
    }
    case 8:
    {
      asm("xchgq %0, %1" : "=r"(__uatomic_exchange$$1$$1$$4$$result), "+m"(*((struct __uatomic_dummy *)addr)) : "0"((unsigned long int)val) : "memory");
      return __uatomic_exchange$$1$$1$$4$$result;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_inc
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc$link1
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc$link1(void *addr$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc$link2
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc$link2(void *addr$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or
// file /usr/include/urcu/uatomic.h line 301
static inline void __uatomic_or(void *addr, unsigned long int val, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "iq"((unsigned char)val) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned short int)val) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "ir"((unsigned int)val) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr)) : "er"((unsigned long int)val) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or$link1
// file /usr/include/urcu/uatomic.h line 301
static inline void __uatomic_or$link1(void *addr$link1, unsigned long int val$link1, signed int len$link1)
{
  switch(len$link1)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "iq"((unsigned char)val$link1) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned short int)val$link1) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "ir"((unsigned int)val$link1) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link1)) : "er"((unsigned long int)val$link1) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_or$link2
// file /usr/include/urcu/uatomic.h line 301
static inline void __uatomic_or$link2(void *addr$link2, unsigned long int val$link2, signed int len$link2)
{
  switch(len$link2)
  {
    case 1:
    {
      asm("lock; orb %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "iq"((unsigned char)val$link2) : "memory");
      break;
    }
    case 2:
    {
      asm("lock; orw %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned short int)val$link2) : "memory");
      break;
    }
    case 4:
    {
      asm("lock; orl %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "ir"((unsigned int)val$link2) : "memory");
      break;
    }
    case 8:
    {
      asm("lock; orq %1, %0" : "=m"(*((struct __uatomic_dummy *)addr$link2)) : "er"((unsigned long int)val$link2) : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// _addmul1
// file fec.c line 216
static void _addmul1(unsigned char *dst, const unsigned char *src, unsigned char c, unsigned long int sz)
{
  unsigned char *__gf_mulc_;
  const unsigned char *lim = &dst[(signed long int)((sz - (unsigned long int)16) + (unsigned long int)1)];
  __gf_mulc_ = gf_mul_table[(signed long int)c];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = dst[(signed long int)0] ^ __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = dst[(signed long int)1] ^ __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = dst[(signed long int)2] ^ __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = dst[(signed long int)3] ^ __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = dst[(signed long int)4] ^ __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = dst[(signed long int)5] ^ __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = dst[(signed long int)6] ^ __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = dst[(signed long int)7] ^ __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = dst[(signed long int)8] ^ __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = dst[(signed long int)9] ^ __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = dst[(signed long int)10] ^ __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = dst[(signed long int)11] ^ __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = dst[(signed long int)12] ^ __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = dst[(signed long int)13] ^ __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = dst[(signed long int)14] ^ __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = dst[(signed long int)15] ^ __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = *dst ^ __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// _init_mul_table
// file fec.c line 127
static void _init_mul_table(void)
{
  signed int i;
  signed int j;
  i = 0;
  unsigned char return_value_modnn$1;
  for( ; !(i >= 256); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 256); j = j + 1)
    {
      return_value_modnn$1=modnn(gf_log[(signed long int)i] + gf_log[(signed long int)j]);
      gf_mul_table[(signed long int)i][(signed long int)j] = gf_exp[(signed long int)return_value_modnn$1];
    }
  }
  j = 0;
  for( ; !(j >= 256); j = j + 1)
  {
    gf_mul_table[(signed long int)j][(signed long int)0] = (unsigned char)0;
    gf_mul_table[(signed long int)0][(signed long int)j] = gf_mul_table[(signed long int)j][(signed long int)0];
  }
}

// _invert_mat
// file fec.c line 278
static void _invert_mat(unsigned char *src, unsigned int d)
{
  unsigned char c;
  unsigned char *p;
  unsigned int irow = (unsigned int)0;
  unsigned int icol = (unsigned int)0;
  unsigned int row;
  unsigned int col;
  unsigned int i;
  unsigned int ix;
  unsigned int *indxc;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  indxc = (unsigned int *)return_value_xmalloc$1;
  unsigned int *indxr;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  indxr = (unsigned int *)return_value_xmalloc$2;
  unsigned int *ipiv;
  void *return_value_xmalloc$3;
  return_value_xmalloc$3=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  ipiv = (unsigned int *)return_value_xmalloc$3;
  unsigned char *id_row;
  void *return_value_xmalloc$4;
  return_value_xmalloc$4=xmalloc((unsigned long int)((unsigned int)1 * d));
  id_row = (unsigned char *)return_value_xmalloc$4;
  memset((void *)id_row, 0, (unsigned long int)d * sizeof(unsigned char) /*1ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= d); i = i + 1u)
    ipiv[(signed long int)i] = (unsigned int)0;
  col = (unsigned int)0;
  for( ; !(col >= d); col = col + 1u)
  {
    unsigned char *pivot_row;
    if(!(ipiv[(signed long int)col] == 1u))
    {
      if((signed int)src[(signed long int)(col * d + col)] == 0)
        goto __CPROVER_DUMP_L4;

      irow = col;
      icol = col;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      row = (unsigned int)0;
      for( ; !(row >= d); row = row + 1u)
        if(!(ipiv[(signed long int)row] == 1u))
        {
          ix = (unsigned int)0;
          for( ; !(ix >= d); ix = ix + 1u)
            if(ipiv[(signed long int)ix] == 0u)
            {
              if(!((signed int)src[(signed long int)(row * d + ix)] == 0))
              {
                irow = row;
                icol = ix;
                goto found_piv;
              }

            }

        }

    }

  found_piv:
    ;
    ipiv[(signed long int)icol] = ipiv[(signed long int)icol] + 1u;
    if(!(irow == icol))
    {
      ix = (unsigned int)0;
      for( ; !(ix >= d); ix = ix + 1u)
      {
        unsigned char tmp = src[(signed long int)(irow * d + ix)];
        src[(signed long int)(irow * d + ix)] = src[(signed long int)(icol * d + ix)];
        src[(signed long int)(icol * d + ix)] = tmp;
      }
    }

    indxr[(signed long int)col] = irow;
    indxc[(signed long int)col] = icol;
    pivot_row = &src[(signed long int)(icol * d)];
    c = pivot_row[(signed long int)icol];
    if(!((signed int)c == 1))
    {
      c = inverse[(signed long int)c];
      pivot_row[(signed long int)icol] = (unsigned char)1;
      ix = (unsigned int)0;
      for( ; !(ix >= d); ix = ix + 1u)
        pivot_row[(signed long int)ix] = gf_mul_table[(signed long int)c][(signed long int)pivot_row[(signed long int)ix]];
    }

    id_row[(signed long int)icol] = (unsigned char)1;
    signed int return_value_memcmp$5;
    return_value_memcmp$5=memcmp((const void *)pivot_row, (const void *)id_row, (unsigned long int)d * sizeof(unsigned char) /*1ul*/ );
    if(!(return_value_memcmp$5 == 0))
    {
      p = src;
      ix = (unsigned int)0;
      for( ; !(ix >= d); p = p + (signed long int)d)
      {
        if(!(ix == icol))
        {
          c = p[(signed long int)icol];
          p[(signed long int)icol] = (unsigned char)0;
          if(!((signed int)c == 0))
            _addmul1(p, pivot_row, c, (unsigned long int)d);

        }

        ix = ix + 1u;
      }
    }

    id_row[(signed long int)icol] = (unsigned char)0;
  }
  col = d;
  for( ; col >= 1u; col = col - 1u)
    if(!(indxr[(signed long int)(col + 4294967295u)] == indxc[(signed long int)(col + 4294967295u)]))
    {
      row = (unsigned int)0;
      for( ; !(row >= d); row = row + 1u)
      {
        unsigned char _invert_mat$$1$$3$$1$$1$$tmp = src[(signed long int)(row * d + indxr[(signed long int)(col - (unsigned int)1)])];
        src[(signed long int)(row * d + indxr[(signed long int)(col - (unsigned int)1)])] = src[(signed long int)(row * d + indxc[(signed long int)(col - (unsigned int)1)])];
        src[(signed long int)(row * d + indxc[(signed long int)(col - (unsigned int)1)])] = _invert_mat$$1$$3$$1$$1$$tmp;
      }
    }

  free((void *)indxc);
  free((void *)indxr);
  free((void *)ipiv);
  free((void *)id_row);
}

// _invert_vdm
// file fec.c line 386
static void _invert_vdm(unsigned char *src, unsigned int d)
{
  unsigned int i;
  unsigned int j;
  unsigned int row;
  unsigned int col;
  unsigned char *b;
  unsigned char *c;
  unsigned char *p;
  unsigned char t;
  unsigned char xx;
  if(!(d == 1u))
  {
    void *return_value_xmalloc$1;
    return_value_xmalloc$1=xmalloc((unsigned long int)((unsigned int)1 * d));
    c = (unsigned char *)return_value_xmalloc$1;
    void *return_value_xmalloc$2;
    return_value_xmalloc$2=xmalloc((unsigned long int)((unsigned int)1 * d));
    b = (unsigned char *)return_value_xmalloc$2;
    void *return_value_xmalloc$3;
    return_value_xmalloc$3=xmalloc((unsigned long int)((unsigned int)1 * d));
    p = (unsigned char *)return_value_xmalloc$3;
    j = (unsigned int)1;
    i = (unsigned int)0;
    for( ; !(i >= d); j = j + d)
    {
      c[(signed long int)i] = (unsigned char)0;
      p[(signed long int)i] = src[(signed long int)j];
      i = i + 1u;
    }
    c[(signed long int)(d - (unsigned int)1)] = p[(signed long int)0];
    i = (unsigned int)1;
    for( ; !(i >= d); i = i + 1u)
    {
      unsigned char p_i = p[(signed long int)i];
      j = (d - (unsigned int)1) - (i - (unsigned int)1);
      for( ; !(j >= d + 4294967295u); j = j + 1u)
        c[(signed long int)j] = c[(signed long int)j] ^ gf_mul_table[(signed long int)p_i][(signed long int)c[(signed long int)(j + (unsigned int)1)]];
      c[(signed long int)(d - (unsigned int)1)] = c[(signed long int)(d - (unsigned int)1)] ^ p_i;
    }
    row = (unsigned int)0;
    for( ; !(row >= d); row = row + 1u)
    {
      xx = p[(signed long int)row];
      t = (unsigned char)1;
      b[(signed long int)(d - (unsigned int)1)] = (unsigned char)1;
      i = d - (unsigned int)1;
      for( ; i >= 1u; i = i - 1u)
      {
        b[(signed long int)(i - (unsigned int)1)] = (unsigned char)((signed int)c[(signed long int)i] ^ (signed int)gf_mul_table[(signed long int)xx][(signed long int)b[(signed long int)i]]);
        t = (unsigned char)((signed int)gf_mul_table[(signed long int)xx][(signed long int)t] ^ (signed int)b[(signed long int)(i - (unsigned int)1)]);
      }
      col = (unsigned int)0;
      for( ; !(col >= d); col = col + 1u)
        src[(signed long int)(col * d + row)] = gf_mul_table[(signed long int)inverse[(signed long int)t]][(signed long int)b[(signed long int)col]];
    }
    free((void *)c);
    free((void *)b);
    free((void *)p);
    goto __CPROVER_DUMP_L14;
  }


__CPROVER_DUMP_L14:
  ;
}

// _matmul
// file fec.c line 255
static void _matmul(unsigned char *a, unsigned char *b, unsigned char *c, unsigned int dp, unsigned int d, unsigned int m)
{
  unsigned int row;
  unsigned int col;
  unsigned int i;
  row = (unsigned int)0;
  for( ; !(row >= dp); row = row + 1u)
  {
    col = (unsigned int)0;
    for( ; !(col >= m); col = col + 1u)
    {
      unsigned char *pa = &a[(signed long int)(row * d)];
      unsigned char *pb = &b[(signed long int)col];
      unsigned char acc = (unsigned char)0;
      i = (unsigned int)0;
      for( ; !(i >= d); pb = pb + (signed long int)m)
      {
        acc = acc ^ gf_mul_table[(signed long int)*pa][(signed long int)*pb];
        i = i + 1u;
        pa = pa + 1l;
      }
      c[(signed long int)(row * m + col)] = acc;
    }
  }
}

// _pread
// file util.c line 168
static signed long int _pread(signed int fd, void *buf, unsigned long int len, signed long int offset)
{
  signed long int nr;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while((_Bool)1)
  {
    nr=pread(fd, buf, len, offset);
    if(!(nr >= 0l))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 11)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

    }

    return nr;
  }
}

// _pwrite
// file util.c line 179
static signed long int _pwrite(signed int fd, const void *buf, unsigned long int len, signed long int offset)
{
  signed long int nr;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while((_Bool)1)
  {
    nr=pwrite(fd, buf, len, offset);
    if(!(nr >= 0l))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 11)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

    }

    return nr;
  }
}

// _read
// file util.c line 106
static signed long int _read(signed int fd, void *buf, unsigned long int len)
{
  signed long int nr;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while((_Bool)1)
  {
    nr=read(fd, buf, len);
    if(!(nr >= 0l))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 11)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

    }

    return nr;
  }
}

// _write
// file util.c line 117
static signed long int _write(signed int fd, const void *buf, unsigned long int len)
{
  signed long int nr;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while((_Bool)1)
  {
    nr=write(fd, buf, len);
    if(!(nr >= 0l))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 11)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

    }

    return nr;
  }
}

// add_timer
// file event.c line 39
void add_timer(struct timer *t, unsigned int mseconds)
{
  struct itimerspec it;
  signed int tfd;
  tfd=timerfd_create(1, 2048);
  if(!(tfd >= 0))
    log_write(3, "add_timer", 46, "timerfd_create: %m");

  else
  {
    memset((void *)&it, 0, sizeof(struct itimerspec) /*32ul*/ );
    it.it_value.tv_sec = (signed long int)(mseconds / (unsigned int)1000);
    it.it_value.tv_nsec = (signed long int)((mseconds % (unsigned int)1000) * (unsigned int)1000000);
    signed int return_value_timerfd_settime$1;
    return_value_timerfd_settime$1=timerfd_settime(tfd, 0, &it, (struct itimerspec *)(void *)0);
    if(!(return_value_timerfd_settime$1 >= 0))
      log_write(3, "add_timer", 55, "timerfd_settime: %m");

    else
    {
      signed int return_value_register_event$2;
      return_value_register_event$2=register_event$link2(tfd, timer_handler, (void *)t);
      if(!(return_value_register_event$2 >= 0))
        log_write(3, "add_timer", 60, "failed to register timer fd");

    }
  }
}

// add_to_dirty_list
// file object_cache.c line 259
static void add_to_dirty_list(struct object_cache_entry *entry)
{
  struct object_cache *oc = entry->oc;
  list_add_tail$link2(&entry->dirty_list, &oc->dirty_head);
  unsigned long int return_value___uatomic_add_return$1;
  return_value___uatomic_add_return$1=__uatomic_add_return$link2((void *)&oc->dirty_count, (unsigned long int)1, (signed int)sizeof(unsigned int) /*4ul*/ );
  if((unsigned int)return_value___uatomic_add_return$1 >= 11u)
  {
    if((signed int)sys->cinfo.status == SD_STATUS_OK)
      kick_background_pusher(oc);

  }

}

// add_to_lru_cache
// file object_cache.c line 685
static void add_to_lru_cache(struct object_cache *oc, unsigned long int idx, _Bool create)
{
  struct object_cache_entry *entry;
  entry=alloc_cache_entry(oc, idx);
  unsigned long int return_value_idx_to_oid$1;
  if(sd_log_level == 7)
  {
    return_value_idx_to_oid$1=idx_to_oid(oc->vid, idx);
    log_write(7, "add_to_lru_cache", 689, "oid %lx added", return_value_idx_to_oid$1);
  }

  write_lock_cache(oc);
  struct object_cache_entry *return_value_lru_tree_insert$2;
  return_value_lru_tree_insert$2=lru_tree_insert(&oc->lru_tree, entry);
  if(!(return_value_lru_tree_insert$2 == ((struct object_cache_entry *)NULL)))
  {
    log_write(0, "add_to_lru_cache", 693, "PANIC: the object already exist");
    abort();
  }

  __uatomic_add((void *)&gcache.capacity, (unsigned long int)(((1UL << 22) / (unsigned long int)1024) / (unsigned long int)1024), (signed int)sizeof(unsigned int) /*4ul*/ );
  list_add_tail$link2(&entry->lru_list, &oc->lru_head);
  oc->total_count = oc->total_count + 1u;
  if(!(create == (_Bool)0))
  {
    entry->bmap = 18446744073709551615UL;
    entry->idx = entry->idx | 1UL << 59;
    add_to_dirty_list(entry);
  }

  unlock_cache(oc);
}

// add_vdi_state
// file sheep_priv.h line 304
signed int add_vdi_state(unsigned int vid, signed int nr_copies, _Bool snapshot, unsigned char cp)
{
  struct vdi_state_entry *entry;
  struct vdi_state_entry *old;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct vdi_state_entry) /*40ul*/ );
  entry = (struct vdi_state_entry *)return_value_xzalloc$1;
  entry->vid = vid;
  entry->nr_copies = (unsigned int)nr_copies;
  entry->snapshot = snapshot;
  entry->copy_policy = cp;
  signed int tmp_statement_expression$2;
  if(!(cp == 0))
  {
    signed int d;
    ec_policy_to_dp$link1(cp, &d, (signed int *)(void *)0);
    signed int _x = d;
    signed int _y = ec_max_data_strip;
    (void)(&_x == &_y);
    tmp_statement_expression$2 = _x > _y ? _x : _y;
    ec_max_data_strip = tmp_statement_expression$2;
  }

  if(sd_log_level == 7)
    log_write(7, "add_vdi_state", 158, "%x, %d, %d", vid, nr_copies, cp);

  sd_write_lock(&vdi_state_lock);
  old=vdi_state_insert(&vdi_state_root, entry);
  if(!(old == ((struct vdi_state_entry *)NULL)))
  {
    free((void *)entry);
    entry = old;
    entry->nr_copies = (unsigned int)nr_copies;
    entry->snapshot = snapshot;
    entry->copy_policy = cp;
  }

  sd_rw_unlock(&vdi_state_lock);
  return 0x00;
}

// addr_to_str
// file ../include/net.h line 56
const char * addr_to_str(const unsigned char *addr, unsigned short int port)
{
  signed int af = 10;
  signed int addr_start_idx = 0;
  const char *ret;
  signed int tmp_post$1;
  if(!(addr[12l] == 0))
  {
    signed int oct_no = 0;
    while(addr[(signed long int)oct_no] == 0)
    {
      tmp_post$1 = oct_no;
      oct_no = oct_no + 1;
      if(tmp_post$1 >= 12)
        break;

    }
    if(oct_no == 12)
    {
      af = 2;
      addr_start_idx = 12;
    }

  }

  static char str[72l];
  ret=inet_ntop(af, (const void *)(addr + (signed long int)addr_start_idx), str, (unsigned int)sizeof(char [72l]) /*72ul*/ );
  if(ret == ((const char *)NULL))
  {
    log_write(0, "addr_to_str", 384, "PANIC: failed to convert addr to string, %m");
    abort();
  }

  if(!(port == 0))
  {
    signed int len;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    len = (signed int)return_value_strlen$2;
    snprintf(str + (signed long int)len, sizeof(char [72l]) /*72ul*/  - (unsigned long int)len, ":%d", port);
  }

  return str;
}

// after
// file ../include/util.h line 52
static inline signed int after(unsigned int seq1, unsigned int seq2)
{
  return (signed int)((signed int)(seq2 - seq1) < 0);
}

// alloc_cache_entry
// file object_cache.c line 671
static inline struct object_cache_entry * alloc_cache_entry(struct object_cache *oc, unsigned long int idx)
{
  struct object_cache_entry *entry;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct object_cache_entry) /*144ul*/ );
  entry = (struct object_cache_entry *)return_value_xzalloc$1;
  entry->oc = oc;
  entry->idx = idx;
  sd_init_rw_lock(&entry->lock);
  INIT_LIST_NODE(&entry->dirty_list);
  INIT_LIST_NODE(&entry->lru_list);
  return entry;
}

// alloc_inode
// file vdi.c line 225
static struct sd_inode * alloc_inode(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int *data_vdi_id)
{
  struct sd_inode *new;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  new = (struct sd_inode *)return_value_xzalloc$1;
  unsigned long int block_size = 1UL << 22;
  pstrcpy(new->name, (signed int)sizeof(char [256l]) /*256ul*/ , iocb->name);
  new->vdi_id = new_vid;
  new->create_time = iocb->time;
  new->vdi_size = iocb->size;
  new->copy_policy = iocb->copy_policy;
  new->store_policy = iocb->store_policy;
  new->nr_copies = iocb->nr_copies;
  unsigned long int return_value_find_next_bit$2;
  return_value_find_next_bit$2=find_next_bit(&block_size, (unsigned long int)8 * sizeof(signed long int) /*8ul*/ , (unsigned long int)0);
  new->block_size_shift = (unsigned char)return_value_find_next_bit$2;
  new->snap_id = new_snapid;
  new->parent_vdi_id = iocb->base_vid;
  if(!(data_vdi_id == ((unsigned int *)NULL)))
    sd_inode_copy_vdis(sheep_bnode_writer, sheep_bnode_reader, data_vdi_id, iocb->store_policy, iocb->nr_copies, iocb->copy_policy, new);

  else
    if(!(new->store_policy == 0))
      sd_inode_init((void *)new->data_vdi_id, 1);

  return new;
}

// alloc_local_request
// file request.c line 512
static struct request * alloc_local_request(void *data, signed int data_length)
{
  struct request *req;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct request) /*232ul*/ );
  req = (struct request *)return_value_xzalloc$1;
  if(!(data_length == 0))
  {
    req->data_length = (unsigned int)data_length;
    req->data = data;
  }

  req->local = (_Bool)1;
  refcount_set$link1(&req->refcnt, 1);
  return req;
}

// alloc_old_vnode_info
// file group.c line 558
static struct vnode_info * alloc_old_vnode_info(void)
{
  struct rb_root old_root = { .rb_node=(struct rb_node *)(void *)0 };
  struct vnode_info *old;
  signed int i = 0;
  struct sd_node *tmp_statement_expression$2;
  struct sd_node *tmp_statement_expression$3;
  for( ; !(i >= (signed int)sys->cinfo.nr_nodes); i = i + 1)
  {
    struct sd_node *new;
    void *return_value_xmalloc$1;
    return_value_xmalloc$1=xmalloc(sizeof(struct sd_node) /*80ul*/ );
    new = (struct sd_node *)return_value_xmalloc$1;
    *new = sys->cinfo.nodes[(signed long int)i];
    struct rb_node **__n = &(&old_root)->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct sd_node *__old = (struct sd_node *)(void *)0;
    struct sd_node *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr = *__n;
      tmp_statement_expression$3 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      __data = tmp_statement_expression$3;
      signed int __cmp;
      __cmp=node_cmp(new, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct sd_node *)NULL))
    {
      rb_link_node(&new->rb, __parent, __n);
      rb_insert_color(&new->rb, &old_root);
    }

    tmp_statement_expression$2 = __old;
    if(!(tmp_statement_expression$2 == ((struct sd_node *)NULL)))
    {
      log_write(0, "alloc_old_vnode_info", 574, "PANIC: node hash collision");
      abort();
    }

  }
  old=alloc_vnode_info(&old_root);
  struct sd_node *__dummy;
  struct rb_node *__p578;
  __p578=rb_first(&old_root);
  struct rb_node *__n578;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  struct sd_node *tmp_statement_expression$5;
  do
  {
    if(!(__p578 == ((struct rb_node *)NULL)))
    {
      __n578=rb_next(__p578);
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      const struct rb_node *alloc_old_vnode_info$$1$$2$$1$$1$$__mptr = __p578;
      tmp_statement_expression$5 = (struct sd_node *)((char *)alloc_old_vnode_info$$1$$2$$1$$1$$__mptr - (signed long int)0ul);
      __dummy = tmp_statement_expression$5;
      tmp_if_expr$6 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(!tmp_if_expr$6)
      break;

    rb_erase(&__dummy->rb, &old_root);
    free((void *)__dummy);
    __p578 = __n578;
  }
  while((_Bool)1);
  return old;
}

// alloc_request
// file request.c line 651
static struct request * alloc_request(struct client_info *ci, signed int data_length)
{
  struct request *req;
  void *return_value_zalloc$1;
  return_value_zalloc$1=zalloc(sizeof(struct request) /*232ul*/ );
  req = (struct request *)return_value_zalloc$1;
  if(req == ((struct request *)NULL))
    return (struct request *)(void *)0;

  else
  {
    req->ci = ci;
    refcount_inc$link1(&ci->refcnt);
    if(!(data_length == 0))
    {
      req->data_length = (unsigned int)data_length;
      req->data=valloc((unsigned long int)data_length);
      if(!(req->data == NULL))
        goto __CPROVER_DUMP_L2;

      free((void *)req);
      return (struct request *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      refcount_set$link1(&req->refcnt, 1);
      __uatomic_inc$link1((void *)&sys->nr_outstanding_reqs, (signed int)sizeof(signed int) /*4ul*/ );
      return req;
    }
  }
}

// alloc_vnode_info
// file group.c line 130
struct vnode_info * alloc_vnode_info(struct rb_root *nroot)
{
  struct vnode_info *vnode_info;
  struct sd_node *n;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct vnode_info) /*32ul*/ );
  vnode_info = (struct vnode_info *)return_value_xzalloc$1;
  INIT_RB_ROOT(&vnode_info->vroot);
  INIT_RB_ROOT(&vnode_info->nroot);
  struct rb_node *__p139;
  __p139=rb_first(nroot);
  struct rb_node *__n139;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct sd_node *tmp_statement_expression$3;
  struct sd_node *tmp_statement_expression$6;
  struct sd_node *tmp_statement_expression$7;
  do
  {
    if(!(__p139 == ((struct rb_node *)NULL)))
    {
      __n139=rb_next(__p139);
      tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      const struct rb_node *__mptr = __p139;
      tmp_statement_expression$3 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$3;
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    struct sd_node *new;
    void *return_value_xmalloc$5;
    return_value_xmalloc$5=xmalloc(sizeof(struct sd_node) /*80ul*/ );
    new = (struct sd_node *)return_value_xmalloc$5;
    *new = *n;
    struct rb_node **__n = &(&vnode_info->nroot)->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct sd_node *__old = (struct sd_node *)(void *)0;
    struct sd_node *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *alloc_vnode_info$$1$$1$$2$$1$$1$$1$$__mptr = *__n;
      tmp_statement_expression$7 = (struct sd_node *)((char *)alloc_vnode_info$$1$$1$$2$$1$$1$$1$$__mptr - (signed long int)0ul);
      __data = tmp_statement_expression$7;
      signed int __cmp;
      __cmp=node_cmp(new, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct sd_node *)NULL))
    {
      rb_link_node(&new->rb, __parent, __n);
      rb_insert_color(&new->rb, &vnode_info->nroot);
    }

    tmp_statement_expression$6 = __old;
    if(!(tmp_statement_expression$6 == ((struct sd_node *)NULL)))
    {
      log_write(0, "alloc_vnode_info", 143, "PANIC: node hash collision");
      abort();
    }

    vnode_info->nr_nodes = vnode_info->nr_nodes + 1;
    __p139 = __n139;
  }
  while((_Bool)1);
  recalculate_vnodes(&vnode_info->nroot);
  nodes_to_vnodes(&vnode_info->nroot, &vnode_info->vroot);
  vnode_info->nr_zones=get_zones_nr_from(&vnode_info->nroot);
  refcount_set(&vnode_info->refcnt, 1);
  return vnode_info;
}

// atomic_create_and_write
// file ../include/util.h line 122
signed int atomic_create_and_write(const char *path, const char *buf, unsigned long int len, _Bool force_create)
{
  signed int fd;
  signed int ret;
  char tmp_path[4096l];
  snprintf(tmp_path, (unsigned long int)4096, "%s.tmp", path);
  signed int *return_value___errno_location$1;
  do
  {

  again:
    ;
    fd=open(tmp_path, 01 | 0100 | 04010000 | 0200, sd_def_fmode);
    if(fd >= 0)
      goto __CPROVER_DUMP_L7;

    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 17))
      goto __CPROVER_DUMP_L5;

    if(force_create == (_Bool)0)
      break;

    if(sd_log_level == 7)
      log_write(7, "atomic_create_and_write", 580, "clean up a temporary file %s", (const void *)tmp_path);

    unlink(tmp_path);
  }
  while((_Bool)1);
  if(sd_log_level == 7)
    log_write(7, "atomic_create_and_write", 585, "someone else is dealing with %s", (const void *)tmp_path);

  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L5:
  ;
  log_write(3, "atomic_create_and_write", 587, "failed to open temporal file %s, %m", (const void *)tmp_path);

__CPROVER_DUMP_L6:
  ;
  ret = -1;
  goto end;

__CPROVER_DUMP_L7:
  ;
  signed long int return_value_xwrite$2;
  return_value_xwrite$2=xwrite(fd, (const void *)buf, len);
  ret = (signed int)return_value_xwrite$2;
  if(!((unsigned long int)ret == len))
  {
    log_write(3, "atomic_create_and_write", 594, "failed to write %s, %m", path);
    ret = -1;
  }

  else
  {
    ret=rename(tmp_path, path);
    if(!(ret >= 0))
    {
      log_write(3, "atomic_create_and_write", 601, "failed to rename %s, %m", path);
      ret = -1;
    }

  }

close_fd:
  ;
  close(fd);

end:
  ;
  return ret;
}

// atomic_set_bit
// file ../include/bitops.h line 144
static inline void atomic_set_bit(signed int nr, unsigned long int *addr)
{
  __uatomic_or((void *)(addr + (signed long int)((unsigned long int)nr / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ))), (unsigned long int)(1UL << (unsigned long int)nr % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ )), (signed int)sizeof(unsigned long int) /*8ul*/ );
}

// atomic_set_bit$link1
// file ../include/bitops.h line 144
static inline void atomic_set_bit$link1(signed int nr$link1, unsigned long int *addr$link1)
{
  __uatomic_or$link1((void *)(addr$link1 + (signed long int)((unsigned long int)nr$link1 / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ))), (unsigned long int)(1UL << (unsigned long int)nr$link1 % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ )), (signed int)sizeof(unsigned long int) /*8ul*/ );
}

// atomic_set_bit$link2
// file ../include/bitops.h line 144
static inline void atomic_set_bit$link2(signed int nr$link2, unsigned long int *addr$link2)
{
  __uatomic_or$link2((void *)(addr$link2 + (signed long int)((unsigned long int)nr$link2 / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ))), (unsigned long int)(1UL << (unsigned long int)nr$link2 % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ )), (signed int)sizeof(unsigned long int) /*8ul*/ );
}

// background_push_done
// file object_cache.c line 234
static void background_push_done(struct work *work)
{
  struct push_work *pw;
  struct push_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct push_work *)((char *)__mptr - (signed long int)0ul);
  pw = tmp_statement_expression$1;
  free((void *)pw);
}

// backup_epoch
// file migrate.c line 166
static signed int backup_epoch(unsigned int epoch)
{
  char path[4096l];
  char suffix[256l];
  struct timeval tv;
  struct tm tm;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  localtime_r(&tv.tv_sec, &tm);
  strftime(suffix, sizeof(char [256l]) /*256ul*/ , "%Y-%m-%d_%H%M%S", &tm);
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s%08u", epoch_path, epoch);
  signed int return_value_backup_file$1;
  return_value_backup_file$1=backup_file(path, suffix);
  return return_value_backup_file$1;
}

// backup_file
// file migrate.c line 114
static signed int backup_file(char *fname, char *suffix)
{
  char dst_file[4096l];
  signed int fd = -1;
  signed int ret = -1;
  signed int len;
  void *buf = (void *)0;
  snprintf(dst_file, sizeof(char [4096l]) /*4096ul*/ , "%s.%s", fname, suffix);
  fd=open(fname, 00);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
    {
      log_write(3, "backup_file", 125, "failed to open %s, %m", fname);
      ret = -1;
    }

    else
      ret = 0;
    goto out;
  }

  unsigned long int return_value_get_file_size$2;
  return_value_get_file_size$2=get_file_size(fname);
  len = (signed int)return_value_get_file_size$2;
  signed long int return_value_xread$3;
  signed long int return_value_xwrite$4;
  if(len >= 0)
  {
    buf=xmalloc((unsigned long int)len);
    return_value_xread$3=xread(fd, buf, (unsigned long int)len);
    ret = (signed int)return_value_xread$3;
    if(!(ret == len))
    {
      log_write(3, "backup_file", 139, "failed to read %s, %d %m", fname, ret);
      ret = -1;
    }

    else
    {
      close(fd);
      fd=open(dst_file, 0100 | 01 | 010000, 0644);
      if(!(fd >= 0))
      {
        log_write(3, "backup_file", 148, "failed to create %s, %m", (const void *)dst_file);
        ret = -1;
      }

      else
      {
        return_value_xwrite$4=xwrite(fd, buf, (unsigned long int)len);
        ret = (signed int)return_value_xwrite$4;
        if(!(ret == len))
        {
          log_write(3, "backup_file", 155, "failed to write to %s, %d %m", (const void *)dst_file, ret);
          ret = -1;
        }

      }
    }
  }


out:
  ;
  if(fd >= 0)
    close(fd);

  free(buf);
  return ret;
}

// backup_store
// file migrate.c line 183
static signed int backup_store(void)
{
  char suffix[256l];
  struct timeval tv;
  struct tm tm;
  signed int ret;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  localtime_r(&tv.tv_sec, &tm);
  strftime(suffix, sizeof(char [256l]) /*256ul*/ , "%Y-%m-%d_%H%M%S", &tm);
  ret=backup_file(config_path, suffix);
  if(!(ret >= 0))
    return ret;

  else
  {
    for_each_epoch(backup_epoch);
    return 0;
  }
}

// before
// file ../include/util.h line 47
static inline signed int before(unsigned int seq1, unsigned int seq2)
{
  return (signed int)((signed int)(seq1 - seq2) < 0);
}

// binary_search
// file sd_inode.c line 222
static void * binary_search(void *first, void *last, void *key, unsigned long int obj_size, signed int (*cmp)(void *, void *))
{
  const char *l;
  const char *r;
  const char *m;
  signed int ret;
  l = (const char *)first;
  r = (const char *)last - (signed long int)obj_size;
  if(r >= l)
  {
    m = l + (signed long int)((((unsigned long int)(r - l) / obj_size) / (unsigned long int)2) * obj_size);
    ret=cmp((void *)key, (void *)m);
    if(!(ret >= 0))
      r = m - (signed long int)obj_size;

    else
      if(ret >= 1)
        l = m + (signed long int)obj_size;

      else
        return (void *)m;
  }

  return (void *)l;
}

// block_sighup
// file logger.c line 130
static void block_sighup(void)
{
  signed int ret;
  struct anonymous$1 new;
  struct anonymous$1 old;
  sigemptyset(&new);
  sigemptyset(&old);
  sigaddset(&new, 1);
  ret=sigprocmask(0, &new, &old);
  if(!(ret >= 0))
    syslog(3, "blocking SIGHUP failed\n");

}

// bnode_create
// file http/kv.c line 276
static signed int bnode_create(struct kv_bnode *bnode, unsigned int account_vid)
{
  struct sd_inode *inode;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$1;
  unsigned int tmp_vid;
  unsigned int idx;
  unsigned long int hval;
  unsigned long int i;
  signed int ret;
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid$link3(account_vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$3;
    return_value_sd_strerror$3=sd_strerror$link8(ret);
    log_write(3, "bnode_create", 287, "failed to read %x %s", account_vid, return_value_sd_strerror$3);
    goto out;
  }

  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(bnode->name);
  hval=sd_hash$link2((const void *)bnode->name, return_value_strlen$4);
  i = (unsigned long int)0;
  for( ; !(i >= 4294967296ull); i = i + 1ul)
  {
    idx = (unsigned int)((hval + i) % (1ULL << 32));
    tmp_vid=sd_inode_get_vid(sheep_bnode_reader, inode, idx);
    if(!(tmp_vid == 0u))
      goto __CPROVER_DUMP_L4;

    else
      break;

  __CPROVER_DUMP_L4:
    ;
  }
  if(i == 4294967296ull)
    ret = 0x15;

  else
    ret=bnode_do_create(bnode, inode, idx);

out:
  ;
  free((void *)inode);
  return ret;
}

// bnode_do_create
// file http/kv.c line 251
static signed int bnode_do_create(struct kv_bnode *bnode, struct sd_inode *inode, unsigned int idx)
{
  unsigned int vid = inode->vdi_id;
  unsigned long int oid;
  oid=vid_to_data_oid$link2(vid, (unsigned long int)idx);
  signed int ret;
  bnode->oid = oid;
  ret=sd_write_object(oid, (char *)bnode, (unsigned int)sizeof(struct kv_bnode) /*280ul*/ , (unsigned long int)0, (_Bool)1);
  if(!(ret == 0x00))
    log_write(3, "bnode_do_create", 261, "failed to create object, %lx", oid);

  else
  {
    sd_inode_set_vid(sheep_bnode_writer, sheep_bnode_reader, inode, idx, vid);
    ret=sd_inode_write_vid(sheep_bnode_writer, inode, idx, vid, vid, 0, (_Bool)0, (_Bool)0);
    if(!(ret == 0x00))
    {
      unsigned long int return_value_vid_to_vdi_oid$1;
      return_value_vid_to_vdi_oid$1=vid_to_vdi_oid$link3(vid);
      log_write(3, "bnode_do_create", 269, "failed to update inode, %lx", return_value_vid_to_vdi_oid$1);
      goto out;
    }

  }

out:
  ;
  return ret;
}

// bnode_lookup
// file http/kv.c line 353
static signed int bnode_lookup(struct kv_bnode *bnode, unsigned int vid, const char *name)
{
  unsigned long int hval;
  unsigned long int i;
  signed int ret;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  hval=sd_hash$link2((const void *)name, return_value_strlen$1);
  i = (unsigned long int)0;
  for( ; !(i >= 4294967296ull); i = i + 1ul)
  {
    unsigned int idx = (unsigned int)((hval + i) % (1ULL << 32));
    unsigned long int oid;
    oid=vid_to_data_oid$link2(vid, (unsigned long int)idx);
    ret=sd_read_object(oid, (char *)bnode, (unsigned int)sizeof(struct kv_bnode) /*280ul*/ , (unsigned long int)0);
    if(!(ret == 0x00))
      goto out;

    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(bnode->name, name);
    if(return_value_strcmp$2 == 0)
      break;

  }
  if(i == 4294967296ull)
    ret = 0x02;


out:
  ;
  return ret;
}

// bnode_update
// file http/kv.c line 391
static signed int bnode_update(const char *account, const char *bucket, unsigned long int used, _Bool create)
{
  unsigned int account_vid;
  struct kv_bnode bnode;
  signed int ret;
  ret=sd_lookup_vdi(account, &account_vid);
  if(!(ret == 0x00))
  {
    log_write(3, "bnode_update", 400, "Failed to find account %s", account);
    return ret;
  }

  else
  {
    ret=bnode_lookup(&bnode, account_vid, bucket);
    if(!(ret == 0x00))
      return ret;

    else
    {
      if(!(create == (_Bool)0))
      {
        bnode.object_count = bnode.object_count + 1ul;
        bnode.bytes_used = bnode.bytes_used + used;
      }

      else
      {
        bnode.object_count = bnode.object_count - 1ul;
        bnode.bytes_used = bnode.bytes_used - used;
      }
      ret=sd_write_object(bnode.oid, (char *)&bnode, (unsigned int)sizeof(struct kv_bnode) /*280ul*/ , (unsigned long int)0, (_Bool)0);
      if(!(ret == 0x00))
      {
        log_write(3, "bnode_update", 418, "failed to update bnode for %s", bucket);
        return ret;
      }

      else
        return 0x00;
    }
  }
}

// bucket_create
// file http/kv.c line 310
static signed int bucket_create(const char *account, unsigned int account_vid, const char *bucket)
{
  char onode_name[256l];
  char alloc_name[256l];
  struct kv_bnode bnode;
  unsigned int vid;
  signed int ret;
  snprintf(onode_name, (unsigned long int)256U, "%s/%s", account, bucket);
  ret=kv_create_hyper_volume(onode_name, &vid);
  if(!(ret == 0x00))
  {
    log_write(3, "bucket_create", 322, "Failed to create bucket %s onode vid", bucket);
    return ret;
  }

  else
  {
    snprintf(alloc_name, (unsigned long int)256U, "%s/%s/allocator", account, bucket);
    ret=kv_create_hyper_volume(alloc_name, &vid);
    if(!(ret == 0x00))
    {
      log_write(3, "bucket_create", 329, "Failed to create bucket %s data vid", bucket);
      sd_delete_vdi(onode_name);
      return ret;
    }

    else
    {
      ret=oalloc_init(vid);
      if(!(ret == 0x00))
        log_write(3, "bucket_create", 335, "Failed to init allocator for bucket %s", bucket);

      else
      {
        pstrcpy(bnode.name, (signed int)sizeof(char [256l]) /*256ul*/ , bucket);
        bnode.bytes_used = (unsigned long int)0;
        bnode.object_count = (unsigned long int)0;
        ret=bnode_create(&bnode, account_vid);
        if(ret == 0x00)
          return 0x00;

      }

    err:
      ;
      sd_delete_vdi(onode_name);
      sd_delete_vdi(alloc_name);
      return ret;
    }
  }
}

// bucket_delete
// file http/kv.c line 424
static signed int bucket_delete(const char *account, unsigned int avid, const char *bucket)
{
  struct kv_bnode bnode;
  char onode_name[256l];
  char alloc_name[256l];
  signed int ret;
  snprintf(onode_name, (unsigned long int)256U, "%s/%s", account, bucket);
  snprintf(alloc_name, (unsigned long int)256U, "%s/%s/allocator", account, bucket);
  ret=bnode_lookup(&bnode, avid, bucket);
  if(!(ret == 0x00))
    return ret;

  else
    if(bnode.object_count >= 1ul)
      return 0x92;

    else
    {
      ret=sd_discard_object(bnode.oid);
      if(!(ret == 0x00))
      {
        log_write(3, "bucket_delete", 444, "failed to discard bnode for %s", bucket);
        return ret;
      }

      else
      {
        sd_delete_vdi(onode_name);
        sd_delete_vdi(alloc_name);
        return 0x00;
      }
    }
}

// bucket_iterate_object
// file http/kv.c line 492
static signed int bucket_iterate_object(unsigned int bucket_vid, void (*cb)(const char *, void *), void *opaque)
{
  struct object_iterater_arg arg = { .opaque=opaque, .cb=cb, .count=(unsigned int)0 };
  struct sd_inode *inode;
  signed int ret;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$1;
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid$link3(bucket_vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$3;
    return_value_sd_strerror$3=sd_strerror$link8(ret);
    log_write(3, "bucket_iterate_object", 503, "failed to read inode %s", return_value_sd_strerror$3);
    goto out;
  }

  traverse_btree(sheep_bnode_reader, inode, object_iterater, (void *)&arg);

out:
  ;
  free((void *)inode);
  return ret;
}

// bucket_iterater
// file http/kv.c line 120
static void bucket_iterater(void *data, enum btree_node_type type, void *arg)
{
  struct sd_extent *ext;
  struct bucket_iterater_arg *biarg = (struct bucket_iterater_arg *)arg;
  struct kv_bnode bnode;
  unsigned long int oid;
  signed int ret;
  if((signed int)type == BTREE_EXT)
  {
    ext = (struct sd_extent *)data;
    if(ext->vdi_id == 0u)
      goto __CPROVER_DUMP_L6;

    oid=vid_to_data_oid$link2(ext->vdi_id, (unsigned long int)ext->idx);
    ret=sd_read_object(oid, (char *)&bnode, (unsigned int)sizeof(struct kv_bnode) /*280ul*/ , (unsigned long int)0);
    if(!(ret == 0x00))
    {
      log_write(3, "bucket_iterater", 136, "Failed to read data object %lx", oid);
      goto __CPROVER_DUMP_L6;
    }

    if((signed int)bnode.name[0l] == 0)
      goto __CPROVER_DUMP_L6;

    if(!(biarg->cb == ((void (*)(const char *, void *))NULL)))
      biarg->cb(bnode.name, biarg->opaque);

    biarg->bucket_count = biarg->bucket_count + 1ul;
    biarg->object_count = biarg->object_count + bnode.object_count;
    biarg->bytes_used = biarg->bytes_used + bnode.bytes_used;
  }


__CPROVER_DUMP_L6:
  ;
}

// build_decode_matrix_into_space
// file fec.c line 538
static void build_decode_matrix_into_space(struct fec * const code, const signed int * const idx, const unsigned int d, unsigned char * const matrix)
{
  unsigned char i;
  unsigned char *p;
  i = (unsigned char)0;
  p = matrix;
  for( ; !((unsigned int)i >= d); p = p + (signed long int)d)
  {
    if(!((unsigned int)idx[(signed long int)i] >= d))
    {
      memset((void *)p, 0, (unsigned long int)d);
      p[(signed long int)i] = (unsigned char)1;
    }

    else
      memcpy((void *)p, (const void *)&code->enc_matrix[(signed long int)(idx[(signed long int)i] * (signed int)code->d)], (unsigned long int)d);
    i = i + 1;
  }
  _invert_mat(matrix, d);
}

// build_long_options
// file ../include/option.h line 31
struct option * build_long_options(struct sd_option *sd_opts)
{
  struct sd_option *opt;
  static struct option lopts[256l];
  static struct option *p;
  p = lopts;
  opt = sd_opts;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
  {
    p->name = opt->name;
    p->has_arg = (signed int)opt->has_arg;
    p->flag = (signed int *)(void *)0;
    p->val = opt->ch;
    p = p + 1l;
  }
  memset((void *)p, 0, sizeof(struct option) /*32ul*/ );
  return lopts;
}

// build_short_options
// file ../include/option.h line 30
char * build_short_options(struct sd_option *sd_opts)
{
  struct sd_option *opt;
  static char sopts[256l];
  static char *p;
  p = sopts;
  opt = sd_opts;
  char *tmp_post$1;
  char *tmp_post$2;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
  {
    tmp_post$1 = p;
    p = p + 1l;
    *tmp_post$1 = (char)opt->ch;
    if(!(opt->has_arg == (_Bool)0))
    {
      tmp_post$2 = p;
      p = p + 1l;
      *tmp_post$2 = (char)58;
    }

  }
  *p = (char)0;
  return sopts;
}

// bypass_object_cache
// file sheep_priv.h line 449
_Bool bypass_object_cache(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  _Bool tmp_if_expr$1;
  if(sys->enable_object_cache == (_Bool)0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = req->local != (_Bool)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool return_value_is_vdi_attr_obj$3;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$1)
    return (_Bool)1;

  else
  {
    _Bool return_value_is_vmstate_obj$2;
    return_value_is_vmstate_obj$2=is_vmstate_obj$link1(oid);
    if(!(return_value_is_vmstate_obj$2 == (_Bool)0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_is_vdi_attr_obj$3=is_vdi_attr_obj$link3(oid);
      tmp_if_expr$4 = return_value_is_vdi_attr_obj$3 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = ((signed int)req->rq.flags & 0x02) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      return (_Bool)1;

    else
    {
      if(!((0x08 & (signed int)req->rq.flags) == 0))
      {
        unsigned int vid;
        vid=oid_to_vid$link5(oid);
        struct object_cache *cache;
        cache=find_object_cache(vid, (_Bool)0);
        if(cache == ((struct object_cache *)NULL))
          return (_Bool)1;

        if(!((0x01 & (signed int)req->rq.flags) == 0))
        {
          object_cache_flush_and_delete(cache);
          return (_Bool)1;
        }

        else
        {
          unsigned long int idx;
          idx=object_cache_oid_to_idx(oid);
          signed int return_value_object_cache_lookup$6;
          return_value_object_cache_lookup$6=object_cache_lookup(cache, idx, (_Bool)0, (_Bool)0);
          if(return_value_object_cache_lookup$6 == 0)
            return (_Bool)0;

          else
            return (_Bool)1;
        }
      }

      return (_Bool)0;
    }
  }
}

// cache_delete_done
// file ops.c line 175
static void cache_delete_done(struct work *work)
{
  struct cache_deletion_work *dw;
  struct cache_deletion_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct cache_deletion_work *)((char *)__mptr - (signed long int)8ul);
  dw = tmp_statement_expression$1;
  free((void *)dw);
}

// cache_delete_work
// file ops.c line 167
static void cache_delete_work(struct work *work)
{
  struct cache_deletion_work *dw;
  struct cache_deletion_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct cache_deletion_work *)((char *)__mptr - (signed long int)8ul);
  dw = tmp_statement_expression$1;
  object_cache_delete(dw->vid);
}

// cache_dir_parser
// file sheep.c line 305
static signed int cache_dir_parser(const char *s)
{
  snprintf(ocpath, sizeof(char [4096l]) /*4096ul*/ , "%s", s);
  return 0;
}

// cache_directio_parser
// file sheep.c line 297
static signed int cache_directio_parser(const char *s)
{
  sys->object_cache_directio = (_Bool)1;
  return 0;
}

// cache_size_parser
// file sheep.c line 278
static signed int cache_size_parser(const char *s)
{
  const unsigned long int max_cache_size = ((unsigned long int)4294967295U + (unsigned long int)1) * (unsigned long int)1024 * (unsigned long int)1024;
  unsigned long int cache_size;
  signed int return_value_option_parse_size$1;
  return_value_option_parse_size$1=option_parse_size(s, &cache_size);
  if(!(return_value_option_parse_size$1 >= 0))
    return -1;

  else
    if(!(cache_size >= 10485760ul) || !(max_cache_size >= cache_size))
    {
      log_write(3, "cache_size_parser", 289, "Invalid cache option '%s': size must be between between %uM and %luG", s, ((10 * 1024 * 1024) / 1024) / 1024, ((max_cache_size / (unsigned long int)1024) / (unsigned long int)1024) / (unsigned long int)1024);
      return -1;
    }

    else
    {
      sys->object_cache_size = (unsigned int)((cache_size / (unsigned long int)1024) / (unsigned long int)1024);
      return 0;
    }
}

// calc_object_bmap
// file object_cache.c line 135
static unsigned long int calc_object_bmap(unsigned long int oid, unsigned long int len, signed long int offset)
{
  signed int start;
  signed int end;
  signed int nr;
  unsigned long int bmap = (unsigned long int)0;
  unsigned long int bsize;
  bsize=get_cache_block_size(oid);
  start = (signed int)((unsigned long int)offset / bsize);
  end = (signed int)(((len + (unsigned long int)offset + bsize) - (unsigned long int)1) / bsize);
  nr = end - start;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = nr;
    nr = nr - 1;
    if(tmp_post$1 == 0)
      break;

    set_bit_64(start + nr, &bmap);
  }
  while((_Bool)1);
  return bmap;
}

// check_gdb
// file logger.c line 753
static _Bool check_gdb(void)
{
  signed int return_value_system$1;
  return_value_system$1=system("which gdb > /dev/null");
  return return_value_system$1 == 0;
}

// check_host_env
// file sheep.c line 477
static void check_host_env(void)
{
  struct rlimit r;
  signed int return_value_getrlimit$1;
  return_value_getrlimit$1=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &r);
  if(!(return_value_getrlimit$1 >= 0))
    log_write(3, "check_host_env", 482, "failed to get nofile %m");

  else
    if(r.rlim_cur == 1024ul)
      log_write(4, "check_host_env", 489, "Allowed open files 1024 too small, suggested %u", 6144 * 100 * 10);

    else
      if(!(r.rlim_cur >= 6144000ul))
        log_write(6, "check_host_env", 492, "Allowed open files %lu, suggested %u", r.rlim_cur, 6144 * 100 * 10);

  signed int return_value_getrlimit$2;
  return_value_getrlimit$2=getrlimit((enum __rlimit_resource)RLIMIT_CORE, &r);
  if(!(return_value_getrlimit$2 >= 0))
  {
    if(sd_log_level == 7)
      log_write(7, "check_host_env", 495, "failed to get core %m");

  }

  else
    if(!(r.rlim_cur >= 18446744073709551615ul))
    {
      if(sd_log_level == 7)
        log_write(7, "check_host_env", 498, "Allowed core file size %lu, suggested unlimited", r.rlim_cur);

    }

  mallopt(-3, 512 * 1024);
}

// check_idx
// file sockfd_cache.c line 277
static inline void check_idx(signed int idx)
{
  struct work *w;
  if(!(fds_high_watermark >= idx))
  {
    _Bool return_value_uatomic_set_true$1;
    return_value_uatomic_set_true$1=uatomic_set_true$link2(&fds_in_grow);
    if(!(return_value_uatomic_set_true$1 == (_Bool)0))
    {
      void *return_value_xmalloc$2;
      return_value_xmalloc$2=xmalloc(sizeof(struct work) /*32ul*/ );
      w = (struct work *)return_value_xmalloc$2;
      w->fn = do_grow_fds;
      w->done = grow_fds_done;
      queue_work(grow_wq, w);
    }

  }

}

// check_path_len
// file store.c line 179
static inline signed int check_path_len(const char *path)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(path);
  len = (signed int)return_value_strlen$1;
  if(len >= 4097)
  {
    log_write(3, "check_path_len", 183, "insanely long object directory %s", path);
    return -1;
  }

  else
    return 0;
}

// check_recover_journal_file
// file journal.c line 248
static void check_recover_journal_file(const char *p)
{
  signed int old = 0;
  signed int new = 0;
  signed int return_value_get_old_new_jfile$1;
  return_value_get_old_new_jfile$1=get_old_new_jfile(p, &old, &new);
  if(return_value_get_old_new_jfile$1 >= 0)
  {
    if(!(old == 0))
    {
      signed int return_value_do_recover$2;
      return_value_do_recover$2=do_recover(old);
      if(!(return_value_do_recover$2 >= 0))
      {
        log_write(0, "check_recover_journal_file", 260, "PANIC: recoverying from journal file (old) failed");
        abort();
      }

      signed int return_value_do_recover$3;
      return_value_do_recover$3=do_recover(new);
      if(!(return_value_do_recover$3 >= 0))
      {
        log_write(0, "check_recover_journal_file", 262, "PANIC: recoverying from journal file (new) failed");
        abort();
      }

    }

  }

}

// check_request_epoch
// file request.c line 147
static signed int check_request_epoch(struct request *req)
{
  signed int return_value_before$4;
  return_value_before$4=before(req->rq.epoch, sys->cinfo.epoch);
  signed int return_value_after$3;
  if(!(return_value_before$4 == 0))
  {
    const char *return_value_op_name$1;
    return_value_op_name$1=op_name(req->op);
    log_write(3, "check_request_epoch", 151, "old node version %u, %u (%s)", sys->cinfo.epoch, req->rq.epoch, return_value_op_name$1);
    req->rp.$anon0.result = (unsigned int)0x81;
    req->rp.epoch = sys->cinfo.epoch;
    put_request(req);
    return -1;
  }

  else
  {
    return_value_after$3=after(req->rq.epoch, sys->cinfo.epoch);
    if(!(return_value_after$3 == 0))
    {
      const char *return_value_op_name$2;
      return_value_op_name$2=op_name(req->op);
      log_write(3, "check_request_epoch", 159, "new node version %u, %u (%s)", sys->cinfo.epoch, req->rq.epoch, return_value_op_name$2);
      req->rp.$anon0.result = (unsigned int)0x82;
      sleep_on_wait_queue(req);
      return -1;
    }

  }
  return 0;
}

// check_stale_objects
// file plain_store.c line 505
static signed int check_stale_objects(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *arg)
{
  _Bool return_value_oid_stale$2;
  return_value_oid_stale$2=oid_stale(oid, (signed int)ec_index, vinfo);
  signed int return_value_move_object_to_stale_dir$1;
  if(!(return_value_oid_stale$2 == (_Bool)0))
  {
    return_value_move_object_to_stale_dir$1=move_object_to_stale_dir(oid, wd, (unsigned int)0, ec_index, (struct vnode_info *)(void *)0, arg);
    return return_value_move_object_to_stale_dir$1;
  }

  else
    return 0x00;
}

// check_tmp_config
// file config.c line 47
static void check_tmp_config(void)
{
  signed int ret;
  char tmp_config_path[4096l];
  snprintf(tmp_config_path, (unsigned long int)4096, "%s.tmp", config_path);
  ret=unlink(tmp_config_path);
  if(!(ret == 0) && ret == 2)
    log_write(6, "check_tmp_config", 58, "removed temporal config file");

}

// chomp
// file ../include/util.h line 106
char * chomp(char *str)
{
  char *p;
  p=strchr(str, 10);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  return str;
}

// clean_journal_file
// file sheep_priv.h line 475
void clean_journal_file(const char *p)
{
  signed int ret;
  char path[4096l];
  sync();
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", p, jfile_name[(signed long int)0]);
  ret=unlink(path);
  if(!(ret >= 0))
    log_write(3, "clean_journal_file", 301, "unlink(%s): %m", (const void *)path);

  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", p, jfile_name[(signed long int)1]);
  ret=unlink(path);
  if(!(ret >= 0))
    log_write(3, "clean_journal_file", 306, "unlink(%s): %m", (const void *)path);

}

// clean_vdi_state
// file vdi.c line 1251
void clean_vdi_state(void)
{
  sd_write_lock(&vdi_state_lock);
  struct vdi_state_entry *__dummy;
  struct rb_node *__p1254;
  __p1254=rb_first(&vdi_state_root);
  struct rb_node *__n1254;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct vdi_state_entry *tmp_statement_expression$2;
  do
  {
    if(!(__p1254 == ((struct rb_node *)NULL)))
    {
      __n1254=rb_next(__p1254);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p1254;
      tmp_statement_expression$2 = (struct vdi_state_entry *)((char *)__mptr - (signed long int)16ul);
      __dummy = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    rb_erase(&__dummy->node, &vdi_state_root);
    free((void *)__dummy);
    __p1254 = __n1254;
  }
  while((_Bool)1);
  INIT_RB_ROOT$link1(&vdi_state_root);
  sd_rw_unlock(&vdi_state_lock);
}

// clear_client_info
// file request.c line 872
static void clear_client_info(struct client_info *ci)
{
  struct request *req;
  if(sd_log_level == 7)
    log_write(7, "clear_client_info", 876, "connection seems to be dead");

  struct request *__n878;
  struct request *tmp_statement_expression$1;
  const struct list_node *__mptr = (&ci->done_reqs)->n.next;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)128ul);
  req = tmp_statement_expression$1;
  struct request *tmp_statement_expression$2;
  const struct list_node *clear_client_info$$1$$2$$2$$__mptr = req->request_list.next;
  tmp_statement_expression$2 = (struct request *)((char *)clear_client_info$$1$$2$$2$$__mptr - (signed long int)128ul);
  __n878 = tmp_statement_expression$2;
  struct request *tmp_statement_expression$3;
  for( ; !(&req->request_list == &(&ci->done_reqs)->n); __n878 = tmp_statement_expression$3)
  {
    list_del$link1(&req->request_list);
    free_request(req);
    req = __n878;
    const struct list_node *clear_client_info$$1$$2$$3$$__mptr = __n878->request_list.next;
    tmp_statement_expression$3 = (struct request *)((char *)clear_client_info$$1$$2$$3$$__mptr - (signed long int)128ul);
  }
  unregister_event(ci->conn.fd);
  signed int return_value_refcount_read$4;
  if(sd_log_level == 7)
  {
    return_value_refcount_read$4=refcount_read$link1(&ci->refcnt);
    log_write(7, "clear_client_info", 886, "refcnt:%d, fd:%d, %s:%d", return_value_refcount_read$4, ci->conn.fd, (const void *)ci->conn.ipstr, ci->conn.port);
  }

  signed int return_value_refcount_read$5;
  return_value_refcount_read$5=refcount_read$link1(&ci->refcnt);
  if(return_value_refcount_read$5 == 0)
    destroy_client(ci);

}

// clear_parent_child_vdi
// file vdi.c line 1024
static void clear_parent_child_vdi(unsigned int vid)
{
  struct sd_inode *inode;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(4664ul);
  inode = (struct sd_inode *)return_value_xmalloc$1;
  unsigned int pvid;
  unsigned int i;
  signed int ret;
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(vid);
  ret=read_backend_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)4664ul, (unsigned long int)0);
  unsigned long int return_value_vid_to_vdi_oid$3;
  unsigned long int return_value_vid_to_vdi_oid$4;
  if(!(ret == 0x00))
    log_write(3, "clear_parent_child_vdi", 1033, "failed to read inode %x", vid);

  else
  {
    pvid = inode->parent_vdi_id;
    if(!(pvid == 0u))
    {
      return_value_vid_to_vdi_oid$3=vid_to_vdi_oid(pvid);
      ret=read_backend_object(return_value_vid_to_vdi_oid$3, (char *)inode, (unsigned int)4664ul, (unsigned long int)0);
      if(!(ret == 0x00))
        log_write(3, "clear_parent_child_vdi", 1043, "failed to read parent inode %x", pvid);

      else
      {
        i = (unsigned int)0;
        for( ; !(i >= 1024U); i = i + 1u)
          if(inode->child_vdi_id[(signed long int)i] == vid)
          {
            inode->child_vdi_id[(signed long int)i] = (unsigned int)0;
            break;
          }

        if(i == 1024U)
          log_write(6, "clear_parent_child_vdi", 1054, "failed to find child %x", vid);

        else
        {
          return_value_vid_to_vdi_oid$4=vid_to_vdi_oid(pvid);
          ret=sd_write_object(return_value_vid_to_vdi_oid$4, (char *)inode, (unsigned int)4664ul, (unsigned long int)0, (_Bool)0);
          if(!(ret == 0x00))
            log_write(3, "clear_parent_child_vdi", 1061, "failed to update parent %x", pvid);

          else
            if(sd_log_level == 7)
              log_write(7, "clear_parent_child_vdi", 1064, "parent %x", pvid);

        }
      }
    }

  }

out:
  ;
  free((void *)inode);
}

// client_handler
// file request.c line 931
static void client_handler(signed int fd, signed int events, void *data)
{
  struct client_info *ci = (struct client_info *)data;
  if(sd_log_level == 7)
    log_write(7, "client_handler", 935, "%x, %d", events, ci->conn.dead);

  if(!((24 & events) == 0))
    ci->conn.dead = (_Bool)1;

  struct request *tmp_statement_expression$3;
  if(!(ci->conn.dead == (_Bool)0))
    clear_client_info(ci);

  else
  {
    if(!((1 & events) == 0))
    {
      signed int return_value_conn_rx_off$1;
      return_value_conn_rx_off$1=conn_rx_off(&ci->conn);
      if(!(return_value_conn_rx_off$1 == 0))
      {
        log_write(3, "client_handler", 950, "switch off receiving flag failure, connection maybe closed");
        goto __CPROVER_DUMP_L8;
      }

      refcount_inc$link1(&ci->refcnt);
      ci->rx_work.fn = rx_work;
      ci->rx_work.done = rx_main;
      queue_work(sys->net_wqueue, &ci->rx_work);
    }

    if(!((4 & events) == 0))
    {
      signed int return_value_conn_tx_off$2;
      return_value_conn_tx_off$2=conn_tx_off(&ci->conn);
      if(!(return_value_conn_tx_off$2 == 0))
      {
        log_write(3, "client_handler", 967, "switch off sending flag failure, connection maybe closed");
        goto __CPROVER_DUMP_L8;
      }

      const struct list_node *__mptr = (&ci->done_reqs)->n.next;
      tmp_statement_expression$3 = (struct request *)((char *)__mptr - (signed long int)128ul);
      ci->tx_req = tmp_statement_expression$3;
      list_del$link1(&ci->tx_req->request_list);
      refcount_inc$link1(&ci->refcnt);
      ci->tx_work.fn = tx_work;
      ci->tx_work.done = tx_main;
      queue_work(sys->net_wqueue, &ci->tx_work);
    }

  }

__CPROVER_DUMP_L8:
  ;
}

// clone_vdi
// file vdi.c line 301
static signed int clone_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int base_vid)
{
  struct sd_inode *new = (struct sd_inode *)(void *)0;
  struct sd_inode *base;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  base = (struct sd_inode *)return_value_xzalloc$1;
  signed int ret;
  signed int idx;
  if(sd_log_level == 7)
    log_write(7, "clone_vdi", 309, "%s: size %lu, vid %x, base %x, copies %d, snapid %u", iocb->name, iocb->size, new_vid, base_vid, iocb->nr_copies, new_snapid);

  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(base_vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)base, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  unsigned long int return_value_vid_to_vdi_oid$3;
  unsigned long int return_value_vid_to_vdi_oid$4;
  if(!(ret == 0x00))
    ret = 0x0C;

  else
  {
    idx=find_free_idx(base->child_vdi_id, sizeof(unsigned int [1024l]) /*4096ul*/  / sizeof(unsigned int) /*4ul*/ );
    if(!(idx >= 0))
      ret = 0x13;

    else
    {
      return_value_vid_to_vdi_oid$3=vid_to_vdi_oid(base_vid);
      ret=sd_write_object(return_value_vid_to_vdi_oid$3, (char *)&new_vid, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4ul * (unsigned long int)idx + 568ul, (_Bool)0);
      if(!(ret == 0x00))
        ret = 0x0D;

      else
      {
        new=alloc_inode(iocb, new_snapid, new_vid, base->data_vdi_id);
        return_value_vid_to_vdi_oid$4=vid_to_vdi_oid(new_vid);
        ret=sd_write_object(return_value_vid_to_vdi_oid$4, (char *)new, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0, (_Bool)1);
        if(!(ret == 0x00))
          ret = 0x0B;

      }
    }
  }

out:
  ;
  free((void *)new);
  free((void *)base);
  return ret;
}

// cluster_cleanup
// file ops.c line 606
static signed int cluster_cleanup(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int ret;
  _Bool return_value_node_in_recovery$1;
  return_value_node_in_recovery$1=node_in_recovery();
  if(!(return_value_node_in_recovery$1 == (_Bool)0))
    return 0x8C;

  else
    if(!(sys->gateway_only == (_Bool)0))
      return 0x00;

    else
    {
      if(!(sd_store->cleanup == ((signed int (*)(void))NULL)))
        ret=sd_store->cleanup();

      else
        ret = 0x8B;
      return ret;
    }
}

// cluster_ctime_check
// file group.c line 375
static _Bool cluster_ctime_check(struct cluster_info *cinfo)
{
  _Bool tmp_if_expr$1;
  if(cinfo->epoch == 0u)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = sys->cinfo.epoch == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (_Bool)1;

  else
    if(!(cinfo->ctime == sys->cinfo.ctime))
    {
      log_write(3, "cluster_ctime_check", 382, "joining node ctime doesn't match: %lu vs %lu", cinfo->ctime, sys->cinfo.ctime);
      return (_Bool)0;
    }

    else
      return (_Bool)1;
}

// cluster_del_vdi
// file ops.c line 146
static signed int cluster_del_vdi(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  unsigned int data_len = hdr->data_length;
  struct vdi_iocb iocb = { .name=(const char *)req->data, .tag=((const char *)NULL), .data_len=data_len,
    .size=0ul, .base_vid=0u, .snapid=hdr->$anon0.vdi.snapid,
    .create_snapshot=(_Bool)0, .copy_policy=0,
    .store_policy=0, .nr_copies=0, .time=0ul };
  signed int return_value_vdi_init_tag$1;
  return_value_vdi_init_tag$1=vdi_init_tag(&iocb.tag, (const char *)req->data, data_len);
  if(!(return_value_vdi_init_tag$1 >= 0))
    return 0x05;

  else
  {
    signed int return_value_vdi_delete$2;
    return_value_vdi_delete$2=vdi_delete(&iocb, req);
    return return_value_vdi_delete$2;
  }
}

// cluster_delete_cache
// file ops.c line 651
static signed int cluster_delete_cache(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  unsigned int vid;
  vid=oid_to_vid$link3(req->$anon0.obj.oid);
  if(!(sys->enable_object_cache == (_Bool)0))
    object_cache_delete(vid);

  return 0x00;
}

// cluster_disable_recover
// file ops.c line 329
static signed int cluster_disable_recover(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  sys->cinfo.disable_recovery = (unsigned char)1;
  return 0x00;
}

// cluster_enable_recover
// file ops.c line 321
static signed int cluster_enable_recover(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  sys->cinfo.disable_recovery = (unsigned char)0;
  resume_suspended_recovery();
  return 0x00;
}

// cluster_force_recover_main
// file ops.c line 566
static signed int cluster_force_recover_main(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  struct vnode_info *old_vnode_info;
  struct vnode_info *vnode_info;
  signed int ret = 0x00;
  struct sd_node *nodes = (struct sd_node *)data;
  unsigned long int cluster_force_recover_main$$1$$nr_nodes = (unsigned long int)rsp->data_length / sizeof(struct sd_node) /*80ul*/ ;
  struct rb_root nroot = { .rb_node=(struct rb_node *)(void *)0 };
  _Bool return_value_is_cluster_formatted$1;
  struct sd_node *tmp_statement_expression$2;
  if(!(rsp->epoch == sys->cinfo.epoch))
  {
    log_write(3, "cluster_force_recover_main", 577, "epoch was incremented while cluster_force_recover");
    return 0x89;
  }

  else
  {
    ret=inc_and_log_epoch();
    if(!(ret == 0))
      log_write(0, "cluster_force_recover_main", 583, "cannot update epoch log");

    else
    {
      return_value_is_cluster_formatted$1=is_cluster_formatted();
      if(return_value_is_cluster_formatted$1 == (_Bool)0)
        set_cluster_config(&sys->cinfo);

      sys->cinfo.status = (enum sd_status)SD_STATUS_OK;
      signed int i = 0;
      for( ; !((unsigned long int)i >= cluster_force_recover_main$$1$$nr_nodes); i = i + 1)
      {
        struct rb_node **__n = &(&nroot)->rb_node;
        struct rb_node *__parent = (struct rb_node *)(void *)0;
        struct sd_node *__old = (struct sd_node *)(void *)0;
        struct sd_node *__data;
        while(!(*__n == ((struct rb_node *)NULL)))
        {
          const struct rb_node *__mptr = *__n;
          tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
          __data = tmp_statement_expression$2;
          signed int __cmp;
          __cmp=node_cmp$link1(&nodes[(signed long int)i], __data);
          __parent = *__n;
          if(!(__cmp >= 0))
            __n = &(*__n)->rb_left;

          else
            if(__cmp >= 1)
              __n = &(*__n)->rb_right;

            else
            {
              __old = __data;
              break;
            }
        }
        if(__old == ((struct sd_node *)NULL))
        {
          rb_link_node$link2(&(&nodes[(signed long int)i])->rb, __parent, __n);
          rb_insert_color(&(&nodes[(signed long int)i])->rb, &nroot);
        }

        __old;
      }
      vnode_info=get_vnode_info();
      old_vnode_info=alloc_vnode_info(&nroot);
      start_recovery(vnode_info, old_vnode_info, (_Bool)1);
      put_vnode_info(vnode_info);
      put_vnode_info(old_vnode_info);
      return ret;
    }

  err:
    ;
    log_write(0, "cluster_force_recover_main", 603, "PANIC: failed in force recovery");
    abort();
  }
}

// cluster_force_recover_work
// file ops.c line 530
static signed int cluster_force_recover_work(struct request *req)
{
  struct vnode_info *old_vnode_info;
  unsigned int epoch;
  epoch=sys_epoch$link2();
  _Bool tmp_if_expr$1;
  if(!((signed int)sys->cinfo.status == SD_STATUS_WAIT))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = req->vinfo == (struct vnode_info *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0x89;

  else
  {
    old_vnode_info=get_vnode_info_epoch(epoch, req->vinfo);
    if(old_vnode_info == ((struct vnode_info *)NULL))
    {
      log_write(0, "cluster_force_recover_work", 546, "cannot get vnode info for epoch %d", epoch);
      put_vnode_info(old_vnode_info);
      return 0x89;
    }

    else
      if(!((unsigned long int)req->rq.data_length >= sizeof(struct sd_node) /*80ul*/  * (unsigned long int)old_vnode_info->nr_nodes))
      {
        log_write(3, "cluster_force_recover_work", 553, "too small buffer size, %d", req->rq.data_length);
        return 0x05;
      }

      else
      {
        req->rp.epoch = epoch;
        req->rp.data_length = (unsigned int)(sizeof(struct sd_node) /*80ul*/  * (unsigned long int)old_vnode_info->nr_nodes);
        nodes_to_buffer$link1(&old_vnode_info->nroot, req->data);
        put_vnode_info(old_vnode_info);
        return 0x00;
      }
  }
}

// cluster_get_vdi_attr
// file ops.c line 336
static signed int cluster_get_vdi_attr(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct sd_rsp *rsp = &req->rp;
  unsigned int vid;
  unsigned int attrid = (unsigned int)0;
  struct sheepdog_vdi_attr *vattr;
  struct vdi_iocb iocb = { .name=((const char *)NULL), .tag=((const char *)NULL), .data_len=0u,
    .size=0ul, .base_vid=0u, .snapid=0u,
    .create_snapshot=(_Bool)0, .copy_policy=0,
    .store_policy=0, .nr_copies=0, .time=0ul };
  struct vdi_info info = { .vid=0u, .snapid=0u, .free_bit=0u, .create_time=0ul };
  signed int ret;
  vattr = (struct sheepdog_vdi_attr *)req->data;
  iocb.name = vattr->name;
  iocb.tag = vattr->tag;
  iocb.snapid = hdr->$anon0.vdi.snapid;
  ret=vdi_lookup(&iocb, &info);
  if(!(ret == 0x00))
    return ret;

  else
  {
    vid=sd_hash_vdi$link1(vattr->name);
    ret=get_vdi_attr((struct sheepdog_vdi_attr *)req->data, (signed int)hdr->data_length, vid, &attrid, info.create_time, !(!(((signed int)hdr->flags & 0x0100) != 0)), !(!(((signed int)hdr->flags & 0x0200) != 0)), !(!(((signed int)hdr->flags & 0x0400) != 0)));
    rsp->$anon0.vdi.vdi_id = vid;
    rsp->$anon0.vdi.attr_id = attrid;
    signed int return_value_get_vdi_copy_number$1;
    return_value_get_vdi_copy_number$1=get_vdi_copy_number(vid);
    rsp->$anon0.vdi.copies = (unsigned char)return_value_get_vdi_copy_number$1;
    return ret;
  }
}

// cluster_get_vdi_info
// file ops.c line 211
static signed int cluster_get_vdi_info(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct sd_rsp *rsp = &req->rp;
  unsigned int data_len = hdr->data_length;
  signed int ret;
  struct vdi_info info = { .vid=0u, .snapid=0u, .free_bit=0u, .create_time=0ul };
  struct vdi_iocb iocb = { .name=(const char *)req->data, .tag=((const char *)NULL), .data_len=data_len,
    .size=0ul, .base_vid=0u, .snapid=hdr->$anon0.vdi.snapid,
    .create_snapshot=(_Bool)0, .copy_policy=0,
    .store_policy=0, .nr_copies=0, .time=0ul };
  signed int return_value_vdi_init_tag$1;
  return_value_vdi_init_tag$1=vdi_init_tag(&iocb.tag, (const char *)req->data, data_len);
  if(!(return_value_vdi_init_tag$1 >= 0))
    return 0x05;

  else
  {
    ret=vdi_lookup(&iocb, &info);
    if(!(ret == 0x00))
      return ret;

    else
    {
      rsp->$anon0.vdi.vdi_id = info.vid;
      signed int return_value_get_vdi_copy_number$2;
      return_value_get_vdi_copy_number$2=get_vdi_copy_number(info.vid);
      rsp->$anon0.vdi.copies = (unsigned char)return_value_get_vdi_copy_number$2;
      return ret;
    }
  }
}

// cluster_info_copy
// file group.c line 419
static void cluster_info_copy(struct cluster_info *dst, struct cluster_info *src)
{
  signed int len = (signed int)(48ul + (unsigned long int)src->nr_nodes * sizeof(struct sd_node) /*80ul*/ );
  memcpy((void *)dst, (const void *)src, (unsigned long int)len);
}

// cluster_join_check
// file group.c line 867
static _Bool cluster_join_check(struct cluster_info *cinfo)
{
  if(!((signed int)cinfo->proto_ver == 0x09))
  {
    log_write(3, "cluster_join_check", 871, "invalid protocol version: %d, %d", cinfo->proto_ver, 0x09);
    return (_Bool)0;
  }

  else
  {
    _Bool return_value_cluster_ctime_check$1;
    return_value_cluster_ctime_check$1=cluster_ctime_check(cinfo);
    if(return_value_cluster_ctime_check$1 == (_Bool)0)
      return (_Bool)0;

    else
      return (_Bool)1;
  }
}

// cluster_make_fs
// file ops.c line 253
static signed int cluster_make_fs(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int i;
  signed int ret;
  unsigned int latest_epoch;
  struct store_driver *driver;
  char *store_name = (char *)data;
  driver=find_store_driver$link2((const char *)data);
  if(driver == ((struct store_driver *)NULL))
    return 0x8A;

  else
  {
    pstrcpy((char *)sys->cinfo.store, (signed int)sizeof(unsigned char [16l]) /*16ul*/ , store_name);
    sd_store = driver;
    latest_epoch=get_latest_epoch();
    ret=sd_store->format();
    if(!(ret == 0x00))
      return ret;

    else
    {
      ret=sd_store->init();
      if(!(ret == 0x00))
        return ret;

      else
      {
        sys->cinfo.nr_copies = req->$anon0.cluster.copies;
        sys->cinfo.copy_policy = req->$anon0.cluster.copy_policy;
        sys->cinfo.flags = req->$anon0.cluster.flags;
        if(sys->cinfo.nr_copies == 0)
          sys->cinfo.nr_copies = (unsigned char)3;

        sys->cinfo.ctime = req->$anon0.cluster.ctime;
        set_cluster_config(&sys->cinfo);
        i = 1;
        if(latest_epoch >= (unsigned int)i)
        {
          remove_epoch((unsigned int)i);
          i = i + 1;
        }

        memset((void *)sys->vdi_inuse, 0, sizeof(unsigned long int [262144l]) /*2097152ul*/ );
        clean_vdi_state();
        sys->cinfo.epoch = (unsigned int)0;
        ret=inc_and_log_epoch();
        if(!(ret == 0))
          return 0x03;

        else
        {
          sys->cinfo.status = (enum sd_status)SD_STATUS_OK;
          return 0x00;
        }
      }
    }
  }
}

// cluster_new_vdi
// file ops.c line 76
static signed int cluster_new_vdi(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct sd_rsp *rsp = &req->rp;
  unsigned int vid;
  signed int ret;
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  struct vdi_iocb iocb = { .name=(const char *)req->data, .tag=((const char *)NULL), .data_len=hdr->data_length,
    .size=hdr->$anon0.vdi.vdi_size, .base_vid=hdr->$anon0.vdi.base_vdi_id,
    .snapid=0u,
    .create_snapshot=!(!(hdr->$anon0.vdi.snapid != 0u)), .copy_policy=hdr->$anon0.vdi.copy_policy,
    .store_policy=hdr->$anon0.vdi.store_policy,
    .nr_copies=hdr->$anon0.vdi.copies,
    .time=(unsigned long int)tv.tv_sec << 32 | (unsigned long int)(tv.tv_usec * (signed long int)1000) };
  if(hdr->$anon0.vdi.copies == 0)
  {
    iocb.nr_copies = sys->cinfo.nr_copies;
    iocb.copy_policy = sys->cinfo.copy_policy;
  }

  signed int return_value_ec_policy_to_dp$1;
  if(!(iocb.copy_policy == 0))
  {
    return_value_ec_policy_to_dp$1=ec_policy_to_dp$link2(iocb.copy_policy, (signed int *)(void *)0, (signed int *)(void *)0);
    iocb.nr_copies = (unsigned char)return_value_ec_policy_to_dp$1;
  }

  if(!(hdr->data_length == 256U))
    return 0x05;

  else
  {
    if(!(iocb.create_snapshot == (_Bool)0))
      ret=vdi_snapshot(&iocb, &vid);

    else
      ret=vdi_create(&iocb, &vid);
    rsp->$anon0.vdi.vdi_id = vid;
    rsp->$anon0.vdi.copies = iocb.nr_copies;
    return ret;
  }
}

// cluster_notify_vdi_add
// file ops.c line 625
static signed int cluster_notify_vdi_add(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int return_value_get_vdi_copy_number$1;
  if(!(req->$anon0.vdi_state.old_vid == 0u))
  {
    return_value_get_vdi_copy_number$1=get_vdi_copy_number(req->$anon0.vdi_state.old_vid);
    add_vdi_state(req->$anon0.vdi_state.old_vid, return_value_get_vdi_copy_number$1, (_Bool)1, req->$anon0.vdi_state.copy_policy);
  }

  if(!(req->$anon0.vdi_state.set_bitmap == 0))
    atomic_set_bit$link1((signed int)req->$anon0.vdi_state.new_vid, sys->vdi_inuse);

  add_vdi_state(req->$anon0.vdi_state.new_vid, (signed int)req->$anon0.vdi_state.copies, (_Bool)0, req->$anon0.vdi_state.copy_policy);
  return 0x00;
}

// cluster_notify_vdi_del
// file ops.c line 643
static signed int cluster_notify_vdi_del(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  unsigned int vid = *((unsigned int *)data);
  signed int return_value_objlist_cache_cleanup$1;
  return_value_objlist_cache_cleanup$1=objlist_cache_cleanup(vid);
  return return_value_objlist_cache_cleanup$1;
}

// cluster_op_done
// file group.c line 224
static void cluster_op_done(struct work *work)
{
  struct request *req;
  struct request *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)192ul);
  req = tmp_statement_expression$1;
  struct vdi_op_message *msg;
  unsigned long int size;
  signed int ret;
  const char *return_value_op_name$2;
  if(!((signed int)req->status == REQUEST_DROPPED))
  {
    if(sd_log_level == 7)
    {
      return_value_op_name$2=op_name(req->op);
      log_write(7, "cluster_op_done", 234, "%s (%p)", return_value_op_name$2, req);
    }

    msg=prepare_cluster_msg(req, &size);
    ret=sys->cdrv->unblock((void *)msg, size);
    if(!(ret == 0x00))
    {
      const char *return_value_sd_strerror$3;
      return_value_sd_strerror$3=sd_strerror(ret);
      log_write(0, "cluster_op_done", 245, "Failed to unblock, %s, exiting.", return_value_sd_strerror$3);
      exit(1);
    }

    free((void *)msg);
    req->status = (enum REQUST_STATUS)REQUEST_DONE;
  }

  else
  {

  drop:
    ;
    list_del(&req->pending_list);
    req->rp.$anon0.result = (unsigned int)0x91;
    put_request(req);
    cluster_op_running = (_Bool)0;
  }
}

// cluster_recovery_completion
// file ops.c line 662
static signed int cluster_recovery_completion(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  struct vnode_info *vnode_info;
  signed int i;
  unsigned int epoch = req->$anon0.obj.tgt_epoch;
  static struct sd_node *node;
  node = (struct sd_node *)data;
  unsigned long int tmp_post$1;
  const char *return_value_node_to_str$2;
  const char *return_value_node_to_str$3;
  struct sd_node *tmp_statement_expression$4;
  struct sd_node *tmp_statement_expression$5;
  static signed int latest_epoch;
  if(!(epoch >= (unsigned int)latest_epoch))
    return 0x00;

  else
  {
    static unsigned long int nr_recovereds;
    if(!((unsigned int)latest_epoch >= epoch))
    {
      if(sd_log_level == 7)
        log_write(7, "cluster_recovery_completion", 679, "new epoch %d", epoch);

      latest_epoch = (signed int)epoch;
      nr_recovereds = (unsigned long int)0;
    }

    tmp_post$1 = nr_recovereds;
    nr_recovereds = nr_recovereds + 1ul;
    static struct sd_node recovereds[6144l];
    recovereds[(signed long int)tmp_post$1] = *node;
    if(nr_recovereds >= 2ul)
      qsort((void *)recovereds, nr_recovereds, sizeof(struct sd_node) /*80ul*/ , (signed int (*)(const void *, const void *))node_cmp$link1);

    if(sd_log_level == 7)
    {
      return_value_node_to_str$2=node_to_str$link1(node);
      log_write(7, "cluster_recovery_completion", 687, "%s is recovered at epoch %d", return_value_node_to_str$2, epoch);
    }

    i = 0;
    for( ; !((unsigned long int)i >= nr_recovereds); i = i + 1)
      if(sd_log_level == 7)
      {
        return_value_node_to_str$3=node_to_str$link1(recovereds + (signed long int)i);
        log_write(7, "cluster_recovery_completion", 689, "[%x] %s", i, return_value_node_to_str$3);
      }

    if(!(sys->cinfo.epoch == (unsigned int)latest_epoch))
      return 0x00;

    else
    {
      vnode_info=get_vnode_info();
      if((unsigned long int)vnode_info->nr_nodes == nr_recovereds)
      {
        i = 0;
        for( ; !((unsigned long int)i >= nr_recovereds); i = i + 1)
        {
          struct rb_node *__n = (&vnode_info->nroot)->rb_node;
          struct sd_node *__ret = (struct sd_node *)(void *)0;
          struct sd_node *__data;
          while(!(__n == ((struct rb_node *)NULL)))
          {
            const struct rb_node *__mptr = __n;
            tmp_statement_expression$5 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
            __data = tmp_statement_expression$5;
            signed int __cmp;
            __cmp=node_cmp$link1(&recovereds[(signed long int)i], __data);
            if(!(__cmp >= 0))
              __n = __n->rb_left;

            else
              if(__cmp >= 1)
                __n = __n->rb_right;

              else
              {
                __ret = __data;
                break;
              }
          }
          tmp_statement_expression$4 = __ret;
          if(tmp_statement_expression$4 == ((struct sd_node *)NULL))
            break;

        }
        if((unsigned long int)i == nr_recovereds)
        {
          log_write(5, "cluster_recovery_completion", 703, "all nodes are recovered, epoch %d", epoch);
          last_gathered_epoch = epoch;
          if(vnode_info->nr_zones >= ec_max_data_strip)
          {
            if(!(sd_store == ((struct store_driver *)NULL)))
            {
              if(!(sd_store->cleanup == ((signed int (*)(void))NULL)))
                sd_store->cleanup();

            }

          }

        }

      }

      put_vnode_info(vnode_info);
      return 0x00;
    }
  }
}

// cluster_reweight
// file ops.c line 746
static signed int cluster_reweight(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  _Bool return_value_node_size_varied$1;
  return_value_node_size_varied$1=node_size_varied();
  signed int return_value;
  if(!(return_value_node_size_varied$1 == (_Bool)0))
  {
    return_value=sys->cdrv->update_node(&sys->this_node);
    return return_value;
  }

  else
    return 0x00;
}

// cluster_shutdown
// file ops.c line 303
static signed int cluster_shutdown(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  sys->cinfo.status = (enum sd_status)SD_STATUS_SHUTDOWN;
  _Bool return_value_node_in_recovery$2;
  return_value_node_in_recovery$2=node_in_recovery();
  if(return_value_node_in_recovery$2 == (_Bool)0)
  {
    unregister_listening_fds();
    signed int return_value_set_cluster_shutdown$1;
    return_value_set_cluster_shutdown$1=set_cluster_shutdown((_Bool)1);
    if(!(return_value_set_cluster_shutdown$1 == 0x00))
      log_write(3, "cluster_shutdown", 315, "failed to set cluster as shutdown");

  }

  return 0x00;
}

// cluster_wait_check
// file group.c line 427
static enum sd_status cluster_wait_check(struct sd_node *joining, struct rb_root *nroot, unsigned long int nr_nodes, struct cluster_info *cinfo)
{
  _Bool return_value_cluster_ctime_check$1;
  return_value_cluster_ctime_check$1=cluster_ctime_check(cinfo);
  _Bool return_value_enough_nodes_gathered$2;
  if(return_value_cluster_ctime_check$1 == (_Bool)0)
  {
    if(sd_log_level == 7)
      log_write(7, "cluster_wait_check", 433, "joining node is invalid");

    return (enum sd_status)sys->cinfo.status;
  }

  else
  {
    if(!(sys->cinfo.epoch >= cinfo->epoch))
    {
      if(sd_log_level == 7)
        log_write(7, "cluster_wait_check", 439, "joining node has a larger epoch, %u, %u", cinfo->epoch, sys->cinfo.epoch);

      cluster_info_copy(&sys->cinfo, cinfo);
    }

    if(sys->cinfo.epoch >= 1u)
    {
      return_value_enough_nodes_gathered$2=enough_nodes_gathered(&sys->cinfo, joining, nroot, nr_nodes);
      if(return_value_enough_nodes_gathered$2 == (_Bool)0)
        goto __CPROVER_DUMP_L5;

      return (enum sd_status)SD_STATUS_OK;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      return (enum sd_status)sys->cinfo.status;
    }
  }
}

// conn_rx_off
// file ../include/net.h line 40
signed int conn_rx_off(struct connection *conn)
{
  conn->events = conn->events & (unsigned int)~1;
  signed int return_value_modify_event$1;
  return_value_modify_event$1=modify_event(conn->fd, conn->events);
  return return_value_modify_event$1;
}

// conn_rx_on
// file ../include/net.h line 41
signed int conn_rx_on(struct connection *conn)
{
  conn->events = conn->events | (unsigned int)1;
  signed int return_value_modify_event$1;
  return_value_modify_event$1=modify_event(conn->fd, conn->events);
  return return_value_modify_event$1;
}

// conn_tx_off
// file ../include/net.h line 38
signed int conn_tx_off(struct connection *conn)
{
  conn->events = conn->events & (unsigned int)~4;
  signed int return_value_modify_event$1;
  return_value_modify_event$1=modify_event(conn->fd, conn->events);
  return return_value_modify_event$1;
}

// conn_tx_on
// file ../include/net.h line 39
signed int conn_tx_on(struct connection *conn)
{
  conn->events = conn->events | (unsigned int)4;
  signed int return_value_modify_event$1;
  return_value_modify_event$1=modify_event(conn->fd, conn->events);
  return return_value_modify_event$1;
}

// connect_to
// file net.c line 137
signed int connect_to(const char *name, signed int port)
{
  char buf[64l];
  char hbuf[1025l];
  char sbuf[32l];
  signed int fd;
  signed int ret;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *res0;
  struct linger linger_opt = { .l_onoff=1, .l_linger=0 };
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  snprintf(buf, sizeof(char [64l]) /*64ul*/ , "%d", port);
  hints.ai_socktype = 1;
  ret=getaddrinfo(name, buf, &hints, &res0);
  signed int *return_value___errno_location$1;
  if(!(ret == 0))
  {
    log_write(3, "connect_to", 152, "failed to get address info: %m");
    return -1;
  }

  else
  {
    res = res0;
    for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
    {
      ret=getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
      if(ret == 0)
      {
        fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
        if(fd >= 0)
        {
          ret=setsockopt(fd, 1, 13, (const void *)&linger_opt, (unsigned int)sizeof(struct linger) /*8ul*/ );
          if(!(ret == 0))
          {
            log_write(3, "connect_to", 170, "failed to set SO_LINGER: %m");
            close(fd);
          }

          else
          {
            ret=set_snd_timeout(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 177, "failed to set send timeout: %m");
              close(fd);
              break;
            }

            ret=set_rcv_timeout(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 184, "failed to set recv timeout: %m");
              close(fd);
              break;
            }

            do
            {

            reconnect:
              ;
              ret=connect(fd, res->ai_addr, res->ai_addrlen);
              if(ret == 0)
                goto __CPROVER_DUMP_L6;

              return_value___errno_location$1=__errno_location();
            }
            while(*return_value___errno_location$1 == 4);
            log_write(3, "connect_to", 193, "failed to connect to %s:%d: %m", name, port);
            close(fd);
            goto __CPROVER_DUMP_L8;

          __CPROVER_DUMP_L6:
            ;
            ret=set_nodelay(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 200, "%m");
              close(fd);
              break;
            }

            else
              goto success;
          }
        }

      }


    __CPROVER_DUMP_L8:
      ;
    }
    fd = -1;

  success:
    ;
    freeaddrinfo(res0);
    if(sd_log_level == 7)
      log_write(7, "connect_to", 209, "%d, %s:%d", fd, name, port);

    return fd;
  }
}

// connect_to_addr
// file ../include/net.h line 71
static inline signed int connect_to_addr(const unsigned char *addr, signed int port)
{
  const char *return_value_addr_to_str$1;
  return_value_addr_to_str$1=addr_to_str(addr, (unsigned short int)0);
  signed int return_value_connect_to$2;
  return_value_connect_to$2=connect_to(return_value_addr_to_str$1, port);
  return return_value_connect_to$2;
}

// convert_ecidx_xattr2path
// file migrate.c line 430
static signed int convert_ecidx_xattr2path(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *info, void *arg)
{
  signed int ret = 0;
  unsigned char idx;
  char path[4097l];
  char new_path[4097l];
  _Bool is_stale = *((_Bool *)arg);
  if(!(is_stale == (_Bool)0))
    snprintf(path, (unsigned long int)4096, "%s/%016lx.%u", wd, oid, epoch);

  else
    snprintf(path, (unsigned long int)4096, "%s/%016lx", wd, oid);
  signed long int return_value_getxattr$1;
  return_value_getxattr$1=getxattr(path, "user.ec.index", (void *)&idx, sizeof(unsigned char) /*1ul*/ );
  signed int return_value_rename$2;
  signed int return_value_removexattr$3;
  if(!(return_value_getxattr$1 >= 0l))
    log_write(6, "convert_ecidx_xattr2path", 447, "object: %s doesn't have its ec index in xattr: %m", (const void *)path);

  else
  {
    if(!(is_stale == (_Bool)0))
      snprintf(new_path, (unsigned long int)4096, "%s/%016lx_%u.%u", wd, oid, idx, epoch);

    else
      snprintf(new_path, (unsigned long int)4096, "%s/%016lx_%u", wd, oid, idx);
    return_value_rename$2=rename(path, new_path);
    if(!(return_value_rename$2 >= 0))
    {
      log_write(0, "convert_ecidx_xattr2path", 459, "rename from %s to %s failed: %m", (const void *)path, (const void *)new_path);
      ret = -1;
    }

    else
    {
      return_value_removexattr$3=removexattr(new_path, "user.ec.index");
      if(!(return_value_removexattr$3 >= 0))
      {
        log_write(0, "convert_ecidx_xattr2path", 467, "remove xattr %s from path %s failed: %m", (const void *)"user.ec.index", (const void *)new_path);
        ret = -1;
      }

    }
  }

out:
  ;
  return ret;
}

// count_data_objs
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs(struct sd_inode *inode)
{
  return ((inode->vdi_size + (1UL << 22)) - (unsigned long int)1) / (1UL << 22);
}

// count_data_objs$link1
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs$link1(struct sd_inode *inode$link1)
{
  return ((inode$link1->vdi_size + (1UL << 22)) - (unsigned long int)1) / (1UL << 22);
}

// crash_handler
// file sheep.c line 265
static void crash_handler(signed int signo)
{
  char *return_value_strsignal$1;
  return_value_strsignal$1=strsignal(signo);
  log_write(0, "crash_handler", 267, "sheep exits unexpectedly (%s).", return_value_strsignal$1);
  sd_backtrace();
  __sd_dump_variable("__sys");
  reraise_crash_signal(signo, 1);
}

// crash_handler$link1
// file logger.c line 534
static void crash_handler$link1(signed int signo$link1)
{
  _Bool return_value_is_sheep_dead$3;
  return_value_is_sheep_dead$3=is_sheep_dead(signo$link1);
  if(!(return_value_is_sheep_dead$3 == (_Bool)0))
    log_write(3, "crash_handler", 537, "sheep pid %d exited unexpectedly.", sheep_pid);

  else
  {
    signed int return_value_getpid$1;
    return_value_getpid$1=getpid();
    char *return_value_strsignal$2;
    return_value_strsignal$2=strsignal(signo$link1);
    log_write(3, "crash_handler", 540, "logger pid %d exits unexpectedly (%s).", return_value_getpid$1, return_value_strsignal$2);
    sd_backtrace();
  }
  log_flush();
  closelog();
  free_logarea();
  _Bool return_value_is_sheep_dead$4;
  return_value_is_sheep_dead$4=is_sheep_dead(signo$link1);
  if(!(return_value_is_sheep_dead$4 == (_Bool)0))
    exit(1);

  reraise_crash_signal(signo$link1, 1);
}

// create_cache_object
// file object_cache.c line 752
static signed int create_cache_object(struct object_cache *oc, unsigned long int idx, void *buffer, unsigned long int buf_size)
{
  signed int flags = def_open_flags | 0100 | 0200;
  signed int fd;
  signed int ret = 0x8E;
  char path[4096l];
  char tmp_path[4096l];
  snprintf(tmp_path, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x/%016lx.tmp", (const void *)object_cache_dir, oc->vid, idx);
  fd=open(tmp_path, flags, sd_def_fmode);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 17)
    {
      if(sd_log_level == 7)
        log_write(7, "create_cache_object", 764, "%016lx already created", idx);

      goto out;
    }

    if(sd_log_level == 7)
      log_write(7, "create_cache_object", 767, "%m");

    ret = 0x03;
    goto out;
  }

  signed long int return_value_xwrite$2;
  return_value_xwrite$2=xwrite(fd, buffer, buf_size);
  ret = (signed int)return_value_xwrite$2;
  if(!((unsigned long int)ret == buf_size))
  {
    ret = 0x03;
    log_write(3, "create_cache_object", 775, "failed, vid %x, idx %lx", oc->vid, idx);
  }

  else
  {
    snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x/%016lx", (const void *)object_cache_dir, oc->vid, idx);
    ret=link(tmp_path, path);
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 17)
      {
        ret = 0x8E;
        goto out_close;
      }

      if(sd_log_level == 7)
        log_write(7, "create_cache_object", 787, "failed to link %s to %s: %m", (const void *)tmp_path, (const void *)path);

      ret = 0x03;
      goto out_close;
    }

    ret = 0x00;
    if(sd_log_level == 7)
      log_write(7, "create_cache_object", 793, "%016lx size %zu", idx, buf_size);

  }

out_close:
  ;
  close(fd);
  unlink(tmp_path);

out:
  ;
  return ret;
}

// create_client
// file request.c line 894
static struct client_info * create_client(signed int fd, struct cluster_info *cluster)
{
  struct client_info *ci;
  struct sockaddr_storage from;
  unsigned int namesize = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  void *return_value_zalloc$1;
  return_value_zalloc$1=zalloc(sizeof(struct client_info) /*168ul*/ );
  ci = (struct client_info *)return_value_zalloc$1;
  if(ci == ((struct client_info *)NULL))
    return (struct client_info *)(void *)0;

  else
  {
    signed int return_value_getpeername$2;
    return_value_getpeername$2=getpeername(fd, (struct sockaddr *)&from, &namesize);
    if(!(return_value_getpeername$2 == 0))
    {
      free((void *)ci);
      return (struct client_info *)(void *)0;
    }

    else
    {
      switch((signed int)from.ss_family)
      {
        case 2:
        {
          ci->conn.port=ntohs(((struct sockaddr_in *)&from)->sin_port);
          inet_ntop(2, (const void *)&((struct sockaddr_in *)&from)->sin_addr, ci->conn.ipstr, (unsigned int)sizeof(char [46l]) /*46ul*/ );
          break;
        }
        case 10:
        {
          ci->conn.port=ntohs(((struct sockaddr_in6 *)&from)->sin6_port);
          inet_ntop(10, (const void *)&((struct sockaddr_in6 *)&from)->sin6_addr, ci->conn.ipstr, (unsigned int)sizeof(char [46l]) /*46ul*/ );
        }
      }
      ci->conn.fd = fd;
      ci->conn.events = (unsigned int)1;
      refcount_set$link1(&ci->refcnt, 0);
      INIT_LIST_HEAD$link1(&ci->done_reqs);
      return ci;
    }
  }
}

// create_cluster
// file sheep_priv.h line 340
signed int create_cluster(signed int port, signed long int zone, signed int nr_vnodes, _Bool explicit_addr)
{
  signed int ret;
  if(sys->cdrv == ((struct cluster_driver *)NULL))
  {
    sys->cdrv=find_cdrv$link1("corosync");
    if(sd_log_level == 7)
      log_write(7, "create_cluster", 1003, "use %s cluster driver as default", (const void *)"corosync");

  }

  ret=sys->cdrv->init(sys->cdrv_option);
  struct list_head *tmp_statement_expression$3;
  struct list_head *tmp_statement_expression$5;
  if(!(ret >= 0))
    return -1;

  else
    if(explicit_addr == (_Bool)0)
    {
      ret=sys->cdrv->get_local_addr(sys->this_node.nid.addr);
      return -1;
    }

    else
    {
      sys->this_node.nid.port = (unsigned short int)port;
      sys->this_node.nr_vnodes = (unsigned short int)nr_vnodes;
      if(zone == -1l)
      {
        unsigned char *b = sys->this_node.nid.addr + (signed long int)12;
        sys->this_node.zone = (unsigned int)((signed int)b[(signed long int)0] | (signed int)b[(signed long int)1] << 8 | (signed int)b[(signed long int)2] << 16 | (signed int)b[(signed long int)3] << 24);
      }

      else
        sys->this_node.zone = (unsigned int)zone;
      if(sd_log_level == 7)
        log_write(7, "create_cluster", 1025, "zone id = %u", sys->this_node.zone);

      sys->this_node.space = sys->disk_space;
      sys->cinfo.epoch=get_latest_epoch();
      if(!(sys->cinfo.epoch == 0u))
      {
        signed int return_value_epoch_log_read$1;
        return_value_epoch_log_read$1=epoch_log_read(sys->cinfo.epoch, sys->cinfo.nodes, (signed int)sizeof(struct sd_node [6144l]) /*491520ul*/ );
        sys->cinfo.nr_nodes = (signed short int)return_value_epoch_log_read$1;
        if((signed int)sys->cinfo.nr_nodes == -1)
          return -1;

      }

      sys->cinfo.status = (enum sd_status)SD_STATUS_WAIT;
      void *return_value_xzalloc$2;
      return_value_xzalloc$2=xzalloc(sizeof(struct list_head) /*16ul*/ );
      pending_block_list.__val = (struct list_head *)return_value_xzalloc$2;
      tmp_statement_expression$3 = pending_block_list.__val;
      INIT_LIST_HEAD(tmp_statement_expression$3);
      void *return_value_xzalloc$4;
      return_value_xzalloc$4=xzalloc(sizeof(struct list_head) /*16ul*/ );
      pending_notify_list.__val = (struct list_head *)return_value_xzalloc$4;
      tmp_statement_expression$5 = pending_notify_list.__val;
      INIT_LIST_HEAD(tmp_statement_expression$5);
      INIT_LIST_HEAD(&sys->local_req_queue);
      INIT_LIST_HEAD(&sys->req_wait_queue);
      ret=send_join_request();
      if(!(ret == 0))
        return -1;

      else
        return 0;
    }
}

// create_dir_for
// file object_cache.c line 594
static signed int create_dir_for(unsigned int vid)
{
  signed int ret = 0;
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x", (const void *)object_cache_dir, vid);
  signed int return_value_xmkdir$1;
  return_value_xmkdir$1=xmkdir(p, sd_def_dmode);
  if(!(return_value_xmkdir$1 >= 0))
  {
    log_write(3, "create_dir_for", 601, "%s, %m", (const void *)p);
    ret = -1;
  }

  return ret;
}

// create_journal_file
// file journal.c line 61
static signed int create_journal_file(const char *root, const char *name)
{
  signed int fd;
  signed int flags = 010000 | 02 | 01000 | 0100 | 040000;
  char path[4096l];
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", root, name);
  fd=open(path, flags, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
  if(!(fd >= 0))
  {
    log_write(3, "create_journal_file", 69, "open %s %m", name);
    return -1;
  }

  else
  {
    signed int return_value_prealloc$1;
    return_value_prealloc$1=prealloc(fd, (unsigned int)jfile_size);
    if(!(return_value_prealloc$1 >= 0))
    {
      log_write(3, "create_journal_file", 73, "prealloc %s %m", name);
      return -1;
    }

    else
      return fd;
  }
}

// create_listen_port
// file sheep_priv.h line 288
signed int create_listen_port(const char *bindaddr, signed int port)
{
  signed int return_value_create_listen_ports$1;
  static _Bool is_inet_socket = (_Bool)1;
  return_value_create_listen_ports$1=create_listen_ports(bindaddr, port, create_listen_port_fn, (void *)&is_inet_socket);
  return return_value_create_listen_ports$1;
}

// create_listen_port_fn
// file request.c line 1038
static signed int create_listen_port_fn(signed int fd, void *data)
{
  struct listening_fd *new_fd;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct listening_fd) /*24ul*/ );
  new_fd = (struct listening_fd *)return_value_xzalloc$1;
  new_fd->fd = fd;
  list_add_tail$link1(&new_fd->list, &listening_fd_list);
  signed int return_value_register_event$2;
  return_value_register_event$2=register_event$link1(fd, listen_handler, data);
  return return_value_register_event$2;
}

// create_listen_ports
// file ../include/net.h line 51
signed int create_listen_ports(const char *bindaddr, signed int port, signed int (*callback)(signed int, void *), void *data)
{
  char servname[64l];
  signed int fd;
  signed int ret;
  signed int opt;
  signed int success = 0;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *res0;
  memset((void *)servname, 0, sizeof(char [64l]) /*64ul*/ );
  snprintf(servname, sizeof(char [64l]) /*64ul*/ , "%d", port);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = 1;
  hints.ai_flags = 0x0001;
  ret=getaddrinfo(bindaddr, servname, &hints, &res0);
  if(!(ret == 0))
  {
    log_write(3, "create_listen_ports", 81, "failed to get address info: %m");
    return 1;
  }

  else
  {
    res = res0;
    for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
    {
      fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(fd >= 0)
      {
        opt = 1;
        ret=setsockopt(fd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(ret == 0))
          log_write(3, "create_listen_ports", 94, "failed to set SO_REUSEADDR: %m");

        opt = 1;
        if(res->ai_family == 10)
        {
          ret=setsockopt(fd, 41, 26, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
          if(ret == 0)
            goto __CPROVER_DUMP_L4;

          close(fd);
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          ret=bind(fd, res->ai_addr, res->ai_addrlen);
          if(!(ret == 0))
          {
            log_write(3, "create_listen_ports", 108, "failed to bind server socket: %m");
            close(fd);
          }

          else
          {
            ret=listen(fd, 128);
            if(!(ret == 0))
            {
              log_write(3, "create_listen_ports", 115, "failed to listen on server socket: %m");
              close(fd);
            }

            else
            {
              ret=callback(fd, data);
              if(!(ret == 0))
                close(fd);

              else
                success = success + 1;
            }
          }
        }
      }

    }
    freeaddrinfo(res0);
    if(success == 0)
      log_write(3, "create_listen_ports", 132, "failed to create a listening port");

    return (signed int)!(success != 0);
  }
}

// create_ordered_work_queue
// file ../include/work.h line 63
struct work_queue * create_ordered_work_queue(const char *name)
{
  struct work_queue *return_value_create_work_queue$1;
  return_value_create_work_queue$1=create_work_queue(name, (enum wq_thread_control)WQ_ORDERED);
  return return_value_create_work_queue$1;
}

// create_pidfile
// file sheep.c line 194
static signed int create_pidfile(const char *filename)
{
  signed int fd = -1;
  signed int len;
  char buffer[128l];
  fd=open(filename, 02 | 0100 | 04010000, 0600);
  if(fd == -1)
    return -1;

  else
  {
    signed int return_value_lockf$1;
    return_value_lockf$1=lockf(fd, 2, (signed long int)0);
    if(return_value_lockf$1 == -1)
    {
      close(fd);
      return -1;
    }

    else
    {
      signed int return_value_getpid$2;
      return_value_getpid$2=getpid();
      len=snprintf(buffer, sizeof(char [128l]) /*128ul*/ , "%d\n", return_value_getpid$2);
      signed long int return_value_write$3;
      return_value_write$3=write(fd, (const void *)buffer, (unsigned long int)len);
      if(!(return_value_write$3 == (signed long int)len))
      {
        close(fd);
        return -1;
      }

      else
        return 0;
    }
  }
}

// create_unix_domain_socket
// file ../include/net.h line 53
signed int create_unix_domain_socket(const char *unix_path, signed int (*callback)(signed int, void *), void *data)
{
  signed int fd;
  signed int ret;
  struct sockaddr_un addr;
  addr.sun_family = (unsigned short int)1;
  pstrcpy(addr.sun_path, (signed int)sizeof(char [108l]) /*108ul*/ , unix_path);
  fd=socket((signed int)addr.sun_family, 1, 0);
  if(!(fd >= 0))
  {
    log_write(3, "create_unix_domain_socket", 547, "failed to create socket, %m");
    return -1;
  }

  else
  {
    ret=bind(fd, &addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(ret == 0))
      log_write(3, "create_unix_domain_socket", 553, "failed to bind socket: %m");

    else
    {
      ret=listen(fd, 128);
      if(!(ret == 0))
        log_write(3, "create_unix_domain_socket", 559, "failed to listen on socket: %m");

      else
      {
        ret=callback(fd, data);
        if(ret == 0)
          return 0;

      }
    }

  err:
    ;
    close(fd);
    return -1;
  }
}

// create_vdi
// file vdi.c line 264
static signed int create_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid)
{
  struct sd_inode *new;
  new=alloc_inode(iocb, new_snapid, new_vid, (unsigned int *)(void *)0);
  signed int ret;
  if(sd_log_level == 7)
    log_write(7, "create_vdi", 273, "%s: size %lu, new_vid %x, copies %d, snapid %u copy policy %ustore policy %u", iocb->name, iocb->size, new_vid, iocb->nr_copies, new_snapid, new->copy_policy, new->store_policy);

  unsigned long int return_value_vid_to_vdi_oid$1;
  return_value_vid_to_vdi_oid$1=vid_to_vdi_oid(new_vid);
  ret=sd_write_object(return_value_vid_to_vdi_oid$1, (char *)new, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0, (_Bool)1);
  if(!(ret == 0x00))
    ret = 0x0B;

  free((void *)new);
  return ret;
}

// create_vdisks
// file md.c line 90
static void create_vdisks(struct disk *disk)
{
  unsigned long int hval;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(disk->path);
  hval=sd_hash$link1((const void *)disk->path, return_value_strlen$1);
  signed int nr;
  nr=vdisk_number(disk);
  signed int i = 0;
  for( ; !(i >= nr); i = i + 1)
  {
    struct vdisk *v;
    void *return_value_xmalloc$2;
    return_value_xmalloc$2=xmalloc(sizeof(struct vdisk) /*40ul*/ );
    v = (struct vdisk *)return_value_xmalloc$2;
    hval=sd_hash_next$link1(hval);
    v->hash = hval;
    v->disk = disk;
    struct vdisk *return_value_vdisk_insert$3;
    return_value_vdisk_insert$3=vdisk_insert(v);
    if(!(return_value_vdisk_insert$3 == ((struct vdisk *)NULL)))
    {
      log_write(0, "create_vdisks", 102, "PANIC: vdisk hash collison");
      abort();
    }

  }
}

// create_work_queue
// file ../include/work.h line 62
struct work_queue * create_work_queue(const char *name, enum wq_thread_control tc)
{
  signed int ret;
  struct wq_info *wi;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct wq_info) /*264ul*/ );
  wi = (struct wq_info *)return_value_xzalloc$1;
  wi->name = name;
  wi->tc = tc;
  INIT_LIST_HEAD$link3(&wi->q.pending_list);
  INIT_LIST_HEAD$link3(&wi->finished_list);
  sd_cond_init(&wi->pending_cond);
  sd_init_mutex$link2(&wi->finished_lock);
  sd_init_mutex$link2(&wi->pending_lock);
  sd_init_mutex$link2(&wi->startup_lock);
  ret=create_worker_threads(wi, (unsigned long int)1);
  if(ret >= 0)
  {
    list_add(&wi->list, &wq_info_list);
    return &wi->q;
  }

  else
  {

  destroy_threads:
    ;
    sd_mutex_unlock$link4(&wi->startup_lock);
    sd_destroy_cond(&wi->pending_cond);
    sd_destroy_mutex(&wi->pending_lock);
    sd_destroy_mutex(&wi->finished_lock);
    free((void *)wi);
    return (struct work_queue *)(void *)0;
  }
}

// create_work_queues
// file sheep.c line 439
static signed int create_work_queues(void)
{
  signed int return_value_init_work_queue$1;
  return_value_init_work_queue$1=init_work_queue(get_nr_nodes);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(!(return_value_init_work_queue$1 == 0))
    return -1;

  else
  {
    sys->net_wqueue=create_work_queue("net", (enum wq_thread_control)WQ_UNLIMITED);
    sys->gateway_wqueue=create_work_queue("gway", (enum wq_thread_control)WQ_UNLIMITED);
    sys->io_wqueue=create_work_queue("io", (enum wq_thread_control)WQ_UNLIMITED);
    sys->recovery_wqueue=create_ordered_work_queue("rw");
    sys->deletion_wqueue=create_ordered_work_queue("deletion");
    sys->block_wqueue=create_ordered_work_queue("block");
    sys->md_wqueue=create_ordered_work_queue("md");
    sys->areq_wqueue=create_work_queue("async_req", (enum wq_thread_control)WQ_UNLIMITED);
    if(!(sys->enable_object_cache == (_Bool)0))
    {
      sys->oc_reclaim_wqueue=create_ordered_work_queue("oc_reclaim");
      sys->oc_push_wqueue=create_work_queue("oc_push", (enum wq_thread_control)WQ_DYNAMIC);
      if(sys->oc_reclaim_wqueue == ((struct work_queue *)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = !(sys->oc_push_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$2)
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      if(sys->gateway_wqueue == ((struct work_queue *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = !(sys->io_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = !(sys->recovery_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = !(sys->deletion_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = !(sys->block_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = !(sys->md_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = !(sys->areq_wqueue != ((struct work_queue *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        return -1;

      else
        return 0;
    }
  }
}

// create_worker_threads
// file work.c line 249
static signed int create_worker_threads(struct wq_info *wi, unsigned long int nr_threads)
{
  unsigned long int thread;
  signed int ret;
  sd_mutex_lock$link4(&wi->startup_lock);
  while(!(wi->nr_threads >= nr_threads))
  {
    ret=pthread_create(&thread, (const union pthread_attr_t *)(void *)0, worker_routine, (void *)wi);
    if(!(ret == 0))
    {
      log_write(3, "create_worker_threads", 258, "failed to create worker thread: %m");
      sd_mutex_unlock$link4(&wi->startup_lock);
      return -1;
    }

    wi->nr_threads = wi->nr_threads + 1ul;
    if(sd_log_level == 7)
      log_write(7, "create_worker_threads", 263, "create thread %s %zu", wi->name, wi->nr_threads);

  }
  sd_mutex_unlock$link4(&wi->startup_lock);
  return 0;
}

// data_is_missing
// file fec.c line 618
static inline _Bool data_is_missing(const unsigned char **dp, signed int d)
{
  signed int i = 0;
  for( ; !(i >= d); i = i + 1)
    if(dp[(signed long int)i] == ((const unsigned char *)NULL))
      return (_Bool)1;

  return (_Bool)0;
}

// data_oid_to_idx
// file ../include/sheepdog_proto.h line 430
static inline unsigned long int data_oid_to_idx(unsigned long int oid)
{
  return oid & (1ULL << 32) - (unsigned long int)1;
}

// data_oid_to_idx$link1
// file ../include/sheepdog_proto.h line 430
static inline unsigned long int data_oid_to_idx$link1(unsigned long int oid$link1)
{
  return oid$link1 & (1ULL << 32) - (unsigned long int)1;
}

// data_to_str
// file ../include/util.h line 110
const char * data_to_str(void *data, unsigned long int data_length)
{
  data_length = data_length < (unsigned long int)256 ? data_length : (unsigned long int)256;
  if(data == NULL)
    return "(null)";

  else
  {
    void *return_value_memchr$1;
    return_value_memchr$1=memchr(data, 0, data_length);
    if(!(return_value_memchr$1 == NULL))
      return (const char *)data;

    else
      return "(not string)";
  }
}

// decode_prepare
// file fec.c line 591
static inline void decode_prepare(struct fec *ctx, const unsigned char **dp, const unsigned char **out, signed int *outidx)
{
  signed int i;
  signed int p = 0;
  i = (signed int)ctx->d;
  for( ; !(i >= (signed int)ctx->dp); i = i + 1)
    if(!(dp[(signed long int)i] == ((const unsigned char *)NULL)))
    {
      p = i;
      break;
    }

  i = 0;
  for( ; !(i >= (signed int)ctx->d); i = i + 1)
    if(!(dp[(signed long int)i] == ((const unsigned char *)NULL)))
    {
      out[(signed long int)i] = dp[(signed long int)i];
      outidx[(signed long int)i] = i;
    }

    else
    {
      out[(signed long int)i] = dp[(signed long int)p];
      outidx[(signed long int)i] = p;
      do
      {
        p = p + 1;
        if(p >= (signed int)ctx->dp)
          break;

        if(!(dp[(signed long int)p] == ((const unsigned char *)NULL)))
          break;

      }
      while((_Bool)1);
    }
}

// default_cleanup
// file plain_store.c line 196
signed int default_cleanup(void)
{
  signed int ret;
  ret=for_each_obj_path(purge_stale_dir);
  if(!(ret == 0x00))
    return ret;

  else
    return 0x00;
}

// default_create_and_write
// file plain_store.c line 346
signed int default_create_and_write(unsigned long int oid, struct siocb *iocb)
{
  char path[4096l];
  char tmp_path[4096l];
  signed int flags;
  flags=prepare_iocb(oid, iocb, (_Bool)1);
  signed int ret;
  signed int fd;
  unsigned int len = iocb->length;
  unsigned long int obj_size;
  if(sd_log_level == 7)
    log_write(7, "default_create_and_write", 354, "%lx", oid);

  get_store_path(oid, iocb->ec_index, path);
  get_store_tmp_path(oid, iocb->ec_index, tmp_path);
  _Bool return_value_uatomic_is_true$2;
  return_value_uatomic_is_true$2=uatomic_is_true$link1(&sys->use_journal);
  signed int return_value_journal_write_store$1;
  if(!(return_value_uatomic_is_true$2 == (_Bool)0))
  {
    return_value_journal_write_store$1=journal_write_store(oid, (const char *)iocb->buf, (unsigned long int)iocb->length, (signed long int)iocb->offset, (_Bool)1);
    if(!(return_value_journal_write_store$1 == 0x00))
    {
      log_write(3, "default_create_and_write", 362, "turn off journaling");
      uatomic_set_false$link1(&sys->use_journal);
      flags = flags | 010000;
      sync();
    }

  }

  fd=open(tmp_path, flags, sd_def_fmode);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(*return_value___errno_location$3 == 17)
    {
      if(sd_log_level == 7)
        log_write(7, "default_create_and_write", 378, "%s exists", (const void *)tmp_path);

      return 0x00;
    }

    log_write(3, "default_create_and_write", 382, "failed to open %s: %m", (const void *)tmp_path);
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    signed int return_value_err_to_sderr$5;
    return_value_err_to_sderr$5=err_to_sderr(path, oid, *return_value___errno_location$4);
    return return_value_err_to_sderr$5;
  }

  obj_size=get_store_objsize(oid);
  ret=prealloc(fd, (unsigned int)obj_size);
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    ret=err_to_sderr(path, oid, *return_value___errno_location$6);
    goto out;
  }

  signed long int return_value_xpwrite$7;
  return_value_xpwrite$7=xpwrite(fd, iocb->buf, (unsigned long int)len, (signed long int)iocb->offset);
  ret = (signed int)return_value_xpwrite$7;
  if(!((unsigned int)ret == len))
  {
    log_write(3, "default_create_and_write", 395, "failed to write object. %m");
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    ret=err_to_sderr(path, oid, *return_value___errno_location$8);
    goto out;
  }

  ret=rename(tmp_path, path);
  if(!(ret >= 0))
  {
    log_write(3, "default_create_and_write", 402, "failed to rename %s to %s: %m", (const void *)tmp_path, (const void *)path);
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    ret=err_to_sderr(path, oid, *return_value___errno_location$9);
    goto out;
  }

  ret = 0x00;
  objlist_cache_insert(oid);

out:
  ;
  if(!(ret == 0x00))
    unlink(tmp_path);

  close(fd);
  return ret;
}

// default_exist
// file plain_store.c line 78
_Bool default_exist(unsigned long int oid, unsigned char ec_index)
{
  _Bool return_value_md_exist$1;
  return_value_md_exist$1=md_exist(oid, ec_index);
  return return_value_md_exist$1;
}

// default_format
// file plain_store.c line 522
signed int default_format(void)
{
  unsigned int ret;
  if(sd_log_level == 7)
    log_write(7, "default_format", 526, "try get a clean store");

  signed int return_value_for_each_obj_path$1;
  return_value_for_each_obj_path$1=for_each_obj_path(purge_dir);
  ret = (unsigned int)return_value_for_each_obj_path$1;
  if(!(ret == 0u))
    return (signed int)ret;

  else
  {
    if(!(sys->enable_object_cache == (_Bool)0))
      object_cache_format();

    return 0x00;
  }
}

// default_get_hash
// file plain_store.c line 603
signed int default_get_hash(unsigned long int oid, unsigned int epoch, unsigned char *sha1)
{
  signed int ret;
  void *buf;
  struct siocb iocb = { .epoch=0u, .buf=NULL, .length=0u, .offset=0u, .ec_index=0,
    .copy_policy=0 };
  unsigned int length;
  _Bool is_readonly_obj;
  is_readonly_obj=oid_is_readonly(oid);
  char path[4096l];
  ret=get_object_path(oid, epoch, path, sizeof(char [4096l]) /*4096ul*/ );
  const char *return_value_sha1_to_hex$1;
  const char *return_value_sha1_to_hex$4;
  if(!(ret == 0x00))
    return ret;

  else
  {
    if(!(is_readonly_obj == (_Bool)0))
    {
      signed int return_value_get_object_sha1$2;
      return_value_get_object_sha1$2=get_object_sha1(path, sha1);
      if(return_value_get_object_sha1$2 == 0)
      {
        if(sd_log_level == 7)
        {
          return_value_sha1_to_hex$1=sha1_to_hex(sha1);
          log_write(7, "default_get_hash", 619, "use cached sha1 digest %s", return_value_sha1_to_hex$1);
        }

        return 0x00;
      }

    }

    unsigned long int return_value_get_store_objsize$3;
    return_value_get_store_objsize$3=get_store_objsize(oid);
    length = (unsigned int)return_value_get_store_objsize$3;
    buf=valloc((unsigned long int)length);
    if(buf == NULL)
      return 0x12;

    else
    {
      iocb.epoch = epoch;
      iocb.buf = buf;
      iocb.length = length;
      ret=default_read_from_path(oid, path, &iocb);
      if(!(ret == 0x00))
      {
        free(buf);
        return ret;
      }

      else
      {
        get_buffer_sha1((unsigned char *)buf, length, sha1);
        free(buf);
        if(sd_log_level == 7)
        {
          return_value_sha1_to_hex$4=sha1_to_hex(sha1);
          log_write(7, "default_get_hash", 643, "the message digest of %lx at epoch %d is %s", oid, epoch, return_value_sha1_to_hex$4);
        }

        if(!(is_readonly_obj == (_Bool)0))
          set_object_sha1(path, sha1);

        return ret;
      }
    }
  }
}

// default_init
// file plain_store.c line 252
signed int default_init(void)
{
  signed int ret;
  if(sd_log_level == 7)
    log_write(7, "default_init", 256, "use plain store driver");

  ret=for_each_obj_path(make_stale_dir);
  if(!(ret == 0x00))
    return ret;

  else
  {
    for_each_object_in_stale(init_objlist_and_vdi_bitmap, (void *)0);
    signed int return_value_for_each_object_in_wd$1;
    return_value_for_each_object_in_wd$1=for_each_object_in_wd(init_objlist_and_vdi_bitmap, (_Bool)1, (void *)0);
    return return_value_for_each_object_in_wd$1;
  }
}

// default_link
// file plain_store.c line 416
signed int default_link(unsigned long int oid, unsigned int tgt_epoch)
{
  char path[4096l];
  char stale_path[4096l];
  if(sd_log_level == 7)
    log_write(7, "default_link", 421, "try link %lx from snapshot with epoch %d", oid, tgt_epoch);

  const char *return_value_md_get_object_dir$1;
  return_value_md_get_object_dir$1=md_get_object_dir(oid);
  snprintf(path, (unsigned long int)4096, "%s/%016lx", return_value_md_get_object_dir$1, oid);
  get_store_stale_path(oid, tgt_epoch, (unsigned char)0, stale_path);
  signed int return_value_link$5;
  return_value_link$5=link(stale_path, path);
  if(!(return_value_link$5 >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 17))
    {
      if(sd_log_level == 7)
        log_write(7, "default_link", 434, "failed to link from %s to %s, %m", (const void *)stale_path, (const void *)path);

      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      signed int return_value_err_to_sderr$4;
      return_value_err_to_sderr$4=err_to_sderr(path, oid, *return_value___errno_location$3);
      return return_value_err_to_sderr$4;
    }

  }


out:
  ;
  return 0x00;
}

// default_purge_obj
// file plain_store.c line 651
signed int default_purge_obj(void)
{
  unsigned int tgt_epoch;
  tgt_epoch=get_latest_epoch();
  signed int return_value_for_each_object_in_wd$1;
  return_value_for_each_object_in_wd$1=for_each_object_in_wd(move_object_to_stale_dir, (_Bool)1, (void *)&tgt_epoch);
  return return_value_for_each_object_in_wd$1;
}

// default_read
// file plain_store.c line 298
signed int default_read(unsigned long int oid, struct siocb *iocb)
{
  signed int ret;
  char path[4096l];
  get_store_path(oid, iocb->ec_index, path);
  ret=default_read_from_path(oid, path, iocb);
  unsigned int return_value_sys_epoch$1;
  if(ret == 0x02)
  {
    if(iocb->epoch >= 1u)
    {
      return_value_sys_epoch$1=sys_epoch$link4();
      if(!(iocb->epoch >= return_value_sys_epoch$1))
      {
        get_store_stale_path(oid, iocb->epoch, iocb->ec_index, path);
        ret=default_read_from_path(oid, path, iocb);
      }

    }

  }

  return ret;
}

// default_read_from_path
// file plain_store.c line 266
static signed int default_read_from_path(unsigned long int oid, const char *path, struct siocb *iocb)
{
  signed int flags;
  flags=prepare_iocb(oid, iocb, (_Bool)0);
  signed int fd;
  signed int ret = 0x00;
  signed long int size;
  _Bool return_value_is_stale_path$3;
  return_value_is_stale_path$3=is_stale_path(path);
  _Bool return_value_default_exist$2;
  signed int return_value_err_to_sderr$1;
  signed int *return_value___errno_location$4;
  signed int return_value_err_to_sderr$5;
  if(return_value_is_stale_path$3 == (_Bool)0)
  {
    return_value_default_exist$2=default_exist(oid, iocb->ec_index);
    if(return_value_default_exist$2 != (_Bool)0)
      goto __CPROVER_DUMP_L1;

    return_value_err_to_sderr$1=err_to_sderr(path, oid, 2);
    return return_value_err_to_sderr$1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    fd=open(path, flags);
    if(!(fd >= 0))
    {
      return_value___errno_location$4=__errno_location();
      return_value_err_to_sderr$5=err_to_sderr(path, oid, *return_value___errno_location$4);
      return return_value_err_to_sderr$5;
    }

    else
    {
      size=xpread(fd, iocb->buf, (unsigned long int)iocb->length, (signed long int)iocb->offset);
      if(!(size == (signed long int)iocb->length))
      {
        log_write(3, "default_read_from_path", 291, "failed to read object %lx, path=%s, offset=%d, size=%d, result=%zd, %m", oid, path, iocb->offset, iocb->length, size);
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        ret=err_to_sderr(path, oid, *return_value___errno_location$6);
      }

      close(fd);
      return ret;
    }
  }
}

// default_remove_object
// file plain_store.c line 537
signed int default_remove_object(unsigned long int oid, unsigned char ec_index)
{
  char path[4096l];
  _Bool return_value_uatomic_is_true$1;
  return_value_uatomic_is_true$1=uatomic_is_true$link1(&sys->use_journal);
  if(!(return_value_uatomic_is_true$1 == (_Bool)0))
    journal_remove_object(oid);

  get_store_path(oid, ec_index, path);
  signed int return_value_unlink$3;
  return_value_unlink$3=unlink(path);
  if(!(return_value_unlink$3 >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 2)
      return 0x02;

    log_write(3, "default_remove_object", 550, "failed, %s, %m", (const void *)path);
    return 0x03;
  }

  return 0x00;
}

// default_update_epoch
// file plain_store.c line 516
signed int default_update_epoch(unsigned int epoch)
{
  signed int return_value_for_each_object_in_wd$1;
  return_value_for_each_object_in_wd$1=for_each_object_in_wd(check_stale_objects, (_Bool)0, (void *)&epoch);
  return return_value_for_each_object_in_wd$1;
}

// default_write
// file plain_store.c line 119
signed int default_write(unsigned long int oid, struct siocb *iocb)
{
  signed int flags;
  flags=prepare_iocb(oid, iocb, (_Bool)0);
  signed int fd;
  signed int ret = 0x00;
  char path[4096l];
  signed long int size;
  unsigned int return_value_sys_epoch$2;
  return_value_sys_epoch$2=sys_epoch$link4();
  unsigned int return_value_sys_epoch$1;
  signed int return_value_journal_write_store$3;
  signed int return_value_err_to_sderr$5;
  signed int *return_value___errno_location$7;
  signed int return_value_err_to_sderr$8;
  if(!(iocb->epoch >= return_value_sys_epoch$2))
  {
    if(sd_log_level == 7)
    {
      return_value_sys_epoch$1=sys_epoch$link4();
      log_write(7, "default_write", 127, "%u sys %u", iocb->epoch, return_value_sys_epoch$1);
    }

    return 0x81;
  }

  else
  {
    _Bool return_value_uatomic_is_true$4;
    return_value_uatomic_is_true$4=uatomic_is_true$link1(&sys->use_journal);
    if(!(return_value_uatomic_is_true$4 == (_Bool)0))
    {
      return_value_journal_write_store$3=journal_write_store(oid, (const char *)iocb->buf, (unsigned long int)iocb->length, (signed long int)iocb->offset, (_Bool)0);
      if(!(return_value_journal_write_store$3 == 0))
      {
        log_write(3, "default_write", 135, "turn off journaling");
        uatomic_set_false$link1(&sys->use_journal);
        flags = flags | 010000;
        sync();
      }

    }

    get_store_path(oid, iocb->ec_index, path);
    _Bool return_value_default_exist$6;
    return_value_default_exist$6=default_exist(oid, iocb->ec_index);
    if(return_value_default_exist$6 == (_Bool)0)
    {
      return_value_err_to_sderr$5=err_to_sderr(path, oid, 2);
      return return_value_err_to_sderr$5;
    }

    else
    {
      fd=open(path, flags, sd_def_fmode);
      if(!(fd >= 0))
      {
        return_value___errno_location$7=__errno_location();
        return_value_err_to_sderr$8=err_to_sderr(path, oid, *return_value___errno_location$7);
        return return_value_err_to_sderr$8;
      }

      else
      {
        size=xpwrite(fd, iocb->buf, (unsigned long int)iocb->length, (signed long int)iocb->offset);
        if(!(size == (signed long int)iocb->length))
        {
          log_write(3, "default_write", 159, "failed to write object %lx, path=%s, offset=%d, size=%d, result=%zd, %m", oid, (const void *)path, iocb->offset, iocb->length, size);
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          ret=err_to_sderr(path, oid, *return_value___errno_location$9);
          goto out;
        }


      out:
        ;
        close(fd);
        return ret;
      }
    }
  }
}

// del_from_dirty_list
// file object_cache.c line 251
static void del_from_dirty_list(struct object_cache_entry *entry)
{
  struct object_cache *oc = entry->oc;
  list_del$link2(&entry->dirty_list);
  __uatomic_dec$link1((void *)&oc->dirty_count, (signed int)sizeof(unsigned int) /*4ul*/ );
}

// del_requeue_request
// file request.c line 18
static void del_requeue_request(struct request *req)
{
  list_del$link1(&req->request_list);
  requeue_request(req);
}

// delete_cb
// file vdi.c line 820
static void delete_cb(void *data, enum btree_node_type type, void *arg)
{
  struct sd_extent *ext;
  struct delete_arg *darg = (struct delete_arg *)arg;
  unsigned long int oid;
  signed int ret;
  if((signed int)type == BTREE_EXT)
  {
    ext = (struct sd_extent *)data;
    if(!(ext->vdi_id == 0u))
    {
      oid=vid_to_data_oid(ext->vdi_id, (unsigned long int)ext->idx);
      if(!(ext->vdi_id == darg->inode->vdi_id))
      {
        if(sd_log_level == 7)
          log_write(7, "delete_cb", 835, "object %lx is base's data, would not be deleted.", oid);

      }

      else
      {
        ret=sd_remove_object(oid);
        if(!(ret == 0x00))
          log_write(3, "delete_cb", 840, "remove object %lx fail, %d", oid, ret);

        *darg->nr_deleted = *darg->nr_deleted + 1u;
      }
    }

  }

}

// delete_inode
// file vdi.c line 771
static signed int delete_inode(unsigned int vid)
{
  struct sd_inode *inode = (struct sd_inode *)(void *)0;
  signed int ret = 0x00;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xzalloc$1;
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)4664ul, (unsigned long int)0);
  unsigned long int return_value_vid_to_vdi_oid$3;
  if(!(ret == 0x00))
    ret = 0x03;

  else
  {
    memset((void *)inode->name, 0, sizeof(char [256l]) /*256ul*/ );
    return_value_vid_to_vdi_oid$3=vid_to_vdi_oid(vid);
    ret=sd_write_object(return_value_vid_to_vdi_oid$3, (char *)inode, (unsigned int)4664ul, (unsigned long int)0, (_Bool)0);
    if(!(ret == 0))
      ret = 0x03;

  }

out:
  ;
  free((void *)inode);
  return ret;
}

// delete_one_vdi
// file vdi.c line 846
static signed int delete_one_vdi(unsigned int vdi_id)
{
  signed int ret = 0;
  unsigned int i;
  unsigned int nr_deleted;
  unsigned int nr_objs;
  struct sd_inode *inode = (struct sd_inode *)(void *)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_malloc$1;
  _Bool return_value_vdi_is_deleted$3;
  _Bool return_value_vdi_is_deleted$5;
  unsigned long int return_value_vid_to_vdi_oid$6;
  if(inode == ((struct sd_inode *)NULL))
  {
    log_write(3, "delete_one_vdi", 854, "failed to allocate memory");
    return -1;
  }

  else
  {
    unsigned long int return_value_vid_to_vdi_oid$2;
    return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(vdi_id);
    ret=read_backend_object(return_value_vid_to_vdi_oid$2, (char *)(void *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
    if(!(ret == 0x00))
    {
      log_write(3, "delete_one_vdi", 862, "cannot find VDI object");
      ret = -1;
    }

    else
    {
      if(inode->vdi_size == 0ul)
      {
        return_value_vdi_is_deleted$3=vdi_is_deleted(inode);
        if(return_value_vdi_is_deleted$3 != (_Bool)0)
          goto out;

      }

      if((signed int)inode->store_policy == 0)
      {
        unsigned long int return_value_count_data_objs$4;
        return_value_count_data_objs$4=count_data_objs(inode);
        nr_objs = (unsigned int)return_value_count_data_objs$4;
        nr_deleted = (unsigned int)0;
        i = (unsigned int)0;
        for( ; !(i >= nr_objs); i = i + 1u)
        {
          unsigned long int oid;
          unsigned int vid;
          vid=sd_inode_get_vid(sheep_bnode_reader, inode, i);
          if(!(vid == 0u))
          {
            oid=vid_to_data_oid(vid, (unsigned long int)i);
            if(!(vid == inode->vdi_id))
            {
              if(sd_log_level == 7)
                log_write(7, "delete_one_vdi", 883, "object %lx is base's data, would not be deleted.", oid);

            }

            else
            {
              ret=sd_remove_object(oid);
              if(!(ret == 0x00))
                log_write(3, "delete_one_vdi", 890, "remove object %lx fail, %d", oid, ret);

              nr_deleted = nr_deleted + 1u;
            }
          }

        }
      }

      else
      {
        struct delete_arg arg = { .inode=inode, .nr_deleted=&nr_deleted };
        traverse_btree(sheep_bnode_reader, inode, delete_cb, (void *)&arg);
      }
      return_value_vdi_is_deleted$5=vdi_is_deleted(inode);
      if(return_value_vdi_is_deleted$5 == (_Bool)0)
      {
        inode->vdi_size = (unsigned long int)0;
        memset((void *)inode->name, 0, sizeof(char [256l]) /*256ul*/ );
        return_value_vid_to_vdi_oid$6=vid_to_vdi_oid(vdi_id);
        sd_write_object(return_value_vid_to_vdi_oid$6, (char *)(void *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0, (_Bool)0);
        if(!(nr_deleted == 0u))
          notify_vdi_deletion(vdi_id);

      }

    }

  out:
    ;
    free((void *)inode);
    return ret;
  }
}

// delete_vdis_done
// file vdi.c line 930
static void delete_vdis_done(struct work *work)
{
  struct deletion_work *dw;
  struct deletion_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct deletion_work *)((char *)__mptr - (signed long int)0ul);
  dw = tmp_statement_expression$1;
  eventfd_xwrite(dw->finish_fd, 1);
  free((void *)dw->delete_vid_array);
  free((void *)dw);
}

// delete_vdis_work
// file vdi.c line 915
static void delete_vdis_work(struct work *work)
{
  struct deletion_work *dw;
  struct deletion_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct deletion_work *)((char *)__mptr - (signed long int)0ul);
  dw = tmp_statement_expression$1;
  signed int i = 0;
  for( ; !(i >= dw->delete_vid_count); i = i + 1)
  {
    signed int ret;
    ret=delete_one_vdi(dw->delete_vid_array[(signed long int)i]);
    if(!(ret >= 0))
      log_write(3, "delete_vdis_work", 926, "deleting VDI %x failed", dw->delete_vid_array[(signed long int)i]);

  }
}

// destroy_all_slots
// file sockfd_cache.c line 141
static inline void destroy_all_slots(struct sockfd_cache_entry *entry)
{
  signed int i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    if(!((entry->fds + (signed long int)i)->fd == -1))
      close((entry->fds + (signed long int)i)->fd);

}

// destroy_client
// file request.c line 865
static void destroy_client(struct client_info *ci)
{
  if(sd_log_level == 7)
    log_write(7, "destroy_client", 867, "connection from: %s:%d", (const void *)ci->conn.ipstr, ci->conn.port);

  close(ci->conn.fd);
  free((void *)ci);
}

// disk_cmp
// file md.c line 62
static signed int disk_cmp(struct disk *d1, struct disk *d2)
{
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(d1->path, d2->path);
  return return_value_strcmp$1;
}

// do_background_push
// file object_cache.c line 222
static void do_background_push(struct work *work)
{
  struct push_work *pw;
  struct push_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct push_work *)((char *)__mptr - (signed long int)0ul);
  pw = tmp_statement_expression$1;
  struct object_cache *oc = pw->oc;
  signed int return_value_sd_mutex_trylock$2;
  return_value_sd_mutex_trylock$2=sd_mutex_trylock$link1(&oc->push_mutex);
  if(!(return_value_sd_mutex_trylock$2 == 16))
  {
    object_cache_push(oc);
    sd_mutex_unlock$link3(&oc->push_mutex);
  }

}

// do_epoch_log_read
// file store.c line 44
static signed int do_epoch_log_read(unsigned int epoch, struct sd_node *nodes, signed int len, signed long int *timestamp)
{
  signed int fd;
  signed int ret;
  signed int do_epoch_log_read$$1$$nr_nodes;
  char path[4096l];
  struct stat epoch_stat;
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s%08u", epoch_path, epoch);
  fd=open(path, 00);
  signed long int return_value_xread$1;
  if(!(fd >= 0))
  {
    if(sd_log_level == 7)
      log_write(7, "do_epoch_log_read", 54, "failed to open epoch %u log, %m", epoch);

  }

  else
  {
    memset((void *)&epoch_stat, 0, sizeof(struct stat) /*144ul*/ );
    ret=fstat(fd, &epoch_stat);
    if(!(ret >= 0))
      log_write(3, "do_epoch_log_read", 61, "failed to stat epoch %u log, %m", epoch);

    else
      if(!((unsigned long int)len >= (unsigned long int)epoch_stat.st_size + 18446744073709551608ul))
        log_write(3, "do_epoch_log_read", 66, "invalid epoch %u log", epoch);

      else
      {
        return_value_xread$1=xread(fd, (void *)nodes, (unsigned long int)epoch_stat.st_size - sizeof(signed long int) /*8ul*/ );
        ret = (signed int)return_value_xread$1;
        if(!(ret >= 0))
          log_write(3, "do_epoch_log_read", 72, "failed to read epoch %u log, %m", epoch);

        else
          if(!((unsigned long int)ret % sizeof(struct sd_node) /*80ul*/  == 0ul))
            log_write(3, "do_epoch_log_read", 78, "invalid epoch %u log", epoch);

          else
          {
            do_epoch_log_read$$1$$nr_nodes = (signed int)((unsigned long int)ret / sizeof(struct sd_node) /*80ul*/ );
            if(!(timestamp == ((signed long int *)NULL)))
            {
              signed long int return_value_xread$2;
              return_value_xread$2=xread(fd, (void *)timestamp, sizeof(signed long int) /*8ul*/ );
              ret = (signed int)return_value_xread$2;
              if(!((unsigned long int)ret == sizeof(signed long int) /*8ul*/ ))
              {
                log_write(3, "do_epoch_log_read", 87, "invalid epoch %u log", epoch);
                goto err;
              }

            }

            close(fd);
            return do_epoch_log_read$$1$$nr_nodes;
          }
      }
  }

err:
  ;
  if(fd >= 0)
    close(fd);

  return -1;
}

// do_event_loop
// file event.c line 190
static void do_event_loop(signed int timeout, _Bool sort_with_prio)
{
  signed int i;
  signed int nr;

refresh:
  ;
  event_loop_refresh = (_Bool)0;
  nr=epoll_wait(efd, events, nr_events, timeout);
  if(!(sort_with_prio == (_Bool)0))
  {
    if(nr >= 2)
      qsort((void *)events, (unsigned long int)nr, sizeof(struct epoll_event) /*12ul*/ , (signed int (*)(const void *, const void *))epoll_event_cmp);

  }

  if(!(nr >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 4)
      goto __CPROVER_DUMP_L7;

    log_write(3, "do_event_loop", 203, "epoll_wait failed: %m");
    exit(1);
  }

  else
    if(!(nr == 0))
    {
      i = 0;
      if(!(i >= nr))
      {
        struct event_info *ei = (struct event_info *)(events + (signed long int)i)->data.ptr;
        ei->handler(ei->fd, (signed int)(events + (signed long int)i)->events, ei->data);
        i = i + 1;
      }

    }


__CPROVER_DUMP_L7:
  ;
}

// do_get_vdis
// file group.c line 486
static void do_get_vdis(struct work *work)
{
  struct get_vdis_work *w;
  struct get_vdis_work *tmp_statement_expression$1;
  const struct work *do_get_vdis$$1$$1$$__mptr = work;
  tmp_statement_expression$1 = (struct get_vdis_work *)((char *)do_get_vdis$$1$$1$$__mptr - (signed long int)0ul);
  w = tmp_statement_expression$1;
  struct sd_node *n;
  signed int ret;
  _Bool return_value_node_is_local$4;
  return_value_node_is_local$4=node_is_local(&w->joined);
  const char *return_value_node_to_str$2;
  const char *return_value_node_to_str$3;
  if(return_value_node_is_local$4 == (_Bool)0)
  {
    if(sd_log_level == 7)
    {
      return_value_node_to_str$2=node_to_str(&w->joined);
      log_write(7, "do_get_vdis", 495, "try to get vdi bitmap from %s", return_value_node_to_str$2);
    }

    ret=get_vdis_from(&w->joined);
    if(!(ret == 0x00))
    {
      return_value_node_to_str$3=node_to_str(&w->joined);
      log_write(1, "do_get_vdis", 499, "failed to get vdi bitmap from %s", return_value_node_to_str$3);
    }

    goto __CPROVER_DUMP_L13;
  }

  struct rb_node *__p503;
  __p503=rb_first(&w->nroot);
  struct rb_node *__n503;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  struct sd_node *tmp_statement_expression$6;
  const char *return_value_node_to_str$9;
  do
  {
    if(!(__p503 == ((struct rb_node *)NULL)))
    {
      __n503=rb_next(__p503);
      tmp_if_expr$5 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      const struct rb_node *__mptr = __p503;
      tmp_statement_expression$6 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$6;
      tmp_if_expr$7 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$7 = (_Bool)0;
    if(!tmp_if_expr$7)
      break;

    _Bool return_value_node_is_local$8;
    return_value_node_is_local$8=node_is_local(n);
    if(return_value_node_is_local$8 == (_Bool)0)
    {
      if(sd_log_level == 7)
      {
        return_value_node_to_str$9=node_to_str(n);
        log_write(7, "do_get_vdis", 508, "try to get vdi bitmap from %s", return_value_node_to_str$9);
      }

      ret=get_vdis_from(n);
      if(!(ret == 0x00))
      {
        const char *return_value_node_to_str$10;
        return_value_node_to_str$10=node_to_str(n);
        log_write(1, "do_get_vdis", 513, "failed to get vdi bitmap from %s", return_value_node_to_str$10);
        goto __CPROVER_DUMP_L11;
      }

    }


  __CPROVER_DUMP_L11:
    ;
    __p503 = __n503;
  }
  while((_Bool)1);

__CPROVER_DUMP_L13:
  ;
}

// do_grow_fds
// file sockfd_cache.c line 247
static void do_grow_fds(struct work *work)
{
  struct sockfd_cache_entry *entry;
  signed int old_fds_count;
  signed int new_fds_count;
  signed int new_size;
  signed int i;
  if(sd_log_level == 7)
    log_write(7, "do_grow_fds", 252, "%d", fds_count);

  sd_write_lock$link4(&sockfd_cache.lock);
  old_fds_count = fds_count;
  new_fds_count = fds_count * 2;
  new_size = (signed int)(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count * (unsigned long int)2);
  struct rb_node *__p257;
  __p257=rb_first(&sockfd_cache.root);
  struct rb_node *__n257;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sockfd_cache_entry *tmp_statement_expression$2;
  do
  {
    if(!(__p257 == ((struct rb_node *)NULL)))
    {
      __n257=rb_next(__p257);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p257;
      tmp_statement_expression$2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
      entry = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    void *return_value_xrealloc$4;
    return_value_xrealloc$4=xrealloc((void *)entry->fds, (unsigned long int)new_size);
    entry->fds = (struct sockfd_cache_fd *)return_value_xrealloc$4;
    i = old_fds_count;
    for( ; !(i >= new_fds_count); i = i + 1)
    {
      (entry->fds + (signed long int)i)->fd = -1;
      uatomic_set_false$link2(&(entry->fds + (signed long int)i)->in_use);
    }
    __p257 = __n257;
  }
  while((_Bool)1);
  fds_count = fds_count * 2;
  fds_high_watermark = (fds_count * 3) / 4;
  sd_rw_unlock$link4(&sockfd_cache.lock);
}

// do_nothing
// file util.c line 28
static void do_nothing(unsigned long int size)
{
  ;
}

// do_plug_unplug
// file md.c line 755
static signed int do_plug_unplug(char *disks, _Bool plug)
{
  const char *path;
  signed int old_nr;
  signed int ret = 0x01;
  sd_write_lock$link3(&md.lock);
  old_nr = (signed int)md.nr_disks;
  path=strtok(disks, ",");
  while((_Bool)1)
  {
    if(!(plug == (_Bool)0))
    {
      _Bool return_value_md_add_disk$1;
      return_value_md_add_disk$1=md_add_disk(path, (_Bool)1);
      if(return_value_md_add_disk$1 == (_Bool)0)
        log_write(3, "do_plug_unplug", 766, "failed to add %s", path);

    }

    else
      md_del_disk(path);
    path=strtok((char *)(void *)0, ",");
    if(path == ((const char *)NULL))
      break;

  }
  if(!((unsigned int)old_nr == md.nr_disks))
    ret = 0x00;


out:
  ;
  sd_rw_unlock$link3(&md.lock);
  if(ret == 0x00)
    kick_recover();

  return ret;
}

// do_process_main
// file sheep_priv.h line 423
signed int do_process_main(struct sd_op_template *op, struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int return_value;
  return_value=op->process_main(req, rsp, data);
  return return_value;
}

// do_process_work
// file sheep_priv.h line 422
void do_process_work(struct work *work)
{
  struct request *req;
  struct request *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)192ul);
  req = tmp_statement_expression$1;
  signed int ret = 0x00;
  if(sd_log_level == 7)
    log_write(7, "do_process_work", 1428, "%x, %lx, %u", req->rq.opcode, req->rq.$anon0.obj.oid, req->rq.epoch);

  if(!(req->op->process_work == ((signed int (*)(struct request *))NULL)))
    ret=req->op->process_work(req);

  const char *return_value_sd_strerror$2;
  if(!(ret == 0x00))
  {
    if(sd_log_level == 7)
    {
      return_value_sd_strerror$2=sd_strerror$link5(ret);
      log_write(7, "do_process_work", 1435, "failed: %x, %lx , %u, %s", req->rq.opcode, req->rq.$anon0.obj.oid, req->rq.epoch, return_value_sd_strerror$2);
    }

  }

  req->rp.$anon0.result = (unsigned int)ret;
}

// do_push_object
// file object_cache.c line 844
static void do_push_object(struct work *work)
{
  struct push_work *pw;
  struct push_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct push_work *)((char *)__mptr - (signed long int)0ul);
  pw = tmp_statement_expression$1;
  struct object_cache_entry *entry = pw->entry;
  struct object_cache *oc = entry->oc;
  unsigned long int oid;
  unsigned long int return_value_entry_idx$2;
  return_value_entry_idx$2=entry_idx(entry);
  oid=idx_to_oid(oc->vid, return_value_entry_idx$2);
  if(sd_log_level == 7)
    log_write(7, "do_push_object", 851, "%lx", oid);

  read_lock_entry(entry);
  unsigned long int return_value_entry_idx$3;
  return_value_entry_idx$3=entry_idx(entry);
  unsigned long int return_value_idx_to_oid$4;
  return_value_idx_to_oid$4=idx_to_oid(oc->vid, return_value_entry_idx$3);
  _Bool return_value_oid_is_readonly$5;
  return_value_oid_is_readonly$5=oid_is_readonly(return_value_idx_to_oid$4);
  unsigned long int return_value_entry_idx$6;
  signed int return_value_push_cache_object$7;
  if(return_value_oid_is_readonly$5 == (_Bool)0)
  {
    return_value_entry_idx$6=entry_idx(entry);
    return_value_push_cache_object$7=push_cache_object(oc->vid, return_value_entry_idx$6, entry->bmap, !(!((entry->idx & 1UL << 59) != 0ul)));
    if(!(return_value_push_cache_object$7 == 0x00))
    {
      log_write(0, "do_push_object", 866, "PANIC: push failed but should never fail");
      abort();
    }

  }


clean:
  ;
  unsigned long int return_value___uatomic_add_return$8;
  return_value___uatomic_add_return$8=__uatomic_add_return$link2((void *)&oc->push_count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(unsigned int) /*4ul*/ );
  if((unsigned int)return_value___uatomic_add_return$8 == 0u)
    eventfd_xwrite(oc->push_efd, 1);

  entry->idx = entry->idx & ~(1UL << 59);
  entry->bmap = (unsigned long int)0;
  unlock_entry(entry);
  if(sd_log_level == 7)
    log_write(7, "do_push_object", 874, "%lx done", oid);

  put_cache_entry(entry);
}

// do_read
// file ../include/net.h line 42
signed int do_read(signed int sockfd, void *buf, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  signed int repeat = (signed int)max_count;
  signed long int return_value_read$1;
  _Bool tmp_if_expr$3;
  _Bool return_value;
  do
  {

  reread:
    ;
    return_value_read$1=read(sockfd, buf, (unsigned long int)len);
    ret = (signed int)return_value_read$1;
    if(ret == 0)
    {
      if(sd_log_level == 7)
        log_write(7, "do_read", 220, "connection is closed (%d bytes left)", len);

      return 1;
    }

    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 4)
        goto reread;

      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(*return_value___errno_location$4 == 11)
      {
        if(!(repeat == 0))
        {
          if(need_retry == ((_Bool (*)(unsigned int))NULL))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value=need_retry(epoch);
            tmp_if_expr$3 = return_value != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
          {
            repeat = repeat - 1;
            goto reread;
          }

        }

      }

      log_write(3, "do_read", 236, "failed to read from socket: %d, %m", ret);
      return 1;
    }

    len = len - ret;
    buf = (void *)((char *)buf + (signed long int)ret);
  }
  while(!(len == 0));
  return 0;
}

// do_reclaim
// file object_cache.c line 555
static void do_reclaim(struct work *work)
{
  struct reclaim_work *rw;
  struct reclaim_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct reclaim_work *)((char *)__mptr - (signed long int)0ul);
  rw = tmp_statement_expression$1;
  struct object_cache *cache;
  struct hlist_node *node;
  signed int i;
  signed int j;
  if(!(rw->delay == 0))
    sleep((unsigned int)rw->delay);

  signed long int return_value_random$2;
  return_value_random$2=random();
  j = (signed int)return_value_random$2;
  i = 0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  struct object_cache *tmp_statement_expression$4;
  volatile unsigned int tmp_statement_expression$6;
  for( ; !(i >= 32); i = i + 1)
  {
    signed int idx = (i + j) % (1 << 5);
    struct hlist_head *head = cache_hashtable + (signed long int)idx;
    sd_read_lock$link1(&hashtable_lock[(signed long int)idx]);
    struct hlist_node *__n571;
    node = head->first;
    __n571 = (struct hlist_node *)(void *)0;
    do
    {
      if(!(node == ((struct hlist_node *)NULL)))
      {
        __n571 = node->next;
        tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        const struct hlist_node *do_reclaim$$1$$2$$1$$1$$1$$__mptr = node;
        tmp_statement_expression$4 = (struct object_cache *)((char *)do_reclaim$$1$$2$$1$$1$$1$$__mptr - (signed long int)16ul);
        cache = tmp_statement_expression$4;
        tmp_if_expr$5 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      unsigned int cap;
      do_reclaim_object(cache);
      asm("" :  :  : "memory");
      tmp_statement_expression$6 = *((volatile unsigned int *)&(*(&gcache.capacity)));
      cap = tmp_statement_expression$6;
      if((9u * sys->object_cache_size) / 10u >= cap)
      {
        sd_rw_unlock$link1(&hashtable_lock[(signed long int)idx]);
        if(sd_log_level == 7)
          log_write(7, "do_reclaim", 578, "complete, capacity %u", cap);

        goto __CPROVER_DUMP_L13;
      }

      node = __n571;
    }
    while((_Bool)1);
    sd_rw_unlock$link1(&hashtable_lock[(signed long int)idx]);
  }
  if(sd_log_level == 7)
    log_write(7, "do_reclaim", 584, "finished");


__CPROVER_DUMP_L13:
  ;
}

// do_reclaim_object
// file object_cache.c line 515
static void do_reclaim_object(struct object_cache *oc)
{
  struct object_cache_entry *entry;
  unsigned long int oid;
  unsigned int cap;
  write_lock_cache(oc);
  struct object_cache_entry *__n522;
  struct object_cache_entry *tmp_statement_expression$1;
  const struct list_node *__mptr = (&oc->lru_head)->n.next;
  tmp_statement_expression$1 = (struct object_cache_entry *)((char *)__mptr - (signed long int)72ul);
  entry = tmp_statement_expression$1;
  struct object_cache_entry *tmp_statement_expression$2;
  const struct list_node *do_reclaim_object$$1$$1$$2$$__mptr = entry->lru_list.next;
  tmp_statement_expression$2 = (struct object_cache_entry *)((char *)do_reclaim_object$$1$$1$$2$$__mptr - (signed long int)72ul);
  __n522 = tmp_statement_expression$2;
  _Bool return_value_oid_is_readonly$6;
  struct object_cache_entry *tmp_statement_expression$3;
  for( ; !(&entry->lru_list == &(&oc->lru_head)->n); __n522 = tmp_statement_expression$3)
  {
    unsigned long int return_value_entry_idx$4;
    return_value_entry_idx$4=entry_idx(entry);
    oid=idx_to_oid(oc->vid, return_value_entry_idx$4);
    _Bool return_value_entry_in_use$5;
    return_value_entry_in_use$5=entry_in_use(entry);
    if(!(return_value_entry_in_use$5 == (_Bool)0))
    {
      if(sd_log_level == 7)
        log_write(7, "do_reclaim_object", 525, "%lx is in use, skip...", oid);

    }

    else
    {
      _Bool return_value_entry_is_dirty$7;
      return_value_entry_is_dirty$7=entry_is_dirty(entry);
      if(!(return_value_entry_is_dirty$7 == (_Bool)0))
      {
        return_value_oid_is_readonly$6=oid_is_readonly(oid);
        if(return_value_oid_is_readonly$6 != (_Bool)0)
          goto __CPROVER_DUMP_L5;

        if(sd_log_level == 7)
          log_write(7, "do_reclaim_object", 536, "%lx is dirty, skip...", oid);

      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        unsigned long int return_value_entry_idx$8;
        return_value_entry_idx$8=entry_idx(entry);
        signed int return_value_remove_cache_object$9;
        return_value_remove_cache_object$9=remove_cache_object(oc, return_value_entry_idx$8);
        if(return_value_remove_cache_object$9 == 0x00)
        {
          free_cache_entry(entry);
          unsigned long int return_value___uatomic_add_return$10;
          return_value___uatomic_add_return$10=__uatomic_add_return$link2((void *)&gcache.capacity, (unsigned long int)-((unsigned long int)(((1UL << 22) / (unsigned long int)1024) / (unsigned long int)1024)), (signed int)sizeof(unsigned int) /*4ul*/ );
          cap = (unsigned int)return_value___uatomic_add_return$10;
          if(sd_log_level == 7)
            log_write(7, "do_reclaim_object", 543, "%lx reclaimed. capacity:%d", oid, cap);

          if((9u * sys->object_cache_size) / 10u >= cap)
            break;

        }

      }
    }
    entry = __n522;
    const struct list_node *do_reclaim_object$$1$$1$$3$$__mptr = __n522->lru_list.next;
    tmp_statement_expression$3 = (struct object_cache_entry *)((char *)do_reclaim_object$$1$$1$$3$$__mptr - (signed long int)72ul);
  }
  unlock_cache(oc);
}

// do_recover
// file journal.c line 190
static signed int do_recover(signed int fd)
{
  struct journal_descriptor *jd;
  void *map;
  char *p;
  char *end;
  struct stat st;
  signed int return_value_fstat$1;
  return_value_fstat$1=fstat(fd, &st);
  signed int return_value_replay_journal_entry$3;
  if(!(return_value_fstat$1 >= 0))
  {
    log_write(3, "do_recover", 198, "fstat %m");
    return -1;
  }

  else
    if(st.st_size == 0l)
    {
      close(fd);
      return 0;
    }

    else
    {
      map=mmap((void *)0, (unsigned long int)st.st_size, 0x1, 0x02, fd, (signed long int)0);
      close(fd);
      if(map == (void *)-1)
      {
        log_write(3, "do_recover", 215, "%m");
        return -1;
      }

      else
      {
        end = (char *)map + st.st_size;
        p = (char *)map;
        while(!(p >= end))
        {
          jd = (struct journal_descriptor *)p;
          if(!(jd->magic == 0xfee1900d))
            p = p + (signed long int)(1U << 9);

          else
          {
            _Bool return_value_journal_entry_full_write$2;
            return_value_journal_entry_full_write$2=journal_entry_full_write(jd);
            if(!(return_value_journal_entry_full_write$2 == (_Bool)0))
            {
              return_value_replay_journal_entry$3=replay_journal_entry(jd);
              if(!(return_value_replay_journal_entry$3 >= 0))
                return -1;

            }


          skip:
            ;
            p = p + (signed long int)((unsigned long int)(508 + 4) + ((jd->size + (unsigned long int)(1U << 9)) - (unsigned long int)1 & (unsigned long int)~((1U << 9) - (unsigned int)1)));
          }
        }
        munmap(map, (unsigned long int)st.st_size);
        sync();
        return 0;
      }
    }
}

// do_recover_object
// file recovery.c line 509
static signed int do_recover_object(struct recovery_obj_work *row)
{
  unsigned long int oid = row->oid;
  _Bool return_value_is_erasure_oid$3;
  return_value_is_erasure_oid$3=is_erasure_oid(oid);
  signed int return_value_recover_erasure_object$1;
  signed int return_value_recover_replication_object$2;
  if(!(return_value_is_erasure_oid$3 == (_Bool)0))
  {
    return_value_recover_erasure_object$1=recover_erasure_object(row);
    return return_value_recover_erasure_object$1;
  }

  else
  {
    return_value_recover_replication_object$2=recover_replication_object(row);
    return return_value_recover_replication_object$2;
  }
}

// do_write
// file net.c line 261
static signed int do_write(signed int sockfd, struct msghdr *msg, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  signed int repeat = (signed int)max_count;
  signed long int return_value_sendmsg$1;
  _Bool tmp_if_expr$3;
  _Bool return_value;
  do
  {

  rewrite:
    ;
    return_value_sendmsg$1=sendmsg(sockfd, msg, 0);
    ret = (signed int)return_value_sendmsg$1;
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 4)
        goto rewrite;

      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(*return_value___errno_location$4 == 11)
      {
        if(!(repeat == 0))
        {
          if(need_retry == ((_Bool (*)(unsigned int))NULL))
            tmp_if_expr$3 = (_Bool)1;

          else
          {
            return_value=need_retry(epoch);
            tmp_if_expr$3 = return_value != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$3)
          {
            repeat = repeat - 1;
            goto rewrite;
          }

        }

      }

      log_write(3, "do_write", 281, "failed to write to socket: %m");
      return 1;
    }

    len = len - ret;
    if(len == 0)
      break;

    forward_iov(msg, ret);
  }
  while((_Bool)1);
  return 0;
}

// do_writev2
// file net.c line 587
signed int do_writev2(signed int fd, void *hdr, unsigned long int hdr_len, void *body, unsigned long int body_len)
{
  struct iovec iov[2l];
  iov[(signed long int)0].iov_base = hdr;
  iov[(signed long int)0].iov_len = hdr_len;
  iov[(signed long int)1].iov_base = body;
  iov[(signed long int)1].iov_len = body_len;
  signed long int return_value_writev$1;
  return_value_writev$1=writev(fd, iov, 2);
  return (signed int)return_value_writev$1;
}

// dolog
// file logger.c line 395
static void dolog(signed int prio, const char *func, signed int line, const char *fmt, void **ap)
{
  char buf[(signed long int)(sizeof(struct logmsg) * 12 + 56) /*1112l*/ ];
  char *str = buf + (signed long int)sizeof(struct logmsg) /*88ul*/ ;
  struct logmsg *msg = (struct logmsg *)buf;
  signed int len = 0;
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  len=vsnprintf(str, (unsigned long int)1024, fmt, ap);
  signed int tmp_statement_expression$1;
  signed int tmp_post$4;
  if(!(len >= 0))
    syslog(3, "vsnprintf failed");

  else
  {
    signed int _x = len;
    signed int _y = 1024 - 1;
    (void)(&_x == &_y);
    tmp_statement_expression$1 = _x < _y ? _x : _y;
    msg->str_len = (unsigned long int)tmp_statement_expression$1;
    if(!(la == ((struct logarea *)NULL)))
    {
      struct sembuf ops;
      ops.sem_num = (unsigned short int)0;
      ops.sem_flg = (signed short int)0x1000;
      ops.sem_op = (signed short int)-1;
      signed int return_value_semop$2;
      return_value_semop$2=semop(la->semid, &ops, (unsigned long int)1);
      if(!(return_value_semop$2 >= 0))
      {
        syslog(3, "semop up failed: %m");
        goto __CPROVER_DUMP_L8;
      }

      if(!((unsigned long int)(la->end - la->tail) >= 89ul + (unsigned long int)len))
        syslog(3, "enqueue: log area overrun, dropping message\n");

      else
      {
        msg = (struct logmsg *)la->tail;
        init_logmsg(msg, &tv, prio, func, line);
        memcpy((void *)msg->str, (const void *)str, (unsigned long int)(len + 1));
        msg->str_len = (unsigned long int)len;
        la->tail = la->tail + (signed long int)(sizeof(struct logmsg) /*88ul*/  + (unsigned long int)len + (unsigned long int)1);
      }
      ops.sem_op = (signed short int)1;
      signed int return_value_semop$3;
      return_value_semop$3=semop(la->semid, &ops, (unsigned long int)1);
      if(!(return_value_semop$3 >= 0))
      {
        syslog(3, "semop down failed: %m");
        goto __CPROVER_DUMP_L8;
      }

    }

    else
    {
      char str_final[1024l];
      init_logmsg(msg, &tv, prio, func, line);
      len=format->formatter(str_final, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, msg, (_Bool)1);
      tmp_post$4 = len;
      len = len + 1;
      str_final[(signed long int)tmp_post$4] = (char)10;
      signed int return_value_fileno$5;
      return_value_fileno$5=fileno(stderr);
      xwrite(return_value_fileno$5, (const void *)str_final, (unsigned long int)len);
      fflush(stderr);
    }
  }

__CPROVER_DUMP_L8:
  ;
}

// dump_btree
// file sd_inode.c line 209
static void dump_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode)
{
  ;
}

// dump_stack_frames
// file logger.c line 800
static signed int dump_stack_frames(void)
{
  signed int return_value_gdb_cmd$1;
  return_value_gdb_cmd$1=gdb_cmd("thread apply all where full");
  return return_value_gdb_cmd$1;
}

// early_log_init
// file ../include/logger.h line 39
void early_log_init(const char *format_name, struct logger_user_info *user_info)
{
  struct log_format *f;
  logger_user_info = user_info;
  struct log_format *__n640;
  struct log_format *tmp_statement_expression$1;
  const struct list_node *early_log_init$$1$$1$$1$$__mptr = (&log_formats)->n.next;
  tmp_statement_expression$1 = (struct log_format *)((char *)early_log_init$$1$$1$$1$$__mptr - (signed long int)16ul);
  f = tmp_statement_expression$1;
  struct log_format *tmp_statement_expression$2;
  const struct list_node *early_log_init$$1$$1$$2$$__mptr = f->list.next;
  tmp_statement_expression$2 = (struct log_format *)((char *)early_log_init$$1$$1$$2$$__mptr - (signed long int)16ul);
  __n640 = tmp_statement_expression$2;
  struct log_format *tmp_statement_expression$3;
  for( ; !(&f->list == &(&log_formats)->n); __n640 = tmp_statement_expression$3)
  {
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(f->name, format_name);
    if(return_value_strcmp$4 == 0)
    {
      format = f;
      goto __CPROVER_DUMP_L6;
    }

    f = __n640;
    const struct list_node *early_log_init$$1$$1$$3$$__mptr = __n640->list.next;
    tmp_statement_expression$3 = (struct log_format *)((char *)early_log_init$$1$$1$$3$$__mptr - (signed long int)16ul);
  }
  log_write(3, "early_log_init", 647, "invalid log format: %s", format_name);
  log_write(3, "early_log_init", 648, "valid options are:");
  struct log_format *__n649;
  struct log_format *tmp_statement_expression$5;
  const struct list_node *early_log_init$$1$$2$$1$$__mptr = (&log_formats)->n.next;
  tmp_statement_expression$5 = (struct log_format *)((char *)early_log_init$$1$$2$$1$$__mptr - (signed long int)16ul);
  f = tmp_statement_expression$5;
  struct log_format *tmp_statement_expression$6;
  const struct list_node *__mptr = f->list.next;
  tmp_statement_expression$6 = (struct log_format *)((char *)__mptr - (signed long int)16ul);
  __n649 = tmp_statement_expression$6;
  struct log_format *tmp_statement_expression$7;
  for( ; !(&f->list == &(&log_formats)->n); __n649 = tmp_statement_expression$7)
  {
    log_write(3, "early_log_init", 650, "\t%s", f->name);
    f = __n649;
    const struct list_node *early_log_init$$1$$2$$3$$__mptr = __n649->list.next;
    tmp_statement_expression$7 = (struct log_format *)((char *)early_log_init$$1$$2$$3$$__mptr - (signed long int)16ul);
  }
  exit(1);

__CPROVER_DUMP_L6:
  ;
}

// ec_decode
// file fec.c line 635
void ec_decode(struct fec *ctx, const unsigned char **input, const signed int *inidx, unsigned char *output, signed int idx)
{
  signed int edp = (signed int)ctx->dp;
  signed int ep = (signed int)ctx->dp - (signed int)ctx->d;
  signed int ed = (signed int)ctx->d;
  const signed long int ed$array_size0 = (signed long int)edp;
  const unsigned char *dp[ed$array_size0];
  const signed long int dp$array_size0 = (signed long int)ed;
  const unsigned char *oin[dp$array_size0];
  const signed long int oin$array_size0 = (signed long int)ed;
  signed int oidx[oin$array_size0];
  signed int i;
  signed int strip_size = 1024 / ed;
  const signed long int strip_size$array_size0 = (signed long int)strip_size;
  const signed long int m0$array_size0 = (signed long int)strip_size;
  const signed long int m1$array_size0 = (signed long int)strip_size;
  const signed long int m2$array_size0 = (signed long int)strip_size;
  const signed long int m3$array_size0 = (signed long int)strip_size;
  const signed long int m4$array_size0 = (signed long int)strip_size;
  const signed long int m5$array_size0 = (signed long int)strip_size;
  const signed long int m6$array_size0 = (signed long int)strip_size;
  const signed long int m7$array_size0 = (signed long int)strip_size;
  const signed long int m8$array_size0 = (signed long int)strip_size;
  const signed long int m9$array_size0 = (signed long int)strip_size;
  const signed long int m10$array_size0 = (signed long int)strip_size;
  const signed long int m11$array_size0 = (signed long int)strip_size;
  const signed long int m12$array_size0 = (signed long int)strip_size;
  const signed long int m13$array_size0 = (signed long int)strip_size;
  const signed long int m14$array_size0 = (signed long int)strip_size;
  const signed long int m15$array_size0 = (signed long int)strip_size;
  const signed long int p0$array_size0 = (signed long int)strip_size;
  const signed long int p1$array_size0 = (signed long int)strip_size;
  const signed long int p2$array_size0 = (signed long int)strip_size;
  const signed long int p3$array_size0 = (signed long int)strip_size;
  const signed long int p4$array_size0 = (signed long int)strip_size;
  const signed long int p5$array_size0 = (signed long int)strip_size;
  const signed long int p6$array_size0 = (signed long int)strip_size;
  const signed long int p7$array_size0 = (signed long int)strip_size;
  const signed long int p8$array_size0 = (signed long int)strip_size;
  const signed long int p9$array_size0 = (signed long int)strip_size;
  const signed long int p10$array_size0 = (signed long int)strip_size;
  const signed long int p11$array_size0 = (signed long int)strip_size;
  const signed long int p12$array_size0 = (signed long int)strip_size;
  const signed long int p13$array_size0 = (signed long int)strip_size;
  unsigned char m0[strip_size$array_size0];
  unsigned char m1[m0$array_size0];
  unsigned char m2[m1$array_size0];
  unsigned char m3[m2$array_size0];
  unsigned char m4[m3$array_size0];
  unsigned char m5[m4$array_size0];
  unsigned char m6[m5$array_size0];
  unsigned char m7[m6$array_size0];
  unsigned char m8[m7$array_size0];
  unsigned char m9[m8$array_size0];
  unsigned char m10[m9$array_size0];
  unsigned char m11[m10$array_size0];
  unsigned char m12[m11$array_size0];
  unsigned char m13[m12$array_size0];
  unsigned char m14[m13$array_size0];
  unsigned char m15[m14$array_size0];
  unsigned char p0[m15$array_size0];
  unsigned char p1[p0$array_size0];
  unsigned char p2[p1$array_size0];
  unsigned char p3[p2$array_size0];
  unsigned char p4[p3$array_size0];
  unsigned char p5[p4$array_size0];
  unsigned char p6[p5$array_size0];
  unsigned char p7[p6$array_size0];
  unsigned char p8[p7$array_size0];
  unsigned char p9[p8$array_size0];
  unsigned char p10[p9$array_size0];
  unsigned char p11[p10$array_size0];
  unsigned char p12[p11$array_size0];
  unsigned char p13[p12$array_size0];
  unsigned char p14[p13$array_size0];
  unsigned char *missing[16l] = { m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15 };
  unsigned char *p[15l] = { p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 };
  i = 0;
  for( ; !(i >= edp); i = i + 1)
    dp[(signed long int)i] = (const unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    oin[(signed long int)i] = (const unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    oidx[(signed long int)i] = 0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    dp[(signed long int)inidx[(signed long int)i]] = input[(signed long int)i];
  decode_prepare(ctx, dp, oin, oidx);
  _Bool return_value_data_is_missing$2;
  return_value_data_is_missing$2=data_is_missing(dp, ed);
  signed int tmp_post$1;
  if(!(return_value_data_is_missing$2 == (_Bool)0))
  {
    signed int m = 0;
    fec_decode(ctx, oin, missing, oidx, (unsigned long int)strip_size);
    i = 0;
    for( ; !(i >= ed); i = i + 1)
      if(dp[(signed long int)i] == ((const unsigned char *)NULL))
      {
        tmp_post$1 = m;
        m = m + 1;
        dp[(signed long int)i] = missing[(signed long int)tmp_post$1];
      }

  }

  if(idx >= ed)
  {
    ec_encode$link1(ctx, dp, p);
    i = 0;
    for( ; !(i >= ep); i = i + 1)
      dp[(signed long int)(ed + i)] = p[(signed long int)i];
  }


out:
  ;
  memcpy((void *)output, (const void *)dp[(signed long int)idx], (unsigned long int)strip_size);
}

// ec_decode_buffer
// file ../include/fec.h line 200
void ec_decode_buffer(struct fec *ctx, unsigned char **input, const signed int *in_idx, char *buf, signed int idx)
{
  signed int i;
  signed int j;
  signed int d = (signed int)ctx->d;
  unsigned long int strip_size = (unsigned long int)(1024 / d);
  i = 0;
  for( ; !((unsigned long int)i >= 4096ul); i = i + 1)
  {
    const signed long int strip_size$array_size0 = (signed long int)d;
    const unsigned char *in[strip_size$array_size0];
    const signed long int in$array_size0 = (signed long int)strip_size;
    unsigned char out[in$array_size0];
    j = 0;
    for( ; !(j >= d); j = j + 1)
      in[(signed long int)j] = input[(signed long int)j] + (signed long int)(strip_size * (unsigned long int)i);
    ec_decode(ctx, in, in_idx, out, idx);
    memcpy((void *)(buf + (signed long int)(strip_size * (unsigned long int)i)), (const void *)out, strip_size);
  }
}

// ec_destroy
// file ../include/fec.h line 195
static inline void ec_destroy(struct fec *ctx)
{
  fec_free(ctx);
}

// ec_destroy$link1
// file ../include/fec.h line 195
static inline void ec_destroy$link1(struct fec *ctx$link1)
{
  fec_free(ctx$link1);
}

// ec_encode
// file ../include/fec.h line 169
static inline void ec_encode(struct fec *ctx, const unsigned char **ds, unsigned char **ps)
{
  signed int p = (signed int)ctx->dp - (signed int)ctx->d;
  const signed long int p$array_size0 = (signed long int)p;
  signed int pidx[p$array_size0];
  signed int i = 0;
  for( ; !(i >= p); i = i + 1)
    pidx[(signed long int)i] = (signed int)ctx->d + i;
  fec_encode(ctx, ds, ps, pidx, (unsigned long int)p, (unsigned long int)(1024 / (signed int)ctx->d));
}

// ec_encode$link1
// file ../include/fec.h line 169
static inline void ec_encode$link1(struct fec *ctx$link1, const unsigned char **ds$link1, unsigned char **ps$link1)
{
  signed int p$link1 = (signed int)ctx$link1->dp - (signed int)ctx$link1->d;
  const signed long int p$array_size0$link1 = (signed long int)p$link1;
  signed int pidx$link1[p$array_size0$link1];
  signed int i$link1 = 0;
  for( ; !(i$link1 >= p$link1); i$link1 = i$link1 + 1)
    pidx$link1[(signed long int)i$link1] = (signed int)ctx$link1->d + i$link1;
  fec_encode(ctx$link1, ds$link1, ps$link1, pidx$link1, (unsigned long int)p$link1, (unsigned long int)(1024 / (signed int)ctx$link1->d));
}

// ec_init
// file ../include/fec.h line 158
static inline struct fec * ec_init(signed int d, signed int dp)
{
  struct fec *return_value_fec_new$1;
  return_value_fec_new$1=fec_new((unsigned short int)d, (unsigned short int)dp);
  return return_value_fec_new$1;
}

// ec_init$link1
// file ../include/fec.h line 158
static inline struct fec * ec_init$link1(signed int d$link1, signed int dp$link1)
{
  struct fec *return_value_fec_new$1$link1;
  return_value_fec_new$1$link1=fec_new((unsigned short int)d$link1, (unsigned short int)dp$link1);
  return return_value_fec_new$1$link1;
}

// ec_policy_to_dp
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp(unsigned char policy, signed int *d, signed int *p)
{
  signed int ed = 0;
  signed int ep = 0;
  ep = (signed int)policy & 0b1111;
  ed = (signed int)policy >> 4;
  if(ep == 0)
  {
    log_write(0, "ec_policy_to_dp", 131, "PANIC: invalid policy %d", policy);
    abort();
  }

  if(!(d == ((signed int *)NULL)))
    *d = ed * 2;

  if(!(p == ((signed int *)NULL)))
    *p = ep;

  return ed * 2 + ep;
}

// ec_policy_to_dp$link1
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link1(unsigned char policy$link1, signed int *d$link1, signed int *p$link1)
{
  signed int ed$link1 = 0;
  signed int ep$link1 = 0;
  ep$link1 = (signed int)policy$link1 & 0b1111;
  ed$link1 = (signed int)policy$link1 >> 4;
  if(ep$link1 == 0)
  {
    log_write(0, "ec_policy_to_dp", 131, "PANIC: invalid policy %d", policy$link1);
    abort();
  }

  if(!(d$link1 == ((signed int *)NULL)))
    *d$link1 = ed$link1 * 2;

  if(!(p$link1 == ((signed int *)NULL)))
    *p$link1 = ep$link1;

  return ed$link1 * 2 + ep$link1;
}

// ec_policy_to_dp$link2
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link2(unsigned char policy$link2, signed int *d$link2, signed int *p$link2)
{
  signed int ed$link2 = 0;
  signed int ep$link2 = 0;
  ep$link2 = (signed int)policy$link2 & 0b1111;
  ed$link2 = (signed int)policy$link2 >> 4;
  if(ep$link2 == 0)
  {
    log_write(0, "ec_policy_to_dp", 131, "PANIC: invalid policy %d", policy$link2);
    abort();
  }

  if(!(d$link2 == ((signed int *)NULL)))
    *d$link2 = ed$link2 * 2;

  if(!(p$link2 == ((signed int *)NULL)))
    *p$link2 = ep$link2;

  return ed$link2 * 2 + ep$link2;
}

// ec_policy_to_dp$link3
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link3(unsigned char policy$link3, signed int *d$link3, signed int *p$link3)
{
  signed int ed$link3 = 0;
  signed int ep$link3 = 0;
  ep$link3 = (signed int)policy$link3 & 0b1111;
  ed$link3 = (signed int)policy$link3 >> 4;
  if(ep$link3 == 0)
  {
    log_write(0, "ec_policy_to_dp", 131, "PANIC: invalid policy %d", policy$link3);
    abort();
  }

  if(!(d$link3 == ((signed int *)NULL)))
    *d$link3 = ed$link3 * 2;

  if(!(p$link3 == ((signed int *)NULL)))
    *p$link3 = ep$link3;

  return ed$link3 * 2 + ep$link3;
}

// ec_policy_to_dp$link4
// file ../include/fec.h line 123
static inline signed int ec_policy_to_dp$link4(unsigned char policy$link4, signed int *d$link4, signed int *p$link4)
{
  signed int ed$link4 = 0;
  signed int ep$link4 = 0;
  ep$link4 = (signed int)policy$link4 & 0b1111;
  ed$link4 = (signed int)policy$link4 >> 4;
  if(ep$link4 == 0)
  {
    log_write(0, "ec_policy_to_dp", 131, "PANIC: invalid policy %d", policy$link4);
    abort();
  }

  if(!(d$link4 == ((signed int *)NULL)))
    *d$link4 = ed$link4 * 2;

  if(!(p$link4 == ((signed int *)NULL)))
    *p$link4 = ep$link4;

  return ed$link4 * 2 + ep$link4;
}

// enough_nodes_gathered
// file group.c line 395
static _Bool enough_nodes_gathered(struct cluster_info *cinfo, struct sd_node *joining, struct rb_root *nroot, unsigned long int nr_nodes)
{
  signed int i = 0;
  struct sd_node *tmp_statement_expression$1;
  struct sd_node *tmp_statement_expression$2;
  _Bool return_value_node_eq$4;
  const char *return_value_node_to_str$3;
  for( ; !(i >= (signed int)cinfo->nr_nodes); i = i + 1)
  {
    struct sd_node *key = cinfo->nodes + (signed long int)i;
    struct sd_node *n;
    struct rb_node *__n = nroot->rb_node;
    struct sd_node *__ret = (struct sd_node *)(void *)0;
    struct sd_node *__data;
    while(!(__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr = __n;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      __data = tmp_statement_expression$2;
      signed int __cmp;
      __cmp=node_cmp(key, __data);
      if(!(__cmp >= 0))
        __n = __n->rb_left;

      else
        if(__cmp >= 1)
          __n = __n->rb_right;

        else
        {
          __ret = __data;
          break;
        }
    }
    tmp_statement_expression$1 = __ret;
    n = tmp_statement_expression$1;
    if(n == ((struct sd_node *)NULL))
    {
      return_value_node_eq$4=node_eq(key, joining);
      if(return_value_node_eq$4 == (_Bool)0)
      {
        if(sd_log_level == 7)
        {
          return_value_node_to_str$3=node_to_str(key);
          log_write(7, "enough_nodes_gathered", 405, "%s doesn't join yet", return_value_node_to_str$3);
        }

        return (_Bool)0;
      }

    }

  }
  if(sd_log_level == 7)
    log_write(7, "enough_nodes_gathered", 411, "all the nodes are gathered, %d, %zd", cinfo->nr_nodes, nr_nodes);

  return (_Bool)1;
}

// entry_idx
// file object_cache.c line 101
static inline unsigned long int entry_idx(struct object_cache_entry *entry)
{
  return entry->idx & ~(1UL << 59);
}

// entry_in_use
// file object_cache.c line 161
static inline _Bool entry_in_use(struct object_cache_entry *entry)
{
  signed int return_value_refcount_read$1;
  return_value_refcount_read$1=refcount_read$link2(&entry->refcnt);
  return return_value_refcount_read$1 > 0;
}

// entry_is_dirty
// file object_cache.c line 90
static inline _Bool entry_is_dirty(struct object_cache_entry *entry)
{
  return !(!(entry->bmap != 0ul));
}

// epoch_log_read
// file sheep_priv.h line 360
signed int epoch_log_read(unsigned int epoch, struct sd_node *nodes, signed int len)
{
  signed int return_value_do_epoch_log_read$1;
  return_value_do_epoch_log_read$1=do_epoch_log_read(epoch, nodes, len, (signed long int *)(void *)0);
  return return_value_do_epoch_log_read$1;
}

// epoch_log_read_remote
// file group.c line 337
signed int epoch_log_read_remote(unsigned int epoch, struct sd_node *nodes, signed int len, signed long int *timestamp, struct vnode_info *vinfo)
{
  char buf[(signed long int)(sizeof(signed long int) * 61441) /*491528l*/ ];
  struct sd_node *node;
  signed int ret;
  struct rb_node *__p344;
  __p344=rb_first(&vinfo->nroot);
  struct rb_node *__n344;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_node *tmp_statement_expression$2;
  do
  {
    if(!(__p344 == ((struct rb_node *)NULL)))
    {
      __n344=rb_next(__p344);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p344;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      node = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    struct sd_req hdr;
    struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
    signed int nodes_len;
    _Bool return_value_node_is_local$4;
    return_value_node_is_local$4=node_is_local(node);
    if(return_value_node_is_local$4 == (_Bool)0)
    {
      sd_init_req(&hdr, (unsigned char)0xA2);
      hdr.data_length = (unsigned int)len;
      hdr.$anon0.obj.tgt_epoch = epoch;
      hdr.epoch=sys_epoch();
      ret=sheep_exec_req(&node->nid, &hdr, (void *)buf);
      if(ret == 0x00)
      {
        nodes_len = (signed int)((unsigned long int)rsp->data_length - sizeof(signed long int) /*8ul*/ );
        memcpy((void *)nodes, (const void *)buf, (unsigned long int)nodes_len);
        if(!(timestamp == ((signed long int *)NULL)))
          memcpy((void *)timestamp, (const void *)(buf + (signed long int)nodes_len), sizeof(signed long int) /*8ul*/ );

        return (signed int)((unsigned long int)nodes_len / sizeof(struct sd_node) /*80ul*/ );
      }

    }

    __p344 = __n344;
  }
  while((_Bool)1);
  return 0;
}

// epoch_log_read_with_timestamp
// file store.c line 105
signed int epoch_log_read_with_timestamp(unsigned int epoch, struct sd_node *nodes, signed int len, signed long int *timestamp)
{
  signed int return_value_do_epoch_log_read$1;
  return_value_do_epoch_log_read$1=do_epoch_log_read(epoch, nodes, len, timestamp);
  return return_value_do_epoch_log_read$1;
}

// epoll_event_cmp
// file event.c line 179
static signed int epoll_event_cmp(struct epoll_event *_a, struct epoll_event *_b)
{
  struct event_info *a;
  struct event_info *b;
  a = (struct event_info *)_a->data.ptr;
  b = (struct event_info *)_b->data.ptr;
  signed int tmp_statement_expression$1;
  signed int _x = b->prio;
  signed int _y = a->prio;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// err_to_sderr
// file plain_store.c line 83
static signed int err_to_sderr(const char *path, unsigned long int oid, signed int err)
{
  struct stat s;
  char p[4096l];
  char *dir;
  pstrcpy(p, (signed int)sizeof(char [4096l]) /*4096ul*/ , path);
  dir=dirname(p);
  if(sd_log_level == 7)
    log_write(7, "err_to_sderr", 92, "%s", path);

  signed int return_value_stat$2;
  signed int return_value_md_handle_eio$3;
  switch(err)
  {
    case 2:
    {
      return_value_stat$2=stat(dir, &s);
      if(!(return_value_stat$2 >= 0))
      {
        log_write(3, "err_to_sderr", 96, "%s corrupted", dir);
        signed int return_value_md_handle_eio$1;
        return_value_md_handle_eio$1=md_handle_eio(dir);
        return return_value_md_handle_eio$1;
      }

      if(sd_log_level == 7)
        log_write(7, "err_to_sderr", 99, "object %016lx not found locally", oid);

      return 0x02;
    }
    case 28:
    {
      log_write(3, "err_to_sderr", 103, "diskfull, oid=%lx", oid);
      return 0x15;
    }
    case 24:

    case 23:

    case 4:

    case 11:

    case 17:
    {
      log_write(3, "err_to_sderr", 110, "%m, oid=%lx", oid);
      return 0x86;
    }
    default:
    {
      log_write(3, "err_to_sderr", 114, "oid=%lx, %m", oid);
      return_value_md_handle_eio$3=md_handle_eio(dir);
      return return_value_md_handle_eio$3;
    }
  }
}

// event_cmp
// file event.c line 74
static signed int event_cmp(struct event_info *e1, struct event_info *e2)
{
  signed int tmp_statement_expression$1;
  signed int _x = e1->fd;
  signed int _y = e2->fd;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// event_force_refresh
// file event.c line 174
void event_force_refresh(void)
{
  event_loop_refresh = (_Bool)1;
}

// event_loop
// file ../include/event.h line 15
void event_loop(signed int timeout)
{
  do_event_loop(timeout, (_Bool)0);
}

// event_loop_prio
// file event.c line 223
void event_loop_prio(signed int timeout)
{
  do_event_loop(timeout, (_Bool)1);
}

// eventfd_xread
// file ../include/util.h line 103
signed int eventfd_xread(signed int efd)
{
  signed int ret;
  unsigned long int value = (unsigned long int)0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    ret=eventfd_read(efd, &value);
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$3;
  if(ret == 0)
    ret = (signed int)value;

  else
  {
    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 11))
    {
      log_write(0, "eventfd_xread", 291, "PANIC: eventfd_read() failed, %m");
      abort();
    }

  }
  return ret;
}

// eventfd_xwrite
// file ../include/util.h line 104
void eventfd_xwrite(signed int efd, signed int value)
{
  signed int ret;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    ret=eventfd_write(efd, (unsigned long int)value);
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
  }
  while(tmp_if_expr$4);
  if(!(ret >= 0))
  {
    log_write(0, "eventfd_xwrite", 305, "PANIC: eventfd_write() failed, %m");
    abort();
  }

}

// exec_local_req
// file request.c line 550
signed int exec_local_req(struct sd_req *rq, void *data)
{
  struct request *req;
  signed int ret;
  req=alloc_local_request(data, (signed int)rq->data_length);
  req->rq = *rq;
  req->local_req_efd=eventfd((unsigned int)0, 0);
  if(!(req->local_req_efd >= 0))
  {
    log_write(3, "exec_local_req", 559, "eventfd failed, %m");
    req->rp.$anon0.result = (unsigned int)0x86;
  }

  else
  {
    submit_local_request(req);
    eventfd_xread(req->local_req_efd);
  }

out:
  ;
  memcpy((void *)rq, (const void *)&req->rp, sizeof(struct sd_rsp) /*48ul*/ );
  close(req->local_req_efd);
  ret = (signed int)req->rp.$anon0.result;
  free_local_request(req);
  return ret;
}

// exec_local_req_async
// file request.c line 632
signed int exec_local_req_async(struct sd_req *rq, void *data, struct request_iocb *iocb)
{
  struct areq_work *areq;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct areq_work) /*104ul*/ );
  areq = (struct areq_work *)return_value_xzalloc$1;
  areq->rq = *rq;
  areq->data = data;
  areq->iocb = iocb;
  areq->work.fn = local_req_async_work;
  areq->work.done = local_req_async_main;
  queue_work(sys->areq_wqueue, &areq->work);
  iocb->count = iocb->count + 1u;
  return 0x00;
}

// exec_req
// file ../include/net.h line 49
signed int exec_req(signed int sockfd, struct sd_req *hdr, void *data, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  struct sd_rsp *rsp = (struct sd_rsp *)hdr;
  unsigned int wlen;
  unsigned int rlen;
  if(!((0x01 & (signed int)hdr->flags) == 0))
  {
    wlen = hdr->data_length;
    rlen = (unsigned int)0;
  }

  else
  {
    wlen = (unsigned int)0;
    rlen = hdr->data_length;
  }
  signed int return_value_send_req$1;
  return_value_send_req$1=send_req(sockfd, hdr, data, wlen, need_retry, epoch, max_count);
  if(!(return_value_send_req$1 == 0))
    return 1;

  else
  {
    ret=do_read(sockfd, (void *)rsp, (signed int)sizeof(struct sd_rsp) /*48ul*/ , need_retry, epoch, max_count);
    if(!(ret == 0))
    {
      log_write(3, "exec_req", 347, "failed to read a response");
      return 1;
    }

    else
    {
      if(!(rsp->data_length >= rlen))
        rlen = rsp->data_length;

      if(!(rlen == 0u))
      {
        ret=do_read(sockfd, data, (signed int)rlen, need_retry, epoch, max_count);
        if(ret == 0)
          goto __CPROVER_DUMP_L6;

        log_write(3, "exec_req", 357, "failed to read the response data");
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        return 0;
      }
    }
  }
}

// ext_in_range
// file sd_inode.c line 252
static _Bool ext_in_range(struct sd_extent_header *header, struct sd_extent *ext)
{
  struct sd_extent *last = (struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  if(last - ext >= 1l)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// extent_comp
// file sd_inode.c line 108
static signed int extent_comp(void *a, void *b)
{
  struct sd_extent *ea = (struct sd_extent *)a;
  struct sd_extent *eb = (struct sd_extent *)b;
  if(!(eb->idx >= ea->idx))
    return 1;

  else
    if(!(ea->idx >= eb->idx))
      return -1;

    else
      return 0;
}

// fec_decode
// file fec.c line 555
void fec_decode(struct fec *code, const unsigned char * const * const inpkts, unsigned char * const * const outpkts, const signed int * const idx, unsigned long int sz)
{
  const signed long int fec_decode$array_size0 = (signed long int)((signed int)code->d * (signed int)code->d);
  unsigned char m_dec[fec_decode$array_size0];
  unsigned char outix = (unsigned char)0;
  unsigned char row = (unsigned char)0;
  unsigned char col = (unsigned char)0;
  build_decode_matrix_into_space(code, idx, (const unsigned int)code->d, m_dec);
  row = (unsigned char)0;
  for( ; !((signed int)row >= (signed int)code->d); row = row + 1)
    if(idx[(signed long int)row] >= (signed int)code->d)
    {
      memset((void *)outpkts[(signed long int)outix], 0, sz);
      col = (unsigned char)0;
      for( ; !((signed int)col >= (signed int)code->d); col = col + 1)
        if(!((signed int)m_dec[(signed long int)((signed int)code->d * (signed int)row + (signed int)col)] == 0))
          _addmul1(outpkts[(signed long int)outix], inpkts[(signed long int)col], m_dec[(signed long int)((signed int)row * (signed int)code->d + (signed int)col)], sz);

      outix = outix + 1;
    }

}

// fec_encode
// file ../include/fec.h line 90
void fec_encode(struct fec *code, const unsigned char * const * const src, unsigned char * const * const fecs, const signed int * const block_nums, unsigned long int num_block_nums, unsigned long int sz)
{
  unsigned char i;
  unsigned char j;
  unsigned long int d;
  unsigned int fecnum;
  const unsigned char *p;
  d = (unsigned long int)0;
  for( ; !(d >= sz); d = d + (unsigned long int)8192)
  {
    unsigned long int stride = sz - d < (unsigned long int)8192 ? sz - d : (unsigned long int)8192;
    i = (unsigned char)0;
    for( ; !((unsigned long int)i >= num_block_nums); i = i + 1)
    {
      fecnum = (unsigned int)block_nums[(signed long int)i];
      memset((void *)(fecs[(signed long int)i] + (signed long int)d), 0, stride);
      p = &code->enc_matrix[(signed long int)(fecnum * (unsigned int)code->d)];
      j = (unsigned char)0;
      for( ; !((signed int)j >= (signed int)code->d); j = j + 1)
        if(!((signed int)p[(signed long int)j] == 0))
          _addmul1(fecs[(signed long int)i] + (signed long int)d, src[(signed long int)j] + (signed long int)d, p[(signed long int)j], stride);

    }
  }
}

// fec_free
// file ../include/fec.h line 80
void fec_free(struct fec *p)
{
  free((void *)p->enc_matrix);
  free((void *)p);
}

// fec_new
// file ../include/fec.h line 79
struct fec * fec_new(unsigned short int d, unsigned short int dp)
{
  unsigned int row;
  unsigned int col;
  unsigned char *p;
  unsigned char *tmp_m;
  struct fec *retval;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct fec) /*24ul*/ );
  retval = (struct fec *)return_value_xmalloc$1;
  retval->d = d;
  retval->dp = dp;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc((unsigned long int)((signed int)dp * (signed int)d));
  retval->enc_matrix = (unsigned char *)return_value_xmalloc$2;
  retval->magic = (unsigned long int)(0xFECC0DEC ^ (unsigned int)d ^ (unsigned int)dp) ^ (unsigned long int)retval->enc_matrix;
  void *return_value_xmalloc$3;
  return_value_xmalloc$3=xmalloc((unsigned long int)((signed int)dp * (signed int)d));
  tmp_m = (unsigned char *)return_value_xmalloc$3;
  tmp_m[(signed long int)0] = (unsigned char)1;
  col = (unsigned int)1;
  for( ; !(col >= (unsigned int)d); col = col + 1u)
    tmp_m[(signed long int)col] = (unsigned char)0;
  p = tmp_m + (signed long int)d;
  row = (unsigned int)0;
  unsigned char return_value_modnn$4;
  for( ; !(row >= 4294967295u + (unsigned int)(signed int)dp); p = p + (signed long int)d)
  {
    col = (unsigned int)0;
    for( ; !(col >= (unsigned int)d); col = col + 1u)
    {
      return_value_modnn$4=modnn((signed int)(row * col));
      p[(signed long int)col] = gf_exp[(signed long int)return_value_modnn$4];
    }
    row = row + 1u;
  }
  _invert_vdm(tmp_m, (unsigned int)d);
  _matmul(tmp_m + (signed long int)((signed int)d * (signed int)d), tmp_m, retval->enc_matrix + (signed long int)((signed int)d * (signed int)d), (unsigned int)((signed int)dp - (signed int)d), (unsigned int)d, (unsigned int)d);
  memset((void *)retval->enc_matrix, 0, (unsigned long int)((signed int)d * (signed int)d) * sizeof(unsigned char) /*1ul*/ );
  p = retval->enc_matrix;
  col = (unsigned int)0;
  for( ; !(col >= (unsigned int)d); p = p + (signed long int)((signed int)d + 1))
  {
    *p = (unsigned char)1;
    col = col + 1u;
  }
  free((void *)tmp_m);
  return retval;
}

// fetch_object_list
// file recovery.c line 905
static unsigned long int * fetch_object_list(struct sd_node *e, unsigned int epoch, unsigned long int *nr_oids)
{
  struct sd_req hdr;
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  unsigned long int buf_size = list_buffer_size;
  unsigned long int *buf;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(buf_size);
  buf = (unsigned long int *)return_value_xmalloc$1;
  signed int ret;
  const char *return_value_addr_to_str$2;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str$2=addr_to_str(e->nid.addr, e->nid.port);
    log_write(7, "fetch_object_list", 914, "%s", return_value_addr_to_str$2);
  }

  void *return_value_xrealloc$3;
  do
  {

  retry:
    ;
    sd_init_req$link4(&hdr, (unsigned char)0xA1);
    hdr.data_length = (unsigned int)buf_size;
    hdr.epoch = epoch;
    ret=sheep_exec_req(&e->nid, &hdr, (void *)buf);
    if(!(ret == 0x00))
    {
      if(ret == 0x88)
        goto __CPROVER_DUMP_L4;

      break;
    }

    goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L4:
    ;
    buf_size = buf_size * (unsigned long int)2;
    return_value_xrealloc$3=xrealloc((void *)buf, buf_size);
    buf = (unsigned long int *)return_value_xrealloc$3;
  }
  while((_Bool)1);
  const char *return_value_addr_to_str$4;
  return_value_addr_to_str$4=addr_to_str(e->nid.addr, e->nid.port);
  log_write(1, "fetch_object_list", 931, "cannot get object list from %s", return_value_addr_to_str$4);
  log_write(1, "fetch_object_list", 933, "some objects may be not recovered at epoch %d", epoch);
  free((void *)buf);
  return (unsigned long int *)(void *)0;

__CPROVER_DUMP_L6:
  ;
  *nr_oids = (unsigned long int)rsp->data_length / sizeof(unsigned long int) /*8ul*/ ;
  if(sd_log_level == 7)
    log_write(7, "fetch_object_list", 939, "%zu", *nr_oids);

  return buf;
}

// fill_delete_vid_array
// file vdi.c line 942
static signed int fill_delete_vid_array(struct deletion_work *dw, unsigned int root_vid)
{
  signed int ret = 0;
  struct sd_inode *inode = (struct sd_inode *)(void *)0;
  signed int done = 0;
  unsigned int vid;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(4664ul);
  inode = (struct sd_inode *)return_value_malloc$1;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$6;
  if(inode == ((struct sd_inode *)NULL))
  {
    log_write(3, "fill_delete_vid_array", 951, "failed to allocate memory");
    return -1;
  }

  else
  {
    tmp_post$2 = dw->delete_vid_count;
    dw->delete_vid_count = dw->delete_vid_count + 1;
    dw->delete_vid_array[(signed long int)tmp_post$2] = root_vid;
    do
    {
      tmp_post$3 = done;
      done = done + 1;
      vid = dw->delete_vid_array[(signed long int)tmp_post$3];
      unsigned long int return_value_vid_to_vdi_oid$4;
      return_value_vid_to_vdi_oid$4=vid_to_vdi_oid(vid);
      ret=read_backend_object(return_value_vid_to_vdi_oid$4, (char *)inode, (unsigned int)4664ul, (unsigned long int)0);
      if(!(ret == 0x00))
      {
        log_write(3, "fill_delete_vid_array", 962, "cannot find VDI object");
        ret = -1;
        break;
      }

      _Bool return_value_vdi_is_deleted$5;
      return_value_vdi_is_deleted$5=vdi_is_deleted(inode);
      if(return_value_vdi_is_deleted$5 == (_Bool)0)
      {
        if(!(vid == dw->target_vid))
        {
          ret = 1;
          break;
        }

      }

      signed int i = 0;
      for( ; !((unsigned long int)i >= 1024ul); i = i + 1)
        if(!(inode->child_vdi_id[(signed long int)i] == 0u))
        {
          tmp_post$6 = dw->delete_vid_count;
          dw->delete_vid_count = dw->delete_vid_count + 1;
          dw->delete_vid_array[(signed long int)tmp_post$6] = inode->child_vdi_id[(signed long int)i];
        }

    }
    while(!(dw->delete_vid_array[(signed long int)done] == 0u));
    free((void *)inode);
    return ret;
  }
}

// fill_vdi_info
// file vdi.c line 592
static signed int fill_vdi_info(unsigned long int left, unsigned long int right, struct vdi_iocb *iocb, struct vdi_info *info)
{
  signed int ret;
  signed int return_value_fill_vdi_info_range$1;
  if(!(left >= right))
  {
    return_value_fill_vdi_info_range$1=fill_vdi_info_range((unsigned int)left, (unsigned int)right, iocb, info);
    return return_value_fill_vdi_info_range$1;
  }

  else
  {
    ret=fill_vdi_info_range((unsigned int)0, (unsigned int)right, iocb, info);
    if(ret == 0x08 || ret == 0x0E)
      ret=fill_vdi_info_range((unsigned int)left, (1U << 24) - (unsigned int)1, iocb, info);

    return ret;
  }
}

// fill_vdi_info_range
// file vdi.c line 537
static signed int fill_vdi_info_range(unsigned int left, unsigned int right, struct vdi_iocb *iocb, struct vdi_info *info)
{
  struct sd_inode *inode;
  _Bool vdi_found = (_Bool)0;
  signed int ret;
  unsigned int i;
  const char *name = iocb->name;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(4664ul);
  inode = (struct sd_inode *)return_value_malloc$1;
  if(inode == ((struct sd_inode *)NULL))
  {
    log_write(3, "fill_vdi_info_range", 549, "failed to allocate memory");
    ret = 0x12;
  }

  else
  {
    i = right - (unsigned int)1;
    for( ; i >= left; i = i - 1u)
    {
      unsigned long int return_value_vid_to_vdi_oid$2;
      return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(i);
      ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)4664ul, (unsigned long int)0);
      if(!(ret == 0x00))
        goto out;

      signed int return_value_strncmp$7;
      return_value_strncmp$7=strncmp(inode->name, name, sizeof(char [256l]) /*256ul*/ );
      if(return_value_strncmp$7 == 0)
      {
        if(sd_log_level == 7)
          log_write(7, "fill_vdi_info_range", 561, "%s = %s, %u = %u", iocb->tag, (const void *)inode->tag, iocb->snapid, inode->snap_id);

        _Bool return_value_vdi_has_tag$6;
        return_value_vdi_has_tag$6=vdi_has_tag(iocb);
        if(!(return_value_vdi_has_tag$6 == (_Bool)0))
        {
          _Bool return_value_vdi_is_snapshot$3;
          return_value_vdi_is_snapshot$3=vdi_is_snapshot(inode);
          if(return_value_vdi_is_snapshot$3 == (_Bool)0)
          {
            vdi_found = (_Bool)1;
            goto __CPROVER_DUMP_L10;
          }

          _Bool return_value_vdi_tag_match$4;
          return_value_vdi_tag_match$4=vdi_tag_match(iocb, inode);
          if(return_value_vdi_tag_match$4 == (_Bool)0)
            goto __CPROVER_DUMP_L10;

        }

        else
        {
          info->snapid = inode->snap_id + (unsigned int)1;
          _Bool return_value_vdi_is_snapshot$5;
          return_value_vdi_is_snapshot$5=vdi_is_snapshot(inode);
          if(!(return_value_vdi_is_snapshot$5 == (_Bool)0))
            break;

        }
        info->create_time = inode->create_time;
        info->vid = inode->vdi_id;
        goto out;
      }


    __CPROVER_DUMP_L10:
      ;
    }
    ret = vdi_found != (_Bool)0 ? 0x0E : 0x08;
  }

out:
  ;
  free((void *)inode);
  return ret;
}

// fill_vdi_state_list
// file vdi.c line 175
signed int fill_vdi_state_list(void *data)
{
  signed int nr = 0;
  struct vdi_state *vs = (struct vdi_state *)data;
  struct vdi_state_entry *entry;
  sd_read_lock(&vdi_state_lock);
  struct rb_node *__p182;
  __p182=rb_first(&vdi_state_root);
  struct rb_node *__n182;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct vdi_state_entry *tmp_statement_expression$2;
  do
  {
    if(!(__p182 == ((struct rb_node *)NULL)))
    {
      __n182=rb_next(__p182);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p182;
      tmp_statement_expression$2 = (struct vdi_state_entry *)((char *)__mptr - (signed long int)16ul);
      entry = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    memset((void *)vs, 0, sizeof(struct vdi_state) /*8ul*/ );
    vs->vid = entry->vid;
    vs->nr_copies = (unsigned char)entry->nr_copies;
    vs->snapshot = (unsigned char)entry->snapshot;
    vs->copy_policy = entry->copy_policy;
    vs = vs + 1l;
    nr = nr + 1;
    __p182 = __n182;
  }
  while((_Bool)1);
  sd_rw_unlock(&vdi_state_lock);
  return (signed int)((unsigned long int)nr * sizeof(struct vdi_state) /*8ul*/ );
}

// find_cdrv
// file cluster.h line 168
static inline struct cluster_driver * find_cdrv(const char *name)
{
  struct cluster_driver *cdrv;
  signed int len;
  struct cluster_driver *__n173;
  struct cluster_driver *tmp_statement_expression$1;
  const struct list_node *__mptr = (&cluster_drivers)->n.next;
  tmp_statement_expression$1 = (struct cluster_driver *)((char *)__mptr - (signed long int)88ul);
  cdrv = tmp_statement_expression$1;
  struct cluster_driver *tmp_statement_expression$2;
  const struct list_node *find_cdrv$$1$$1$$2$$__mptr = cdrv->list.next;
  tmp_statement_expression$2 = (struct cluster_driver *)((char *)find_cdrv$$1$$1$$2$$__mptr - (signed long int)88ul);
  __n173 = tmp_statement_expression$2;
  _Bool tmp_if_expr$5;
  struct cluster_driver *tmp_statement_expression$3;
  for( ; !(&cdrv->list == &(&cluster_drivers)->n); __n173 = tmp_statement_expression$3)
  {
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(cdrv->name);
    len = (signed int)return_value_strlen$4;
    signed int return_value_strncmp$6;
    return_value_strncmp$6=strncmp(cdrv->name, name, (unsigned long int)len);
    if(return_value_strncmp$6 == 0)
    {
      if((signed int)name[(signed long int)len] == 58)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)name[(signed long int)len] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return cdrv;

    }

    cdrv = __n173;
    const struct list_node *find_cdrv$$1$$1$$3$$__mptr = __n173->list.next;
    tmp_statement_expression$3 = (struct cluster_driver *)((char *)find_cdrv$$1$$1$$3$$__mptr - (signed long int)88ul);
  }
  return (struct cluster_driver *)(void *)0;
}

// find_cdrv$link1
// file cluster.h line 168
static inline struct cluster_driver * find_cdrv$link1(const char *name$link1)
{
  struct cluster_driver *cdrv$link1;
  signed int len$link1;
  struct cluster_driver *__n173$link1;
  struct cluster_driver *tmp_statement_expression$1$link1;
  const struct list_node *find_cdrv$$1$$1$$1$$__mptr$link1 = (&cluster_drivers)->n.next;
  tmp_statement_expression$1$link1 = (struct cluster_driver *)((char *)find_cdrv$$1$$1$$1$$__mptr$link1 - (signed long int)88ul);
  cdrv$link1 = tmp_statement_expression$1$link1;
  struct cluster_driver *tmp_statement_expression$2$link1;
  const struct list_node *find_cdrv$$1$$1$$2$$__mptr$link1 = cdrv$link1->list.next;
  tmp_statement_expression$2$link1 = (struct cluster_driver *)((char *)find_cdrv$$1$$1$$2$$__mptr$link1 - (signed long int)88ul);
  __n173$link1 = tmp_statement_expression$2$link1;
  _Bool tmp_if_expr$5$link1;
  struct cluster_driver *tmp_statement_expression$3$link1;
  for( ; !(&cdrv$link1->list == &(&cluster_drivers)->n); __n173$link1 = tmp_statement_expression$3$link1)
  {
    unsigned long int return_value_strlen$4$link1;
    return_value_strlen$4$link1=strlen(cdrv$link1->name);
    len$link1 = (signed int)return_value_strlen$4$link1;
    signed int return_value_strncmp$6$link1;
    return_value_strncmp$6$link1=strncmp(cdrv$link1->name, name$link1, (unsigned long int)len$link1);
    if(return_value_strncmp$6$link1 == 0)
    {
      if((signed int)name$link1[(signed long int)len$link1] == 58)
        tmp_if_expr$5$link1 = (_Bool)1;

      else
        tmp_if_expr$5$link1 = (signed int)name$link1[(signed long int)len$link1] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5$link1)
        return cdrv$link1;

    }

    cdrv$link1 = __n173$link1;
    const struct list_node *__mptr$link1 = __n173$link1->list.next;
    tmp_statement_expression$3$link1 = (struct cluster_driver *)((char *)__mptr$link1 - (signed long int)88ul);
  }
  return (struct cluster_driver *)(void *)0;
}

// find_free_idx
// file vdi.c line 253
static signed int find_free_idx(unsigned int *vdi_id, unsigned long int max_idx)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= max_idx); i = i + 1)
    if(vdi_id[(signed long int)i] == 0u)
      return i;

  return -1;
}

// find_hdrv
// file http/http.h line 77
static inline struct http_driver * find_hdrv(struct list_head *drivers, const char *name)
{
  struct http_driver *hdrv;
  signed int len;
  struct http_driver *__n83;
  struct http_driver *tmp_statement_expression$1;
  const struct list_node *__mptr = drivers->n.next;
  tmp_statement_expression$1 = (struct http_driver *)((char *)__mptr - (signed long int)56ul);
  hdrv = tmp_statement_expression$1;
  struct http_driver *tmp_statement_expression$2;
  const struct list_node *find_hdrv$$1$$1$$2$$__mptr = hdrv->list.next;
  tmp_statement_expression$2 = (struct http_driver *)((char *)find_hdrv$$1$$1$$2$$__mptr - (signed long int)56ul);
  __n83 = tmp_statement_expression$2;
  _Bool tmp_if_expr$5;
  struct http_driver *tmp_statement_expression$3;
  for( ; !(&hdrv->list == &drivers->n); __n83 = tmp_statement_expression$3)
  {
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(hdrv->name);
    len = (signed int)return_value_strlen$4;
    signed int return_value_strncmp$6;
    return_value_strncmp$6=strncmp(hdrv->name, name, (unsigned long int)len);
    if(return_value_strncmp$6 == 0)
    {
      if((signed int)name[(signed long int)len] == 58)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)name[(signed long int)len] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return hdrv;

    }

    hdrv = __n83;
    const struct list_node *find_hdrv$$1$$1$$3$$__mptr = __n83->list.next;
    tmp_statement_expression$3 = (struct http_driver *)((char *)find_hdrv$$1$$1$$3$$__mptr - (signed long int)56ul);
  }
  return (struct http_driver *)(void *)0;
}

// find_next_bit
// file ../include/bitops.h line 93
static inline unsigned long int find_next_bit(const unsigned long int *addr, unsigned long int size, unsigned long int offset)
{
  const unsigned long int *p = addr + (signed long int)(offset / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ));
  unsigned long int result = offset & ~((unsigned long int)8 * sizeof(signed long int) /*8ul*/  - (unsigned long int)1);
  unsigned long int tmp;
  const unsigned long int *tmp_post$1;
  const unsigned long int *tmp_post$2;
  signed int tmp_if_expr$4;
  signed int return_value___builtin_ffsl$3;
  if(offset >= size)
    return size;

  else
  {
    size = size - result;
    offset = offset % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
    if(!(offset == 0ul))
    {
      tmp_post$1 = p;
      p = p + 1l;
      tmp = *tmp_post$1;
      tmp = tmp & ~0UL << offset;
      if(!(size >= sizeof(signed long int) * 8 /*64ul*/ ))
        goto found_first;

      if(!(tmp == 0ul))
        goto found_middle;

      size = size - (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
      result = result + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
    }

    for( ; !((18446744073709551552ul & size) == 0ul); size = size - (unsigned long int)8 * sizeof(signed long int) /*8ul*/ )
    {
      tmp_post$2 = p;
      p = p + 1l;
      tmp = *tmp_post$2;
      if(!(tmp == 0ul))
        goto found_middle;

      result = result + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
    }
    if(size == 0ul)
      return result;

    else
    {
      tmp = *p;

    found_first:
      ;
      tmp = tmp & ~0UL >> (unsigned long int)8 * sizeof(signed long int) /*8ul*/  - size;
      if(tmp == 0UL)
        return result + size;

      else
      {

      found_middle:
        ;
        if(!(tmp == 0ul))
        {
          return_value___builtin_ffsl$3=__builtin_ffsl(tmp);
          tmp_if_expr$4 = return_value___builtin_ffsl$3 - 1;
        }

        else
          tmp_if_expr$4 = 0;
        return result + (unsigned long int)tmp_if_expr$4;
      }
    }
  }
}

// find_next_zero_bit
// file ../include/bitops.h line 52
static inline unsigned long int find_next_zero_bit(const unsigned long int *addr, unsigned long int size, unsigned long int offset)
{
  const unsigned long int *p = addr + (signed long int)(offset / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ));
  unsigned long int result = offset & ~((unsigned long int)8 * sizeof(signed long int) /*8ul*/  - (unsigned long int)1);
  unsigned long int tmp;
  const unsigned long int *tmp_post$1;
  const unsigned long int *tmp_post$2;
  signed int tmp_if_expr$4;
  signed int return_value___builtin_ffsl$3;
  if(offset >= size)
    return size;

  else
  {
    size = size - result;
    offset = offset % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
    if(!(offset == 0ul))
    {
      tmp_post$1 = p;
      p = p + 1l;
      tmp = *tmp_post$1;
      tmp = tmp | ~0UL >> (unsigned long int)8 * sizeof(signed long int) /*8ul*/  - offset;
      if(!(size >= sizeof(signed long int) * 8 /*64ul*/ ))
        goto found_first;

      if(!(~tmp == 0ul))
        goto found_middle;

      size = size - (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
      result = result + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
    }

    for( ; !((18446744073709551552ul & size) == 0ul); size = size - (unsigned long int)8 * sizeof(signed long int) /*8ul*/ )
    {
      tmp_post$2 = p;
      p = p + 1l;
      tmp = *tmp_post$2;
      if(!(~tmp == 0ul))
        goto found_middle;

      result = result + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
    }
    if(size == 0ul)
      return result;

    else
    {
      tmp = *p;

    found_first:
      ;
      tmp = tmp | ~0UL << size;
      if(tmp == 18446744073709551615ul)
        return result + size;

      else
      {

      found_middle:
        ;
        if(!(~tmp == 0ul))
        {
          return_value___builtin_ffsl$3=__builtin_ffsl(~tmp);
          tmp_if_expr$4 = return_value___builtin_ffsl$3 - 1;
        }

        else
          tmp_if_expr$4 = 0;
        return result + (unsigned long int)tmp_if_expr$4;
      }
    }
  }
}

// find_object_cache
// file object_cache.c line 607
static struct object_cache * find_object_cache(unsigned int vid, _Bool create)
{
  signed int h;
  h=hash((unsigned long int)vid);
  struct hlist_head *head = cache_hashtable + (signed long int)h;
  struct object_cache *cache = (struct object_cache *)(void *)0;
  struct hlist_node *node;
  if(!(create == (_Bool)0))
    sd_write_lock$link1(&hashtable_lock[(signed long int)h]);

  else
    sd_read_lock$link1(&hashtable_lock[(signed long int)h]);
  _Bool return_value_hlist_empty$1;
  return_value_hlist_empty$1=hlist_empty(head);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct object_cache *tmp_statement_expression$3;
  if(return_value_hlist_empty$1 == (_Bool)0)
  {
    struct hlist_node *__n622;
    node = head->first;
    __n622 = (struct hlist_node *)(void *)0;
    do
    {
      if(!(node == ((struct hlist_node *)NULL)))
      {
        __n622 = node->next;
        tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        const struct hlist_node *__mptr = node;
        tmp_statement_expression$3 = (struct object_cache *)((char *)__mptr - (signed long int)16ul);
        cache = tmp_statement_expression$3;
        tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      if(cache->vid == vid)
        goto out;

      node = __n622;
    }
    while((_Bool)1);
  }


not_found:
  ;
  if(!(create == (_Bool)0))
  {
    void *return_value_xzalloc$5;
    return_value_xzalloc$5=xzalloc(sizeof(struct object_cache) /*176ul*/ );
    cache = (struct object_cache *)return_value_xzalloc$5;
    cache->vid = vid;
    INIT_RB_ROOT$link2(&cache->lru_tree);
    create_dir_for(vid);
    cache->push_efd=eventfd((unsigned int)0, 0);
    INIT_LIST_HEAD$link2(&cache->dirty_head);
    INIT_LIST_HEAD$link2(&cache->lru_head);
    sd_init_rw_lock(&cache->lock);
    hlist_add_head(&cache->hash, head);
    sd_init_mutex$link1(&cache->push_mutex);
  }

  else
    cache = (struct object_cache *)(void *)0;

out:
  ;
  sd_rw_unlock$link1(&hashtable_lock[(signed long int)h]);
  return cache;
}

// find_store_driver
// file sheep_priv.h line 261
static inline struct store_driver * find_store_driver(const char *name)
{
  struct store_driver *driver;
  struct store_driver *__n265;
  struct store_driver *tmp_statement_expression$1;
  const struct list_node *find_store_driver$$1$$1$$1$$__mptr = (&store_drivers)->n.next;
  tmp_statement_expression$1 = (struct store_driver *)((char *)find_store_driver$$1$$1$$1$$__mptr - (signed long int)0ul);
  driver = tmp_statement_expression$1;
  struct store_driver *tmp_statement_expression$2;
  const struct list_node *find_store_driver$$1$$1$$2$$__mptr = driver->list.next;
  tmp_statement_expression$2 = (struct store_driver *)((char *)find_store_driver$$1$$1$$2$$__mptr - (signed long int)0ul);
  __n265 = tmp_statement_expression$2;
  struct store_driver *tmp_statement_expression$3;
  for( ; !(&driver->list == &(&store_drivers)->n); __n265 = tmp_statement_expression$3)
  {
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(driver->name, name);
    if(return_value_strcmp$4 == 0)
      return driver;

    driver = __n265;
    const struct list_node *__mptr = __n265->list.next;
    tmp_statement_expression$3 = (struct store_driver *)((char *)__mptr - (signed long int)0ul);
  }
  return (struct store_driver *)(void *)0;
}

// find_store_driver$link1
// file sheep_priv.h line 261
static inline struct store_driver * find_store_driver$link1(const char *name$link1)
{
  struct store_driver *driver$link1;
  struct store_driver *__n265$link1;
  struct store_driver *tmp_statement_expression$1$link1;
  const struct list_node *__mptr$link1 = (&store_drivers)->n.next;
  tmp_statement_expression$1$link1 = (struct store_driver *)((char *)__mptr$link1 - (signed long int)0ul);
  driver$link1 = tmp_statement_expression$1$link1;
  struct store_driver *tmp_statement_expression$2$link1;
  const struct list_node *find_store_driver$$1$$1$$2$$__mptr$link1 = driver$link1->list.next;
  tmp_statement_expression$2$link1 = (struct store_driver *)((char *)find_store_driver$$1$$1$$2$$__mptr$link1 - (signed long int)0ul);
  __n265$link1 = tmp_statement_expression$2$link1;
  struct store_driver *tmp_statement_expression$3$link1;
  for( ; !(&driver$link1->list == &(&store_drivers)->n); __n265$link1 = tmp_statement_expression$3$link1)
  {
    signed int return_value_strcmp$4$link1;
    return_value_strcmp$4$link1=strcmp(driver$link1->name, name$link1);
    if(return_value_strcmp$4$link1 == 0)
      return driver$link1;

    driver$link1 = __n265$link1;
    const struct list_node *find_store_driver$$1$$1$$3$$__mptr$link1 = __n265$link1->list.next;
    tmp_statement_expression$3$link1 = (struct store_driver *)((char *)find_store_driver$$1$$1$$3$$__mptr$link1 - (signed long int)0ul);
  }
  return (struct store_driver *)(void *)0;
}

// find_store_driver$link2
// file sheep_priv.h line 261
static inline struct store_driver * find_store_driver$link2(const char *name$link2)
{
  struct store_driver *driver$link2;
  struct store_driver *__n265$link2;
  struct store_driver *tmp_statement_expression$1$link2;
  const struct list_node *__mptr$link2 = (&store_drivers)->n.next;
  tmp_statement_expression$1$link2 = (struct store_driver *)((char *)__mptr$link2 - (signed long int)0ul);
  driver$link2 = tmp_statement_expression$1$link2;
  struct store_driver *tmp_statement_expression$2$link2;
  const struct list_node *find_store_driver$$1$$1$$2$$__mptr$link2 = driver$link2->list.next;
  tmp_statement_expression$2$link2 = (struct store_driver *)((char *)find_store_driver$$1$$1$$2$$__mptr$link2 - (signed long int)0ul);
  __n265$link2 = tmp_statement_expression$2$link2;
  struct store_driver *tmp_statement_expression$3$link2;
  for( ; !(&driver$link2->list == &(&store_drivers)->n); __n265$link2 = tmp_statement_expression$3$link2)
  {
    signed int return_value_strcmp$4$link2;
    return_value_strcmp$4$link2=strcmp(driver$link2->name, name$link2);
    if(return_value_strcmp$4$link2 == 0)
      return driver$link2;

    driver$link2 = __n265$link2;
    const struct list_node *find_store_driver$$1$$1$$3$$__mptr$link2 = __n265$link2->list.next;
    tmp_statement_expression$3$link2 = (struct store_driver *)((char *)find_store_driver$$1$$1$$3$$__mptr$link2 - (signed long int)0ul);
  }
  return (struct store_driver *)(void *)0;
}

// find_string_integer
// file md.c line 162
static signed long int find_string_integer(const char *str, const char *delimiter)
{
  char *pos;
  pos=strstr(str, delimiter);
  char *p;
  signed long int ret;
  ret=strtoll(pos + (signed long int)1, &p, 10);
  if(p == pos + 1l || ret == 0x7fffffffffffffffLL)
  {
    log_write(3, "find_string_integer", 169, "%s strtoul failed, delimiter %s, %m", str, delimiter);
    return (signed long int)-1;
  }

  else
    return ret;
}

// finish_object_list
// file recovery.c line 877
static void finish_object_list(struct work *work)
{
  struct recovery_work *rw;
  struct recovery_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct recovery_work *)((char *)__mptr - (signed long int)24ul);
  rw = tmp_statement_expression$1;
  struct recovery_list_work *rlw;
  struct recovery_list_work *tmp_statement_expression$2;
  const struct recovery_work *finish_object_list$$1$$2$$__mptr = rw;
  tmp_statement_expression$2 = (struct recovery_list_work *)((char *)finish_object_list$$1$$2$$__mptr - (signed long int)0ul);
  rlw = tmp_statement_expression$2;
  struct recovery_info *rinfo;
  struct recovery_info *tmp_statement_expression$3 = current_rinfo.__val;
  rinfo = tmp_statement_expression$3;
  rinfo->state = (enum rw_state)RW_RECOVER_OBJ;
  rinfo->count = rlw->count;
  rinfo->oids = rlw->oids;
  rlw->oids = (unsigned long int *)(void *)0;
  free_recovery_list_work(rlw);
  _Bool return_value_run_next_rw$4;
  return_value_run_next_rw$4=run_next_rw();
  if(return_value_run_next_rw$4 == (_Bool)0)
  {
    if(rinfo->count == 0ul)
      finish_recovery(rinfo);

    else
    {
      recover_next_object(rinfo);
      goto __CPROVER_DUMP_L3;
    }
  }


__CPROVER_DUMP_L3:
  ;
}

// finish_one_entry
// file gateway.c line 322
static inline void finish_one_entry(struct forward_info *fi, signed int i)
{
  sockfd_cache_put(fi->ent[(signed long int)i].nid, fi->ent[(signed long int)i].sfd);
  forward_info_update(fi, i);
}

// finish_one_entry_err
// file gateway.c line 328
static inline void finish_one_entry_err(struct forward_info *fi, signed int i)
{
  sockfd_cache_del(fi->ent[(signed long int)i].nid, fi->ent[(signed long int)i].sfd);
  forward_info_update(fi, i);
}

// finish_recovery
// file recovery.c line 725
static inline void finish_recovery(struct recovery_info *rinfo)
{
  unsigned int recovered_epoch = rinfo->epoch;
  current_rinfo.__val = (struct recovery_info *)(void *)0;
  wakeup_all_requests();
  if(!(rinfo->notify_complete == (_Bool)0))
  {
    rinfo->state = (enum rw_state)RW_NOTIFY_COMPLETION;
    queue_recovery_work(rinfo);
  }

  free_recovery_info(rinfo);
  if(sd_log_level == 7)
    log_write(7, "finish_recovery", 739, "recovery complete: new epoch %u", recovered_epoch);

}

// finish_requests
// file gateway.c line 197
static void finish_requests(struct request *req, struct req_iter *reqs, signed int nr_to_send)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  unsigned int len = req->rq.data_length;
  unsigned long int off = (unsigned long int)req->rq.$anon0.obj.offset;
  signed int opcode = (signed int)req->rq.opcode;
  signed int start = (signed int)(off / (unsigned long int)1024);
  signed int end = (signed int)(((off + (unsigned long int)len + (unsigned long int)1024) - (unsigned long int)1) / (unsigned long int)1024);
  signed int i;
  signed int j;
  signed int nr_stripe = end - start;
  _Bool return_value_is_erasure_oid$1;
  return_value_is_erasure_oid$1=is_erasure_oid(oid);
  signed int tmp_if_expr$5;
  unsigned int return_value_oid_to_vid$3;
  signed int return_value_get_vdi_copy_policy$4;
  if(!(return_value_is_erasure_oid$1 == (_Bool)0))
  {
    if(sd_log_level == 7)
      log_write(7, "finish_requests", 212, "start %d, end %d, send %d, off %lu, len %u", start, end, nr_to_send, off, len);

    if(opcode == 0x02)
    {
      char *p;
      char *buf;
      void *return_value_xmalloc$2;
      return_value_xmalloc$2=xmalloc((unsigned long int)(1024 * nr_stripe));
      buf = (char *)return_value_xmalloc$2;
      unsigned char policy;
      if(!((signed int)req->rq.$anon0.obj.copy_policy == 0))
        tmp_if_expr$5 = (signed int)req->rq.$anon0.obj.copy_policy;

      else
      {
        return_value_oid_to_vid$3=oid_to_vid$link1(req->rq.$anon0.obj.oid);
        return_value_get_vdi_copy_policy$4=get_vdi_copy_policy(return_value_oid_to_vid$3);
        tmp_if_expr$5 = return_value_get_vdi_copy_policy$4;
      }
      policy = (unsigned char)tmp_if_expr$5;
      signed int ed = 0;
      signed int strip_size;
      ec_policy_to_dp(policy, &ed, (signed int *)(void *)0);
      strip_size = 1024 / ed;
      p = buf;
      i = 0;
      for( ; !(i >= nr_stripe); i = i + 1)
      {
        j = 0;
        for( ; !(j >= nr_to_send); j = j + 1)
        {
          memcpy((void *)p, (const void *)((reqs + (signed long int)j)->buf + (signed long int)(strip_size * i)), (unsigned long int)strip_size);
          p = p + (signed long int)strip_size;
        }
      }
      memcpy(req->data, (const void *)(buf + (signed long int)(off % (unsigned long int)1024)), (unsigned long int)len);
      req->rp.data_length = req->rq.data_length;
      free((void *)buf);
    }

    i = 0;
    for( ; !(i >= nr_to_send); i = i + 1)
      free((void *)(reqs + (signed long int)i)->buf);
  }


out:
  ;
  free((void *)reqs);
}

// finish_schedule_oids
// file recovery.c line 758
static inline void finish_schedule_oids(struct recovery_info *rinfo)
{
  unsigned long int i;
  unsigned long int nr_recovered = rinfo->done;
  unsigned long int new_idx;
  unsigned long int *new_oids;
  void *return_value_xmalloc$1;
  unsigned long int tmp_post$3;
  if(!(nr_recovered == rinfo->count + 18446744073709551615ul))
  {
    return_value_xmalloc$1=xmalloc(list_buffer_size);
    new_oids = (unsigned long int *)return_value_xmalloc$1;
    memcpy((void *)new_oids, (const void *)rinfo->oids, nr_recovered * sizeof(unsigned long int) /*8ul*/ );
    memcpy((void *)(new_oids + (signed long int)nr_recovered), (const void *)rinfo->prio_oids, rinfo->nr_prio_oids * sizeof(unsigned long int) /*8ul*/ );
    new_idx = nr_recovered + rinfo->nr_prio_oids;
    i = rinfo->done;
    for( ; !(i >= rinfo->count); i = i + 1ul)
    {
      _Bool return_value_oid_in_prio_oids$2;
      return_value_oid_in_prio_oids$2=oid_in_prio_oids(rinfo, rinfo->oids[(signed long int)i]);
      if(return_value_oid_in_prio_oids$2 == (_Bool)0)
      {
        tmp_post$3 = new_idx;
        new_idx = new_idx + 1ul;
        new_oids[(signed long int)tmp_post$3] = rinfo->oids[(signed long int)i];
      }

    }
    if(sd_log_level == 7)
      log_write(7, "finish_schedule_oids", 782, "%snr_recovered %lu, nr_prio_oids %lu, count %lu = new %lu", rinfo->count == new_idx ? "" : "WARN: ", nr_recovered, rinfo->nr_prio_oids, rinfo->count, new_idx);

    free((void *)rinfo->oids);
    rinfo->oids = new_oids;
  }


done:
  ;
  free((void *)rinfo->prio_oids);
  rinfo->prio_oids = (unsigned long int *)(void *)0;
  rinfo->nr_scheduled_prio_oids = rinfo->nr_scheduled_prio_oids + rinfo->nr_prio_oids;
  rinfo->nr_prio_oids = (unsigned long int)0;
}

// fls64
// file ../include/bitops.h line 184
static inline signed int fls64(unsigned long int x)
{
  if(x == 0ul)
    return 0;

  else
  {
    signed int return_value___builtin_clzl$1;
    return_value___builtin_clzl$1=__builtin_clzl(x);
    return 64 - return_value___builtin_clzl$1;
  }
}

// fnv_64a_64
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64(unsigned long int oid, unsigned long int hval)
{
  hval = hval ^ oid & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 8 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 16 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 24 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 32 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 40 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 48 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  hval = hval ^ oid >> 56 & (unsigned long int)0xff;
  hval = hval * (unsigned long int)0x100000001b3ULL;
  return hval;
}

// fnv_64a_64$link1
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link1(unsigned long int oid$link1, unsigned long int hval$link1)
{
  hval$link1 = hval$link1 ^ oid$link1 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 8 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 16 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 24 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 32 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 40 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 48 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  hval$link1 = hval$link1 ^ oid$link1 >> 56 & (unsigned long int)0xff;
  hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  return hval$link1;
}

// fnv_64a_64$link2
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link2(unsigned long int oid$link2, unsigned long int hval$link2)
{
  hval$link2 = hval$link2 ^ oid$link2 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 8 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 16 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 24 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 32 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 40 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 48 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  hval$link2 = hval$link2 ^ oid$link2 >> 56 & (unsigned long int)0xff;
  hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  return hval$link2;
}

// fnv_64a_64$link3
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link3(unsigned long int oid$link3, unsigned long int hval$link3)
{
  hval$link3 = hval$link3 ^ oid$link3 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 8 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 16 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 24 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 32 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 40 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 48 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  hval$link3 = hval$link3 ^ oid$link3 >> 56 & (unsigned long int)0xff;
  hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  return hval$link3;
}

// fnv_64a_64$link4
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link4(unsigned long int oid$link4, unsigned long int hval$link4)
{
  hval$link4 = hval$link4 ^ oid$link4 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 8 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 16 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 24 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 32 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 40 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 48 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  hval$link4 = hval$link4 ^ oid$link4 >> 56 & (unsigned long int)0xff;
  hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  return hval$link4;
}

// fnv_64a_64$link5
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link5(unsigned long int oid$link5, unsigned long int hval$link5)
{
  hval$link5 = hval$link5 ^ oid$link5 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 8 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 16 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 24 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 32 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 40 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 48 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  hval$link5 = hval$link5 ^ oid$link5 >> 56 & (unsigned long int)0xff;
  hval$link5 = hval$link5 * (unsigned long int)0x100000001b3ULL;
  return hval$link5;
}

// fnv_64a_64$link6
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link6(unsigned long int oid$link6, unsigned long int hval$link6)
{
  hval$link6 = hval$link6 ^ oid$link6 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 8 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 16 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 24 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 32 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 40 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 48 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  hval$link6 = hval$link6 ^ oid$link6 >> 56 & (unsigned long int)0xff;
  hval$link6 = hval$link6 * (unsigned long int)0x100000001b3ULL;
  return hval$link6;
}

// fnv_64a_64$link7
// file ../include/sheepdog_proto.h line 319
static inline unsigned long int fnv_64a_64$link7(unsigned long int oid$link7, unsigned long int hval$link7)
{
  hval$link7 = hval$link7 ^ oid$link7 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 8 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 16 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 24 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 32 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 40 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 48 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  hval$link7 = hval$link7 ^ oid$link7 >> 56 & (unsigned long int)0xff;
  hval$link7 = hval$link7 * (unsigned long int)0x100000001b3ULL;
  return hval$link7;
}

// fnv_64a_buf
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf(const void *buf, unsigned long int len, unsigned long int hval)
{
  const unsigned char *p = (const unsigned char *)buf;
  signed int i = 0;
  for( ; !((unsigned long int)i >= len); i = i + 1)
  {
    hval = hval ^ (unsigned long int)p[(signed long int)i];
    hval = hval * (unsigned long int)0x100000001b3ULL;
  }
  return hval;
}

// fnv_64a_buf$link1
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link1(const void *buf$link1, unsigned long int len$link1, unsigned long int hval$link1)
{
  const unsigned char *p$link1 = (const unsigned char *)buf$link1;
  signed int i$link1 = 0;
  for( ; !((unsigned long int)i$link1 >= len$link1); i$link1 = i$link1 + 1)
  {
    hval$link1 = hval$link1 ^ (unsigned long int)p$link1[(signed long int)i$link1];
    hval$link1 = hval$link1 * (unsigned long int)0x100000001b3ULL;
  }
  return hval$link1;
}

// fnv_64a_buf$link2
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link2(const void *buf$link2, unsigned long int len$link2, unsigned long int hval$link2)
{
  const unsigned char *p$link2 = (const unsigned char *)buf$link2;
  signed int i$link2 = 0;
  for( ; !((unsigned long int)i$link2 >= len$link2); i$link2 = i$link2 + 1)
  {
    hval$link2 = hval$link2 ^ (unsigned long int)p$link2[(signed long int)i$link2];
    hval$link2 = hval$link2 * (unsigned long int)0x100000001b3ULL;
  }
  return hval$link2;
}

// fnv_64a_buf$link3
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link3(const void *buf$link3, unsigned long int len$link3, unsigned long int hval$link3)
{
  const unsigned char *p$link3 = (const unsigned char *)buf$link3;
  signed int i$link3 = 0;
  for( ; !((unsigned long int)i$link3 >= len$link3); i$link3 = i$link3 + 1)
  {
    hval$link3 = hval$link3 ^ (unsigned long int)p$link3[(signed long int)i$link3];
    hval$link3 = hval$link3 * (unsigned long int)0x100000001b3ULL;
  }
  return hval$link3;
}

// fnv_64a_buf$link4
// file ../include/sheepdog_proto.h line 303
static inline unsigned long int fnv_64a_buf$link4(const void *buf$link4, unsigned long int len$link4, unsigned long int hval$link4)
{
  const unsigned char *p$link4 = (const unsigned char *)buf$link4;
  signed int i$link4 = 0;
  for( ; !((unsigned long int)i$link4 >= len$link4); i$link4 = i$link4 + 1)
  {
    hval$link4 = hval$link4 ^ (unsigned long int)p$link4[(signed long int)i$link4];
    hval$link4 = hval$link4 * (unsigned long int)0x100000001b3ULL;
  }
  return hval$link4;
}

// for_each_epoch
// file migrate.c line 88
static void for_each_epoch(signed int (*func)(unsigned int))
{
  struct __dirstream *dir;
  struct dirent *d;
  dir=opendir(epoch_path);
  if(dir == ((struct __dirstream *)NULL))
  {
    log_write(0, "for_each_epoch", 95, "PANIC: failed to open %s: %m", epoch_path);
    abort();
  }

  do
  {
    d=readdir(dir);
    if(d == ((struct dirent *)NULL))
      break;

    unsigned int e;
    char *p;
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(d->d_name, &p, 10);
    e = (unsigned int)return_value_strtol$1;
    if(!(d->d_name == p))
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(d->d_name);
      if(return_value_strlen$2 == 8ul)
      {
        signed int return_value;
        return_value=func(e);
      }

    }

  }
  while((_Bool)1);
  closedir(dir);
}

// for_each_obj_path
// file sheep_priv.h line 250
signed int for_each_obj_path(signed int (*func)(const char *))
{
  signed int ret = 0x00;
  struct disk *disk;
  sd_read_lock$link3(&md.lock);
  struct rb_node *__p496;
  __p496=rb_first(&md.root);
  struct rb_node *__n496;
  _Bool tmp_if_expr$1;
  if(!(__p496 == ((struct rb_node *)NULL)))
  {
    __n496=rb_next(__p496);
    tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  struct disk *tmp_statement_expression$2;
  if(tmp_if_expr$1)
  {
    const struct rb_node *__mptr = __p496;
    tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
    disk = tmp_statement_expression$2;
    tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    ret=func(disk->path);
    if(ret == 0x00)
      __p496 = __n496;

  }

  sd_rw_unlock$link3(&md.lock);
  return ret;
}

// for_each_object_in_path
// file md.c line 177
static signed int for_each_object_in_path(const char *path, signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *), _Bool cleanup, struct vnode_info *vinfo, void *arg)
{
  struct __dirstream *dir;
  struct dirent *d;
  unsigned long int oid;
  signed int ret = 0x00;
  dir=opendir(path);
  if(dir == ((struct __dirstream *)NULL))
  {
    log_write(3, "for_each_object_in_path", 191, "failed to open %s, %m", path);
    return 0x03;
  }

  else
  {
    do
    {
      d=readdir(dir);
      if(d == ((struct dirent *)NULL))
        break;

      unsigned int epoch = (unsigned int)0;
      unsigned char ec_index = (unsigned char)(16 * 2 - 1);
      signed int return_value_strncmp$1;
      return_value_strncmp$1=strncmp(d->d_name, ".", (unsigned long int)1);
      if(!(return_value_strncmp$1 == 0))
      {
        if(sd_log_level == 7)
          log_write(7, "for_each_object_in_path", 203, "%s, %s", path, (const void *)d->d_name);

        oid=strtoull(d->d_name, (char ** restrict )(void *)0, 16);
        if(!(oid == 0ul) && !(oid == 1ULL))
        {
          _Bool return_value_is_tmp_dentry$2;
          return_value_is_tmp_dentry$2=is_tmp_dentry(d->d_name);
          if(!(return_value_is_tmp_dentry$2 == (_Bool)0))
          {
            if(!(cleanup == (_Bool)0))
            {
              if(sd_log_level == 7)
                log_write(7, "for_each_object_in_path", 211, "remove tmp object %s", (const void *)d->d_name);

              unlink(d->d_name);
            }

          }

          else
          {
            _Bool return_value_is_stale_dentry$4;
            return_value_is_stale_dentry$4=is_stale_dentry(d->d_name);
            if(!(return_value_is_stale_dentry$4 == (_Bool)0))
            {
              signed long int return_value_find_string_integer$3;
              return_value_find_string_integer$3=find_string_integer(d->d_name, ".");
              epoch = (unsigned int)return_value_find_string_integer$3;
            }

            _Bool return_value_is_ec_dentry$6;
            return_value_is_ec_dentry$6=is_ec_dentry(d->d_name);
            if(!(return_value_is_ec_dentry$6 == (_Bool)0))
            {
              signed long int return_value_find_string_integer$5;
              return_value_find_string_integer$5=find_string_integer(d->d_name, "_");
              ec_index = (unsigned char)return_value_find_string_integer$5;
              if(!((signed int)ec_index >= 0))
                continue;

            }

            ret=func(oid, path, epoch, ec_index, vinfo, arg);
            if(!(ret == 0x00))
              break;

          }
        }

      }

    }
    while((_Bool)1);
    closedir(dir);
    return ret;
  }
}

// for_each_object_in_stale
// file sheep_priv.h line 246
signed int for_each_object_in_stale(signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *), void *arg)
{
  signed int ret = 0x00;
  char path[4096l];
  struct disk *disk;
  sd_read_lock$link3(&md.lock);
  struct rb_node *__p479;
  __p479=rb_first(&md.root);
  struct rb_node *__n479;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct disk *tmp_statement_expression$2;
  do
  {
    if(!(__p479 == ((struct rb_node *)NULL)))
    {
      __n479=rb_next(__p479);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p479;
      tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
      disk = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/.stale", (const void *)disk->path);
    ret=for_each_object_in_path(path, func, (_Bool)0, (struct vnode_info *)(void *)0, arg);
    if(!(ret == 0x00))
      break;

    __p479 = __n479;
  }
  while((_Bool)1);
  sd_rw_unlock$link3(&md.lock);
  return ret;
}

// for_each_object_in_wd
// file sheep_priv.h line 243
signed int for_each_object_in_wd(signed int (*func)(unsigned long int, const char *, unsigned int, unsigned char, struct vnode_info *, void *), _Bool cleanup, void *arg)
{
  signed int ret = 0x00;
  struct disk *disk;
  struct process_path_arg *thread_args;
  struct process_path_arg *path_arg;
  struct vnode_info *vinfo;
  void *ret_arg;
  unsigned long int *thread_array;
  signed int nr_thread = 0;
  signed int idx = 0;
  sd_read_lock$link3(&md.lock);
  struct rb_node *__p416;
  __p416=rb_first(&md.root);
  struct rb_node *__n416;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct disk *tmp_statement_expression$2;
  do
  {
    if(!(__p416 == ((struct rb_node *)NULL)))
    {
      __n416=rb_next(__p416);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p416;
      tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
      disk = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    nr_thread = nr_thread + 1;
    __p416 = __n416;
  }
  while((_Bool)1);
  void *return_value_xmalloc$4;
  return_value_xmalloc$4=xmalloc((unsigned long int)nr_thread * sizeof(struct process_path_arg) /*48ul*/ );
  thread_args = (struct process_path_arg *)return_value_xmalloc$4;
  void *return_value_xmalloc$5;
  return_value_xmalloc$5=xmalloc((unsigned long int)nr_thread * sizeof(unsigned long int) /*8ul*/ );
  thread_array = (unsigned long int *)return_value_xmalloc$5;
  vinfo=get_vnode_info();
  struct rb_node *__p425;
  __p425=rb_first(&md.root);
  struct rb_node *__n425;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  struct disk *tmp_statement_expression$7;
  do
  {
    if(!(__p425 == ((struct rb_node *)NULL)))
    {
      __n425=rb_next(__p425);
      tmp_if_expr$6 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      const struct rb_node *for_each_object_in_wd$$1$$2$$1$$__mptr = __p425;
      tmp_statement_expression$7 = (struct disk *)((char *)for_each_object_in_wd$$1$$2$$1$$__mptr - (signed long int)0ul);
      disk = tmp_statement_expression$7;
      tmp_if_expr$8 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    if(!tmp_if_expr$8)
      break;

    (thread_args + (signed long int)idx)->path = disk->path;
    (thread_args + (signed long int)idx)->vinfo = vinfo;
    (thread_args + (signed long int)idx)->func = func;
    (thread_args + (signed long int)idx)->cleanup = cleanup;
    (thread_args + (signed long int)idx)->opaque = arg;
    (thread_args + (signed long int)idx)->result = 0x00;
    ret=pthread_create(thread_array + (signed long int)idx, (const union pthread_attr_t *)(void *)0, thread_process_path, (void *)(thread_args + (signed long int)idx));
    if(!(ret == 0))
    {
      log_write(0, "for_each_object_in_wd", 442, "PANIC: Failed to create thread for path %s", (const void *)disk->path);
      abort();
    }

    idx = idx + 1;
    __p425 = __n425;
  }
  while((_Bool)1);
  if(sd_log_level == 7)
    log_write(7, "for_each_object_in_wd", 447, "Create %d threads for all path", nr_thread);

  idx = 0;
  const char *return_value_sd_strerror$9;
  for( ; !(idx >= nr_thread); idx = idx + 1)
  {
    ret=pthread_join(thread_array[(signed long int)idx], &ret_arg);
    if(!(ret == 0))
      log_write(3, "for_each_object_in_wd", 452, "Failed to join thread");

    if(!(ret_arg == NULL))
    {
      path_arg = (struct process_path_arg *)ret_arg;
      if(!(path_arg->result == 0x00))
      {
        return_value_sd_strerror$9=sd_strerror$link7(path_arg->result);
        log_write(3, "for_each_object_in_wd", 457, "%s, %s", path_arg->path, return_value_sd_strerror$9);
      }

    }

  }
  put_vnode_info(vinfo);
  sd_rw_unlock$link3(&md.lock);
  free((void *)thread_args);
  free((void *)thread_array);
  return ret;
}

// format_thread_name
// file logger.c line 156
static const char * format_thread_name(char *str, unsigned long int size, const char *name, signed int idx)
{
  _Bool tmp_if_expr$2;
  if(!(name == ((const char *)NULL)))
    tmp_if_expr$2 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$1;
  if(!(idx == 0) && tmp_if_expr$2)
    snprintf(str, size, "%s %d", name, idx);

  else
  {
    if(!(name == ((const char *)NULL)))
      tmp_if_expr$1 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      snprintf(str, size, "%s", name);

    else
      snprintf(str, size, "main");
  }
  return str;
}

// forward_info_advance
// file gateway.c line 458
static inline void forward_info_advance(struct forward_info *fi, struct node_id *nid, struct sockfd *sfd, void *buf)
{
  fi->ent[(signed long int)fi->nr_sent].nid = nid;
  fi->ent[(signed long int)fi->nr_sent].pfd.fd = sfd->fd;
  fi->ent[(signed long int)fi->nr_sent].pfd.events = (signed short int)0x001;
  fi->ent[(signed long int)fi->nr_sent].sfd = sfd;
  fi->ent[(signed long int)fi->nr_sent].buf = buf;
  fi->nr_sent = fi->nr_sent + 1;
}

// forward_info_find
// file gateway.c line 335
static inline struct forward_info_entry * forward_info_find(struct forward_info *fi, signed int fd)
{
  signed int i = 0;
  for( ; !(i >= fi->nr_sent); i = i + 1)
    if(fi->ent[(signed long int)i].pfd.fd == fd)
      return &fi->ent[(signed long int)i];

  log_write(0, "forward_info_find", 341, "PANIC: can't find entry for %d", fd);
  abort();
  return (struct forward_info_entry *)(void *)0;
}

// forward_info_init
// file gateway.c line 449
static inline void forward_info_init(struct forward_info *fi, unsigned long int nr_to_send)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_to_send); i = i + 1)
    fi->ent[(signed long int)i].pfd.fd = -1;
  fi->nr_sent = 0;
}

// forward_info_update
// file gateway.c line 314
static inline void forward_info_update(struct forward_info *fi, signed int pos)
{
  if(sd_log_level == 7)
    log_write(7, "forward_info_update", 316, "%d, %d", fi->nr_sent, pos);

  fi->nr_sent = fi->nr_sent - 1;
  memmove((void *)(fi->ent + (signed long int)pos), (const void *)(fi->ent + (signed long int)pos + (signed long int)1), sizeof(struct forward_info_entry) /*32ul*/  * (unsigned long int)(fi->nr_sent - pos));
}

// forward_iov
// file net.c line 248
static void forward_iov(struct msghdr *msg, signed int len)
{
  for( ; (unsigned long int)len >= msg->msg_iov->iov_len; msg->msg_iovlen = msg->msg_iovlen - 1ul)
  {
    len = len - (signed int)msg->msg_iov->iov_len;
    msg->msg_iov = msg->msg_iov + 1l;
  }
  msg->msg_iov->iov_base = (void *)((char *)msg->msg_iov->iov_base + (signed long int)len);
  msg->msg_iov->iov_len = msg->msg_iov->iov_len - (unsigned long int)len;
}

// free_cache_entry
// file object_cache.c line 270
static inline void free_cache_entry(struct object_cache_entry *entry)
{
  struct object_cache *oc = entry->oc;
  rb_erase(&entry->node, &oc->lru_tree);
  list_del$link2(&entry->lru_list);
  oc->total_count = oc->total_count - 1u;
  _Bool return_value_list_linked$1;
  return_value_list_linked$1=list_linked(&entry->dirty_list);
  if(!(return_value_list_linked$1 == (_Bool)0))
    del_from_dirty_list(entry);

  sd_destroy_rw_lock(&entry->lock);
  free((void *)entry);
}

// free_cache_entry$link1
// file sockfd_cache.c line 149
static void free_cache_entry$link1(struct sockfd_cache_entry *entry$link1)
{
  free((void *)entry$link1->fds);
  free((void *)entry$link1);
}

// free_desc_cmp
// file http/oalloc.c line 195
static signed int free_desc_cmp(struct free_desc *a, struct free_desc *b)
{
  signed int tmp_statement_expression$1;
  unsigned long int _x = a->start;
  unsigned long int _y = b->start;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return -tmp_statement_expression$1;
}

// free_local_request
// file request.c line 529
static void free_local_request(struct request *req)
{
  put_vnode_info(req->vinfo);
  free((void *)req);
}

// free_logarea
// file logger.c line 350
static void free_logarea(void)
{
  if(log_fd >= 0)
    close(log_fd);

  semctl(la->semid, 0, 0, la->semarg);
  shmdt((const void *)la->start);
  shmdt((const void *)la);
}

// free_recovery_info
// file recovery.c line 664
static void free_recovery_info(struct recovery_info *rinfo)
{
  put_vnode_info(rinfo->cur_vinfo);
  put_vnode_info(rinfo->old_vinfo);
  free((void *)rinfo->oids);
  free((void *)rinfo->prio_oids);
  free((void *)rinfo);
}

// free_recovery_list_work
// file recovery.c line 649
static void free_recovery_list_work(struct recovery_list_work *rlw)
{
  put_vnode_info(rlw->base.cur_vinfo);
  put_vnode_info(rlw->base.old_vinfo);
  free((void *)rlw->oids);
  free((void *)rlw);
}

// free_recovery_obj_work
// file recovery.c line 657
static void free_recovery_obj_work(struct recovery_obj_work *row)
{
  put_vnode_info(row->base.cur_vinfo);
  put_vnode_info(row->base.old_vinfo);
  free((void *)row);
}

// free_recovery_work
// file recovery.c line 642
static void free_recovery_work(struct recovery_work *rw)
{
  put_vnode_info(rw->cur_vinfo);
  put_vnode_info(rw->old_vinfo);
  free((void *)rw);
}

// free_request
// file request.c line 677
static void free_request(struct request *req)
{
  __uatomic_dec((void *)&sys->nr_outstanding_reqs, (signed int)sizeof(signed int) /*4ul*/ );
  refcount_dec$link1(&req->ci->refcnt);
  put_vnode_info(req->vinfo);
  free(req->data);
  free((void *)req);
}

// gateway_create_and_write_obj
// file gateway.c line 607
signed int gateway_create_and_write_obj(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  _Bool return_value_oid_is_readonly$1;
  return_value_oid_is_readonly$1=oid_is_readonly(oid);
  signed int return_value_gateway_handle_cow$2;
  signed int return_value_object_cache_handle_request$3;
  if(!(return_value_oid_is_readonly$1 == (_Bool)0))
    return 0x1A;

  else
    if(!((0x02 & (signed int)req->rq.flags) == 0))
    {
      return_value_gateway_handle_cow$2=gateway_handle_cow(req);
      return return_value_gateway_handle_cow$2;
    }

    else
    {
      _Bool return_value_bypass_object_cache$4;
      return_value_bypass_object_cache$4=bypass_object_cache(req);
      if(return_value_bypass_object_cache$4 == (_Bool)0)
      {
        return_value_object_cache_handle_request$3=object_cache_handle_request(req);
        return return_value_object_cache_handle_request$3;
      }

      else
      {
        signed int return_value_gateway_forward_request$5;
        return_value_gateway_forward_request$5=gateway_forward_request(req);
        return return_value_gateway_forward_request$5;
      }
    }
}

// gateway_forward_request
// file gateway.c line 469
static signed int gateway_forward_request(struct request *req)
{
  signed int i;
  signed int err_ret = 0x00;
  signed int ret;
  unsigned int wlen;
  unsigned long int oid = req->rq.$anon0.obj.oid;
  struct forward_info fi;
  struct sd_req hdr;
  struct sd_node *target_nodes[6144l];
  signed int nr_copies;
  nr_copies=get_req_copy_number(req);
  signed int nr_reqs;
  signed int nr_to_send = 0;
  struct req_iter *reqs = (struct req_iter *)(void *)0;
  if(sd_log_level == 7)
    log_write(7, "gateway_forward_request", 480, "%lx", oid);

  gateway_init_fwd_hdr(&hdr, &req->rq);
  oid_to_nodes(oid, &req->vinfo->vroot, nr_copies, target_nodes);
  forward_info_init(&fi, (unsigned long int)nr_copies);
  reqs=prepare_requests(req, &nr_to_send);
  signed int tmp_if_expr$3;
  unsigned int return_value_oid_to_vid$1;
  signed int return_value_get_vdi_copy_policy$2;
  if(reqs == ((struct req_iter *)NULL))
    return 0x86;

  else
  {
    nr_reqs = nr_to_send;
    if(!(nr_copies >= nr_to_send))
    {
      unsigned char policy;
      if(!((signed int)req->rq.$anon0.obj.copy_policy == 0))
        tmp_if_expr$3 = (signed int)req->rq.$anon0.obj.copy_policy;

      else
      {
        return_value_oid_to_vid$1=oid_to_vid$link1(req->rq.$anon0.obj.oid);
        return_value_get_vdi_copy_policy$2=get_vdi_copy_policy(return_value_oid_to_vid$1);
        tmp_if_expr$3 = return_value_get_vdi_copy_policy$2;
      }
      policy = (unsigned char)tmp_if_expr$3;
      signed int ds;
      ec_policy_to_dp(policy, &ds, (signed int *)(void *)0);
      if(!(nr_copies >= ds))
      {
        log_write(3, "gateway_forward_request", 504, "There isn't enough copies(%d) to send out (%d)", nr_copies, nr_to_send);
        err_ret = 0x06;
        goto out;
      }

      nr_to_send = ds;
    }

    i = 0;
    for( ; !(i >= nr_to_send); i = i + 1)
    {
      struct sockfd *sfd;
      struct node_id *nid = &target_nodes[(signed long int)i]->nid;
      sfd=sockfd_cache_get(nid);
      if(sfd == ((struct sockfd *)NULL))
      {
        err_ret = 0x86;
        break;
      }

      hdr.data_length = (reqs + (signed long int)i)->dlen;
      wlen = (reqs + (signed long int)i)->wlen;
      hdr.$anon0.obj.offset = (unsigned int)(reqs + (signed long int)i)->off;
      hdr.$anon0.obj.ec_index = (unsigned char)i;
      hdr.$anon0.obj.copy_policy = req->rq.$anon0.obj.copy_policy;
      ret=send_req(sfd->fd, &hdr, (void *)(reqs + (signed long int)i)->buf, wlen, sheep_need_retry, req->rq.epoch, (unsigned int)(30 / 5));
      if(!(ret == 0))
      {
        sockfd_cache_del_node(nid);
        err_ret = 0x86;
        if(sd_log_level == 7)
          log_write(7, "gateway_forward_request", 533, "fail %d", ret);

        break;
      }

      forward_info_advance(&fi, nid, sfd, (void *)(reqs + (signed long int)i)->buf);
    }
    if(sd_log_level == 7)
      log_write(7, "gateway_forward_request", 539, "nr_sent %d, err %x", fi.nr_sent, err_ret);

    if(fi.nr_sent >= 1)
    {
      ret=wait_forward_request(&fi, req);
      if(!(ret == 0x00))
        err_ret = ret;

    }


  out:
    ;
    finish_requests(req, reqs, nr_reqs);
    return err_ret;
  }
}

// gateway_handle_cow
// file gateway.c line 576
static signed int gateway_handle_cow(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  unsigned long int len;
  len=get_objsize(oid);
  struct sd_req hdr;
  struct sd_req *req_hdr = &req->rq;
  char *buf;
  void *return_value_xvalloc$1;
  return_value_xvalloc$1=xvalloc(len);
  buf = (char *)return_value_xvalloc$1;
  signed int ret;
  if(!((unsigned long int)req->rq.data_length == len))
  {
    sd_init_req$link1(&hdr, (unsigned char)0x02);
    hdr.$anon0.obj.oid = req_hdr->$anon0.obj.cow_oid;
    hdr.data_length = (unsigned int)len;
    hdr.$anon0.obj.offset = (unsigned int)0;
    ret=exec_local_req(&hdr, (void *)buf);
    if(!(ret == 0x00))
      goto out;

  }

  memcpy((void *)(buf + (signed long int)req_hdr->$anon0.obj.offset), req->data, (unsigned long int)req_hdr->data_length);
  sd_init_req$link1(&hdr, (unsigned char)0x01);
  hdr.flags = (unsigned short int)0x01;
  hdr.$anon0.obj.oid = oid;
  hdr.data_length = (unsigned int)len;
  hdr.$anon0.obj.offset = (unsigned int)0;
  ret=exec_local_req(&hdr, (void *)buf);

out:
  ;
  free((void *)buf);
  return ret;
}

// gateway_init_fwd_hdr
// file gateway.c line 15
static inline void gateway_init_fwd_hdr(struct sd_req *fwd, struct sd_req *hdr)
{
  memcpy((void *)fwd, (const void *)hdr, sizeof(struct sd_req) /*48ul*/ );
  signed int return_value_gateway_to_peer_opcode$1;
  return_value_gateway_to_peer_opcode$1=gateway_to_peer_opcode((signed int)hdr->opcode);
  fwd->opcode = (unsigned char)return_value_gateway_to_peer_opcode$1;
  fwd->proto_ver = (unsigned char)0x09;
}

// gateway_op_done
// file request.c line 90
static void gateway_op_done(struct work *work)
{
  struct request *req;
  struct request *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)192ul);
  req = tmp_statement_expression$1;
  struct sd_req *hdr = &req->rq;
  const char *return_value_op_name$2;
  _Bool return_value_is_access_local$3;
  const char *return_value_sd_strerror$4;
  switch(req->rp.$anon0.result)
  {
    case (unsigned int)0x81:
      if(!(sys->cinfo.epoch >= req->rp.epoch))
      {
        sleep_on_wait_queue(req);
        goto __CPROVER_DUMP_L11;
      }

    case (unsigned int)0x82:

    case (unsigned int)0x86:

    case (unsigned int)0x17:

    case (unsigned int)0x16:

    case (unsigned int)0x8D:
    {
      if(sd_log_level == 7)
      {
        return_value_op_name$2=op_name(req->op);
        log_write(7, "gateway_op_done", 113, "retrying failed I/O request op %s result %x epoch %u, sys epoch %u", return_value_op_name$2, req->rp.$anon0.result, req->rq.epoch, sys->cinfo.epoch);
      }

      goto retry;
    }
    case (unsigned int)0x03:
    {
      return_value_is_access_local$3=is_access_local(req, hdr->$anon0.obj.oid);
      if(!(return_value_is_access_local$3 == (_Bool)0))
      {
        log_write(3, "gateway_op_done", 117, "leaving sheepdog cluster");
        leave_cluster();
        goto retry;
      }

      break;
    }
    case (unsigned int)0x00:
      break;
    default:
      if(sd_log_level == 7)
      {
        return_value_sd_strerror$4=sd_strerror$link1((signed int)req->rp.$anon0.result);
        log_write(7, "gateway_op_done", 125, "unhandled error %s", return_value_sd_strerror$4);
      }

  }
  put_request(req);
  goto __CPROVER_DUMP_L11;

retry:
  ;
  requeue_request(req);

__CPROVER_DUMP_L11:
  ;
}

// gateway_read_obj
// file gateway.c line 550
signed int gateway_read_obj(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  _Bool return_value_bypass_object_cache$2;
  return_value_bypass_object_cache$2=bypass_object_cache(req);
  signed int return_value_object_cache_handle_request$1;
  signed int return_value_gateway_forward_request$3;
  signed int return_value_gateway_replication_read$4;
  if(return_value_bypass_object_cache$2 == (_Bool)0)
  {
    return_value_object_cache_handle_request$1=object_cache_handle_request(req);
    return return_value_object_cache_handle_request$1;
  }

  else
  {
    _Bool return_value_is_erasure_oid$5;
    return_value_is_erasure_oid$5=is_erasure_oid(oid);
    if(!(return_value_is_erasure_oid$5 == (_Bool)0))
    {
      return_value_gateway_forward_request$3=gateway_forward_request(req);
      return return_value_gateway_forward_request$3;
    }

    else
    {
      return_value_gateway_replication_read$4=gateway_replication_read(req);
      return return_value_gateway_replication_read$4;
    }
  }
}

// gateway_remove_obj
// file gateway.c line 623
signed int gateway_remove_obj(struct request *req)
{
  signed int return_value_gateway_forward_request$1;
  return_value_gateway_forward_request$1=gateway_forward_request(req);
  return return_value_gateway_forward_request$1;
}

// gateway_replication_read
// file gateway.c line 248
static signed int gateway_replication_read(struct request *req)
{
  signed int i;
  signed int ret = 0x00;
  struct sd_req fwd_hdr;
  struct sd_rsp *rsp = (struct sd_rsp *)&fwd_hdr;
  struct sd_vnode *v;
  struct sd_vnode *obj_vnodes[31l];
  unsigned long int oid = req->rq.$anon0.obj.oid;
  signed int nr_copies;
  signed int j;
  nr_copies=get_req_copy_number(req);
  oid_to_vnodes$link1(oid, &req->vinfo->vroot, nr_copies, obj_vnodes);
  i = 0;
  for( ; !(i >= nr_copies); i = i + 1)
  {
    v = obj_vnodes[(signed long int)i];
    _Bool return_value_vnode_is_local$1;
    return_value_vnode_is_local$1=vnode_is_local$link1(v);
    if(!(return_value_vnode_is_local$1 == (_Bool)0))
    {
      ret=peer_read_obj(req);
      if(ret == 0x00)
        goto out;

      const char *return_value_sd_strerror$2;
      return_value_sd_strerror$2=sd_strerror$link2(ret);
      log_write(3, "gateway_replication_read", 270, "local read %lx failed, %s", oid, return_value_sd_strerror$2);
      break;
    }

  }
  signed long int return_value_random$3;
  return_value_random$3=random();
  j = (signed int)return_value_random$3;
  i = 0;
  for( ; !(i >= nr_copies); i = i + 1)
  {
    signed int idx = (i + j) % nr_copies;
    v = obj_vnodes[(signed long int)idx];
    _Bool return_value_vnode_is_local$4;
    return_value_vnode_is_local$4=vnode_is_local$link1(v);
    if(return_value_vnode_is_local$4 == (_Bool)0)
    {
      gateway_init_fwd_hdr(&fwd_hdr, &req->rq);
      ret=sheep_exec_req(&v->node->nid, &fwd_hdr, req->data);
      if(ret == 0x00)
      {
        memcpy((void *)&req->rp, (const void *)rsp, sizeof(struct sd_rsp) /*48ul*/ );
        break;
      }

    }

  }

out:
  ;
  return ret;
}

// gateway_to_peer_opcode
// file sheep_priv.h line 425
signed int gateway_to_peer_opcode(signed int opcode)
{
  return map_table[(signed long int)opcode];
}

// gateway_write_obj
// file gateway.c line 563
signed int gateway_write_obj(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  _Bool return_value_oid_is_readonly$1;
  return_value_oid_is_readonly$1=oid_is_readonly(oid);
  signed int return_value_object_cache_handle_request$2;
  if(!(return_value_oid_is_readonly$1 == (_Bool)0))
    return 0x1A;

  else
  {
    _Bool return_value_bypass_object_cache$3;
    return_value_bypass_object_cache$3=bypass_object_cache(req);
    if(return_value_bypass_object_cache$3 == (_Bool)0)
    {
      return_value_object_cache_handle_request$2=object_cache_handle_request(req);
      return return_value_object_cache_handle_request$2;
    }

    else
    {
      signed int return_value_gateway_forward_request$4;
      return_value_gateway_forward_request$4=gateway_forward_request(req);
      return return_value_gateway_forward_request$4;
    }
  }
}

// gdb_cmd
// file logger.c line 760
static signed int gdb_cmd(const char *cmd)
{
  signed long int time_str$array_size0;
  time_str$array_size0=sysconf(0);
  char time_str[256l];
  char cmd_str[time_str$array_size0];
  signed long int ti;
  struct tm tm;
  _Bool return_value_check_gdb$1;
  return_value_check_gdb$1=check_gdb();
  if(return_value_check_gdb$1 == (_Bool)0)
  {
    if(sd_log_level == 7)
      log_write(7, "gdb_cmd", 767, "cannot find gdb");

    return -1;
  }

  else
  {
    time(&ti);
    localtime_r(&ti, &tm);
    strftime(time_str, sizeof(char [256l]) /*256ul*/ , "%b %2d %H:%M:%S ", &tm);
    const char *return_value_my_exe_path$2;
    return_value_my_exe_path$2=my_exe_path();
    signed int return_value_getpid$3;
    return_value_getpid$3=getpid();
    const char *return_value_my_exe_path$4;
    return_value_my_exe_path$4=my_exe_path();
    snprintf(cmd_str, (unsigned long int)time_str$array_size0, "gdb -nw %s %d -batch >/dev/null 2>&1 -ex 'set logging on' -ex 'echo \\n' -ex 'echo ==\\n' -ex 'echo == %s\\n' -ex 'echo == program: %s\\n' -ex 'echo == command: %s\\n' -ex 'echo ==\\n' -ex '%s' -ex 'set logging off'", return_value_my_exe_path$2, return_value_getpid$3, (const void *)time_str, return_value_my_exe_path$4, cmd, cmd);
    signed int return_value_system$5;
    return_value_system$5=system(cmd_str);
    return return_value_system$5;
  }
}

// generate_gf
// file fec.c line 143
static void generate_gf(void)
{
  signed int i;
  unsigned char mask = (unsigned char)1;
  gf_exp[(signed long int)8] = (unsigned char)0;
  i = 0;
  for( ; !(i >= 8); mask = mask << 1)
  {
    gf_exp[(signed long int)i] = mask;
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
    if((signed int)Pp[(signed long int)i] == 49)
      gf_exp[(signed long int)8] = gf_exp[(signed long int)8] ^ mask;

    i = i + 1;
  }
  gf_log[(signed long int)gf_exp[(signed long int)8]] = 8;
  mask = (unsigned char)(1 << 7);
  i = 9;
  for( ; !(i >= 255); i = i + 1)
  {
    if((signed int)gf_exp[(signed long int)(i + -1)] >= (signed int)mask)
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)8] ^ ((signed int)gf_exp[(signed long int)(i - 1)] ^ (signed int)mask) << 1);

    else
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)(i - 1)] << 1);
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
  }
  gf_log[(signed long int)0] = 255;
  i = 0;
  for( ; !(i >= 255); i = i + 1)
    gf_exp[(signed long int)(i + 255)] = gf_exp[(signed long int)i];
  inverse[(signed long int)0] = (unsigned char)0;
  inverse[(signed long int)1] = (unsigned char)1;
  i = 2;
  for( ; !(i >= 256); i = i + 1)
    inverse[(signed long int)i] = gf_exp[(signed long int)(255 - gf_log[(signed long int)i])];
}

// get_buffer_sha1
// file ../include/sha1.h line 35
void get_buffer_sha1(unsigned char *buf, unsigned int len, unsigned char *sha1)
{
  struct sha1_ctx c;
  sha1_init((void *)&c);
  sha1_update((void *)&c, buf, len);
  sha1_final((void *)&c, sha1);
}

// get_cache_block_size
// file object_cache.c line 127
static inline unsigned long int get_cache_block_size(unsigned long int oid)
{
  unsigned long int bsize;
  unsigned long int return_value_get_objsize$1;
  return_value_get_objsize$1=get_objsize$link2(oid);
  bsize = ((return_value_get_objsize$1 + sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8) - (unsigned long int)1) / (sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8);
  return 1 != 0 && ((1U << 12) - (unsigned int)1 & 1U << 12) == (unsigned int)0 ? (bsize + (unsigned long int)(1U << 12)) - (unsigned long int)1 & (unsigned long int)~((1U << 12) - (unsigned int)1) : ((bsize + (unsigned long int)((1U << 12) - (unsigned int)1)) / (unsigned long int)(1U << 12)) * (unsigned long int)(1U << 12);
}

// get_cache_entry
// file object_cache.c line 151
static inline void get_cache_entry(struct object_cache_entry *entry)
{
  refcount_inc$link2(&entry->refcnt);
}

// get_cache_entry_from
// file object_cache.c line 968
static struct object_cache_entry * get_cache_entry_from(struct object_cache *cache, unsigned long int idx)
{
  struct object_cache_entry *entry;
  read_lock_cache(cache);
  entry=lru_tree_search(&cache->lru_tree, idx);
  if(entry == ((struct object_cache_entry *)NULL))
  {
    unlock_cache(cache);
    return (struct object_cache_entry *)(void *)0;
  }

  else
  {
    get_cache_entry(entry);
    unlock_cache(cache);
    return entry;
  }
}

// get_cdrv_option
// file cluster.h line 184
static inline const char * get_cdrv_option(struct cluster_driver *cdrv, const char *arg)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(cdrv->name);
  len = (signed int)return_value_strlen$1;
  char *return_value_strdup$2;
  if((signed int)arg[(signed long int)len] == 58)
  {
    return_value_strdup$2=strdup(arg + (signed long int)len + (signed long int)1);
    return return_value_strdup$2;
  }

  else
    return (const char *)(void *)0;
}

// get_cluster_config
// file config.c line 61
static signed int get_cluster_config(struct cluster_info *cinfo)
{
  cinfo->ctime = config.ctime;
  cinfo->nr_copies = config.copies;
  cinfo->flags = config.flags;
  cinfo->copy_policy = config.copy_policy;
  memcpy((void *)cinfo->store, (const void *)config.store, sizeof(unsigned char [16l]) /*16ul*/ );
  return 0x00;
}

// get_file_size
// file migrate.c line 75
static unsigned long int get_file_size(const char *path)
{
  struct stat stbuf;
  signed int ret;
  ret=stat(path, &stbuf);
  if(!(ret >= 0))
  {
    log_write(3, "get_file_size", 82, "failed to stat %s, %m", path);
    return (unsigned long int)-1;
  }

  else
    return (unsigned long int)stbuf.st_size;
}

// get_free_slot
// file sockfd_cache.c line 94
static inline signed int get_free_slot(struct sockfd_cache_entry *entry)
{
  signed int idx = -1;
  signed int i = 0;
  for( ; !(i >= fds_count); i = i + 1)
  {
    _Bool return_value_uatomic_set_true$1;
    return_value_uatomic_set_true$1=uatomic_set_true$link2(&(entry->fds + (signed long int)i)->in_use);
    if(!(return_value_uatomic_set_true$1 == (_Bool)0))
    {
      idx = i;
      break;
    }

  }
  return idx;
}

// get_hdrv_option
// file http/http.h line 94
static inline const char * get_hdrv_option(struct http_driver *hdrv, const char *arg)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(hdrv->name);
  len = (signed int)return_value_strlen$1;
  char *return_value_strdup$2;
  if((signed int)arg[(signed long int)len] == 58)
  {
    return_value_strdup$2=strdup(arg + (signed long int)len + (signed long int)1);
    return return_value_strdup$2;
  }

  else
    return (const char *)(void *)0;
}

// get_latest_epoch
// file sheep_priv.h line 365
unsigned int get_latest_epoch(void)
{
  struct __dirstream *dir;
  struct dirent *d;
  unsigned int e;
  unsigned int epoch = (unsigned int)0;
  char *p;
  dir=opendir(epoch_path);
  if(dir == ((struct __dirstream *)NULL))
  {
    log_write(0, "get_latest_epoch", 120, "PANIC: failed to get the latest epoch: %m");
    abort();
  }

  do
  {
    d=readdir(dir);
    if(d == ((struct dirent *)NULL))
      break;

    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(d->d_name, &p, 10);
    e = (unsigned int)return_value_strtol$1;
    if(!(d->d_name == p))
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(d->d_name);
      if(return_value_strlen$2 == 8ul)
      {
        if(!(epoch >= e))
          epoch = e;

      }

    }

  }
  while((_Bool)1);
  closedir(dir);
  return epoch;
}

// get_local_addr
// file net.c line 493
signed int get_local_addr(unsigned char *bytes)
{
  struct ifaddrs *ifaddr;
  struct ifaddrs *ifa;
  signed int ret = 0;
  signed int return_value_getifaddrs$1;
  return_value_getifaddrs$1=getifaddrs(&ifaddr);
  if(return_value_getifaddrs$1 == -1)
  {
    log_write(3, "get_local_addr", 499, "getifaddrs failed: %m");
    return -1;
  }

  else
  {
    ifa = ifaddr;
    for( ; !(ifa == ((struct ifaddrs *)NULL)); ifa = ifa->ifa_next)
    {
      struct sockaddr_in *sin;
      struct sockaddr_in6 *sin6;
      if((8u & ifa->ifa_flags) == 0u)
      {
        if(!(ifa->ifa_addr == ((struct sockaddr *)NULL)))
          switch((signed int)ifa->ifa_addr->sa_family)
          {
            case 2:
            {
              sin = (struct sockaddr_in *)ifa->ifa_addr;
              memset((void *)bytes, 0, (unsigned long int)12);
              memcpy((void *)(bytes + (signed long int)12), (const void *)&sin->sin_addr, (unsigned long int)4);
              memcpy((void *)(bytes + (signed long int)12), (const void *)&sin->sin_addr, (unsigned long int)4);
              log_write(5, "get_local_addr", 519, "found IPv4 address");
              goto out;
            }
            case 10:
            {
              sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
              memcpy((void *)bytes, (const void *)&sin6->sin6_addr, (unsigned long int)16);
              log_write(5, "get_local_addr", 524, "found IPv6 address");
              goto out;
            }
            default:
              ;
          }

      }

    }
    log_write(3, "get_local_addr", 529, "no valid interface found");
    ret = -1;

  out:
    ;
    freeifaddrs(ifaddr);
    return ret;
  }
}

// get_loglevel
// file ../include/logger.h line 121
signed int get_loglevel(void)
{
  return sd_log_level;
}

// get_msec_time
// file work.c line 194
static unsigned long int get_msec_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
}

// get_node_space
// file sheep_priv.h line 352
signed int get_node_space(unsigned long int *space)
{
  *space = config.space;
  return 0x00;
}

// get_nr_nodes
// file sheep.c line 426
static unsigned long int get_nr_nodes(void)
{
  struct vnode_info *vinfo;
  unsigned long int nr = (unsigned long int)1;
  vinfo=get_vnode_info();
  if(!(vinfo == ((struct vnode_info *)NULL)))
    nr = (unsigned long int)vinfo->nr_nodes;

  put_vnode_info(vinfo);
  return nr;
}

// get_obj_copy_number
// file vdi.c line 124
signed int get_obj_copy_number(unsigned long int oid, signed int nr_zones)
{
  signed int tmp_statement_expression$1;
  signed int _x;
  unsigned int return_value_oid_to_vid$2;
  return_value_oid_to_vid$2=oid_to_vid$link2(oid);
  _x=get_vdi_copy_number(return_value_oid_to_vid$2);
  signed int _y = nr_zones;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? _x : _y;
  return tmp_statement_expression$1;
}

// get_obj_list
// file sheep_priv.h line 368
signed int get_obj_list(struct sd_req *hdr, struct sd_rsp *rsp, void *data)
{
  signed int nr = 0;
  struct objlist_cache_entry *entry;
  sd_read_lock$link2(&obj_list_cache.lock);
  void *return_value_xrealloc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct objlist_cache_entry *tmp_statement_expression$3;
  signed int tmp_post$5;
  if(!(obj_list_cache.tree_version == obj_list_cache.buf_version))
  {
    sd_rw_unlock$link2(&obj_list_cache.lock);
    sd_write_lock$link2(&obj_list_cache.lock);
    if(!(obj_list_cache.tree_version == obj_list_cache.buf_version))
    {
      obj_list_cache.buf_version = obj_list_cache.tree_version;
      return_value_xrealloc$1=xrealloc((void *)obj_list_cache.buf, (unsigned long int)obj_list_cache.cache_size * sizeof(unsigned long int) /*8ul*/ );
      obj_list_cache.buf = (unsigned long int *)return_value_xrealloc$1;
      struct rb_node *__p118;
      __p118=rb_first(&obj_list_cache.root);
      struct rb_node *__n118;
      do
      {
        if(!(__p118 == ((struct rb_node *)NULL)))
        {
          __n118=rb_next(__p118);
          tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          const struct rb_node *__mptr = __p118;
          tmp_statement_expression$3 = (struct objlist_cache_entry *)((char *)__mptr - (signed long int)8ul);
          entry = tmp_statement_expression$3;
          tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        tmp_post$5 = nr;
        nr = nr + 1;
        obj_list_cache.buf[(signed long int)tmp_post$5] = entry->oid;
        __p118 = __n118;
      }
      while((_Bool)1);
    }

  }


out:
  ;
  if(!((unsigned long int)hdr->data_length >= sizeof(unsigned long int) /*8ul*/  * (unsigned long int)obj_list_cache.cache_size))
  {
    sd_rw_unlock$link2(&obj_list_cache.lock);
    log_write(3, "get_obj_list", 125, "GET_OBJ_LIST buffer too small");
    return 0x88;
  }

  else
  {
    rsp->data_length = (unsigned int)((unsigned long int)obj_list_cache.cache_size * sizeof(unsigned long int) /*8ul*/ );
    memcpy(data, (const void *)obj_list_cache.buf, (unsigned long int)rsp->data_length);
    sd_rw_unlock$link2(&obj_list_cache.lock);
    return 0x00;
  }
}

// get_object_path
// file plain_store.c line 584
static signed int get_object_path(unsigned long int oid, unsigned int epoch, char *path, unsigned long int size)
{
  _Bool return_value_default_exist$4;
  return_value_default_exist$4=default_exist(oid, (unsigned char)0);
  if(!(return_value_default_exist$4 == (_Bool)0))
  {
    const char *return_value_md_get_object_dir$1;
    return_value_md_get_object_dir$1=md_get_object_dir(oid);
    snprintf(path, (unsigned long int)4096, "%s/%016lx", return_value_md_get_object_dir$1, oid);
  }

  else
  {
    get_store_stale_path(oid, epoch, (unsigned char)0, path);
    signed int return_value_access$3;
    return_value_access$3=access(path, 0);
    if(!(return_value_access$3 >= 0))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 2)
        return 0x02;

      return 0x03;
    }

  }
  return 0x00;
}

// get_object_sha1
// file plain_store.c line 559
static signed int get_object_sha1(const char *path, unsigned char *sha1)
{
  signed long int return_value_getxattr$2;
  return_value_getxattr$2=getxattr(path, "user.obj.sha1", (void *)sha1, (unsigned long int)20);
  if(!(return_value_getxattr$2 == 20l))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 61)
    {
      if(sd_log_level == 7)
        log_write(7, "get_object_sha1", 564, "sha1 is not cached yet, %s", path);

    }

    else
      log_write(3, "get_object_sha1", 566, "fail to get xattr, %s", path);
    return -1;
  }

  return 0;
}

// get_objsize
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize(unsigned long int oid)
{
  _Bool return_value_is_vdi_obj$1;
  return_value_is_vdi_obj$1=is_vdi_obj(oid);
  if(!(return_value_is_vdi_obj$1 == (_Bool)0))
    return sizeof(struct sd_inode) /*4198976ul*/ ;

  else
  {
    _Bool return_value_is_vdi_attr_obj$2;
    return_value_is_vdi_attr_obj$2=is_vdi_attr_obj(oid);
    if(!(return_value_is_vdi_attr_obj$2 == (_Bool)0))
      return sizeof(struct sheepdog_vdi_attr) /*66320ul*/ ;

    else
    {
      _Bool return_value_is_vdi_btree_obj$3;
      return_value_is_vdi_btree_obj$3=is_vdi_btree_obj(oid);
      if(!(return_value_is_vdi_btree_obj$3 == (_Bool)0))
        return sizeof(unsigned int) /*4ul*/  * (1ULL << 20);

      else
        return 1UL << 22;
    }
  }
}

// get_objsize$link1
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize$link1(unsigned long int oid$link1)
{
  _Bool return_value_is_vdi_obj$1$link1;
  return_value_is_vdi_obj$1$link1=is_vdi_obj$link2(oid$link1);
  if(!(return_value_is_vdi_obj$1$link1 == (_Bool)0))
    return sizeof(struct sd_inode) /*4198976ul*/ ;

  else
  {
    _Bool return_value_is_vdi_attr_obj$2$link1;
    return_value_is_vdi_attr_obj$2$link1=is_vdi_attr_obj$link2(oid$link1);
    if(!(return_value_is_vdi_attr_obj$2$link1 == (_Bool)0))
      return sizeof(struct sheepdog_vdi_attr) /*66320ul*/ ;

    else
    {
      _Bool return_value_is_vdi_btree_obj$3$link1;
      return_value_is_vdi_btree_obj$3$link1=is_vdi_btree_obj$link2(oid$link1);
      if(!(return_value_is_vdi_btree_obj$3$link1 == (_Bool)0))
        return sizeof(unsigned int) /*4ul*/  * (1ULL << 20);

      else
        return 1UL << 22;
    }
  }
}

// get_objsize$link2
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize$link2(unsigned long int oid$link2)
{
  _Bool return_value_is_vdi_obj$1$link2;
  return_value_is_vdi_obj$1$link2=is_vdi_obj$link3(oid$link2);
  if(!(return_value_is_vdi_obj$1$link2 == (_Bool)0))
    return sizeof(struct sd_inode) /*4198976ul*/ ;

  else
  {
    _Bool return_value_is_vdi_attr_obj$2$link2;
    return_value_is_vdi_attr_obj$2$link2=is_vdi_attr_obj$link3(oid$link2);
    if(!(return_value_is_vdi_attr_obj$2$link2 == (_Bool)0))
      return sizeof(struct sheepdog_vdi_attr) /*66320ul*/ ;

    else
    {
      _Bool return_value_is_vdi_btree_obj$3$link2;
      return_value_is_vdi_btree_obj$3$link2=is_vdi_btree_obj$link3(oid$link2);
      if(!(return_value_is_vdi_btree_obj$3$link2 == (_Bool)0))
        return sizeof(unsigned int) /*4ul*/  * (1ULL << 20);

      else
        return 1UL << 22;
    }
  }
}

// get_objsize$link3
// file ../include/sheepdog_proto.h line 416
static inline unsigned long int get_objsize$link3(unsigned long int oid$link3)
{
  _Bool return_value_is_vdi_obj$1$link3;
  return_value_is_vdi_obj$1$link3=is_vdi_obj$link5(oid$link3);
  if(!(return_value_is_vdi_obj$1$link3 == (_Bool)0))
    return sizeof(struct sd_inode) /*4198976ul*/ ;

  else
  {
    _Bool return_value_is_vdi_attr_obj$2$link3;
    return_value_is_vdi_attr_obj$2$link3=is_vdi_attr_obj$link4(oid$link3);
    if(!(return_value_is_vdi_attr_obj$2$link3 == (_Bool)0))
      return sizeof(struct sheepdog_vdi_attr) /*66320ul*/ ;

    else
    {
      _Bool return_value_is_vdi_btree_obj$3$link3;
      return_value_is_vdi_btree_obj$3$link3=is_vdi_btree_obj$link4(oid$link3);
      if(!(return_value_is_vdi_btree_obj$3$link3 == (_Bool)0))
        return sizeof(unsigned int) /*4ul*/  * (1ULL << 20);

      else
        return 1UL << 22;
    }
  }
}

// get_old_new_jfile
// file journal.c line 81
static signed int get_old_new_jfile(const char *p, signed int *old, signed int *new)
{
  signed int fd1;
  signed int fd2;
  signed int flags = 00;
  char path[4096l];
  struct stat st1;
  struct stat st2;
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", p, jfile_name[(signed long int)0]);
  fd1=open(path, flags);
  if(!(fd1 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      return 0;

    log_write(3, "get_old_new_jfile", 94, "open1 %m");
    return -1;
  }

  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", p, jfile_name[(signed long int)1]);
  fd2=open(path, flags);
  _Bool tmp_if_expr$4;
  signed int return_value_fstat$3;
  if(!(fd2 >= 0))
  {
    log_write(3, "get_old_new_jfile", 100, "open2 %m");
    close(fd1);
    return -1;
  }

  else
  {
    signed int return_value_fstat$2;
    return_value_fstat$2=fstat(fd1, &st1);
    if(!(return_value_fstat$2 >= 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_fstat$3=fstat(fd2, &st2);
      tmp_if_expr$4 = return_value_fstat$3 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      log_write(3, "get_old_new_jfile", 106, "stat %m");

    else
    {
      if(!(st1.st_mtim.tv_sec >= st2.st_mtim.tv_sec))
      {
        *old = fd1;
        *new = fd2;
      }

      else
      {
        *old = fd2;
        *new = fd1;
      }
      return 0;
    }

  out:
    ;
    close(fd1);
    close(fd2);
    return -1;
  }
}

// get_old_new_path
// file md.c line 567
static signed int get_old_new_path(unsigned long int oid, unsigned int epoch, unsigned char ec_index, const char *path, char *old, char *new)
{
  if(epoch == 0u)
  {
    _Bool return_value_is_erasure_oid$3;
    return_value_is_erasure_oid$3=is_erasure_oid(oid);
    if(return_value_is_erasure_oid$3 == (_Bool)0)
    {
      snprintf(old, (unsigned long int)4096, "%s/%016lx", path, oid);
      const char *return_value_md_get_object_dir_nolock$1;
      return_value_md_get_object_dir_nolock$1=md_get_object_dir_nolock(oid);
      snprintf(new, (unsigned long int)4096, "%s/%016lx", return_value_md_get_object_dir_nolock$1, oid);
    }

    else
    {
      snprintf(old, (unsigned long int)4096, "%s/%016lx_%d", path, oid, ec_index);
      const char *return_value_md_get_object_dir_nolock$2;
      return_value_md_get_object_dir_nolock$2=md_get_object_dir_nolock(oid);
      snprintf(new, (unsigned long int)4096, "%s/%016lx_%d", return_value_md_get_object_dir_nolock$2, oid, ec_index);
    }
  }

  else
  {
    _Bool return_value_is_erasure_oid$6;
    return_value_is_erasure_oid$6=is_erasure_oid(oid);
    if(return_value_is_erasure_oid$6 == (_Bool)0)
    {
      snprintf(old, (unsigned long int)4096, "%s/.stale/%016lx.%u", path, oid, epoch);
      const char *return_value_md_get_object_dir_nolock$4;
      return_value_md_get_object_dir_nolock$4=md_get_object_dir_nolock(oid);
      snprintf(new, (unsigned long int)4096, "%s/.stale/%016lx.%u", return_value_md_get_object_dir_nolock$4, oid, epoch);
    }

    else
    {
      snprintf(old, (unsigned long int)4096, "%s/.stale/%016lx_%d.%u", path, oid, ec_index, epoch);
      const char *return_value_md_get_object_dir_nolock$5;
      return_value_md_get_object_dir_nolock$5=md_get_object_dir_nolock(oid);
      snprintf(new, (unsigned long int)4096, "%s/.stale/%016lx_%d.%u", return_value_md_get_object_dir_nolock$5, oid, ec_index, epoch);
    }
  }
  _Bool return_value_md_access$7;
  return_value_md_access$7=md_access(old);
  if(return_value_md_access$7 == (_Bool)0)
    return -1;

  else
    return 0;
}

// get_path_free_size
// file md.c line 237
static unsigned long int get_path_free_size(const char *path, unsigned long int *used)
{
  struct statvfs fs;
  unsigned long int size;
  signed int return_value_statvfs$1;
  return_value_statvfs$1=statvfs(path, &fs);
  signed int return_value_for_each_object_in_path$2;
  if(!(return_value_statvfs$1 >= 0))
  {
    log_write(3, "get_path_free_size", 243, "get disk %s space failed %m", path);
    return (unsigned long int)0;
  }

  else
  {
    size = (unsigned long int)(signed long int)fs.f_frsize * fs.f_bavail;
    if(!(used == ((unsigned long int *)NULL)))
    {
      return_value_for_each_object_in_path$2=for_each_object_in_path(path, get_total_object_size, (_Bool)0, (struct vnode_info *)(void *)0, (void *)used);
      if(return_value_for_each_object_in_path$2 == 0x00)
        goto out;

      return (unsigned long int)0;
    }

    else
    {

    out:
      ;
      return size;
    }
  }
}

// get_recovery_state
// file sheep_priv.h line 374
void get_recovery_state(struct recovery_state *state)
{
  struct recovery_info *rinfo;
  struct recovery_info *tmp_statement_expression$1 = current_rinfo.__val;
  rinfo = tmp_statement_expression$1;
  memset((void *)state, 0, sizeof(struct recovery_state) /*24ul*/ );
  if(rinfo == ((struct recovery_info *)NULL))
    state->in_recovery = (unsigned char)0;

  else
  {
    state->in_recovery = (unsigned char)1;
    state->state = rinfo->state;
    state->nr_finished = rinfo->done;
    state->nr_total = rinfo->count;
  }
}

// get_req_copy_number
// file sheep_priv.h line 303
signed int get_req_copy_number(struct request *req)
{
  signed int nr_copies;
  signed int tmp_statement_expression$1;
  signed int _x = (signed int)req->rq.$anon0.obj.copies;
  signed int _y = req->vinfo->nr_zones;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? _x : _y;
  nr_copies = tmp_statement_expression$1;
  if(nr_copies == 0)
    nr_copies=get_obj_copy_number(req->rq.$anon0.obj.oid, req->vinfo->nr_zones);

  return nr_copies;
}

// get_sd_op
// file sheep_priv.h line 412
struct sd_op_template * get_sd_op(unsigned char opcode)
{
  if((signed int)sd_ops[(signed long int)opcode].type == 0)
    return (struct sd_op_template *)(void *)0;

  else
    return sd_ops + (signed long int)opcode;
}

// get_seconds
// file http/kv.c line 730
static unsigned long int get_seconds(void)
{
  struct timeval tv;
  unsigned long int seconds;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  seconds = (unsigned long int)tv.tv_sec;
  return seconds;
}

// get_store_objsize
// file sheep_priv.h line 251
unsigned long int get_store_objsize(unsigned long int oid)
{
  _Bool return_value_is_erasure_oid$3;
  return_value_is_erasure_oid$3=is_erasure_oid(oid);
  if(!(return_value_is_erasure_oid$3 == (_Bool)0))
  {
    unsigned char policy;
    unsigned int return_value_oid_to_vid$1;
    return_value_oid_to_vid$1=oid_to_vid$link7(oid);
    signed int return_value_get_vdi_copy_policy$2;
    return_value_get_vdi_copy_policy$2=get_vdi_copy_policy(return_value_oid_to_vid$1);
    policy = (unsigned char)return_value_get_vdi_copy_policy$2;
    signed int d;
    ec_policy_to_dp$link4(policy, &d, (signed int *)(void *)0);
    return (1UL << 22) / (unsigned long int)d;
  }

  unsigned long int return_value_get_objsize$4;
  return_value_get_objsize$4=get_objsize$link3(oid);
  return return_value_get_objsize$4;
}

// get_store_path
// file plain_store.c line 42
signed int get_store_path(unsigned long int oid, unsigned char ec_index, char *path)
{
  _Bool return_value_is_erasure_oid$3;
  return_value_is_erasure_oid$3=is_erasure_oid(oid);
  if(!(return_value_is_erasure_oid$3 == (_Bool)0))
  {
    if((signed int)ec_index >= 2)
    {
      log_write(0, "get_store_path", 46, "PANIC: invalid ec_index %d", ec_index);
      abort();
    }

    const char *return_value_md_get_object_dir$1;
    return_value_md_get_object_dir$1=md_get_object_dir(oid);
    signed int return_value_snprintf$2;
    return_value_snprintf$2=snprintf(path, (unsigned long int)4096, "%s/%016lx_%d", return_value_md_get_object_dir$1, oid, ec_index);
    return return_value_snprintf$2;
  }

  const char *return_value_md_get_object_dir$4;
  return_value_md_get_object_dir$4=md_get_object_dir(oid);
  signed int return_value_snprintf$5;
  return_value_snprintf$5=snprintf(path, (unsigned long int)4096, "%s/%016lx", return_value_md_get_object_dir$4, oid);
  return return_value_snprintf$5;
}

// get_store_stale_path
// file plain_store.c line 68
static signed int get_store_stale_path(unsigned long int oid, unsigned int epoch, unsigned char ec_index, char *path)
{
  signed int return_value_md_get_stale_path$1;
  return_value_md_get_stale_path$1=md_get_stale_path(oid, epoch, ec_index, path);
  return return_value_md_get_stale_path$1;
}

// get_store_tmp_path
// file plain_store.c line 55
static signed int get_store_tmp_path(unsigned long int oid, unsigned char ec_index, char *path)
{
  _Bool return_value_is_erasure_oid$3;
  return_value_is_erasure_oid$3=is_erasure_oid(oid);
  if(!(return_value_is_erasure_oid$3 == (_Bool)0))
  {
    if((signed int)ec_index >= 2)
    {
      log_write(0, "get_store_tmp_path", 59, "PANIC: invalid ec_index %d", ec_index);
      abort();
    }

    const char *return_value_md_get_object_dir$1;
    return_value_md_get_object_dir$1=md_get_object_dir(oid);
    signed int return_value_snprintf$2;
    return_value_snprintf$2=snprintf(path, (unsigned long int)4096, "%s/%016lx_%d.tmp", return_value_md_get_object_dir$1, oid, ec_index);
    return return_value_snprintf$2;
  }

  const char *return_value_md_get_object_dir$4;
  return_value_md_get_object_dir$4=md_get_object_dir(oid);
  signed int return_value_snprintf$5;
  return_value_snprintf$5=snprintf(path, (unsigned long int)4096, "%s/%016lx.tmp", return_value_md_get_object_dir$4, oid);
  return return_value_snprintf$5;
}

// get_thread_name
// file logger.c line 745
void get_thread_name(char *name)
{
  format_thread_name(name, (unsigned long int)20, worker_name, worker_idx);
}

// get_total_object_size
// file md.c line 145
static signed int get_total_object_size(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *total)
{
  unsigned long int *t = (unsigned long int *)total;
  struct stat s;
  char path[4096l];
  snprintf(path, (unsigned long int)4096, "%s/%016lx", wd, oid);
  signed int return_value_stat$2;
  return_value_stat$2=stat(path, &s);
  unsigned long int return_value_get_store_objsize$1;
  if(return_value_stat$2 == 0)
    *t = *t + (unsigned long int)(s.st_blocks * (signed long int)(1U << 9));

  else
  {
    return_value_get_store_objsize$1=get_store_objsize(oid);
    *t = *t + return_value_get_store_objsize$1;
  }
  return 0x00;
}

// get_vdi_attr
// file vdi.c line 1181
signed int get_vdi_attr(struct sheepdog_vdi_attr *vattr, signed int data_len, unsigned int vid, unsigned int *attrid, unsigned long int create_time, _Bool wr, _Bool excl, _Bool delete)
{
  struct sheepdog_vdi_attr tmp_attr;
  unsigned long int oid;
  unsigned int end;
  signed int ret;
  vattr->ctime = create_time;
  *attrid=hash_vdi_attr(vattr);
  end = *attrid - (unsigned int)1;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  while(!(*attrid == end))
  {
    oid=vid_to_attr_oid(vid, *attrid);
    ret=sd_read_object(oid, (char *)&tmp_attr, (unsigned int)sizeof(struct sheepdog_vdi_attr) /*66320ul*/ , (unsigned long int)0);
    if(ret == 0x02 && !(wr == (_Bool)0))
    {
      ret=sd_write_object(oid, (char *)vattr, (unsigned int)data_len, (unsigned long int)0, (_Bool)1);
      if(!(ret == 0))
        ret = 0x03;

      else
        ret = 0x00;
      goto out;
    }

    if(!(ret == 0x00))
      goto out;

    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(tmp_attr.name, vattr->name);
    if(return_value_strcmp$3 == 0)
    {
      return_value_strcmp$2=strcmp(tmp_attr.tag, vattr->tag);
      if(return_value_strcmp$2 == 0)
      {
        if(tmp_attr.snap_id == vattr->snap_id)
        {
          return_value_strcmp$1=strcmp(tmp_attr.key, vattr->key);
          if(return_value_strcmp$1 == 0)
          {
            if(!(excl == (_Bool)0))
              ret = 0x04;

            else
              if(!(delete == (_Bool)0))
              {
                ret=sd_write_object(oid, (char *)"", (unsigned int)1, 0ul, (_Bool)0);
                if(!(ret == 0))
                  ret = 0x03;

                else
                  ret = 0x00;
              }

              else
                if(!(wr == (_Bool)0))
                {
                  ret=sd_write_object(oid, (char *)vattr, (unsigned int)sizeof(struct sheepdog_vdi_attr) /*66320ul*/ , (unsigned long int)0, (_Bool)0);
                  if(!(ret == 0))
                    ret = 0x03;

                  else
                    ret = 0x00;
                }

                else
                  ret = 0x00;
            goto out;
          }

        }

      }

    }

    *attrid = *attrid + 1u;
  }
  if(sd_log_level == 7)
    log_write(7, "get_vdi_attr", 1245, "there is no space for new VDIs");

  ret = 0x13;

out:
  ;
  return ret;
}

// get_vdi_bitmap_range
// file vdi.c line 501
static signed int get_vdi_bitmap_range(const char *name, unsigned long int *left, unsigned long int *right)
{
  unsigned int return_value_sd_hash_vdi$1;
  return_value_sd_hash_vdi$1=sd_hash_vdi(name);
  *left = (unsigned long int)return_value_sd_hash_vdi$1;
  *right=find_next_zero_bit(sys->vdi_inuse, (unsigned long int)(1U << 24), *left);
  if(*left == *right)
    return 0x08;

  else
    if(*right == 16777216ul)
    {
      *right=find_next_zero_bit(sys->vdi_inuse, (unsigned long int)(1U << 24), (unsigned long int)0);
      if(!(*right == 16777216ul))
        goto __CPROVER_DUMP_L2;

      return 0x13;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return 0x00;
    }
}

// get_vdi_copy_number
// file sheep_priv.h line 300
signed int get_vdi_copy_number(unsigned int vid)
{
  struct vdi_state_entry *entry;
  sd_read_lock(&vdi_state_lock);
  entry=vdi_state_search(&vdi_state_root, vid);
  sd_rw_unlock(&vdi_state_lock);
  if(entry == ((struct vdi_state_entry *)NULL))
  {
    log_write(1, "get_vdi_copy_number", 100, "copy number for %x not found, set %d", vid, sys->cinfo.nr_copies);
    return (signed int)sys->cinfo.nr_copies;
  }

  else
    return (signed int)entry->nr_copies;
}

// get_vdi_copy_policy
// file sheep_priv.h line 301
signed int get_vdi_copy_policy(unsigned int vid)
{
  struct vdi_state_entry *entry;
  sd_read_lock(&vdi_state_lock);
  entry=vdi_state_search(&vdi_state_root, vid);
  sd_rw_unlock(&vdi_state_lock);
  if(entry == ((struct vdi_state_entry *)NULL))
  {
    log_write(1, "get_vdi_copy_policy", 117, "copy policy for %x not found, set %d", vid, sys->cinfo.copy_policy);
    return (signed int)sys->cinfo.copy_policy;
  }

  else
    return (signed int)entry->copy_policy;
}

// get_vdi_root
// file vdi.c line 985
static unsigned long int get_vdi_root(unsigned int vid, _Bool *cloned)
{
  signed int ret;
  struct sd_inode *inode = (struct sd_inode *)(void *)0;
  *cloned = (_Bool)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(4664ul);
  inode = (struct sd_inode *)return_value_malloc$1;
  if(inode == ((struct sd_inode *)NULL))
  {
    log_write(3, "get_vdi_root", 994, "failed to allocate memory");
    return (unsigned long int)0;
  }

  else
  {
    do
    {
      unsigned long int return_value_vid_to_vdi_oid$2;
      return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(vid);
      ret=read_backend_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)4664ul, (unsigned long int)0);
      if(!(ret == 0x00))
      {
        log_write(3, "get_vdi_root", 1002, "cannot find VDI object");
        vid = (unsigned int)0;
        break;
      }

      if(vid == inode->vdi_id)
      {
        if(inode->snap_id == 1u)
        {
          if(!(inode->parent_vdi_id == 0u))
          {
            if(inode->snap_ctime == 0ul)
            {
              if(sd_log_level == 7)
                log_write(7, "get_vdi_root", 1009, "vdi %x is a cloned vdi.", vid);

              *cloned = (_Bool)1;
            }

          }

        }

      }

      if(inode->parent_vdi_id == 0u)
        break;

      vid = inode->parent_vdi_id;
    }
    while((_Bool)1);
    free((void *)inode);
    return (unsigned long int)vid;
  }
}

// get_vdis
// file group.c line 611
static void get_vdis(struct rb_root *nroot, struct sd_node *joined)
{
  struct get_vdis_work *w;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct get_vdis_work) /*2097272ul*/ );
  w = (struct get_vdis_work *)return_value_xmalloc$1;
  w->joined = *joined;
  INIT_RB_ROOT(&w->nroot);
  struct sd_node *__src;
  struct sd_node *__dst;
  struct rb_node *__p618;
  __p618=rb_first(nroot);
  struct rb_node *__n618;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct sd_node *tmp_statement_expression$3;
  struct sd_node *tmp_statement_expression$6;
  do
  {
    if(!(__p618 == ((struct rb_node *)NULL)))
    {
      __n618=rb_next(__p618);
      tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      const struct rb_node *__mptr = __p618;
      tmp_statement_expression$3 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      __src = tmp_statement_expression$3;
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    void *return_value_xmalloc$5;
    return_value_xmalloc$5=xmalloc(sizeof(struct sd_node) /*80ul*/ );
    __dst = (struct sd_node *)return_value_xmalloc$5;
    *__dst = *__src;
    struct rb_node **__n = &(&w->nroot)->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct sd_node *__old = (struct sd_node *)(void *)0;
    struct sd_node *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *get_vdis$$1$$1$$1$$2$$1$$1$$1$$__mptr = *__n;
      tmp_statement_expression$6 = (struct sd_node *)((char *)get_vdis$$1$$1$$1$$2$$1$$1$$1$$__mptr - (signed long int)0ul);
      __data = tmp_statement_expression$6;
      signed int __cmp;
      __cmp=node_cmp(__dst, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct sd_node *)NULL))
    {
      rb_link_node(&__dst->rb, __parent, __n);
      rb_insert_color(&__dst->rb, &w->nroot);
    }

    __old;
    __p618 = __n618;
  }
  while((_Bool)1);
  refcount_inc(&nr_get_vdis_works);
  w->work.fn = do_get_vdis;
  w->work.done = get_vdis_done;
  queue_work(sys->block_wqueue, &w->work);
}

// get_vdis_done
// file group.c line 525
static void get_vdis_done(struct work *work)
{
  struct get_vdis_work *w;
  struct get_vdis_work *tmp_statement_expression$1;
  const struct work *get_vdis_done$$1$$1$$__mptr = work;
  tmp_statement_expression$1 = (struct get_vdis_work *)((char *)get_vdis_done$$1$$1$$__mptr - (signed long int)0ul);
  w = tmp_statement_expression$1;
  sd_mutex_lock(&wait_vdis_lock);
  refcount_dec(&nr_get_vdis_works);
  sd_cond_broadcast(&wait_vdis_cond);
  sd_mutex_unlock(&wait_vdis_lock);
  struct sd_node *__dummy;
  struct rb_node *__p535;
  __p535=rb_first(&w->nroot);
  struct rb_node *__n535;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct sd_node *tmp_statement_expression$3;
  do
  {
    if(!(__p535 == ((struct rb_node *)NULL)))
    {
      __n535=rb_next(__p535);
      tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      const struct rb_node *__mptr = __p535;
      tmp_statement_expression$3 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      __dummy = tmp_statement_expression$3;
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    rb_erase(&__dummy->rb, &w->nroot);
    free((void *)__dummy);
    __p535 = __n535;
  }
  while((_Bool)1);
  free((void *)w);
}

// get_vdis_from
// file group.c line 454
static signed int get_vdis_from(struct sd_node *node)
{
  struct sd_req hdr;
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  struct vdi_state *vs = (struct vdi_state *)(void *)0;
  signed int i;
  signed int ret = 0x00;
  unsigned int rlen;
  signed int count;
  _Bool return_value_node_is_local$1;
  return_value_node_is_local$1=node_is_local(node);
  void *return_value_xzalloc$2;
  if(return_value_node_is_local$1 == (_Bool)0)
  {
    rlen = (unsigned int)(1UL << 22);
    return_value_xzalloc$2=xzalloc((unsigned long int)rlen);
    vs = (struct vdi_state *)return_value_xzalloc$2;
    sd_init_req(&hdr, (unsigned char)0xAB);
    hdr.data_length = rlen;
    hdr.epoch=sys_epoch();
    ret=sheep_exec_req(&node->nid, &hdr, (void *)(char *)vs);
    if(ret == 0x00)
    {
      count = (signed int)((unsigned long int)rsp->data_length / sizeof(struct vdi_state) /*8ul*/ );
      i = 0;
      for( ; !(i >= count); i = i + 1)
      {
        atomic_set_bit((signed int)(vs + (signed long int)i)->vid, sys->vdi_inuse);
        add_vdi_state((vs + (signed long int)i)->vid, (signed int)(vs + (signed long int)i)->nr_copies, (_Bool)(vs + (signed long int)i)->snapshot, (vs + (signed long int)i)->copy_policy);
      }
    }

  }


out:
  ;
  free((void *)vs);
  return ret;
}

// get_vnode_info
// file sheep_priv.h line 326
struct vnode_info * get_vnode_info(void)
{
  struct vnode_info *cur_vinfo;
  struct vnode_info *tmp_statement_expression$1 = current_vnode_info.__val;
  cur_vinfo = tmp_statement_expression$1;
  if(cur_vinfo == ((struct vnode_info *)NULL))
    return (struct vnode_info *)(void *)0;

  else
  {
    struct vnode_info *return_value_grab_vnode_info$2;
    return_value_grab_vnode_info$2=grab_vnode_info(cur_vinfo);
    return return_value_grab_vnode_info$2;
  }
}

// get_vnode_info_epoch
// file group.c line 155
struct vnode_info * get_vnode_info_epoch(unsigned int epoch, struct vnode_info *cur_vinfo)
{
  struct sd_node nodes[6144l];
  struct rb_root nroot = { .rb_node=(struct rb_node *)(void *)0 };
  signed int get_vnode_info_epoch$$1$$nr_nodes;
  get_vnode_info_epoch$$1$$nr_nodes=epoch_log_read(epoch, nodes, (signed int)sizeof(struct sd_node [6144l]) /*491520ul*/ );
  struct sd_node *tmp_statement_expression$1;
  if(!(get_vnode_info_epoch$$1$$nr_nodes >= 0))
  {
    get_vnode_info_epoch$$1$$nr_nodes=epoch_log_read_remote(epoch, nodes, (signed int)sizeof(struct sd_node [6144l]) /*491520ul*/ , (signed long int *)(void *)0, cur_vinfo);
    if(!(get_vnode_info_epoch$$1$$nr_nodes == 0))
      goto __CPROVER_DUMP_L1;

    return (struct vnode_info *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed int i = 0;
    for( ; !(i >= get_vnode_info_epoch$$1$$nr_nodes); i = i + 1)
    {
      struct rb_node **__n = &(&nroot)->rb_node;
      struct rb_node *__parent = (struct rb_node *)(void *)0;
      struct sd_node *__old = (struct sd_node *)(void *)0;
      struct sd_node *__data;
      while(!(*__n == ((struct rb_node *)NULL)))
      {
        const struct rb_node *__mptr = *__n;
        tmp_statement_expression$1 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
        __data = tmp_statement_expression$1;
        signed int __cmp;
        __cmp=node_cmp(&nodes[(signed long int)i], __data);
        __parent = *__n;
        if(!(__cmp >= 0))
          __n = &(*__n)->rb_left;

        else
          if(__cmp >= 1)
            __n = &(*__n)->rb_right;

          else
          {
            __old = __data;
            break;
          }
      }
      if(__old == ((struct sd_node *)NULL))
      {
        rb_link_node(&(&nodes[(signed long int)i])->rb, __parent, __n);
        rb_insert_color(&(&nodes[(signed long int)i])->rb, &nroot);
      }

      __old;
    }
    struct vnode_info *return_value_alloc_vnode_info$2;
    return_value_alloc_vnode_info$2=alloc_vnode_info(&nroot);
    return return_value_alloc_vnode_info$2;
  }
}

// get_zones_nr_from
// file group.c line 34
static signed int get_zones_nr_from(struct rb_root *nroot)
{
  signed int nr_zones = 0;
  signed int j;
  unsigned int zones[31l];
  struct sd_node *n;
  struct rb_node *__p40;
  __p40=rb_first(nroot);
  struct rb_node *__n40;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_node *tmp_statement_expression$2;
  do
  {
    if(!(__p40 == ((struct rb_node *)NULL)))
    {
      __n40=rb_next(__p40);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p40;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    if(!(n->nr_vnodes == 0))
    {
      j = 0;
      for( ; !(j >= nr_zones); j = j + 1)
        if(n->zone == zones[(signed long int)j])
          break;

      if(j == nr_zones)
      {
        zones[(signed long int)nr_zones] = n->zone;
        nr_zones = nr_zones + 1;
        if((unsigned long int)nr_zones == 31ul)
          break;

      }

    }

    __p40 = __n40;
  }
  while((_Bool)1);
  return nr_zones;
}

// gettid
// file ../include/util.h line 114
signed int gettid(void)
{
  signed long int return_value_syscall$1;
  return_value_syscall$1=syscall((signed long int)186);
  return (signed int)return_value_syscall$1;
}

// grab_vnode_info
// file group.c line 70
struct vnode_info * grab_vnode_info(struct vnode_info *vnode_info)
{
  refcount_inc(&vnode_info->refcnt);
  return vnode_info;
}

// grow_fds_done
// file sockfd_cache.c line 270
static void grow_fds_done(struct work *work)
{
  if(sd_log_level == 7)
    log_write(7, "grow_fds_done", 272, "fd count has been grown into %d", fds_count);

  uatomic_set_false$link2(&fds_in_grow);
  free((void *)work);
}

// has_enough_zones
// file request.c line 296
static _Bool has_enough_zones(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  unsigned int return_value_oid_to_vid$1;
  return_value_oid_to_vid$1=oid_to_vid(oid);
  signed int return_value_get_vdi_copy_number$2;
  return_value_get_vdi_copy_number$2=get_vdi_copy_number(return_value_oid_to_vid$1);
  return req->vinfo->nr_zones >= return_value_get_vdi_copy_number$2;
}

// has_process_main
// file sheep_priv.h line 421
_Bool has_process_main(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = !(!(op->process_main != ((signed int (*)(struct sd_req *, struct sd_rsp *, void *))NULL))) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// has_process_work
// file sheep_priv.h line 420
_Bool has_process_work(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = !(!(op->process_work != ((signed int (*)(struct request *))NULL))) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// has_scheduled_objects
// file recovery.c line 800
static _Bool has_scheduled_objects(struct recovery_info *rinfo)
{
  return rinfo->done < rinfo->nr_scheduled_prio_oids;
}

// hash
// file object_cache.c line 95
static inline signed int hash(unsigned long int vid)
{
  unsigned long int return_value_hash_64$1;
  return_value_hash_64$1=hash_64(vid, (unsigned int)5);
  return (signed int)return_value_hash_64$1;
}

// hash_64
// file ../include/sheepdog_proto.h line 380
static inline unsigned long int hash_64(unsigned long int val, unsigned int bits)
{
  unsigned long int return_value_sd_hash_64$1;
  return_value_sd_hash_64$1=sd_hash_64$link3(val);
  return return_value_sd_hash_64$1 >> (unsigned int)64 - bits;
}

// hash_vdi_attr
// file vdi.c line 1168
static unsigned int hash_vdi_attr(struct sheepdog_vdi_attr *attr)
{
  unsigned long int hval;
  hval=fnv_64a_buf$link1((const void *)attr->name, sizeof(char [256l]) /*256ul*/ , (unsigned long int)0xcbf29ce484222325ULL);
  hval=fnv_64a_buf$link1((const void *)attr->tag, sizeof(char [256l]) /*256ul*/ , hval);
  hval=fnv_64a_buf$link1((const void *)&attr->snap_id, sizeof(unsigned int) /*4ul*/ , hval);
  hval=fnv_64a_buf$link1((const void *)attr->key, sizeof(char [256l]) /*256ul*/ , hval);
  return (unsigned int)(hval & (1UL << 32) - (unsigned long int)1);
}

// hlist_add_head
// file ../include/list.h line 202
static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
  struct hlist_node *first = h->first;
  n->next = first;
  if(!(first == ((struct hlist_node *)NULL)))
    first->pprev = &n->next;

  h->first = n;
  n->pprev = &h->first;
}

// hlist_del
// file ../include/list.h line 195
static inline void hlist_del(struct hlist_node *n)
{
  __hlist_del(n);
  n->next = (struct hlist_node *)(void *)0x00100100;
  n->pprev = (struct hlist_node **)(void *)0x00200200;
}

// hlist_empty
// file ../include/list.h line 181
static inline _Bool hlist_empty(struct hlist_head *h)
{
  return !(h->first != ((struct hlist_node *)NULL));
}

// http_end_request
// file http/http.c line 234
static void http_end_request(struct http_request *req)
{
  FCGX_Finish_r(&req->fcgx);
  free((void *)req);
}

// http_init
// file sheep_priv.h line 514
signed int http_init(const char *options)
{
  unsigned long int t;
  signed int err;
  char *s;
  char address[72l];
  s=strdup(options);
  if(s == ((char *)NULL))
  {
    log_write(0, "http_init", 390, "OOM");
    return -1;
  }

  else
  {
    signed int return_value_option_parse$1;
    return_value_option_parse$1=option_parse(s, ",", http_opt_parsers);
    if(!(return_value_option_parse$1 >= 0))
      return -1;

    else
    {
      _Bool return_value_list_empty$2;
      return_value_list_empty$2=list_empty$link2(&http_enabled_drivers);
      if(!(return_value_list_empty$2 == (_Bool)0))
      {
        http_opt_default_parser("swift");
        if(sd_log_level == 7)
          log_write(7, "http_init", 399, "Use swift as default http driver");

      }

      sys->http_wqueue=create_work_queue("http", (enum wq_thread_control)WQ_DYNAMIC);
      if(sys->http_wqueue == ((struct work_queue *)NULL))
        return -1;

      else
      {
        FCGX_Init();
        snprintf(address, sizeof(char [72l]) /*72ul*/ , "%s:%s", http_host, http_port);
        http_sockfd=FCGX_OpenSocket(address, 1024);
        if(!(http_sockfd >= 0))
        {
          log_write(3, "http_init", 412, "open socket failed, address %s", (const void *)address);
          return -1;
        }

        else
        {
          log_write(6, "http_init", 415, "http service listen at %s", (const void *)address);
          err=pthread_create(&t, (const union pthread_attr_t *)(void *)0, http_main_loop, (void *)0);
          if(!(err == 0))
          {
            char *return_value_strerror$3;
            return_value_strerror$3=strerror(err);
            log_write(3, "http_init", 418, "%s", return_value_strerror$3);
            return -1;
          }

          return 0;
        }
      }
    }
  }
}

// http_init_request
// file http/http.c line 210
static signed int http_init_request(struct http_request *req)
{
  char *p;
  signed int i = 0;
  do
  {
    p = req->fcgx.envp[(signed long int)i];
    if(p == ((char *)NULL))
      break;

    if(sd_log_level == 7)
      log_write(7, "http_init_request", 215, "%s", p);

    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_request_init_operation$1;
  return_value_request_init_operation$1=request_init_operation(req);
  return return_value_request_init_operation$1;
}

// http_main_loop
// file http/http.c line 309
static void * http_main_loop(void *ignored)
{
  signed int err;
  do
  {
    struct http_request *req;
    req=http_new_request(http_sockfd);
    signed int ret;
    ret=FCGX_Accept_r(&req->fcgx);
    if(!(ret >= 0))
    {
      log_write(3, "http_main_loop", 319, "accept failed, %d, %d", http_sockfd, ret);
      break;
    }

    ret=http_init_request(req);
    if(!(ret == OK))
    {
      http_response_header(req, (enum http_status)ret);
      http_end_request(req);
    }

    else
      http_queue_request(req);
  }
  while((_Bool)1);

out:
  ;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  err=pthread_detach(return_value_pthread_self$1);
  char *return_value_strerror$2;
  if(!(err == 0))
  {
    return_value_strerror$2=strerror(err);
    log_write(3, "http_main_loop", 333, "%s", return_value_strerror$2);
  }

  pthread_exit((void *)0);
}

// http_new_request
// file http/http.c line 299
static inline struct http_request * http_new_request(signed int sockfd)
{
  struct http_request *req;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct http_request) /*112ul*/ );
  req = (struct http_request *)return_value_xzalloc$1;
  FCGX_InitRequest(&req->fcgx, sockfd, 0);
  return req;
}

// http_opt_default_parser
// file http/http.c line 349
static signed int http_opt_default_parser(const char *s)
{
  struct http_driver *hdrv;
  hdrv=find_hdrv(&http_enabled_drivers, s);
  if(!(hdrv == ((struct http_driver *)NULL)))
  {
    log_write(3, "http_opt_default_parser", 355, "%s driver is already enabled", hdrv->name);
    return -1;
  }

  else
  {
    hdrv=find_hdrv(&http_drivers, s);
    if(hdrv == ((struct http_driver *)NULL))
    {
      log_write(3, "http_opt_default_parser", 361, "'%s' is not a valid driver name", s);
      return -1;
    }

    else
    {
      const char *return_value_get_hdrv_option$1;
      return_value_get_hdrv_option$1=get_hdrv_option(hdrv, s);
      signed int return_value;
      return_value=hdrv->init(return_value_get_hdrv_option$1);
      if(!(return_value >= 0))
      {
        log_write(3, "http_opt_default_parser", 366, "failed to initialize %s driver", hdrv->name);
        return -1;
      }

      else
      {
        list_move_tail$link1(&hdrv->list, &http_enabled_drivers);
        return 0;
      }
    }
  }
}

// http_opt_host_parser
// file http/http.c line 337
static signed int http_opt_host_parser(const char *s)
{
  http_host = s;
  return 0;
}

// http_opt_port_parser
// file http/http.c line 343
static signed int http_opt_port_parser(const char *s)
{
  http_port = s;
  return 0;
}

// http_queue_request
// file http/http.c line 289
static void http_queue_request(struct http_request *req)
{
  struct http_work *hw;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct http_work) /*40ul*/ );
  hw = (struct http_work *)return_value_xmalloc$1;
  hw->work.fn = http_run_request;
  hw->work.done = http_request_done;
  hw->request = req;
  queue_work(sys->http_wqueue, &hw->work);
}

// http_request_done
// file http/http.c line 283
static void http_request_done(struct work *work)
{
  struct http_work *hw;
  struct http_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct http_work *)((char *)__mptr - (signed long int)0ul);
  hw = tmp_statement_expression$1;
  free((void *)hw);
}

// http_request_error
// file http/http.c line 91
static inline void http_request_error(struct http_request *req)
{
  signed int ret;
  ret=FCGX_GetError(req->fcgx.out);
  char *return_value_strerror$1;
  if(ret == 0)
    goto __CPROVER_DUMP_L4;

  else
    if(!(ret >= 0))
      log_write(3, "http_request_error", 98, "failed, FCGI error %d", ret);

    else
    {
      return_value_strerror$1=strerror(ret);
      log_write(3, "http_request_error", 100, "failed, %s", return_value_strerror$1);
    }

__CPROVER_DUMP_L4:
  ;
}

// http_request_read
// file http/http.c line 111
signed int http_request_read(struct http_request *req, void *buf, signed int len)
{
  signed int ret;
  ret=FCGX_GetStr((char *)buf, len, req->fcgx.in);
  if(!(ret >= 0))
    http_request_error(req);

  return ret;
}

// http_request_write
// file http/http.c line 103
signed int http_request_write(struct http_request *req, const void *buf, signed int len)
{
  signed int ret;
  ret=FCGX_PutStr((const char *)buf, len, req->fcgx.out);
  if(!(ret >= 0))
    http_request_error(req);

  return ret;
}

// http_request_writef
// file http/http.c line 128
signed int http_request_writef(struct http_request *req, const char *fmt, ...)
{
  void **ap;
  signed int ret;
  ap = (void **)&fmt;
  ret=FCGX_VFPrintF(req->fcgx.out, fmt, ap);
  ap = ((void **)NULL);
  if(!(ret >= 0))
    http_request_error(req);

  return ret;
}

// http_request_writes
// file http/http.c line 119
signed int http_request_writes(struct http_request *req, const char *str)
{
  signed int ret;
  ret=FCGX_PutS(str, req->fcgx.out);
  if(!(ret >= 0))
    http_request_error(req);

  return ret;
}

// http_response_header
// file http/http.c line 221
void http_response_header(struct http_request *req, enum http_status status)
{
  _Bool tmp_if_expr$2;
  if((signed int)req->status == UNKNOWN)
  {
    req->status = status;
    const char *return_value_strstatus$1;
    return_value_strstatus$1=strstatus(status);
    http_request_writef(req, "Status: %s\r\n", return_value_strstatus$1);
    if((signed int)req->opcode == HTTP_GET)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)req->opcode == HTTP_HEAD ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      http_request_writef(req, "Content-Length: %lu\r\n", req->data_length);

    http_request_writes(req, "Content-type: text/plain;\r\n\r\n");
  }

}

// http_run_request
// file http/http.c line 240
static void http_run_request(struct work *work)
{
  struct http_work *hw;
  struct http_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct http_work *)((char *)__mptr - (signed long int)0ul);
  hw = tmp_statement_expression$1;
  struct http_request *req = hw->request;
  signed int op = (signed int)req->opcode;
  struct http_driver *hdrv;
  struct http_driver *__n247;
  struct http_driver *tmp_statement_expression$2;
  const struct list_node *http_run_request$$1$$2$$1$$__mptr = (&http_enabled_drivers)->n.next;
  tmp_statement_expression$2 = (struct http_driver *)((char *)http_run_request$$1$$2$$1$$__mptr - (signed long int)56ul);
  hdrv = tmp_statement_expression$2;
  struct http_driver *tmp_statement_expression$3;
  const struct list_node *http_run_request$$1$$2$$2$$__mptr = hdrv->list.next;
  tmp_statement_expression$3 = (struct http_driver *)((char *)http_run_request$$1$$2$$2$$__mptr - (signed long int)56ul);
  __n247 = tmp_statement_expression$3;
  struct http_driver *tmp_statement_expression$4;
  for( ; !(&hdrv->list == &(&http_enabled_drivers)->n); __n247 = tmp_statement_expression$4)
  {
    void (*method)(struct http_request *) = (void (*)(struct http_request *))(void *)0;
    switch(op)
    {
      case HTTP_HEAD:
      {
        method = hdrv->head;
        break;
      }
      case HTTP_GET:
      {
        method = hdrv->get;
        break;
      }
      case HTTP_PUT:
      {
        method = hdrv->put;
        break;
      }
      case HTTP_POST:
      {
        method = hdrv->post;
        break;
      }
      case HTTP_DELETE:
        method = hdrv->delete;
    }
    if(!(method == ((void (*)(struct http_request *))NULL)))
    {
      method(req);
      if(sd_log_level == 7)
        log_write(7, "http_run_request", 272, "req->status %d", req->status);

    }

    hdrv = __n247;
    const struct list_node *http_run_request$$1$$2$$3$$__mptr = __n247->list.next;
    tmp_statement_expression$4 = (struct http_driver *)((char *)http_run_request$$1$$2$$3$$__mptr - (signed long int)56ul);
  }
  http_response_header(req, (enum http_status)METHOD_NOT_ALLOWED);

out:
  ;
  http_end_request(req);
}

// http_time
// file http/kv.c line 1167
static char * http_time(unsigned long int time_sec)
{
  struct tm *return_value_gmtime$1;
  return_value_gmtime$1=gmtime((signed long int *)&time_sec);
  static char time_str[128l];
  strftime(time_str, sizeof(char [128l]) /*128ul*/ , "%a, %d %b %Y %H:%M:%S GMT", return_value_gmtime$1);
  return time_str;
}

// hval_to_vdisk
// file md.c line 78
static struct vdisk * hval_to_vdisk(unsigned long int hval)
{
  struct vdisk dummy = { .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .disk=((struct disk *)NULL),
    .hash=hval };
  struct vdisk *tmp_statement_expression$1;
  struct rb_node *__n = (&md.vroot)->rb_node;
  struct vdisk *__ret = (struct vdisk *)(void *)0;
  struct vdisk *__data;
  struct vdisk *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct vdisk *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=vdisk_cmp(&dummy, __data);
    if(!(__cmp >= 0))
    {
      __ret = __data;
      __n = __n->rb_left;
    }

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  struct vdisk *tmp_statement_expression$3;
  if(__ret == ((struct vdisk *)NULL))
  {
    if(!(md.vroot.rb_node == ((struct rb_node *)NULL)))
    {
      const struct rb_node *hval_to_vdisk$$1$$1$$2$$__mptr;
      hval_to_vdisk$$1$$1$$2$$__mptr=rb_first(&md.vroot);
      tmp_statement_expression$3 = (struct vdisk *)((char *)hval_to_vdisk$$1$$1$$2$$__mptr - (signed long int)0ul);
      __ret = tmp_statement_expression$3;
    }

  }

  tmp_statement_expression$1 = __ret;
  return tmp_statement_expression$1;
}

// idx_has_vdi_bit
// file object_cache.c line 122
static inline _Bool idx_has_vdi_bit(unsigned long int idx)
{
  return !(!((idx & 1UL << 63) != 0ul));
}

// idx_in_range
// file sd_inode.c line 261
static _Bool idx_in_range(struct sd_extent_header *header, struct sd_extent_idx *idx)
{
  struct sd_extent_idx *last = (struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  if(last - idx >= 1l)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// idx_to_oid
// file object_cache.c line 283
static unsigned long int idx_to_oid(unsigned int vid, unsigned long int idx)
{
  _Bool return_value_idx_has_vdi_bit$3;
  return_value_idx_has_vdi_bit$3=idx_has_vdi_bit(idx);
  unsigned long int return_value_vid_to_vdi_oid$1;
  unsigned long int return_value_vid_to_data_oid$2;
  if(!(return_value_idx_has_vdi_bit$3 == (_Bool)0))
  {
    return_value_vid_to_vdi_oid$1=vid_to_vdi_oid$link2(vid);
    return return_value_vid_to_vdi_oid$1;
  }

  else
  {
    return_value_vid_to_data_oid$2=vid_to_data_oid$link1(vid, idx);
    return return_value_vid_to_data_oid$2;
  }
}

// inc_and_log_epoch
// file group.c line 539
signed int inc_and_log_epoch(void)
{
  struct vnode_info *cur_vinfo;
  cur_vinfo=get_vnode_info();
  if(!(cur_vinfo == ((struct vnode_info *)NULL)))
  {
    sys->cinfo.nr_nodes = (signed short int)cur_vinfo->nr_nodes;
    nodes_to_buffer(&cur_vinfo->nroot, (void *)sys->cinfo.nodes);
    put_vnode_info(cur_vinfo);
  }

  else
    sys->cinfo.nr_nodes = (signed short int)0;
  __uatomic_inc((void *)&sys->cinfo.epoch, (signed int)sizeof(unsigned int) /*4ul*/ );
  signed int return_value_update_epoch_log$1;
  return_value_update_epoch_log$1=update_epoch_log(sys->cinfo.epoch, sys->cinfo.nodes, (unsigned long int)sys->cinfo.nr_nodes);
  return return_value_update_epoch_log$1;
}

// index_comp
// file sd_inode.c line 122
static signed int index_comp(void *a, void *b)
{
  struct sd_extent_idx *ia = (struct sd_extent_idx *)a;
  struct sd_extent_idx *ib = (struct sd_extent_idx *)b;
  if(!(ib->idx >= ia->idx))
    return 1;

  else
    if(!(ia->idx >= ib->idx))
      return -1;

    else
      return 0;
}

// inetaddr_is_valid
// file ../include/net.h line 64
_Bool inetaddr_is_valid(char *addr)
{
  unsigned char buf[46l];
  signed int af;
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(addr, ":");
  af = return_value_strstr$1 != ((char *)NULL) ? 10 : 2;
  signed int return_value_inet_pton$2;
  return_value_inet_pton$2=inet_pton(af, addr, (void *)buf);
  if(return_value_inet_pton$2 == 0)
  {
    log_write(3, "inetaddr_is_valid", 581, "Bad address '%s'", addr);
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// init_base_path
// file sheep_priv.h line 294
signed int init_base_path(const char *d)
{
  signed int return_value_xmkdir$1;
  return_value_xmkdir$1=xmkdir(d, sd_def_dmode);
  if(!(return_value_xmkdir$1 >= 0))
  {
    log_write(3, "init_base_path", 172, "cannot create the directory %s (%m)", d);
    return -1;
  }

  else
    return 0;
}

// init_config_file
// file sheep_priv.h line 367
signed int init_config_file(void)
{
  signed int fd;
  signed int ret;
  check_tmp_config();
  fd=open(config_path, 00);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
    {
      log_write(3, "init_config_file", 81, "failed to read config file, %m");
      return -1;
    }

    goto create;
  }

  signed long int return_value_xread$2;
  return_value_xread$2=xread(fd, (void *)&config, sizeof(struct sheepdog_config) /*40ul*/ );
  ret = (signed int)return_value_xread$2;
  if(ret == 0)
    close(fd);

  else
  {
    if(!(ret >= 0))
    {
      log_write(3, "init_config_file", 93, "failed to read config file, %m");
      goto out;
    }

    if(!((signed int)config.version == 0x0004))
    {
      log_write(3, "init_config_file", 99, "This sheep version is not compatible with the existing data layout, %d", config.version);
      if(!(sys->upgrade == (_Bool)0))
      {
        ret=sd_migrate_store((signed int)config.version, 0x0004);
        if(ret == 0)
        {
          signed long int return_value_xpread$3;
          return_value_xpread$3=xpread(fd, (void *)&config, sizeof(struct sheepdog_config) /*40ul*/ , (signed long int)0);
          ret = (signed int)return_value_xpread$3;
          if(!((unsigned long int)ret == sizeof(struct sheepdog_config) /*40ul*/ ))
          {
            log_write(3, "init_config_file", 108, "failed to reload config file, %m");
            ret = -1;
          }

          else
          {
            ret = 0;
            goto reload;
          }
        }

        goto out;
      }

      log_write(3, "init_config_file", 118, "use '-u' option to upgrade sheep store");
      ret = -1;
      goto out;
    }


  reload:
    ;
    ret = 0;
    get_cluster_config(&sys->cinfo);
  }

create:
  ;
  config.version = (unsigned short int)0x0004;
  signed int return_value_write_config$4;
  return_value_write_config$4=write_config();
  if(!(return_value_write_config$4 == 0x00))
    return -1;

  else
  {

  out:
    ;
    close(fd);
    return ret;
  }
}

// init_config_path
// file sheep_priv.h line 366
void init_config_path(const char *base_path)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(base_path);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("/config");
  len = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
  void *return_value_xzalloc$3;
  return_value_xzalloc$3=xzalloc((unsigned long int)len);
  config_path = (char *)return_value_xzalloc$3;
  snprintf(config_path, (unsigned long int)len, "%s/config", base_path);
}

// init_disk_space
// file sheep_priv.h line 295
signed int init_disk_space(const char *base_path)
{
  signed int ret = 0x00;
  unsigned long int space_size = (unsigned long int)0;
  unsigned long int mds;
  struct statvfs fs;
  if(sys->gateway_only == (_Bool)0)
  {
    mds=md_init_space();
    ret=get_node_space(&space_size);
    if(!(space_size == 0ul))
      sys->disk_space = space_size;

    else
      if(!(sys->disk_space == 0ul))
        ret=set_node_space(sys->disk_space);

      else
      {
        if(!(mds == 0ul))
          sys->disk_space = mds;

        else
        {
          ret=statvfs(base_path, &fs);
          if(!(ret >= 0))
          {
            if(sd_log_level == 7)
              log_write(7, "init_disk_space", 330, "get disk space failed %m");

            ret = 0x03;
            goto out;
          }

          sys->disk_space = (unsigned long int)fs.f_frsize * fs.f_bavail;
        }
        ret=set_node_space(sys->disk_space);
      }
  }


out:
  ;
  if(sd_log_level == 7)
    log_write(7, "init_disk_space", 339, "disk free space is %lu", sys->disk_space);

  return ret;
}

// init_epoch_path
// file store.c line 251
static signed int init_epoch_path(const char *base_path)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(base_path);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("/epoch/");
  len = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
  void *return_value_xzalloc$3;
  return_value_xzalloc$3=xzalloc((unsigned long int)len);
  epoch_path = (char *)return_value_xzalloc$3;
  snprintf(epoch_path, (unsigned long int)len, "%s/epoch/", base_path);
  signed int return_value_xmkdir$4;
  return_value_xmkdir$4=xmkdir(epoch_path, sd_def_dmode);
  return return_value_xmkdir$4;
}

// init_erasure_buffer
// file gateway.c line 58
static void * init_erasure_buffer(struct request *req, signed int buf_len)
{
  char *buf;
  void *return_value_xvalloc$1;
  return_value_xvalloc$1=xvalloc((unsigned long int)buf_len);
  buf = (char *)return_value_xvalloc$1;
  unsigned int len = req->rq.data_length;
  unsigned long int off = (unsigned long int)req->rq.$anon0.obj.offset;
  unsigned long int oid = req->rq.$anon0.obj.oid;
  signed int opcode = (signed int)req->rq.opcode;
  struct sd_req hdr;
  unsigned long int head = (off / (unsigned long int)1024) * (unsigned long int)1024;
  unsigned long int tail = ((off + (unsigned long int)len) / (unsigned long int)1024) * (unsigned long int)1024;
  signed int ret;
  if(opcode == 0x03)
  {
    if(!(off % 1024ul == 0ul))
    {
      sd_init_req$link1(&hdr, (unsigned char)0x02);
      hdr.$anon0.obj.oid = oid;
      hdr.data_length = (unsigned int)1024;
      hdr.$anon0.obj.offset = (unsigned int)head;
      ret=exec_local_req(&hdr, (void *)buf);
      if(!(ret == 0x00))
      {
        free((void *)buf);
        return (void *)0;
      }

    }

    if(!(tail + -head >= 1ul) || (off + (unsigned long int)len) % 1024ul == 0ul)
      goto out;

    sd_init_req$link1(&hdr, (unsigned char)0x02);
    hdr.$anon0.obj.oid = oid;
    hdr.data_length = (unsigned int)1024;
    hdr.$anon0.obj.offset = (unsigned int)tail;
    ret=exec_local_req(&hdr, (void *)((buf + (signed long int)tail) - (signed long int)head));
    if(ret == 0x00)
      goto out;

    free((void *)buf);
    return (void *)0;
  }

  else
  {

  out:
    ;
    memcpy((void *)(buf + (signed long int)(off % (unsigned long int)1024)), req->data, (unsigned long int)len);
    return (void *)buf;
  }
}

// init_event
// file ../include/event.h line 11
signed int init_event(signed int nr)
{
  nr_events = nr;
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc((unsigned long int)nr_events, sizeof(struct epoll_event) /*12ul*/ );
  events = (struct epoll_event *)return_value_xcalloc$1;
  efd=epoll_create(nr);
  if(!(efd >= 0))
  {
    log_write(3, "init_event", 86, "failed to create epoll fd");
    return -1;
  }

  else
    return 0;
}

// init_fec
// file ../include/fec.h line 74
void init_fec(void)
{
  generate_gf();
  _init_mul_table();
}

// init_global_pathnames
// file sheep_priv.h line 293
signed int init_global_pathnames(const char *d, char *argp)
{
  signed int ret;
  ret=init_obj_path(d, argp);
  if(!(ret == 0))
    return ret;

  else
  {
    ret=init_epoch_path(d);
    if(!(ret == 0))
      return ret;

    else
    {
      init_config_path(d);
      return 0;
    }
  }
}

// init_logmsg
// file logger.c line 381
static void init_logmsg(struct logmsg *msg, struct timeval *tv, signed int prio, const char *func, signed int line)
{
  msg->tv = *tv;
  msg->prio = prio;
  pstrcpy(msg->func, 32, func);
  msg->line = line;
  if(!(worker_name == ((const char *)NULL)))
    pstrcpy(msg->worker_name, 20, worker_name);

  else
    msg->worker_name[(signed long int)0] = (char)0;
  msg->worker_idx = worker_idx;
}

// init_obj_path
// file store.c line 203
static signed int init_obj_path(const char *base_path, char *argp)
{
  char *p;
  signed int len;
  signed int ret;
  struct sd_md_info mdi;
  signed int return_value_check_path_len$1;
  return_value_check_path_len$1=check_path_len(base_path);
  if(!(return_value_check_path_len$1 >= 0))
    return -1;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(base_path);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen("/obj");
    len = (signed int)(return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)1);
    void *return_value_xzalloc$4;
    return_value_xzalloc$4=xzalloc((unsigned long int)len);
    obj_path = (char *)return_value_xzalloc$4;
    snprintf(obj_path, (unsigned long int)len, "%s/obj", base_path);
    strtok(argp, ",");
    p=strtok((char *)(void *)0, ",");
    if(p == ((char *)NULL))
      md_add_disk(obj_path, (_Bool)0);

    else
      do
      {
        signed int return_value_is_meta_store$5;
        return_value_is_meta_store$5=is_meta_store(p);
        if(!(return_value_is_meta_store$5 == 0))
        {
          log_write(3, "init_obj_path", 230, "%s is meta-store, abort", p);
          return -1;
        }

        md_add_disk(p, (_Bool)0);
        p=strtok((char *)(void *)0, ",");
      }
      while(!(p == ((char *)NULL)));
    unsigned int return_value_md_get_info$6;
    return_value_md_get_info$6=md_get_info(&mdi);
    ret = (signed int)return_value_md_get_info$6;
    if(!((unsigned long int)ret == sizeof(struct sd_md_info) /*263688ul*/ ))
    {
      log_write(3, "init_obj_path", 239, "Can't get md info");
      return -1;
    }

    else
      if(!(mdi.nr >= 1))
      {
        log_write(3, "init_obj_path", 244, "There isn't any available disk!");
        return -1;
      }

      else
      {
        signed int return_value_xmkdir$7;
        return_value_xmkdir$7=xmkdir(obj_path, sd_def_dmode);
        return return_value_xmkdir$7;
      }
  }
}

// init_objlist_and_vdi_bitmap
// file plain_store.c line 234
static signed int init_objlist_and_vdi_bitmap(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *arg)
{
  signed int ret;
  objlist_cache_insert(oid);
  _Bool return_value_is_vdi_obj$1;
  return_value_is_vdi_obj$1=is_vdi_obj$link5(oid);
  if(!(return_value_is_vdi_obj$1 == (_Bool)0))
  {
    if(sd_log_level == 7)
      log_write(7, "init_objlist_and_vdi_bitmap", 244, "found the VDI object %lx epoch %u at %s", oid, epoch, wd);

    ret=init_vdi_state(oid, wd, epoch);
    if(ret == 0x00)
      goto __CPROVER_DUMP_L2;

    return ret;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return 0x00;
  }
}

// init_path_space
// file md.c line 263
static unsigned long int init_path_space(const char *path, _Bool purge)
{
  unsigned long int size;
  char stale[4096l];
  _Bool return_value_is_xattr_enabled$1;
  return_value_is_xattr_enabled$1=is_xattr_enabled(path);
  signed int return_value_purge_directory$2;
  signed int return_value_xmkdir$3;
  signed long int return_value_getxattr$5;
  signed int return_value_setxattr$6;
  if(return_value_is_xattr_enabled$1 == (_Bool)0)
    log_write(4, "init_path_space", 270, "multi-disk support need xattr feature for path: %s", path);

  else
  {
    if(!(purge == (_Bool)0))
    {
      return_value_purge_directory$2=purge_directory(path);
      if(!(return_value_purge_directory$2 >= 0))
        log_write(3, "init_path_space", 275, "failed to purge %s", path);

    }

    snprintf(stale, (unsigned long int)4096, "%s/.stale", path);
    return_value_xmkdir$3=xmkdir(stale, sd_def_dmode);
    if(!(return_value_xmkdir$3 >= 0))
      log_write(3, "init_path_space", 279, "can't mkdir for %s, %m", (const void *)stale);

    else
    {
      return_value_getxattr$5=getxattr(path, "user.md.size", (void *)&size, sizeof(unsigned long int) /*8ul*/ );
      if(!(return_value_getxattr$5 >= 0l))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        if(*return_value___errno_location$4 == 61)
          goto create;

        else
        {
          log_write(3, "init_path_space", 289, "%s, %m", path);
          goto broken_path;
        }
      }

      return size;

    create:
      ;
      size=get_path_free_size(path, (unsigned long int *)(void *)0);
      if(!(size == 0ul))
      {
        return_value_setxattr$6=setxattr(path, "user.md.size", (const void *)&size, sizeof(unsigned long int) /*8ul*/ , 0);
        if(!(return_value_setxattr$6 >= 0))
          log_write(3, "init_path_space", 300, "%s, %m", path);

        else
          return size;
      }

    }
  }

broken_path:
  ;
  return (unsigned long int)0;
}

// init_signal
// file sheep.c line 239
static signed int init_signal(void)
{
  struct anonymous$1 mask;
  signed int ret;
  sigemptyset(&mask);
  sigaddset(&mask, 15);
  sigprocmask(0, &mask, (struct anonymous$1 *)(void *)0);
  sigfd=signalfd(-1, &mask, 2048);
  if(!(sigfd >= 0))
  {
    log_write(3, "init_signal", 250, "failed to create a signal fd: %m");
    return -1;
  }

  else
  {
    ret=register_event(sigfd, signal_handler, (void *)0);
    if(!(ret == 0))
    {
      log_write(3, "init_signal", 256, "failed to register signal handler (%d)", ret);
      return -1;
    }

    else
    {
      if(sd_log_level == 7)
        log_write(7, "init_signal", 260, "register signal_handler for %d", sigfd);

      return 0;
    }
  }
}

// init_store_driver
// file sheep_priv.h line 292
signed int init_store_driver(_Bool is_gateway)
{
  char driver_name[16l];
  char *p;
  pstrcpy(driver_name, (signed int)sizeof(char [16l]) /*16ul*/ , (char *)sys->cinfo.store);
  void *return_value_memchr$1;
  return_value_memchr$1=memchr((const void *)driver_name, 0, (unsigned long int)16);
  p = (char *)return_value_memchr$1;
  if(p == ((char *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "init_store_driver", 277, "store name not NUL terminated");

    return 0x8A;
  }

  else
    if(p == driver_name)
      return 0;

    else
    {
      sd_store=find_store_driver$link1(driver_name);
      if(sd_store == ((struct store_driver *)NULL))
      {
        if(sd_log_level == 7)
          log_write(7, "init_store_driver", 290, "store %s not found", (const void *)driver_name);

        return 0x8A;
      }

      else
        if(!(is_gateway == (_Bool)0))
          return 0x00;

        else
        {
          signed int return_value;
          return_value=sd_store->init();
          return return_value;
        }
    }
}

// init_unix_domain_socket
// file sheep_priv.h line 289
signed int init_unix_domain_socket(const char *dir)
{
  char unix_path[4096l];
  snprintf(unix_path, sizeof(char [4096l]) /*4096ul*/ , "%s/sock", dir);
  unlink(unix_path);
  signed int return_value_create_unix_domain_socket$1;
  static _Bool is_inet_socket;
  return_value_create_unix_domain_socket$1=create_unix_domain_socket(unix_path, create_listen_port_fn, (void *)&is_inet_socket);
  return return_value_create_unix_domain_socket$1;
}

// init_vdi_state
// file plain_store.c line 207
static signed int init_vdi_state(unsigned long int oid, const char *wd, unsigned int epoch)
{
  signed int ret;
  struct sd_inode *inode;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(4664ul);
  inode = (struct sd_inode *)return_value_xzalloc$1;
  struct siocb iocb = { .epoch=epoch, .buf=(void *)inode, .length=(unsigned int)4664ul, .offset=0u,
    .ec_index=0, .copy_policy=0 };
  ret=default_read(oid, &iocb);
  unsigned int return_value_oid_to_vid$2;
  _Bool return_value_vdi_is_snapshot$3;
  unsigned int return_value_oid_to_vid$4;
  if(!(ret == 0x00))
    log_write(3, "init_vdi_state", 220, "failed to read inode header %lx %dwat %s", oid, epoch, wd);

  else
  {
    return_value_oid_to_vid$2=oid_to_vid$link7(oid);
    return_value_vdi_is_snapshot$3=vdi_is_snapshot$link1(inode);
    add_vdi_state(return_value_oid_to_vid$2, (signed int)inode->nr_copies, return_value_vdi_is_snapshot$3, inode->copy_policy);
    return_value_oid_to_vid$4=oid_to_vid$link7(oid);
    atomic_set_bit$link2((signed int)return_value_oid_to_vid$4, sys->vdi_inuse);
    ret = 0x00;
  }

out:
  ;
  free((void *)inode);
  return ret;
}

// init_work_queue
// file ../include/work.h line 61
signed int init_work_queue(unsigned long int (*get_nr_nodes)(void))
{
  signed int ret;
  wq_get_nr_nodes = get_nr_nodes;
  if(!(wq_get_nr_nodes == ((unsigned long int (*)(void))NULL)))
    nr_nodes=wq_get_nr_nodes();

  efd$link1=eventfd((unsigned int)0, 2048);
  if(!(efd$link1 >= 0))
  {
    log_write(3, "init_work_queue", 375, "failed to create event fd: %m");
    return -1;
  }

  else
  {
    ret=wq_trace_init();
    if(!(ret >= 0))
      return ret;

    else
    {
      ret=register_event$link3(efd$link1, worker_thread_request_done, (void *)0);
      if(!(ret == 0))
      {
        log_write(3, "init_work_queue", 385, "failed to register event fd %m");
        close(efd$link1);
        return -1;
      }

      else
        return 0;
    }
  }
}

// insert_ext_entry_nosearch
// file sd_inode.c line 290
static void insert_ext_entry_nosearch(struct sd_extent_header *header, struct sd_extent *ext, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent *last = (struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  memmove((void *)(ext + (signed long int)1), (const void *)ext, (unsigned long int)(last - ext) * sizeof(struct sd_extent) /*8ul*/ );
  ext->idx = idx;
  ext->vdi_id = vdi_id;
  header->entries = header->entries + 1u;
}

// insert_idx_entry
// file sd_inode.c line 314
static void insert_idx_entry(struct sd_extent_header *header, unsigned int idx, unsigned long int oid)
{
  struct sd_extent_idx *found;
  if(!((unsigned long int)header->entries >= 262143ul))
  {
    if(header->entries == 0u)
    {
      ((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ))->idx = idx;
      ((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ))->oid = oid;
      header->entries = header->entries + 1u;
    }

    else
    {
      found=search_idx_entry(header, idx);
      insert_idx_entry_nosearch(header, found, idx, oid);
    }
  }


out:
  ;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// insert_idx_entry_nosearch
// file sd_inode.c line 302
static void insert_idx_entry_nosearch(struct sd_extent_header *header, struct sd_extent_idx *idx_ext, unsigned int idx, unsigned long int oid)
{
  struct sd_extent_idx *last = (struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  memmove((void *)(idx_ext + (signed long int)1), (const void *)idx_ext, (unsigned long int)(last - idx_ext) * sizeof(struct sd_extent_idx) /*16ul*/ );
  idx_ext->idx = idx;
  idx_ext->oid = oid;
  header->entries = header->entries + 1u;
}

// insert_new_node
// file sd_inode.c line 499
static signed int insert_new_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, struct find_path *path, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent_header *header = (struct sd_extent_header *)inode->data_vdi_id;
  struct sd_extent_header *leaf_node = (struct sd_extent_header *)(void *)0;
  unsigned long int oid;
  signed int ret = 0x00;
  unsigned int tmp_post$2;
  if(path->depth == 1)
  {
    if((unsigned long int)header->entries >= 524287ul)
    {
      transfer_to_idx_root(writer, inode);
      ret = 0x1D;
      goto out;
    }

    insert_ext_entry_nosearch(header, path->p_ext, idx, vdi_id);
  }

  else
    if(path->depth == 2)
    {
      _Bool return_value_idx_in_range$3;
      return_value_idx_in_range$3=idx_in_range(header, path->p_idx);
      if(!(return_value_idx_in_range$3 == (_Bool)0))
      {
        if(path->p_ext_header == ((struct sd_extent_header *)NULL))
        {
          ret = 0x1B;
          goto out;
        }

        if((unsigned long int)path->p_ext_header->entries >= 524287ul)
        {
          split_ext_node(writer, inode, path);
          ret = 0x1D;
          goto out;
        }

        insert_ext_entry_nosearch(path->p_ext_header, path->p_ext, idx, vdi_id);
        writer(path->p_idx->oid, (void *)path->p_ext_header, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
      }

      else
        if(!(path->p_ext_header == ((struct sd_extent_header *)NULL)))
        {
          insert_ext_entry_nosearch(path->p_ext_header, path->p_ext, idx, vdi_id);
          path->p_idx = path->p_idx - 1l;
          path->p_idx->idx = (((struct sd_extent *)((char *)path->p_ext_header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)path->p_ext_header)->entries) - (signed long int)1)->idx;
          writer(path->p_idx->oid, (void *)path->p_ext_header, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
        }

        else
        {
          if((unsigned long int)header->entries >= 262143ul)
          {
            log_write(0, "insert_new_node", 545, "PANIC: %s() B-tree is full!", (const void *)"insert_new_node");
            abort();
          }

          void *return_value_xvalloc$1;
          return_value_xvalloc$1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
          leaf_node = (struct sd_extent_header *)return_value_xvalloc$1;
          sd_inode_init((void *)leaf_node, 2);
          tmp_post$2 = inode->btree_counter;
          inode->btree_counter = inode->btree_counter + 1u;
          oid=vid_to_btree_oid(inode->vdi_id, tmp_post$2);
          insert_ext_entry_nosearch(leaf_node, (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), idx, vdi_id);
          writer(oid, (void *)leaf_node, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
          insert_idx_entry_nosearch(header, path->p_idx, idx, oid);
        }
    }


out:
  ;
  if(!(leaf_node == ((struct sd_extent_header *)NULL)))
    free((void *)leaf_node);

  return ret;
}

// install_crash_handler
// file ../include/util.h line 112
signed int install_crash_handler(void (*handler)(signed int))
{
  signed int return_value_install_sighandler$1;
  return_value_install_sighandler$1=install_sighandler(11, handler, (_Bool)1);
  _Bool tmp_if_expr$3;
  signed int return_value_install_sighandler$2;
  if(!(return_value_install_sighandler$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_install_sighandler$2=install_sighandler(6, handler, (_Bool)1);
    tmp_if_expr$3 = return_value_install_sighandler$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  signed int return_value_install_sighandler$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_install_sighandler$4=install_sighandler(7, handler, (_Bool)1);
    tmp_if_expr$5 = return_value_install_sighandler$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_install_sighandler$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_install_sighandler$6=install_sighandler(4, handler, (_Bool)1);
    tmp_if_expr$7 = return_value_install_sighandler$6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$9;
  signed int return_value_install_sighandler$8;
  if(tmp_if_expr$7)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_install_sighandler$8=install_sighandler(8, handler, (_Bool)1);
    tmp_if_expr$9 = return_value_install_sighandler$8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$9;
}

// install_sighandler
// file ../include/util.h line 111
signed int install_sighandler(signed int signum, void (*handler)(signed int), _Bool once)
{
  struct sigaction sa = { .__sigaction_handler={ .sa_handler=((void (*)(signed int))NULL) }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  sa.__sigaction_handler.sa_handler = handler;
  if(!(once == (_Bool)0))
    sa.sa_flags = (signed int)(0x80000000 | (unsigned int)0x40000000);

  sigemptyset(&sa.sa_mask);
  signed int return_value_sigaction$1;
  return_value_sigaction$1=sigaction(signum, &sa, (struct sigaction *)(void *)0);
  return return_value_sigaction$1;
}

// invalid_node
// file recovery.c line 120
static _Bool invalid_node(struct sd_node *n, struct vnode_info *info)
{
  struct sd_node *tmp_statement_expression$1;
  struct rb_node *__n = (&info->nroot)->rb_node;
  struct sd_node *__ret = (struct sd_node *)(void *)0;
  struct sd_node *__data;
  struct sd_node *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=node_cmp$link2(n, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  if(!(tmp_statement_expression$1 == ((struct sd_node *)NULL)))
    return (_Bool)0;

  else
    return (_Bool)1;
}

// io_op_done
// file request.c line 40
static void io_op_done(struct work *work)
{
  struct request *req;
  struct request *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)192ul);
  req = tmp_statement_expression$1;
  const char *return_value_sd_strerror$2;
  switch(req->rp.$anon0.result)
  {
    case (unsigned int)0x03:
    {
      req->rp.$anon0.result = (unsigned int)0x86;
      log_write(3, "io_op_done", 48, "leaving sheepdog cluster");
      leave_cluster();
      break;
    }
    case (unsigned int)0x00:

    case (unsigned int)0x86:
      break;
    default:
      if(sd_log_level == 7)
      {
        return_value_sd_strerror$2=sd_strerror$link1((signed int)req->rp.$anon0.result);
        log_write(7, "io_op_done", 55, "unhandled error %s", return_value_sd_strerror$2);
      }

  }
  put_request(req);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// iocb_is_aligned
// file plain_store.c line 18
static inline _Bool iocb_is_aligned(struct siocb *iocb)
{
  _Bool tmp_statement_expression$1 = (iocb->offset & (1U << 9) - (unsigned int)1) == (unsigned int)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_statement_expression$2;
  if(tmp_statement_expression$1)
  {
    tmp_statement_expression$2 = (iocb->length & (1U << 9) - (unsigned int)1) == (unsigned int)0;
    tmp_if_expr$3 = tmp_statement_expression$2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return tmp_if_expr$3;
}

// ionic_host_parser
// file sheep.c line 372
static signed int ionic_host_parser(const char *s)
{
  io_addr = s;
  return 0;
}

// ionic_port_parser
// file sheep.c line 378
static signed int ionic_port_parser(const char *s)
{
  io_pt = s;
  return 0;
}

// is_access_local
// file request.c line 24
static _Bool is_access_local(struct request *req, unsigned long int oid)
{
  struct sd_vnode *obj_vnodes[31l];
  signed int nr_copies;
  signed int i;
  nr_copies=get_req_copy_number(req);
  oid_to_vnodes(oid, &req->vinfo->vroot, nr_copies, obj_vnodes);
  i = 0;
  for( ; !(i >= nr_copies); i = i + 1)
  {
    _Bool return_value_vnode_is_local$1;
    return_value_vnode_is_local$1=vnode_is_local(obj_vnodes[(signed long int)i]);
    if(!(return_value_vnode_is_local$1 == (_Bool)0))
      return (_Bool)1;

  }
  return (_Bool)0;
}

// is_aligned_to_pagesize
// file sheep_priv.h line 283
static inline _Bool is_aligned_to_pagesize(void *p)
{
  signed int return_value_getpagesize$1;
  return_value_getpagesize$1=getpagesize();
  return ((unsigned long int)p & (unsigned long int)(return_value_getpagesize$1 - 1)) == (unsigned long int)0;
}

// is_cluster_formatted
// file sheep_priv.h line 353
_Bool is_cluster_formatted(void)
{
  struct cluster_info cinfo;
  get_cluster_config(&cinfo);
  return cinfo.ctime != (unsigned long int)0;
}

// is_cluster_op
// file sheep_priv.h line 414
_Bool is_cluster_op(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = (signed int)op->type == SD_OP_TYPE_CLUSTER ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// is_data_obj
// file ../include/sheepdog_proto.h line 405
static inline _Bool is_data_obj(unsigned long int oid)
{
  _Bool return_value_is_vdi_obj$1;
  return_value_is_vdi_obj$1=is_vdi_obj$link1(oid);
  _Bool tmp_if_expr$3;
  _Bool return_value_is_vmstate_obj$2;
  if(return_value_is_vdi_obj$1 == (_Bool)0)
  {
    return_value_is_vmstate_obj$2=is_vmstate_obj(oid);
    tmp_if_expr$3 = !(return_value_is_vmstate_obj$2 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool return_value_is_vdi_attr_obj$4;
  if(tmp_if_expr$3)
  {
    return_value_is_vdi_attr_obj$4=is_vdi_attr_obj$link1(oid);
    tmp_if_expr$5 = !(return_value_is_vdi_attr_obj$4 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  _Bool tmp_if_expr$7;
  _Bool return_value_is_vdi_btree_obj$6;
  if(tmp_if_expr$5)
  {
    return_value_is_vdi_btree_obj$6=is_vdi_btree_obj$link1(oid);
    tmp_if_expr$7 = !(return_value_is_vdi_btree_obj$6 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  return tmp_if_expr$7;
}

// is_ec_dentry
// file sheep_priv.h line 507
static inline _Bool is_ec_dentry(const char *dentry)
{
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(dentry, "_");
  return !(!(return_value_strstr$1 != ((char *)NULL)));
}

// is_erasure_oid
// file gateway.c line 182
_Bool is_erasure_oid(unsigned long int oid)
{
  _Bool return_value_is_vdi_obj$1;
  return_value_is_vdi_obj$1=is_vdi_obj(oid);
  _Bool tmp_if_expr$3;
  _Bool return_value_is_vdi_btree_obj$2;
  if(return_value_is_vdi_obj$1 == (_Bool)0)
  {
    return_value_is_vdi_btree_obj$2=is_vdi_btree_obj(oid);
    tmp_if_expr$3 = !(return_value_is_vdi_btree_obj$2 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$6;
  unsigned int return_value_oid_to_vid$4;
  signed int return_value_get_vdi_copy_policy$5;
  if(tmp_if_expr$3)
  {
    return_value_oid_to_vid$4=oid_to_vid$link1(oid);
    return_value_get_vdi_copy_policy$5=get_vdi_copy_policy(return_value_oid_to_vid$4);
    tmp_if_expr$6 = return_value_get_vdi_copy_policy$5 > 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  return tmp_if_expr$6;
}

// is_force_op
// file sheep_priv.h line 418
_Bool is_force_op(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = op->force != (_Bool)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// is_gateway_op
// file sheep_priv.h line 417
_Bool is_gateway_op(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = (signed int)op->type == SD_OP_TYPE_GATEWAY ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// is_local_op
// file sheep_priv.h line 415
_Bool is_local_op(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = (signed int)op->type == SD_OP_TYPE_LOCAL ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// is_logging_op
// file sheep_priv.h line 419
_Bool is_logging_op(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = op->is_admin_op != (_Bool)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// is_meta_store
// file store.c line 190
static signed int is_meta_store(const char *path)
{
  char conf[4096l];
  char epoch[4096l];
  snprintf(conf, (unsigned long int)4096, "%s/config", path);
  snprintf(epoch, (unsigned long int)4096, "%s/epoch", path);
  signed int return_value_access$2;
  return_value_access$2=access(conf, 4);
  signed int return_value_access$1;
  if(return_value_access$2 == 0)
  {
    return_value_access$1=access(epoch, 4);
    if(!(return_value_access$1 == 0))
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// is_numeric
// file util.c line 399
_Bool is_numeric(const char *s)
{
  const char *p = s;
  const char *tmp_post$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  if(!(*p == 0))
  {
    char c;
    do
    {
      tmp_post$1 = p;
      p = p + 1l;
      c = *tmp_post$1;
      if(c == 0)
        break;

      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)c]) == 0)
        return (_Bool)0;

    }
    while((_Bool)1);
    return (_Bool)1;
  }

  return (_Bool)0;
}

// is_peer_op
// file sheep_priv.h line 416
_Bool is_peer_op(struct sd_op_template *op)
{
  _Bool tmp_if_expr$1;
  if(!(op == ((struct sd_op_template *)NULL)))
    tmp_if_expr$1 = (signed int)op->type == SD_OP_TYPE_PEER ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return tmp_if_expr$1;
}

// is_sheep_dead
// file logger.c line 529
static _Bool is_sheep_dead(signed int signo)
{
  return signo == 1;
}

// is_stale_dentry
// file sheep_priv.h line 497
static inline _Bool is_stale_dentry(const char *dentry)
{
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(dentry, ".");
  return !(!(return_value_strstr$1 != ((char *)NULL)));
}

// is_stale_path
// file sheep_priv.h line 492
static inline _Bool is_stale_path(const char *path)
{
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(path, ".stale");
  return !(!(return_value_strstr$1 != ((char *)NULL)));
}

// is_stdout_console
// file ../include/util.h line 493
static inline _Bool is_stdout_console(void)
{
  signed int return_value_isatty$1;
  return_value_isatty$1=isatty(1);
  return (_Bool)return_value_isatty$1;
}

// is_tmp_dentry
// file sheep_priv.h line 502
static inline _Bool is_tmp_dentry(const char *dentry)
{
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(dentry, ".tmp");
  return !(!(return_value_strstr$1 != ((char *)NULL)));
}

// is_vdi_attr_obj
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 61) != 0ul));
}

// is_vdi_attr_obj$link1
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link1(unsigned long int oid$link1)
{
  return !(!((oid$link1 & 1UL << 61) != 0ul));
}

// is_vdi_attr_obj$link2
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link2(unsigned long int oid$link2)
{
  return !(!((oid$link2 & 1UL << 61) != 0ul));
}

// is_vdi_attr_obj$link3
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link3(unsigned long int oid$link3)
{
  return !(!((oid$link3 & 1UL << 61) != 0ul));
}

// is_vdi_attr_obj$link4
// file ../include/sheepdog_proto.h line 395
static inline _Bool is_vdi_attr_obj$link4(unsigned long int oid$link4)
{
  return !(!((oid$link4 & 1UL << 61) != 0ul));
}

// is_vdi_btree_obj
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 60) != 0ul));
}

// is_vdi_btree_obj$link1
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link1(unsigned long int oid$link1)
{
  return !(!((oid$link1 & 1UL << 60) != 0ul));
}

// is_vdi_btree_obj$link2
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link2(unsigned long int oid$link2)
{
  return !(!((oid$link2 & 1UL << 60) != 0ul));
}

// is_vdi_btree_obj$link3
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link3(unsigned long int oid$link3)
{
  return !(!((oid$link3 & 1UL << 60) != 0ul));
}

// is_vdi_btree_obj$link4
// file ../include/sheepdog_proto.h line 400
static inline _Bool is_vdi_btree_obj$link4(unsigned long int oid$link4)
{
  return !(!((oid$link4 & 1UL << 60) != 0ul));
}

// is_vdi_obj
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 63) != 0ul));
}

// is_vdi_obj$link1
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link1(unsigned long int oid$link1)
{
  return !(!((oid$link1 & 1UL << 63) != 0ul));
}

// is_vdi_obj$link2
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link2(unsigned long int oid$link2)
{
  return !(!((oid$link2 & 1UL << 63) != 0ul));
}

// is_vdi_obj$link3
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link3(unsigned long int oid$link3)
{
  return !(!((oid$link3 & 1UL << 63) != 0ul));
}

// is_vdi_obj$link4
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link4(unsigned long int oid$link4)
{
  return !(!((oid$link4 & 1UL << 63) != 0ul));
}

// is_vdi_obj$link5
// file ../include/sheepdog_proto.h line 385
static inline _Bool is_vdi_obj$link5(unsigned long int oid$link5)
{
  return !(!((oid$link5 & 1UL << 63) != 0ul));
}

// is_vmstate_obj
// file ../include/sheepdog_proto.h line 390
static inline _Bool is_vmstate_obj(unsigned long int oid)
{
  return !(!((oid & 1UL << 62) != 0ul));
}

// is_vmstate_obj$link1
// file ../include/sheepdog_proto.h line 390
static inline _Bool is_vmstate_obj$link1(unsigned long int oid$link1)
{
  return !(!((oid$link1 & 1UL << 62) != 0ul));
}

// is_xattr_enabled
// file ../include/util.h line 116
_Bool is_xattr_enabled(const char *path)
{
  signed int ret;
  signed int dummy;
  signed long int return_value_getxattr$1;
  return_value_getxattr$1=getxattr(path, "user.dummy", (void *)&dummy, sizeof(signed int) /*4ul*/ );
  ret = (signed int)return_value_getxattr$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  if(ret == -1)
  {
    return_value___errno_location$2=__errno_location();
    tmp_if_expr$3 = *return_value___errno_location$2 == 95 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  return !tmp_if_expr$3;
}

// jfile_enough_space
// file journal.c line 309
static inline _Bool jfile_enough_space(unsigned long int size)
{
  return (unsigned long int)jfile.pos + size < jfile_size;
}

// journal_commit_data_done
// file journal.c line 334
static void journal_commit_data_done(struct work *work)
{
  free((void *)work);
}

// journal_commit_data_work
// file journal.c line 322
static void journal_commit_data_work(struct work *work)
{
  sync();
  signed int return_value_xftruncate$1;
  return_value_xftruncate$1=xftruncate(jfile.commit_fd, (signed long int)0);
  if(!(return_value_xftruncate$1 >= 0))
  {
    log_write(0, "journal_commit_data_work", 327, "PANIC: truncate %m");
    abort();
  }

  signed int return_value_prealloc$2;
  return_value_prealloc$2=prealloc(jfile.commit_fd, (unsigned int)jfile_size);
  if(!(return_value_prealloc$2 >= 0))
  {
    log_write(0, "journal_commit_data_work", 329, "PANIC: prealloc %m");
    abort();
  }

  sd_mutex_unlock$link2(&journal_commit_mutex);
}

// journal_dir_parser
// file sheep.c line 394
static signed int journal_dir_parser(const char *s)
{
  snprintf(jpath, sizeof(char [4096l]) /*4096ul*/ , "%s", s);
  return 0;
}

// journal_entry_full_write
// file journal.c line 125
static _Bool journal_entry_full_write(struct journal_descriptor *jd)
{
  char *end = (char *)jd + (signed long int)((jd->size + (unsigned long int)(1U << 9)) - (unsigned long int)1 & (unsigned long int)~((1U << 9) - (unsigned int)1)) + (signed long int)(508 + 4);
  unsigned int marker = *((unsigned int *)end - (signed long int)1);
  if(!(marker == 0xdeadbeef))
    return (_Bool)0;

  else
    return (_Bool)1;
}

// journal_file_init
// file sheep_priv.h line 474
signed int journal_file_init(const char *path, unsigned long int size, _Bool skip)
{
  signed int fd;
  if(skip == (_Bool)0)
    check_recover_journal_file(path);

  jfile_size = size / (unsigned long int)2;
  fd=create_journal_file(path, jfile_name[(signed long int)0]);
  if(!(fd >= 0))
    return -1;

  else
  {
    jfile_fds[(signed long int)0] = fd;
    jfile.fd = jfile_fds[(signed long int)0];
    fd=create_journal_file(path, jfile_name[(signed long int)1]);
    jfile_fds[(signed long int)1] = fd;
    commit_wq=create_ordered_work_queue("journal commit");
    if(commit_wq == ((struct work_queue *)NULL))
    {
      log_write(3, "journal_file_init", 284, "error at creating a workqueue for journal data commit");
      return -1;
    }

    else
      return 0;
  }
}

// journal_file_write
// file journal.c line 363
static signed int journal_file_write(struct journal_descriptor *jd, const char *buf)
{
  unsigned int marker = 0xdeadbeef;
  signed int ret = 0x00;
  unsigned long int size = jd->size;
  signed long int written;
  signed long int rusize = (signed long int)(1 != 0 && ((1U << 9) - (unsigned int)1 & 1U << 9) == (unsigned int)0 ? (size + (unsigned long int)(1U << 9)) - (unsigned long int)1 & (unsigned long int)~((1U << 9) - (unsigned int)1) : ((size + (unsigned long int)((1U << 9) - (unsigned int)1)) / (unsigned long int)(1U << 9)) * (unsigned long int)(1U << 9));
  signed long int wsize = (signed long int)(508 + 4) + rusize;
  signed long int woff;
  char *wbuffer;
  char *p;
  sd_mutex_lock$link2(&jfile_lock);
  _Bool return_value_jfile_enough_space$1;
  return_value_jfile_enough_space$1=jfile_enough_space((unsigned long int)wsize);
  if(return_value_jfile_enough_space$1 == (_Bool)0)
    switch_journal_file();

  woff = jfile.pos;
  jfile.pos = jfile.pos + wsize;
  sd_mutex_unlock$link2(&jfile_lock);
  void *return_value_xvalloc$2;
  return_value_xvalloc$2=xvalloc((unsigned long int)wsize);
  wbuffer = (char *)return_value_xvalloc$2;
  p = wbuffer;
  memcpy((void *)p, (const void *)jd, (unsigned long int)508);
  p = p + (signed long int)508;
  memcpy((void *)p, (const void *)buf, size);
  p = p + (signed long int)size;
  if(!(size >= (unsigned long int)rusize))
  {
    memset((void *)p, 0, (unsigned long int)rusize - size);
    p = p + (signed long int)((unsigned long int)rusize - size);
  }

  memcpy((void *)p, (const void *)&marker, (unsigned long int)4);
  written=xpwrite(jfile.fd, (const void *)wbuffer, (unsigned long int)wsize, woff);
  if(!(written == wsize))
  {
    log_write(3, "journal_file_write", 399, "failed, written %zd, len %zd", written, wsize);
    ret = 0x03;
  }


out:
  ;
  free((void *)wbuffer);
  return ret;
}

// journal_remove_object
// file journal.c line 424
signed int journal_remove_object(unsigned long int oid)
{
  struct journal_descriptor jd = { .magic=0xfee1900d, .flag=(unsigned short int)2, .reserved=0,
    .oid=oid, .offset=0ul, .size=(unsigned long int)0, .create=0,
    .pad={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int return_value_journal_file_write$1;
  return_value_journal_file_write$1=journal_file_write(&jd, (const char *)(void *)0);
  return return_value_journal_file_write$1;
}

// journal_size_parser
// file sheep.c line 400
static signed int journal_size_parser(const char *s)
{
  signed int return_value_option_parse_size$1;
  return_value_option_parse_size$1=option_parse_size(s, &jsize);
  if(!(return_value_option_parse_size$1 >= 0))
    return -1;

  else
    if(!(jsize >= 67108864ul))
    {
      log_write(3, "journal_size_parser", 407, "invalid size %s, must be bigger than %u(M)", s, ((64 * 1024 * 1024) / 1024) / 1024);
      return -1;
    }

    else
      return 0;
}

// journal_skip_parser
// file sheep.c line 413
static signed int journal_skip_parser(const char *s)
{
  jskip = (_Bool)1;
  return 0;
}

// journal_write_store
// file journal.c line 409
signed int journal_write_store(unsigned long int oid, const char *buf, unsigned long int size, signed long int offset, _Bool create)
{
  struct journal_descriptor jd = { .magic=0xfee1900d, .flag=(unsigned short int)0, .reserved=0,
    .oid=oid, .offset=(unsigned long int)offset, .size=size,
    .create=(unsigned char)create, .pad={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int return_value_journal_file_write$1;
  return_value_journal_file_write$1=journal_file_write(&jd, buf);
  return return_value_journal_file_write$1;
}

// kick_background_pusher
// file object_cache.c line 240
static void kick_background_pusher(struct object_cache *oc)
{
  struct push_work *pw;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct push_work) /*48ul*/ );
  pw = (struct push_work *)return_value_xzalloc$1;
  pw->oc = oc;
  pw->work.fn = do_background_push;
  pw->work.done = background_push_done;
  queue_work(sys->oc_push_wqueue, &pw->work);
}

// kick_node_recover
// file group.c line 972
static void kick_node_recover(void)
{
  struct vnode_info *old;
  struct vnode_info *tmp_statement_expression$1 = current_vnode_info.__val;
  old = tmp_statement_expression$1;
  signed int ret;
  current_vnode_info.__val=alloc_vnode_info(&old->nroot);
  ret=inc_and_log_epoch();
  if(!(ret == 0))
  {
    log_write(0, "kick_node_recover", 984, "PANIC: cannot log current epoch %d", sys->cinfo.epoch);
    abort();
  }

  struct vnode_info *tmp_statement_expression$2 = current_vnode_info.__val;
  start_recovery(tmp_statement_expression$2, old, (_Bool)1);
  put_vnode_info(old);
}

// kick_recover
// file md.c line 510
static inline void kick_recover(void)
{
  struct vnode_info *vinfo;
  vinfo=get_vnode_info();
  start_recovery(vinfo, vinfo, (_Bool)0);
  put_vnode_info(vinfo);
}

// kv_create_account
// file http/kv.c line 114
signed int kv_create_account(const char *account)
{
  unsigned int vdi_id;
  signed int return_value_kv_create_hyper_volume$1;
  return_value_kv_create_hyper_volume$1=kv_create_hyper_volume(account, &vdi_id);
  return return_value_kv_create_hyper_volume$1;
}

// kv_create_bucket
// file http/kv.c line 513
signed int kv_create_bucket(const char *account, const char *bucket)
{
  unsigned int account_vid;
  unsigned int vid;
  char vdi_name[256l];
  signed int ret;
  ret=sd_lookup_vdi(account, &account_vid);
  if(!(ret == 0x00))
  {
    log_write(3, "kv_create_bucket", 521, "Failed to find account %s", account);
    return ret;
  }

  else
  {
    sys->cdrv->lock((unsigned long int)account_vid);
    snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
    ret=sd_lookup_vdi(vdi_name, &vid);
    if(ret == 0x00)
    {
      log_write(3, "kv_create_bucket", 529, "bucket %s is exists.", bucket);
      ret = 0x04;
    }

    else
      if(ret == 0x08)
        ret=bucket_create(account, account_vid, bucket);


  out:
    ;
    sys->cdrv->unlock((unsigned long int)account_vid);
    return ret;
  }
}

// kv_create_hyper_volume
// file http/kv.c line 63
static signed int kv_create_hyper_volume(const char *name, unsigned int *vdi_id)
{
  struct sd_req hdr;
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  signed int ret;
  char buf[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  pstrcpy(buf, (signed int)256U, name);
  sd_init_req$link6(&hdr, (unsigned char)0x11);
  hdr.flags = (unsigned short int)0x01;
  hdr.data_length = 256U;
  hdr.$anon0.vdi.vdi_size = (1UL << 22) * (1ULL << 32);
  hdr.$anon0.vdi.copies = sys->cinfo.nr_copies;
  hdr.$anon0.vdi.copy_policy = sys->cinfo.copy_policy;
  hdr.$anon0.vdi.store_policy = (unsigned char)1;
  ret=exec_local_req(&hdr, (void *)buf);
  const char *return_value_sd_strerror$1;
  if(!(rsp->$anon0.result == 0u))
  {
    return_value_sd_strerror$1=sd_strerror$link8((signed int)rsp->$anon0.result);
    log_write(3, "kv_create_hyper_volume", 84, "Failed to create VDI %s: %s", name, return_value_sd_strerror$1);
  }

  if(!(vdi_id == ((unsigned int *)NULL)))
    *vdi_id = rsp->$anon0.vdi.vdi_id;

  return ret;
}

// kv_create_object
// file http/kv.c line 1032
signed int kv_create_object(struct http_request *req, const char *account, const char *bucket, const char *name)
{
  char vdi_name[256l];
  struct kv_onode *onode;
  unsigned int bucket_vid;
  unsigned int data_vid;
  signed int ret;
  snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
  ret=sd_lookup_vdi(vdi_name, &bucket_vid);
  if(!(ret == 0x00))
    return ret;

  else
  {
    void *return_value_xzalloc$1;
    return_value_xzalloc$1=xzalloc(sizeof(struct kv_onode) /*4194304ul*/ );
    onode = (struct kv_onode *)return_value_xzalloc$1;
    ret=onode_lookup(onode, bucket_vid, name);
    if(ret == 0x00)
    {
      ret=kv_delete_object(account, bucket, name);
      if(!(ret == 0x00))
      {
        log_write(3, "kv_create_object", 1051, "Failed to delete exists object %s", name);
        goto out;
      }

    }

    else
      if(!(ret == 0x02))
        goto out;

    snprintf(vdi_name, (unsigned long int)256U, "%s/%s/allocator", account, bucket);
    ret=sd_lookup_vdi(vdi_name, &data_vid);
    if(ret == 0x00)
    {
      memset((void *)onode, 0, sizeof(struct kv_onode) /*4194304ul*/ );
      pstrcpy(onode->$anon0.$anon0.name, (signed int)sizeof(char [1024l]) /*1024ul*/ , name);
      onode->$anon0.$anon0.data_vid = data_vid;
      ret=onode_populate_data(onode, req);
      if(!(ret == 0x00))
        log_write(3, "kv_create_object", 1068, "failed to write data for %s", name);

      else
      {
        ret=onode_create(onode, bucket_vid);
        if(!(ret == 0x00))
        {
          log_write(3, "kv_create_object", 1074, "failed to create onode for %s", name);
          onode_free_data(onode);
        }

        else
        {
          ret=bnode_update(account, bucket, req->data_length, (_Bool)1);
          if(!(ret == 0x00))
          {
            log_write(3, "kv_create_object", 1081, "failed to update bucket for %s", name);
            onode_delete(onode);
          }

        }
      }
    }


  out:
    ;
    free((void *)onode);
    return ret;
  }
}

// kv_delete_account
// file http/kv.c line 202
signed int kv_delete_account(struct http_request *req, const char *account)
{
  unsigned long int bcount;
  unsigned long int ocount;
  unsigned long int used;
  signed int ret;
  ret=read_account_meta(account, &bcount, &ocount, &used);
  if(!(ret == 0x00))
    return ret;

  else
    if(!(bcount == 0ul))
      return 0x92;

    else
    {
      ret=sd_delete_vdi(account);
      if(!(ret == 0x00))
        log_write(3, "kv_delete_account", 216, "Failed to delete vdi %s", account);

      return ret;
    }
}

// kv_delete_bucket
// file http/kv.c line 574
signed int kv_delete_bucket(const char *account, const char *bucket)
{
  unsigned int account_vid;
  unsigned int vid;
  char vdi_name[256l];
  signed int ret;
  ret=sd_lookup_vdi(account, &account_vid);
  if(!(ret == 0x00))
  {
    log_write(3, "kv_delete_bucket", 582, "Failed to find account %s", account);
    return ret;
  }

  else
  {
    sys->cdrv->lock((unsigned long int)account_vid);
    snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
    ret=sd_lookup_vdi(vdi_name, &vid);
    if(ret == 0x00)
      ret=bucket_delete(account, account_vid, bucket);


  out:
    ;
    sys->cdrv->unlock((unsigned long int)account_vid);
    return ret;
  }
}

// kv_delete_object
// file http/kv.c line 1116
signed int kv_delete_object(const char *account, const char *bucket, const char *name)
{
  char vdi_name[256l];
  unsigned int bucket_vid;
  struct kv_onode *onode = (struct kv_onode *)(void *)0;
  signed int ret;
  snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
  ret=sd_lookup_vdi(vdi_name, &bucket_vid);
  if(!(ret == 0x00))
    return ret;

  else
  {
    void *return_value_xzalloc$1;
    return_value_xzalloc$1=xzalloc(sizeof(struct kv_onode) /*4194304ul*/ );
    onode = (struct kv_onode *)return_value_xzalloc$1;
    ret=onode_lookup(onode, bucket_vid, name);
    if(ret == 0x00)
    {
      ret=onode_delete(onode);
      if(!(ret == 0x00))
        log_write(3, "kv_delete_object", 1135, "failed to delete bnode for %s", name);

      else
      {
        ret=bnode_update(account, bucket, onode->$anon0.$anon0.size, (_Bool)0);
        if(!(ret == 0x00))
          log_write(3, "kv_delete_object", 1140, "failed to update bnode for %s", name);

      }
    }


  out:
    ;
    free((void *)onode);
    return ret;
  }
}

// kv_iterate_bucket
// file http/kv.c line 598
signed int kv_iterate_bucket(const char *account, void (*cb)(const char *, void *), void *opaque)
{
  struct sd_inode account_inode;
  struct bucket_iterater_arg arg = { .opaque=opaque, .cb=cb, .bucket_count=(unsigned long int)0, .object_count=(unsigned long int)0,
    .bytes_used=(unsigned long int)0 };
  unsigned int account_vid;
  unsigned long int oid;
  signed int ret;
  ret=sd_lookup_vdi(account, &account_vid);
  if(!(ret == 0x00))
  {
    log_write(3, "kv_iterate_bucket", 608, "Failed to find account %s", account);
    return ret;
  }

  else
  {
    oid=vid_to_vdi_oid$link3(account_vid);
    sys->cdrv->lock((unsigned long int)account_vid);
    ret=sd_read_object(oid, (char *)&account_inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
    if(!(ret == 0x00))
      log_write(3, "kv_iterate_bucket", 617, "Failed to read account inode header %s", account);

    else
      traverse_btree(sheep_bnode_reader, &account_inode, bucket_iterater, (void *)&arg);

  out:
    ;
    sys->cdrv->unlock((unsigned long int)account_vid);
    return ret;
  }
}

// kv_iterate_object
// file http/kv.c line 1148
signed int kv_iterate_object(const char *account, const char *bucket, void (*cb)(const char *, void *), void *opaque)
{
  char vdi_name[256l];
  unsigned int bucket_vid;
  signed int ret;
  snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
  ret=sd_lookup_vdi(vdi_name, &bucket_vid);
  if(!(ret == 0x00))
    return ret;

  else
  {
    sys->cdrv->lock((unsigned long int)bucket_vid);
    ret=bucket_iterate_object(bucket_vid, cb, opaque);
    sys->cdrv->unlock((unsigned long int)bucket_vid);
    return ret;
  }
}

// kv_read_account_meta
// file http/kv.c line 180
signed int kv_read_account_meta(struct http_request *req, const char *account)
{
  unsigned long int bcount;
  unsigned long int ocount;
  unsigned long int used;
  signed int ret;
  ret=read_account_meta(account, &bcount, &ocount, &used);
  if(!(ret == 0x00))
    return ret;

  else
  {
    http_request_writef(req, "X-Account-Container-Count: %lu\n", bcount);
    http_request_writef(req, "X-Account-Object-Count: %lu\n", ocount);
    http_request_writef(req, "X-Account-Bytes-Used: %lu\n", used);
    return ret;
  }
}

// kv_read_bucket
// file http/kv.c line 542
signed int kv_read_bucket(struct http_request *req, const char *account, const char *bucket)
{
  unsigned int account_vid;
  struct kv_bnode bnode;
  signed int ret;
  ret=sd_lookup_vdi(account, &account_vid);
  if(!(ret == 0x00))
  {
    log_write(3, "kv_read_bucket", 551, "Failed to find account %s", account);
    return ret;
  }

  else
  {
    ret=bnode_lookup(&bnode, account_vid, bucket);
    if(ret == 0x00)
    {
      http_request_writef(req, "X-Container-Object-Count: %lu\n", bnode.object_count);
      http_request_writef(req, "X-Container-Bytes-Used: %lu\n", bnode.bytes_used);
    }


  out:
    ;
    return ret;
  }
}

// kv_read_object
// file http/kv.c line 1090
signed int kv_read_object(struct http_request *req, const char *account, const char *bucket, const char *name)
{
  struct kv_onode *onode = (struct kv_onode *)(void *)0;
  char vdi_name[256l];
  unsigned int bucket_vid;
  signed int ret;
  snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
  ret=sd_lookup_vdi(vdi_name, &bucket_vid);
  if(!(ret == 0x00))
    return ret;

  else
  {
    void *return_value_xzalloc$1;
    return_value_xzalloc$1=xzalloc(sizeof(struct kv_onode) /*4194304ul*/ );
    onode = (struct kv_onode *)return_value_xzalloc$1;
    ret=onode_lookup(onode, bucket_vid, name);
    if(ret == 0x00)
    {
      ret=onode_read_data(onode, req);
      if(!(ret == 0x00))
        log_write(3, "kv_read_object", 1110, "failed to read data for %s", name);

    }


  out:
    ;
    free((void *)onode);
    return ret;
  }
}

// kv_read_object_meta
// file http/kv.c line 1176
signed int kv_read_object_meta(struct http_request *req, const char *account, const char *bucket, const char *name)
{
  struct kv_onode *onode = (struct kv_onode *)(void *)0;
  char vdi_name[256l];
  unsigned int bucket_vid;
  signed int ret;
  snprintf(vdi_name, (unsigned long int)256U, "%s/%s", account, bucket);
  ret=sd_lookup_vdi(vdi_name, &bucket_vid);
  char *return_value_http_time$2;
  if(!(ret == 0x00))
    return ret;

  else
  {
    void *return_value_xzalloc$1;
    return_value_xzalloc$1=xzalloc(sizeof(struct kv_onode) /*4194304ul*/ );
    onode = (struct kv_onode *)return_value_xzalloc$1;
    ret=onode_lookup(onode, bucket_vid, name);
    if(ret == 0x00)
    {
      req->data_length = onode->$anon0.$anon0.size;
      return_value_http_time$2=http_time(onode->$anon0.$anon0.mtime);
      http_request_writef(req, "Last-Modified: %s\n", return_value_http_time$2);
    }


  out:
    ;
    free((void *)onode);
    return ret;
  }
}

// kv_update_account
// file http/kv.c line 196
signed int kv_update_account(const char *account)
{
  return -1;
}

// kv_update_bucket
// file http/kv.c line 567
signed int kv_update_bucket(const char *account, const char *bucket)
{
  return -1;
}

// leave_cluster
// file sheep_priv.h line 342
signed int leave_cluster(void)
{
  static _Bool left;
  if(!(left == (_Bool)0))
    return 0;

  else
  {
    left = (_Bool)1;
    signed int return_value;
    return_value=sys->cdrv->leave();
    return return_value;
  }
}

// list_add
// file ../include/list.h line 82
static inline void list_add(struct list_node *new, struct list_head *head)
{
  __list_add$link4(new, &head->n, head->n.next);
}

// list_add_tail
// file ../include/list.h line 87
static inline void list_add_tail(struct list_node *new, struct list_head *head)
{
  __list_add(new, head->n.prev, &head->n);
}

// list_add_tail$link1
// file ../include/list.h line 87
static inline void list_add_tail$link1(struct list_node *new$link1, struct list_head *head$link1)
{
  __list_add$link1(new$link1, head$link1->n.prev, &head$link1->n);
}

// list_add_tail$link2
// file ../include/list.h line 87
static inline void list_add_tail$link2(struct list_node *new$link2, struct list_head *head$link2)
{
  __list_add$link2(new$link2, head$link2->n.prev, &head$link2->n);
}

// list_add_tail$link3
// file ../include/list.h line 87
static inline void list_add_tail$link3(struct list_node *new$link3, struct list_head *head$link3)
{
  __list_add$link3(new$link3, head$link3->n.prev, &head$link3->n);
}

// list_add_tail$link4
// file ../include/list.h line 87
static inline void list_add_tail$link4(struct list_node *new$link4, struct list_head *head$link4)
{
  __list_add$link4(new$link4, head$link4->n.prev, &head$link4->n);
}

// list_del
// file ../include/list.h line 103
static inline void list_del(struct list_node *entry)
{
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_node *)(void *)0;
  entry->next = entry->prev;
}

// list_del$link1
// file ../include/list.h line 103
static inline void list_del$link1(struct list_node *entry$link1)
{
  __list_del$link1(entry$link1->prev, entry$link1->next);
  entry$link1->prev = (struct list_node *)(void *)0;
  entry$link1->next = entry$link1->prev;
}

// list_del$link2
// file ../include/list.h line 103
static inline void list_del$link2(struct list_node *entry$link2)
{
  __list_del$link2(entry$link2->prev, entry$link2->next);
  entry$link2->prev = (struct list_node *)(void *)0;
  entry$link2->next = entry$link2->prev;
}

// list_del$link3
// file ../include/list.h line 103
static inline void list_del$link3(struct list_node *entry$link3)
{
  __list_del$link4(entry$link3->prev, entry$link3->next);
  entry$link3->prev = (struct list_node *)(void *)0;
  entry$link3->next = entry$link3->prev;
}

// list_empty
// file ../include/list.h line 42
static inline _Bool list_empty(struct list_head *head)
{
  return head->n.next == &head->n;
}

// list_empty$link1
// file ../include/list.h line 42
static inline _Bool list_empty$link1(struct list_head *head$link1)
{
  return head$link1->n.next == &head$link1->n;
}

// list_empty$link2
// file ../include/list.h line 42
static inline _Bool list_empty$link2(struct list_head *head$link2)
{
  return head$link2->n.next == &head$link2->n;
}

// list_empty$link3
// file ../include/list.h line 42
static inline _Bool list_empty$link3(struct list_head *head$link3)
{
  return head$link3->n.next == &head$link3->n;
}

// list_empty$link4
// file ../include/list.h line 42
static inline _Bool list_empty$link4(struct list_head *head$link4)
{
  return head$link4->n.next == &head$link4->n;
}

// list_linked
// file ../include/list.h line 47
static inline _Bool list_linked(struct list_node *node)
{
  return node->next != (struct list_node *)(void *)0;
}

// list_move_tail
// file ../include/list.h line 115
static inline void list_move_tail(struct list_node *list, struct list_head *head)
{
  __list_del_entry(list);
  list_add_tail$link2(list, head);
}

// list_move_tail$link1
// file ../include/list.h line 115
static inline void list_move_tail$link1(struct list_node *list$link1, struct list_head *head$link1)
{
  __list_del_entry$link1(list$link1);
  list_add_tail$link3(list$link1, head$link1);
}

// list_sort
// file util.c line 700
void list_sort(void *priv, struct list_head *head, signed int (*cmp)(void *, struct list_node *, struct list_node *))
{
  struct list_node *part[21l];
  signed int lev;
  signed int max_lev = 0;
  struct list_node *list;
  _Bool return_value_list_empty$1;
  return_value_list_empty$1=list_empty$link3(head);
  if(return_value_list_empty$1 == (_Bool)0)
  {
    memset((void *)part, 0, sizeof(struct list_node *[21l]) /*168ul*/ );
    head->n.prev->next = (struct list_node *)(void *)0;
    list = head->n.next;
    while(!(list == ((struct list_node *)NULL)))
    {
      struct list_node *cur = list;
      list = list->next;
      cur->next = (struct list_node *)(void *)0;
      lev = 0;
      for( ; !(part[(signed long int)lev] == ((struct list_node *)NULL)); lev = lev + 1)
      {
        cur=merge(priv, cmp, part[(signed long int)lev], cur);
        part[(signed long int)lev] = (struct list_node *)(void *)0;
      }
      if(!(max_lev >= lev))
      {
        if((unsigned long int)lev >= 20ul)
          lev = lev - 1;

        max_lev = lev;
      }

      part[(signed long int)lev] = cur;
    }
    lev = 0;
    for( ; !(lev >= max_lev); lev = lev + 1)
      if(!(part[(signed long int)lev] == ((struct list_node *)NULL)))
        list=merge(priv, cmp, part[(signed long int)lev], list);

    merge_and_restore_back_links(priv, cmp, head, part[(signed long int)max_lev], list);
  }

}

// list_splice_init
// file ../include/list.h line 136
static inline void list_splice_init(struct list_head *list, struct list_head *head)
{
  _Bool return_value_list_empty$1;
  return_value_list_empty$1=list_empty(list);
  if(return_value_list_empty$1 == (_Bool)0)
  {
    __list_splice(list, &head->n, head->n.next);
    INIT_LIST_HEAD$link1(list);
  }

}

// list_splice_init$link1
// file ../include/list.h line 136
static inline void list_splice_init$link1(struct list_head *list$link1, struct list_head *head$link1)
{
  _Bool return_value_list_empty$1$link1;
  return_value_list_empty$1$link1=list_empty$link4(list$link1);
  if(return_value_list_empty$1$link1 == (_Bool)0)
  {
    __list_splice$link1(list$link1, &head$link1->n, head$link1->n.next);
    INIT_LIST_HEAD$link3(list$link1);
  }

}

// listen_handler
// file request.c line 987
static void listen_handler(signed int listen_fd, signed int events, void *data)
{
  struct sockaddr_storage from;
  unsigned int namesize;
  signed int fd;
  signed int ret;
  struct client_info *ci;
  _Bool is_inet_socket = *((_Bool *)data);
  if((signed int)sys->cinfo.status == SD_STATUS_SHUTDOWN)
  {
    if(sd_log_level == 7)
      log_write(7, "listen_handler", 996, "unregistering connection %d", listen_fd);

    unregister_event(listen_fd);
  }

  else
  {
    namesize = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    fd=accept(listen_fd, (struct sockaddr *)&from, &namesize);
    if(!(fd >= 0))
      log_write(3, "listen_handler", 1004, "failed to accept a new connection: %m");

    else
      if(!(is_inet_socket == (_Bool)0))
      {
        ret=set_nodelay(fd);
        if(ret == 0)
          goto __CPROVER_DUMP_L4;

        close(fd);
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        ci=create_client(fd, (struct cluster_info *)data);
        if(ci == ((struct client_info *)NULL))
          close(fd);

        else
        {
          ret=register_event$link1(fd, client_handler, (void *)ci);
          if(!(ret == 0))
            destroy_client(ci);

          else
            if(sd_log_level == 7)
              log_write(7, "listen_handler", 1028, "accepted a new connection: %d", fd);

        }
      }
  }
}

// load_cache
// file object_cache.c line 1261
static signed int load_cache(void)
{
  struct __dirstream *dir;
  struct dirent *d;
  unsigned long int vid;
  char path[4096l];
  signed int ret = 0;
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s", (const void *)object_cache_dir);
  dir=opendir(path);
  if(dir == ((struct __dirstream *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "load_cache", 1272, "%m");

    ret = -1;
  }

  else
  {
    do
    {
      d=readdir(dir);
      if(d == ((struct dirent *)NULL))
        break;

      signed int return_value_strncmp$1;
      return_value_strncmp$1=strncmp(d->d_name, ".", (unsigned long int)1);
      if(!(return_value_strncmp$1 == 0))
      {
        vid=strtoul(d->d_name, (char ** restrict )(void *)0, 16);
        if(!(vid == 1UL))
        {
          struct object_cache *return_value_find_object_cache$2;
          return_value_find_object_cache$2=find_object_cache((unsigned int)vid, (_Bool)1);
          load_cache_object(return_value_find_object_cache$2);
        }

      }

    }
    while((_Bool)1);
    closedir(dir);
  }

out:
  ;
  return ret;
}

// load_cache_object
// file object_cache.c line 1214
static signed int load_cache_object(struct object_cache *cache)
{
  struct __dirstream *dir;
  struct dirent *d;
  unsigned long int idx;
  char path[4096l];
  signed int ret = 0;
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x", (const void *)object_cache_dir, cache->vid);
  dir=opendir(path);
  unsigned long int return_value_idx_to_oid$5;
  if(dir == ((struct __dirstream *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "load_cache_object", 1226, "%m");

    ret = -1;
  }

  else
  {
    do
    {
      d=readdir(dir);
      if(d == ((struct dirent *)NULL))
        break;

      signed int return_value_strncmp$1;
      return_value_strncmp$1=strncmp(d->d_name, ".", (unsigned long int)1);
      if(!(return_value_strncmp$1 == 0))
      {
        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(d->d_name + (signed long int)8, ".tmp");
        if(return_value_strcmp$4 == 0)
        {
          if(sd_log_level == 7)
            log_write(7, "load_cache_object", 1236, "try to del %s", (const void *)d->d_name);

          signed int return_value_dirfd$2;
          return_value_dirfd$2=dirfd(dir);
          signed int return_value_unlinkat$3;
          return_value_unlinkat$3=unlinkat(return_value_dirfd$2, d->d_name, 0);
          if(!(return_value_unlinkat$3 >= 0))
            log_write(3, "load_cache_object", 1238, "%m");

          continue;
        }

        idx=strtoull(d->d_name, (char ** restrict )(void *)0, 16);
        if(!(idx == 1ULL))
        {
          add_to_lru_cache(cache, idx, (_Bool)1);
          if(sd_log_level == 7)
          {
            return_value_idx_to_oid$5=idx_to_oid(cache->vid, idx);
            log_write(7, "load_cache_object", 1253, "%lx", return_value_idx_to_oid$5);
          }

        }

      }

    }
    while((_Bool)1);
    closedir(dir);
  }

out:
  ;
  return ret;
}

// local_cache_purge
// file ops.c line 804
static signed int local_cache_purge(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  unsigned int vid;
  vid=oid_to_vid$link3(req->rq.$anon0.obj.oid);
  if((signed int)hdr->flags == 0x01)
    object_cache_delete(vid);

  else
    object_cache_format();

out:
  ;
  return 0x00;
}

// local_discard_obj
// file ops.c line 839
static signed int local_discard_obj(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  unsigned int vid;
  vid=oid_to_vid$link3(oid);
  unsigned int tmp_vid;
  signed int ret = 0x00;
  signed int idx;
  unsigned long int return_value_data_oid_to_idx$1;
  return_value_data_oid_to_idx$1=data_oid_to_idx(oid);
  idx = (signed int)return_value_data_oid_to_idx$1;
  struct sd_inode *inode;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$2;
  if(sd_log_level == 7)
    log_write(7, "local_discard_obj", 846, "%lx", oid);

  unsigned long int return_value_vid_to_vdi_oid$3;
  return_value_vid_to_vdi_oid$3=vid_to_vdi_oid$link1(vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$3, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(ret == 0x00)
  {
    tmp_vid=sd_inode_get_vid(sheep_bnode_reader, inode, (unsigned int)idx);
    if(!(tmp_vid == 0u))
    {
      sd_inode_set_vid(sheep_bnode_writer, sheep_bnode_reader, inode, (unsigned int)idx, (unsigned int)0);
      ret=sd_inode_write_vid(sheep_bnode_writer, inode, (unsigned int)idx, vid, (unsigned int)0, 0, (_Bool)0, (_Bool)0);
      if(ret == 0x00)
      {
        signed int return_value_sd_remove_object$4;
        return_value_sd_remove_object$4=sd_remove_object(oid);
        if(!(return_value_sd_remove_object$4 == 0x00))
          log_write(3, "local_discard_obj", 861, "failed to remove %lx", oid);

      }

    }

  }


out:
  ;
  free((void *)inode);
  return ret;
}

// local_flush_and_del
// file ops.c line 872
static signed int local_flush_and_del(struct request *req)
{
  if(sys->enable_object_cache == (_Bool)0)
    return 0x00;

  else
  {
    signed int return_value_object_cache_flush_and_del$1;
    return_value_object_cache_flush_and_del$1=object_cache_flush_and_del(req);
    return return_value_object_cache_flush_and_del$1;
  }
}

// local_flush_vdi
// file ops.c line 827
static signed int local_flush_vdi(struct request *req)
{
  signed int ret = 0x05;
  if(!(sys->enable_object_cache == (_Bool)0))
  {
    unsigned int vid;
    vid=oid_to_vid$link3(req->rq.$anon0.obj.oid);
    ret=object_cache_flush_vdi(vid);
  }

  return ret;
}

// local_get_cache_info
// file ops.c line 793
static signed int local_get_cache_info(struct request *request)
{
  struct sd_rsp *rsp = &request->rp;
  signed int return_value_object_cache_get_info$1;
  return_value_object_cache_get_info$1=object_cache_get_info((struct object_cache_info *)request->data);
  rsp->data_length = (unsigned int)return_value_object_cache_get_info$1;
  return 0x00;
}

// local_get_epoch
// file ops.c line 508
static signed int local_get_epoch(struct request *req)
{
  unsigned int epoch = req->rq.$anon0.obj.tgt_epoch;
  signed int local_get_epoch$$1$$nr_nodes;
  signed int nodes_len;
  signed long int timestamp;
  if(sd_log_level == 7)
    log_write(7, "local_get_epoch", 514, "%d", epoch);

  local_get_epoch$$1$$nr_nodes=epoch_log_read_with_timestamp(epoch, (struct sd_node *)req->data, (signed int)((unsigned long int)req->rq.data_length - sizeof(signed long int) /*8ul*/ ), &timestamp);
  if(local_get_epoch$$1$$nr_nodes == -1)
    return 0x0E;

  else
  {
    nodes_len = (signed int)((unsigned long int)local_get_epoch$$1$$nr_nodes * sizeof(struct sd_node) /*80ul*/ );
    memcpy((void *)((char *)req->data + (signed long int)nodes_len), (const void *)&timestamp, sizeof(signed long int) /*8ul*/ );
    req->rp.data_length = (unsigned int)((unsigned long int)nodes_len + sizeof(signed long int) /*8ul*/ );
    return 0x00;
  }
}

// local_get_hash
// file ops.c line 781
static signed int local_get_hash(struct request *request)
{
  struct sd_req *req = &request->rq;
  struct sd_rsp *rsp = &request->rp;
  if(sd_store->get_hash == ((signed int (*)(unsigned long int, unsigned int, unsigned char *))NULL))
    return 0x8B;

  else
  {
    signed int return_value;
    return_value=sd_store->get_hash(req->$anon0.obj.oid, req->$anon0.obj.tgt_epoch, rsp->$anon0.hash.digest);
    return return_value;
  }
}

// local_get_loglevel
// file ops.c line 991
static signed int local_get_loglevel(struct request *req)
{
  signed int current_level;
  current_level=get_loglevel();
  memcpy(req->data, (const void *)&current_level, sizeof(signed int) /*4ul*/ );
  req->rp.data_length = (unsigned int)sizeof(signed int) /*4ul*/ ;
  log_write(6, "local_get_loglevel", 999, "returning log level: %u", current_level);
  return 0x00;
}

// local_get_node_list
// file group.c line 175
signed int local_get_node_list(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int local_get_node_list$$1$$nr_nodes;
  struct vnode_info *cur_vinfo;
  cur_vinfo=get_vnode_info();
  if(!(cur_vinfo == ((struct vnode_info *)NULL)))
  {
    local_get_node_list$$1$$nr_nodes = cur_vinfo->nr_nodes;
    nodes_to_buffer(&cur_vinfo->nroot, data);
    rsp->data_length = (unsigned int)((unsigned long int)local_get_node_list$$1$$nr_nodes * sizeof(struct sd_node) /*80ul*/ );
    rsp->$anon0.node.nr_nodes = (unsigned int)local_get_node_list$$1$$nr_nodes;
    put_vnode_info(cur_vinfo);
  }

  else
    rsp->$anon0.node.nr_nodes = (unsigned int)0;
  return 0x00;
}

// local_get_obj_list
// file ops.c line 503
static signed int local_get_obj_list(struct request *req)
{
  signed int return_value_get_obj_list$1;
  return_value_get_obj_list$1=get_obj_list(&req->rq, &req->rp, req->data);
  return return_value_get_obj_list$1;
}

// local_get_store_list
// file ops.c line 392
static signed int local_get_store_list(struct request *req)
{
  struct strbuf buf = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  struct store_driver *driver;
  struct store_driver *__n397;
  struct store_driver *tmp_statement_expression$1;
  const struct list_node *__mptr = (&store_drivers)->n.next;
  tmp_statement_expression$1 = (struct store_driver *)((char *)__mptr - (signed long int)0ul);
  driver = tmp_statement_expression$1;
  struct store_driver *tmp_statement_expression$2;
  const struct list_node *local_get_store_list$$1$$1$$2$$__mptr = driver->list.next;
  tmp_statement_expression$2 = (struct store_driver *)((char *)local_get_store_list$$1$$1$$2$$__mptr - (signed long int)0ul);
  __n397 = tmp_statement_expression$2;
  struct store_driver *tmp_statement_expression$3;
  for( ; !(&driver->list == &(&store_drivers)->n); __n397 = tmp_statement_expression$3)
  {
    strbuf_addf(&buf, "%s ", driver->name);
    driver = __n397;
    const struct list_node *local_get_store_list$$1$$1$$3$$__mptr = __n397->list.next;
    tmp_statement_expression$3 = (struct store_driver *)((char *)local_get_store_list$$1$$1$$3$$__mptr - (signed long int)0ul);
  }
  signed int return_value_strbuf_copyout$4;
  return_value_strbuf_copyout$4=strbuf_copyout(&buf, req->data, (unsigned long int)req->data_length);
  req->rp.data_length = (unsigned int)return_value_strbuf_copyout$4;
  strbuf_release(&buf);
  return 0x00;
}

// local_get_vdi_copies
// file ops.c line 412
static signed int local_get_vdi_copies(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int return_value_fill_vdi_state_list$1;
  return_value_fill_vdi_state_list$1=fill_vdi_state_list(data);
  rsp->data_length = (unsigned int)return_value_fill_vdi_state_list$1;
  return 0x00;
}

// local_kill_node
// file ops.c line 914
static signed int local_kill_node(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  sys->cinfo.status = (enum sd_status)SD_STATUS_KILLED;
  unregister_listening_fds();
  return 0x00;
}

// local_md_info
// file ops.c line 755
static signed int local_md_info(struct request *request)
{
  struct sd_rsp *rsp = &request->rp;
  rsp->data_length=md_get_info((struct sd_md_info *)request->data);
  return rsp->data_length != 0u ? 0x00 : 0x01;
}

// local_md_plug
// file ops.c line 765
static signed int local_md_plug(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  char *disks = (char *)data;
  signed int return_value_md_plug_disks$1;
  return_value_md_plug_disks$1=md_plug_disks(disks);
  return return_value_md_plug_disks$1;
}

// local_md_unplug
// file ops.c line 773
static signed int local_md_unplug(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  char *disks = (char *)data;
  signed int return_value_md_unplug_disks$1;
  return_value_md_unplug_disks$1=md_unplug_disks(disks);
  return return_value_md_unplug_disks$1;
}

// local_node_copy_index
// file recovery.c line 447
static unsigned char local_node_copy_index(struct vnode_info *vinfo, unsigned long int oid)
{
  signed int idx;
  _Bool return_value_is_erasure_oid$1;
  return_value_is_erasure_oid$1=is_erasure_oid(oid);
  if(return_value_is_erasure_oid$1 == (_Bool)0)
    return (unsigned char)0;

  else
  {
    idx = 0;
    for( ; !(idx >= vinfo->nr_zones); idx = idx + 1)
    {
      struct sd_node *n;
      n=oid_to_node(oid, &vinfo->vroot, idx);
      _Bool return_value_node_is_local$2;
      return_value_node_is_local$2=node_is_local$link1(n);
      if(!(return_value_node_is_local$2 == (_Bool)0))
        return (unsigned char)idx;

    }
    log_write(0, "local_node_copy_index", 459, "PANIC: can't get valid index for %lx", oid);
    abort();
  }
}

// local_op_done
// file request.c line 135
static void local_op_done(struct work *work)
{
  struct request *req;
  struct request *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)192ul);
  req = tmp_statement_expression$1;
  _Bool return_value_has_process_main$3;
  return_value_has_process_main$3=has_process_main(req->op);
  if(!(return_value_has_process_main$3 == (_Bool)0))
  {
    signed int return_value_do_process_main$2;
    return_value_do_process_main$2=do_process_main(req->op, &req->rq, &req->rp, req->data);
    req->rp.$anon0.result = (unsigned int)return_value_do_process_main$2;
  }

  put_request(req);
}

// local_read_vdis
// file ops.c line 406
static signed int local_read_vdis(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int return_value_read_vdis$1;
  return_value_read_vdis$1=read_vdis((char *)data, (signed int)req->data_length, &rsp->data_length);
  return return_value_read_vdis$1;
}

// local_release_vdi
// file ops.c line 371
static signed int local_release_vdi(struct request *req)
{
  unsigned int vid = req->rq.$anon0.vdi.base_vdi_id;
  signed int ret;
  if(sys->enable_object_cache == (_Bool)0)
    return 0x00;

  else
    if(vid == 0u)
    {
      log_write(6, "local_release_vdi", 381, "Some VDI failed to release the object cache. Probably you are running old QEMU.");
      return 0x00;
    }

    else
    {
      ret=object_cache_flush_vdi(vid);
      if(ret == 0x00)
        object_cache_delete(vid);

      return ret;
    }
}

// local_req_async_main
// file request.c line 621
static void local_req_async_main(struct work *work)
{
  struct areq_work *areq;
  struct areq_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct areq_work *)((char *)__mptr - (signed long int)72ul);
  areq = tmp_statement_expression$1;
  if(!(areq->result == 0x00))
    areq->iocb->result = areq->result;

  eventfd_xwrite(areq->iocb->efd, 1);
  free((void *)areq);
}

// local_req_async_work
// file request.c line 614
static void local_req_async_work(struct work *work)
{
  struct areq_work *areq;
  struct areq_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct areq_work *)((char *)__mptr - (signed long int)72ul);
  areq = tmp_statement_expression$1;
  areq->result=exec_local_req(&areq->rq, areq->data);
}

// local_req_handler
// file request.c line 1079
static void local_req_handler(signed int listen_fd, signed int events, void *data)
{
  struct request *req;
  struct list_head pending_list = { .n={ .next=&pending_list.n, .prev=&pending_list.n } };
  if(!((8 & events) == 0))
    log_write(3, "local_req_handler", 1085, "request handler error");

  eventfd_xread(listen_fd);
  sd_mutex_lock$link1(&sys->local_req_lock);
  list_splice_init(&sys->local_req_queue, &pending_list);
  sd_mutex_unlock$link1(&sys->local_req_lock);
  struct request *__n1093;
  struct request *tmp_statement_expression$1;
  const struct list_node *__mptr = (&pending_list)->n.next;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)128ul);
  req = tmp_statement_expression$1;
  struct request *tmp_statement_expression$2;
  const struct list_node *local_req_handler$$1$$1$$2$$__mptr = req->request_list.next;
  tmp_statement_expression$2 = (struct request *)((char *)local_req_handler$$1$$1$$2$$__mptr - (signed long int)128ul);
  __n1093 = tmp_statement_expression$2;
  struct request *tmp_statement_expression$3;
  for( ; !(&req->request_list == &(&pending_list)->n); __n1093 = tmp_statement_expression$3)
  {
    list_del$link1(&req->request_list);
    queue_request(req);
    req = __n1093;
    const struct list_node *local_req_handler$$1$$1$$3$$__mptr = __n1093->request_list.next;
    tmp_statement_expression$3 = (struct request *)((char *)local_req_handler$$1$$1$$3$$__mptr - (signed long int)128ul);
  }
}

// local_req_init
// file request.c line 578
struct request_iocb * local_req_init(void)
{
  struct request_iocb *iocb;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct request_iocb) /*12ul*/ );
  iocb = (struct request_iocb *)return_value_xzalloc$1;
  iocb->efd=eventfd((unsigned int)0, 1);
  if(!(iocb->efd >= 0))
  {
    log_write(3, "local_req_init", 584, "eventfd failed, %m");
    free((void *)iocb);
    return (struct request_iocb *)(void *)0;
  }

  else
  {
    iocb->result = 0x00;
    return iocb;
  }
}

// local_req_wait
// file request.c line 592
signed int local_req_wait(struct request_iocb *iocb)
{
  signed int ret;
  unsigned int i = (unsigned int)0;
  for( ; !(i >= iocb->count); i = i + 1u)
    eventfd_xread(iocb->efd);
  ret = iocb->result;
  close(iocb->efd);
  free((void *)iocb);
  return ret;
}

// local_request_init
// file sheep_priv.h line 390
void local_request_init(void)
{
  sd_init_mutex(&sys->local_req_lock);
  sys->local_req_efd=eventfd((unsigned int)0, 2048);
  if(!(sys->local_req_efd >= 0))
  {
    log_write(0, "local_request_init", 1104, "PANIC: failed to init local req efd");
    abort();
  }

  register_event$link1(sys->local_req_efd, local_req_handler, (void *)0);
}

// local_sd_stat
// file ops.c line 818
static signed int local_sd_stat(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  memcpy(data, (const void *)&sys->stat, sizeof(struct sd_stat) /*120ul*/ );
  rsp->data_length = (unsigned int)sizeof(struct sd_stat) /*120ul*/ ;
  return 0x00;
}

// local_set_loglevel
// file ops.c line 1004
static signed int local_set_loglevel(struct request *req)
{
  signed int new_level = 0;
  memcpy((void *)&new_level, req->data, sizeof(signed int) /*4ul*/ );
  if(!(new_level >= 0) || new_level >= 8)
  {
    log_write(3, "local_set_loglevel", 1010, "invalid log level: %d", new_level);
    return 0x05;
  }

  else
  {
    set_loglevel(new_level);
    return 0x00;
  }
}

// local_stat_cluster
// file ops.c line 437
static signed int local_stat_cluster(struct request *req)
{
  struct sd_rsp *rsp = &req->rp;
  struct epoch_log *elog;
  signed int i;
  signed int max_elogs;
  unsigned int epoch;
  if(req->vinfo == ((struct vnode_info *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "local_stat_cluster", 445, "cluster is not started up");

  }

  else
  {
    max_elogs = (signed int)((unsigned long int)req->rq.data_length / sizeof(struct epoch_log) /*491568ul*/ );
    epoch=get_latest_epoch();
    i = 0;
    for( ; !(i >= max_elogs); i = i + 1)
    {
      signed int local_stat_cluster$$1$$2$$1$$nr_nodes;
      if(!(epoch >= 1u))
        break;

      elog = (struct epoch_log *)req->data + (signed long int)i;
      memset((void *)elog, 0, sizeof(struct epoch_log) /*491568ul*/ );
      if(i == 0)
      {
        elog->ctime = sys->cinfo.ctime;
        elog->disable_recovery = sys->cinfo.disable_recovery;
        elog->nr_copies = sys->cinfo.nr_copies;
        elog->copy_policy = sys->cinfo.copy_policy;
        strncpy(elog->drv_name, (char *)sys->cinfo.store, (unsigned long int)16);
      }

      elog->epoch = epoch;
      local_stat_cluster$$1$$2$$1$$nr_nodes=epoch_log_read_with_timestamp(epoch, elog->nodes, (signed int)sizeof(struct sd_node [6144l]) /*491520ul*/ , (signed long int *)&elog->time);
      if(local_stat_cluster$$1$$2$$1$$nr_nodes == -1)
        local_stat_cluster$$1$$2$$1$$nr_nodes=epoch_log_read_remote(epoch, elog->nodes, (signed int)sizeof(struct sd_node [6144l]) /*491520ul*/ , (signed long int *)&elog->time, req->vinfo);

      elog->nr_nodes = (unsigned int)local_stat_cluster$$1$$2$$1$$nr_nodes;
      rsp->data_length = rsp->data_length + (unsigned int)sizeof(struct epoch_log) /*491568ul*/ ;
      epoch = epoch - 1u;
    }
  }

out:
  ;
  switch((signed int)sys->cinfo.status)
  {
    case SD_STATUS_OK:
      return 0x00;
    case SD_STATUS_WAIT:
      if(sys->cinfo.ctime == 0ul)
        return 0x16;

      else
        return 0x17;
    case SD_STATUS_SHUTDOWN:
      return 0x11;
    default:
      return 0x06;
  }
}

// local_stat_recovery
// file ops.c line 428
static signed int local_stat_recovery(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  get_recovery_state((struct recovery_state *)data);
  rsp->data_length = (unsigned int)sizeof(struct recovery_state) /*24ul*/ ;
  return 0x00;
}

// local_stat_sheep
// file ops.c line 420
static signed int local_stat_sheep(struct request *req)
{
  struct sd_rsp *rsp = &req->rp;
  unsigned int epoch = req->rq.epoch;
  signed int return_value_stat_sheep$1;
  return_value_stat_sheep$1=stat_sheep(&rsp->$anon0.node.store_size, &rsp->$anon0.node.store_free, epoch);
  return return_value_stat_sheep$1;
}

// local_trace_disable
// file ops.c line 885
static signed int local_trace_disable(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int return_value_trace_disable$1;
  return_value_trace_disable$1=trace_disable((const char *)data);
  return return_value_trace_disable$1;
}

// local_trace_enable
// file ops.c line 879
static signed int local_trace_enable(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  signed int return_value_trace_enable$1;
  return_value_trace_enable$1=trace_enable((const char *)data);
  return return_value_trace_enable$1;
}

// local_trace_read_buf
// file ops.c line 899
static signed int local_trace_read_buf(struct request *request)
{
  struct sd_req *req = &request->rq;
  struct sd_rsp *rsp = &request->rp;
  signed int ret;
  ret=trace_buffer_pop(request->data, req->data_length);
  if(ret == -1)
    return 0x8F;

  else
  {
    rsp->data_length = (unsigned int)ret;
    if(sd_log_level == 7)
      log_write(7, "local_trace_read_buf", 910, "%u", rsp->data_length);

    return 0x00;
  }
}

// local_trace_status
// file ops.c line 891
static signed int local_trace_status(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  unsigned long int return_value_trace_status$1;
  return_value_trace_status$1=trace_status((char *)data);
  rsp->data_length = (unsigned int)return_value_trace_status$1;
  return 0x00;
}

// lock_and_daemon
// file sheep.c line 517
static signed int lock_and_daemon(_Bool daemonize, const char *base_dir)
{
  signed int ret;
  signed int devnull_fd = 0;
  signed int status = 0;
  signed int pipefd[2l];
  ret=pipe(pipefd);
  if(!(ret >= 0))
  {
    log_write(0, "lock_and_daemon", 524, "PANIC: pipe() for passing exit status failed: %m");
    abort();
  }

  if(!(daemonize == (_Bool)0))
  {
    signed int return_value_fork$1;
    return_value_fork$1=fork();
    if(!(return_value_fork$1 == 0))
    {
      if(return_value_fork$1 == -1)
        goto __CPROVER_DUMP_L3;

    }

    else
    {
      goto __CPROVER_DUMP_L6;

    __CPROVER_DUMP_L3:
      ;
      log_write(0, "lock_and_daemon", 531, "PANIC: fork() failed during daemonize: %m");
      abort();
      goto __CPROVER_DUMP_L6;
    }
    signed long int return_value_read$2;
    return_value_read$2=read(pipefd[(signed long int)0], (void *)&status, sizeof(signed int) /*4ul*/ );
    ret = (signed int)return_value_read$2;
    if(!((unsigned long int)ret == sizeof(signed int) /*4ul*/ ))
    {
      log_write(0, "lock_and_daemon", 536, "PANIC: read exit status failed: %m");
      abort();
    }

    exit(status);
    goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L6:
    ;
    signed int return_value_setsid$3;
    return_value_setsid$3=setsid();
    if(return_value_setsid$3 == -1)
    {
      log_write(3, "lock_and_daemon", 543, "becoming a leader of a new session failed: %m");
      status = 1;
      goto end;
    }

    signed int return_value_fork$4;
    return_value_fork$4=fork();
    if(!(return_value_fork$4 == 0))
    {
      if(return_value_fork$4 == -1)
        goto __CPROVER_DUMP_L9;

    }

    else
    {
      goto __CPROVER_DUMP_L11;

    __CPROVER_DUMP_L9:
      ;
      log_write(3, "lock_and_daemon", 552, "fork() failed during daemonize: %m");
      status = 1;
      goto end;
    }
    exit(0);

  __CPROVER_DUMP_L11:
    ;
    signed int return_value_chdir$5;
    return_value_chdir$5=chdir("/");
    if(!(return_value_chdir$5 == 0))
    {
      log_write(3, "lock_and_daemon", 561, "chdir to / failed: %m");
      status = 1;
      goto end;
    }

    devnull_fd=open("/dev/null", 02);
    if(!(devnull_fd >= 0))
    {
      log_write(3, "lock_and_daemon", 568, "opening /dev/null failed: %m");
      status = 1;
      goto end;
    }

  }

  ret=lock_base_dir(base_dir);
  if(!(ret >= 0))
  {
    log_write(3, "lock_and_daemon", 576, "locking directory: %s failed", base_dir);
    status = 1;
  }

  else
    if(!(daemonize == (_Bool)0))
    {
      dup2(devnull_fd, 0);
      dup2(devnull_fd, 1);
      dup2(devnull_fd, 2);
      close(devnull_fd);
    }


end:
  ;
  signed long int return_value_write$6;
  return_value_write$6=write(pipefd[(signed long int)1], (const void *)&status, sizeof(signed int) /*4ul*/ );
  ret = (signed int)return_value_write$6;
  if(!((unsigned long int)ret == sizeof(signed int) /*4ul*/ ))
  {
    log_write(0, "lock_and_daemon", 596, "PANIC: writing exit status failed: %m");
    abort();
  }

  return status;
}

// lock_base_dir
// file sheep_priv.h line 296
signed int lock_base_dir(const char *d)
{
  char *lock_path;
  signed int ret = 0;
  signed int fd;
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(d);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("/lock");
  len = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
  void *return_value_xzalloc$3;
  return_value_xzalloc$3=xzalloc((unsigned long int)len);
  lock_path = (char *)return_value_xzalloc$3;
  snprintf(lock_path, (unsigned long int)len, "%s/lock", d);
  fd=open(lock_path, 01 | 0100, sd_def_fmode);
  signed int return_value_lockf$7;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  if(!(fd >= 0))
  {
    log_write(3, "lock_base_dir", 150, "failed to open lock file %s (%m)", lock_path);
    ret = -1;
  }

  else
  {
    return_value_lockf$7=lockf(fd, 2, (signed long int)1);
    if(!(return_value_lockf$7 >= 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(*return_value___errno_location$4 == 13)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value___errno_location$5=__errno_location();
        tmp_if_expr$6 = *return_value___errno_location$5 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        log_write(3, "lock_base_dir", 157, "another sheep daemon is using %s", d);

      else
        log_write(3, "lock_base_dir", 159, "unable to get base dir lock (%m)");
      ret = -1;
      goto out;
    }

  }

out:
  ;
  free((void *)lock_path);
  return ret;
}

// log_close
// file ../include/logger.h line 43
void log_close(void)
{
  signed int pid;
  if(!(la == ((struct logarea *)NULL)))
    while((_Bool)1)
    {
      la->active = (_Bool)0;
      pid=waitpid(logger_pid, (signed int *)(void *)0, 1);
      if(pid == 0)
      {
        usleep((unsigned int)100000);
        continue;
      }

      else
        if(pid >= 1)
        {
          syslog(4, "logger pid %d stopped\n", logger_pid);
          closelog();
          free_logarea();
          break;
        }

        else
        {
          syslog(3, "waitpid() failure\n");
          exit(1);
        }
    }

}

// log_dir_parser
// file sheep.c line 336
static signed int log_dir_parser(const char *s)
{
  logdir=realpath(s, (char *)(void *)0);
  if(logdir == ((char *)NULL))
  {
    log_write(3, "log_dir_parser", 340, "%m");
    exit(1);
  }

  return 0;
}

// log_dst_parser
// file sheep.c line 356
static signed int log_dst_parser(const char *s)
{
  log_dst = s;
  return 0;
}

// log_flush
// file logger.c line 494
static void log_flush(void)
{
  struct sembuf ops;
  unsigned long int size;
  unsigned long int done = (unsigned long int)0;
  struct logmsg *msg;
  if(!(la->tail == la->start))
  {
    ops.sem_num = (unsigned short int)0;
    ops.sem_flg = (signed short int)0x1000;
    ops.sem_op = (signed short int)-1;
    signed int return_value_semop$1;
    return_value_semop$1=semop(la->semid, &ops, (unsigned long int)1);
    if(!(return_value_semop$1 >= 0))
    {
      syslog(3, "semop up failed: %m");
      exit(1);
    }

    size = (unsigned long int)(la->tail - la->start);
    memcpy((void *)log_buff, (const void *)la->start, size);
    memset((void *)la->start, 0, size);
    la->tail = la->start;
    ops.sem_op = (signed short int)1;
    signed int return_value_semop$2;
    return_value_semop$2=semop(la->semid, &ops, (unsigned long int)1);
    if(!(return_value_semop$2 >= 0))
    {
      syslog(3, "semop down failed: %m");
      exit(1);
    }

    for( ; !(done >= size); done = done + sizeof(struct logmsg) /*88ul*/  + msg->str_len + (unsigned long int)1)
    {
      msg = (struct logmsg *)(log_buff + (signed long int)done);
      log_syslog(msg);
    }
  }

}

// log_format_parser
// file sheep.c line 348
static signed int log_format_parser(const char *s)
{
  log_format = s;
  return 0;
}

// log_init
// file ../include/logger.h line 41
signed int log_init(const char *program_name, enum log_dst_type type, signed int level, char *outfile)
{
  char log_dir[4096l];
  char tmp[4096l];
  signed int size = level == 7 ? 32 * 1024 * 1024 : 1 * 1024 * 1024;
  dst_type = type;
  sd_log_level = level;
  log_name = program_name;
  log_nowname = outfile;
  pstrcpy(tmp, (signed int)sizeof(char [4096l]) /*4096ul*/ , outfile);
  char *return_value_dirname$1;
  return_value_dirname$1=dirname(tmp);
  pstrcpy(log_dir, (signed int)sizeof(char [4096l]) /*4096ul*/ , return_value_dirname$1);
  signed long int return_value_random$2;
  return_value_random$2=random();
  semkey = (signed int)return_value_random$2;
  _Bool return_value_is_stdout_console$3;
  signed int return_value_logarea_init$4;
  switch((signed int)type)
  {
    case LOG_DST_STDOUT:
    {
      return_value_is_stdout_console$3=is_stdout_console();
      if(!(return_value_is_stdout_console$3 == (_Bool)0))
        colorize = (_Bool)1;

      break;
    }
    case LOG_DST_SYSLOG:
      openlog(program_name, 0x01, 3 << 3);
    case LOG_DST_DEFAULT:
    {
      return_value_logarea_init$4=logarea_init(size);
      if(!(return_value_logarea_init$4 == 0))
      {
        syslog(3, "failed to initialize the logger\n");
        return 1;
      }

      sheep_pid=getpid();
      logger_pid=fork();
      if(!(logger_pid >= 0))
      {
        syslog(3, "failed to fork the logger process: %m\n");
        return 1;
      }

      if(!(logger_pid == 0))
        syslog(4, "logger pid %d starting\n", logger_pid);

      else
        logger(log_dir, outfile);
      break;
    }
    default:
    {
      log_write(3, "log_init", 705, "unknown type of log destination type: %d", type);
      return -1;
    }
  }
  return 0;
}

// log_level_parser
// file sheep.c line 320
static signed int log_level_parser(const char *s)
{
  signed int level;
  level=loglevel_str2num(s);
  if(!(level >= 0))
  {
    log_write(3, "log_level_parser", 325, "Invalid log level '%s'", s);
    sdlog_help();
    return -1;
  }

  else
  {
    log_level = level;
    return 0;
  }
}

// log_syslog
// file logger.c line 360
static void log_syslog(struct logmsg *msg)
{
  char str[1024l];
  signed int len;
  len=format->formatter(str, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, msg, log_fd >= 0);
  signed int tmp_post$1;
  signed int tmp_post$2;
  if((signed int)dst_type == LOG_DST_DEFAULT)
  {
    tmp_post$1 = len;
    len = len + 1;
    str[(signed long int)tmp_post$1] = (char)10;
  }

  else
  {
    tmp_post$2 = len;
    len = len + 1;
    str[(signed long int)tmp_post$2] = (char)0;
  }
  block_sighup();
  if(log_fd >= 0)
    xwrite(log_fd, (const void *)str, (unsigned long int)len);

  else
    syslog(msg->prio, "%s", (const void *)str);
  unblock_sighup();
}

// log_write
// file ../include/logger.h line 45
void log_write(signed int prio, const char *func, signed int line, const char *fmt, ...)
{
  void **ap;
  if(sd_log_level >= prio)
  {
    ap = (void **)&fmt;
    dolog(prio, func, line, fmt, ap);
    ap = ((void **)NULL);
  }

}

// logarea_init
// file logger.c line 289
static signed int logarea_init(signed int size)
{
  signed int shmid;
  shmid=shmget((signed int)0, sizeof(struct logarea) /*56ul*/ , 0644 | 01000 | 02000);
  if(shmid == -1)
  {
    syslog(3, "shmget logarea failed: %m");
    return 1;
  }

  else
  {
    void *return_value_shmat$1;
    return_value_shmat$1=shmat(shmid, (void *)0, 0);
    la = (struct logarea *)return_value_shmat$1;
    if(la == ((struct logarea *)NULL))
    {
      syslog(3, "shmat logarea failed: %m");
      return 1;
    }

    else
    {
      shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
      if(!(size >= 1024))
        size = 1 * 1024 * 1024;

      shmid=shmget((signed int)0, (unsigned long int)size, 0644 | 01000 | 02000);
      if(shmid == -1)
      {
        syslog(3, "shmget msg failed: %m");
        shmdt((const void *)la);
        return 1;
      }

      else
      {
        void *return_value_shmat$2;
        return_value_shmat$2=shmat(shmid, (void *)0, 0);
        la->start = (char *)return_value_shmat$2;
        if(la->start == ((char *)NULL))
        {
          syslog(3, "shmat msg failed: %m");
          shmdt((const void *)la);
          return 1;
        }

        else
        {
          memset((void *)la->start, 0, (unsigned long int)size);
          shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
          la->end = la->start + (signed long int)size;
          la->tail = la->start;
          la->semid=semget(semkey, 1, 0666 | 01000);
          if(!(la->semid >= 0))
          {
            syslog(3, "semget failed: %m");
            shmdt((const void *)la->start);
            shmdt((const void *)la);
            return 1;
          }

          else
          {
            la->semarg.val = 1;
            signed int return_value_semctl$3;
            return_value_semctl$3=semctl(la->semid, 0, 16, la->semarg);
            if(!(return_value_semctl$3 >= 0))
            {
              syslog(3, "semctl failed: %m");
              shmdt((const void *)la->start);
              shmdt((const void *)la);
              return 1;
            }

            else
              return 0;
          }
        }
      }
    }
  }
}

// logger
// file logger.c line 560
static void logger(char *log_dir, char *outfile)
{
  signed int fd;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc((unsigned long int)(la->end - la->start));
  log_buff = (char *)return_value_xzalloc$1;
  if((signed int)dst_type == LOG_DST_DEFAULT)
  {
    log_fd=open(outfile, 0100 | 02 | 02000, 0644);
    if(!(log_fd >= 0))
    {
      syslog(3, "failed to open %s\n", outfile);
      exit(1);
    }

  }

  la->active = (_Bool)1;
  fd=open("/dev/null", 02);
  if(!(fd >= 0))
  {
    syslog(3, "failed to open /dev/null: %m\n");
    exit(1);
  }

  dup2(fd, 0);
  dup2(fd, 1);
  dup2(fd, 2);
  setsid();
  signed int return_value_chdir$2;
  return_value_chdir$2=chdir(log_dir);
  if(!(return_value_chdir$2 >= 0))
  {
    syslog(3, "failed to chdir to %s: %m\n", log_dir);
    exit(1);
  }

  install_crash_handler(crash_handler$link1);
  install_sighandler(1, sighup_handler$link1, (_Bool)0);
  signed int return_value_kill$3;
  return_value_kill$3=kill(sheep_pid, 0);
  if(!(return_value_kill$3 >= 0))
    kill(logger_pid, 1);

  while(!(la->active == (_Bool)0))
  {
    log_flush();
    block_sighup();
    if((signed int)dst_type == LOG_DST_DEFAULT && !(max_logsize == 0l))
    {
      signed long int offset;
      offset=lseek(log_fd, (signed long int)0, 2);
      if(!(offset >= 0l))
        syslog(3, "sheep log error\n");

      else
      {
        unsigned long int log_size = (unsigned long int)offset;
        if(log_size >= (unsigned long int)max_logsize)
          rotate_log();

      }
    }

    unblock_sighup();
    signed int return_value_getppid$4;
    return_value_getppid$4=getppid();
    if(return_value_getppid$4 == 1)
      break;

    sleep((unsigned int)1);
  }
  log_flush();
  free((void *)log_buff);
  free_logarea();
  exit(0);
}

// loglevel_str2num
// file ../include/logger.h line 98
static inline signed int loglevel_str2num(const char *str)
{
  signed int i;
  signed int max = (signed int)(sizeof(const char * const [8l]) /*64ul*/  / sizeof(const char *) /*8ul*/ );
  i = 0;
  for( ; !(i >= max); i = i + 1)
  {
    signed int return_value_strcmp$1;
    static const char * const loglevel_table[8l] = { "emerg", "alert", "crit", "err", "warning", "notice", "info", "debug" };
    return_value_strcmp$1=strcmp(loglevel_table[(signed long int)i], str);
    if(return_value_strcmp$1 == 0)
      break;

  }
  return i == max ? -1 : i;
}

// lookup_event
// file event.c line 92
static struct event_info * lookup_event(signed int fd)
{
  struct event_info key = { .handler=((void (*)(signed int, signed int, void *))NULL), .fd=fd,
    .data=NULL, .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .prio=0 };
  struct event_info *tmp_statement_expression$1;
  struct rb_node *__n = (&events_tree)->rb_node;
  struct event_info *__ret = (struct event_info *)(void *)0;
  struct event_info *__data;
  struct event_info *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct event_info *)((char *)__mptr - (signed long int)24ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=event_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  return tmp_statement_expression$1;
}

// lookup_path
// file object_cache.c line 706
static inline signed int lookup_path(char *path)
{
  signed int ret = 0x00;
  signed int return_value_access$2;
  return_value_access$2=access(path, 4 | 2);
  if(!(return_value_access$2 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
    {
      if(sd_log_level == 7)
        log_write(7, "lookup_path", 712, "%m");

      ret = 0x03;
    }

    else
      ret = 0x87;
  }

  return ret;
}

// lru_tree_insert
// file object_cache.c line 209
static struct object_cache_entry * lru_tree_insert(struct rb_root *root, struct object_cache_entry *new)
{
  struct object_cache_entry *tmp_statement_expression$1;
  struct rb_node **__n = &root->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct object_cache_entry *__old = (struct object_cache_entry *)(void *)0;
  struct object_cache_entry *__data;
  struct object_cache_entry *tmp_statement_expression$2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression$2 = (struct object_cache_entry *)((char *)__mptr - (signed long int)32ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=object_cache_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct object_cache_entry *)NULL))
  {
    rb_link_node$link3(&new->node, __parent, __n);
    rb_insert_color(&new->node, root);
  }

  tmp_statement_expression$1 = __old;
  return tmp_statement_expression$1;
}

// lru_tree_search
// file object_cache.c line 214
static struct object_cache_entry * lru_tree_search(struct rb_root *root, unsigned long int idx)
{
  struct object_cache_entry key = { .idx=idx, .refcnt={ .val=0 }, .bmap=0ul, .oc=((struct object_cache *)NULL),
    .node={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .dirty_list={ .next=((struct list_node *)NULL), .prev=((struct list_node *)NULL) },
    .lru_list={ .next=((struct list_node *)NULL), .prev=((struct list_node *)NULL) },
    .lock={ .rwlock={ .__data={ .__lock=0, .__nr_readers=0u, .__readers_wakeup=0u, .__writer_wakeup=0u,
    .__nr_readers_queued=0u, .__nr_writers_queued=0u,
    .__writer=0, .__shared=0,
    .__rwelision=0, .__pad1={ 0, 0, 0, 0, 0, 0, 0 }, .__pad2=0ul,
    .__flags=0u } } } };
  struct object_cache_entry *tmp_statement_expression$1;
  struct rb_node *__n = root->rb_node;
  struct object_cache_entry *__ret = (struct object_cache_entry *)(void *)0;
  struct object_cache_entry *__data;
  struct object_cache_entry *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct object_cache_entry *)((char *)__mptr - (signed long int)32ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=object_cache_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  return tmp_statement_expression$1;
}

// main
// file sheep.c line 610
signed int main(signed int argc, char **argv)
{
  signed int ch;
  signed int longindex;
  signed int ret;
  signed int port = 7000;
  signed int io_port = 7000;
  signed int nr_vnodes = 128;
  const char *dirp = "/tmp";
  const char *short_options;
  char *dir;
  char *p;
  char *pid_file = (char *)(void *)0;
  char *bindaddr = (char *)(void *)0;
  char log_path[4096l];
  char *argp = (char *)(void *)0;
  _Bool explicit_addr = (_Bool)0;
  signed long int zone = (signed long int)-1;
  struct cluster_driver *cdrv;
  struct option *long_options;
  const char *http_options = (const char *)(void *)0;
  struct stat logdir_st;
  enum log_dst_type log_dst_type;
  install_crash_handler(crash_handler);
  signal(13, (void (*)(signed int))1);
  install_sighandler(1, sighup_handler, (_Bool)0);
  long_options=build_long_options(sheep_options);
  short_options=build_short_options(sheep_options);
  signed long int return_value_strtol$1;
  _Bool tmp_if_expr$2;
  signed int return_value_option_parse$3;
  unsigned char *return_value_str_to_addr$4;
  _Bool tmp_if_expr$5;
  struct cluster_driver *tmp_statement_expression$6;
  struct cluster_driver *tmp_statement_expression$7;
  struct cluster_driver *tmp_statement_expression$8;
  signed int return_value_option_parse$9;
  signed int return_value_option_parse$10;
  unsigned char *return_value_str_to_addr$11;
  signed int return_value_sscanf$12;
  signed int return_value_option_parse$13;
  _Bool return_value_inetaddr_is_valid$14;
  do
  {
    ch=getopt_long(argc, argv, short_options, long_options, &longindex);
    if(!(ch >= 0))
      break;

    switch(ch)
    {
      case 112:
      {
        return_value_strtol$1=strtol(optarg, &p, 10);
        port = (signed int)return_value_strtol$1;
        if(optarg == p || port >= 65536 || !(port >= 1))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*p != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          log_write(3, "main", 640, "Invalid port number '%s'", optarg);
          exit(1);
        }

        break;
      }
      case 80:
      {
        pid_file = optarg;
        break;
      }
      case 114:
      {
        http_options = optarg;
        break;
      }
      case 108:
      {
        return_value_option_parse$3=option_parse(optarg, ",", log_parsers);
        if(!(return_value_option_parse$3 >= 0))
          exit(1);

        break;
      }
      case 110:
      {
        sys->nosync = (_Bool)1;
        break;
      }
      case 121:
      {
        return_value_str_to_addr$4=str_to_addr(optarg, sys->this_node.nid.addr);
        if(return_value_str_to_addr$4 == ((unsigned char *)NULL))
        {
          log_write(3, "main", 659, "Invalid address: '%s'", optarg);
          exit(1);
        }

        explicit_addr = (_Bool)1;
        break;
      }
      case 68:
      {
        sys->backend_dio = (_Bool)1;
        break;
      }
      case 103:
      {
        nr_vnodes = 0;
        break;
      }
      case 122:
      {
        zone=strtol(optarg, &p, 10);
        if(optarg == p || zone >= 4294967296l || !(zone >= 0l))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = (signed int)*p != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
        {
          log_write(3, "main", 677, "Invalid zone id '%s': must be an integer between 0 and %u", optarg, 4294967295U);
          exit(1);
        }

        sys->this_node.zone = (unsigned int)zone;
        break;
      }
      case 117:
      {
        sys->upgrade = (_Bool)1;
        break;
      }
      case 99:
      {
        sys->cdrv=find_cdrv(optarg);
        if(sys->cdrv == ((struct cluster_driver *)NULL))
        {
          log_write(3, "main", 688, "Invalid cluster driver '%s'", optarg);
          fprintf(stderr, "Supported drivers:");
          struct cluster_driver *__n690;
          const struct list_node *__mptr = (&cluster_drivers)->n.next;
          tmp_statement_expression$6 = (struct cluster_driver *)((char *)__mptr - (signed long int)88ul);
          cdrv = tmp_statement_expression$6;
          const struct list_node *main$$1$$1$$1$$4$$1$$2$$__mptr = cdrv->list.next;
          tmp_statement_expression$7 = (struct cluster_driver *)((char *)main$$1$$1$$1$$4$$1$$2$$__mptr - (signed long int)88ul);
          __n690 = tmp_statement_expression$7;
          for( ; !(&cdrv->list == &(&cluster_drivers)->n); __n690 = tmp_statement_expression$8)
          {
            fprintf(stderr, " %s", cdrv->name);
            cdrv = __n690;
            const struct list_node *main$$1$$1$$1$$4$$1$$3$$__mptr = __n690->list.next;
            tmp_statement_expression$8 = (struct cluster_driver *)((char *)main$$1$$1$$1$$4$$1$$3$$__mptr - (signed long int)88ul);
          }
          fprintf(stderr, "\n");
          exit(1);
        }

        sys->cdrv_option=get_cdrv_option(sys->cdrv, optarg);
        break;
      }
      case 119:
      {
        sys->enable_object_cache = (_Bool)1;
        sys->object_cache_size = (unsigned int)0;
        return_value_option_parse$9=option_parse(optarg, ",", cache_parsers);
        if(!(return_value_option_parse$9 >= 0))
          exit(1);

        if(sys->object_cache_size == 0u)
        {
          log_write(3, "main", 707, "object cache size is not set");
          exit(1);
        }

        break;
      }
      case 105:
      {
        return_value_option_parse$10=option_parse(optarg, ",", ionic_parsers);
        if(!(return_value_option_parse$10 >= 0))
          exit(1);

        return_value_str_to_addr$11=str_to_addr(io_addr, sys->this_node.nid.io_addr);
        if(return_value_str_to_addr$11 == ((unsigned char *)NULL))
        {
          log_write(3, "main", 716, "Bad addr: '%s'", io_addr);
          exit(1);
        }

        if(!(io_pt == ((const char *)NULL)))
        {
          return_value_sscanf$12=sscanf(io_pt, "%u", &io_port);
          if(!(return_value_sscanf$12 == 1))
          {
            log_write(3, "main", 722, "Bad port '%s'", io_pt);
            exit(1);
          }

        }

        sys->this_node.nid.io_port = (unsigned short int)io_port;
        break;
      }
      case 106:
      {
        uatomic_set_true(&sys->use_journal);
        return_value_option_parse$13=option_parse(optarg, ",", journal_parsers);
        if(!(return_value_option_parse$13 >= 0))
          exit(1);

        if(jsize == 0ul)
        {
          log_write(3, "main", 732, "you must specify size for journal");
          exit(1);
        }

        break;
      }
      case 98:
      {
        return_value_inetaddr_is_valid$14=inetaddr_is_valid(optarg);
        if(return_value_inetaddr_is_valid$14 == (_Bool)0)
          exit(1);

        bindaddr = optarg;
        break;
      }
      case 104:
      {
        usage(0);
        break;
      }
      case 118:
      {
        fprintf(stdout, "Sheepdog daemon version %s\n", (const void *)"0.8.3");
        exit(0);
        break;
      }
      default:
        usage(1);
    }
  }
  while((_Bool)1);
  static struct logger_user_info sheep_info;
  sheep_info.port = port;
  early_log_init(log_format, &sheep_info);
  if(nr_vnodes == 0)
  {
    sys->gateway_only = (_Bool)1;
    sys->disk_space = (unsigned long int)0;
  }

  if(!(optind == argc))
  {
    argp=strdup(argv[(signed long int)optind]);
    dirp=strtok(argv[(signed long int)optind], ",");
  }

  ret=init_base_path(dirp);
  if(!(ret == 0))
    exit(1);

  dir=realpath(dirp, (char *)(void *)0);
  if(dir == ((char *)NULL))
  {
    log_write(3, "main", 774, "%m");
    exit(1);
  }

  signed int return_value_strcmp$17;
  return_value_strcmp$17=strcmp(log_dst, "default");
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  if(return_value_strcmp$17 == 0)
    log_dst_type = (enum log_dst_type)LOG_DST_DEFAULT;

  else
  {
    return_value_strcmp$16=strcmp(log_dst, "stdout");
    if(return_value_strcmp$16 == 0)
      log_dst_type = (enum log_dst_type)LOG_DST_STDOUT;

    else
    {
      return_value_strcmp$15=strcmp(log_dst, "syslog");
      if(return_value_strcmp$15 == 0)
        log_dst_type = (enum log_dst_type)LOG_DST_SYSLOG;

      else
      {
        log_write(3, "main", 785, "invalid type of log destination: %s", log_dst);
        exit(1);
      }
    }
  }
  if(!(logdir == ((char *)NULL)))
  {
    if(!((signed int)log_dst_type == LOG_DST_DEFAULT))
    {
      log_write(3, "main", 794, "logdir (%s) is specified but logging destination is %s", logdir, (signed int)log_dst_type == LOG_DST_STDOUT ? "stdout" : "syslog");
      exit(1);
    }

    memset((void *)&logdir_st, 0, sizeof(struct stat) /*144ul*/ );
    ret=stat(logdir, &logdir_st);
    if(!(ret >= 0))
    {
      log_write(3, "main", 801, "stat() failed on %s, %m", logdir);
      exit(1);
    }

    if(!((61440u & logdir_st.st_mode) == 16384u))
    {
      log_write(3, "main", 806, "log dir: %s is not a directory", logdir);
      exit(1);
    }

  }

  snprintf(log_path, sizeof(char [4096l]) /*4096ul*/ , "%s/sheep.log", (_Bool)logdir ? logdir : dir);
  free((void *)logdir);
  srandom((unsigned int)port);
  signed int return_value_lock_and_daemon$18;
  return_value_lock_and_daemon$18=lock_and_daemon((signed int)log_dst_type != LOG_DST_STDOUT, dir);
  if(!(return_value_lock_and_daemon$18 == 0))
    exit(1);

  ret=log_init(program_name, log_dst_type, log_level, log_path);
  if(!(ret == 0))
    exit(1);

  ret=init_event(4096);
  if(!(ret == 0))
    exit(1);

  ret=init_global_pathnames(dir, argp);
  free((void *)argp);
  if(!(ret == 0))
    exit(1);

  ret=init_config_file();
  if(!(ret == 0))
    exit(1);

  ret=create_listen_port(bindaddr, port);
  if(!(ret == 0))
    exit(1);

  signed int return_value_create_listen_port$19;
  if(!(io_addr == ((const char *)NULL)))
  {
    return_value_create_listen_port$19=create_listen_port(io_addr, io_port);
    if(!(return_value_create_listen_port$19 == 0))
      exit(1);

  }

  ret=init_unix_domain_socket(dir);
  if(!(ret == 0))
    exit(1);

  local_request_init();
  ret=init_signal();
  if(!(ret == 0))
    exit(1);

  ret=init_disk_space(dir);
  if(!(ret == 0))
    exit(1);

  ret=create_cluster(port, zone, nr_vnodes, explicit_addr);
  if(!(ret == 0))
  {
    log_write(3, "main", 862, "failed to create sheepdog cluster");
    exit(1);
  }

  _Bool return_value_uatomic_is_true$22;
  return_value_uatomic_is_true$22=uatomic_is_true(&sys->use_journal);
  unsigned long int return_value_strlen$20;
  if(!(return_value_uatomic_is_true$22 == (_Bool)0))
  {
    unsigned long int return_value_strlen$21;
    return_value_strlen$21=strlen(jpath);
    if(return_value_strlen$21 == 0ul)
    {
      return_value_strlen$20=strlen(dir);
      memcpy((void *)jpath, (const void *)dir, return_value_strlen$20);
    }

    if(sd_log_level == 7)
      log_write(7, "main", 871, "%s, %lu, %d", (const void *)jpath, jsize, jskip);

    ret=journal_file_init(jpath, jsize, jskip);
    if(!(ret == 0))
      exit(1);

  }

  init_fec();
  ret=create_work_queues();
  if(!(ret == 0))
    exit(1);

  ret=sockfd_init();
  if(!(ret == 0))
    exit(1);

  ret=init_store_driver(sys->gateway_only);
  if(!(ret == 0))
    exit(1);

  unsigned long int return_value_strlen$23;
  if(!(sys->enable_object_cache == (_Bool)0))
  {
    unsigned long int return_value_strlen$24;
    return_value_strlen$24=strlen(ocpath);
    if(return_value_strlen$24 == 0ul)
    {
      return_value_strlen$23=strlen(dir);
      memcpy((void *)ocpath, (const void *)dir, return_value_strlen$23);
    }

    ret=object_cache_init(ocpath);
    if(!(ret == 0))
      exit(1);

  }

  ret=trace_init();
  if(!(ret == 0))
    exit(1);

  signed int return_value_http_init$25;
  if(!(http_options == ((const char *)NULL)))
  {
    return_value_http_init$25=http_init(http_options);
    if(!(return_value_http_init$25 == 0))
      exit(1);

  }

  signed int return_value_create_pidfile$26;
  if(!(pid_file == ((char *)NULL)))
  {
    return_value_create_pidfile$26=create_pidfile(pid_file);
    if(!(return_value_create_pidfile$26 == 0))
    {
      log_write(3, "main", 915, "failed to pid file '%s' - %m", pid_file);
      exit(1);
    }

  }

  signed int return_value_chdir$27;
  return_value_chdir$27=chdir(dir);
  if(!(return_value_chdir$27 >= 0))
  {
    log_write(3, "main", 920, "failed to chdir to %s: %m", dir);
    exit(1);
  }

  free((void *)dir);
  check_host_env();
  log_write(6, "main", 926, "sheepdog daemon (version %s) started", (const void *)"0.8.3");
  while((_Bool)1)
  {
    if(sys->nr_outstanding_reqs == 0)
    {
      if(!((signed int)sys->cinfo.status == SD_STATUS_KILLED))
      {
        if((signed int)sys->cinfo.status == SD_STATUS_SHUTDOWN)
          goto __CPROVER_DUMP_L78;

      }

      else
      {

      __CPROVER_DUMP_L78:
        ;
        goto __CPROVER_DUMP_L80;
      }
    }

    event_loop(-1);
  }

__CPROVER_DUMP_L80:
  ;
  log_write(6, "main", 933, "shutdown");
  leave_cluster();
  _Bool return_value_uatomic_is_true$28;
  return_value_uatomic_is_true$28=uatomic_is_true(&sys->use_journal);
  if(!(return_value_uatomic_is_true$28 == (_Bool)0))
  {
    log_write(6, "main", 938, "cleaning journal file");
    clean_journal_file(jpath);
  }

  log_close();
  if(!(pid_file == ((char *)NULL)))
    unlink(pid_file);

  return 0;
}

// make_path
// file util.c line 554
void make_path(char *path, unsigned long int size, unsigned long int nr_segs, const char **segs)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_segs); i = i + 1)
  {
    signed int len;
    len=snprintf(path, size, "/%s", segs[(signed long int)i]);
    path = path + (signed long int)len;
    size = size - (unsigned long int)len;
  }
}

// make_stale_dir
// file plain_store.c line 168
static signed int make_stale_dir(const char *path)
{
  char p[4096l];
  snprintf(p, (unsigned long int)4096, "%s/.stale", path);
  signed int return_value_xmkdir$1;
  return_value_xmkdir$1=xmkdir(p, sd_def_dmode);
  if(!(return_value_xmkdir$1 >= 0))
  {
    log_write(3, "make_stale_dir", 174, "%s failed, %m", (const void *)p);
    return 0x03;
  }

  else
    return 0x00;
}

// md_access
// file md.c line 556
static inline _Bool md_access(const char *path)
{
  signed int return_value_access$2;
  return_value_access$2=access(path, 4 | 2);
  if(!(return_value_access$2 >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
      log_write(3, "md_access", 560, "failed to check %s, %m", path);

    return (_Bool)0;
  }

  return (_Bool)1;
}

// md_add_disk
// file sheep_priv.h line 481
_Bool md_add_disk(const char *path, _Bool purge)
{
  struct disk *new;
  struct disk *return_value_path_to_disk$1;
  return_value_path_to_disk$1=path_to_disk(path);
  struct disk *tmp_statement_expression$4;
  if(!(return_value_path_to_disk$1 == ((struct disk *)NULL)))
  {
    log_write(3, "md_add_disk", 314, "duplicate path %s", path);
    return (_Bool)0;
  }

  else
  {
    signed int return_value_xmkdir$2;
    return_value_xmkdir$2=xmkdir(path, sd_def_dmode);
    if(!(return_value_xmkdir$2 >= 0))
    {
      log_write(3, "md_add_disk", 319, "can't mkdir for %s, %m", path);
      return (_Bool)0;
    }

    else
    {
      void *return_value_xmalloc$3;
      return_value_xmalloc$3=xmalloc(sizeof(struct disk) /*4128ul*/ );
      new = (struct disk *)return_value_xmalloc$3;
      pstrcpy(new->path, 4096, path);
      trim_last_slash(new->path);
      new->space=init_path_space(new->path, purge);
      if(new->space == 0ul)
      {
        free((void *)new);
        return (_Bool)0;
      }

      else
      {
        create_vdisks(new);
        struct rb_node **__n = &(&md.root)->rb_node;
        struct rb_node *__parent = (struct rb_node *)(void *)0;
        struct disk *__old = (struct disk *)(void *)0;
        struct disk *__data;
        while(!(*__n == ((struct rb_node *)NULL)))
        {
          const struct rb_node *__mptr = *__n;
          tmp_statement_expression$4 = (struct disk *)((char *)__mptr - (signed long int)0ul);
          __data = tmp_statement_expression$4;
          signed int __cmp;
          __cmp=disk_cmp(new, __data);
          __parent = *__n;
          if(!(__cmp >= 0))
            __n = &(*__n)->rb_left;

          else
            if(__cmp >= 1)
              __n = &(*__n)->rb_right;

            else
            {
              __old = __data;
              break;
            }
        }
        if(__old == ((struct disk *)NULL))
        {
          rb_link_node$link5(&new->rb, __parent, __n);
          rb_insert_color(&new->rb, &md.root);
        }

        __old;
        md.space = md.space + new->space;
        md.nr_disks = md.nr_disks + 1u;
        signed int return_value_vdisk_number$5;
        return_value_vdisk_number$5=vdisk_number(new);
        log_write(6, "md_add_disk", 338, "%s, vdisk nr %d, total disk %d", (const void *)new->path, return_value_vdisk_number$5, md.nr_disks);
        return (_Bool)1;
      }
    }
  }
}

// md_check_and_move
// file md.c line 639
static signed int md_check_and_move(unsigned long int oid, unsigned int epoch, unsigned char ec_index, const char *path)
{
  char old[4096l];
  char new[4096l];
  signed int return_value_get_old_new_path$1;
  return_value_get_old_new_path$1=get_old_new_path(oid, epoch, ec_index, path, old, new);
  if(!(return_value_get_old_new_path$1 >= 0))
    return 0x03;

  else
  {
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(old, new);
    if(return_value_strcmp$2 == 0)
      return 0x00;

    else
    {
      signed int return_value_md_move_object$3;
      return_value_md_move_object$3=md_move_object(oid, old, new);
      if(!(return_value_md_move_object$3 >= 0))
      {
        log_write(3, "md_check_and_move", 657, "move old %s to new %s failed", (const void *)old, (const void *)new);
        return 0x03;
      }

      else
      {
        if(sd_log_level == 7)
          log_write(7, "md_check_and_move", 661, "from %s to %s", (const void *)old, (const void *)new);

        return 0x00;
      }
    }
  }
}

// md_del_disk
// file md.c line 744
static inline void md_del_disk(const char *path)
{
  struct disk *disk;
  disk=path_to_disk(path);
  if(disk == ((struct disk *)NULL))
    log_write(3, "md_del_disk", 749, "invalid path %s", path);

  else
    md_remove_disk(disk);
}

// md_do_recover
// file md.c line 518
static void md_do_recover(struct work *work)
{
  struct md_work *mw;
  struct md_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct md_work *)((char *)__mptr - (signed long int)0ul);
  mw = tmp_statement_expression$1;
  struct disk *disk;
  signed int nr = 0;
  sd_write_lock$link3(&md.lock);
  disk=path_to_disk(mw->path);
  if(!(disk == ((struct disk *)NULL)))
  {
    md_remove_disk(disk);
    nr = (signed int)md.nr_disks;
  }


out:
  ;
  sd_rw_unlock$link3(&md.lock);
  if(nr >= 1)
    kick_recover();

  free((void *)mw);
}

// md_exist
// file sheep_priv.h line 485
_Bool md_exist(unsigned long int oid, unsigned char ec_index)
{
  char path[4096l];
  get_store_path(oid, ec_index, path);
  _Bool return_value_md_access$1;
  return_value_md_access$1=md_access(path);
  if(!(return_value_md_access$1 == (_Bool)0))
    return (_Bool)1;

  else
  {
    signed int return_value_scan_wd$2;
    return_value_scan_wd$2=scan_wd(oid, (unsigned int)0, ec_index);
    if(return_value_scan_wd$2 == 0x00)
      return (_Bool)1;

    else
      return (_Bool)0;
  }
}

// md_get_info
// file sheep_priv.h line 487
unsigned int md_get_info(struct sd_md_info *info)
{
  unsigned int ret = (unsigned int)sizeof(struct sd_md_info) /*263688ul*/ ;
  struct disk *disk;
  signed int i = 0;
  memset((void *)info, 0, (unsigned long int)ret);
  sd_read_lock$link3(&md.lock);
  struct rb_node *__p731;
  __p731=rb_first(&md.root);
  struct rb_node *__n731;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct disk *tmp_statement_expression$2;
  do
  {
    if(!(__p731 == ((struct rb_node *)NULL)))
    {
      __n731=rb_next(__p731);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p731;
      tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
      disk = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    info->disk[(signed long int)i].idx = i;
    pstrcpy(info->disk[(signed long int)i].path, 4096, disk->path);
    info->disk[(signed long int)i].free=get_path_free_size(info->disk[(signed long int)i].path, &info->disk[(signed long int)i].used);
    i = i + 1;
    __p731 = __n731;
  }
  while((_Bool)1);
  info->nr = (signed int)md.nr_disks;
  sd_rw_unlock$link3(&md.lock);
  return ret;
}

// md_get_object_dir
// file sheep_priv.h line 483
const char * md_get_object_dir(unsigned long int oid)
{
  const char *p;
  sd_read_lock$link3(&md.lock);
  p=md_get_object_dir_nolock(oid);
  sd_rw_unlock$link3(&md.lock);
  return p;
}

// md_get_object_dir_nolock
// file md.c line 356
static const char * md_get_object_dir_nolock(unsigned long int oid)
{
  struct vdisk *vd;
  if(md.nr_disks == 0u)
    return "/all/disks/are/broken/,ps/o7/!";

  else
  {
    vd=oid_to_vdisk(oid);
    return vd->disk->path;
  }
}

// md_get_size
// file sheep_priv.h line 490
unsigned long int md_get_size(unsigned long int *used)
{
  unsigned long int fsize = (unsigned long int)0;
  struct disk *disk;
  *used = (unsigned long int)0;
  sd_read_lock$link3(&md.lock);
  struct rb_node *__p803;
  __p803=rb_first(&md.root);
  struct rb_node *__n803;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct disk *tmp_statement_expression$2;
  do
  {
    if(!(__p803 == ((struct rb_node *)NULL)))
    {
      __n803=rb_next(__p803);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p803;
      tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
      disk = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    unsigned long int return_value_get_path_free_size$4;
    return_value_get_path_free_size$4=get_path_free_size(disk->path, used);
    fsize = fsize + return_value_get_path_free_size$4;
    __p803 = __n803;
  }
  while((_Bool)1);
  sd_rw_unlock$link3(&md.lock);
  return fsize + *used;
}

// md_get_stale_path
// file sheep_priv.h line 486
signed int md_get_stale_path(unsigned long int oid, unsigned int epoch, unsigned char ec_index, char *path)
{
  if(epoch == 0u)
  {
    log_write(0, "md_get_stale_path", 702, "PANIC: invalid 0 epoch");
    abort();
  }

  _Bool return_value_is_erasure_oid$3;
  return_value_is_erasure_oid$3=is_erasure_oid(oid);
  const char *return_value_md_get_object_dir$2;
  if(!(return_value_is_erasure_oid$3 == (_Bool)0))
  {
    if((signed int)ec_index >= 2)
    {
      log_write(0, "md_get_stale_path", 706, "PANIC: invalid ec index %d", ec_index);
      abort();
    }

    const char *return_value_md_get_object_dir$1;
    return_value_md_get_object_dir$1=md_get_object_dir(oid);
    snprintf(path, (unsigned long int)4096, "%s/.stale/%016lx_%d.%u", return_value_md_get_object_dir$1, oid, ec_index, epoch);
  }

  else
  {
    return_value_md_get_object_dir$2=md_get_object_dir(oid);
    snprintf(path, (unsigned long int)4096, "%s/.stale/%016lx.%u", return_value_md_get_object_dir$2, oid, epoch);
  }
  _Bool return_value_md_access$4;
  return_value_md_access$4=md_access(path);
  if(!(return_value_md_access$4 == (_Bool)0))
    return 0x00;

  else
  {
    signed int return_value_scan_wd$5;
    return_value_scan_wd$5=scan_wd(oid, epoch, ec_index);
    if(return_value_scan_wd$5 == 0x00)
      return 0x00;

    else
      return 0x02;
  }
}

// md_handle_eio
// file sheep_priv.h line 484
signed int md_handle_eio(const char *fault_path)
{
  struct md_work *mw;
  signed int return_value_nr_online_disks$1;
  return_value_nr_online_disks$1=nr_online_disks();
  if(return_value_nr_online_disks$1 == 0)
    return 0x03;

  else
  {
    void *return_value_xzalloc$2;
    return_value_xzalloc$2=xzalloc(sizeof(struct md_work) /*4128ul*/ );
    mw = (struct md_work *)return_value_xzalloc$2;
    mw->work.done = md_do_recover;
    pstrcpy(mw->path, 4096, fault_path);
    queue_work(sys->md_wqueue, &mw->work);
    return 0x86;
  }
}

// md_init_space
// file sheep_priv.h line 482
unsigned long int md_init_space(void)
{
  return md.space;
}

// md_move_object
// file md.c line 606
static signed int md_move_object(unsigned long int oid, const char *old, const char *new)
{
  struct strbuf buf = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  signed int fd;
  signed int ret = -1;
  unsigned long int sz;
  sz=get_store_objsize(oid);
  fd=open(old, 00);
  signed long int return_value_strbuf_read$1;
  signed int return_value_atomic_create_and_write$2;
  if(!(fd >= 0))
    log_write(3, "md_move_object", 614, "failed to open %s", old);

  else
  {
    return_value_strbuf_read$1=strbuf_read(&buf, fd, sz);
    ret = (signed int)return_value_strbuf_read$1;
    if(!((unsigned long int)ret == sz))
    {
      log_write(3, "md_move_object", 620, "failed to read %s, size %zu, %d, %m", old, sz, ret);
      ret = -1;
    }

    else
    {
      return_value_atomic_create_and_write$2=atomic_create_and_write(new, buf.buf, buf.len, (_Bool)0);
      if(!(return_value_atomic_create_and_write$2 >= 0))
      {
        log_write(3, "md_move_object", 626, "failed to create %s", new);
        ret = -1;
      }

      else
      {
        unlink(old);
        ret = 0;
      }
    }

  out_close:
    ;
    close(fd);
  }

out:
  ;
  strbuf_release(&buf);
  return ret;
}

// md_plug_disks
// file sheep_priv.h line 488
signed int md_plug_disks(char *disks)
{
  signed int return_value_do_plug_unplug$1;
  return_value_do_plug_unplug$1=do_plug_unplug(disks, (_Bool)1);
  return return_value_do_plug_unplug$1;
}

// md_remove_disk
// file md.c line 342
static inline void md_remove_disk(struct disk *disk)
{
  log_write(6, "md_remove_disk", 344, "%s from multi-disk array", (const void *)disk->path);
  rb_erase(&disk->rb, &md.root);
  md.nr_disks = md.nr_disks - 1u;
  remove_vdisks(disk);
  free((void *)disk);
}

// md_unplug_disks
// file sheep_priv.h line 489
signed int md_unplug_disks(char *disks)
{
  signed int return_value_do_plug_unplug$1;
  return_value_do_plug_unplug$1=do_plug_unplug(disks, (_Bool)0);
  return return_value_do_plug_unplug$1;
}

// merge
// file util.c line 616
static struct list_node * merge(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_node *a, struct list_node *b)
{
  struct list_node head;
  struct list_node *tail = &head;
  if(!(a == ((struct list_node *)NULL)) && !(b == ((struct list_node *)NULL)))
  {
    signed int return_value;
    return_value=cmp(priv, a, b);
    if(!(return_value >= 1))
    {
      tail->next = a;
      a = a->next;
    }

    else
    {
      tail->next = b;
      b = b->next;
    }
    tail = tail->next;
  }

  tail->next = (_Bool)a ? a : b;
  return head.next;
}

// merge_and_restore_back_links
// file util.c line 646
static void merge_and_restore_back_links(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_head *head, struct list_node *a, struct list_node *b)
{
  struct list_node *tail = &head->n;
  if(!(a == ((struct list_node *)NULL)) && !(b == ((struct list_node *)NULL)))
  {
    signed int return_value;
    return_value=cmp(priv, a, b);
    if(!(return_value >= 1))
    {
      tail->next = a;
      a->prev = tail;
      a = a->next;
    }

    else
    {
      tail->next = b;
      b->prev = tail;
      b = b->next;
    }
    tail = tail->next;
  }

  tail->next = (_Bool)a ? a : b;
  cmp(priv, tail->next, tail->next);
  tail->next->prev = tail;
  tail = tail->next;
  tail->next = &head->n;
  head->n.prev = tail;
}

// migrate_from_v0_to_v1
// file migrate.c line 260
static signed int migrate_from_v0_to_v1(void)
{
  signed int ret;
  signed int fd;
  struct sheepdog_config_v1 migrate_from_v0_to_v1$$1$$config;
  fd=open(config_path, 02);
  if(!(fd >= 0))
  {
    log_write(3, "migrate_from_v0_to_v1", 267, "failed to open config file, %m");
    return -1;
  }

  else
  {
    memset((void *)&migrate_from_v0_to_v1$$1$$config, 0, sizeof(struct sheepdog_config_v1) /*40ul*/ );
    signed long int return_value_xread$1;
    return_value_xread$1=xread(fd, (void *)&migrate_from_v0_to_v1$$1$$config, sizeof(struct sheepdog_config_v1) /*40ul*/ );
    ret = (signed int)return_value_xread$1;
    if(!(ret >= 0))
    {
      log_write(3, "migrate_from_v0_to_v1", 274, "failed to read config file, %m");
      close(fd);
      return ret;
    }

    else
    {
      migrate_from_v0_to_v1$$1$$config.version = (unsigned short int)1;
      signed long int return_value_xpwrite$2;
      return_value_xpwrite$2=xpwrite(fd, (const void *)&migrate_from_v0_to_v1$$1$$config, sizeof(struct sheepdog_config_v1) /*40ul*/ , (signed long int)0);
      ret = (signed int)return_value_xpwrite$2;
      if(!((unsigned long int)ret == sizeof(struct sheepdog_config_v1) /*40ul*/ ))
      {
        log_write(3, "migrate_from_v0_to_v1", 282, "failed to write config data, %m");
        close(fd);
        return -1;
      }

      else
      {
        ret=xftruncate(fd, (signed long int)sizeof(struct sheepdog_config_v1) /*40ul*/ );
        if(!(ret == 0))
        {
          log_write(3, "migrate_from_v0_to_v1", 290, "failed to truncate config data, %m");
          close(fd);
          return -1;
        }

        else
        {
          close(fd);
          if(migrate_from_v0_to_v1$$1$$config.space >= 1ul)
            return 0;

          else
          {
            for_each_epoch(update_epoch_from_v0_to_v1);
            return ret;
          }
        }
      }
    }
  }
}

// migrate_from_v1_to_v2
// file migrate.c line 385
static signed int migrate_from_v1_to_v2(void)
{
  signed int fd;
  signed int ret;
  unsigned short int version = (unsigned short int)2;
  char store[16l] = { 'p', 'l', 'a', 'i', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  fd=open(config_path, 01 | 010000);
  if(!(fd >= 0))
  {
    log_write(3, "migrate_from_v1_to_v2", 393, "failed to open config file, %m");
    return -1;
  }

  else
  {
    signed long int return_value_xpwrite$1;
    return_value_xpwrite$1=xpwrite(fd, (const void *)&version, sizeof(unsigned short int) /*2ul*/ , (signed long int)30ul);
    ret = (signed int)return_value_xpwrite$1;
    if(!((unsigned long int)ret == sizeof(unsigned short int) /*2ul*/ ))
    {
      log_write(3, "migrate_from_v1_to_v2", 400, "failed to write config data, %m");
      close(fd);
      return -1;
    }

    else
    {
      signed long int return_value_xpwrite$2;
      return_value_xpwrite$2=xpwrite(fd, (const void *)store, sizeof(char [16l]) /*16ul*/ , (signed long int)11ul);
      ret = (signed int)return_value_xpwrite$2;
      if(!((unsigned long int)ret == sizeof(char [16l]) /*16ul*/ ))
      {
        log_write(3, "migrate_from_v1_to_v2", 408, "failed to write config data, %m");
        close(fd);
        return -1;
      }

      else
      {
        close(fd);
        for_each_epoch(update_epoch_from_v1_to_v2);
        return ret;
      }
    }
  }
}

// migrate_from_v2_to_v3
// file migrate.c line 421
static signed int migrate_from_v2_to_v3(void)
{
  log_write(3, "migrate_from_v2_to_v3", 423, "not implemented");
  return -1;
}

// migrate_from_v3_to_v4
// file migrate.c line 475
static signed int migrate_from_v3_to_v4(void)
{
  _Bool is_stale = (_Bool)1;
  signed int ret;
  ret=for_each_object_in_stale(convert_ecidx_xattr2path, (void *)&is_stale);
  if(!(ret >= 0))
  {
    log_write(0, "migrate_from_v3_to_v4", 484, "converting store format of stale object directoryfailed");
    return ret;
  }

  else
  {
    is_stale = (_Bool)0;
    ret=for_each_object_in_wd(convert_ecidx_xattr2path, (_Bool)0, (void *)&is_stale);
    if(!(ret >= 0))
    {
      log_write(0, "migrate_from_v3_to_v4", 492, "converting store format of object directory failed");
      return ret;
    }

    else
    {
      log_write(6, "migrate_from_v3_to_v4", 496, "converting store format v3 to v4 is ended successfully");
      return 0;
    }
  }
}

// modify_event
// file event.c line 148
signed int modify_event(signed int fd, unsigned int new_events)
{
  signed int ret;
  struct epoll_event ev;
  struct event_info *ei;
  ei=lookup_event(fd);
  if(ei == ((struct event_info *)NULL))
  {
    log_write(3, "modify_event", 156, "event info for fd %d not found", fd);
    return 1;
  }

  else
  {
    memset((void *)&ev, 0, sizeof(struct epoll_event) /*12ul*/ );
    ev.events = new_events;
    ev.data.ptr = (void *)ei;
    ret=epoll_ctl(efd, 3, fd, &ev);
    if(!(ret == 0))
    {
      log_write(3, "modify_event", 166, "failed to modify epoll event for fd %d: %m", fd);
      return 1;
    }

    else
      return 0;
  }
}

// modnn
// file fec.c line 89
static unsigned char modnn(signed int x)
{
  for( ; x >= 255; x = (x >> 8) + (x & 255))
    x = x - 255;
  return (unsigned char)x;
}

// move_object_to_stale_dir
// file plain_store.c line 474
static signed int move_object_to_stale_dir(unsigned long int oid, const char *wd, unsigned int epoch, unsigned char ec_index, struct vnode_info *vinfo, void *arg)
{
  char path[4096l];
  char stale_path[4096l];
  unsigned int tgt_epoch = *((unsigned int *)arg);
  if(!((signed int)ec_index >= 2))
  {
    const char *return_value_md_get_object_dir$1;
    return_value_md_get_object_dir$1=md_get_object_dir(oid);
    snprintf(path, (unsigned long int)4096, "%s/%016lx_%d", return_value_md_get_object_dir$1, oid, ec_index);
    const char *return_value_md_get_object_dir$2;
    return_value_md_get_object_dir$2=md_get_object_dir(oid);
    snprintf(stale_path, (unsigned long int)4096, "%s/.stale/%016lx_%d.%u", return_value_md_get_object_dir$2, oid, ec_index, tgt_epoch);
  }

  else
  {
    const char *return_value_md_get_object_dir$3;
    return_value_md_get_object_dir$3=md_get_object_dir(oid);
    snprintf(path, (unsigned long int)4096, "%s/%016lx", return_value_md_get_object_dir$3, oid);
    const char *return_value_md_get_object_dir$4;
    return_value_md_get_object_dir$4=md_get_object_dir(oid);
    snprintf(stale_path, (unsigned long int)4096, "%s/.stale/%016lx.%u", return_value_md_get_object_dir$4, oid, tgt_epoch);
  }
  signed int return_value_rename$5;
  return_value_rename$5=rename(path, stale_path);
  if(!((signed long int)!(return_value_rename$5 == 0) >= 0l))
  {
    log_write(3, "move_object_to_stale_dir", 497, "failed to move stale object %lX to %s, %m", oid, (const void *)path);
    return 0x03;
  }

  else
  {
    if(sd_log_level == 7)
      log_write(7, "move_object_to_stale_dir", 501, "moved object %lx", oid);

    return 0x00;
  }
}

// my_exe_path
// file ../include/util.h line 117
const char * my_exe_path(void)
{
  signed int ret;
  static char path[4096l];
  if((signed int)path[0l] == 0)
  {
    signed long int return_value_readlink$1;
    return_value_readlink$1=readlink("/proc/self/exe", path, sizeof(char [4096l]) /*4096ul*/ );
    ret = (signed int)return_value_readlink$1;
    if(!(ret >= -1))
    {
      log_write(0, "my_exe_path", 504, "PANIC: %m");
      abort();
    }

  }

  return path;
}

// node_cmp
// file ../include/sheep.h line 196
static inline signed int node_cmp(struct sd_node *node1, struct sd_node *node2)
{
  signed int return_value_node_id_cmp$1;
  return_value_node_id_cmp$1=node_id_cmp(&node1->nid, &node2->nid);
  return return_value_node_id_cmp$1;
}

// node_cmp$link1
// file ../include/sheep.h line 196
static inline signed int node_cmp$link1(struct sd_node *node1$link1, struct sd_node *node2$link1)
{
  signed int return_value_node_id_cmp$1$link1;
  return_value_node_id_cmp$1$link1=node_id_cmp$link3(&node1$link1->nid, &node2$link1->nid);
  return return_value_node_id_cmp$1$link1;
}

// node_cmp$link2
// file ../include/sheep.h line 196
static inline signed int node_cmp$link2(struct sd_node *node1$link2, struct sd_node *node2$link2)
{
  signed int return_value_node_id_cmp$1$link2;
  return_value_node_id_cmp$1$link2=node_id_cmp$link4(&node1$link2->nid, &node2$link2->nid);
  return return_value_node_id_cmp$1$link2;
}

// node_eq
// file ../include/sheep.h line 202
static inline _Bool node_eq(struct sd_node *a, struct sd_node *b)
{
  signed int return_value_node_cmp$1;
  return_value_node_cmp$1=node_cmp(a, b);
  return return_value_node_cmp$1 == 0;
}

// node_eq$link1
// file ../include/sheep.h line 202
static inline _Bool node_eq$link1(struct sd_node *a$link1, struct sd_node *b$link1)
{
  signed int return_value_node_cmp$1$link1;
  return_value_node_cmp$1$link1=node_cmp$link2(a$link1, b$link1);
  return return_value_node_cmp$1$link1 == 0;
}

// node_id_cmp
// file ../include/sheep.h line 186
static inline signed int node_id_cmp(struct node_id *node1, struct node_id *node2)
{
  signed int cmp;
  cmp=memcmp((const void *)node1->addr, (const void *)node2->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1;
  if(!(cmp == 0))
    return cmp;

  else
  {
    unsigned short int _x = node1->port;
    unsigned short int _y = node2->port;
    (void)(&_x == &_y);
    tmp_statement_expression$1 = (signed int)_x < (signed int)_y ? -1 : ((signed int)_x > (signed int)_y ? 1 : 0);
    return tmp_statement_expression$1;
  }
}

// node_id_cmp$link1
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link1(struct node_id *node1$link1, struct node_id *node2$link1)
{
  signed int cmp$link1;
  cmp$link1=memcmp((const void *)node1$link1->addr, (const void *)node2$link1->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1$link1;
  if(!(cmp$link1 == 0))
    return cmp$link1;

  else
  {
    unsigned short int _x$link1 = node1$link1->port;
    unsigned short int _y$link1 = node2$link1->port;
    (void)(&_x$link1 == &_y$link1);
    tmp_statement_expression$1$link1 = (signed int)_x$link1 < (signed int)_y$link1 ? -1 : ((signed int)_x$link1 > (signed int)_y$link1 ? 1 : 0);
    return tmp_statement_expression$1$link1;
  }
}

// node_id_cmp$link2
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link2(struct node_id *node1$link2, struct node_id *node2$link2)
{
  signed int cmp$link2;
  cmp$link2=memcmp((const void *)node1$link2->addr, (const void *)node2$link2->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1$link2;
  if(!(cmp$link2 == 0))
    return cmp$link2;

  else
  {
    unsigned short int _x$link2 = node1$link2->port;
    unsigned short int _y$link2 = node2$link2->port;
    (void)(&_x$link2 == &_y$link2);
    tmp_statement_expression$1$link2 = (signed int)_x$link2 < (signed int)_y$link2 ? -1 : ((signed int)_x$link2 > (signed int)_y$link2 ? 1 : 0);
    return tmp_statement_expression$1$link2;
  }
}

// node_id_cmp$link3
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link3(struct node_id *node1$link3, struct node_id *node2$link3)
{
  signed int cmp$link3;
  cmp$link3=memcmp((const void *)node1$link3->addr, (const void *)node2$link3->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1$link3;
  if(!(cmp$link3 == 0))
    return cmp$link3;

  else
  {
    unsigned short int _x$link3 = node1$link3->port;
    unsigned short int _y$link3 = node2$link3->port;
    (void)(&_x$link3 == &_y$link3);
    tmp_statement_expression$1$link3 = (signed int)_x$link3 < (signed int)_y$link3 ? -1 : ((signed int)_x$link3 > (signed int)_y$link3 ? 1 : 0);
    return tmp_statement_expression$1$link3;
  }
}

// node_id_cmp$link4
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link4(struct node_id *node1$link4, struct node_id *node2$link4)
{
  signed int cmp$link4;
  cmp$link4=memcmp((const void *)node1$link4->addr, (const void *)node2$link4->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1$link4;
  if(!(cmp$link4 == 0))
    return cmp$link4;

  else
  {
    unsigned short int _x$link4 = node1$link4->port;
    unsigned short int _y$link4 = node2$link4->port;
    (void)(&_x$link4 == &_y$link4);
    tmp_statement_expression$1$link4 = (signed int)_x$link4 < (signed int)_y$link4 ? -1 : ((signed int)_x$link4 > (signed int)_y$link4 ? 1 : 0);
    return tmp_statement_expression$1$link4;
  }
}

// node_id_cmp$link5
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link5(struct node_id *node1$link5, struct node_id *node2$link5)
{
  signed int cmp$link5;
  cmp$link5=memcmp((const void *)node1$link5->addr, (const void *)node2$link5->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1$link5;
  if(!(cmp$link5 == 0))
    return cmp$link5;

  else
  {
    unsigned short int _x$link5 = node1$link5->port;
    unsigned short int _y$link5 = node2$link5->port;
    (void)(&_x$link5 == &_y$link5);
    tmp_statement_expression$1$link5 = (signed int)_x$link5 < (signed int)_y$link5 ? -1 : ((signed int)_x$link5 > (signed int)_y$link5 ? 1 : 0);
    return tmp_statement_expression$1$link5;
  }
}

// node_id_cmp$link6
// file ../include/sheep.h line 186
static inline signed int node_id_cmp$link6(struct node_id *node1$link6, struct node_id *node2$link6)
{
  signed int cmp$link6;
  cmp$link6=memcmp((const void *)node1$link6->addr, (const void *)node2$link6->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression$1$link6;
  if(!(cmp$link6 == 0))
    return cmp$link6;

  else
  {
    unsigned short int _x$link6 = node1$link6->port;
    unsigned short int _y$link6 = node2$link6->port;
    (void)(&_x$link6 == &_y$link6);
    tmp_statement_expression$1$link6 = (signed int)_x$link6 < (signed int)_y$link6 ? -1 : ((signed int)_x$link6 > (signed int)_y$link6 ? 1 : 0);
    return tmp_statement_expression$1$link6;
  }
}

// node_in_recovery
// file sheep_priv.h line 373
_Bool node_in_recovery(void)
{
  struct recovery_info *tmp_statement_expression$1 = current_rinfo.__val;
  return tmp_statement_expression$1 != (struct recovery_info *)(void *)0;
}

// node_is_gateway_only
// file recovery.c line 92
static inline _Bool node_is_gateway_only(void)
{
  return (signed int)sys->this_node.nr_vnodes == 0;
}

// node_is_local
// file sheep_priv.h line 434
static inline _Bool node_is_local(struct sd_node *n)
{
  _Bool return_value_node_eq$1;
  return_value_node_eq$1=node_eq(n, &sys->this_node);
  return return_value_node_eq$1;
}

// node_is_local$link1
// file sheep_priv.h line 434
static inline _Bool node_is_local$link1(struct sd_node *n$link1)
{
  _Bool return_value_node_eq$1$link1;
  return_value_node_eq$1$link1=node_eq$link1(n$link1, &sys->this_node);
  return return_value_node_eq$1$link1;
}

// node_size_varied
// file ops.c line 717
static _Bool node_size_varied(void)
{
  unsigned long int new;
  unsigned long int used;
  unsigned long int old = sys->this_node.space;
  double diff;
  if(!(sys->gateway_only == (_Bool)0))
    return (_Bool)0;

  else
  {
    new=md_get_size(&used);
    if(old == 0ul)
    {
      if(!(new == 0ul))
        return (_Bool)1;

      return (_Bool)0;
    }

    else
    {
      diff = new > old ? (double)(new - old) : (double)(old - new);
      if(sd_log_level == 7)
        log_write(7, "node_size_varied", 736, "new %lu, old %lu, ratio %f", new, old, diff / (double)old);

      if(diff / (double)old < 0.01)
        return (_Bool)0;

      else
      {
        sys->this_node.space = new;
        set_node_space(new);
        return (_Bool)1;
      }
    }
  }
}

// node_to_str
// file ../include/sheep.h line 244
static inline const char * node_to_str(struct sd_node *id)
{
  signed int af = 10;
  const unsigned char *addr = id->nid.addr;
  signed int tmp_post$1;
  if(!(addr[12l] == 0))
  {
    signed int oct_no = 0;
    while(addr[(signed long int)oct_no] == 0)
    {
      tmp_post$1 = oct_no;
      oct_no = oct_no + 1;
      if(tmp_post$1 >= 12)
        break;

    }
    if(oct_no == 12)
      af = 2;

  }

  const char *return_value_addr_to_str$2;
  return_value_addr_to_str$2=addr_to_str(id->nid.addr, (unsigned short int)0);
  static char str[256l];
  snprintf(str, sizeof(char [256l]) /*256ul*/ , "%s ip:%s port:%d", af == 2 ? "IPv4" : "IPv6", return_value_addr_to_str$2, id->nid.port);
  return str;
}

// node_to_str$link1
// file ../include/sheep.h line 244
static inline const char * node_to_str$link1(struct sd_node *id$link1)
{
  signed int af$link1 = 10;
  const unsigned char *addr$link1 = id$link1->nid.addr;
  signed int tmp_post$1$link1;
  if(!(addr$link1[12l] == 0))
  {
    signed int oct_no$link1 = 0;
    while(addr$link1[(signed long int)oct_no$link1] == 0)
    {
      tmp_post$1$link1 = oct_no$link1;
      oct_no$link1 = oct_no$link1 + 1;
      if(tmp_post$1$link1 >= 12)
        break;

    }
    if(oct_no$link1 == 12)
      af$link1 = 2;

  }

  const char *return_value_addr_to_str$2$link1;
  return_value_addr_to_str$2$link1=addr_to_str(id$link1->nid.addr, (unsigned short int)0);
  static char str$link1[256l];
  snprintf(str$link1, sizeof(char [256l]) /*256ul*/ , "%s ip:%s port:%d", af$link1 == 2 ? "IPv4" : "IPv6", return_value_addr_to_str$2$link1, id$link1->nid.port);
  return str$link1;
}

// node_to_str$link2
// file ../include/sheep.h line 244
static inline const char * node_to_str$link2(struct sd_node *id$link2)
{
  signed int af$link2 = 10;
  const unsigned char *addr$link2 = id$link2->nid.addr;
  signed int tmp_post$1$link2;
  if(!(addr$link2[12l] == 0))
  {
    signed int oct_no$link2 = 0;
    while(addr$link2[(signed long int)oct_no$link2] == 0)
    {
      tmp_post$1$link2 = oct_no$link2;
      oct_no$link2 = oct_no$link2 + 1;
      if(tmp_post$1$link2 >= 12)
        break;

    }
    if(oct_no$link2 == 12)
      af$link2 = 2;

  }

  const char *return_value_addr_to_str$2$link2;
  return_value_addr_to_str$2$link2=addr_to_str(id$link2->nid.addr, (unsigned short int)0);
  static char str$link2[256l];
  snprintf(str$link2, sizeof(char [256l]) /*256ul*/ , "%s ip:%s port:%d", af$link2 == 2 ? "IPv4" : "IPv6", return_value_addr_to_str$2$link2, id$link2->nid.port);
  return str$link2;
}

// node_to_vnodes
// file ../include/sheep.h line 208
static inline void node_to_vnodes(struct sd_node *n, struct rb_root *vroot)
{
  unsigned long int hval;
  hval=sd_hash((const void *)&n->nid, 18ul);
  signed int i = 0;
  struct sd_vnode *tmp_statement_expression$2;
  struct sd_vnode *tmp_statement_expression$3;
  for( ; !(i >= (signed int)n->nr_vnodes); i = i + 1)
  {
    struct sd_vnode *v;
    void *return_value_xmalloc$1;
    return_value_xmalloc$1=xmalloc(sizeof(struct sd_vnode) /*40ul*/ );
    v = (struct sd_vnode *)return_value_xmalloc$1;
    hval=sd_hash_next(hval);
    v->hash = hval;
    v->node = n;
    struct rb_node **__n = &vroot->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct sd_vnode *__old = (struct sd_vnode *)(void *)0;
    struct sd_vnode *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr = *__n;
      tmp_statement_expression$3 = (struct sd_vnode *)((char *)__mptr - (signed long int)0ul);
      __data = tmp_statement_expression$3;
      signed int __cmp;
      __cmp=vnode_cmp(v, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct sd_vnode *)NULL))
    {
      rb_link_node(&v->rb, __parent, __n);
      rb_insert_color(&v->rb, vroot);
    }

    tmp_statement_expression$2 = __old;
    if(!(tmp_statement_expression$2 == ((struct sd_vnode *)NULL)))
    {
      log_write(0, "node_to_vnodes", 220, "PANIC: vdisk hash collison");
      abort();
    }

  }
}

// nodes_to_buffer
// file ../include/sheep.h line 233
static inline void nodes_to_buffer(struct rb_root *nroot, void *buffer)
{
  struct sd_node *n;
  struct sd_node *buf = (struct sd_node *)buffer;
  struct rb_node *__p237;
  __p237=rb_first(nroot);
  struct rb_node *__n237;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_node *tmp_statement_expression$2;
  struct sd_node *tmp_post$4;
  do
  {
    if(!(__p237 == ((struct rb_node *)NULL)))
    {
      __n237=rb_next(__p237);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p237;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    tmp_post$4 = buf;
    buf = buf + 1l;
    memcpy((void *)tmp_post$4, (const void *)n, sizeof(struct sd_node) /*80ul*/ );
    __p237 = __n237;
  }
  while((_Bool)1);
}

// nodes_to_buffer$link1
// file ../include/sheep.h line 233
static inline void nodes_to_buffer$link1(struct rb_root *nroot$link1, void *buffer$link1)
{
  struct sd_node *n$link1;
  struct sd_node *buf$link1 = (struct sd_node *)buffer$link1;
  struct rb_node *__p237$link1;
  __p237$link1=rb_first(nroot$link1);
  struct rb_node *__n237$link1;
  _Bool tmp_if_expr$1$link1;
  _Bool tmp_if_expr$3$link1;
  struct sd_node *tmp_statement_expression$2$link1;
  struct sd_node *tmp_post$4$link1;
  do
  {
    if(!(__p237$link1 == ((struct rb_node *)NULL)))
    {
      __n237$link1=rb_next(__p237$link1);
      tmp_if_expr$1$link1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1$link1 = (_Bool)0;
    if(tmp_if_expr$1$link1)
    {
      const struct rb_node *__mptr$link1 = __p237$link1;
      tmp_statement_expression$2$link1 = (struct sd_node *)((char *)__mptr$link1 - (signed long int)0ul);
      n$link1 = tmp_statement_expression$2$link1;
      tmp_if_expr$3$link1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3$link1 = (_Bool)0;
    if(!tmp_if_expr$3$link1)
      break;

    tmp_post$4$link1 = buf$link1;
    buf$link1 = buf$link1 + 1l;
    memcpy((void *)tmp_post$4$link1, (const void *)n$link1, sizeof(struct sd_node) /*80ul*/ );
    __p237$link1 = __n237$link1;
  }
  while((_Bool)1);
}

// nodes_to_buffer$link2
// file ../include/sheep.h line 233
static inline void nodes_to_buffer$link2(struct rb_root *nroot$link2, void *buffer$link2)
{
  struct sd_node *n$link2;
  struct sd_node *buf$link2 = (struct sd_node *)buffer$link2;
  struct rb_node *__p237$link2;
  __p237$link2=rb_first(nroot$link2);
  struct rb_node *__n237$link2;
  _Bool tmp_if_expr$1$link2;
  _Bool tmp_if_expr$3$link2;
  struct sd_node *tmp_statement_expression$2$link2;
  struct sd_node *tmp_post$4$link2;
  do
  {
    if(!(__p237$link2 == ((struct rb_node *)NULL)))
    {
      __n237$link2=rb_next(__p237$link2);
      tmp_if_expr$1$link2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1$link2 = (_Bool)0;
    if(tmp_if_expr$1$link2)
    {
      const struct rb_node *__mptr$link2 = __p237$link2;
      tmp_statement_expression$2$link2 = (struct sd_node *)((char *)__mptr$link2 - (signed long int)0ul);
      n$link2 = tmp_statement_expression$2$link2;
      tmp_if_expr$3$link2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3$link2 = (_Bool)0;
    if(!tmp_if_expr$3$link2)
      break;

    tmp_post$4$link2 = buf$link2;
    buf$link2 = buf$link2 + 1l;
    memcpy((void *)tmp_post$4$link2, (const void *)n$link2, sizeof(struct sd_node) /*80ul*/ );
    __p237$link2 = __n237$link2;
  }
  while((_Bool)1);
}

// nodes_to_vnodes
// file ../include/sheep.h line 225
static inline void nodes_to_vnodes(struct rb_root *nroot, struct rb_root *vroot)
{
  struct sd_node *n;
  struct rb_node *__p229;
  __p229=rb_first(nroot);
  struct rb_node *__n229;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_node *tmp_statement_expression$2;
  do
  {
    if(!(__p229 == ((struct rb_node *)NULL)))
    {
      __n229=rb_next(__p229);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p229;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    node_to_vnodes(n, vroot);
    __p229 = __n229;
  }
  while((_Bool)1);
}

// notify_recovery_completion_main
// file recovery.c line 718
static void notify_recovery_completion_main(struct work *work)
{
  struct recovery_work *rw;
  struct recovery_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct recovery_work *)((char *)__mptr - (signed long int)24ul);
  rw = tmp_statement_expression$1;
  free_recovery_work(rw);
}

// notify_recovery_completion_work
// file recovery.c line 701
static void notify_recovery_completion_work(struct work *work)
{
  struct recovery_work *rw;
  struct recovery_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct recovery_work *)((char *)__mptr - (signed long int)24ul);
  rw = tmp_statement_expression$1;
  struct sd_req hdr;
  signed int ret;
  sd_init_req$link4(&hdr, (unsigned char)0xAC);
  hdr.$anon0.obj.tgt_epoch = rw->epoch;
  hdr.flags = (unsigned short int)0x01;
  hdr.data_length = (unsigned int)sizeof(struct sd_node) /*80ul*/ ;
  ret=exec_local_req(&hdr, (void *)&sys->this_node);
  if(!(ret == 0x00))
    log_write(3, "notify_recovery_completion_work", 715, "failed to notify recovery completion, %d", rw->epoch);

}

// notify_vdi_add
// file vdi.c line 631
static signed int notify_vdi_add(unsigned int vdi_id, unsigned int nr_copies, unsigned int old_vid, unsigned char copy_policy)
{
  signed int ret = 0x00;
  struct sd_req hdr;
  sd_init_req$link3(&hdr, (unsigned char)0xAF);
  hdr.$anon0.vdi_state.old_vid = old_vid;
  hdr.$anon0.vdi_state.new_vid = vdi_id;
  hdr.$anon0.vdi_state.copies = (unsigned char)nr_copies;
  hdr.$anon0.vdi_state.set_bitmap = (unsigned char)0;
  hdr.$anon0.vdi_state.copy_policy = copy_policy;
  ret=exec_local_req(&hdr, (void *)0);
  if(!(ret == 0x00))
    log_write(3, "notify_vdi_add", 647, "fail to notify vdi add event(%x, %d, %x)", vdi_id, nr_copies, old_vid);

  return ret;
}

// notify_vdi_deletion
// file vdi.c line 798
static signed int notify_vdi_deletion(unsigned int vdi_id)
{
  struct sd_req hdr;
  signed int ret = 0x00;
  sd_init_req$link3(&hdr, (unsigned char)0x99);
  hdr.flags = (unsigned short int)0x01;
  hdr.data_length = (unsigned int)sizeof(unsigned int) /*4ul*/ ;
  ret=exec_local_req(&hdr, (void *)&vdi_id);
  if(!(ret == 0x00))
    log_write(3, "notify_vdi_deletion", 810, "fail to notify vdi deletion(%x), %d", vdi_id, ret);

  return ret;
}

// nr_online_disks
// file md.c line 46
static inline signed int nr_online_disks(void)
{
  signed int nr;
  sd_read_lock$link3(&md.lock);
  nr = (signed int)md.nr_disks;
  sd_rw_unlock$link3(&md.lock);
  return nr;
}

// oalloc_free
// file http/http.h line 153
signed int oalloc_free(unsigned int vid, unsigned long int start, unsigned long int count)
{
  char *meta;
  void *return_value_xvalloc$1;
  return_value_xvalloc$1=xvalloc(1UL << 22);
  meta = (char *)return_value_xvalloc$1;
  struct header *hd;
  unsigned long int oid;
  oid=vid_to_data_oid$link3(vid, (unsigned long int)0);
  unsigned long int i;
  signed int ret;
  ret=sd_read_object(oid, meta, (unsigned int)(1UL << 22), (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$2;
    return_value_sd_strerror$2=sd_strerror$link9(ret);
    log_write(3, "oalloc_free", 273, "failed to read meta %lx, %s", oid, return_value_sd_strerror$2);
    goto out;
  }

  ret=update_and_merge_free_desc(meta, start, count, vid);
  unsigned int return_value_oalloc_meta_length$3;
  if(ret == 0x00)
  {
    i = (unsigned long int)0;
    for( ; !(i >= count); i = i + 1ul)
    {
      struct sd_req hdr;
      sd_init_req$link7(&hdr, (unsigned char)0x05);
      hdr.$anon0.obj.oid=vid_to_data_oid$link3(vid, start + i);
      ret=exec_local_req(&hdr, (void *)0);
      if(!(ret == 0x00))
        goto out;

    }
    hd = (struct header *)meta;
    return_value_oalloc_meta_length$3=oalloc_meta_length(hd);
    ret=sd_write_object(oid, meta, return_value_oalloc_meta_length$3, (unsigned long int)0, (_Bool)0);
    if(!(ret == 0x00))
    {
      const char *return_value_sd_strerror$4;
      return_value_sd_strerror$4=sd_strerror$link9(ret);
      log_write(3, "oalloc_free", 296, "failed to update meta %lx, %s", oid, return_value_sd_strerror$4);
      goto out;
    }

    if(sd_log_level == 7)
      log_write(7, "oalloc_free", 299, "used %lu, nr_free %lu", hd->used, hd->nr_free);

  }


out:
  ;
  free((void *)meta);
  return ret;
}

// oalloc_init
// file http/http.h line 154
signed int oalloc_init(unsigned int vid)
{
  struct strbuf buf = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  struct sd_inode *inode;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$1;
  struct header hd = { .used=0ul, .nr_free=(unsigned long int)1 };
  struct free_desc fd = { .start=(unsigned long int)1, .count=(1ULL << 32) - (unsigned long int)1 };
  signed int ret;
  strbuf_add(&buf, (const void *)&hd, sizeof(struct header) /*16ul*/ );
  strbuf_add(&buf, (const void *)&fd, sizeof(struct free_desc) /*16ul*/ );
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid$link4(vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$3;
    return_value_sd_strerror$3=sd_strerror$link9(ret);
    log_write(3, "oalloc_init", 83, "failed to read inode, %x, %s", vid, return_value_sd_strerror$3);
    goto out;
  }

  unsigned long int return_value_vid_to_data_oid$4;
  return_value_vid_to_data_oid$4=vid_to_data_oid$link3(vid, (unsigned long int)0);
  ret=sd_write_object(return_value_vid_to_data_oid$4, buf.buf, (unsigned int)buf.len, (unsigned long int)0, (_Bool)1);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$5;
    return_value_sd_strerror$5=sd_strerror$link9(ret);
    log_write(3, "oalloc_init", 90, "failed to create meta object for %x, %s", vid, return_value_sd_strerror$5);
    goto out;
  }

  sd_inode_set_vid(sheep_bnode_writer, sheep_bnode_reader, inode, (unsigned int)0, vid);
  ret=sd_inode_write_vid(sheep_bnode_writer, inode, (unsigned int)0, vid, vid, 0, (_Bool)0, (_Bool)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$6;
    return_value_sd_strerror$6=sd_strerror$link9(ret);
    log_write(3, "oalloc_init", 98, "failed to update inode, %x, %s", vid, return_value_sd_strerror$6);
    goto out;
  }


out:
  ;
  strbuf_release(&buf);
  free((void *)inode);
  return ret;
}

// oalloc_meta_length
// file http/oalloc.c line 47
static inline unsigned int oalloc_meta_length(struct header *hd)
{
  return (unsigned int)(sizeof(struct header) /*16ul*/  + sizeof(struct free_desc) /*16ul*/  * hd->nr_free);
}

// oalloc_new_finish
// file http/http.h line 152
signed int oalloc_new_finish(unsigned int vid, unsigned long int start, unsigned long int count)
{
  struct sd_inode *inode;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$1;
  signed int ret;
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid$link4(vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(!(ret == 0x00))
  {
    unsigned long int return_value_vid_to_vdi_oid$3;
    return_value_vid_to_vdi_oid$3=vid_to_vdi_oid$link4(vid);
    const char *return_value_sd_strerror$4;
    return_value_sd_strerror$4=sd_strerror$link9(ret);
    log_write(3, "oalloc_new_finish", 177, "failed to read inode, %lx, %s", return_value_vid_to_vdi_oid$3, return_value_sd_strerror$4);
    goto out;
  }

  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= count); i = i + 1ul)
    sd_inode_set_vid(sheep_bnode_writer, sheep_bnode_reader, inode, (unsigned int)(start + i), vid);
  ret=sd_inode_write(sheep_bnode_writer, inode, 0, (_Bool)0, (_Bool)0);
  if(!(ret == 0x00))
  {
    unsigned long int return_value_vid_to_vdi_oid$5;
    return_value_vid_to_vdi_oid$5=vid_to_vdi_oid$link4(vid);
    const char *return_value_sd_strerror$6;
    return_value_sd_strerror$6=sd_strerror$link9(ret);
    log_write(3, "oalloc_new_finish", 187, "failed to update inode, %lx, %s", return_value_vid_to_vdi_oid$5, return_value_sd_strerror$6);
    goto out;
  }


out:
  ;
  free((void *)inode);
  return ret;
}

// oalloc_new_prepare
// file http/http.h line 151
signed int oalloc_new_prepare(unsigned int vid, unsigned long int *start, unsigned long int count)
{
  char *meta;
  void *return_value_xvalloc$1;
  return_value_xvalloc$1=xvalloc(1UL << 22);
  meta = (char *)return_value_xvalloc$1;
  struct header *hd;
  struct free_desc *fd;
  unsigned long int oid;
  oid=vid_to_data_oid$link3(vid, (unsigned long int)0);
  unsigned long int i;
  signed int ret;
  ret=sd_read_object(oid, meta, (unsigned int)(1UL << 22), (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$2;
    return_value_sd_strerror$2=sd_strerror$link9(ret);
    log_write(3, "oalloc_new_prepare", 128, "failed to read meta %lx, %s", oid, return_value_sd_strerror$2);
    goto out;
  }

  hd = (struct header *)meta;
  unsigned int return_value_oalloc_meta_length$3;
  return_value_oalloc_meta_length$3=oalloc_meta_length(hd);
  fd = (struct free_desc *)(meta + (signed long int)return_value_oalloc_meta_length$3) - (signed long int)1;
  if(sd_log_level == 7)
    log_write(7, "oalloc_new_prepare", 134, "used %lu, nr_free %lu", hd->used, hd->nr_free);

  i = (unsigned long int)0;
  for( ; !(i >= hd->nr_free); fd = fd - 1l)
  {
    if(sd_log_level == 7)
      log_write(7, "oalloc_new_prepare", 137, "start %lu, count %lu", fd->start, fd->count);

    if(!(count >= fd->count))
      break;

    i = i + 1ul;
  }
  unsigned int return_value_oalloc_meta_length$4;
  const char *return_value_sd_strerror$5;
  if(i == hd->nr_free)
    ret = 0x15;

  else
  {
    *start = fd->start;
    fd->start = fd->start + count;
    fd->count = fd->count - count;
    hd->used = hd->used + count;
    return_value_oalloc_meta_length$4=oalloc_meta_length(hd);
    ret=sd_write_object(oid, meta, return_value_oalloc_meta_length$4, (unsigned long int)0, (_Bool)0);
    if(!(ret == 0x00))
    {
      return_value_sd_strerror$5=sd_strerror$link9(ret);
      log_write(3, "oalloc_new_prepare", 155, "failed to update meta %lx, %s", oid, return_value_sd_strerror$5);
    }

  }

out:
  ;
  free((void *)meta);
  return ret;
}

// obj_cmp
// file recovery.c line 84
static signed int obj_cmp(const unsigned long int *oid1, const unsigned long int *oid2)
{
  unsigned long int hval1;
  hval1=sd_hash_oid$link2(*oid1);
  unsigned long int hval2;
  hval2=sd_hash_oid$link2(*oid2);
  signed int tmp_statement_expression$1;
  unsigned long int _x = hval1;
  unsigned long int _y = hval2;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// object_cache_cmp
// file object_cache.c line 106
static signed int object_cache_cmp(struct object_cache_entry *a, struct object_cache_entry *b)
{
  signed int tmp_statement_expression$1;
  unsigned long int _x;
  _x=entry_idx(a);
  unsigned long int _y;
  _y=entry_idx(b);
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// object_cache_delete
// file sheep_priv.h line 459
void object_cache_delete(unsigned int vid)
{
  struct object_cache *cache;
  signed int h;
  h=hash((unsigned long int)vid);
  struct object_cache_entry *entry;
  char path[4096l];
  cache=find_object_cache(vid, (_Bool)0);
  struct object_cache_entry *tmp_statement_expression$1;
  struct object_cache_entry *tmp_statement_expression$2;
  struct object_cache_entry *tmp_statement_expression$3;
  if(!(cache == ((struct object_cache *)NULL)))
  {
    sd_write_lock$link1(&hashtable_lock[(signed long int)h]);
    hlist_del(&cache->hash);
    sd_rw_unlock$link1(&hashtable_lock[(signed long int)h]);
    write_lock_cache(cache);
    struct object_cache_entry *__n953;
    const struct list_node *__mptr = (&cache->lru_head)->n.next;
    tmp_statement_expression$1 = (struct object_cache_entry *)((char *)__mptr - (signed long int)72ul);
    entry = tmp_statement_expression$1;
    const struct list_node *object_cache_delete$$1$$1$$2$$__mptr = entry->lru_list.next;
    tmp_statement_expression$2 = (struct object_cache_entry *)((char *)object_cache_delete$$1$$1$$2$$__mptr - (signed long int)72ul);
    __n953 = tmp_statement_expression$2;
    for( ; !(&entry->lru_list == &(&cache->lru_head)->n); __n953 = tmp_statement_expression$3)
    {
      free_cache_entry(entry);
      __uatomic_add((void *)&gcache.capacity, (unsigned long int)-((unsigned long int)(((1UL << 22) / (unsigned long int)1024) / (unsigned long int)1024)), (signed int)sizeof(unsigned int) /*4ul*/ );
      entry = __n953;
      const struct list_node *object_cache_delete$$1$$1$$3$$__mptr = __n953->lru_list.next;
      tmp_statement_expression$3 = (struct object_cache_entry *)((char *)object_cache_delete$$1$$1$$3$$__mptr - (signed long int)72ul);
    }
    unlock_cache(cache);
    sd_destroy_rw_lock(&cache->lock);
    close(cache->push_efd);
    free((void *)cache);
    snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x", (const void *)object_cache_dir, vid);
    rmdir_r(path);
  }

}

// object_cache_flush_and_del
// file sheep_priv.h line 458
signed int object_cache_flush_and_del(struct request *req)
{
  unsigned int vid;
  vid=oid_to_vid$link5(req->rq.$anon0.obj.oid);
  struct object_cache *cache;
  cache=find_object_cache(vid, (_Bool)0);
  signed int return_value_object_cache_flush_and_delete$1;
  if(!(cache == ((struct object_cache *)NULL)))
  {
    return_value_object_cache_flush_and_delete$1=object_cache_flush_and_delete(cache);
    if(return_value_object_cache_flush_and_delete$1 >= 0)
      goto __CPROVER_DUMP_L1;

    return 0x03;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0x00;
  }
}

// object_cache_flush_and_delete
// file object_cache.c line 1001
static signed int object_cache_flush_and_delete(struct object_cache *oc)
{
  struct __dirstream *dir;
  struct dirent *d;
  unsigned int vid = oc->vid;
  unsigned long int idx;
  unsigned long int all = 18446744073709551615UL;
  signed int ret = 0;
  char p[4096l];
  if(sd_log_level == 7)
    log_write(7, "object_cache_flush_and_delete", 1011, "%x", vid);

  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x", (const void *)object_cache_dir, vid);
  dir=opendir(p);
  if(dir == ((struct __dirstream *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "object_cache_flush_and_delete", 1015, "%m");

    ret = -1;
  }

  else
  {
    do
    {
      d=readdir(dir);
      if(d == ((struct dirent *)NULL))
        break;

      signed int return_value_strncmp$1;
      return_value_strncmp$1=strncmp(d->d_name, ".", (unsigned long int)1);
      if(!(return_value_strncmp$1 == 0))
      {
        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(d->d_name + (signed long int)8, ".tmp");
        if(return_value_strcmp$4 == 0)
        {
          if(sd_log_level == 7)
            log_write(7, "object_cache_flush_and_delete", 1024, "try to del %s", (const void *)d->d_name);

          signed int return_value_dirfd$2;
          return_value_dirfd$2=dirfd(dir);
          signed int return_value_unlinkat$3;
          return_value_unlinkat$3=unlinkat(return_value_dirfd$2, d->d_name, 0);
          if(!(return_value_unlinkat$3 >= 0))
            log_write(3, "object_cache_flush_and_delete", 1026, "%m");

          continue;
        }

        idx=strtoull(d->d_name, (char ** restrict )(void *)0, 16);
        if(!(idx == 1ULL))
        {
          signed int return_value_push_cache_object$5;
          return_value_push_cache_object$5=push_cache_object(vid, idx, all, (_Bool)1);
          if(!(return_value_push_cache_object$5 == 0x00))
          {
            ret = -1;
            goto out_close_dir;
          }

        }

      }

    }
    while((_Bool)1);
    object_cache_delete(vid);

  out_close_dir:
    ;
    closedir(dir);
  }

out:
  ;
  return ret;
}

// object_cache_flush_vdi
// file sheep_priv.h line 457
signed int object_cache_flush_vdi(unsigned int vid)
{
  struct object_cache *cache;
  signed int ret;
  cache=find_object_cache(vid, (_Bool)0);
  if(cache == ((struct object_cache *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "object_cache_flush_vdi", 1185, "%x not found", vid);

    return 0x00;
  }

  else
  {
    sd_mutex_lock$link3(&cache->push_mutex);
    ret=object_cache_push(cache);
    sd_mutex_unlock$link3(&cache->push_mutex);
    return ret;
  }
}

// object_cache_format
// file sheep_priv.h line 448
void object_cache_format(void)
{
  struct object_cache *cache;
  struct hlist_node *node;
  signed int i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct object_cache *tmp_statement_expression$2;
  for( ; !(i >= 32); i = i + 1)
  {
    struct hlist_head *head = cache_hashtable + (signed long int)i;
    struct hlist_node *__n1365;
    node = head->first;
    __n1365 = (struct hlist_node *)(void *)0;
    do
    {
      if(!(node == ((struct hlist_node *)NULL)))
      {
        __n1365 = node->next;
        tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        const struct hlist_node *__mptr = node;
        tmp_statement_expression$2 = (struct object_cache *)((char *)__mptr - (signed long int)16ul);
        cache = tmp_statement_expression$2;
        tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      object_cache_delete(cache->vid);
      node = __n1365;
    }
    while((_Bool)1);
  }
  unsigned int _v;
  volatile unsigned int tmp_statement_expression$4;
  *((volatile unsigned int *)&(*(&gcache.capacity))) = (volatile unsigned int)0;
  tmp_statement_expression$4 = *((volatile unsigned int *)&(*(&gcache.capacity)));
  _v = tmp_statement_expression$4;
  asm("" :  :  : "memory");
  _v = _v;
}

// object_cache_get_info
// file sheep_priv.h line 462
signed int object_cache_get_info(struct object_cache_info *info)
{
  signed int j = 0;
  memset((void *)info, 0, sizeof(struct object_cache_info) /*12312ul*/ );
  info->used = (unsigned long int)gcache.capacity * (unsigned long int)1024 * (unsigned long int)1024;
  info->size = (unsigned long int)sys->object_cache_size * (unsigned long int)1024 * (unsigned long int)1024;
  signed int i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct object_cache *tmp_statement_expression$2;
  for( ; !(i >= 32); i = i + 1)
  {
    struct hlist_head *head = cache_hashtable + (signed long int)i;
    struct object_cache *cache;
    struct hlist_node *node;
    sd_read_lock$link1(&hashtable_lock[(signed long int)i]);
    struct hlist_node *__n1386;
    node = head->first;
    __n1386 = (struct hlist_node *)(void *)0;
    do
    {
      if(!(node == ((struct hlist_node *)NULL)))
      {
        __n1386 = node->next;
        tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        const struct hlist_node *__mptr = node;
        tmp_statement_expression$2 = (struct object_cache *)((char *)__mptr - (signed long int)16ul);
        cache = tmp_statement_expression$2;
        tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      read_lock_cache(cache);
      info->caches[(signed long int)j].vid = cache->vid;
      info->caches[(signed long int)j].dirty = cache->dirty_count;
      info->caches[(signed long int)j].total = cache->total_count;
      j = j + 1;
      unlock_cache(cache);
      node = __n1386;
    }
    while((_Bool)1);
    sd_rw_unlock$link1(&hashtable_lock[(signed long int)i]);
  }
  info->count = j;
  info->directio = (unsigned char)sys->object_cache_directio;
  return (signed int)sizeof(struct object_cache_info) /*12312ul*/ ;
}

// object_cache_handle_request
// file sheep_priv.h line 452
signed int object_cache_handle_request(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  unsigned long int oid = req->rq.$anon0.obj.oid;
  unsigned int vid;
  vid=oid_to_vid$link5(oid);
  unsigned long int idx;
  idx=object_cache_oid_to_idx(oid);
  struct object_cache *cache;
  struct object_cache_entry *entry;
  signed int ret;
  _Bool create = (_Bool)0;
  if(sd_log_level == 7)
    log_write(7, "object_cache_handle_request", 1095, "%08lx, len %u, off %u", idx, hdr->data_length, hdr->$anon0.obj.offset);

  cache=find_object_cache(vid, (_Bool)1);
  if((signed int)req->rq.opcode == 0x01)
    create = (_Bool)1;

  do
  {

  retry:
    ;
    ret=object_cache_lookup(cache, idx, create, (_Bool)((signed int)hdr->flags & 0x04));
    switch(ret)
    {
      case 0x87:
      {
        ret=object_cache_pull(cache, idx);
        if(!(ret == 0x00))
          return ret;

        goto __CPROVER_DUMP_L6;
      }
      case 0x03:
        return ret;
      default:
      {

      __CPROVER_DUMP_L6:
        ;
        entry=get_cache_entry_from(cache, idx);
        if(!(entry == ((struct object_cache_entry *)NULL)))
          goto __CPROVER_DUMP_L8;

        if(sd_log_level == 7)
          log_write(7, "object_cache_handle_request", 1116, "retry oid %lx", oid);

        pthread_yield();
      }
    }
  }
  while((_Bool)1);

__CPROVER_DUMP_L8:
  ;
  if(!((0x01 & (signed int)hdr->flags) == 0))
  {
    ret=write_cache_object(entry, req->data, (unsigned long int)hdr->data_length, (signed long int)hdr->$anon0.obj.offset, create, (_Bool)((signed int)hdr->flags & 0x04));
    if(!(ret == 0x00))
      goto err;

  }

  else
  {
    ret=read_cache_object(entry, req->data, (unsigned long int)hdr->data_length, (signed long int)hdr->$anon0.obj.offset);
    if(ret == 0x00)
      req->rp.data_length = hdr->data_length;

  }

err:
  ;
  put_cache_entry(entry);
  return ret;
}

// object_cache_init
// file sheep_priv.h line 460
signed int object_cache_init(const char *p)
{
  signed int ret = 0;
  struct strbuf buf = { .alloc=(unsigned long int)0, .len=(unsigned long int)0, .eof=0,
    .buf=(char *)(void *)0 };
  strbuf_addstr(&buf, p);
  signed int return_value_xmkdir$1;
  return_value_xmkdir$1=xmkdir(buf.buf, sd_def_dmode);
  signed int return_value_xmkdir$2;
  volatile unsigned int tmp_statement_expression$3;
  if(!(return_value_xmkdir$1 >= 0))
  {
    log_write(3, "object_cache_init", 1336, "%s %m", buf.buf);
    ret = -1;
  }

  else
  {
    strbuf_addstr(&buf, "/cache");
    return_value_xmkdir$2=xmkdir(buf.buf, sd_def_dmode);
    if(!(return_value_xmkdir$2 >= 0))
    {
      log_write(3, "object_cache_init", 1342, "%s %m", buf.buf);
      ret = -1;
    }

    else
    {
      strbuf_copyout(&buf, (void *)object_cache_dir, sizeof(char [4096l]) /*4096ul*/ );
      unsigned int _v;
      *((volatile unsigned int *)&(*(&gcache.capacity))) = (volatile unsigned int)0;
      tmp_statement_expression$3 = *((volatile unsigned int *)&(*(&gcache.capacity)));
      _v = tmp_statement_expression$3;
      asm("" :  :  : "memory");
      _v = _v;
      uatomic_set_false(&gcache.in_reclaim);
      ret=load_cache();
    }
  }

err:
  ;
  strbuf_release(&buf);
  return ret;
}

// object_cache_lookup
// file object_cache.c line 721
static signed int object_cache_lookup(struct object_cache *oc, unsigned long int idx, _Bool create, _Bool writeback)
{
  signed int fd;
  signed int ret;
  signed int flags = def_open_flags;
  char path[4096l];
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x/%016lx", (const void *)object_cache_dir, oc->vid, idx);
  signed int return_value_lookup_path$1;
  unsigned long int return_value_idx_to_oid$2;
  unsigned long int return_value_get_objsize$3;
  if(create == (_Bool)0)
  {
    return_value_lookup_path$1=lookup_path(path);
    return return_value_lookup_path$1;
  }

  else
  {
    flags = flags | 0100 | 01000;
    fd=open(path, flags, sd_def_fmode);
    if(!(fd >= 0))
    {
      if(sd_log_level == 7)
        log_write(7, "object_cache_lookup", 735, "%s, %m", (const void *)path);

      ret = 0x03;
    }

    else
    {
      return_value_idx_to_oid$2=idx_to_oid(oc->vid, idx);
      return_value_get_objsize$3=get_objsize$link2(return_value_idx_to_oid$2);
      ret=prealloc(fd, (unsigned int)return_value_get_objsize$3);
      if(!(ret >= 0))
        ret = 0x03;

      else
      {
        add_to_lru_cache(oc, idx, writeback);
        object_cache_try_to_reclaim(0);
      }

    out_close:
      ;
      close(fd);
    }

  out:
    ;
    return ret;
  }
}

// object_cache_oid_to_idx
// file object_cache.c line 112
static inline unsigned long int object_cache_oid_to_idx(unsigned long int oid)
{
  unsigned long int idx;
  idx=data_oid_to_idx$link1(oid);
  _Bool return_value_is_vdi_obj$2;
  return_value_is_vdi_obj$2=is_vdi_obj$link3(oid);
  _Bool return_value_is_vdi_btree_obj$1;
  if(!(return_value_is_vdi_obj$2 == (_Bool)0))
    idx = idx | 1ULL << 63;

  else
  {
    return_value_is_vdi_btree_obj$1=is_vdi_btree_obj$link3(oid);
    if(!(return_value_is_vdi_btree_obj$1 == (_Bool)0))
      idx = idx | 1UL << 60;

  }
  return idx;
}

// object_cache_pull
// file object_cache.c line 802
static signed int object_cache_pull(struct object_cache *oc, unsigned long int idx)
{
  struct sd_req hdr;
  signed int ret = 0x12;
  unsigned long int oid;
  oid=idx_to_oid(oc->vid, idx);
  unsigned int data_length;
  unsigned long int return_value_get_objsize$1;
  return_value_get_objsize$1=get_objsize$link2(oid);
  data_length = (unsigned int)return_value_get_objsize$1;
  void *buf;
  buf=xvalloc((unsigned long int)data_length);
  sd_init_req$link5(&hdr, (unsigned char)0x02);
  hdr.data_length = data_length;
  hdr.$anon0.obj.oid = oid;
  hdr.$anon0.obj.offset = (unsigned int)0;
  ret=exec_local_req(&hdr, buf);
  if(ret == 0x00)
  {
    if(sd_log_level == 7)
      log_write(7, "object_cache_pull", 819, "oid %lx pulled successfully", oid);

    ret=create_cache_object(oc, idx, buf, (unsigned long int)data_length);
    switch(ret)
    {
      case 0x00:
      {
        add_to_lru_cache(oc, idx, (_Bool)0);
        object_cache_try_to_reclaim(1);
        break;
      }
      case 0x8E:
        ret = 0x00;
    }
  }


err:
  ;
  free(buf);
  return ret;
}

// object_cache_push
// file object_cache.c line 893
static signed int object_cache_push(struct object_cache *oc)
{
  struct object_cache_entry *entry;
  write_lock_cache(oc);
  _Bool return_value_list_empty$1;
  return_value_list_empty$1=list_empty$link1(&oc->dirty_head);
  volatile unsigned int tmp_statement_expression$2;
  volatile unsigned int tmp_statement_expression$3;
  struct object_cache_entry *tmp_statement_expression$4;
  struct object_cache_entry *tmp_statement_expression$5;
  struct object_cache_entry *tmp_statement_expression$6;
  if(!(return_value_list_empty$1 == (_Bool)0))
  {
    unlock_cache(oc);
    return 0x00;
  }

  else
  {
    unsigned int _v;
    asm("" :  :  : "memory");
    tmp_statement_expression$3 = *((volatile unsigned int *)&(*(&oc->dirty_count)));
    *((volatile unsigned int *)&(*(&oc->push_count))) = tmp_statement_expression$3;
    tmp_statement_expression$2 = *((volatile unsigned int *)&(*(&oc->push_count)));
    _v = tmp_statement_expression$2;
    asm("" :  :  : "memory");
    _v = _v;
    struct object_cache_entry *__n904;
    const struct list_node *__mptr = (&oc->dirty_head)->n.next;
    tmp_statement_expression$4 = (struct object_cache_entry *)((char *)__mptr - (signed long int)56ul);
    entry = tmp_statement_expression$4;
    const struct list_node *object_cache_push$$1$$3$$2$$__mptr = entry->dirty_list.next;
    tmp_statement_expression$5 = (struct object_cache_entry *)((char *)object_cache_push$$1$$3$$2$$__mptr - (signed long int)56ul);
    __n904 = tmp_statement_expression$5;
    for( ; !(&entry->dirty_list == &(&oc->dirty_head)->n); __n904 = tmp_statement_expression$6)
    {
      struct push_work *pw;
      get_cache_entry(entry);
      void *return_value_xzalloc$7;
      return_value_xzalloc$7=xzalloc(sizeof(struct push_work) /*48ul*/ );
      pw = (struct push_work *)return_value_xzalloc$7;
      pw->work.fn = do_push_object;
      pw->work.done = push_object_done;
      pw->entry = entry;
      queue_work(sys->oc_push_wqueue, &pw->work);
      del_from_dirty_list(entry);
      entry = __n904;
      const struct list_node *object_cache_push$$1$$3$$3$$__mptr = __n904->dirty_list.next;
      tmp_statement_expression$6 = (struct object_cache_entry *)((char *)object_cache_push$$1$$3$$3$$__mptr - (signed long int)56ul);
    }
    unlock_cache(oc);
    eventfd_xread(oc->push_efd);
    if(sd_log_level == 7)
      log_write(7, "object_cache_push", 919, "%x completed", oc->vid);

    return 0x00;
  }
}

// object_cache_read
// file sheep_priv.h line 455
signed int object_cache_read(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset)
{
  struct object_cache_entry *entry;
  entry=oid_to_entry(oid);
  signed int ret;
  if(sd_log_level == 7)
    log_write(7, "object_cache_read", 1167, "%lx", oid);

  if(entry == ((struct object_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "object_cache_read", 1169, "%lx doesn't exist", oid);

    return 0x87;
  }

  else
  {
    ret=read_cache_object(entry, (void *)data, (unsigned long int)datalen, (signed long int)offset);
    put_cache_entry(entry);
    return ret;
  }
}

// object_cache_remove
// file sheep_priv.h line 461
signed int object_cache_remove(unsigned long int oid)
{
  struct object_cache_entry *entry;
  entry=oid_to_entry(oid);
  struct object_cache *oc;
  signed int ret;
  signed int return_value_refcount_read$1;
  if(entry == ((struct object_cache_entry *)NULL))
    return 0x02;

  else
  {
    oc = entry->oc;
    if(sd_log_level == 7)
      log_write(7, "object_cache_remove", 1304, "%lx", oid);

    do
    {
      return_value_refcount_read$1=refcount_read$link2(&entry->refcnt);
      if(!(return_value_refcount_read$1 >= 2))
        break;

      usleep((unsigned int)100000);
    }
    while((_Bool)1);
    write_lock_cache(oc);
    unsigned long int return_value_entry_idx$2;
    return_value_entry_idx$2=entry_idx(entry);
    ret=remove_cache_object(oc, return_value_entry_idx$2);
    if(!(ret == 0x00))
    {
      unlock_cache(oc);
      return ret;
    }

    else
    {
      free_cache_entry(entry);
      unlock_cache(oc);
      __uatomic_add((void *)&gcache.capacity, (unsigned long int)-((unsigned long int)(((1UL << 22) / (unsigned long int)1024) / (unsigned long int)1024)), (signed int)sizeof(unsigned int) /*4ul*/ );
      return 0x00;
    }
  }
}

// object_cache_try_to_reclaim
// file object_cache.c line 649
static void object_cache_try_to_reclaim(signed int delay)
{
  struct reclaim_work *rw;
  volatile unsigned int tmp_statement_expression$1;
  if(!(sys->object_cache_size == 0u))
  {
    asm("" :  :  : "memory");
    tmp_statement_expression$1 = *((volatile unsigned int *)&(*(&gcache.capacity)));
    if(tmp_statement_expression$1 >= (9u * sys->object_cache_size) / 10u)
    {
      _Bool return_value_uatomic_set_true$2;
      return_value_uatomic_set_true$2=uatomic_set_true$link1(&gcache.in_reclaim);
      if(!(return_value_uatomic_set_true$2 == (_Bool)0))
      {
        void *return_value_xzalloc$3;
        return_value_xzalloc$3=xzalloc(sizeof(struct reclaim_work) /*40ul*/ );
        rw = (struct reclaim_work *)return_value_xzalloc$3;
        rw->delay = delay;
        rw->work.fn = do_reclaim;
        rw->work.done = reclaim_done;
        queue_work(sys->oc_reclaim_wqueue, &rw->work);
      }

    }

  }

}

// object_cache_write
// file sheep_priv.h line 453
signed int object_cache_write(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset, _Bool create)
{
  struct object_cache_entry *entry;
  entry=oid_to_entry(oid);
  signed int ret;
  if(sd_log_level == 7)
    log_write(7, "object_cache_write", 1150, "%lx", oid);

  if(entry == ((struct object_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "object_cache_write", 1152, "%lx doesn't exist", oid);

    return 0x87;
  }

  else
  {
    ret=write_cache_object(entry, (void *)data, (unsigned long int)datalen, (signed long int)offset, create, (_Bool)0);
    put_cache_entry(entry);
    return ret;
  }
}

// object_is_cached
// file sheep_priv.h line 450
_Bool object_is_cached(unsigned long int oid)
{
  unsigned int vid;
  vid=oid_to_vid$link5(oid);
  unsigned long int idx;
  idx=object_cache_oid_to_idx(oid);
  struct object_cache *cache;
  cache=find_object_cache(vid, (_Bool)0);
  if(cache == ((struct object_cache *)NULL))
    return (_Bool)0;

  else
  {
    signed int return_value_object_cache_lookup$1;
    return_value_object_cache_lookup$1=object_cache_lookup(cache, idx, (_Bool)0, (_Bool)0);
    return return_value_object_cache_lookup$1 == 0x00;
  }
}

// object_iterater
// file http/kv.c line 461
static void object_iterater(void *data, enum btree_node_type type, void *arg)
{
  struct sd_extent *ext;
  struct object_iterater_arg *oiarg = (struct object_iterater_arg *)arg;
  struct kv_onode *onode = (struct kv_onode *)(void *)0;
  unsigned long int oid;
  signed int ret;
  if((signed int)type == BTREE_EXT)
  {
    ext = (struct sd_extent *)data;
    if(!(ext->vdi_id == 0u))
    {
      void *return_value_xmalloc$1;
      return_value_xmalloc$1=xmalloc(1UL << 22);
      onode = (struct kv_onode *)return_value_xmalloc$1;
      oid=vid_to_data_oid$link2(ext->vdi_id, (unsigned long int)ext->idx);
      ret=sd_read_object(oid, (char *)onode, (unsigned int)(1UL << 22), (unsigned long int)0);
      if(!(ret == 0x00))
        log_write(3, "object_iterater", 478, "Failed to read data object %lx", oid);

      else
        if(!((signed int)onode->$anon0.$anon0.name[0l] == 0))
        {
          if(!(oiarg->cb == ((void (*)(const char *, void *))NULL)))
            oiarg->cb(onode->$anon0.$anon0.name, oiarg->opaque);

          oiarg->count = oiarg->count + 1u;
        }

    }

  }


out:
  ;
  free((void *)onode);
}

// objlist_cache_cleanup
// file sheep_priv.h line 369
signed int objlist_cache_cleanup(unsigned int vid)
{
  struct objlist_deletion_work *ow;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct objlist_deletion_work) /*40ul*/ );
  ow = (struct objlist_deletion_work *)return_value_xzalloc$1;
  ow->vid = vid;
  ow->work.fn = objlist_deletion_work;
  ow->work.done = objlist_deletion_done;
  queue_work(sys->deletion_wqueue, &ow->work);
  return 0x00;
}

// objlist_cache_cmp
// file object_list_cache.c line 41
static signed int objlist_cache_cmp(struct objlist_cache_entry *a, struct objlist_cache_entry *b)
{
  signed int tmp_statement_expression$1;
  unsigned long int _x = a->oid;
  unsigned long int _y = b->oid;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// objlist_cache_insert
// file object_list_cache.c line 77
signed int objlist_cache_insert(unsigned long int oid)
{
  struct objlist_cache_entry *entry;
  struct objlist_cache_entry *p;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct objlist_cache_entry) /*32ul*/ );
  entry = (struct objlist_cache_entry *)return_value_xzalloc$1;
  entry->oid = oid;
  rb_init_node(&entry->node);
  sd_write_lock$link2(&obj_list_cache.lock);
  p=objlist_cache_rb_insert(&obj_list_cache.root, entry);
  if(!(p == ((struct objlist_cache_entry *)NULL)))
    free((void *)entry);

  else
  {
    obj_list_cache.cache_size = obj_list_cache.cache_size + 1;
    obj_list_cache.tree_version = obj_list_cache.tree_version + 1;
  }
  sd_rw_unlock$link2(&obj_list_cache.lock);
  return 0;
}

// objlist_cache_rb_insert
// file object_list_cache.c line 47
static struct objlist_cache_entry * objlist_cache_rb_insert(struct rb_root *root, struct objlist_cache_entry *new)
{
  struct objlist_cache_entry *tmp_statement_expression$1;
  struct rb_node **__n = &root->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct objlist_cache_entry *__old = (struct objlist_cache_entry *)(void *)0;
  struct objlist_cache_entry *__data;
  struct objlist_cache_entry *tmp_statement_expression$2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression$2 = (struct objlist_cache_entry *)((char *)__mptr - (signed long int)8ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=objlist_cache_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct objlist_cache_entry *)NULL))
  {
    rb_link_node$link4(&new->node, __parent, __n);
    rb_insert_color(&new->node, root);
  }

  tmp_statement_expression$1 = __old;
  return tmp_statement_expression$1;
}

// objlist_cache_rb_remove
// file object_list_cache.c line 53
static signed int objlist_cache_rb_remove(struct rb_root *root, unsigned long int oid)
{
  struct objlist_cache_entry *entry;
  struct objlist_cache_entry key = { .oid=oid, .node={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) } };
  struct objlist_cache_entry *tmp_statement_expression$1;
  struct rb_node *__n = root->rb_node;
  struct objlist_cache_entry *__ret = (struct objlist_cache_entry *)(void *)0;
  struct objlist_cache_entry *__data;
  struct objlist_cache_entry *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct objlist_cache_entry *)((char *)__mptr - (signed long int)8ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=objlist_cache_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  entry = tmp_statement_expression$1;
  if(entry == ((struct objlist_cache_entry *)NULL))
    return -1;

  else
  {
    rb_erase(&entry->node, root);
    free((void *)entry);
    return 0;
  }
}

// objlist_cache_remove
// file sheep_priv.h line 395
void objlist_cache_remove(unsigned long int oid)
{
  sd_write_lock$link2(&obj_list_cache.lock);
  signed int return_value_objlist_cache_rb_remove$1;
  return_value_objlist_cache_rb_remove$1=objlist_cache_rb_remove(&obj_list_cache.root, oid);
  if(return_value_objlist_cache_rb_remove$1 == 0)
  {
    obj_list_cache.cache_size = obj_list_cache.cache_size - 1;
    obj_list_cache.tree_version = obj_list_cache.tree_version + 1;
  }

  sd_rw_unlock$link2(&obj_list_cache.lock);
}

// objlist_deletion_done
// file object_list_cache.c line 172
static void objlist_deletion_done(struct work *work)
{
  struct objlist_deletion_work *ow;
  struct objlist_deletion_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct objlist_deletion_work *)((char *)__mptr - (signed long int)8ul);
  ow = tmp_statement_expression$1;
  free((void *)ow);
}

// objlist_deletion_work
// file object_list_cache.c line 135
static void objlist_deletion_work(struct work *work)
{
  struct objlist_deletion_work *ow;
  struct objlist_deletion_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct objlist_deletion_work *)((char *)__mptr - (signed long int)8ul);
  ow = tmp_statement_expression$1;
  struct objlist_cache_entry *entry;
  unsigned int vid = ow->vid;
  unsigned int entry_vid;
  signed int return_value_vdi_exist$2;
  return_value_vdi_exist$2=vdi_exist(vid);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  struct objlist_cache_entry *tmp_statement_expression$4;
  if(!(return_value_vdi_exist$2 == 0))
  {
    if(sd_log_level == 7)
      log_write(7, "objlist_deletion_work", 151, "VDI (%x) is still in use, can not be deleted", vid);

  }

  else
  {
    sd_write_lock$link2(&obj_list_cache.lock);
    struct rb_node *__p156;
    __p156=rb_first(&obj_list_cache.root);
    struct rb_node *__n156;
    do
    {
      if(!(__p156 == ((struct rb_node *)NULL)))
      {
        __n156=rb_next(__p156);
        tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        const struct rb_node *objlist_deletion_work$$1$$3$$1$$__mptr = __p156;
        tmp_statement_expression$4 = (struct objlist_cache_entry *)((char *)objlist_deletion_work$$1$$3$$1$$__mptr - (signed long int)8ul);
        entry = tmp_statement_expression$4;
        tmp_if_expr$5 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      entry_vid=oid_to_vid$link6(entry->oid);
      if(entry_vid == vid)
      {
        _Bool return_value_is_vdi_obj$6;
        return_value_is_vdi_obj$6=is_vdi_obj$link4(entry->oid);
        if(return_value_is_vdi_obj$6 == (_Bool)0)
        {
          if(sd_log_level == 7)
            log_write(7, "objlist_deletion_work", 165, "delete object entry %lx", entry->oid);

          rb_erase(&entry->node, &obj_list_cache.root);
          free((void *)entry);
        }

      }

      __p156 = __n156;
    }
    while((_Bool)1);
    sd_rw_unlock$link2(&obj_list_cache.lock);
  }
}

// oid_cmp
// file ../include/sheep.h line 181
static inline signed int oid_cmp(const unsigned long int *oid1, const unsigned long int *oid2)
{
  signed int tmp_statement_expression$1;
  unsigned long int _x = *oid1;
  unsigned long int _y = *oid2;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// oid_in_prio_oids
// file recovery.c line 742
static inline _Bool oid_in_prio_oids(struct recovery_info *rinfo, unsigned long int oid)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= rinfo->nr_prio_oids); i = i + 1ul)
    if(rinfo->prio_oids[(signed long int)i] == oid)
      return (_Bool)1;

  return (_Bool)0;
}

// oid_in_recovery
// file sheep_priv.h line 372
_Bool oid_in_recovery(unsigned long int oid)
{
  struct recovery_info *rinfo;
  struct recovery_info *tmp_statement_expression$1 = current_rinfo.__val;
  rinfo = tmp_statement_expression$1;
  struct vnode_info *cur;
  _Bool return_value_node_in_recovery$2;
  return_value_node_in_recovery$2=node_in_recovery();
  struct recovery_info * volatile tmp_statement_expression$4;
  unsigned long int *tmp_statement_expression$5;
  unsigned long int *tmp_statement_expression$7;
  if(return_value_node_in_recovery$2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    cur = rinfo->cur_vinfo;
    unsigned char return_value_local_node_copy_index$3;
    return_value_local_node_copy_index$3=local_node_copy_index(cur, oid);
    _Bool return_value;
    return_value=sd_store->exist(oid, return_value_local_node_copy_index$3);
    if(!(return_value == (_Bool)0))
    {
      if(sd_log_level == 7)
        log_write(7, "oid_in_recovery", 586, "the object %lx is already recoverd", oid);

      return (_Bool)0;
    }

    else
    {
      asm("" :  :  : "memory");
      tmp_statement_expression$4 = *((struct recovery_info * volatile *)&(*(&next_rinfo)));
      if(!(tmp_statement_expression$4 == ((struct recovery_info *)NULL)))
        return (_Bool)1;

      else
      {
        if((signed int)rinfo->state == RW_PREPARE_LIST)
        {
          unsigned long int *__ret = (unsigned long int *)(void *)0;
          if(rinfo->done >= 1ul)
          {
            unsigned long int __n = rinfo->done;
            void *return_value_lfind$6;
            return_value_lfind$6=lfind((const void *)&oid, (const void *)rinfo->oids, &__n, sizeof(unsigned long int) /*8ul*/ , (signed int (*)(const void *, const void *))oid_cmp);
            __ret = (unsigned long int *)return_value_lfind$6;
          }

          tmp_statement_expression$5 = __ret;
          if(!(tmp_statement_expression$5 == ((unsigned long int *)NULL)))
          {
            if(sd_log_level == 7)
              log_write(7, "oid_in_recovery", 603, "%lx has been already recovered", oid);

            return (_Bool)0;
          }

          if(rinfo->oids[(signed long int)rinfo->done] == oid)
            return (_Bool)1;

          unsigned long int *oid_in_recovery$$1$$4$$4$$__ret = (unsigned long int *)(void *)0;
          if(rinfo->count + -(1ul + rinfo->done) >= 1ul)
          {
            unsigned long int oid_in_recovery$$1$$4$$4$$1$$__n = rinfo->count - (rinfo->done + (unsigned long int)1);
            void *return_value_lfind$8;
            return_value_lfind$8=lfind((const void *)&oid, (const void *)(rinfo->oids + (signed long int)rinfo->done + (signed long int)1), &oid_in_recovery$$1$$4$$4$$1$$__n, sizeof(unsigned long int) /*8ul*/ , (signed int (*)(const void *, const void *))oid_cmp);
            oid_in_recovery$$1$$4$$4$$__ret = (unsigned long int *)return_value_lfind$8;
          }

          tmp_statement_expression$7 = oid_in_recovery$$1$$4$$4$$__ret;
          if(tmp_statement_expression$7 == ((unsigned long int *)NULL))
          {
            if(sd_log_level == 7)
              log_write(7, "oid_in_recovery", 631, "%lx is not in the recovery list", oid);

            return (_Bool)0;
            if(sd_log_level == 7)
              log_write(7, "oid_in_recovery", 634, "the object %lx is already recoverd", oid);

            return (_Bool)0;
          }

        }

        prepare_schedule_oid(oid);
        return (_Bool)1;
      }
    }
  }
}

// oid_is_readonly
// file sheep_priv.h line 299
_Bool oid_is_readonly(unsigned long int oid)
{
  _Bool return_value_is_data_obj$1;
  return_value_is_data_obj$1=is_data_obj(oid);
  if(return_value_is_data_obj$1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    unsigned int return_value_oid_to_vid$2;
    return_value_oid_to_vid$2=oid_to_vid$link2(oid);
    _Bool return_value_vid_is_snapshot$3;
    return_value_vid_is_snapshot$3=vid_is_snapshot(return_value_oid_to_vid$2);
    return return_value_vid_is_snapshot$3;
  }
}

// oid_stale
// file plain_store.c line 449
static _Bool oid_stale(unsigned long int oid, signed int ec_index, struct vnode_info *vinfo)
{
  unsigned int i;
  unsigned int nr_copies;
  struct sd_vnode *v;
  _Bool ret = (_Bool)1;
  struct sd_vnode *obj_vnodes[31l];
  signed int return_value_get_obj_copy_number$1;
  return_value_get_obj_copy_number$1=get_obj_copy_number(oid, vinfo->nr_zones);
  nr_copies = (unsigned int)return_value_get_obj_copy_number$1;
  oid_to_vnodes$link3(oid, &vinfo->vroot, (signed int)nr_copies, obj_vnodes);
  i = (unsigned int)0;
  for( ; !(i >= nr_copies); i = i + 1u)
  {
    v = obj_vnodes[(signed long int)i];
    _Bool return_value_vnode_is_local$2;
    return_value_vnode_is_local$2=vnode_is_local$link3(v);
    if(!(return_value_vnode_is_local$2 == (_Bool)0))
    {
      if(!(ec_index >= 2))
      {
        if(i == (unsigned int)ec_index)
          ret = (_Bool)0;

      }

      else
        ret = (_Bool)0;
      break;
    }

  }
  return ret;
}

// oid_to_entry
// file object_cache.c line 985
static struct object_cache_entry * oid_to_entry(unsigned long int oid)
{
  unsigned int vid;
  vid=oid_to_vid$link5(oid);
  unsigned long int idx;
  idx=object_cache_oid_to_idx(oid);
  struct object_cache *cache;
  struct object_cache_entry *entry;
  cache=find_object_cache(vid, (_Bool)0);
  entry=get_cache_entry_from(cache, idx);
  if(entry == ((struct object_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "oid_to_entry", 995, "%lx doesn't exist", oid);

    return (struct object_cache_entry *)(void *)0;
  }

  else
    return entry;
}

// oid_to_first_vnode
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode(unsigned long int oid, struct rb_root *root)
{
  struct sd_vnode dummy;
  unsigned long int return_value_sd_hash_oid$1;
  return_value_sd_hash_oid$1=sd_hash_oid(oid);
  dummy = (struct sd_vnode){ .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .node=((struct sd_node *)NULL),
    .hash=return_value_sd_hash_oid$1 };
  struct sd_vnode *tmp_statement_expression$2;
  struct rb_node *__n = root->rb_node;
  struct sd_vnode *__ret = (struct sd_vnode *)(void *)0;
  struct sd_vnode *__data;
  struct sd_vnode *tmp_statement_expression$3;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$3 = (struct sd_vnode *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$3;
    signed int __cmp;
    __cmp=vnode_cmp$link1(&dummy, __data);
    if(!(__cmp >= 0))
    {
      __ret = __data;
      __n = __n->rb_left;
    }

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  struct sd_vnode *tmp_statement_expression$4;
  if(__ret == ((struct sd_vnode *)NULL))
  {
    if(!(root->rb_node == ((struct rb_node *)NULL)))
    {
      const struct rb_node *oid_to_first_vnode$$1$$1$$2$$__mptr;
      oid_to_first_vnode$$1$$1$$2$$__mptr=rb_first(root);
      tmp_statement_expression$4 = (struct sd_vnode *)((char *)oid_to_first_vnode$$1$$1$$2$$__mptr - (signed long int)0ul);
      __ret = tmp_statement_expression$4;
    }

  }

  tmp_statement_expression$2 = __ret;
  return tmp_statement_expression$2;
}

// oid_to_first_vnode$link1
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode$link1(unsigned long int oid$link1, struct rb_root *root$link1)
{
  struct sd_vnode dummy$link1;
  unsigned long int return_value_sd_hash_oid$1$link1;
  return_value_sd_hash_oid$1$link1=sd_hash_oid$link1(oid$link1);
  dummy$link1 = (struct sd_vnode){ .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .node=((struct sd_node *)NULL),
    .hash=return_value_sd_hash_oid$1$link1 };
  struct sd_vnode *tmp_statement_expression$2$link1;
  struct rb_node *__n$link1 = root$link1->rb_node;
  struct sd_vnode *__ret$link1 = (struct sd_vnode *)(void *)0;
  struct sd_vnode *__data$link1;
  struct sd_vnode *tmp_statement_expression$3$link1;
  while(!(__n$link1 == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr$link1 = __n$link1;
    tmp_statement_expression$3$link1 = (struct sd_vnode *)((char *)__mptr$link1 - (signed long int)0ul);
    __data$link1 = tmp_statement_expression$3$link1;
    signed int __cmp$link1;
    __cmp$link1=vnode_cmp$link2(&dummy$link1, __data$link1);
    if(!(__cmp$link1 >= 0))
    {
      __ret$link1 = __data$link1;
      __n$link1 = __n$link1->rb_left;
    }

    else
      if(__cmp$link1 >= 1)
        __n$link1 = __n$link1->rb_right;

      else
      {
        __ret$link1 = __data$link1;
        break;
      }
  }
  struct sd_vnode *tmp_statement_expression$4$link1;
  if(__ret$link1 == ((struct sd_vnode *)NULL))
  {
    if(!(root$link1->rb_node == ((struct rb_node *)NULL)))
    {
      const struct rb_node *oid_to_first_vnode$$1$$1$$2$$__mptr$link1;
      oid_to_first_vnode$$1$$1$$2$$__mptr$link1=rb_first(root$link1);
      tmp_statement_expression$4$link1 = (struct sd_vnode *)((char *)oid_to_first_vnode$$1$$1$$2$$__mptr$link1 - (signed long int)0ul);
      __ret$link1 = tmp_statement_expression$4$link1;
    }

  }

  tmp_statement_expression$2$link1 = __ret$link1;
  return tmp_statement_expression$2$link1;
}

// oid_to_first_vnode$link2
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode$link2(unsigned long int oid$link2, struct rb_root *root$link2)
{
  struct sd_vnode dummy$link2;
  unsigned long int return_value_sd_hash_oid$1$link2;
  return_value_sd_hash_oid$1$link2=sd_hash_oid$link2(oid$link2);
  dummy$link2 = (struct sd_vnode){ .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .node=((struct sd_node *)NULL),
    .hash=return_value_sd_hash_oid$1$link2 };
  struct sd_vnode *tmp_statement_expression$2$link2;
  struct rb_node *__n$link2 = root$link2->rb_node;
  struct sd_vnode *__ret$link2 = (struct sd_vnode *)(void *)0;
  struct sd_vnode *__data$link2;
  struct sd_vnode *tmp_statement_expression$3$link2;
  while(!(__n$link2 == ((struct rb_node *)NULL)))
  {
    const struct rb_node *oid_to_first_vnode$$1$$1$$1$$1$$__mptr$link2 = __n$link2;
    tmp_statement_expression$3$link2 = (struct sd_vnode *)((char *)oid_to_first_vnode$$1$$1$$1$$1$$__mptr$link2 - (signed long int)0ul);
    __data$link2 = tmp_statement_expression$3$link2;
    signed int __cmp$link2;
    __cmp$link2=vnode_cmp$link3(&dummy$link2, __data$link2);
    if(!(__cmp$link2 >= 0))
    {
      __ret$link2 = __data$link2;
      __n$link2 = __n$link2->rb_left;
    }

    else
      if(__cmp$link2 >= 1)
        __n$link2 = __n$link2->rb_right;

      else
      {
        __ret$link2 = __data$link2;
        break;
      }
  }
  struct sd_vnode *tmp_statement_expression$4$link2;
  if(__ret$link2 == ((struct sd_vnode *)NULL))
  {
    if(!(root$link2->rb_node == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr$link2;
      __mptr$link2=rb_first(root$link2);
      tmp_statement_expression$4$link2 = (struct sd_vnode *)((char *)__mptr$link2 - (signed long int)0ul);
      __ret$link2 = tmp_statement_expression$4$link2;
    }

  }

  tmp_statement_expression$2$link2 = __ret$link2;
  return tmp_statement_expression$2$link2;
}

// oid_to_first_vnode$link3
// file ../include/sheep.h line 58
static inline struct sd_vnode * oid_to_first_vnode$link3(unsigned long int oid$link3, struct rb_root *root$link3)
{
  struct sd_vnode dummy$link3;
  unsigned long int return_value_sd_hash_oid$1$link3;
  return_value_sd_hash_oid$1$link3=sd_hash_oid$link3(oid$link3);
  dummy$link3 = (struct sd_vnode){ .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .node=((struct sd_node *)NULL),
    .hash=return_value_sd_hash_oid$1$link3 };
  struct sd_vnode *tmp_statement_expression$2$link3;
  struct rb_node *__n$link3 = root$link3->rb_node;
  struct sd_vnode *__ret$link3 = (struct sd_vnode *)(void *)0;
  struct sd_vnode *__data$link3;
  struct sd_vnode *tmp_statement_expression$3$link3;
  while(!(__n$link3 == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr$link3 = __n$link3;
    tmp_statement_expression$3$link3 = (struct sd_vnode *)((char *)__mptr$link3 - (signed long int)0ul);
    __data$link3 = tmp_statement_expression$3$link3;
    signed int __cmp$link3;
    __cmp$link3=vnode_cmp$link4(&dummy$link3, __data$link3);
    if(!(__cmp$link3 >= 0))
    {
      __ret$link3 = __data$link3;
      __n$link3 = __n$link3->rb_left;
    }

    else
      if(__cmp$link3 >= 1)
        __n$link3 = __n$link3->rb_right;

      else
      {
        __ret$link3 = __data$link3;
        break;
      }
  }
  struct sd_vnode *tmp_statement_expression$4$link3;
  if(__ret$link3 == ((struct sd_vnode *)NULL))
  {
    if(!(root$link3->rb_node == ((struct rb_node *)NULL)))
    {
      const struct rb_node *oid_to_first_vnode$$1$$1$$2$$__mptr$link3;
      oid_to_first_vnode$$1$$1$$2$$__mptr$link3=rb_first(root$link3);
      tmp_statement_expression$4$link3 = (struct sd_vnode *)((char *)oid_to_first_vnode$$1$$1$$2$$__mptr$link3 - (signed long int)0ul);
      __ret$link3 = tmp_statement_expression$4$link3;
    }

  }

  tmp_statement_expression$2$link3 = __ret$link3;
  return tmp_statement_expression$2$link3;
}

// oid_to_node
// file ../include/sheep.h line 99
static inline struct sd_node * oid_to_node(unsigned long int oid, struct rb_root *root, signed int copy_idx)
{
  struct sd_vnode *vnode;
  vnode=oid_to_vnode(oid, root, copy_idx);
  return vnode->node;
}

// oid_to_nodes
// file ../include/sheep.h line 108
static inline void oid_to_nodes(unsigned long int oid, struct rb_root *root, signed int nr_copies, struct sd_node **nodes)
{
  struct sd_vnode *vnodes[31l];
  oid_to_vnodes$link1(oid, root, nr_copies, vnodes);
  signed int i = 0;
  for( ; !(i >= nr_copies); i = i + 1)
    nodes[(signed long int)i] = vnodes[(signed long int)i]->node;
}

// oid_to_vdisk
// file md.c line 85
static struct vdisk * oid_to_vdisk(unsigned long int oid)
{
  unsigned long int return_value_sd_hash_oid$1;
  return_value_sd_hash_oid$1=sd_hash_oid$link4(oid);
  struct vdisk *return_value_hval_to_vdisk$2;
  return_value_hval_to_vdisk$2=hval_to_vdisk(return_value_sd_hash_oid$1);
  return return_value_hval_to_vdisk$2;
}

// oid_to_vid
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid(unsigned long int oid)
{
  return (unsigned int)((oid & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link1
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link1(unsigned long int oid$link1)
{
  return (unsigned int)((oid$link1 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link2
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link2(unsigned long int oid$link2)
{
  return (unsigned int)((oid$link2 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link3
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link3(unsigned long int oid$link3)
{
  return (unsigned int)((oid$link3 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link4
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link4(unsigned long int oid$link4)
{
  return (unsigned int)((oid$link4 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link5
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link5(unsigned long int oid$link5)
{
  return (unsigned int)((oid$link5 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link6
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link6(unsigned long int oid$link6)
{
  return (unsigned int)((oid$link6 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vid$link7
// file ../include/sheepdog_proto.h line 445
static inline unsigned int oid_to_vid$link7(unsigned long int oid$link7)
{
  return (unsigned int)((oid$link7 & (unsigned long int)0x00FFFFFF00000000) >> 32);
}

// oid_to_vnode
// file ../include/sheep.h line 89
static inline struct sd_vnode * oid_to_vnode(unsigned long int oid, struct rb_root *root, signed int copy_idx)
{
  struct sd_vnode *vnodes[31l];
  oid_to_vnodes$link2(oid, root, copy_idx + 1, vnodes);
  return vnodes[(signed long int)copy_idx];
}

// oid_to_vnodes
// file ../include/sheep.h line 67
static inline void oid_to_vnodes(unsigned long int oid, struct rb_root *root, signed int nr_copies, struct sd_vnode **vnodes)
{
  struct sd_vnode *next;
  next=oid_to_first_vnode(oid, root);
  vnodes[(signed long int)0] = next;
  signed int i = 1;
  struct sd_vnode *tmp_statement_expression$1;
  struct sd_vnode *tmp_statement_expression$2;
  signed int j;
  signed int return_value_same_zone$3;
  for( ; !(i >= nr_copies); i = i + 1)
  {
    do
    {

    next:
      ;
      const struct rb_node *__mptr;
      __mptr=rb_next(&next->rb);
      tmp_statement_expression$1 = (struct sd_vnode *)((char *)__mptr - (signed long int)0ul);
      next = tmp_statement_expression$1;
      if(next == ((struct sd_vnode *)NULL))
      {
        const struct rb_node *oid_to_vnodes$$1$$1$$1$$2$$__mptr;
        oid_to_vnodes$$1$$1$$1$$2$$__mptr=rb_first(root);
        tmp_statement_expression$2 = (struct sd_vnode *)((char *)oid_to_vnodes$$1$$1$$1$$2$$__mptr - (signed long int)0ul);
        next = tmp_statement_expression$2;
      }

      if(next == *vnodes)
      {
        log_write(0, "oid_to_vnodes", 80, "PANIC: can't find a valid vnode");
        abort();
      }

      j = 0;

    __CPROVER_DUMP_L5:
      ;
      if(j >= i)
        goto __CPROVER_DUMP_L6;

      return_value_same_zone$3=same_zone(vnodes[(signed long int)j], next);
    }
    while(!(return_value_same_zone$3 == 0));
    j = j + 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L6:
    ;
    vnodes[(signed long int)i] = next;
  }
}

// oid_to_vnodes$link1
// file ../include/sheep.h line 67
static inline void oid_to_vnodes$link1(unsigned long int oid$link1, struct rb_root *root$link1, signed int nr_copies$link1, struct sd_vnode **vnodes$link1)
{
  struct sd_vnode *next$link1;
  next$link1=oid_to_first_vnode$link1(oid$link1, root$link1);
  vnodes$link1[(signed long int)0] = next$link1;
  signed int i$link1 = 1;
  struct sd_vnode *tmp_statement_expression$1$link1;
  struct sd_vnode *tmp_statement_expression$2$link1;
  signed int j$link1;
  signed int return_value_same_zone$3$link1;
  for( ; !(i$link1 >= nr_copies$link1); i$link1 = i$link1 + 1)
  {
    do
    {

    next:
      ;
      const struct rb_node *__mptr$link1;
      __mptr$link1=rb_next(&next$link1->rb);
      tmp_statement_expression$1$link1 = (struct sd_vnode *)((char *)__mptr$link1 - (signed long int)0ul);
      next$link1 = tmp_statement_expression$1$link1;
      if(next$link1 == ((struct sd_vnode *)NULL))
      {
        const struct rb_node *oid_to_vnodes$$1$$1$$1$$2$$__mptr$link1;
        oid_to_vnodes$$1$$1$$1$$2$$__mptr$link1=rb_first(root$link1);
        tmp_statement_expression$2$link1 = (struct sd_vnode *)((char *)oid_to_vnodes$$1$$1$$1$$2$$__mptr$link1 - (signed long int)0ul);
        next$link1 = tmp_statement_expression$2$link1;
      }

      if(next$link1 == *vnodes$link1)
      {
        log_write(0, "oid_to_vnodes", 80, "PANIC: can't find a valid vnode");
        abort();
      }

      j$link1 = 0;

    __CPROVER_DUMP_L5:
      ;
      if(j$link1 >= i$link1)
        goto __CPROVER_DUMP_L6;

      return_value_same_zone$3$link1=same_zone$link1(vnodes$link1[(signed long int)j$link1], next$link1);
    }
    while(!(return_value_same_zone$3$link1 == 0));
    j$link1 = j$link1 + 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L6:
    ;
    vnodes$link1[(signed long int)i$link1] = next$link1;
  }
}

// oid_to_vnodes$link2
// file ../include/sheep.h line 67
static inline void oid_to_vnodes$link2(unsigned long int oid$link2, struct rb_root *root$link2, signed int nr_copies$link2, struct sd_vnode **vnodes$link2)
{
  struct sd_vnode *next$link2;
  next$link2=oid_to_first_vnode$link2(oid$link2, root$link2);
  vnodes$link2[(signed long int)0] = next$link2;
  signed int i$link2 = 1;
  struct sd_vnode *tmp_statement_expression$1$link2;
  struct sd_vnode *tmp_statement_expression$2$link2;
  signed int j$link2;
  signed int return_value_same_zone$3$link2;
  for( ; !(i$link2 >= nr_copies$link2); i$link2 = i$link2 + 1)
  {
    do
    {

    next:
      ;
      const struct rb_node *__mptr$link2;
      __mptr$link2=rb_next(&next$link2->rb);
      tmp_statement_expression$1$link2 = (struct sd_vnode *)((char *)__mptr$link2 - (signed long int)0ul);
      next$link2 = tmp_statement_expression$1$link2;
      if(next$link2 == ((struct sd_vnode *)NULL))
      {
        const struct rb_node *oid_to_vnodes$$1$$1$$1$$2$$__mptr$link2;
        oid_to_vnodes$$1$$1$$1$$2$$__mptr$link2=rb_first(root$link2);
        tmp_statement_expression$2$link2 = (struct sd_vnode *)((char *)oid_to_vnodes$$1$$1$$1$$2$$__mptr$link2 - (signed long int)0ul);
        next$link2 = tmp_statement_expression$2$link2;
      }

      if(next$link2 == *vnodes$link2)
      {
        log_write(0, "oid_to_vnodes", 80, "PANIC: can't find a valid vnode");
        abort();
      }

      j$link2 = 0;

    __CPROVER_DUMP_L5:
      ;
      if(j$link2 >= i$link2)
        goto __CPROVER_DUMP_L6;

      return_value_same_zone$3$link2=same_zone$link2(vnodes$link2[(signed long int)j$link2], next$link2);
    }
    while(!(return_value_same_zone$3$link2 == 0));
    j$link2 = j$link2 + 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L6:
    ;
    vnodes$link2[(signed long int)i$link2] = next$link2;
  }
}

// oid_to_vnodes$link3
// file ../include/sheep.h line 67
static inline void oid_to_vnodes$link3(unsigned long int oid$link3, struct rb_root *root$link3, signed int nr_copies$link3, struct sd_vnode **vnodes$link3)
{
  struct sd_vnode *next$link3;
  next$link3=oid_to_first_vnode$link3(oid$link3, root$link3);
  vnodes$link3[(signed long int)0] = next$link3;
  signed int i$link3 = 1;
  struct sd_vnode *tmp_statement_expression$1$link3;
  struct sd_vnode *tmp_statement_expression$2$link3;
  signed int j$link3;
  signed int return_value_same_zone$3$link3;
  for( ; !(i$link3 >= nr_copies$link3); i$link3 = i$link3 + 1)
  {
    do
    {

    next:
      ;
      const struct rb_node *__mptr$link3;
      __mptr$link3=rb_next(&next$link3->rb);
      tmp_statement_expression$1$link3 = (struct sd_vnode *)((char *)__mptr$link3 - (signed long int)0ul);
      next$link3 = tmp_statement_expression$1$link3;
      if(next$link3 == ((struct sd_vnode *)NULL))
      {
        const struct rb_node *oid_to_vnodes$$1$$1$$1$$2$$__mptr$link3;
        oid_to_vnodes$$1$$1$$1$$2$$__mptr$link3=rb_first(root$link3);
        tmp_statement_expression$2$link3 = (struct sd_vnode *)((char *)oid_to_vnodes$$1$$1$$1$$2$$__mptr$link3 - (signed long int)0ul);
        next$link3 = tmp_statement_expression$2$link3;
      }

      if(next$link3 == *vnodes$link3)
      {
        log_write(0, "oid_to_vnodes", 80, "PANIC: can't find a valid vnode");
        abort();
      }

      j$link3 = 0;

    __CPROVER_DUMP_L5:
      ;
      if(j$link3 >= i$link3)
        goto __CPROVER_DUMP_L6;

      return_value_same_zone$3$link3=same_zone$link3(vnodes$link3[(signed long int)j$link3], next$link3);
    }
    while(!(return_value_same_zone$3$link3 == 0));
    j$link3 = j$link3 + 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L6:
    ;
    vnodes$link3[(signed long int)i$link3] = next$link3;
  }
}

// onode_create
// file http/kv.c line 800
static signed int onode_create(struct kv_onode *onode, unsigned int bucket_vid)
{
  struct sd_inode *inode;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$1;
  unsigned int tmp_vid;
  unsigned int idx;
  unsigned long int hval;
  unsigned long int i;
  signed int ret;
  _Bool create = (_Bool)1;
  sys->cdrv->lock((unsigned long int)bucket_vid);
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid$link3(bucket_vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$3;
    return_value_sd_strerror$3=sd_strerror$link8(ret);
    log_write(3, "onode_create", 813, "failed to read %x %s", bucket_vid, return_value_sd_strerror$3);
  }

  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(onode->$anon0.$anon0.name);
  hval=sd_hash$link2((const void *)onode->$anon0.$anon0.name, return_value_strlen$4);
  i = (unsigned long int)0;
  if(!(i >= 4294967296ull))
  {
    idx = (unsigned int)((hval + i) % (1ULL << 32));
    tmp_vid=sd_inode_get_vid(sheep_bnode_reader, inode, idx);
    if(!(tmp_vid == 0u))
    {
      unsigned long int oid;
      oid=vid_to_data_oid$link2(bucket_vid, (unsigned long int)idx);
      char name[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      ret=sd_read_object(oid, name, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , (unsigned long int)0);
      if((signed int)name[0l] == 0)
        create = (_Bool)0;

    }

    i = i + 1ul;
  }

  if(i == 4294967296ull)
    ret = 0x15;

  else
  {

  create:
    ;
    ret=onode_do_create(onode, inode, idx, create);
  }

out:
  ;
  free((void *)inode);
  sys->cdrv->unlock((unsigned long int)bucket_vid);
  return ret;
}

// onode_delete
// file http/kv.c line 1008
static signed int onode_delete(struct kv_onode *onode)
{
  char name[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int ret;
  ret=sd_write_object(onode->$anon0.$anon0.oid, name, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , (unsigned long int)0, (_Bool)0);
  if(!(ret == 0x00))
  {
    log_write(3, "onode_delete", 1015, "failed to zero onode for %s", (const void *)onode->$anon0.$anon0.name);
    return ret;
  }

  else
  {
    ret=onode_free_data(onode);
    if(!(ret == 0x00))
      log_write(3, "onode_delete", 1021, "failed to free data for %s", (const void *)onode->$anon0.$anon0.name);

    return 0x00;
  }
}

// onode_do_create
// file http/kv.c line 766
static signed int onode_do_create(struct kv_onode *onode, struct sd_inode *inode, unsigned int idx, _Bool create)
{
  unsigned int vid = inode->vdi_id;
  unsigned long int oid;
  oid=vid_to_data_oid$link2(vid, (unsigned long int)idx);
  unsigned long int len;
  signed int ret;
  onode->$anon0.$anon0.oid = oid;
  if(!(onode->$anon0.$anon0.inlined == 0))
    len = onode->$anon0.$anon0.size;

  else
    len = sizeof(struct onode_extent) /*16ul*/  * (unsigned long int)onode->$anon0.$anon0.nr_extent;
  ret=sd_write_object(oid, (char *)onode, (unsigned int)((unsigned long int)(1U << 12) + len), (unsigned long int)0, create);
  if(!(ret == 0x00))
    log_write(3, "onode_do_create", 782, "failed to create object, %lx", oid);

  else
    if(!(create == (_Bool)0))
    {
      sd_inode_set_vid(sheep_bnode_writer, sheep_bnode_reader, inode, idx, vid);
      ret=sd_inode_write_vid(sheep_bnode_writer, inode, idx, vid, vid, 0, (_Bool)0, (_Bool)0);
      if(!(ret == 0x00))
      {
        unsigned long int return_value_vid_to_vdi_oid$1;
        return_value_vid_to_vdi_oid$1=vid_to_vdi_oid$link3(vid);
        log_write(3, "onode_do_create", 793, "failed to update inode, %lx", return_value_vid_to_vdi_oid$1);
        goto out;
      }

    }


out:
  ;
  return ret;
}

// onode_free_data
// file http/kv.c line 847
static signed int onode_free_data(struct kv_onode *onode)
{
  unsigned int data_vid = onode->$anon0.$anon0.data_vid;
  signed int ret;
  sys->cdrv->lock((unsigned long int)data_vid);
  ret=oalloc_free(data_vid, onode->$anon1.o_extent[(signed long int)0].start, onode->$anon1.o_extent[(signed long int)0].count);
  sys->cdrv->unlock((unsigned long int)data_vid);
  if(!(ret == 0x00))
    log_write(3, "onode_free_data", 857, "failed to free %s", (const void *)onode->$anon0.$anon0.name);

  return ret;
}

// onode_lookup
// file http/kv.c line 919
static signed int onode_lookup(struct kv_onode *onode, unsigned int ovid, const char *name)
{
  struct sd_inode *inode;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xmalloc$1;
  unsigned int tmp_vid;
  unsigned int idx;
  unsigned long int hval;
  unsigned long int i;
  signed int ret;
  sys->cdrv->lock((unsigned long int)ovid);
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid$link3(ovid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$3;
    return_value_sd_strerror$3=sd_strerror$link8(ret);
    log_write(3, "onode_lookup", 931, "failed to read %x %s", ovid, return_value_sd_strerror$3);
  }

  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(name);
  hval=sd_hash$link2((const void *)name, return_value_strlen$4);
  i = (unsigned long int)0;
  if(!(i >= 4294967296ull))
  {
    idx = (unsigned int)((hval + i) % (1ULL << 32));
    tmp_vid=sd_inode_get_vid(sheep_bnode_reader, inode, idx);
    if(!(tmp_vid == 0u))
    {
      unsigned long int oid;
      oid=vid_to_data_oid$link2(ovid, (unsigned long int)idx);
      ret=sd_read_object(oid, (char *)onode, (unsigned int)sizeof(struct kv_onode) /*4194304ul*/ , (unsigned long int)0);
      signed int return_value_strcmp$5;
      return_value_strcmp$5=strcmp(onode->$anon0.$anon0.name, name);
    }

    else
      ret = 0x02;
    i = i + 1ul;
  }

  if(i == 4294967296ull)
    ret = 0x02;


out:
  ;
  free((void *)inode);
  sys->cdrv->unlock((unsigned long int)ovid);
  return ret;
}

// onode_populate_data
// file http/kv.c line 740
static signed int onode_populate_data(struct kv_onode *onode, struct http_request *req)
{
  signed long int size;
  signed int ret = 0x00;
  _Bool tmp_if_expr$2;
  if(!(req->data_length >= 4190209ul))
  {
    onode->$anon0.$anon0.inlined = (unsigned char)1;
    signed int return_value_http_request_read$1;
    return_value_http_request_read$1=http_request_read(req, (void *)onode->$anon1.data, (signed int)sizeof(unsigned char [4190208l]) /*4190208ul*/ );
    size = (signed long int)return_value_http_request_read$1;
    if(!(size >= 0l))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = req->data_length != (unsigned long int)size ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      log_write(3, "onode_populate_data", 750, "Failed to read from web server for %s", (const void *)onode->$anon0.$anon0.name);
      ret = 0x06;
      goto out;
    }

  }

  else
  {
    ret=onode_populate_extents(onode, req);
    if(!(ret == 0x00))
      goto out;

  }
  onode->$anon0.$anon0.mtime=get_seconds();
  onode->$anon0.$anon0.size = req->data_length;

out:
  ;
  return ret;
}

// onode_populate_extents
// file http/kv.c line 678
static signed int onode_populate_extents(struct kv_onode *onode, struct http_request *req)
{
  signed long int size;
  unsigned long int start = (unsigned long int)0;
  unsigned long int count;
  unsigned long int done = (unsigned long int)0;
  unsigned long int total;
  unsigned long int offset;
  signed int ret;
  char *data_buf = (char *)(void *)0;
  unsigned int data_vid = onode->$anon0.$anon0.data_vid;
  unsigned long int write_buffer_size;
  unsigned long int tmp_if_expr$1;
  if(req->data_length >= 104857601ul)
    tmp_if_expr$1 = (1UL << 22) * (unsigned long int)25;

  else
    tmp_if_expr$1 = req->data_length;
  write_buffer_size = tmp_if_expr$1;
  count = ((req->data_length + (1UL << 22)) - (unsigned long int)1) / (1UL << 22);
  sys->cdrv->lock((unsigned long int)data_vid);
  ret=oalloc_new_prepare(data_vid, &start, count);
  sys->cdrv->unlock((unsigned long int)data_vid);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$2;
    return_value_sd_strerror$2=sd_strerror$link8(ret);
    log_write(3, "onode_populate_extents", 694, "oalloc_new_prepare failed for %s, %s", (const void *)onode->$anon0.$anon0.name, return_value_sd_strerror$2);
  }

  void *return_value_xmalloc$3;
  return_value_xmalloc$3=xmalloc(write_buffer_size);
  data_buf = (char *)return_value_xmalloc$3;
  offset = start * (1UL << 22);
  total = req->data_length;
  if(!(done >= total))
  {
    signed int return_value_http_request_read$4;
    return_value_http_request_read$4=http_request_read(req, (void *)data_buf, (signed int)write_buffer_size);
    size = (signed long int)return_value_http_request_read$4;
    ret=vdi_read_write(data_vid, data_buf, (unsigned long int)size, (signed long int)offset, (_Bool)0);
    if(!(ret == 0x00))
    {
      const char *return_value_sd_strerror$5;
      return_value_sd_strerror$5=sd_strerror$link8(ret);
      log_write(3, "onode_populate_extents", 706, "Failed to write data object for %s, %s", (const void *)onode->$anon0.$anon0.name, return_value_sd_strerror$5);
    }

    done = done + (unsigned long int)size;
    offset = offset + (unsigned long int)size;
  }

  sys->cdrv->lock((unsigned long int)data_vid);
  ret=oalloc_new_finish(data_vid, start, count);
  sys->cdrv->unlock((unsigned long int)data_vid);
  if(!(ret == 0x00))
  {
    const char *return_value_sd_strerror$6;
    return_value_sd_strerror$6=sd_strerror$link8(ret);
    log_write(3, "onode_populate_extents", 718, "oalloc_new_finish failed for %s, %s", (const void *)onode->$anon0.$anon0.name, return_value_sd_strerror$6);
  }

  onode->$anon1.o_extent[(signed long int)0].start = start;
  onode->$anon1.o_extent[(signed long int)0].count = count;
  onode->$anon0.$anon0.nr_extent = (unsigned int)1;

out:
  ;
  free((void *)data_buf);
  return ret;
}

// onode_read_data
// file http/kv.c line 963
static signed int onode_read_data(struct kv_onode *onode, struct http_request *req)
{
  signed int ret;
  unsigned long int off = (unsigned long int)0;
  unsigned long int len = onode->$anon0.$anon0.size;
  _Bool tmp_if_expr$1;
  if(!(req->offset == 0ul))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = req->data_length != 0ul ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    off = req->offset;
    len = req->data_length;
    if(!(onode->$anon0.$anon0.size >= len + off + 18446744073709551615ul))
    {
      if(!(off >= onode->$anon0.$anon0.size))
        len = onode->$anon0.$anon0.size - off;

      else
        len = (unsigned long int)0;
    }

  }

  req->data_length = len;
  signed int return_value_onode_read_extents$2;
  if(len == 0ul)
    return 0x05;

  else
  {
    http_response_header(req, (enum http_status)OK);
    if(onode->$anon0.$anon0.inlined == 0)
    {
      return_value_onode_read_extents$2=onode_read_extents(onode, req);
      return return_value_onode_read_extents$2;
    }

    else
    {
      ret=http_request_write(req, (const void *)(onode->$anon1.data + (signed long int)off), (signed int)len);
      if(!((unsigned long int)ret == len))
        return 0x06;

      else
        return 0x00;
    }
  }
}

// onode_read_extents
// file http/kv.c line 861
static signed int onode_read_extents(struct kv_onode *onode, struct http_request *req)
{
  struct onode_extent *ext;
  unsigned long int size;
  unsigned long int total;
  unsigned long int total_size;
  unsigned long int offset;
  unsigned long int done = (unsigned long int)0;
  unsigned long int i;
  unsigned long int ext_len;
  unsigned long int off = req->offset;
  unsigned long int len = req->data_length;
  signed int ret;
  char *data_buf = (char *)(void *)0;
  unsigned long int read_buffer_size;
  unsigned long int tmp_if_expr$1;
  if(onode->$anon0.$anon0.size >= 104857601ul)
    tmp_if_expr$1 = (1UL << 22) * (unsigned long int)25;

  else
    tmp_if_expr$1 = onode->$anon0.$anon0.size;
  read_buffer_size = tmp_if_expr$1;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc(read_buffer_size);
  data_buf = (char *)return_value_xmalloc$2;
  total_size = len;
  i = (unsigned long int)0;
  unsigned long int tmp_statement_expression$3;
  for( ; !(i >= (unsigned long int)onode->$anon0.$anon0.nr_extent); i = i + 1ul)
  {
    ext = onode->$anon1.o_extent + (signed long int)i;
    ext_len = ext->count * (1UL << 22);
    if(off >= ext_len)
      off = off - ext_len;

    else
    {
      unsigned long int _x = ext_len - off;
      unsigned long int _y = total_size;
      (void)(&_x == &_y);
      tmp_statement_expression$3 = _x < _y ? _x : _y;
      total = tmp_statement_expression$3;
      offset = ext->start * (1UL << 22) + off;
      off = (unsigned long int)0;
      done = (unsigned long int)0;
      for( ; !(done >= total); total_size = total_size - size)
      {
        size = total - done < read_buffer_size ? total - done : read_buffer_size;
        ret=vdi_read_write(onode->$anon0.$anon0.data_vid, data_buf, size, (signed long int)offset, (_Bool)1);
        if(sd_log_level == 7)
          log_write(7, "onode_read_extents", 888, "vdi_read_write size: %lx, offset: %lx", size, offset);

        if(!(ret == 0x00))
        {
          log_write(3, "onode_read_extents", 891, "Failed to read for vid %x", onode->$anon0.$anon0.data_vid);
          goto out;
        }

        http_request_write(req, (const void *)data_buf, (signed int)size);
        done = done + size;
        offset = offset + size;
      }
    }
  }

out:
  ;
  free((void *)data_buf);
  return ret;
}

// op_name
// file sheep_priv.h line 413
const char * op_name(struct sd_op_template *op)
{
  if(op == ((struct sd_op_template *)NULL))
    return "(invalid opcode)";

  else
    return op->name;
}

// option_get_help
// file ../include/option.h line 32
const char * option_get_help(struct sd_option *sd_opts, signed int ch)
{
  struct sd_option *opt = sd_opts;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
    if(opt->ch == ch)
      return opt->help;

  return (const char *)(void *)0;
}

// option_parse
// file ../include/option.h line 33
signed int option_parse(char *arg, const char *delim, struct option_parser *parsers)
{
  char *savep;
  char *opt;
  struct option_parser *iter = (struct option_parser *)(void *)0;
  opt=strtok_r(arg, delim, &savep);
  do
  {
    iter = parsers;
    for( ; !(iter->option == ((const char *)NULL)); iter = iter + 1l)
    {
      signed int len;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(iter->option);
      len = (signed int)return_value_strlen$1;
      signed int return_value_strncmp$2;
      return_value_strncmp$2=strncmp(iter->option, opt, (unsigned long int)len);
      if(return_value_strncmp$2 == 0)
      {
        signed int return_value;
        return_value=iter->parser(opt + (signed long int)len);
        if(!(return_value >= 0))
          return -1;

        break;
      }

    }
    if(iter->option == ((const char *)NULL))
    {
      log_write(3, "option_parse", 121, "invalid option %s", opt);
      return -1;
    }

    opt=strtok_r((char *)(void *)0, delim, &savep);
  }
  while(!(opt == ((char *)NULL)));
  return 0;
}

// option_parse_size
// file ../include/option.h line 34
signed int option_parse_size(const char *value, unsigned long int *ret)
{
  char *postfix;
  double sizef;
  sizef=strtod(value, &postfix);
  if(!((signed int)*postfix == 0))
  {
    if(!((signed int)postfix[1l] == 0))
      goto err;

  }

  switch((signed int)*postfix)
  {
    case 80:

    case 112:
      sizef = sizef * (double)1024;
    case 84:

    case 116:
      sizef = sizef * (double)1024;
    case 71:

    case 103:
      sizef = sizef * (double)1024;
    case 77:

    case 109:
      sizef = sizef * (double)1024;
    case 75:

    case 107:
      sizef = sizef * (double)1024;
    case 98:

    case 0:
    {
      *ret = (unsigned long int)sizef;
      break;
    }
    default:
    {

    err:
      ;
      log_write(3, "option_parse_size", 95, "Invalid size '%s'", value);
      log_write(3, "option_parse_size", 97, "You may use k, M, G, T or P suffixes for kilobytes, megabytes, gigabytes, terabytes and petabytes.");
      return -1;
    }
  }
  return 0;
}

// path_to_disk
// file md.c line 135
static struct disk * path_to_disk(const char *path)
{
  struct disk key = { .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .space=0ul };
  pstrcpy(key.path, (signed int)sizeof(char [4096l]) /*4096ul*/ , path);
  trim_last_slash(key.path);
  struct disk *tmp_statement_expression$1;
  struct rb_node *__n = (&md.root)->rb_node;
  struct disk *__ret = (struct disk *)(void *)0;
  struct disk *__data;
  struct disk *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=disk_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  return tmp_statement_expression$1;
}

// peer_create_and_write_obj
// file ops.c line 976
static signed int peer_create_and_write_obj(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct siocb iocb = { .epoch=0u, .buf=NULL, .length=0u, .offset=0u, .ec_index=0,
    .copy_policy=0 };
  iocb.epoch = hdr->epoch;
  iocb.buf = req->data;
  iocb.length = hdr->data_length;
  iocb.ec_index = hdr->$anon0.obj.ec_index;
  iocb.copy_policy = hdr->$anon0.obj.copy_policy;
  iocb.offset = hdr->$anon0.obj.offset;
  signed int return_value;
  return_value=sd_store->create_and_write(hdr->$anon0.obj.oid, &iocb);
  return return_value;
}

// peer_read_obj
// file sheep_priv.h line 229
signed int peer_read_obj(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct sd_rsp *rsp = &req->rp;
  signed int ret;
  unsigned int epoch = hdr->epoch;
  struct siocb iocb;
  if(!(sys->gateway_only == (_Bool)0))
    return 0x02;

  else
  {
    memset((void *)&iocb, 0, sizeof(struct siocb) /*32ul*/ );
    iocb.epoch = epoch;
    iocb.buf = req->data;
    iocb.length = hdr->data_length;
    iocb.offset = hdr->$anon0.obj.offset;
    iocb.ec_index = hdr->$anon0.obj.ec_index;
    iocb.copy_policy = hdr->$anon0.obj.copy_policy;
    ret=sd_store->read(hdr->$anon0.obj.oid, &iocb);
    if(ret == 0x00)
      rsp->data_length = hdr->data_length;


  out:
    ;
    return ret;
  }
}

// peer_remove_obj
// file ops.c line 923
static signed int peer_remove_obj(struct request *req)
{
  unsigned long int oid = req->rq.$anon0.obj.oid;
  unsigned char ec_index = req->rq.$anon0.obj.ec_index;
  objlist_cache_remove(oid);
  signed int return_value;
  return_value=sd_store->remove_object(oid, ec_index);
  return return_value;
}

// peer_write_obj
// file ops.c line 960
static signed int peer_write_obj(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct siocb iocb = { .epoch=0u, .buf=NULL, .length=0u, .offset=0u, .ec_index=0,
    .copy_policy=0 };
  unsigned long int oid = hdr->$anon0.obj.oid;
  iocb.epoch = hdr->epoch;
  iocb.buf = req->data;
  iocb.length = hdr->data_length;
  iocb.offset = hdr->$anon0.obj.offset;
  iocb.ec_index = hdr->$anon0.obj.ec_index;
  iocb.copy_policy = hdr->$anon0.obj.copy_policy;
  signed int return_value;
  return_value=sd_store->write(oid, &iocb);
  return return_value;
}

// pfd_info_init
// file gateway.c line 350
static inline void pfd_info_init(struct forward_info *fi, struct pfd_info *pi)
{
  signed int i = 0;
  for( ; !(i >= fi->nr_sent); i = i + 1)
    pi->pfds[(signed long int)i] = fi->ent[(signed long int)i].pfd;
  pi->nr = fi->nr_sent;
}

// post_cluster_del_vdi
// file ops.c line 183
static signed int post_cluster_del_vdi(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  unsigned long int vid = (unsigned long int)rsp->$anon0.vdi.vdi_id;
  struct cache_deletion_work *dw;
  signed int ret = (signed int)rsp->$anon0.result;
  if(sys->enable_object_cache == (_Bool)0)
    return ret;

  else
  {
    void *return_value_xzalloc$1;
    return_value_xzalloc$1=xzalloc(sizeof(struct cache_deletion_work) /*40ul*/ );
    dw = (struct cache_deletion_work *)return_value_xzalloc$1;
    dw->vid = (unsigned int)vid;
    dw->work.fn = cache_delete_work;
    dw->work.done = cache_delete_done;
    queue_work(sys->deletion_wqueue, &dw->work);
    return ret;
  }
}

// post_cluster_new_vdi
// file ops.c line 121
static signed int post_cluster_new_vdi(struct sd_req *req, struct sd_rsp *rsp, void *data)
{
  unsigned long int nr = (unsigned long int)rsp->$anon0.vdi.vdi_id;
  signed int ret = (signed int)rsp->$anon0.result;
  if(sd_log_level == 7)
    log_write(7, "post_cluster_new_vdi", 127, "done %d %lx", ret, nr);

  if(ret == 0x00)
    atomic_set_bit$link1((signed int)nr, sys->vdi_inuse);

  return ret;
}

// prealloc
// file sheep_priv.h line 392
signed int prealloc(signed int fd, unsigned int size)
{
  signed int ret;
  ret=xfallocate(fd, 0, (signed long int)0, (signed long int)size);
  signed int *return_value___errno_location$1;
  if(!(ret >= 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 38))
    {
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 95))
      {
        log_write(3, "prealloc", 325, "failed to preallocate space, %m");
        return ret;
      }

    }

    signed int return_value_xftruncate$3;
    return_value_xftruncate$3=xftruncate(fd, (signed long int)size);
    return return_value_xftruncate$3;
  }

  return 0;
}

// prepare_cluster_msg
// file group.c line 198
static struct vdi_op_message * prepare_cluster_msg(struct request *req, unsigned long int *sizep)
{
  struct vdi_op_message *msg;
  unsigned long int size;
  _Bool return_value_has_process_main$1;
  return_value_has_process_main$1=has_process_main(req->op);
  _Bool tmp_if_expr$2;
  if(!(return_value_has_process_main$1 == (_Bool)0))
    tmp_if_expr$2 = ((signed int)req->rq.flags & 0x01) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
    size = sizeof(struct vdi_op_message) /*96ul*/  + (unsigned long int)req->rq.data_length;

  else
    size = sizeof(struct vdi_op_message) /*96ul*/  + (unsigned long int)req->rp.data_length;
  void *return_value_xzalloc$3;
  return_value_xzalloc$3=xzalloc(size);
  msg = (struct vdi_op_message *)return_value_xzalloc$3;
  memcpy((void *)&msg->req, (const void *)&req->rq, sizeof(struct sd_req) /*48ul*/ );
  memcpy((void *)&msg->rsp, (const void *)&req->rp, sizeof(struct sd_rsp) /*48ul*/ );
  _Bool return_value_has_process_main$4;
  return_value_has_process_main$4=has_process_main(req->op);
  if(!(return_value_has_process_main$4 == (_Bool)0))
  {
    if(size >= 97ul)
      memcpy((void *)msg->data, req->data, size - sizeof(struct vdi_op_message) /*96ul*/ );

  }

  *sizep = size;
  return msg;
}

// prepare_erasure_requests
// file gateway.c line 107
static struct req_iter * prepare_erasure_requests(struct request *req, signed int *nr)
{
  unsigned int len = req->rq.data_length;
  unsigned long int off = (unsigned long int)req->rq.$anon0.obj.offset;
  signed int opcode = (signed int)req->rq.opcode;
  signed int start = (signed int)(off / (unsigned long int)1024);
  signed int end = (signed int)(((off + (unsigned long int)len + (unsigned long int)1024) - (unsigned long int)1) / (unsigned long int)1024);
  signed int i;
  signed int j;
  signed int nr_stripe = end - start;
  struct fec *ctx;
  signed int strip_size;
  signed int nr_to_send;
  struct req_iter *reqs;
  char *p;
  char *buf = (char *)(void *)0;
  unsigned char policy;
  signed int tmp_if_expr$3;
  unsigned int return_value_oid_to_vid$1;
  signed int return_value_get_vdi_copy_policy$2;
  if(!((signed int)req->rq.$anon0.obj.copy_policy == 0))
    tmp_if_expr$3 = (signed int)req->rq.$anon0.obj.copy_policy;

  else
  {
    return_value_oid_to_vid$1=oid_to_vid$link1(req->rq.$anon0.obj.oid);
    return_value_get_vdi_copy_policy$2=get_vdi_copy_policy(return_value_oid_to_vid$1);
    tmp_if_expr$3 = return_value_get_vdi_copy_policy$2;
  }
  policy = (unsigned char)tmp_if_expr$3;
  signed int ed = 0;
  signed int ep = 0;
  signed int edp;
  edp=ec_policy_to_dp(policy, &ed, &ep);
  ctx=ec_init(ed, edp);
  nr_to_send = opcode == 0x02 ? ed : edp;
  *nr = nr_to_send;
  strip_size = 1024 / ed;
  void *return_value_xzalloc$4;
  return_value_xzalloc$4=xzalloc(sizeof(struct req_iter) /*24ul*/  * (unsigned long int)nr_to_send);
  reqs = (struct req_iter *)return_value_xzalloc$4;
  if(sd_log_level == 7)
    log_write(7, "prepare_erasure_requests", 130, "start %d, end %d, send %d, off %lu, len %u", start, end, nr_to_send, off, len);

  i = 0;
  for( ; !(i >= nr_to_send); i = i + 1)
  {
    signed int l = strip_size * nr_stripe;
    void *return_value_xmalloc$5;
    return_value_xmalloc$5=xmalloc((unsigned long int)l);
    (reqs + (signed long int)i)->buf = (unsigned char *)return_value_xmalloc$5;
    (reqs + (signed long int)i)->dlen = (unsigned int)l;
    (reqs + (signed long int)i)->off = (unsigned long int)(start * strip_size);
    if(opcode == 0x01 || opcode == 0x03)
      (reqs + (signed long int)i)->wlen = (unsigned int)l;

  }
  void *return_value_init_erasure_buffer$6;
  if(opcode == 0x01 || opcode == 0x03)
  {
    return_value_init_erasure_buffer$6=init_erasure_buffer(req, 1024 * nr_stripe);
    buf = (char *)return_value_init_erasure_buffer$6;
    p = buf;
    if(buf == ((char *)NULL))
    {
      log_write(3, "prepare_erasure_requests", 154, "failed to init erasure buffer %lx", req->rq.$anon0.obj.oid);
      free((void *)reqs);
      reqs = (struct req_iter *)(void *)0;
    }

    else
    {
      i = 0;
      for( ; !(i >= nr_stripe); i = i + 1)
      {
        const signed long int l$array_size0 = (signed long int)ed;
        const unsigned char *ds[l$array_size0];
        const signed long int ds$array_size0 = (signed long int)ep;
        unsigned char *ps[ds$array_size0];
        j = 0;
        for( ; !(j >= ed); j = j + 1)
          ds[(signed long int)j] = (reqs + (signed long int)j)->buf + (signed long int)(strip_size * i);
        j = 0;
        for( ; !(j >= ep); j = j + 1)
          ps[(signed long int)j] = (reqs + (signed long int)(ed + j))->buf + (signed long int)(strip_size * i);
        j = 0;
        for( ; !(j >= ed); j = j + 1)
          memcpy((void *)(unsigned char *)ds[(signed long int)j], (const void *)(p + (signed long int)(j * strip_size)), (unsigned long int)strip_size);
        ec_encode(ctx, ds, ps);
        p = p + (signed long int)1024;
      }
    }
  }


out:
  ;
  ec_destroy(ctx);
  free((void *)buf);
  return reqs;
}

// prepare_iocb
// file plain_store.c line 23
static signed int prepare_iocb(unsigned long int oid, struct siocb *iocb, _Bool create)
{
  signed int flags = 010000 | 02;
  _Bool return_value_uatomic_is_true$1;
  return_value_uatomic_is_true$1=uatomic_is_true$link1(&sys->use_journal);
  _Bool tmp_if_expr$2;
  if(!(return_value_uatomic_is_true$1 == (_Bool)0))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)sys->nosync == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    flags = flags & ~010000;

  _Bool return_value_iocb_is_aligned$4;
  if(!(sys->backend_dio == (_Bool)0))
  {
    return_value_iocb_is_aligned$4=iocb_is_aligned(iocb);
    if(!(return_value_iocb_is_aligned$4 == (_Bool)0))
    {
      _Bool return_value_is_aligned_to_pagesize$3;
      return_value_is_aligned_to_pagesize$3=is_aligned_to_pagesize(iocb->buf);
      if(return_value_is_aligned_to_pagesize$3 == (_Bool)0)
      {
        log_write(0, "prepare_iocb", 32, "PANIC: Memory isn't aligned to pagesize %p", iocb->buf);
        abort();
      }

      flags = flags | 040000;
    }

  }

  if(!(create == (_Bool)0))
    flags = flags | 0100 | 0200;

  return flags;
}

// prepare_object_list
// file recovery.c line 980
static void prepare_object_list(struct work *work)
{
  struct recovery_work *rw;
  struct recovery_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct recovery_work *)((char *)__mptr - (signed long int)24ul);
  rw = tmp_statement_expression$1;
  struct recovery_list_work *rlw;
  struct recovery_list_work *tmp_statement_expression$2;
  const struct recovery_work *prepare_object_list$$1$$2$$__mptr = rw;
  tmp_statement_expression$2 = (struct recovery_list_work *)((char *)prepare_object_list$$1$$2$$__mptr - (signed long int)0ul);
  rlw = tmp_statement_expression$2;
  signed int prepare_object_list$$1$$nr_nodes = rw->cur_vinfo->nr_nodes;
  signed int start;
  signed long int return_value_random$3;
  return_value_random$3=random();
  start = (signed int)(return_value_random$3 % (signed long int)prepare_object_list$$1$$nr_nodes);
  signed int i;
  signed int end = prepare_object_list$$1$$nr_nodes;
  unsigned long int *oids;
  struct sd_node *nodes;
  _Bool return_value_node_is_gateway_only$4;
  return_value_node_is_gateway_only$4=node_is_gateway_only();
  struct recovery_info * volatile tmp_statement_expression$6;
  if(return_value_node_is_gateway_only$4 == (_Bool)0)
  {
    if(sd_log_level == 7)
      log_write(7, "prepare_object_list", 995, "%u", rw->epoch);

    wait_get_vdis_done();
    void *return_value_xmalloc$5;
    return_value_xmalloc$5=xmalloc(sizeof(struct sd_node) /*80ul*/  * (unsigned long int)prepare_object_list$$1$$nr_nodes);
    nodes = (struct sd_node *)return_value_xmalloc$5;
    nodes_to_buffer$link2(&rw->cur_vinfo->nroot, (void *)nodes);
    do
    {

    again:
      ;
      i = start;
      for( ; !(i >= end); i = i + 1)
      {
        unsigned long int nr_oids;
        struct sd_node *node = nodes + (signed long int)i;
        asm("" :  :  : "memory");
        tmp_statement_expression$6 = *((struct recovery_info * volatile *)&(*(&next_rinfo)));
        if(!(tmp_statement_expression$6 == ((struct recovery_info *)NULL)))
        {
          if(sd_log_level == 7)
            log_write(7, "prepare_object_list", 1007, "go to the next recovery");

          goto out;
        }

        oids=fetch_object_list(node, rw->epoch, &nr_oids);
        if(!(oids == ((unsigned long int *)NULL)))
        {
          screen_object_list(rlw, oids, nr_oids);
          free((void *)oids);
        }

      }
      if(start == 0)
        break;

      end = start;
      start = 0;
    }
    while((_Bool)1);
    if(sd_log_level == 7)
      log_write(7, "prepare_object_list", 1024, "%lu", rlw->count);


  out:
    ;
    free((void *)nodes);
  }

}

// prepare_replication_requests
// file gateway.c line 29
static struct req_iter * prepare_replication_requests(struct request *req, signed int *nr)
{
  signed int nr_copies;
  nr_copies=get_req_copy_number(req);
  void *data = req->data;
  unsigned int len = req->rq.data_length;
  unsigned long int off = (unsigned long int)req->rq.$anon0.obj.offset;
  struct req_iter *reqs;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct req_iter) /*24ul*/  * (unsigned long int)nr_copies);
  reqs = (struct req_iter *)return_value_xzalloc$1;
  if(sd_log_level == 7)
    log_write(7, "prepare_replication_requests", 38, "%lx", req->rq.$anon0.obj.oid);

  *nr = nr_copies;
  signed int i = 0;
  for( ; !(i >= nr_copies); i = i + 1)
  {
    (reqs + (signed long int)i)->buf = (unsigned char *)data;
    (reqs + (signed long int)i)->dlen = len;
    (reqs + (signed long int)i)->off = off;
    (reqs + (signed long int)i)->wlen = len;
  }
  return reqs;
}

// prepare_requests
// file gateway.c line 189
static struct req_iter * prepare_requests(struct request *req, signed int *nr)
{
  _Bool return_value_is_erasure_oid$3;
  return_value_is_erasure_oid$3=is_erasure_oid(req->rq.$anon0.obj.oid);
  struct req_iter *return_value_prepare_erasure_requests$1;
  struct req_iter *return_value_prepare_replication_requests$2;
  if(!(return_value_is_erasure_oid$3 == (_Bool)0))
  {
    return_value_prepare_erasure_requests$1=prepare_erasure_requests(req, nr);
    return return_value_prepare_erasure_requests$1;
  }

  else
  {
    return_value_prepare_replication_requests$2=prepare_replication_requests(req, nr);
    return return_value_prepare_replication_requests$2;
  }
}

// prepare_schedule_oid
// file recovery.c line 558
static inline void prepare_schedule_oid(unsigned long int oid)
{
  struct recovery_info *rinfo;
  struct recovery_info *tmp_statement_expression$1 = current_rinfo.__val;
  rinfo = tmp_statement_expression$1;
  unsigned long int *tmp_statement_expression$2;
  unsigned long int *__ret = (unsigned long int *)(void *)0;
  if(rinfo->nr_prio_oids >= 1ul)
  {
    unsigned long int __n = rinfo->nr_prio_oids;
    void *return_value_lfind$3;
    return_value_lfind$3=lfind((const void *)&oid, (const void *)rinfo->prio_oids, &__n, sizeof(unsigned long int) /*8ul*/ , (signed int (*)(const void *, const void *))oid_cmp);
    __ret = (unsigned long int *)return_value_lfind$3;
  }

  tmp_statement_expression$2 = __ret;
  if(!(tmp_statement_expression$2 == ((unsigned long int *)NULL)))
  {
    if(sd_log_level == 7)
      log_write(7, "prepare_schedule_oid", 563, "%lx has been already in prio_oids", oid);

  }

  else
  {
    rinfo->nr_prio_oids = rinfo->nr_prio_oids + 1ul;
    void *return_value_xrealloc$4;
    return_value_xrealloc$4=xrealloc((void *)rinfo->prio_oids, rinfo->nr_prio_oids * sizeof(unsigned long int) /*8ul*/ );
    rinfo->prio_oids = (unsigned long int *)return_value_xrealloc$4;
    rinfo->prio_oids[(signed long int)(rinfo->nr_prio_oids - (unsigned long int)1)] = oid;
    if(sd_log_level == 7)
      log_write(7, "prepare_schedule_oid", 571, "%lx nr_prio_oids %lu", oid, rinfo->nr_prio_oids);

    resume_suspended_recovery();
  }
}

// pstrcpy
// file ../include/util.h line 105
void pstrcpy(char *buf, signed int buf_size, const char *str)
{
  signed int c;
  char *q = buf;
  const char *tmp_post$1;
  char *tmp_post$2;
  if(buf_size >= 1)
  {
    for( ; (_Bool)1; *tmp_post$2 = (char)c)
    {
      tmp_post$1 = str;
      str = str + 1l;
      c = (signed int)*tmp_post$1;
      if(c == 0 || q >= buf + (signed long int)buf_size + -1l)
        break;

      tmp_post$2 = q;
      q = q + 1l;
    }
    *q = (char)0;
  }

}

// purge_dir
// file plain_store.c line 180
static signed int purge_dir(const char *path)
{
  signed int return_value_purge_directory$1;
  return_value_purge_directory$1=purge_directory(path);
  if(!(return_value_purge_directory$1 >= 0))
    return 0x03;

  else
    return 0x00;
}

// purge_directory
// file ../include/util.h line 108
signed int purge_directory(const char *dir_path)
{
  signed int ret = 0;
  struct stat s;
  struct __dirstream *dir;
  struct dirent *d;
  char path[4096l];
  dir=opendir(dir_path);
  if(dir == ((struct __dirstream *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 2))
      log_write(3, "purge_directory", 357, "failed to open %s: %m", dir_path);

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    return -(*return_value___errno_location$2);
  }

  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  do
  {
    d=readdir(dir);
    if(d == ((struct dirent *)NULL))
      break;

    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(d->d_name, ".");
    if(return_value_strcmp$3 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strcmp$4=strcmp(d->d_name, "..");
      tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$5)
    {
      snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", dir_path, (const void *)d->d_name);
      ret=stat(path, &s);
      if(!(ret == 0))
      {
        log_write(3, "purge_directory", 368, "failed to stat %s: %m", (const void *)path);
        break;
      }

      if((61440u & s.st_mode) == 16384u)
        ret=rmdir_r(path);

      else
        ret=unlink(path);
      if(!(ret == 0))
      {
        log_write(3, "purge_directory", 378, "failed to remove %s %s: %m", (s.st_mode & (unsigned int)0170000) == (unsigned int)0040000 ? "directory" : "file", (const void *)path);
        break;
      }

    }

  }
  while((_Bool)1);

out:
  ;
  closedir(dir);
  return ret;
}

// purge_stale_dir
// file plain_store.c line 188
static signed int purge_stale_dir(const char *path)
{
  char p[4096l];
  snprintf(p, (unsigned long int)4096, "%s/.stale", path);
  signed int return_value_purge_dir$1;
  return_value_purge_dir$1=purge_dir(p);
  return return_value_purge_dir$1;
}

// push_cache_object
// file object_cache.c line 453
static signed int push_cache_object(unsigned int vid, unsigned long int idx, unsigned long int bmap, _Bool create)
{
  struct sd_req hdr;
  void *buf;
  signed long int offset;
  unsigned long int oid;
  oid=idx_to_oid(vid, idx);
  unsigned long int data_length;
  unsigned long int bsize;
  bsize=get_cache_block_size(oid);
  signed int ret = 0x12;
  signed int first_bit;
  signed int last_bit;
  unsigned long int tmp_statement_expression$3;
  const char *return_value_sd_strerror$5;
  if(bmap == 0ul)
  {
    if(sd_log_level == 7)
      log_write(7, "push_cache_object", 465, "WARN: nothing to flush %lx", oid);

    return 0x00;
  }

  else
  {
    signed int return_value_ffsll$1;
    return_value_ffsll$1=ffsll((signed long long int)bmap);
    first_bit = return_value_ffsll$1 - 1;
    signed int return_value_fls64$2;
    return_value_fls64$2=fls64(bmap);
    last_bit = return_value_fls64$2 - 1;
    if(sd_log_level == 7)
      log_write(7, "push_cache_object", 473, "%lx bmap(%zd):0x%lx, first_bit:%d, last_bit:%d", oid, bsize, bmap, first_bit, last_bit);

    offset = (signed long int)((unsigned long int)first_bit * bsize);
    unsigned long int _x = (unsigned long int)((last_bit - first_bit) + 1) * bsize;
    unsigned long int _y;
    unsigned long int return_value_get_objsize$4;
    return_value_get_objsize$4=get_objsize$link2(oid);
    _y = return_value_get_objsize$4 - (unsigned long int)offset;
    (void)(&_x == &_y);
    tmp_statement_expression$3 = _x < _y ? _x : _y;
    data_length = tmp_statement_expression$3;
    buf=xvalloc(data_length);
    ret=read_cache_object_noupdate(vid, idx, buf, data_length, offset);
    if(ret == 0x00)
    {
      if(!(create == (_Bool)0))
        sd_init_req$link5(&hdr, (unsigned char)0x01);

      else
        sd_init_req$link5(&hdr, (unsigned char)0x03);
      hdr.flags = (unsigned short int)0x01;
      hdr.data_length = (unsigned int)data_length;
      hdr.$anon0.obj.oid = oid;
      hdr.$anon0.obj.offset = (unsigned int)offset;
      ret=exec_local_req(&hdr, buf);
      if(!(ret == 0x00))
      {
        return_value_sd_strerror$5=sd_strerror$link6(ret);
        log_write(3, "push_cache_object", 495, "failed to push object %lx, %s", oid, return_value_sd_strerror$5);
      }

    }


  out:
    ;
    free(buf);
    return ret;
  }
}

// push_object_done
// file object_cache.c line 878
static void push_object_done(struct work *work)
{
  struct push_work *pw;
  struct push_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct push_work *)((char *)__mptr - (signed long int)0ul);
  pw = tmp_statement_expression$1;
  free((void *)pw);
}

// put_cache_entry
// file object_cache.c line 156
static inline void put_cache_entry(struct object_cache_entry *entry)
{
  refcount_dec$link2(&entry->refcnt);
}

// put_request
// file sheep_priv.h line 397
void put_request(struct request *req)
{
  struct client_info *ci = req->ci;
  signed int return_value_refcount_dec$1;
  return_value_refcount_dec$1=refcount_dec$link1(&req->refcnt);
  signed int return_value_conn_tx_on$2;
  if(!(return_value_refcount_dec$1 >= 1))
  {
    stat_request_end(req);
    if(!(req->local == (_Bool)0))
      eventfd_xwrite(req->local_req_efd, 1);

    else
      if(!(ci->conn.dead == (_Bool)0))
      {
        free_request(req);
        clear_client_info(ci);
      }

      else
      {
        list_add_tail$link1(&req->request_list, &ci->done_reqs);
        if(ci->tx_req == ((struct request *)NULL))
        {
          return_value_conn_tx_on$2=conn_tx_on(&ci->conn);
          if(!(return_value_conn_tx_on$2 == 0))
          {
            log_write(3, "put_request", 715, "switch on sending flag failure, connection maybe closed");
            clear_client_info(ci);
          }

        }

      }
  }

}

// put_vnode_info
// file sheep_priv.h line 327
void put_vnode_info(struct vnode_info *vnode_info)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_vnode *tmp_statement_expression$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  struct sd_node *tmp_statement_expression$5;
  if(!(vnode_info == ((struct vnode_info *)NULL)))
  {
    signed int return_value_refcount_dec$7;
    return_value_refcount_dec$7=refcount_dec(&vnode_info->refcnt);
    if(return_value_refcount_dec$7 == 0)
    {
      struct sd_vnode *__dummy;
      struct rb_node *__p96;
      __p96=rb_first(&vnode_info->vroot);
      struct rb_node *__n96;
      do
      {
        if(!(__p96 == ((struct rb_node *)NULL)))
        {
          __n96=rb_next(__p96);
          tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
        {
          const struct rb_node *__mptr = __p96;
          tmp_statement_expression$2 = (struct sd_vnode *)((char *)__mptr - (signed long int)0ul);
          __dummy = tmp_statement_expression$2;
          tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        rb_erase(&__dummy->rb, &vnode_info->vroot);
        free((void *)__dummy);
        __p96 = __n96;
      }
      while((_Bool)1);
      struct sd_node *put_vnode_info$$1$$1$$1$$2$$__dummy;
      struct rb_node *__p97;
      __p97=rb_first(&vnode_info->nroot);
      struct rb_node *__n97;
      do
      {
        if(!(__p97 == ((struct rb_node *)NULL)))
        {
          __n97=rb_next(__p97);
          tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          const struct rb_node *put_vnode_info$$1$$1$$1$$2$$1$$1$$__mptr = __p97;
          tmp_statement_expression$5 = (struct sd_node *)((char *)put_vnode_info$$1$$1$$1$$2$$1$$1$$__mptr - (signed long int)0ul);
          put_vnode_info$$1$$1$$1$$2$$__dummy = tmp_statement_expression$5;
          tmp_if_expr$6 = 1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
        if(!tmp_if_expr$6)
          break;

        rb_erase(&put_vnode_info$$1$$1$$1$$2$$__dummy->rb, &vnode_info->nroot);
        free((void *)put_vnode_info$$1$$1$$1$$2$$__dummy);
        __p97 = __n97;
      }
      while((_Bool)1);
      free((void *)vnode_info);
    }

  }

}

// queue_cluster_request
// file group.c line 297
void queue_cluster_request(struct request *req)
{
  signed int ret;
  const char *return_value_op_name$1;
  if(sd_log_level == 7)
  {
    return_value_op_name$1=op_name(req->op);
    log_write(7, "queue_cluster_request", 300, "%s (%p)", return_value_op_name$1, req);
  }

  _Bool return_value_has_process_work$6;
  return_value_has_process_work$6=has_process_work(req->op);
  struct list_head *tmp_statement_expression$3;
  struct list_head *tmp_statement_expression$5;
  if(!(return_value_has_process_work$6 == (_Bool)0))
  {
    ret=sys->cdrv->block();
    if(!(ret == 0x00))
    {
      const char *return_value_sd_strerror$2;
      return_value_sd_strerror$2=sd_strerror(ret);
      log_write(3, "queue_cluster_request", 306, "failed to broadcast block to cluster, %s", return_value_sd_strerror$2);
    }

    tmp_statement_expression$3 = pending_block_list.__val;
    list_add_tail(&req->pending_list, tmp_statement_expression$3);
  }

  else
  {
    struct vdi_op_message *msg;
    unsigned long int size;
    msg=prepare_cluster_msg(req, &size);
    msg->rsp.$anon0.result = (unsigned int)0x00;
    ret=sys->cdrv->notify((void *)msg, size);
    if(!(ret == 0x00))
    {
      const char *return_value_sd_strerror$4;
      return_value_sd_strerror$4=sd_strerror(ret);
      log_write(3, "queue_cluster_request", 321, "failed to broadcast notify to cluster, %s", return_value_sd_strerror$4);
    }

    tmp_statement_expression$5 = pending_notify_list.__val;
    list_add_tail(&req->pending_list, tmp_statement_expression$5);
    free((void *)msg);
  }
  req->status = (enum REQUST_STATUS)REQUEST_INIT;

error:
  ;
  req->rp.$anon0.result = (unsigned int)ret;
  put_request(req);
}

// queue_gateway_request
// file request.c line 303
static void queue_gateway_request(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  _Bool return_value_is_access_local$1;
  return_value_is_access_local$1=is_access_local(req, hdr->$anon0.obj.oid);
  if(!(return_value_is_access_local$1 == (_Bool)0))
    req->local_oid = hdr->$anon0.obj.oid;

  if(!(sys->enable_object_cache == (_Bool)0))
  {
    if(req->local == (_Bool)0)
      goto queue_work;

  }

  _Bool return_value_request_in_recovery$2;
  _Bool tmp_if_expr$4;
  _Bool return_value_has_enough_zones$3;
  if(!(req->local_oid == 0ul))
  {
    return_value_request_in_recovery$2=request_in_recovery(req);
    if(return_value_request_in_recovery$2 == (_Bool)0)
      goto queue_work;

  }

  else
  {

  queue_work:
    ;
    if(req->vinfo->vroot.rb_node == ((struct rb_node *)NULL))
      log_write(3, "queue_gateway_request", 328, "there is no living nodes");

    else
      if(!((0x0001 & (signed int)sys->cinfo.flags) == 0))
      {
        if((signed int)hdr->opcode == 0x01)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = (signed int)hdr->opcode == 0x03 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$4)
          goto __CPROVER_DUMP_L7;

        return_value_has_enough_zones$3=has_enough_zones(req);
        if(return_value_has_enough_zones$3 != (_Bool)0)
          goto __CPROVER_DUMP_L7;

        log_write(3, "queue_gateway_request", 335, "not enough zones available");
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        req->work.fn = do_process_work;
        req->work.done = gateway_op_done;
        queue_work(sys->gateway_wqueue, &req->work);
        goto __CPROVER_DUMP_L9;
      }

  end_request:
    ;
    req->rp.$anon0.result = (unsigned int)0x19;
    put_request(req);
    goto __CPROVER_DUMP_L9;
  }

__CPROVER_DUMP_L9:
  ;
}

// queue_local_request
// file request.c line 350
static void queue_local_request(struct request *req)
{
  req->work.fn = do_process_work;
  req->work.done = local_op_done;
  queue_work(sys->io_wqueue, &req->work);
}

// queue_peer_request
// file request.c line 269
static void queue_peer_request(struct request *req)
{
  req->local_oid = req->rq.$anon0.obj.oid;
  if(!(req->local_oid == 0ul))
  {
    signed int return_value_check_request_epoch$1;
    return_value_check_request_epoch$1=check_request_epoch(req);
    if(!(return_value_check_request_epoch$1 >= 0))
      goto __CPROVER_DUMP_L4;

    _Bool return_value_request_in_recovery$2;
    return_value_request_in_recovery$2=request_in_recovery(req);
    if(!(return_value_request_in_recovery$2 == (_Bool)0))
      goto __CPROVER_DUMP_L4;

  }

  if(!((0x0080 & (signed int)req->rq.flags) == 0))
    req->rq.epoch = req->rq.$anon0.obj.tgt_epoch;

  req->work.fn = do_process_work;
  req->work.done = io_op_done;
  queue_work(sys->io_wqueue, &req->work);

__CPROVER_DUMP_L4:
  ;
}

// queue_recovery_work
// file recovery.c line 1072
static void queue_recovery_work(struct recovery_info *rinfo)
{
  struct recovery_work *rw;
  struct recovery_list_work *rlw;
  struct recovery_obj_work *row;
  void *return_value_xzalloc$1;
  void *return_value_xmalloc$2;
  void *return_value_xzalloc$3;
  void *return_value_xzalloc$4;
  switch((signed int)rinfo->state)
  {
    case RW_PREPARE_LIST:
    {
      return_value_xzalloc$1=xzalloc(sizeof(struct recovery_list_work) /*72ul*/ );
      rlw = (struct recovery_list_work *)return_value_xzalloc$1;
      return_value_xmalloc$2=xmalloc(list_buffer_size);
      rlw->oids = (unsigned long int *)return_value_xmalloc$2;
      rw = &rlw->base;
      rw->work.fn = prepare_object_list;
      rw->work.done = finish_object_list;
      break;
    }
    case RW_RECOVER_OBJ:
    {
      return_value_xzalloc$3=xzalloc(sizeof(struct recovery_obj_work) /*96ul*/ );
      row = (struct recovery_obj_work *)return_value_xzalloc$3;
      row->oid = rinfo->oids[(signed long int)rinfo->done];
      rw = &row->base;
      rw->work.fn = recover_object_work;
      rw->work.done = recover_object_main;
      break;
    }
    case RW_NOTIFY_COMPLETION:
    {
      return_value_xzalloc$4=xzalloc(sizeof(struct recovery_work) /*56ul*/ );
      rw = (struct recovery_work *)return_value_xzalloc$4;
      rw->work.fn = notify_recovery_completion_work;
      rw->work.done = notify_recovery_completion_main;
      break;
    }
    default:
    {
      log_write(0, "queue_recovery_work", 1101, "PANIC: unknow recovery state %d", rinfo->state);
      abort();
    }
  }
  rw->epoch = rinfo->epoch;
  rw->tgt_epoch = rinfo->tgt_epoch;
  rw->cur_vinfo=grab_vnode_info(rinfo->cur_vinfo);
  rw->old_vinfo=grab_vnode_info(rinfo->old_vinfo);
  queue_work(sys->recovery_wqueue, &rw->work);
}

// queue_request
// file request.c line 425
static void queue_request(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  struct sd_rsp *rsp = &req->rp;
  if((signed int)hdr->opcode >= 0x80)
  {
    if(!((signed int)hdr->proto_ver == 0x09))
    {
      rsp->$anon0.result = (unsigned int)0x14;
      goto done;
    }

  }

  else
    if(!(hdr->proto_ver == 0))
    {
      if((signed int)hdr->proto_ver >= 3)
      {
        rsp->$anon0.result = (unsigned int)0x14;
        goto done;
      }

    }

  req->op=get_sd_op(hdr->opcode);
  const char *return_value_op_name$1;
  _Bool return_value_is_force_op$2;
  _Bool return_value_is_peer_op$6;
  _Bool return_value_is_gateway_op$5;
  _Bool return_value_is_local_op$4;
  _Bool return_value_is_cluster_op$3;
  if(req->op == ((struct sd_op_template *)NULL))
  {
    log_write(3, "queue_request", 449, "invalid opcode %d", hdr->opcode);
    rsp->$anon0.result = (unsigned int)0x05;
  }

  else
  {
    if(sd_log_level == 7)
    {
      return_value_op_name$1=op_name(req->op);
      log_write(7, "queue_request", 454, "%s, %d", return_value_op_name$1, sys->cinfo.status);
    }

    switch((signed int)sys->cinfo.status)
    {
      case SD_STATUS_KILLED:
      {
        rsp->$anon0.result = (unsigned int)0x8D;
        goto done;
      }
      case SD_STATUS_SHUTDOWN:
      {
        rsp->$anon0.result = (unsigned int)0x11;
        goto done;
      }
      case SD_STATUS_WAIT:
      {
        return_value_is_force_op$2=is_force_op(req->op);
        if(return_value_is_force_op$2 == (_Bool)0)
        {
          if(sys->cinfo.ctime == 0ul)
            rsp->$anon0.result = (unsigned int)0x16;

          else
            rsp->$anon0.result = (unsigned int)0x17;
          goto done;
        }

        break;
      }
      default:
        ;
    }
    req->vinfo=get_vnode_info();
    stat_request_begin(req);
    return_value_is_peer_op$6=is_peer_op(req->op);
    if(!(return_value_is_peer_op$6 == (_Bool)0))
      queue_peer_request(req);

    else
    {
      return_value_is_gateway_op$5=is_gateway_op(req->op);
      if(!(return_value_is_gateway_op$5 == (_Bool)0))
      {
        hdr->epoch = sys->cinfo.epoch;
        queue_gateway_request(req);
      }

      else
      {
        return_value_is_local_op$4=is_local_op(req->op);
        if(!(return_value_is_local_op$4 == (_Bool)0))
        {
          hdr->epoch = sys->cinfo.epoch;
          queue_local_request(req);
        }

        else
        {
          return_value_is_cluster_op$3=is_cluster_op(req->op);
          if(!(return_value_is_cluster_op$3 == (_Bool)0))
          {
            hdr->epoch = sys->cinfo.epoch;
            queue_cluster_request(req);
          }

          else
          {
            log_write(3, "queue_request", 490, "unknown operation %d", hdr->opcode);
            rsp->$anon0.result = (unsigned int)0x06;
            goto done;
          }
        }
      }
    }
    goto __CPROVER_DUMP_L20;
  }

done:
  ;
  put_request(req);

__CPROVER_DUMP_L20:
  ;
}

// queue_work
// file ../include/work.h line 64
void queue_work(struct work_queue *q, struct work *work)
{
  struct wq_info *wi;
  struct wq_info *tmp_statement_expression$1;
  const struct work_queue *__mptr = q;
  tmp_statement_expression$1 = (struct wq_info *)((char *)__mptr - (signed long int)208ul);
  wi = tmp_statement_expression$1;
  __uatomic_inc$link2((void *)&wi->nr_queued_work, (signed int)sizeof(unsigned long int) /*8ul*/ );
  sd_mutex_lock$link4(&wi->pending_lock);
  _Bool return_value_wq_need_grow$2;
  return_value_wq_need_grow$2=wq_need_grow(wi);
  if(!(return_value_wq_need_grow$2 == (_Bool)0))
    create_worker_threads(wi, wi->nr_threads * (unsigned long int)2);

  list_add_tail$link4(&work->w_list, &wi->q.pending_list);
  sd_mutex_unlock$link4(&wi->pending_lock);
  sd_cond_signal(&wi->pending_cond);
}

// rb_erase
// file ../include/rbtree.h line 57
void rb_erase(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *child;
  struct rb_node *parent;
  signed int color;
  if(node->rb_left == ((struct rb_node *)NULL))
    child = node->rb_right;

  else
    if(node->rb_right == ((struct rb_node *)NULL))
      child = node->rb_left;

    else
    {
      struct rb_node *old = node;
      struct rb_node *left;
      node = node->rb_right;
      do
      {
        left = node->rb_left;
        if(left == ((struct rb_node *)NULL))
          break;

        node = left;
      }
      while((_Bool)1);
      if(!((18446744073709551612ul & old->rb_parent_color) == 0ul))
      {
        if(((struct rb_node *)(18446744073709551612ul & old->rb_parent_color))->rb_left == old)
          ((struct rb_node *)(old->rb_parent_color & (unsigned long int)~3))->rb_left = node;

        else
          ((struct rb_node *)(old->rb_parent_color & (unsigned long int)~3))->rb_right = node;
      }

      else
        root->rb_node = node;
      child = node->rb_right;
      parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      color = (signed int)(node->rb_parent_color & (unsigned long int)1);
      if(parent == old)
        parent = node;

      else
      {
        if(!(child == ((struct rb_node *)NULL)))
          rb_set_parent$link1(child, parent);

        parent->rb_left = child;
        node->rb_right = old->rb_right;
        rb_set_parent$link1(old->rb_right, node);
      }
      node->rb_parent_color = old->rb_parent_color;
      node->rb_left = old->rb_left;
      rb_set_parent$link1(old->rb_left, node);
      goto color;
    }
  parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  color = (signed int)(node->rb_parent_color & (unsigned long int)1);
  if(!(child == ((struct rb_node *)NULL)))
    rb_set_parent$link1(child, parent);

  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(parent->rb_left == node)
      parent->rb_left = child;

    else
      parent->rb_right = child;
  }

  else
    root->rb_node = child;

color:
  ;
  if(color == 1)
    __rb_erase_color(child, parent, root);

}

// rb_first
// file ../include/rbtree.h line 62
struct rb_node * rb_first(struct rb_root *root)
{
  struct rb_node *n = root->rb_node;
  if(n == ((struct rb_node *)NULL))
    return (struct rb_node *)(void *)0;

  else
  {
    for( ; !(n->rb_left == ((struct rb_node *)NULL)); n = n->rb_left)
      ;
    return n;
  }
}

// rb_init_node
// file ../include/rbtree.h line 48
static inline void rb_init_node(struct rb_node *rb)
{
  rb->rb_parent_color = (unsigned long int)0;
  rb->rb_right = (struct rb_node *)(void *)0;
  rb->rb_left = (struct rb_node *)(void *)0;
  rb_set_parent(rb, rb);
}

// rb_insert_color
// file ../include/rbtree.h line 56
void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *parent;
  struct rb_node *gparent;
  do
  {
    parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
    if(parent == ((struct rb_node *)NULL))
      break;

    if(!((1ul & parent->rb_parent_color) == 0ul))
      break;

    gparent = (struct rb_node *)(parent->rb_parent_color & (unsigned long int)~3);
    if(parent == gparent->rb_left)
    {
      struct rb_node *rb_insert_color$$1$$1$$1$$uncle = gparent->rb_right;
      if(!(rb_insert_color$$1$$1$$1$$uncle == ((struct rb_node *)NULL)))
      {
        if((1ul & rb_insert_color$$1$$1$$1$$uncle->rb_parent_color) == 0ul)
        {
          do
            rb_insert_color$$1$$1$$1$$uncle->rb_parent_color = rb_insert_color$$1$$1$$1$$uncle->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          node = gparent;
          continue;
        }

      }

      if(parent->rb_right == node)
      {
        struct rb_node *tmp;
        __rb_rotate_left(parent, root);
        tmp = parent;
        parent = node;
        node = tmp;
      }

      do
        parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
      while((_Bool)0);
      do
        gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
      while((_Bool)0);
      __rb_rotate_right(gparent, root);
    }

    else
    {
      struct rb_node *uncle = gparent->rb_left;
      if(!(uncle == ((struct rb_node *)NULL)))
      {
        if(!((1ul & uncle->rb_parent_color) == 0ul))
          goto __CPROVER_DUMP_L12;

        do
          uncle->rb_parent_color = uncle->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = gparent;
      }

      else
      {

      __CPROVER_DUMP_L12:
        ;
        if(parent->rb_left == node)
        {
          struct rb_node *rb_insert_color$$1$$1$$2$$2$$tmp;
          __rb_rotate_right(parent, root);
          rb_insert_color$$1$$1$$2$$2$$tmp = parent;
          parent = node;
          node = rb_insert_color$$1$$1$$2$$2$$tmp;
        }

        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_left(gparent, root);
      }
    }
  }
  while((_Bool)1);
  do
    root->rb_node->rb_parent_color = root->rb_node->rb_parent_color | (unsigned long int)1;
  while((_Bool)0);
}

// rb_last
// file rbtree.c line 267
struct rb_node * rb_last(struct rb_root *root)
{
  struct rb_node *n = root->rb_node;
  if(n == ((struct rb_node *)NULL))
    return (struct rb_node *)(void *)0;

  else
  {
    for( ; !(n->rb_right == ((struct rb_node *)NULL)); n = n->rb_right)
      ;
    return n;
  }
}

// rb_link_node
// file ../include/rbtree.h line 69
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link)
{
  node->rb_parent_color = (unsigned long int)parent;
  node->rb_right = (struct rb_node *)(void *)0;
  node->rb_left = node->rb_right;
  *rb_link = node;
}

// rb_link_node$link1
// file ../include/rbtree.h line 69
static inline void rb_link_node$link1(struct rb_node *node$link1, struct rb_node *parent$link1, struct rb_node **rb_link$link1)
{
  node$link1->rb_parent_color = (unsigned long int)parent$link1;
  node$link1->rb_right = (struct rb_node *)(void *)0;
  node$link1->rb_left = node$link1->rb_right;
  *rb_link$link1 = node$link1;
}

// rb_link_node$link2
// file ../include/rbtree.h line 69
static inline void rb_link_node$link2(struct rb_node *node$link2, struct rb_node *parent$link2, struct rb_node **rb_link$link2)
{
  node$link2->rb_parent_color = (unsigned long int)parent$link2;
  node$link2->rb_right = (struct rb_node *)(void *)0;
  node$link2->rb_left = node$link2->rb_right;
  *rb_link$link2 = node$link2;
}

// rb_link_node$link3
// file ../include/rbtree.h line 69
static inline void rb_link_node$link3(struct rb_node *node$link3, struct rb_node *parent$link3, struct rb_node **rb_link$link3)
{
  node$link3->rb_parent_color = (unsigned long int)parent$link3;
  node$link3->rb_right = (struct rb_node *)(void *)0;
  node$link3->rb_left = node$link3->rb_right;
  *rb_link$link3 = node$link3;
}

// rb_link_node$link4
// file ../include/rbtree.h line 69
static inline void rb_link_node$link4(struct rb_node *node$link4, struct rb_node *parent$link4, struct rb_node **rb_link$link4)
{
  node$link4->rb_parent_color = (unsigned long int)parent$link4;
  node$link4->rb_right = (struct rb_node *)(void *)0;
  node$link4->rb_left = node$link4->rb_right;
  *rb_link$link4 = node$link4;
}

// rb_link_node$link5
// file ../include/rbtree.h line 69
static inline void rb_link_node$link5(struct rb_node *node$link5, struct rb_node *parent$link5, struct rb_node **rb_link$link5)
{
  node$link5->rb_parent_color = (unsigned long int)parent$link5;
  node$link5->rb_right = (struct rb_node *)(void *)0;
  node$link5->rb_left = node$link5->rb_right;
  *rb_link$link5 = node$link5;
}

// rb_link_node$link6
// file ../include/rbtree.h line 69
static inline void rb_link_node$link6(struct rb_node *node$link6, struct rb_node *parent$link6, struct rb_node **rb_link$link6)
{
  node$link6->rb_parent_color = (unsigned long int)parent$link6;
  node$link6->rb_right = (struct rb_node *)(void *)0;
  node$link6->rb_left = node$link6->rb_right;
  *rb_link$link6 = node$link6;
}

// rb_link_node$link7
// file ../include/rbtree.h line 69
static inline void rb_link_node$link7(struct rb_node *node$link7, struct rb_node *parent$link7, struct rb_node **rb_link$link7)
{
  node$link7->rb_parent_color = (unsigned long int)parent$link7;
  node$link7->rb_right = (struct rb_node *)(void *)0;
  node$link7->rb_left = node$link7->rb_right;
  *rb_link$link7 = node$link7;
}

// rb_next
// file ../include/rbtree.h line 60
struct rb_node * rb_next(struct rb_node *node)
{
  struct rb_node *parent;
  if((struct rb_node *)(18446744073709551612ul & node->rb_parent_color) == node)
    return (struct rb_node *)(void *)0;

  else
    if(!(node->rb_right == ((struct rb_node *)NULL)))
    {
      node = node->rb_right;
      for( ; !(node->rb_left == ((struct rb_node *)NULL)); node = node->rb_left)
        ;
      return (struct rb_node *)node;
    }

    else
    {
      do
      {
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
        if(parent == ((struct rb_node *)NULL))
          break;

        if(!(node == parent->rb_right))
          break;

        node = parent;
      }
      while((_Bool)1);
      return parent;
    }
}

// rb_prev
// file rbtree.c line 311
struct rb_node * rb_prev(struct rb_node *node)
{
  struct rb_node *parent;
  if((struct rb_node *)(18446744073709551612ul & node->rb_parent_color) == node)
    return (struct rb_node *)(void *)0;

  else
    if(!(node->rb_left == ((struct rb_node *)NULL)))
    {
      node = node->rb_left;
      for( ; !(node->rb_right == ((struct rb_node *)NULL)); node = node->rb_right)
        ;
      return (struct rb_node *)node;
    }

    else
    {
      do
      {
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
        if(parent == ((struct rb_node *)NULL))
          break;

        if(!(node == parent->rb_left))
          break;

        node = parent;
      }
      while((_Bool)1);
      return parent;
    }
}

// rb_replace_node
// file rbtree.c line 339
void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root)
{
  struct rb_node *parent = (struct rb_node *)(victim->rb_parent_color & (unsigned long int)~3);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(victim == parent->rb_left)
      parent->rb_left = new;

    else
      parent->rb_right = new;
  }

  else
    root->rb_node = new;
  if(!(victim->rb_left == ((struct rb_node *)NULL)))
    rb_set_parent$link1(victim->rb_left, new);

  if(!(victim->rb_right == ((struct rb_node *)NULL)))
    rb_set_parent$link1(victim->rb_right, new);

  *new = *victim;
}

// rb_set_color
// file ../include/rbtree.h line 31
static inline void rb_set_color(struct rb_node *rb, signed int color)
{
  rb->rb_parent_color = rb->rb_parent_color & (unsigned long int)~1 | (unsigned long int)color;
}

// rb_set_parent
// file ../include/rbtree.h line 27
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p)
{
  rb->rb_parent_color = rb->rb_parent_color & (unsigned long int)3 | (unsigned long int)p;
}

// rb_set_parent$link1
// file ../include/rbtree.h line 27
static inline void rb_set_parent$link1(struct rb_node *rb$link1, struct rb_node *p$link1)
{
  rb$link1->rb_parent_color = rb$link1->rb_parent_color & (unsigned long int)3 | (unsigned long int)p$link1;
}

// read_account_meta
// file http/kv.c line 150
static signed int read_account_meta(const char *account, unsigned long int *bucket_count, unsigned long int *object_count, unsigned long int *used)
{
  struct sd_inode *inode = (struct sd_inode *)(void *)0;
  struct bucket_iterater_arg arg = { .opaque=NULL, .cb=((void (*)(const char *, void *))NULL), .bucket_count=0ul,
    .object_count=0ul, .bytes_used=0ul };
  unsigned int account_vid;
  unsigned long int oid;
  signed int ret;
  ret=sd_lookup_vdi(account, &account_vid);
  void *return_value_xmalloc$1;
  if(ret == 0x00)
  {
    oid=vid_to_vdi_oid$link3(account_vid);
    return_value_xmalloc$1=xmalloc(sizeof(struct sd_inode) /*4198976ul*/ );
    inode = (struct sd_inode *)return_value_xmalloc$1;
    ret=sd_read_object(oid, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
    if(!(ret == 0x00))
      log_write(3, "read_account_meta", 167, "Failed to read inode header %lx", oid);

    else
    {
      traverse_btree(sheep_bnode_reader, inode, bucket_iterater, (void *)&arg);
      *object_count = arg.object_count;
      *bucket_count = arg.bucket_count;
      *used = arg.bytes_used;
    }
  }


out:
  ;
  free((void *)inode);
  return ret;
}

// read_backend_object
// file store.c line 400
signed int read_backend_object(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset)
{
  struct sd_req hdr;
  signed int ret;
  sd_init_req$link2(&hdr, (unsigned char)0x02);
  hdr.data_length = datalen;
  hdr.$anon0.obj.oid = oid;
  hdr.$anon0.obj.offset = (unsigned int)offset;
  ret=exec_local_req(&hdr, (void *)data);
  const char *return_value_sd_strerror$1;
  if(!(ret == 0x00))
  {
    return_value_sd_strerror$1=sd_strerror$link3(ret);
    log_write(3, "read_backend_object", 414, "failed to read object %lx, %s", oid, return_value_sd_strerror$1);
  }

  return ret;
}

// read_cache_object
// file object_cache.c line 383
static signed int read_cache_object(struct object_cache_entry *entry, void *buf, unsigned long int count, signed long int offset)
{
  unsigned int vid = entry->oc->vid;
  unsigned long int idx;
  idx=entry_idx(entry);
  struct object_cache *oc = entry->oc;
  signed int ret;
  ret=read_cache_object_noupdate(vid, idx, buf, count, offset);
  if(ret == 0x00)
  {
    write_lock_cache(oc);
    list_move_tail(&entry->lru_list, &oc->lru_head);
    unlock_cache(oc);
  }

  return ret;
}

// read_cache_object_noupdate
// file object_cache.c line 310
static signed int read_cache_object_noupdate(unsigned int vid, unsigned long int idx, void *buf, unsigned long int count, signed long int offset)
{
  unsigned long int size;
  signed int fd;
  signed int flags = def_open_flags;
  signed int ret = 0x00;
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x/%016lx", (const void *)object_cache_dir, vid, idx);
  _Bool return_value_idx_has_vdi_bit$1;
  if(!(sys->object_cache_directio == (_Bool)0))
  {
    return_value_idx_has_vdi_bit$1=idx_has_vdi_bit(idx);
    if(return_value_idx_has_vdi_bit$1 == (_Bool)0)
      flags = flags | 040000;

  }

  fd=open(p, flags, sd_def_fmode);
  signed long int return_value_xpread$2;
  if(!(fd >= 0))
  {
    log_write(3, "read_cache_object_noupdate", 327, "%m");
    ret = 0x03;
  }

  else
  {
    return_value_xpread$2=xpread(fd, buf, count, offset);
    size = (unsigned long int)return_value_xpread$2;
    if(!(size == count))
    {
      log_write(3, "read_cache_object_noupdate", 336, "size %zu, count:%zu, offset %jd %m", size, count, (signed long int)offset);
      ret = 0x03;
    }


  out_close:
    ;
    close(fd);
  }

out:
  ;
  return ret;
}

// read_erasure_object
// file recovery.c line 158
static void * read_erasure_object(unsigned long int oid, unsigned char idx, struct recovery_obj_work *row)
{
  struct sd_req hdr;
  unsigned int rlen;
  unsigned long int return_value_get_store_objsize$1;
  return_value_get_store_objsize$1=get_store_objsize(oid);
  rlen = (unsigned int)return_value_get_store_objsize$1;
  void *buf;
  buf=xvalloc((unsigned long int)rlen);
  struct recovery_work *rw = &row->base;
  struct vnode_info *old;
  old=grab_vnode_info(rw->old_vinfo);
  struct vnode_info *new_old;
  unsigned int epoch = rw->epoch;
  unsigned int tgt_epoch = rw->tgt_epoch;
  struct sd_node *node;
  unsigned char policy;
  unsigned int return_value_oid_to_vid$2;
  return_value_oid_to_vid$2=oid_to_vid$link4(oid);
  signed int return_value_get_vdi_copy_policy$3;
  return_value_get_vdi_copy_policy$3=get_vdi_copy_policy(return_value_oid_to_vid$2);
  policy = (unsigned char)return_value_get_vdi_copy_policy$3;
  signed int edp;
  edp=ec_policy_to_dp$link3(policy, (signed int *)(void *)0, (signed int *)(void *)0);
  signed int ret;

again:
  ;
  const char *return_value_node_to_str$5;
  _Bool return_value_invalid_node$6;
  for( ; (_Bool)1; old = new_old)
  {
    if(!(old->nr_zones >= edp))
    {
      signed int return_value_search_erasure_object$4;
      return_value_search_erasure_object$4=search_erasure_object(oid, idx, &old->nroot, rw, tgt_epoch, buf);
      if(return_value_search_erasure_object$4 == 0x00)
        goto done;

      else
        goto rollback;
    }

    node=oid_to_node(oid, &old->vroot, (signed int)idx);
    if(sd_log_level == 7)
    {
      return_value_node_to_str$5=node_to_str$link2(node);
      log_write(7, "read_erasure_object", 182, "%lx epoch %u tgt %u idx %d, %s", oid, epoch, tgt_epoch, idx, return_value_node_to_str$5);
    }

    return_value_invalid_node$6=invalid_node(node, rw->cur_vinfo);
    if(return_value_invalid_node$6 == (_Bool)0)
    {
      sd_init_req$link4(&hdr, (unsigned char)0xA4);
      hdr.epoch = epoch;
      hdr.flags = (unsigned short int)0x0080;
      hdr.data_length = rlen;
      hdr.$anon0.obj.oid = oid;
      hdr.$anon0.obj.tgt_epoch = tgt_epoch;
      hdr.$anon0.obj.ec_index = idx;
      ret=sheep_exec_req(&node->nid, &hdr, buf);
      switch(ret)
      {
        case 0x00:
          goto done;
        case 0x81:
        {
          free(buf);
          buf = (void *)0;
          row->stop = (_Bool)1;
          goto done;
        }
        default:
          ;
      }
    }


  rollback:
    ;
    new_old=rollback_vnode_info(&tgt_epoch, rw->cur_vinfo);
    if(new_old == ((struct vnode_info *)NULL))
    {
      log_write(3, "read_erasure_object", 206, "can not read %lx idx %d", oid, idx);
      free(buf);
      buf = (void *)0;
      break;
    }

    put_vnode_info(old);
  }

done:
  ;
  put_vnode_info(old);
  return buf;
}

// read_lock_cache
// file object_cache.c line 178
static inline void read_lock_cache(struct object_cache *oc)
{
  sd_read_lock$link1(&oc->lock);
}

// read_lock_entry
// file object_cache.c line 193
static inline void read_lock_entry(struct object_cache_entry *entry)
{
  sd_read_lock$link1(&entry->lock);
}

// read_vdis
// file vdi.c line 750
signed int read_vdis(char *data, signed int len, unsigned int *rsp_len)
{
  if(!((unsigned long int)len == sizeof(unsigned long int [262144l]) /*2097152ul*/ ))
    return 0x05;

  else
  {
    memcpy((void *)data, (const void *)sys->vdi_inuse, sizeof(unsigned long int [262144l]) /*2097152ul*/ );
    *rsp_len = (unsigned int)sizeof(unsigned long int [262144l]) /*2097152ul*/ ;
    return 0x00;
  }
}

// rebase_vdi
// file vdi.c line 433
static signed int rebase_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int base_vid, unsigned int cur_vid)
{
  struct sd_inode *new = (struct sd_inode *)(void *)0;
  struct sd_inode *base;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  base = (struct sd_inode *)return_value_xzalloc$1;
  signed int ret;
  signed int idx;
  if(sd_log_level == 7)
    log_write(7, "rebase_vdi", 442, "%s: size %lu, vid %x, base %x, cur %x, copies %d, snapid %u", iocb->name, iocb->size, new_vid, base_vid, cur_vid, iocb->nr_copies, new_snapid);

  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(base_vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)base, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  unsigned long int return_value_vid_to_vdi_oid$3;
  unsigned long int return_value_vid_to_vdi_oid$4;
  unsigned long int return_value_vid_to_vdi_oid$5;
  if(!(ret == 0x00))
    ret = 0x0C;

  else
  {
    idx=find_free_idx(base->child_vdi_id, sizeof(unsigned int [1024l]) /*4096ul*/  / sizeof(unsigned int) /*4ul*/ );
    if(!(idx >= 0))
      ret = 0x13;

    else
    {
      return_value_vid_to_vdi_oid$3=vid_to_vdi_oid(cur_vid);
      ret=sd_write_object(return_value_vid_to_vdi_oid$3, (char *)&iocb->time, (unsigned int)sizeof(unsigned long int) /*8ul*/ , 520ul, (_Bool)0);
      if(!(ret == 0x00))
        ret = 0x0B;

      else
      {
        return_value_vid_to_vdi_oid$4=vid_to_vdi_oid(base_vid);
        ret=sd_write_object(return_value_vid_to_vdi_oid$4, (char *)&new_vid, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4ul * (unsigned long int)idx + 568ul, (_Bool)0);
        if(!(ret == 0x00))
          ret = 0x0D;

        else
        {
          new=alloc_inode(iocb, new_snapid, new_vid, base->data_vdi_id);
          return_value_vid_to_vdi_oid$5=vid_to_vdi_oid(new_vid);
          ret=sd_write_object(return_value_vid_to_vdi_oid$5, (char *)new, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0, (_Bool)1);
          if(!(ret == 0x00))
            ret = 0x0B;

        }
      }
    }
  }

out:
  ;
  free((void *)new);
  free((void *)base);
  return ret;
}

// rebuild_erasure_object
// file recovery.c line 403
static void * rebuild_erasure_object(unsigned long int oid, unsigned char idx, struct recovery_obj_work *row)
{
  signed int len;
  unsigned long int return_value_get_store_objsize$1;
  return_value_get_store_objsize$1=get_store_objsize(oid);
  len = (signed int)return_value_get_store_objsize$1;
  char *lost;
  void *return_value_xvalloc$2;
  return_value_xvalloc$2=xvalloc((unsigned long int)len);
  lost = (char *)return_value_xvalloc$2;
  signed int i;
  signed int j;
  unsigned char policy;
  unsigned int return_value_oid_to_vid$3;
  return_value_oid_to_vid$3=oid_to_vid$link4(oid);
  signed int return_value_get_vdi_copy_policy$4;
  return_value_get_vdi_copy_policy$4=get_vdi_copy_policy(return_value_oid_to_vid$3);
  policy = (unsigned char)return_value_get_vdi_copy_policy$4;
  signed int ed = 0;
  signed int edp;
  edp=ec_policy_to_dp$link3(policy, &ed, (signed int *)(void *)0);
  struct fec *ctx;
  ctx=ec_init$link1(ed, edp);
  const signed long int ctx$array_size0 = (signed long int)ed;
  unsigned char *bufs[ctx$array_size0];
  const signed long int bufs$array_size0 = (signed long int)ed;
  signed int idxs[bufs$array_size0];
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    bufs[(signed long int)i] = (unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    idxs[(signed long int)i] = 0;
  i = 0;
  j = 0;
  signed int tmp_post$6;
  for( ; !(i >= edp) && !(j >= ed); i = i + 1)
    if(!(i == (signed int)idx))
    {
      void *return_value_read_erasure_object$5;
      return_value_read_erasure_object$5=read_erasure_object(oid, (unsigned char)i, row);
      bufs[(signed long int)j] = (unsigned char *)return_value_read_erasure_object$5;
      if(!(row->stop == (_Bool)0))
        break;

      if(!(bufs[(signed long int)j] == ((unsigned char *)NULL)))
      {
        tmp_post$6 = j;
        j = j + 1;
        idxs[(signed long int)tmp_post$6] = i;
      }

    }

  if(!(j == ed))
  {
    free((void *)lost);
    lost = (char *)(void *)0;
  }

  else
    ec_decode_buffer(ctx, bufs, idxs, lost, (signed int)idx);

out:
  ;
  ec_destroy$link1(ctx);
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    free((void *)bufs[(signed long int)i]);
  return (void *)lost;
}

// recalculate_vnodes
// file group.c line 103
static void recalculate_vnodes(struct rb_root *nroot)
{
  signed int nr_non_gateway_nodes = 0;
  unsigned long int avg_size = (unsigned long int)0;
  struct sd_node *n;
  float factor;
  struct rb_node *__p110;
  __p110=rb_first(nroot);
  struct rb_node *__n110;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_node *tmp_statement_expression$2;
  do
  {
    if(!(__p110 == ((struct rb_node *)NULL)))
    {
      __n110=rb_next(__p110);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p110;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    if(!(n->space == 0ul))
    {
      avg_size = avg_size + n->space;
      nr_non_gateway_nodes = nr_non_gateway_nodes + 1;
    }

    __p110 = __n110;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  struct sd_node *tmp_statement_expression$5;
  const char *return_value_node_to_str$8;
  if(!(nr_non_gateway_nodes == 0))
  {
    avg_size = avg_size / (unsigned long int)nr_non_gateway_nodes;
    struct rb_node *__p122;
    __p122=rb_first(nroot);
    struct rb_node *__n122;
    do
    {
      if(!(__p122 == ((struct rb_node *)NULL)))
      {
        __n122=rb_next(__p122);
        tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        const struct rb_node *recalculate_vnodes$$1$$2$$1$$__mptr = __p122;
        tmp_statement_expression$5 = (struct sd_node *)((char *)recalculate_vnodes$$1$$2$$1$$__mptr - (signed long int)0ul);
        n = tmp_statement_expression$5;
        tmp_if_expr$6 = 1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        break;

      factor = (float)n->space / (float)avg_size;
      float return_value_rintf$7;
      return_value_rintf$7=rintf((float)128 * factor);
      n->nr_vnodes = (unsigned short int)return_value_rintf$7;
      if(sd_log_level == 7)
      {
        return_value_node_to_str$8=node_to_str(n);
        log_write(7, "recalculate_vnodes", 126, "node %s has %d vnodes, free space %lu", return_value_node_to_str$8, n->nr_vnodes, n->space);
      }

      __p122 = __n122;
    }
    while((_Bool)1);
  }

}

// reclaim_done
// file object_cache.c line 587
static void reclaim_done(struct work *work)
{
  struct reclaim_work *rw;
  struct reclaim_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct reclaim_work *)((char *)__mptr - (signed long int)0ul);
  rw = tmp_statement_expression$1;
  uatomic_set_false(&gcache.in_reclaim);
  free((void *)rw);
}

// recover_erasure_object
// file recovery.c line 478
static signed int recover_erasure_object(struct recovery_obj_work *row)
{
  struct recovery_work *rw = &row->base;
  struct vnode_info *cur = rw->cur_vinfo;
  unsigned long int oid = row->oid;
  struct siocb iocb = { .epoch=(unsigned int)0, .buf=NULL, .length=0u, .offset=0u,
    .ec_index=0, .copy_policy=0 };
  void *buf = (void *)0;
  unsigned char idx;
  signed int ret = -1;
  idx=local_node_copy_index(cur, oid);
  buf=read_erasure_object(oid, idx, row);
  if(buf == NULL)
  {
    if(row->stop == (_Bool)0)
      buf=rebuild_erasure_object(oid, idx, row);

  }

  unsigned long int return_value_get_store_objsize$1;
  if(buf == NULL)
  {
    if(row->stop == (_Bool)0)
      log_write(3, "recover_erasure_object", 494, "failed to recover %lx idx %d", oid, idx);

  }

  else
  {
    iocb.epoch = rw->epoch;
    return_value_get_store_objsize$1=get_store_objsize(oid);
    iocb.length = (unsigned int)return_value_get_store_objsize$1;
    iocb.offset = (unsigned int)0;
    iocb.buf = buf;
    iocb.ec_index = idx;
    ret=sd_store->create_and_write(oid, &iocb);
    free(buf);
  }

out:
  ;
  return ret;
}

// recover_next_object
// file recovery.c line 805
static void recover_next_object(struct recovery_info *rinfo)
{
  _Bool return_value_run_next_rw$1;
  return_value_run_next_rw$1=run_next_rw();
  _Bool return_value_has_scheduled_objects$2;
  if(return_value_run_next_rw$1 == (_Bool)0)
  {
    if(!(rinfo->nr_prio_oids == 0ul))
      finish_schedule_oids(rinfo);

    if(!(sys->cinfo.disable_recovery == 0))
    {
      return_value_has_scheduled_objects$2=has_scheduled_objects(rinfo);
      if(return_value_has_scheduled_objects$2 != (_Bool)0)
        goto __CPROVER_DUMP_L3;

      if(sd_log_level == 7)
        log_write(7, "recover_next_object", 814, "suspended");

      rinfo->suspended = (_Bool)1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      queue_recovery_work(rinfo);
    }
  }

}

// recover_object_from
// file recovery.c line 226
static signed int recover_object_from(struct recovery_obj_work *row, struct sd_node *node, unsigned int tgt_epoch)
{
  unsigned long int oid = row->oid;
  unsigned int local_epoch = row->local_epoch;
  unsigned char *sha1 = row->local_sha1;
  unsigned int epoch = row->base.epoch;
  signed int ret;
  unsigned int rlen;
  void *buf = (void *)0;
  struct sd_req hdr;
  struct sd_rsp *rsp = (struct sd_rsp *)&hdr;
  struct siocb iocb = { .epoch=(unsigned int)0, .buf=NULL, .length=0u, .offset=0u,
    .ec_index=0, .copy_policy=0 };
  _Bool return_value_node_is_local$2;
  return_value_node_is_local$2=node_is_local$link1(node);
  signed int return_value;
  if(!(return_value_node_is_local$2 == (_Bool)0))
  {
    unsigned int return_value_sys_epoch$1;
    return_value_sys_epoch$1=sys_epoch$link3();
    if(!(tgt_epoch >= return_value_sys_epoch$1))
    {
      return_value=sd_store->link(oid, tgt_epoch);
      return return_value;
    }

    return 0x02;
  }

  if(local_epoch >= 1u)
  {
    sd_init_req$link4(&hdr, (unsigned char)0xB4);
    hdr.$anon0.obj.oid = oid;
    hdr.$anon0.obj.tgt_epoch = tgt_epoch;
    ret=sheep_exec_req(&node->nid, &hdr, (void *)0);
    if(!(ret == 0x00))
      return ret;

    signed int return_value_memcmp$3;
    return_value_memcmp$3=memcmp((const void *)rsp->$anon0.hash.digest, (const void *)sha1, sizeof(signed int) /*4ul*/ );
    if(return_value_memcmp$3 == 0)
    {
      if(sd_log_level == 7)
        log_write(7, "recover_object_from", 259, "use local replica at epoch %d", local_epoch);

      ret=sd_store->link(oid, local_epoch);
      if(ret == 0x00)
        return ret;

    }

  }

  unsigned long int return_value_get_store_objsize$4;
  return_value_get_store_objsize$4=get_store_objsize(oid);
  rlen = (unsigned int)return_value_get_store_objsize$4;
  buf=xvalloc((unsigned long int)rlen);
  sd_init_req$link4(&hdr, (unsigned char)0xA4);
  hdr.epoch = epoch;
  hdr.flags = (unsigned short int)0x0080;
  hdr.data_length = rlen;
  hdr.$anon0.obj.oid = oid;
  hdr.$anon0.obj.tgt_epoch = tgt_epoch;
  ret=sheep_exec_req(&node->nid, &hdr, buf);
  if(ret == 0x00)
  {
    iocb.epoch = epoch;
    iocb.length = rsp->data_length;
    iocb.offset = (unsigned int)rsp->$anon0.obj.offset;
    iocb.buf = buf;
    ret=sd_store->create_and_write(oid, &iocb);
  }

  free(buf);
  return ret;
}

// recover_object_from_replica
// file recovery.c line 290
static signed int recover_object_from_replica(struct recovery_obj_work *row, struct vnode_info *old, unsigned int tgt_epoch)
{
  unsigned long int oid = row->oid;
  unsigned int epoch = row->base.epoch;
  signed int nr_copies;
  signed int ret = 0x00;
  signed int start = 0;
  _Bool fully_replicated = (_Bool)1;
  nr_copies=get_obj_copy_number(oid, old->nr_zones);
  signed int i = 0;
  for( ; !(i >= nr_copies); i = i + 1)
  {
    struct sd_vnode *vnode;
    vnode=oid_to_vnode(oid, &old->vroot, i);
    _Bool return_value_vnode_is_local$1;
    return_value_vnode_is_local$1=vnode_is_local$link2(vnode);
    if(!(return_value_vnode_is_local$1 == (_Bool)0))
    {
      start = i;
      break;
    }

  }
  signed int recover_object_from_replica$$1$$2$$i = 0;
  for( ; !(recover_object_from_replica$$1$$2$$i >= nr_copies); recover_object_from_replica$$1$$2$$i = recover_object_from_replica$$1$$2$$i + 1)
  {
    struct sd_node *node;
    signed int idx = (recover_object_from_replica$$1$$2$$i + start) % nr_copies;
    node=oid_to_node(oid, &old->vroot, idx);
    _Bool return_value_invalid_node$2;
    return_value_invalid_node$2=invalid_node(node, row->base.cur_vinfo);
    if(return_value_invalid_node$2 == (_Bool)0)
    {
      ret=recover_object_from(row, node, tgt_epoch);
      switch(ret)
      {
        case 0x00:
        {
          if(sd_log_level == 7)
            log_write(7, "recover_object_from_replica", 327, "recovered oid %lx from %d to epoch %d", oid, tgt_epoch, epoch);

          return ret;
        }
        case 0x81:
          return ret;
        case 0x02:
          fully_replicated = (_Bool)0;
        default:
          ;
      }
    }

  }
  if(!(ret == 0x00) && !(fully_replicated == (_Bool)0))
    ret = 0x90;

  return ret;
}

// recover_object_main
// file recovery.c line 834
static void recover_object_main(struct work *work)
{
  struct recovery_work *rw;
  struct recovery_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct recovery_work *)((char *)__mptr - (signed long int)24ul);
  rw = tmp_statement_expression$1;
  struct recovery_obj_work *row;
  struct recovery_obj_work *tmp_statement_expression$2;
  const struct recovery_work *recover_object_main$$1$$2$$__mptr = rw;
  tmp_statement_expression$2 = (struct recovery_obj_work *)((char *)recover_object_main$$1$$2$$__mptr - (signed long int)0ul);
  row = tmp_statement_expression$2;
  struct recovery_info *rinfo;
  struct recovery_info *tmp_statement_expression$3 = current_rinfo.__val;
  rinfo = tmp_statement_expression$3;
  _Bool return_value_run_next_rw$4;
  return_value_run_next_rw$4=run_next_rw();
  if(return_value_run_next_rw$4 == (_Bool)0)
  {
    if(!(row->stop == (_Bool)0))
    {
      rinfo->notify_complete = (_Bool)0;
      finish_recovery(rinfo);
      if(sd_log_level == 7)
        log_write(7, "recover_object_main", 854, "recovery is stopped");

    }

    else
    {
      wakeup_requests_on_oid(row->oid);
      rinfo->done = rinfo->done + 1ul;
      if(rinfo->done % ((100ul + rinfo->count + 18446744073709551615ul) / 100ul) == 0ul)
        log_write(6, "recover_object_main", 863, "object recovery progress %3.0lf%% ", ((double)rinfo->done / (double)rinfo->count) * (double)100);

      if(sd_log_level == 7)
        log_write(7, "recover_object_main", 865, "object %lx is recovered (%lu/%lu)", row->oid, rinfo->done, rinfo->count);

      if(!(rinfo->done >= rinfo->count))
        recover_next_object(rinfo);

      else
        finish_recovery(rinfo);
    }
  }


out:
  ;
  free_recovery_obj_work(row);
}

// recover_object_work
// file recovery.c line 519
static void recover_object_work(struct work *work)
{
  struct recovery_work *rw;
  struct recovery_work *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct recovery_work *)((char *)__mptr - (signed long int)24ul);
  rw = tmp_statement_expression$1;
  struct recovery_obj_work *row;
  struct recovery_obj_work *tmp_statement_expression$2;
  const struct recovery_work *recover_object_work$$1$$2$$__mptr = rw;
  tmp_statement_expression$2 = (struct recovery_obj_work *)((char *)recover_object_work$$1$$2$$__mptr - (signed long int)0ul);
  row = tmp_statement_expression$2;
  unsigned long int oid = row->oid;
  struct vnode_info *cur = rw->cur_vinfo;
  signed int ret;
  signed int epoch;
  unsigned char return_value_local_node_copy_index$3;
  return_value_local_node_copy_index$3=local_node_copy_index(cur, oid);
  _Bool return_value;
  return_value=sd_store->exist(oid, return_value_local_node_copy_index$3);
  if(!(return_value == (_Bool)0))
  {
    if(sd_log_level == 7)
      log_write(7, "recover_object_work", 531, "the object is already recovered");

  }

  else
  {
    _Bool return_value_is_erasure_oid$5;
    return_value_is_erasure_oid$5=is_erasure_oid(oid);
    if(return_value_is_erasure_oid$5 == (_Bool)0)
    {
      unsigned int return_value_sys_epoch$4;
      return_value_sys_epoch$4=sys_epoch$link3();
      epoch = (signed int)(return_value_sys_epoch$4 - (unsigned int)1);
      if((unsigned int)epoch >= last_gathered_epoch)
      {
        ret=sd_store->get_hash(oid, (unsigned int)epoch, row->local_sha1);
        if(ret == 0x00)
        {
          if(sd_log_level == 7)
            log_write(7, "recover_object_work", 542, "replica found in local at epoch %d", epoch);

          row->local_epoch = (unsigned int)epoch;
        }

        else
          epoch = epoch - 1;
      }

    }

    ret=do_recover_object(row);
    if(!(ret == 0))
      log_write(3, "recover_object_work", 550, "failed to recover object %lx", oid);

  }
}

// recover_replication_object
// file recovery.c line 357
static signed int recover_replication_object(struct recovery_obj_work *row)
{
  struct recovery_work *rw = &row->base;
  struct vnode_info *old;
  unsigned long int oid = row->oid;
  unsigned int tgt_epoch = rw->tgt_epoch;
  signed int ret;
  struct vnode_info *new_old;
  old=grab_vnode_info(rw->old_vinfo);

again:
  ;
  while((_Bool)1)
  {
    if(sd_log_level == 7)
      log_write(7, "recover_replication_object", 369, "try recover object %lx from epoch %u", oid, tgt_epoch);

    ret=recover_object_from_replica(row, old, tgt_epoch);
    switch(ret)
    {
      case 0x00:
        goto out;
      case 0x81:
      {
        row->stop = (_Bool)1;
        goto out;
      }
      case 0x90:
      {
        log_write(1, "recover_replication_object", 382, "cannot access any replicas of %lx at epoch %d", oid, tgt_epoch);
        log_write(1, "recover_replication_object", 383, "clients may see old data");
      }
      default:
      {
        new_old=rollback_vnode_info(&tgt_epoch, rw->cur_vinfo);
        if(new_old == ((struct vnode_info *)NULL))
        {
          log_write(3, "recover_replication_object", 389, "can not recover oid %lx", oid);
          ret = -1;
          goto out;
        }

        put_vnode_info(old);
        old = new_old;
      }
    }
  }

out:
  ;
  put_vnode_info(old);
  return ret;
}

// refcount_dec
// file ../include/util.h line 259
static inline signed int refcount_dec(struct anonymous$2 *rc)
{
  unsigned long int return_value___uatomic_add_return$1;
  return_value___uatomic_add_return$1=__uatomic_add_return((void *)&rc->val, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  return (signed int)return_value___uatomic_add_return$1;
}

// refcount_dec$link1
// file ../include/util.h line 259
static inline signed int refcount_dec$link1(struct anonymous$2 *rc$link1)
{
  unsigned long int return_value___uatomic_add_return$1$link1;
  return_value___uatomic_add_return$1$link1=__uatomic_add_return$link1((void *)&rc$link1->val, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  return (signed int)return_value___uatomic_add_return$1$link1;
}

// refcount_dec$link2
// file ../include/util.h line 259
static inline signed int refcount_dec$link2(struct anonymous$2 *rc$link2)
{
  unsigned long int return_value___uatomic_add_return$1$link2;
  return_value___uatomic_add_return$1$link2=__uatomic_add_return$link2((void *)&rc$link2->val, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
  return (signed int)return_value___uatomic_add_return$1$link2;
}

// refcount_inc
// file ../include/util.h line 254
static inline signed int refcount_inc(struct anonymous$2 *rc)
{
  unsigned long int return_value___uatomic_add_return$1;
  return_value___uatomic_add_return$1=__uatomic_add_return((void *)&rc->val, (unsigned long int)1, (signed int)sizeof(signed int) /*4ul*/ );
  return (signed int)return_value___uatomic_add_return$1;
}

// refcount_inc$link1
// file ../include/util.h line 254
static inline signed int refcount_inc$link1(struct anonymous$2 *rc$link1)
{
  unsigned long int return_value___uatomic_add_return$1$link1;
  return_value___uatomic_add_return$1$link1=__uatomic_add_return$link1((void *)&rc$link1->val, (unsigned long int)1, (signed int)sizeof(signed int) /*4ul*/ );
  return (signed int)return_value___uatomic_add_return$1$link1;
}

// refcount_inc$link2
// file ../include/util.h line 254
static inline signed int refcount_inc$link2(struct anonymous$2 *rc$link2)
{
  unsigned long int return_value___uatomic_add_return$1$link2;
  return_value___uatomic_add_return$1$link2=__uatomic_add_return$link2((void *)&rc$link2->val, (unsigned long int)1, (signed int)sizeof(signed int) /*4ul*/ );
  return (signed int)return_value___uatomic_add_return$1$link2;
}

// refcount_read
// file ../include/util.h line 249
static inline signed int refcount_read(struct anonymous$2 *rc)
{
  volatile signed int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile signed int *)&(*(&rc->val)));
  return tmp_statement_expression$1;
}

// refcount_read$link1
// file ../include/util.h line 249
static inline signed int refcount_read$link1(struct anonymous$2 *rc$link1)
{
  volatile signed int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&rc$link1->val)));
  return tmp_statement_expression$1$link1;
}

// refcount_read$link2
// file ../include/util.h line 249
static inline signed int refcount_read$link2(struct anonymous$2 *rc$link2)
{
  volatile signed int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile signed int *)&(*(&rc$link2->val)));
  return tmp_statement_expression$1$link2;
}

// refcount_set
// file ../include/util.h line 244
static inline void refcount_set(struct anonymous$2 *rc, signed int val)
{
  signed int _v;
  volatile signed int tmp_statement_expression$1;
  *((volatile signed int *)&(*(&rc->val))) = val;
  tmp_statement_expression$1 = *((volatile signed int *)&(*(&rc->val)));
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
}

// refcount_set$link1
// file ../include/util.h line 244
static inline void refcount_set$link1(struct anonymous$2 *rc$link1, signed int val$link1)
{
  signed int _v$link1;
  volatile signed int tmp_statement_expression$1$link1;
  *((volatile signed int *)&(*(&rc$link1->val))) = val$link1;
  tmp_statement_expression$1$link1 = *((volatile signed int *)&(*(&rc$link1->val)));
  _v$link1 = tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
}

// register_event
// file ../include/event.h line 30
static inline signed int register_event(signed int fd, void (*h)(signed int, signed int, void *), void *data)
{
  signed int return_value_register_event_prio$1;
  return_value_register_event_prio$1=register_event_prio(fd, h, data, 0);
  return return_value_register_event_prio$1;
}

// register_event$link1
// file ../include/event.h line 30
static inline signed int register_event$link1(signed int fd$link1, void (*h$link1)(signed int, signed int, void *), void *data$link1)
{
  signed int return_value_register_event_prio$1$link1;
  return_value_register_event_prio$1$link1=register_event_prio(fd$link1, h$link1, data$link1, 0);
  return return_value_register_event_prio$1$link1;
}

// register_event$link2
// file ../include/event.h line 30
static inline signed int register_event$link2(signed int fd$link2, void (*h$link2)(signed int, signed int, void *), void *data$link2)
{
  signed int return_value_register_event_prio$1$link2;
  return_value_register_event_prio$1$link2=register_event_prio(fd$link2, h$link2, data$link2, 0);
  return return_value_register_event_prio$1$link2;
}

// register_event$link3
// file ../include/event.h line 30
static inline signed int register_event$link3(signed int fd$link3, void (*h$link3)(signed int, signed int, void *), void *data$link3)
{
  signed int return_value_register_event_prio$1$link3;
  return_value_register_event_prio$1$link3=register_event_prio(fd$link3, h$link3, data$link3, 0);
  return return_value_register_event_prio$1$link3;
}

// register_event_prio
// file ../include/event.h line 12
signed int register_event_prio(signed int fd, void (*h)(signed int, signed int, void *), void *data, signed int prio)
{
  signed int ret;
  struct epoll_event ev;
  struct event_info *ei;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct event_info) /*56ul*/ );
  ei = (struct event_info *)return_value_xzalloc$1;
  ei->fd = fd;
  ei->handler = h;
  ei->data = data;
  ei->prio = prio;
  memset((void *)&ev, 0, sizeof(struct epoll_event) /*12ul*/ );
  ev.events = (unsigned int)1;
  ev.data.ptr = (void *)ei;
  ret=epoll_ctl(efd, 1, fd, &ev);
  struct event_info *tmp_statement_expression$2;
  if(!(ret == 0))
  {
    log_write(3, "register_event_prio", 117, "failed to add epoll event for fd %d: %m", fd);
    free((void *)ei);
  }

  else
  {
    struct rb_node **__n = &(&events_tree)->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct event_info *__old = (struct event_info *)(void *)0;
    struct event_info *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr = *__n;
      tmp_statement_expression$2 = (struct event_info *)((char *)__mptr - (signed long int)24ul);
      __data = tmp_statement_expression$2;
      signed int __cmp;
      __cmp=event_cmp(ei, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct event_info *)NULL))
    {
      rb_link_node$link6(&ei->rb, __parent, __n);
      rb_insert_color(&ei->rb, &events_tree);
    }

    __old;
  }
  return ret;
}

// remove_cache_object
// file object_cache.c line 291
static signed int remove_cache_object(struct object_cache *oc, unsigned long int idx)
{
  signed int ret = 0x00;
  char path[4096l];
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x/%016lx", (const void *)object_cache_dir, oc->vid, idx);
  unsigned long int return_value_idx_to_oid$1;
  if(sd_log_level == 7)
  {
    return_value_idx_to_oid$1=idx_to_oid(oc->vid, idx);
    log_write(7, "remove_cache_object", 298, "%lx", return_value_idx_to_oid$1);
  }

  signed int return_value_unlink$3;
  return_value_unlink$3=unlink(path);
  if(!(return_value_unlink$3 >= 0))
  {
    log_write(3, "remove_cache_object", 300, "failed to remove cached object %m");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 2)
      return 0x00;

    ret = 0x03;
    goto out;
  }


out:
  ;
  return ret;
}

// remove_epoch
// file ops.c line 237
static signed int remove_epoch(unsigned int epoch)
{
  signed int ret;
  char path[4096l];
  if(sd_log_level == 7)
    log_write(7, "remove_epoch", 242, "remove epoch %u", epoch);

  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s%08u", epoch_path, epoch);
  ret=unlink(path);
  signed int *return_value___errno_location$1;
  if(!(ret == 0))
  {
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      goto __CPROVER_DUMP_L2;

    log_write(3, "remove_epoch", 246, "failed to remove %s: %m", (const void *)path);
    return 0x03;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return 0x00;
  }
}

// remove_vdisks
// file md.c line 112
static void remove_vdisks(struct disk *disk)
{
  unsigned long int hval;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(disk->path);
  hval=sd_hash$link1((const void *)disk->path, return_value_strlen$1);
  signed int nr;
  nr=vdisk_number(disk);
  signed int i = 0;
  for( ; !(i >= nr); i = i + 1)
  {
    struct vdisk *v;
    hval=sd_hash_next$link1(hval);
    v=hval_to_vdisk(hval);
    vdisk_free(v);
  }
}

// replay_journal_entry
// file journal.c line 136
static signed int replay_journal_entry(struct journal_descriptor *jd)
{
  char path[4096l];
  signed long int size;
  signed int fd;
  signed int flags = 01;
  signed int ret = 0;
  void *buf = (void *)0;
  char *p = (char *)jd;
  const char *return_value_md_get_object_dir$1;
  return_value_md_get_object_dir$1=md_get_object_dir(jd->oid);
  snprintf(path, (unsigned long int)4096, "%s/%016lx", return_value_md_get_object_dir$1, jd->oid);
  if((signed int)jd->flag == 2)
  {
    log_write(6, "replay_journal_entry", 148, "%s (remove)", (const void *)path);
    unlink(path);
    return 0;
  }

  else
  {
    if(!((signed int)jd->flag == 0))
    {
      log_write(0, "replay_journal_entry", 156, "PANIC: flag is not JF_STORE, the journaling file is broken. please remove the journaling file and restart sheep daemon");
      abort();
    }

    log_write(6, "replay_journal_entry", 159, "%s, size %lu, off %lu, %d", (const void *)path, jd->size, jd->offset, jd->create);
    if(!(jd->create == 0))
      flags = flags | 0100;

    fd=open(path, flags, sd_def_fmode);
    if(!(fd >= 0))
    {
      log_write(3, "replay_journal_entry", 166, "open %m");
      return -1;
    }

    else
    {
      if(!(jd->create == 0))
      {
        unsigned long int return_value_get_objsize$2;
        return_value_get_objsize$2=get_objsize$link1(jd->oid);
        ret=prealloc(fd, (unsigned int)return_value_get_objsize$2);
        if(!(ret >= 0))
          goto out;

      }

      buf=xmalloc(jd->size);
      p = p + (signed long int)508;
      memcpy(buf, (const void *)p, jd->size);
      size=xpwrite(fd, buf, jd->size, (signed long int)jd->offset);
      if(!((unsigned long int)size == jd->size))
      {
        log_write(3, "replay_journal_entry", 180, "write %zd, size %lu, errno %m", size, jd->size);
        ret = -1;
      }


    out:
      ;
      free(buf);
      close(fd);
      return ret;
    }
  }
}

// request_in_recovery
// file request.c line 169
static _Bool request_in_recovery(struct request *req)
{
  _Bool tmp_if_expr$1;
  if((signed int)req->rq.opcode == 0xA3)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)req->rq.opcode == 0x01 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (_Bool)0;

  else
    if(!((0x0080 & (signed int)req->rq.flags) == 0))
      return (_Bool)0;

    else
    {
      _Bool return_value_oid_in_recovery$2;
      return_value_oid_in_recovery$2=oid_in_recovery(req->local_oid);
      if(!(return_value_oid_in_recovery$2 == (_Bool)0))
      {
        if(sd_log_level == 7)
          log_write(7, "request_in_recovery", 195, "%lx wait on oid", req->local_oid);

        sleep_on_wait_queue(req);
        return (_Bool)1;
      }

      else
        return (_Bool)0;
    }
}

// request_init_operation
// file http/http.c line 141
static signed int request_init_operation(struct http_request *req)
{
  char **env = req->fcgx.envp;
  char *p;
  char *endp;
  p=FCGX_GetParam("REQUEST_METHOD", env);
  signed int return_value_strcmp$5;
  return_value_strcmp$5=strcmp(p, "PUT");
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$5 == 0)
    req->opcode = (enum http_opcode)HTTP_PUT;

  else
  {
    return_value_strcmp$4=strcmp(p, "GET");
    if(return_value_strcmp$4 == 0)
      req->opcode = (enum http_opcode)HTTP_GET;

    else
    {
      return_value_strcmp$3=strcmp(p, "POST");
      if(return_value_strcmp$3 == 0)
        req->opcode = (enum http_opcode)HTTP_POST;

      else
      {
        return_value_strcmp$2=strcmp(p, "DELETE");
        if(return_value_strcmp$2 == 0)
          req->opcode = (enum http_opcode)HTTP_DELETE;

        else
        {
          return_value_strcmp$1=strcmp(p, "HEAD");
          if(return_value_strcmp$1 == 0)
            req->opcode = (enum http_opcode)HTTP_HEAD;

          else
            return BAD_REQUEST;
        }
      }
    }
  }
  p=FCGX_GetParam("CONTENT_LENGTH", env);
  if(!((signed int)*p == 0))
  {
    signed long long int return_value_strtoll$6;
    return_value_strtoll$6=strtoll(p, &endp, 10);
    req->data_length = (unsigned long int)return_value_strtoll$6;
    if(p == endp)
    {
      log_write(3, "request_init_operation", 165, "invalid content_length %s", p);
      return BAD_REQUEST;
    }

  }

  req->uri=FCGX_GetParam("DOCUMENT_URI", env);
  if(req->uri == ((char *)NULL))
    return BAD_REQUEST;

  else
  {
    p=FCGX_GetParam("HTTP_RANGE", env);
    if(!(p == ((char *)NULL)))
    {
      if(!((signed int)*p == 0))
      {
        const char prefix[7l] = { 'b', 'y', 't', 'e', 's', '=', 0 };
        char *left;
        char *right;
        char num[64l];
        unsigned long int max;
        left=strstr(p, prefix);
        if(p == ((char *)NULL))
          goto invalid_range;

        right=strchr(left, 45);
        strncpy(num, (left + (signed long int)sizeof(const char [7l]) /*7ul*/ ) - (signed long int)1, (unsigned long int)(right - left));
        signed long long int return_value_strtoll$7;
        return_value_strtoll$7=strtoll(num, &endp, 10);
        req->offset = (unsigned long int)return_value_strtoll$7;
        if(num == endp)
          goto invalid_range;

        strcpy(num, right + (signed long int)1);
        signed long long int return_value_strtoll$8;
        return_value_strtoll$8=strtoll(num, &endp, 10);
        max = (unsigned long int)(return_value_strtoll$8 + (signed long int)1);
        if(num == endp)
          goto invalid_range;

        if(req->offset >= max)
          goto invalid_range;

        req->data_length = max - req->offset;
        if(sd_log_level == 7)
          log_write(7, "request_init_operation", 198, "HTTP_RANGE: %lu %lu", req->offset, max);

      }

    }

    req->status = (enum http_status)UNKNOWN;
    return OK;

  invalid_range:
    ;
    log_write(3, "request_init_operation", 206, "invalid range %s", p);
    return REQUEST_RANGE_NOT_SATISFIABLE;
  }
}

// requeue_cluster_request
// file group.c line 791
static void requeue_cluster_request(void)
{
  struct request *req;
  struct vdi_op_message *msg;
  unsigned long int size;
  struct request *__n798;
  struct request *tmp_statement_expression$1;
  const struct list_node *requeue_cluster_request$$1$$1$$1$$__mptr;
  struct list_head *tmp_statement_expression$2 = pending_notify_list.__val;
  requeue_cluster_request$$1$$1$$1$$__mptr = tmp_statement_expression$2->n.next;
  tmp_statement_expression$1 = (struct request *)((char *)requeue_cluster_request$$1$$1$$1$$__mptr - (signed long int)144ul);
  req = tmp_statement_expression$1;
  struct request *tmp_statement_expression$3;
  const struct list_node *requeue_cluster_request$$1$$1$$2$$__mptr = req->pending_list.next;
  tmp_statement_expression$3 = (struct request *)((char *)requeue_cluster_request$$1$$1$$2$$__mptr - (signed long int)144ul);
  __n798 = tmp_statement_expression$3;
  struct list_head *tmp_statement_expression$4;
  const char *return_value_op_name$6;
  struct request *tmp_statement_expression$5;
  do
  {
    tmp_statement_expression$4 = pending_notify_list.__val;
    if(&req->pending_list == &tmp_statement_expression$4->n)
      break;

    if(sd_log_level == 7)
    {
      return_value_op_name$6=op_name(req->op);
      log_write(7, "requeue_cluster_request", 807, "finish pending notify request, op: %s", return_value_op_name$6);
    }

    msg=prepare_cluster_msg(req, &size);
    sd_notify_handler(&sys->this_node, (void *)msg, size);
    free((void *)msg);
    req = __n798;
    const struct list_node *requeue_cluster_request$$1$$1$$4$$__mptr = __n798->pending_list.next;
    tmp_statement_expression$5 = (struct request *)((char *)requeue_cluster_request$$1$$1$$4$$__mptr - (signed long int)144ul);
    __n798 = tmp_statement_expression$5;
  }
  while((_Bool)1);
  struct request *__n814;
  struct request *tmp_statement_expression$7;
  const struct list_node *__mptr;
  struct list_head *tmp_statement_expression$8 = pending_block_list.__val;
  __mptr = tmp_statement_expression$8->n.next;
  tmp_statement_expression$7 = (struct request *)((char *)__mptr - (signed long int)144ul);
  req = tmp_statement_expression$7;
  struct request *tmp_statement_expression$9;
  const struct list_node *requeue_cluster_request$$1$$2$$2$$__mptr = req->pending_list.next;
  tmp_statement_expression$9 = (struct request *)((char *)requeue_cluster_request$$1$$2$$2$$__mptr - (signed long int)144ul);
  __n814 = tmp_statement_expression$9;
  struct list_head *tmp_statement_expression$10;
  const char *return_value_op_name$12;
  const char *return_value_op_name$13;
  const char *return_value_op_name$14;
  struct request *tmp_statement_expression$11;
  do
  {
    tmp_statement_expression$10 = pending_block_list.__val;
    if(&req->pending_list == &tmp_statement_expression$10->n)
      break;

    switch((signed int)req->status)
    {
      case REQUEST_INIT:
      {
        if(sd_log_level == 7)
        {
          return_value_op_name$12=op_name(req->op);
          log_write(7, "requeue_cluster_request", 819, "requeue a block request, op: %s", return_value_op_name$12);
        }

        list_del(&req->pending_list);
        queue_cluster_request(req);
        break;
      }
      case REQUEST_QUEUED:
      {
        if(sd_log_level == 7)
        {
          return_value_op_name$13=op_name(req->op);
          log_write(7, "requeue_cluster_request", 833, "drop pending block request, op: %s", return_value_op_name$13);
        }

        req->status = (enum REQUST_STATUS)REQUEST_DROPPED;
        break;
      }
      case REQUEST_DONE:
      {
        if(sd_log_level == 7)
        {
          return_value_op_name$14=op_name(req->op);
          log_write(7, "requeue_cluster_request", 845, "finish pending block request, op: %s", return_value_op_name$14);
        }

        msg=prepare_cluster_msg(req, &size);
        sd_notify_handler(&sys->this_node, (void *)msg, size);
        free((void *)msg);
      }
    }
    req = __n814;
    const struct list_node *requeue_cluster_request$$1$$2$$4$$__mptr = __n814->pending_list.next;
    tmp_statement_expression$11 = (struct request *)((char *)requeue_cluster_request$$1$$2$$4$$__mptr - (signed long int)144ul);
    __n814 = tmp_statement_expression$11;
  }
  while((_Bool)1);
}

// requeue_request
// file request.c line 500
static void requeue_request(struct request *req)
{
  if(!(req->vinfo == ((struct vnode_info *)NULL)))
  {
    put_vnode_info(req->vinfo);
    req->vinfo = (struct vnode_info *)(void *)0;
  }

  stat_request_end(req);
  queue_request(req);
}

// reraise_crash_signal
// file ../include/util.h line 113
void reraise_crash_signal(signed int signo, signed int status)
{
  signed int ret;
  ret=raise(signo);
  char *return_value_strsignal$1;
  char *return_value_strsignal$2;
  if(!(ret == 0))
  {
    return_value_strsignal$1=strsignal(signo);
    log_write(0, "reraise_crash_signal", 468, "failed to re-raise signal %d (%s).", signo, return_value_strsignal$1);
  }

  else
  {
    return_value_strsignal$2=strsignal(signo);
    log_write(0, "reraise_crash_signal", 472, "default handler for the re-raised signal %d (%s) didn't work expectedly", signo, return_value_strsignal$2);
  }
  exit(status);
}

// resume_suspended_recovery
// file sheep_priv.h line 338
void resume_suspended_recovery(void)
{
  struct recovery_info *rinfo;
  struct recovery_info *tmp_statement_expression$1 = current_rinfo.__val;
  rinfo = tmp_statement_expression$1;
  if(!(rinfo == ((struct recovery_info *)NULL)))
  {
    if(!(rinfo->suspended == (_Bool)0))
    {
      rinfo->suspended = (_Bool)0;
      recover_next_object(rinfo);
    }

  }

}

// revalidate_node
// file sockfd_cache.c line 293
static inline signed int revalidate_node(struct node_id *nid)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  signed int fd;
  if(!(use_io == (_Bool)0))
  {
    fd=connect_to_addr(nid->io_addr, (signed int)nid->io_port);
    if(fd >= 0)
      goto alive;

  }

  fd=connect_to_addr(nid->addr, (signed int)nid->port);
  if(!(fd >= 0))
    return 0;

  else
  {

  alive:
    ;
    close(fd);
    sockfd_cache_add(nid);
    return 1;
  }
}

// rmdir_r
// file ../include/util.h line 107
signed int rmdir_r(const char *dir_path)
{
  signed int ret;
  ret=purge_directory(dir_path);
  if(ret == 0)
    ret=rmdir(dir_path);

  return ret;
}

// rollback_vnode_info
// file recovery.c line 97
static struct vnode_info * rollback_vnode_info(unsigned int *epoch, struct vnode_info *cur)
{
  struct vnode_info *vinfo;
  do
  {

  rollback:
    ;
    *epoch = *epoch - (unsigned int)1;
    if(!(*epoch >= last_gathered_epoch))
      return (struct vnode_info *)(void *)0;

    vinfo=get_vnode_info_epoch(*epoch, cur);
    if(!(vinfo == ((struct vnode_info *)NULL)))
      break;

    log_write(1, "rollback_vnode_info", 109, "cannot get epoch %d", *epoch);
    log_write(1, "rollback_vnode_info", 110, "clients may see old data");
  }
  while((_Bool)1);
  return vinfo;
}

// rotate_log
// file logger.c line 453
static void rotate_log(void)
{
  signed int new_fd;
  signed int return_value_access$1;
  return_value_access$1=access(log_nowname, 4);
  if(return_value_access$1 == 0)
  {
    char old_logfile[256l];
    signed long int t;
    struct tm tm;
    time(&t);
    localtime_r((const signed long int *)&t, &tm);
    snprintf(old_logfile, sizeof(char [256l]) /*256ul*/ , "%s.%04d-%02d-%02d-%02d-%02d", log_nowname, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);
    rename(log_nowname, old_logfile);
  }

  new_fd=open(log_nowname, 02 | 0100 | 02000, 0644);
  if(!(new_fd >= 0))
  {
    syslog(3, "failed to create new log file\n");
    exit(1);
  }

  signed int return_value_dup2$2;
  return_value_dup2$2=dup2(new_fd, log_fd);
  if(!(return_value_dup2$2 >= 0))
  {
    syslog(3, "failed to dup2 the log fd\n");
    exit(1);
  }

  close(new_fd);
}

// run_next_rw
// file recovery.c line 674
static inline _Bool run_next_rw(void)
{
  struct recovery_info *nrinfo;
  struct recovery_info *tmp_statement_expression$1;
  unsigned long int ret;
  unsigned long int return_value___uatomic_exchange$2;
  return_value___uatomic_exchange$2=__uatomic_exchange((void *)(unsigned long int *)&next_rinfo, (unsigned long int)(void *)0, (signed int)sizeof(unsigned long int) /*8ul*/ );
  ret = (unsigned long int)return_value___uatomic_exchange$2;
  tmp_statement_expression$1 = (struct recovery_info *)ret;
  nrinfo = tmp_statement_expression$1;
  struct recovery_info *cur;
  struct recovery_info *tmp_statement_expression$3 = current_rinfo.__val;
  cur = tmp_statement_expression$3;
  if(nrinfo == ((struct recovery_info *)NULL))
    return (_Bool)0;

  else
  {
    if(nrinfo->notify_complete == (_Bool)0)
    {
      if(!(cur->notify_complete == (_Bool)0))
        nrinfo->notify_complete = (_Bool)1;

    }

    free_recovery_info(cur);
    _Bool return_value_node_is_gateway_only$4;
    return_value_node_is_gateway_only$4=node_is_gateway_only();
    if(return_value_node_is_gateway_only$4 == (_Bool)0)
      sd_store->update_epoch(nrinfo->tgt_epoch);

    current_rinfo.__val = nrinfo;
    wakeup_all_requests();
    queue_recovery_work(nrinfo);
    if(sd_log_level == 7)
      log_write(7, "run_next_rw", 697, "recovery work is superseded");

    return (_Bool)1;
  }
}

// rx_main
// file request.c line 764
static void rx_main(struct work *work)
{
  struct client_info *ci;
  struct client_info *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct client_info *)((char *)__mptr - (signed long int)72ul);
  ci = tmp_statement_expression$1;
  struct request *req = ci->rx_req;
  ci->rx_req = (struct request *)(void *)0;
  refcount_dec$link1(&ci->refcnt);
  if(!(ci->conn.dead == (_Bool)0))
  {
    if(!(req == ((struct request *)NULL)))
      free_request(req);

    clear_client_info(ci);
  }

  else
  {
    signed int return_value_conn_rx_on$2;
    return_value_conn_rx_on$2=conn_rx_on(&ci->conn);
    if(!(return_value_conn_rx_on$2 == 0))
      log_write(3, "rx_main", 784, "switch on receiving flag failure, connection maybe closed");

    struct sd_op_template *return_value_get_sd_op$6;
    return_value_get_sd_op$6=get_sd_op(req->rq.opcode);
    _Bool return_value_is_logging_op$7;
    return_value_is_logging_op$7=is_logging_op(return_value_get_sd_op$6);
    if(!(return_value_is_logging_op$7 == (_Bool)0))
    {
      struct sd_op_template *return_value_get_sd_op$3;
      return_value_get_sd_op$3=get_sd_op(req->rq.opcode);
      const char *return_value_op_name$4;
      return_value_op_name$4=op_name(return_value_get_sd_op$3);
      const char *return_value_data_to_str$5;
      return_value_data_to_str$5=data_to_str(req->data, (unsigned long int)req->rp.data_length);
      log_write(6, "rx_main", 792, "req=%p, fd=%d, client=%s:%d, op=%s, data=%s", req, ci->conn.fd, (const void *)ci->conn.ipstr, ci->conn.port, return_value_op_name$4, return_value_data_to_str$5);
    }

    else
      if(sd_log_level == 7)
        log_write(7, "rx_main", 797, "%d, %s:%d", ci->conn.fd, (const void *)ci->conn.ipstr, ci->conn.port);

    queue_request(req);
  }
}

// rx_work
// file request.c line 727
static void rx_work(struct work *work)
{
  struct client_info *ci;
  struct client_info *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct client_info *)((char *)__mptr - (signed long int)72ul);
  ci = tmp_statement_expression$1;
  signed int ret;
  struct connection *conn = &ci->conn;
  struct sd_req hdr;
  struct request *req;
  ret=do_read(conn->fd, (void *)&hdr, (signed int)sizeof(struct sd_req) /*48ul*/ , (_Bool (*)(unsigned int))(void *)0, (unsigned int)0, 4294967295U);
  if(!(ret == 0))
  {
    if(sd_log_level == 7)
      log_write(7, "rx_work", 738, "failed to read a header");

    conn->dead = (_Bool)1;
  }

  else
  {
    req=alloc_request(ci, (signed int)hdr.data_length);
    if(req == ((struct request *)NULL))
    {
      log_write(3, "rx_work", 745, "failed to allocate request");
      conn->dead = (_Bool)1;
    }

    else
    {
      ci->rx_req = req;
      memcpy((void *)&req->rq, (const void *)&hdr, sizeof(struct sd_req) /*48ul*/ );
      if(!((0x01 & (signed int)hdr.flags) == 0) && !(hdr.data_length == 0u))
      {
        ret=do_read(conn->fd, req->data, (signed int)hdr.data_length, (_Bool (*)(unsigned int))(void *)0, (unsigned int)0, 4294967295U);
        if(!(ret == 0))
        {
          log_write(3, "rx_work", 758, "failed to read data");
          conn->dead = (_Bool)1;
        }

      }

    }
  }
}

// same_zone
// file ../include/sheep.h line 44
static inline signed int same_zone(struct sd_vnode *v1, struct sd_vnode *v2)
{
  return (signed int)(v1->node->zone == v2->node->zone);
}

// same_zone$link1
// file ../include/sheep.h line 44
static inline signed int same_zone$link1(struct sd_vnode *v1$link1, struct sd_vnode *v2$link1)
{
  return (signed int)(v1$link1->node->zone == v2$link1->node->zone);
}

// same_zone$link2
// file ../include/sheep.h line 44
static inline signed int same_zone$link2(struct sd_vnode *v1$link2, struct sd_vnode *v2$link2)
{
  return (signed int)(v1$link2->node->zone == v2$link2->node->zone);
}

// same_zone$link3
// file ../include/sheep.h line 44
static inline signed int same_zone$link3(struct sd_vnode *v1$link3, struct sd_vnode *v2$link3)
{
  return (signed int)(v1$link3->node->zone == v2$link3->node->zone);
}

// scan_wd
// file md.c line 665
static signed int scan_wd(unsigned long int oid, unsigned int epoch, unsigned char ec_index)
{
  signed int ret = 0x03;
  struct disk *disk;
  sd_read_lock$link3(&md.lock);
  struct rb_node *__p671;
  __p671=rb_first(&md.root);
  struct rb_node *__n671;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct disk *tmp_statement_expression$2;
  do
  {
    if(!(__p671 == ((struct rb_node *)NULL)))
    {
      __n671=rb_next(__p671);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p671;
      tmp_statement_expression$2 = (struct disk *)((char *)__mptr - (signed long int)0ul);
      disk = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    ret=md_check_and_move(oid, epoch, ec_index, disk->path);
    if(ret == 0x00)
      break;

    __p671 = __n671;
  }
  while((_Bool)1);
  sd_rw_unlock$link3(&md.lock);
  return ret;
}

// screen_object_list
// file recovery.c line 944
static void screen_object_list(struct recovery_list_work *rlw, unsigned long int *oids, unsigned long int nr_oids)
{
  struct recovery_work *rw = &rlw->base;
  struct sd_vnode *vnodes[31l];
  unsigned long int old_count = rlw->count;
  unsigned long int nr_objs;
  unsigned long int i;
  unsigned long int j;
  i = (unsigned long int)0;
  unsigned long int *tmp_statement_expression$1;
  unsigned long int tmp_post$5;
  for( ; !(i >= nr_oids); i = i + 1ul)
  {
    unsigned long int *__ret = (unsigned long int *)(void *)0;
    if(old_count >= 1ul)
    {
      void *return_value_bsearch$2;
      return_value_bsearch$2=bsearch((const void *)&oids[(signed long int)i], (const void *)rlw->oids, old_count, sizeof(unsigned long int) /*8ul*/ , (signed int (*)(const void *, const void *))obj_cmp);
      __ret = (unsigned long int *)return_value_bsearch$2;
    }

    tmp_statement_expression$1 = __ret;
    if(tmp_statement_expression$1 == ((unsigned long int *)NULL))
    {
      signed int return_value_get_obj_copy_number$3;
      return_value_get_obj_copy_number$3=get_obj_copy_number(oids[(signed long int)i], rw->cur_vinfo->nr_zones);
      nr_objs = (unsigned long int)return_value_get_obj_copy_number$3;
      oid_to_vnodes$link2(oids[(signed long int)i], &rw->cur_vinfo->vroot, (signed int)nr_objs, vnodes);
      j = (unsigned long int)0;
      for( ; !(j >= nr_objs); j = j + 1ul)
      {
        _Bool return_value_vnode_is_local$4;
        return_value_vnode_is_local$4=vnode_is_local$link2(vnodes[(signed long int)j]);
        if(!(return_value_vnode_is_local$4 == (_Bool)0))
        {
          tmp_post$5 = rlw->count;
          rlw->count = rlw->count + 1ul;
          rlw->oids[(signed long int)tmp_post$5] = oids[(signed long int)i];
          if(rlw->count == list_buffer_size / sizeof(unsigned long int) /*8ul*/ )
          {
            list_buffer_size = list_buffer_size * (unsigned long int)2;
            void *return_value_xrealloc$6;
            return_value_xrealloc$6=xrealloc((void *)rlw->oids, list_buffer_size);
            rlw->oids = (unsigned long int *)return_value_xrealloc$6;
          }

          break;
        }

      }
    }

  }
  if(rlw->count >= 2ul)
    qsort((void *)rlw->oids, rlw->count, sizeof(unsigned long int) /*8ul*/ , (signed int (*)(const void *, const void *))obj_cmp);

}

// sd_accept_handler
// file group.c line 893
void sd_accept_handler(struct sd_node *joined, struct rb_root *nroot, unsigned long int nr_nodes, const void *opaque)
{
  struct cluster_info *cinfo = (struct cluster_info *)opaque;
  struct sd_node *n;
  _Bool return_value_node_is_local$2;
  return_value_node_is_local$2=node_is_local(joined);
  _Bool return_value_cluster_join_check$1;
  if(!(return_value_node_is_local$2 == (_Bool)0))
  {
    return_value_cluster_join_check$1=cluster_join_check(cinfo);
    if(return_value_cluster_join_check$1 == (_Bool)0)
    {
      log_write(3, "sd_accept_handler", 901, "failed to join Sheepdog");
      exit(1);
    }

  }

  cluster_info_copy(&sys->cinfo, cinfo);
  const char *return_value_node_to_str$3;
  if(sd_log_level == 7)
  {
    return_value_node_to_str$3=node_to_str(joined);
    log_write(7, "sd_accept_handler", 907, "join %s", return_value_node_to_str$3);
  }

  struct rb_node *__p908;
  __p908=rb_first(nroot);
  struct rb_node *__n908;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  struct sd_node *tmp_statement_expression$5;
  const char *return_value_node_to_str$7;
  do
  {
    if(!(__p908 == ((struct rb_node *)NULL)))
    {
      __n908=rb_next(__p908);
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      const struct rb_node *__mptr = __p908;
      tmp_statement_expression$5 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$5;
      tmp_if_expr$6 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(!tmp_if_expr$6)
      break;

    if(sd_log_level == 7)
    {
      return_value_node_to_str$7=node_to_str(n);
      log_write(7, "sd_accept_handler", 909, "%s", return_value_node_to_str$7);
    }

    __p908 = __n908;
  }
  while((_Bool)1);
  if(!((signed int)sys->cinfo.status == SD_STATUS_SHUTDOWN))
  {
    update_cluster_info(cinfo, joined, nroot, nr_nodes);
    _Bool return_value_node_is_local$8;
    return_value_node_is_local$8=node_is_local(joined);
    if(!(return_value_node_is_local$8 == (_Bool)0))
    {
      if(sd_log_level == 7)
        log_write(7, "sd_accept_handler", 919, "join Sheepdog cluster");

    }

  }

}

// sd_backtrace
// file ../include/logger.h line 54
void sd_backtrace(void)
{
  void *addrs[1024l];
  signed int i;
  signed int n;
  n=backtrace(addrs, (signed int)(sizeof(void *[1024l]) /*8192ul*/  / sizeof(void *) /*8ul*/ ));
  i = 1;
  char *return_value_fgets$2;
  _Bool tmp_if_expr$4;
  char *return_value_chomp$3;
  for( ; !(i >= n); i = i + 1)
  {
    void *addr = addrs[(signed long int)i];
    signed long int addr$array_size0;
    addr$array_size0=sysconf(0);
    char cmd[addr$array_size0];
    char info[256l];
    char **str;
    struct _IO_FILE *f;
    addr = (void *)((char *)addr - (signed long int)1);
    const char *return_value_my_exe_path$1;
    return_value_my_exe_path$1=my_exe_path();
    snprintf(cmd, (unsigned long int)addr$array_size0, "addr2line -s -e %s -f -i %p | perl -e '@a=<>; chomp @a; print \"$a[1]: $a[0]\"'", return_value_my_exe_path$1, addr);
    f=popen(cmd, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
    {
      return_value_fgets$2=fgets(info, (signed int)sizeof(char [256l]) /*256ul*/ , f);
      if(!(return_value_fgets$2 == ((char *)NULL)))
      {
        if(!((signed int)info[0l] == 63))
          tmp_if_expr$4 = (signed int)info[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          return_value_chomp$3=chomp(info);
          log_write(0, "sd_backtrace", 833, "%s", return_value_chomp$3);
        }

        else
          goto fallback_close;
        pclose(f);
        goto __CPROVER_DUMP_L8;
      }


    fallback_close:
      ;
      pclose(f);
    }


  fallback:
    ;
    str=backtrace_symbols(&addr, 1);
    log_write(0, "sd_backtrace", 847, "%s", *str);
    free((void *)str);

  __CPROVER_DUMP_L8:
    ;
  }
  dump_stack_frames();
}

// sd_block_handler
// file group.c line 269
_Bool sd_block_handler(struct sd_node *sender)
{
  struct request *req;
  _Bool return_value_node_is_local$1;
  return_value_node_is_local$1=node_is_local(sender);
  struct request *tmp_statement_expression$2;
  struct list_head *tmp_statement_expression$3;
  if(return_value_node_is_local$1 == (_Bool)0)
    return (_Bool)0;

  else
    if(!(cluster_op_running == (_Bool)0))
      return (_Bool)0;

    else
    {
      cluster_op_running = (_Bool)1;
      const struct list_node *__mptr;
      tmp_statement_expression$3 = pending_block_list.__val;
      __mptr = tmp_statement_expression$3->n.next;
      tmp_statement_expression$2 = (struct request *)((char *)__mptr - (signed long int)144ul);
      req = tmp_statement_expression$2;
      req->work.fn = do_process_work;
      req->work.done = cluster_op_done;
      queue_work(sys->block_wqueue, &req->work);
      req->status = (enum REQUST_STATUS)REQUEST_QUEUED;
      return (_Bool)1;
    }
}

// sd_cond_broadcast
// file ../include/util.h line 392
static inline signed int sd_cond_broadcast(struct sd_cond *cond)
{
  signed int return_value_pthread_cond_broadcast$1;
  return_value_pthread_cond_broadcast$1=pthread_cond_broadcast(&cond->cond);
  return return_value_pthread_cond_broadcast$1;
}

// sd_cond_init
// file ../include/util.h line 348
static inline void sd_cond_init(struct sd_cond *cond)
{
  signed int ret;
  do
    ret=pthread_cond_init(&cond->cond, (const union anonymous$21 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_cond_init", 357, "PANIC: failed to initialize a lock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_cond_signal
// file ../include/util.h line 373
static inline signed int sd_cond_signal(struct sd_cond *cond)
{
  signed int return_value_pthread_cond_signal$1;
  return_value_pthread_cond_signal$1=pthread_cond_signal(&cond->cond);
  return return_value_pthread_cond_signal$1;
}

// sd_cond_wait
// file ../include/util.h line 378
static inline signed int sd_cond_wait(struct sd_cond *cond, struct sd_mutex *mutex)
{
  signed int return_value_pthread_cond_wait$1;
  return_value_pthread_cond_wait$1=pthread_cond_wait(&cond->cond, &mutex->mutex);
  return return_value_pthread_cond_wait$1;
}

// sd_cond_wait$link1
// file ../include/util.h line 378
static inline signed int sd_cond_wait$link1(struct sd_cond *cond$link1, struct sd_mutex *mutex$link1)
{
  signed int return_value_pthread_cond_wait$1$link1;
  return_value_pthread_cond_wait$1$link1=pthread_cond_wait(&cond$link1->cond, &mutex$link1->mutex);
  return return_value_pthread_cond_wait$1$link1;
}

// sd_delete_vdi
// file vdi.c line 1259
signed int sd_delete_vdi(const char *name)
{
  struct sd_req hdr;
  char data[256l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int ret;
  sd_init_req$link3(&hdr, (unsigned char)0x17);
  hdr.flags = (unsigned short int)0x01;
  hdr.data_length = (unsigned int)sizeof(char [256l]) /*256ul*/ ;
  pstrcpy(data, (signed int)256U, name);
  ret=exec_local_req(&hdr, (void *)data);
  const char *return_value_sd_strerror$1;
  if(!(ret == 0x00))
  {
    return_value_sd_strerror$1=sd_strerror$link4(ret);
    log_write(3, "sd_delete_vdi", 1272, "Failed to delete vdi %s %s", name, return_value_sd_strerror$1);
  }

  return ret;
}

// sd_destroy_cond
// file ../include/util.h line 361
static inline void sd_destroy_cond(struct sd_cond *cond)
{
  signed int ret;
  do
    ret=pthread_cond_destroy(&cond->cond);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_destroy_cond", 370, "PANIC: failed to destroy a lock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_destroy_mutex
// file ../include/util.h line 299
static inline void sd_destroy_mutex(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_destroy(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_destroy_mutex", 308, "PANIC: failed to destroy a lock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_destroy_rw_lock
// file ../include/util.h line 417
static inline void sd_destroy_rw_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_destroy(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_destroy_rw_lock", 426, "PANIC: failed to destroy a lock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_discard_object
// file store.c line 463
signed int sd_discard_object(unsigned long int oid)
{
  signed int ret;
  struct sd_req hdr;
  sd_init_req$link2(&hdr, (unsigned char)0x05);
  hdr.$anon0.obj.oid = oid;
  ret=exec_local_req(&hdr, (void *)0);
  const char *return_value_sd_strerror$1;
  if(!(ret == 0x00))
  {
    return_value_sd_strerror$1=sd_strerror$link3(ret);
    log_write(3, "sd_discard_object", 474, "Failed to discard data obj %lu %s", oid, return_value_sd_strerror$1);
  }

  return ret;
}

// sd_hash
// file ../include/sheepdog_proto.h line 341
static inline unsigned long int sd_hash(const void *buf, unsigned long int len)
{
  unsigned long int hval;
  hval=fnv_64a_buf(buf, len, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1;
  return_value_fnv_64a_64$1=fnv_64a_64(hval, hval);
  return return_value_fnv_64a_64$1;
}

// sd_hash$link1
// file ../include/sheepdog_proto.h line 341
static inline unsigned long int sd_hash$link1(const void *buf$link1, unsigned long int len$link1)
{
  unsigned long int hval$link1;
  hval$link1=fnv_64a_buf$link3(buf$link1, len$link1, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link1;
  return_value_fnv_64a_64$1$link1=fnv_64a_64$link6(hval$link1, hval$link1);
  return return_value_fnv_64a_64$1$link1;
}

// sd_hash$link2
// file ../include/sheepdog_proto.h line 341
static inline unsigned long int sd_hash$link2(const void *buf$link2, unsigned long int len$link2)
{
  unsigned long int hval$link2;
  hval$link2=fnv_64a_buf$link4(buf$link2, len$link2, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link2;
  return_value_fnv_64a_64$1$link2=fnv_64a_64$link7(hval$link2, hval$link2);
  return return_value_fnv_64a_64$1$link2;
}

// sd_hash_64
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64(unsigned long int oid)
{
  unsigned long int hval;
  hval=fnv_64a_64$link1(oid, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1;
  return_value_fnv_64a_64$1=fnv_64a_64$link1(hval, hval);
  return return_value_fnv_64a_64$1;
}

// sd_hash_64$link1
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link1(unsigned long int oid$link1)
{
  unsigned long int hval$link1;
  hval$link1=fnv_64a_64$link2(oid$link1, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link1;
  return_value_fnv_64a_64$1$link1=fnv_64a_64$link2(hval$link1, hval$link1);
  return return_value_fnv_64a_64$1$link1;
}

// sd_hash_64$link2
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link2(unsigned long int oid$link2)
{
  unsigned long int hval$link2;
  hval$link2=fnv_64a_64$link3(oid$link2, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link2;
  return_value_fnv_64a_64$1$link2=fnv_64a_64$link3(hval$link2, hval$link2);
  return return_value_fnv_64a_64$1$link2;
}

// sd_hash_64$link3
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link3(unsigned long int oid$link3)
{
  unsigned long int hval$link3;
  hval$link3=fnv_64a_64$link4(oid$link3, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link3;
  return_value_fnv_64a_64$1$link3=fnv_64a_64$link4(hval$link3, hval$link3);
  return return_value_fnv_64a_64$1$link3;
}

// sd_hash_64$link4
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link4(unsigned long int oid$link4)
{
  unsigned long int hval$link4;
  hval$link4=fnv_64a_64$link5(oid$link4, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link4;
  return_value_fnv_64a_64$1$link4=fnv_64a_64$link5(hval$link4, hval$link4);
  return return_value_fnv_64a_64$1$link4;
}

// sd_hash_64$link5
// file ../include/sheepdog_proto.h line 348
static inline unsigned long int sd_hash_64$link5(unsigned long int oid$link5)
{
  unsigned long int hval$link5;
  hval$link5=fnv_64a_64$link6(oid$link5, (unsigned long int)0xcbf29ce484222325ULL);
  unsigned long int return_value_fnv_64a_64$1$link5;
  return_value_fnv_64a_64$1$link5=fnv_64a_64$link6(hval$link5, hval$link5);
  return return_value_fnv_64a_64$1$link5;
}

// sd_hash_next
// file ../include/sheepdog_proto.h line 355
static inline unsigned long int sd_hash_next(unsigned long int hval)
{
  unsigned long int return_value_fnv_64a_64$1;
  return_value_fnv_64a_64$1=fnv_64a_64(hval, hval);
  return return_value_fnv_64a_64$1;
}

// sd_hash_next$link1
// file ../include/sheepdog_proto.h line 355
static inline unsigned long int sd_hash_next$link1(unsigned long int hval$link1)
{
  unsigned long int return_value_fnv_64a_64$1$link1;
  return_value_fnv_64a_64$1$link1=fnv_64a_64$link6(hval$link1, hval$link1);
  return return_value_fnv_64a_64$1$link1;
}

// sd_hash_oid
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid(unsigned long int oid)
{
  unsigned long int return_value_sd_hash_64$1;
  return_value_sd_hash_64$1=sd_hash_64(oid);
  return return_value_sd_hash_64$1;
}

// sd_hash_oid$link1
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link1(unsigned long int oid$link1)
{
  unsigned long int return_value_sd_hash_64$1$link1;
  return_value_sd_hash_64$1$link1=sd_hash_64$link1(oid$link1);
  return return_value_sd_hash_64$1$link1;
}

// sd_hash_oid$link2
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link2(unsigned long int oid$link2)
{
  unsigned long int return_value_sd_hash_64$1$link2;
  return_value_sd_hash_64$1$link2=sd_hash_64$link2(oid$link2);
  return return_value_sd_hash_64$1$link2;
}

// sd_hash_oid$link3
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link3(unsigned long int oid$link3)
{
  unsigned long int return_value_sd_hash_64$1$link3;
  return_value_sd_hash_64$1$link3=sd_hash_64$link4(oid$link3);
  return return_value_sd_hash_64$1$link3;
}

// sd_hash_oid$link4
// file ../include/sheepdog_proto.h line 364
static inline unsigned long int sd_hash_oid$link4(unsigned long int oid$link4)
{
  unsigned long int return_value_sd_hash_64$1$link4;
  return_value_sd_hash_64$1$link4=sd_hash_64$link5(oid$link4);
  return return_value_sd_hash_64$1$link4;
}

// sd_hash_vdi
// file ../include/sheepdog_proto.h line 373
static inline unsigned int sd_hash_vdi(const char *name)
{
  unsigned long int hval;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  hval=fnv_64a_buf$link1((const void *)name, return_value_strlen$1, (unsigned long int)0xcbf29ce484222325ULL);
  return (unsigned int)(hval & (unsigned long int)((1U << 24) - (unsigned int)1));
}

// sd_hash_vdi$link1
// file ../include/sheepdog_proto.h line 373
static inline unsigned int sd_hash_vdi$link1(const char *name$link1)
{
  unsigned long int hval$link1;
  unsigned long int return_value_strlen$1$link1;
  return_value_strlen$1$link1=strlen(name$link1);
  hval$link1=fnv_64a_buf$link2((const void *)name$link1, return_value_strlen$1$link1, (unsigned long int)0xcbf29ce484222325ULL);
  return (unsigned int)(hval$link1 & (unsigned long int)((1U << 24) - (unsigned int)1));
}

// sd_init_mutex
// file ../include/util.h line 273
static inline void sd_init_mutex(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_init(&mutex->mutex, (const union anonymous$21 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_init_mutex", 282, "PANIC: failed to initialize a lock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_init_mutex$link1
// file ../include/util.h line 273
static inline void sd_init_mutex$link1(struct sd_mutex *mutex$link1)
{
  signed int ret$link1;
  do
    ret$link1=pthread_mutex_init(&mutex$link1->mutex, (const union anonymous$21 *)(void *)0);
  while(ret$link1 == 11);
  if(!(ret$link1 == 0))
  {
    char *return_value_strerror$1$link1;
    return_value_strerror$1$link1=strerror(ret$link1);
    log_write(0, "sd_init_mutex", 282, "PANIC: failed to initialize a lock, %s", return_value_strerror$1$link1);
    abort();
  }

}

// sd_init_mutex$link2
// file ../include/util.h line 273
static inline void sd_init_mutex$link2(struct sd_mutex *mutex$link2)
{
  signed int ret$link2;
  do
    ret$link2=pthread_mutex_init(&mutex$link2->mutex, (const union anonymous$21 *)(void *)0);
  while(ret$link2 == 11);
  if(!(ret$link2 == 0))
  {
    char *return_value_strerror$1$link2;
    return_value_strerror$1$link2=strerror(ret$link2);
    log_write(0, "sd_init_mutex", 282, "PANIC: failed to initialize a lock, %s", return_value_strerror$1$link2);
    abort();
  }

}

// sd_init_req
// file ../include/sheep.h line 37
static inline void sd_init_req(struct sd_req *req, unsigned char opcode)
{
  memset((void *)req, 0, sizeof(struct sd_req) /*48ul*/ );
  req->opcode = opcode;
  req->proto_ver = (unsigned char)((signed int)opcode < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link1
// file ../include/sheep.h line 37
static inline void sd_init_req$link1(struct sd_req *req$link1, unsigned char opcode$link1)
{
  memset((void *)req$link1, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link1->opcode = opcode$link1;
  req$link1->proto_ver = (unsigned char)((signed int)opcode$link1 < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link2
// file ../include/sheep.h line 37
static inline void sd_init_req$link2(struct sd_req *req$link2, unsigned char opcode$link2)
{
  memset((void *)req$link2, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link2->opcode = opcode$link2;
  req$link2->proto_ver = (unsigned char)((signed int)opcode$link2 < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link3
// file ../include/sheep.h line 37
static inline void sd_init_req$link3(struct sd_req *req$link3, unsigned char opcode$link3)
{
  memset((void *)req$link3, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link3->opcode = opcode$link3;
  req$link3->proto_ver = (unsigned char)((signed int)opcode$link3 < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link4
// file ../include/sheep.h line 37
static inline void sd_init_req$link4(struct sd_req *req$link4, unsigned char opcode$link4)
{
  memset((void *)req$link4, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link4->opcode = opcode$link4;
  req$link4->proto_ver = (unsigned char)((signed int)opcode$link4 < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link5
// file ../include/sheep.h line 37
static inline void sd_init_req$link5(struct sd_req *req$link5, unsigned char opcode$link5)
{
  memset((void *)req$link5, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link5->opcode = opcode$link5;
  req$link5->proto_ver = (unsigned char)((signed int)opcode$link5 < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link6
// file ../include/sheep.h line 37
static inline void sd_init_req$link6(struct sd_req *req$link6, unsigned char opcode$link6)
{
  memset((void *)req$link6, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link6->opcode = opcode$link6;
  req$link6->proto_ver = (unsigned char)((signed int)opcode$link6 < 0x80 ? 0x02 : 0x09);
}

// sd_init_req$link7
// file ../include/sheep.h line 37
static inline void sd_init_req$link7(struct sd_req *req$link7, unsigned char opcode$link7)
{
  memset((void *)req$link7, 0, sizeof(struct sd_req) /*48ul*/ );
  req$link7->opcode = opcode$link7;
  req$link7->proto_ver = (unsigned char)((signed int)opcode$link7 < 0x80 ? 0x02 : 0x09);
}

// sd_init_rw_lock
// file ../include/util.h line 405
static inline void sd_init_rw_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_init(&lock->rwlock, (const union anonymous$24 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_init_rw_lock", 414, "PANIC: failed to initialize a lock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_inode_copy_vdis
// file ../include/sheepdog_proto.h line 289
extern void sd_inode_copy_vdis(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), unsigned int *data_vdi_id, unsigned char store_policy, unsigned char nr_copies, unsigned char copy_policy, struct sd_inode *newi)
{
  struct sd_extent_header *header = (struct sd_extent_header *)data_vdi_id;
  struct sd_extent_header *leaf_node;
  struct sd_extent_idx *last_idx;
  struct sd_extent_idx *old_iter_idx;
  struct sd_extent_idx *new_iter_idx;
  unsigned long int oid;
  void *tmp;
  memcpy((void *)newi->data_vdi_id, (const void *)data_vdi_id, sizeof(unsigned int [1048576l]) /*4194304ul*/ );
  unsigned int tmp_post$2;
  if((signed int)store_policy == 1)
  {
    if((signed int)header->depth >= 2)
    {
      last_idx = (struct sd_extent_idx *)((char *)data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)data_vdi_id)->entries;
      old_iter_idx = (struct sd_extent_idx *)((char *)data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      new_iter_idx = (struct sd_extent_idx *)((char *)newi->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      void *return_value_xvalloc$1;
      return_value_xvalloc$1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
      leaf_node = (struct sd_extent_header *)return_value_xvalloc$1;
      tmp = (void *)leaf_node;
      if(!(old_iter_idx == last_idx))
      {
        reader(old_iter_idx->oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
        tmp_post$2 = newi->btree_counter;
        newi->btree_counter = newi->btree_counter + 1u;
        oid=vid_to_btree_oid(newi->vdi_id, tmp_post$2);
        writer(oid, (void *)leaf_node, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)nr_copies, (signed int)copy_policy, (_Bool)1, (_Bool)0);
        new_iter_idx->oid = oid;
        old_iter_idx = old_iter_idx + 1l;
        new_iter_idx = new_iter_idx + 1l;
      }

      free((void *)leaf_node);
    }

  }

}

// sd_inode_get_meta_size
// file sd_inode.c line 626
extern unsigned int sd_inode_get_meta_size(struct sd_inode *inode, unsigned long int size)
{
  struct sd_extent_header *header;
  unsigned int len;
  if((signed int)inode->store_policy == 0)
  {
    unsigned long int return_value_count_data_objs$1;
    return_value_count_data_objs$1=count_data_objs$link1(inode);
    len = (unsigned int)(return_value_count_data_objs$1 * sizeof(unsigned int) /*4ul*/ );
    if(!(size + 18446744073709546952ul + 18446744073709551612ul >= (unsigned long int)len))
      len = (unsigned int)((size - 4664ul) - sizeof(unsigned int) /*4ul*/ );

  }

  else
  {
    header = (struct sd_extent_header *)inode->data_vdi_id;
    len = (unsigned int)sizeof(struct sd_extent_header) /*8ul*/ ;
    if((signed int)header->depth == 1)
      len = len + (unsigned int)(sizeof(struct sd_extent) /*8ul*/  * (unsigned long int)header->entries);

    else
      if((signed int)header->depth == 2)
        len = len + (unsigned int)(sizeof(struct sd_extent_idx) /*16ul*/  * (unsigned long int)header->entries);

      else
      {
        log_write(0, "sd_inode_get_meta_size", 644, "PANIC: Depth of B-tree is out of range(depth: %u)", header->depth);
        abort();
      }
  }
  return len;
}

// sd_inode_get_vid
// file ../include/sheepdog_proto.h line 278
extern unsigned int sd_inode_get_vid(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx)
{
  struct find_path path;
  signed int ret;
  if((signed int)inode->store_policy == 0)
    return inode->data_vdi_id[(signed long int)idx];

  else
  {
    if(inode->data_vdi_id[0l] == 0u)
      return (unsigned int)0;

    memset((void *)&path, 0, sizeof(struct find_path) /*32ul*/ );
    ret=search_whole_btree(reader, inode, idx, &path);
    if(ret == 0x1C)
      return path.p_ext->vdi_id;

    if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
      free((void *)path.p_ext_header);

  }
  return (unsigned int)0;
}

// sd_inode_init
// file ../include/sheepdog_proto.h line 277
extern void sd_inode_init(void *data, signed int depth)
{
  struct sd_extent_header *header = (struct sd_extent_header *)data;
  header->magic = (unsigned short int)0x6274;
  header->depth = (unsigned short int)depth;
  header->entries = (unsigned int)0;
}

// sd_inode_set_vid
// file ../include/sheepdog_proto.h line 280
extern void sd_inode_set_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent_header *header;
  struct find_path path;
  unsigned long int offset;
  signed int ret;
  path.p_ext_header = (struct sd_extent_header *)(void *)0;
  if((signed int)inode->store_policy == 0)
    inode->data_vdi_id[(signed long int)idx] = vdi_id;

  else
  {
    if(inode->data_vdi_id[0l] == 0u)
      sd_inode_init((void *)inode->data_vdi_id, 1);

    header = (struct sd_extent_header *)inode->data_vdi_id;
    if(!((signed int)header->magic == 0x6274))
    {
      log_write(0, "sd_inode_set_vid", 583, "PANIC: %s() B-tree in inode is corrupt!", (const void *)"sd_inode_set_vid");
      abort();
    }

    while((_Bool)1)
    {
      memset((void *)&path, 0, sizeof(struct find_path) /*32ul*/ );
      ret=search_whole_btree(reader, inode, idx, &path);
      if(ret == 0x1C)
      {
        path.p_ext->vdi_id = vdi_id;
        if(path.p_ext_header == ((struct sd_extent_header *)NULL))
          break;

        offset = (unsigned long int)((unsigned char *)path.p_ext - (unsigned char *)path.p_ext_header) + 4ul;
        writer(path.p_idx->oid, (void *)&vdi_id, (unsigned int)sizeof(unsigned int) /*4ul*/ , offset, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
        break;
      }

      else
      {
        ret=insert_new_node(writer, reader, inode, &path, idx, vdi_id);
        if(ret == 0x1D)
        {
          if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
            free((void *)path.p_ext_header);

          continue;
        }

        else
          break;
      }
    }
  }

out:
  ;
  if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
    free((void *)path.p_ext_header);

  if(!((signed int)inode->store_policy == 0))
    dump_btree(reader, inode);

}

// sd_inode_write
// file ../include/sheepdog_proto.h line 283
extern signed int sd_inode_write(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, signed int flags, _Bool create, _Bool direct)
{
  unsigned int len;
  signed int ret;
  unsigned long int return_value_vid_to_vdi_oid$1;
  if((signed int)inode->store_policy == 0)
  {
    return_value_vid_to_vdi_oid$1=vid_to_vdi_oid$link5(inode->vdi_id);
    ret=writer(return_value_vid_to_vdi_oid$1, (void *)inode, (unsigned int)4664ul, (unsigned long int)0, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, direct);
  }

  else
  {
    unsigned int return_value_sd_inode_get_meta_size$2;
    return_value_sd_inode_get_meta_size$2=sd_inode_get_meta_size(inode, (unsigned long int)0);
    len = (unsigned int)(4664ul + (unsigned long int)return_value_sd_inode_get_meta_size$2);
    unsigned long int return_value_vid_to_vdi_oid$3;
    return_value_vid_to_vdi_oid$3=vid_to_vdi_oid$link5(inode->vdi_id);
    ret=writer(return_value_vid_to_vdi_oid$3, (void *)inode, len, (unsigned long int)0, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, (_Bool)0);
    if(ret == 0x00)
    {
      unsigned long int return_value_vid_to_vdi_oid$4;
      return_value_vid_to_vdi_oid$4=vid_to_vdi_oid$link5(inode->vdi_id);
      ret=writer(return_value_vid_to_vdi_oid$4, (void *)inode, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4198968ul, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, (_Bool)0);
    }

  }

out:
  ;
  return ret;
}

// sd_inode_write_vid
// file ../include/sheepdog_proto.h line 285
extern signed int sd_inode_write_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, unsigned int idx, unsigned int vid, unsigned int value, signed int flags, _Bool create, _Bool direct)
{
  signed int ret = 0x00;
  unsigned long int return_value_vid_to_vdi_oid$1;
  if((signed int)inode->store_policy == 0)
  {
    return_value_vid_to_vdi_oid$1=vid_to_vdi_oid$link5(vid);
    ret=writer(return_value_vid_to_vdi_oid$1, (void *)&value, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4664ul + sizeof(unsigned int) /*4ul*/  * (unsigned long int)idx, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, direct);
  }

  else
    ret=sd_inode_write(writer, inode, flags, create, direct);
  return ret;
}

// sd_join_handler
// file group.c line 748
_Bool sd_join_handler(struct sd_node *joining, struct rb_root *nroot, unsigned long int nr_nodes, void *opaque)
{
  struct cluster_info *cinfo = (struct cluster_info *)opaque;
  enum sd_status status;
  _Bool return_value_node_is_local$1;
  const char *return_value_node_to_str$2;
  const char *return_value_addr_to_str$3;
  if(nr_nodes >= 1ul)
  {
    return_value_node_is_local$1=node_is_local(joining);
    if(return_value_node_is_local$1 == (_Bool)0)
      goto __CPROVER_DUMP_L2;

    if(sd_log_level == 7)
      log_write(7, "sd_join_handler", 761, "wait for another node to accept this node");

    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(sd_log_level == 7)
    {
      return_value_node_to_str$2=node_to_str(joining);
      log_write(7, "sd_join_handler", 765, "check %s, %d", return_value_node_to_str$2, sys->cinfo.status);
    }

    if((signed int)sys->cinfo.status == SD_STATUS_WAIT)
      status=cluster_wait_check(joining, nroot, nr_nodes, cinfo);

    else
      status = (enum sd_status)sys->cinfo.status;
    cluster_info_copy(cinfo, &sys->cinfo);
    cinfo->status = status;
    cinfo->proto_ver = (unsigned char)0x09;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str$3=addr_to_str(joining->nid.addr, joining->nid.port);
      log_write(7, "sd_join_handler", 778, "%s: cluster_status = 0x%x", return_value_addr_to_str$3, cinfo->status);
    }

    return (_Bool)1;
  }
}

// sd_leave_handler
// file group.c line 922
void sd_leave_handler(struct sd_node *left, struct rb_root *nroot, unsigned long int nr_nodes)
{
  struct vnode_info *old_vnode_info;
  struct sd_node *n;
  signed int ret;
  const char *return_value_node_to_str$1;
  if(sd_log_level == 7)
  {
    return_value_node_to_str$1=node_to_str(left);
    log_write(7, "sd_leave_handler", 929, "leave %s", return_value_node_to_str$1);
  }

  struct rb_node *__p930;
  __p930=rb_first(nroot);
  struct rb_node *__n930;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct sd_node *tmp_statement_expression$3;
  const char *return_value_node_to_str$5;
  do
  {
    if(!(__p930 == ((struct rb_node *)NULL)))
    {
      __n930=rb_next(__p930);
      tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      const struct rb_node *__mptr = __p930;
      tmp_statement_expression$3 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$3;
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    if(sd_log_level == 7)
    {
      return_value_node_to_str$5=node_to_str(n);
      log_write(7, "sd_leave_handler", 931, "%s", return_value_node_to_str$5);
    }

    __p930 = __n930;
  }
  while((_Bool)1);
  struct vnode_info *tmp_statement_expression$7;
  struct vnode_info *tmp_statement_expression$8;
  if(!((signed int)sys->cinfo.status == SD_STATUS_SHUTDOWN))
  {
    _Bool return_value_node_is_local$6;
    return_value_node_is_local$6=node_is_local(left);
    if(!(return_value_node_is_local$6 == (_Bool)0))
      sys->this_node.nr_vnodes = (unsigned short int)0;

    tmp_statement_expression$7 = current_vnode_info.__val;
    old_vnode_info = tmp_statement_expression$7;
    current_vnode_info.__val=alloc_vnode_info(nroot);
    if((signed int)sys->cinfo.status == SD_STATUS_OK)
    {
      ret=inc_and_log_epoch();
      if(!(ret == 0))
      {
        log_write(0, "sd_leave_handler", 950, "PANIC: cannot log current epoch %d", sys->cinfo.epoch);
        abort();
      }

      tmp_statement_expression$8 = current_vnode_info.__val;
      start_recovery(tmp_statement_expression$8, old_vnode_info, (_Bool)1);
    }

    put_vnode_info(old_vnode_info);
    sockfd_cache_del_node(&left->nid);
  }

}

// sd_lookup_vdi
// file vdi.c line 1277
signed int sd_lookup_vdi(const char *name, unsigned int *vid)
{
  signed int ret;
  struct vdi_info info = { .vid=0u, .snapid=0u, .free_bit=0u, .create_time=0ul };
  struct vdi_iocb iocb;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  iocb = (struct vdi_iocb){ .name=name, .tag=((const char *)NULL), .data_len=(unsigned int)return_value_strlen$1,
    .size=0ul,
    .base_vid=0u, .snapid=0u, .create_snapshot=(_Bool)0,
    .copy_policy=0, .store_policy=0,
    .nr_copies=0, .time=0ul };
  ret=vdi_lookup(&iocb, &info);
  switch(ret)
  {
    case 0x00:
    {
      *vid = info.vid;
      break;
    }
    case 0x08:
      break;
    default:
    {
      const char *return_value_sd_strerror$2;
      return_value_sd_strerror$2=sd_strerror$link4(ret);
      log_write(3, "sd_lookup_vdi", 1294, "Failed to lookup name %s, %s", name, return_value_sd_strerror$2);
    }
  }
  return ret;
}

// sd_migrate_store
// file sheep_priv.h line 465
signed int sd_migrate_store(signed int from, signed int to)
{
  signed int ver;
  signed int ret;
  ret=backup_store();
  if(!(ret == 0))
  {
    log_write(3, "sd_migrate_store", 520, "failed to backup the old store");
    return ret;
  }

  else
  {
    ver = from;
    if(!(ver >= to))
    {
      ret=migrate[(signed long int)ver]();
      if(!(ret >= 0))
        return ret;

      ver = ver + 1;
    }

    return 0;
  }
}

// sd_mutex_lock
// file ../include/util.h line 311
static inline void sd_mutex_lock(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_lock(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror$1);
    abort();
  }

}

// sd_mutex_lock$link1
// file ../include/util.h line 311
static inline void sd_mutex_lock$link1(struct sd_mutex *mutex$link1)
{
  signed int ret$link1;
  do
    ret$link1=pthread_mutex_lock(&mutex$link1->mutex);
  while(ret$link1 == 11);
  if(!(ret$link1 == 0))
  {
    char *return_value_strerror$1$link1;
    return_value_strerror$1$link1=strerror(ret$link1);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link1);
    abort();
  }

}

// sd_mutex_lock$link2
// file ../include/util.h line 311
static inline void sd_mutex_lock$link2(struct sd_mutex *mutex$link2)
{
  signed int ret$link2;
  do
    ret$link2=pthread_mutex_lock(&mutex$link2->mutex);
  while(ret$link2 == 11);
  if(!(ret$link2 == 0))
  {
    char *return_value_strerror$1$link2;
    return_value_strerror$1$link2=strerror(ret$link2);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link2);
    abort();
  }

}

// sd_mutex_lock$link3
// file ../include/util.h line 311
static inline void sd_mutex_lock$link3(struct sd_mutex *mutex$link3)
{
  signed int ret$link3;
  do
    ret$link3=pthread_mutex_lock(&mutex$link3->mutex);
  while(ret$link3 == 11);
  if(!(ret$link3 == 0))
  {
    char *return_value_strerror$1$link3;
    return_value_strerror$1$link3=strerror(ret$link3);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link3);
    abort();
  }

}

// sd_mutex_lock$link4
// file ../include/util.h line 311
static inline void sd_mutex_lock$link4(struct sd_mutex *mutex$link4)
{
  signed int ret$link4;
  do
    ret$link4=pthread_mutex_lock(&mutex$link4->mutex);
  while(ret$link4 == 11);
  if(!(ret$link4 == 0))
  {
    char *return_value_strerror$1$link4;
    return_value_strerror$1$link4=strerror(ret$link4);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link4);
    abort();
  }

}

// sd_mutex_trylock
// file ../include/util.h line 323
static inline signed int sd_mutex_trylock(struct sd_mutex *mutex)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&mutex->mutex);
  return return_value_pthread_mutex_trylock$1;
}

// sd_mutex_trylock$link1
// file ../include/util.h line 323
static inline signed int sd_mutex_trylock$link1(struct sd_mutex *mutex$link1)
{
  signed int return_value_pthread_mutex_trylock$1$link1;
  return_value_pthread_mutex_trylock$1$link1=pthread_mutex_trylock(&mutex$link1->mutex);
  return return_value_pthread_mutex_trylock$1$link1;
}

// sd_mutex_unlock
// file ../include/util.h line 328
static inline void sd_mutex_unlock(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_unlock(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_mutex_unlock$link1
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link1(struct sd_mutex *mutex$link1)
{
  signed int ret$link1;
  do
    ret$link1=pthread_mutex_unlock(&mutex$link1->mutex);
  while(ret$link1 == 11);
  if(!(ret$link1 == 0))
  {
    char *return_value_strerror$1$link1;
    return_value_strerror$1$link1=strerror(ret$link1);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror$1$link1);
    abort();
  }

}

// sd_mutex_unlock$link2
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link2(struct sd_mutex *mutex$link2)
{
  signed int ret$link2;
  do
    ret$link2=pthread_mutex_unlock(&mutex$link2->mutex);
  while(ret$link2 == 11);
  if(!(ret$link2 == 0))
  {
    char *return_value_strerror$1$link2;
    return_value_strerror$1$link2=strerror(ret$link2);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror$1$link2);
    abort();
  }

}

// sd_mutex_unlock$link3
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link3(struct sd_mutex *mutex$link3)
{
  signed int ret$link3;
  do
    ret$link3=pthread_mutex_unlock(&mutex$link3->mutex);
  while(ret$link3 == 11);
  if(!(ret$link3 == 0))
  {
    char *return_value_strerror$1$link3;
    return_value_strerror$1$link3=strerror(ret$link3);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror$1$link3);
    abort();
  }

}

// sd_mutex_unlock$link4
// file ../include/util.h line 328
static inline void sd_mutex_unlock$link4(struct sd_mutex *mutex$link4)
{
  signed int ret$link4;
  do
    ret$link4=pthread_mutex_unlock(&mutex$link4->mutex);
  while(ret$link4 == 11);
  if(!(ret$link4 == 0))
  {
    char *return_value_strerror$1$link4;
    return_value_strerror$1$link4=strerror(ret$link4);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror$1$link4);
    abort();
  }

}

// sd_notify_handler
// file group.c line 700
void sd_notify_handler(struct sd_node *sender, void *data, unsigned long int data_len)
{
  struct vdi_op_message *msg = (struct vdi_op_message *)data;
  struct sd_op_template *op;
  op=get_sd_op(msg->req.opcode);
  signed int ret = (signed int)msg->rsp.$anon0.result;
  struct request *req = (struct request *)(void *)0;
  const char *return_value_op_name$1;
  const char *return_value_node_to_str$2;
  if(sd_log_level == 7)
  {
    return_value_op_name$1=op_name(op);
    return_value_node_to_str$2=node_to_str(sender);
    log_write(7, "sd_notify_handler", 709, "op %s, size: %zu, from: %s", return_value_op_name$1, data_len, return_value_node_to_str$2);
  }

  _Bool return_value_node_is_local$8;
  return_value_node_is_local$8=node_is_local(sender);
  struct request *tmp_statement_expression$3;
  struct list_head *tmp_statement_expression$4;
  struct request *tmp_statement_expression$5;
  struct list_head *tmp_statement_expression$6;
  if(!(return_value_node_is_local$8 == (_Bool)0))
  {
    _Bool return_value_has_process_work$7;
    return_value_has_process_work$7=has_process_work(op);
    if(!(return_value_has_process_work$7 == (_Bool)0))
    {
      const struct list_node *sd_notify_handler$$1$$2$$1$$__mptr;
      tmp_statement_expression$4 = pending_block_list.__val;
      sd_notify_handler$$1$$2$$1$$__mptr = tmp_statement_expression$4->n.next;
      tmp_statement_expression$3 = (struct request *)((char *)sd_notify_handler$$1$$2$$1$$__mptr - (signed long int)144ul);
      req = tmp_statement_expression$3;
    }

    else
    {
      const struct list_node *__mptr;
      tmp_statement_expression$6 = pending_notify_list.__val;
      __mptr = tmp_statement_expression$6->n.next;
      tmp_statement_expression$5 = (struct request *)((char *)__mptr - (signed long int)144ul);
      req = tmp_statement_expression$5;
    }
    list_del(&req->pending_list);
  }

  _Bool return_value_has_process_main$9;
  if(ret == 0x00)
  {
    return_value_has_process_main$9=has_process_main(op);
    if(!(return_value_has_process_main$9 == (_Bool)0))
      ret=do_process_main(op, &msg->req, &msg->rsp, (void *)msg->data);

  }

  if(!(req == ((struct request *)NULL)))
  {
    msg->rsp.$anon0.result = (unsigned int)ret;
    _Bool return_value_has_process_main$10;
    return_value_has_process_main$10=has_process_main(req->op);
    if(!(return_value_has_process_main$10 == (_Bool)0))
    {
      if((0x01 & (signed int)req->rq.flags) == 0)
        memcpy(req->data, (const void *)msg->data, (unsigned long int)msg->rsp.data_length);

    }

    memcpy((void *)&req->rp, (const void *)&msg->rsp, sizeof(struct sd_rsp) /*48ul*/ );
    put_request(req);
  }

  _Bool return_value_has_process_work$11;
  return_value_has_process_work$11=has_process_work(op);
  if(!(return_value_has_process_work$11 == (_Bool)0))
    cluster_op_running = (_Bool)0;

}

// sd_read_lock
// file ../include/util.h line 429
static inline void sd_read_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_rdlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror$1);
    abort();
  }

}

// sd_read_lock$link1
// file ../include/util.h line 429
static inline void sd_read_lock$link1(struct sd_rw_lock *lock$link1)
{
  signed int ret$link1;
  do
    ret$link1=pthread_rwlock_rdlock(&lock$link1->rwlock);
  while(ret$link1 == 11);
  if(!(ret$link1 == 0))
  {
    char *return_value_strerror$1$link1;
    return_value_strerror$1$link1=strerror(ret$link1);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link1);
    abort();
  }

}

// sd_read_lock$link2
// file ../include/util.h line 429
static inline void sd_read_lock$link2(struct sd_rw_lock *lock$link2)
{
  signed int ret$link2;
  do
    ret$link2=pthread_rwlock_rdlock(&lock$link2->rwlock);
  while(ret$link2 == 11);
  if(!(ret$link2 == 0))
  {
    char *return_value_strerror$1$link2;
    return_value_strerror$1$link2=strerror(ret$link2);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link2);
    abort();
  }

}

// sd_read_lock$link3
// file ../include/util.h line 429
static inline void sd_read_lock$link3(struct sd_rw_lock *lock$link3)
{
  signed int ret$link3;
  do
    ret$link3=pthread_rwlock_rdlock(&lock$link3->rwlock);
  while(ret$link3 == 11);
  if(!(ret$link3 == 0))
  {
    char *return_value_strerror$1$link3;
    return_value_strerror$1$link3=strerror(ret$link3);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link3);
    abort();
  }

}

// sd_read_lock$link4
// file ../include/util.h line 429
static inline void sd_read_lock$link4(struct sd_rw_lock *lock$link4)
{
  signed int ret$link4;
  do
    ret$link4=pthread_rwlock_rdlock(&lock$link4->rwlock);
  while(ret$link4 == 11);
  if(!(ret$link4 == 0))
  {
    char *return_value_strerror$1$link4;
    return_value_strerror$1$link4=strerror(ret$link4);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror$1$link4);
    abort();
  }

}

// sd_read_object
// file store.c line 422
signed int sd_read_object(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset)
{
  signed int ret;
  _Bool return_value_object_is_cached$2;
  if(!(sys->enable_object_cache == (_Bool)0))
  {
    return_value_object_is_cached$2=object_is_cached(oid);
    if(return_value_object_is_cached$2 == (_Bool)0)
      goto forward_read;

    ret=object_cache_read(oid, data, datalen, offset);
    if(!(ret == 0x00))
    {
      const char *return_value_sd_strerror$1;
      return_value_sd_strerror$1=sd_strerror$link3(ret);
      log_write(3, "sd_read_object", 431, "try forward read %lx %s", oid, return_value_sd_strerror$1);
      goto forward_read;
    }

    return ret;
  }

  else
  {

  forward_read:
    ;
    signed int return_value_read_backend_object$3;
    return_value_read_backend_object$3=read_backend_object(oid, data, datalen, offset);
    return return_value_read_backend_object$3;
  }
}

// sd_reconnect_handler
// file group.c line 856
signed int sd_reconnect_handler(void)
{
  sys->cinfo.status = (enum sd_status)SD_STATUS_WAIT;
  signed int return_value;
  return_value=sys->cdrv->init(sys->cdrv_option);
  if(!(return_value == 0))
    return -1;

  else
  {
    signed int return_value_send_join_request$1;
    return_value_send_join_request$1=send_join_request();
    if(!(return_value_send_join_request$1 == 0))
      return -1;

    else
    {
      requeue_cluster_request();
      return 0;
    }
  }
}

// sd_remove_object
// file store.c line 441
signed int sd_remove_object(unsigned long int oid)
{
  struct sd_req hdr;
  signed int ret;
  _Bool return_value_object_is_cached$1;
  const char *return_value_sd_strerror$2;
  if(!(sys->enable_object_cache == (_Bool)0))
  {
    return_value_object_is_cached$1=object_is_cached(oid);
    if(return_value_object_is_cached$1 == (_Bool)0)
      goto __CPROVER_DUMP_L1;

    ret=object_cache_remove(oid);
    if(ret == 0x00)
      goto __CPROVER_DUMP_L1;

    return ret;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    sd_init_req$link2(&hdr, (unsigned char)0x04);
    hdr.$anon0.obj.oid = oid;
    ret=exec_local_req(&hdr, (void *)0);
    if(!(ret == 0x00))
    {
      return_value_sd_strerror$2=sd_strerror$link3(ret);
      log_write(3, "sd_remove_object", 458, "failed to remove object %lx, %s", oid, return_value_sd_strerror$2);
    }

    return ret;
  }
}

// sd_rw_unlock
// file ../include/util.h line 457
static inline void sd_rw_unlock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_unlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror$1);
    abort();
  }

}

// sd_rw_unlock$link1
// file ../include/util.h line 457
static inline void sd_rw_unlock$link1(struct sd_rw_lock *lock$link1)
{
  signed int ret$link1;
  do
    ret$link1=pthread_rwlock_unlock(&lock$link1->rwlock);
  while(ret$link1 == 11);
  if(!(ret$link1 == 0))
  {
    char *return_value_strerror$1$link1;
    return_value_strerror$1$link1=strerror(ret$link1);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror$1$link1);
    abort();
  }

}

// sd_rw_unlock$link2
// file ../include/util.h line 457
static inline void sd_rw_unlock$link2(struct sd_rw_lock *lock$link2)
{
  signed int ret$link2;
  do
    ret$link2=pthread_rwlock_unlock(&lock$link2->rwlock);
  while(ret$link2 == 11);
  if(!(ret$link2 == 0))
  {
    char *return_value_strerror$1$link2;
    return_value_strerror$1$link2=strerror(ret$link2);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror$1$link2);
    abort();
  }

}

// sd_rw_unlock$link3
// file ../include/util.h line 457
static inline void sd_rw_unlock$link3(struct sd_rw_lock *lock$link3)
{
  signed int ret$link3;
  do
    ret$link3=pthread_rwlock_unlock(&lock$link3->rwlock);
  while(ret$link3 == 11);
  if(!(ret$link3 == 0))
  {
    char *return_value_strerror$1$link3;
    return_value_strerror$1$link3=strerror(ret$link3);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror$1$link3);
    abort();
  }

}

// sd_rw_unlock$link4
// file ../include/util.h line 457
static inline void sd_rw_unlock$link4(struct sd_rw_lock *lock$link4)
{
  signed int ret$link4;
  do
    ret$link4=pthread_rwlock_unlock(&lock$link4->rwlock);
  while(ret$link4 == 11);
  if(!(ret$link4 == 0))
  {
    char *return_value_strerror$1$link4;
    return_value_strerror$1$link4=strerror(ret$link4);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror$1$link4);
    abort();
  }

}

// sd_strerror
// file ../include/sheep.h line 119
static inline const char * sd_strerror(signed int err)
{
  _Bool tmp_if_expr$1;
  static const char *descs[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err >= 0) || (unsigned long int)err >= 256ul)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = descs[(signed long int)err] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    static char msg[32l];
    snprintf(msg, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err);
    return msg;
  }

  else
    return descs[(signed long int)err];
}

// sd_strerror$link1
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link1(signed int err$link1)
{
  _Bool tmp_if_expr$1$link1;
  static const char *descs$link1[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link1 >= 0) || (unsigned long int)err$link1 >= 256ul)
    tmp_if_expr$1$link1 = (_Bool)1;

  else
    tmp_if_expr$1$link1 = descs$link1[(signed long int)err$link1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link1)
  {
    static char msg$link1[32l];
    snprintf(msg$link1, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link1);
    return msg$link1;
  }

  else
    return descs$link1[(signed long int)err$link1];
}

// sd_strerror$link2
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link2(signed int err$link2)
{
  _Bool tmp_if_expr$1$link2;
  static const char *descs$link2[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link2 >= 0) || (unsigned long int)err$link2 >= 256ul)
    tmp_if_expr$1$link2 = (_Bool)1;

  else
    tmp_if_expr$1$link2 = descs$link2[(signed long int)err$link2] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link2)
  {
    static char msg$link2[32l];
    snprintf(msg$link2, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link2);
    return msg$link2;
  }

  else
    return descs$link2[(signed long int)err$link2];
}

// sd_strerror$link3
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link3(signed int err$link3)
{
  _Bool tmp_if_expr$1$link3;
  static const char *descs$link3[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link3 >= 0) || (unsigned long int)err$link3 >= 256ul)
    tmp_if_expr$1$link3 = (_Bool)1;

  else
    tmp_if_expr$1$link3 = descs$link3[(signed long int)err$link3] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link3)
  {
    static char msg$link3[32l];
    snprintf(msg$link3, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link3);
    return msg$link3;
  }

  else
    return descs$link3[(signed long int)err$link3];
}

// sd_strerror$link4
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link4(signed int err$link4)
{
  _Bool tmp_if_expr$1$link4;
  static const char *descs$link4[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link4 >= 0) || (unsigned long int)err$link4 >= 256ul)
    tmp_if_expr$1$link4 = (_Bool)1;

  else
    tmp_if_expr$1$link4 = descs$link4[(signed long int)err$link4] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link4)
  {
    static char msg$link4[32l];
    snprintf(msg$link4, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link4);
    return msg$link4;
  }

  else
    return descs$link4[(signed long int)err$link4];
}

// sd_strerror$link5
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link5(signed int err$link5)
{
  _Bool tmp_if_expr$1$link5;
  static const char *descs$link5[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link5 >= 0) || (unsigned long int)err$link5 >= 256ul)
    tmp_if_expr$1$link5 = (_Bool)1;

  else
    tmp_if_expr$1$link5 = descs$link5[(signed long int)err$link5] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link5)
  {
    static char msg$link5[32l];
    snprintf(msg$link5, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link5);
    return msg$link5;
  }

  else
    return descs$link5[(signed long int)err$link5];
}

// sd_strerror$link6
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link6(signed int err$link6)
{
  _Bool tmp_if_expr$1$link6;
  static const char *descs$link6[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link6 >= 0) || (unsigned long int)err$link6 >= 256ul)
    tmp_if_expr$1$link6 = (_Bool)1;

  else
    tmp_if_expr$1$link6 = descs$link6[(signed long int)err$link6] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link6)
  {
    static char msg$link6[32l];
    snprintf(msg$link6, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link6);
    return msg$link6;
  }

  else
    return descs$link6[(signed long int)err$link6];
}

// sd_strerror$link7
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link7(signed int err$link7)
{
  _Bool tmp_if_expr$1$link7;
  static const char *descs$link7[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link7 >= 0) || (unsigned long int)err$link7 >= 256ul)
    tmp_if_expr$1$link7 = (_Bool)1;

  else
    tmp_if_expr$1$link7 = descs$link7[(signed long int)err$link7] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link7)
  {
    static char msg$link7[32l];
    snprintf(msg$link7, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link7);
    return msg$link7;
  }

  else
    return descs$link7[(signed long int)err$link7];
}

// sd_strerror$link8
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link8(signed int err$link8)
{
  _Bool tmp_if_expr$1$link8;
  static const char *descs$link8[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link8 >= 0) || (unsigned long int)err$link8 >= 256ul)
    tmp_if_expr$1$link8 = (_Bool)1;

  else
    tmp_if_expr$1$link8 = descs$link8[(signed long int)err$link8] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link8)
  {
    static char msg$link8[32l];
    snprintf(msg$link8, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link8);
    return msg$link8;
  }

  else
    return descs$link8[(signed long int)err$link8];
}

// sd_strerror$link9
// file ../include/sheep.h line 119
static inline const char * sd_strerror$link9(signed int err$link9)
{
  _Bool tmp_if_expr$1$link9;
  static const char *descs$link9[256l] = { "Success", "Unknown error", "No object found", "I/O error", "VDI exists already", "Invalid parameters", "System error", "VDI is already locked", "No VDI found", "No base VDI found", "Failed to read from requested VDI", "Failed to write to requested VDI", "Failed to read from base VDI", "Failed to write to base VDI", "Failed to find requested tag", "System is still booting", "VDI is not locked", "System is shutting down", "Out of memory on server", "Maximum number of VDIs reached", "Protocol version mismatch", "Server has no space for new objects", "Waiting for cluster to be formatted", "Waiting for other nodes to join cluster",
    "Node has failed to join cluster", "IO has halted as there are not enough living nodes",
    "Object is read-only", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Request has an old epoch", "Request has a new epoch", "Cluster has not been formatted", "Creation times differ", "Invalid epoch", "Network error between sheep", "No cache object found", "The buffer is too small", "Cluster is running/halted and cannot be force recovered",
    "Targeted backend store is not found", "Operation is not supported", "Targeted node is in recovery", "Node is killed", "Object ID exists already", "Ask to try again", "Object may be stale", "Cluster driver error", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
  if(!(err$link9 >= 0) || (unsigned long int)err$link9 >= 256ul)
    tmp_if_expr$1$link9 = (_Bool)1;

  else
    tmp_if_expr$1$link9 = descs$link9[(signed long int)err$link9] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1$link9)
  {
    static char msg$link9[32l];
    snprintf(msg$link9, sizeof(char [32l]) /*32ul*/ , "Invalid error code %x", err$link9);
    return msg$link9;
  }

  else
    return descs$link9[(signed long int)err$link9];
}

// sd_update_node_handler
// file group.c line 989
void sd_update_node_handler(struct sd_node *node)
{
  update_node_size(node);
  kick_node_recover();
}

// sd_write_lock
// file ../include/util.h line 445
static inline void sd_write_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_wrlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(ret);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror$1);
    abort();
  }

}

// sd_write_lock$link1
// file ../include/util.h line 445
static inline void sd_write_lock$link1(struct sd_rw_lock *lock$link1)
{
  signed int ret$link1;
  do
    ret$link1=pthread_rwlock_wrlock(&lock$link1->rwlock);
  while(ret$link1 == 11);
  if(!(ret$link1 == 0))
  {
    char *return_value_strerror$1$link1;
    return_value_strerror$1$link1=strerror(ret$link1);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror$1$link1);
    abort();
  }

}

// sd_write_lock$link2
// file ../include/util.h line 445
static inline void sd_write_lock$link2(struct sd_rw_lock *lock$link2)
{
  signed int ret$link2;
  do
    ret$link2=pthread_rwlock_wrlock(&lock$link2->rwlock);
  while(ret$link2 == 11);
  if(!(ret$link2 == 0))
  {
    char *return_value_strerror$1$link2;
    return_value_strerror$1$link2=strerror(ret$link2);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror$1$link2);
    abort();
  }

}

// sd_write_lock$link3
// file ../include/util.h line 445
static inline void sd_write_lock$link3(struct sd_rw_lock *lock$link3)
{
  signed int ret$link3;
  do
    ret$link3=pthread_rwlock_wrlock(&lock$link3->rwlock);
  while(ret$link3 == 11);
  if(!(ret$link3 == 0))
  {
    char *return_value_strerror$1$link3;
    return_value_strerror$1$link3=strerror(ret$link3);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror$1$link3);
    abort();
  }

}

// sd_write_lock$link4
// file ../include/util.h line 445
static inline void sd_write_lock$link4(struct sd_rw_lock *lock$link4)
{
  signed int ret$link4;
  do
    ret$link4=pthread_rwlock_wrlock(&lock$link4->rwlock);
  while(ret$link4 == 11);
  if(!(ret$link4 == 0))
  {
    char *return_value_strerror$1$link4;
    return_value_strerror$1$link4=strerror(ret$link4);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror$1$link4);
    abort();
  }

}

// sd_write_object
// file store.c line 362
signed int sd_write_object(unsigned long int oid, char *data, unsigned int datalen, unsigned long int offset, _Bool create)
{
  struct sd_req hdr;
  signed int ret;
  _Bool return_value_object_is_cached$1;
  const char *return_value_sd_strerror$2;
  if(!(sys->enable_object_cache == (_Bool)0))
  {
    return_value_object_is_cached$1=object_is_cached(oid);
    if(return_value_object_is_cached$1 == (_Bool)0)
      goto forward_write;

    ret=object_cache_write(oid, data, datalen, offset, create);
    if(ret == 0x87)
      goto forward_write;

    if(ret == 0)
      goto forward_write;

    log_write(3, "sd_write_object", 376, "write cache failed %lx %x", oid, ret);
    return ret;
  }

  else
  {

  forward_write:
    ;
    if(!(create == (_Bool)0))
      sd_init_req$link2(&hdr, (unsigned char)0x01);

    else
      sd_init_req$link2(&hdr, (unsigned char)0x03);
    hdr.flags = (unsigned short int)0x01;
    hdr.data_length = datalen;
    hdr.$anon0.obj.oid = oid;
    hdr.$anon0.obj.offset = (unsigned int)offset;
    ret=exec_local_req(&hdr, (void *)data);
    if(!(ret == 0x00))
    {
      return_value_sd_strerror$2=sd_strerror$link3(ret);
      log_write(3, "sd_write_object", 395, "failed to write object %lx, %s", oid, return_value_sd_strerror$2);
    }

    return ret;
  }
}

// sdlog_help
// file sheep.c line 180
static void sdlog_help(void)
{
  printf("Available log levels:\n  Level      Description\n  emerg      system has failed and is unusable\n  alert      action must be taken immediately\n  crit       critical conditions\n  err        error conditions\n  warning    warning conditions\n  notice     normal but significant conditions\n  info       informational notices\n  debug      debugging messages\n");
}

// search_erasure_object
// file recovery.c line 128
static signed int search_erasure_object(unsigned long int oid, unsigned char idx, struct rb_root *nroot, struct recovery_work *rw, unsigned int tgt_epoch, void *buf)
{
  struct sd_req hdr;
  unsigned int rlen;
  unsigned long int return_value_get_store_objsize$1;
  return_value_get_store_objsize$1=get_store_objsize(oid);
  rlen = (unsigned int)return_value_get_store_objsize$1;
  struct sd_node *n;
  unsigned int epoch = rw->epoch;
  struct rb_node *__p139;
  __p139=rb_first(nroot);
  struct rb_node *__n139;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  struct sd_node *tmp_statement_expression$3;
  const char *return_value_node_to_str$6;
  do
  {
    if(!(__p139 == ((struct rb_node *)NULL)))
    {
      __n139=rb_next(__p139);
      tmp_if_expr$2 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
    {
      const struct rb_node *__mptr = __p139;
      tmp_statement_expression$3 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$3;
      tmp_if_expr$4 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    _Bool return_value_invalid_node$5;
    return_value_invalid_node$5=invalid_node(n, rw->cur_vinfo);
    if(return_value_invalid_node$5 == (_Bool)0)
    {
      sd_init_req$link4(&hdr, (unsigned char)0xA4);
      hdr.epoch = epoch;
      hdr.flags = (unsigned short int)0x0080;
      hdr.data_length = rlen;
      hdr.$anon0.obj.oid = oid;
      hdr.$anon0.obj.tgt_epoch = tgt_epoch;
      hdr.$anon0.obj.ec_index = idx;
      if(sd_log_level == 7)
      {
        return_value_node_to_str$6=node_to_str$link2(n);
        log_write(7, "search_erasure_object", 151, "%lx epoch %u tgt %u idx %d, %s", oid, epoch, tgt_epoch, idx, return_value_node_to_str$6);
      }

      signed int return_value_sheep_exec_req$7;
      return_value_sheep_exec_req$7=sheep_exec_req(&n->nid, &hdr, buf);
      if(return_value_sheep_exec_req$7 == 0x00)
        return 0x00;

    }

    __p139 = __n139;
  }
  while((_Bool)1);
  return 0x02;
}

// search_ext_entry
// file sd_inode.c line 271
static struct sd_extent * search_ext_entry(struct sd_extent_header *header, unsigned int idx)
{
  struct sd_extent tmp;
  tmp.idx = idx;
  void *return_value_binary_search$1;
  return_value_binary_search$1=binary_search((void *)(struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (void *)((struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries), (void *)&tmp, sizeof(struct sd_extent) /*8ul*/ , extent_comp);
  return (struct sd_extent *)return_value_binary_search$1;
}

// search_idx_entry
// file sd_inode.c line 281
static struct sd_extent_idx * search_idx_entry(struct sd_extent_header *header, unsigned int idx)
{
  struct sd_extent_idx tmp;
  tmp.idx = idx;
  void *return_value_binary_search$1;
  return_value_binary_search$1=binary_search((void *)(struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (void *)((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries), (void *)&tmp, sizeof(struct sd_extent_idx) /*16ul*/ , index_comp);
  return (struct sd_extent_idx *)return_value_binary_search$1;
}

// search_whole_btree
// file sd_inode.c line 392
static signed int search_whole_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, struct find_path *path)
{
  struct sd_extent_header *header;
  struct sd_extent_header *leaf_node;
  void *tmp;
  unsigned long int oid;
  signed int ret = 0x1B;
  header = (struct sd_extent_header *)inode->data_vdi_id;
  _Bool tmp_if_expr$5;
  if((signed int)header->depth == 2)
  {
    path->depth = 2;
    path->p_idx=search_idx_entry(header, idx);
    void *return_value_xvalloc$1;
    return_value_xvalloc$1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
    leaf_node = (struct sd_extent_header *)return_value_xvalloc$1;
    tmp = (void *)leaf_node;
    _Bool return_value_idx_in_range$3;
    return_value_idx_in_range$3=idx_in_range(header, path->p_idx);
    if(!(return_value_idx_in_range$3 == (_Bool)0))
    {
      oid = path->p_idx->oid;
      ret=reader(oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
      path->p_ext=search_ext_entry(leaf_node, idx);
      path->p_ext_header = leaf_node;
      _Bool return_value_ext_in_range$2;
      return_value_ext_in_range$2=ext_in_range(leaf_node, path->p_ext);
      if(!(return_value_ext_in_range$2 == (_Bool)0))
      {
        if(path->p_ext->idx == idx)
          ret = 0x1C;

      }

    }

    else
    {
      oid = (path->p_idx - (signed long int)1)->oid;
      ret=reader(oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
      if(!((unsigned long int)leaf_node->entries >= 524287ul))
      {
        path->p_ext=search_ext_entry(leaf_node, idx);
        path->p_ext_header = leaf_node;
      }

    }
  }

  else
    if((signed int)header->depth == 1)
    {
      path->depth = 1;
      path->p_ext=search_ext_entry(header, idx);
      _Bool return_value_ext_in_range$4;
      return_value_ext_in_range$4=ext_in_range(header, path->p_ext);
      if(!(return_value_ext_in_range$4 == (_Bool)0))
        tmp_if_expr$5 = path->p_ext->idx == idx ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        ret = 0x1C;

      else
        ret = 0x1B;
    }


out:
  ;
  return ret;
}

// send_join_request
// file group.c line 783
static signed int send_join_request(void)
{
  struct sd_node *n = &sys->this_node;
  const char *return_value_node_to_str$1;
  return_value_node_to_str$1=node_to_str(n);
  log_write(6, "send_join_request", 787, "%s going to join the cluster", return_value_node_to_str$1);
  signed int return_value;
  return_value=sys->cdrv->join(n, (void *)&sys->cinfo, sizeof(struct cluster_info) /*491568ul*/ );
  return return_value;
}

// send_req
// file ../include/net.h line 47
signed int send_req(signed int sockfd, struct sd_req *hdr, void *data, unsigned int wlen, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  struct msghdr msg;
  struct iovec iov[2l];
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  iov[(signed long int)0].iov_base = (void *)hdr;
  iov[(signed long int)0].iov_len = sizeof(struct sd_req) /*48ul*/ ;
  if(!(wlen == 0u))
  {
    msg.msg_iovlen = msg.msg_iovlen + 1ul;
    iov[(signed long int)1].iov_base = data;
    iov[(signed long int)1].iov_len = (unsigned long int)wlen;
  }

  ret=do_write(sockfd, &msg, (signed int)(sizeof(struct sd_req) /*48ul*/  + (unsigned long int)wlen), need_retry, epoch, max_count);
  if(!(ret == 0))
  {
    log_write(3, "send_req", 319, "failed to send request %x, %d: %m", hdr->opcode, wlen);
    ret = -1;
  }

  return ret;
}

// set_bit_64
// file ../include/bitops.h line 139
static inline void set_bit_64(signed int nr, unsigned long int *addr)
{
  addr[(signed long int)((unsigned long int)nr / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = addr[(signed long int)((unsigned long int)nr / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | 1ULL << (unsigned long int)nr % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );
}

// set_cluster_config
// file sheep_priv.h line 350
signed int set_cluster_config(struct cluster_info *cinfo)
{
  config.ctime = cinfo->ctime;
  config.copies = cinfo->nr_copies;
  config.copy_policy = cinfo->copy_policy;
  config.flags = cinfo->flags;
  memset((void *)config.store, 0, sizeof(unsigned char [16l]) /*16ul*/ );
  pstrcpy((char *)config.store, (signed int)sizeof(unsigned char [16l]) /*16ul*/ , (char *)cinfo->store);
  signed int return_value_write_config$1;
  return_value_write_config$1=write_config();
  return return_value_write_config$1;
}

// set_cluster_shutdown
// file sheep_priv.h line 355
signed int set_cluster_shutdown(_Bool down)
{
  config.shutdown = (unsigned char)down;
  signed int return_value_write_config$1;
  return_value_write_config$1=write_config();
  return return_value_write_config$1;
}

// set_keepalive
// file net.c line 467
signed int set_keepalive(signed int fd)
{
  signed int val = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(fd, 1, 9, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt$1 >= 0))
  {
    if(sd_log_level == 7)
      log_write(7, "set_keepalive", 472, "%m");

    return -1;
  }

  else
  {
    val = 5;
    signed int return_value_setsockopt$2;
    return_value_setsockopt$2=setsockopt(fd, 6, 4, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt$2 >= 0))
    {
      if(sd_log_level == 7)
        log_write(7, "set_keepalive", 477, "%m");

      return -1;
    }

    else
    {
      val = 1;
      signed int return_value_setsockopt$3;
      return_value_setsockopt$3=setsockopt(fd, 6, 5, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt$3 >= 0))
      {
        if(sd_log_level == 7)
          log_write(7, "set_keepalive", 482, "%m");

        return -1;
      }

      else
      {
        val = 3;
        signed int return_value_setsockopt$4;
        return_value_setsockopt$4=setsockopt(fd, 6, 6, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_setsockopt$4 >= 0))
        {
          if(sd_log_level == 7)
            log_write(7, "set_keepalive", 487, "%m");

          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// set_loglevel
// file ../include/logger.h line 120
void set_loglevel(signed int new_loglevel)
{
  sd_log_level = new_loglevel;
}

// set_node_space
// file sheep_priv.h line 351
signed int set_node_space(unsigned long int space)
{
  config.space = space;
  signed int return_value_write_config$1;
  return_value_write_config$1=write_config();
  return return_value_write_config$1;
}

// set_nodelay
// file ../include/net.h line 59
signed int set_nodelay(signed int fd)
{
  signed int ret;
  signed int opt = 1;
  ret=setsockopt(fd, 6, 1, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return ret;
}

// set_object_sha1
// file plain_store.c line 573
static signed int set_object_sha1(const char *path, const unsigned char *sha1)
{
  signed int ret;
  ret=setxattr(path, "user.obj.sha1", (const void *)sha1, (unsigned long int)20, 0);
  if(!(ret >= 0))
    log_write(3, "set_object_sha1", 579, "fail to set sha1, %s", path);

  return ret;
}

// set_rcv_timeout
// file net.c line 438
signed int set_rcv_timeout(signed int fd)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)30;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(fd, 1, 20, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  return return_value_setsockopt$1;
}

// set_snd_timeout
// file net.c line 427
signed int set_snd_timeout(signed int fd)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)5;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(fd, 1, 21, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  return return_value_setsockopt$1;
}

// set_thread_name
// file logger.c line 738
void set_thread_name(const char *name, _Bool show_idx)
{
  worker_name = name;
  if(!(show_idx == (_Bool)0))
    worker_idx=gettid();

}

// set_try_to_free_routine
// file util.c line 34
void (*set_try_to_free_routine(void (*routine)(unsigned long int)))(unsigned long int)
{
  void (*old)(unsigned long int) = try_to_free_routine;
  if(routine == ((void (*)(unsigned long int))NULL))
    routine = do_nothing;

  try_to_free_routine = routine;
  return old;
}

// setup_backend_store
// file group.c line 582
static void setup_backend_store(struct cluster_info *cinfo)
{
  signed int ret;
  struct sd_node *tmp_statement_expression$1;
  if(!((signed int)cinfo->store[0l] == 0))
  {
    if(sd_store == ((struct store_driver *)NULL))
    {
      sd_store=find_store_driver((char *)cinfo->store);
      if(sd_store == ((struct store_driver *)NULL))
      {
        log_write(0, "setup_backend_store", 592, "PANIC: backend store %s not supported", (const void *)cinfo->store);
        abort();
      }

      ret=sd_store->init();
      if(!(ret == 0x00))
      {
        log_write(0, "setup_backend_store", 596, "PANIC: failed to initialize store");
        abort();
      }

    }

    struct sd_node *__ret = (struct sd_node *)(void *)0;
    if((signed int)cinfo->nr_nodes >= 1)
    {
      unsigned long int __n = (unsigned long int)cinfo->nr_nodes;
      void *return_value_lfind$2;
      return_value_lfind$2=lfind((const void *)&sys->this_node, (const void *)cinfo->nodes, &__n, sizeof(struct sd_node) /*80ul*/ , (signed int (*)(const void *, const void *))node_cmp);
      __ret = (struct sd_node *)return_value_lfind$2;
    }

    tmp_statement_expression$1 = __ret;
    if(tmp_statement_expression$1 == ((struct sd_node *)NULL))
    {
      ret=sd_store->purge_obj();
      if(!(ret == 0x00))
      {
        log_write(0, "setup_backend_store", 607, "PANIC: can't remove stale objects");
        abort();
      }

    }

  }

}

// sha1_to_hex
// file ../include/sha1.h line 34
const char * sha1_to_hex(const unsigned char *sha1)
{
  static char buffer[50l];
  char *buf = buffer;
  signed int i = 0;
  const unsigned char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  for( ; !(i >= 20); i = i + 1)
  {
    unsigned int val;
    tmp_post$1 = sha1;
    sha1 = sha1 + 1l;
    val = (unsigned int)*tmp_post$1;
    tmp_post$2 = buf;
    buf = buf + 1l;
    static const char hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
    *tmp_post$2 = hex[(signed long int)(val >> 4)];
    tmp_post$3 = buf;
    buf = buf + 1l;
    *tmp_post$3 = hex[(signed long int)(val & (unsigned int)0xf)];
  }
  return buffer;
}

// sheep_bnode_reader
// file vdi.c line 39
signed int sheep_bnode_reader(unsigned long int oid, void **mem, unsigned int len, unsigned long int offset)
{
  signed int return_value_sd_read_object$1;
  return_value_sd_read_object$1=sd_read_object(oid, (char *)*mem, len, offset);
  return return_value_sd_read_object$1;
}

// sheep_bnode_writer
// file vdi.c line 32
signed int sheep_bnode_writer(unsigned long int oid, void *mem, unsigned int len, unsigned long int offset, unsigned int flags, signed int copies, signed int copy_policy, _Bool create, _Bool direct)
{
  signed int return_value_sd_write_object$1;
  return_value_sd_write_object$1=sd_write_object(oid, (char *)mem, len, offset, create);
  return return_value_sd_write_object$1;
}

// sheep_exec_req
// file sheep_priv.h line 470
signed int sheep_exec_req(struct node_id *nid, struct sd_req *hdr, void *buf)
{
  struct sd_rsp *rsp = (struct sd_rsp *)hdr;
  struct sockfd *sfd;
  signed int ret;
  sfd=sockfd_cache_get(nid);
  const char *return_value_sd_strerror$1;
  const char *return_value_addr_to_str$2;
  struct sd_op_template *return_value_get_sd_op$3;
  const char *return_value_op_name$4;
  if(sfd == ((struct sockfd *)NULL))
    return 0x86;

  else
  {
    ret=exec_req(sfd->fd, hdr, buf, sheep_need_retry, hdr->epoch, (unsigned int)(30 / 5));
    if(!(ret == 0))
    {
      if(sd_log_level == 7)
        log_write(7, "sheep_exec_req", 1122, "remote node might have gone away");

      sockfd_cache_del(nid, sfd);
      return 0x86;
    }

    else
    {
      ret = (signed int)rsp->$anon0.result;
      if(!(ret == 0x00))
      {
        return_value_sd_strerror$1=sd_strerror$link1(ret);
        return_value_addr_to_str$2=addr_to_str(nid->addr, nid->port);
        return_value_get_sd_op$3=get_sd_op(hdr->opcode);
        return_value_op_name$4=op_name(return_value_get_sd_op$3);
        log_write(3, "sheep_exec_req", 1131, "failed %s, remote address: %s, op name: %s", return_value_sd_strerror$1, return_value_addr_to_str$2, return_value_op_name$4);
      }

      sockfd_cache_put(nid, sfd);
      return ret;
    }
  }
}

// sheep_need_retry
// file request.c line 1137
_Bool sheep_need_retry(unsigned int epoch)
{
  unsigned int return_value_sys_epoch$1;
  return_value_sys_epoch$1=sys_epoch$link1();
  return return_value_sys_epoch$1 == epoch;
}

// sighup_handler
// file sheep.c line 601
static void sighup_handler(signed int signum)
{
  if(!(logger_pid == -1))
    kill(logger_pid, 1);

}

// sighup_handler$link1
// file logger.c line 555
static void sighup_handler$link1(signed int signo)
{
  rotate_log();
}

// signal_handler
// file sheep.c line 221
static void signal_handler(signed int listen_fd, signed int events, void *data)
{
  struct signalfd_siginfo siginfo;
  signed int ret = ret;
  signed long int return_value_read$1;
  return_value_read$1=read(sigfd, (void *)&siginfo, sizeof(struct signalfd_siginfo) /*128ul*/ );
  ret = (signed int)return_value_read$1;
  if(sd_log_level == 7)
    log_write(7, "signal_handler", 228, "signal %d", siginfo.ssi_signo);

  if(siginfo.ssi_signo == 15u)
  {
    sys->cinfo.status = (enum sd_status)SD_STATUS_KILLED;
    goto __CPROVER_DUMP_L4;
  }

  log_write(3, "signal_handler", 234, "signal %d unhandled", siginfo.ssi_signo);

__CPROVER_DUMP_L4:
  ;
}

// sleep_on_wait_queue
// file request.c line 85
static inline void sleep_on_wait_queue(struct request *req)
{
  list_add_tail$link1(&req->request_list, &sys->req_wait_queue);
}

// slots_all_free
// file sockfd_cache.c line 132
static inline _Bool slots_all_free(struct sockfd_cache_entry *entry)
{
  signed int i = 0;
  _Bool return_value_uatomic_is_true$1;
  for( ; !(i >= fds_count); i = i + 1)
  {
    return_value_uatomic_is_true$1=uatomic_is_true$link2(&(entry->fds + (signed long int)i)->in_use);
    if(!(return_value_uatomic_is_true$1 == (_Bool)0))
      return (_Bool)0;

  }
  return (_Bool)1;
}

// snapshot_vdi
// file vdi.c line 365
static signed int snapshot_vdi(struct vdi_iocb *iocb, unsigned int new_snapid, unsigned int new_vid, unsigned int base_vid)
{
  struct sd_inode *new = (struct sd_inode *)(void *)0;
  struct sd_inode *base;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  base = (struct sd_inode *)return_value_xzalloc$1;
  signed int ret;
  signed int idx;
  if(sd_log_level == 7)
    log_write(7, "snapshot_vdi", 373, "%s: size %lu, vid %x, base %x, copies %d, snapid %u", iocb->name, iocb->size, new_vid, base_vid, iocb->nr_copies, new_snapid);

  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(base_vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)base, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  unsigned long int return_value_vid_to_vdi_oid$3;
  unsigned long int return_value_vid_to_vdi_oid$4;
  if(!(ret == 0x00))
    ret = 0x0C;

  else
  {
    idx=find_free_idx(base->child_vdi_id, sizeof(unsigned int [1024l]) /*4096ul*/  / sizeof(unsigned int) /*4ul*/ );
    if(!(idx >= 0))
      ret = 0x13;

    else
    {
      base->snap_ctime = iocb->time;
      base->child_vdi_id[(signed long int)idx] = new_vid;
      return_value_vid_to_vdi_oid$3=vid_to_vdi_oid(base_vid);
      ret=sd_write_object(return_value_vid_to_vdi_oid$3, (char *)base, (unsigned int)4664ul, (unsigned long int)0, (_Bool)0);
      if(!(ret == 0x00))
        ret = 0x0D;

      else
      {
        new=alloc_inode(iocb, new_snapid, new_vid, base->data_vdi_id);
        return_value_vid_to_vdi_oid$4=vid_to_vdi_oid(new_vid);
        ret=sd_write_object(return_value_vid_to_vdi_oid$4, (char *)new, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0, (_Bool)1);
        if(!(ret == 0x00))
          ret = 0x0B;

      }
    }
  }

out:
  ;
  free((void *)new);
  free((void *)base);
  return ret;
}

// sockaddr_in_to_str
// file net.c line 394
char * sockaddr_in_to_str(struct sockaddr_in *sockaddr)
{
  signed int i;
  signed int si;
  unsigned char *addr;
  si = 0;
  static char str[32l];
  memset((void *)str, 0, (unsigned long int)32);
  addr = (unsigned char *)&sockaddr->sin_addr.s_addr;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    signed int return_value_snprintf$1;
    return_value_snprintf$1=snprintf(str + (signed long int)si, (unsigned long int)(32 - si), i != 3 ? "%d." : "%d", addr[(signed long int)i]);
    si = si + return_value_snprintf$1;
  }
  snprintf(str + (signed long int)si, (unsigned long int)(32 - si), ":%u", sockaddr->sin_port);
  return str;
}

// sockfd_cache_add
// file ../include/sockfd_cache.h line 11
void sockfd_cache_add(struct node_id *nid)
{
  struct sockfd_cache_entry *new;
  signed int n;
  signed int i;
  sd_write_lock$link4(&sockfd_cache.lock);
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sockfd_cache_entry) /*72ul*/ );
  new = (struct sockfd_cache_entry *)return_value_xmalloc$1;
  void *return_value_xzalloc$2;
  return_value_xzalloc$2=xzalloc(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count);
  new->fds = (struct sockfd_cache_fd *)return_value_xzalloc$2;
  i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    (new->fds + (signed long int)i)->fd = -1;
  memcpy((void *)&new->nid, (const void *)nid, sizeof(struct node_id) /*40ul*/ );
  struct sockfd_cache_entry *return_value_sockfd_cache_insert$3;
  return_value_sockfd_cache_insert$3=sockfd_cache_insert(new);
  const char *return_value_addr_to_str$5;
  if(!(return_value_sockfd_cache_insert$3 == ((struct sockfd_cache_entry *)NULL)))
  {
    free_cache_entry$link1(new);
    sd_rw_unlock$link4(&sockfd_cache.lock);
  }

  else
  {
    sd_rw_unlock$link4(&sockfd_cache.lock);
    unsigned long int return_value___uatomic_add_return$4;
    return_value___uatomic_add_return$4=__uatomic_add_return$link3((void *)&sockfd_cache.count, (unsigned long int)1, (signed int)sizeof(signed int) /*4ul*/ );
    n = (signed int)return_value___uatomic_add_return$4;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str$5=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_add", 239, "%s, count %d", return_value_addr_to_str$5, n);
    }

  }
}

// sockfd_cache_add_group
// file ../include/sockfd_cache.h line 12
void sockfd_cache_add_group(struct rb_root *nroot)
{
  struct sd_node *n;
  sd_write_lock$link4(&sockfd_cache.lock);
  struct rb_node *__p213;
  __p213=rb_first(nroot);
  struct rb_node *__n213;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  struct sd_node *tmp_statement_expression$2;
  do
  {
    if(!(__p213 == ((struct rb_node *)NULL)))
    {
      __n213=rb_next(__p213);
      tmp_if_expr$1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
    {
      const struct rb_node *__mptr = __p213;
      tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression$2;
      tmp_if_expr$3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    sockfd_cache_add_nolock(&n->nid);
    __p213 = __n213;
  }
  while((_Bool)1);
  sd_rw_unlock$link4(&sockfd_cache.lock);
}

// sockfd_cache_add_nolock
// file sockfd_cache.c line 190
static void sockfd_cache_add_nolock(struct node_id *nid)
{
  struct sockfd_cache_entry *new;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct sockfd_cache_entry) /*72ul*/ );
  new = (struct sockfd_cache_entry *)return_value_xmalloc$1;
  signed int i;
  void *return_value_xzalloc$2;
  return_value_xzalloc$2=xzalloc(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count);
  new->fds = (struct sockfd_cache_fd *)return_value_xzalloc$2;
  i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    (new->fds + (signed long int)i)->fd = -1;
  memcpy((void *)&new->nid, (const void *)nid, sizeof(struct node_id) /*40ul*/ );
  struct sockfd_cache_entry *return_value_sockfd_cache_insert$3;
  return_value_sockfd_cache_insert$3=sockfd_cache_insert(new);
  if(!(return_value_sockfd_cache_insert$3 == ((struct sockfd_cache_entry *)NULL)))
    free_cache_entry$link1(new);

  else
    sockfd_cache.count = sockfd_cache.count + 1;
}

// sockfd_cache_close
// file sockfd_cache.c line 381
static void sockfd_cache_close(struct node_id *nid, signed int idx)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr$1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr$1 = nid->io_addr;

  else
    tmp_if_expr$1 = nid->addr;
  addr = tmp_if_expr$1;
  signed int port;
  signed int tmp_if_expr$2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr$2 = (signed int)nid->io_port;

  else
    tmp_if_expr$2 = (signed int)nid->port;
  port = tmp_if_expr$2;
  struct sockfd_cache_entry *entry;
  const char *return_value_addr_to_str$3;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str$3=addr_to_str(addr, (unsigned short int)port);
    log_write(7, "sockfd_cache_close", 388, "%s idx %d", return_value_addr_to_str$3, idx);
  }

  sd_write_lock$link4(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  if(!(entry == ((struct sockfd_cache_entry *)NULL)))
  {
    close((entry->fds + (signed long int)idx)->fd);
    (entry->fds + (signed long int)idx)->fd = -1;
    uatomic_set_false$link2(&(entry->fds + (signed long int)idx)->in_use);
  }

  sd_rw_unlock$link4(&sockfd_cache.lock);
}

// sockfd_cache_cmp
// file sockfd_cache.c line 75
static signed int sockfd_cache_cmp(struct sockfd_cache_entry *a, struct sockfd_cache_entry *b)
{
  signed int return_value_node_id_cmp$1;
  return_value_node_id_cmp$1=node_id_cmp$link6(&a->nid, &b->nid);
  return return_value_node_id_cmp$1;
}

// sockfd_cache_del
// file ../include/sockfd_cache.h line 10
void sockfd_cache_del(struct node_id *nid, struct sockfd *sfd)
{
  if(sfd->idx == -1)
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_del", 488, "%d", sfd->fd);

    close(sfd->fd);
    free((void *)sfd);
  }

  else
  {
    sockfd_cache_close(nid, sfd->idx);
    sockfd_cache_del_node(nid);
    free((void *)sfd);
  }
}

// sockfd_cache_del_node
// file ../include/sockfd_cache.h line 9
void sockfd_cache_del_node(struct node_id *nid)
{
  signed int n;
  _Bool return_value_sockfd_cache_destroy$1;
  return_value_sockfd_cache_destroy$1=sockfd_cache_destroy(nid);
  const char *return_value_addr_to_str$3;
  if(!(return_value_sockfd_cache_destroy$1 == (_Bool)0))
  {
    unsigned long int return_value___uatomic_add_return$2;
    return_value___uatomic_add_return$2=__uatomic_add_return$link3((void *)&sockfd_cache.count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
    n = (signed int)return_value___uatomic_add_return$2;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str$3=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_del_node", 475, "%s, count %d", return_value_addr_to_str$3, n);
    }

  }

}

// sockfd_cache_destroy
// file sockfd_cache.c line 162
static _Bool sockfd_cache_destroy(struct node_id *nid)
{
  struct sockfd_cache_entry *entry;
  sd_write_lock$link4(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  _Bool return_value_slots_all_free$1;
  if(entry == ((struct sockfd_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_destroy", 169, "It is already destroyed");

  }

  else
  {
    return_value_slots_all_free$1=slots_all_free(entry);
    if(return_value_slots_all_free$1 == (_Bool)0)
    {
      if(sd_log_level == 7)
        log_write(7, "sockfd_cache_destroy", 174, "Some victim still holds it");

    }

    else
    {
      rb_erase(&entry->rb, &sockfd_cache.root);
      sd_rw_unlock$link4(&sockfd_cache.lock);
      destroy_all_slots(entry);
      free_cache_entry$link1(entry);
      return (_Bool)1;
    }
  }

false_out:
  ;
  sd_rw_unlock$link4(&sockfd_cache.lock);
  return (_Bool)0;
}

// sockfd_cache_get
// file ../include/sockfd_cache.h line 7
struct sockfd * sockfd_cache_get(struct node_id *nid)
{
  struct sockfd *sfd;
  signed int fd;
  sfd=sockfd_cache_get_long(nid);
  if(!(sfd == ((struct sockfd *)NULL)))
    return sfd;

  else
  {
    fd=connect_to_addr(nid->addr, (signed int)nid->port);
    if(!(fd >= 0))
      return (struct sockfd *)(void *)0;

    else
    {
      void *return_value_xmalloc$1;
      return_value_xmalloc$1=xmalloc(sizeof(struct sockfd) /*8ul*/ );
      sfd = (struct sockfd *)return_value_xmalloc$1;
      sfd->idx = -1;
      sfd->fd = fd;
      if(sd_log_level == 7)
        log_write(7, "sockfd_cache_get", 442, "%d", fd);

      return sfd;
    }
  }
}

// sockfd_cache_get_long
// file sockfd_cache.c line 313
static struct sockfd * sockfd_cache_get_long(struct node_id *nid)
{
  struct sockfd_cache_entry *entry;
  struct sockfd *sfd;
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr$1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr$1 = nid->io_addr;

  else
    tmp_if_expr$1 = nid->addr;
  addr = tmp_if_expr$1;
  signed int fd;
  signed int idx = -1;
  signed int port;
  signed int tmp_if_expr$2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr$2 = (signed int)nid->io_port;

  else
    tmp_if_expr$2 = (signed int)nid->port;
  port = tmp_if_expr$2;
  signed int return_value_revalidate_node$3;
  do
  {

  grab:
    ;
    entry=sockfd_cache_grab(nid, &idx);
    if(!(entry == ((struct sockfd_cache_entry *)NULL)))
      break;

    return_value_revalidate_node$3=revalidate_node(nid);
    if(return_value_revalidate_node$3 == 0)
      return (struct sockfd *)(void *)0;

  }
  while((_Bool)1);
  check_idx(idx);
  const char *return_value_addr_to_str$4;
  const char *return_value_addr_to_str$5;
  if(!((entry->fds + (signed long int)idx)->fd == -1))
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str$4=addr_to_str(addr, (unsigned short int)port);
      log_write(7, "sockfd_cache_get_long", 338, "%s, idx %d", return_value_addr_to_str$4, idx);
    }

  }

  else
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str$5=addr_to_str(addr, (unsigned short int)port);
      log_write(7, "sockfd_cache_get_long", 344, "create cache connection %s idx %d", return_value_addr_to_str$5, idx);
    }

    fd=connect_to_addr(addr, port);
    if(!(fd >= 0))
    {
      if(!(use_io == (_Bool)0))
      {
        log_write(3, "sockfd_cache_get_long", 348, "fallback to non-io connection");
        fd=connect_to_addr(nid->addr, (signed int)nid->port);
        if(fd >= 0)
          goto new;

      }

      uatomic_set_false$link2(&(entry->fds + (signed long int)idx)->in_use);
      return (struct sockfd *)(void *)0;
    }


  new:
    ;
    (entry->fds + (signed long int)idx)->fd = fd;
  }

out:
  ;
  void *return_value_xmalloc$6;
  return_value_xmalloc$6=xmalloc(sizeof(struct sockfd) /*8ul*/ );
  sfd = (struct sockfd *)return_value_xmalloc$6;
  sfd->fd = (entry->fds + (signed long int)idx)->fd;
  sfd->idx = idx;
  return sfd;
}

// sockfd_cache_grab
// file sockfd_cache.c line 112
static struct sockfd_cache_entry * sockfd_cache_grab(struct node_id *nid, signed int *ret_idx)
{
  struct sockfd_cache_entry *entry;
  sd_read_lock$link4(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  const char *return_value_addr_to_str$1;
  if(entry == ((struct sockfd_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str$1=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_grab", 120, "failed node %s", return_value_addr_to_str$1);
    }

  }

  else
  {
    *ret_idx=get_free_slot(entry);
    if(*ret_idx == -1)
      entry = (struct sockfd_cache_entry *)(void *)0;

  }

out:
  ;
  sd_rw_unlock$link4(&sockfd_cache.lock);
  return entry;
}

// sockfd_cache_insert
// file sockfd_cache.c line 82
static struct sockfd_cache_entry * sockfd_cache_insert(struct sockfd_cache_entry *new)
{
  struct sockfd_cache_entry *tmp_statement_expression$1;
  struct rb_node **__n = &(&sockfd_cache.root)->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct sockfd_cache_entry *__old = (struct sockfd_cache_entry *)(void *)0;
  struct sockfd_cache_entry *__data;
  struct sockfd_cache_entry *tmp_statement_expression$2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression$2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=sockfd_cache_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct sockfd_cache_entry *)NULL))
  {
    rb_link_node$link7(&new->rb, __parent, __n);
    rb_insert_color(&new->rb, &sockfd_cache.root);
  }

  tmp_statement_expression$1 = __old;
  return tmp_statement_expression$1;
}

// sockfd_cache_put
// file ../include/sockfd_cache.h line 8
void sockfd_cache_put(struct node_id *nid, struct sockfd *sfd)
{
  if(sfd->idx == -1)
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_put", 456, "%d", sfd->fd);

    close(sfd->fd);
    free((void *)sfd);
  }

  else
  {
    sockfd_cache_put_long(nid, sfd->idx);
    free((void *)sfd);
  }
}

// sockfd_cache_put_long
// file sockfd_cache.c line 365
static void sockfd_cache_put_long(struct node_id *nid, signed int idx)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr$1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr$1 = nid->io_addr;

  else
    tmp_if_expr$1 = nid->addr;
  addr = tmp_if_expr$1;
  signed int port;
  signed int tmp_if_expr$2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr$2 = (signed int)nid->io_port;

  else
    tmp_if_expr$2 = (signed int)nid->port;
  port = tmp_if_expr$2;
  struct sockfd_cache_entry *entry;
  const char *return_value_addr_to_str$3;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str$3=addr_to_str(addr, (unsigned short int)port);
    log_write(7, "sockfd_cache_put_long", 372, "%s idx %d", return_value_addr_to_str$3, idx);
  }

  sd_read_lock$link4(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  if(!(entry == ((struct sockfd_cache_entry *)NULL)))
    uatomic_set_false$link2(&(entry->fds + (signed long int)idx)->in_use);

  sd_rw_unlock$link4(&sockfd_cache.lock);
}

// sockfd_cache_search
// file sockfd_cache.c line 87
static struct sockfd_cache_entry * sockfd_cache_search(struct node_id *nid)
{
  struct sockfd_cache_entry key = { .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .nid=*nid,
    .fds=((struct sockfd_cache_fd *)NULL) };
  struct sockfd_cache_entry *tmp_statement_expression$1;
  struct rb_node *__n = (&sockfd_cache.root)->rb_node;
  struct sockfd_cache_entry *__ret = (struct sockfd_cache_entry *)(void *)0;
  struct sockfd_cache_entry *__data;
  struct sockfd_cache_entry *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=sockfd_cache_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  return tmp_statement_expression$1;
}

// sockfd_init
// file ../include/sockfd_cache.h line 14
signed int sockfd_init(void)
{
  grow_wq=create_ordered_work_queue("sockfd_grow");
  if(grow_wq == ((struct work_queue *)NULL))
  {
    log_write(3, "sockfd_init", 409, "error at creating workqueue for sockfd growth");
    return -1;
  }

  else
    return 0;
}

// split_ext_node
// file sd_inode.c line 471
static void split_ext_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, struct find_path *path)
{
  struct sd_extent_header *old = path->p_ext_header;
  struct sd_extent_header *new_ext;
  unsigned int num = old->entries / (unsigned int)2;
  unsigned long int new_oid;
  void *return_value_xvalloc$1;
  return_value_xvalloc$1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  new_ext = (struct sd_extent_header *)return_value_xvalloc$1;
  split_to_nodes(old, new_ext, old, (signed int)num);
  unsigned int tmp_post$2 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  new_oid=vid_to_btree_oid(inode->vdi_id, tmp_post$2);
  writer(new_oid, (void *)new_ext, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  writer(path->p_idx->oid, (void *)old, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
  insert_idx_entry((struct sd_extent_header *)inode->data_vdi_id, ((struct sd_extent *)((char *)new_ext + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)new_ext)->entries)->idx, new_oid);
  free((void *)new_ext);
}

// split_path
// file util.c line 525
signed int split_path(const char *path, unsigned long int nr_segs, char **segs)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_segs); i = i + 1)
  {
    for( ; (signed int)*path == 47; path = path + 1l)
      ;
    if((signed int)*path == 0)
      return i;

    if((unsigned long int)i == nr_segs + 18446744073709551615ul)
    {
      segs[(signed long int)i]=strdup(path);
      if(segs[(signed long int)i] == ((char *)NULL))
      {
        log_write(0, "split_path", 537, "PANIC: OOM");
        abort();
      }

    }

    else
    {
      char *p;
      p=strchrnul(path, 47);
      signed int len = (signed int)(p - path);
      void *return_value_xmalloc$1;
      return_value_xmalloc$1=xmalloc((unsigned long int)(len + 1));
      segs[(signed long int)i] = (char *)return_value_xmalloc$1;
      memcpy((void *)segs[(signed long int)i], (const void *)path, (unsigned long int)len);
      segs[(signed long int)i][(signed long int)len] = (char)0;
      path = p;
    }
  }
  return (signed int)nr_segs;
}

// split_to_nodes
// file sd_inode.c line 335
static void split_to_nodes(struct sd_extent_header *src, struct sd_extent_header *left, struct sd_extent_header *right, signed int num)
{
  memcpy((void *)left, (const void *)src, sizeof(struct sd_extent_header) /*8ul*/  + (unsigned long int)num * sizeof(struct sd_extent) /*8ul*/ );
  left->entries = (unsigned int)num;
  mempcpy((void *)right, (const void *)src, sizeof(struct sd_extent_header) /*8ul*/ );
  mempcpy((void *)(struct sd_extent *)((char *)right + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (const void *)((char *)src + (signed long int)sizeof(struct sd_extent_header) /*8ul*/  + (signed long int)((unsigned long int)num * sizeof(struct sd_extent) /*8ul*/ )), (unsigned long int)(src->entries - (unsigned int)num) * sizeof(struct sd_extent) /*8ul*/ );
  right->entries = src->entries - (unsigned int)num;
}

// start_deletion
// file vdi.c line 1069
static signed int start_deletion(struct request *req, unsigned int vid)
{
  struct deletion_work *dw = (struct deletion_work *)(void *)0;
  signed int ret = 0x00;
  signed int finish_fd;
  _Bool cloned;
  unsigned int root_vid;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct deletion_work) /*56ul*/ );
  dw = (struct deletion_work *)return_value_xzalloc$1;
  void *return_value_xzalloc$2;
  return_value_xzalloc$2=xzalloc(sizeof(struct sd_inode) /*4198976ul*/  - 4664ul);
  dw->delete_vid_array = (unsigned int *)return_value_xzalloc$2;
  dw->delete_vid_count = 0;
  dw->target_vid = vid;
  dw->finish_fd=eventfd((unsigned int)0, 0);
  finish_fd = dw->finish_fd;
  unsigned long int return_value_get_vdi_root$3;
  if(!(dw->finish_fd >= 0))
    log_write(3, "start_deletion", 1083, "cannot create an eventfd for notifying finish of deletion info: %m");

  else
  {
    return_value_get_vdi_root$3=get_vdi_root(dw->target_vid, &cloned);
    root_vid = (unsigned int)return_value_get_vdi_root$3;
    if(root_vid == 0u)
      ret = 0x03;

    else
    {
      ret=fill_delete_vid_array(dw, root_vid);
      if(!(ret >= 0))
      {
        ret = 0x03;
        goto out;
      }

      else
        if(ret == 1)
        {
          ret = 0x00;
          if(!(cloned == (_Bool)0))
          {
            dw->delete_vid_array[(signed long int)0] = vid;
            dw->delete_vid_count = 1;
            clear_parent_child_vdi(vid);
          }

          else
          {
            if(sd_log_level == 7)
              log_write(7, "start_deletion", 1121, "snapshot chain has valid vdi, just mark vdi %x as deleted.", dw->target_vid);

            delete_inode(dw->target_vid);
            goto out;
          }
        }

      if(sd_log_level == 7)
        log_write(7, "start_deletion", 1127, "number of VDI deletion: %d", dw->delete_vid_count);

      if(!(dw->delete_vid_count == 0))
      {
        dw->work.fn = delete_vdis_work;
        dw->work.done = delete_vdis_done;
        queue_work(sys->deletion_wqueue, &dw->work);
        eventfd_xread(finish_fd);
        close(finish_fd);
        return ret;
      }

    }
  }

out:
  ;
  if(!(dw == ((struct deletion_work *)NULL)))
    free((void *)dw->delete_vid_array);

  free((void *)dw);
  return ret;
}

// start_recovery
// file sheep_priv.h line 371
signed int start_recovery(struct vnode_info *cur_vinfo, struct vnode_info *old_vinfo, _Bool epoch_lifted)
{
  struct recovery_info *rinfo;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct recovery_info) /*88ul*/ );
  rinfo = (struct recovery_info *)return_value_xzalloc$1;
  rinfo->state = (enum rw_state)RW_PREPARE_LIST;
  rinfo->epoch = sys->cinfo.epoch;
  unsigned int tmp_if_expr$2;
  if(!(epoch_lifted == (_Bool)0))
    tmp_if_expr$2 = sys->cinfo.epoch - (unsigned int)1;

  else
    tmp_if_expr$2 = sys->cinfo.epoch;
  rinfo->tgt_epoch = tmp_if_expr$2;
  rinfo->count = (unsigned long int)0;
  if(!(epoch_lifted == (_Bool)0))
    rinfo->notify_complete = (_Bool)1;

  else
    rinfo->notify_complete = (_Bool)0;
  rinfo->cur_vinfo=grab_vnode_info(cur_vinfo);
  rinfo->old_vinfo=grab_vnode_info(old_vinfo);
  _Bool return_value_node_is_gateway_only$3;
  return_value_node_is_gateway_only$3=node_is_gateway_only();
  if(return_value_node_is_gateway_only$3 == (_Bool)0)
    sd_store->update_epoch(rinfo->tgt_epoch);

  struct recovery_info *tmp_statement_expression$6 = current_rinfo.__val;
  struct recovery_info *tmp_statement_expression$4;
  if(!(tmp_statement_expression$6 == ((struct recovery_info *)NULL)))
  {
    struct recovery_info *nrinfo;
    unsigned long int ret;
    unsigned long int return_value___uatomic_exchange$5;
    return_value___uatomic_exchange$5=__uatomic_exchange((void *)(unsigned long int *)&next_rinfo, (unsigned long int)rinfo, (signed int)sizeof(unsigned long int) /*8ul*/ );
    ret = (unsigned long int)return_value___uatomic_exchange$5;
    tmp_statement_expression$4 = (struct recovery_info *)ret;
    nrinfo = tmp_statement_expression$4;
    if(!(nrinfo == ((struct recovery_info *)NULL)))
      free_recovery_info(nrinfo);

    if(sd_log_level == 7)
      log_write(7, "start_recovery", 1057, "recovery skipped");

    resume_suspended_recovery();
  }

  else
  {
    current_rinfo.__val = rinfo;
    queue_recovery_work(rinfo);
  }
  wakeup_requests_on_epoch();
  return 0;
}

// stat_request_begin
// file request.c line 357
static inline void stat_request_begin(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  req->stat = (_Bool)1;
  _Bool return_value_is_peer_op$2;
  return_value_is_peer_op$2=is_peer_op(req->op);
  _Bool return_value_is_gateway_op$1;
  if(!(return_value_is_peer_op$2 == (_Bool)0))
  {
    sys->stat.r.peer_total_nr = sys->stat.r.peer_total_nr + 1ul;
    sys->stat.r.peer_active_nr = sys->stat.r.peer_active_nr + 1ul;
    if(!((0x01 & (signed int)hdr->flags) == 0))
      sys->stat.r.peer_total_rx = sys->stat.r.peer_total_rx + (unsigned long int)hdr->data_length;

    else
      sys->stat.r.peer_total_tx = sys->stat.r.peer_total_tx + (unsigned long int)hdr->data_length;
    switch((signed int)hdr->opcode)
    {
      case 0xA4:
      {
        sys->stat.r.peer_total_read_nr = sys->stat.r.peer_total_read_nr + 1ul;
        break;
      }
      case 0xA5:

      case 0xA3:
      {
        sys->stat.r.peer_total_write_nr = sys->stat.r.peer_total_write_nr + 1ul;
        break;
      }
      case 0xA6:
        sys->stat.r.peer_total_remove_nr = sys->stat.r.peer_total_remove_nr + 1ul;
    }
  }

  else
  {
    return_value_is_gateway_op$1=is_gateway_op(req->op);
    if(!(return_value_is_gateway_op$1 == (_Bool)0))
    {
      sys->stat.r.gway_total_nr = sys->stat.r.gway_total_nr + 1ul;
      sys->stat.r.gway_active_nr = sys->stat.r.gway_active_nr + 1ul;
      if(!((0x01 & (signed int)hdr->flags) == 0))
        sys->stat.r.gway_total_rx = sys->stat.r.gway_total_rx + (unsigned long int)hdr->data_length;

      else
        sys->stat.r.gway_total_tx = sys->stat.r.gway_total_tx + (unsigned long int)hdr->data_length;
      switch((signed int)hdr->opcode)
      {
        case 0x02:
        {
          sys->stat.r.gway_total_read_nr = sys->stat.r.gway_total_read_nr + 1ul;
          break;
        }
        case 0x03:

        case 0x01:
        {
          sys->stat.r.gway_total_write_nr = sys->stat.r.gway_total_write_nr + 1ul;
          break;
        }
        case 0x05:
          sys->stat.r.gway_total_remove_nr = sys->stat.r.gway_total_remove_nr + 1ul;
      }
    }

    else
      if((signed int)hdr->opcode == 0x16)
      {
        sys->stat.r.gway_total_nr = sys->stat.r.gway_total_nr + 1ul;
        sys->stat.r.gway_active_nr = sys->stat.r.gway_active_nr + 1ul;
        sys->stat.r.gway_total_flush_nr = sys->stat.r.gway_total_flush_nr + 1ul;
      }

  }
}

// stat_request_end
// file request.c line 410
static inline void stat_request_end(struct request *req)
{
  struct sd_req *hdr = &req->rq;
  _Bool return_value_is_gateway_op$1;
  if(!(req->stat == (_Bool)0))
  {
    _Bool return_value_is_peer_op$2;
    return_value_is_peer_op$2=is_peer_op(req->op);
    if(!(return_value_is_peer_op$2 == (_Bool)0))
      sys->stat.r.peer_active_nr = sys->stat.r.peer_active_nr - 1ul;

    else
    {
      return_value_is_gateway_op$1=is_gateway_op(req->op);
      if(!(return_value_is_gateway_op$1 == (_Bool)0))
        sys->stat.r.gway_active_nr = sys->stat.r.gway_active_nr - 1ul;

      else
        if((signed int)hdr->opcode == 0x16)
          sys->stat.r.gway_active_nr = sys->stat.r.gway_active_nr - 1ul;

    }
  }

}

// stat_sheep
// file ops.c line 61
static signed int stat_sheep(unsigned long int *store_size, unsigned long int *store_free, unsigned int epoch)
{
  unsigned long int used;
  if(!(sys->gateway_only == (_Bool)0))
  {
    *store_size = (unsigned long int)0;
    *store_free = (unsigned long int)0;
  }

  else
  {
    *store_size=md_get_size(&used);
    *store_free = *store_size - used;
  }
  return 0x00;
}

// str_http_req
// file http/http.c line 75
const char * str_http_req(struct http_request *req)
{
  const char *return_value_stropcode$1;
  return_value_stropcode$1=stropcode(req->opcode);
  const char *return_value_strstatus$2;
  return_value_strstatus$2=strstatus(req->status);
  static char msg[1024l];
  snprintf(msg, sizeof(char [1024l]) /*1024ul*/ , "%s %s, status = %s, data_length = %lu", req->uri, return_value_stropcode$1, return_value_strstatus$2, req->data_length);
  return msg;
}

// str_to_addr
// file ../include/net.h line 57
unsigned char * str_to_addr(const char *ipstr, unsigned char *addr)
{
  signed int addr_start_idx = 0;
  signed int af;
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(ipstr, ":");
  af = return_value_strstr$1 != ((char *)NULL) ? 10 : 2;
  if(af == 2)
  {
    addr_start_idx = 12;
    memset((void *)addr, 0, (unsigned long int)addr_start_idx);
  }

  signed int return_value_inet_pton$2;
  return_value_inet_pton$2=inet_pton(af, ipstr, (void *)(addr + (signed long int)addr_start_idx));
  if(return_value_inet_pton$2 == 0)
    return (unsigned char *)(void *)0;

  else
    return addr;
}

// strbuf_add
// file ../include/strbuf.h line 81
void strbuf_add(struct strbuf *sb, const void *data, unsigned long int len)
{
  strbuf_grow(sb, len);
  memcpy((void *)(sb->buf + (signed long int)sb->len), data, len);
  strbuf_setlen(sb, sb->len + len);
}

// strbuf_addf
// file ../include/strbuf.h line 91
void strbuf_addf(struct strbuf *sb, const char *fmt, ...)
{
  signed int len;
  void **ap = (void **)&fmt;
  len=vsnprintf(sb->buf + (signed long int)sb->len, sb->alloc - sb->len, fmt, ap);
  ap = ((void **)NULL);
  if(!(len >= 0))
    len = 0;

  unsigned long int return_value_strbuf_avail$2;
  return_value_strbuf_avail$2=strbuf_avail(sb);
  if(!(return_value_strbuf_avail$2 >= (unsigned long int)len))
  {
    strbuf_grow(sb, (unsigned long int)len);
    ap = (void **)&fmt;
    len=vsnprintf(sb->buf + (signed long int)sb->len, sb->alloc - sb->len, fmt, ap);
    ap = ((void **)NULL);
    unsigned long int return_value_strbuf_avail$1;
    return_value_strbuf_avail$1=strbuf_avail(sb);
    if(!(return_value_strbuf_avail$1 >= (unsigned long int)len))
    {
      log_write(0, "strbuf_addf", 124, "PANIC: this should not happen, your snprintf is broken");
      abort();
    }

  }

  strbuf_setlen(sb, sb->len + (unsigned long int)len);
}

// strbuf_addstr
// file ../include/strbuf.h line 82
static inline void strbuf_addstr(struct strbuf *sb, const char *s)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  strbuf_add(sb, (const void *)s, return_value_strlen$1);
}

// strbuf_attach
// file strbuf.c line 43
void strbuf_attach(struct strbuf *sb, void *buf, unsigned long int len, unsigned long int alloc)
{
  strbuf_release(sb);
  sb->buf = (char *)buf;
  sb->len = len;
  sb->alloc = alloc;
  strbuf_grow(sb, (unsigned long int)0);
  sb->buf[(signed long int)sb->len] = (char)0;
}

// strbuf_avail
// file ../include/strbuf.h line 49
static inline unsigned long int strbuf_avail(struct strbuf *sb)
{
  unsigned long int tmp_if_expr$1;
  if(!(sb->alloc == 0ul))
    tmp_if_expr$1 = (sb->alloc - sb->len) - (unsigned long int)1;

  else
    tmp_if_expr$1 = (unsigned long int)0;
  return tmp_if_expr$1;
}

// strbuf_copyout
// file ../include/strbuf.h line 97
signed int strbuf_copyout(struct strbuf *sb, void *buf, unsigned long int len)
{
  unsigned long int tmp_statement_expression$1;
  unsigned long int _x = len;
  unsigned long int _y = sb->len + (unsigned long int)1;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? _x : _y;
  len = tmp_statement_expression$1;
  memcpy(buf, (const void *)sb->buf, len);
  return (signed int)len;
}

// strbuf_detach
// file strbuf.c line 36
char * strbuf_detach(struct strbuf *sb)
{
  char *res = sb->buf;
  strbuf_init(sb, (unsigned long int)0);
  return res;
}

// strbuf_fread
// file strbuf.c line 129
unsigned long int strbuf_fread(struct strbuf *sb, unsigned long int size, struct _IO_FILE *f)
{
  unsigned long int res;
  strbuf_grow(sb, size);
  res=fread((void *)(sb->buf + (signed long int)sb->len), (unsigned long int)1, size, f);
  if(res >= 1ul)
    strbuf_setlen(sb, sb->len + res);

  return res;
}

// strbuf_getline
// file strbuf.c line 184
signed int strbuf_getline(struct strbuf *sb, struct _IO_FILE *fp, signed int term)
{
  signed int return_value_strbuf_getwholeline$1;
  return_value_strbuf_getwholeline$1=strbuf_getwholeline(sb, fp, term);
  if(!(return_value_strbuf_getwholeline$1 == 0))
    return -1;

  else
  {
    if((signed int)sb->buf[-1l + (signed long int)sb->len] == term)
      strbuf_setlen(sb, sb->len - (unsigned long int)1);

    return 0;
  }
}

// strbuf_getwholeline
// file strbuf.c line 163
static signed int strbuf_getwholeline(struct strbuf *sb, struct _IO_FILE *fp, signed int term)
{
  signed int ch;
  signed int return_value_feof$1;
  return_value_feof$1=feof(fp);
  unsigned long int tmp_post$2;
  if(!(return_value_feof$1 == 0))
    return -1;

  else
  {
    strbuf_reset(sb);
    do
    {
      ch=fgetc(fp);
      if(ch == -1)
        break;

      strbuf_grow(sb, (unsigned long int)1);
      tmp_post$2 = sb->len;
      sb->len = sb->len + 1ul;
      sb->buf[(signed long int)tmp_post$2] = (char)ch;
      if(ch == term)
        break;

    }
    while((_Bool)1);
    if(ch == -1)
    {
      if(!(sb->len == 0ul))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      sb->buf[(signed long int)sb->len] = (char)0;
      return 0;
    }
  }
}

// strbuf_grow
// file strbuf.c line 53
void strbuf_grow(struct strbuf *sb, unsigned long int extra)
{
  if(sb->len >= 1ul + sb->len + extra)
  {
    log_write(0, "strbuf_grow", 56, "PANIC: you want to use way too much memory");
    abort();
  }

  do
    if(!(sb->alloc >= 1ul + sb->len + extra))
    {
      if(!(((16ul + sb->alloc) * 3ul) / 2ul >= 1ul + sb->len + extra))
        sb->alloc = sb->len + extra + (unsigned long int)1;

      else
        sb->alloc = ((sb->alloc + (unsigned long int)16) * (unsigned long int)3) / (unsigned long int)2;
      void *return_value_xrealloc$1;
      return_value_xrealloc$1=xrealloc((void *)sb->buf, sb->alloc * sizeof(char) /*1ul*/ );
      sb->buf = (char *)return_value_xrealloc$1;
    }

  while((_Bool)0);
}

// strbuf_init
// file strbuf.c line 16
void strbuf_init(struct strbuf *sb, unsigned long int hint)
{
  memset((void *)sb, 0, sizeof(struct strbuf) /*32ul*/ );
  if(!(hint == 0ul))
    strbuf_grow(sb, hint);

}

// strbuf_insert
// file strbuf.c line 67
void strbuf_insert(struct strbuf *sb, unsigned long int pos, const void *data, unsigned long int len)
{
  strbuf_grow(sb, len);
  if(!(sb->len >= pos))
  {
    log_write(0, "strbuf_insert", 71, "PANIC: `pos' is too far after the end of the buffer");
    abort();
  }

  memmove((void *)(sb->buf + (signed long int)pos + (signed long int)len), (const void *)(sb->buf + (signed long int)pos), sb->len - pos);
  memcpy((void *)(sb->buf + (signed long int)pos), data, len);
  strbuf_setlen(sb, sb->len + len);
}

// strbuf_read
// file ../include/strbuf.h line 95
signed long int strbuf_read(struct strbuf *sb, signed int fd, unsigned long int hint)
{
  unsigned long int oldlen = sb->len;
  strbuf_grow(sb, hint != 0ul ? hint : (unsigned long int)8192);
  do
  {
    signed long int cnt;
    cnt=xread(fd, (void *)(sb->buf + (signed long int)sb->len), (sb->alloc - sb->len) - (unsigned long int)1);
    if(!(cnt >= 0l))
    {
      strbuf_setlen(sb, oldlen);
      return (signed long int)-1;
    }

    if(cnt == 0l)
      break;

    sb->len = sb->len + (unsigned long int)cnt;
    strbuf_grow(sb, (unsigned long int)8192);
  }
  while((_Bool)1);
  sb->buf[(signed long int)sb->len] = (char)0;
  return (signed long int)(sb->len - oldlen);
}

// strbuf_release
// file ../include/strbuf.h line 43
void strbuf_release(struct strbuf *sb)
{
  free((void *)sb->buf);
  memset((void *)sb, 0, sizeof(struct strbuf) /*32ul*/ );
}

// strbuf_remove
// file strbuf.c line 96
void strbuf_remove(struct strbuf *sb, unsigned long int pos, unsigned long int len)
{
  strbuf_splice(sb, pos, len, (void *)0, (unsigned long int)0);
}

// strbuf_reset
// file strbuf.c line 29
void strbuf_reset(struct strbuf *sb)
{
  if(!(sb->len == 0ul))
    strbuf_setlen(sb, (unsigned long int)0);

  sb->eof = 0;
}

// strbuf_rtrim
// file strbuf.c line 60
void strbuf_rtrim(struct strbuf *sb)
{
  const unsigned short int **return_value___ctype_b_loc$1;
  for( ; sb->len >= 1ul; sb->len = sb->len - 1ul)
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)sb->buf[-1l + (signed long int)sb->len]]) == 0)
      break;

  }
  sb->buf[(signed long int)sb->len] = (char)0;
}

// strbuf_setlen
// file ../include/strbuf.h line 53
static inline void strbuf_setlen(struct strbuf *sb, unsigned long int len)
{
  sb->len = len;
  sb->buf[(signed long int)len] = (char)0;
}

// strbuf_splice
// file strbuf.c line 77
void strbuf_splice(struct strbuf *sb, unsigned long int pos, unsigned long int len, const void *data, unsigned long int dlen)
{
  if(!(len + pos >= pos))
  {
    log_write(0, "strbuf_splice", 81, "PANIC: you want to use way too much memory");
    abort();
  }

  if(!(sb->len >= pos))
  {
    log_write(0, "strbuf_splice", 83, "PANIC: `pos' is too far after the end of the buffer");
    abort();
  }

  if(!(sb->len >= len + pos))
  {
    log_write(0, "strbuf_splice", 85, "PANIC: `pos + len' is too far after the end of the buffer");
    abort();
  }

  if(dlen >= len)
    strbuf_grow(sb, dlen - len);

  memmove((void *)(sb->buf + (signed long int)pos + (signed long int)dlen), (const void *)(sb->buf + (signed long int)pos + (signed long int)len), (sb->len - pos) - len);
  memcpy((void *)(sb->buf + (signed long int)pos), data, dlen);
  strbuf_setlen(sb, (sb->len + dlen) - len);
}

// strbuf_stripout
// file strbuf.c line 201
signed int strbuf_stripout(struct strbuf *sb, void *buf, unsigned long int len)
{
  unsigned long int tmp_statement_expression$1;
  unsigned long int _x = len;
  unsigned long int _y = sb->len;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? _x : _y;
  len = tmp_statement_expression$1;
  if(!(len == 0ul))
  {
    memcpy(buf, (const void *)sb->buf, len);
    strbuf_remove(sb, (unsigned long int)0, len);
  }


out:
  ;
  return (signed int)len;
}

// stropcode
// file http/http.c line 26
static inline const char * stropcode(enum http_opcode opcode)
{
  static const char * const descs[6l] = { ((const char *)NULL), "GET", "PUT", "POST", "DELETE", "HEAD" };
  if(descs[(signed long int)opcode] == ((const char *)NULL))
  {
    static char msg[32l];
    snprintf(msg, sizeof(char [32l]) /*32ul*/ , "Invalid opcode %d", opcode);
    return msg;
  }

  else
    return descs[(signed long int)opcode];
}

// strstatus
// file http/http.c line 45
static inline const char * strstatus(enum http_status status)
{
  static const char * const descs[15l] = { "Unknown", "200 OK", "201 Created", "202 Accepted", "204 No Content", "206 Partial Content", "400 Bad Request", "401 Unauthorized", "404 Not Found", "405 Method Not Allowed", "409 Conflict", "416 Requested Range Not Satisfiable", "500 Internal Server Error", "501 Not Implemented", "503 Service_Unavailable" };
  if(descs[(signed long int)status] == ((const char *)NULL))
  {
    static char msg[32l];
    snprintf(msg, sizeof(char [32l]) /*32ul*/ , "Invalid Status %d", status);
    return msg;
  }

  else
    return descs[(signed long int)status];
}

// submit_local_request
// file request.c line 535
static void submit_local_request(struct request *req)
{
  sd_mutex_lock$link1(&sys->local_req_lock);
  list_add_tail$link1(&req->request_list, &sys->local_req_queue);
  sd_mutex_unlock$link1(&sys->local_req_lock);
  eventfd_xwrite(sys->local_req_efd, 1);
}

// switch_journal_file
// file journal.c line 339
static void switch_journal_file(void)
{
  signed int old = jfile.fd;
  struct work *w;
  signed int return_value_sd_mutex_trylock$1;
  return_value_sd_mutex_trylock$1=sd_mutex_trylock(&journal_commit_mutex);
  if(return_value_sd_mutex_trylock$1 == 16)
  {
    log_write(3, "switch_journal_file", 346, "journal file in commiting, you might need enlarge jfile size");
    sd_mutex_lock$link2(&journal_commit_mutex);
  }

  if(old == jfile_fds[0l])
    jfile.fd = jfile_fds[(signed long int)1];

  else
    jfile.fd = jfile_fds[(signed long int)0];
  jfile.commit_fd = old;
  jfile.pos = (signed long int)0;
  void *return_value_xzalloc$2;
  return_value_xzalloc$2=xzalloc(sizeof(struct work) /*32ul*/ );
  w = (struct work *)return_value_xzalloc$2;
  w->fn = journal_commit_data_work;
  w->done = journal_commit_data_done;
  queue_work(commit_wq, w);
}

// sys_epoch
// file sheep_priv.h line 278
static inline unsigned int sys_epoch(void)
{
  volatile unsigned int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned int *)&(*(&sys->cinfo.epoch)));
  return tmp_statement_expression$1;
}

// sys_epoch$link1
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link1(void)
{
  volatile unsigned int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile unsigned int *)&(*(&sys->cinfo.epoch)));
  return tmp_statement_expression$1$link1;
}

// sys_epoch$link2
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link2(void)
{
  volatile unsigned int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile unsigned int *)&(*(&sys->cinfo.epoch)));
  return tmp_statement_expression$1$link2;
}

// sys_epoch$link3
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link3(void)
{
  volatile unsigned int tmp_statement_expression$1$link3;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link3 = *((volatile unsigned int *)&(*(&sys->cinfo.epoch)));
  return tmp_statement_expression$1$link3;
}

// sys_epoch$link4
// file sheep_priv.h line 278
static inline unsigned int sys_epoch$link4(void)
{
  volatile unsigned int tmp_statement_expression$1$link4;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link4 = *((volatile unsigned int *)&(*(&sys->cinfo.epoch)));
  return tmp_statement_expression$1$link4;
}

// thread_process_path
// file md.c line 388
static void * thread_process_path(void *arg)
{
  signed int ret = 0x00;
  struct process_path_arg *parg = (struct process_path_arg *)arg;
  ret=for_each_object_in_path(parg->path, parg->func, parg->cleanup, parg->vinfo, parg->opaque);
  if(!(ret == 0x00))
    parg->result = ret;

  return arg;
}

// timer_handler
// file event.c line 25
static void timer_handler(signed int fd, signed int events, void *data)
{
  struct timer *t = (struct timer *)data;
  unsigned long int val;
  signed long int return_value_read$1;
  return_value_read$1=read(fd, (void *)&val, sizeof(unsigned long int) /*8ul*/ );
  if(return_value_read$1 >= 0l)
  {
    t->callback(t->data);
    unregister_event(fd);
    close(fd);
  }

}

// tkill
// file util.c line 482
signed int tkill(signed int tid, signed int sig)
{
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  signed long int return_value_syscall$2;
  return_value_syscall$2=syscall((signed long int)234, return_value_getpid$1, tid, sig);
  return (signed int)return_value_syscall$2;
}

// trace_buffer_pop
// file trace/trace.h line 53
static inline signed int trace_buffer_pop(void *buf, unsigned int len)
{
  return 0;
}

// trace_clear_tid_map
// file work.c line 190
static inline void trace_clear_tid_map(signed int tid)
{
  ;
}

// trace_disable
// file trace/trace.h line 51
static inline signed int trace_disable(const char *name)
{
  return 0;
}

// trace_enable
// file trace/trace.h line 50
static inline signed int trace_enable(const char *name)
{
  return 0;
}

// trace_init
// file trace/trace.h line 49
static inline signed int trace_init(void)
{
  return 0;
}

// trace_set_tid_map
// file work.c line 189
static inline void trace_set_tid_map(signed int tid)
{
  ;
}

// trace_status
// file trace/trace.h line 52
static inline unsigned long int trace_status(char *buf)
{
  return (unsigned long int)0;
}

// transfer_to_idx_root
// file sd_inode.c line 355
static void transfer_to_idx_root(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode)
{
  struct sd_extent_header *left;
  struct sd_extent_header *right;
  struct sd_extent_header *root = (struct sd_extent_header *)inode->data_vdi_id;
  unsigned long int left_oid;
  unsigned long int right_oid;
  unsigned int num = root->entries / (unsigned int)2;
  void *return_value_xvalloc$1;
  return_value_xvalloc$1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  left = (struct sd_extent_header *)return_value_xvalloc$1;
  void *return_value_xvalloc$2;
  return_value_xvalloc$2=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  right = (struct sd_extent_header *)return_value_xvalloc$2;
  split_to_nodes(root, left, right, (signed int)num);
  unsigned int tmp_post$3 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  left_oid=vid_to_btree_oid(inode->vdi_id, tmp_post$3);
  unsigned int tmp_post$4 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  right_oid=vid_to_btree_oid(inode->vdi_id, tmp_post$4);
  writer(left_oid, (void *)left, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  writer(right_oid, (void *)right, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  root->entries = (unsigned int)0;
  root->depth = (unsigned short int)2;
  insert_idx_entry(root, (((struct sd_extent *)((char *)left + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)left)->entries) - (signed long int)1)->idx, left_oid);
  insert_idx_entry(root, (((struct sd_extent *)((char *)right + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)right)->entries) - (signed long int)1)->idx, right_oid);
  free((void *)left);
  free((void *)right);
}

// traverse_btree
// file ../include/sheepdog_proto.h line 295
extern void traverse_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, void (*fn)(void *, enum btree_node_type, void *), void *arg)
{
  struct sd_extent_header *header = (struct sd_extent_header *)inode->data_vdi_id;
  struct sd_extent_header *leaf_node = (struct sd_extent_header *)(void *)0;
  struct sd_extent *last;
  struct sd_extent *iter;
  struct sd_extent_idx *last_idx;
  struct sd_extent_idx *iter_idx;
  void *tmp;
  fn((void *)header, (enum btree_node_type)BTREE_HEAD, arg);
  if((signed int)header->depth == 1)
  {
    last = (struct sd_extent *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)inode->data_vdi_id)->entries;
    iter = (struct sd_extent *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
    if(!(iter == last))
    {
      fn((void *)iter, (enum btree_node_type)BTREE_EXT, arg);
      iter = iter + 1l;
    }

  }

  else
    if((signed int)header->depth == 2)
    {
      last_idx = (struct sd_extent_idx *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)inode->data_vdi_id)->entries;
      iter_idx = (struct sd_extent_idx *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      void *return_value_xvalloc$1;
      return_value_xvalloc$1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
      leaf_node = (struct sd_extent_header *)return_value_xvalloc$1;
      tmp = (void *)leaf_node;
      if(!(iter_idx == last_idx))
      {
        reader(iter_idx->oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
        fn((void *)iter_idx, (enum btree_node_type)BTREE_IDX, arg);
        fn((void *)leaf_node, (enum btree_node_type)BTREE_HEAD, arg);
        last = (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)leaf_node)->entries;
        iter = (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
        if(!(iter == last))
        {
          fn((void *)iter, (enum btree_node_type)BTREE_EXT, arg);
          iter = iter + 1l;
        }

        iter_idx = iter_idx + 1l;
      }

      free((void *)leaf_node);
    }

    else
    {
      log_write(0, "traverse_btree", 180, "PANIC: This B-tree not support depth %u", header->depth);
      abort();
    }
}

// trim_last_slash
// file md.c line 128
static inline void trim_last_slash(char *path)
{
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  do
  {
    return_value_strlen$1=strlen(path);
    if(!((signed int)path[-1l + (signed long int)return_value_strlen$1] == 47))
      break;

    return_value_strlen$2=strlen(path);
    path[(signed long int)(return_value_strlen$2 - (unsigned long int)1)] = (char)0;
  }
  while((_Bool)1);
}

// tx_main
// file request.c line 830
static void tx_main(struct work *work)
{
  struct client_info *ci;
  struct client_info *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct client_info *)((char *)__mptr - (signed long int)112ul);
  ci = tmp_statement_expression$1;
  refcount_dec$link1(&ci->refcnt);
  _Bool return_value_is_logging_op$3;
  return_value_is_logging_op$3=is_logging_op(ci->tx_req->op);
  if(!(return_value_is_logging_op$3 == (_Bool)0))
  {
    const char *return_value_op_name$2;
    return_value_op_name$2=op_name(ci->tx_req->op);
    log_write(6, "tx_main", 844, "req=%p, fd=%d, client=%s:%d, op=%s, result=%02X", ci->tx_req, ci->conn.fd, (const void *)ci->conn.ipstr, ci->conn.port, return_value_op_name$2, ci->tx_req->rp.$anon0.result);
  }

  else
    if(sd_log_level == 7)
      log_write(7, "tx_main", 849, "%d, %s:%d", ci->conn.fd, (const void *)ci->conn.ipstr, ci->conn.port);

  free_request(ci->tx_req);
  ci->tx_req = (struct request *)(void *)0;
  signed int return_value_conn_tx_on$4;
  if(!(ci->conn.dead == (_Bool)0))
    clear_client_info(ci);

  else
  {
    _Bool return_value_list_empty$5;
    return_value_list_empty$5=list_empty(&ci->done_reqs);
    if(return_value_list_empty$5 == (_Bool)0)
    {
      return_value_conn_tx_on$4=conn_tx_on(&ci->conn);
      if(!(return_value_conn_tx_on$4 == 0))
        log_write(3, "tx_main", 862, "switch on sending flag failure, connection maybe closed");

    }

  }
}

// tx_work
// file request.c line 802
static void tx_work(struct work *work)
{
  struct client_info *ci;
  struct client_info *tmp_statement_expression$1;
  const struct work *__mptr = work;
  tmp_statement_expression$1 = (struct client_info *)((char *)__mptr - (signed long int)112ul);
  ci = tmp_statement_expression$1;
  signed int ret;
  struct connection *conn = &ci->conn;
  struct sd_rsp rsp;
  struct request *req = ci->tx_req;
  void *data = (void *)0;
  memcpy((void *)&rsp, (const void *)&req->rp, sizeof(struct sd_rsp) /*48ul*/ );
  rsp.epoch = sys->cinfo.epoch;
  rsp.opcode = req->rq.opcode;
  rsp.id = req->rq.id;
  if(!(rsp.data_length == 0u))
    data = req->data;

  ret=send_req(conn->fd, (struct sd_req *)&rsp, data, rsp.data_length, (_Bool (*)(unsigned int))(void *)0, (unsigned int)0, 4294967295U);
  if(!(ret == 0))
  {
    log_write(3, "tx_work", 825, "failed to send a request");
    conn->dead = (_Bool)1;
  }

}

// uatomic_is_true
// file ../include/util.h line 206
static inline _Bool uatomic_is_true(struct anonymous$0 *val)
{
  volatile unsigned long int tmp_statement_expression$1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&val->val)));
  return tmp_statement_expression$1 == (unsigned long int)1;
}

// uatomic_is_true$link1
// file ../include/util.h line 206
static inline _Bool uatomic_is_true$link1(struct anonymous$0 *val$link1)
{
  volatile unsigned long int tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link1 = *((volatile unsigned long int *)&(*(&val$link1->val)));
  return tmp_statement_expression$1$link1 == (unsigned long int)1;
}

// uatomic_is_true$link2
// file ../include/util.h line 206
static inline _Bool uatomic_is_true$link2(struct anonymous$0 *val$link2)
{
  volatile unsigned long int tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  tmp_statement_expression$1$link2 = *((volatile unsigned long int *)&(*(&val$link2->val)));
  return tmp_statement_expression$1$link2 == (unsigned long int)1;
}

// uatomic_set_false
// file ../include/util.h line 217
static inline void uatomic_set_false(struct anonymous$0 *val)
{
  unsigned long int _v;
  volatile unsigned long int tmp_statement_expression$1;
  *((volatile unsigned long int *)&(*(&val->val))) = (volatile unsigned long int)0;
  tmp_statement_expression$1 = *((volatile unsigned long int *)&(*(&val->val)));
  _v = tmp_statement_expression$1;
  asm("" :  :  : "memory");
  _v = _v;
}

// uatomic_set_false$link1
// file ../include/util.h line 217
static inline void uatomic_set_false$link1(struct anonymous$0 *val$link1)
{
  unsigned long int _v$link1;
  volatile unsigned long int tmp_statement_expression$1$link1;
  *((volatile unsigned long int *)&(*(&val$link1->val))) = (volatile unsigned long int)0;
  tmp_statement_expression$1$link1 = *((volatile unsigned long int *)&(*(&val$link1->val)));
  _v$link1 = tmp_statement_expression$1$link1;
  asm("" :  :  : "memory");
  _v$link1 = _v$link1;
}

// uatomic_set_false$link2
// file ../include/util.h line 217
static inline void uatomic_set_false$link2(struct anonymous$0 *val$link2)
{
  unsigned long int _v$link2;
  volatile unsigned long int tmp_statement_expression$1$link2;
  *((volatile unsigned long int *)&(*(&val$link2->val))) = (volatile unsigned long int)0;
  tmp_statement_expression$1$link2 = *((volatile unsigned long int *)&(*(&val$link2->val)));
  _v$link2 = tmp_statement_expression$1$link2;
  asm("" :  :  : "memory");
  _v$link2 = _v$link2;
}

// uatomic_set_true
// file ../include/util.h line 212
static inline _Bool uatomic_set_true(struct anonymous$0 *val)
{
  unsigned long int return_value___uatomic_cmpxchg$1;
  return_value___uatomic_cmpxchg$1=__uatomic_cmpxchg((void *)&val->val, (unsigned long int)0, (unsigned long int)1, (signed int)sizeof(unsigned long int) /*8ul*/ );
  return (unsigned long int)return_value___uatomic_cmpxchg$1 == (unsigned long int)0;
}

// uatomic_set_true$link1
// file ../include/util.h line 212
static inline _Bool uatomic_set_true$link1(struct anonymous$0 *val$link1)
{
  unsigned long int return_value___uatomic_cmpxchg$1$link1;
  return_value___uatomic_cmpxchg$1$link1=__uatomic_cmpxchg$link1((void *)&val$link1->val, (unsigned long int)0, (unsigned long int)1, (signed int)sizeof(unsigned long int) /*8ul*/ );
  return (unsigned long int)return_value___uatomic_cmpxchg$1$link1 == (unsigned long int)0;
}

// uatomic_set_true$link2
// file ../include/util.h line 212
static inline _Bool uatomic_set_true$link2(struct anonymous$0 *val$link2)
{
  unsigned long int return_value___uatomic_cmpxchg$1$link2;
  return_value___uatomic_cmpxchg$1$link2=__uatomic_cmpxchg$link2((void *)&val$link2->val, (unsigned long int)0, (unsigned long int)1, (signed int)sizeof(unsigned long int) /*8ul*/ );
  return (unsigned long int)return_value___uatomic_cmpxchg$1$link2 == (unsigned long int)0;
}

// unblock_sighup
// file logger.c line 143
static void unblock_sighup(void)
{
  signed int ret;
  struct anonymous$1 new;
  struct anonymous$1 old;
  sigemptyset(&new);
  sigemptyset(&old);
  sigaddset(&new, 1);
  ret=sigprocmask(1, &new, &old);
  if(!(ret >= 0))
    syslog(3, "unblock SIGHUP failed\n");

}

// unlock_cache
// file object_cache.c line 188
static inline void unlock_cache(struct object_cache *oc)
{
  sd_rw_unlock$link1(&oc->lock);
}

// unlock_entry
// file object_cache.c line 203
static inline void unlock_entry(struct object_cache_entry *entry)
{
  sd_rw_unlock$link1(&entry->lock);
}

// unregister_event
// file ../include/event.h line 13
void unregister_event(signed int fd)
{
  signed int ret;
  struct event_info *ei;
  ei=lookup_event(fd);
  if(!(ei == ((struct event_info *)NULL)))
  {
    ret=epoll_ctl(efd, 2, fd, (struct epoll_event *)(void *)0);
    if(!(ret == 0))
      log_write(3, "unregister_event", 136, "failed to delete epoll event for fd %d: %m", fd);

    rb_erase(&ei->rb, &events_tree);
    free((void *)ei);
    event_force_refresh();
  }

}

// unregister_listening_fds
// file request.c line 1049
void unregister_listening_fds(void)
{
  struct listening_fd *fd;
  struct listening_fd *__n1053;
  struct listening_fd *tmp_statement_expression$1;
  const struct list_node *__mptr = (&listening_fd_list)->n.next;
  tmp_statement_expression$1 = (struct listening_fd *)((char *)__mptr - (signed long int)8ul);
  fd = tmp_statement_expression$1;
  struct listening_fd *tmp_statement_expression$2;
  const struct list_node *unregister_listening_fds$$1$$1$$2$$__mptr = fd->list.next;
  tmp_statement_expression$2 = (struct listening_fd *)((char *)unregister_listening_fds$$1$$1$$2$$__mptr - (signed long int)8ul);
  __n1053 = tmp_statement_expression$2;
  struct listening_fd *tmp_statement_expression$3;
  for( ; !(&fd->list == &(&listening_fd_list)->n); __n1053 = tmp_statement_expression$3)
  {
    if(sd_log_level == 7)
      log_write(7, "unregister_listening_fds", 1054, "unregistering fd: %d", fd->fd);

    unregister_event(fd->fd);
    fd = __n1053;
    const struct list_node *unregister_listening_fds$$1$$1$$3$$__mptr = __n1053->list.next;
    tmp_statement_expression$3 = (struct listening_fd *)((char *)unregister_listening_fds$$1$$1$$3$$__mptr - (signed long int)8ul);
  }
}

// update_and_merge_free_desc
// file http/oalloc.c line 200
static inline signed int update_and_merge_free_desc(char *meta, unsigned long int start, unsigned long int count, unsigned int vid)
{
  struct header *hd = (struct header *)meta;
  struct free_desc *tail;
  struct free_desc *fd = (struct free_desc *)((char *)hd + (signed long int)sizeof(struct header) /*16ul*/ );
  unsigned long int i;
  unsigned long int j;
  i = (unsigned long int)0;
  for( ; !(i >= hd->nr_free); i = i + 1ul)
  {
    if(count + start == fd->start)
    {
      fd->start = start;
      fd->count = fd->count + count;
      break;
    }

    else
      if(fd->count + fd->start == start)
      {
        fd->count = fd->count + count;
        break;
      }

    fd = fd + 1l;
  }
  if(i == hd->nr_free)
  {
    if(hd->nr_free >= 262143ul)
      return 0x15;

    unsigned int return_value_oalloc_meta_length$1;
    return_value_oalloc_meta_length$1=oalloc_meta_length(hd);
    tail = (struct free_desc *)(meta + (signed long int)return_value_oalloc_meta_length$1);
    tail->start = start;
    tail->count = count;
    hd->nr_free = hd->nr_free + 1ul;
  }

  hd->used = hd->used - count;
  if(hd->nr_free >= 2ul)
    qsort((void *)(struct free_desc *)((char *)hd + (signed long int)sizeof(struct header) /*16ul*/ ), hd->nr_free, sizeof(struct free_desc) /*16ul*/ , (signed int (*)(const void *, const void *))free_desc_cmp);

  j = hd->nr_free - (unsigned long int)1;
  unsigned int return_value_oalloc_meta_length$2;
  return_value_oalloc_meta_length$2=oalloc_meta_length(hd);
  tail = (struct free_desc *)(meta + (signed long int)return_value_oalloc_meta_length$2) - (signed long int)1;
  i = (unsigned long int)0;
  for( ; !(i >= j); tail = tail - 1l)
  {
    struct free_desc *front = tail - (signed long int)1;
    if(sd_log_level == 7)
      log_write(7, "update_and_merge_free_desc", 240, "start %lu, count %lu", tail->start, tail->count);

    if(!(front->start >= tail->count + tail->start))
      log_write(0, "update_and_merge_free_desc", 242, "bad free descriptor found at %x", vid);

    if(tail->count + tail->start == front->start)
    {
      front->start = tail->start;
      front->count = front->count + tail->count;
      memmove((void *)tail, (const void *)(tail + (signed long int)1), sizeof(struct free_desc) /*16ul*/  * i);
      hd->nr_free = hd->nr_free - 1ul;
    }

    i = i + 1ul;
  }
  return 0x00;
}

// update_cluster_info
// file group.c line 638
static void update_cluster_info(struct cluster_info *cinfo, struct sd_node *joined, struct rb_root *nroot, unsigned long int nr_nodes)
{
  struct vnode_info *old_vnode_info;
  if(sd_log_level == 7)
    log_write(7, "update_cluster_info", 645, "status = %d, epoch = %d", cinfo->status, cinfo->epoch);

  if(sys->gateway_only == (_Bool)0)
    setup_backend_store(cinfo);

  _Bool return_value_node_is_local$1;
  return_value_node_is_local$1=node_is_local(joined);
  if(!(return_value_node_is_local$1 == (_Bool)0))
    sockfd_cache_add_group(nroot);

  sockfd_cache_add(&joined->nid);
  struct vnode_info *tmp_statement_expression$2 = current_vnode_info.__val;
  old_vnode_info = tmp_statement_expression$2;
  current_vnode_info.__val=alloc_vnode_info(nroot);
  get_vdis(nroot, joined);
  struct vnode_info *tmp_statement_expression$4;
  _Bool return_value_was_cluster_shutdowned$7;
  struct vnode_info *tmp_statement_expression$5;
  struct vnode_info *tmp_statement_expression$6;
  if((signed int)cinfo->status == SD_STATUS_OK)
  {
    _Bool return_value_is_cluster_formatted$3;
    return_value_is_cluster_formatted$3=is_cluster_formatted();
    if(return_value_is_cluster_formatted$3 == (_Bool)0)
      set_cluster_config(&sys->cinfo);

    if(!(nr_nodes == (unsigned long int)cinfo->nr_nodes))
    {
      signed int ret;
      if(!(old_vnode_info == ((struct vnode_info *)NULL)))
        put_vnode_info(old_vnode_info);

      old_vnode_info=alloc_old_vnode_info();
      ret=inc_and_log_epoch();
      if(!(ret == 0))
      {
        log_write(0, "update_cluster_info", 679, "PANIC: cannot log current epoch %d", sys->cinfo.epoch);
        abort();
      }

      tmp_statement_expression$4 = current_vnode_info.__val;
      start_recovery(tmp_statement_expression$4, old_vnode_info, (_Bool)1);
    }

    else
    {
      return_value_was_cluster_shutdowned$7=was_cluster_shutdowned();
      if(return_value_was_cluster_shutdowned$7 == (_Bool)0)
      {
        tmp_statement_expression$5 = current_vnode_info.__val;
        tmp_statement_expression$6 = current_vnode_info.__val;
        start_recovery(tmp_statement_expression$5, tmp_statement_expression$6, (_Bool)0);
      }

    }
    set_cluster_shutdown((_Bool)0);
  }

  put_vnode_info(old_vnode_info);
}

// update_epoch_from_v0_to_v1
// file migrate.c line 203
static signed int update_epoch_from_v0_to_v1(unsigned int epoch)
{
  char path[4096l];
  struct sd_node_v0 nodes_v0[6144l];
  struct sd_node_v1 nodes_v1[6144l];
  unsigned long int update_epoch_from_v0_to_v1$$1$$nr_nodes;
  signed long int *t;
  signed int len;
  signed int fd;
  signed int ret;
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s%08u", epoch_path, epoch);
  fd=open(path, 02 | 010000);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      return 0;

    log_write(3, "update_epoch_from_v0_to_v1", 218, "failed to open epoch %u log", epoch);
    return -1;
  }

  signed long int return_value_xread$2;
  return_value_xread$2=xread(fd, (void *)nodes_v0, sizeof(struct sd_node_v0 [6144l]) /*147456ul*/ );
  ret = (signed int)return_value_xread$2;
  if(!(ret >= 0))
  {
    log_write(3, "update_epoch_from_v0_to_v1", 224, "failed to read epoch %u log", epoch);
    close(fd);
    return ret;
  }

  else
  {
    update_epoch_from_v0_to_v1$$1$$nr_nodes = (unsigned long int)ret / sizeof(struct sd_node_v0) /*24ul*/ ;
    signed int i = 0;
    for( ; !((unsigned long int)i >= update_epoch_from_v0_to_v1$$1$$nr_nodes); i = i + 1)
    {
      memcpy((void *)&nodes_v1[(signed long int)i].nid, (const void *)&nodes_v0[(signed long int)i].nid, sizeof(struct node_id_v1) /*18ul*/ );
      nodes_v1[(signed long int)i].nr_vnodes = nodes_v0[(signed long int)i].nr_vnodes;
      nodes_v1[(signed long int)i].zone = nodes_v0[(signed long int)i].zone;
      nodes_v1[(signed long int)i].space = (unsigned long int)0;
    }
    len = (signed int)(sizeof(struct sd_node_v1) /*32ul*/  * update_epoch_from_v0_to_v1$$1$$nr_nodes);
    signed long int return_value_xpwrite$3;
    return_value_xpwrite$3=xpwrite(fd, (const void *)nodes_v1, (unsigned long int)len, (signed long int)0);
    ret = (signed int)return_value_xpwrite$3;
    if(!(ret == len))
    {
      log_write(3, "update_epoch_from_v0_to_v1", 241, "failed to write epoch %u log", epoch);
      close(fd);
      return -1;
    }

    else
    {
      t = (signed long int *)&nodes_v0[(signed long int)update_epoch_from_v0_to_v1$$1$$nr_nodes];
      signed long int return_value_xpwrite$4;
      return_value_xpwrite$4=xpwrite(fd, (const void *)t, sizeof(signed long int) /*8ul*/ , (signed long int)len);
      ret = (signed int)return_value_xpwrite$4;
      if(!((unsigned long int)ret == sizeof(signed long int) /*8ul*/ ))
      {
        log_write(3, "update_epoch_from_v0_to_v1", 250, "failed to write time to epoch %u log", epoch);
        close(fd);
        return -1;
      }

      else
      {
        close(fd);
        return 0;
      }
    }
  }
}

// update_epoch_from_v1_to_v2
// file migrate.c line 311
static signed int update_epoch_from_v1_to_v2(unsigned int epoch)
{
  char path[4096l];
  struct sd_node_v1 nodes_v1[6144l];
  struct sd_node_v2 nodes_v2[6144l];
  unsigned long int update_epoch_from_v1_to_v2$$1$$nr_nodes;
  signed long int *t;
  signed int len;
  signed int fd;
  signed int ret;
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s%08u", epoch_path, epoch);
  fd=open(path, 02 | 010000);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 2)
      return 0;

    log_write(3, "update_epoch_from_v1_to_v2", 326, "failed to open epoch %u log", epoch);
    return -1;
  }

  unsigned long int return_value_get_file_size$2;
  return_value_get_file_size$2=get_file_size(path);
  if(!((return_value_get_file_size$2 + 18446744073709551608ul) % sizeof(struct sd_node_v1) /*32ul*/  == 0ul))
  {
    if(sd_log_level == 7)
      log_write(7, "update_epoch_from_v1_to_v2", 336, "%s is not a v1 format", (const void *)path);

    close(fd);
    return 0;
  }

  else
  {
    signed long int return_value_xread$3;
    return_value_xread$3=xread(fd, (void *)nodes_v1, sizeof(struct sd_node_v1 [6144l]) /*196608ul*/ );
    ret = (signed int)return_value_xread$3;
    if(!(ret >= 0))
    {
      log_write(3, "update_epoch_from_v1_to_v2", 343, "failed to read epoch %u log", epoch);
      close(fd);
      return ret;
    }

    else
    {
      update_epoch_from_v1_to_v2$$1$$nr_nodes = (unsigned long int)ret / sizeof(struct sd_node_v1) /*32ul*/ ;
      signed int i = 0;
      for( ; !((unsigned long int)i >= update_epoch_from_v1_to_v2$$1$$nr_nodes); i = i + 1)
      {
        if((signed int)nodes_v1[(signed long int)i].nid.port == 0)
        {
          if(sd_log_level == 7)
            log_write(7, "update_epoch_from_v1_to_v2", 351, "%s is not a v1 format", (const void *)path);

          return 0;
        }

        memset((void *)&nodes_v2[(signed long int)i].nid, 0, sizeof(struct node_id_v2) /*40ul*/ );
        memcpy((void *)nodes_v2[(signed long int)i].nid.addr, (const void *)nodes_v1[(signed long int)i].nid.addr, sizeof(unsigned char [16l]) /*16ul*/ );
        nodes_v2[(signed long int)i].nid.port = nodes_v1[(signed long int)i].nid.port;
        nodes_v2[(signed long int)i].nr_vnodes = nodes_v1[(signed long int)i].nr_vnodes;
        nodes_v2[(signed long int)i].zone = nodes_v1[(signed long int)i].zone;
        nodes_v2[(signed long int)i].space = nodes_v1[(signed long int)i].space;
      }
      len = (signed int)(sizeof(struct sd_node_v2) /*56ul*/  * update_epoch_from_v1_to_v2$$1$$nr_nodes);
      signed long int return_value_xpwrite$4;
      return_value_xpwrite$4=xpwrite(fd, (const void *)nodes_v2, (unsigned long int)len, (signed long int)0);
      ret = (signed int)return_value_xpwrite$4;
      if(!(ret == len))
      {
        log_write(3, "update_epoch_from_v1_to_v2", 366, "failed to write epoch %u log", epoch);
        close(fd);
        return -1;
      }

      else
      {
        t = (signed long int *)&nodes_v1[(signed long int)update_epoch_from_v1_to_v2$$1$$nr_nodes];
        signed long int return_value_xpwrite$5;
        return_value_xpwrite$5=xpwrite(fd, (const void *)t, sizeof(signed long int) /*8ul*/ , (signed long int)len);
        ret = (signed int)return_value_xpwrite$5;
        if(!((unsigned long int)ret == sizeof(signed long int) /*8ul*/ ))
        {
          log_write(3, "update_epoch_from_v1_to_v2", 375, "failed to write time to epoch %u log", epoch);
          close(fd);
          return -1;
        }

        else
        {
          close(fd);
          return 0;
        }
      }
    }
  }
}

// update_epoch_log
// file sheep_priv.h line 346
signed int update_epoch_log(unsigned int epoch, struct sd_node *nodes, unsigned long int nr_nodes)
{
  signed int ret;
  signed int len;
  signed int nodes_len;
  signed long int t;
  char path[4096l];
  char *buf;
  if(sd_log_level == 7)
    log_write(7, "update_epoch_log", 26, "update epoch: %d, %zu", epoch, nr_nodes);

  time(&t);
  nodes_len = (signed int)(nr_nodes * sizeof(struct sd_node) /*80ul*/ );
  len = (signed int)((unsigned long int)nodes_len + sizeof(signed long int) /*8ul*/ );
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc((unsigned long int)len);
  buf = (char *)return_value_xmalloc$1;
  memcpy((void *)buf, (const void *)nodes, (unsigned long int)nodes_len);
  memcpy((void *)(buf + (signed long int)nodes_len), (const void *)&t, sizeof(signed long int) /*8ul*/ );
  snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s%08u", epoch_path, epoch);
  ret=atomic_create_and_write(path, buf, (unsigned long int)len, (_Bool)1);
  free((void *)buf);
  return ret;
}

// update_node_size
// file group.c line 960
static void update_node_size(struct sd_node *node)
{
  struct vnode_info *cur_vinfo;
  cur_vinfo=get_vnode_info();
  struct sd_node *n;
  struct sd_node *tmp_statement_expression$1;
  struct rb_node *__n = (&cur_vinfo->nroot)->rb_node;
  struct sd_node *__ret = (struct sd_node *)(void *)0;
  struct sd_node *__data;
  struct sd_node *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=node_cmp(node, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  n = tmp_statement_expression$1;
  if(n == ((struct sd_node *)NULL))
  {
    const char *return_value_node_to_str$3;
    return_value_node_to_str$3=node_to_str(node);
    log_write(0, "update_node_size", 966, "PANIC: can't find %s", return_value_node_to_str$3);
    abort();
  }

  n->space = node->space;
  put_vnode_info(cur_vinfo);
}

// usage
// file sheep.c line 150
static void usage(signed int status)
{
  if(!(status == 0))
  {
    const char *help;
    help=option_get_help(sheep_options, optopt);
    if(!(help == ((const char *)NULL)))
    {
      printf("%s", help);
      goto out;
    }

    log_write(3, "usage", 160, "Try '%s --help' for more information.", (const void *)program_name);
  }

  else
  {
    struct sd_option *opt;
    printf("Sheepdog daemon (version %s)\nUsage: %s [OPTION]... [PATH] (default: /tmp)\nOptions:\n", (const void *)"0.8.3", (const void *)program_name);
    opt = sheep_options;
    for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
      printf("  -%c, --%-18s%s\n", opt->ch, opt->name, opt->desc);
    printf("\nTry '%s <option>', e.g., '%s -w', to get more detail about specific option\n", (const void *)program_name, (const void *)program_name);
  }

out:
  ;
  exit(status);
}

// vdi_create
// file vdi.c line 678
signed int vdi_create(struct vdi_iocb *iocb, unsigned int *new_vid)
{
  struct vdi_info info = { .vid=0u, .snapid=0u, .free_bit=0u, .create_time=0ul };
  signed int ret;
  ret=vdi_lookup(iocb, &info);
  const char *return_value_sd_strerror$1;
  switch(ret)
  {
    case 0x00:
      return 0x04;
    case 0x08:
      break;
    default:
    {
      return_value_sd_strerror$1=sd_strerror$link4(ret);
      log_write(3, "vdi_create", 690, "%s", return_value_sd_strerror$1);
      return ret;
    }
  }
  if(info.snapid == 0u)
    info.snapid = (unsigned int)1;

  *new_vid = info.free_bit;
  ret=notify_vdi_add(*new_vid, (unsigned int)iocb->nr_copies, info.vid, iocb->copy_policy);
  signed int return_value_create_vdi$2;
  signed int return_value_clone_vdi$3;
  if(!(ret == 0x00))
    return ret;

  else
    if(iocb->base_vid == 0u)
    {
      return_value_create_vdi$2=create_vdi(iocb, info.snapid, *new_vid);
      return return_value_create_vdi$2;
    }

    else
    {
      return_value_clone_vdi$3=clone_vdi(iocb, info.snapid, *new_vid, iocb->base_vid);
      return return_value_clone_vdi$3;
    }
}

// vdi_delete
// file vdi.c line 1153
signed int vdi_delete(struct vdi_iocb *iocb, struct request *req)
{
  struct vdi_info info;
  signed int ret;
  ret=vdi_lookup(iocb, &info);
  if(ret == 0x00)
    ret=start_deletion(req, info.vid);


out:
  ;
  return ret;
}

// vdi_exist
// file vdi.c line 201
signed int vdi_exist(unsigned int vid)
{
  struct sd_inode *inode;
  signed int ret = 1;
  void *return_value_xzalloc$1;
  return_value_xzalloc$1=xzalloc(sizeof(struct sd_inode) /*4198976ul*/ );
  inode = (struct sd_inode *)return_value_xzalloc$1;
  unsigned long int return_value_vid_to_vdi_oid$2;
  return_value_vid_to_vdi_oid$2=vid_to_vdi_oid(vid);
  ret=sd_read_object(return_value_vid_to_vdi_oid$2, (char *)inode, (unsigned int)sizeof(struct sd_inode) /*4198976ul*/ , (unsigned long int)0);
  _Bool return_value_vdi_is_deleted$3;
  if(!(ret == 0x00))
  {
    log_write(3, "vdi_exist", 210, "fail to read vdi inode (%x)", vid);
    ret = 0;
  }

  else
  {
    return_value_vdi_is_deleted$3=vdi_is_deleted(inode);
    if(!(return_value_vdi_is_deleted$3 == (_Bool)0))
      ret = 0;

    else
      ret = 1;
  }

out:
  ;
  free((void *)inode);
  return ret;
}

// vdi_flush
// file vdi.c line 652
static void vdi_flush(unsigned int vid)
{
  struct sd_req hdr;
  signed int ret;
  sd_init_req$link3(&hdr, (unsigned char)0x16);
  hdr.$anon0.obj.oid=vid_to_vdi_oid(vid);
  ret=exec_local_req(&hdr, (void *)0);
  const char *return_value_sd_strerror$1;
  if(!(ret == 0x00))
  {
    return_value_sd_strerror$1=sd_strerror$link4(ret);
    log_write(3, "vdi_flush", 663, "fail to flush vdi %x, %s", vid, return_value_sd_strerror$1);
  }

}

// vdi_has_tag
// file vdi.c line 518
static inline _Bool vdi_has_tag(struct vdi_iocb *iocb)
{
  _Bool tmp_if_expr$1;
  if(!(iocb->tag == ((const char *)NULL)))
    tmp_if_expr$1 = iocb->tag[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = iocb->snapid != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// vdi_init_tag
// file ops.c line 134
static signed int vdi_init_tag(const char **tag, const char *buf, unsigned int len)
{
  if(len == 256U)
    *tag = buf + (signed long int)256U;

  else
    if(len == 256U)
      *tag = (const char *)(void *)0;

    else
      return -1;
  return 0;
}

// vdi_is_deleted
// file vdi.c line 196
static inline _Bool vdi_is_deleted(struct sd_inode *inode)
{
  return (signed int)inode->name[0l] == 0;
}

// vdi_is_snapshot
// file ../include/sheepdog_proto.h line 465
static inline _Bool vdi_is_snapshot(struct sd_inode *inode)
{
  return !(!(inode->snap_ctime != 0ul));
}

// vdi_is_snapshot$link1
// file ../include/sheepdog_proto.h line 465
static inline _Bool vdi_is_snapshot$link1(struct sd_inode *inode$link1)
{
  return !(!(inode$link1->snap_ctime != 0ul));
}

// vdi_lookup
// file vdi.c line 613
signed int vdi_lookup(struct vdi_iocb *iocb, struct vdi_info *info)
{
  unsigned long int left;
  unsigned long int right;
  signed int ret;
  ret=get_vdi_bitmap_range(iocb->name, &left, &right);
  info->free_bit = (unsigned int)right;
  if(sd_log_level == 7)
    log_write(7, "vdi_lookup", 620, "%s left %lx right %lx, %x", iocb->name, left, right, ret);

  if(!(ret == 0x08) && !(ret == 0x13))
  {
    if(ret == 0x00)
      goto __CPROVER_DUMP_L3;

  }

  else
    return ret;

__CPROVER_DUMP_L3:
  ;
  signed int return_value_fill_vdi_info$1;
  return_value_fill_vdi_info$1=fill_vdi_info(left, right, iocb, info);
  return return_value_fill_vdi_info$1;
}

// vdi_read_write
// file http/kv.c line 632
static signed int vdi_read_write(unsigned int vid, char *data, unsigned long int length, signed long int offset, _Bool is_read)
{
  struct sd_req hdr;
  unsigned int idx = (unsigned int)((unsigned long int)offset / (1UL << 22));
  unsigned long int done = (unsigned long int)0;
  struct request_iocb *iocb;
  signed int ret;
  iocb=local_req_init();
  unsigned long int tmp_statement_expression$1;
  const char *return_value_sd_strerror$2;
  if(iocb == ((struct request_iocb *)NULL))
    return 0x06;

  else
  {
    offset = offset % (signed long int)(1UL << 22);
    while(!(done >= length))
    {
      unsigned long int len;
      unsigned long int _x = length - done;
      unsigned long int _y = (1UL << 22) - (unsigned long int)offset;
      (void)(&_x == &_y);
      tmp_statement_expression$1 = _x < _y ? _x : _y;
      len = tmp_statement_expression$1;
      if(!(is_read == (_Bool)0))
        sd_init_req$link6(&hdr, (unsigned char)0x02);

      else
      {
        sd_init_req$link6(&hdr, (unsigned char)0x01);
        hdr.flags = (unsigned short int)0x01;
      }
      hdr.data_length = (unsigned int)len;
      hdr.$anon0.obj.oid=vid_to_data_oid$link2(vid, (unsigned long int)idx);
      hdr.$anon0.obj.offset = (unsigned int)offset;
      ret=exec_local_req_async(&hdr, (void *)data, iocb);
      if(!(ret == 0x00))
      {
        return_value_sd_strerror$2=sd_strerror$link8(ret);
        log_write(3, "vdi_read_write", 662, "failed to write object %lx, %s", hdr.$anon0.obj.oid, return_value_sd_strerror$2);
      }

      offset = offset + (signed long int)len;
      if((unsigned long int)offset == 4194304ul)
      {
        offset = (signed long int)0;
        idx = idx + 1u;
      }

      done = done + len;
      data = data + (signed long int)len;
    }
    signed int return_value_local_req_wait$3;
    return_value_local_req_wait$3=local_req_wait(iocb);
    return return_value_local_req_wait$3;
  }
}

// vdi_snapshot
// file vdi.c line 721
signed int vdi_snapshot(struct vdi_iocb *iocb, unsigned int *new_vid)
{
  struct vdi_info info = { .vid=0u, .snapid=0u, .free_bit=0u, .create_time=0ul };
  signed int ret;
  ret=vdi_lookup(iocb, &info);
  if(ret == 0x00)
  {
    if(!(sys->enable_object_cache == (_Bool)0))
      vdi_flush(iocb->base_vid);

  }

  else
  {
    const char *return_value_sd_strerror$1;
    return_value_sd_strerror$1=sd_strerror$link4(ret);
    log_write(3, "vdi_snapshot", 731, "%s", return_value_sd_strerror$1);
    return ret;
  }
  *new_vid = info.free_bit;
  ret=notify_vdi_add(*new_vid, (unsigned int)iocb->nr_copies, info.vid, iocb->copy_policy);
  signed int return_value_snapshot_vdi$2;
  signed int return_value_rebase_vdi$3;
  if(!(ret == 0x00))
    return ret;

  else
    if(iocb->base_vid == info.vid)
    {
      return_value_snapshot_vdi$2=snapshot_vdi(iocb, info.snapid, *new_vid, iocb->base_vid);
      return return_value_snapshot_vdi$2;
    }

    else
    {
      return_value_rebase_vdi$3=rebase_vdi(iocb, info.snapid, *new_vid, iocb->base_vid, info.vid);
      return return_value_rebase_vdi$3;
    }
}

// vdi_state_cmp
// file vdi.c line 45
static signed int vdi_state_cmp(struct vdi_state_entry *a, struct vdi_state_entry *b)
{
  signed int tmp_statement_expression$1;
  unsigned int _x = a->vid;
  unsigned int _y = b->vid;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// vdi_state_insert
// file vdi.c line 59
static struct vdi_state_entry * vdi_state_insert(struct rb_root *root, struct vdi_state_entry *new)
{
  struct vdi_state_entry *tmp_statement_expression$1;
  struct rb_node **__n = &root->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct vdi_state_entry *__old = (struct vdi_state_entry *)(void *)0;
  struct vdi_state_entry *__data;
  struct vdi_state_entry *tmp_statement_expression$2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression$2 = (struct vdi_state_entry *)((char *)__mptr - (signed long int)16ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=vdi_state_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct vdi_state_entry *)NULL))
  {
    rb_link_node$link1(&new->node, __parent, __n);
    rb_insert_color(&new->node, root);
  }

  tmp_statement_expression$1 = __old;
  return tmp_statement_expression$1;
}

// vdi_state_search
// file vdi.c line 51
static struct vdi_state_entry * vdi_state_search(struct rb_root *root, unsigned int vid)
{
  struct vdi_state_entry key = { .vid=vid, .nr_copies=0u, .snapshot=(_Bool)0, .copy_policy=0,
    .node={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) } };
  struct vdi_state_entry *tmp_statement_expression$1;
  struct rb_node *__n = root->rb_node;
  struct vdi_state_entry *__ret = (struct vdi_state_entry *)(void *)0;
  struct vdi_state_entry *__data;
  struct vdi_state_entry *tmp_statement_expression$2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression$2 = (struct vdi_state_entry *)((char *)__mptr - (signed long int)16ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=vdi_state_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression$1 = __ret;
  return tmp_statement_expression$1;
}

// vdi_tag_match
// file vdi.c line 525
static inline _Bool vdi_tag_match(struct vdi_iocb *iocb, struct sd_inode *inode)
{
  const char *tag = iocb->tag;
  signed int return_value_strncmp$1;
  if(!(inode->tag[0l] == 0))
  {
    return_value_strncmp$1=strncmp(inode->tag, tag, sizeof(char [256l]) /*256ul*/ );
    if(!(return_value_strncmp$1 == 0))
      goto __CPROVER_DUMP_L1;

    return (_Bool)1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(iocb->snapid == inode->snap_id)
      return (_Bool)1;

    else
      return (_Bool)0;
  }
}

// vdisk_cmp
// file md.c line 67
static signed int vdisk_cmp(struct vdisk *d1, struct vdisk *d2)
{
  signed int tmp_statement_expression$1;
  unsigned long int _x = d1->hash;
  unsigned long int _y = d2->hash;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// vdisk_free
// file md.c line 106
static inline void vdisk_free(struct vdisk *v)
{
  rb_erase(&v->rb, &md.vroot);
  free((void *)v);
}

// vdisk_insert
// file md.c line 72
static struct vdisk * vdisk_insert(struct vdisk *new)
{
  struct vdisk *tmp_statement_expression$1;
  struct rb_node **__n = &(&md.vroot)->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct vdisk *__old = (struct vdisk *)(void *)0;
  struct vdisk *__data;
  struct vdisk *tmp_statement_expression$2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression$2 = (struct vdisk *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression$2;
    signed int __cmp;
    __cmp=vdisk_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct vdisk *)NULL))
  {
    rb_link_node$link5(&new->rb, __parent, __n);
    rb_insert_color(&new->rb, &md.vroot);
  }

  tmp_statement_expression$1 = __old;
  return tmp_statement_expression$1;
}

// vdisk_number
// file md.c line 57
static inline signed int vdisk_number(struct disk *disk)
{
  return (signed int)(((disk->space + (unsigned long int)1 * (unsigned long int)1024 * (unsigned long int)1024 * (unsigned long int)1024) - (unsigned long int)1) / ((unsigned long int)1 * (unsigned long int)1024 * (unsigned long int)1024 * (unsigned long int)1024));
}

// vid_is_snapshot
// file vdi.c line 65
static _Bool vid_is_snapshot(unsigned int vid)
{
  struct vdi_state_entry *entry;
  sd_read_lock(&vdi_state_lock);
  entry=vdi_state_search(&vdi_state_root, vid);
  sd_rw_unlock(&vdi_state_lock);
  if(entry == ((struct vdi_state_entry *)NULL))
  {
    log_write(3, "vid_is_snapshot", 74, "No VDI entry for %x found", vid);
    return (_Bool)0;
  }

  else
    return entry->snapshot;
}

// vid_to_attr_oid
// file ../include/sheepdog_proto.h line 450
static inline unsigned long int vid_to_attr_oid(unsigned int vid, unsigned int attrid)
{
  return (unsigned long int)vid << 32 | 1UL << 61 | (unsigned long int)attrid;
}

// vid_to_btree_oid
// file ../include/sheepdog_proto.h line 455
static inline unsigned long int vid_to_btree_oid(unsigned int vid, unsigned int btreeid)
{
  return (unsigned long int)vid << 32 | 1UL << 60 | (unsigned long int)btreeid;
}

// vid_to_data_oid
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid(unsigned int vid, unsigned long int idx)
{
  return (unsigned long int)vid << 32 | idx;
}

// vid_to_data_oid$link1
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid$link1(unsigned int vid$link1, unsigned long int idx$link1)
{
  return (unsigned long int)vid$link1 << 32 | idx$link1;
}

// vid_to_data_oid$link2
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid$link2(unsigned int vid$link2, unsigned long int idx$link2)
{
  return (unsigned long int)vid$link2 << 32 | idx$link2;
}

// vid_to_data_oid$link3
// file ../include/sheepdog_proto.h line 440
static inline unsigned long int vid_to_data_oid$link3(unsigned int vid$link3, unsigned long int idx$link3)
{
  return (unsigned long int)vid$link3 << 32 | idx$link3;
}

// vid_to_vdi_oid
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid(unsigned int vid)
{
  return 1UL << 63 | (unsigned long int)vid << 32;
}

// vid_to_vdi_oid$link1
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link1(unsigned int vid$link1)
{
  return 1UL << 63 | (unsigned long int)vid$link1 << 32;
}

// vid_to_vdi_oid$link2
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link2(unsigned int vid$link2)
{
  return 1UL << 63 | (unsigned long int)vid$link2 << 32;
}

// vid_to_vdi_oid$link3
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link3(unsigned int vid$link3)
{
  return 1UL << 63 | (unsigned long int)vid$link3 << 32;
}

// vid_to_vdi_oid$link4
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link4(unsigned int vid$link4)
{
  return 1UL << 63 | (unsigned long int)vid$link4 << 32;
}

// vid_to_vdi_oid$link5
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid$link5(unsigned int vid$link5)
{
  return 1UL << 63 | (unsigned long int)vid$link5 << 32;
}

// vnode_cmp
// file ../include/sheep.h line 50
static inline signed int vnode_cmp(struct sd_vnode *node1, struct sd_vnode *node2)
{
  signed int tmp_statement_expression$1;
  unsigned long int _x = node1->hash;
  unsigned long int _y = node2->hash;
  (void)(&_x == &_y);
  tmp_statement_expression$1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression$1;
}

// vnode_cmp$link1
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link1(struct sd_vnode *node1$link1, struct sd_vnode *node2$link1)
{
  signed int tmp_statement_expression$1$link1;
  unsigned long int _x$link1 = node1$link1->hash;
  unsigned long int _y$link1 = node2$link1->hash;
  (void)(&_x$link1 == &_y$link1);
  tmp_statement_expression$1$link1 = _x$link1 < _y$link1 ? -1 : (_x$link1 > _y$link1 ? 1 : 0);
  return tmp_statement_expression$1$link1;
}

// vnode_cmp$link2
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link2(struct sd_vnode *node1$link2, struct sd_vnode *node2$link2)
{
  signed int tmp_statement_expression$1$link2;
  unsigned long int _x$link2 = node1$link2->hash;
  unsigned long int _y$link2 = node2$link2->hash;
  (void)(&_x$link2 == &_y$link2);
  tmp_statement_expression$1$link2 = _x$link2 < _y$link2 ? -1 : (_x$link2 > _y$link2 ? 1 : 0);
  return tmp_statement_expression$1$link2;
}

// vnode_cmp$link3
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link3(struct sd_vnode *node1$link3, struct sd_vnode *node2$link3)
{
  signed int tmp_statement_expression$1$link3;
  unsigned long int _x$link3 = node1$link3->hash;
  unsigned long int _y$link3 = node2$link3->hash;
  (void)(&_x$link3 == &_y$link3);
  tmp_statement_expression$1$link3 = _x$link3 < _y$link3 ? -1 : (_x$link3 > _y$link3 ? 1 : 0);
  return tmp_statement_expression$1$link3;
}

// vnode_cmp$link4
// file ../include/sheep.h line 50
static inline signed int vnode_cmp$link4(struct sd_vnode *node1$link4, struct sd_vnode *node2$link4)
{
  signed int tmp_statement_expression$1$link4;
  unsigned long int _x$link4 = node1$link4->hash;
  unsigned long int _y$link4 = node2$link4->hash;
  (void)(&_x$link4 == &_y$link4);
  tmp_statement_expression$1$link4 = _x$link4 < _y$link4 ? -1 : (_x$link4 > _y$link4 ? 1 : 0);
  return tmp_statement_expression$1$link4;
}

// vnode_is_local
// file sheep_priv.h line 429
static inline _Bool vnode_is_local(struct sd_vnode *v)
{
  signed int return_value_node_id_cmp$1;
  return_value_node_id_cmp$1=node_id_cmp$link1(&v->node->nid, &sys->this_node.nid);
  return return_value_node_id_cmp$1 == 0;
}

// vnode_is_local$link1
// file sheep_priv.h line 429
static inline _Bool vnode_is_local$link1(struct sd_vnode *v$link1)
{
  signed int return_value_node_id_cmp$1$link1;
  return_value_node_id_cmp$1$link1=node_id_cmp$link2(&v$link1->node->nid, &sys->this_node.nid);
  return return_value_node_id_cmp$1$link1 == 0;
}

// vnode_is_local$link2
// file sheep_priv.h line 429
static inline _Bool vnode_is_local$link2(struct sd_vnode *v$link2)
{
  signed int return_value_node_id_cmp$1$link2;
  return_value_node_id_cmp$1$link2=node_id_cmp$link4(&v$link2->node->nid, &sys->this_node.nid);
  return return_value_node_id_cmp$1$link2 == 0;
}

// vnode_is_local$link3
// file sheep_priv.h line 429
static inline _Bool vnode_is_local$link3(struct sd_vnode *v$link3)
{
  signed int return_value_node_id_cmp$1$link3;
  return_value_node_id_cmp$1$link3=node_id_cmp$link5(&v$link3->node->nid, &sys->this_node.nid);
  return return_value_node_id_cmp$1$link3 == 0;
}

// wait_forward_request
// file gateway.c line 366
static signed int wait_forward_request(struct forward_info *fi, struct request *req)
{
  signed int nr_sent;
  signed int err_ret = 0x00;
  signed int ret;
  signed int pollret;
  signed int i;
  signed int repeat = 30 / 5;
  struct pfd_info pi;
  struct sd_rsp *rsp = &req->rp;
  do
  {

  again:
    ;
    pfd_info_init(fi, &pi);
    pollret=poll(pi.pfds, (unsigned long int)pi.nr, 1000 * 5);
    if(!(pollret >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
        goto again;

      log_write(0, "wait_forward_request", 379, "PANIC: %m");
      abort();
    }

    else
      if(pollret == 0)
      {
        _Bool return_value_sheep_need_retry$2;
        return_value_sheep_need_retry$2=sheep_need_retry(req->rq.epoch);
        if(!(return_value_sheep_need_retry$2 == (_Bool)0))
        {
          if(!(repeat == 0))
          {
            repeat = repeat - 1;
            log_write(4, "wait_forward_request", 389, "poll timeout %d, disks of some nodes or network is busy. Going to poll-wait again", fi->nr_sent);
            goto again;
          }

        }

        nr_sent = fi->nr_sent;
        i = 0;
        for( ; !(i >= nr_sent); i = i + 1)
          sockfd_cache_del(fi->ent[(signed long int)i].nid, fi->ent[(signed long int)i].sfd);
        return 0x86;
      }

    nr_sent = fi->nr_sent;
    i = 0;
    for( ; !(i >= nr_sent); i = i + 1)
      if(!((0x001 & (signed int)pi.pfds[(signed long int)i].revents) == 0))
        break;

    if(!(i >= nr_sent))
    {
      signed int re = (signed int)pi.pfds[(signed long int)i].revents;
      if(sd_log_level == 7)
        log_write(7, "wait_forward_request", 407, "%d, revents %x", i, re);

      if(!((56 & re) == 0))
      {
        err_ret = 0x86;
        finish_one_entry_err(fi, i);
      }

      else
      {
        signed int return_value_do_read$3;
        return_value_do_read$3=do_read(pi.pfds[(signed long int)i].fd, (void *)rsp, (signed int)sizeof(struct sd_rsp) /*48ul*/ , sheep_need_retry, req->rq.epoch, (unsigned int)(30 / 5));
        if(!(return_value_do_read$3 == 0))
        {
          log_write(3, "wait_forward_request", 415, "remote node might have gone away");
          err_ret = 0x86;
          finish_one_entry_err(fi, i);
        }

        else
        {
          if(!(rsp->data_length == 0u))
          {
            struct forward_info_entry *ent;
            ent=forward_info_find(fi, pi.pfds[(signed long int)i].fd);
            signed int return_value_do_read$4;
            return_value_do_read$4=do_read(pi.pfds[(signed long int)i].fd, ent->buf, (signed int)rsp->data_length, sheep_need_retry, req->rq.epoch, (unsigned int)(30 / 5));
            if(!(return_value_do_read$4 == 0))
            {
              log_write(3, "wait_forward_request", 428, "remote node might have gone away");
              err_ret = 0x86;
              finish_one_entry_err(fi, i);
              continue;
            }

          }

          ret = (signed int)rsp->$anon0.result;
          if(!(ret == 0x00))
          {
            const char *return_value_sd_strerror$5;
            return_value_sd_strerror$5=sd_strerror$link2(ret);
            log_write(3, "wait_forward_request", 437, "fail %lx, %s", req->rq.$anon0.obj.oid, return_value_sd_strerror$5);
            err_ret = ret;
          }

          finish_one_entry(fi, i);
        }
      }
    }


  out:
    ;
  }
  while(fi->nr_sent >= 1);
  return err_ret;
}

// wait_get_vdis_done
// file group.c line 626
void wait_get_vdis_done(void)
{
  if(sd_log_level == 7)
    log_write(7, "wait_get_vdis_done", 628, "waiting for vdi list");

  sd_mutex_lock(&wait_vdis_lock);
  signed int return_value_refcount_read$1;
  do
  {
    return_value_refcount_read$1=refcount_read(&nr_get_vdis_works);
    if(!(return_value_refcount_read$1 >= 1))
      break;

    sd_cond_wait(&wait_vdis_cond, &wait_vdis_lock);
  }
  while((_Bool)1);
  sd_mutex_unlock(&wait_vdis_lock);
  if(sd_log_level == 7)
    log_write(7, "wait_get_vdis_done", 635, "vdi list ready");

}

// wakeup_all_requests
// file request.c line 256
void wakeup_all_requests(void)
{
  struct request *req;
  struct list_head pending_list = { .n={ .next=&pending_list.n, .prev=&pending_list.n } };
  list_splice_init(&sys->req_wait_queue, &pending_list);
  struct request *__n263;
  struct request *tmp_statement_expression$1;
  const struct list_node *__mptr = (&pending_list)->n.next;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)128ul);
  req = tmp_statement_expression$1;
  struct request *tmp_statement_expression$2;
  const struct list_node *wakeup_all_requests$$1$$1$$2$$__mptr = req->request_list.next;
  tmp_statement_expression$2 = (struct request *)((char *)wakeup_all_requests$$1$$1$$2$$__mptr - (signed long int)128ul);
  __n263 = tmp_statement_expression$2;
  struct request *tmp_statement_expression$3;
  for( ; !(&req->request_list == &(&pending_list)->n); __n263 = tmp_statement_expression$3)
  {
    if(sd_log_level == 7)
      log_write(7, "wakeup_all_requests", 264, "%lx", req->rq.$anon0.obj.oid);

    del_requeue_request(req);
    req = __n263;
    const struct list_node *wakeup_all_requests$$1$$1$$3$$__mptr = __n263->request_list.next;
    tmp_statement_expression$3 = (struct request *)((char *)wakeup_all_requests$$1$$1$$3$$__mptr - (signed long int)128ul);
  }
}

// wakeup_requests_on_epoch
// file request.c line 203
void wakeup_requests_on_epoch(void)
{
  struct request *req;
  struct list_head pending_list = { .n={ .next=&pending_list.n, .prev=&pending_list.n } };
  list_splice_init(&sys->req_wait_queue, &pending_list);
  struct request *__n210;
  struct request *tmp_statement_expression$1;
  const struct list_node *__mptr = (&pending_list)->n.next;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)128ul);
  req = tmp_statement_expression$1;
  struct request *tmp_statement_expression$2;
  const struct list_node *wakeup_requests_on_epoch$$1$$1$$2$$__mptr = req->request_list.next;
  tmp_statement_expression$2 = (struct request *)((char *)wakeup_requests_on_epoch$$1$$1$$2$$__mptr - (signed long int)128ul);
  __n210 = tmp_statement_expression$2;
  struct request *tmp_statement_expression$3;
  for( ; !(&req->request_list == &(&pending_list)->n); __n210 = tmp_statement_expression$3)
  {
    switch(req->rp.$anon0.result)
    {
      case (unsigned int)0x81:
      {
        if(sd_log_level == 7)
          log_write(7, "wakeup_requests_on_epoch", 218, "gateway %lx", req->rq.$anon0.obj.oid);

        req->rq.epoch = sys->cinfo.epoch;
        del_requeue_request(req);
        break;
      }
      case (unsigned int)0x82:
      {
        if(sd_log_level == 7)
          log_write(7, "wakeup_requests_on_epoch", 228, "peer %lx", req->rq.$anon0.obj.oid);

        del_requeue_request(req);
      }
    }
    req = __n210;
    const struct list_node *wakeup_requests_on_epoch$$1$$1$$3$$__mptr = __n210->request_list.next;
    tmp_statement_expression$3 = (struct request *)((char *)wakeup_requests_on_epoch$$1$$1$$3$$__mptr - (signed long int)128ul);
  }
  list_splice_init(&pending_list, &sys->req_wait_queue);
}

// wakeup_requests_on_oid
// file request.c line 240
void wakeup_requests_on_oid(unsigned long int oid)
{
  struct request *req;
  struct list_head pending_list = { .n={ .next=&pending_list.n, .prev=&pending_list.n } };
  list_splice_init(&sys->req_wait_queue, &pending_list);
  struct request *__n247;
  struct request *tmp_statement_expression$1;
  const struct list_node *__mptr = (&pending_list)->n.next;
  tmp_statement_expression$1 = (struct request *)((char *)__mptr - (signed long int)128ul);
  req = tmp_statement_expression$1;
  struct request *tmp_statement_expression$2;
  const struct list_node *wakeup_requests_on_oid$$1$$1$$2$$__mptr = req->request_list.next;
  tmp_statement_expression$2 = (struct request *)((char *)wakeup_requests_on_oid$$1$$1$$2$$__mptr - (signed long int)128ul);
  __n247 = tmp_statement_expression$2;
  struct request *tmp_statement_expression$3;
  for( ; !(&req->request_list == &(&pending_list)->n); __n247 = tmp_statement_expression$3)
  {
    if(req->local_oid == oid)
    {
      if(sd_log_level == 7)
        log_write(7, "wakeup_requests_on_oid", 250, "retry %lx", req->local_oid);

      del_requeue_request(req);
    }

    req = __n247;
    const struct list_node *wakeup_requests_on_oid$$1$$1$$3$$__mptr = __n247->request_list.next;
    tmp_statement_expression$3 = (struct request *)((char *)wakeup_requests_on_oid$$1$$1$$3$$__mptr - (signed long int)128ul);
  }
  list_splice_init(&pending_list, &sys->req_wait_queue);
}

// was_cluster_shutdowned
// file sheep_priv.h line 354
_Bool was_cluster_shutdowned(void)
{
  return (_Bool)config.shutdown;
}

// work_queue_empty
// file work.c line 445
_Bool work_queue_empty(struct work_queue *q)
{
  struct wq_info *wi;
  struct wq_info *tmp_statement_expression$1;
  const struct work_queue *__mptr = q;
  tmp_statement_expression$1 = (struct wq_info *)((char *)__mptr - (signed long int)208ul);
  wi = tmp_statement_expression$1;
  volatile unsigned long int tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  return tmp_statement_expression$2 == (unsigned long int)0;
}

// worker_routine
// file work.c line 313
static void * worker_routine(void *arg)
{
  struct wq_info *wi = (struct wq_info *)arg;
  struct work *work;
  signed int tid;
  tid=gettid();
  set_thread_name(wi->name, (signed int)wi->tc != WQ_ORDERED);
  sd_mutex_lock$link4(&wi->startup_lock);
  sd_mutex_unlock$link4(&wi->startup_lock);
  trace_set_tid_map(tid);
  _Bool return_value_list_empty$3;
  struct work *tmp_statement_expression$4;
  while((_Bool)1)
  {
    sd_mutex_lock$link4(&wi->pending_lock);
    _Bool return_value_wq_need_shrink$2;
    return_value_wq_need_shrink$2=wq_need_shrink(wi);
    if(!(return_value_wq_need_shrink$2 == (_Bool)0))
    {
      wi->nr_threads = wi->nr_threads - 1ul;
      trace_clear_tid_map(tid);
      sd_mutex_unlock$link4(&wi->pending_lock);
      unsigned long int return_value_pthread_self$1;
      return_value_pthread_self$1=pthread_self();
      pthread_detach(return_value_pthread_self$1);
      if(sd_log_level == 7)
        log_write(7, "worker_routine", 336, "destroy thread %s %d, %zu", wi->name, tid, wi->nr_threads);

      break;
    }

    do
    {

    retest:
      ;
      return_value_list_empty$3=list_empty$link4(&wi->q.pending_list);
      if(return_value_list_empty$3 == (_Bool)0)
        break;

      sd_cond_wait$link1(&wi->pending_cond, &wi->pending_lock);
    }
    while((_Bool)1);
    const struct list_node *__mptr = (&wi->q.pending_list)->n.next;
    tmp_statement_expression$4 = (struct work *)((char *)__mptr - (signed long int)0ul);
    work = tmp_statement_expression$4;
    list_del$link3(&work->w_list);
    sd_mutex_unlock$link4(&wi->pending_lock);
    if(!(work->fn == ((void (*)(struct work *))NULL)))
      work->fn(work);

    sd_mutex_lock$link4(&wi->finished_lock);
    list_add_tail$link4(&work->w_list, &wi->finished_list);
    sd_mutex_unlock$link4(&wi->finished_lock);
    eventfd_xwrite(efd$link1, 1);
  }
  pthread_exit((void *)0);
}

// worker_thread_request_done
// file work.c line 287
static void worker_thread_request_done(signed int fd, signed int events, void *data)
{
  struct wq_info *wi;
  struct work *work;
  struct list_head list = { .n={ .next=&list.n, .prev=&list.n } };
  if(!(wq_get_nr_nodes == ((unsigned long int (*)(void))NULL)))
    nr_nodes=wq_get_nr_nodes();

  eventfd_xread(fd);
  struct wq_info *__n298;
  struct wq_info *tmp_statement_expression$1;
  const struct list_node *__mptr = (&wq_info_list)->n.next;
  tmp_statement_expression$1 = (struct wq_info *)((char *)__mptr - (signed long int)24ul);
  wi = tmp_statement_expression$1;
  struct wq_info *tmp_statement_expression$2;
  const struct list_node *worker_thread_request_done$$1$$1$$2$$__mptr = wi->list.next;
  tmp_statement_expression$2 = (struct wq_info *)((char *)worker_thread_request_done$$1$$1$$2$$__mptr - (signed long int)24ul);
  __n298 = tmp_statement_expression$2;
  struct work *tmp_statement_expression$5;
  struct wq_info *tmp_statement_expression$3;
  for( ; !(&wi->list == &(&wq_info_list)->n); __n298 = tmp_statement_expression$3)
  {
    sd_mutex_lock$link4(&wi->finished_lock);
    list_splice_init$link1(&wi->finished_list, &list);
    sd_mutex_unlock$link4(&wi->finished_lock);
    _Bool return_value_list_empty$4;
    return_value_list_empty$4=list_empty$link4(&list);
    if(return_value_list_empty$4 == (_Bool)0)
    {
      const struct list_node *worker_thread_request_done$$1$$1$$4$$1$$1$$__mptr = (&list)->n.next;
      tmp_statement_expression$5 = (struct work *)((char *)worker_thread_request_done$$1$$1$$4$$1$$1$$__mptr - (signed long int)0ul);
      work = tmp_statement_expression$5;
      list_del$link3(&work->w_list);
      work->done(work);
      __uatomic_dec$link2((void *)&wi->nr_queued_work, (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    wi = __n298;
    const struct list_node *worker_thread_request_done$$1$$1$$3$$__mptr = __n298->list.next;
    tmp_statement_expression$3 = (struct wq_info *)((char *)worker_thread_request_done$$1$$1$$3$$__mptr - (signed long int)24ul);
  }
}

// wq_get_roof
// file work.c line 202
static inline unsigned long int wq_get_roof(struct wq_info *wi)
{
  unsigned long int nr = (unsigned long int)1;
  switch((signed int)wi->tc)
  {
    case WQ_ORDERED:
      break;
    case WQ_DYNAMIC:
    {
      nr = nr_nodes * (unsigned long int)2;
      break;
    }
    case WQ_UNLIMITED:
    {
      nr = 18446744073709551615UL;
      break;
    }
    default:
    {
      log_write(0, "wq_get_roof", 217, "PANIC: Invalid threads control %d", wi->tc);
      abort();
    }
  }
  return nr;
}

// wq_need_grow
// file work.c line 222
static _Bool wq_need_grow(struct wq_info *wi)
{
  volatile unsigned long int tmp_statement_expression$3;
  asm("" :  :  : "memory");
  tmp_statement_expression$3 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  unsigned long int return_value_wq_get_roof$2;
  if(!(wi->nr_threads >= tmp_statement_expression$3))
  {
    return_value_wq_get_roof$2=wq_get_roof(wi);
    if(return_value_wq_get_roof$2 >= 2ul * wi->nr_threads)
    {
      unsigned long int return_value_get_msec_time$1;
      return_value_get_msec_time$1=get_msec_time();
      wi->tm_end_of_protection = return_value_get_msec_time$1 + (unsigned long int)1000;
      return (_Bool)1;
    }

  }

  return (_Bool)0;
}

// wq_need_shrink
// file work.c line 238
static _Bool wq_need_shrink(struct wq_info *wi)
{
  volatile unsigned long int tmp_statement_expression$2;
  asm("" :  :  : "memory");
  tmp_statement_expression$2 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  unsigned long int return_value_get_msec_time$1;
  if(!(tmp_statement_expression$2 >= wi->nr_threads / 2ul))
  {
    return_value_get_msec_time$1=get_msec_time();
    return wi->tm_end_of_protection <= return_value_get_msec_time$1;
  }

  else
  {
    unsigned long int return_value_get_msec_time$3;
    return_value_get_msec_time$3=get_msec_time();
    wi->tm_end_of_protection = return_value_get_msec_time$3 + (unsigned long int)1000;
    return (_Bool)0;
  }
}

// wq_trace_init
// file work.c line 188
static inline signed int wq_trace_init(void)
{
  return 0;
}

// write_cache_object
// file object_cache.c line 401
static signed int write_cache_object(struct object_cache_entry *entry, void *buf, unsigned long int count, signed long int offset, _Bool create, _Bool writeback)
{
  unsigned int vid = entry->oc->vid;
  unsigned long int idx;
  idx=entry_idx(entry);
  unsigned long int oid;
  oid=idx_to_oid(vid, idx);
  struct object_cache *oc = entry->oc;
  struct sd_req hdr;
  signed int ret;
  write_lock_entry(entry);
  ret=write_cache_object_noupdate(vid, idx, buf, count, offset);
  if(!(ret == 0x00))
  {
    unlock_entry(entry);
    return ret;
  }

  else
  {
    write_lock_cache(oc);
    if(!(writeback == (_Bool)0))
    {
      unsigned long int return_value_calc_object_bmap$1;
      return_value_calc_object_bmap$1=calc_object_bmap(oid, count, offset);
      entry->bmap = entry->bmap | return_value_calc_object_bmap$1;
      _Bool return_value_list_linked$2;
      return_value_list_linked$2=list_linked(&entry->dirty_list);
      if(return_value_list_linked$2 == (_Bool)0)
        add_to_dirty_list(entry);

    }

    list_move_tail(&entry->lru_list, &oc->lru_head);
    unlock_cache(oc);
    unlock_entry(entry);
    if(writeback == (_Bool)0)
    {
      if(!(create == (_Bool)0))
        sd_init_req$link5(&hdr, (unsigned char)0x01);

      else
        sd_init_req$link5(&hdr, (unsigned char)0x03);
      hdr.flags = (unsigned short int)0x01;
      hdr.data_length = (unsigned int)count;
      hdr.$anon0.obj.oid = oid;
      hdr.$anon0.obj.offset = (unsigned int)offset;
      ret=exec_local_req(&hdr, buf);
      if(!(ret == 0x00))
      {
        const char *return_value_sd_strerror$3;
        return_value_sd_strerror$3=sd_strerror$link6(ret);
        log_write(3, "write_cache_object", 446, "failed to write object %lx, %s", oid, return_value_sd_strerror$3);
        return ret;
      }

    }


  out:
    ;
    return ret;
  }
}

// write_cache_object_noupdate
// file object_cache.c line 347
static signed int write_cache_object_noupdate(unsigned int vid, unsigned long int idx, void *buf, unsigned long int count, signed long int offset)
{
  unsigned long int size;
  signed int fd;
  signed int flags = def_open_flags;
  signed int ret = 0x00;
  char p[4096l];
  snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%06x/%016lx", (const void *)object_cache_dir, vid, idx);
  _Bool return_value_idx_has_vdi_bit$1;
  if(!(sys->object_cache_directio == (_Bool)0))
  {
    return_value_idx_has_vdi_bit$1=idx_has_vdi_bit(idx);
    if(return_value_idx_has_vdi_bit$1 == (_Bool)0)
      flags = flags | 040000;

  }

  fd=open(p, flags, sd_def_fmode);
  signed long int return_value_xpwrite$2;
  if(!(fd >= 0))
  {
    log_write(3, "write_cache_object_noupdate", 363, "%m");
    ret = 0x03;
  }

  else
  {
    return_value_xpwrite$2=xpwrite(fd, buf, count, offset);
    size = (unsigned long int)return_value_xpwrite$2;
    if(!(size == count))
    {
      log_write(3, "write_cache_object_noupdate", 372, "size %zu, count:%zu, offset %jd %m", size, count, (signed long int)offset);
      ret = 0x03;
    }


  out_close:
    ;
    close(fd);
  }

out:
  ;
  return ret;
}

// write_config
// file config.c line 33
static signed int write_config(void)
{
  signed int ret;
  ret=atomic_create_and_write(config_path, (char *)&config, sizeof(struct sheepdog_config) /*40ul*/ , (_Bool)1);
  if(!(ret >= 0))
  {
    log_write(3, "write_config", 40, "atomic_create_and_write() failed");
    return 0x03;
  }

  else
    return 0x00;
}

// write_lock_cache
// file object_cache.c line 183
static inline void write_lock_cache(struct object_cache *oc)
{
  sd_write_lock$link1(&oc->lock);
}

// write_lock_entry
// file object_cache.c line 198
static inline void write_lock_entry(struct object_cache_entry *entry)
{
  sd_write_lock$link1(&entry->lock);
}

// xcalloc
// file ../include/util.h line 94
void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *ret;
  ret=calloc(nmemb, size);
  if(ret == NULL && (nmemb == 0ul || size == 0ul))
    ret=calloc((unsigned long int)1, (unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(nmemb * size);
    ret=calloc(nmemb, size);
    if(ret == NULL && (nmemb == 0ul || size == 0ul))
      ret=calloc((unsigned long int)1, (unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xcalloc", 91, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xfallocate
// file ../include/util.h line 101
signed int xfallocate(signed int fd, signed int mode, signed long int offset, signed long int len)
{
  signed int ret;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    ret=fallocate(fd, mode, offset, len);
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 11)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
  }
  while(tmp_if_expr$4);
  return ret;
}

// xftruncate
// file ../include/util.h line 102
signed int xftruncate(signed int fd, signed long int length)
{
  signed int ret;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    ret=ftruncate(fd, length);
    if(!(ret >= 0))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 11)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
  }
  while(tmp_if_expr$4);
  return ret;
}

// xmalloc
// file ../include/util.h line 91
void * xmalloc(unsigned long int size)
{
  void *ret;
  ret=malloc(size);
  if(ret == NULL && size == 0ul)
    ret=malloc((unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(size);
    ret=malloc(size);
    if(ret == NULL && size == 0ul)
      ret=malloc((unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xmalloc", 54, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xmkdir
// file ../include/util.h line 100
signed int xmkdir(const char *pathname, unsigned int mode)
{
  signed int return_value_mkdir$4;
  return_value_mkdir$4=mkdir(pathname, mode);
  if(!(return_value_mkdir$4 >= 0))
  {
    struct stat st;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 17))
      return -1;

    signed int return_value_stat$2;
    return_value_stat$2=stat(pathname, &st);
    if(!(return_value_stat$2 >= 0))
      return -1;

    if(!((61440u & st.st_mode) == 16384u))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 17;
      return -1;
    }

  }

  return 0;
}

// xpread
// file ../include/util.h line 98
signed long int xpread(signed int fd, void *buf, unsigned long int count, signed long int offset)
{
  char *p = (char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int loaded;
    loaded=_pread(fd, (void *)p, count, offset);
    if(!(loaded >= 0l))
      return (signed long int)-1;

    if(loaded == 0l)
      return total;

    count = count - (unsigned long int)loaded;
    p = p + loaded;
    total = total + loaded;
    offset = offset + loaded;
  }
  return total;
}

// xpwrite
// file ../include/util.h line 99
signed long int xpwrite(signed int fd, const void *buf, unsigned long int count, signed long int offset)
{
  const char *p = (const char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int written;
    written=_pwrite(fd, (const void *)p, count, offset);
    if(!(written >= 0l))
      return (signed long int)-1;

    if(written == 0l)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 28;
      return (signed long int)-1;
    }

    count = count - (unsigned long int)written;
    p = p + written;
    total = total + written;
    offset = offset + written;
  }
  return total;
}

// xread
// file ../include/util.h line 96
signed long int xread(signed int fd, void *buf, unsigned long int count)
{
  char *p = (char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int loaded;
    loaded=_read(fd, (void *)p, count);
    if(!(loaded >= 0l))
      return (signed long int)-1;

    if(loaded == 0l)
      return total;

    count = count - (unsigned long int)loaded;
    p = p + loaded;
    total = total + loaded;
  }
  return total;
}

// xrealloc
// file ../include/util.h line 93
void * xrealloc(void *ptr, unsigned long int size)
{
  void *ret;
  ret=realloc(ptr, size);
  if(ret == NULL && size == 0ul)
    ret=realloc(ptr, (unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(size);
    ret=realloc(ptr, size);
    if(ret == NULL && size == 0ul)
      ret=realloc(ptr, (unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xrealloc", 75, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xvalloc
// file ../include/util.h line 95
void * xvalloc(unsigned long int size)
{
  void *ret;
  ret=valloc(size);
  if(ret == NULL)
  {
    log_write(0, "xvalloc", 101, "PANIC: Out of memory");
    abort();
  }

  memset(ret, 0, size);
  return ret;
}

// xwrite
// file ../include/util.h line 97
signed long int xwrite(signed int fd, const void *buf, unsigned long int count)
{
  const char *p = (const char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int written;
    written=_write(fd, (const void *)p, count);
    if(!(written >= 0l))
      return (signed long int)-1;

    if(written == 0l)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 28;
      return (signed long int)-1;
    }

    count = count - (unsigned long int)written;
    p = p + written;
    total = total + written;
  }
  return total;
}

// xzalloc
// file ../include/util.h line 92
void * xzalloc(unsigned long int size)
{
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc((unsigned long int)1, size);
  return return_value_xcalloc$1;
}

// zalloc
// file ../include/util.h line 69
static inline void * zalloc(unsigned long int size)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, size);
  return return_value_calloc$1;
}

