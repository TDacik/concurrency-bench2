// #anon_enum_t_int=0_t_list=1_t_sep=2_t_func=3
// file wavemon.h line 159
enum anonymous_24 { t_int=0, t_list=1, t_sep=2, t_func=3 };

// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_21;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_19;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_10;

// tag-#anon#ST[S32'quot'||S32'rem'|]
// file /usr/include/stdlib.h line 97
struct anonymous_12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_15;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_18;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_17;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_23;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_16;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_20;

// tag-#anon#ST[U16'encoding'||U16'parity'|]
// file /usr/include/linux/hdlc/ioctl.h line 52
struct anonymous_0;

// tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'|]
// file /usr/include/linux/hdlc/ioctl.h line 39
struct anonymous_5;

// tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'||U32'slot_map'|]
// file /usr/include/linux/hdlc/ioctl.h line 45
struct anonymous_6;

// tag-#anon#ST[U32'dlci'|]
// file /usr/include/linux/hdlc/ioctl.h line 67
struct anonymous_3;

// tag-#anon#ST[U32'dlci'||ARR16{S8}_S8_'master'|]
// file /usr/include/linux/hdlc/ioctl.h line 71
struct anonymous_4;

// tag-#anon#ST[U32'interval'||U32'timeout'|]
// file /usr/include/linux/hdlc/ioctl.h line 76
struct anonymous_1;

// tag-#anon#ST[U32't391'||U32't392'||U32'n391'||U32'n392'||U32'n393'||U16'lmi'||U16'dce'|]
// file /usr/include/linux/hdlc/ioctl.h line 57
struct anonymous_2;

// tag-#anon#ST[U64'n'||S8'eol'||U56'_pad0'|]
// file llist.c line 50
struct anonymous_26;

// tag-#anon#UN[*{S32}_S32_'i'||*{V(...)->V}_V(...)->V_'fp'|]
// file wavemon.h line 166
union anonymous_25;

// tag-#anon#UN[*{SYM#tag-#anon#ST[U16'encoding'||U16'parity'|]#}_SYM#tag-#anon#ST[U16'encoding'||U16'parity'|]#_'raw_hdlc'||*{SYM#tag-#anon#ST[U32'interval'||U32'timeout'|]#}_SYM#tag-#anon#ST[U32'interval'||U32'timeout'|]#_'cisco'||*{SYM#tag-#anon#ST[U32't391'||U32't392'||U32'n391'||U32'n392'||U32'n393'||U16'lmi'||U16'dce'|]#}_SYM#tag-#anon#ST[U32't391'||U32't392'||U32'n391'||U32'n392'||U32'n393'||U16'lmi'||U16'dce'|]#_'fr'||*{SYM#tag-#anon#ST[U32'dlci'|]#}_SYM#tag-#anon#ST[U32'dlci'|]#_'fr_pvc'||*{SYM#tag-#anon#ST[U32'dlci'||ARR16{S8}_S8_'master'|]#}_SYM#tag-#anon#ST[U32'dlci'||ARR16{S8}_S8_'master'|]#_'fr_pvc_info'||*{SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'|]#}_SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'|]#_'sync'||*{SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'||U32'slot_map'|]#}_SYM#tag-#anon#ST[U32'clock_rate'||U32'clock_type'||U16'loopback'||U16'_pad0'||U32'slot_map'|]#_'te1'|]
// file /usr/include/linux/if.h line 182
union anonymous_7;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_9;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/linux/if.h line 205
union anonymous;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_22;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_14;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_13;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{V}_V_'ifru_data'||SYM#tag-if_settings#'ifru_settings'|]
// file /usr/include/linux/if.h line 210
union anonymous_8;

// tag-#anon#cST[c*{cS8}_cS8_'key_name'||*{V()->V}_V()->V_'init'||*{S32(*{SYM#tag-_win_st#}_SYM#tag-_win_st#_)->S32}_S32(*{SYM#tag-_win_st#}_SYM#tag-_win_st#_)->S32_'loop'||*{V()->V}_V()->V_'fini'|]
// file wavemon.c line 33
struct anonymous_11;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_win_st
// file /usr/include/curses.h line 365
struct _win_st;

// tag-assorted_numbers
// file iw_if.h line 282
struct assorted_numbers;

// tag-chain
// file llist.c line 42
struct chain;

// tag-cmd
// file iw_nl80211.h line 45
struct cmd;

// tag-cnt
// file iw_if.h line 259
struct cnt;

// tag-colour_pair
// file wavemon.h line 243
enum colour_pair { CP_STANDARD=1, CP_SCALEHI=2, CP_SCALEMID=3, CP_SCALELOW=4, CP_WTITLE=5, CP_INACTIVE=6, CP_ACTIVE=7, CP_STATSIG=8, CP_STATNOISE=9, CP_STATSNR=10, CP_STATBKG=11, CP_STATSIG_S=12, CP_STATNOISE_S=13, CP_PREF_NORMAL=14, CP_PREF_SELECT=15, CP_PREF_ARROW=16, CP_SCAN_CRYPT=17, CP_SCAN_UNENC=18, CP_SCAN_NON_AP=19 };

// tag-conf_item
// file wavemon.h line 155
struct conf_item;

// tag-ether_addr
// file /usr/include/net/ethernet.h line 32
struct ether_addr;

// tag-genlmsghdr
// file /usr/include/linux/genetlink.h line 12
struct genlmsghdr;

// tag-handler_args
// file iw_nl80211.c line 615
struct handler_args;

// tag-if_info
// file iw_if.h line 68
struct if_info;

// tag-if_settings
// file /usr/include/linux/if.h line 179
struct if_settings;

// tag-if_stat
// file iw_if.h line 187
struct if_stat;

// tag-ifmap
// file /usr/include/linux/if.h line 169
struct ifmap;

// tag-ifreq
// file /usr/include/linux/if.h line 203
struct ifreq;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-itimerval
// file /usr/include/x86_64-linux-gnu/sys/time.h line 107
struct itimerval;

// tag-iw_dyn_info
// file iw_if.h line 120
struct iw_dyn_info;

// tag-iw_extrema
// file lhist_scr.c line 45
struct iw_extrema;

// tag-iw_freq
// file /usr/include/linux/wireless.h line 701
struct iw_freq;

// tag-iw_key
// file iw_if.h line 87
struct iw_key;

// tag-iw_levelstat
// file iw_if.h line 199
struct iw_levelstat;

// tag-iw_nl80211_ifstat
// file iw_nl80211.h line 70
struct iw_nl80211_ifstat;

// tag-iw_nl80211_linkstat
// file iw_nl80211.h line 144
struct iw_nl80211_linkstat;

// tag-iw_nl80211_reg
// file iw_nl80211.h line 202
struct iw_nl80211_reg;

// tag-iw_nl80211_survey
// file iw_nl80211.h line 98
struct iw_nl80211_survey;

// tag-iw_param
// file /usr/include/linux/wireless.h line 673
struct iw_param;

// tag-iw_point
// file /usr/include/linux/wireless.h line 685
struct iw_point;

// tag-iw_quality
// file /usr/include/linux/wireless.h line 712
struct iw_quality;

// tag-iw_range
// file /usr/include/linux/wireless.h line 968
struct iw_range;

// tag-iwreq
// file /usr/include/linux/wireless.h line 947
struct iwreq;

// tag-iwreq_data
// file /usr/include/linux/wireless.h line 909
union iwreq_data;

// tag-ldat
// file /usr/include/curses.h line 412
struct ldat;

// tag-msg_attribute
// file iw_nl80211.h line 29
struct msg_attribute;

// tag-nl80211_chan_width
// file nl80211.h line 3301
enum nl80211_chan_width { NL80211_CHAN_WIDTH_20_NOHT=0, NL80211_CHAN_WIDTH_20=1, NL80211_CHAN_WIDTH_40=2, NL80211_CHAN_WIDTH_80=3, NL80211_CHAN_WIDTH_80P80=4, NL80211_CHAN_WIDTH_160=5, NL80211_CHAN_WIDTH_5=6, NL80211_CHAN_WIDTH_10=7 };

// tag-nl80211_channel_type
// file nl80211.h line 3275
enum nl80211_channel_type { NL80211_CHAN_NO_HT=0, NL80211_CHAN_HT20=1, NL80211_CHAN_HT40MINUS=2, NL80211_CHAN_HT40PLUS=3 };

// tag-nl80211_commands
// file nl80211.h line 817
enum nl80211_commands { NL80211_CMD_UNSPEC=0, NL80211_CMD_GET_WIPHY=1, NL80211_CMD_SET_WIPHY=2, NL80211_CMD_NEW_WIPHY=3, NL80211_CMD_DEL_WIPHY=4, NL80211_CMD_GET_INTERFACE=5, NL80211_CMD_SET_INTERFACE=6, NL80211_CMD_NEW_INTERFACE=7, NL80211_CMD_DEL_INTERFACE=8, NL80211_CMD_GET_KEY=9, NL80211_CMD_SET_KEY=10, NL80211_CMD_NEW_KEY=11, NL80211_CMD_DEL_KEY=12, NL80211_CMD_GET_BEACON=13, NL80211_CMD_SET_BEACON=14, NL80211_CMD_START_AP=15, NL80211_CMD_NEW_BEACON=15, NL80211_CMD_STOP_AP=16, NL80211_CMD_DEL_BEACON=16, NL80211_CMD_GET_STATION=17, NL80211_CMD_SET_STATION=18, NL80211_CMD_NEW_STATION=19, NL80211_CMD_DEL_STATION=20, NL80211_CMD_GET_MPATH=21, NL80211_CMD_SET_MPATH=22, NL80211_CMD_NEW_MPATH=23, NL80211_CMD_DEL_MPATH=24, NL80211_CMD_SET_BSS=25, NL80211_CMD_SET_REG=26, NL80211_CMD_REQ_SET_REG=27, NL80211_CMD_GET_MESH_CONFIG=28, NL80211_CMD_SET_MESH_CONFIG=29, NL80211_CMD_SET_MGMT_EXTRA_IE=30, NL80211_CMD_GET_REG=31, NL80211_CMD_GET_SCAN=32, NL80211_CMD_TRIGGER_SCAN=33, NL80211_CMD_NEW_SCAN_RESULTS=34, NL80211_CMD_SCAN_ABORTED=35, NL80211_CMD_REG_CHANGE=36, NL80211_CMD_AUTHENTICATE=37, NL80211_CMD_ASSOCIATE=38, NL80211_CMD_DEAUTHENTICATE=39, NL80211_CMD_DISASSOCIATE=40, NL80211_CMD_MICHAEL_MIC_FAILURE=41, NL80211_CMD_REG_BEACON_HINT=42, NL80211_CMD_JOIN_IBSS=43, NL80211_CMD_LEAVE_IBSS=44, NL80211_CMD_TESTMODE=45, NL80211_CMD_CONNECT=46, NL80211_CMD_ROAM=47, NL80211_CMD_DISCONNECT=48, NL80211_CMD_SET_WIPHY_NETNS=49, NL80211_CMD_GET_SURVEY=50, NL80211_CMD_NEW_SURVEY_RESULTS=51, NL80211_CMD_SET_PMKSA=52, NL80211_CMD_DEL_PMKSA=53, NL80211_CMD_FLUSH_PMKSA=54, NL80211_CMD_REMAIN_ON_CHANNEL=55, NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL=56, NL80211_CMD_SET_TX_BITRATE_MASK=57, NL80211_CMD_REGISTER_FRAME=58, NL80211_CMD_REGISTER_ACTION=58, NL80211_CMD_FRAME=59, NL80211_CMD_ACTION=59, NL80211_CMD_FRAME_TX_STATUS=60, NL80211_CMD_ACTION_TX_STATUS=60, NL80211_CMD_SET_POWER_SAVE=61, NL80211_CMD_GET_POWER_SAVE=62, NL80211_CMD_SET_CQM=63, NL80211_CMD_NOTIFY_CQM=64, NL80211_CMD_SET_CHANNEL=65, NL80211_CMD_SET_WDS_PEER=66, NL80211_CMD_FRAME_WAIT_CANCEL=67, NL80211_CMD_JOIN_MESH=68, NL80211_CMD_LEAVE_MESH=69, NL80211_CMD_UNPROT_DEAUTHENTICATE=70, NL80211_CMD_UNPROT_DISASSOCIATE=71, NL80211_CMD_NEW_PEER_CANDIDATE=72, NL80211_CMD_GET_WOWLAN=73, NL80211_CMD_SET_WOWLAN=74, NL80211_CMD_START_SCHED_SCAN=75, NL80211_CMD_STOP_SCHED_SCAN=76, NL80211_CMD_SCHED_SCAN_RESULTS=77, NL80211_CMD_SCHED_SCAN_STOPPED=78, NL80211_CMD_SET_REKEY_OFFLOAD=79, NL80211_CMD_PMKSA_CANDIDATE=80, NL80211_CMD_TDLS_OPER=81, NL80211_CMD_TDLS_MGMT=82, NL80211_CMD_UNEXPECTED_FRAME=83, NL80211_CMD_PROBE_CLIENT=84, NL80211_CMD_REGISTER_BEACONS=85, NL80211_CMD_UNEXPECTED_4ADDR_FRAME=86, NL80211_CMD_SET_NOACK_MAP=87, NL80211_CMD_CH_SWITCH_NOTIFY=88, NL80211_CMD_START_P2P_DEVICE=89, NL80211_CMD_STOP_P2P_DEVICE=90, NL80211_CMD_CONN_FAILED=91, NL80211_CMD_SET_MCAST_RATE=92, NL80211_CMD_SET_MAC_ACL=93, NL80211_CMD_RADAR_DETECT=94, NL80211_CMD_GET_PROTOCOL_FEATURES=95, NL80211_CMD_UPDATE_FT_IES=96, NL80211_CMD_FT_EVENT=97, NL80211_CMD_CRIT_PROTOCOL_START=98, NL80211_CMD_CRIT_PROTOCOL_STOP=99, NL80211_CMD_GET_COALESCE=100, NL80211_CMD_SET_COALESCE=101, NL80211_CMD_CHANNEL_SWITCH=102, NL80211_CMD_VENDOR=103, NL80211_CMD_SET_QOS_MAP=104, NL80211_CMD_ADD_TX_TS=105, NL80211_CMD_DEL_TX_TS=106, NL80211_CMD_GET_MPP=107, NL80211_CMD_JOIN_OCB=108, NL80211_CMD_LEAVE_OCB=109, NL80211_CMD_CH_SWITCH_STARTED_NOTIFY=110, NL80211_CMD_TDLS_CHANNEL_SWITCH=111, NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH=112, NL80211_CMD_WIPHY_REG_CHANGE=113, __NL80211_CMD_AFTER_LAST=114, NL80211_CMD_MAX=113 };

// tag-nl80211_dfs_regions
// file nl80211.h line 2874
enum nl80211_dfs_regions { NL80211_DFS_UNSET=0, NL80211_DFS_FCC=1, NL80211_DFS_ETSI=2, NL80211_DFS_JP=3 };

// tag-nl80211_iftype
// file nl80211.h line 2218
enum nl80211_iftype { NL80211_IFTYPE_UNSPECIFIED=0, NL80211_IFTYPE_ADHOC=1, NL80211_IFTYPE_STATION=2, NL80211_IFTYPE_AP=3, NL80211_IFTYPE_AP_VLAN=4, NL80211_IFTYPE_WDS=5, NL80211_IFTYPE_MONITOR=6, NL80211_IFTYPE_MESH_POINT=7, NL80211_IFTYPE_P2P_CLIENT=8, NL80211_IFTYPE_P2P_GO=9, NL80211_IFTYPE_P2P_DEVICE=10, NL80211_IFTYPE_OCB=11, NUM_NL80211_IFTYPES=12, NL80211_IFTYPE_MAX=11 };

// tag-nl80211_sta_flag_update
// file nl80211.h line 2285
struct nl80211_sta_flag_update;

// tag-nl_cb
// file /usr/include/libnl3/netlink/handlers.h line 25
struct nl_cb;

// tag-nl_cb_kind
// file /usr/include/libnl3/netlink/handlers.h line 72
enum nl_cb_kind { NL_CB_DEFAULT=0, NL_CB_VERBOSE=1, NL_CB_DEBUG=2, NL_CB_CUSTOM=3, __NL_CB_KIND_MAX=4 };

// tag-nl_cb_type
// file /usr/include/libnl3/netlink/handlers.h line 90
enum nl_cb_type { NL_CB_VALID=0, NL_CB_FINISH=1, NL_CB_OVERRUN=2, NL_CB_SKIPPED=3, NL_CB_ACK=4, NL_CB_MSG_IN=5, NL_CB_MSG_OUT=6, NL_CB_INVALID=7, NL_CB_SEQ_CHECK=8, NL_CB_SEND_ACK=9, NL_CB_DUMP_INTR=10, __NL_CB_TYPE_MAX=11 };

// tag-nl_msg
// file /usr/include/libnl3/netlink/handlers.h line 27
struct nl_msg;

// tag-nl_sock
// file /usr/include/libnl3/netlink/handlers.h line 26
struct nl_sock;

// tag-nla_policy
// file /usr/include/libnl3/netlink/attr.h line 67
struct nla_policy;

// tag-nlattr
// file /usr/include/linux/netlink.h line 164
struct nlattr;

// tag-nlmsgerr
// file /usr/include/linux/netlink.h line 99
struct nlmsgerr;

// tag-nlmsghdr
// file /usr/include/linux/netlink.h line 42
struct nlmsghdr;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pdat
// file /usr/include/curses.h line 452
struct pdat;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-scan_entry
// file iw_if.h line 234
struct scan_entry;

// tag-scan_result
// file iw_if.h line 277
struct scan_result;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_nl
// file /usr/include/linux/netlink.h line 35
struct sockaddr_nl;

// tag-threshold_action
// file wavemon.h line 90
enum threshold_action { TA_DISABLED=0, TA_BEEP=1, TA_FLASH=2, TA_BEEP_FLASH=3 };

// tag-time_data_in_milliseconds
// file iw_nl80211.h line 102
struct time_data_in_milliseconds;

// tag-timer
// file wavemon.h line 289
struct timer;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-wait_event
// file iw_nl80211.h line 219
struct wait_event;

// tag-wavemon_conf
// file wavemon.h line 121
struct wavemon_conf;

// tag-wavemon_screen
// file wavemon.h line 184
enum wavemon_screen { SCR_INFO=0, SCR_LHIST=1, SCR_SCAN=2, SCR_EMPTY_F4=3, SCR_EMPTY_F5=4, SCR_EMPTY_F6=5, SCR_PREFS=6, SCR_HELP=7, SCR_ABOUT=8, SCR_QUIT=9 };

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __sigsetjmp
// file /usr/include/setjmp.h line 59
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// ack_handler
// file iw_nl80211.h line 261
static inline signed int ack_handler(struct nl_msg *msg, void *arg);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// alloc_nl_mcast_sk
// file iw_nl80211.c line 710
extern struct nl_sock * alloc_nl_mcast_sk(const char *grp);
// arg2element
// file llist.c line 58
static struct chain * arg2element(char type, void ***ap, struct chain *next);
// argv_count
// file wavemon.h line 319
static inline unsigned long int argv_count(char **argv);
// argv_count_link1
// file wavemon.h line 319
static inline unsigned long int argv_count_link1(char **argv_link1);
// argv_find
// file wavemon.h line 329
static inline signed int argv_find(char **argv, const char *what);
// beep
// file /usr/include/curses.h line 588
extern signed int beep(void);
// bit_count
// file utils.c line 71
unsigned char bit_count(unsigned int mask);
// byte_units
// file wavemon.h line 379
static inline char * byte_units(const double bytes);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// cbreak
// file /usr/include/curses.h line 594
extern signed int cbreak(void);
// change_item
// file conf_scr.c line 93
static void change_item(signed int inum, char sign);
// channel_type_name
// file utils.c line 205
const char * channel_type_name(enum nl80211_channel_type channel_type);
// channel_width_name
// file utils.c line 184
const char * channel_width_name(enum nl80211_chan_width width);
// check_geometry
// file wavemon.c line 133
static void check_geometry(void);
// clamp
// file wavemon.h line 373
static inline signed int clamp(signed int val, signed int min, signed int max);
// clamp_link1
// file wavemon.h line 373
static inline signed int clamp_link1(signed int val_link1, signed int min_link1, signed int max_link1);
// clear_scan_list
// file iw_scan.c line 304
static void clear_scan_list(struct scan_result *sr);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// cmp_chan
// file iw_scan.c line 52
static _Bool cmp_chan(struct scan_entry *a, struct scan_entry *b);
// cmp_chan_sig
// file iw_scan.c line 58
static _Bool cmp_chan_sig(struct scan_entry *a, struct scan_entry *b);
// cmp_cnt
// file iw_scan.c line 331
static signed int cmp_cnt(const void *a, const void *b);
// cmp_essid
// file iw_scan.c line 37
static _Bool cmp_essid(struct scan_entry *a, struct scan_entry *b);
// cmp_freq
// file iw_scan.c line 23
static _Bool cmp_freq(struct scan_entry *a, struct scan_entry *b);
// cmp_key
// file iw_scan.c line 325
static signed int cmp_key(const void *a, const void *b);
// cmp_mac
// file iw_scan.c line 46
static _Bool cmp_mac(struct scan_entry *a, struct scan_entry *b);
// cmp_open
// file iw_scan.c line 64
static _Bool cmp_open(struct scan_entry *a, struct scan_entry *b);
// cmp_open_sig
// file iw_scan.c line 70
static _Bool cmp_open_sig(struct scan_entry *a, struct scan_entry *b);
// cmp_sig
// file iw_scan.c line 29
static _Bool cmp_sig(struct scan_entry *a, struct scan_entry *b);
// compute_channel_stats
// file iw_scan.c line 341
static void compute_channel_stats(struct scan_result *sr);
// conf_get_interface_list
// file wavemon.h line 283
extern void conf_get_interface_list(void);
// conf_ifname
// file wavemon.h line 282
extern const char * conf_ifname(void);
// cp_from_scale
// file wavemon.h line 265
static inline signed int cp_from_scale(float value, const signed char *cscale, _Bool reverse);
// curs_set
// file /usr/include/curses.h line 604
extern signed int curs_set(signed int);
// curses_version
// file /usr/include/curses.h line 896
extern const char * curses_version(void);
// curtail
// file ui.c line 81
extern const char * curtail(const char *str, const char *sep, signed int len);
// dbm2mw
// file utils.c line 138
double dbm2mw(const double in);
// dbm2units
// file utils.c line 143
char * dbm2units(const double in);
// dbm_to_u8
// file utils.c line 132
unsigned char dbm_to_u8(const signed int dbm);
// delwin
// file /usr/include/curses.h line 610
extern signed int delwin(struct _win_st *);
// dfs_domain_name
// file utils.c line 247
const char * dfs_domain_name(enum nl80211_dfs_regions region);
// display_aplist
// file scan_scr.c line 91
static void display_aplist(struct _win_st *w_aplst);
// display_info
// file info_scr.c line 238
static void display_info(struct _win_st *w_if, struct _win_st *w_info);
// display_key
// file lhist_scr.c line 291
static void display_key(struct _win_st *w_key);
// display_levels
// file info_scr.c line 50
static void display_levels(void);
// display_lhist
// file lhist_scr.c line 224
static void display_lhist(void);
// display_netinfo
// file info_scr.c line 580
static void display_netinfo(struct _win_st *w_net);
// display_stats
// file info_scr.c line 162
static void display_stats(void);
// div
// file /usr/include/stdlib.h line 788
extern struct anonymous_12 div(signed int, signed int);
// do_scan
// file iw_if.h line 296
extern void * do_scan(void *sr_ptr);
// dyn_info_active_keys
// file iw_if.h line 158
static inline unsigned char dyn_info_active_keys(struct iw_dyn_info *info);
// dyn_info_cleanup
// file iw_if.h line 181
extern void dyn_info_cleanup(struct iw_dyn_info *info);
// dyn_info_get
// file iw_if.h line 179
extern void dyn_info_get(struct iw_dyn_info *info, const char *ifname, struct iw_range *ir);
// dyn_info_wep_keys
// file iw_if.h line 169
static inline unsigned char dyn_info_wep_keys(struct iw_dyn_info *info);
// end_timer
// file timer.c line 38
extern _Bool end_timer(struct timer *t);
// endwin
// file /usr/include/curses.h line 618
extern signed int endwin(void);
// err_msg
// file error.c line 52
extern void err_msg(const char *format, ...);
// err_quit
// file wavemon.h line 302
extern void err_quit(const char *format, ...);
// err_sys
// file wavemon.h line 303
extern void err_sys(const char *format, ...);
// error_handler
// file iw_nl80211.h line 246
static inline signed int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err, void *arg);
// errx
// file /usr/include/err.h line 50
extern void errx(signed int, const char *, ...);
// ether_addr
// file utils.c line 26
char * ether_addr(struct ether_addr *ea);
// ether_addr_is_zero
// file utils.c line 18
_Bool ether_addr_is_zero(struct ether_addr *ea);
// ether_lookup
// file utils.c line 40
char * ether_lookup(struct ether_addr *ea);
// ether_ntoa
// file /usr/include/netinet/ether.h line 30
extern char * ether_ntoa(struct ether_addr *);
// ether_ntohost
// file /usr/include/netinet/ether.h line 40
extern signed int ether_ntohost(char *, struct ether_addr *);
// ewma
// file wavemon.h line 401
static inline double ewma(double mavg, double sample, double weight);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// family_handler
// file iw_nl80211.c line 621
static signed int family_handler(struct nl_msg *msg, void *arg);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// finish_handler
// file iw_nl80211.h line 254
static inline signed int finish_handler(struct nl_msg *msg, void *arg);
// flash
// file /usr/include/curses.h line 621
extern signed int flash(void);
// fmt_extrema
// file lhist_scr.c line 68
static char * fmt_extrema(struct iw_extrema *ie, const char *unit);
// fmt_scan_entry
// file scan_scr.c line 35
static void fmt_scan_entry(struct scan_entry *cur, char *buf, unsigned long int buflen);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// format_bssid
// file utils.c line 58
char * format_bssid(struct sockaddr *ap);
// format_enc_capab
// file iw_if.h line 461
static inline const char * format_enc_capab(const unsigned int capa, const char *sep);
// format_key
// file iw_if.h line 429
static inline char * format_key(struct iw_key * const iwk);
// format_power
// file iw_if.h line 341
static inline char * format_power(struct iw_param *pwr, struct iw_range *range);
// format_retry
// file iw_if.h line 485
static inline char * format_retry(struct iw_param *retry, struct iw_range *range);
// format_txpower
// file iw_if.h line 325
static inline char * format_txpower(struct iw_param *txpwr);
// format_wpa
// file iw_if.h line 480
static inline const char * format_wpa(struct iw_range *ir);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_scan_list
// file iw_scan.c line 296
static void free_scan_list(struct scan_entry *head);
// freq_to_hz
// file iw_if.h line 397
static inline float freq_to_hz(struct iw_freq *freq);
// genl_connect
// file /usr/include/libnl3/netlink/genl/genl.h line 23
extern signed int genl_connect(struct nl_sock *);
// genl_ctrl_resolve
// file /usr/include/libnl3/netlink/genl/ctrl.h line 30
extern signed int genl_ctrl_resolve(struct nl_sock *, const char *);
// genlmsg_attrdata
// file /usr/include/libnl3/netlink/genl/genl.h line 43
extern struct nlattr * genlmsg_attrdata(struct genlmsghdr *, signed int);
// genlmsg_attrlen
// file /usr/include/libnl3/netlink/genl/genl.h line 44
extern signed int genlmsg_attrlen(struct genlmsghdr *, signed int);
// genlmsg_put
// file /usr/include/libnl3/netlink/genl/genl.h line 27
extern void * genlmsg_put(struct nl_msg *, unsigned int, unsigned int, signed int, signed int, signed int, unsigned char, unsigned char);
// get_confname
// file conf.c line 115
static char * get_confname(void);
// get_usecs
// file timer.c line 22
static unsigned long int get_usecs(void);
// getconf
// file wavemon.h line 152
extern void getconf(signed int argc, char **argv);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// handle_cmd
// file iw_nl80211.c line 18
extern signed int handle_cmd(struct cmd *cmd);
// has_net_admin_capability
// file error.c line 42
extern _Bool has_net_admin_capability(void);
// hist_level
// file lhist_scr.c line 172
static double hist_level(double val, signed int min, signed int max);
// hist_level_inverse
// file lhist_scr.c line 177
static double hist_level_inverse(signed int y_level, signed int min, signed int max);
// hist_plot
// file lhist_scr.c line 195
static void hist_plot(double yval, signed int xval, enum colour_pair plot_colour);
// hist_x
// file lhist_scr.c line 189
static signed int hist_x(signed int xval);
// hist_y
// file lhist_scr.c line 183
static signed int hist_y(signed int yval);
// ieee80211_frequency_to_channel
// file utils.c line 167
signed int ieee80211_frequency_to_channel(signed int freq);
// if_get_flags
// file iw_if.c line 30
static signed int if_get_flags(signed int skfd, const char *ifname);
// if_getinf
// file iw_if.h line 79
extern void if_getinf(const char *ifname, struct if_info *info);
// if_getstat
// file iw_if.h line 194
extern void if_getstat(const char *ifname, struct if_stat *stat);
// if_is_up
// file iw_if.h line 77
extern _Bool if_is_up(const char *ifname);
// if_nametoindex
// file /usr/include/net/if.h line 193
extern unsigned int if_nametoindex(const char *);
// if_set_up
// file iw_if.h line 78
extern signed int if_set_up(const char *ifname);
// iface_handler
// file iw_nl80211.c line 182
static signed int iface_handler(struct nl_msg *msg, void *arg);
// iftype_name
// file utils.c line 222
const char * iftype_name(enum nl80211_iftype iftype);
// in_range
// file wavemon.h line 368
static inline _Bool in_range(signed int val, signed int min, signed int max);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// init_conf_items
// file conf.c line 305
static void init_conf_items(void);
// init_extrema
// file lhist_scr.c line 51
static void init_extrema(struct iw_extrema *ie);
// init_menubar
// file wavemon.c line 103
static struct _win_st * init_menubar(const enum wavemon_screen active);
// init_pair
// file /usr/include/curses.h line 641
extern signed int init_pair(signed short int, signed short int, signed short int);
// initscr
// file /usr/include/curses.h line 639
extern struct _win_st * initscr(void);
// interpolate
// file ui.c line 113
static double interpolate(const double val, const double min, const double max);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// iw_cache_get
// file lhist_scr.c line 112
static struct iw_levelstat iw_cache_get(const unsigned int index);
// iw_cache_insert
// file lhist_scr.c line 100
static void iw_cache_insert(struct iw_levelstat new);
// iw_cache_update
// file iw_nl80211.h line 189
extern void iw_cache_update(struct iw_nl80211_linkstat *ls);
// iw_get_interface_list
// file wavemon.h line 284
extern void iw_get_interface_list(char **if_list, unsigned long int max_entries);
// iw_getinf_range
// file iw_if.h line 206
extern void iw_getinf_range(const char *ifname, struct iw_range *range);
// iw_nl80211_get_linkstat
// file iw_nl80211.c line 529
extern void iw_nl80211_get_linkstat(struct iw_nl80211_linkstat *ls);
// iw_nl80211_get_scan_data
// file iw_scan.c line 262
static signed int iw_nl80211_get_scan_data(struct scan_result *sr);
// iw_nl80211_get_survey
// file iw_nl80211.c line 594
extern void iw_nl80211_get_survey(struct iw_nl80211_survey *sd);
// iw_nl80211_getifstat
// file iw_nl80211.c line 581
extern void iw_nl80211_getifstat(struct iw_nl80211_ifstat *ifs);
// iw_nl80211_getreg
// file iw_nl80211.c line 568
extern void iw_nl80211_getreg(struct iw_nl80211_reg *ir);
// iw_nl80211_have_survey_data
// file iw_nl80211.h line 192
static inline _Bool iw_nl80211_have_survey_data(struct iw_nl80211_linkstat *ls);
// iw_nl80211_have_survey_data_link1
// file iw_nl80211.h line 192
static inline _Bool iw_nl80211_have_survey_data_link1(struct iw_nl80211_linkstat *ls_link1);
// iw_nl80211_scan_trigger
// file iw_scan.c line 253
static signed int iw_nl80211_scan_trigger(void);
// keypad
// file /usr/include/curses.h line 654
extern signed int keypad(struct _win_st *, _Bool);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// link_handler
// file iw_nl80211.c line 329
static signed int link_handler(struct nl_msg *msg, void *arg);
// link_sta_handler
// file iw_nl80211.c line 381
static signed int link_sta_handler(struct nl_msg *msg, void *arg);
// ll_create
// file llist.c line 87
signed int ll_create(void);
// ll_destroy
// file llist.c line 216
void ll_destroy(signed int ld);
// ll_get
// file llist.c line 111
void * ll_get(signed int ld, unsigned long int n);
// ll_getall
// file llist.c line 124
void * ll_getall(signed int ld);
// ll_push
// file llist.c line 162
void ll_push(signed int ld, const char *format, ...);
// ll_replace
// file llist.c line 180
void ll_replace(signed int ld, unsigned long int n, const char *format, ...);
// ll_reset
// file llist.c line 154
void ll_reset(signed int ld);
// ll_size
// file llist.c line 203
unsigned long int ll_size(signed int ld);
// log10
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 112
extern double log10(double);
// lsearch
// file /usr/include/search.h line 169
extern void * lsearch(const void *, void *, unsigned long int *, unsigned long int, signed int (*)(const void *, const void *));
// m_pref
// file conf_scr.c line 133
static signed int m_pref(struct _win_st *w_conf, signed int list_offset, signed int active_item, signed int num_items);
// mac_addr
// file utils.c line 50
char * mac_addr(struct sockaddr *sa);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// map_range
// file wavemon.h line 413
static inline double map_range(double val, double minv, double maxv, double min, double max);
// map_val
// file wavemon.h line 407
static inline double map_val(double ratio, double min, double max);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// modf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 115
extern double modf(double, double *);
// mvwclrtoborder
// file ui.c line 54
extern void mvwclrtoborder(struct _win_st *win, signed int y, signed int x);
// mw2dbm
// file utils.c line 161
double mw2dbm(const double in);
// newpad
// file /usr/include/curses.h line 712
extern struct _win_st * newpad(signed int, signed int);
// newwin
// file /usr/include/curses.h line 714
extern struct _win_st * newwin(signed int, signed int, signed int, signed int);
// newwin_title
// file wavemon.h line 224
extern struct _win_st * newwin_title(signed int y, signed int h, const char *title, _Bool nobottom);
// nl_cb_alloc
// file /usr/include/libnl3/netlink/handlers.h line 118
extern struct nl_cb * nl_cb_alloc(enum nl_cb_kind);
// nl_cb_err
// file /usr/include/libnl3/netlink/handlers.h line 127
extern signed int nl_cb_err(struct nl_cb *, enum nl_cb_kind, signed int (*)(struct sockaddr_nl *, struct nlmsgerr *, void *), void *);
// nl_cb_put
// file /usr/include/libnl3/netlink/handlers.h line 121
extern void nl_cb_put(struct nl_cb *);
// nl_cb_set
// file /usr/include/libnl3/netlink/handlers.h line 123
extern signed int nl_cb_set(struct nl_cb *, enum nl_cb_type, enum nl_cb_kind, signed int (*)(struct nl_msg *, void *), void *);
// nl_get_multicast_id
// file iw_nl80211.c line 655
signed int nl_get_multicast_id(struct nl_sock *sock, const char *family, const char *group);
// nl_recvmsgs
// file /usr/include/libnl3/netlink/netlink.h line 77
extern signed int nl_recvmsgs(struct nl_sock *, struct nl_cb *);
// nl_send_auto_complete
// file /usr/include/libnl3/netlink/netlink.h line 66
extern signed int nl_send_auto_complete(struct nl_sock *, struct nl_msg *);
// nl_socket_add_membership
// file /usr/include/libnl3/netlink/socket.h line 30
extern signed int nl_socket_add_membership(struct nl_sock *, signed int);
// nl_socket_alloc
// file /usr/include/libnl3/netlink/socket.h line 22
extern struct nl_sock * nl_socket_alloc(void);
// nla_data
// file /usr/include/libnl3/netlink/attr.h line 85
extern void * nla_data(struct nlattr *);
// nla_get_u16
// file /usr/include/libnl3/netlink/attr.h line 115
extern unsigned short int nla_get_u16(struct nlattr *);
// nla_get_u32
// file /usr/include/libnl3/netlink/attr.h line 119
extern unsigned int nla_get_u32(struct nlattr *);
// nla_get_u64
// file /usr/include/libnl3/netlink/attr.h line 123
extern unsigned long int nla_get_u64(struct nlattr *);
// nla_get_u8
// file /usr/include/libnl3/netlink/attr.h line 111
extern unsigned char nla_get_u8(struct nlattr *);
// nla_len
// file /usr/include/libnl3/netlink/attr.h line 86
extern signed int nla_len(struct nlattr *);
// nla_next
// file /usr/include/libnl3/netlink/attr.h line 88
extern struct nlattr * nla_next(struct nlattr *, signed int *);
// nla_ok
// file /usr/include/libnl3/netlink/attr.h line 87
extern signed int nla_ok(struct nlattr *, signed int);
// nla_parse
// file /usr/include/libnl3/netlink/attr.h line 89
extern signed int nla_parse(struct nlattr **, signed int, struct nlattr *, signed int, struct nla_policy *);
// nla_parse_nested
// file /usr/include/libnl3/netlink/attr.h line 145
extern signed int nla_parse_nested(struct nlattr **, signed int, struct nlattr *, struct nla_policy *);
// nla_put
// file /usr/include/libnl3/netlink/attr.h line 103
extern signed int nla_put(struct nl_msg *, signed int, signed int, const void *);
// nlmsg_alloc
// file /usr/include/libnl3/netlink/msg.h line 72
extern struct nl_msg * nlmsg_alloc(void);
// nlmsg_data
// file /usr/include/libnl3/netlink/msg.h line 54
extern void * nlmsg_data(struct nlmsghdr *);
// nlmsg_free
// file /usr/include/libnl3/netlink/msg.h line 86
extern void nlmsg_free(struct nl_msg *);
// nlmsg_hdr
// file /usr/include/libnl3/netlink/msg.h line 84
extern struct nlmsghdr * nlmsg_hdr(struct nl_msg *);
// no_seq_check
// file iw_nl80211.h line 268
static inline signed int no_seq_check(struct nl_msg *msg, void *arg);
// nodelay
// file /usr/include/curses.h line 717
extern signed int nodelay(struct _win_st *, _Bool);
// noecho
// file /usr/include/curses.h line 718
extern signed int noecho(void);
// nonl
// file /usr/include/curses.h line 719
extern signed int nonl(void);
// parse_bitrate
// file iw_nl80211.c line 106
void parse_bitrate(struct nlattr *bitrate_attr, char *buf, signed int buflen);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// prefix_len
// file utils.c line 82
unsigned char prefix_len(struct in_addr *netmask);
// prefresh
// file /usr/include/curses.h line 729
extern signed int prefresh(struct _win_st *, signed int, signed int, signed int, signed int, signed int, signed int);
// pretty_time
// file utils.c line 88
const char * pretty_time(const unsigned int sec);
// pretty_time_ms
// file utils.c line 116
const char * pretty_time_ms(const unsigned int msec);
// print_ssid_escaped
// file iw_nl80211.c line 157
extern void print_ssid_escaped(char *buf, const unsigned long int buflen, const unsigned char *data, const unsigned long int datalen);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_13 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_13 *, const union anonymous_14 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_13 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_13 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_13 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_14 *);
// pthread_mutexattr_setrobust
// file /usr/include/pthread.h line 874
extern signed int pthread_mutexattr_setrobust(union anonymous_14 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous_10 *, struct anonymous_10 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read_cf
// file conf.c line 203
static void read_cf(void);
// redraw_lhist
// file lhist_scr.c line 320
static void redraw_lhist(signed int signum);
// redraw_stat_levels
// file info_scr.c line 671
static void redraw_stat_levels(signed int signum);
// reg_handler
// file iw_nl80211.c line 299
static signed int reg_handler(struct nl_msg *msg, void *arg);
// reset_shell_mode
// file /usr/include/curses.h line 739
extern signed int reset_shell_mode(void);
// resizeterm
// file /usr/include/curses.h line 903
extern signed int resizeterm(signed int, signed int);
// reverse_range
// file wavemon.h line 420
static inline signed int reverse_range(signed int val, signed int min, signed int max);
// sampling_do_poll
// file info_scr.c line 44
extern void sampling_do_poll(void);
// sampling_init
// file info_scr.c line 29
extern void sampling_init(void (*sampling_handler)(signed int));

//

// sampling_stop
// file iw_if.h line 213
static inline void sampling_stop(void);
// sampling_stop_link1
// file iw_if.h line 213
static inline void sampling_stop_link1(void);
// scan_dump_handler
// file iw_scan.c line 143
signed int scan_dump_handler(struct nl_msg *msg, void *arg);
// scan_result_fini
// file iw_if.h line 295
extern void scan_result_fini(struct scan_result *sr);
// scan_result_init
// file iw_if.h line 294
extern void scan_result_init(struct scan_result *sr);
// scr_about_fini
// file wavemon.h line 219
extern void scr_about_fini(void);
// scr_about_init
// file wavemon.h line 217
extern void scr_about_init(void);
// scr_about_loop
// file wavemon.h line 218
extern signed int scr_about_loop(struct _win_st *w_menu);
// scr_aplst_fini
// file wavemon.h line 207
extern void scr_aplst_fini(void);
// scr_aplst_init
// file wavemon.h line 205
extern void scr_aplst_init(void);
// scr_aplst_loop
// file wavemon.h line 206
extern signed int scr_aplst_loop(struct _win_st *w_menu);
// scr_conf_fini
// file wavemon.h line 211
extern void scr_conf_fini(void);
// scr_conf_init
// file wavemon.h line 209
extern void scr_conf_init(void);
// scr_conf_loop
// file wavemon.h line 210
extern signed int scr_conf_loop(struct _win_st *w_menu);
// scr_help_fini
// file wavemon.h line 215
extern void scr_help_fini(void);
// scr_help_init
// file wavemon.h line 213
extern void scr_help_init(void);
// scr_help_loop
// file wavemon.h line 214
extern signed int scr_help_loop(struct _win_st *w_menu);
// scr_info_fini
// file wavemon.h line 199
extern void scr_info_fini(void);
// scr_info_init
// file wavemon.h line 197
extern void scr_info_init(void);
// scr_info_loop
// file wavemon.h line 198
extern signed int scr_info_loop(struct _win_st *w_menu);
// scr_lhist_fini
// file wavemon.h line 203
extern void scr_lhist_fini(void);
// scr_lhist_init
// file wavemon.h line 201
extern void scr_lhist_init(void);
// scr_lhist_loop
// file wavemon.h line 202
extern signed int scr_lhist_loop(struct _win_st *w_menu);
// select_item
// file conf_scr.c line 119
static signed int select_item(signed int rv, signed int incr);
// setitimer
// file /usr/include/x86_64-linux-gnu/sys/time.h line 131
extern signed int setitimer(signed int, struct itimerval *, struct itimerval *);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sig_winch
// file wavemon.c line 95
static void sig_winch(signed int signo);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_10 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_10 *);
// siglongjmp
// file /usr/include/setjmp.h line 102
extern void siglongjmp(struct __jmp_buf_tag *, signed int);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_10 *, struct anonymous_10 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_scan_list
// file iw_if.h line 252
extern void sort_scan_list(struct scan_entry **headp);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_color
// file /usr/include/curses.h line 771
extern signed int start_color(void);
// start_timer
// file timer.c line 32
extern void start_timer(struct timer *t, unsigned long int duration);
// str_is_ascii
// file wavemon.h line 347
static inline _Bool str_is_ascii(char *s);
// str_is_ascii_link1
// file wavemon.h line 347
static inline _Bool str_is_ascii_link1(char *s_link1);
// str_tolower
// file wavemon.h line 340
static inline void str_tolower(char *s);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// survey_handler
// file iw_nl80211.c line 235
static signed int survey_handler(struct nl_msg *msg, void *arg);
// terminate_all_processes
// file error.c line 68
static void terminate_all_processes(const char *fmt, signed int strerr, void **ap);
// threshold_action
// file wavemon.h line 97
static inline void threshold_action(enum threshold_action action);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// track_extrema
// file lhist_scr.c line 56
static void track_extrema(const float new_sample, struct iw_extrema *ie);
// u8_to_dbm
// file utils.c line 128
signed int u8_to_dbm(const signed int power);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vwarn
// file /usr/include/err.h line 36
extern void vwarn(const char *, void **);
// vwarnx
// file /usr/include/err.h line 42
extern void vwarnx(const char *, void **);
// wadd_attr_str
// file wavemon.h line 230
extern void wadd_attr_str(struct _win_st *win, const signed int attrs, const char *s);
// waddbar
// file ui.c line 119
extern void waddbar(struct _win_st *win, signed int y, float v, float min, float max, signed char *cscale, _Bool rev);
// waddch
// file /usr/include/curses.h line 792
extern signed int waddch(struct _win_st *, const unsigned long int);
// waddnstr
// file /usr/include/curses.h line 795
extern signed int waddnstr(struct _win_st *, const char *, signed int);
// waddstr_b
// file wavemon.h line 231
static inline void waddstr_b(struct _win_st *win, const char *s);
// waddstr_b_link1
// file wavemon.h line 231
static inline void waddstr_b_link1(struct _win_st *win_link1, const char *s_link1);
// waddstr_b_link2
// file wavemon.h line 231
static inline void waddstr_b_link2(struct _win_st *win_link2, const char *s_link2);
// waddstr_center
// file wavemon.h line 236
extern void waddstr_center(struct _win_st *win, signed int y, const char *s);
// waddstr_item
// file conf_scr.c line 37
static void waddstr_item(struct _win_st *w, signed int y, struct conf_item *item, char hilight);
// waddthreshold
// file ui.c line 129
extern void waddthreshold(struct _win_st *win, signed int y, float v, float tv, float minv, float maxv, signed char *cscale, unsigned long int tch);
// wait_event
// file iw_scan.c line 90
static signed int wait_event(struct nl_msg *msg, void *arg);
// wait_for_scan_events
// file iw_scan.c line 108
static _Bool wait_for_scan_events(struct scan_result *sr);
// wattr_off
// file /usr/include/curses.h line 802
extern signed int wattr_off(struct _win_st *, unsigned long int, void *);
// wattr_on
// file /usr/include/curses.h line 801
extern signed int wattr_on(struct _win_st *, unsigned long int, void *);
// wborder
// file /usr/include/curses.h line 806
extern signed int wborder(struct _win_st *, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
// wclear
// file /usr/include/curses.h line 808
extern signed int wclear(struct _win_st *);
// wclrtoborder
// file ui.c line 60
extern void wclrtoborder(struct _win_st *win);
// werase
// file /usr/include/curses.h line 816
extern signed int werase(struct _win_st *);
// wgetch
// file /usr/include/curses.h line 817
extern signed int wgetch(struct _win_st *);
// whline
// file /usr/include/curses.h line 820
extern signed int whline(struct _win_st *, unsigned long int, signed int);
// wmove
// file /usr/include/curses.h line 831
extern signed int wmove(struct _win_st *, signed int, signed int);
// wprintw
// file /usr/include/curses.h line 833
extern signed int wprintw(struct _win_st *, const char *, ...);
// wrefresh
// file /usr/include/curses.h line 836
extern signed int wrefresh(struct _win_st *);
// write_cf
// file conf.c line 132
static void write_cf(void);
// wvline
// file /usr/include/curses.h line 847
extern signed int wvline(struct _win_st *, unsigned long int, signed int);
// xsignal
// file wavemon.h line 310
static inline void (*xsignal(signed int signo, void (*handler)(signed int)))(signed int);
// xsignal_link1
// file wavemon.h line 310
static inline void (*xsignal_link1(signed int signo_link1, void (*handler_link1)(signed int)))(signed int);
// xsignal_link2
// file wavemon.h line 310
static inline void (*xsignal_link2(signed int signo_link2, void (*handler_link2)(signed int)))(signed int);

//


//


//


struct anonymous_21
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_19
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_10
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_12
{
  // quot
  signed int quot;
  // rem
  signed int rem;
};

struct anonymous_15
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_18
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_17
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_16
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_20
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_22
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_15 _kill;
  // _timer
  struct anonymous_16 _timer;
  // _rt
  struct anonymous_17 _rt;
  // _sigchld
  struct anonymous_18 _sigchld;
  // _sigfault
  struct anonymous_19 _sigfault;
  // _sigpoll
  struct anonymous_20 _sigpoll;
  // _sigsys
  struct anonymous_21 _sigsys;
};

struct anonymous_23
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_22 _sifields;
};

struct anonymous_0
{
  // encoding
  unsigned short int encoding;
  // parity
  unsigned short int parity;
};

struct anonymous_5
{
  // clock_rate
  unsigned int clock_rate;
  // clock_type
  unsigned int clock_type;
  // loopback
  unsigned short int loopback;
};

struct anonymous_6
{
  // clock_rate
  unsigned int clock_rate;
  // clock_type
  unsigned int clock_type;
  // loopback
  unsigned short int loopback;
  // slot_map
  unsigned int slot_map;
};

struct anonymous_3
{
  // dlci
  unsigned int dlci;
};

struct anonymous_4
{
  // dlci
  unsigned int dlci;
  // master
  char master[16l];
};

struct anonymous_1
{
  // interval
  unsigned int interval;
  // timeout
  unsigned int timeout;
};

struct anonymous_2
{
  // t391
  unsigned int t391;
  // t392
  unsigned int t392;
  // n391
  unsigned int n391;
  // n392
  unsigned int n392;
  // n393
  unsigned int n393;
  // lmi
  unsigned short int lmi;
  // dce
  unsigned short int dce;
};

struct anonymous_26
{
  // n
  unsigned long int n;
  // eol
  char eol;
};

union anonymous_25
{
  // i
  signed int *i;
  // fp
  void (*fp)();
};

union anonymous_7
{
  // raw_hdlc
  struct anonymous_0 *raw_hdlc;
  // cisco
  struct anonymous_1 *cisco;
  // fr
  struct anonymous_2 *fr;
  // fr_pvc
  struct anonymous_3 *fr_pvc;
  // fr_pvc_info
  struct anonymous_4 *fr_pvc_info;
  // sync
  struct anonymous_5 *sync;
  // te1
  struct anonymous_6 *te1;
};

union anonymous_9
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_23 *, void *);
};

union anonymous
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_14
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_13
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

struct if_settings
{
  // type
  unsigned int type;
  // size
  unsigned int size;
  // ifs_ifsu
  union anonymous_7 ifs_ifsu;
};

union anonymous_8
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  void *ifru_data;
  // ifru_settings
  struct if_settings ifru_settings;
};

struct anonymous_11
{
  // key_name
  const char * const key_name;
  // init
  void (*init)(void);
  // loop
  signed int (*loop)(struct _win_st *);
  // fini
  void (*fini)(void);
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_10 __saved_mask;
};

struct pdat
{
  // _pad_y
  signed short int _pad_y;
  // _pad_x
  signed short int _pad_x;
  // _pad_top
  signed short int _pad_top;
  // _pad_left
  signed short int _pad_left;
  // _pad_bottom
  signed short int _pad_bottom;
  // _pad_right
  signed short int _pad_right;
};

struct _win_st
{
  // _cury
  signed short int _cury;
  // _curx
  signed short int _curx;
  // _maxy
  signed short int _maxy;
  // _maxx
  signed short int _maxx;
  // _begy
  signed short int _begy;
  // _begx
  signed short int _begx;
  // _flags
  signed short int _flags;
  // _attrs
  unsigned long int _attrs;
  // _bkgd
  unsigned long int _bkgd;
  // _notimeout
  _Bool _notimeout;
  // _clear
  _Bool _clear;
  // _leaveok
  _Bool _leaveok;
  // _scroll
  _Bool _scroll;
  // _idlok
  _Bool _idlok;
  // _idcok
  _Bool _idcok;
  // _immed
  _Bool _immed;
  // _sync
  _Bool _sync;
  // _use_keypad
  _Bool _use_keypad;
  // _delay
  signed int _delay;
  // _line
  struct ldat *_line;
  // _regtop
  signed short int _regtop;
  // _regbottom
  signed short int _regbottom;
  // _parx
  signed int _parx;
  // _pary
  signed int _pary;
  // _parent
  struct _win_st *_parent;
  // _pad
  struct pdat _pad;
  // _yoffset
  signed short int _yoffset;
};

struct assorted_numbers
{
  // entries
  unsigned short int entries;
  // open
  unsigned short int open;
  // two_gig
  unsigned short int two_gig;
  // five_gig
  unsigned short int five_gig;
  // ch_stats
  unsigned long int ch_stats;
};

struct chain
{
  // e
  void *e;
  // type
  char type;
  // next
  struct chain *next;
};

struct cmd
{
  // cmd
  enum nl80211_commands cmd;
  // sk
  struct nl_sock *sk;
  // flags
  signed int flags;
  // handler
  signed int (*handler)(struct nl_msg *, void *);
  // handler_arg
  void *handler_arg;
  // msg_args
  struct msg_attribute *msg_args;
  // msg_args_len
  unsigned char msg_args_len;
};

struct cnt
{
  // val
  signed int val;
  // count
  signed int count;
};

struct conf_item
{
  // name
  char *name;
  // cfname
  char *cfname;
  // type
  enum anonymous_24 type;
  // v
  union anonymous_25 v;
  // list
  char **list;
  // dep
  signed int *dep;
  // min
  double min;
  // max
  double max;
  // inc
  double inc;
  // unit
  char *unit;
};

struct ether_addr
{
  // ether_addr_octet
  unsigned char ether_addr_octet[6l];
} __attribute__ ((__packed__));

struct genlmsghdr
{
  // cmd
  unsigned char cmd;
  // version
  unsigned char version;
  // reserved
  unsigned short int reserved;
};

struct handler_args
{
  // group
  const char *group;
  // id
  signed int id;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct if_info
{
  // hwaddr
  struct ether_addr hwaddr;
  // addr
  struct in_addr addr;
  // netmask
  struct in_addr netmask;
  // bcast
  struct in_addr bcast;
  // mtu
  unsigned short int mtu;
  // txqlen
  unsigned short int txqlen;
  // flags
  unsigned short int flags;
};

struct if_stat
{
  // rx_packets
  unsigned long long int rx_packets;
  // tx_packets
  unsigned long long int tx_packets;
  // rx_bytes
  unsigned long long int rx_bytes;
  // tx_bytes
  unsigned long long int tx_bytes;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous ifr_ifrn;
  // ifr_ifru
  union anonymous_8 ifr_ifru;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct itimerval
{
  // it_interval
  struct timeval it_interval;
  // it_value
  struct timeval it_value;
};

struct iw_param
{
  // value
  signed int value;
  // fixed
  unsigned char fixed;
  // disabled
  unsigned char disabled;
  // flags
  unsigned short int flags;
};

struct iw_dyn_info
{
  // name
  char name[16l];
  // mode
  unsigned char mode;
  // cap_essid
  _Bool cap_essid : 1;
  // cap_nickname
  _Bool cap_nickname : 1;
  // cap_freq
  _Bool cap_freq : 1;
  // cap_sens
  _Bool cap_sens : 1;
  // cap_txpower
  _Bool cap_txpower : 1;
  // cap_retry
  _Bool cap_retry : 1;
  // cap_rts
  _Bool cap_rts : 1;
  // cap_frag
  _Bool cap_frag : 1;
  // cap_mode
  _Bool cap_mode : 1;
  // cap_ap
  _Bool cap_ap : 1;
  // cap_power
  _Bool cap_power : 1;
  // cap_aplist
  _Bool cap_aplist : 1;
  // essid
  char essid[34l];
  // essid_ct
  unsigned char essid_ct;
  // nickname
  char nickname[34l];
  // ap_addr
  struct sockaddr ap_addr;
  // retry
  struct iw_param retry;
  // rts
  struct iw_param rts;
  // frag
  struct iw_param frag;
  // txpower
  struct iw_param txpower;
  // power
  struct iw_param power;
  // freq
  float freq;
  // sens
  signed int sens;
  // bitrate
  unsigned long int bitrate;
  // keys
  struct iw_key *keys;
  // nkeys
  unsigned char nkeys;
  // active_key
  unsigned char active_key;
};

struct iw_extrema
{
  // initialised
  _Bool initialised;
  // min
  float min;
  // max
  float max;
};

struct iw_freq
{
  // m
  signed int m;
  // e
  signed short int e;
  // i
  unsigned char i;
  // flags
  unsigned char flags;
};

struct iw_key
{
  // key
  unsigned char key[64l];
  // size
  unsigned short int size;
  // flags
  unsigned short int flags;
};

struct iw_levelstat
{
  // signal
  float signal;
  // noise
  float noise;
  // flags
  unsigned char flags;
};

struct iw_nl80211_ifstat
{
  // phy
  unsigned int phy;
  // ifindex
  unsigned int ifindex;
  // wdev
  unsigned int wdev;
  // iftype
  unsigned int iftype;
  // ssid
  char ssid[64l];
  // freq
  unsigned int freq;
  // chan_width
  signed int chan_width;
  // chan_type
  signed int chan_type;
  // freq_ctr1
  signed int freq_ctr1;
  // freq_ctr2
  signed int freq_ctr2;
};

struct time_data_in_milliseconds
{
  // active
  unsigned long int active;
  // busy
  unsigned long int busy;
  // ext_busy
  unsigned long int ext_busy;
  // rx
  unsigned long int rx;
  // tx
  unsigned long int tx;
  // scan
  unsigned long int scan;
};

struct iw_nl80211_survey
{
  // freq
  unsigned int freq;
  // noise
  signed char noise;
  // time
  struct time_data_in_milliseconds time;
};

struct iw_nl80211_linkstat
{
  // status
  unsigned int status;
  // bssid
  struct ether_addr bssid;
  // inactive_time
  unsigned int inactive_time;
  // connected_time
  unsigned int connected_time;
  // rx_bytes
  unsigned int rx_bytes;
  // rx_packets
  unsigned int rx_packets;
  // rx_drop_misc
  unsigned long int rx_drop_misc;
  // beacon_int
  unsigned short int beacon_int;
  // dtim_period
  unsigned char dtim_period;
  // beacon_avg_sig
  unsigned char beacon_avg_sig;
  // beacons
  unsigned long int beacons;
  // beacon_loss
  unsigned int beacon_loss;
  // tx_bytes
  unsigned int tx_bytes;
  // tx_packets
  unsigned int tx_packets;
  // tx_retries
  unsigned int tx_retries;
  // tx_failed
  unsigned int tx_failed;
  // expected_thru
  unsigned int expected_thru;
  // signal
  signed char signal;
  // signal_avg
  signed char signal_avg;
  // bss_signal
  signed char bss_signal;
  // bss_signal_qual
  unsigned char bss_signal_qual;
  // tx_bitrate
  char tx_bitrate[100l];
  // rx_bitrate
  char rx_bitrate[100l];
  // cts_protection
  _Bool cts_protection : 1;
  // long_preamble
  _Bool long_preamble : 1;
  // short_slot_time
  _Bool short_slot_time : 1;
  // wme
  _Bool wme : 1;
  // mfp
  _Bool mfp : 1;
  // tdls
  _Bool tdls : 1;
  // survey
  struct iw_nl80211_survey survey;
};

struct iw_nl80211_reg
{
  // region
  signed int region;
  // country
  char country[3l];
};

struct iw_point
{
  // pointer
  void *pointer;
  // length
  unsigned short int length;
  // flags
  unsigned short int flags;
};

struct iw_quality
{
  // qual
  unsigned char qual;
  // level
  unsigned char level;
  // noise
  unsigned char noise;
  // updated
  unsigned char updated;
};

struct iw_range
{
  // throughput
  unsigned int throughput;
  // min_nwid
  unsigned int min_nwid;
  // max_nwid
  unsigned int max_nwid;
  // old_num_channels
  unsigned short int old_num_channels;
  // old_num_frequency
  unsigned char old_num_frequency;
  // scan_capa
  unsigned char scan_capa;
  // event_capa
  unsigned int event_capa[6l];
  // sensitivity
  signed int sensitivity;
  // max_qual
  struct iw_quality max_qual;
  // avg_qual
  struct iw_quality avg_qual;
  // num_bitrates
  unsigned char num_bitrates;
  // bitrate
  signed int bitrate[32l];
  // min_rts
  signed int min_rts;
  // max_rts
  signed int max_rts;
  // min_frag
  signed int min_frag;
  // max_frag
  signed int max_frag;
  // min_pmp
  signed int min_pmp;
  // max_pmp
  signed int max_pmp;
  // min_pmt
  signed int min_pmt;
  // max_pmt
  signed int max_pmt;
  // pmp_flags
  unsigned short int pmp_flags;
  // pmt_flags
  unsigned short int pmt_flags;
  // pm_capa
  unsigned short int pm_capa;
  // encoding_size
  unsigned short int encoding_size[8l];
  // num_encoding_sizes
  unsigned char num_encoding_sizes;
  // max_encoding_tokens
  unsigned char max_encoding_tokens;
  // encoding_login_index
  unsigned char encoding_login_index;
  // txpower_capa
  unsigned short int txpower_capa;
  // num_txpower
  unsigned char num_txpower;
  // txpower
  signed int txpower[8l];
  // we_version_compiled
  unsigned char we_version_compiled;
  // we_version_source
  unsigned char we_version_source;
  // retry_capa
  unsigned short int retry_capa;
  // retry_flags
  unsigned short int retry_flags;
  // r_time_flags
  unsigned short int r_time_flags;
  // min_retry
  signed int min_retry;
  // max_retry
  signed int max_retry;
  // min_r_time
  signed int min_r_time;
  // max_r_time
  signed int max_r_time;
  // num_channels
  unsigned short int num_channels;
  // num_frequency
  unsigned char num_frequency;
  // freq
  struct iw_freq freq[32l];
  // enc_capa
  unsigned int enc_capa;
};

union iwreq_data
{
  // name
  char name[16l];
  // essid
  struct iw_point essid;
  // nwid
  struct iw_param nwid;
  // freq
  struct iw_freq freq;
  // sens
  struct iw_param sens;
  // bitrate
  struct iw_param bitrate;
  // txpower
  struct iw_param txpower;
  // rts
  struct iw_param rts;
  // frag
  struct iw_param frag;
  // mode
  unsigned int mode;
  // retry
  struct iw_param retry;
  // encoding
  struct iw_point encoding;
  // power
  struct iw_param power;
  // qual
  struct iw_quality qual;
  // ap_addr
  struct sockaddr ap_addr;
  // addr
  struct sockaddr addr;
  // param
  struct iw_param param;
  // data
  struct iw_point data;
};

struct iwreq
{
  // ifr_ifrn
  union anonymous ifr_ifrn;
  // u
  union iwreq_data u;
};

struct msg_attribute
{
  // type
  signed int type;
  // len
  signed int len;
  // data
  const void *data;
};

struct nl80211_sta_flag_update
{
  // mask
  unsigned int mask;
  // set
  unsigned int set;
} __attribute__ ((__packed__));

struct nla_policy
{
  // type
  unsigned short int type;
  // minlen
  unsigned short int minlen;
  // maxlen
  unsigned short int maxlen;
};

struct nlattr
{
  // nla_len
  unsigned short int nla_len;
  // nla_type
  unsigned short int nla_type;
};

struct nlmsghdr
{
  // nlmsg_len
  unsigned int nlmsg_len;
  // nlmsg_type
  unsigned short int nlmsg_type;
  // nlmsg_flags
  unsigned short int nlmsg_flags;
  // nlmsg_seq
  unsigned int nlmsg_seq;
  // nlmsg_pid
  unsigned int nlmsg_pid;
};

struct nlmsgerr
{
  // error
  signed int error;
  // msg
  struct nlmsghdr msg;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct scan_entry
{
  // ap_addr
  struct ether_addr ap_addr;
  // essid
  char essid[34l];
  // freq
  unsigned int freq;
  // chan
  signed int chan;
  // has_key
  unsigned char has_key : 1;
  // last_seen
  unsigned int last_seen;
  // tsf
  unsigned long int tsf;
  // bss_signal
  signed char bss_signal;
  // bss_signal_qual
  unsigned char bss_signal_qual;
  // bss_capa
  unsigned short int bss_capa;
  // bss_sta_count
  unsigned char bss_sta_count;
  // bss_chan_usage
  unsigned char bss_chan_usage;
  // next
  struct scan_entry *next;
};

struct scan_result
{
  // head
  struct scan_entry *head;
  // msg
  char msg[128l];
  // max_essid_len
  unsigned short int max_essid_len;
  // channel_stats
  struct cnt *channel_stats;
  // num
  struct assorted_numbers num;
  // mutex
  union anonymous_13 mutex;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_9 __sigaction_handler;
  // sa_mask
  struct anonymous_10 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_nl
{
  // nl_family
  unsigned short int nl_family;
  // nl_pad
  unsigned short int nl_pad;
  // nl_pid
  unsigned int nl_pid;
  // nl_groups
  unsigned int nl_groups;
};

struct timer
{
  // stime
  unsigned long long int stime;
  // duration
  unsigned long int duration;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct wait_event
{
  // cmds
  const unsigned int *cmds;
  // n_cmds
  unsigned char n_cmds;
  // cmd
  unsigned int cmd;
};

struct wavemon_conf
{
  // if_idx
  signed int if_idx;
  // stat_iv
  signed int stat_iv;
  // info_iv
  signed int info_iv;
  // sig_min
  signed int sig_min;
  // sig_max
  signed int sig_max;
  // noise_min
  signed int noise_min;
  // noise_max
  signed int noise_max;
  // lthreshold
  signed int lthreshold;
  // hthreshold
  signed int hthreshold;
  // slotsize
  signed int slotsize;
  // meter_decay
  signed int meter_decay;
  // check_geometry
  signed int check_geometry;
  // cisco_mac
  signed int cisco_mac;
  // override_bounds
  signed int override_bounds;
  // scan_sort_asc
  signed int scan_sort_asc;
  // scan_sort_order
  signed int scan_sort_order;
  // lthreshold_action
  signed int lthreshold_action;
  // hthreshold_action
  signed int hthreshold_action;
  // startup_scr
  signed int startup_scr;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// COLS
// file /usr/include/curses.h line 1399
extern signed int COLS;
// LINES
// file /usr/include/curses.h line 1401
extern signed int LINES;
// about_lines
// file about_scr.c line 25
static char *about_lines[10l] = { "wavemon - status monitor for wireless network devices",
    "version 0.8.0 (built Sat Feb 13 18:07:20 UTC 2016)",
    "", "original by jan morgenstern <jan@jm-music.de>",
    "distributed under the GNU general public license v3",
    "", "please send suggestions and bug reports to ",
    "gerrit@erg.abdn.ac.uk", "", "https://github.com/uoaerg/wavemon" };
// acs_map
// file /usr/include/curses.h line 274
extern unsigned long int acs_map[];
// action_items
// file conf.c line 30
static char *action_items[5l] = { "Disabled", "Beep", "Flash", "Beep+Flash", (char *)(void *)0 };
// active_item
// file conf_scr.c line 34
static signed int active_item;
// conf
// file conf.c line 56
struct wavemon_conf conf = { .if_idx=0, .stat_iv=100, .info_iv=10, .sig_min=-100, .sig_max=-10,
    .noise_min=-120, .noise_max=-40, .lthreshold=-80,
    .hthreshold=-10, .slotsize=4, .meter_decay=0,
    .check_geometry=0, .cisco_mac=0, .override_bounds=0,
    .scan_sort_asc=0, .scan_sort_order=5,
    .lthreshold_action=0, .hthreshold_action=0,
    .startup_scr=0 };
// conf_items
// file conf.c line 27
signed int conf_items;
// count
// file lhist_scr.c line 97
static unsigned int count;
// dyn_updates
// file info_scr.c line 25
static struct timer dyn_updates;
// e_noise
// file lhist_scr.c line 49
static struct iw_extrema e_noise;
// e_signal
// file lhist_scr.c line 49
static struct iw_extrema e_signal;
// e_snr
// file lhist_scr.c line 49
static struct iw_extrema e_snr;
// env_winch
// file wavemon.c line 92
static struct __jmp_buf_tag env_winch[1l];
// env_winch_ready
// file wavemon.c line 93
static volatile signed int env_winch_ready;
// first_item
// file conf_scr.c line 34
static signed int first_item;
// i
// file about_scr.c line 38
static signed int i;
// if_list
// file conf.c line 26
static char *if_list[64l];
// iw_stats_cache
// file lhist_scr.c line 96
static struct iw_levelstat iw_stats_cache[1024l];
// j
// file about_scr.c line 38
static signed int j;
// linecd
// file about_scr.c line 38
static signed int *linecd[10l];
// list_offset
// file conf_scr.c line 35
static signed int list_offset;
// lists
// file llist.c line 47
static struct chain *lists[256l];
// lp
// file llist.c line 53
static struct anonymous_26 lp[256l];
// ls
// file info_scr.c line 27
static struct iw_nl80211_linkstat ls;
// num_items
// file conf_scr.c line 35
static signed int num_items;
// on_off_names
// file conf.c line 29
static char *on_off_names[3l] = { "Off", "On", (char *)(void *)0 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// range
// file info_scr.c line 26
struct iw_range range;
// scan_cmp
// file iw_scan.c line 75
static _Bool (*scan_cmp[7l])(struct scan_entry *, struct scan_entry *);
// scan_cmp
// file iw_scan.c line 75
static _Bool (*scan_cmp[7l])(struct scan_entry *, struct scan_entry *) = { cmp_chan, cmp_sig, cmp_mac, cmp_essid, cmp_open, cmp_chan_sig, cmp_open_sig };
// scan_thread
// file scan_scr.c line 26
static unsigned long int scan_thread;
// scan_wait_sk
// file iw_scan.c line 15
static struct nl_sock *scan_wait_sk;
// screen_names
// file conf.c line 49
static char *screen_names[4l] = { "Info screen", "Histogram", "Scan window", (char *)(void *)0 };
// screens
// file wavemon.c line 38
static struct anonymous_11 screens[10l];
// screens
// file wavemon.c line 38
static struct anonymous_11 screens[10l] = { { .key_name="info", .init=scr_info_init, .loop=scr_info_loop,
    .fini=scr_info_fini },
    { .key_name="lhist", .init=scr_lhist_init, .loop=scr_lhist_loop,
    .fini=scr_lhist_fini },
    { .key_name="scan", .init=scr_aplst_init, .loop=scr_aplst_loop,
    .fini=scr_aplst_fini },
    { .key_name="", .init=((void (*)(void))NULL), .loop=((signed int (*)(struct _win_st *))NULL),
    .fini=((void (*)(void))NULL) },
    { .key_name="", .init=((void (*)(void))NULL), .loop=((signed int (*)(struct _win_st *))NULL),
    .fini=((void (*)(void))NULL) },
    { .key_name="", .init=((void (*)(void))NULL), .loop=((signed int (*)(struct _win_st *))NULL),
    .fini=((void (*)(void))NULL) },
    { .key_name="prefs", .init=scr_conf_init, .loop=scr_conf_loop,
    .fini=scr_conf_fini },
    { .key_name="help", .init=scr_help_init, .loop=scr_help_loop,
    .fini=scr_help_fini },
    { .key_name="about", .init=scr_about_init, .loop=scr_about_loop,
    .fini=scr_about_fini },
    { .key_name="quit", .init=((void (*)(void))NULL), .loop=((signed int (*)(struct _win_st *))NULL),
    .fini=((void (*)(void))NULL) } };
// sort_order
// file conf.c line 38
static char *sort_order[8l] = { "Channel", "Signal", "MAC", "Essid", "Open", "Chan/Sig", "Open/Sig", (char *)(void *)0 };
// sr
// file scan_scr.c line 25
static struct scan_result sr;
// stdscr
// file /usr/include/curses.h line 1395
extern struct _win_st *stdscr;
// w_about
// file about_scr.c line 23
static struct _win_st *w_about;
// w_aplst
// file scan_scr.c line 27
static struct _win_st *w_aplst;
// w_conf
// file conf_scr.c line 33
static struct _win_st *w_conf;
// w_confpad
// file conf_scr.c line 33
static struct _win_st *w_confpad;
// w_help
// file help_scr.c line 23
static struct _win_st *w_help;
// w_if
// file info_scr.c line 24
static struct _win_st *w_if;
// w_info
// file info_scr.c line 24
static struct _win_st *w_info;
// w_key
// file lhist_scr.c line 40
static struct _win_st *w_key;
// w_levels
// file info_scr.c line 24
static struct _win_st *w_levels;
// w_lhist
// file lhist_scr.c line 40
static struct _win_st *w_lhist;
// w_net
// file info_scr.c line 24
static struct _win_st *w_net;
// w_stats
// file info_scr.c line 24
static struct _win_st *w_stats;

// ack_handler
// file iw_nl80211.h line 261
static inline signed int ack_handler(struct nl_msg *msg, void *arg)
{
  signed int *ret = (signed int *)arg;
  *ret = 0;
  return 2;
}

// alloc_nl_mcast_sk
// file iw_nl80211.c line 710
extern struct nl_sock * alloc_nl_mcast_sk(const char *grp)
{
  signed int mcid;
  signed int ret;
  struct nl_sock *sk;
  sk=nl_socket_alloc();
  if(sk == ((struct nl_sock *)NULL))
    err_sys("failed to allocate netlink multicast socket");

  signed int return_value_genl_connect_1;
  return_value_genl_connect_1=genl_connect(sk);
  if(!(return_value_genl_connect_1 == 0))
    err_sys("failed to connect multicast socket to GeNetlink");

  mcid=nl_get_multicast_id(sk, "nl80211", grp);
  if(!(mcid >= 0))
    err_quit("failed to resolve nl80211 '%s' multicast group", grp);

  ret=nl_socket_add_membership(sk, mcid);
  if(!(ret == 0))
    err_sys("failed to join nl80211 multicast group %s", grp);

  return sk;
}

// arg2element
// file llist.c line 58
static struct chain * arg2element(char type, void ***ap, struct chain *next)
{
  struct chain *l;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct chain) /*24ul*/ );
  l = (struct chain *)return_value_malloc_1;
  void *return_value_malloc_2;
  void *return_value_malloc_3;
  char *return_value_gcc_builtin_va_arg_4;
  char *return_value_strdup_5;
  void *return_value_malloc_6;
  switch((signed int)type)
  {
    case 100:
    {
      return_value_malloc_2=malloc(sizeof(signed int) /*4ul*/ );
      l->e = (void *)return_value_malloc_2;
      *((signed int *)l->e)=va_arg(*ap, __typeof__(*((signed int *)l->e)));
      break;
    }
    case 115:
    {
      return_value_malloc_3=malloc(sizeof(char *) /*8ul*/ );
      l->e = (void *)return_value_malloc_3;
      return_value_gcc_builtin_va_arg_4=va_arg(*ap, __typeof__(return_value_gcc_builtin_va_arg_4));
      return_value_strdup_5=strdup(return_value_gcc_builtin_va_arg_4);
      l->e = (void *)return_value_strdup_5;
      break;
    }
    case 102:
    {
      return_value_malloc_6=malloc(sizeof(double) /*8ul*/ );
      l->e = (void *)return_value_malloc_6;
      *((double *)l->e)=va_arg(*ap, __typeof__(*((double *)l->e)));
      break;
    }
    case 42:
      l->e=va_arg(*ap, __typeof__(l->e));
  }
  l->next = next;
  return l;
}

// argv_count
// file wavemon.h line 319
static inline unsigned long int argv_count(char **argv)
{
  signed int cnt = 0;
  /* assertion argv != ((void *)0) */
  assert(argv != (char **)(void *)0);
  char **tmp_post_1;
  do
  {
    tmp_post_1 = argv;
    argv = argv + 1l;
    if(*tmp_post_1 == ((char *)NULL))
      break;

    cnt = cnt + 1;
  }
  while((_Bool)1);
  return (unsigned long int)cnt;
}

// argv_count_link1
// file wavemon.h line 319
static inline unsigned long int argv_count_link1(char **argv_link1)
{
  signed int cnt_link1 = 0;
  /* assertion argv != ((void *)0) */
  assert(argv_link1 != (char **)(void *)0);
  char **tmp_post_1_link1;
  do
  {
    tmp_post_1_link1 = argv_link1;
    argv_link1 = argv_link1 + 1l;
    if(*tmp_post_1_link1 == ((char *)NULL))
      break;

    cnt_link1 = cnt_link1 + 1;
  }
  while((_Bool)1);
  return (unsigned long int)cnt_link1;
}

// argv_find
// file wavemon.h line 329
static inline signed int argv_find(char **argv, const char *what)
{
  signed int cnt;
  unsigned long int return_value_argv_count_1;
  return_value_argv_count_1=argv_count_link1(argv);
  cnt = (signed int)return_value_argv_count_1;
  signed int len;
  signed int argv_find__1__i;
  /* assertion what != ((void *)0) */
  assert(what != (const char *)(void *)0);
  argv_find__1__i = 0;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(what);
  len = (signed int)return_value_strlen_2;
  signed int return_value_strncasecmp_3;
  for( ; !(argv_find__1__i >= cnt); argv_find__1__i = argv_find__1__i + 1)
  {
    return_value_strncasecmp_3=strncasecmp(argv[(signed long int)argv_find__1__i], what, (unsigned long int)len);
    if(return_value_strncasecmp_3 == 0)
      return argv_find__1__i;

  }
  return -1;
}

// bit_count
// file utils.c line 71
unsigned char bit_count(unsigned int mask)
{
  unsigned char bits_set = (unsigned char)0;
  for( ; !(mask == 0u); bits_set = bits_set + 1)
    mask = mask & mask - (unsigned int)1;
  return bits_set;
}

// byte_units
// file wavemon.h line 379
static inline char * byte_units(const double bytes)
{
  static char result[256l];
  if(bytes >= 1.073742e+9)
    sprintf(result, "%0.2lf GiB", bytes / (double)(1 << 30));

  else
    if(bytes >= 1.048576e+6)
      sprintf(result, "%0.2lf MiB", bytes / (double)(1 << 20));

    else
      if(bytes >= 1024.000000)
        sprintf(result, "%0.2lf KiB", bytes / (double)(1 << 10));

      else
        sprintf(result, "%.0lf B", bytes);
  return result;
}

// change_item
// file conf_scr.c line 93
static void change_item(signed int inum, char sign)
{
  struct conf_item *item;
  void *return_value_ll_get_1;
  return_value_ll_get_1=ll_get(conf_items, (unsigned long int)inum);
  item = (struct conf_item *)return_value_ll_get_1;
  signed int tmp;
  unsigned long int return_value_argv_count_2;
  switch((signed int)item->type)
  {
    case t_int:
    {
      if((double)*item->v.i + item->inc * (double)sign <= item->max)
      {
        if((double)*item->v.i + item->inc * (double)sign >= item->min)
          *item->v.i = *item->v.i + (signed int)(item->inc * (double)sign);

      }

      goto __CPROVER_DUMP_L6;
    }
    case t_list:
    {
      *item->v.i = *item->v.i + (signed int)sign;
      return_value_argv_count_2=argv_count(item->list);
      tmp = (signed int)return_value_argv_count_2;
      if(*item->v.i >= tmp)
        *item->v.i = 0;

      else
        if(!(*item->v.i >= 0))
          *item->v.i = tmp - 1;

    }
    case t_sep:

    case t_func:
      ;
    default:

      __CPROVER_DUMP_L6:
        ;
  }
}

// channel_type_name
// file utils.c line 205
const char * channel_type_name(enum nl80211_channel_type channel_type)
{
  switch((signed int)channel_type)
  {
    case NL80211_CHAN_NO_HT:
      return "NO HT";
    case NL80211_CHAN_HT20:
      return "HT20";
    case NL80211_CHAN_HT40MINUS:
      return "HT40-";
    case NL80211_CHAN_HT40PLUS:
      return "HT40+";
    default:
      return "unknown";
  }
}

// channel_width_name
// file utils.c line 184
const char * channel_width_name(enum nl80211_chan_width width)
{
  switch((signed int)width)
  {
    case NL80211_CHAN_WIDTH_20_NOHT:
      return "20 MHz (no HT)";
    case NL80211_CHAN_WIDTH_20:
      return "20 MHz";
    case NL80211_CHAN_WIDTH_40:
      return "40 MHz";
    case NL80211_CHAN_WIDTH_80:
      return "80 MHz";
    case NL80211_CHAN_WIDTH_80P80:
      return "80+80 MHz";
    case NL80211_CHAN_WIDTH_160:
      return "160 MHz";
    default:
      return "unknown";
  }
}

// check_geometry
// file wavemon.c line 133
static void check_geometry(void)
{
  if(!(conf.check_geometry == 0) && (!(COLS >= 80) || !(LINES >= 26)))
    err_quit("need at least a screen of %ux%u, have only %ux%u", 2 + 9 + 3 + 1 + 8 + 3, 80, LINES, COLS);

}

// clamp
// file wavemon.h line 373
static inline signed int clamp(signed int val, signed int min, signed int max)
{
  return val < min ? min : (val > max ? max : val);
}

// clamp_link1
// file wavemon.h line 373
static inline signed int clamp_link1(signed int val_link1, signed int min_link1, signed int max_link1)
{
  return val_link1 < min_link1 ? min_link1 : (val_link1 > max_link1 ? max_link1 : val_link1);
}

// clear_scan_list
// file iw_scan.c line 304
static void clear_scan_list(struct scan_result *sr)
{
  pthread_mutex_lock(&sr->mutex);
  free_scan_list(sr->head);
  free((void *)sr->channel_stats);
  sr->head = (struct scan_entry *)(void *)0;
  sr->channel_stats = (struct cnt *)(void *)0;
  sr->msg[(signed long int)0] = (char)0;
  sr->max_essid_len = (unsigned short int)16;
  memset((void *)&sr->num, 0, sizeof(struct assorted_numbers) /*16ul*/ );
  pthread_mutex_unlock(&sr->mutex);
}

// cmp_chan
// file iw_scan.c line 52
static _Bool cmp_chan(struct scan_entry *a, struct scan_entry *b)
{
  signed int tmp_if_expr_3;
  _Bool return_value_cmp_essid_1;
  _Bool return_value_cmp_freq_2;
  if(a->freq == b->freq)
  {
    return_value_cmp_essid_1=cmp_essid(a, b);
    tmp_if_expr_3 = (signed int)return_value_cmp_essid_1;
  }

  else
  {
    return_value_cmp_freq_2=cmp_freq(a, b);
    tmp_if_expr_3 = (signed int)return_value_cmp_freq_2;
  }
  return (_Bool)tmp_if_expr_3;
}

// cmp_chan_sig
// file iw_scan.c line 58
static _Bool cmp_chan_sig(struct scan_entry *a, struct scan_entry *b)
{
  signed int tmp_if_expr_3;
  _Bool return_value_cmp_sig_1;
  _Bool return_value_cmp_chan_2;
  if(a->freq == b->freq)
  {
    return_value_cmp_sig_1=cmp_sig(a, b);
    tmp_if_expr_3 = (signed int)return_value_cmp_sig_1;
  }

  else
  {
    return_value_cmp_chan_2=cmp_chan(a, b);
    tmp_if_expr_3 = (signed int)return_value_cmp_chan_2;
  }
  return (_Bool)tmp_if_expr_3;
}

// cmp_cnt
// file iw_scan.c line 331
static signed int cmp_cnt(const void *a, const void *b)
{
  if(conf.scan_sort_asc == 0 && conf.scan_sort_order == 0)
    return ((struct cnt *)a)->count - ((struct cnt *)b)->count;

  else
    return ((struct cnt *)b)->count - ((struct cnt *)a)->count;
}

// cmp_essid
// file iw_scan.c line 37
static _Bool cmp_essid(struct scan_entry *a, struct scan_entry *b)
{
  signed int res;
  res=strncmp(a->essid, b->essid, (unsigned long int)32);
  signed int tmp_if_expr_4;
  signed int tmp_if_expr_3;
  _Bool return_value_cmp_sig_1;
  _Bool return_value_cmp_freq_2;
  if(res == 0)
  {
    if(a->freq == b->freq)
    {
      return_value_cmp_sig_1=cmp_sig(a, b);
      tmp_if_expr_3 = (signed int)return_value_cmp_sig_1;
    }

    else
    {
      return_value_cmp_freq_2=cmp_freq(a, b);
      tmp_if_expr_3 = (signed int)return_value_cmp_freq_2;
    }
    tmp_if_expr_4 = tmp_if_expr_3;
  }

  else
    tmp_if_expr_4 = (signed int)(res < 0);
  return (_Bool)tmp_if_expr_4;
}

// cmp_freq
// file iw_scan.c line 23
static _Bool cmp_freq(struct scan_entry *a, struct scan_entry *b)
{
  return a->freq < b->freq;
}

// cmp_key
// file iw_scan.c line 325
static signed int cmp_key(const void *a, const void *b)
{
  return ((struct cnt *)a)->val - ((struct cnt *)b)->val;
}

// cmp_mac
// file iw_scan.c line 46
static _Bool cmp_mac(struct scan_entry *a, struct scan_entry *b)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)&a->ap_addr, (const void *)&b->ap_addr, sizeof(struct ether_addr) /*6ul*/ );
  return return_value_memcmp_1 < 0;
}

// cmp_open
// file iw_scan.c line 64
static _Bool cmp_open(struct scan_entry *a, struct scan_entry *b)
{
  return (signed int)a->has_key < (signed int)b->has_key;
}

// cmp_open_sig
// file iw_scan.c line 70
static _Bool cmp_open_sig(struct scan_entry *a, struct scan_entry *b)
{
  signed int tmp_if_expr_3;
  _Bool return_value_cmp_sig_1;
  _Bool return_value_cmp_open_2;
  if(a->has_key == b->has_key)
  {
    return_value_cmp_sig_1=cmp_sig(a, b);
    tmp_if_expr_3 = (signed int)return_value_cmp_sig_1;
  }

  else
  {
    return_value_cmp_open_2=cmp_open(a, b);
    tmp_if_expr_3 = (signed int)return_value_cmp_open_2;
  }
  return (_Bool)tmp_if_expr_3;
}

// cmp_sig
// file iw_scan.c line 29
static _Bool cmp_sig(struct scan_entry *a, struct scan_entry *b)
{
  if(a->bss_signal == 0)
  {
    if(!(b->bss_signal == 0))
      goto __CPROVER_DUMP_L1;

    return (signed int)a->bss_signal_qual < (signed int)b->bss_signal_qual;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (signed int)a->bss_signal < (signed int)b->bss_signal;
  }
}

// compute_channel_stats
// file iw_scan.c line 341
static void compute_channel_stats(struct scan_result *sr)
{
  struct scan_entry *cur;
  struct cnt *bin;
  struct cnt key = { .val=0, .count=0 };
  unsigned long int n = (unsigned long int)0;
  if(!(sr->num.entries == 0))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)sr->num.entries, sizeof(struct cnt) /*8ul*/ );
    sr->channel_stats = (struct cnt *)return_value_calloc_1;
    cur = sr->head;
    for( ; !(cur == ((struct scan_entry *)NULL)); cur = cur->next)
      if(cur->chan >= 0)
      {
        key.val = cur->chan;
        void *return_value_lsearch_2;
        return_value_lsearch_2=lsearch((const void *)&key, (void *)sr->channel_stats, &n, sizeof(struct cnt) /*8ul*/ , cmp_key);
        bin = (struct cnt *)return_value_lsearch_2;
        if(!(bin == ((struct cnt *)NULL)))
          bin->count = bin->count + 1;

      }

    if(n >= 1ul)
      qsort((void *)sr->channel_stats, n, sizeof(struct cnt) /*8ul*/ , cmp_cnt);

    else
    {
      free((void *)sr->channel_stats);
      sr->channel_stats = (struct cnt *)(void *)0;
    }
    sr->num.ch_stats = n < (unsigned long int)3 ? n : (unsigned long int)3;
  }

}

// conf_get_interface_list
// file wavemon.h line 283
extern void conf_get_interface_list(void)
{
  char *old_if = (char *)(void *)0;
  signed int idx = 0;
  for( ; !(if_list[(signed long int)idx] == ((char *)NULL)); idx = idx + 1)
    if(idx == conf.if_idx)
      old_if = if_list[(signed long int)idx];

    else
      free((void *)if_list[(signed long int)idx]);
  iw_get_interface_list(if_list, (unsigned long int)64);
  if(if_list[0l] == ((char *)NULL))
    err_quit("no supported wireless interfaces found!");

  conf.if_idx = 0;
  if(!(old_if == ((char *)NULL)))
  {
    idx=argv_find(if_list, old_if);
    if(idx >= 1)
      conf.if_idx = idx;

    free((void *)old_if);
  }

}

// conf_ifname
// file wavemon.h line 282
extern const char * conf_ifname(void)
{
  _Bool tmp_if_expr_1;
  if(!(if_list[0l] == ((char *)NULL)))
    tmp_if_expr_1 = if_list[(signed long int)conf.if_idx] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  char *tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = if_list[(signed long int)conf.if_idx];

  else
    tmp_if_expr_2 = "(none)";
  return tmp_if_expr_2;
}

// cp_from_scale
// file wavemon.h line 265
static inline signed int cp_from_scale(float value, const signed char *cscale, _Bool reverse)
{
  enum colour_pair cp;
  if(value < (float)*cscale)
    cp = (enum colour_pair)(reverse != (_Bool)0 ? CP_SCALEHI : CP_SCALELOW);

  else
    if(value < (float)cscale[1l])
      cp = (enum colour_pair)CP_SCALEMID;

    else
      cp = (enum colour_pair)(reverse != (_Bool)0 ? CP_SCALELOW : CP_SCALEHI);
  return (signed int)((unsigned long int)cp << 0 + 8);
}

// curtail
// file ui.c line 81
extern const char * curtail(const char *str, const char *sep, signed int len)
{
  const char fallback_sep[2l] = { 126, 0 };
  signed int l = 0;
  signed int front;
  signed int mid;
  signed int back;
  if((unsigned long int)len >= sizeof(char [128l]) /*128ul*/ )
    len = (signed int)(sizeof(char [128l]) /*128ul*/  - (unsigned long int)1);

  _Bool tmp_if_expr_1;
  if(sep == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*sep == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    sep = fallback_sep;

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(sep);
  mid = (signed int)return_value_strlen_2;
  if(!(len >= mid))
  {
    sep = fallback_sep;
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(sep);
    mid = (signed int)return_value_strlen_3;
  }

  unsigned long int return_value_strlen_4;
  if(!(str == ((const char *)NULL)))
  {
    return_value_strlen_4=strlen(str);
    l = (signed int)return_value_strlen_4;
  }

  if(len >= l)
    return str;

  else
  {
    front = (signed int)((double)(len - mid) / 2.0 + 0.5);
    back = (len - front) - mid;
    static char out_buf[128l];
    strncpy(out_buf, str, (unsigned long int)front);
    strncpy(out_buf + (signed long int)front, sep, (unsigned long int)mid);
    strncpy(out_buf + (signed long int)front + (signed long int)mid, (str + (signed long int)l) - (signed long int)back, (unsigned long int)(back + 1));
    return out_buf;
  }
}

// dbm2mw
// file utils.c line 138
double dbm2mw(const double in)
{
  double return_value_pow_1;
  return_value_pow_1=pow(10.0, in / 10.0);
  return return_value_pow_1;
}

// dbm2units
// file utils.c line 143
char * dbm2units(const double in)
{
  double val;
  val=dbm2mw(in);
  static char with_units[256l];
  if(val < 0.00000001)
    sprintf(with_units, "%.2f pW", val * 1e9);

  else
    if(val < 0.00001)
      sprintf(with_units, "%.2f nW", val * 1e6);

    else
      if(val < 0.01)
        sprintf(with_units, "%.2f uW", val * 1e3);

      else
        sprintf(with_units, "%.2f mW", val);
  return with_units;
}

// dbm_to_u8
// file utils.c line 132
unsigned char dbm_to_u8(const signed int dbm)
{
  return (unsigned char)(dbm < 0 ? dbm + 0x100 : dbm);
}

// dfs_domain_name
// file utils.c line 247
const char * dfs_domain_name(enum nl80211_dfs_regions region)
{
  switch((signed int)region)
  {
    case NL80211_DFS_UNSET:
      return "DFS-UNSET";
    case NL80211_DFS_FCC:
      return "DFS-FCC";
    case NL80211_DFS_ETSI:
      return "DFS-ETSI";
    case NL80211_DFS_JP:
      return "DFS-JP";
    default:
      return "DFS-invalid";
  }
}

// display_aplist
// file scan_scr.c line 91
static void display_aplist(struct _win_st *w_aplst)
{
  char s[256l];
  const char *sort_type[7l] = { "Chan", "Sig", "Mac", "Essid", "Open", "Ch/Sg", "Op/Sg" };
  signed int display_aplist__1__i;
  signed int col;
  signed int line = 2;
  struct scan_entry *cur;
  signed int return_value_pthread_mutex_trylock_1;
  return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&sr.mutex);
  _Bool tmp_if_expr_2;
  _Bool return_value_str_is_ascii_3;
  if(return_value_pthread_mutex_trylock_1 == 0)
  {
    if(!(sr.head == ((struct scan_entry *)NULL)))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = sr.msg[0l] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      display_aplist__1__i = 1;
      for( ; LINES + -1 + -2 >= display_aplist__1__i; display_aplist__1__i = display_aplist__1__i + 1)
        mvwclrtoborder(w_aplst, display_aplist__1__i, 1);
    }

    if(sr.head == ((struct scan_entry *)NULL))
      waddstr_center(w_aplst, (LINES - 1) / 2 - 1, sr.msg);

    sort_scan_list(&sr.head);
    cur = sr.head;
    for( ; !(cur == ((struct scan_entry *)NULL)) && !(line >= LINES + -1 + -2); cur = cur->next)
    {
      col = CP_SCAN_NON_AP;
      if(!((3 & (signed int)cur->bss_capa) == 0))
      {
        if(!((1 & (signed int)cur->bss_capa) == 0))
          col = cur->has_key != 0 ? CP_SCAN_CRYPT : CP_SCAN_UNENC;

      }

      wmove(w_aplst, line, 1);
      if(cur->essid[0l] == 0)
      {
        sprintf(s, "%-*s ", sr.max_essid_len, (const void *)"<hidden ESSID>");
        wattr_on(w_aplst, (unsigned long int)((unsigned long int)col << 0 + 8), (void *)0);
        waddnstr(w_aplst, s, -1);
      }

      else
      {
        return_value_str_is_ascii_3=str_is_ascii(cur->essid);
        if(!(return_value_str_is_ascii_3 == (_Bool)0))
        {
          sprintf(s, "%-*s ", sr.max_essid_len, (const void *)cur->essid);
          waddstr_b_link1(w_aplst, s);
          wattr_on(w_aplst, (unsigned long int)((unsigned long int)col << 0 + 8), (void *)0);
        }

        else
        {
          sprintf(s, "%-*s ", sr.max_essid_len, (const void *)"<cryptic ESSID>");
          wattr_on(w_aplst, (unsigned long int)((unsigned long int)col << 0 + 8), (void *)0);
          waddnstr(w_aplst, s, -1);
        }
      }
      char *return_value_ether_addr_4;
      return_value_ether_addr_4=ether_addr(&cur->ap_addr);
      waddnstr(w_aplst, return_value_ether_addr_4, -1);
      wattr_off(w_aplst, (unsigned long int)((unsigned long int)col << 0 + 8), (void *)0);
      fmt_scan_entry(cur, s, sizeof(char [256l]) /*256ul*/ );
      waddnstr(w_aplst, " ", -1);
      waddnstr(w_aplst, s, -1);
      line = line + 1;
    }
    if((signed int)sr.num.entries >= 3)
    {
      wmove(w_aplst, (LINES - 1) - 2, 1);
      wadd_attr_str(w_aplst, (const signed int)((unsigned long int)1UL << 10 + 8), "total:");
      sprintf(s, " %d ", sr.num.entries);
      waddnstr(w_aplst, s, -1);
      sprintf(s, "%s %ssc", sort_type[(signed long int)conf.scan_sort_order], conf.scan_sort_asc != 0 ? "a" : "de");
      wadd_attr_str(w_aplst, (const signed int)((unsigned long int)1UL << 10 + 8), s);
      if(!(line >= 2 + (signed int)sr.num.entries))
      {
        sprintf(s, ", %d not shown", ((signed int)sr.num.entries + 2) - line);
        waddnstr(w_aplst, s, -1);
      }

      if(!(sr.num.open == 0))
      {
        sprintf(s, ", %d open", sr.num.open);
        waddnstr(w_aplst, s, -1);
      }

      if(!(sr.num.five_gig == 0) && !(sr.num.two_gig == 0))
      {
        waddch(w_aplst, (const unsigned long int)32);
        wadd_attr_str(w_aplst, (const signed int)((unsigned long int)1UL << 10 + 8), "5/2GHz:");
        sprintf(s, " %d/%d", sr.num.five_gig, sr.num.two_gig);
        waddnstr(w_aplst, s, -1);
      }

      if(!(sr.channel_stats == ((struct cnt *)NULL)))
      {
        waddch(w_aplst, (const unsigned long int)32);
        if(conf.scan_sort_asc == 0 && conf.scan_sort_order == 0)
          sprintf(s, "bottom-%d:", (signed int)sr.num.ch_stats);

        else
          sprintf(s, "top-%d:", (signed int)sr.num.ch_stats);
        wadd_attr_str(w_aplst, (const signed int)((unsigned long int)1UL << 10 + 8), s);
        display_aplist__1__i = 0;
        for( ; !((unsigned long int)display_aplist__1__i >= sr.num.ch_stats); display_aplist__1__i = display_aplist__1__i + 1)
        {
          waddnstr(w_aplst, display_aplist__1__i != 0 ? ", " : " ", -1);
          sprintf(s, "ch#%d", (sr.channel_stats + (signed long int)display_aplist__1__i)->val);
          wadd_attr_str(w_aplst, (const signed int)((unsigned long int)1UL << 13 + 8), s);
          sprintf(s, " (%d)", (sr.channel_stats + (signed long int)display_aplist__1__i)->count);
          waddnstr(w_aplst, s, -1);
        }
      }

    }


  done:
    ;
    pthread_mutex_unlock(&sr.mutex);
    wrefresh(w_aplst);
  }

}

// display_info
// file info_scr.c line 238
static void display_info(struct _win_st *w_if, struct _win_st *w_info)
{
  struct iw_dyn_info info;
  struct iw_nl80211_ifstat ifs;
  struct iw_nl80211_reg ir;
  char tmp[256l];
  signed int display_info__1__i;
  const char *return_value_conf_ifname_1;
  return_value_conf_ifname_1=conf_ifname();
  dyn_info_get(&info, return_value_conf_ifname_1, &range);
  iw_nl80211_getifstat(&ifs);
  iw_nl80211_getreg(&ir);
  wmove(w_if, 1, 1);
  const char *return_value_conf_ifname_2;
  return_value_conf_ifname_2=conf_ifname();
  waddstr_b_link2(w_if, return_value_conf_ifname_2);
  const char *return_value_format_wpa_3;
  if(!((3u & range.enc_capa) == 0u))
  {
    return_value_format_wpa_3=format_wpa(&range);
    sprintf(tmp, " (%s, %s)", (const void *)info.name, return_value_format_wpa_3);
  }

  else
    sprintf(tmp, " (%s)", (const void *)info.name);
  waddnstr(w_if, tmp, -1);
  waddnstr(w_if, ", phy ", -1);
  sprintf(tmp, "%d", ifs.phy);
  waddstr_b_link2(w_if, tmp);
  waddnstr(w_if, ", reg: ", -1);
  if(ir.region >= 1)
  {
    waddstr_b_link2(w_if, ir.country);
    const char *return_value_dfs_domain_name_4;
    return_value_dfs_domain_name_4=dfs_domain_name((enum nl80211_dfs_regions)ir.region);
    sprintf(tmp, " (%s)", return_value_dfs_domain_name_4);
    waddnstr(w_if, tmp, -1);
  }

  else
    waddstr_b_link2(w_if, "n/a");
  if(!(ifs.ssid[0l] == 0))
  {
    waddnstr(w_if, ", SSID: ", -1);
    waddstr_b_link2(w_if, ifs.ssid);
  }

  wclrtoborder(w_if);
  wrefresh(w_if);
  wmove(w_info, 1, 1);
  waddnstr(w_info, "mode: ", -1);
  const char *return_value_iftype_name_5;
  return_value_iftype_name_5=iftype_name((enum nl80211_iftype)ifs.iftype);
  waddstr_b_link2(w_info, return_value_iftype_name_5);
  _Bool return_value_ether_addr_is_zero_8;
  return_value_ether_addr_is_zero_8=ether_addr_is_zero(&ls.bssid);
  if(return_value_ether_addr_is_zero_8 == (_Bool)0)
  {
    waddstr_b_link2(w_info, ", ");
    switch(ls.status)
    {
      case (unsigned int)1:
      {
        waddnstr(w_info, "connected to: ", -1);
        break;
      }
      case (unsigned int)0:
      {
        waddnstr(w_info, "authenticated with: ", -1);
        break;
      }
      case (unsigned int)2:
      {
        waddnstr(w_info, "joined IBSS: ", -1);
        break;
      }
      default:
        waddnstr(w_info, "station: ", -1);
    }
    char *return_value_ether_lookup_6;
    return_value_ether_lookup_6=ether_lookup(&ls.bssid);
    waddstr_b_link2(w_info, return_value_ether_lookup_6);
    if(ls.status == 1u)
    {
      waddstr_b_link2(w_info, ",");
      waddnstr(w_info, " time: ", -1);
      const char *return_value_pretty_time_7;
      return_value_pretty_time_7=pretty_time(ls.connected_time);
      waddstr_b_link2(w_info, return_value_pretty_time_7);
      waddnstr(w_info, ", inactive: ", -1);
      sprintf(tmp, "%.1fs", (double)(float)ls.inactive_time / 1e3);
      waddstr_b_link2(w_info, tmp);
    }

  }

  wclrtoborder(w_info);
  wmove(w_info, 2, 1);
  _Bool return_value_iw_nl80211_have_survey_data_12;
  if(!(ifs.freq == 0u))
  {
    waddnstr(w_info, "freq: ", -1);
    sprintf(tmp, "%d MHz", ifs.freq);
    waddstr_b_link2(w_info, tmp);
    if(!(ls.survey.freq == 0u) && !(ls.survey.freq == ifs.freq))
    {
      sprintf(tmp, " [survey freq: %d MHz]", ls.survey.freq);
      waddnstr(w_info, tmp, -1);
    }

    if(!(ifs.freq_ctr1 == 0) && !((unsigned int)ifs.freq_ctr1 == ifs.freq))
    {
      waddnstr(w_info, ", ctr1: ", -1);
      sprintf(tmp, "%d MHz", ifs.freq_ctr1);
      waddstr_b_link2(w_info, tmp);
    }

    if(!(ifs.freq_ctr2 == 0) && !(ifs.freq_ctr2 == ifs.freq_ctr1) && !((unsigned int)ifs.freq_ctr2 == ifs.freq))
    {
      waddnstr(w_info, ", ctr2: ", -1);
      sprintf(tmp, "%d MHz", ifs.freq_ctr2);
      waddstr_b_link2(w_info, tmp);
    }

    waddnstr(w_info, ", channel: ", -1);
    signed int return_value_ieee80211_frequency_to_channel_9;
    return_value_ieee80211_frequency_to_channel_9=ieee80211_frequency_to_channel((signed int)ifs.freq);
    sprintf(tmp, "%d", return_value_ieee80211_frequency_to_channel_9);
    waddstr_b_link2(w_info, tmp);
    if(ifs.chan_width >= 0)
    {
      const char *return_value_channel_width_name_10;
      return_value_channel_width_name_10=channel_width_name((enum nl80211_chan_width)ifs.chan_width);
      sprintf(tmp, " (width: %s)", return_value_channel_width_name_10);
      waddnstr(w_info, tmp, -1);
    }

    else
      if(ifs.chan_type >= 0)
      {
        const char *return_value_channel_type_name_11;
        return_value_channel_type_name_11=channel_type_name((enum nl80211_channel_type)ifs.chan_type);
        sprintf(tmp, " (%s)", return_value_channel_type_name_11);
        waddnstr(w_info, tmp, -1);
      }

  }

  else
  {
    return_value_iw_nl80211_have_survey_data_12=iw_nl80211_have_survey_data(&ls);
    if(!(return_value_iw_nl80211_have_survey_data_12 == (_Bool)0))
    {
      waddnstr(w_info, "freq: ", -1);
      sprintf(tmp, "%d MHz", ls.survey.freq);
      waddstr_b_link2(w_info, tmp);
    }

    else
      waddnstr(w_info, "frequency/channel: n/a", -1);
  }
  wclrtoborder(w_info);
  wmove(w_info, 3, 1);
  _Bool return_value_iw_nl80211_have_survey_data_19;
  return_value_iw_nl80211_have_survey_data_19=iw_nl80211_have_survey_data(&ls);
  if(!(return_value_iw_nl80211_have_survey_data_19 == (_Bool)0))
  {
    waddnstr(w_info, "channel ", -1);
    waddnstr(w_info, "active: ", -1);
    const char *return_value_pretty_time_ms_13;
    return_value_pretty_time_ms_13=pretty_time_ms((const unsigned int)ls.survey.time.active);
    waddstr_b_link2(w_info, return_value_pretty_time_ms_13);
    waddnstr(w_info, ", busy: ", -1);
    const char *return_value_pretty_time_ms_14;
    return_value_pretty_time_ms_14=pretty_time_ms((const unsigned int)ls.survey.time.busy);
    waddstr_b_link2(w_info, return_value_pretty_time_ms_14);
    if(!(ls.survey.time.ext_busy == 0ul))
    {
      waddnstr(w_info, ", ext-busy: ", -1);
      const char *return_value_pretty_time_ms_15;
      return_value_pretty_time_ms_15=pretty_time_ms((const unsigned int)ls.survey.time.ext_busy);
      waddstr_b_link2(w_info, return_value_pretty_time_ms_15);
    }

    waddnstr(w_info, ", rx: ", -1);
    const char *return_value_pretty_time_ms_16;
    return_value_pretty_time_ms_16=pretty_time_ms((const unsigned int)ls.survey.time.rx);
    waddstr_b_link2(w_info, return_value_pretty_time_ms_16);
    waddnstr(w_info, ", tx: ", -1);
    const char *return_value_pretty_time_ms_17;
    return_value_pretty_time_ms_17=pretty_time_ms((const unsigned int)ls.survey.time.tx);
    waddstr_b_link2(w_info, return_value_pretty_time_ms_17);
    if(!(ls.survey.time.scan == 0ul))
    {
      waddnstr(w_info, ", scan: ", -1);
      const char *return_value_pretty_time_ms_18;
      return_value_pretty_time_ms_18=pretty_time_ms((const unsigned int)ls.survey.time.scan);
      waddstr_b_link2(w_info, return_value_pretty_time_ms_18);
    }

  }

  else
    if(!(ls.tx_bitrate[0l] == 0))
    {
      if(!(ls.rx_bitrate[0l] == 0))
      {
        waddnstr(w_info, "rx rate: ", -1);
        waddstr_b_link2(w_info, ls.rx_bitrate);
        if(!(ls.expected_thru == 0u))
        {
          if(ls.expected_thru >= 1024u)
            sprintf(tmp, " (exp: %.1f MB/s)", (double)ls.expected_thru / 1024.0);

          else
            sprintf(tmp, " (exp: %u kB/s)", ls.expected_thru);
          waddnstr(w_info, tmp, -1);
        }

        waddnstr(w_info, ", tx rate: ", -1);
        waddstr_b_link2(w_info, ls.tx_bitrate);
      }

    }

  wmove(w_info, 4, 1);
  if(!(ls.beacons == 0ul))
  {
    waddnstr(w_info, "beacons: ", -1);
    sprintf(tmp, "%'llu", (unsigned long long int)ls.beacons);
    waddstr_b_link2(w_info, tmp);
    if(!(ls.beacon_loss == 0u))
    {
      waddnstr(w_info, ", lost: ", -1);
      sprintf(tmp, "%'u", ls.beacon_loss);
      waddstr_b_link2(w_info, tmp);
    }

    waddnstr(w_info, ", avg sig: ", -1);
    sprintf(tmp, "%d dBm", (signed char)ls.beacon_avg_sig);
    waddstr_b_link2(w_info, tmp);
    waddnstr(w_info, ", interval: ", -1);
    sprintf(tmp, "%.1fs", ((double)ls.beacon_int * 1024.0) / 1e6);
    waddstr_b_link2(w_info, tmp);
    waddnstr(w_info, ", DTIM: ", -1);
    sprintf(tmp, "%u", ls.dtim_period);
    waddstr_b_link2(w_info, tmp);
  }

  else
  {
    waddnstr(w_info, "station flags:", -1);
    if(!(ls.cts_protection == 0))
      waddstr_b_link2(w_info, " CTS");

    if(!(ls.wme == 0))
      waddstr_b_link2(w_info, " WME");

    if(!(ls.tdls == 0))
      waddstr_b_link2(w_info, " TDLS");

    if(!(ls.mfp == 0))
      waddstr_b_link2(w_info, " MFP");

    if(((signed int)ls.cts_protection | (signed int)ls.mfp | (signed int)ls.tdls | (signed int)ls.wme) == 0)
      waddstr_b_link2(w_info, " (none)");

    waddnstr(w_info, ", preamble:", -1);
    if(!(ls.long_preamble == 0))
      waddstr_b_link2(w_info, " long");

    else
      waddstr_b_link2(w_info, " short");
    waddnstr(w_info, ", slot:", -1);
    if(!(ls.short_slot_time == 0))
      waddstr_b_link2(w_info, " short");

    else
      waddstr_b_link2(w_info, " long");
  }
  if(!(info.cap_sens == 0))
  {
    waddnstr(w_info, ",  sensitivity: ", -1);
    if(!(info.sens >= 0))
      sprintf(tmp, "%d dBm", info.sens);

    else
      sprintf(tmp, "%d/%d", info.sens, range.sensitivity);
    waddstr_b_link2(w_info, tmp);
  }

  wclrtoborder(w_info);
  wmove(w_info, 5, 1);
  waddnstr(w_info, "power mgt: ", -1);
  char *return_value_format_power_20;
  if(!(info.cap_power == 0))
  {
    return_value_format_power_20=format_power(&info.power, &range);
    waddstr_b_link2(w_info, return_value_format_power_20);
  }

  else
    waddnstr(w_info, "n/a", -1);
  if(!(info.txpower.disabled == 0) && !(info.cap_txpower == 0))
    waddnstr(w_info, ",  tx-power: off", -1);

  else
    if(!(info.cap_txpower == 0))
    {
      if(!(info.txpower.fixed == 0))
        waddnstr(w_info, ",  tx-power: ", -1);

      else
        waddnstr(w_info, ",  TX-power: ", -1);
      char *return_value_format_txpower_21;
      return_value_format_txpower_21=format_txpower(&info.txpower);
      waddstr_b_link2(w_info, return_value_format_txpower_21);
    }

  wclrtoborder(w_info);
  wmove(w_info, 6, 1);
  waddnstr(w_info, "retry: ", -1);
  char *return_value_format_retry_22;
  if(!(info.cap_retry == 0))
  {
    return_value_format_retry_22=format_retry(&info.retry, &range);
    waddstr_b_link2(w_info, return_value_format_retry_22);
  }

  else
    waddnstr(w_info, "n/a", -1);
  waddnstr(w_info, ",  ", -1);
  if(!(info.cap_rts == 0))
  {
    waddnstr(w_info, info.rts.fixed != 0 ? "rts/cts: " : "RTS/cts: ", -1);
    if(!(info.rts.disabled == 0))
      sprintf(tmp, "off");

    else
      sprintf(tmp, "%d B", info.rts.value);
    waddstr_b_link2(w_info, tmp);
  }

  else
    waddnstr(w_info, "rts/cts: n/a", -1);
  waddnstr(w_info, ",  ", -1);
  if(!(info.cap_frag == 0))
  {
    waddnstr(w_info, info.frag.fixed != 0 ? "frag: " : "Frag: ", -1);
    if(!(info.frag.disabled == 0))
      sprintf(tmp, "off");

    else
      sprintf(tmp, "%d B", info.frag.value);
    waddstr_b_link2(w_info, tmp);
  }

  else
    waddnstr(w_info, "frag: n/a", -1);
  wclrtoborder(w_info);
  wmove(w_info, 7, 1);
  waddnstr(w_info, "encryption: ", -1);
  unsigned char return_value_dyn_info_wep_keys_31;
  unsigned char tmp_post_27;
  _Bool tmp_if_expr_26;
  signed int return_value_sprintf_28;
  signed int return_value_sprintf_29;
  signed int return_value_sprintf_30;
  _Bool return_value_has_net_admin_capability_32;
  if(!(info.keys == ((struct iw_key *)NULL)))
  {
    signed int cnt;
    unsigned char return_value_dyn_info_active_keys_23;
    return_value_dyn_info_active_keys_23=dyn_info_active_keys(&info);
    cnt = (signed int)return_value_dyn_info_active_keys_23;
    if(cnt == 0)
      waddstr_b_link2(w_info, "off (no key set)");

    else
      if(!(info.active_key == 0))
      {
        display_info__1__i = (signed int)info.active_key - 1;
        char *return_value_format_key_24;
        return_value_format_key_24=format_key(info.keys + (signed long int)display_info__1__i);
        const char *return_value_curtail_25;
        return_value_curtail_25=curtail(return_value_format_key_24, "..", (COLS - 2) / 2);
        waddstr_b_link2(w_info, return_value_curtail_25);
        if(!((0x4000 & (signed int)(info.keys + (signed long int)display_info__1__i)->flags) == 0))
          waddnstr(w_info, ", restricted", -1);

        if(!((0x2000 & (signed int)(info.keys + (signed long int)display_info__1__i)->flags) == 0))
          waddnstr(w_info, ", open", -1);

        if(cnt >= 2 || !((signed int)info.active_key == 1))
        {
          sprintf(tmp, " [%d]", info.active_key);
          waddstr_b_link2(w_info, tmp);
        }

        if(cnt >= 2)
        {
          sprintf(tmp, " (%d other key%s)", cnt - 1, cnt == 2 ? "" : "s");
          waddnstr(w_info, tmp, -1);
        }

      }

      else
      {
        return_value_dyn_info_wep_keys_31=dyn_info_wep_keys(&info);
        if((signed int)return_value_dyn_info_wep_keys_31 == cnt)
        {
          waddstr_b_link2(w_info, "off ");
          sprintf(tmp, "(%d disabled WEP key%s)", cnt, cnt == 1 ? "" : "s");
          waddnstr(w_info, tmp, -1);
        }

        else
        {
          unsigned char display_info__1__19__4__j = (unsigned char)0;
          unsigned char k = (unsigned char)0;
          while((_Bool)1)
          {
            if(!((info.keys + (signed long int)display_info__1__19__4__j)->size == 0))
            {
              if((0x8000 & (signed int)(info.keys + (signed long int)display_info__1__19__4__j)->flags) == 0)
              {
                tmp_post_27 = k;
                k = k + 1;
                (info.keys + (signed long int)tmp_post_27)->size = (info.keys + (signed long int)display_info__1__19__4__j)->size;
              }

            }

            if(!((signed int)k >= cnt))
            {
              display_info__1__19__4__j = display_info__1__19__4__j + 1;
              tmp_if_expr_26 = (signed int)display_info__1__19__4__j < (signed int)info.nkeys ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_26 = (_Bool)0;
            if(!tmp_if_expr_26)
              break;

          }
          if(cnt == 1)
          {
            return_value_sprintf_28=sprintf(tmp, "1 key (index #%u), ", (signed int)display_info__1__19__4__j + 1);
            display_info__1__19__4__j = (unsigned char)return_value_sprintf_28;
          }

          else
          {
            return_value_sprintf_29=sprintf(tmp, "%d keys with ", k);
            display_info__1__19__4__j = (unsigned char)return_value_sprintf_29;
          }
          display_info__1__i = 0;
          for( ; !(display_info__1__i >= (signed int)k); display_info__1__i = display_info__1__i + 1)
          {
            return_value_sprintf_30=sprintf(tmp + (signed long int)display_info__1__19__4__j, "%s%d", display_info__1__i != 0 ? "/" : "", (signed int)(info.keys + (signed long int)display_info__1__i)->size * 8);
            display_info__1__19__4__j = display_info__1__19__4__j + (unsigned char)return_value_sprintf_30;
          }
          sprintf(tmp + (signed long int)display_info__1__19__4__j, " bits");
          waddstr_b_link2(w_info, tmp);
        }
      }
  }

  else
  {
    return_value_has_net_admin_capability_32=has_net_admin_capability();
    if(!(return_value_has_net_admin_capability_32 == (_Bool)0))
      waddnstr(w_info, "no information available", -1);

    else
      waddnstr(w_info, "n/a (requires CAP_NET_ADMIN permissions)", -1);
  }
  dyn_info_cleanup(&info);
  wclrtoborder(w_info);
  wrefresh(w_info);
}

// display_key
// file lhist_scr.c line 291
static void display_key(struct _win_st *w_key)
{
  wmove(w_key, 1, 1);
  wclrtoborder(w_key);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STANDARD << 0 + 8);
    0;
  }

  else
    -1;
  waddch(w_key, (const unsigned long int)91);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STATSIG << 0 + 8);
    0;
  }

  else
    -1;
  waddch(w_key, acs_map[(signed long int)(unsigned char)113]);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STANDARD << 0 + 8);
    0;
  }

  else
    -1;
  char *return_value_fmt_extrema_1;
  return_value_fmt_extrema_1=fmt_extrema(&e_signal, "dBm");
  wprintw(w_key, "] sig lvl (%s)  [", return_value_fmt_extrema_1);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STATNOISE << 0 + 8);
    0;
  }

  else
    -1;
  waddch(w_key, acs_map[(signed long int)(unsigned char)113]);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STANDARD << 0 + 8);
    0;
  }

  else
    -1;
  char *return_value_fmt_extrema_2;
  return_value_fmt_extrema_2=fmt_extrema(&e_noise, "dBm");
  wprintw(w_key, "] ns lvl (%s)  [", return_value_fmt_extrema_2);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STATSNR << 0 + 8);
    0;
  }

  else
    -1;
  waddch(w_key, (const unsigned long int)32);
  if(!(w_key == ((struct _win_st *)NULL)))
  {
    w_key->_attrs = (unsigned long int)((unsigned long int)CP_STANDARD << 0 + 8);
    0;
  }

  else
    -1;
  char *return_value_fmt_extrema_3;
  return_value_fmt_extrema_3=fmt_extrema(&e_snr, "dB");
  wprintw(w_key, "] S-N ratio (%s)", return_value_fmt_extrema_3);
  wrefresh(w_key);
}

// display_levels
// file info_scr.c line 50
static void display_levels(void)
{
  signed char nscale[2l] = { (signed char)conf.noise_min, (signed char)conf.noise_max };
  signed char lvlscale[2l] = { (signed char)-40, (signed char)-20 };
  char tmp[256l];
  signed int line;
  _Bool noise_data_valid;
  noise_data_valid=iw_nl80211_have_survey_data(&ls);
  signed int sig_qual = -1;
  signed int sig_qual_max;
  signed int sig_level = (_Bool)(signed int)ls.signal_avg ? (signed int)ls.signal_avg : (signed int)ls.signal;
  if(sig_level == 0)
    sig_level = (signed int)ls.bss_signal;

  line = 1;
  for( ; !(line >= 10); line = line + 1)
    mvwclrtoborder(w_levels, line, 1);
  if(!(ls.bss_signal_qual == 0))
  {
    sig_qual = (signed int)ls.bss_signal_qual;
    sig_qual_max = 100;
  }

  else
    if(!(sig_level == 0))
    {
      if(!(sig_level >= -110))
        sig_qual = 0;

      else
        if(sig_level >= -39)
          sig_qual = 70;

        else
          sig_qual = sig_level + 110;
      sig_qual_max = 70;
    }

  signed int tmp_post_2;
  signed int tmp_post_4;
  signed int tmp_post_6;
  signed int tmp_post_10;
  signed int tmp_post_13;
  signed int tmp_post_15;
  if(noise_data_valid == (_Bool)0 && sig_level == 0 && sig_qual == -1)
  {
    wattr_on(w_levels, (unsigned long int)((unsigned long int)1UL << 13 + 8), (void *)0);
    waddstr_center(w_levels, (9 + 1) / 2, "NO INTERFACE DATA");
  }

  else
  {
    line = 1;
    if(noise_data_valid == (_Bool)0)
      line = line + 1;

    if(sig_qual == -1)
      line = line + 1;

    else
    {
      double return_value_ewma_1;
      static float qual;
      return_value_ewma_1=ewma((double)qual, (double)sig_qual, (double)conf.meter_decay / 100.0);
      qual = (float)return_value_ewma_1;
      tmp_post_2 = line;
      line = line + 1;
      signed int return_value_wmove_3;
      return_value_wmove_3=wmove(w_levels, tmp_post_2, 1);
      if(return_value_wmove_3 == -1)
        -1;

      else
        waddnstr(w_levels, "link quality: ", -1);
      sprintf(tmp, "%0.f%%  ", (1e2 * (double)qual) / (double)sig_qual_max);
      waddstr_b_link2(w_levels, tmp);
      sprintf(tmp, "(%0.f/%d)  ", qual, sig_qual_max);
      waddnstr(w_levels, tmp, -1);
      tmp_post_4 = line;
      line = line + 1;
      waddbar(w_levels, tmp_post_4, qual, (float)0, (float)sig_qual_max, lvlscale, (_Bool)1);
    }
    line = line + 1;
    if(noise_data_valid == (_Bool)0)
      line = line + 1;

    if(!(sig_level == 0))
    {
      double return_value_ewma_5;
      static float signal;
      return_value_ewma_5=ewma((double)signal, (double)sig_level, (double)conf.meter_decay / 100.0);
      signal = (float)return_value_ewma_5;
      tmp_post_6 = line;
      line = line + 1;
      signed int return_value_wmove_7;
      return_value_wmove_7=wmove(w_levels, tmp_post_6, 1);
      if(return_value_wmove_7 == -1)
        -1;

      else
        waddnstr(w_levels, "signal level: ", -1);
      char *return_value_dbm2units_8;
      return_value_dbm2units_8=dbm2units((const double)signal);
      sprintf(tmp, "%.0f dBm (%s)", signal, return_value_dbm2units_8);
      waddstr_b_link2(w_levels, tmp);
      waddbar(w_levels, line, signal, (float)conf.sig_min, (float)conf.sig_max, lvlscale, (_Bool)1);
      if(!(conf.lthreshold_action == 0))
        waddthreshold(w_levels, line, signal, (float)conf.lthreshold, (float)conf.sig_min, (float)conf.sig_max, lvlscale, (unsigned long int)62);

      if(!(conf.hthreshold_action == 0))
        waddthreshold(w_levels, line, signal, (float)conf.hthreshold, (float)conf.sig_min, (float)conf.sig_max, lvlscale, (unsigned long int)60);

    }

    line = line + 1;
    if(!(noise_data_valid == (_Bool)0))
    {
      double return_value_ewma_9;
      static float noise;
      return_value_ewma_9=ewma((double)noise, (double)ls.survey.noise, (double)conf.meter_decay / 100.0);
      noise = (float)return_value_ewma_9;
      tmp_post_10 = line;
      line = line + 1;
      signed int return_value_wmove_11;
      return_value_wmove_11=wmove(w_levels, tmp_post_10, 1);
      if(return_value_wmove_11 == -1)
        -1;

      else
        waddnstr(w_levels, "noise level:  ", -1);
      char *return_value_dbm2units_12;
      return_value_dbm2units_12=dbm2units((const double)noise);
      sprintf(tmp, "%.0f dBm (%s)", noise, return_value_dbm2units_12);
      waddstr_b_link2(w_levels, tmp);
      tmp_post_13 = line;
      line = line + 1;
      waddbar(w_levels, tmp_post_13, noise, (float)conf.noise_min, (float)conf.noise_max, nscale, (_Bool)0);
    }

    if(!(sig_level == 0) && !(noise_data_valid == (_Bool)0))
    {
      double return_value_ewma_14;
      static float ssnr;
      return_value_ewma_14=ewma((double)ssnr, (double)(sig_level - (signed int)ls.survey.noise), (double)conf.meter_decay / 100.0);
      ssnr = (float)return_value_ewma_14;
      tmp_post_15 = line;
      line = line + 1;
      signed int return_value_wmove_16;
      return_value_wmove_16=wmove(w_levels, tmp_post_15, 1);
      if(return_value_wmove_16 == -1)
        -1;

      else
        waddnstr(w_levels, "SNR:           ", -1);
      sprintf(tmp, "%.0f dB", ssnr);
      waddstr_b_link2(w_levels, tmp);
    }

  }

done_levels:
  ;
  wrefresh(w_levels);
}

// display_lhist
// file lhist_scr.c line 224
static void display_lhist(void)
{
  struct iw_levelstat iwl;
  double snr_level;
  double noise_level;
  double sig_level;
  enum colour_pair plot_colour;
  signed int x;
  signed int y;
  x = 1;
  signed int return_value_hist_y_1;
  signed int return_value_hist_x_2;
  signed int return_value_wmove_3;
  signed int return_value_clamp_4;
  signed int return_value_hist_y_5;
  signed int return_value_hist_x_6;
  signed int return_value_wmove_7;
  for( ; COLS + -2 >= x; x = x + 1)
  {
    iwl=iw_cache_get((const unsigned int)x);
    if(!(w_lhist == ((struct _win_st *)NULL)))
    {
      w_lhist->_attrs = (unsigned long int)((unsigned long int)CP_STATBKG << 0 + 8);
      0;
    }

    else
      -1;
    y = 1;
    for( ; LINES + -1 + -3 + -1 >= y; y = y + 1)
    {
      return_value_hist_y_1=hist_y(y);
      return_value_hist_x_2=hist_x(x);
      return_value_wmove_3=wmove(w_lhist, return_value_hist_y_1, return_value_hist_x_2);
      if(return_value_wmove_3 == -1)
        -1;

      else
        waddch(w_lhist, (const unsigned long int)(y % 5 != 0 ? 32 : 45));
    }
    if(!((96 & (signed int)iwl.flags) == 0))
      snr_level = (double)0;

    else
    {
      snr_level=hist_level((double)(iwl.signal - iwl.noise), conf.sig_min - conf.noise_max, conf.sig_max - conf.noise_min);
      if(!(w_lhist == ((struct _win_st *)NULL)))
      {
        w_lhist->_attrs = (unsigned long int)((unsigned long int)CP_STATSNR << 0 + 8);
        0;
      }

      else
        -1;
      y = 1;
      do
      {
        return_value_clamp_4=clamp_link1((signed int)snr_level, 1, ((LINES - 1) - 3) - 1);
        if(!(return_value_clamp_4 >= y))
          break;

        return_value_hist_y_5=hist_y(y);
        return_value_hist_x_6=hist_x(x);
        return_value_wmove_7=wmove(w_lhist, return_value_hist_y_5, return_value_hist_x_6);
        if(return_value_wmove_7 == -1)
          -1;

        else
          waddch(w_lhist, (const unsigned long int)32);
        y = y + 1;
      }
      while((_Bool)1);
    }
    if((0x40 & (signed int)iwl.flags) == 0)
    {
      noise_level=hist_level((double)iwl.noise, conf.noise_min, conf.noise_max);
      plot_colour = (enum colour_pair)(noise_level > snr_level ? CP_STATNOISE : CP_STATNOISE_S);
      hist_plot(noise_level, x, plot_colour);
    }

    else
      if((0x20 & (signed int)iwl.flags) == 0 && x == 5)
      {
        char tmp[6l];
        signed int len;
        if(!(w_lhist == ((struct _win_st *)NULL)))
        {
          w_lhist->_attrs = (unsigned long int)((unsigned long int)CP_STATSIG << 0 + 8);
          0;
        }

        else
          -1;
        y = 1;
        for( ; LINES + -1 + -3 + -1 >= y; y = y + 1)
          if(y % 5 == 0 || y == LINES + -1 + -3 + -1 || y == 1)
          {
            double return_value_hist_level_inverse_8;
            return_value_hist_level_inverse_8=hist_level_inverse(y, conf.sig_min, conf.sig_max);
            len=snprintf(tmp, sizeof(char [6l]) /*6ul*/ , "%.0f", return_value_hist_level_inverse_8);
            signed int return_value_hist_y_9;
            return_value_hist_y_9=hist_y(y);
            signed int return_value_hist_x_10;
            return_value_hist_x_10=hist_x(len);
            signed int return_value_wmove_11;
            return_value_wmove_11=wmove(w_lhist, return_value_hist_y_9, return_value_hist_x_10);
            if(return_value_wmove_11 == -1)
              -1;

            else
              waddnstr(w_lhist, tmp, -1);
          }

      }

    if((0x20 & (signed int)iwl.flags) == 0)
    {
      sig_level=hist_level((double)iwl.signal, conf.sig_min, conf.sig_max);
      plot_colour = (enum colour_pair)(sig_level > snr_level ? CP_STATSIG : CP_STATSIG_S);
      hist_plot(sig_level, x, plot_colour);
    }

  }
  wrefresh(w_lhist);
}

// display_netinfo
// file info_scr.c line 580
static void display_netinfo(struct _win_st *w_net)
{
  struct if_info info;
  char tmp[64l];
  const char *return_value_conf_ifname_1;
  return_value_conf_ifname_1=conf_ifname();
  if_getinf(return_value_conf_ifname_1, &info);
  wmove(w_net, 1, 1);
  wclrtoborder(w_net);
  signed int tmp_if_expr_3;
  if(!(w_net == ((struct _win_st *)NULL)))
    tmp_if_expr_3 = (signed int)w_net->_maxy + 1;

  else
    tmp_if_expr_3 = -1;
  if(tmp_if_expr_3 == 5)
  {
    const char *return_value_conf_ifname_2;
    return_value_conf_ifname_2=conf_ifname();
    waddnstr(w_net, return_value_conf_ifname_2, -1);
    waddstr_b_link2(w_net, " (");
    waddnstr(w_net, ((signed int)info.flags & 1) != 0 ? "UP" : "DOWN", -1);
    if(!((64 & (signed int)info.flags) == 0))
      waddnstr(w_net, " RUNNING", -1);

    if(!((65536 & (signed int)info.flags) == 0))
      waddnstr(w_net, " LOWER_UP", -1);

    if(!((131072 & (signed int)info.flags) == 0))
      waddnstr(w_net, " DORMANT", -1);

    if(!((1024 & (signed int)info.flags) == 0))
      waddnstr(w_net, " MASTER", -1);

    if(!((2048 & (signed int)info.flags) == 0))
      waddnstr(w_net, " SLAVE", -1);

    if(!((16 & (signed int)info.flags) == 0))
      waddnstr(w_net, " POINTOPOINT", -1);

    if(!((32768 & (signed int)info.flags) == 0))
      waddnstr(w_net, " DYNAMIC", -1);

    if(!((2 & (signed int)info.flags) == 0))
      waddnstr(w_net, " BROADCAST", -1);

    if(!((4096 & (signed int)info.flags) == 0))
      waddnstr(w_net, " MULTICAST", -1);

    if(!((512 & (signed int)info.flags) == 0))
      waddnstr(w_net, " ALLMULTI", -1);

    if(!((128 & (signed int)info.flags) == 0))
      waddnstr(w_net, " NOARP", -1);

    if(!((32 & (signed int)info.flags) == 0))
      waddnstr(w_net, " NOTRAILERS", -1);

    if(!((256 & (signed int)info.flags) == 0))
      waddnstr(w_net, " PROMISC", -1);

    if(!((4 & (signed int)info.flags) == 0))
      waddnstr(w_net, " DEBUG", -1);

    waddstr_b_link2(w_net, ")");
    wmove(w_net, 2, 1);
    wclrtoborder(w_net);
  }

  waddnstr(w_net, "mac: ", -1);
  char *return_value_ether_lookup_4;
  return_value_ether_lookup_4=ether_lookup(&info.hwaddr);
  waddstr_b_link2(w_net, return_value_ether_lookup_4);
  signed int tmp_if_expr_5;
  if(!(w_net == ((struct _win_st *)NULL)))
    tmp_if_expr_5 = (signed int)w_net->_maxy + 1;

  else
    tmp_if_expr_5 = -1;
  if(tmp_if_expr_5 == 5)
  {
    waddnstr(w_net, ", qlen: ", -1);
    sprintf(tmp, "%u", info.txqlen);
    waddstr_b_link2(w_net, tmp);
    wmove(w_net, 3, 1);
    wclrtoborder(w_net);
  }

  else
    waddnstr(w_net, ", ", -1);
  waddnstr(w_net, "ip: ", -1);
  if(info.addr.s_addr == 0u)
    waddnstr(w_net, "n/a", -1);

  else
  {
    char *return_value_inet_ntoa_6;
    return_value_inet_ntoa_6=inet_ntoa(info.addr);
    unsigned char return_value_prefix_len_7;
    return_value_prefix_len_7=prefix_len(&info.netmask);
    sprintf(tmp, "%s/%u", return_value_inet_ntoa_6, return_value_prefix_len_7);
    waddstr_b_link2(w_net, tmp);
    if(!(info.bcast.s_addr == (~info.netmask.s_addr | info.addr.s_addr)))
    {
      waddnstr(w_net, ",  bcast: ", -1);
      char *return_value_inet_ntoa_8;
      return_value_inet_ntoa_8=inet_ntoa(info.bcast);
      waddstr_b_link2(w_net, return_value_inet_ntoa_8);
    }

  }
  if(!(info.mtu == 0) && !((signed int)info.mtu == 1500))
  {
    waddnstr(w_net, ",  mtu: ", -1);
    sprintf(tmp, "%u", info.mtu);
    waddstr_b_link2(w_net, tmp);
  }

  wrefresh(w_net);
}

// display_stats
// file info_scr.c line 162
static void display_stats(void)
{
  struct if_stat nstat;
  char tmp[256l];
  const char *return_value_conf_ifname_1;
  return_value_conf_ifname_1=conf_ifname();
  if_getstat(return_value_conf_ifname_1, &nstat);
  signed int return_value_wmove_2;
  return_value_wmove_2=wmove(w_stats, 1, 1);
  if(return_value_wmove_2 == -1)
    -1;

  else
    waddnstr(w_stats, "RX: ", -1);
  if(!(ls.rx_packets == 0u))
  {
    char *return_value_byte_units_3;
    return_value_byte_units_3=byte_units((const double)ls.rx_bytes);
    sprintf(tmp, "%'u (%s)", ls.rx_packets, return_value_byte_units_3);
    waddstr_b_link2(w_stats, tmp);
  }

  else
    waddnstr(w_stats, "n/a", -1);
  _Bool return_value_iw_nl80211_have_survey_data_4;
  return_value_iw_nl80211_have_survey_data_4=iw_nl80211_have_survey_data(&ls);
  if(!(return_value_iw_nl80211_have_survey_data_4 == (_Bool)0))
  {
    if(!(ls.rx_bitrate[0l] == 0))
    {
      waddnstr(w_stats, ", rate: ", -1);
      waddstr_b_link2(w_stats, ls.rx_bitrate);
    }

    if(!(ls.expected_thru == 0u))
    {
      if(ls.expected_thru >= 1024u)
        sprintf(tmp, " (exp: %.1f MB/s)", (double)ls.expected_thru / 1024.0);

      else
        sprintf(tmp, " (exp: %u kB/s)", ls.expected_thru);
      waddnstr(w_stats, tmp, -1);
    }

  }

  if(!(ls.rx_drop_misc == 0ul))
  {
    waddnstr(w_stats, ", drop: ", -1);
    sprintf(tmp, "%'llu", (unsigned long long int)ls.rx_drop_misc);
    waddstr_b_link2(w_stats, tmp);
  }

  wclrtoborder(w_stats);
  signed int return_value_wmove_5;
  return_value_wmove_5=wmove(w_stats, 2, 1);
  if(return_value_wmove_5 == -1)
    -1;

  else
    waddnstr(w_stats, "TX: ", -1);
  if(!(ls.tx_packets == 0u))
  {
    char *return_value_byte_units_6;
    return_value_byte_units_6=byte_units((const double)ls.tx_bytes);
    sprintf(tmp, "%'u (%s)", ls.tx_packets, return_value_byte_units_6);
    waddstr_b_link2(w_stats, tmp);
  }

  else
    waddnstr(w_stats, "n/a", -1);
  _Bool return_value_iw_nl80211_have_survey_data_7;
  return_value_iw_nl80211_have_survey_data_7=iw_nl80211_have_survey_data(&ls);
  if(!(return_value_iw_nl80211_have_survey_data_7 == (_Bool)0))
  {
    if(!(ls.tx_bitrate[0l] == 0))
    {
      waddnstr(w_stats, ", rate: ", -1);
      waddstr_b_link2(w_stats, ls.tx_bitrate);
    }

  }

  if(!(ls.tx_retries == 0u))
  {
    waddnstr(w_stats, ", retries: ", -1);
    sprintf(tmp, "%'u", ls.tx_retries);
    waddstr_b_link2(w_stats, tmp);
  }

  if(!(ls.tx_failed == 0u))
  {
    waddnstr(w_stats, ", failed: ", -1);
    sprintf(tmp, "%'u", ls.tx_failed);
    waddstr_b_link2(w_stats, tmp);
  }

  wclrtoborder(w_stats);
  wrefresh(w_stats);
}

// do_scan
// file iw_if.h line 296
extern void * do_scan(void *sr_ptr)
{
  struct scan_result *do_scan__1__sr = (struct scan_result *)sr_ptr;
  struct anonymous_10 blockmask;
  signed int ret = 0;
  sigemptyset(&blockmask);
  sigaddset(&blockmask, 28);
  pthread_sigmask(0, &blockmask, (struct anonymous_10 *)(void *)0);
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_detach(return_value_pthread_self_1);
  _Bool return_value_wait_for_scan_events_6;
  _Bool return_value_has_net_admin_capability_7;
  const char *return_value_conf_ifname_12;
  _Bool return_value_if_is_up_13;
  const char *return_value_conf_ifname_8;
  const char *return_value_conf_ifname_10;
  signed int return_value_if_set_up_11;
  const char *return_value_conf_ifname_9;
  signed int return_value_usleep_2;
  do
  {
    clear_scan_list(do_scan__1__sr);
    ret=iw_nl80211_scan_trigger();
    switch(-ret)
    {
      case 0:

      case 16:
      {
        return_value_wait_for_scan_events_6=wait_for_scan_events(do_scan__1__sr);
        if(return_value_wait_for_scan_events_6 == (_Bool)0)
          snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "Waiting for scan data...");

        else
        {
          pthread_mutex_lock(&do_scan__1__sr->mutex);
          ret=iw_nl80211_get_scan_data(do_scan__1__sr);
          if(!(ret >= 0))
          {
            const char *return_value_conf_ifname_3;
            return_value_conf_ifname_3=conf_ifname();
            char *return_value_strerror_4;
            return_value_strerror_4=strerror(-ret);
            snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "Scan failed on %s: %s", return_value_conf_ifname_3, return_value_strerror_4);
          }

          else
            if(do_scan__1__sr->head == ((struct scan_entry *)NULL))
            {
              const char *return_value_conf_ifname_5;
              return_value_conf_ifname_5=conf_ifname();
              snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "Empty scan results on %s", return_value_conf_ifname_5);
            }

          compute_channel_stats(do_scan__1__sr);
          pthread_mutex_unlock(&do_scan__1__sr->mutex);
        }
        break;
      }
      case 1:
      {
        return_value_has_net_admin_capability_7=has_net_admin_capability();
        if(return_value_has_net_admin_capability_7 == (_Bool)0)
          snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "This screen requires CAP_NET_ADMIN permissions");

        return (void *)0;
      }
      case 14:

      case 4:

      case 11:
      {
        snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "Waiting for device to become ready ...");
        break;
      }
      case 100:
      {
        return_value_conf_ifname_12=conf_ifname();
        return_value_if_is_up_13=if_is_up(return_value_conf_ifname_12);
        if(return_value_if_is_up_13 != (_Bool)0)
          goto __CPROVER_DUMP_L12;

        return_value_conf_ifname_8=conf_ifname();
        snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "Interface %s is down - setting it up ...", return_value_conf_ifname_8);
        return_value_conf_ifname_10=conf_ifname();
        return_value_if_set_up_11=if_set_up(return_value_conf_ifname_10);
        if(!(return_value_if_set_up_11 >= 0))
        {
          return_value_conf_ifname_9=conf_ifname();
          err_sys("Can not bring up interface '%s'", return_value_conf_ifname_9);
        }

        break;
      }
      default:
      {

      __CPROVER_DUMP_L12:
        ;
        const char *return_value_conf_ifname_14;
        return_value_conf_ifname_14=conf_ifname();
        char *return_value_strerror_15;
        return_value_strerror_15=strerror(-ret);
        snprintf(do_scan__1__sr->msg, sizeof(char [128l]) /*128ul*/ , "Scan trigger failed on %s: %s", return_value_conf_ifname_14, return_value_strerror_15);
      }
    }
    return_value_usleep_2=usleep((unsigned int)(conf.stat_iv * 1000));
  }
  while(return_value_usleep_2 == 0);
  return (void *)0;
}

// dyn_info_active_keys
// file iw_if.h line 158
static inline unsigned char dyn_info_active_keys(struct iw_dyn_info *info)
{
  signed int dyn_info_active_keys__1__i;
  signed int num_active = 0;
  dyn_info_active_keys__1__i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(dyn_info_active_keys__1__i >= (signed int)info->nkeys); dyn_info_active_keys__1__i = dyn_info_active_keys__1__i + 1)
  {
    if(!((info->keys + (signed long int)dyn_info_active_keys__1__i)->size == 0))
      tmp_if_expr_1 = !(((signed int)(info->keys + (signed long int)dyn_info_active_keys__1__i)->flags & 0x8000) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    num_active = num_active + (signed int)tmp_if_expr_1;
  }
  return (unsigned char)num_active;
}

// dyn_info_cleanup
// file iw_if.h line 181
extern void dyn_info_cleanup(struct iw_dyn_info *info)
{
  if(!(info == ((struct iw_dyn_info *)NULL)))
    free((void *)info->keys);

}

// dyn_info_get
// file iw_if.h line 179
extern void dyn_info_get(struct iw_dyn_info *info, const char *ifname, struct iw_range *ir)
{
  struct iwreq iwr;
  signed int dyn_info_get__1__i;
  signed int skfd;
  skfd=socket(2, 2, 0);
  if(!(skfd >= 0))
    err_sys("%s: can not open socket", (const void *)"dyn_info_get");

  memset((void *)info, 0, sizeof(struct iw_dyn_info) /*176ul*/ );
  strncpy(iwr.ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(skfd, (unsigned long int)0x8B01, &iwr);
  if(!(return_value_ioctl_1 >= 0))
    err_sys("can not open device '%s'", ifname);

  strncpy(info->name, iwr.u.name, (unsigned long int)16);
  iwr.u.essid.pointer = (void *)(char *)info->essid;
  iwr.u.essid.length = (unsigned short int)sizeof(char [34l]) /*34ul*/ ;
  iwr.u.essid.flags = (unsigned short int)0;
  signed int return_value_ioctl_2;
  return_value_ioctl_2=ioctl(skfd, (unsigned long int)0x8B1B, &iwr);
  if(return_value_ioctl_2 >= 0)
  {
    info->cap_essid = (_Bool)1;
    info->essid_ct = (unsigned char)((_Bool)((signed int)iwr.u.essid.flags & 0x00FF) ? (signed int)iwr.u.essid.flags & 0x00FF : 1);
    info->essid[(signed long int)iwr.u.essid.length] = (char)0;
  }

  iwr.u.essid.pointer = (void *)(char *)info->nickname;
  iwr.u.essid.length = (unsigned short int)sizeof(char [34l]) /*34ul*/ ;
  iwr.u.essid.flags = (unsigned short int)0;
  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(skfd, (unsigned long int)0x8B1D, &iwr);
  if(return_value_ioctl_3 >= 0)
  {
    if((signed int)iwr.u.data.length >= 2)
      info->cap_nickname = (_Bool)1;

  }

  signed int return_value_ioctl_4;
  return_value_ioctl_4=ioctl(skfd, (unsigned long int)0x8B05, &iwr);
  if(return_value_ioctl_4 >= 0)
  {
    info->cap_freq = (_Bool)1;
    info->freq=freq_to_hz(&iwr.u.freq);
  }

  signed int return_value_ioctl_5;
  return_value_ioctl_5=ioctl(skfd, (unsigned long int)0x8B09, &iwr);
  if(return_value_ioctl_5 >= 0)
  {
    info->cap_sens = (_Bool)1;
    info->sens = iwr.u.sens.value;
  }

  signed int return_value_ioctl_6;
  return_value_ioctl_6=ioctl(skfd, (unsigned long int)0x8B21, &iwr);
  if(return_value_ioctl_6 >= 0)
    info->bitrate = (unsigned long int)iwr.u.bitrate.value;

  signed int return_value_ioctl_7;
  return_value_ioctl_7=ioctl(skfd, (unsigned long int)0x8B27, &iwr);
  if(return_value_ioctl_7 >= 0)
  {
    info->cap_txpower = (_Bool)1;
    memcpy((void *)&info->txpower, (const void *)&iwr.u.txpower, sizeof(struct iw_param) /*8ul*/ );
  }

  signed int return_value_ioctl_8;
  return_value_ioctl_8=ioctl(skfd, (unsigned long int)0x8B2D, &iwr);
  if(return_value_ioctl_8 >= 0)
  {
    info->cap_power = (_Bool)1;
    memcpy((void *)&info->power, (const void *)&iwr.u.power, sizeof(struct iw_param) /*8ul*/ );
  }

  signed int return_value_ioctl_9;
  return_value_ioctl_9=ioctl(skfd, (unsigned long int)0x8B29, &iwr);
  if(return_value_ioctl_9 >= 0)
  {
    info->cap_retry = (_Bool)1;
    memcpy((void *)&info->retry, (const void *)&iwr.u.retry, sizeof(struct iw_param) /*8ul*/ );
  }

  signed int return_value_ioctl_10;
  return_value_ioctl_10=ioctl(skfd, (unsigned long int)0x8B23, &iwr);
  if(return_value_ioctl_10 >= 0)
  {
    info->cap_rts = (_Bool)1;
    memcpy((void *)&info->rts, (const void *)&iwr.u.rts, sizeof(struct iw_param) /*8ul*/ );
  }

  signed int return_value_ioctl_11;
  return_value_ioctl_11=ioctl(skfd, (unsigned long int)0x8B25, &iwr);
  if(return_value_ioctl_11 >= 0)
  {
    info->cap_frag = (_Bool)1;
    memcpy((void *)&info->frag, (const void *)&iwr.u.frag, sizeof(struct iw_param) /*8ul*/ );
  }

  signed int return_value_ioctl_12;
  return_value_ioctl_12=ioctl(skfd, (unsigned long int)0x8B07, &iwr);
  if(return_value_ioctl_12 >= 0)
  {
    info->cap_mode = (_Bool)1;
    info->mode = (unsigned char)iwr.u.mode;
  }

  info->nkeys = ir->max_encoding_tokens;
  if(!(info->nkeys == 0))
  {
    void *return_value_calloc_13;
    return_value_calloc_13=calloc((unsigned long int)info->nkeys, sizeof(struct iw_key) /*68ul*/ );
    info->keys = (struct iw_key *)return_value_calloc_13;
    if(info->keys == ((struct iw_key *)NULL))
      err_sys("malloc(key array)");

    iwr.u.data.pointer = (void *)(info->keys + (signed long int)0)->key;
    iwr.u.data.length = (unsigned short int)sizeof(unsigned char [64l]) /*64ul*/ ;
    iwr.u.data.flags = (unsigned short int)0;
    signed int return_value_ioctl_14;
    return_value_ioctl_14=ioctl(skfd, (unsigned long int)0x8B2B, &iwr);
    if(!(return_value_ioctl_14 >= 0))
    {
      free((void *)info->keys);
      info->keys = (struct iw_key *)(void *)0;
      info->nkeys = (unsigned char)0;
    }

    else
      info->active_key = (unsigned char)((signed int)iwr.u.data.flags & 0x00FF);
  }

  dyn_info_get__1__i = 0;
  _Bool tmp_if_expr_16;
  for( ; !(dyn_info_get__1__i >= (signed int)info->nkeys); dyn_info_get__1__i = dyn_info_get__1__i + 1)
  {
    iwr.u.data.pointer = (void *)(info->keys + (signed long int)dyn_info_get__1__i)->key;
    iwr.u.data.length = (unsigned short int)sizeof(unsigned char [64l]) /*64ul*/ ;
    iwr.u.data.flags = (unsigned short int)(dyn_info_get__1__i + 1);
    signed int return_value_ioctl_15;
    return_value_ioctl_15=ioctl(skfd, (unsigned long int)0x8B2B, &iwr);
    if(!(return_value_ioctl_15 >= 0))
    {
      free((void *)info->keys);
      info->nkeys = (unsigned char)0;
      break;
    }

    (info->keys + (signed long int)dyn_info_get__1__i)->size = iwr.u.data.length;
    (info->keys + (signed long int)dyn_info_get__1__i)->flags = iwr.u.data.flags;
    if(1 + dyn_info_get__1__i == (signed int)info->active_key)
    {
      if((signed int)(info->keys + (signed long int)dyn_info_get__1__i)->size == 0)
        tmp_if_expr_16 = (_Bool)1;

      else
        tmp_if_expr_16 = ((signed int)(info->keys + (signed long int)dyn_info_get__1__i)->flags & 0x8000) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_16)
        info->active_key = (unsigned char)0;

    }

  }
  signed int return_value_ioctl_17;
  return_value_ioctl_17=ioctl(skfd, (unsigned long int)0x8B15, &iwr);
  if(return_value_ioctl_17 >= 0)
  {
    info->cap_ap = (_Bool)1;
    memcpy((void *)&info->ap_addr, (const void *)&iwr.u.ap_addr, sizeof(struct sockaddr) /*16ul*/ );
  }

  close(skfd);
}

// dyn_info_wep_keys
// file iw_if.h line 169
static inline unsigned char dyn_info_wep_keys(struct iw_dyn_info *info)
{
  signed int dyn_info_wep_keys__1__i;
  signed int num_wep = 0;
  dyn_info_wep_keys__1__i = 0;
  _Bool tmp_if_expr_1;
  for( ; !(dyn_info_wep_keys__1__i >= (signed int)info->nkeys); dyn_info_wep_keys__1__i = dyn_info_wep_keys__1__i + 1)
    if((0x8000 & (signed int)(info->keys + (signed long int)dyn_info_wep_keys__1__i)->flags) == 0)
    {
      if((signed int)(info->keys + (signed long int)dyn_info_wep_keys__1__i)->size == 5)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)(info->keys + (signed long int)dyn_info_wep_keys__1__i)->size == 13 ? (_Bool)1 : (_Bool)0;
      num_wep = num_wep + (signed int)tmp_if_expr_1;
    }

  return (unsigned char)num_wep;
}

// end_timer
// file timer.c line 38
extern _Bool end_timer(struct timer *t)
{
  unsigned long int return_value_get_usecs_1;
  return_value_get_usecs_1=get_usecs();
  return return_value_get_usecs_1 >= t->stime + t->duration;
}

// err_msg
// file error.c line 52
extern void err_msg(const char *format, ...)
{
  void **argp = (void **)&format;
  vwarnx(format, argp);
  argp = ((void **)NULL);
  sleep((unsigned int)1);
}

// err_quit
// file wavemon.h line 302
extern void err_quit(const char *format, ...)
{
  void **argp = (void **)&format;
  terminate_all_processes(format, 0, argp);
}

// err_sys
// file wavemon.h line 303
extern void err_sys(const char *format, ...)
{
  void **argp = (void **)&format;
  terminate_all_processes(format, 1, argp);
}

// error_handler
// file iw_nl80211.h line 246
static inline signed int error_handler(struct sockaddr_nl *nla, struct nlmsgerr *err, void *arg)
{
  signed int *ret = (signed int *)arg;
  *ret = err->error;
  return 2;
}

// ether_addr
// file utils.c line 26
char * ether_addr(struct ether_addr *ea)
{
  static char mac[18l];
  char *d = mac;
  char *a;
  a=ether_ntoa(ea);
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  char *tmp_post_1;
  char *tmp_post_4;
  signed int tmp_if_expr_7;
  signed int tmp_if_expr_5;
  signed int return_value_toupper_6;
  char *tmp_post_8;
  do
  {

  next_chunk:
    ;
    if((signed int)*a == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (signed int)a[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (signed int)a[(signed long int)1] == 58 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      tmp_post_1 = d;
      d = d + 1l;
      *tmp_post_1 = (char)48;
    }


  __CPROVER_DUMP_L6:
    ;
    tmp_post_4 = d;
    d = d + 1l;
    if(!(conf.cisco_mac == 0))
    {
      if((signed int)*a == 58)
        tmp_if_expr_5 = 46;

      else
        tmp_if_expr_5 = (signed int)*a;
      tmp_if_expr_7 = tmp_if_expr_5;
    }

    else
    {
      return_value_toupper_6=toupper((signed int)*a);
      tmp_if_expr_7 = return_value_toupper_6;
    }
    *tmp_post_4 = (char)tmp_if_expr_7;
    if(*tmp_post_4 == 0)
      goto __CPROVER_DUMP_L11;

    tmp_post_8 = a;
    a = a + 1l;
  }
  while((signed int)*tmp_post_8 == 58);
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L11:
  ;
  return mac;
}

// ether_addr_is_zero
// file utils.c line 18
_Bool ether_addr_is_zero(struct ether_addr *ea)
{
  signed int return_value_memcmp_1;
  static struct ether_addr zero = { .ether_addr_octet={ (unsigned char)0, 0, 0, 0, 0, 0 } };
  return_value_memcmp_1=memcmp((const void *)ea, (const void *)&zero, sizeof(struct ether_addr) /*6ul*/ );
  return return_value_memcmp_1 == 0;
}

// ether_lookup
// file utils.c line 40
char * ether_lookup(struct ether_addr *ea)
{
  signed int return_value_ether_ntohost_1;
  static char hostname[8192l];
  return_value_ether_ntohost_1=ether_ntohost(hostname, ea);
  if(return_value_ether_ntohost_1 == 0)
    return hostname;

  else
  {
    char *return_value_ether_addr_2;
    return_value_ether_addr_2=ether_addr(ea);
    return return_value_ether_addr_2;
  }
}

// ewma
// file wavemon.h line 401
static inline double ewma(double mavg, double sample, double weight)
{
  return IEEE_FLOAT_EQUAL(mavg, (double)0) ? sample : weight * mavg + (1.0 - weight) * sample;
}

// family_handler
// file iw_nl80211.c line 621
static signed int family_handler(struct nl_msg *msg, void *arg)
{
  struct handler_args *grp = (struct handler_args *)arg;
  struct nlattr *tb[8l];
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  struct nlattr *mcgrp;
  signed int rem_mcgrp;
  struct nlattr *return_value_genlmsg_attrdata_3;
  return_value_genlmsg_attrdata_3=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_4;
  return_value_genlmsg_attrlen_4=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb, 8 - 1, return_value_genlmsg_attrdata_3, return_value_genlmsg_attrlen_4, (struct nla_policy *)(void *)0);
  signed int return_value_nla_ok_6;
  _Bool tmp_if_expr_9;
  if(tb[7l] == ((struct nlattr *)NULL))
    return 1;

  else
  {
    void *return_value_nla_data_5;
    return_value_nla_data_5=nla_data(tb[(signed long int)7]);
    mcgrp = (struct nlattr *)return_value_nla_data_5;
    rem_mcgrp=nla_len(tb[(signed long int)7]);
    do
    {
      return_value_nla_ok_6=nla_ok(mcgrp, rem_mcgrp);
      if(return_value_nla_ok_6 == 0)
        break;

      struct nlattr *tb_mcgrp[3l];
      void *return_value_nla_data_7;
      return_value_nla_data_7=nla_data(mcgrp);
      signed int return_value_nla_len_8;
      return_value_nla_len_8=nla_len(mcgrp);
      nla_parse(tb_mcgrp, 3 - 1, (struct nlattr *)return_value_nla_data_7, return_value_nla_len_8, (struct nla_policy *)(void *)0);
      if(tb_mcgrp[1l] == ((struct nlattr *)NULL))
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = !(tb_mcgrp[(signed long int)2] != ((struct nlattr *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_9)
      {
        void *return_value_nla_data_10;
        return_value_nla_data_10=nla_data(tb_mcgrp[(signed long int)1]);
        signed int return_value_nla_len_11;
        return_value_nla_len_11=nla_len(tb_mcgrp[(signed long int)1]);
        signed int return_value_strncmp_12;
        return_value_strncmp_12=strncmp((const char *)return_value_nla_data_10, grp->group, (unsigned long int)return_value_nla_len_11);
        if(return_value_strncmp_12 == 0)
        {
          unsigned int return_value_nla_get_u32_13;
          return_value_nla_get_u32_13=nla_get_u32(tb_mcgrp[(signed long int)2]);
          grp->id = (signed int)return_value_nla_get_u32_13;
          break;
        }

      }

      mcgrp=nla_next(mcgrp, &rem_mcgrp);
    }
    while((_Bool)1);
    return 1;
  }
}

// finish_handler
// file iw_nl80211.h line 254
static inline signed int finish_handler(struct nl_msg *msg, void *arg)
{
  signed int *ret = (signed int *)arg;
  *ret = 0;
  return 1;
}

// fmt_extrema
// file lhist_scr.c line 68
static char * fmt_extrema(struct iw_extrema *ie, const char *unit)
{
  static char fmt_extrema__1__range[256l];
  if(ie->initialised == (_Bool)0)
    snprintf(fmt_extrema__1__range, sizeof(char [256l]) /*256ul*/ , "unknown");

  else
    if(IEEE_FLOAT_EQUAL(ie->min, ie->max))
      snprintf(fmt_extrema__1__range, sizeof(char [256l]) /*256ul*/ , "%+.0f %s", ie->min, unit);

    else
      snprintf(fmt_extrema__1__range, sizeof(char [256l]) /*256ul*/ , "%+.0f..%+.0f %s", ie->min, ie->max, unit);
  return fmt_extrema__1__range;
}

// fmt_scan_entry
// file scan_scr.c line 35
static void fmt_scan_entry(struct scan_entry *cur, char *buf, unsigned long int buflen)
{
  unsigned long int len = (unsigned long int)0;
  if(!(cur->bss_signal == 0))
  {
    float sig_qual;
    float sig_qual_max;
    if(!(cur->bss_signal_qual == 0))
    {
      sig_qual = (float)cur->bss_signal_qual;
      sig_qual_max = (float)100;
    }

    else
    {
      if(!((signed int)cur->bss_signal >= -110))
        sig_qual = (float)0;

      else
        if((signed int)cur->bss_signal >= -39)
          sig_qual = (float)70;

        else
          sig_qual = (float)((signed int)cur->bss_signal + 110);
      sig_qual_max = (float)70;
    }
    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(buf + (signed long int)len, buflen - len, "%3.0f%%, %d dBm", (1E2 * (double)sig_qual) / (double)sig_qual_max, cur->bss_signal);
    len = len + (unsigned long int)return_value_snprintf_1;
  }

  else
    if(!(cur->bss_signal_qual == 0))
    {
      signed int return_value_snprintf_2;
      return_value_snprintf_2=snprintf(buf + (signed long int)len, buflen - len, "%2d/%d", cur->bss_signal_qual, 100);
      len = len + (unsigned long int)return_value_snprintf_2;
    }

    else
    {
      signed int return_value_snprintf_3;
      return_value_snprintf_3=snprintf(buf + (signed long int)len, buflen - len, "? dBm");
      len = len + (unsigned long int)return_value_snprintf_3;
    }
  signed int return_value_snprintf_4;
  signed int return_value_snprintf_5;
  if(cur->chan >= 0)
  {
    return_value_snprintf_4=snprintf(buf + (signed long int)len, buflen - len, ", %s %3d, %d MHz", (double)cur->freq < 5e6 ? "ch" : "CH", cur->chan, cur->freq);
    len = len + (unsigned long int)return_value_snprintf_4;
  }

  else
  {
    return_value_snprintf_5=snprintf(buf + (signed long int)len, buflen - len, ", %g GHz", (double)cur->freq / 1e3);
    len = len + (unsigned long int)return_value_snprintf_5;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_snprintf_6;
  signed int return_value_snprintf_7;
  signed int return_value_snprintf_10;
  signed int return_value_snprintf_11;
  if(!((1 & (signed int)cur->bss_capa) == 0))
  {
    if(!(cur->bss_sta_count == 0))
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = (signed int)cur->bss_chan_usage > 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
    {
      if(!(cur->bss_sta_count == 0))
      {
        return_value_snprintf_6=snprintf(buf + (signed long int)len, buflen - len, " %u sta", cur->bss_sta_count);
        len = len + (unsigned long int)return_value_snprintf_6;
      }

      if((signed int)cur->bss_chan_usage >= 3)
      {
        return_value_snprintf_7=snprintf(buf + (signed long int)len, buflen - len, "%s %.0f%% chan", cur->bss_sta_count != 0 ? "," : "", (1e2 * (double)cur->bss_chan_usage) / 2.55e2);
        len = len + (unsigned long int)return_value_snprintf_7;
      }

    }

    else
    {
      signed int return_value_snprintf_8;
      return_value_snprintf_8=snprintf(buf + (signed long int)len, buflen - len, " ESS");
      len = len + (unsigned long int)return_value_snprintf_8;
    }
    if(!((4096 & (signed int)cur->bss_capa) == 0))
    {
      return_value_snprintf_10=snprintf(buf + (signed long int)len, buflen - len, ", Radio Measure");
      len = len + (unsigned long int)return_value_snprintf_10;
    }

    if(!((256 & (signed int)cur->bss_capa) == 0))
    {
      return_value_snprintf_11=snprintf(buf + (signed long int)len, buflen - len, ", Spectrum Mgmt");
      len = len + (unsigned long int)return_value_snprintf_11;
    }

  }

  else
    if(!((2 & (signed int)cur->bss_capa) == 0))
    {
      signed int return_value_snprintf_12;
      return_value_snprintf_12=snprintf(buf + (signed long int)len, buflen - len, " IBSS");
      len = len + (unsigned long int)return_value_snprintf_12;
    }

}

// format_bssid
// file utils.c line 58
char * format_bssid(struct sockaddr *ap)
{
  unsigned char bcast_addr[6l] = { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff };
  unsigned char zero_addr[6l] = { (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00 };
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)ap->sa_data, (const void *)zero_addr, (unsigned long int)6);
  if(return_value_memcmp_1 == 0)
    return "Not-Associated";

  else
  {
    signed int return_value_memcmp_2;
    return_value_memcmp_2=memcmp((const void *)ap->sa_data, (const void *)bcast_addr, (unsigned long int)6);
    if(return_value_memcmp_2 == 0)
      return "Invalid";

    else
    {
      char *return_value_mac_addr_3;
      return_value_mac_addr_3=mac_addr(ap);
      return return_value_mac_addr_3;
    }
  }
}

// format_enc_capab
// file iw_if.h line 461
static inline const char * format_enc_capab(const unsigned int capa, const char *sep)
{
  unsigned long int len = (unsigned long int)0;
  unsigned long int max = sizeof(char [32l]) /*32ul*/ ;
  signed int return_value_snprintf_1;
  static char buf[32l];
  if(!((1u & capa) == 0u))
  {
    return_value_snprintf_1=snprintf(buf, max, "WPA");
    len = (unsigned long int)return_value_snprintf_1;
  }

  signed int return_value_snprintf_2;
  if(!((2u & capa) == 0u))
  {
    return_value_snprintf_2=snprintf(buf + (signed long int)len, max - len, "%sWPA2", len != 0ul ? sep : "");
    len = len + (unsigned long int)return_value_snprintf_2;
  }

  signed int return_value_snprintf_3;
  if(!((4u & capa) == 0u))
  {
    return_value_snprintf_3=snprintf(buf + (signed long int)len, max - len, "%sTKIP", len != 0ul ? sep : "");
    len = len + (unsigned long int)return_value_snprintf_3;
  }

  signed int return_value_snprintf_4;
  if(!((8u & capa) == 0u))
  {
    return_value_snprintf_4=snprintf(buf + (signed long int)len, max - len, "%sCCMP", len != 0ul ? sep : "");
    len = len + (unsigned long int)return_value_snprintf_4;
  }

  buf[(signed long int)len] = (char)0;
  return buf;
}

// format_key
// file iw_if.h line 429
static inline char * format_key(struct iw_key * const iwk)
{
  signed int format_key__1__i;
  signed int is_printable = 0;
  signed int len = 0;
  _Bool tmp_if_expr_1;
  if(!(iwk == ((struct iw_key *)NULL)))
    tmp_if_expr_1 = (unsigned long int)((signed int)iwk->size * 3) < sizeof(char [128l]) /*128ul*/  ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion iwk != ((void *)0) && iwk->size * 3 < sizeof(buf) */
  assert(tmp_if_expr_1);
  format_key__1__i = 0;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  do
  {
    if(!(format_key__1__i >= (signed int)iwk->size))
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      is_printable = (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)iwk->key[(signed long int)format_key__1__i]] & (signed int)(unsigned short int)16384;
      tmp_if_expr_3 = is_printable != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    format_key__1__i = format_key__1__i + 1;
  }
  while((_Bool)1);
  signed int return_value_sprintf_4;
  static char buf[128l];
  if(!(is_printable == 0))
  {
    return_value_sprintf_4=sprintf(buf, "\"");
    len = len + return_value_sprintf_4;
  }

  format_key__1__i = 0;
  signed int return_value_sprintf_6;
  for( ; !(format_key__1__i >= (signed int)iwk->size); format_key__1__i = format_key__1__i + 1)
    if(!(is_printable == 0))
    {
      signed int return_value_sprintf_5;
      return_value_sprintf_5=sprintf(buf + (signed long int)len, "%c", iwk->key[(signed long int)format_key__1__i]);
      len = len + return_value_sprintf_5;
    }

    else
    {
      if((1 & format_key__1__i) == 0 && format_key__1__i >= 1)
      {
        return_value_sprintf_6=sprintf(buf + (signed long int)len, "-");
        len = len + return_value_sprintf_6;
      }

      signed int return_value_sprintf_7;
      return_value_sprintf_7=sprintf(buf + (signed long int)len, "%02X", iwk->key[(signed long int)format_key__1__i]);
      len = len + return_value_sprintf_7;
    }
  signed int return_value_sprintf_8;
  if(!(is_printable == 0))
  {
    return_value_sprintf_8=sprintf(buf + (signed long int)len, "\"");
    len = len + return_value_sprintf_8;
  }

  sprintf(buf + (signed long int)len, " (%u bits)", (signed int)iwk->size * 8);
  return buf;
}

// format_power
// file iw_if.h line 341
static inline char * format_power(struct iw_param *pwr, struct iw_range *range)
{
  double val = (double)pwr->value;
  signed int len = 0;
  if(!(pwr->disabled == 0))
    return "off";

  else
    if((signed int)pwr->flags == 0x0000)
      return "on";

  signed int return_value_snprintf_1;
  static char buf[128l];
  if(!((0x0001 & (signed int)pwr->flags) == 0))
  {
    return_value_snprintf_1=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "min ");
    len = len + return_value_snprintf_1;
  }

  signed int return_value_snprintf_2;
  if(!((0x0002 & (signed int)pwr->flags) == 0))
  {
    return_value_snprintf_2=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "max ");
    len = len + return_value_snprintf_2;
  }

  signed int return_value_snprintf_3;
  signed int return_value_snprintf_4;
  signed int return_value_snprintf_5;
  if(!((0x2000 & (signed int)pwr->flags) == 0))
  {
    return_value_snprintf_3=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "timeout ");
    len = len + return_value_snprintf_3;
  }

  else
    if(!((0x4000 & (signed int)pwr->flags) == 0))
    {
      return_value_snprintf_4=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "saving ");
      len = len + return_value_snprintf_4;
    }

    else
    {
      return_value_snprintf_5=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "period ");
      len = len + return_value_snprintf_5;
    }
  _Bool tmp_if_expr_11;
  if(!((0x0004 & (signed int)pwr->flags) == 0))
    tmp_if_expr_11 = (signed int)range->we_version_compiled < 21 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_11 = (_Bool)0;
  signed int return_value_snprintf_6;
  signed int return_value_snprintf_7;
  signed int return_value_snprintf_8;
  signed int return_value_snprintf_9;
  signed int return_value_snprintf_10;
  if(tmp_if_expr_11)
  {
    return_value_snprintf_6=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%+g", val / 1e6);
    len = len + return_value_snprintf_6;
  }

  else
    if(!((0x0004 & (signed int)pwr->flags) == 0))
    {
      return_value_snprintf_7=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%+g", val);
      len = len + return_value_snprintf_7;
    }

    else
      if(val > 1e6)
      {
        return_value_snprintf_8=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%g s", val / 1e6);
        len = len + return_value_snprintf_8;
      }

      else
        if(val > 1e3)
        {
          return_value_snprintf_9=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%g ms", val / 1e3);
          len = len + return_value_snprintf_9;
        }

        else
        {
          return_value_snprintf_10=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%g us", val);
          len = len + return_value_snprintf_10;
        }
  signed int return_value_snprintf_12;
  signed int return_value_snprintf_13;
  signed int return_value_snprintf_14;
  signed int return_value_snprintf_15;
  switch((signed int)pwr->flags & 0x0F00)
  {
    case 0x0100:
    {
      return_value_snprintf_12=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, ", rcv unicast");
      len = len + return_value_snprintf_12;
      break;
    }
    case 0x0200:
    {
      return_value_snprintf_13=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, ", rcv mcast");
      len = len + return_value_snprintf_13;
      break;
    }
    case 0x0300:
    {
      return_value_snprintf_14=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, ", rcv all");
      len = len + return_value_snprintf_14;
      break;
    }
    case 0x0400:
    {
      return_value_snprintf_15=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, ", force send");
      len = len + return_value_snprintf_15;
      break;
    }
    case 0x0800:
    {
      signed int return_value_snprintf_16;
      return_value_snprintf_16=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, ", repeat mcast");
      len = len + return_value_snprintf_16;
    }
  }
  return buf;
}

// format_retry
// file iw_if.h line 485
static inline char * format_retry(struct iw_param *retry, struct iw_range *range)
{
  double val = (double)retry->value;
  signed int len = 0;
  if(!(retry->disabled == 0))
    return "off";

  else
    if((signed int)retry->flags == 0x0000)
      return "on";

  signed int return_value_snprintf_1;
  static char buf[128l];
  if(!((0x0001 & (signed int)retry->flags) == 0))
  {
    return_value_snprintf_1=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "min ");
    len = len + return_value_snprintf_1;
  }

  signed int return_value_snprintf_2;
  if(!((0x0002 & (signed int)retry->flags) == 0))
  {
    return_value_snprintf_2=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "max ");
    len = len + return_value_snprintf_2;
  }

  signed int return_value_snprintf_3;
  if(!((0x0010 & (signed int)retry->flags) == 0))
  {
    return_value_snprintf_3=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "short ");
    len = len + return_value_snprintf_3;
  }

  signed int return_value_snprintf_4;
  if(!((0x0020 & (signed int)retry->flags) == 0))
  {
    return_value_snprintf_4=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "long ");
    len = len + return_value_snprintf_4;
  }

  signed int return_value_snprintf_5;
  if(!((0x2000 & (signed int)retry->flags) == 0))
  {
    return_value_snprintf_5=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "lifetime ");
    len = len + return_value_snprintf_5;
  }

  else
  {
    snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "limit %d", retry->value);
    return buf;
  }
  _Bool tmp_if_expr_11;
  if(!((0x0004 & (signed int)retry->flags) == 0))
    tmp_if_expr_11 = (signed int)range->we_version_compiled < 21 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_11 = (_Bool)0;
  signed int return_value_snprintf_6;
  signed int return_value_snprintf_7;
  signed int return_value_snprintf_8;
  signed int return_value_snprintf_9;
  signed int return_value_snprintf_10;
  if(tmp_if_expr_11)
  {
    return_value_snprintf_6=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%+g", val / 1e6);
    len = len + return_value_snprintf_6;
  }

  else
    if(!((0x0004 & (signed int)retry->flags) == 0))
    {
      return_value_snprintf_7=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%+g", val);
      len = len + return_value_snprintf_7;
    }

    else
      if(val > 1e6)
      {
        return_value_snprintf_8=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%g s", val / 1e6);
        len = len + return_value_snprintf_8;
      }

      else
        if(val > 1e3)
        {
          return_value_snprintf_9=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%g ms", val / 1e3);
          len = len + return_value_snprintf_9;
        }

        else
        {
          return_value_snprintf_10=snprintf(buf + (signed long int)len, sizeof(char [128l]) /*128ul*/  - (unsigned long int)len, "%g us", val);
          len = len + return_value_snprintf_10;
        }
  return buf;
}

// format_txpower
// file iw_if.h line 325
static inline char * format_txpower(struct iw_param *txpwr)
{
  double return_value_mw2dbm_1;
  double return_value_dbm2mw_2;
  static char txline[64l];
  if(!((0x0002 & (signed int)txpwr->flags) == 0))
    snprintf(txline, sizeof(char [64l]) /*64ul*/ , "%d (no units)", txpwr->value);

  else
    if(!((0x0001 & (signed int)txpwr->flags) == 0))
    {
      return_value_mw2dbm_1=mw2dbm((const double)txpwr->value);
      snprintf(txline, sizeof(char [64l]) /*64ul*/ , "%.0f dBm (%d mW)", return_value_mw2dbm_1, txpwr->value);
    }

    else
    {
      return_value_dbm2mw_2=dbm2mw((const double)txpwr->value);
      snprintf(txline, sizeof(char [64l]) /*64ul*/ , "%d dBm (%.2f mW)", txpwr->value, return_value_dbm2mw_2);
    }
  return txline;
}

// format_wpa
// file iw_if.h line 480
static inline const char * format_wpa(struct iw_range *ir)
{
  const char *return_value_format_enc_capab_1;
  return_value_format_enc_capab_1=format_enc_capab(ir->enc_capa & (unsigned int)(0x00000001 | 0x00000002), "/");
  return return_value_format_enc_capab_1;
}

// free_scan_list
// file iw_scan.c line 296
static void free_scan_list(struct scan_entry *head)
{
  if(!(head == ((struct scan_entry *)NULL)))
  {
    free_scan_list(head->next);
    free((void *)head);
  }

}

// freq_to_hz
// file iw_if.h line 397
static inline float freq_to_hz(struct iw_freq *freq)
{
  double return_value_pow_1;
  return_value_pow_1=pow((double)10, (double)freq->e);
  return (float)((double)freq->m * return_value_pow_1);
}

// get_confname
// file conf.c line 115
static char * get_confname(void)
{
  char *full_path;
  char *homedir;
  homedir=getenv("HOME");
  struct passwd *pw;
  if(homedir == ((char *)NULL))
  {
    unsigned int return_value_getuid_1;
    return_value_getuid_1=getuid();
    pw=getpwuid(return_value_getuid_1);
    if(pw == ((struct passwd *)NULL))
      err_quit("can not determine _HOME");

    homedir = pw->pw_dir;
  }

  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(homedir);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(".wavemonrc");
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)3);
  full_path = (char *)return_value_malloc_4;
  sprintf(full_path, "%s/%s", homedir, (const void *)".wavemonrc");
  return full_path;
}

// get_usecs
// file timer.c line 22
static unsigned long int get_usecs(void)
{
  struct timeval tv;
  struct timezone tz;
  gettimeofday(&tv, &tz);
  return (unsigned long int)(tv.tv_sec * (signed long int)1000000 + tv.tv_usec);
}

// getconf
// file wavemon.h line 152
extern void getconf(signed int argc, char **argv)
{
  signed int arg;
  signed int help = 0;
  signed int version = 0;
  conf_get_interface_list();
  init_conf_items();
  read_cf();
  do
  {
    arg=getopt(argc, argv, "ghi:v");
    if(!(arg >= 0))
      break;

    switch(arg)
    {
      case 103:
      {
        conf.check_geometry = 1;
        break;
      }
      case 104:
      {
        help = help + 1;
        break;
      }
      case 105:
      {
        conf.if_idx=argv_find(if_list, optarg);
        if(!(conf.if_idx >= 0))
          err_quit("no wireless extensions found on '%s'", optarg);

        break;
      }
      case 118:
      {
        version = version + 1;
        break;
      }
      default:
        exit(1);
    }
  }
  while((_Bool)1);
  if(!(version == 0))
  {
    printf("wavemon %s", (const void *)"0.8.0");
    const char *return_value_curses_version_1;
    return_value_curses_version_1=curses_version();
    printf(" with %s.\n", return_value_curses_version_1);
    printf("Distributed under the terms of the GPLv3.\n%s", help != 0 ? "\n" : "");
  }

  if(!(help == 0))
  {
    printf("usage: wavemon [ -hgv ] [ -i ifname ]\n");
    printf("  -g            Ensure screen is sufficiently dimensioned\n");
    printf("  -h            This help screen\n");
    printf("  -i <ifname>   Use specified network interface (default: auto)\n");
    printf("  -v            Print version number\n");
  }

  if(!(help == 0) || !(version == 0))
    exit(0);

}

// handle_cmd
// file iw_nl80211.c line 18
extern signed int handle_cmd(struct cmd *cmd)
{
  struct nl_cb *cb;
  struct nl_msg *msg;
  signed int ret;
  unsigned int ifindex;
  unsigned int idx;
  if(cmd->sk == ((struct nl_sock *)NULL))
  {
    cmd->sk=nl_socket_alloc();
    if(cmd->sk == ((struct nl_sock *)NULL))
      err_sys("failed to allocate netlink socket");

    signed int return_value_genl_connect_1;
    return_value_genl_connect_1=genl_connect(cmd->sk);
    if(!(return_value_genl_connect_1 == 0))
      err_sys("failed to connect to GeNetlink");

  }

  static signed int nl80211_id = -1;
  if(!(nl80211_id >= 0))
  {
    nl80211_id=genl_ctrl_resolve(cmd->sk, "nl80211");
    if(!(nl80211_id >= 0))
      err_sys("nl80211 not found");

  }

  const char *return_value_conf_ifname_2;
  return_value_conf_ifname_2=conf_ifname();
  ifindex=if_nametoindex(return_value_conf_ifname_2);
  signed int *return_value___errno_location_4;
  const char *return_value_conf_ifname_3;
  if(ifindex == 0u)
  {
    return_value___errno_location_4=__errno_location();
    if(!(*return_value___errno_location_4 == 0))
    {
      return_value_conf_ifname_3=conf_ifname();
      err_sys("failed to look up interface %s", return_value_conf_ifname_3);
    }

  }

  msg=nlmsg_alloc();
  if(msg == ((struct nl_msg *)NULL))
    err_sys("failed to allocate netlink message");

  cb=nl_cb_alloc((enum nl_cb_kind)(0 != 0 ? NL_CB_DEBUG : NL_CB_DEFAULT));
  if(cb == ((struct nl_cb *)NULL))
    err_sys("failed to allocate netlink callback");

  genlmsg_put(msg, (unsigned int)0, (unsigned int)0, nl80211_id, 0, cmd->flags, (unsigned char)cmd->cmd, (unsigned char)0);
  do
  {
    signed int return_value_nla_put_5;
    return_value_nla_put_5=nla_put(msg, 3, (signed int)sizeof(unsigned int) /*4ul*/ , (const void *)&ifindex);
    if(!(return_value_nla_put_5 >= 0))
      goto nla_put_failure;

  }
  while((_Bool)0);
  if(!(cmd->msg_args == ((struct msg_attribute *)NULL)))
  {
    idx = (unsigned int)0;
    for( ; !(idx >= (unsigned int)cmd->msg_args_len); idx = idx + 1u)
      do
      {
        signed int return_value_nla_put_6;
        return_value_nla_put_6=nla_put(msg, (cmd->msg_args + (signed long int)idx)->type, (cmd->msg_args + (signed long int)idx)->len, (cmd->msg_args + (signed long int)idx)->data);
        if(!(return_value_nla_put_6 >= 0))
          goto nla_put_failure;

      }
      while((_Bool)0);
  }

  ret=nl_send_auto_complete(cmd->sk, msg);
  if(!(ret >= 0))
    err_sys("failed to send netlink message");

  nl_cb_err(cb, (enum nl_cb_kind)NL_CB_CUSTOM, error_handler, (void *)&ret);
  nl_cb_set(cb, (enum nl_cb_type)NL_CB_FINISH, (enum nl_cb_kind)NL_CB_CUSTOM, finish_handler, (void *)&ret);
  nl_cb_set(cb, (enum nl_cb_type)NL_CB_ACK, (enum nl_cb_kind)NL_CB_CUSTOM, ack_handler, (void *)&ret);
  if(!(cmd->handler == ((signed int (*)(struct nl_msg *, void *))NULL)))
    nl_cb_set(cb, (enum nl_cb_type)NL_CB_VALID, (enum nl_cb_kind)NL_CB_CUSTOM, cmd->handler, cmd->handler_arg);

  while(ret >= 1)
    nl_recvmsgs(cmd->sk, cb);
  nl_cb_put(cb);
  nlmsg_free(msg);
  goto out;

nla_put_failure:
  ;
  err_quit("failed to add attribute to netlink message");

out:
  ;
  return ret;
}

// has_net_admin_capability
// file error.c line 42
extern _Bool has_net_admin_capability(void)
{
  unsigned int return_value_geteuid_1;
  return_value_geteuid_1=geteuid();
  return return_value_geteuid_1 == (unsigned int)0;
}

// hist_level
// file lhist_scr.c line 172
static double hist_level(double val, signed int min, signed int max)
{
  double return_value_map_range_1;
  return_value_map_range_1=map_range(val, (double)min, (double)max, (double)1, (double)(((LINES - 1) - 3) - 1));
  return return_value_map_range_1;
}

// hist_level_inverse
// file lhist_scr.c line 177
static double hist_level_inverse(signed int y_level, signed int min, signed int max)
{
  double return_value_map_range_1;
  return_value_map_range_1=map_range((double)y_level, (double)1, (double)(((LINES - 1) - 3) - 1), (double)min, (double)max);
  return return_value_map_range_1;
}

// hist_plot
// file lhist_scr.c line 195
static void hist_plot(double yval, signed int xval, enum colour_pair plot_colour)
{
  double level;
  double fraction;
  unsigned long int ch;
  fraction=modf(yval, &level);
  _Bool return_value_in_range_4;
  return_value_in_range_4=in_range((signed int)level, 1, ((LINES - 1) - 3) - 1);
  if(!(return_value_in_range_4 == (_Bool)0))
  {
    if(fraction < 0.2)
      ch = acs_map[(signed long int)(unsigned char)115];

    else
      if(fraction < 0.4)
        ch = acs_map[(signed long int)(unsigned char)114];

      else
        if(fraction < 0.6)
          ch = acs_map[(signed long int)(unsigned char)113];

        else
          if(fraction < 0.8)
            ch = acs_map[(signed long int)(unsigned char)112];

          else
            ch = acs_map[(signed long int)(unsigned char)111];
    if(!(w_lhist == ((struct _win_st *)NULL)))
    {
      w_lhist->_attrs = (unsigned long int)((unsigned long int)plot_colour << 0 + 8 | (unsigned long int)1UL << 13 + 8);
      0;
    }

    else
      -1;
    signed int return_value_hist_y_1;
    return_value_hist_y_1=hist_y((signed int)level);
    signed int return_value_hist_x_2;
    return_value_hist_x_2=hist_x(xval);
    signed int return_value_wmove_3;
    return_value_wmove_3=wmove(w_lhist, return_value_hist_y_1, return_value_hist_x_2);
    if(return_value_wmove_3 == -1)
      -1;

    else
      waddch(w_lhist, ch);
  }

}

// hist_x
// file lhist_scr.c line 189
static signed int hist_x(signed int xval)
{
  signed int return_value_reverse_range_1;
  return_value_reverse_range_1=reverse_range(xval, 1, COLS - 2);
  return return_value_reverse_range_1;
}

// hist_y
// file lhist_scr.c line 183
static signed int hist_y(signed int yval)
{
  signed int return_value_reverse_range_1;
  return_value_reverse_range_1=reverse_range(yval, 1, ((LINES - 1) - 3) - 1);
  return return_value_reverse_range_1;
}

// ieee80211_frequency_to_channel
// file utils.c line 167
signed int ieee80211_frequency_to_channel(signed int freq)
{
  if(freq == 2484)
    return 14;

  else
    if(!(freq >= 2484))
      return (freq - 2407) / 5;

    else
      if(freq >= 4910 && !(freq >= 4981))
        return (freq - 4000) / 5;

      else
        if(!(freq >= 45001))
          return (freq - 5000) / 5;

        else
          if(freq >= 58320 && !(freq >= 64801))
            return (freq - 56160) / 2160;

          else
            return 0;
}

// if_get_flags
// file iw_if.c line 30
static signed int if_get_flags(signed int skfd, const char *ifname)
{
  struct ifreq ifr;
  memset((void *)&ifr, 0, sizeof(struct ifreq) /*40ul*/ );
  strncpy(ifr.ifr_ifrn.ifrn_name, ifname, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(skfd, (unsigned long int)0x8913, &ifr);
  if(!(return_value_ioctl_1 >= 0))
    err_sys("can not get interface flags for %s", ifname);

  return (signed int)ifr.ifr_ifru.ifru_flags;
}

// if_getinf
// file iw_if.h line 79
extern void if_getinf(const char *ifname, struct if_info *info)
{
  struct ifreq ifr;
  signed int skfd;
  skfd=socket(2, 2, 0);
  if(!(skfd >= 0))
    err_sys("%s: can not open socket", (const void *)"if_getinf");

  memset((void *)&ifr, 0, sizeof(struct ifreq) /*40ul*/ );
  memset((void *)info, 0, sizeof(struct if_info) /*28ul*/ );
  signed int return_value_if_get_flags_1;
  return_value_if_get_flags_1=if_get_flags(skfd, ifname);
  info->flags = (unsigned short int)return_value_if_get_flags_1;
  strncpy(ifr.ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);
  signed int return_value_ioctl_2;
  return_value_ioctl_2=ioctl(skfd, (unsigned long int)0x8921, &ifr);
  if(return_value_ioctl_2 == 0)
    info->mtu = (unsigned short int)ifr.ifr_ifru.ifru_mtu;

  signed int return_value_ioctl_3;
  return_value_ioctl_3=ioctl(skfd, (unsigned long int)0x8942, &ifr);
  if(return_value_ioctl_3 >= 0)
    info->txqlen = (unsigned short int)ifr.ifr_ifru.ifru_ivalue;

  signed int return_value_ioctl_4;
  return_value_ioctl_4=ioctl(skfd, (unsigned long int)0x8927, &ifr);
  if(return_value_ioctl_4 >= 0)
    memcpy((void *)&info->hwaddr, (const void *)&ifr.ifr_ifru.ifru_hwaddr.sa_data, (unsigned long int)6);

  signed int return_value_ioctl_5;
  return_value_ioctl_5=ioctl(skfd, (unsigned long int)0x8915, &ifr);
  if(return_value_ioctl_5 >= 0)
    memcpy((void *)&info->addr, (const void *)&ifr.ifr_ifru.ifru_addr.sa_data[(signed long int)2], (unsigned long int)4);

  signed int return_value_ioctl_6;
  return_value_ioctl_6=ioctl(skfd, (unsigned long int)0x891b, &ifr);
  if(return_value_ioctl_6 >= 0)
    memcpy((void *)&info->netmask, (const void *)&ifr.ifr_ifru.ifru_netmask.sa_data[(signed long int)2], (unsigned long int)4);

  signed int return_value_ioctl_7;
  return_value_ioctl_7=ioctl(skfd, (unsigned long int)0x8919, &ifr);
  if(return_value_ioctl_7 >= 0)
    memcpy((void *)&info->bcast, (const void *)&ifr.ifr_ifru.ifru_broadaddr.sa_data[(signed long int)2], (unsigned long int)4);

  close(skfd);
}

// if_getstat
// file iw_if.h line 194
extern void if_getstat(const char *ifname, struct if_stat *stat)
{
  char line[256l];
  unsigned long long int d;
  char *if_getstat__1__lp;
  unsigned long int l;
  l=strlen(ifname);
  const char path[14l] = { '/', 'p', 'r', 'o', 'c', '/', 'n', 'e', 't', '/', 'd', 'e', 'v', 0 };
  struct _IO_FILE *fp;
  fp=fopen(path, "r");
  if(fp == ((struct _IO_FILE *)NULL))
    err_sys("can not open %s", (const void *)path);

  char *return_value_fgets_1;
  do
  {
    return_value_fgets_1=fgets(line, (signed int)sizeof(char [256l]) /*256ul*/ , fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    unsigned long int return_value_strspn_2;
    return_value_strspn_2=strspn(line, " ");
    if_getstat__1__lp = line + (signed long int)return_value_strspn_2;
    signed int return_value_strncmp_4;
    return_value_strncmp_4=strncmp(if_getstat__1__lp, ifname, l);
    if(return_value_strncmp_4 == 0)
    {
      if((signed int)if_getstat__1__lp[(signed long int)l] == 58)
      {
        if_getstat__1__lp = if_getstat__1__lp + (signed long int)(l + (unsigned long int)1);
        unsigned long int return_value_strspn_3;
        return_value_strspn_3=strspn(if_getstat__1__lp, " ");
        if_getstat__1__lp = if_getstat__1__lp + (signed long int)return_value_strspn_3;
        sscanf(if_getstat__1__lp, "%llu %llu %llu %llu %llu %llu %llu %llu %llu %llu", &stat->rx_bytes, &stat->rx_packets, &d, &d, &d, &d, &d, &d, &stat->tx_bytes, &stat->tx_packets);
      }

    }

  }
  while((_Bool)1);
  fclose(fp);
}

// if_is_up
// file iw_if.h line 77
extern _Bool if_is_up(const char *ifname)
{
  signed int ret;
  signed int skfd;
  skfd=socket(2, 2, 0);
  if(!(skfd >= 0))
    err_sys("%s: can not open socket", (const void *)"if_is_up");

  signed int return_value_if_get_flags_1;
  return_value_if_get_flags_1=if_get_flags(skfd, ifname);
  ret = return_value_if_get_flags_1 & 1;
  close(skfd);
  return (_Bool)ret;
}

// if_set_up
// file iw_if.h line 78
extern signed int if_set_up(const char *ifname)
{
  struct ifreq ifr;
  signed int ret;
  signed int skfd;
  skfd=socket(2, 2, 0);
  if(!(skfd >= 0))
    err_sys("%s: can not open socket", (const void *)"if_set_up");

  memset((void *)&ifr, 0, sizeof(struct ifreq) /*40ul*/ );
  strncpy(ifr.ifr_ifrn.ifrn_name, ifname, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
  signed int return_value_if_get_flags_1;
  return_value_if_get_flags_1=if_get_flags(skfd, ifname);
  ifr.ifr_ifru.ifru_flags = (signed short int)return_value_if_get_flags_1;
  if(!((1 & (signed int)ifr.ifr_ifru.ifru_flags) == 0))
    return 0;

  else
  {
    ifr.ifr_ifru.ifru_flags = ifr.ifr_ifru.ifru_flags | (signed short int)1;
    ret=ioctl(skfd, (unsigned long int)0x8914, &ifr);
    close(skfd);
    return ret;
  }
}

// iface_handler
// file iw_nl80211.c line 182
static signed int iface_handler(struct nl_msg *msg, void *arg)
{
  struct iw_nl80211_ifstat *ifs = (struct iw_nl80211_ifstat *)arg;
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  struct nlattr *tb_msg[222l];
  /* assertion ifs != ((void *)0) */
  assert(ifs != (struct iw_nl80211_ifstat *)(void *)0);
  struct nlattr *return_value_genlmsg_attrdata_3;
  return_value_genlmsg_attrdata_3=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_4;
  return_value_genlmsg_attrlen_4=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb_msg, 221, return_value_genlmsg_attrdata_3, return_value_genlmsg_attrlen_4, (struct nla_policy *)(void *)0);
  if(!(tb_msg[1l] == ((struct nlattr *)NULL)))
    ifs->phy=nla_get_u32(tb_msg[(signed long int)1]);

  if(!(tb_msg[3l] == ((struct nlattr *)NULL)))
    ifs->ifindex=nla_get_u32(tb_msg[(signed long int)3]);

  unsigned long int return_value_nla_get_u64_5;
  if(!(tb_msg[153l] == ((struct nlattr *)NULL)))
  {
    return_value_nla_get_u64_5=nla_get_u64(tb_msg[(signed long int)153]);
    ifs->wdev = (unsigned int)return_value_nla_get_u64_5;
  }

  void *return_value_nla_data_6;
  signed int return_value_nla_len_7;
  if(!(tb_msg[52l] == ((struct nlattr *)NULL)))
  {
    return_value_nla_data_6=nla_data(tb_msg[(signed long int)52]);
    return_value_nla_len_7=nla_len(tb_msg[(signed long int)52]);
    print_ssid_escaped(ifs->ssid, sizeof(char [64l]) /*64ul*/ , (const unsigned char *)return_value_nla_data_6, (const unsigned long int)return_value_nla_len_7);
  }

  if(!(tb_msg[5l] == ((struct nlattr *)NULL)))
    ifs->iftype=nla_get_u32(tb_msg[(signed long int)5]);

  ifs->chan_width = -1;
  ifs->chan_type = -1;
  unsigned int return_value_nla_get_u32_9;
  unsigned int return_value_nla_get_u32_10;
  unsigned int return_value_nla_get_u32_11;
  if(!(tb_msg[38l] == ((struct nlattr *)NULL)))
  {
    ifs->freq=nla_get_u32(tb_msg[(signed long int)38]);
    if(!(tb_msg[159l] == ((struct nlattr *)NULL)))
    {
      unsigned int return_value_nla_get_u32_8;
      return_value_nla_get_u32_8=nla_get_u32(tb_msg[(signed long int)159]);
      ifs->chan_width = (signed int)return_value_nla_get_u32_8;
      if(!(tb_msg[160l] == ((struct nlattr *)NULL)))
      {
        return_value_nla_get_u32_9=nla_get_u32(tb_msg[(signed long int)160]);
        ifs->freq_ctr1 = (signed int)return_value_nla_get_u32_9;
      }

      if(!(tb_msg[161l] == ((struct nlattr *)NULL)))
      {
        return_value_nla_get_u32_10=nla_get_u32(tb_msg[(signed long int)161]);
        ifs->freq_ctr2 = (signed int)return_value_nla_get_u32_10;
      }

    }

    if(!(tb_msg[39l] == ((struct nlattr *)NULL)))
    {
      return_value_nla_get_u32_11=nla_get_u32(tb_msg[(signed long int)39]);
      ifs->chan_type = (signed int)return_value_nla_get_u32_11;
    }

  }

  return 1;
}

// iftype_name
// file utils.c line 222
const char * iftype_name(enum nl80211_iftype iftype)
{
  if(!((signed int)iftype >= 12))
  {
    static const char *ifmodes[12l] = { "Unspecified", "IBSS", "Managed", "AP", "AP/VLAN", "WDS", "Monitor", "Mesh Point", "P2P-Client", "P2P-GO", "P2P-Device", "Outside of a BSS" };
    if(ifmodes[(signed long int)iftype] == ((const char *)NULL))
      goto __CPROVER_DUMP_L1;

    return ifmodes[(signed long int)iftype];
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    static char modebuf[100l];
    sprintf(modebuf, "Unknown mode (%d)", iftype);
    return modebuf;
  }
}

// in_range
// file wavemon.h line 368
static inline _Bool in_range(signed int val, signed int min, signed int max)
{
  return min <= val && val <= max;
}

// init_conf_items
// file conf.c line 305
static void init_conf_items(void)
{
  struct conf_item *item;
  conf_items=ll_create();
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_1;
  item->name=strdup("Interface");
  item->type = (enum anonymous_24)t_sep;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_2;
  item->name=strdup("Interface");
  item->cfname=strdup("interface");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.if_idx;
  item->list = if_list;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_3;
  item->name=strdup("Cisco-style MAC addresses");
  item->cfname=strdup("cisco_mac");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.cisco_mac;
  item->list = on_off_names;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_4;
  item->name=strdup("Scan sort type");
  item->cfname=strdup("sort_order");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.scan_sort_order;
  item->list = sort_order;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_5;
  return_value_calloc_5=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_5;
  item->name=strdup("Scan sort in ascending order");
  item->cfname=strdup("sort_ascending");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.scan_sort_asc;
  item->list = on_off_names;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_6;
  return_value_calloc_6=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_6;
  item->name=strdup("Statistics updates");
  item->cfname=strdup("stat_updates");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.stat_iv;
  item->min = (double)10;
  item->max = (double)4000;
  item->inc = (double)10;
  item->unit=strdup("ms");
  ll_push(conf_items, "*", item);
  void *return_value_calloc_7;
  return_value_calloc_7=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_7;
  item->name=strdup("Histogram update cycles");
  item->cfname=strdup("lhist_slot_size");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.slotsize;
  item->min = (double)1;
  item->max = (double)64;
  item->inc = (double)1;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_8;
  return_value_calloc_8=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_8;
  item->name=strdup("Level meter smoothness");
  item->cfname=strdup("meter_smoothness");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.meter_decay;
  item->min = (double)0;
  item->max = (double)99;
  item->inc = (double)1;
  item->unit=strdup("%");
  ll_push(conf_items, "*", item);
  void *return_value_calloc_9;
  return_value_calloc_9=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_9;
  item->name=strdup("Dynamic info updates");
  item->cfname=strdup("info_updates");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.info_iv;
  item->min = (double)1;
  item->max = (double)60;
  item->inc = (double)1;
  item->unit=strdup("s");
  ll_push(conf_items, "*", item);
  void *return_value_calloc_10;
  return_value_calloc_10=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_10;
  item->type = (enum anonymous_24)t_sep;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_11;
  return_value_calloc_11=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_11;
  item->name=strdup("Level scales");
  item->type = (enum anonymous_24)t_sep;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_12;
  return_value_calloc_12=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_12;
  item->name=strdup("Override scale autodetect");
  item->cfname=strdup("override_auto_scale");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.override_bounds;
  item->list = on_off_names;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_13;
  return_value_calloc_13=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_13;
  item->name=strdup("Minimum signal level");
  item->cfname=strdup("min_signal_level");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.sig_min;
  item->min = (double)-100;
  item->max = (double)-39;
  item->inc = (double)1;
  item->unit=strdup("dBm");
  item->dep = &conf.override_bounds;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_14;
  return_value_calloc_14=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_14;
  item->name=strdup("Maximum signal level");
  item->cfname=strdup("max_signal_level");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.sig_max;
  item->min = (double)-40;
  item->max = (double)-10;
  item->inc = (double)1;
  item->unit=strdup("dBm");
  item->dep = &conf.override_bounds;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_15;
  return_value_calloc_15=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_15;
  item->name=strdup("Minimum noise level");
  item->cfname=strdup("min_noise_level");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.noise_min;
  item->min = (double)-120;
  item->max = (double)-70;
  item->inc = (double)1;
  item->unit=strdup("dBm");
  item->dep = &conf.override_bounds;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_16;
  return_value_calloc_16=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_16;
  item->name=strdup("Maximum noise level");
  item->cfname=strdup("max_noise_level");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.noise_max;
  item->min = (double)-69;
  item->max = (double)-40;
  item->inc = (double)1;
  item->unit=strdup("dBm");
  item->dep = &conf.override_bounds;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_17;
  return_value_calloc_17=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_17;
  item->name=strdup("Low threshold action");
  item->cfname=strdup("lo_threshold_action");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.lthreshold_action;
  item->list = action_items;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_18;
  return_value_calloc_18=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_18;
  item->name=strdup("Low threshold");
  item->cfname=strdup("lo_threshold");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.lthreshold;
  item->min = (double)-120;
  item->max = (double)-60;
  item->inc = (double)1;
  item->unit=strdup("dBm");
  item->dep = &conf.lthreshold_action;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_19;
  return_value_calloc_19=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_19;
  item->name=strdup("High threshold action");
  item->cfname=strdup("hi_threshold_action");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.hthreshold_action;
  item->list = action_items;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_20;
  return_value_calloc_20=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_20;
  item->name=strdup("High threshold");
  item->cfname=strdup("hi_threshold");
  item->type = (enum anonymous_24)t_int;
  item->v.i = &conf.hthreshold;
  item->min = (double)-59;
  item->max = (double)120;
  item->inc = (double)1;
  item->unit=strdup("dBm");
  item->dep = &conf.hthreshold_action;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_21;
  return_value_calloc_21=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_21;
  item->type = (enum anonymous_24)t_sep;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_22;
  return_value_calloc_22=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_22;
  item->name=strdup("Startup");
  item->type = (enum anonymous_24)t_sep;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_23;
  return_value_calloc_23=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_23;
  item->name=strdup("Startup screen");
  item->cfname=strdup("startup_screen");
  item->type = (enum anonymous_24)t_list;
  item->v.i = &conf.startup_scr;
  item->list = screen_names;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_24;
  return_value_calloc_24=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_24;
  item->type = (enum anonymous_24)t_sep;
  ll_push(conf_items, "*", item);
  void *return_value_calloc_25;
  return_value_calloc_25=calloc((unsigned long int)1, sizeof(struct conf_item) /*80ul*/ );
  item = (struct conf_item *)return_value_calloc_25;
  item->name=strdup("Save configuration");
  item->type = (enum anonymous_24)t_func;
  item->v.fp = (void (*)())write_cf;
  ll_push(conf_items, "*", item);
}

// init_extrema
// file lhist_scr.c line 51
static void init_extrema(struct iw_extrema *ie)
{
  memset((void *)ie, 0, sizeof(struct iw_extrema) /*12ul*/ );
}

// init_menubar
// file wavemon.c line 103
static struct _win_st * init_menubar(const enum wavemon_screen active)
{
  struct _win_st *menu;
  menu=newwin(1, COLS, LINES - 1, 0);
  enum wavemon_screen cur;
  nodelay(menu, (_Bool)1);
  keypad(menu, (_Bool)1);
  wmove(menu, 0, 0);
  cur = (enum wavemon_screen)SCR_INFO;
  for( ; !((signed int)cur >= 10); cur = (enum wavemon_screen)((signed int)cur + 1))
  {
    if(!(menu == ((struct _win_st *)NULL)))
    {
      menu->_attrs = (unsigned long int)((unsigned long int)1UL << 10 + 8 | (unsigned long int)1UL << 13 + 8);
      0;
    }

    else
      -1;
    wprintw(menu, "F%d", (signed int)cur + 1);
    if(!(menu == ((struct _win_st *)NULL)))
    {
      menu->_attrs = (unsigned long int)(cur != active ? (unsigned long int)CP_INACTIVE << 0 + 8 : (unsigned long int)CP_ACTIVE << 0 + 8 | (unsigned long int)1UL << 13 + 8);
      0;
    }

    else
      -1;
    if(!(*screens[(signed long int)cur].key_name == 0))
    {
      wattr_on(menu, (unsigned long int)((unsigned long int)1UL << 9 + 8), (void *)0);
      waddch(menu, (const unsigned long int)screens[(signed long int)cur].key_name[(signed long int)0]);
      wattr_off(menu, (unsigned long int)((unsigned long int)1UL << 9 + 8), (void *)0);
      wprintw(menu, "%-5s", screens[(signed long int)cur].key_name + (signed long int)1);
    }

    else
      wprintw(menu, "%-6s", (const void *)"");
  }
  wrefresh(menu);
  return menu;
}

// interpolate
// file ui.c line 113
static double interpolate(const double val, const double min, const double max)
{
  return val < min ? (double)0 : (val > max ? (double)1 : (val - min) / (max - min));
}

// iw_cache_get
// file lhist_scr.c line 112
static struct iw_levelstat iw_cache_get(const unsigned int index)
{
  struct iw_levelstat zero = { .signal=(float)0, .noise=(float)0, .flags=(unsigned char)(0x20 | 0x40) };
  if(index >= 1025u || !(count >= index))
    return zero;

  else
    return iw_stats_cache[(signed long int)((count - index) % (unsigned int)1024)];
}

// iw_cache_insert
// file lhist_scr.c line 100
static void iw_cache_insert(struct iw_levelstat new)
{
  iw_stats_cache[(signed long int)(count % (unsigned int)1024)] = new;
  count = count + 1u;
  if(count == 4294967295u)
    count = (unsigned int)1024 + (unsigned int)-1 % (unsigned int)1024;

}

// iw_cache_update
// file iw_nl80211.h line 189
extern void iw_cache_update(struct iw_nl80211_linkstat *ls)
{
  signed int sig_level;
  signed int tmp_if_expr_1;
  if(!((signed int)ls->signal_avg == 0))
    tmp_if_expr_1 = (signed int)ls->signal_avg;

  else
    tmp_if_expr_1 = (signed int)ls->signal;
  sig_level = tmp_if_expr_1;
  if(sig_level == 0)
    sig_level = (signed int)ls->bss_signal;

  static struct iw_levelstat avg = { .signal=(float)0, .noise=(float)0, .flags=(unsigned char)(0x20 | 0x40) };
  if(sig_level == 0)
    avg.flags = avg.flags | (unsigned char)0x20;

  else
  {
    avg.flags = avg.flags & (unsigned char)~0x20;
    avg.signal = avg.signal + (float)sig_level / (float)conf.slotsize;
    track_extrema((const float)sig_level, &e_signal);
  }
  _Bool return_value_iw_nl80211_have_survey_data_2;
  return_value_iw_nl80211_have_survey_data_2=iw_nl80211_have_survey_data_link1(ls);
  if(!(return_value_iw_nl80211_have_survey_data_2 == (_Bool)0))
  {
    avg.flags = avg.flags & (unsigned char)~0x40;
    avg.noise = avg.noise + (float)ls->survey.noise / (float)conf.slotsize;
    track_extrema((const float)ls->survey.noise, &e_noise);
    if((0x20 & (signed int)avg.flags) == 0)
      track_extrema((const float)(sig_level - (signed int)ls->survey.noise), &e_snr);

  }

  static signed int slot;
  slot = slot + 1;
  if(slot >= conf.slotsize)
  {
    iw_cache_insert(avg);
    static struct iw_levelstat prev;
    if(prev.signal < (float)conf.lthreshold && avg.signal >= (float)conf.lthreshold && !(conf.lthreshold_action == 0))
      threshold_action((enum threshold_action)conf.lthreshold);

    else
      if(avg.signal <= (float)conf.hthreshold && prev.signal > (float)conf.hthreshold && !(conf.hthreshold_action == 0))
        threshold_action((enum threshold_action)conf.hthreshold);

    prev = avg;
    slot = 0;
    avg.noise = (float)slot;
    avg.signal = avg.noise;
    avg.flags = (unsigned char)(0x20 | 0x40);
  }

}

// iw_get_interface_list
// file wavemon.h line 284
extern void iw_get_interface_list(char **if_list, unsigned long int max_entries)
{
  char *p;
  char tmp[8192l];
  signed int nifs = 1;
  struct iwreq wrq;
  struct _IO_FILE *fp;
  signed int skfd;
  skfd=socket(2, 2, 0);
  if(!(skfd >= 0))
    err_sys("%s: can not open socket", (const void *)"iw_get_interface_list");

  fp=fopen("/proc/net/dev", "r");
  if(fp == ((struct _IO_FILE *)NULL))
    err_sys("can not open /proc/net/dev");

  char *return_value_fgets_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  signed int tmp_post_4;
  do
  {
    return_value_fgets_1=fgets(tmp, (signed int)sizeof(char [8192l]) /*8192ul*/ , fp);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    p=strchr(tmp, 58);
    if(!(p == ((char *)NULL)))
    {
      *p = (char)0;
      p = tmp;
      do
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*p]) == 0)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      snprintf(wrq.ifr_ifrn.ifrn_name, (unsigned long int)16, "%s", p);
      signed int return_value_ioctl_3;
      return_value_ioctl_3=ioctl(skfd, (unsigned long int)0x8B01, &wrq);
      if(return_value_ioctl_3 >= 0)
      {
        if((unsigned long int)nifs >= max_entries)
          break;

        if_list[(signed long int)(nifs - 1)]=strdup(p);
        tmp_post_4 = nifs;
        nifs = nifs + 1;
        if_list[(signed long int)tmp_post_4] = (char *)(void *)0;
      }

    }

  }
  while((_Bool)1);
  close(skfd);
  fclose(fp);
}

// iw_getinf_range
// file iw_if.h line 206
extern void iw_getinf_range(const char *ifname, struct iw_range *range)
{
  struct iwreq iwr;
  signed int skfd;
  skfd=socket(2, 2, 0);
  if(!(skfd >= 0))
    err_sys("%s: can not open socket", (const void *)"iw_getinf_range");

  memset((void *)range, 0, sizeof(struct iw_range) /*568ul*/ );
  strncpy(iwr.ifr_ifrn.ifrn_name, ifname, (unsigned long int)16);
  iwr.u.data.pointer = (void *)(char *)range;
  iwr.u.data.length = (unsigned short int)sizeof(struct iw_range) /*568ul*/ ;
  iwr.u.data.flags = (unsigned short int)0;
  signed int return_value_ioctl_1;
  return_value_ioctl_1=ioctl(skfd, (unsigned long int)0x8B0B, &iwr);
  if(!(return_value_ioctl_1 >= 0))
    err_sys("can not get range information");

  close(skfd);
}

// iw_nl80211_get_linkstat
// file iw_nl80211.c line 529
extern void iw_nl80211_get_linkstat(struct iw_nl80211_linkstat *ls)
{
  struct msg_attribute station_addr = { .type=6, .len=(signed int)sizeof(struct ether_addr) /*6ul*/ , .data=(const void *)&ls->bssid };
  static struct cmd cmd_linkstat = { .cmd=(enum nl80211_commands)NL80211_CMD_GET_SCAN, .sk=((struct nl_sock *)NULL),
    .flags=0x100 | 0x200, .handler=link_handler,
    .handler_arg=NULL, .msg_args=((struct msg_attribute *)NULL),
    .msg_args_len=0 };
  cmd_linkstat.handler_arg = (void *)ls;
  memset((void *)ls, 0, sizeof(struct iw_nl80211_linkstat) /*344ul*/ );
  handle_cmd(&cmd_linkstat);
  _Bool return_value_ether_addr_is_zero_1;
  return_value_ether_addr_is_zero_1=ether_addr_is_zero(&ls->bssid);
  if(return_value_ether_addr_is_zero_1 == (_Bool)0)
  {
    static struct cmd cmd_getstation = { .cmd=(enum nl80211_commands)NL80211_CMD_GET_STATION, .sk=((struct nl_sock *)NULL),
    .flags=0, .handler=link_sta_handler,
    .handler_arg=NULL, .msg_args=((struct msg_attribute *)NULL),
    .msg_args_len=0 };
    cmd_getstation.handler_arg = (void *)ls;
    cmd_getstation.msg_args = &station_addr;
    cmd_getstation.msg_args_len = (unsigned char)1;
    handle_cmd(&cmd_getstation);
    iw_nl80211_get_survey(&ls->survey);
  }

}

// iw_nl80211_get_scan_data
// file iw_scan.c line 262
static signed int iw_nl80211_get_scan_data(struct scan_result *sr)
{
  memset((void *)sr, 0, sizeof(struct scan_result) /*208ul*/ );
  static struct cmd cmd_scan_dump = { .cmd=(enum nl80211_commands)NL80211_CMD_GET_SCAN, .sk=((struct nl_sock *)NULL),
    .flags=0x100 | 0x200, .handler=scan_dump_handler,
    .handler_arg=NULL, .msg_args=((struct msg_attribute *)NULL),
    .msg_args_len=0 };
  cmd_scan_dump.handler_arg = (void *)sr;
  signed int return_value_handle_cmd_1;
  return_value_handle_cmd_1=handle_cmd(&cmd_scan_dump);
  return return_value_handle_cmd_1;
}

// iw_nl80211_get_survey
// file iw_nl80211.c line 594
extern void iw_nl80211_get_survey(struct iw_nl80211_survey *sd)
{
  static struct cmd cmd_survey = { .cmd=(enum nl80211_commands)NL80211_CMD_GET_SURVEY, .sk=((struct nl_sock *)NULL),
    .flags=0x100 | 0x200, .handler=survey_handler,
    .handler_arg=NULL, .msg_args=((struct msg_attribute *)NULL),
    .msg_args_len=0 };
  cmd_survey.handler_arg = (void *)sd;
  memset((void *)sd, 0, sizeof(struct iw_nl80211_survey) /*56ul*/ );
  handle_cmd(&cmd_survey);
}

// iw_nl80211_getifstat
// file iw_nl80211.c line 581
extern void iw_nl80211_getifstat(struct iw_nl80211_ifstat *ifs)
{
  static struct cmd cmd_ifstat = { .cmd=(enum nl80211_commands)NL80211_CMD_GET_INTERFACE, .sk=((struct nl_sock *)NULL),
    .flags=0, .handler=iface_handler,
    .handler_arg=NULL, .msg_args=((struct msg_attribute *)NULL),
    .msg_args_len=0 };
  cmd_ifstat.handler_arg = (void *)ifs;
  memset((void *)ifs, 0, sizeof(struct iw_nl80211_ifstat) /*100ul*/ );
  handle_cmd(&cmd_ifstat);
}

// iw_nl80211_getreg
// file iw_nl80211.c line 568
extern void iw_nl80211_getreg(struct iw_nl80211_reg *ir)
{
  static struct cmd cmd_reg = { .cmd=(enum nl80211_commands)NL80211_CMD_GET_REG, .sk=((struct nl_sock *)NULL),
    .flags=0, .handler=reg_handler,
    .handler_arg=NULL, .msg_args=((struct msg_attribute *)NULL),
    .msg_args_len=0 };
  cmd_reg.handler_arg = (void *)ir;
  memset((void *)ir, 0, sizeof(struct iw_nl80211_reg) /*8ul*/ );
  handle_cmd(&cmd_reg);
}

// iw_nl80211_have_survey_data
// file iw_nl80211.h line 192
static inline _Bool iw_nl80211_have_survey_data(struct iw_nl80211_linkstat *ls)
{
  _Bool tmp_if_expr_1;
  if(!(ls->survey.freq == 0u))
    tmp_if_expr_1 = (signed int)ls->survey.noise != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return tmp_if_expr_1;
}

// iw_nl80211_have_survey_data_link1
// file iw_nl80211.h line 192
static inline _Bool iw_nl80211_have_survey_data_link1(struct iw_nl80211_linkstat *ls_link1)
{
  _Bool tmp_if_expr_1_link1;
  if(!(ls_link1->survey.freq == 0u))
    tmp_if_expr_1_link1 = (signed int)ls_link1->survey.noise != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1_link1 = (_Bool)0;
  return tmp_if_expr_1_link1;
}

// iw_nl80211_scan_trigger
// file iw_scan.c line 253
static signed int iw_nl80211_scan_trigger(void)
{
  signed int return_value_handle_cmd_1;
  static struct cmd cmd_trigger_scan = { .cmd=(enum nl80211_commands)NL80211_CMD_TRIGGER_SCAN, .sk=((struct nl_sock *)NULL),
    .flags=0, .handler=((signed int (*)(struct nl_msg *, void *))NULL),
    .handler_arg=NULL,
    .msg_args=((struct msg_attribute *)NULL), .msg_args_len=0 };
  return_value_handle_cmd_1=handle_cmd(&cmd_trigger_scan);
  return return_value_handle_cmd_1;
}

// link_handler
// file iw_nl80211.c line 329
static signed int link_handler(struct nl_msg *msg, void *arg)
{
  struct iw_nl80211_linkstat *link_handler__1__ls = (struct iw_nl80211_linkstat *)arg;
  struct nlattr *tb[222l];
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  struct nlattr *bss[15l];
  struct nlattr *return_value_genlmsg_attrdata_3;
  return_value_genlmsg_attrdata_3=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_4;
  return_value_genlmsg_attrlen_4=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb, 221, return_value_genlmsg_attrdata_3, return_value_genlmsg_attrlen_4, (struct nla_policy *)(void *)0);
  if(tb[47l] == ((struct nlattr *)NULL))
    return 1;

  else
  {
    signed int return_value_nla_parse_nested_5;
    static struct nla_policy bss_policy[15l] = { { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 } };
    return_value_nla_parse_nested_5=nla_parse_nested(bss, 14, tb[(signed long int)47], bss_policy);
    if(!(return_value_nla_parse_nested_5 == 0))
      return 1;

    else
      if(bss[1l] == ((struct nlattr *)NULL))
        return 1;

      else
        if(bss[9l] == ((struct nlattr *)NULL))
          return 1;

        else
        {
          if(!(bss[8l] == ((struct nlattr *)NULL)))
            link_handler__1__ls->bss_signal_qual=nla_get_u8(bss[(signed long int)8]);

          if(!(bss[7l] == ((struct nlattr *)NULL)))
          {
            signed int s;
            unsigned int return_value_nla_get_u32_6;
            return_value_nla_get_u32_6=nla_get_u32(bss[(signed long int)7]);
            s = (signed int)return_value_nla_get_u32_6;
            link_handler__1__ls->bss_signal = (signed char)(s / 100);
          }

          link_handler__1__ls->status=nla_get_u32(bss[(signed long int)9]);
          if(link_handler__1__ls->status == 0u || link_handler__1__ls->status == 1u || link_handler__1__ls->status == 2u)
          {
            void *return_value_nla_data_7;
            return_value_nla_data_7=nla_data(bss[(signed long int)1]);
            memcpy((void *)&link_handler__1__ls->bssid, return_value_nla_data_7, (unsigned long int)6);
          }

          return 1;
        }
  }
}

// link_sta_handler
// file iw_nl80211.c line 381
static signed int link_sta_handler(struct nl_msg *msg, void *arg)
{
  struct iw_nl80211_linkstat *link_sta_handler__1__ls = (struct iw_nl80211_linkstat *)arg;
  struct nlattr *tb[222l];
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  struct nlattr *sinfo[32l];
  struct nlattr *binfo[6l];
  struct nl80211_sta_flag_update *sta_flags;
  struct nlattr *return_value_genlmsg_attrdata_3;
  return_value_genlmsg_attrdata_3=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_4;
  return_value_genlmsg_attrlen_4=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb, 221, return_value_genlmsg_attrdata_3, return_value_genlmsg_attrlen_4, (struct nla_policy *)(void *)0);
  unsigned char return_value_nla_get_u8_6;
  unsigned char return_value_nla_get_u8_7;
  if(tb[21l] == ((struct nlattr *)NULL))
    return 1;

  else
  {
    signed int return_value_nla_parse_nested_5;
    static struct nla_policy stats_policy[32l] = { { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)8, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)8, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=(unsigned short int)sizeof(struct nl80211_sta_flag_update) /*8ul*/ , .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)8, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)8, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 } };
    return_value_nla_parse_nested_5=nla_parse_nested(sinfo, 31, tb[(signed long int)21], stats_policy);
    if(!(return_value_nla_parse_nested_5 == 0))
      return 1;

    else
    {
      if(!(sinfo[11l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->tx_retries=nla_get_u32(sinfo[(signed long int)11]);

      if(!(sinfo[12l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->tx_failed=nla_get_u32(sinfo[(signed long int)12]);

      if(!(sinfo[27l] == ((struct nlattr *)NULL)))
      {
        link_sta_handler__1__ls->expected_thru=nla_get_u32(sinfo[(signed long int)27]);
        link_sta_handler__1__ls->expected_thru = (link_sta_handler__1__ls->expected_thru * (unsigned int)1000) / (unsigned int)1024;
      }

      if(!(sinfo[1l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->inactive_time=nla_get_u32(sinfo[(signed long int)1]);

      if(!(sinfo[16l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->connected_time=nla_get_u32(sinfo[(signed long int)16]);

      if(!(sinfo[2l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->rx_bytes=nla_get_u32(sinfo[(signed long int)2]);

      if(!(sinfo[9l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->rx_packets=nla_get_u32(sinfo[(signed long int)9]);

      if(!(sinfo[28l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->rx_drop_misc=nla_get_u64(sinfo[(signed long int)28]);

      if(!(sinfo[3l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->tx_bytes=nla_get_u32(sinfo[(signed long int)3]);

      if(!(sinfo[10l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->tx_packets=nla_get_u32(sinfo[(signed long int)10]);

      if(!(sinfo[7l] == ((struct nlattr *)NULL)))
      {
        return_value_nla_get_u8_6=nla_get_u8(sinfo[(signed long int)7]);
        link_sta_handler__1__ls->signal = (signed char)return_value_nla_get_u8_6;
      }

      if(!(sinfo[13l] == ((struct nlattr *)NULL)))
      {
        return_value_nla_get_u8_7=nla_get_u8(sinfo[(signed long int)13]);
        link_sta_handler__1__ls->signal_avg = (signed char)return_value_nla_get_u8_7;
      }

      if(!(sinfo[30l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->beacon_avg_sig=nla_get_u8(sinfo[(signed long int)30]);

      if(!(sinfo[29l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->beacons=nla_get_u64(sinfo[(signed long int)29]);

      if(!(sinfo[18l] == ((struct nlattr *)NULL)))
        link_sta_handler__1__ls->beacon_loss=nla_get_u32(sinfo[(signed long int)18]);

      if(!(sinfo[8l] == ((struct nlattr *)NULL)))
        parse_bitrate(sinfo[(signed long int)8], link_sta_handler__1__ls->tx_bitrate, (signed int)sizeof(char [100l]) /*100ul*/ );

      if(!(sinfo[14l] == ((struct nlattr *)NULL)))
        parse_bitrate(sinfo[(signed long int)14], link_sta_handler__1__ls->rx_bitrate, (signed int)sizeof(char [100l]) /*100ul*/ );

      if(!(sinfo[17l] == ((struct nlattr *)NULL)))
      {
        void *return_value_nla_data_8;
        return_value_nla_data_8=nla_data(sinfo[(signed long int)17]);
        sta_flags = (struct nl80211_sta_flag_update *)return_value_nla_data_8;
        if(!((4ull & (unsigned long int)sta_flags->mask) == 0ul))
        {
          if(!((4ull & (unsigned long int)sta_flags->set) == 0ul))
            link_sta_handler__1__ls->long_preamble = (_Bool)1;

        }

        if(!((8ull & (unsigned long int)sta_flags->mask) == 0ul))
        {
          if(!((8ull & (unsigned long int)sta_flags->set) == 0ul))
            link_sta_handler__1__ls->wme = (_Bool)1;

        }

        if(!((16ull & (unsigned long int)sta_flags->mask) == 0ul))
        {
          if(!((16ull & (unsigned long int)sta_flags->set) == 0ul))
            link_sta_handler__1__ls->mfp = (_Bool)1;

        }

        if(!((64ull & (unsigned long int)sta_flags->mask) == 0ul))
        {
          if(!((64ull & (unsigned long int)sta_flags->set) == 0ul))
            link_sta_handler__1__ls->tdls = (_Bool)1;

        }

      }

      if(!(sinfo[15l] == ((struct nlattr *)NULL)))
      {
        signed int return_value_nla_parse_nested_9;
        static struct nla_policy bss_policy[6l] = { { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)6, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)6, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)6, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 } };
        return_value_nla_parse_nested_9=nla_parse_nested(binfo, 5, sinfo[(signed long int)15], bss_policy);
        if(return_value_nla_parse_nested_9 == 0)
        {
          if(!(binfo[1l] == ((struct nlattr *)NULL)))
            link_sta_handler__1__ls->cts_protection = (_Bool)1;

          if(!(binfo[2l] == ((struct nlattr *)NULL)))
            link_sta_handler__1__ls->long_preamble = (_Bool)0;

          if(!(binfo[3l] == ((struct nlattr *)NULL)))
            link_sta_handler__1__ls->short_slot_time = (_Bool)1;

          link_sta_handler__1__ls->beacon_int=nla_get_u16(binfo[(signed long int)5]);
          link_sta_handler__1__ls->dtim_period=nla_get_u8(binfo[(signed long int)4]);
        }

      }

      return 1;
    }
  }
}

// ll_create
// file llist.c line 87
signed int ll_create(void)
{
  unsigned long int ll_create__1__i;
  static char firstcall = (char)1;
  if(!(firstcall == 0))
  {
    ll_create__1__i = (unsigned long int)0;
    for( ; !(ll_create__1__i >= 256ul); ll_create__1__i = ll_create__1__i + 1ul)
      lists[(signed long int)ll_create__1__i] = (struct chain *)(void *)0;
    firstcall = (char)0;
  }

  ll_create__1__i = (unsigned long int)0;
  for( ; !(ll_create__1__i >= 256ul); ll_create__1__i = ll_create__1__i + 1ul)
    if(lists[(signed long int)ll_create__1__i] == ((struct chain *)NULL))
      break;

  if(!(ll_create__1__i >= 256ul))
  {
    void *return_value_calloc_1;
    return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct chain) /*24ul*/ );
    lists[(signed long int)ll_create__1__i] = (struct chain *)return_value_calloc_1;
    return (signed int)ll_create__1__i;
  }

  else
    return -1;
}

// ll_destroy
// file llist.c line 216
void ll_destroy(signed int ld)
{
  struct chain *l = lists[(signed long int)ld];
  struct chain *lnext;
  for( ; !(l == ((struct chain *)NULL)); l = lnext)
  {
    lnext = l->next;
    free(l->e);
    free((void *)l);
  }
  lp[(signed long int)ld].eol = (char)0;
  lp[(signed long int)ld].n = (unsigned long int)lp[(signed long int)ld].eol;
  lists[(signed long int)ld] = (struct chain *)(void *)0;
}

// ll_get
// file llist.c line 111
void * ll_get(signed int ld, unsigned long int n)
{
  struct chain *l = lists[(signed long int)ld]->next;
  signed int ll_get__1__i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!((unsigned long int)ll_get__1__i >= n))
      tmp_if_expr_1 = l->next != ((struct chain *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    l = l->next;
    ll_get__1__i = ll_get__1__i + 1;
  }
  while((_Bool)1);
  return l->e;
}

// ll_getall
// file llist.c line 124
void * ll_getall(signed int ld)
{
  struct chain *l = lists[(signed long int)ld]->next;
  void *rv;
  unsigned long int ll_getall__1__i;
  static char firstcall = (char)1;
  if(!(firstcall == 0))
  {
    ll_getall__1__i = (unsigned long int)0;
    for( ; !(ll_getall__1__i >= 256ul); ll_getall__1__i = ll_getall__1__i + 1ul)
    {
      lp[(signed long int)ll_getall__1__i].eol = (char)0;
      lp[(signed long int)ll_getall__1__i].n = (unsigned long int)lp[(signed long int)ll_getall__1__i].eol;
    }
    firstcall = (char)0;
  }

  if(lp[(signed long int)ld].eol == 0)
  {
    ll_getall__1__i = (unsigned long int)0;
    for( ; !(ll_getall__1__i >= lp[(signed long int)ld].n); ll_getall__1__i = ll_getall__1__i + 1ul)
      l = l->next;
    if(l->next == ((struct chain *)NULL))
      lp[(signed long int)ld].eol = (char)1;

    rv = l->e;
    lp[(signed long int)ld].n = lp[(signed long int)ld].n + 1ul;
  }

  else
  {
    rv = (void *)0;
    lp[(signed long int)ld].n = (unsigned long int)0;
    lp[(signed long int)ld].eol = (char)lp[(signed long int)ld].n;
  }
  return rv;
}

// ll_push
// file llist.c line 162
void ll_push(signed int ld, const char *format, ...)
{
  struct chain *l = lists[(signed long int)ld];
  void **ap;
  for( ; !(l->next == ((struct chain *)NULL)); l = l->next)
    ;
  ap = (void **)&format;
  const char *tmp_post_1;
  for( ; !(*format == 0); l = l->next)
  {
    tmp_post_1 = format;
    format = format + 1l;
    l->next=arg2element(*tmp_post_1, &ap, (struct chain *)(void *)0);
  }
  ap = ((void **)NULL);
  l->next = (struct chain *)(void *)0;
}

// ll_replace
// file llist.c line 180
void ll_replace(signed int ld, unsigned long int n, const char *format, ...)
{
  struct chain *prevl = lists[(signed long int)ld];
  struct chain *l = lists[(signed long int)ld]->next;
  signed int ll_replace__1__i;
  void **ap;
  ll_replace__1__i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!((unsigned long int)ll_replace__1__i >= n))
      tmp_if_expr_1 = l->next != ((struct chain *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    prevl = l;
    l = l->next;
    ll_replace__1__i = ll_replace__1__i + 1;
  }
  while((_Bool)1);
  ap = (void **)&format;
  if(!(*format == 0))
    prevl->next=arg2element(*format, &ap, l->next);

  ap = ((void **)NULL);
  free(l->e);
  free((void *)l);
}

// ll_reset
// file llist.c line 154
void ll_reset(signed int ld)
{
  lp[(signed long int)ld].eol = (char)0;
  lp[(signed long int)ld].n = (unsigned long int)lp[(signed long int)ld].eol;
}

// ll_size
// file llist.c line 203
unsigned long int ll_size(signed int ld)
{
  struct chain *l = lists[(signed long int)ld];
  unsigned long int ll_size__1__i = (unsigned long int)0;
  do
  {
    l = l->next;
    if(l == ((struct chain *)NULL))
      break;

    ll_size__1__i = ll_size__1__i + 1ul;
  }
  while((_Bool)1);
  return ll_size__1__i;
}

// m_pref
// file conf_scr.c line 133
static signed int m_pref(struct _win_st *w_conf, signed int list_offset, signed int active_item, signed int num_items)
{
  signed int active_line;
  signed int m_pref__1__i;
  signed int m_pref__1__j;
  werase(w_conf);
  m_pref__1__j = 0;
  m_pref__1__i = m_pref__1__j;
  active_line = m_pref__1__i;
  _Bool tmp_if_expr_4;
  signed int tmp_post_2;
  signed int tmp_post_3;
  for( ; !(m_pref__1__i >= num_items); m_pref__1__i = m_pref__1__i + 1)
  {
    struct conf_item *item;
    void *return_value_ll_get_1;
    return_value_ll_get_1=ll_get(conf_items, (unsigned long int)m_pref__1__i);
    item = (struct conf_item *)return_value_ll_get_1;
    if(item->dep == ((signed int *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = *item->dep != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      if(!(m_pref__1__i == active_item))
      {
        tmp_post_2 = m_pref__1__j;
        m_pref__1__j = m_pref__1__j + 1;
        waddstr_item(w_conf, tmp_post_2, item, (char)0);
      }

      else
      {
        waddstr_item(w_conf, m_pref__1__j, item, (char)1);
        tmp_post_3 = m_pref__1__j;
        m_pref__1__j = m_pref__1__j + 1;
        active_line = tmp_post_3;
      }
    }

  }
  if(!(LINES + -1 + -2 + -1 >= active_line + -list_offset))
    return active_line - (((LINES - 1) - 2) - 1);

  else
    if(!(active_line >= list_offset))
      return active_line;

    else
      return list_offset;
}

// mac_addr
// file utils.c line 50
char * mac_addr(struct sockaddr *sa)
{
  if(!((signed int)sa->sa_family == 1))
    return "00:00:00:00:00:00";

  else
  {
    char *return_value_ether_lookup_1;
    return_value_ether_lookup_1=ether_lookup((struct ether_addr *)sa->sa_data);
    return return_value_ether_lookup_1;
  }
}

// main
// file wavemon.c line 141
signed int main(signed int argc, char **argv)
{
  enum wavemon_screen cur;
  enum wavemon_screen next;
  struct anonymous_10 blockmask;
  struct anonymous_10 oldmask;
  getconf(argc, argv);
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(0);
  if(return_value_isatty_1 == 0)
    errx(1, "input is not from a terminal");

  setlocale(1, "");
  initscr();
  noecho();
  nonl();
  cbreak();
  curs_set(0);
  wclear(stdscr);
  check_geometry();
  start_color();
  init_pair((signed short int)CP_STANDARD, (signed short int)7, (signed short int)0);
  init_pair((signed short int)CP_SCALEHI, (signed short int)1, (signed short int)0);
  init_pair((signed short int)CP_SCALEMID, (signed short int)3, (signed short int)0);
  init_pair((signed short int)CP_SCALELOW, (signed short int)2, (signed short int)0);
  init_pair((signed short int)CP_WTITLE, (signed short int)6, (signed short int)0);
  init_pair((signed short int)CP_INACTIVE, (signed short int)6, (signed short int)0);
  init_pair((signed short int)CP_ACTIVE, (signed short int)6, (signed short int)4);
  init_pair((signed short int)CP_STATSIG, (signed short int)2, (signed short int)0);
  init_pair((signed short int)CP_STATNOISE, (signed short int)1, (signed short int)0);
  init_pair((signed short int)CP_STATSNR, (signed short int)4, (signed short int)4);
  init_pair((signed short int)CP_STATBKG, (signed short int)4, (signed short int)0);
  init_pair((signed short int)CP_STATSIG_S, (signed short int)2, (signed short int)4);
  init_pair((signed short int)CP_STATNOISE_S, (signed short int)1, (signed short int)4);
  init_pair((signed short int)CP_PREF_NORMAL, (signed short int)7, (signed short int)0);
  init_pair((signed short int)CP_PREF_SELECT, (signed short int)7, (signed short int)4);
  init_pair((signed short int)CP_PREF_ARROW, (signed short int)1, (signed short int)0);
  init_pair((signed short int)CP_SCAN_CRYPT, (signed short int)1, (signed short int)0);
  init_pair((signed short int)CP_SCAN_UNENC, (signed short int)2, (signed short int)0);
  init_pair((signed short int)CP_SCAN_NON_AP, (signed short int)3, (signed short int)0);
  xsignal(17, (void (*)(signed int))1);
  xsignal(28, sig_winch);
  sigemptyset(&blockmask);
  sigaddset(&blockmask, 28);
  cur = (enum wavemon_screen)conf.startup_scr;
  if(!((signed int)cur == SCR_QUIT))
  {
    struct _win_st *w_menu;
    signed int escape = 0;
    signed int return_value_sigprocmask_2;
    return_value_sigprocmask_2=sigprocmask(0, &blockmask, &oldmask);
    if(!(return_value_sigprocmask_2 >= 0))
      err_sys("cannot block SIGWINCH");

    next = cur;
    w_menu=init_menubar(cur);
    screens[(signed long int)cur].init();
    signed int return_value_sigprocmask_3;
    return_value_sigprocmask_3=sigprocmask(2, &oldmask, (struct anonymous_10 *)(void *)0);
    if(!(return_value_sigprocmask_3 >= 0))
      err_sys("cannot unblock SIGWINCH");

    signed int return_value___sigsetjmp_4;
    return_value___sigsetjmp_4=__sigsetjmp(env_winch, 1);
    if(return_value___sigsetjmp_4 == 0)
    {
      env_winch_ready = 1;
      signed int key;
      key=screens[(signed long int)cur].loop(w_menu);
      if(!(key >= 1))
        usleep((unsigned int)5000);

      if(key == 033)
      {
        escape = 1;
        escape = 2;
        if(escape == 2)
          key = 0410 + (key - 80) + 1;

      }

      escape = 0;
      if(key == 105 || key == 1)
      {
        next = (enum wavemon_screen)SCR_INFO;
        next = (enum wavemon_screen)SCR_LHIST;
        next = (enum wavemon_screen)SCR_SCAN;
        next = (enum wavemon_screen)SCR_PREFS;
        next = (enum wavemon_screen)SCR_HELP;
        next = (enum wavemon_screen)SCR_ABOUT;
        next = (enum wavemon_screen)SCR_QUIT;
      }

    }

    delwin(w_menu);
    screens[(signed long int)cur].fini();
    if(next == cur)
    {
      struct winsize size;
      signed int return_value_ioctl_5;
      return_value_ioctl_5=ioctl(0, (unsigned long int)0x5413, &size);
      if(!(return_value_ioctl_5 >= 0))
        err_sys("can not determine terminal size");

      resizeterm((signed int)size.ws_row, (signed int)size.ws_col);
      check_geometry();
    }

    wclear(stdscr);
    wrefresh(stdscr);
    cur = next;
  }

  endwin();
  return 0;
}

// map_range
// file wavemon.h line 413
static inline double map_range(double val, double minv, double maxv, double min, double max)
{
  double return_value_map_val_1;
  return_value_map_val_1=map_val((val - minv) / (maxv - minv), min, max);
  return return_value_map_val_1;
}

// map_val
// file wavemon.h line 407
static inline double map_val(double ratio, double min, double max)
{
  return min + ratio * (max - min);
}

// mvwclrtoborder
// file ui.c line 54
extern void mvwclrtoborder(struct _win_st *win, signed int y, signed int x)
{
  signed int return_value_wmove_1;
  if(COLS + -2 >= x && x >= 1)
  {
    return_value_wmove_1=wmove(win, y, x);
    if(return_value_wmove_1 == -1)
      -1;

    else
      whline(win, (unsigned long int)32, (1 + (COLS - 2)) - x);
  }

}

// mw2dbm
// file utils.c line 161
double mw2dbm(const double in)
{
  double return_value_log10_1;
  return_value_log10_1=log10(in);
  return 10.0 * return_value_log10_1;
}

// newwin_title
// file wavemon.h line 224
extern struct _win_st * newwin_title(signed int y, signed int h, const char *title, _Bool nobottom)
{
  struct _win_st *win;
  win=newwin(h, COLS, y, 0);
  unsigned long int top_left;
  unsigned long int tmp_if_expr_1;
  if(y >= 1)
    tmp_if_expr_1 = acs_map[(signed long int)(unsigned char)116];

  else
    tmp_if_expr_1 = acs_map[(signed long int)(unsigned char)108];
  top_left = tmp_if_expr_1;
  unsigned long int top_right;
  unsigned long int tmp_if_expr_2;
  if(y >= 1)
    tmp_if_expr_2 = acs_map[(signed long int)(unsigned char)117];

  else
    tmp_if_expr_2 = acs_map[(signed long int)(unsigned char)107];
  top_right = tmp_if_expr_2;
  if(!(nobottom == (_Bool)0))
  {
    signed int return_value_wmove_3;
    return_value_wmove_3=wmove(win, 0, 0);
    if(return_value_wmove_3 == -1)
      -1;

    else
      waddch(win, top_left);
    signed int return_value_wmove_4;
    return_value_wmove_4=wmove(win, 0, 1);
    if(return_value_wmove_4 == -1)
      -1;

    else
      whline(win, acs_map[(signed long int)(unsigned char)113], COLS - 2);
    signed int return_value_wmove_5;
    return_value_wmove_5=wmove(win, 1, 0);
    if(return_value_wmove_5 == -1)
      -1;

    else
      wvline(win, acs_map[(signed long int)(unsigned char)120], h);
    signed int return_value_wmove_6;
    return_value_wmove_6=wmove(win, 0, COLS - 1);
    if(return_value_wmove_6 == -1)
      -1;

    else
      waddch(win, top_right);
    signed int return_value_wmove_7;
    return_value_wmove_7=wmove(win, 1, COLS - 1);
    if(return_value_wmove_7 == -1)
      -1;

    else
      wvline(win, acs_map[(signed long int)(unsigned char)120], h);
  }

  else
    wborder(win, acs_map[(signed long int)(unsigned char)120], acs_map[(signed long int)(unsigned char)120], acs_map[(signed long int)(unsigned char)113], acs_map[(signed long int)(unsigned char)113], top_left, top_right, acs_map[(signed long int)(unsigned char)109], acs_map[(signed long int)(unsigned char)106]);
  if(!(win == ((struct _win_st *)NULL)))
  {
    win->_attrs = (unsigned long int)((unsigned long int)CP_WTITLE << 0 + 8);
    0;
  }

  else
    -1;
  signed int return_value_wmove_8;
  return_value_wmove_8=wmove(win, 0, 2);
  if(return_value_wmove_8 == -1)
    -1;

  else
    waddnstr(win, title, -1);
  wattr_off(win, (unsigned long int)((unsigned long int)CP_WTITLE << 0 + 8), (void *)0);
  return win;
}

// nl_get_multicast_id
// file iw_nl80211.c line 655
signed int nl_get_multicast_id(struct nl_sock *sock, const char *family, const char *group)
{
  struct nl_msg *msg;
  struct nl_cb *cb;
  signed int ret;
  signed int ctrlid;
  struct handler_args grp = { .group=group, .id=-2 };
  msg=nlmsg_alloc();
  if(msg == ((struct nl_msg *)NULL))
    return -12;

  else
  {
    cb=nl_cb_alloc((enum nl_cb_kind)NL_CB_DEFAULT);
    if(cb == ((struct nl_cb *)NULL))
      ret = -12;

    else
    {
      ctrlid=genl_ctrl_resolve(sock, "nlctrl");
      genlmsg_put(msg, (unsigned int)0, (unsigned int)0, ctrlid, 0, 0, (unsigned char)3, (unsigned char)0);
      ret = -105;
      do
      {
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(family);
        signed int return_value_nla_put_2;
        return_value_nla_put_2=nla_put(msg, 2, (signed int)return_value_strlen_1 + 1, (const void *)family);
        if(!(return_value_nla_put_2 >= 0))
          goto nla_put_failure;

      }
      while((_Bool)0);
      ret=nl_send_auto_complete(sock, msg);
      if(ret >= 0)
      {
        ret = 1;
        nl_cb_err(cb, (enum nl_cb_kind)NL_CB_CUSTOM, error_handler, (void *)&ret);
        nl_cb_set(cb, (enum nl_cb_type)NL_CB_ACK, (enum nl_cb_kind)NL_CB_CUSTOM, ack_handler, (void *)&ret);
        nl_cb_set(cb, (enum nl_cb_type)NL_CB_VALID, (enum nl_cb_kind)NL_CB_CUSTOM, family_handler, (void *)&grp);
        while(ret >= 1)
          nl_recvmsgs(sock, cb);
        if(ret == 0)
          ret = grp.id;

      }


    nla_put_failure:

      out:
        ;
      nl_cb_put(cb);
    }

  out_fail_cb:
    ;
    nlmsg_free(msg);
    return ret;
  }
}

// no_seq_check
// file iw_nl80211.h line 268
static inline signed int no_seq_check(struct nl_msg *msg, void *arg)
{
  return 0;
}

// parse_bitrate
// file iw_nl80211.c line 106
void parse_bitrate(struct nlattr *bitrate_attr, char *buf, signed int buflen)
{
  signed int rate = 0;
  char *pos = buf;
  struct nlattr *rinfo[13l];
  signed int return_value_nla_parse_nested_1;
  static struct nla_policy rate_policy[13l] = { { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)6, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)6, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 } };
  return_value_nla_parse_nested_1=nla_parse_nested(rinfo, 12, bitrate_attr, rate_policy);
  unsigned int return_value_nla_get_u32_2;
  unsigned short int return_value_nla_get_u16_3;
  signed int return_value_snprintf_4;
  unsigned char return_value_nla_get_u8_5;
  signed int return_value_snprintf_6;
  unsigned char return_value_nla_get_u8_7;
  signed int return_value_snprintf_8;
  signed int return_value_snprintf_9;
  signed int return_value_snprintf_10;
  signed int return_value_snprintf_11;
  signed int return_value_snprintf_12;
  signed int return_value_snprintf_13;
  unsigned char return_value_nla_get_u8_14;
  signed int return_value_snprintf_15;
  if(!(return_value_nla_parse_nested_1 == 0))
    snprintf(buf, (unsigned long int)buflen, "failed to parse nested rate attributes!");

  else
  {
    if(!(rinfo[5l] == ((struct nlattr *)NULL)))
    {
      return_value_nla_get_u32_2=nla_get_u32(rinfo[(signed long int)5]);
      rate = (signed int)return_value_nla_get_u32_2;
    }

    else
      if(!(rinfo[1l] == ((struct nlattr *)NULL)))
      {
        return_value_nla_get_u16_3=nla_get_u16(rinfo[(signed long int)1]);
        rate = (signed int)return_value_nla_get_u16_3;
      }

    if(rate >= 1)
    {
      return_value_snprintf_4=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), "%d.%d MBit/s", rate / 10, rate % 10);
      pos = pos + (signed long int)return_value_snprintf_4;
    }

    if(!(rinfo[2l] == ((struct nlattr *)NULL)))
    {
      return_value_nla_get_u8_5=nla_get_u8(rinfo[(signed long int)2]);
      return_value_snprintf_6=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " MCS %d", return_value_nla_get_u8_5);
      pos = pos + (signed long int)return_value_snprintf_6;
    }

    if(!(rinfo[6l] == ((struct nlattr *)NULL)))
    {
      return_value_nla_get_u8_7=nla_get_u8(rinfo[(signed long int)6]);
      return_value_snprintf_8=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " VHT-MCS %d", return_value_nla_get_u8_7);
      pos = pos + (signed long int)return_value_snprintf_8;
    }

    if(!(rinfo[3l] == ((struct nlattr *)NULL)))
    {
      return_value_snprintf_9=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " 40MHz");
      pos = pos + (signed long int)return_value_snprintf_9;
    }

    if(!(rinfo[8l] == ((struct nlattr *)NULL)))
    {
      return_value_snprintf_10=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " 80MHz");
      pos = pos + (signed long int)return_value_snprintf_10;
    }

    if(!(rinfo[9l] == ((struct nlattr *)NULL)))
    {
      return_value_snprintf_11=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " 80P80MHz");
      pos = pos + (signed long int)return_value_snprintf_11;
    }

    if(!(rinfo[10l] == ((struct nlattr *)NULL)))
    {
      return_value_snprintf_12=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " 160MHz");
      pos = pos + (signed long int)return_value_snprintf_12;
    }

    if(!(rinfo[4l] == ((struct nlattr *)NULL)))
    {
      return_value_snprintf_13=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " short GI");
      pos = pos + (signed long int)return_value_snprintf_13;
    }

    if(!(rinfo[7l] == ((struct nlattr *)NULL)))
    {
      return_value_nla_get_u8_14=nla_get_u8(rinfo[(signed long int)7]);
      return_value_snprintf_15=snprintf(pos, (unsigned long int)((signed long int)buflen - (pos - buf)), " VHT-NSS %d", return_value_nla_get_u8_14);
      pos = pos + (signed long int)return_value_snprintf_15;
    }

  }
}

// prefix_len
// file utils.c line 82
unsigned char prefix_len(struct in_addr *netmask)
{
  unsigned char return_value_bit_count_1;
  return_value_bit_count_1=bit_count(netmask->s_addr);
  return return_value_bit_count_1;
}

// pretty_time
// file utils.c line 88
const char * pretty_time(const unsigned int sec)
{
  unsigned int d = sec / (unsigned int)86400;
  unsigned int h = (sec % (unsigned int)86400) / (unsigned int)3600;
  unsigned int m = (sec % (unsigned int)3600) / (unsigned int)60;
  static char buf[12l];
  if(d >= 10u)
    sprintf(buf, "%u days", d);

  else
    if(!(d == 0u))
    {
      if(!(h == 0u))
        sprintf(buf, "%ud %uh", d, h);

      else
        if(!(m == 0u))
          sprintf(buf, "%ud %dm", d, m);

        else
          sprintf(buf, "%u day%s", d, d == (unsigned int)1 ? "" : "s");
    }

    else
      if(!(h == 0u))
        sprintf(buf, "%u:%02uh", h, m);

      else
        if(!(m == 0u))
          sprintf(buf, "%u:%02um", m, sec % (unsigned int)60);

        else
          sprintf(buf, "%u sec", sec);
  return buf;
}

// pretty_time_ms
// file utils.c line 116
const char * pretty_time_ms(const unsigned int msec)
{
  if(!(msec >= 1000u))
  {
    static char buf[12l];
    sprintf(buf, "%u ms", msec);
    return buf;
  }

  else
  {
    const char *return_value_pretty_time_1;
    return_value_pretty_time_1=pretty_time(msec / (unsigned int)1000);
    return return_value_pretty_time_1;
  }
}

// print_ssid_escaped
// file iw_nl80211.c line 157
extern void print_ssid_escaped(char *buf, const unsigned long int buflen, const unsigned char *data, const unsigned long int datalen)
{
  signed int print_ssid_escaped__1__i;
  signed int l;
  memset((void *)buf, 0, buflen);
  print_ssid_escaped__1__i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!((unsigned long int)print_ssid_escaped__1__i >= datalen))
      tmp_if_expr_1 = (signed int)data[(signed long int)print_ssid_escaped__1__i] == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    print_ssid_escaped__1__i = print_ssid_escaped__1__i + 1;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  signed int return_value_sprintf_2;
  signed int return_value_sprintf_3;
  signed int return_value_sprintf_4;
  if(!((unsigned long int)print_ssid_escaped__1__i == datalen))
  {
    l = 0;
    print_ssid_escaped__1__i = l;
    for( ; !((unsigned long int)print_ssid_escaped__1__i >= datalen); print_ssid_escaped__1__i = print_ssid_escaped__1__i + 1)
      if((unsigned long int)(4 + l) >= buflen)
        goto __CPROVER_DUMP_L16;

      else
      {
        return_value___ctype_b_loc_5=__ctype_b_loc();
        if(!((16384 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)data[(signed long int)print_ssid_escaped__1__i]]) == 0))
          tmp_if_expr_6 = (signed int)data[(signed long int)print_ssid_escaped__1__i] != 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
          tmp_if_expr_7 = (signed int)data[(signed long int)print_ssid_escaped__1__i] != 92 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
        {
          return_value_sprintf_2=sprintf(buf + (signed long int)l, "%c", data[(signed long int)print_ssid_escaped__1__i]);
          l = l + return_value_sprintf_2;
        }

        else
          if((signed int)data[(signed long int)print_ssid_escaped__1__i] == 32 && !(print_ssid_escaped__1__i == 0) && !((unsigned long int)print_ssid_escaped__1__i == datalen + 18446744073709551615ul))
          {
            return_value_sprintf_3=sprintf(buf + (signed long int)l, " ");
            l = l + return_value_sprintf_3;
          }

          else
          {
            return_value_sprintf_4=sprintf(buf + (signed long int)l, "\\x%.2x", data[(signed long int)print_ssid_escaped__1__i]);
            l = l + return_value_sprintf_4;
          }
      }
  }


__CPROVER_DUMP_L16:
  ;
}

// read_cf
// file conf.c line 203
static void read_cf(void)
{
  char tmp[256l];
  char lv[32l];
  char rv[32l];
  struct conf_item *ci = (struct conf_item *)(void *)0;
  struct _IO_FILE *fd;
  unsigned long int len;
  signed int lnum;
  signed int found;
  signed int v_int;
  char *read_cf__1__lp;
  char *conv_err;
  _Bool file_needs_update = (_Bool)0;
  char *cfname;
  cfname=get_confname();
  signed int return_value_access_1;
  return_value_access_1=access(cfname, 0);
  char *return_value_fgets_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_6;
  void *return_value_ll_getall_5;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  signed int return_value_strcasecmp_8;
  char *tmp_post_11;
  signed long int return_value_strtol_13;
  unsigned long int return_value_argv_count_14;
  if(return_value_access_1 == 0)
  {
    fd=fopen(cfname, "r");
    if(fd == ((struct _IO_FILE *)NULL))
      err_sys("can not read configuration file '%s'", cfname);

    lnum = 1;
    do
    {
      return_value_fgets_2=fgets(tmp, (signed int)sizeof(char [256l]) /*256ul*/ , fd);
      if(return_value_fgets_2 == ((char *)NULL))
        break;

      unsigned long int return_value_strspn_3;
      return_value_strspn_3=strspn(tmp, " ");
      read_cf__1__lp = tmp + (signed long int)return_value_strspn_3;
      if((signed int)*read_cf__1__lp == 35)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)*read_cf__1__lp == 10 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_4)
      {
        len=strcspn(read_cf__1__lp, " =");
        if(len >= 33ul)
          err_quit("parse error in %s, line %d: identifier too long", cfname, lnum);

        strncpy(lv, read_cf__1__lp, len);
        lv[(signed long int)len] = (char)0;
        read_cf__1__lp = read_cf__1__lp + (signed long int)len;
        ll_reset(conf_items);
        found = 0;
        do
        {
          if(found == 0)
          {
            return_value_ll_getall_5=ll_getall(conf_items);
            ci = (struct conf_item *)return_value_ll_getall_5;
            tmp_if_expr_6 = ci != ((struct conf_item *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(!tmp_if_expr_6)
            break;

          if(!((signed int)ci->type == t_sep))
            tmp_if_expr_7 = (signed int)ci->type != t_func ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_7 = (_Bool)0;
          if(tmp_if_expr_7)
          {
            return_value_strcasecmp_8=strcasecmp(ci->cfname, lv);
            tmp_if_expr_9 = return_value_strcasecmp_8 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          found = (signed int)tmp_if_expr_9;
        }
        while((_Bool)1);
        if(found == 0)
        {
          err_msg("%s, line %d: ignoring unknown identifier '%s'", cfname, lnum, (const void *)lv);
          file_needs_update = (_Bool)1;
        }

        else
        {
          unsigned long int return_value_strspn_10;
          return_value_strspn_10=strspn(read_cf__1__lp, " ");
          read_cf__1__lp = read_cf__1__lp + (signed long int)return_value_strspn_10;
          tmp_post_11 = read_cf__1__lp;
          read_cf__1__lp = read_cf__1__lp + 1l;
          if(!((signed int)*tmp_post_11 == 61))
            err_quit("parse error in %s, line %d: missing '=' operator in assignment", cfname, lnum);

          unsigned long int return_value_strspn_12;
          return_value_strspn_12=strspn(read_cf__1__lp, " ");
          read_cf__1__lp = read_cf__1__lp + (signed long int)return_value_strspn_12;
          len=strcspn(read_cf__1__lp, " \n");
          if(len >= 33ul)
            err_quit("parse error in %s, line %d: argument too long", cfname, lnum);

          else
            if((signed int)*read_cf__1__lp == 10)
              err_quit("parse error in %s, line %d: argument expected", cfname, lnum);

          strncpy(rv, read_cf__1__lp, len);
          rv[(signed long int)len] = (char)0;
          switch((signed int)ci->type)
          {
            case t_int:
            {
              return_value_strtol_13=strtol(rv, &conv_err, 10);
              v_int = (signed int)return_value_strtol_13;
              if(!((signed int)*conv_err == 0))
                err_quit("parse error in %s, line %d: integer value expected, '%s' found instead", cfname, lnum, (const void *)rv);

              else
                if((double)v_int > ci->max)
                {
                  err_msg("%s, line %d: value exceeds maximum of %d - using maximum", cfname, lnum, (signed int)ci->max);
                  *ci->v.i = (signed int)ci->max;
                  file_needs_update = (_Bool)1;
                }

                else
                  if((double)v_int < ci->min)
                  {
                    err_msg("%s, line %d: value is below minimum of %d - using minimum", cfname, lnum, (signed int)ci->min);
                    *ci->v.i = (signed int)ci->min;
                    file_needs_update = (_Bool)1;
                  }

                  else
                    *ci->v.i = v_int;
              goto __CPROVER_DUMP_L28;
            }
            case t_list:
            {
              /* assertion ci->list != ((void *)0) */
              assert(ci->list != (char **)(void *)0);
              return_value_argv_count_14=argv_count_link1(ci->list);
              if(return_value_argv_count_14 == 0ul)
                err_quit("no usable %s candidates available for '%s'", ci->name, (const void *)rv);

              v_int=argv_find(ci->list, rv);
              if(!(v_int >= 0))
              {
                err_msg("%s, line %d: '%s = %s' is not valid - using defaults", cfname, lnum, (const void *)lv, (const void *)rv);
                file_needs_update = (_Bool)1;
              }

              else
                *ci->v.i = v_int;
            }
            case t_sep:

            case t_func:
              ;
            default:

              __CPROVER_DUMP_L28:
                ;
          }
        }
      }

      lnum = lnum + 1;
    }
    while((_Bool)1);
    fclose(fd);
  }


done:
  ;
  free((void *)cfname);
  if(!(file_needs_update == (_Bool)0))
    write_cf();

}

// redraw_lhist
// file lhist_scr.c line 320
static void redraw_lhist(signed int signum)
{
  sampling_do_poll();
  static signed int vcount = 1;
  vcount = vcount - 1;
  if(vcount == 0)
  {
    vcount = conf.slotsize;
    display_lhist();
    display_key(w_key);
  }

}

// redraw_stat_levels
// file info_scr.c line 671
static void redraw_stat_levels(signed int signum)
{
  sampling_do_poll();
  display_levels();
  display_stats();
}

// reg_handler
// file iw_nl80211.c line 299
static signed int reg_handler(struct nl_msg *msg, void *arg)
{
  struct iw_nl80211_reg *ir = (struct iw_nl80211_reg *)arg;
  struct nlattr *tb_msg[222l];
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  char *alpha2;
  ir->region = -1;
  struct nlattr *return_value_genlmsg_attrdata_3;
  return_value_genlmsg_attrdata_3=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_4;
  return_value_genlmsg_attrlen_4=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb_msg, 221, return_value_genlmsg_attrdata_3, return_value_genlmsg_attrlen_4, (struct nla_policy *)(void *)0);
  unsigned char return_value_nla_get_u8_5;
  if(tb_msg[33l] == ((struct nlattr *)NULL))
    return 1;

  else
    if(tb_msg[34l] == ((struct nlattr *)NULL))
      return 1;

    else
    {
      if(!(tb_msg[146l] == ((struct nlattr *)NULL)))
      {
        return_value_nla_get_u8_5=nla_get_u8(tb_msg[(signed long int)146]);
        ir->region = (signed int)return_value_nla_get_u8_5;
      }

      else
        ir->region = NL80211_DFS_UNSET;
      void *return_value_nla_data_6;
      return_value_nla_data_6=nla_data(tb_msg[(signed long int)33]);
      alpha2 = (char *)return_value_nla_data_6;
      ir->country[(signed long int)0] = alpha2[(signed long int)0];
      ir->country[(signed long int)1] = alpha2[(signed long int)1];
      return 1;
    }
}

// reverse_range
// file wavemon.h line 420
static inline signed int reverse_range(signed int val, signed int min, signed int max)
{
  /* assertion min <= val && val <= max */
  assert(min <= val && val <= max);
  return max - (val - min);
}

// sampling_do_poll
// file info_scr.c line 44
extern void sampling_do_poll(void)
{
  iw_nl80211_get_linkstat(&ls);
  iw_cache_update(&ls);
}

// sampling_init
// file info_scr.c line 29
extern void sampling_init(void (*sampling_handler)(signed int))
{
  struct itimerval sampling_init__1__i;
  struct anonymous_12 d;
  d=div(conf.stat_iv, 1000);
  xsignal_link2(14, (void (*)(signed int))1);
  const char *return_value_conf_ifname_1;
  return_value_conf_ifname_1=conf_ifname();
  iw_getinf_range(return_value_conf_ifname_1, &range);
  sampling_init__1__i.it_value.tv_sec = (signed long int)d.quot;
  sampling_init__1__i.it_interval.tv_sec = sampling_init__1__i.it_value.tv_sec;
  sampling_init__1__i.it_value.tv_usec = (signed long int)(d.rem * 1000);
  sampling_init__1__i.it_interval.tv_usec = sampling_init__1__i.it_value.tv_usec;
  xsignal_link2(14, sampling_handler);
  sampling_handler(0);
  setitimer(0, &sampling_init__1__i, (struct itimerval *)(void *)0);
}

// sampling_stop
// file iw_if.h line 213
static inline void sampling_stop(void)
{
  alarm((unsigned int)0);
}

// sampling_stop_link1
// file iw_if.h line 213
static inline void sampling_stop_link1(void)
{
  alarm((unsigned int)0);
}

// scan_dump_handler
// file iw_scan.c line 143
signed int scan_dump_handler(struct nl_msg *msg, void *arg)
{
  struct scan_result *scan_dump_handler__1__sr = (struct scan_result *)arg;
  struct scan_entry *new;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct scan_entry) /*80ul*/ );
  new = (struct scan_entry *)return_value_calloc_1;
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_2;
  return_value_nlmsg_hdr_2=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_3;
  return_value_nlmsg_data_3=nlmsg_data(return_value_nlmsg_hdr_2);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_3;
  struct nlattr *tb[222l];
  struct nlattr *bss[15l];
  struct nlattr *return_value_genlmsg_attrdata_4;
  return_value_genlmsg_attrdata_4=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_5;
  return_value_genlmsg_attrlen_5=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb, 221, return_value_genlmsg_attrdata_4, return_value_genlmsg_attrlen_5, (struct nla_policy *)(void *)0);
  unsigned long int return_value_strlen_11;
  signed int return_value_clamp_12;
  if(tb[47l] == ((struct nlattr *)NULL))
    return 1;

  else
  {
    signed int return_value_nla_parse_nested_6;
    static struct nla_policy bss_policy[15l] = { { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)2, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 }, { .type=0, .minlen=0, .maxlen=0 } };
    return_value_nla_parse_nested_6=nla_parse_nested(bss, 14, tb[(signed long int)47], bss_policy);
    if(!(return_value_nla_parse_nested_6 == 0))
      return 1;

    else
      if(bss[1l] == ((struct nlattr *)NULL))
        return 1;

      else
      {
        void *return_value_calloc_7;
        return_value_calloc_7=calloc((unsigned long int)1, sizeof(struct scan_entry) /*80ul*/ );
        new = (struct scan_entry *)return_value_calloc_7;
        if(new == ((struct scan_entry *)NULL))
          err_sys("failed to allocate scan entry");

        void *return_value_nla_data_8;
        return_value_nla_data_8=nla_data(bss[(signed long int)1]);
        memcpy((void *)&new->ap_addr, return_value_nla_data_8, sizeof(struct ether_addr) /*6ul*/ );
        if(!(bss[2l] == ((struct nlattr *)NULL)))
        {
          new->freq=nla_get_u32(bss[(signed long int)2]);
          new->chan=ieee80211_frequency_to_channel((signed int)new->freq);
        }

        if(!(bss[8l] == ((struct nlattr *)NULL)))
          new->bss_signal_qual=nla_get_u8(bss[(signed long int)8]);

        if(!(bss[7l] == ((struct nlattr *)NULL)))
        {
          signed int s;
          unsigned int return_value_nla_get_u32_9;
          return_value_nla_get_u32_9=nla_get_u32(bss[(signed long int)7]);
          s = (signed int)return_value_nla_get_u32_9;
          new->bss_signal = (signed char)(s / 100);
        }

        if(!(bss[5l] == ((struct nlattr *)NULL)))
        {
          new->bss_capa=nla_get_u16(bss[(signed long int)5]);
          new->has_key = (unsigned char)(((signed int)new->bss_capa & 1 << 4) != 0);
        }

        if(!(bss[10l] == ((struct nlattr *)NULL)))
          new->last_seen=nla_get_u32(bss[(signed long int)10]);

        if(!(bss[3l] == ((struct nlattr *)NULL)))
          new->tsf=nla_get_u64(bss[(signed long int)3]);

        if(!(bss[6l] == ((struct nlattr *)NULL)))
        {
          unsigned char *ie;
          void *return_value_nla_data_10;
          return_value_nla_data_10=nla_data(bss[(signed long int)6]);
          ie = (unsigned char *)return_value_nla_data_10;
          signed int ielen;
          ielen=nla_len(bss[(signed long int)6]);
          unsigned char len = ie[(signed long int)1];
          for( ; ielen >= 2; ie = ie + (signed long int)((signed int)ie[(signed long int)1] + 2))
          {
            if(!(ielen >= (signed int)ie[1l]))
              break;

            switch((signed int)ie[(signed long int)0])
            {
              case 0:
              {
                if((signed int)len >= 1 && !((signed int)len >= 33))
                  print_ssid_escaped(new->essid, sizeof(char [34l]) /*34ul*/ , ie + (signed long int)2, (const unsigned long int)len);

                break;
              }
              case 11:
                if((signed int)len >= 5)
                {
                  new->bss_sta_count = (unsigned char)((signed int)ie[(signed long int)3] << 8 | (signed int)ie[(signed long int)2]);
                  new->bss_chan_usage = ie[(signed long int)4];
                }

            }
            ielen = ielen - ((signed int)ie[(signed long int)1] + 2);
          }
        }

        new->next = scan_dump_handler__1__sr->head;
        scan_dump_handler__1__sr->head = new;
        _Bool return_value_str_is_ascii_13;
        return_value_str_is_ascii_13=str_is_ascii_link1(new->essid);
        if(!(return_value_str_is_ascii_13 == (_Bool)0))
        {
          return_value_strlen_11=strlen(new->essid);
          return_value_clamp_12=clamp((signed int)return_value_strlen_11, (signed int)scan_dump_handler__1__sr->max_essid_len, 32);
          scan_dump_handler__1__sr->max_essid_len = (unsigned short int)return_value_clamp_12;
        }

        if(new->freq >= 45001u)
          err_quit("FIXME: can not handle %d MHz spectrum yet", new->freq);

        else
          if(new->freq >= 5000u)
            scan_dump_handler__1__sr->num.five_gig = scan_dump_handler__1__sr->num.five_gig + 1;

          else
            if(new->freq >= 2000u)
              scan_dump_handler__1__sr->num.two_gig = scan_dump_handler__1__sr->num.two_gig + 1;

        scan_dump_handler__1__sr->num.entries = scan_dump_handler__1__sr->num.entries + (unsigned short int)1;
        scan_dump_handler__1__sr->num.open = scan_dump_handler__1__sr->num.open + (unsigned short int)!(new->has_key != 0);
        return 1;
      }
  }
}

// scan_result_fini
// file iw_if.h line 295
extern void scan_result_fini(struct scan_result *sr)
{
  free_scan_list(sr->head);
  free((void *)sr->channel_stats);
  pthread_mutex_destroy(&sr->mutex);
}

// scan_result_init
// file iw_if.h line 294
extern void scan_result_init(struct scan_result *sr)
{
  union anonymous_14 ma;
  memset((void *)sr, 0, sizeof(struct scan_result) /*208ul*/ );
  pthread_mutexattr_init(&ma);
  signed int return_value_pthread_mutexattr_setrobust_1;
  return_value_pthread_mutexattr_setrobust_1=pthread_mutexattr_setrobust(&ma, 1);
  if(!(return_value_pthread_mutexattr_setrobust_1 >= 0))
    err_sys("Failed to set the mutex robust attribute");

  pthread_mutex_init(&sr->mutex, &ma);
}

// scr_about_fini
// file wavemon.h line 219
extern void scr_about_fini(void)
{
  delwin(w_about);
  i = 0;
  for( ; !((unsigned long int)i >= 10ul); i = i + 1)
    free((void *)linecd[(signed long int)i]);
}

// scr_about_init
// file wavemon.h line 217
extern void scr_about_init(void)
{
  w_about=newwin_title(0, LINES - 1, "About", (_Bool)0);
  i = 0;
  unsigned long int return_value_strlen_3;
  signed int return_value_rand_4;
  for( ; !((unsigned long int)i >= 10ul); i = i + 1)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(about_lines[(signed long int)i]);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(return_value_strlen_1 * sizeof(signed int) /*4ul*/ );
    linecd[(signed long int)i] = (signed int *)return_value_malloc_2;
    j = 0;
    do
    {
      return_value_strlen_3=strlen(about_lines[(signed long int)i]);
      if((unsigned long int)j >= return_value_strlen_3)
        break;

      return_value_rand_4=rand();
      linecd[(signed long int)i][(signed long int)j] = (signed int)(((float)return_value_rand_4 / (float)2147483647) * (float)120 + (float)60);
      j = j + 1;
    }
    while((_Bool)1);
  }
}

// scr_about_loop
// file wavemon.h line 218
extern signed int scr_about_loop(struct _win_st *w_menu)
{
  char buf[256l];
  i = 0;
  unsigned long int return_value_strlen_1;
  for( ; !((unsigned long int)i >= 10ul); i = i + 1)
  {
    j = 0;
    do
    {
      return_value_strlen_1=strlen(about_lines[(signed long int)i]);
      if((unsigned long int)j >= return_value_strlen_1)
        break;

      if(linecd[(signed long int)i][(signed long int)j] >= 61)
      {
        buf[(signed long int)j] = (char)32;
        linecd[(signed long int)i][(signed long int)j] = linecd[(signed long int)i][(signed long int)j] - 1;
      }

      else
        if(!(linecd[(signed long int)i][(signed long int)j] == 0))
        {
          signed int return_value_rand_2;
          return_value_rand_2=rand();
          buf[(signed long int)j] = (char)(((float)return_value_rand_2 / (float)2147483647) * (float)54 + (float)65);
          linecd[(signed long int)i][(signed long int)j] = linecd[(signed long int)i][(signed long int)j] - 1;
        }

        else
          buf[(signed long int)j] = about_lines[(signed long int)i][(signed long int)j];
      j = j + 1;
    }
    while((_Bool)1);
    buf[(signed long int)j] = (char)0;
    waddstr_center(w_about, (signed int)(((unsigned long int)(LINES - 1) - sizeof(char *[10l]) /*80ul*/  / sizeof(char *) /*8ul*/ ) / (unsigned long int)2 + (unsigned long int)i), buf);
  }
  wrefresh(w_about);
  signed int return_value_wgetch_3;
  return_value_wgetch_3=wgetch(w_menu);
  return return_value_wgetch_3;
}

// scr_aplst_fini
// file wavemon.h line 207
extern void scr_aplst_fini(void)
{
  pthread_cancel(scan_thread);
  scan_result_fini(&sr);
  delwin(w_aplst);
}

// scr_aplst_init
// file wavemon.h line 205
extern void scr_aplst_init(void)
{
  w_aplst=newwin_title(0, LINES - 1, "Scan window", (_Bool)0);
  signed int return_value_wmove_1;
  return_value_wmove_1=wmove(w_aplst, 2, 1);
  if(return_value_wmove_1 == -1)
    -1;

  else
    waddnstr(w_aplst, "Waiting for scan data ...", -1);
  wrefresh(w_aplst);
  scan_result_init(&sr);
  pthread_create(&scan_thread, (const union pthread_attr_t *)(void *)0, do_scan, (void *)&sr);
}

// scr_aplst_loop
// file wavemon.h line 206
extern signed int scr_aplst_loop(struct _win_st *w_menu)
{
  signed int key;
  display_aplist(w_aplst);
  key=wgetch(w_menu);
  switch(key)
  {
    case 97:
    {
      conf.scan_sort_asc = 1;
      return -1;
    }
    case 99:
    {
      conf.scan_sort_order = 0;
      return -1;
    }
    case 67:
    {
      conf.scan_sort_order = 5;
      return -1;
    }
    case 100:
    {
      conf.scan_sort_asc = 0;
      return -1;
    }
    case 101:
    {
      conf.scan_sort_order = 3;
      return -1;
    }
    case 109:
    {
      conf.scan_sort_order = 2;
      return -1;
    }
    case 111:
    {
      conf.scan_sort_order = 4;
      conf.scan_sort_asc = 0;
      return -1;
    }
    case 79:
    {
      conf.scan_sort_order = 6;
      conf.scan_sort_asc = 0;
      return -1;
    }
    case 115:
    {
      conf.scan_sort_order = 1;
      return -1;
    }
    default:
      return key;
  }
}

// scr_conf_fini
// file wavemon.h line 211
extern void scr_conf_fini(void)
{
  delwin(w_conf);
  delwin(w_confpad);
}

// scr_conf_init
// file wavemon.h line 209
extern void scr_conf_init(void)
{
  struct conf_item *item;
  conf_get_interface_list();
  unsigned long int return_value_ll_size_1;
  return_value_ll_size_1=ll_size(conf_items);
  num_items = (signed int)return_value_ll_size_1;
  w_conf=newwin_title(0, LINES - 1, "Preferences", (_Bool)0);
  w_confpad=newpad(num_items + 1, 80 / 2);
  void *return_value_ll_get_2;
  if(first_item == 0)
  {
    do
    {
      return_value_ll_get_2=ll_get(conf_items, (unsigned long int)first_item);
      item = (struct conf_item *)return_value_ll_get_2;
      if(item == ((struct conf_item *)NULL))
        break;

      if(!((signed int)item->type == t_sep))
        break;

      first_item = first_item + 1;
    }
    while((_Bool)1);
    active_item = first_item;
  }

}

// scr_conf_loop
// file wavemon.h line 210
extern signed int scr_conf_loop(struct _win_st *w_menu)
{
  struct conf_item *item;
  signed int key;
  list_offset=m_pref(w_confpad, list_offset, active_item, num_items);
  prefresh(w_confpad, list_offset, 0, 1, (COLS - 80 / 2) / 2, (LINES - 1) - 2, (COLS + 80 / 2) / 2);
  wrefresh(w_conf);
  key=wgetch(w_menu);
  switch(key)
  {
    case 0406:
    {
      active_item = first_item;
      break;
    }
    case 0550:
    {
      active_item = num_items - 1;
      break;
    }
    case 0402:

    case 0522:
    {
      active_item=select_item(active_item, 1);
      if(active_item >= num_items)
      {
        active_item = first_item;
        list_offset = 0;
      }

      break;
    }
    case 0403:

    case 0523:
    {
      active_item=select_item(active_item, -1);
      if(!(active_item >= first_item))
        active_item = num_items - 1;

      break;
    }
    case 0404:
    {
      change_item(active_item, (char)-1);
      break;
    }
    case 0405:
    {
      change_item(active_item, (char)1);
      break;
    }
    case 13:
    {
      void *return_value_ll_get_1;
      return_value_ll_get_1=ll_get(conf_items, (unsigned long int)active_item);
      item = (struct conf_item *)return_value_ll_get_1;
      if((signed int)item->type == t_func)
      {
        flash();
        item->v.fp();
      }

    }
  }
  return key;
}

// scr_help_fini
// file wavemon.h line 215
extern void scr_help_fini(void)
{
  delwin(w_help);
}

// scr_help_init
// file wavemon.h line 213
extern void scr_help_init(void)
{
  w_help=newwin_title(0, LINES - 1, "Help", (_Bool)0);
  waddstr_center(w_help, (LINES - 1) / 2 - 1, "don't panic.");
  wrefresh(w_help);
}

// scr_help_loop
// file wavemon.h line 214
extern signed int scr_help_loop(struct _win_st *w_menu)
{
  signed int return_value_wgetch_1;
  return_value_wgetch_1=wgetch(w_menu);
  return return_value_wgetch_1;
}

// scr_info_fini
// file wavemon.h line 199
extern void scr_info_fini(void)
{
  sampling_stop();
  delwin(w_net);
  delwin(w_info);
  delwin(w_stats);
  delwin(w_levels);
  delwin(w_if);
}

// scr_info_init
// file wavemon.h line 197
extern void scr_info_init(void)
{
  signed int line = 0;
  w_if=newwin_title(line, 2, "Interface", (_Bool)1);
  line = line + 2;
  w_levels=newwin_title(line, 9, "Levels", (_Bool)1);
  line = line + 9;
  w_stats=newwin_title(line, 3, "Statistics", (_Bool)1);
  line = line + 3;
  w_info=newwin_title(line, 8, "Info", (_Bool)1);
  line = line + 8;
  if(LINES >= 28)
    w_net=newwin_title(line, 5, "Network", (_Bool)0);

  else
    w_net=newwin_title(line, 5, "Network", (_Bool)0);
  display_info(w_if, w_info);
  display_netinfo(w_net);
  start_timer(&dyn_updates, (unsigned long int)(conf.info_iv * 1000000));
  sampling_init(redraw_stat_levels);
}

// scr_info_loop
// file wavemon.h line 198
extern signed int scr_info_loop(struct _win_st *w_menu)
{
  _Bool return_value_end_timer_1;
  return_value_end_timer_1=end_timer(&dyn_updates);
  if(!(return_value_end_timer_1 == (_Bool)0))
  {
    display_info(w_if, w_info);
    display_netinfo(w_net);
    start_timer(&dyn_updates, (unsigned long int)(conf.info_iv * 1000000));
  }

  signed int return_value_wgetch_2;
  return_value_wgetch_2=wgetch(w_menu);
  return return_value_wgetch_2;
}

// scr_lhist_fini
// file wavemon.h line 203
extern void scr_lhist_fini(void)
{
  sampling_stop_link1();
  delwin(w_lhist);
  delwin(w_key);
}

// scr_lhist_init
// file wavemon.h line 201
extern void scr_lhist_init(void)
{
  w_lhist=newwin_title(0, (LINES - 1) - 3, "Level histogram", (_Bool)1);
  w_key=newwin_title((((LINES - 1) - 3) - 1) + 1, 3, "Key", (_Bool)0);
  init_extrema(&e_signal);
  init_extrema(&e_noise);
  init_extrema(&e_snr);
  sampling_init(redraw_lhist);
  display_key(w_key);
}

// scr_lhist_loop
// file wavemon.h line 202
extern signed int scr_lhist_loop(struct _win_st *w_menu)
{
  signed int return_value_wgetch_1;
  return_value_wgetch_1=wgetch(w_menu);
  return return_value_wgetch_1;
}

// select_item
// file conf_scr.c line 119
static signed int select_item(signed int rv, signed int incr)
{
  struct conf_item *item;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  do
  {
    rv = rv + incr;
    void *return_value_ll_get_3;
    return_value_ll_get_3=ll_get(conf_items, (unsigned long int)rv);
    item = (struct conf_item *)return_value_ll_get_3;
    if((signed int)item->type == t_sep)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      if(!(item->dep == ((signed int *)NULL)))
        tmp_if_expr_1 = !(*item->dep != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
    }
  }
  while(tmp_if_expr_2);
  return rv;
}

// sig_winch
// file wavemon.c line 95
static void sig_winch(signed int signo)
{
  if(!(env_winch_ready == 0))
  {
    env_winch_ready = 0;
    siglongjmp(env_winch, 1);
  }

}

// sort_scan_list
// file iw_if.h line 252
extern void sort_scan_list(struct scan_entry **headp)
{
  struct scan_entry *head = (struct scan_entry *)(void *)0;
  struct scan_entry *cur;
  struct scan_entry *new = *headp;
  struct scan_entry **prev;
  _Bool tmp_if_expr_1;
  _Bool return_value;
  for( ; !(new == ((struct scan_entry *)NULL)); (*prev)->next = cur)
  {
    cur = head;
    prev = &head;
    do
    {
      if(!(cur == ((struct scan_entry *)NULL)))
      {
        return_value=scan_cmp[(signed long int)conf.scan_sort_order](cur, new);
        tmp_if_expr_1 = conf.scan_sort_asc == (signed int)return_value ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      prev = &cur->next;
      cur = cur->next;
    }
    while((_Bool)1);
    *prev = new;
    new = new->next;
  }
  *headp = head;
}

// start_timer
// file timer.c line 32
extern void start_timer(struct timer *t, unsigned long int duration)
{
  t->stime=get_usecs();
  t->duration = duration;
}

// str_is_ascii
// file wavemon.h line 347
static inline _Bool str_is_ascii(char *s)
{
  _Bool tmp_if_expr_1;
  if(s == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*s != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  const unsigned short int **return_value___ctype_b_loc_2;
  if(tmp_if_expr_1)
    return (_Bool)0;

  else
  {
    for( ; !(*s == 0); s = s + 1l)
    {
      if(!((-128 & (signed int)*s) == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc_2=__ctype_b_loc();
        tmp_if_expr_3 = ((signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)*s] & (signed int)(unsigned short int)2) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        return (_Bool)0;

    }
    return (_Bool)1;
  }
}

// str_is_ascii_link1
// file wavemon.h line 347
static inline _Bool str_is_ascii_link1(char *s_link1)
{
  _Bool tmp_if_expr_1_link1;
  if(s_link1 == ((char *)NULL))
    tmp_if_expr_1_link1 = (_Bool)1;

  else
    tmp_if_expr_1_link1 = !(*s_link1 != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3_link1;
  const unsigned short int **return_value___ctype_b_loc_2_link1;
  if(tmp_if_expr_1_link1)
    return (_Bool)0;

  else
  {
    for( ; !(*s_link1 == 0); s_link1 = s_link1 + 1l)
    {
      if(!((-128 & (signed int)*s_link1) == 0))
        tmp_if_expr_3_link1 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc_2_link1=__ctype_b_loc();
        tmp_if_expr_3_link1 = ((signed int)(*return_value___ctype_b_loc_2_link1)[(signed long int)(signed int)*s_link1] & (signed int)(unsigned short int)2) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3_link1)
        return (_Bool)0;

    }
    return (_Bool)1;
  }
}

// str_tolower
// file wavemon.h line 340
static inline void str_tolower(char *s)
{
  _Bool tmp_if_expr_1;
  signed int return_value_tolower_2;
  do
  {
    if(!(s == ((char *)NULL)))
      tmp_if_expr_1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    return_value_tolower_2=tolower((signed int)*s);
    *s = (char)return_value_tolower_2;
    s = s + 1l;
  }
  while((_Bool)1);
}

// survey_handler
// file iw_nl80211.c line 235
static signed int survey_handler(struct nl_msg *msg, void *arg)
{
  struct iw_nl80211_survey *sd = (struct iw_nl80211_survey *)arg;
  struct nlattr *tb[222l];
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  struct nlattr *sinfo[10l];
  struct nlattr *return_value_genlmsg_attrdata_3;
  return_value_genlmsg_attrdata_3=genlmsg_attrdata(gnlh, 0);
  signed int return_value_genlmsg_attrlen_4;
  return_value_genlmsg_attrlen_4=genlmsg_attrlen(gnlh, 0);
  nla_parse(tb, 221, return_value_genlmsg_attrdata_3, return_value_genlmsg_attrlen_4, (struct nla_policy *)(void *)0);
  unsigned char return_value_nla_get_u8_6;
  if(tb[84l] == ((struct nlattr *)NULL))
    return 1;

  else
  {
    signed int return_value_nla_parse_nested_5;
    static struct nla_policy survey_policy[10l] = { { .type=0, .minlen=0, .maxlen=0 }, { .type=(unsigned short int)3, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)1, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)6, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 },
    { .type=(unsigned short int)4, .minlen=0, .maxlen=0 } };
    return_value_nla_parse_nested_5=nla_parse_nested(sinfo, 9, tb[(signed long int)84], survey_policy);
    if(!(return_value_nla_parse_nested_5 == 0))
      return 1;

    else
      if(sinfo[1l] == ((struct nlattr *)NULL))
        return 1;

      else
        if(sinfo[3l] == ((struct nlattr *)NULL))
          return 1;

        else
        {
          sd->freq=nla_get_u32(sinfo[(signed long int)1]);
          if(!(sinfo[2l] == ((struct nlattr *)NULL)))
          {
            return_value_nla_get_u8_6=nla_get_u8(sinfo[(signed long int)2]);
            sd->noise = (signed char)return_value_nla_get_u8_6;
          }

          if(!(sinfo[4l] == ((struct nlattr *)NULL)))
            sd->time.active=nla_get_u64(sinfo[(signed long int)4]);

          if(!(sinfo[5l] == ((struct nlattr *)NULL)))
            sd->time.busy=nla_get_u64(sinfo[(signed long int)5]);

          if(!(sinfo[6l] == ((struct nlattr *)NULL)))
            sd->time.ext_busy=nla_get_u64(sinfo[(signed long int)6]);

          if(!(sinfo[7l] == ((struct nlattr *)NULL)))
            sd->time.rx=nla_get_u64(sinfo[(signed long int)7]);

          if(!(sinfo[8l] == ((struct nlattr *)NULL)))
            sd->time.tx=nla_get_u64(sinfo[(signed long int)8]);

          if(!(sinfo[9l] == ((struct nlattr *)NULL)))
            sd->time.scan=nla_get_u64(sinfo[(signed long int)9]);

          return 1;
        }
  }
}

// terminate_all_processes
// file error.c line 68
static void terminate_all_processes(const char *fmt, signed int strerr, void **ap)
{
  signed int saved_errno;
  signed int tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  if(!(strerr == 0))
  {
    return_value___errno_location_1=__errno_location();
    tmp_if_expr_2 = *return_value___errno_location_1;
  }

  else
    tmp_if_expr_2 = 0;
  saved_errno = tmp_if_expr_2;
  xsignal_link1(15, (void (*)(signed int))1);
  endwin();
  kill(0, 15);
  reset_shell_mode();
  if(!(saved_errno == 0))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = saved_errno;
    vwarn(fmt, ap);
  }

  else
    vwarnx(fmt, ap);
  ap = ((void **)NULL);
  exit(1);
}

// threshold_action
// file wavemon.h line 97
static inline void threshold_action(enum threshold_action action)
{
  if(!((TA_FLASH & (signed int)action) == 0))
    flash();

  if(!((TA_BEEP & (signed int)action) == 0))
    beep();

}

// track_extrema
// file lhist_scr.c line 56
static void track_extrema(const float new_sample, struct iw_extrema *ie)
{
  if(ie->initialised == (_Bool)0)
  {
    ie->initialised = (_Bool)1;
    ie->max = new_sample;
    ie->min = ie->max;
  }

  else
    if(new_sample < ie->min)
      ie->min = new_sample;

    else
      if(new_sample > ie->max)
        ie->max = new_sample;

}

// u8_to_dbm
// file utils.c line 128
signed int u8_to_dbm(const signed int power)
{
  return power > 63 ? power - 0x100 : power;
}

// wadd_attr_str
// file wavemon.h line 230
extern void wadd_attr_str(struct _win_st *win, const signed int attrs, const char *s)
{
  wattr_on(win, (unsigned long int)attrs, (void *)0);
  waddnstr(win, s, -1);
  wattr_off(win, (unsigned long int)attrs, (void *)0);
}

// waddbar
// file ui.c line 119
extern void waddbar(struct _win_st *win, signed int y, float v, float min, float max, signed char *cscale, _Bool rev)
{
  unsigned long int ch;
  signed int return_value_cp_from_scale_1;
  return_value_cp_from_scale_1=cp_from_scale(v, cscale, rev);
  ch = (unsigned long int)61 | (unsigned long int)1UL << 13 + 8 | (unsigned long int)return_value_cp_from_scale_1;
  signed int len;
  double return_value_interpolate_2;
  return_value_interpolate_2=interpolate((const double)v, (const double)min, (const double)max);
  len = (signed int)((double)(COLS - 2) * return_value_interpolate_2);
  signed int return_value_wmove_3;
  return_value_wmove_3=wmove(win, y, 1);
  if(return_value_wmove_3 == -1)
    -1;

  else
    whline(win, ch, len);
  mvwclrtoborder(win, y, len + 1);
}

// waddstr_b
// file wavemon.h line 231
static inline void waddstr_b(struct _win_st *win, const char *s)
{
  wadd_attr_str(win, (const signed int)((unsigned long int)1UL << 13 + 8), s);
}

// waddstr_b_link1
// file wavemon.h line 231
static inline void waddstr_b_link1(struct _win_st *win_link1, const char *s_link1)
{
  wadd_attr_str(win_link1, (const signed int)((unsigned long int)1UL << 13 + 8), s_link1);
}

// waddstr_b_link2
// file wavemon.h line 231
static inline void waddstr_b_link2(struct _win_st *win_link2, const char *s_link2)
{
  wadd_attr_str(win_link2, (const signed int)((unsigned long int)1UL << 13 + 8), s_link2);
}

// waddstr_center
// file wavemon.h line 236
extern void waddstr_center(struct _win_st *win, signed int y, const char *s)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  signed int return_value_wmove_2;
  return_value_wmove_2=wmove(win, y, (signed int)(((unsigned long int)COLS - return_value_strlen_1) / (unsigned long int)2));
  if(return_value_wmove_2 == -1)
    -1;

  else
    waddnstr(win, s, -1);
}

// waddstr_item
// file conf_scr.c line 37
static void waddstr_item(struct _win_st *w, signed int y, struct conf_item *item, char hilight)
{
  char s[64l];
  if(!(w == ((struct _win_st *)NULL)))
  {
    w->_attrs = (unsigned long int)((unsigned long int)CP_PREF_NORMAL << 0 + 8);
    0;
  }

  else
    -1;
  signed int return_value_wmove_1;
  return_value_wmove_1=wmove(w, y, 0);
  if(return_value_wmove_1 == -1)
    -1;

  else
    whline(w, (unsigned long int)32, 80 / 2);
  _Bool tmp_if_expr_13;
  if(!((signed int)item->type == t_sep))
    tmp_if_expr_13 = (signed int)item->type != t_func ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_13 = (_Bool)0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_12;
  if(tmp_if_expr_13)
  {
    signed int return_value_wmove_2;
    return_value_wmove_2=wmove(w, y, item->dep != ((signed int *)NULL) ? 2 : 0);
    if(return_value_wmove_2 == -1)
      -1;

    else
      waddnstr(w, item->name, -1);
    switch((signed int)item->type)
    {
      case t_int:
      {
        sprintf(s, "%d", *item->v.i);
        goto __CPROVER_DUMP_L13;
      }
      case t_list:
      {
        if(!(item->list == ((char **)NULL)))
          tmp_if_expr_3 = item->list[(signed long int)*item->v.i] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        /* assertion item->list && item->list[*item->v.i] */
        assert(tmp_if_expr_3);
        strncpy(s, item->list[(signed long int)*item->v.i], sizeof(char [64l]) /*64ul*/ );
      }
      case t_sep:

      case t_func:

      default:
      {

      __CPROVER_DUMP_L13:
        ;
        if(item->unit == ((char *)NULL))
        {
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(s);
          wmove(w, y, (signed int)((unsigned long int)(80 / 2) - return_value_strlen_4));
          if(!(hilight == 0))
          {
            wattr_on(w, (unsigned long int)((unsigned long int)1UL << 10 + 8), (void *)0);
            waddstr_b(w, s);
            wattr_off(w, (unsigned long int)((unsigned long int)1UL << 10 + 8), (void *)0);
          }

          else
            waddstr_b(w, s);
        }

        else
        {
          unsigned long int return_value_strlen_5;
          return_value_strlen_5=strlen(s);
          unsigned long int return_value_strlen_6;
          return_value_strlen_6=strlen(item->unit);
          wmove(w, y, (signed int)((((unsigned long int)(80 / 2) - return_value_strlen_5) - return_value_strlen_6) - (unsigned long int)1));
          if(!(hilight == 0))
          {
            wattr_on(w, (unsigned long int)((unsigned long int)1UL << 10 + 8), (void *)0);
            waddstr_b(w, s);
            wattr_off(w, (unsigned long int)((unsigned long int)1UL << 10 + 8), (void *)0);
          }

          else
            waddstr_b(w, s);
          unsigned long int return_value_strlen_7;
          return_value_strlen_7=strlen(item->unit);
          signed int return_value_wmove_8;
          return_value_wmove_8=wmove(w, y, (signed int)((unsigned long int)(80 / 2) - return_value_strlen_7));
          if(return_value_wmove_8 == -1)
            -1;

          else
            waddnstr(w, item->unit, -1);
        }
      }
    }
  }

  else
  {
    if((signed int)item->type == t_sep)
      tmp_if_expr_12 = item->name != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_12 = (_Bool)0;
    if(tmp_if_expr_12)
    {
      sprintf(s, "- %s -", item->name);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(s);
      signed int return_value_wmove_10;
      return_value_wmove_10=wmove(w, y, (signed int)(((unsigned long int)(80 / 2) - return_value_strlen_9) / (unsigned long int)2));
      if(return_value_wmove_10 == -1)
        -1;

      else
        waddnstr(w, s, -1);
    }

    else
      if((signed int)item->type == t_func)
      {
        unsigned long int return_value_strlen_11;
        return_value_strlen_11=strlen(item->name);
        wmove(w, y, (signed int)(((unsigned long int)(80 / 2) - return_value_strlen_11) / (unsigned long int)2));
        if(!(hilight == 0))
        {
          wattr_on(w, (unsigned long int)((unsigned long int)1UL << 10 + 8), (void *)0);
          waddnstr(w, item->name, -1);
          wattr_off(w, (unsigned long int)((unsigned long int)1UL << 10 + 8), (void *)0);
        }

        else
          waddnstr(w, item->name, -1);
      }

  }
}

// waddthreshold
// file ui.c line 129
extern void waddthreshold(struct _win_st *win, signed int y, float v, float tv, float minv, float maxv, signed char *cscale, unsigned long int tch)
{
  signed int return_value_cp_from_scale_1;
  if(tv < maxv && tv > minv)
  {
    if(v > tv)
      tch = tch | (unsigned long int)CP_STANDARD << 0 + 8;

    else
    {
      return_value_cp_from_scale_1=cp_from_scale(v, cscale, (_Bool)1);
      tch = tch | (unsigned long int)return_value_cp_from_scale_1;
    }
    double return_value_interpolate_2;
    return_value_interpolate_2=interpolate((const double)tv, (const double)minv, (const double)maxv);
    signed int return_value_wmove_3;
    return_value_wmove_3=wmove(win, y, (signed int)((double)1 + (double)(COLS - 2) * return_value_interpolate_2));
    if(return_value_wmove_3 == -1)
      -1;

    else
      waddch(win, tch);
  }

}

// wait_event
// file iw_scan.c line 90
static signed int wait_event(struct nl_msg *msg, void *arg)
{
  struct wait_event *wait = (struct wait_event *)arg;
  struct genlmsghdr *gnlh;
  struct nlmsghdr *return_value_nlmsg_hdr_1;
  return_value_nlmsg_hdr_1=nlmsg_hdr(msg);
  void *return_value_nlmsg_data_2;
  return_value_nlmsg_data_2=nlmsg_data(return_value_nlmsg_hdr_1);
  gnlh = (struct genlmsghdr *)return_value_nlmsg_data_2;
  signed int wait_event__1__i = 0;
  for( ; !(wait_event__1__i >= (signed int)wait->n_cmds); wait_event__1__i = wait_event__1__i + 1)
    if((unsigned int)gnlh->cmd == wait->cmds[(signed long int)wait_event__1__i])
      wait->cmd = (unsigned int)gnlh->cmd;

  return 1;
}

// wait_for_scan_events
// file iw_scan.c line 108
static _Bool wait_for_scan_events(struct scan_result *sr)
{
  static const unsigned int cmds[2l] = { (const unsigned int)NL80211_CMD_NEW_SCAN_RESULTS,
    (const unsigned int)NL80211_CMD_SCAN_ABORTED };
  struct wait_event wait_ev = { .cmds=cmds, .n_cmds=(unsigned char)(sizeof(const unsigned int [2l]) /*8ul*/  / sizeof(const unsigned int) /*4ul*/ ), .cmd=(unsigned int)0 };
  struct nl_cb *cb;
  if(scan_wait_sk == ((struct nl_sock *)NULL))
    scan_wait_sk=alloc_nl_mcast_sk("scan");

  cb=nl_cb_alloc((enum nl_cb_kind)(0 != 0 ? NL_CB_DEBUG : NL_CB_DEFAULT));
  if(cb == ((struct nl_cb *)NULL))
    err_sys("failed to allocate netlink callbacks");

  nl_cb_set(cb, (enum nl_cb_type)NL_CB_SEQ_CHECK, (enum nl_cb_kind)NL_CB_CUSTOM, no_seq_check, (void *)0);
  nl_cb_set(cb, (enum nl_cb_type)NL_CB_VALID, (enum nl_cb_kind)NL_CB_CUSTOM, wait_event, (void *)&wait_ev);
  while(wait_ev.cmd == 0u)
    nl_recvmsgs(scan_wait_sk, cb);
  nl_cb_put(cb);
  return wait_ev.cmd == (unsigned int)NL80211_CMD_NEW_SCAN_RESULTS;
}

// wclrtoborder
// file ui.c line 60
extern void wclrtoborder(struct _win_st *win)
{
  signed int x;
  signed int y;
  signed int tmp_if_expr_1;
  if(!(win == ((struct _win_st *)NULL)))
    tmp_if_expr_1 = (signed int)win->_cury;

  else
    tmp_if_expr_1 = -1;
  y = tmp_if_expr_1;
  signed int tmp_if_expr_2;
  if(!(win == ((struct _win_st *)NULL)))
    tmp_if_expr_2 = (signed int)win->_curx;

  else
    tmp_if_expr_2 = -1;
  x = tmp_if_expr_2;
  mvwclrtoborder(win, y, x);
}

// write_cf
// file conf.c line 132
static void write_cf(void)
{
  char tmp[256l];
  char rv[64l];
  struct conf_item *ci = (struct conf_item *)(void *)0;
  char *write_cf__1__lp;
  char *cp;
  signed int add;
  signed int write_cf__1__i;
  char *cfname;
  cfname=get_confname();
  signed int cfld;
  cfld=ll_create();
  struct _IO_FILE *fd;
  fd=fopen(cfname, "w");
  if(fd == ((struct _IO_FILE *)NULL))
    err_sys("failed to open configuration file '%s'", cfname);

  ll_reset(conf_items);
  void *return_value_ll_getall_1;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_16;
  unsigned long int return_value_argv_count_2;
  unsigned long int return_value_ll_size_3;
  unsigned long int return_value_strlen_12;
  unsigned long int return_value_strcspn_13;
  do
  {
    return_value_ll_getall_1=ll_getall(conf_items);
    ci = (struct conf_item *)return_value_ll_getall_1;
    if(ci == ((struct conf_item *)NULL))
      break;

    if(!((signed int)ci->type == t_sep))
    {
      if(!((signed int)ci->type == t_func))
      {
        if(ci->dep == ((signed int *)NULL))
          tmp_if_expr_17 = (_Bool)1;

        else
        {
          if(!(ci->dep == ((signed int *)NULL)))
            tmp_if_expr_16 = *ci->dep != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_16 = (_Bool)0;
          tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_17)
          switch((signed int)ci->type)
          {
            case t_int:
            {
              sprintf(rv, "%d", *ci->v.i);
              goto __CPROVER_DUMP_L10;
            }
            case t_list:
            {
              return_value_argv_count_2=argv_count_link1(ci->list);
              if(return_value_argv_count_2 == 0ul)
                break;

              sprintf(rv, "%s", ci->list[(signed long int)*ci->v.i]);
              str_tolower(rv);
              goto __CPROVER_DUMP_L10;
            }
            case t_sep:

            case t_func:
              ;
            default:
            {

            __CPROVER_DUMP_L10:
              ;
              add = 1;
              write_cf__1__i = 0;
              do
              {
                return_value_ll_size_3=ll_size(cfld);
                if((unsigned long int)write_cf__1__i >= return_value_ll_size_3)
                  break;

                void *return_value_ll_get_4;
                return_value_ll_get_4=ll_get(cfld, (unsigned long int)write_cf__1__i);
                write_cf__1__lp = (char *)return_value_ll_get_4;
                unsigned long int return_value_strspn_5;
                return_value_strspn_5=strspn(write_cf__1__lp, " ");
                write_cf__1__lp = write_cf__1__lp + (signed long int)return_value_strspn_5;
                cp = write_cf__1__lp;
                unsigned long int return_value_strcspn_14;
                return_value_strcspn_14=strcspn(cp, " =");
                signed int return_value_strncasecmp_15;
                return_value_strncasecmp_15=strncasecmp(cp, ci->cfname, return_value_strcspn_14);
                if(return_value_strncasecmp_15 == 0)
                {
                  return_value_strlen_12=strlen(ci->cfname);
                  return_value_strcspn_13=strcspn(cp, " =");
                  if(return_value_strlen_12 == return_value_strcspn_13)
                  {
                    add = 0;
                    unsigned long int return_value_strcspn_6;
                    return_value_strcspn_6=strcspn(cp, "=");
                    cp = cp + (signed long int)(return_value_strcspn_6 + (unsigned long int)1);
                    unsigned long int return_value_strspn_7;
                    return_value_strspn_7=strspn(cp, " ");
                    cp = cp + (signed long int)return_value_strspn_7;
                    unsigned long int return_value_strcspn_8;
                    return_value_strcspn_8=strcspn(cp, " #\n");
                    strncpy(tmp, cp, return_value_strcspn_8);
                    signed int return_value_strcasecmp_11;
                    return_value_strcasecmp_11=strcasecmp(tmp, rv);
                    if(!(return_value_strcasecmp_11 == 0))
                    {
                      unsigned long int return_value_strcspn_9;
                      return_value_strcspn_9=strcspn(write_cf__1__lp, " =");
                      strncpy(tmp, write_cf__1__lp, return_value_strcspn_9);
                      unsigned long int return_value_strcspn_10;
                      return_value_strcspn_10=strcspn(write_cf__1__lp, " =");
                      tmp[(signed long int)return_value_strcspn_10] = (char)0;
                      strcat(tmp, " = ");
                      strcat(tmp, rv);
                      strcat(tmp, "\n");
                      ll_replace(cfld, (unsigned long int)write_cf__1__i, "s", (const void *)tmp);
                    }

                  }

                }

                write_cf__1__i = write_cf__1__i + 1;
              }
              while((_Bool)1);
              if(!(add == 0))
              {
                strcpy(tmp, ci->cfname);
                strcat(tmp, " = ");
                strcat(tmp, rv);
                strcat(tmp, "\n");
                ll_push(cfld, "s", (const void *)tmp);
              }

            }
          }

      }

    }

  }
  while((_Bool)1);
  ll_reset(cfld);
  void *return_value_ll_getall_18;
  do
  {
    return_value_ll_getall_18=ll_getall(cfld);
    write_cf__1__lp = (char *)return_value_ll_getall_18;
    if(write_cf__1__lp == ((char *)NULL))
      break;

    fputs(write_cf__1__lp, fd);
  }
  while((_Bool)1);
  fclose(fd);
  ll_destroy(cfld);
  free((void *)cfname);
}

// xsignal
// file wavemon.h line 310
static inline void (*xsignal(signed int signo, void (*handler)(signed int)))(signed int)
{
  struct sigaction old_sa;
  struct sigaction sa = { .__sigaction_handler={ .sa_handler=handler }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  signed int return_value_sigemptyset_1;
  return_value_sigemptyset_1=sigemptyset(&sa.sa_mask);
  _Bool tmp_if_expr_3;
  signed int return_value_sigaction_2;
  if(!(return_value_sigemptyset_1 >= 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_sigaction_2=sigaction(signo, &sa, &old_sa);
    tmp_if_expr_3 = return_value_sigaction_2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    err_sys("xsignal(%d) failed", signo);

  return old_sa.__sigaction_handler.sa_handler;
}

// xsignal_link1
// file wavemon.h line 310
static inline void (*xsignal_link1(signed int signo_link1, void (*handler_link1)(signed int)))(signed int)
{
  struct sigaction old_sa_link1;
  struct sigaction sa_link1 = { .__sigaction_handler={ .sa_handler=handler_link1 }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  signed int return_value_sigemptyset_1_link1;
  return_value_sigemptyset_1_link1=sigemptyset(&sa_link1.sa_mask);
  _Bool tmp_if_expr_3_link1;
  signed int return_value_sigaction_2_link1;
  if(!(return_value_sigemptyset_1_link1 >= 0))
    tmp_if_expr_3_link1 = (_Bool)1;

  else
  {
    return_value_sigaction_2_link1=sigaction(signo_link1, &sa_link1, &old_sa_link1);
    tmp_if_expr_3_link1 = return_value_sigaction_2_link1 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3_link1)
    err_sys("xsignal(%d) failed", signo_link1);

  return old_sa_link1.__sigaction_handler.sa_handler;
}

// xsignal_link2
// file wavemon.h line 310
static inline void (*xsignal_link2(signed int signo_link2, void (*handler_link2)(signed int)))(signed int)
{
  struct sigaction old_sa_link2;
  struct sigaction sa_link2 = { .__sigaction_handler={ .sa_handler=handler_link2 }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  signed int return_value_sigemptyset_1_link2;
  return_value_sigemptyset_1_link2=sigemptyset(&sa_link2.sa_mask);
  _Bool tmp_if_expr_3_link2;
  signed int return_value_sigaction_2_link2;
  if(!(return_value_sigemptyset_1_link2 >= 0))
    tmp_if_expr_3_link2 = (_Bool)1;

  else
  {
    return_value_sigaction_2_link2=sigaction(signo_link2, &sa_link2, &old_sa_link2);
    tmp_if_expr_3_link2 = return_value_sigaction_2_link2 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3_link2)
    err_sys("xsignal(%d) failed", signo_link2);

  return old_sa_link2.__sigaction_handler.sa_handler;
}

