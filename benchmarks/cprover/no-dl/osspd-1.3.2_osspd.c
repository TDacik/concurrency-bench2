// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_10;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_8;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_4;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_7;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_6;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_12;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_5;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_9;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_13;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_11;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_old_mixer_info
// file /usr/include/linux/soundcard.h line 910
struct _old_mixer_info;

// tag-audio_buf_info
// file /usr/include/linux/soundcard.h line 568
struct audio_buf_info;

// tag-buffmem_desc
// file /usr/include/linux/soundcard.h line 611
struct buffmem_desc;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-count_info
// file /usr/include/linux/soundcard.h line 602
struct count_info;

// tag-cuse_info
// file /usr/include/fuse/cuse_lowlevel.h line 33
struct cuse_info;

// tag-cuse_lowlevel_ops
// file /usr/include/fuse/cuse_lowlevel.h line 49
struct cuse_lowlevel_ops;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-fuse_args
// file /usr/include/fuse/fuse_opt.h line 108
struct fuse_args;

// tag-fuse_chan
// file /usr/include/fuse/fuse_common.h line 193
struct fuse_chan;

// tag-fuse_conn_info
// file /usr/include/fuse/fuse_common.h line 140
struct fuse_conn_info;

// tag-fuse_ctx
// file /usr/include/fuse/fuse_lowlevel.h line 110
struct fuse_ctx;

// tag-fuse_file_info
// file /usr/include/fuse/fuse_common.h line 45
struct fuse_file_info;

// tag-fuse_opt
// file /usr/include/fuse/fuse_opt.h line 76
struct fuse_opt;

// tag-fuse_pollhandle
// file /usr/include/fuse/fuse_common.h line 194
struct fuse_pollhandle;

// tag-fuse_req
// file /usr/include/fuse/fuse_lowlevel.h line 50
struct fuse_req;

// tag-fuse_session
// file /usr/include/fuse/fuse_common.h line 192
struct fuse_session;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-list_head
// file ossp-util.h line 191
struct list_head;

// tag-mixer_info
// file /usr/include/linux/soundcard.h line 902
struct mixer_info;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-ossp_arg_size
// file ossp.h line 107
struct ossp_arg_size;

// tag-ossp_cmd
// file ossp.h line 89
struct ossp_cmd;

// tag-ossp_dsp_mmap_arg
// file ossp.h line 84
struct ossp_dsp_mmap_arg;

// tag-ossp_dsp_open_arg
// file ossp.h line 75
struct ossp_dsp_open_arg;

// tag-ossp_dsp_rw_arg
// file ossp.h line 80
struct ossp_dsp_rw_arg;

// tag-ossp_dsp_stream
// file osspd.c line 138
struct ossp_dsp_stream;

// tag-ossp_mixer
// file osspd.c line 79
struct ossp_mixer;

// tag-ossp_mixer_arg
// file ossp.h line 71
struct ossp_mixer_arg;

// tag-ossp_mixer_cmd
// file osspd.c line 90
struct ossp_mixer_cmd;

// tag-ossp_notify
// file ossp.h line 102
struct ossp_notify;

// tag-ossp_notify_opcode
// file ossp.h line 63
enum ossp_notify_opcode { OSSP_NOTIFY_POLL=0, OSSP_NOTIFY_OBITUARY=1, OSSP_NOTIFY_VOLCHG=2, OSSP_NR_NOTIFY_OPCODES=3 };

// tag-ossp_opcode
// file ossp.h line 27
enum ossp_opcode { OSSP_MIXER=0, OSSP_DSP_OPEN=1, OSSP_DSP_READ=2, OSSP_DSP_WRITE=3, OSSP_DSP_POLL=4, OSSP_DSP_MMAP=5, OSSP_DSP_MUNMAP=6, OSSP_DSP_RESET=7, OSSP_DSP_SYNC=8, OSSP_DSP_POST=9, OSSP_DSP_GET_RATE=10, OSSP_DSP_GET_CHANNELS=11, OSSP_DSP_GET_FORMAT=12, OSSP_DSP_GET_BLKSIZE=13, OSSP_DSP_GET_FORMATS=14, OSSP_DSP_SET_RATE=15, OSSP_DSP_SET_CHANNELS=16, OSSP_DSP_SET_FORMAT=17, OSSP_DSP_SET_SUBDIVISION=18, OSSP_DSP_SET_FRAGMENT=19, OSSP_DSP_GET_TRIGGER=20, OSSP_DSP_SET_TRIGGER=21, OSSP_DSP_GET_OSPACE=22, OSSP_DSP_GET_ISPACE=23, OSSP_DSP_GET_OPTR=24, OSSP_DSP_GET_IPTR=25, OSSP_DSP_GET_ODELAY=26, OSSP_NR_OPCODES=27 };

// tag-ossp_param
// file osspd.c line 2015
struct ossp_param;

// tag-ossp_reply
// file ossp.h line 96
struct ossp_reply;

// tag-ossp_stream
// file osspd.c line 100
struct ossp_stream;

// tag-ossp_uid_cnt
// file osspd.c line 73
struct ossp_uid_cnt;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-ring_buf
// file ossp-util.h line 94
struct ring_buf;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sized_buf
// file ossp-util.h line 135
struct sized_buf;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// INIT_LIST_HEAD
// file ossp-util.h line 200
static inline void INIT_LIST_HEAD(struct list_head *list);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __clear_bit
// file ossp-util.h line 152
extern void __clear_bit(signed int nr, volatile unsigned long int *addr);
// __cmsg_nxthdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 272
extern struct cmsghdr * __cmsg_nxthdr(struct msghdr *, struct cmsghdr *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __ffs
// file ossp-util.c line 221
static unsigned long int __ffs(unsigned long int word);
// __list_add
// file ossp-util.h line 212
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __list_del
// file ossp-util.h line 255
static inline void __list_del(struct list_head *prev, struct list_head *next);
// __set_bit
// file ossp-util.h line 151
extern void __set_bit(signed int nr, volatile unsigned long int *addr);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// alloc_os
// file osspd.c line 901
static signed int alloc_os(unsigned long int stream_size, unsigned long int mmap_size, signed int pid, unsigned int pgrp, unsigned int uid, unsigned int gid, signed int cmd_sock, const signed int *notify, struct fuse_session *se, struct ossp_stream **osp);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// clearenv
// file /usr/include/stdlib.h line 595
extern signed int clearenv(void);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// create_os
// file osspd.c line 1110
static signed int create_os(const char *slave_path, unsigned long int stream_size, unsigned long int mmap_size, signed int pid, signed int pgrp, unsigned int uid, unsigned int gid, struct fuse_session *se, struct ossp_stream **osp);
// cuse_lowlevel_setup
// file /usr/include/fuse/cuse_lowlevel.h line 73
struct fuse_session * cuse_lowlevel_setup(signed int, char **, struct cuse_info *, struct cuse_lowlevel_ops *, signed int *, void *);
// cuse_lowlevel_teardown
// file /usr/include/fuse/cuse_lowlevel.h line 78
void cuse_lowlevel_teardown(struct fuse_session *);
// cuse_worker
// file osspd.c line 2094
static void * cuse_worker(void *arg);
// dsp_ioctl
// file osspd.c line 1483
static void dsp_ioctl(struct fuse_req *req, signed int signed_cmd, void *uarg, struct fuse_file_info *fi, unsigned int flags, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz);
// dsp_open
// file osspd.c line 1358
static void dsp_open(struct fuse_req *req, struct fuse_file_info *fi);
// dsp_open_common
// file osspd.c line 1291
static void dsp_open_common(struct fuse_req *req, struct fuse_file_info *fi, struct fuse_session *se);
// dsp_poll
// file osspd.c line 1454
static void dsp_poll(struct fuse_req *req, struct fuse_file_info *fi, struct fuse_pollhandle *ph);
// dsp_read
// file osspd.c line 1380
static void dsp_read(struct fuse_req *req, unsigned long int size, signed long int off, struct fuse_file_info *fi);
// dsp_release
// file osspd.c line 1368
static void dsp_release(struct fuse_req *req, struct fuse_file_info *fi);
// dsp_write
// file osspd.c line 1421
static void dsp_write(struct fuse_req *req, const char *buf, unsigned long int size, signed long int off, struct fuse_file_info *fi);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// ensure_sbuf_size
// file ossp-util.c line 205
signed int ensure_sbuf_size(struct sized_buf *sbuf, unsigned long int size);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// exec_cmd
// file osspd.c line 355
static signed long int exec_cmd(struct ossp_stream *os, enum ossp_opcode opcode, const void *carg, unsigned long int carg_size, const void *din, unsigned long int din_size, void *rarg, unsigned long int rarg_size, void *dout, unsigned long int *dout_sizep, signed int fd);
// exec_cmd_intern
// file osspd.c line 259
static signed long int exec_cmd_intern(struct ossp_stream *os, enum ossp_opcode opcode, const void *carg, unsigned long int carg_size, const void *din, unsigned long int din_size, void *rarg, unsigned long int rarg_size, void *dout, unsigned long int *dout_sizep, signed int fd);
// exec_mixer_cmd
// file osspd.c line 621
static signed int exec_mixer_cmd(struct ossp_mixer_cmd *mxcmd, struct ossp_stream *os);
// exec_simple_cmd
// file osspd.c line 424
static signed long int exec_simple_cmd(struct ossp_stream *os, enum ossp_opcode opcode, void *carg, void *rarg);
// execv
// file /usr/include/unistd.h line 563
extern signed int execv(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// find_mixer
// file osspd.c line 216
static struct ossp_mixer * find_mixer(signed int pgrp);
// find_mixer_locked
// file osspd.c line 206
static struct ossp_mixer * find_mixer_locked(signed int pgrp);
// find_next_zero_bit
// file ossp-util.h line 148
unsigned long int find_next_zero_bit(const unsigned long int *addr, unsigned long int size, unsigned long int offset);
// find_os
// file osspd.c line 226
static struct ossp_stream * find_os(unsigned int id);
// find_os_by_notify_rx
// file osspd.c line 240
static struct ossp_stream * find_os_by_notify_rx(signed int notify_rx);
// finish_mixer_cmd
// file osspd.c line 651
static void finish_mixer_cmd(struct ossp_mixer_cmd *mxcmd);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fuse_chan_fd
// file /usr/include/fuse/fuse_lowlevel.h line 1765
signed int fuse_chan_fd(struct fuse_chan *);
// fuse_lowlevel_notify_poll
// file /usr/include/fuse/fuse_lowlevel.h line 1324
signed int fuse_lowlevel_notify_poll(struct fuse_pollhandle *);
// fuse_opt_add_arg
// file /usr/include/fuse/fuse_opt.h line 230
signed int fuse_opt_add_arg(struct fuse_args *, const char *);
// fuse_opt_parse
// file /usr/include/fuse/fuse_opt.h line 202
signed int fuse_opt_parse(struct fuse_args *, void *, struct fuse_opt *, signed int (*)(void *, const char *, signed int, struct fuse_args *));
// fuse_pollhandle_destroy
// file /usr/include/fuse/fuse_common.h line 260
void fuse_pollhandle_destroy(struct fuse_pollhandle *);
// fuse_reply_buf
// file /usr/include/fuse/fuse_lowlevel.h line 1150
signed int fuse_reply_buf(struct fuse_req *, const char *, unsigned long int);
// fuse_reply_err
// file /usr/include/fuse/fuse_lowlevel.h line 1039
signed int fuse_reply_err(struct fuse_req *, signed int);
// fuse_reply_ioctl
// file /usr/include/fuse/fuse_lowlevel.h line 1289
signed int fuse_reply_ioctl(struct fuse_req *, signed int, const void *, unsigned long int);
// fuse_reply_ioctl_retry
// file /usr/include/fuse/fuse_lowlevel.h line 1274
signed int fuse_reply_ioctl_retry(struct fuse_req *, struct iovec *, unsigned long int, struct iovec *, unsigned long int);
// fuse_reply_open
// file /usr/include/fuse/fuse_lowlevel.h line 1125
signed int fuse_reply_open(struct fuse_req *, struct fuse_file_info *);
// fuse_reply_poll
// file /usr/include/fuse/fuse_lowlevel.h line 1311
signed int fuse_reply_poll(struct fuse_req *, unsigned int);
// fuse_reply_write
// file /usr/include/fuse/fuse_lowlevel.h line 1137
signed int fuse_reply_write(struct fuse_req *, unsigned long int);
// fuse_req_ctx
// file /usr/include/fuse/fuse_lowlevel.h line 1450
struct fuse_ctx * fuse_req_ctx(struct fuse_req *);
// fuse_session_loop_mt
// file /usr/include/fuse/fuse_lowlevel.h line 1703
signed int fuse_session_loop_mt(struct fuse_session *);
// fuse_session_next_chan
// file /usr/include/fuse/fuse_lowlevel.h line 1610
struct fuse_chan * fuse_session_next_chan(struct fuse_session *, struct fuse_chan *);
// get_mixer
// file osspd.c line 509
static struct ossp_mixer * get_mixer(signed int pgrp);
// get_proc_self_info
// file ossp-util.h line 159
signed int get_proc_self_info(signed int pid, signed int *ppid_r, char *cmd_buf, unsigned long int cmd_buf_sz);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getpwuid_r
// file /usr/include/pwd.h line 144
extern signed int getpwuid_r(unsigned int, struct passwd *, char *, unsigned long int, struct passwd ** restrict );
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// init_mixer_cmd
// file osspd.c line 612
static void init_mixer_cmd(struct ossp_mixer_cmd *mxcmd, struct ossp_mixer *mixer);
// ioctl_prep_uarg
// file osspd.c line 432
static signed int ioctl_prep_uarg(struct fuse_req *req, void *in, unsigned long int in_sz, void *out, unsigned long int out_sz, void *uarg, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz);
// list_add
// file ossp-util.h line 230
static inline void list_add(struct list_head *new, struct list_head *head);
// list_add_tail
// file ossp-util.h line 243
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_del_init
// file ossp-util.h line 301
static inline void list_del_init(struct list_head *entry);
// list_empty
// file ossp-util.h line 345
static inline signed int list_empty(struct list_head *head);
// log_msg
// file ossp-util.h line 68
void log_msg(signed int severity, const char *fmt, ...);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mixer_delayed_put_worker
// file osspd.c line 579
static void * mixer_delayed_put_worker(void *arg);
// mixer_do_ioctl
// file osspd.c line 752
static void mixer_do_ioctl(struct fuse_req *req, struct ossp_mixer *mixer, unsigned int cmd, void *uarg, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz);
// mixer_ioctl
// file osspd.c line 868
static void mixer_ioctl(struct fuse_req *req, signed int signed_cmd, void *uarg, struct fuse_file_info *fi, unsigned int flags, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz);
// mixer_open
// file osspd.c line 846
static void mixer_open(struct fuse_req *req, struct fuse_file_info *fi);
// mixer_release
// file osspd.c line 884
static void mixer_release(struct fuse_req *req, struct fuse_file_info *fi);
// mixer_simple_ioctl
// file osspd.c line 696
static void mixer_simple_ioctl(struct fuse_req *req, struct ossp_mixer *mixer, unsigned int cmd, void *uarg, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz, signed int *not_minep);
// mixer_tbl_head
// file osspd.c line 186
static struct list_head * mixer_tbl_head(signed int pid);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// notify_poller
// file osspd.c line 1747
static void * notify_poller(void *arg);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// os_notify_tbl_head
// file osspd.c line 201
static struct list_head * os_notify_tbl_head(signed int notify_rx);
// os_pgrp_tbl_head
// file osspd.c line 196
static struct list_head * os_pgrp_tbl_head(signed int pgrp);
// os_tbl_head
// file osspd.c line 191
static struct list_head * os_tbl_head(unsigned long int id);
// ossp_daemonize
// file osspd.c line 1891
static void ossp_daemonize(void);
// ossp_init_done
// file osspd.c line 1942
static void ossp_init_done(void *userdata);
// ossp_slave_init
// file ossp-slave.c line 44
void ossp_slave_init(signed int argc, char **argv);
// ossp_slave_process_command
// file ossp-slave.c line 133
signed int ossp_slave_process_command(signed int cmd_fd, signed long int (* const *action_fn_tbl)(enum ossp_opcode, void *, void *, unsigned long int, void *, void *, unsigned long int *, signed int), signed int (*action_pre_fn)(void), void (*action_post_fn)(void));
// ossp_slave_process_command::action_fn_tbl_object_object
//
signed long int action_fn_tbl_object_object(enum ossp_opcode, void *, void *, unsigned long int, void *, void *, unsigned long int *, signed int);
// ossp_slave_process_command::action_post_fn_object
//
void action_post_fn_object(void);
// ossp_slave_process_command::action_pre_fn_object
//
signed int action_pre_fn_object(void);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// process_arg
// file osspd.c line 2105
static signed int process_arg(void *data, const char *arg, signed int key, struct fuse_args *outargs);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_3 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_3 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_3 *, union anonymous_0 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_3 *, union anonymous_0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_0 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_0 *, const union anonymous_1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// put_mixer
// file osspd.c line 559
static void put_mixer(struct ossp_mixer *mixer);
// put_mixer_real
// file osspd.c line 485
static void put_mixer_real(struct ossp_mixer *mixer);
// put_os
// file osspd.c line 1020
static void put_os(struct ossp_stream *os);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_fill
// file ossp-util.h line 142
signed int read_fill(signed int fd, void *buf, unsigned long int size);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// ring_bytes
// file ossp-util.h line 106
static inline unsigned long int ring_bytes(struct ring_buf *ring);
// ring_consume
// file ossp-util.h line 116
static inline void ring_consume(struct ring_buf *ring, unsigned long int size);
// ring_data
// file ossp-util.c line 169
void * ring_data(struct ring_buf *ring, unsigned long int *sizep);
// ring_fill
// file ossp-util.c line 145
void ring_fill(struct ring_buf *ring, const void *buf, unsigned long int size);
// ring_resize
// file ossp-util.c line 182
signed int ring_resize(struct ring_buf *ring, unsigned long int new_size);
// ring_space
// file ossp-util.h line 111
static inline unsigned long int ring_space(struct ring_buf *ring);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// set_extra_env
// file osspd.c line 1058
static void set_extra_env(signed int pid);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setresgid
// file /usr/include/unistd.h line 748
extern signed int setresgid(unsigned int, unsigned int, unsigned int);
// setresuid
// file /usr/include/unistd.h line 743
extern signed int setresuid(unsigned int, unsigned int, unsigned int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setup_ossp_cuse
// file osspd.c line 2060
static struct fuse_session * setup_ossp_cuse(struct cuse_lowlevel_ops *ops, const char *name, signed int major, signed int minor, signed int argc, char **argv);
// shutdown_notification
// file osspd.c line 990
static void shutdown_notification(struct ossp_stream *os);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// slave_reaper
// file osspd.c line 1849
static void * slave_reaper(void *arg);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_fill
// file ossp-util.h line 143
signed int write_fill(signed int fd, const void *buf, unsigned long int size);

struct anonymous_10
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_8
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_2
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_4
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_7
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_5
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_11
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_4 _kill;
  // _timer
  struct anonymous_5 _timer;
  // _rt
  struct anonymous_6 _rt;
  // _sigchld
  struct anonymous_7 _sigchld;
  // _sigfault
  struct anonymous_8 _sigfault;
  // _sigpoll
  struct anonymous_9 _sigpoll;
  // _sigsys
  struct anonymous_10 _sigsys;
};

struct anonymous_12
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_11 _sifields;
};

union anonymous_13
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_12 *, void *);
};

union anonymous_1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_3
{
  // __data
  struct anonymous_2 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _old_mixer_info
{
  // id
  char id[16l];
  // name
  char name[32l];
};

struct audio_buf_info
{
  // fragments
  signed int fragments;
  // fragstotal
  signed int fragstotal;
  // fragsize
  signed int fragsize;
  // bytes
  signed int bytes;
};

struct buffmem_desc
{
  // buffer
  unsigned int *buffer;
  // size
  signed int size;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct count_info
{
  // bytes
  signed int bytes;
  // blocks
  signed int blocks;
  // ptr
  signed int ptr;
};

struct cuse_info
{
  // dev_major
  unsigned int dev_major;
  // dev_minor
  unsigned int dev_minor;
  // dev_info_argc
  unsigned int dev_info_argc;
  // dev_info_argv
  const char **dev_info_argv;
  // flags
  unsigned int flags;
};

struct cuse_lowlevel_ops
{
  // init
  void (*init)(void *, struct fuse_conn_info *);
  // init_done
  void (*init_done)(void *);
  // destroy
  void (*destroy)(void *);
  // open
  void (*open)(struct fuse_req *, struct fuse_file_info *);
  // read
  void (*read)(struct fuse_req *, unsigned long int, signed long int, struct fuse_file_info *);
  // write
  void (*write)(struct fuse_req *, const char *, unsigned long int, signed long int, struct fuse_file_info *);
  // flush
  void (*flush)(struct fuse_req *, struct fuse_file_info *);
  // release
  void (*release)(struct fuse_req *, struct fuse_file_info *);
  // fsync
  void (*fsync)(struct fuse_req *, signed int, struct fuse_file_info *);
  // ioctl
  void (*ioctl)(struct fuse_req *, signed int, void *, struct fuse_file_info *, unsigned int, const void *, unsigned long int, unsigned long int);
  // poll
  void (*poll)(struct fuse_req *, struct fuse_file_info *, struct fuse_pollhandle *);
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct fuse_args
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // allocated
  signed int allocated;
};

struct fuse_conn_info
{
  // proto_major
  unsigned int proto_major;
  // proto_minor
  unsigned int proto_minor;
  // async_read
  unsigned int async_read;
  // max_write
  unsigned int max_write;
  // max_readahead
  unsigned int max_readahead;
  // capable
  unsigned int capable;
  // want
  unsigned int want;
  // max_background
  unsigned int max_background;
  // congestion_threshold
  unsigned int congestion_threshold;
  // reserved
  unsigned int reserved[23l];
};

struct fuse_ctx
{
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // pid
  signed int pid;
  // umask
  unsigned int umask;
};

struct fuse_file_info
{
  // flags
  signed int flags;
  // fh_old
  unsigned long int fh_old;
  // writepage
  signed int writepage;
  // direct_io
  unsigned int direct_io : 1;
  // keep_cache
  unsigned int keep_cache : 1;
  // flush
  unsigned int flush : 1;
  // nonseekable
  unsigned int nonseekable : 1;
  // flock_release
  unsigned int flock_release : 1;
  // padding
  unsigned int padding : 27;
  // fh
  unsigned long int fh;
  // lock_owner
  unsigned long int lock_owner;
};

struct fuse_opt
{
  // templ
  const char *templ;
  // offset
  unsigned long int offset;
  // value
  signed int value;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct mixer_info
{
  // id
  char id[16l];
  // name
  char name[32l];
  // modify_counter
  signed int modify_counter;
  // fillers
  signed int fillers[10l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct ossp_arg_size
{
  // carg_size
  signed long int carg_size;
  // rarg_size
  signed long int rarg_size;
  // has_fd
  unsigned int has_fd : 1;
};

struct ossp_cmd
{
  // magic
  unsigned int magic;
  // opcode
  enum ossp_opcode opcode;
  // din_size
  unsigned long int din_size;
  // dout_size
  unsigned long int dout_size;
};

struct ossp_dsp_mmap_arg
{
  // dir
  signed int dir;
  // size
  unsigned long int size;
};

struct ossp_dsp_open_arg
{
  // flags
  signed int flags;
  // opener_pid
  signed int opener_pid;
};

struct ossp_dsp_rw_arg
{
  // nonblock
  unsigned int nonblock : 1;
};

struct ossp_stream
{
  // id
  unsigned int id;
  // link
  struct list_head link;
  // pgrp_link
  struct list_head pgrp_link;
  // notify_link
  struct list_head notify_link;
  // refcnt
  unsigned int refcnt;
  // cmd_mutex
  union anonymous_0 cmd_mutex;
  // mmap_mutex
  union anonymous_0 mmap_mutex;
  // ph
  struct fuse_pollhandle *ph;
  // pid
  signed int pid;
  // pgrp
  signed int pgrp;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // slave_pid
  signed int slave_pid;
  // cmd_fd
  signed int cmd_fd;
  // notify_tx
  signed int notify_tx;
  // notify_rx
  signed int notify_rx;
  // dead
  signed int dead;
  // mixer_pending
  signed int mixer_pending;
  // vol
  signed int vol[2l][2l];
  // vol_set
  signed int vol_set[2l][2l];
  // mmap_off
  signed long int mmap_off;
  // mmap_size
  unsigned long int mmap_size;
  // ucnt
  struct ossp_uid_cnt *ucnt;
  // se
  struct fuse_session *se;
  // mixer
  struct ossp_mixer *mixer;
};

struct ossp_dsp_stream
{
  // os
  struct ossp_stream os;
  // rw
  unsigned int rw;
  // mmapped
  unsigned int mmapped;
  // nonblock
  signed int nonblock;
};

struct ossp_mixer
{
  // pgrp
  signed int pgrp;
  // link
  struct list_head link;
  // delayed_put_link
  struct list_head delayed_put_link;
  // refcnt
  unsigned int refcnt;
  // vol
  signed int vol[2l][2l];
  // modify_counter
  signed int modify_counter;
  // put_expires
  signed long int put_expires;
};

struct ossp_mixer_arg
{
  // vol
  signed int vol[2l][2l];
};

struct ossp_mixer_cmd
{
  // mixer
  struct ossp_mixer *mixer;
  // set
  struct ossp_mixer_arg set;
  // out_dir
  signed int out_dir;
  // rvol
  signed int rvol;
};

struct ossp_notify
{
  // magic
  unsigned int magic;
  // opcode
  enum ossp_notify_opcode opcode;
};

struct ossp_param
{
  // dsp_name
  char *dsp_name;
  // dsp_major
  unsigned int dsp_major;
  // dsp_minor
  unsigned int dsp_minor;
  // adsp_name
  char *adsp_name;
  // adsp_major
  unsigned int adsp_major;
  // adsp_minor
  unsigned int adsp_minor;
  // mixer_name
  char *mixer_name;
  // mixer_major
  unsigned int mixer_major;
  // mixer_minor
  unsigned int mixer_minor;
  // max_streams
  unsigned int max_streams;
  // umax_streams
  unsigned int umax_streams;
  // dsp_slave_path
  char *dsp_slave_path;
  // log_level
  unsigned int log_level;
  // exit_on_idle
  signed int exit_on_idle;
  // timestamp
  signed int timestamp;
  // fg
  signed int fg;
  // help
  signed int help;
};

struct ossp_reply
{
  // magic
  unsigned int magic;
  // result
  signed int result;
  // dout_size
  unsigned long int dout_size;
};

struct ossp_uid_cnt
{
  // link
  struct list_head link;
  // uid
  unsigned int uid;
  // nr_os
  unsigned int nr_os;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ring_buf
{
  // buf
  char *buf;
  // size
  unsigned long int size;
  // head
  unsigned long int head;
  // bytes
  unsigned long int bytes;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_13 __sigaction_handler;
  // sa_mask
  struct anonymous sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sized_buf
{
  // buf
  char *buf;
  // size
  unsigned long int size;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// adsp_se
// file osspd.c line 177
static struct fuse_session *adsp_se;
// cuse_adsp_thread
// file osspd.c line 166
static unsigned long int cuse_adsp_thread;
// cuse_mixer_thread
// file osspd.c line 165
static unsigned long int cuse_mixer_thread;
// dsp_ops
// file osspd.c line 1964
static struct cuse_lowlevel_ops dsp_ops;
// dsp_ops
// file osspd.c line 1964
static struct cuse_lowlevel_ops dsp_ops = { .init=((void (*)(void *, struct fuse_conn_info *))NULL), .init_done=ossp_init_done,
    .destroy=((void (*)(void *))NULL), .open=dsp_open,
    .read=dsp_read, .write=dsp_write, .flush=((void (*)(struct fuse_req *, struct fuse_file_info *))NULL),
    .release=dsp_release,
    .fsync=((void (*)(struct fuse_req *, signed int, struct fuse_file_info *))NULL), .ioctl=dsp_ioctl,
    .poll=dsp_poll };
// dsp_se
// file osspd.c line 176
static struct fuse_session *dsp_se;
// dsp_slave_path
// file osspd.c line 150
static char dsp_slave_path[4096l];
// exit_on_idle
// file osspd.c line 174
static signed int exit_on_idle;
// hashtbl_size
// file osspd.c line 149
static unsigned int hashtbl_size;
// init_wait_fd
// file osspd.c line 173
static signed int init_wait_fd = -1;
// max_streams
// file osspd.c line 147
static unsigned int max_streams;
// mixer_delayed_put_cond
// file osspd.c line 171
static union anonymous_3 mixer_delayed_put_cond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mixer_delayed_put_head
// file osspd.c line 170
static struct list_head mixer_delayed_put_head;
// mixer_delayed_put_head
// file osspd.c line 170
static struct list_head mixer_delayed_put_head = { .next=&mixer_delayed_put_head, .prev=&mixer_delayed_put_head };
// mixer_delayed_put_thread
// file osspd.c line 164
static unsigned long int mixer_delayed_put_thread;
// mixer_mutex
// file osspd.c line 153
static union anonymous_0 mixer_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mixer_ops
// file osspd.c line 1958
static struct cuse_lowlevel_ops mixer_ops;
// mixer_ops
// file osspd.c line 1958
static struct cuse_lowlevel_ops mixer_ops = { .init=((void (*)(void *, struct fuse_conn_info *))NULL), .init_done=((void (*)(void *))NULL),
    .destroy=((void (*)(void *))NULL),
    .open=mixer_open, .read=((void (*)(struct fuse_req *, unsigned long int, signed long int, struct fuse_file_info *))NULL),
    .write=((void (*)(struct fuse_req *, const char *, unsigned long int, signed long int, struct fuse_file_info *))NULL),
    .flush=((void (*)(struct fuse_req *, struct fuse_file_info *))NULL),
    .release=mixer_release,
    .fsync=((void (*)(struct fuse_req *, signed int, struct fuse_file_info *))NULL), .ioctl=mixer_ioctl,
    .poll=((void (*)(struct fuse_req *, struct fuse_file_info *, struct fuse_pollhandle *))NULL) };
// mixer_se
// file osspd.c line 175
static struct fuse_session *mixer_se;
// mixer_tbl
// file osspd.c line 156
static struct list_head *mixer_tbl;
// mutex
// file osspd.c line 152
static union anonymous_0 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// notify_epfd
// file osspd.c line 161
static signed int notify_epfd;
// notify_poller_kill_wait
// file osspd.c line 167
static union anonymous_3 notify_poller_kill_wait = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// notify_poller_thread
// file osspd.c line 162
static unsigned long int notify_poller_thread;
// nr_mixers
// file osspd.c line 155
static unsigned int nr_mixers;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// os_id_bitmap
// file osspd.c line 154
static unsigned long int *os_id_bitmap;
// os_notify_tbl
// file osspd.c line 159
static struct list_head *os_notify_tbl;
// os_pgrp_tbl
// file osspd.c line 158
static struct list_head *os_pgrp_tbl;
// os_tbl
// file osspd.c line 157
static struct list_head *os_tbl;
// ossp_arg_sizes
// file ossp.c line 12
struct ossp_arg_size ossp_arg_sizes[27l] = { { .carg_size=(signed long int)sizeof(struct ossp_mixer_arg) /*16ul*/ , .rarg_size=(signed long int)sizeof(struct ossp_mixer_arg) /*16ul*/ ,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(struct ossp_dsp_open_arg) /*8ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(struct ossp_dsp_rw_arg) /*4ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(struct ossp_dsp_rw_arg) /*4ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)sizeof(unsigned int) /*4ul*/ ,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(struct ossp_dsp_mmap_arg) /*16ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)0, .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)0, .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)0, .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ ,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ ,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ ,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ ,
    .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)sizeof(signed int) /*4ul*/ , .rarg_size=(signed long int)0,
    .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(struct audio_buf_info) /*16ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(struct audio_buf_info) /*16ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(struct count_info) /*12ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(struct count_info) /*12ul*/ , .has_fd=0 },
    { .carg_size=(signed long int)0, .rarg_size=(signed long int)sizeof(signed int) /*4ul*/ , .has_fd=0 } };
// ossp_cmd_fd
// file ossp-slave.c line 41
signed int ossp_cmd_fd = -1;
// ossp_cmd_str
// file ossp.c line 45
const char *ossp_cmd_str[27l] = { "MIXER", "OPEN", "READ", "WRITE", "POLL", "MMAP", "MUNMAP", "RESET", "SYNC", "POST", "GET_RATE", "GET_CHANNELS", "GET_FORMAT", "GET_BLKSIZE", "GET_FORMATS", "SET_RATE", "SET_CHANNELS", "SET_FORMAT", "SET_BUSDIVISION", "SET_FRAGMENT", "GET_TRIGGER", "SET_TRIGGER", "GET_OSPACE", "GET_ISPACE", "GET_OPTR", "GET_IPTR", "GET_ODELAY" };
// ossp_log_level
// file ossp-util.c line 29
signed int ossp_log_level = 4;
// ossp_log_name
// file ossp-util.c line 28
char ossp_log_name[128l];
// ossp_log_timestamp
// file ossp-util.c line 30
signed int ossp_log_timestamp;
// ossp_mmap_addr
// file ossp-slave.c line 42
void *ossp_mmap_addr[2l];
// ossp_notify_fd
// file ossp-slave.c line 41
signed int ossp_notify_fd = -1;
// ossp_notify_str
// file ossp.c line 79
const char *ossp_notify_str[3l] = { "POLL", "OBITUARY", "VOLCHG" };
// ossp_opts
// file osspd.c line 2037
static struct fuse_opt ossp_opts[20l] = { { .templ="--dsp=%s", .offset=0ul, .value=1 },
    { .templ="--dsp-maj=%u", .offset=8ul, .value=1 },
    { .templ="--dsp-min=%u", .offset=12ul, .value=1 },
    { .templ="--adsp=%s", .offset=16ul, .value=1 },
    { .templ="--adsp-maj=%u", .offset=24ul, .value=1 },
    { .templ="--adsp-min=%u", .offset=28ul, .value=1 },
    { .templ="--mixer=%s", .offset=32ul, .value=1 },
    { .templ="--mixer-maj=%u", .offset=40ul, .value=1 },
    { .templ="--mixer-min=%u", .offset=44ul, .value=1 },
    { .templ="--max=%u", .offset=48ul, .value=1 },
    { .templ="--umax=%u", .offset=52ul, .value=1 },
    { .templ="--exit-on-idle", .offset=68ul, .value=1 },
    { .templ="--dsp-slave=%s", .offset=56ul, .value=1 },
    { .templ="--timestamp", .offset=72ul, .value=1 },
    { .templ="--log=%u", .offset=64ul, .value=1 },
    { .templ="-f", .offset=76ul, .value=1 },
    { .templ="-h", .offset=(unsigned long int)-1U, .value=0 },
    { .templ="--help", .offset=(unsigned long int)-1U, .value=0 },
    { .templ="-v", .offset=(unsigned long int)-1U, .value=1 },
    { .templ=(const char *)(void *)0, .offset=(unsigned long int)0, .value=0 } };
// ossp_user_name
// file ossp-slave.c line 40
char ossp_user_name[128l];
// severity_map
// file ossp-util.c line 41
static signed int severity_map[7l] = { 0, 3, 3, 4, 6, 7, 7 };
// severity_strs
// file ossp-util.c line 32
static const char *severity_strs[7l] = { ((const char *)NULL), "CRIT", " ERR", "WARN", (const char *)(void *)0, "DBG0", "DBG1" };
// slave_corpse_list
// file osspd.c line 169
static struct list_head slave_corpse_list;
// slave_corpse_list
// file osspd.c line 169
static struct list_head slave_corpse_list = { .next=&slave_corpse_list, .prev=&slave_corpse_list };
// slave_reaper_thread
// file osspd.c line 163
static unsigned long int slave_reaper_thread;
// slave_reaper_wait
// file osspd.c line 168
static union anonymous_3 slave_reaper_wait = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// uid_cnt_list
// file osspd.c line 160
static struct list_head uid_cnt_list;
// uid_cnt_list
// file osspd.c line 160
static struct list_head uid_cnt_list = { .next=&uid_cnt_list, .prev=&uid_cnt_list };
// umax_streams
// file osspd.c line 148
static unsigned int umax_streams;
// usage
// file osspd.c line 1991
static const char *usage = "usage: osspd [options]\n\noptions:\n    --help            print this help message\n    --dsp=NAME        DSP device name (default dsp)\n    --dsp-maj=MAJ     DSP device major number (default 14)\n    --dsp-min=MIN     DSP device minor number (default 3)\n    --adsp=NAME       Aux DSP device name (default adsp, blank to disable)\n    --adsp-maj=MAJ    Aux DSP device major number (default 14)\n    --adsp-min=MIN    Aux DSP device minor number (default 12)\n    --mixer=NAME      mixer device name (default mixer, blank to disable)\n    --mixer-maj=MAJ   mixer device major number (default 14)\n    --mixer-min=MIN   mixer device minor number (default 0)\n    --max=MAX         maximum number of open streams (default 256)\n    --umax=MAX        maximum number of open streams per UID (default --max)\n    --exit-on-idle    exit if idle\n    --dsp-slave=PATH  DSP slave (default: /usr/lib/osspd/ossp-padsp)\n    --log=LEVEL       log level (0..6)\n    --timestamp       timestamp log messages\n    -v                increase verbosity, can be specified multiple times\n    -f                Run in foreground (don't daemonize)\n\n";
// usage_link1
// file ossp-slave.c line 24
static const char *usage_link1 = "usage: ossp-SLAVE [options]\n\nproxies commands from osspd to pulseaudio\n\noptions:\n    -u UID            uid to use\n    -g GID            gid to use\n    -c CMD_FD         fd to receive commands from osspd\n    -n NOTIFY_FD      fd to send async notifications to osspd\n    -m MMAP_FD        fd to use for mmap\n    -o MMAP_OFFSET    mmap offset\n    -s MMAP_SIZE      mmap size\n    -l LOG_LEVEL      set log level\n    -t                enable log timestamps\n";

// INIT_LIST_HEAD
// file ossp-util.h line 200
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  list->next = list;
  list->prev = list;
}

// __clear_bit
// file ossp-util.h line 152
extern void __clear_bit(signed int nr, volatile unsigned long int *addr)
{
  unsigned long int mask = 1UL << (unsigned long int)nr % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  unsigned long int *p = (unsigned long int *)addr + (signed long int)((unsigned long int)nr / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ));
  *p = *p & ~mask;
}

// __ffs
// file ossp-util.c line 221
static unsigned long int __ffs(unsigned long int word)
{
  signed int num = 0;
  if((4294967295ul & word) == 0ul)
  {
    num = num + 32;
    word = word >> 32;
  }

  if((65535ul & word) == 0ul)
  {
    num = num + 16;
    word = word >> 16;
  }

  if((255ul & word) == 0ul)
  {
    num = num + 8;
    word = word >> 8;
  }

  if((15ul & word) == 0ul)
  {
    num = num + 4;
    word = word >> 4;
  }

  if((3ul & word) == 0ul)
  {
    num = num + 2;
    word = word >> 2;
  }

  if((1ul & word) == 0ul)
    num = num + 1;

  return (unsigned long int)num;
}

// __list_add
// file ossp-util.h line 212
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_del
// file ossp-util.h line 255
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// __set_bit
// file ossp-util.h line 151
extern void __set_bit(signed int nr, volatile unsigned long int *addr)
{
  unsigned long int mask = 1UL << (unsigned long int)nr % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
  unsigned long int *p = (unsigned long int *)addr + (signed long int)((unsigned long int)nr / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ));
  *p = *p | mask;
}

// alloc_os
// file osspd.c line 901
static signed int alloc_os(unsigned long int stream_size, unsigned long int mmap_size, signed int pid, unsigned int pgrp, unsigned int uid, unsigned int gid, signed int cmd_sock, const signed int *notify, struct fuse_session *se, struct ossp_stream **osp)
{
  struct ossp_uid_cnt *tmp_ucnt;
  struct ossp_uid_cnt *ucnt = (struct ossp_uid_cnt *)(void *)0;
  struct ossp_stream *os;
  signed int rc;
  /* assertion stream_size >= sizeof(struct ossp_stream) */
  assert(stream_size >= sizeof(struct ossp_stream) /*264ul*/ );
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, stream_size);
  os = (struct ossp_stream *)return_value_calloc_1;
  signed int return_value_pthread_mutex_init_3;
  struct ossp_uid_cnt *tmp_statement_expression_4;
  struct ossp_uid_cnt *tmp_statement_expression_5;
  unsigned long int return_value_find_next_zero_bit_7;
  struct list_head *return_value_os_tbl_head_8;
  struct list_head *return_value_os_pgrp_tbl_head_9;
  if(os == ((struct ossp_stream *)NULL))
    return -12;

  else
  {
    INIT_LIST_HEAD(&os->link);
    INIT_LIST_HEAD(&os->pgrp_link);
    INIT_LIST_HEAD(&os->notify_link);
    os->refcnt = (unsigned int)1;
    signed int return_value_pthread_mutex_init_2;
    return_value_pthread_mutex_init_2=pthread_mutex_init(&os->cmd_mutex, (const union anonymous_1 *)(void *)0);
    rc = -return_value_pthread_mutex_init_2;
    if(rc == 0)
    {
      return_value_pthread_mutex_init_3=pthread_mutex_init(&os->mmap_mutex, (const union anonymous_1 *)(void *)0);
      rc = -return_value_pthread_mutex_init_3;
      if(rc == 0)
      {
        pthread_mutex_lock(&mutex);
        const struct list_head *alloc_os__1__1__1____mptr = (&uid_cnt_list)->next;
        tmp_statement_expression_4 = (struct ossp_uid_cnt *)((char *)alloc_os__1__1__1____mptr - (signed long int)0ul);
        tmp_ucnt = tmp_statement_expression_4;
        for( ; !(&tmp_ucnt->link == &uid_cnt_list); tmp_ucnt = tmp_statement_expression_5)
        {
          if(tmp_ucnt->uid == uid)
          {
            ucnt = tmp_ucnt;
            break;
          }

          const struct list_head *__mptr = tmp_ucnt->link.next;
          tmp_statement_expression_5 = (struct ossp_uid_cnt *)((char *)__mptr - (signed long int)0ul);
        }
        if(ucnt == ((struct ossp_uid_cnt *)NULL))
        {
          rc = -12;
          void *return_value_calloc_6;
          return_value_calloc_6=calloc((unsigned long int)1, sizeof(struct ossp_uid_cnt) /*24ul*/ );
          ucnt = (struct ossp_uid_cnt *)return_value_calloc_6;
          if(ucnt == ((struct ossp_uid_cnt *)NULL))
            goto err_unlock;

          ucnt->uid = uid;
          list_add(&ucnt->link, &uid_cnt_list);
        }

        rc = -16;
        if(umax_streams >= 1u + ucnt->nr_os)
        {
          rc = -16;
          return_value_find_next_zero_bit_7=find_next_zero_bit(os_id_bitmap, (unsigned long int)max_streams, (unsigned long int)0);
          os->id = (unsigned int)return_value_find_next_zero_bit_7;
          if(!(os->id >= max_streams))
          {
            __set_bit((signed int)os->id, os_id_bitmap);
            os->cmd_fd = cmd_sock;
            os->notify_tx = notify[(signed long int)1];
            os->notify_rx = notify[(signed long int)0];
            os->pid = pid;
            os->pgrp = (signed int)pgrp;
            os->uid = uid;
            os->gid = gid;
            if(!(mmap_size == 0ul))
            {
              os->mmap_off = (signed long int)((unsigned long int)os->id * mmap_size);
              os->mmap_size = mmap_size;
            }

            os->ucnt = ucnt;
            os->se = se;
            memset((void *)os->vol, -1, sizeof(signed int [2l][2l]) /*16ul*/ );
            memset((void *)os->vol_set, -1, sizeof(signed int [2l][2l]) /*16ul*/ );
            return_value_os_tbl_head_8=os_tbl_head((unsigned long int)os->id);
            list_add(&os->link, return_value_os_tbl_head_8);
            return_value_os_pgrp_tbl_head_9=os_pgrp_tbl_head(os->pgrp);
            list_add(&os->pgrp_link, return_value_os_pgrp_tbl_head_9);
            ucnt->nr_os = ucnt->nr_os + 1u;
            *osp = os;
            pthread_mutex_unlock(&mutex);
            return 0;
          }

        }


      err_unlock:
        ;
        pthread_mutex_unlock(&mutex);
        pthread_mutex_destroy(&os->mmap_mutex);
      }


    err_destroy_cmd_mutex:
      ;
      pthread_mutex_destroy(&os->cmd_mutex);
    }


  err_free:
    ;
    free((void *)os);
    return rc;
  }
}

// create_os
// file osspd.c line 1110
static signed int create_os(const char *slave_path, unsigned long int stream_size, unsigned long int mmap_size, signed int pid, signed int pgrp, unsigned int uid, unsigned int gid, struct fuse_session *se, struct ossp_stream **osp)
{
  signed int cmd_sock[2l] = { -1, -1 };
  signed int notify_sock[2l] = { -1, -1 };
  struct ossp_stream *os = (struct ossp_stream *)(void *)0;
  struct epoll_event ev = { .events=0u, .data={ .ptr=NULL } };
  signed int i;
  signed int rc;
  static union anonymous_0 create_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  pthread_mutex_lock(&create_mutex);
  signed int return_value_socketpair_3;
  return_value_socketpair_3=socketpair(1, 1, 0, cmd_sock);
  _Bool tmp_if_expr_5;
  signed int return_value_socketpair_4;
  if(!(return_value_socketpair_3 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_socketpair_4=socketpair(1, 1, 0, notify_sock);
    tmp_if_expr_5 = return_value_socketpair_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    rc = -(*return_value___errno_location_1);
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(-rc);
    log_msg(3, "failed to create slave command channel (%s)", return_value_strerror_2);
    goto close_all;
  }

  signed int return_value_fcntl_8;
  return_value_fcntl_8=fcntl(notify_sock[(signed long int)0], 4, 04000);
  if(!(return_value_fcntl_8 >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    rc = -(*return_value___errno_location_6);
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(-rc);
    log_msg(3, "failed to set NONBLOCK on notify sock (%s)", return_value_strerror_7);
    goto close_all;
  }

  rc=alloc_os(stream_size, mmap_size, pid, (unsigned int)pgrp, uid, gid, cmd_sock[(signed long int)0], notify_sock, se, &os);
  if(!(rc == 0))
  {
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(-rc);
    log_msg(3, "failed to allocate stream for %d (%s)", pid, return_value_strerror_9);
    goto close_all;
  }

  rc = -12;
  os->mixer=get_mixer(pgrp);
  struct list_head *return_value_os_notify_tbl_head_10;
  signed int return_value_epoll_ctl_13;
  _Bool tmp_if_expr_20;
  signed int return_value_close_19;
  signed int return_value_fcntl_27;
  _Bool tmp_if_expr_29;
  signed int return_value_fcntl_28;
  _Bool tmp_if_expr_31;
  signed int return_value_fcntl_30;
  if(!(os->mixer == ((struct ossp_mixer *)NULL)))
  {
    pthread_mutex_lock(&mutex);
    return_value_os_notify_tbl_head_10=os_notify_tbl_head(os->notify_rx);
    list_add(&os->notify_link, return_value_os_notify_tbl_head_10);
    pthread_mutex_unlock(&mutex);
    ev.events = (unsigned int)1;
    ev.data.fd = notify_sock[(signed long int)0];
    return_value_epoll_ctl_13=epoll_ctl(notify_epfd, 1, notify_sock[(signed long int)0], &ev);
    if(!(return_value_epoll_ctl_13 == 0))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      rc = -(*return_value___errno_location_11);
      char *return_value_strerror_12;
      return_value_strerror_12=strerror(-rc);
      log_msg(3, "S[%u/%d] failed to add notify epoll (%s)", os->id, os->pid, return_value_strerror_12);
      close(os->notify_rx);
      os->notify_rx = -1;
      goto put_os;
    }

    os->slave_pid=fork();
    if(!(os->slave_pid >= 0))
    {
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      rc = -(*return_value___errno_location_14);
      char *return_value_strerror_15;
      return_value_strerror_15=strerror(-rc);
      log_msg(3, "S[%u/%d] failed to fork slave (%s)", os->id, os->pid, return_value_strerror_15);
      goto put_os;
    }

    if(os->slave_pid == 0)
    {
      char id_str[2l][16l];
      char fd_str[3l][16l];
      char mmap_off_str[32l];
      char mmap_size_str[32l];
      char log_str[16l];
      char slave_path_copy[4096l];
      char *argv[19l] = { slave_path_copy, "-u", id_str[(signed long int)0], "-g", id_str[(signed long int)1], "-c", fd_str[(signed long int)0], "-n", fd_str[(signed long int)1], "-m", fd_str[(signed long int)2], "-o", mmap_off_str, "-s", mmap_size_str, "-l", log_str, (char *)(void *)0, (char *)(void *)0 };
      struct passwd *pwd;
      signed int return_value_close_18;
      return_value_close_18=close(cmd_sock[(signed long int)0]);
      if(!(return_value_close_18 == 0))
        tmp_if_expr_20 = (_Bool)1;

      else
      {
        return_value_close_19=close(notify_sock[(signed long int)0]);
        tmp_if_expr_20 = return_value_close_19 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_20)
        do
        {
          signed int *return_value___errno_location_16;
          return_value___errno_location_16=__errno_location();
          char *return_value_strerror_17;
          return_value_strerror_17=strerror(-(-(*return_value___errno_location_16)));
          log_msg(1, "failed to close server pipe fds (%s)", return_value_strerror_17);
          _exit(1);
        }
        while((_Bool)0);

      clearenv();
      pwd=getpwuid(os->uid);
      if(!(pwd == ((struct passwd *)NULL)))
      {
        setenv("LOGNAME", pwd->pw_name, 1);
        setenv("USER", pwd->pw_name, 1);
        setenv("HOME", pwd->pw_dir, 1);
      }

      set_extra_env(pid);
      slave_path_copy[(signed long int)(sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1)] = (char)0;
      strncpy(slave_path_copy, slave_path, sizeof(char [4096l]) /*4096ul*/  - (unsigned long int)1);
      if(!((signed int)slave_path_copy[4095l] == 0))
      {
        signed int *return_value___errno_location_21;
        return_value___errno_location_21=__errno_location();
        rc = -(*return_value___errno_location_21);
        char *return_value_strerror_22;
        return_value_strerror_22=strerror(-rc);
        log_msg(2, "S[%u/%d] slave path too long (%s)", os->id, os->pid, return_value_strerror_22);
        goto child_fail;
      }

      snprintf(id_str[(signed long int)0], sizeof(char [16l]) /*16ul*/ , "%d", os->uid);
      snprintf(id_str[(signed long int)1], sizeof(char [16l]) /*16ul*/ , "%d", os->gid);
      snprintf(fd_str[(signed long int)0], sizeof(char [16l]) /*16ul*/ , "%d", cmd_sock[(signed long int)1]);
      snprintf(fd_str[(signed long int)1], sizeof(char [16l]) /*16ul*/ , "%d", notify_sock[(signed long int)1]);
      snprintf(fd_str[(signed long int)2], sizeof(char [16l]) /*16ul*/ , "%d", -1);
      snprintf(mmap_off_str, sizeof(char [32l]) /*32ul*/ , "0x%llx", (unsigned long long int)os->mmap_off);
      snprintf(mmap_size_str, sizeof(char [32l]) /*32ul*/ , "0x%zx", mmap_size);
      snprintf(log_str, sizeof(char [16l]) /*16ul*/ , "%d", ossp_log_level);
      if(!(ossp_log_timestamp == 0))
        argv[(signed long int)(sizeof(char *[19l]) /*152ul*/  / sizeof(char *) /*8ul*/  - (unsigned long int)2)] = "-t";

      execv(slave_path, argv);
      signed int *return_value___errno_location_23;
      return_value___errno_location_23=__errno_location();
      rc = -(*return_value___errno_location_23);
      char *return_value_strerror_24;
      return_value_strerror_24=strerror(-rc);
      log_msg(2, "S[%u/%d] execv failed for <%d> (%s)", os->id, os->pid, pid, return_value_strerror_24);

    child_fail:
      ;
      _exit(1);
    }

    return_value_fcntl_27=fcntl(os->cmd_fd, 2, 1);
    if(!(return_value_fcntl_27 >= 0))
      tmp_if_expr_29 = (_Bool)1;

    else
    {
      return_value_fcntl_28=fcntl(os->notify_tx, 2, 1);
      tmp_if_expr_29 = return_value_fcntl_28 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_29)
      tmp_if_expr_31 = (_Bool)1;

    else
    {
      return_value_fcntl_30=fcntl(os->notify_rx, 2, 1);
      tmp_if_expr_31 = return_value_fcntl_30 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_31)
    {
      signed int *return_value___errno_location_25;
      return_value___errno_location_25=__errno_location();
      rc = -(*return_value___errno_location_25);
      char *return_value_strerror_26;
      return_value_strerror_26=strerror(-rc);
      log_msg(2, "S[%u/%d] failed to set CLOEXEC on server side fds (%s)", os->id, os->pid, return_value_strerror_26);
      goto put_os;
    }

    log_msg(5, "S[%u/%d] CREATE slave=%d %s", os->id, os->pid, os->slave_pid, slave_path);
    log_msg(5, "S[%u/%d]   client=%d cmd=%d:%d notify=%d:%d mmap=%d:0x%llx:%zu", os->id, os->pid, pid, cmd_sock[(signed long int)0], cmd_sock[(signed long int)1], notify_sock[(signed long int)0], notify_sock[(signed long int)1], -1, (unsigned long long int)os->mmap_off, os->mmap_size);
    *osp = os;
    rc = 0;
  }

  else
  {

  put_os:
    ;
    put_os(os);
  }

close_client_fds:
  ;
  close(cmd_sock[(signed long int)1]);
  pthread_mutex_unlock(&create_mutex);
  return rc;

close_all:
  ;
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    close(cmd_sock[(signed long int)i]);
    close(notify_sock[(signed long int)i]);
  }
  pthread_mutex_unlock(&create_mutex);
  return rc;
}

// cuse_worker
// file osspd.c line 2094
static void * cuse_worker(void *arg)
{
  struct fuse_session *se = (struct fuse_session *)arg;
  signed int rc;
  rc=fuse_session_loop_mt(se);
  cuse_lowlevel_teardown(se);
  return (void *)(unsigned long int)rc;
}

// dsp_ioctl
// file osspd.c line 1483
static void dsp_ioctl(struct fuse_req *req, signed int signed_cmd, void *uarg, struct fuse_file_info *fi, unsigned int flags, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz)
{
  unsigned int cmd = (unsigned int)signed_cmd;
  struct ossp_stream *os;
  struct ossp_dsp_stream *dsps;
  enum ossp_opcode op;
  signed long int ret;
  signed int i;
  ret = (signed long int)-9;
  os=find_os((unsigned int)fi->fh);
  struct ossp_dsp_stream *tmp_statement_expression_1;
  if(!(os == ((struct ossp_stream *)NULL)))
  {
    const struct ossp_stream *__mptr = os;
    tmp_statement_expression_1 = (struct ossp_dsp_stream *)((char *)__mptr - (signed long int)0ul);
    dsps = tmp_statement_expression_1;
    if((255u & cmd >> 8) == 77u)
    {
      mixer_do_ioctl(req, os->mixer, cmd, uarg, in_buf, in_bufsz, out_bufsz);
      goto __CPROVER_DUMP_L85;
    }

    if(!(cmd == 2147765622u))
    {
      if(cmd == 2147766287u)
        goto __CPROVER_DUMP_L8;

      if(cmd == 20494u)
        goto __CPROVER_DUMP_L14;

      if(cmd == 20480u)
        goto __CPROVER_DUMP_L18;

      if(cmd == 20481u)
        goto __CPROVER_DUMP_L19;

      if(cmd == 20488u)
        goto __CPROVER_DUMP_L20;

      if(cmd == 2147766274u)
        goto __CPROVER_DUMP_L25;

      if(cmd == 2147766277u)
        goto __CPROVER_DUMP_L26;

      if(cmd == 2147766278u)
        goto __CPROVER_DUMP_L27;

      if(cmd == 3221508100u)
        goto __CPROVER_DUMP_L28;

      if(cmd == 2147766283u)
        goto __CPROVER_DUMP_L29;

      if(cmd == 2147766288u)
        goto __CPROVER_DUMP_L30;

      if(cmd == 3221508098u)
        goto __CPROVER_DUMP_L36;

      if(cmd == 3221508101u)
        goto __CPROVER_DUMP_L37;

      if(cmd == 3221508102u)
        goto __CPROVER_DUMP_L38;

      if(cmd == 3221508105u)
        goto __CPROVER_DUMP_L39;

      if(cmd == 3221508099u)
        goto __CPROVER_DUMP_L45;

      if(cmd == 3221508106u)
        goto __CPROVER_DUMP_L50;

      if(cmd == 1074024464u)
        goto __CPROVER_DUMP_L55;

      if(cmd == 2148552716u || cmd == 2148552717u)
        goto __CPROVER_DUMP_L60;

      if(cmd == 2148290577u || cmd == 2148290578u)
        goto __CPROVER_DUMP_L67;

      if(cmd == 2147766295u)
        goto __CPROVER_DUMP_L73;

      if(cmd == 2147766279u || cmd == 3221508103u)
        goto __CPROVER_DUMP_L78;

      if(cmd == 2148552723u || cmd == 2148552724u)
        goto __CPROVER_DUMP_L79;

      if(cmd == 20501u || cmd == 20502u || cmd == 1074024471u)
        goto __CPROVER_DUMP_L80;

    }

    else
    {
      i = 198672;
      do
      {
        signed int return_value_ioctl_prep_uarg_2;
        return_value_ioctl_prep_uarg_2=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_2 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L8:
      ;
      i = 0x00000100 | 0x00000200 | 0x00001000 | 0x00004000;
      do
      {
        signed int return_value_ioctl_prep_uarg_3;
        return_value_ioctl_prep_uarg_3=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_3 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L14:
      ;
      dsps->nonblock = 1;
      ret = (signed long int)0;
      fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L18:
      ;
      op = (enum ossp_opcode)OSSP_DSP_RESET;
      goto nd;

    __CPROVER_DUMP_L19:
      ;
      op = (enum ossp_opcode)OSSP_DSP_SYNC;
      goto nd;

    __CPROVER_DUMP_L20:
      ;
      op = (enum ossp_opcode)OSSP_DSP_POST;

    nd:
      ;
      ret=exec_simple_cmd(&dsps->os, op, (void *)0, (void *)0);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L25:
      ;
      op = (enum ossp_opcode)OSSP_DSP_GET_RATE;
      goto ri;

    __CPROVER_DUMP_L26:
      ;
      op = (enum ossp_opcode)OSSP_DSP_GET_FORMAT;
      goto ri;

    __CPROVER_DUMP_L27:
      ;
      op = (enum ossp_opcode)OSSP_DSP_GET_CHANNELS;
      goto ri;

    __CPROVER_DUMP_L28:
      ;
      op = (enum ossp_opcode)OSSP_DSP_GET_BLKSIZE;
      goto ri;

    __CPROVER_DUMP_L29:
      ;
      op = (enum ossp_opcode)OSSP_DSP_GET_FORMATS;
      goto ri;

    __CPROVER_DUMP_L30:
      ;
      op = (enum ossp_opcode)OSSP_DSP_GET_TRIGGER;
      do
      {

      ri:
        ;
        signed int return_value_ioctl_prep_uarg_4;
        return_value_ioctl_prep_uarg_4=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_4 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      ret=exec_simple_cmd(&dsps->os, op, (void *)0, (void *)&i);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L36:
      ;
      op = (enum ossp_opcode)OSSP_DSP_SET_RATE;
      goto wi;

    __CPROVER_DUMP_L37:
      ;
      op = (enum ossp_opcode)OSSP_DSP_SET_FORMAT;
      goto wi;

    __CPROVER_DUMP_L38:
      ;
      op = (enum ossp_opcode)OSSP_DSP_SET_CHANNELS;
      goto wi;

    __CPROVER_DUMP_L39:
      ;
      op = (enum ossp_opcode)OSSP_DSP_SET_SUBDIVISION;
      do
      {

      wi:
        ;
        signed int return_value_ioctl_prep_uarg_5;
        return_value_ioctl_prep_uarg_5=ioctl_prep_uarg(req, (void *)&i, sizeof(signed int) /*4ul*/ , (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_5 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      ret=exec_simple_cmd(&dsps->os, op, (void *)&i, (void *)&i);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
      goto __CPROVER_DUMP_L85;
      do
      {

      __CPROVER_DUMP_L45:
        ;
        signed int return_value_ioctl_prep_uarg_6;
        return_value_ioctl_prep_uarg_6=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_6 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      i = 2;
      ret=exec_simple_cmd(&dsps->os, (enum ossp_opcode)OSSP_DSP_SET_CHANNELS, (void *)&i, (void *)&i);
      i = i - 1;
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
      goto __CPROVER_DUMP_L85;
      do
      {

      __CPROVER_DUMP_L50:
        ;
        signed int return_value_ioctl_prep_uarg_7;
        return_value_ioctl_prep_uarg_7=ioctl_prep_uarg(req, (void *)&i, sizeof(signed int) /*4ul*/ , (void *)0, 1ul, uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_7 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      ret=exec_simple_cmd(&dsps->os, (enum ossp_opcode)OSSP_DSP_SET_FRAGMENT, (void *)&i, (void *)0);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
      goto __CPROVER_DUMP_L85;
      do
      {

      __CPROVER_DUMP_L55:
        ;
        signed int return_value_ioctl_prep_uarg_8;
        return_value_ioctl_prep_uarg_8=ioctl_prep_uarg(req, (void *)&i, sizeof(signed int) /*4ul*/ , (void *)0, 1ul, uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_8 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      ret=exec_simple_cmd(&dsps->os, (enum ossp_opcode)OSSP_DSP_SET_TRIGGER, (void *)&i, (void *)0);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L60:
      ;
      struct audio_buf_info info;
      ret = (signed long int)-22;
      if((unsigned long int)cmd == 2148552716ul)
      {
        if((1u & dsps->rw) == 0u)
          goto err;

        op = (enum ossp_opcode)OSSP_DSP_GET_OSPACE;
      }

      else
      {
        if((2u & dsps->rw) == 0u)
          goto err;

        op = (enum ossp_opcode)OSSP_DSP_GET_ISPACE;
      }
      do
      {
        signed int return_value_ioctl_prep_uarg_9;
        return_value_ioctl_prep_uarg_9=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&info, sizeof(struct audio_buf_info) /*16ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_9 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      ret=exec_simple_cmd(&dsps->os, op, (void *)0, (void *)&info);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (const void *)&info, sizeof(struct audio_buf_info) /*16ul*/ );
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L67:
      ;
      struct count_info dsp_ioctl__1__3__18__info;
      op = (enum ossp_opcode)((unsigned long int)cmd == ((unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(80 << 0 + 8) | (unsigned int)(18 << 0)) | sizeof(struct count_info) /*12ul*/  << 0 + 8 + 8) ? OSSP_DSP_GET_OPTR : OSSP_DSP_GET_IPTR);
      do
      {
        signed int return_value_ioctl_prep_uarg_10;
        return_value_ioctl_prep_uarg_10=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&dsp_ioctl__1__3__18__info, sizeof(struct count_info) /*12ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_10 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      ret=exec_simple_cmd(&dsps->os, op, (void *)0, (void *)&dsp_ioctl__1__3__18__info);
      if(!(ret == 0l))
        goto err;

      fuse_reply_ioctl(req, 0, (const void *)&dsp_ioctl__1__3__18__info, sizeof(struct count_info) /*12ul*/ );
      goto __CPROVER_DUMP_L85;
      do
      {

      __CPROVER_DUMP_L73:
        ;
        signed int return_value_ioctl_prep_uarg_11;
        return_value_ioctl_prep_uarg_11=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
        if(!(return_value_ioctl_prep_uarg_11 == 0))
          goto __CPROVER_DUMP_L85;

      }
      while((_Bool)0);
      i = 0;
      ret=exec_simple_cmd(&dsps->os, (enum ossp_opcode)OSSP_DSP_GET_ODELAY, (void *)0, (void *)&i);
      fuse_reply_ioctl(req, (signed int)ret, (const void *)&i, sizeof(signed int) /*4ul*/ );
      goto __CPROVER_DUMP_L85;

    __CPROVER_DUMP_L78:
      ;
      ret = (signed long int)-5;
      goto err;

    __CPROVER_DUMP_L79:
      ;
      ret = (signed long int)-22;
      goto err;

    __CPROVER_DUMP_L80:
      ;
      fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
      goto __CPROVER_DUMP_L85;
    }
    log_msg(3, "S[%u/%d] unknown ioctl 0x%x", os->id, os->pid, cmd);
    ret = (signed long int)-22;
    goto err;
    /* assertion 0 */
    assert(0 != 0);
  }


err:
  ;
  fuse_reply_err(req, (signed int)-ret);

__CPROVER_DUMP_L85:
  ;
}

// dsp_open
// file osspd.c line 1358
static void dsp_open(struct fuse_req *req, struct fuse_file_info *fi)
{
  dsp_open_common(req, fi, dsp_se);
}

// dsp_open_common
// file osspd.c line 1291
static void dsp_open_common(struct fuse_req *req, struct fuse_file_info *fi, struct fuse_session *se)
{
  struct fuse_ctx *fuse_ctx;
  fuse_ctx=fuse_req_ctx(req);
  struct ossp_dsp_open_arg arg = { .flags=0, .opener_pid=0 };
  struct ossp_stream *os = (struct ossp_stream *)(void *)0;
  struct ossp_mixer *mixer;
  struct ossp_dsp_stream *dsps;
  struct ossp_mixer_cmd mxcmd;
  signed int pgrp;
  signed long int ret;
  signed int return_value_get_proc_self_info_1;
  return_value_get_proc_self_info_1=get_proc_self_info(fuse_ctx->pid, &pgrp, (char *)(void *)0, (unsigned long int)0);
  ret = (signed long int)return_value_get_proc_self_info_1;
  if(!(ret == 0l))
  {
    char *return_value_strerror_2;
    return_value_strerror_2=strerror((signed int)-ret);
    log_msg(2, "get_proc_self_info(%d) failed (%s)", fuse_ctx->pid, return_value_strerror_2);
    goto err;
  }

  signed int return_value_create_os_3;
  return_value_create_os_3=create_os(dsp_slave_path, sizeof(struct ossp_dsp_stream) /*280ul*/ , (unsigned long int)1048576, fuse_ctx->pid, pgrp, fuse_ctx->uid, fuse_ctx->gid, se, &os);
  ret = (signed long int)return_value_create_os_3;
  struct ossp_dsp_stream *tmp_statement_expression_4;
  _Bool tmp_if_expr_5;
  if(ret == 0l)
  {
    const struct ossp_stream *__mptr = os;
    tmp_statement_expression_4 = (struct ossp_dsp_stream *)((char *)__mptr - (signed long int)0ul);
    dsps = tmp_statement_expression_4;
    mixer = os->mixer;
    switch(fi->flags & 0003)
    {
      case 01:
      {
        dsps->rw = dsps->rw | (unsigned int)(1 << 0);
        break;
      }
      case 00:
      {
        dsps->rw = dsps->rw | (unsigned int)(1 << 1);
        break;
      }
      case 02:
      {
        dsps->rw = dsps->rw | (unsigned int)(1 << 0 | 1 << 1);
        break;
      }
      default:
        /* assertion 0 */
        assert(0 != 0);
    }
    arg.flags = fi->flags;
    arg.opener_pid = os->pid;
    ret=exec_simple_cmd(&dsps->os, (enum ossp_opcode)OSSP_DSP_OPEN, (void *)&arg, (void *)0);
    if(!(ret >= 0l))
    {
      put_os(os);
      goto err;
    }

    memcpy((void *)os->vol, (const void *)mixer->vol, sizeof(signed int [2l][2l]) /*16ul*/ );
    if(os->vol[0l][0l] >= 0)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = os->vol[(signed long int)1][(signed long int)0] >= 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
    {
      init_mixer_cmd(&mxcmd, mixer);
      memcpy((void *)mxcmd.set.vol, (const void *)os->vol, sizeof(signed int [2l][2l]) /*16ul*/ );
      exec_mixer_cmd(&mxcmd, os);
      finish_mixer_cmd(&mxcmd);
    }

    fi->direct_io = (unsigned int)1;
    fi->nonseekable = (unsigned int)1;
    fi->fh = (unsigned long int)os->id;
    fuse_reply_open(req, fi);
  }

  else
  {

  err:
    ;
    fuse_reply_err(req, (signed int)-ret);
  }
}

// dsp_poll
// file osspd.c line 1454
static void dsp_poll(struct fuse_req *req, struct fuse_file_info *fi, struct fuse_pollhandle *ph)
{
  signed int notify = (signed int)(ph != (struct fuse_pollhandle *)(void *)0);
  unsigned int revents = (unsigned int)0;
  struct ossp_stream *os;
  signed long int ret = (signed long int)-9;
  os=find_os((unsigned int)fi->fh);
  if(!(os == ((struct ossp_stream *)NULL)))
  {
    if(!(ph == ((struct fuse_pollhandle *)NULL)))
    {
      pthread_mutex_lock(&mutex);
      if(!(os->ph == ((struct fuse_pollhandle *)NULL)))
        fuse_pollhandle_destroy(os->ph);

      os->ph = ph;
      pthread_mutex_unlock(&mutex);
    }

    ret=exec_simple_cmd(os, (enum ossp_opcode)OSSP_DSP_POLL, (void *)&notify, (void *)&revents);
  }


out:
  ;
  if(ret >= 0l)
    fuse_reply_poll(req, revents);

  else
    fuse_reply_err(req, (signed int)-ret);
}

// dsp_read
// file osspd.c line 1380
static void dsp_read(struct fuse_req *req, unsigned long int size, signed long int off, struct fuse_file_info *fi)
{
  struct ossp_dsp_rw_arg arg = { .nonblock=0u };
  struct ossp_stream *os;
  struct ossp_dsp_stream *dsps;
  void *buf = (void *)0;
  signed long int ret = (signed long int)-9;
  os=find_os((unsigned int)fi->fh);
  struct ossp_dsp_stream *tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  if(!(os == ((struct ossp_stream *)NULL)))
  {
    const struct ossp_stream *__mptr = os;
    tmp_statement_expression_1 = (struct ossp_dsp_stream *)((char *)__mptr - (signed long int)0ul);
    dsps = tmp_statement_expression_1;
    ret = (signed long int)-22;
    if(!((2u & dsps->rw) == 0u))
    {
      ret = (signed long int)-6;
      if(dsps->mmapped == 0u)
      {
        ret = (signed long int)-12;
        buf=malloc(size);
        if(!(buf == NULL))
        {
          if(!((04000 & fi->flags) == 0))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = dsps->nonblock != 0 ? (_Bool)1 : (_Bool)0;
          arg.nonblock = (unsigned int)tmp_if_expr_2;
          ret=exec_cmd(os, (enum ossp_opcode)OSSP_DSP_READ, (const void *)&arg, sizeof(struct ossp_dsp_rw_arg) /*4ul*/ , (void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, buf, &size, -1);
        }

      }

    }

  }


out:
  ;
  if(ret >= 0l)
    fuse_reply_buf(req, (const char *)buf, size);

  else
    fuse_reply_err(req, (signed int)-ret);
  free(buf);
}

// dsp_release
// file osspd.c line 1368
static void dsp_release(struct fuse_req *req, struct fuse_file_info *fi)
{
  struct ossp_stream *os;
  os=find_os((unsigned int)fi->fh);
  if(!(os == ((struct ossp_stream *)NULL)))
  {
    put_os(os);
    fuse_reply_err(req, 0);
  }

  else
    fuse_reply_err(req, 9);
}

// dsp_write
// file osspd.c line 1421
static void dsp_write(struct fuse_req *req, const char *buf, unsigned long int size, signed long int off, struct fuse_file_info *fi)
{
  struct ossp_dsp_rw_arg arg = { .nonblock=0u };
  struct ossp_stream *os;
  struct ossp_dsp_stream *dsps;
  signed long int ret = (signed long int)-9;
  os=find_os((unsigned int)fi->fh);
  struct ossp_dsp_stream *tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  if(!(os == ((struct ossp_stream *)NULL)))
  {
    const struct ossp_stream *__mptr = os;
    tmp_statement_expression_1 = (struct ossp_dsp_stream *)((char *)__mptr - (signed long int)0ul);
    dsps = tmp_statement_expression_1;
    ret = (signed long int)-22;
    if(!((1u & dsps->rw) == 0u))
    {
      ret = (signed long int)-6;
      if(dsps->mmapped == 0u)
      {
        if(!((04000 & fi->flags) == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = dsps->nonblock != 0 ? (_Bool)1 : (_Bool)0;
        arg.nonblock = (unsigned int)tmp_if_expr_2;
        ret=exec_cmd(os, (enum ossp_opcode)OSSP_DSP_WRITE, (const void *)&arg, sizeof(struct ossp_dsp_rw_arg) /*4ul*/ , (const void *)buf, size, (void *)0, (unsigned long int)0, (void *)0, (unsigned long int *)(void *)0, -1);
      }

    }

  }


out:
  ;
  if(ret >= 0l)
    fuse_reply_write(req, (unsigned long int)ret);

  else
    fuse_reply_err(req, (signed int)-ret);
}

// ensure_sbuf_size
// file ossp-util.c line 205
signed int ensure_sbuf_size(struct sized_buf *sbuf, unsigned long int size)
{
  char *new_buf;
  if(sbuf->size >= size)
    return 0;

  else
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)sbuf->buf, size);
    new_buf = (char *)return_value_realloc_1;
    if(new_buf == ((char *)NULL) && !(size == 0ul))
      return -12;

    else
    {
      sbuf->buf = new_buf;
      sbuf->size = size;
      return 0;
    }
  }
}

// exec_cmd
// file osspd.c line 355
static signed long int exec_cmd(struct ossp_stream *os, enum ossp_opcode opcode, const void *carg, unsigned long int carg_size, const void *din, unsigned long int din_size, void *rarg, unsigned long int rarg_size, void *dout, unsigned long int *dout_sizep, signed int fd)
{
  signed int is_mixer;
  signed int i;
  signed int j;
  signed long int ret;
  signed long int mret;
  is_mixer = (signed int)((signed int)opcode == OSSP_MIXER);
  if(!(is_mixer == 0))
  {
    signed int return_value_pthread_mutex_trylock_1;
    return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(&os->cmd_mutex);
    ret = (signed long int)-return_value_pthread_mutex_trylock_1;
    if(!(ret == 0l))
      return ret;

  }

  else
  {
    pthread_mutex_lock(&os->cmd_mutex);
    ret=exec_cmd_intern(os, opcode, carg, carg_size, din, din_size, rarg, rarg_size, dout, dout_sizep, fd);
  }
  pthread_mutex_lock(&mixer_mutex);
  if(!(os->mixer_pending == 0))
  {
    struct ossp_mixer_arg marg;
    do
    {

    repeat_mixer:
      ;
      memcpy((void *)marg.vol, (const void *)os->vol_set, sizeof(signed int [2l][2l]) /*16ul*/ );
      memset((void *)os->vol_set, -1, sizeof(signed int [2l][2l]) /*16ul*/ );
      pthread_mutex_unlock(&mixer_mutex);
      mret=exec_cmd_intern(os, (enum ossp_opcode)OSSP_MIXER, (const void *)&marg, sizeof(struct ossp_mixer_arg) /*16ul*/ , (void *)0, (unsigned long int)0, (void *)&marg, sizeof(struct ossp_mixer_arg) /*16ul*/ , (void *)0, (unsigned long int *)(void *)0, -1);
      pthread_mutex_lock(&mixer_mutex);
      i = 0;
      j = 0;

    __CPROVER_DUMP_L5:
      ;
      if(i >= 2)
        goto __CPROVER_DUMP_L6;

    }
    while(os->vol_set[(signed long int)i][(signed long int)j] >= 0);
    j = j + (i << 1);
    j = j + 1;
    i = j >> 1;
    j = j & 1;
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L6:
    ;
    if(mret == 0l)
    {
      i = 0;
      j = 0;
      for( ; !(i >= 2); j = j & 1)
      {
        if(marg.vol[(signed long int)i][(signed long int)j] >= 0)
        {
          if(!(os->vol[(signed long int)i][(signed long int)j] == marg.vol[(signed long int)i][(signed long int)j]))
            os->mixer->modify_counter = os->mixer->modify_counter + 1;

          os->vol[(signed long int)i][(signed long int)j] = marg.vol[(signed long int)i][(signed long int)j];
        }

        j = j + (i << 1);
        j = j + 1;
        i = j >> 1;
      }
    }

    os->mixer_pending = 0;
  }

  pthread_mutex_unlock(&os->cmd_mutex);
  pthread_mutex_unlock(&mixer_mutex);
  return is_mixer != 0 ? mret : ret;
}

// exec_cmd_intern
// file osspd.c line 259
static signed long int exec_cmd_intern(struct ossp_stream *os, enum ossp_opcode opcode, const void *carg, unsigned long int carg_size, const void *din, unsigned long int din_size, void *rarg, unsigned long int rarg_size, void *dout, unsigned long int *dout_sizep, signed int fd)
{
  unsigned long int dout_size;
  unsigned long int tmp_if_expr_1;
  if(!(dout_sizep == ((unsigned long int *)NULL)))
    tmp_if_expr_1 = *dout_sizep;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  dout_size = tmp_if_expr_1;
  struct ossp_cmd cmd = { .magic=0xdeadbeef, .opcode=opcode, .din_size=din_size, .dout_size=dout_size };
  struct iovec iov = { .iov_base=(void *)&cmd, .iov_len=sizeof(struct ossp_cmd) /*24ul*/  };
  struct msghdr msg = { .msg_name=NULL, .msg_namelen=0u, .msg_iov=&iov, .msg_iovlen=(unsigned long int)1,
    .msg_control=NULL, .msg_controllen=0ul,
    .msg_flags=0 };
  struct ossp_reply reply = { .magic=0u, .result=0, .dout_size=0ul };
  char cmsg_buf[24l];
  char reason[512l];
  signed int rc;
  struct cmsghdr *tmp_if_expr_2;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_10;
  if(!(os->dead == 0))
    return (signed long int)-5;

  else
  {
    log_msg(6, "S[%u/%d] %s carg=%zu din=%zu rarg=%zu dout=%zu", os->id, os->pid, ossp_cmd_str[(signed long int)opcode], carg_size, din_size, rarg_size, dout_size);
    if(fd >= 0)
    {
      struct cmsghdr *cmsg;
      msg.msg_control = (void *)cmsg_buf;
      msg.msg_controllen = sizeof(char [24l]) /*24ul*/ ;
      if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
        tmp_if_expr_2 = (struct cmsghdr *)(&msg)->msg_control;

      else
        tmp_if_expr_2 = (struct cmsghdr *)0;
      cmsg = tmp_if_expr_2;
      cmsg->cmsg_level = 1;
      cmsg->cmsg_type = 1;
      cmsg->cmsg_len = ((sizeof(struct cmsghdr) /*16ul*/  + sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)1 & (unsigned long int)~(sizeof(unsigned long int) /*8ul*/  - (unsigned long int)1)) + sizeof(signed int) /*4ul*/ ;
      *((signed int *)cmsg->__cmsg_data) = fd;
      msg.msg_controllen = cmsg->cmsg_len;
    }

    signed long int return_value_sendmsg_5;
    return_value_sendmsg_5=sendmsg(os->cmd_fd, &msg, 0);
    if(!(return_value_sendmsg_5 >= 1l))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      rc = -(*return_value___errno_location_3);
      char *return_value_strerror_4;
      return_value_strerror_4=strerror(-rc);
      snprintf(reason, sizeof(char [512l]) /*512ul*/ , "command sendmsg failed: %s", return_value_strerror_4);
      goto fail;
    }

    rc=write_fill(os->cmd_fd, carg, carg_size);
    if(!(rc >= 0))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      rc=write_fill(os->cmd_fd, din, din_size);
      tmp_if_expr_7 = rc < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      char *return_value_strerror_6;
      return_value_strerror_6=strerror(-rc);
      snprintf(reason, sizeof(char [512l]) /*512ul*/ , "can't tranfer command argument and/or data: %s", return_value_strerror_6);
      goto fail;
    }

    rc=read_fill(os->cmd_fd, (void *)&reply, sizeof(struct ossp_reply) /*16ul*/ );
    if(!(rc >= 0))
    {
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(-rc);
      snprintf(reason, sizeof(char [512l]) /*512ul*/ , "can't read reply: %s", return_value_strerror_8);
      goto fail;
    }

    if(!(reply.magic == 0xbeefdead))
    {
      snprintf(reason, sizeof(char [512l]) /*512ul*/ , "reply magic mismatch %x != %x", reply.magic, 0xbeefdead);
      rc = -22;
    }

    else
    {
      if(reply.result >= 0)
      {
        if(!(dout_size >= reply.dout_size))
        {
          snprintf(reason, sizeof(char [512l]) /*512ul*/ , "data out size overflow %zu > %zu", reply.dout_size, dout_size);
          rc = -22;
          goto fail;
        }

        dout_size = reply.dout_size;
        if(!(dout_sizep == ((unsigned long int *)NULL)))
          *dout_sizep = dout_size;

        rc=read_fill(os->cmd_fd, rarg, rarg_size);
        if(!(rc >= 0))
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          rc=read_fill(os->cmd_fd, dout, dout_size);
          tmp_if_expr_10 = rc < 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_10)
        {
          char *return_value_strerror_9;
          return_value_strerror_9=strerror(-rc);
          snprintf(reason, sizeof(char [512l]) /*512ul*/ , "can't read data out: %s", return_value_strerror_9);
          goto fail;
        }

      }


    out_unlock:
      ;
      log_msg(6, "S[%u/%d]   completed, result=%d dout=%zu", os->id, os->pid, reply.result, dout_size);
      return (signed long int)reply.result;
    }

  fail:
    ;
    log_msg(3, "S[%u/%d] communication with slave failed (%s)", os->id, os->pid, (const void *)reason);
    os->dead = 1;
    return (signed long int)rc;
  }
}

// exec_mixer_cmd
// file osspd.c line 621
static signed int exec_mixer_cmd(struct ossp_mixer_cmd *mxcmd, struct ossp_stream *os)
{
  signed int i;
  signed int j;
  signed int rc;
  pthread_mutex_lock(&mixer_mutex);
  os->mixer_pending = 1;
  i = 0;
  j = 0;
  for( ; !(i >= 2); j = j & 1)
  {
    if(mxcmd->set.vol[(signed long int)i][(signed long int)j] >= 0)
      os->vol_set[(signed long int)i][(signed long int)j] = mxcmd->set.vol[(signed long int)i][(signed long int)j];

    j = j + (i << 1);
    j = j + 1;
    i = j >> 1;
  }
  pthread_mutex_unlock(&mixer_mutex);
  signed long int return_value_exec_simple_cmd_1;
  return_value_exec_simple_cmd_1=exec_simple_cmd(os, (enum ossp_opcode)OSSP_MIXER, (void *)0, (void *)0);
  rc = (signed int)return_value_exec_simple_cmd_1;
  char *return_value_strerror_2;
  if(rc >= 0)
    log_msg(5, "S[%u/%d] volume set=%d/%d:%d/%d get=%d/%d:%d/%d", os->id, os->pid, mxcmd->set.vol[(signed long int)0][(signed long int)0], mxcmd->set.vol[(signed long int)0][(signed long int)1], mxcmd->set.vol[(signed long int)1][(signed long int)0], mxcmd->set.vol[(signed long int)1][(signed long int)1], os->vol[(signed long int)0][(signed long int)0], os->vol[(signed long int)0][(signed long int)1], os->vol[(signed long int)1][(signed long int)0], os->vol[(signed long int)1][(signed long int)1]);

  else
    if(!(rc == -16))
    {
      return_value_strerror_2=strerror(-rc);
      log_msg(3, "S[%u/%d] mixer command failed (%s)", os->id, os->pid, return_value_strerror_2);
    }

  return rc;
}

// exec_simple_cmd
// file osspd.c line 424
static signed long int exec_simple_cmd(struct ossp_stream *os, enum ossp_opcode opcode, void *carg, void *rarg)
{
  signed long int return_value_exec_cmd_1;
  return_value_exec_cmd_1=exec_cmd(os, opcode, carg, (unsigned long int)ossp_arg_sizes[(signed long int)opcode].carg_size, (void *)0, (unsigned long int)0, rarg, (unsigned long int)ossp_arg_sizes[(signed long int)opcode].rarg_size, (void *)0, (unsigned long int *)(void *)0, -1);
  return return_value_exec_cmd_1;
}

// find_mixer
// file osspd.c line 216
static struct ossp_mixer * find_mixer(signed int pgrp)
{
  struct ossp_mixer *mixer;
  pthread_mutex_lock(&mutex);
  mixer=find_mixer_locked(pgrp);
  pthread_mutex_unlock(&mutex);
  return mixer;
}

// find_mixer_locked
// file osspd.c line 206
static struct ossp_mixer * find_mixer_locked(signed int pgrp)
{
  struct ossp_mixer *mixer;
  struct ossp_mixer *tmp_statement_expression_1;
  const struct list_head *__mptr;
  struct list_head *return_value_mixer_tbl_head_2;
  return_value_mixer_tbl_head_2=mixer_tbl_head(pgrp);
  __mptr = return_value_mixer_tbl_head_2->next;
  tmp_statement_expression_1 = (struct ossp_mixer *)((char *)__mptr - (signed long int)8ul);
  mixer = tmp_statement_expression_1;
  struct list_head *return_value_mixer_tbl_head_3;
  struct ossp_mixer *tmp_statement_expression_4;
  do
  {
    return_value_mixer_tbl_head_3=mixer_tbl_head(pgrp);
    if(&mixer->link == return_value_mixer_tbl_head_3)
      break;

    if(mixer->pgrp == pgrp)
      return mixer;

    const struct list_head *find_mixer_locked__1__1__2____mptr = mixer->link.next;
    tmp_statement_expression_4 = (struct ossp_mixer *)((char *)find_mixer_locked__1__1__2____mptr - (signed long int)8ul);
    mixer = tmp_statement_expression_4;
  }
  while((_Bool)1);
  return (struct ossp_mixer *)(void *)0;
}

// find_next_zero_bit
// file ossp-util.h line 148
unsigned long int find_next_zero_bit(const unsigned long int *addr, unsigned long int size, unsigned long int offset)
{
  const unsigned long int *p = addr + (signed long int)(offset / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ));
  unsigned long int result = offset & ~((unsigned long int)8 * sizeof(signed long int) /*8ul*/  - (unsigned long int)1);
  unsigned long int tmp;
  const unsigned long int *tmp_post_1;
  const unsigned long int *tmp_post_2;
  if(offset >= size)
    return size;

  else
  {
    size = size - result;
    offset = offset % ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ );
    if(!(offset == 0ul))
    {
      tmp_post_1 = p;
      p = p + 1l;
      tmp = *tmp_post_1;
      tmp = tmp | ~0UL >> (unsigned long int)8 * sizeof(signed long int) /*8ul*/  - offset;
      if(!(size >= sizeof(signed long int) * 8 /*64ul*/ ))
        goto found_first;

      if(!(~tmp == 0ul))
        goto found_middle;

      size = size - (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
      result = result + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
    }

    for( ; !((18446744073709551552ul & size) == 0ul); size = size - (unsigned long int)8 * sizeof(signed long int) /*8ul*/ )
    {
      tmp_post_2 = p;
      p = p + 1l;
      tmp = *tmp_post_2;
      if(!(~tmp == 0ul))
        goto found_middle;

      result = result + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ;
    }
    if(size == 0ul)
      return result;

    else
    {
      tmp = *p;

    found_first:
      ;
      tmp = tmp | ~0UL << size;
      if(tmp == 18446744073709551615ul)
        return result + size;

      else
      {

      found_middle:
        ;
        unsigned long int return_value___ffs_3;
        return_value___ffs_3=__ffs(~tmp);
        return result + return_value___ffs_3;
      }
    }
  }
}

// find_os
// file osspd.c line 226
static struct ossp_stream * find_os(unsigned int id)
{
  struct ossp_stream *os;
  struct ossp_stream *found = (struct ossp_stream *)(void *)0;
  pthread_mutex_lock(&mutex);
  struct ossp_stream *tmp_statement_expression_1;
  const struct list_head *__mptr;
  struct list_head *return_value_os_tbl_head_2;
  return_value_os_tbl_head_2=os_tbl_head((unsigned long int)id);
  __mptr = return_value_os_tbl_head_2->next;
  tmp_statement_expression_1 = (struct ossp_stream *)((char *)__mptr - (signed long int)8ul);
  os = tmp_statement_expression_1;
  struct list_head *return_value_os_tbl_head_3;
  struct ossp_stream *tmp_statement_expression_4;
  do
  {
    return_value_os_tbl_head_3=os_tbl_head((unsigned long int)id);
    if(&os->link == return_value_os_tbl_head_3)
      break;

    if(os->id == id)
    {
      found = os;
      break;
    }

    const struct list_head *find_os__1__1__2____mptr = os->link.next;
    tmp_statement_expression_4 = (struct ossp_stream *)((char *)find_os__1__1__2____mptr - (signed long int)8ul);
    os = tmp_statement_expression_4;
  }
  while((_Bool)1);
  pthread_mutex_unlock(&mutex);
  return found;
}

// find_os_by_notify_rx
// file osspd.c line 240
static struct ossp_stream * find_os_by_notify_rx(signed int notify_rx)
{
  struct ossp_stream *os;
  struct ossp_stream *found = (struct ossp_stream *)(void *)0;
  pthread_mutex_lock(&mutex);
  struct ossp_stream *tmp_statement_expression_1;
  const struct list_head *__mptr;
  struct list_head *return_value_os_notify_tbl_head_2;
  return_value_os_notify_tbl_head_2=os_notify_tbl_head(notify_rx);
  __mptr = return_value_os_notify_tbl_head_2->next;
  tmp_statement_expression_1 = (struct ossp_stream *)((char *)__mptr - (signed long int)40ul);
  os = tmp_statement_expression_1;
  struct list_head *return_value_os_notify_tbl_head_3;
  struct ossp_stream *tmp_statement_expression_4;
  do
  {
    return_value_os_notify_tbl_head_3=os_notify_tbl_head(notify_rx);
    if(&os->notify_link == return_value_os_notify_tbl_head_3)
      break;

    if(os->notify_rx == notify_rx)
    {
      found = os;
      break;
    }

    const struct list_head *find_os_by_notify_rx__1__1__2____mptr = os->notify_link.next;
    tmp_statement_expression_4 = (struct ossp_stream *)((char *)find_os_by_notify_rx__1__1__2____mptr - (signed long int)40ul);
    os = tmp_statement_expression_4;
  }
  while((_Bool)1);
  pthread_mutex_unlock(&mutex);
  return found;
}

// finish_mixer_cmd
// file osspd.c line 651
static void finish_mixer_cmd(struct ossp_mixer_cmd *mxcmd)
{
  struct ossp_mixer *mixer = mxcmd->mixer;
  struct ossp_stream *os;
  signed int dir = mxcmd->out_dir;
  signed int vol[2l][2l] = { { 0, 0 }, { 0, 0 } };
  signed int cnt[2l][2l] = { { 0, 0 }, { 0, 0 } };
  signed int i;
  signed int j;
  pthread_mutex_lock(&mixer_mutex);
  pthread_mutex_lock(&mutex);
  struct ossp_stream *tmp_statement_expression_1;
  const struct list_head *__mptr;
  struct list_head *return_value_os_pgrp_tbl_head_2;
  return_value_os_pgrp_tbl_head_2=os_pgrp_tbl_head(mixer->pgrp);
  __mptr = return_value_os_pgrp_tbl_head_2->next;
  tmp_statement_expression_1 = (struct ossp_stream *)((char *)__mptr - (signed long int)24ul);
  os = tmp_statement_expression_1;
  struct list_head *return_value_os_pgrp_tbl_head_3;
  struct ossp_stream *tmp_statement_expression_4;
  do
  {
    return_value_os_pgrp_tbl_head_3=os_pgrp_tbl_head(mixer->pgrp);
    if(&os->pgrp_link == return_value_os_pgrp_tbl_head_3)
      break;

    if(os->pgrp == mixer->pgrp)
    {
      i = 0;
      j = 0;
      for( ; !(i >= 2); j = j & 1)
      {
        if(os->vol[(signed long int)i][(signed long int)j] >= 0)
        {
          vol[(signed long int)i][(signed long int)j] = vol[(signed long int)i][(signed long int)j] + os->vol[(signed long int)i][(signed long int)j];
          cnt[(signed long int)i][(signed long int)j] = cnt[(signed long int)i][(signed long int)j] + 1;
        }

        j = j + (i << 1);
        j = j + 1;
        i = j >> 1;
      }
    }

    const struct list_head *finish_mixer_cmd__1__1__2____mptr = os->pgrp_link.next;
    tmp_statement_expression_4 = (struct ossp_stream *)((char *)finish_mixer_cmd__1__1__2____mptr - (signed long int)24ul);
    os = tmp_statement_expression_4;
  }
  while((_Bool)1);
  pthread_mutex_unlock(&mutex);
  i = 0;
  j = 0;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_6;
  for( ; !(i >= 2); j = j & 1)
  {
    if(mxcmd->set.vol[(signed long int)i][(signed long int)j] >= 0)
      vol[(signed long int)i][(signed long int)j] = mxcmd->set.vol[(signed long int)i][(signed long int)j];

    else
      if(!(cnt[(signed long int)i][(signed long int)j] == 0))
        vol[(signed long int)i][(signed long int)j] = vol[(signed long int)i][(signed long int)j] / cnt[(signed long int)i][(signed long int)j];

      else
        if(mixer->vol[(signed long int)i][(signed long int)j] >= 0)
          vol[(signed long int)i][(signed long int)j] = mixer->vol[(signed long int)i][(signed long int)j];

        else
          vol[(signed long int)i][(signed long int)j] = 100;
    signed int _min1;
    signed int _max1 = 0;
    signed int _max2 = vol[(signed long int)i][(signed long int)j];
    (void)(&_max1 == &_max2);
    tmp_statement_expression_6 = _max1 > _max2 ? _max1 : _max2;
    _min1 = tmp_statement_expression_6;
    signed int _min2 = 100;
    (void)(&_min1 == &_min2);
    tmp_statement_expression_5 = _min1 < _min2 ? _min1 : _min2;
    vol[(signed long int)i][(signed long int)j] = tmp_statement_expression_5;
    j = j + (i << 1);
    j = j + 1;
    i = j >> 1;
  }
  if(dir >= 0)
    mxcmd->rvol = vol[(signed long int)dir][(signed long int)0] | vol[(signed long int)dir][(signed long int)1] << 8;

  pthread_mutex_unlock(&mixer_mutex);
}

// get_mixer
// file osspd.c line 509
static struct ossp_mixer * get_mixer(signed int pgrp)
{
  struct ossp_mixer *mixer;
  pthread_mutex_lock(&mutex);
  mixer=find_mixer_locked(pgrp);
  if(!(mixer == ((struct ossp_mixer *)NULL)))
  {
    signed int return_value_list_empty_1;
    return_value_list_empty_1=list_empty(&mixer->delayed_put_link);
    if(!(return_value_list_empty_1 == 0))
      mixer->refcnt = mixer->refcnt + 1u;

    else
      list_del_init(&mixer->delayed_put_link);
    goto out_unlock;
  }

  signed int return_value_list_empty_2;
  struct ossp_mixer *tmp_statement_expression_3;
  while(!(2u * max_streams >= nr_mixers))
  {
    return_value_list_empty_2=list_empty(&mixer_delayed_put_head);
    if(!(return_value_list_empty_2 == 0))
      break;

    struct ossp_mixer *get_mixer__1__2__mixer;
    const struct list_head *__mptr = (&mixer_delayed_put_head)->next;
    tmp_statement_expression_3 = (struct ossp_mixer *)((char *)__mptr - (signed long int)24ul);
    get_mixer__1__2__mixer = tmp_statement_expression_3;
    /* assertion mixer->refcnt == 1 */
    assert(get_mixer__1__2__mixer->refcnt == (unsigned int)1);
    put_mixer_real(get_mixer__1__2__mixer);
  }
  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)1, sizeof(struct ossp_mixer) /*72ul*/ );
  mixer = (struct ossp_mixer *)return_value_calloc_4;
  struct list_head *return_value_mixer_tbl_head_5;
  if(mixer == ((struct ossp_mixer *)NULL))
  {
    log_msg(3, "failed to allocate mixer for %d", pgrp);
    mixer = (struct ossp_mixer *)(void *)0;
  }

  else
  {
    mixer->pgrp = pgrp;
    INIT_LIST_HEAD(&mixer->link);
    INIT_LIST_HEAD(&mixer->delayed_put_link);
    mixer->refcnt = (unsigned int)1;
    memset((void *)mixer->vol, -1, sizeof(signed int [2l][2l]) /*16ul*/ );
    return_value_mixer_tbl_head_5=mixer_tbl_head(pgrp);
    list_add(&mixer->link, return_value_mixer_tbl_head_5);
    nr_mixers = nr_mixers + 1u;
    log_msg(5, "CREATE mixer(%d)", pgrp);
  }

out_unlock:
  ;
  pthread_mutex_unlock(&mutex);
  return mixer;
}

// get_proc_self_info
// file ossp-util.h line 159
signed int get_proc_self_info(signed int pid, signed int *ppid_r, char *cmd_buf, unsigned long int cmd_buf_sz)
{
  char path[64l];
  char buf[4096l];
  signed int fd = -1;
  char *cmd_start;
  char *cmd_end;
  char *ppid_start;
  char *end;
  signed long int ret;
  signed int ppid;
  signed int i;
  signed int rc;
  snprintf(path, sizeof(char [64l]) /*64ul*/ , "/proc/%ld/stat", (signed long int)pid);
  fd=open(path, 00);
  if(!(fd >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    rc = -(*return_value___errno_location_1);
    goto out;
  }

  ret=read(fd, (void *)buf, sizeof(char [4096l]) /*4096ul*/ );
  unsigned long int return_value_strtoul_2;
  _Bool tmp_if_expr_3;
  unsigned long int tmp_statement_expression_4;
  if(ret >= 0l)
  {
    if((unsigned long int)ret == sizeof(char [4096l]) /*4096ul*/ )
      rc = -75;

    else
    {
      buf[ret] = (char)0;
      rc = -22;
      cmd_start=strchr(buf, 40);
      cmd_end=strrchr(buf, 41);
      if(!(cmd_end == ((char *)NULL)) && !(cmd_start == ((char *)NULL)))
      {
        cmd_start = cmd_start + 1l;
        ppid_start = cmd_end;
        i = 0;
        for( ; !(i >= 3); i = i + 1)
        {
          ppid_start=strchr(ppid_start, 32);
          if(ppid_start == ((char *)NULL))
            goto out;

          ppid_start = ppid_start + 1l;
        }
        return_value_strtoul_2=strtoul(ppid_start, &end, 10);
        ppid = (signed int)return_value_strtoul_2;
        if(end == ppid_start)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)*end != 32 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_3)
        {
          if(!(ppid_r == ((signed int *)NULL)))
            *ppid_r = ppid;

          if(!(cmd_buf == ((char *)NULL)))
          {
            unsigned long int len;
            unsigned long int __min1 = (unsigned long int)(cmd_end - cmd_start);
            unsigned long int __min2 = cmd_buf_sz - (unsigned long int)1;
            tmp_statement_expression_4 = __min1 < __min2 ? __min1 : __min2;
            len = tmp_statement_expression_4;
            memcpy((void *)cmd_buf, (const void *)cmd_start, len);
            cmd_buf[(signed long int)len] = (char)0;
          }

          rc = 0;
        }

      }

    }
  }


out:
  ;
  close(fd);
  return rc;
}

// init_mixer_cmd
// file osspd.c line 612
static void init_mixer_cmd(struct ossp_mixer_cmd *mxcmd, struct ossp_mixer *mixer)
{
  memset((void *)mxcmd, 0, sizeof(struct ossp_mixer_cmd) /*32ul*/ );
  memset((void *)&mxcmd->set.vol, -1, sizeof(signed int [2l][2l]) /*16ul*/ );
  mxcmd->mixer = mixer;
  mxcmd->out_dir = -1;
}

// ioctl_prep_uarg
// file osspd.c line 432
static signed int ioctl_prep_uarg(struct fuse_req *req, void *in, unsigned long int in_sz, void *out, unsigned long int out_sz, void *uarg, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz)
{
  struct iovec in_iov = { .iov_base=NULL, .iov_len=0ul };
  struct iovec out_iov = { .iov_base=NULL, .iov_len=0ul };
  signed int retry = 0;
  if(!(in == NULL))
  {
    if(in_bufsz == 0ul)
    {
      in_iov.iov_base = uarg;
      in_iov.iov_len = in_sz;
      retry = 1;
    }

    else
    {
      /* assertion in_bufsz == in_sz */
      assert(in_bufsz == in_sz);
      memcpy(in, in_buf, in_sz);
    }
  }

  if(!(out == NULL))
  {
    if(out_bufsz == 0ul)
    {
      out_iov.iov_base = uarg;
      out_iov.iov_len = out_sz;
      retry = 1;
    }

    else
      /* assertion out_bufsz == out_sz */
      assert(out_bufsz == out_sz);
  }

  if(!(retry == 0))
    fuse_reply_ioctl_retry(req, &in_iov, (unsigned long int)1, &out_iov, (unsigned long int)1);

  return retry;
}

// list_add
// file ossp-util.h line 230
static inline void list_add(struct list_head *new, struct list_head *head)
{
  __list_add(new, head, head->next);
}

// list_add_tail
// file ossp-util.h line 243
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

// list_del_init
// file ossp-util.h line 301
static inline void list_del_init(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
  INIT_LIST_HEAD(entry);
}

// list_empty
// file ossp-util.h line 345
static inline signed int list_empty(struct list_head *head)
{
  return (signed int)(head->next == head);
}

// log_msg
// file ossp-util.h line 68
void log_msg(signed int severity, const char *fmt, ...)
{
  char buf[1024l];
  unsigned long int len = sizeof(char [1024l]) /*1024ul*/ ;
  unsigned long int off = (unsigned long int)0;
  void **ap;
  signed int return_value_abs_1;
  return_value_abs_1=abs(ossp_log_level);
  signed int return_value_snprintf_4;
  if(return_value_abs_1 >= severity)
  {
    static signed int syslog_opened = 0;
    if(syslog_opened == 0 && !(ossp_log_level >= 0))
      openlog(ossp_log_name, 0, 3 << 3);

    /* assertion severity >= 0 && severity < (sizeof(severity_strs) / sizeof((severity_strs)[0])) */
    assert(severity >= 0 && (unsigned long int)severity < sizeof(const char *[7l]) /*56ul*/  / sizeof(const char *) /*8ul*/ );
    if(!(ossp_log_timestamp == 0))
    {
      unsigned long int now;
      struct timeval tv;
      gettimeofday(&tv, (struct timezone *)(void *)0);
      now = (unsigned long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
      static unsigned long int start;
      if(start == 0ul)
        start = now;

      signed int return_value_snprintf_2;
      return_value_snprintf_2=snprintf(buf + (signed long int)off, len - off, "<%08lu> ", now - start);
      off = off + (unsigned long int)return_value_snprintf_2;
    }

    if(ossp_log_level >= 1)
    {
      char sev_buf[16l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      if(!(severity_strs[(signed long int)severity] == ((const char *)NULL)))
        snprintf(sev_buf, sizeof(char [16l]) /*16ul*/ , " %s", severity_strs[(signed long int)severity]);

      signed int return_value_snprintf_3;
      return_value_snprintf_3=snprintf(buf + (signed long int)off, len - off, "%s%s: ", (const void *)ossp_log_name, (const void *)sev_buf);
      off = off + (unsigned long int)return_value_snprintf_3;
    }

    else
      if(!(severity_strs[(signed long int)severity] == ((const char *)NULL)))
      {
        return_value_snprintf_4=snprintf(buf + (signed long int)off, len - off, "%s ", severity_strs[(signed long int)severity]);
        off = off + (unsigned long int)return_value_snprintf_4;
      }

    ap = (void **)&fmt;
    signed int return_value_vsnprintf_5;
    return_value_vsnprintf_5=vsnprintf(buf + (signed long int)off, len - off, fmt, ap);
    off = off + (unsigned long int)return_value_vsnprintf_5;
    ap = ((void **)NULL);
    signed int return_value_snprintf_6;
    return_value_snprintf_6=snprintf(buf + (signed long int)off, len - off, "\n");
    off = off + (unsigned long int)return_value_snprintf_6;
    if(ossp_log_level >= 1)
      fputs(buf, stderr);

    else
      syslog(severity_map[(signed long int)severity], "%s", (const void *)buf);
  }

}

// main
// file osspd.c line 2122
signed int main(signed int argc, char **argv)
{
  struct fuse_args args = { .argc=argc, .argv=argv, .allocated=0 };
  char adsp_buf[64l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char mixer_buf[64l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct sigaction sa;
  struct stat stat_buf;
  signed long int ret;
  unsigned int u;
  snprintf(ossp_log_name, sizeof(char [128l]) /*128ul*/ , "osspd");
  static struct ossp_param param = { .dsp_name="dsp", .dsp_major=(unsigned int)14, .dsp_minor=(unsigned int)3,
    .adsp_name="adsp", .adsp_major=(unsigned int)14,
    .adsp_minor=(unsigned int)12, .mixer_name="mixer",
    .mixer_major=(unsigned int)14, .mixer_minor=(unsigned int)0,
    .max_streams=(unsigned int)128, .umax_streams=0u,
    .dsp_slave_path=((char *)NULL), .log_level=0u,
    .exit_on_idle=0, .timestamp=0, .fg=0,
    .help=0 };
  param.log_level = (unsigned int)ossp_log_level;
  signed int return_value_fuse_opt_parse_1;
  return_value_fuse_opt_parse_1=fuse_opt_parse(&args, (void *)&param, ossp_opts, process_arg);
  if(!(return_value_fuse_opt_parse_1 == 0))
    do
    {
      log_msg(1, "failed to parse arguments");
      _exit(1);
    }
    while((_Bool)0);

  char *return_value_strerror_28;
  char *return_value_strerror_30;
  if(!(param.help == 0))
    return 0;

  else
  {
    max_streams = param.max_streams;
    hashtbl_size = max_streams / (unsigned int)2 + (unsigned int)13;
    umax_streams = max_streams;
    if(!(param.umax_streams == 0u))
      umax_streams = param.umax_streams;

    if(param.log_level >= 7u)
      param.log_level = (unsigned int)6;

    if(param.fg == 0)
      param.log_level = -param.log_level;

    ossp_log_level = (signed int)param.log_level;
    ossp_log_timestamp = param.timestamp;
    if(param.fg == 0)
      ossp_daemonize();

    fuse_opt_add_arg(&args, "-f");
    log_msg(4, "OSS Proxy v%s (C) 2008-2010 by Tejun Heo <teheo@suse.de>", (const void *)"1.3.2");
    memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
    sa.__sigaction_handler.sa_handler = (void (*)(signed int))1;
    signed int return_value_sigaction_4;
    return_value_sigaction_4=sigaction(13, &sa, (struct sigaction *)(void *)0);
    if(!(return_value_sigaction_4 == 0))
      do
      {
        signed int *return_value___errno_location_2;
        return_value___errno_location_2=__errno_location();
        char *return_value_strerror_3;
        return_value_strerror_3=strerror(-(-(*return_value___errno_location_2)));
        log_msg(1, "failed to ignore SIGPIPE (%s)", return_value_strerror_3);
        _exit(1);
      }
      while((_Bool)0);

    if(!(param.dsp_slave_path == ((char *)NULL)))
    {
      strncpy(dsp_slave_path, param.dsp_slave_path, (unsigned long int)(4096 - 1));
      dsp_slave_path[(signed long int)(4096 - 1)] = (char)0;
    }

    else
    {
      signed int return_value_snprintf_5;
      return_value_snprintf_5=snprintf(dsp_slave_path, (unsigned long int)4096, "%s/%s", (const void *)"/usr/lib/osspd", (const void *)"ossp-padsp");
      ret = (signed long int)return_value_snprintf_5;
      if(ret >= 4096l)
        do
        {
          log_msg(1, "dsp slave pathname too long");
          _exit(1);
        }
        while((_Bool)0);

    }
    signed int return_value_stat_8;
    return_value_stat_8=stat(dsp_slave_path, &stat_buf);
    if(!(return_value_stat_8 == 0))
      do
      {
        signed int *return_value___errno_location_6;
        return_value___errno_location_6=__errno_location();
        char *return_value_strerror_7;
        return_value_strerror_7=strerror(-(-(*return_value___errno_location_6)));
        log_msg(1, "failed to stat %s (%s)", (const void *)dsp_slave_path, return_value_strerror_7);
        _exit(1);
      }
      while((_Bool)0);

    if((292u & stat_buf.st_mode) == 0u || !((61440u & stat_buf.st_mode) == 32768u))
      do
      {
        log_msg(1, "%s is not executable", (const void *)dsp_slave_path);
        _exit(1);
      }
      while((_Bool)0);

    void *return_value_calloc_9;
    return_value_calloc_9=calloc((((unsigned long int)max_streams + (unsigned long int)8 * sizeof(signed long int) /*8ul*/ ) - (unsigned long int)1) / ((unsigned long int)8 * sizeof(signed long int) /*8ul*/ ), sizeof(signed long int) /*8ul*/ );
    os_id_bitmap = (unsigned long int *)return_value_calloc_9;
    void *return_value_calloc_10;
    return_value_calloc_10=calloc((unsigned long int)hashtbl_size, sizeof(struct list_head) /*16ul*/ );
    mixer_tbl = (struct list_head *)return_value_calloc_10;
    void *return_value_calloc_11;
    return_value_calloc_11=calloc((unsigned long int)hashtbl_size, sizeof(struct list_head) /*16ul*/ );
    os_tbl = (struct list_head *)return_value_calloc_11;
    void *return_value_calloc_12;
    return_value_calloc_12=calloc((unsigned long int)hashtbl_size, sizeof(struct list_head) /*16ul*/ );
    os_pgrp_tbl = (struct list_head *)return_value_calloc_12;
    void *return_value_calloc_13;
    return_value_calloc_13=calloc((unsigned long int)hashtbl_size, sizeof(struct list_head) /*16ul*/ );
    os_notify_tbl = (struct list_head *)return_value_calloc_13;
    if(mixer_tbl == ((struct list_head *)NULL) || os_notify_tbl == ((struct list_head *)NULL) || os_pgrp_tbl == ((struct list_head *)NULL) || os_tbl == ((struct list_head *)NULL) || os_id_bitmap == ((unsigned long int *)NULL))
      do
      {
        log_msg(1, "failed to allocate stream hash tables");
        _exit(1);
      }
      while((_Bool)0);

    u = (unsigned int)0;
    for( ; !(u >= hashtbl_size); u = u + 1u)
    {
      INIT_LIST_HEAD(&mixer_tbl[(signed long int)u]);
      INIT_LIST_HEAD(&os_tbl[(signed long int)u]);
      INIT_LIST_HEAD(&os_pgrp_tbl[(signed long int)u]);
      INIT_LIST_HEAD(&os_notify_tbl[(signed long int)u]);
    }
    __set_bit(0, os_id_bitmap);
    signed int return_value_pthread_create_14;
    return_value_pthread_create_14=pthread_create(&mixer_delayed_put_thread, (const union pthread_attr_t *)(void *)0, mixer_delayed_put_worker, (void *)0);
    ret = (signed long int)-return_value_pthread_create_14;
    if(!(ret == 0l))
      do
      {
        char *return_value_strerror_15;
        return_value_strerror_15=strerror((signed int)-ret);
        log_msg(1, "failed to create mixer delayed put worker (%s)", return_value_strerror_15);
        _exit(1);
      }
      while((_Bool)0);

    exit_on_idle = param.exit_on_idle;
    if(!(exit_on_idle == 0))
    {
      struct ossp_mixer *mixer;
      mixer=get_mixer(0);
      if(mixer == ((struct ossp_mixer *)NULL))
        do
        {
          log_msg(1, "failed to touch idle mixer");
          _exit(1);
        }
        while((_Bool)0);

      put_mixer(mixer);
    }

    notify_epfd=epoll_create((signed int)max_streams);
    if(!(notify_epfd >= 0))
      do
      {
        signed int *return_value___errno_location_16;
        return_value___errno_location_16=__errno_location();
        char *return_value_strerror_17;
        return_value_strerror_17=strerror(-(-(*return_value___errno_location_16)));
        log_msg(1, "failed to create notify epoll (%s)", return_value_strerror_17);
        _exit(1);
      }
      while((_Bool)0);

    signed int return_value_fcntl_20;
    return_value_fcntl_20=fcntl(notify_epfd, 2, 1);
    if(!(return_value_fcntl_20 >= 0))
      do
      {
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        char *return_value_strerror_19;
        return_value_strerror_19=strerror(-(-(*return_value___errno_location_18)));
        log_msg(1, "failed to set CLOEXEC on notify epfd (%s)", return_value_strerror_19);
        _exit(1);
      }
      while((_Bool)0);

    signed int return_value_pthread_create_21;
    return_value_pthread_create_21=pthread_create(&notify_poller_thread, (const union pthread_attr_t *)(void *)0, notify_poller, (void *)0);
    ret = (signed long int)-return_value_pthread_create_21;
    if(!(ret == 0l))
      do
      {
        char *return_value_strerror_22;
        return_value_strerror_22=strerror((signed int)-ret);
        log_msg(1, "failed to create notify poller thread (%s)", return_value_strerror_22);
        _exit(1);
      }
      while((_Bool)0);

    signed int return_value_pthread_create_23;
    return_value_pthread_create_23=pthread_create(&slave_reaper_thread, (const union pthread_attr_t *)(void *)0, slave_reaper, (void *)0);
    ret = (signed long int)-return_value_pthread_create_23;
    if(!(ret == 0l))
      do
      {
        char *return_value_strerror_24;
        return_value_strerror_24=strerror((signed int)-ret);
        log_msg(1, "failed to create slave reaper thread (%s)", return_value_strerror_24);
        _exit(1);
      }
      while((_Bool)0);

    unsigned long int return_value_strlen_25;
    return_value_strlen_25=strlen(param.mixer_name);
    if(!(return_value_strlen_25 == 0ul))
      mixer_se=setup_ossp_cuse(&mixer_ops, param.mixer_name, (signed int)param.mixer_major, (signed int)param.mixer_minor, args.argc, args.argv);

    unsigned long int return_value_strlen_26;
    return_value_strlen_26=strlen(param.adsp_name);
    if(!(return_value_strlen_26 == 0ul))
      adsp_se=setup_ossp_cuse(&dsp_ops, param.adsp_name, (signed int)param.adsp_major, (signed int)param.adsp_minor, args.argc, args.argv);

    dsp_se=setup_ossp_cuse(&dsp_ops, param.dsp_name, (signed int)param.dsp_major, (signed int)param.dsp_minor, args.argc, args.argv);
    if(dsp_se == ((struct fuse_session *)NULL))
      do
      {
        log_msg(1, "can't create dsp, giving up");
        _exit(1);
      }
      while((_Bool)0);

    if(!(mixer_se == ((struct fuse_session *)NULL)))
      snprintf(mixer_buf, sizeof(char [64l]) /*64ul*/ , ", %s (%d:%d)", param.mixer_name, param.mixer_major, param.mixer_minor);

    if(!(adsp_se == ((struct fuse_session *)NULL)))
      snprintf(adsp_buf, sizeof(char [64l]) /*64ul*/ , ", %s (%d:%d)", param.adsp_name, param.adsp_major, param.adsp_minor);

    log_msg(4, "Creating %s (%d:%d)%s%s", param.dsp_name, param.dsp_major, param.dsp_minor, (const void *)adsp_buf, (const void *)mixer_buf);
    if(!(mixer_se == ((struct fuse_session *)NULL)))
    {
      signed int return_value_pthread_create_27;
      return_value_pthread_create_27=pthread_create(&cuse_mixer_thread, (const union pthread_attr_t *)(void *)0, cuse_worker, (void *)mixer_se);
      ret = (signed long int)-return_value_pthread_create_27;
      if(!(ret == 0l))
      {
        return_value_strerror_28=strerror((signed int)-ret);
        log_msg(2, "failed to create mixer worker (%s)", return_value_strerror_28);
      }

    }

    if(!(adsp_se == ((struct fuse_session *)NULL)))
    {
      signed int return_value_pthread_create_29;
      return_value_pthread_create_29=pthread_create(&cuse_adsp_thread, (const union pthread_attr_t *)(void *)0, cuse_worker, (void *)adsp_se);
      ret = (signed long int)-return_value_pthread_create_29;
      if(!(ret == 0l))
      {
        return_value_strerror_30=strerror((signed int)-ret);
        log_msg(2, "failed to create adsp worker (%s)", return_value_strerror_30);
      }

    }

    void *return_value_cuse_worker_31;
    return_value_cuse_worker_31=cuse_worker((void *)dsp_se);
    ret = (signed long int)return_value_cuse_worker_31;
    if(!(ret >= 0l))
      do
      {
        log_msg(1, "dsp worker failed");
        _exit(1);
      }
      while((_Bool)0);

    return 0;
  }
}

// mixer_delayed_put_worker
// file osspd.c line 579
static void * mixer_delayed_put_worker(void *arg)
{
  struct ossp_mixer *mixer;
  struct timespec ts;
  signed long int now;
  pthread_mutex_lock(&mutex);
  signed int return_value_list_empty_1;
  struct ossp_mixer *tmp_statement_expression_2;
  do
  {

  again:
    ;
    clock_gettime(0, &ts);
    now = ts.tv_sec;
    mixer = (struct ossp_mixer *)(void *)0;
    do
    {
      return_value_list_empty_1=list_empty(&mixer_delayed_put_head);
      if(!(return_value_list_empty_1 == 0))
        break;

      const struct list_head *__mptr = (&mixer_delayed_put_head)->next;
      tmp_statement_expression_2 = (struct ossp_mixer *)((char *)__mptr - (signed long int)24ul);
      mixer = tmp_statement_expression_2;
      if(mixer->put_expires >= now)
        break;

      /* assertion mixer->refcnt == 1 */
      assert(mixer->refcnt == (unsigned int)1);
      put_mixer_real(mixer);
      mixer = (struct ossp_mixer *)(void *)0;
    }
    while((_Bool)1);
    if(!(mixer == ((struct ossp_mixer *)NULL)))
    {
      ts.tv_sec = mixer->put_expires + (signed long int)1;
      pthread_cond_timedwait(&mixer_delayed_put_cond, &mutex, &ts);
    }

    else
      pthread_cond_wait(&mixer_delayed_put_cond, &mutex);
  }
  while((_Bool)1);
}

// mixer_do_ioctl
// file osspd.c line 752
static void mixer_do_ioctl(struct fuse_req *req, struct ossp_mixer *mixer, unsigned int cmd, void *uarg, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz)
{
  struct ossp_mixer_cmd mxcmd;
  struct ossp_stream *os;
  struct ossp_stream **osa;
  signed int not_mine = 0;
  signed int slot = (signed int)(cmd & (unsigned int)0xff);
  signed int dir;
  signed int nr_os;
  signed int i;
  signed int rc;
  mixer_simple_ioctl(req, mixer, cmd, uarg, in_buf, in_bufsz, out_bufsz, &not_mine);
  void *return_value_calloc_3;
  struct ossp_stream *tmp_statement_expression_4;
  struct list_head *return_value_os_pgrp_tbl_head_6;
  signed int tmp_post_8;
  struct ossp_stream *tmp_statement_expression_7;
  if(!(not_mine == 0))
  {
    rc = -6;
    if(!((3221225472u & cmd) == 0u))
    {
      if(!((1073741824u & cmd) == 0u))
        do
        {
          signed int return_value_ioctl_prep_uarg_1;
          return_value_ioctl_prep_uarg_1=ioctl_prep_uarg(req, (void *)&i, sizeof(signed int) /*4ul*/ , (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
          if(!(return_value_ioctl_prep_uarg_1 == 0))
            goto __CPROVER_DUMP_L25;

        }
        while((_Bool)0);

      else
        do
        {
          signed int return_value_ioctl_prep_uarg_2;
          return_value_ioctl_prep_uarg_2=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
          if(!(return_value_ioctl_prep_uarg_2 == 0))
            goto __CPROVER_DUMP_L25;

        }
        while((_Bool)0);
      switch(slot)
      {
        case 4:
        {
          dir = 0;
          break;
        }
        case 12:
        {
          dir = 1;
          break;
        }
        default:
        {
          i = 0;
          fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
          goto __CPROVER_DUMP_L25;
        }
      }
      init_mixer_cmd(&mxcmd, mixer);
      if(!((1073741824u & cmd) == 0u))
      {
        unsigned int l;
        unsigned int r;
        rc = -22;
        l = (unsigned int)(i & 0xff);
        r = (unsigned int)(i >> 8 & 0xff);
        if(l >= 101u || r >= 101u)
          goto err;

        mxcmd.set.vol[(signed long int)dir][(signed long int)0] = (signed int)l;
        mixer->vol[(signed long int)dir][(signed long int)0] = mxcmd.set.vol[(signed long int)dir][(signed long int)0];
        mxcmd.set.vol[(signed long int)dir][(signed long int)1] = (signed int)r;
        mixer->vol[(signed long int)dir][(signed long int)1] = mxcmd.set.vol[(signed long int)dir][(signed long int)1];
      }

      mxcmd.out_dir = dir;
      pthread_mutex_lock(&mutex);
      return_value_calloc_3=calloc((unsigned long int)max_streams, sizeof(struct ossp_stream *) /*8ul*/ );
      osa = (struct ossp_stream **)return_value_calloc_3;
      if(osa == ((struct ossp_stream **)NULL))
      {
        pthread_mutex_unlock(&mutex);
        rc = -12;
      }

      else
      {
        nr_os = 0;
        const struct list_head *__mptr;
        struct list_head *return_value_os_pgrp_tbl_head_5;
        return_value_os_pgrp_tbl_head_5=os_pgrp_tbl_head(mixer->pgrp);
        __mptr = return_value_os_pgrp_tbl_head_5->next;
        tmp_statement_expression_4 = (struct ossp_stream *)((char *)__mptr - (signed long int)24ul);
        os = tmp_statement_expression_4;
        do
        {
          return_value_os_pgrp_tbl_head_6=os_pgrp_tbl_head(mixer->pgrp);
          if(&os->pgrp_link == return_value_os_pgrp_tbl_head_6)
            break;

          if(os->pgrp == mixer->pgrp)
          {
            tmp_post_8 = nr_os;
            nr_os = nr_os + 1;
            osa[(signed long int)tmp_post_8] = os;
            os->refcnt = os->refcnt + 1u;
          }

          const struct list_head *mixer_do_ioctl__1__6__2____mptr = os->pgrp_link.next;
          tmp_statement_expression_7 = (struct ossp_stream *)((char *)mixer_do_ioctl__1__6__2____mptr - (signed long int)24ul);
          os = tmp_statement_expression_7;
        }
        while((_Bool)1);
        pthread_mutex_unlock(&mutex);
        i = 0;
        for( ; !(i >= nr_os); i = i + 1)
        {
          exec_mixer_cmd(&mxcmd, osa[(signed long int)i]);
          put_os(osa[(signed long int)i]);
        }
        finish_mixer_cmd(&mxcmd);
        free((void *)osa);
        if(!(out_bufsz == 0ul))
          fuse_reply_ioctl(req, 0, (const void *)(out_bufsz != 0ul ? &mxcmd.rvol : (signed int *)(void *)0), sizeof(signed int) /*4ul*/ );

        else
          fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
        goto __CPROVER_DUMP_L25;
      }
    }


  err:
    ;
    fuse_reply_err(req, -rc);
  }


__CPROVER_DUMP_L25:
  ;
}

// mixer_ioctl
// file osspd.c line 868
static void mixer_ioctl(struct fuse_req *req, signed int signed_cmd, void *uarg, struct fuse_file_info *fi, unsigned int flags, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz)
{
  struct ossp_mixer *mixer;
  mixer=find_mixer((signed int)fi->fh);
  if(mixer == ((struct ossp_mixer *)NULL))
    fuse_reply_err(req, 9);

  else
    mixer_do_ioctl(req, mixer, (unsigned int)signed_cmd, uarg, in_buf, in_bufsz, out_bufsz);
}

// mixer_open
// file osspd.c line 846
static void mixer_open(struct fuse_req *req, struct fuse_file_info *fi)
{
  signed int pid;
  struct fuse_ctx *return_value_fuse_req_ctx_1;
  return_value_fuse_req_ctx_1=fuse_req_ctx(req);
  pid = return_value_fuse_req_ctx_1->pid;
  signed int pgrp;
  struct ossp_mixer *mixer;
  signed int rc;
  rc=get_proc_self_info(pid, &pgrp, (char *)(void *)0, (unsigned long int)0);
  if(!(rc == 0))
  {
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(-rc);
    log_msg(2, "get_proc_self_info(%d) failed (%s)", pid, return_value_strerror_2);
    fuse_reply_err(req, -rc);
    goto __CPROVER_DUMP_L4;
  }

  mixer=get_mixer(pgrp);
  fi->fh = (unsigned long int)pgrp;
  if(!(mixer == ((struct ossp_mixer *)NULL)))
    fuse_reply_open(req, fi);

  else
    fuse_reply_err(req, 12);

__CPROVER_DUMP_L4:
  ;
}

// mixer_release
// file osspd.c line 884
static void mixer_release(struct fuse_req *req, struct fuse_file_info *fi)
{
  struct ossp_mixer *mixer;
  mixer=find_mixer((signed int)fi->fh);
  if(!(mixer == ((struct ossp_mixer *)NULL)))
  {
    put_mixer(mixer);
    fuse_reply_err(req, 0);
  }

  else
    fuse_reply_err(req, 9);
}

// mixer_simple_ioctl
// file osspd.c line 696
static void mixer_simple_ioctl(struct fuse_req *req, struct ossp_mixer *mixer, unsigned int cmd, void *uarg, const void *in_buf, unsigned long int in_bufsz, unsigned long int out_bufsz, signed int *not_minep)
{
  const char *id = "OSS Proxy";
  const char *name = "Mixer";
  signed int i;
  if(!(cmd == 2153532773u))
  {
    if(cmd == 2150649189u)
      goto __CPROVER_DUMP_L7;

    if(cmd == 2147765622u)
      goto __CPROVER_DUMP_L13;

    if(cmd == 2147765755u || cmd == 2147765758u)
      goto __CPROVER_DUMP_L14;

    if(cmd == 2147765756u)
      goto __CPROVER_DUMP_L15;

    if(cmd == 2147765757u || cmd == 2147765759u)
      goto __CPROVER_DUMP_L16;

    if(cmd == 3221507583u)
      goto __CPROVER_DUMP_L22;

  }

  else
  {
    struct mixer_info info = { .id={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .modify_counter=0,
    .fillers={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
    do
    {
      signed int return_value_ioctl_prep_uarg_1;
      return_value_ioctl_prep_uarg_1=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&info, sizeof(struct mixer_info) /*92ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
      if(!(return_value_ioctl_prep_uarg_1 == 0))
        goto __CPROVER_DUMP_L26;

    }
    while((_Bool)0);
    strncpy(info.id, id, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
    strncpy(info.name, name, sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);
    info.modify_counter = mixer->modify_counter;
    fuse_reply_ioctl(req, 0, (const void *)&info, sizeof(struct mixer_info) /*92ul*/ );
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L7:
    ;
    struct _old_mixer_info mixer_simple_ioctl__1__1__2__info = { .id={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
    do
    {
      signed int return_value_ioctl_prep_uarg_2;
      return_value_ioctl_prep_uarg_2=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&mixer_simple_ioctl__1__1__2__info, sizeof(struct _old_mixer_info) /*48ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
      if(!(return_value_ioctl_prep_uarg_2 == 0))
        goto __CPROVER_DUMP_L26;

    }
    while((_Bool)0);
    strncpy(mixer_simple_ioctl__1__1__2__info.id, id, sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
    strncpy(mixer_simple_ioctl__1__1__2__info.name, name, sizeof(char [32l]) /*32ul*/  - (unsigned long int)1);
    fuse_reply_ioctl(req, 0, (const void *)&mixer_simple_ioctl__1__1__2__info, sizeof(struct _old_mixer_info) /*48ul*/ );
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L13:
    ;
    i = 198672;
    goto puti;

  __CPROVER_DUMP_L14:
    ;
    i = 1 << 4 | 1 << 12;
    goto puti;

  __CPROVER_DUMP_L15:
    ;
    i = 0x00000001;
    goto puti;

  __CPROVER_DUMP_L16:
    ;
    i = 1 << 12;
    do
    {

    puti:
      ;
      signed int return_value_ioctl_prep_uarg_3;
      return_value_ioctl_prep_uarg_3=ioctl_prep_uarg(req, (void *)0, 1ul, (void *)&i, sizeof(signed int) /*4ul*/ , uarg, in_buf, in_bufsz, out_bufsz);
      if(!(return_value_ioctl_prep_uarg_3 == 0))
        goto __CPROVER_DUMP_L26;

    }
    while((_Bool)0);
    fuse_reply_ioctl(req, 0, (const void *)&i, sizeof(signed int) /*4ul*/ );
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L22:
    ;
    fuse_reply_ioctl(req, 0, (void *)0, (unsigned long int)0);
    goto __CPROVER_DUMP_L26;
  }
  *not_minep = 1;
  goto __CPROVER_DUMP_L26;
  /* assertion 0 */
  assert(0 != 0);

__CPROVER_DUMP_L26:
  ;
}

// mixer_tbl_head
// file osspd.c line 186
static struct list_head * mixer_tbl_head(signed int pid)
{
  return &mixer_tbl[(signed long int)((unsigned int)pid % hashtbl_size)];
}

// notify_poller
// file osspd.c line 1747
static void * notify_poller(void *arg)
{
  struct epoll_event events[1024l];
  signed int i;
  signed int nfds;
  signed int *return_value___errno_location_3;
  do
  {

  repeat:
    ;
    nfds=epoll_wait(notify_epfd, events, (signed int)(sizeof(struct epoll_event [1024l]) /*12288ul*/  / sizeof(struct epoll_event) /*12ul*/ ), -1);
    i = 0;
    for( ; !(i >= nfds); i = i + 1)
    {
      signed int do_notify = 0;
      struct ossp_stream *os;
      struct ossp_notify notify;
      signed long int ret;
      os=find_os_by_notify_rx(events[(signed long int)i].data.fd);
      if(os == ((struct ossp_stream *)NULL))
      {
        log_msg(2, "can't find stream for notify_rx fd %d", events[(signed long int)i].data.fd);
        epoll_ctl(notify_epfd, 2, events[(signed long int)i].data.fd, (struct epoll_event *)(void *)0);
      }

      else
      {
        do
        {
          ret=read(os->notify_rx, (void *)&notify, sizeof(struct ossp_notify) /*8ul*/ );
          if(!(ret >= 1l))
            break;

          if(os->dead == 0)
          {
            if(!((unsigned long int)ret == sizeof(struct ossp_notify) /*8ul*/ ))
            {
              log_msg(3, "S[%u/%d] short read on notify_rx (%zu, expected %zu), killing the stream", os->id, os->pid, ret, sizeof(struct ossp_notify) /*8ul*/ );
              os->dead = 1;
              break;
            }

            if(!(notify.magic == 0xbebebebe))
            {
              log_msg(3, "S[%u/%d] invalid magic on notification, killing the stream", os->id, os->pid);
              os->dead = 1;
              break;
            }

            if(!((signed int)notify.opcode >= OSSP_NR_NOTIFY_OPCODES))
            {
              log_msg(6, "S[%u/%d] NOTIFY %s", os->id, os->pid, ossp_notify_str[(signed long int)notify.opcode]);
              if(!((signed int)notify.opcode == OSSP_NOTIFY_POLL))
              {
                if((signed int)notify.opcode == OSSP_NOTIFY_OBITUARY)
                  goto __CPROVER_DUMP_L7;

                if((signed int)notify.opcode == OSSP_NOTIFY_VOLCHG)
                  goto __CPROVER_DUMP_L8;

                goto unknown;
              }

              do_notify = 1;
              continue;

            __CPROVER_DUMP_L7:
              ;
              os->dead = 1;
              continue;

            __CPROVER_DUMP_L8:
              ;
              pthread_mutex_lock(&mixer_mutex);
              os->mixer->modify_counter = os->mixer->modify_counter + 1;
              pthread_mutex_unlock(&mixer_mutex);
            }

            else
            {

            unknown:
              ;
              log_msg(3, "S[%u/%d] unknown notification %d", os->id, os->pid, notify.opcode);
            }
          }

        }
        while((_Bool)1);
        if(ret == 0l)
          os->dead = 1;

        else
          if(!(ret >= 0l))
          {
            return_value___errno_location_3=__errno_location();
            if(!(*return_value___errno_location_3 == 11))
            {
              signed int *return_value___errno_location_1;
              return_value___errno_location_1=__errno_location();
              char *return_value_strerror_2;
              return_value_strerror_2=strerror(-(-(*return_value___errno_location_1)));
              log_msg(3, "S[%u/%d] read fail on notify fd (%s)", os->id, os->pid, return_value_strerror_2);
              os->dead = 1;
            }

          }

        if(do_notify == 0)
        {
          if(!(os->dead == 0))
            goto __CPROVER_DUMP_L14;

        }

        else
        {

        __CPROVER_DUMP_L14:
          ;
          pthread_mutex_lock(&mutex);
          if(!(os->ph == ((struct fuse_pollhandle *)NULL)))
          {
            fuse_lowlevel_notify_poll(os->ph);
            fuse_pollhandle_destroy(os->ph);
            os->ph = (struct fuse_pollhandle *)(void *)0;
          }

          if(!(os->dead == 0))
          {
            log_msg(5, "S[%u/%d] removing %d from notify poll list", os->id, os->pid, os->notify_rx);
            epoll_ctl(notify_epfd, 2, os->notify_rx, (struct epoll_event *)(void *)0);
            close(os->notify_rx);
            os->notify_rx = -1;
            pthread_cond_broadcast(&notify_poller_kill_wait);
          }

          pthread_mutex_unlock(&mutex);
        }
      }
    }
  }
  while((_Bool)1);
}

// os_notify_tbl_head
// file osspd.c line 201
static struct list_head * os_notify_tbl_head(signed int notify_rx)
{
  return &os_notify_tbl[(signed long int)((unsigned int)notify_rx % hashtbl_size)];
}

// os_pgrp_tbl_head
// file osspd.c line 196
static struct list_head * os_pgrp_tbl_head(signed int pgrp)
{
  return &os_pgrp_tbl[(signed long int)((unsigned int)pgrp % hashtbl_size)];
}

// os_tbl_head
// file osspd.c line 191
static struct list_head * os_tbl_head(unsigned long int id)
{
  return &os_tbl[(signed long int)(id % (unsigned long int)hashtbl_size)];
}

// ossp_daemonize
// file osspd.c line 1891
static void ossp_daemonize(void)
{
  signed int fd;
  signed int pfd[2l];
  signed int pid;
  signed long int ret;
  signed int err;
  fd=open("/dev/null", 02);
  if(fd >= 0)
  {
    dup2(fd, 0);
    dup2(fd, 1);
    dup2(fd, 2);
    if(fd >= 3)
      close(fd);

  }

  signed int return_value_pipe_3;
  return_value_pipe_3=pipe(pfd);
  if(!(return_value_pipe_3 == 0))
    do
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(-(-(*return_value___errno_location_1)));
      log_msg(1, "failed to create pipe for init wait (%s)", return_value_strerror_2);
      _exit(1);
    }
    while((_Bool)0);

  signed int return_value_fcntl_6;
  return_value_fcntl_6=fcntl(pfd[(signed long int)0], 2, 1);
  _Bool tmp_if_expr_8;
  signed int return_value_fcntl_7;
  if(!(return_value_fcntl_6 >= 0))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    return_value_fcntl_7=fcntl(pfd[(signed long int)1], 2, 1);
    tmp_if_expr_8 = return_value_fcntl_7 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_8)
    do
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(-(-(*return_value___errno_location_4)));
      log_msg(1, "failed to set CLOEXEC on init wait pipe (%s)", return_value_strerror_5);
      _exit(1);
    }
    while((_Bool)0);

  pid=fork();
  if(!(pid >= 0))
    do
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      char *return_value_strerror_10;
      return_value_strerror_10=strerror(-(-(*return_value___errno_location_9)));
      log_msg(1, "failed to fork for daemon (%s)", return_value_strerror_10);
      _exit(1);
    }
    while((_Bool)0);

  _Bool tmp_if_expr_12;
  signed int *return_value___errno_location_11;
  if(pid == 0)
  {
    close(pfd[(signed long int)0]);
    init_wait_fd = pfd[(signed long int)1];
    chdir("/");
    setsid();
  }

  else
  {
    close(pfd[(signed long int)1]);
    do
    {
      ret=read(pfd[(signed long int)0], (void *)&err, sizeof(signed int) /*4ul*/ );
      if(!(ret >= 0l))
      {
        return_value___errno_location_11=__errno_location();
        tmp_if_expr_12 = *return_value___errno_location_11 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_12 = (_Bool)0;
    }
    while(tmp_if_expr_12);
    if(err == 0 && (unsigned long int)ret == sizeof(signed int) /*4ul*/ )
      exit(0);

    do
    {
      log_msg(1, "daemon init failed ret=%zd err=%d", ret, err);
      _exit(1);
    }
    while((_Bool)0);
    exit(1);
  }
}

// ossp_init_done
// file osspd.c line 1942
static void ossp_init_done(void *userdata)
{
  if(init_wait_fd >= 0)
  {
    signed long int ret;
    signed int err = 0;
    ret=write(init_wait_fd, (const void *)&err, sizeof(signed int) /*4ul*/ );
    if(!((unsigned long int)ret == sizeof(signed int) /*4ul*/ ))
      do
      {
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        char *return_value_strerror_2;
        return_value_strerror_2=strerror(-(-(*return_value___errno_location_1)));
        log_msg(1, "failed to notify init completion, ret=%zd (%s)", ret, return_value_strerror_2);
        _exit(1);
      }
      while((_Bool)0);

    close(init_wait_fd);
    init_wait_fd = -1;
  }

}

// ossp_slave_init
// file ossp-slave.c line 44
void ossp_slave_init(signed int argc, char **argv)
{
  signed int have_uid = 0;
  signed int have_gid = 0;
  unsigned int uid;
  unsigned int gid;
  signed int mmap_fd = -1;
  signed long int mmap_off = (signed long int)0;
  unsigned long int mmap_size = (unsigned long int)0;
  signed int opt;
  struct passwd *pw;
  struct passwd pw_buf;
  struct sigaction sa;
  signed long int sa_array_size0;
  sa_array_size0=sysconf(70);
  char pw_sbuf[sa_array_size0];
  signed long int return_value_strtol_1;
  signed long int return_value_strtol_2;
  signed long int return_value_strtol_3;
  signed long int return_value_strtol_4;
  signed long int return_value_strtol_5;
  unsigned long long int return_value_strtoull_6;
  signed long int return_value_strtol_7;
  do
  {
    opt=getopt(argc, argv, "u:g:c:n:m:o:s:l:t");
    if(opt == -1)
      break;

    switch(opt)
    {
      case 117:
      {
        have_uid = 1;
        return_value_strtol_1=strtol(optarg, (char ** restrict )(void *)0, 0);
        uid = (unsigned int)return_value_strtol_1;
        break;
      }
      case 103:
      {
        have_gid = 1;
        return_value_strtol_2=strtol(optarg, (char ** restrict )(void *)0, 0);
        gid = (unsigned int)return_value_strtol_2;
        break;
      }
      case 99:
      {
        return_value_strtol_3=strtol(optarg, (char ** restrict )(void *)0, 0);
        ossp_cmd_fd = (signed int)return_value_strtol_3;
        break;
      }
      case 110:
      {
        return_value_strtol_4=strtol(optarg, (char ** restrict )(void *)0, 0);
        ossp_notify_fd = (signed int)return_value_strtol_4;
        break;
      }
      case 109:
      {
        return_value_strtol_5=strtol(optarg, (char ** restrict )(void *)0, 0);
        mmap_fd = (signed int)return_value_strtol_5;
        break;
      }
      case 111:
      {
        return_value_strtoull_6=strtoull(optarg, (char ** restrict )(void *)0, 0);
        mmap_off = (signed long int)return_value_strtoull_6;
        break;
      }
      case 115:
      {
        mmap_size=strtoul(optarg, (char ** restrict )(void *)0, 0);
        break;
      }
      case 108:
      {
        return_value_strtol_7=strtol(optarg, (char ** restrict )(void *)0, 0);
        ossp_log_level = (signed int)return_value_strtol_7;
        break;
      }
      case 116:
        ossp_log_timestamp = 1;
    }
  }
  while((_Bool)1);
  if(have_gid == 0 || have_uid == 0 || !(ossp_cmd_fd >= 0) || !(ossp_notify_fd >= 0))
  {
    fputs(usage_link1, stderr);
    _exit(1);
  }

  snprintf(ossp_user_name, sizeof(char [128l]) /*128ul*/ , "uid%d", uid);
  signed int return_value_getpwuid_r_8;
  return_value_getpwuid_r_8=getpwuid_r(uid, &pw_buf, pw_sbuf, (unsigned long int)sa_array_size0, &pw);
  if(return_value_getpwuid_r_8 == 0)
    snprintf(ossp_user_name, sizeof(char [128l]) /*128ul*/ , "%s", pw->pw_name);

  signed int return_value_getpid_9;
  return_value_getpid_9=getpid();
  snprintf(ossp_log_name, sizeof(char [128l]) /*128ul*/ , "ossp-padsp[%s:%d]", (const void *)ossp_user_name, return_value_getpid_9);
  if(mmap_fd >= 0)
  {
    void *p;
    if(mmap_off == 0l || mmap_size == 0ul)
    {
      fputs(usage_link1, stderr);
      _exit(1);
    }

    p=mmap((void *)0, mmap_size, 0x1 | 0x2, 0x01, mmap_fd, mmap_off);
    if(p == (void *)-1)
      do
      {
        signed int *return_value___errno_location_10;
        return_value___errno_location_10=__errno_location();
        char *return_value_strerror_11;
        return_value_strerror_11=strerror(-(-(*return_value___errno_location_10)));
        log_msg(1, "mmap failed (%s)", return_value_strerror_11);
        _exit(1);
      }
      while((_Bool)0);

    ossp_mmap_addr[(signed long int)0] = p;
    ossp_mmap_addr[(signed long int)1] = p + (signed long int)(mmap_size / (unsigned long int)2);
    close(mmap_fd);
  }

  signed int return_value_setresgid_14;
  return_value_setresgid_14=setresgid(gid, gid, gid);
  _Bool tmp_if_expr_16;
  signed int return_value_setresuid_15;
  if(!(return_value_setresgid_14 == 0))
    tmp_if_expr_16 = (_Bool)1;

  else
  {
    return_value_setresuid_15=setresuid(uid, uid, uid);
    tmp_if_expr_16 = return_value_setresuid_15 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_16)
    do
    {
      signed int *return_value___errno_location_12;
      return_value___errno_location_12=__errno_location();
      char *return_value_strerror_13;
      return_value_strerror_13=strerror(-(-(*return_value___errno_location_12)));
      log_msg(1, "failed to drop privileges (%s)", return_value_strerror_13);
      _exit(1);
    }
    while((_Bool)0);

  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  signed int return_value_sigaction_19;
  return_value_sigaction_19=sigaction(13, &sa, (struct sigaction *)(void *)0);
  if(!(return_value_sigaction_19 == 0))
    do
    {
      signed int *return_value___errno_location_17;
      return_value___errno_location_17=__errno_location();
      char *return_value_strerror_18;
      return_value_strerror_18=strerror(-(-(*return_value___errno_location_17)));
      log_msg(1, "failed to ignore SIGPIPE (%s)", return_value_strerror_18);
      _exit(1);
    }
    while((_Bool)0);

}

// ossp_slave_process_command
// file ossp-slave.c line 133
signed int ossp_slave_process_command(signed int cmd_fd, signed long int (* const *action_fn_tbl)(enum ossp_opcode, void *, void *, unsigned long int, void *, void *, unsigned long int *, signed int), signed int (*action_pre_fn)(void), void (*action_post_fn)(void))
{
  struct ossp_cmd cmd;
  signed int fd = -1;
  char cmsg_buf[24l];
  struct iovec iov = { .iov_base=(void *)&cmd, .iov_len=sizeof(struct ossp_cmd) /*24ul*/  };
  struct msghdr msg = { .msg_name=NULL, .msg_namelen=0u, .msg_iov=&iov, .msg_iovlen=(unsigned long int)1,
    .msg_control=(void *)cmsg_buf, .msg_controllen=sizeof(char [24l]) /*24ul*/ ,
    .msg_flags=0 };
  struct cmsghdr *cmsg;
  unsigned long int carg_size;
  unsigned long int din_size;
  unsigned long int rarg_size;
  unsigned long int dout_size;
  char *carg = (char *)(void *)0;
  char *din = (char *)(void *)0;
  char *rarg = (char *)(void *)0;
  char *dout = (char *)(void *)0;
  struct ossp_reply reply = { .magic=0xbeefdead, .result=0, .dout_size=0ul };
  signed long int ret;
  ret=recvmsg(cmd_fd, &msg, 0);
  struct cmsghdr *tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  signed int return_value_ensure_sbuf_size_6;
  _Bool tmp_if_expr_9;
  signed int return_value_ensure_sbuf_size_8;
  _Bool tmp_if_expr_11;
  signed int return_value_ensure_sbuf_size_10;
  _Bool tmp_if_expr_16;
  signed int return_value_write_fill_15;
  _Bool tmp_if_expr_18;
  signed int return_value_write_fill_17;
  if(ret == 0l)
    return 0;

  else
  {
    if(!(ret >= 0l))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      ret = (signed long int)-(*return_value___errno_location_1);
      char *return_value_strerror_2;
      return_value_strerror_2=strerror((signed int)-ret);
      log_msg(2, "failed to read command channel (%s)", return_value_strerror_2);
      return (signed int)ret;
    }

    if(!((unsigned long int)ret == sizeof(struct ossp_cmd) /*24ul*/ ))
    {
      log_msg(2, "command struct size mismatch (%zu, should be %zu)", ret, sizeof(struct ossp_cmd) /*24ul*/ );
      return -22;
    }

    else
      if(!(cmd.magic == 0xdeadbeef))
      {
        log_msg(2, "illegal command magic 0x%x", cmd.magic);
        return -22;
      }

      else
      {
        if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
          tmp_if_expr_3 = (struct cmsghdr *)(&msg)->msg_control;

        else
          tmp_if_expr_3 = (struct cmsghdr *)0;
        cmsg = tmp_if_expr_3;
        while(!(cmsg == ((struct cmsghdr *)NULL)))
        {
          if(cmsg->cmsg_level == 1)
            tmp_if_expr_4 = cmsg->cmsg_type == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            fd = *((signed int *)cmsg->__cmsg_data);

          else
          {
            log_msg(2, "unknown cmsg %d:%d received (opcode %d)", cmsg->cmsg_level, cmsg->cmsg_type, cmd.opcode);
            return -22;
          }
          cmsg=__cmsg_nxthdr(&msg, cmsg);
        }
        if((signed int)cmd.opcode >= OSSP_NR_OPCODES)
        {
          log_msg(2, "unknown opcode %d", cmd.opcode);
          return -22;
        }

        else
        {
          carg_size = (unsigned long int)ossp_arg_sizes[(signed long int)cmd.opcode].carg_size;
          din_size = cmd.din_size;
          rarg_size = (unsigned long int)ossp_arg_sizes[(signed long int)cmd.opcode].rarg_size;
          dout_size = cmd.dout_size;
          if(!((signed int)(fd >= 0) == (signed int)ossp_arg_sizes[(signed long int)cmd.opcode].has_fd))
          {
            log_msg(2, "fd=%d unexpected for opcode %d", fd, cmd.opcode);
            return -22;
          }

          else
          {
            signed int return_value_ensure_sbuf_size_5;
            static struct sized_buf carg_sbuf = { .buf=((char *)NULL), .size=0ul };
            return_value_ensure_sbuf_size_5=ensure_sbuf_size(&carg_sbuf, carg_size);
            static struct sized_buf din_sbuf = { .buf=((char *)NULL), .size=0ul };
            if(!(return_value_ensure_sbuf_size_5 == 0))
              tmp_if_expr_7 = (_Bool)1;

            else
            {
              return_value_ensure_sbuf_size_6=ensure_sbuf_size(&din_sbuf, din_size);
              tmp_if_expr_7 = return_value_ensure_sbuf_size_6 != 0 ? (_Bool)1 : (_Bool)0;
            }
            static struct sized_buf rarg_sbuf = { .buf=((char *)NULL), .size=0ul };
            if(tmp_if_expr_7)
              tmp_if_expr_9 = (_Bool)1;

            else
            {
              return_value_ensure_sbuf_size_8=ensure_sbuf_size(&rarg_sbuf, rarg_size);
              tmp_if_expr_9 = return_value_ensure_sbuf_size_8 != 0 ? (_Bool)1 : (_Bool)0;
            }
            static struct sized_buf dout_sbuf = { .buf=((char *)NULL), .size=0ul };
            if(tmp_if_expr_9)
              tmp_if_expr_11 = (_Bool)1;

            else
            {
              return_value_ensure_sbuf_size_10=ensure_sbuf_size(&dout_sbuf, dout_size);
              tmp_if_expr_11 = return_value_ensure_sbuf_size_10 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_11)
            {
              log_msg(2, "failed to allocate command buffers");
              return -12;
            }

            else
            {
              if(!(carg_size == 0ul))
              {
                carg = carg_sbuf.buf;
                signed int return_value_read_fill_12;
                return_value_read_fill_12=read_fill(cmd_fd, (void *)carg, carg_size);
                ret = (signed long int)return_value_read_fill_12;
                if(!(ret >= 0l))
                  return (signed int)ret;

              }

              if(!(din_size == 0ul))
              {
                din = din_sbuf.buf;
                signed int return_value_read_fill_13;
                return_value_read_fill_13=read_fill(cmd_fd, (void *)din, din_size);
                ret = (signed long int)return_value_read_fill_13;
                if(!(ret >= 0l))
                  return (signed int)ret;

              }

              if(!(rarg_size == 0ul))
                rarg = rarg_sbuf.buf;

              if(!(dout_size == 0ul))
                dout = dout_sbuf.buf;

              ret = (signed long int)-22;
              if(!(action_fn_tbl[(signed long int)cmd.opcode] == ((signed long int (*)(enum ossp_opcode, void *, void *, unsigned long int, void *, void *, unsigned long int *, signed int))NULL)))
              {
                signed int return_value;
                return_value=action_pre_fn();
                ret = (signed long int)return_value;
                if(ret == 0l)
                {
                  ret=action_fn_tbl[(signed long int)cmd.opcode](cmd.opcode, (void *)carg, (void *)din, din_size, (void *)rarg, (void *)dout, &dout_size, fd);
                  action_post_fn();
                }

              }

              reply.result = (signed int)ret;
              if(ret >= 0l)
                reply.dout_size = dout_size;

              else
              {
                rarg_size = (unsigned long int)0;
                dout_size = (unsigned long int)0;
              }
              signed int return_value_write_fill_14;
              return_value_write_fill_14=write_fill(cmd_fd, (const void *)&reply, sizeof(struct ossp_reply) /*16ul*/ );
              if(!(return_value_write_fill_14 >= 0))
                tmp_if_expr_16 = (_Bool)1;

              else
              {
                return_value_write_fill_15=write_fill(cmd_fd, (const void *)rarg, rarg_size);
                tmp_if_expr_16 = return_value_write_fill_15 < 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_16)
                tmp_if_expr_18 = (_Bool)1;

              else
              {
                return_value_write_fill_17=write_fill(cmd_fd, (const void *)dout, dout_size);
                tmp_if_expr_18 = return_value_write_fill_17 < 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_18)
                return -5;

              else
                return 1;
            }
          }
        }
      }
  }
}

// process_arg
// file osspd.c line 2105
static signed int process_arg(void *data, const char *arg, signed int key, struct fuse_args *outargs)
{
  struct ossp_param *param = (struct ossp_param *)data;
  switch(key)
  {
    case 0:
    {
      fputs(usage, stderr);
      param->help = 1;
      return 0;
    }
    case 1:
    {
      param->log_level = param->log_level + 1u;
      return 0;
    }
    default:
      return 1;
  }
}

// put_mixer
// file osspd.c line 559
static void put_mixer(struct ossp_mixer *mixer)
{
  pthread_mutex_lock(&mutex);
  if(!(mixer == ((struct ossp_mixer *)NULL)))
  {
    if(mixer->refcnt == 1u)
    {
      struct timespec ts;
      clock_gettime(0, &ts);
      mixer->put_expires = ts.tv_sec + (signed long int)600;
      list_add_tail(&mixer->delayed_put_link, &mixer_delayed_put_head);
      pthread_cond_signal(&mixer_delayed_put_cond);
    }

    else
      put_mixer_real(mixer);
  }

  pthread_mutex_unlock(&mutex);
}

// put_mixer_real
// file osspd.c line 485
static void put_mixer_real(struct ossp_mixer *mixer)
{
  mixer->refcnt = mixer->refcnt - 1u;
  if(mixer->refcnt == 0u)
  {
    log_msg(5, "DESTROY mixer(%d)", mixer->pgrp);
    list_del_init(&mixer->link);
    list_del_init(&mixer->delayed_put_link);
    free((void *)mixer);
    nr_mixers = nr_mixers - 1u;
    if(nr_mixers == 0u && !(exit_on_idle == 0))
    {
      log_msg(4, "idle, exiting");
      exit(0);
    }

  }

}

// put_os
// file osspd.c line 1020
static void put_os(struct ossp_stream *os)
{
  if(!(os == ((struct ossp_stream *)NULL)))
  {
    pthread_mutex_lock(&mutex);
    /* assertion os->refcnt */
    assert(os->refcnt != 0u);
    os->refcnt = os->refcnt - 1u;
    if(!(os->refcnt == 0u))
      pthread_mutex_unlock(&mutex);

    else
    {
      os->dead = 1;
      shutdown_notification(os);
      log_msg(5, "S[%u/%d] DESTROY", os->id, os->pid);
      list_del_init(&os->link);
      list_del_init(&os->pgrp_link);
      list_del_init(&os->notify_link);
      os->ucnt->nr_os = os->ucnt->nr_os - 1u;
      pthread_mutex_unlock(&mutex);
      close(os->cmd_fd);
      close(os->notify_tx);
      put_mixer(os->mixer);
      pthread_mutex_destroy(&os->cmd_mutex);
      pthread_mutex_destroy(&os->mmap_mutex);
      pthread_mutex_lock(&mutex);
      log_msg(6, "S[%u/%d] stream dead, requesting reaping", os->id, os->pid);
      list_add_tail(&os->link, &slave_corpse_list);
      pthread_cond_signal(&slave_reaper_wait);
      pthread_mutex_unlock(&mutex);
    }
  }

}

// read_fill
// file ossp-util.h line 142
signed int read_fill(signed int fd, void *buf, unsigned long int size)
{
  signed int *return_value___errno_location_1;
  while(!(size == 0ul))
  {
    signed long int ret;
    signed int rc;
    ret=read(fd, buf, size);
    if(!(ret >= 1l))
    {
      if(ret == 0l)
        rc = -5;

      else
      {
        return_value___errno_location_1=__errno_location();
        rc = -(*return_value___errno_location_1);
      }
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(-rc);
      log_msg(2, "failed to read_fill %zu bytes from fd %d (%s)", size, fd, return_value_strerror_2);
      return rc;
    }

    buf = buf + ret;
    size = size - (unsigned long int)ret;
  }
  return 0;
}

// ring_bytes
// file ossp-util.h line 106
static inline unsigned long int ring_bytes(struct ring_buf *ring)
{
  return ring->bytes;
}

// ring_consume
// file ossp-util.h line 116
static inline void ring_consume(struct ring_buf *ring, unsigned long int size)
{
  /* assertion ring->bytes >= size */
  assert(ring->bytes >= size);
  ring->bytes = ring->bytes - size;
}

// ring_data
// file ossp-util.c line 169
void * ring_data(struct ring_buf *ring, unsigned long int *sizep)
{
  unsigned long int tail;
  unsigned long int tmp_statement_expression_1;
  if(ring->bytes == 0ul)
    return (void *)0;

  else
  {
    tail = ((ring->head + ring->size) - ring->bytes) % ring->size;
    unsigned long int _min1 = ring->bytes;
    unsigned long int _min2 = ring->size - tail;
    (void)(&_min1 == &_min2);
    tmp_statement_expression_1 = _min1 < _min2 ? _min1 : _min2;
    *sizep = tmp_statement_expression_1;
    return (void *)(ring->buf + (signed long int)tail);
  }
}

// ring_fill
// file ossp-util.c line 145
void ring_fill(struct ring_buf *ring, const void *buf, unsigned long int size)
{
  unsigned long int tail;
  unsigned long int return_value_ring_space_1;
  return_value_ring_space_1=ring_space(ring);
  /* assertion ring_space(ring) >= size */
  assert(return_value_ring_space_1 >= size);
  tail = ((ring->head + ring->size) - ring->bytes) % ring->size;
  unsigned long int tmp_statement_expression_2;
  if(ring->head >= tail)
  {
    unsigned long int todo;
    unsigned long int _min1 = size;
    unsigned long int _min2 = ring->size - ring->head;
    (void)(&_min1 == &_min2);
    tmp_statement_expression_2 = _min1 < _min2 ? _min1 : _min2;
    todo = tmp_statement_expression_2;
    memcpy((void *)(ring->buf + (signed long int)ring->head), buf, todo);
    ring->head = (ring->head + todo) % ring->size;
    ring->bytes = ring->bytes + todo;
    buf = buf + (signed long int)todo;
    size = size - todo;
  }

  /* assertion ring->size - ring->head >= size */
  assert(ring->size - ring->head >= size);
  memcpy((void *)(ring->buf + (signed long int)ring->head), buf, size);
  ring->head = ring->head + size;
  ring->bytes = ring->bytes + size;
}

// ring_resize
// file ossp-util.c line 182
signed int ring_resize(struct ring_buf *ring, unsigned long int new_size)
{
  struct ring_buf new_ring = { .buf=((char *)NULL), .size=new_size, .head=0ul, .bytes=0ul };
  void *p;
  unsigned long int size;
  unsigned long int return_value_ring_bytes_1;
  return_value_ring_bytes_1=ring_bytes(ring);
  if(!(new_size >= return_value_ring_bytes_1))
    return -28;

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, new_size);
    new_ring.buf = (char *)return_value_calloc_2;
    if(new_ring.buf == ((char *)NULL) && !(new_size == 0ul))
      return -12;

    else
    {
      do
      {
        p=ring_data(ring, &size);
        if(p == NULL)
          break;

        ring_fill(&new_ring, p, size);
        ring_consume(ring, size);
      }
      while((_Bool)1);
      free((void *)ring->buf);
      *ring = new_ring;
      return 0;
    }
  }
}

// ring_space
// file ossp-util.h line 111
static inline unsigned long int ring_space(struct ring_buf *ring)
{
  return ring->size - ring->bytes;
}

// set_extra_env
// file osspd.c line 1058
static void set_extra_env(signed int pid)
{
  char procenviron[32l];
  const signed int step = 1024;
  char *data;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(step + 1));
  data = (char *)return_value_malloc_1;
  signed int ofs = 0;
  signed int fd;
  signed int ret;
  signed long int return_value_read_2;
  unsigned long int return_value_strlen_4;
  _Bool tmp_if_expr_7;
  signed int return_value_strncmp_6;
  if(!(data == ((char *)NULL)))
  {
    sprintf(procenviron, "/proc/%d/environ", pid);
    fd=open(procenviron, 00);
    if(fd >= 0)
    {
      do
      {
        return_value_read_2=read(fd, (void *)(data + (signed long int)ofs), (unsigned long int)step);
        ret = (signed int)return_value_read_2;
        if(!(ret >= 1))
          break;

        char *newdata;
        ofs = ofs + ret;
        void *return_value_realloc_3;
        return_value_realloc_3=realloc((void *)data, (unsigned long int)(ofs + step + 1));
        newdata = (char *)return_value_realloc_3;
        if(newdata == ((char *)NULL))
        {
          ret = -1;
          break;
        }

        data = newdata;
      }
      while((_Bool)1);
      if(ret == 0)
      {
        char *ptr = data;
        data[(signed long int)ofs] = (char)0;
        do
        {
          return_value_strlen_4=strlen(ptr);
          ret = (signed int)return_value_strlen_4;
          if(!(ret >= 1))
            break;

          signed int return_value_strncmp_5;
          return_value_strncmp_5=strncmp(ptr, "DISPLAY=", (unsigned long int)8);
          if(return_value_strncmp_5 == 0)
            tmp_if_expr_7 = (_Bool)1;

          else
          {
            return_value_strncmp_6=strncmp(ptr, "PULSE_", (unsigned long int)6);
            tmp_if_expr_7 = !(return_value_strncmp_6 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_7)
            putenv(ptr);

          ptr = ptr + (signed long int)(ret + 1);
        }
        while((_Bool)1);
      }

      free((void *)data);
      close(fd);
    }

  }

}

// setup_ossp_cuse
// file osspd.c line 2060
static struct fuse_session * setup_ossp_cuse(struct cuse_lowlevel_ops *ops, const char *name, signed int major, signed int minor, signed int argc, char **argv)
{
  char name_buf[128l];
  const char *bufp = name_buf;
  struct cuse_info ci = { .dev_major=(unsigned int)major, .dev_minor=(unsigned int)minor, .dev_info_argc=(unsigned int)1,
    .dev_info_argv=&bufp, .flags=(unsigned int)(1 << 0) };
  struct fuse_session *se;
  signed int fd;
  snprintf(name_buf, sizeof(char [128l]) /*128ul*/ , "DEVNAME=%s", name);
  se=cuse_lowlevel_setup(argc, argv, &ci, ops, (signed int *)(void *)0, (void *)0);
  if(se == ((struct fuse_session *)NULL))
  {
    log_msg(2, "failed to setup %s CUSE", name);
    return (struct fuse_session *)(void *)0;
  }

  else
  {
    struct fuse_chan *return_value_fuse_session_next_chan_1;
    return_value_fuse_session_next_chan_1=fuse_session_next_chan(se, (struct fuse_chan *)(void *)0);
    fd=fuse_chan_fd(return_value_fuse_session_next_chan_1);
    signed int return_value_fcntl_4;
    return_value_fcntl_4=fcntl(fd, 2, 1);
    if(!(return_value_fcntl_4 >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(-(-(*return_value___errno_location_2)));
      log_msg(2, "failed to set CLOEXEC on %s CUSE fd (%s)", name, return_value_strerror_3);
      cuse_lowlevel_teardown(se);
      return (struct fuse_session *)(void *)0;
    }

    return se;
  }
}

// shutdown_notification
// file osspd.c line 990
static void shutdown_notification(struct ossp_stream *os)
{
  struct ossp_notify obituary = { .magic=0xbebebebe, .opcode=(enum ossp_notify_opcode)OSSP_NOTIFY_OBITUARY };
  signed long int ret;
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  while(os->notify_rx >= 0)
  {
    ret=write(os->notify_tx, (const void *)&obituary, sizeof(struct ossp_notify) /*8ul*/ );
    if(!(ret >= 1l))
    {
      if(ret == 0l)
        log_msg(3, "S[%u/%d] unexpected EOF on notify_tx", os->id, os->pid);

      else
      {
        return_value___errno_location_3=__errno_location();
        if(!(*return_value___errno_location_3 == 32))
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(-(-(*return_value___errno_location_1)));
          log_msg(3, "S[%u/%d] unexpected error on notify_tx (%s)", os->id, os->pid, return_value_strerror_2);
        }

      }
      close(os->notify_rx);
      os->notify_rx = -1;
      break;
    }

    if(!((unsigned long int)ret == sizeof(struct ossp_notify) /*8ul*/ ))
      log_msg(3, "S[%u/%d] short transfer on notify_tx", os->id, os->pid);

    pthread_cond_wait(&notify_poller_kill_wait, &mutex);
  }
}

// slave_reaper
// file osspd.c line 1849
static void * slave_reaper(void *arg)
{
  struct ossp_stream *os;
  signed int status;
  signed int pid;
  pthread_mutex_lock(&mutex);
  signed int return_value_list_empty_1;
  struct ossp_stream *tmp_statement_expression_2;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  do
  {

  repeat:
    ;
    return_value_list_empty_1=list_empty(&slave_corpse_list);
    if(!(return_value_list_empty_1 == 0))
    {
      pthread_cond_wait(&slave_reaper_wait, &mutex);
      goto repeat;
    }

    const struct list_head *__mptr = (&slave_corpse_list)->next;
    tmp_statement_expression_2 = (struct ossp_stream *)((char *)__mptr - (signed long int)8ul);
    os = tmp_statement_expression_2;
    list_del_init(&os->link);
    pthread_mutex_unlock(&mutex);
    do
    {
      pid=waitpid(os->slave_pid, &status, 0);
      if(!(pid >= 0))
      {
        return_value___errno_location_3=__errno_location();
        tmp_if_expr_4 = *return_value___errno_location_3 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
    }
    while(tmp_if_expr_4);
    if(!(pid >= 0))
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      if(*return_value___errno_location_9 == 10)
      {
        return_value___errno_location_5=__errno_location();
        return_value_strerror_6=strerror(-(-(*return_value___errno_location_5)));
        log_msg(3, "S[%u/%d] slave %d already gone? (%s)", os->id, os->pid, os->slave_pid, return_value_strerror_6);
      }

      else
        do
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          char *return_value_strerror_8;
          return_value_strerror_8=strerror(-(-(*return_value___errno_location_7)));
          log_msg(1, "waitpid(%d) failed (%s)", os->slave_pid, return_value_strerror_8);
          _exit(1);
        }
        while((_Bool)0);
    }

    pthread_mutex_lock(&mutex);
    log_msg(6, "S[%u/%d] slave %d reaped", os->id, os->pid, os->slave_pid);
    __clear_bit((signed int)os->id, os_id_bitmap);
    free((void *)os);
  }
  while((_Bool)1);
}

// write_fill
// file ossp-util.h line 143
signed int write_fill(signed int fd, const void *buf, unsigned long int size)
{
  signed int *return_value___errno_location_1;
  while(!(size == 0ul))
  {
    signed long int ret;
    signed int rc;
    ret=write(fd, buf, size);
    if(!(ret >= 1l))
    {
      if(ret == 0l)
        rc = -5;

      else
      {
        return_value___errno_location_1=__errno_location();
        rc = -(*return_value___errno_location_1);
      }
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(-rc);
      log_msg(2, "failed to write_fill %zu bytes to fd %d (%s)", size, fd, return_value_strerror_2);
      return rc;
    }

    buf = buf + ret;
    size = size - (unsigned long int)ret;
  }
  return 0;
}

