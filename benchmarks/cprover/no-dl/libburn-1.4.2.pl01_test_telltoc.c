// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$0;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-buffer
// file libburn/transport.h line 43
struct buffer;

// tag-burn_block_types
// file libburn/libburn.h line 188
enum burn_block_types { BURN_BLOCK_RAW0=1, BURN_BLOCK_RAW16=2, BURN_BLOCK_RAW96P=4, BURN_BLOCK_RAW96R=8, BURN_BLOCK_MODE1=256, BURN_BLOCK_MODE2R=512, BURN_BLOCK_MODE2_PATHETIC=1024, BURN_BLOCK_MODE2_LAME=2048, BURN_BLOCK_MODE2_OBSCURE=4096, BURN_BLOCK_MODE2_OK=8192, BURN_BLOCK_SAO=16384 };

// tag-burn_cdtext
// file libburn/structure.h line 28
struct burn_cdtext;

// tag-burn_cue_file_cursor
// file libburn/structure.c line 1169
struct burn_cue_file_cursor;

// tag-burn_disc
// file libburn/libburn.h line 54
struct burn_disc;

// tag-burn_disc_mode_demands
// file libburn/drive.h line 111
struct burn_disc_mode_demands;

// tag-burn_disc_status
// file test/../libburn/libburn.h line 228
enum burn_disc_status { BURN_DISC_UNREADY=0, BURN_DISC_BLANK=1, BURN_DISC_EMPTY=2, BURN_DISC_APPENDABLE=3, BURN_DISC_FULL=4, BURN_DISC_UNGRABBED=5, BURN_DISC_UNSUITABLE=6 };

// tag-burn_drive
// file libburn/libburn.h line 51
struct burn_drive;

// tag-burn_drive_enumerator_struct
// file libburn/os-linux.h line 56
struct burn_drive_enumerator_struct;

// tag-burn_drive_info
// file test/../libburn/libburn.h line 583
struct burn_drive_info;

// tag-burn_drive_status
// file libburn/libburn.h line 289
enum burn_drive_status { BURN_DRIVE_IDLE=0, BURN_DRIVE_SPAWNING=1, BURN_DRIVE_READING=2, BURN_DRIVE_WRITING=3, BURN_DRIVE_WRITING_LEADIN=4, BURN_DRIVE_WRITING_LEADOUT=5, BURN_DRIVE_ERASING=6, BURN_DRIVE_GRABBING=7, BURN_DRIVE_WRITING_PREGAP=8, BURN_DRIVE_CLOSING_TRACK=9, BURN_DRIVE_CLOSING_SESSION=10, BURN_DRIVE_FORMATTING=11, BURN_DRIVE_READING_SYNC=12, BURN_DRIVE_WRITING_SYNC=13 };

// tag-burn_feature_descr
// file libburn/transport.h line 145
struct burn_feature_descr;

// tag-burn_format_descr
// file libburn/transport.h line 130
struct burn_format_descr;

// tag-burn_multi_caps
// file test/../libburn/libburn.h line 3448
struct burn_multi_caps;

// tag-burn_pack_cursor
// file libburn/cdtext.c line 33
struct burn_pack_cursor;

// tag-burn_progress
// file libburn/libburn.h line 667
struct burn_progress;

// tag-burn_read_opts
// file libburn/libburn.h line 1668
struct burn_read_opts;

// tag-burn_scsi_inquiry_data
// file libburn/transport.h line 74
struct burn_scsi_inquiry_data;

// tag-burn_session
// file libburn/libburn.h line 57
struct burn_session;

// tag-burn_source
// file libburn/libburn.h line 460
struct burn_source;

// tag-burn_source_fifo
// file libburn/file.h line 24
struct burn_source_fifo;

// tag-burn_source_file
// file libburn/file.h line 11
struct burn_source_file;

// tag-burn_source_offst
// file libburn/file.h line 78
struct burn_source_offst;

// tag-burn_source_status
// file libburn/libburn.h line 277
enum burn_source_status { BURN_SOURCE_OK=0, BURN_SOURCE_EOF=1, BURN_SOURCE_FAILED=2 };

// tag-burn_speed_descriptor
// file test/../libburn/libburn.h line 721
struct burn_speed_descriptor;

// tag-burn_toc_entry
// file test/../libburn/libburn.h line 347
struct burn_toc_entry;

// tag-burn_track
// file libburn/libburn.h line 60
struct burn_track;

// tag-burn_write_opts
// file libburn/libburn.h line 64
struct burn_write_opts;

// tag-burn_write_types
// file test/../libburn/libburn.h line 134
enum burn_write_types { BURN_WRITE_PACKET=0, BURN_WRITE_TAO=1, BURN_WRITE_SAO=2, BURN_WRITE_RAW=3, BURN_WRITE_NONE=4 };

// tag-cd_mid_record
// file libburn/util.c line 42
struct cd_mid_record;

// tag-command
// file libburn/transport.h line 57
struct command;

// tag-cue_sheet
// file libburn/transport.h line 31
struct cue_sheet;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-dvd_mid_record
// file libburn/util.c line 141
struct dvd_mid_record;

// tag-erase_opts
// file libburn/async.c line 74
struct erase_opts;

// tag-fifo_opts
// file libburn/async.c line 95
struct fifo_opts;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-format_opts
// file libburn/async.c line 81
struct format_opts;

// tag-hd_driveid
// file /usr/include/linux/hdreg.h line 385
struct hd_driveid;

// tag-isrc
// file libburn/structure.h line 10
struct isrc;

// tag-libdax_audioxtr
// file libburn/libdax_audioxtr.h line 30
struct libdax_audioxtr;

// tag-libdax_msgs
// file libburn/libdax_msgs.h line 44
struct libdax_msgs;

// tag-libdax_msgs_item
// file libburn/libdax_msgs.h line 22
struct libdax_msgs_item;

// tag-params
// file libburn/transport.h line 37
struct params;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-response
// file libburn/spc.h line 59
enum response { RETRY=0, FAIL=1, GO_ON=2 };

// tag-scan_opts
// file libburn/async.c line 66
struct scan_opts;

// tag-scsi_mode_data
// file libburn/transport.h line 90
struct scsi_mode_data;

// tag-sg_io_hdr
// file /usr/include/scsi/sg.h line 44
struct sg_io_hdr;

// tag-sg_scsi_id
// file /usr/include/scsi/sg.h line 102
struct sg_scsi_id;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statvfs
// file /usr/include/x86_64-linux-gnu/bits/statvfs.h line 29
struct statvfs;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-w_list
// file libburn/async.c line 110
struct w_list;

// tag-w_list_data
// file libburn/async.c line 101
union w_list_data;

// tag-write_opts
// file libburn/async.c line 88
struct write_opts;

#ifndef NULL
#define NULL ((void*)0)
#endif

// Cleanup_handler_exit
// file libburn/cleanup.c line 90
static signed int Cleanup_handler_exit(signed int exit_value, signed int signum, signed int flag);
// Cleanup_handler_generic
// file libburn/cleanup.c line 121
static void Cleanup_handler_generic(signed int signum);
// Cleanup_set_handlers
// file libburn/cleanup.c line 146
signed int Cleanup_set_handlers(void *handle, signed int (*handler)(void *, signed int, signed int), signed int flag);
// Cleanup_set_handlers::1::sig_handler$object
//
void sig_handler$object(signed int);
// Cleanup_set_handlers::handler$object
//
signed int handler$object(void *, signed int, signed int);
// Cleanup_signo_to_name
// file libburn/cleanup.c line 136
static char * Cleanup_signo_to_name(signed int signo);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __isoc99_sscanf
// file /usr/include/stdio.h line 448
extern signed int __isoc99_sscanf(const char *, const char *, ...);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_catalog_cue
// file libburn/write.c line 420
static signed int add_catalog_cue(struct cue_sheet *sheet, unsigned char *catalog);
// add_cue
// file libburn/write.c line 394
static signed int add_cue(struct cue_sheet *sheet, unsigned char ctladr, unsigned char tno, unsigned char indx, unsigned char form, unsigned char scms, signed int lba);
// add_isrc_cue
// file libburn/write.c line 438
static signed int add_isrc_cue(struct cue_sheet *sheet, unsigned char ctladr, signed int tno, struct isrc *isrc);
// add_proc_info_drives
// file libburn/sg-linux.c line 1414
static signed int add_proc_info_drives(signed int flag);
// add_worker
// file libburn/async.c line 136
static void add_worker(signed int w_type, struct burn_drive *d, void * (*f)(void *), union w_list_data *data);
// add_worker::f$object
//
void * f$object(void *);
// alarm
// file /usr/include/unistd.h line 435
extern unsigned int alarm(unsigned int);
// ata_enumerate
// file libburn/sg-linux.c line 1125
static void ata_enumerate(void);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bitcount
// file libburn/read.c line 193
static signed int bitcount(unsigned char *data, signed int n);
// burn__split_path
// file libburn/drive.c line 3115
static signed int burn__split_path(char *adr, char **dpt, char **npt);
// burn_abort
// file libburn/drive.c line 2459
signed int burn_abort(signed int patience, signed int (*pacifier_func)(void *, signed int, signed int), void *handle);
// burn_abort::pacifier_func$object
//
signed int pacifier_func$object(void *, signed int, signed int);
// burn_abort_5
// file libburn/drive.c line 2350
signed int burn_abort_5(signed int patience, signed int (*pacifier_func)(void *, signed int, signed int), void *handle, signed int elapsed, signed int flag);
// burn_abort_5::pacifier_func$object
//
signed int pacifier_func$object(void *, signed int, signed int);
// burn_abort_exit
// file libburn/init.c line 386
signed int burn_abort_exit(signed int value);
// burn_abort_pacifier
// file libburn/drive.c line 2334
signed int burn_abort_pacifier(void *handle, signed int patience, signed int elapsed);
// burn_alloc_mem
// file libburn/init.h line 38
void * burn_alloc_mem(unsigned long int size, unsigned long int count, signed int flag);
// burn_allow_drive_role_4
// file libburn/init.c line 646
void burn_allow_drive_role_4(signed int allowed);
// burn_allow_untested_profiles
// file libburn/init.c line 619
void burn_allow_untested_profiles(signed int yes);
// burn_builtin_abort_handler
// file libburn/init.c line 399
signed int burn_builtin_abort_handler(void *handle, signed int signum, signed int flag);
// burn_cdtext_check_blockno
// file libburn/structure.c line 1003
static signed int burn_cdtext_check_blockno(signed int block);
// burn_cdtext_crc_mismatches
// file libburn/cdtext.c line 103
signed int burn_cdtext_crc_mismatches(unsigned char *packs, signed int num_packs, signed int flag);
// burn_cdtext_create
// file libburn/structure.c line 891
struct burn_cdtext * burn_cdtext_create(void);
// burn_cdtext_free
// file libburn/structure.c line 907
void burn_cdtext_free(struct burn_cdtext **cdtext);
// burn_cdtext_from_packfile
// file libburn/cdtext.c line 1077
signed int burn_cdtext_from_packfile(char *path, unsigned char **text_packs, signed int *num_packs, signed int flag);
// burn_cdtext_from_session
// file libburn/cdtext.c line 359
signed int burn_cdtext_from_session(struct burn_session *s, unsigned char **text_packs, signed int *num_packs, signed int flag);
// burn_cdtext_get
// file libburn/structure.c line 983
static signed int burn_cdtext_get(struct burn_cdtext *t, signed int pack_type, char *pack_type_name, unsigned char **payload, signed int *length, signed int flag);
// burn_cdtext_name_to_type
// file libburn/structure.c line 922
static signed int burn_cdtext_name_to_type(char *pack_type_name);
// burn_cdtext_set
// file libburn/structure.c line 946
static signed int burn_cdtext_set(struct burn_cdtext **cdtext, signed int pack_type, char *pack_type_name, unsigned char *payload, signed int length, signed int flag);
// burn_create_bl_size_packs
// file libburn/cdtext.c line 192
static signed int burn_create_bl_size_packs(signed int block, unsigned char *char_codes, unsigned char *copyrights, unsigned char *languages, signed int num_tracks, struct burn_pack_cursor *crs, signed int flag);
// burn_create_new_pack
// file libburn/cdtext.c line 45
signed int burn_create_new_pack(signed int pack_type, signed int track_no, signed int double_byte, signed int block, signed int char_pos, struct burn_pack_cursor *crs, signed int flag);
// burn_create_text_packs
// file libburn/write.c line 909
static signed int burn_create_text_packs(struct burn_write_opts *o, struct burn_session *s, signed int flag);
// burn_create_toc_entries
// file libburn/write.c line 465
struct cue_sheet * burn_create_toc_entries(struct burn_write_opts *o, struct burn_session *session, signed int nwa);
// burn_create_tybl_packs
// file libburn/cdtext.c line 159
static signed int burn_create_tybl_packs(unsigned char *payload, signed int length, signed int track_no, signed int pack_type, signed int block, struct burn_pack_cursor *crs, signed int flag);
// burn_create_tybl_s_packs
// file libburn/cdtext.c line 313
static signed int burn_create_tybl_s_packs(struct burn_session *s, signed int pack_type, signed int block, struct burn_pack_cursor *crs, signed int flag);
// burn_create_tybl_t_packs
// file libburn/cdtext.c line 245
static signed int burn_create_tybl_t_packs(struct burn_track *t, signed int track_no, signed int pack_type, signed int block, struct burn_pack_cursor *crs, signed int flag);
// burn_decide_cdtext_tab
// file libburn/cdtext.c line 287
static signed int burn_decide_cdtext_tab(signed int block, signed int pack_type, struct burn_cdtext *cdt_curr, struct burn_cdtext *cdt_prev, signed int flag);
// burn_disc_add_session
// file libburn/libburn.h line 1953
signed int burn_disc_add_session(struct burn_disc *d, struct burn_session *s, unsigned int pos);
// burn_disc_available_space
// file test/../libburn/libburn.h line 1537
signed long int burn_disc_available_space(struct burn_drive *d, struct burn_write_opts *o);
// burn_disc_cd_toc_extensions
// file libburn/structure.h line 177
signed int burn_disc_cd_toc_extensions(struct burn_drive *drive, signed int flag);
// burn_disc_close_damaged
// file libburn/write.c line 3334
signed int burn_disc_close_damaged(struct burn_write_opts *o, signed int flag);
// burn_disc_close_session_dvd_minus_r
// file libburn/write.c line 2040
signed int burn_disc_close_session_dvd_minus_r(struct burn_write_opts *o);
// burn_disc_close_session_dvd_minus_rw
// file libburn/write.c line 2021
signed int burn_disc_close_session_dvd_minus_rw(struct burn_write_opts *o, struct burn_session *s);
// burn_disc_close_session_dvd_plus_rw
// file libburn/write.c line 2001
signed int burn_disc_close_session_dvd_plus_rw(struct burn_write_opts *o, struct burn_session *s);
// burn_disc_close_track_dvd_minus_r
// file libburn/write.c line 1664
signed int burn_disc_close_track_dvd_minus_r(struct burn_write_opts *o, signed int tnum);
// burn_disc_close_track_dvd_plus_r
// file libburn/write.c line 1720
signed int burn_disc_close_track_dvd_plus_r(struct burn_write_opts *o, signed int tnum, signed int is_last_track);
// burn_disc_create
// file libburn/libburn.h line 1929
struct burn_disc * burn_disc_create(void);
// burn_disc_erasable
// file test/../libburn/libburn.h line 1631
signed int burn_disc_erasable(struct burn_drive *d);
// burn_disc_erase
// file libburn/async.c line 352
void burn_disc_erase(struct burn_drive *drive, signed int fast);
// burn_disc_erase_sync
// file libburn/drive.h line 68
void burn_disc_erase_sync(struct burn_drive *d, signed int fast);
// burn_disc_finalize_dvd_plus_r
// file libburn/write.c line 1688
signed int burn_disc_finalize_dvd_plus_r(struct burn_write_opts *o);
// burn_disc_format
// file libburn/async.c line 453
void burn_disc_format(struct burn_drive *drive, signed long int size, signed int flag);
// burn_disc_format_sync
// file libburn/drive.h line 107
void burn_disc_format_sync(struct burn_drive *d, signed long int size, signed int flag);
// burn_disc_free
// file test/../libburn/libburn.h line 1934
void burn_disc_free(struct burn_disc *d);
// burn_disc_free_multi_caps
// file test/../libburn/libburn.h line 3552
signed int burn_disc_free_multi_caps(struct burn_multi_caps **caps);
// burn_disc_get_bd_spare_info
// file libburn/drive.c line 3383
signed int burn_disc_get_bd_spare_info(struct burn_drive *d, signed int *alloc_blocks, signed int *free_blocks, signed int flag);
// burn_disc_get_cd_info
// file libburn/drive.c line 3360
signed int burn_disc_get_cd_info(struct burn_drive *d, char *disc_type, unsigned int *disc_id, char *bar_code, signed int *app_code, signed int *valid);
// burn_disc_get_format_descr
// file test/../libburn/libburn.h line 1781
signed int burn_disc_get_format_descr(struct burn_drive *d, signed int index, signed int *type, signed long int *size, unsigned int *tdp);
// burn_disc_get_formats
// file test/../libburn/libburn.h line 1763
signed int burn_disc_get_formats(struct burn_drive *d, signed int *status, signed long int *size, unsigned int *bl_sas, signed int *num_formats);
// burn_disc_get_incomplete_sessions
// file libburn/structure.c line 721
signed int burn_disc_get_incomplete_sessions(struct burn_disc *d);
// burn_disc_get_leadin_text
// file libburn/drive.c line 3423
signed int burn_disc_get_leadin_text(struct burn_drive *d, unsigned char **text_packs, signed int *num_packs, signed int flag);
// burn_disc_get_media_id
// file libburn/drive.c line 3331
signed int burn_disc_get_media_id(struct burn_drive *d, char **product_id, char **media_code1, char **media_code2, char **book_type, signed int flag);
// burn_disc_get_msc1
// file test/../libburn/libburn.h line 1517
signed int burn_disc_get_msc1(struct burn_drive *d, signed int *start);
// burn_disc_get_multi_caps
// file test/../libburn/libburn.h line 3543
signed int burn_disc_get_multi_caps(struct burn_drive *d, enum burn_write_types wt, struct burn_multi_caps **caps, signed int flag);
// burn_disc_get_phys_format_info
// file libburn/drive.c line 3397
signed int burn_disc_get_phys_format_info(struct burn_drive *d, signed int *disk_category, char **book_name, signed int *part_version, signed int *num_layers, signed int *num_blocks, signed int flag);
// burn_disc_get_profile
// file test/../libburn/libburn.h line 1572
signed int burn_disc_get_profile(struct burn_drive *d, signed int *pno, char *name);
// burn_disc_get_sectors
// file libburn/structure.c line 676
signed int burn_disc_get_sectors(struct burn_disc *d);
// burn_disc_get_sessions
// file test/../libburn/libburn.h line 3578
struct burn_session ** burn_disc_get_sessions(struct burn_disc *d, signed int *num);
// burn_disc_get_status
// file test/../libburn/libburn.h line 1228
enum burn_disc_status burn_disc_get_status(struct burn_drive *d);
// burn_disc_get_write_mode_demands
// file libburn/drive.c line 3044
signed int burn_disc_get_write_mode_demands(struct burn_disc *disc, struct burn_write_opts *opts, struct burn_disc_mode_demands *result, signed int flag);
// burn_disc_init_track_status
// file libburn/write.c line 1073
signed int burn_disc_init_track_status(struct burn_write_opts *o, struct burn_session *s, struct burn_track *t, signed int tnum, signed int sectors);
// burn_disc_init_write_status
// file libburn/write.c line 1323
signed int burn_disc_init_write_status(struct burn_write_opts *o, struct burn_disc *disc);
// burn_disc_next_track_is_damaged
// file libburn/drive.c line 3414
signed int burn_disc_next_track_is_damaged(struct burn_drive *d, signed int flag);
// burn_disc_open_track_dvd_minus_r
// file libburn/write.c line 1539
signed int burn_disc_open_track_dvd_minus_r(struct burn_write_opts *o, struct burn_session *s, signed int tnum);
// burn_disc_open_track_dvd_plus_r
// file libburn/write.c line 1600
signed int burn_disc_open_track_dvd_plus_r(struct burn_write_opts *o, struct burn_session *s, signed int tnum);
// burn_disc_pretend_blank
// file libburn/drive.c line 2487
signed int burn_disc_pretend_blank(struct burn_drive *d);
// burn_disc_pretend_full
// file libburn/drive.c line 2499
signed int burn_disc_pretend_full(struct burn_drive *d);
// burn_disc_pretend_full_uncond
// file libburn/drive.c line 2511
signed int burn_disc_pretend_full_uncond(struct burn_drive *d);
// burn_disc_read
// file libburn/read.c line 55
void burn_disc_read(struct burn_drive *d, struct burn_read_opts *o);
// burn_disc_read_atip
// file test/../libburn/libburn.h line 1313
signed int burn_disc_read_atip(struct burn_drive *d);
// burn_disc_remove_session
// file libburn/libburn.h line 1960
signed int burn_disc_remove_session(struct burn_disc *d, struct burn_session *s);
// burn_disc_setup_dvd_minus_r
// file libburn/write.c line 2258
signed int burn_disc_setup_dvd_minus_r(struct burn_write_opts *o, struct burn_disc *disc);
// burn_disc_setup_dvd_minus_rw
// file libburn/write.c line 2204
signed int burn_disc_setup_dvd_minus_rw(struct burn_write_opts *o, struct burn_disc *disc);
// burn_disc_setup_dvd_plus_r
// file libburn/write.c line 2271
signed int burn_disc_setup_dvd_plus_r(struct burn_write_opts *o, struct burn_disc *disc);
// burn_disc_setup_dvd_plus_rw
// file libburn/write.c line 2179
signed int burn_disc_setup_dvd_plus_rw(struct burn_write_opts *o, struct burn_disc *disc);
// burn_disc_track_lba_nwa
// file test/../libburn/libburn.h line 1466
signed int burn_disc_track_lba_nwa(struct burn_drive *d, struct burn_write_opts *o, signed int trackno, signed int *lba, signed int *nwa);
// burn_disc_write
// file libburn/async.c line 595
void burn_disc_write(struct burn_write_opts *opts, struct burn_disc *disc);
// burn_disc_write_is_ok
// file libburn/write.c line 1299
signed int burn_disc_write_is_ok(struct burn_write_opts *o, struct burn_disc *disc, signed int flag);
// burn_disc_write_sync
// file libburn/write.h line 27
void burn_disc_write_sync(struct burn_write_opts *o, struct burn_disc *disc);
// burn_drive__fd_from_special_adr
// file libburn/drive.c line 327
signed int burn_drive__fd_from_special_adr(char *adr);
// burn_drive__is_rdwr
// file libburn/drive.c line 346
static signed int burn_drive__is_rdwr(char *fname, signed int *stat_ret, struct stat *stbuf_ret, signed long int *read_size_ret, signed int flag);
// burn_drive_add_whitelist
// file libburn/drive.c line 1604
signed int burn_drive_add_whitelist(char *device_address);
// burn_drive_adr_debug_msg
// file libburn/drive.c line 1895
signed int burn_drive_adr_debug_msg(char *fmt, char *arg);
// burn_drive_cancel
// file libburn/drive.c line 1161
void burn_drive_cancel(struct burn_drive *d);
// burn_drive_clear_whitelist
// file libburn/drive.c line 1619
void burn_drive_clear_whitelist(void);
// burn_drive_convert_fs_adr
// file test/../libburn/libburn.h line 1083
signed int burn_drive_convert_fs_adr(char *path, char *adr);
// burn_drive_convert_fs_adr_sub
// file libburn/drive.c line 2193
signed int burn_drive_convert_fs_adr_sub(char *path, char *adr, signed int *rec_count);
// burn_drive_convert_scsi_adr
// file libburn/drive.c line 2113
signed int burn_drive_convert_scsi_adr(signed int bus_no, signed int host_no, signed int channel_no, signed int target_no, signed int lun_no, char *adr);
// burn_drive_count
// file libburn/drive.c line 233
unsigned int burn_drive_count(void);
// burn_drive_d_get_adr
// file libburn/drive.c line 1919
signed int burn_drive_d_get_adr(struct burn_drive *d, char *adr);
// burn_drive_equals_adr
// file libburn/drive.c line 3133
signed int burn_drive_equals_adr(struct burn_drive *d1, char *adr2_in, signed int role2);
// burn_drive_extract_audio
// file libburn/file.c line 940
signed int burn_drive_extract_audio(struct burn_drive *drive, signed int start_sector, signed int sector_count, char *target_path, signed int flag);
// burn_drive_extract_audio_track
// file libburn/file.c line 1060
signed int burn_drive_extract_audio_track(struct burn_drive *drive, struct burn_track *track, char *target_path, signed int flag);
// burn_drive_find_by_thread_pid
// file libburn/drive.c line 3288
signed int burn_drive_find_by_thread_pid(struct burn_drive **d, signed int pid, unsigned long int tid);
// burn_drive_find_devno
// file libburn/drive.c line 2032
signed int burn_drive_find_devno(unsigned long int devno, char *adr);
// burn_drive_find_scsi_equiv
// file libburn/drive.c line 2166
signed int burn_drive_find_scsi_equiv(char *path, char *adr);
// burn_drive_finish_enum
// file libburn/drive.c line 598
struct burn_drive * burn_drive_finish_enum(struct burn_drive *d);
// burn_drive_force_idle
// file libburn/drive.c line 167
signed int burn_drive_force_idle(struct burn_drive *d);
// burn_drive_forget
// file libburn/drive.c line 1429
signed int burn_drive_forget(struct burn_drive *d, signed int force);
// burn_drive_free
// file libburn/drive.c line 131
void burn_drive_free(struct burn_drive *d);
// burn_drive_free_all
// file libburn/drive.c line 145
void burn_drive_free_all(void);
// burn_drive_free_speedlist
// file test/../libburn/libburn.h line 3441
signed int burn_drive_free_speedlist(struct burn_speed_descriptor **speed_list);
// burn_drive_free_subs
// file libburn/drive.c line 101
void burn_drive_free_subs(struct burn_drive *d);
// burn_drive_get_adr
// file test/../libburn/libburn.h line 1059
signed int burn_drive_get_adr(struct burn_drive_info *drive_info, char *adr);
// burn_drive_get_all_profiles
// file test/../libburn/libburn.h line 3356
signed int burn_drive_get_all_profiles(struct burn_drive *d, signed int *num_profiles, signed int *profiles, char *is_current);
// burn_drive_get_best_speed
// file libburn/drive.c line 2793
signed int burn_drive_get_best_speed(struct burn_drive *d, signed int speed_goal, struct burn_speed_descriptor **best_descr, signed int flag);
// burn_drive_get_disc
// file test/../libburn/libburn.h line 2642
struct burn_disc * burn_drive_get_disc(struct burn_drive *d);
// burn_drive_get_drive_role
// file libburn/drive.c line 3105
signed int burn_drive_get_drive_role(struct burn_drive *d);
// burn_drive_get_media_sno
// file libburn/drive.c line 3532
signed int burn_drive_get_media_sno(struct burn_drive *d, char **sno, signed int *sno_len);
// burn_drive_get_min_write_speed
// file test/../libburn/libburn.h line 3387
signed int burn_drive_get_min_write_speed(struct burn_drive *d);
// burn_drive_get_read_speed
// file libburn/drive.c line 1579
signed int burn_drive_get_read_speed(struct burn_drive *d);
// burn_drive_get_serial_no
// file libburn/drive.c line 3511
signed int burn_drive_get_serial_no(struct burn_drive *d, char **sno, signed int *sno_len);
// burn_drive_get_speedlist
// file test/../libburn/libburn.h line 3410
signed int burn_drive_get_speedlist(struct burn_drive *d, struct burn_speed_descriptor **speed_list);
// burn_drive_get_start_end_lba
// file libburn/drive.c line 2475
signed int burn_drive_get_start_end_lba(struct burn_drive *d, signed int *start_lba, signed int *end_lba, signed int flag);
// burn_drive_get_status
// file libburn/drive.c line 1111
enum burn_drive_status burn_drive_get_status(struct burn_drive *d, struct burn_progress *p);
// burn_drive_get_write_speed
// file test/../libburn/libburn.h line 3376
signed int burn_drive_get_write_speed(struct burn_drive *d);
// burn_drive_grab
// file test/../libburn/libburn.h line 1156
signed int burn_drive_grab(struct burn_drive *d, signed int le);
// burn_drive_grab_dummy
// file libburn/drive.c line 1685
signed int burn_drive_grab_dummy(struct burn_drive_info **drive_infos, char *fname);
// burn_drive_grab_stdio
// file libburn/drive.c line 402
signed int burn_drive_grab_stdio(struct burn_drive *d, signed int flag);
// burn_drive_has_feature
// file libburn/drive.c line 3494
signed int burn_drive_has_feature(struct burn_drive *d, signed int feature_code, struct burn_feature_descr **descr, signed int flag);
// burn_drive_info_forget
// file test/../libburn/libburn.h line 1025
signed int burn_drive_info_forget(struct burn_drive_info *info, signed int force);
// burn_drive_info_free
// file libburn/drive.c line 1462
void burn_drive_info_free(struct burn_drive_info *drive_infos);
// burn_drive_inquire_media
// file libburn/drive.c line 272
signed int burn_drive_inquire_media(struct burn_drive *d);
// burn_drive_is_banned
// file libburn/drive.c line 1627
signed int burn_drive_is_banned(char *device_address);
// burn_drive_is_enumerable_adr
// file libburn/drive.c line 1947
signed int burn_drive_is_enumerable_adr(char *adr);
// burn_drive_is_listed
// file libburn/drive.c line 240
signed int burn_drive_is_listed(char *path, struct burn_drive **found, signed int flag);
// burn_drive_is_occupied
// file libburn/drive.c line 193
signed int burn_drive_is_occupied(struct burn_drive *d);
// burn_drive_is_open
// file libburn/drive.c line 157
signed int burn_drive_is_open(struct burn_drive *d);
// burn_drive_is_released
// file libburn/drive.c line 175
signed int burn_drive_is_released(struct burn_drive *d);
// burn_drive_leave_locked
// file libburn/drive.c line 788
signed int burn_drive_leave_locked(struct burn_drive *d, signed int flag);
// burn_drive_mark_unready
// file libburn/drive.c line 642
signed int burn_drive_mark_unready(struct burn_drive *d, signed int flag);
// burn_drive_obtain_scsi_adr
// file libburn/drive.c line 2074
signed int burn_drive_obtain_scsi_adr(char *path, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no);
// burn_drive_probe_cd_write_modes
// file libburn/drive.c line 1306
signed int burn_drive_probe_cd_write_modes(struct burn_drive_info *dinfo);
// burn_drive_re_assess
// file libburn/drive.c line 756
signed int burn_drive_re_assess(struct burn_drive *d, signed int flag);
// burn_drive_register
// file libburn/drive.c line 529
struct burn_drive * burn_drive_register(struct burn_drive *d);
// burn_drive_release
// file test/../libburn/libburn.h line 1205
void burn_drive_release(struct burn_drive *d, signed int le);
// burn_drive_release_fl
// file libburn/drive.c line 679
signed int burn_drive_release_fl(struct burn_drive *d, signed int flag);
// burn_drive_resolve_link
// file libburn/drive.c line 1959
signed int burn_drive_resolve_link(char *path, char *adr, signed int *recursion_count, signed int flag);
// burn_drive_scan
// file test/../libburn/libburn.h line 1007
signed int burn_drive_scan(struct burn_drive_info **drives, unsigned int *n_drives);
// burn_drive_scan_and_grab
// file test/../libburn/libburn.h line 964
signed int burn_drive_scan_and_grab(struct burn_drive_info **drive_infos, char *adr, signed int load);
// burn_drive_scan_sync
// file libburn/drive.h line 65
signed int burn_drive_scan_sync(struct burn_drive_info **drives, unsigned int *n_drives, signed int flag);
// burn_drive_send_default_page_05
// file libburn/drive.c line 299
signed int burn_drive_send_default_page_05(struct burn_drive *d, signed int flag);
// burn_drive_set_buffer_waiting
// file libburn/drive.c line 1540
signed int burn_drive_set_buffer_waiting(struct burn_drive *d, signed int enable, signed int min_usec, signed int max_usec, signed int timeout_sec, signed int min_percent, signed int max_percent);
// burn_drive_set_media_capacity_remaining
// file libburn/drive.c line 3313
signed int burn_drive_set_media_capacity_remaining(struct burn_drive *d, signed long int value);
// burn_drive_set_speed
// file libburn/drive.c line 1530
void burn_drive_set_speed(struct burn_drive *d, signed int r, signed int w);
// burn_drive_set_stream_recording
// file libburn/drive.c line 1149
signed int burn_drive_set_stream_recording(struct burn_drive *d, signed int recmode, signed int start, signed int flag);
// burn_drive_snooze
// file libburn/drive.c line 735
signed int burn_drive_snooze(struct burn_drive *d, signed int flag);
// burn_drive_unregister
// file libburn/drive.c line 586
signed int burn_drive_unregister(struct burn_drive *d);
// burn_drive_was_feat21_failure
// file libburn/drive.c line 3437
signed int burn_drive_was_feat21_failure(struct burn_drive *d);
// burn_drive_whitelist_count
// file libburn/drive.c line 1640
signed int burn_drive_whitelist_count(void);
// burn_drive_whitelist_item
// file libburn/drive.c line 1645
char * burn_drive_whitelist_item(signed int idx, signed int flag);
// burn_drive_wrote_well
// file libburn/drive.c line 2685
signed int burn_drive_wrote_well(struct burn_drive *d);
// burn_drives_are_clear
// file libburn/drive.h line 55
signed int burn_drives_are_clear(signed int flag);
// burn_dvd_write_session
// file libburn/write.c line 2065
signed int burn_dvd_write_session(struct burn_write_opts *o, struct burn_session *s, signed int is_last_session);
// burn_dvd_write_sync
// file libburn/write.c line 2284
signed int burn_dvd_write_sync(struct burn_write_opts *o, struct burn_disc *disc);
// burn_dvd_write_track
// file libburn/write.c line 1876
signed int burn_dvd_write_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum, signed int is_last_track);
// burn_ecma130_scramble
// file libburn/ecma130ab.c line 693
void burn_ecma130_scramble(unsigned char *sector);
// burn_fd_source_new
// file libburn/file.c line 178
struct burn_source * burn_fd_source_new(signed int datafd, signed int subfd, signed long int size);
// burn_feature_descr_free
// file libburn/drive.c line 3476
signed int burn_feature_descr_free(struct burn_feature_descr **descr, signed int flag);
// burn_feature_descr_new
// file libburn/drive.c line 3444
signed int burn_feature_descr_new(struct burn_feature_descr **new, unsigned char *descr, signed int descr_len, signed int flag);
// burn_fifo_abort
// file libburn/async.c line 762
signed int burn_fifo_abort(struct burn_source_fifo *fs, signed int flag);
// burn_fifo_cancel
// file libburn/file.c line 490
signed int burn_fifo_cancel(struct burn_source *source);
// burn_fifo_fill
// file libburn/file.c line 755
signed int burn_fifo_fill(struct burn_source *source, signed int bufsize, signed int flag);
// burn_fifo_fill_data
// file libburn/file.c line 647
signed int burn_fifo_fill_data(struct burn_source *source, char *buf, signed int bufsize, signed int flag);
// burn_fifo_get_statistics
// file libburn/file.c line 609
void burn_fifo_get_statistics(struct burn_source *source, signed int *total_min_fill, signed int *interval_min_fill, signed int *put_counter, signed int *get_counter, signed int *empty_counter, signed int *full_counter);
// burn_fifo_inquire_status
// file libburn/file.c line 566
signed int burn_fifo_inquire_status(struct burn_source *source, signed int *size, signed int *free_bytes, char **status_text);
// burn_fifo_next_interval
// file libburn/file.c line 626
void burn_fifo_next_interval(struct burn_source *source, signed int *interval_min_fill);
// burn_fifo_peek_data
// file libburn/file.c line 747
signed int burn_fifo_peek_data(struct burn_source *source, char *buf, signed int bufsize, signed int flag);
// burn_fifo_source_new
// file libburn/file.c line 502
struct burn_source * burn_fifo_source_new(struct burn_source *inp, signed int chunksize, signed int chunks, signed int flag);
// burn_fifo_source_shoveller
// file libburn/file.h line 74
signed int burn_fifo_source_shoveller(struct burn_source *source, signed int flag);
// burn_fifo_start
// file libburn/async.c line 737
signed int burn_fifo_start(struct burn_source *source, signed int flag);
// burn_file_source_new
// file libburn/file.c line 121
struct burn_source * burn_file_source_new(const char *path, const char *subpath);
// burn_finalize_text_pack
// file libburn/cdtext.c line 135
static signed int burn_finalize_text_pack(struct burn_pack_cursor *crs, signed int flag);
// burn_finish
// file test/../libburn/libburn.h line 778
void burn_finish(void);
// burn_get_read_capacity
// file libburn/drive.c line 3323
signed int burn_get_read_capacity(struct burn_drive *d, signed int *capacity, signed int flag);
// burn_get_time
// file libburn/util.h line 20
double burn_get_time(signed int flag);
// burn_global_signal_handler$object
//
signed int burn_global_signal_handler$object(void *, signed int, signed int);
// burn_grab_prepare_sig_action
// file libburn/init.h line 59
signed int burn_grab_prepare_sig_action(signed int *signal_action_mem, signed int flag);
// burn_grab_restore_sig_action
// file libburn/init.h line 60
signed int burn_grab_restore_sig_action(signed int signal_action_mem, signed int flag);
// burn_guess_cd_manufacturer
// file libburn/util.c line 57
char * burn_guess_cd_manufacturer(signed int m_li, signed int s_li, signed int f_li, signed int m_lo, signed int s_lo, signed int f_lo, signed int flag);
// burn_guess_manufacturer
// file libburn/util.c line 149
char * burn_guess_manufacturer(signed int prf, char *media_code1, char *media_code2, signed int flag);
// burn_init_catch_on_abort
// file libburn/init.h line 35
signed int burn_init_catch_on_abort(signed int flag);
// burn_initialize
// file test/../libburn/libburn.h line 772
signed int burn_initialize(void);
// burn_int_to_lsb
// file libburn/util.h line 17
void burn_int_to_lsb(signed int val, char *target);
// burn_is_aborting
// file libburn/libburn.h line 3900
signed int burn_is_aborting(signed int flag);
// burn_lba_to_msf
// file test/../libburn/libburn.h line 1924
void burn_lba_to_msf(signed int lba, signed int *m, signed int *s, signed int *f);
// burn_list_sev_texts
// file libburn/init.c line 358
char * burn_list_sev_texts(signed int flag);
// burn_lookup_device_link
// file libburn/drive.c line 2250
signed int burn_lookup_device_link(char *dev_adr, char *link_adr, char *dir_adr, char **ranks, signed int rank_count, signed int flag);
// burn_make_input_sheet_v07t
// file libburn/cdtext.c line 1708
signed int burn_make_input_sheet_v07t(unsigned char *text_packs, signed int num_packs, signed int start_tno, signed int track_count, char **result, signed int *char_code, signed int flag);
// burn_make_v07t
// file libburn/cdtext.c line 1592
static signed int burn_make_v07t(unsigned char *text_packs, signed int num_packs, signed int first_tno, signed int track_count, char *result, signed int result_size, signed int *char_code, signed int flag);
// burn_mdata_free_subs
// file libburn/drive.c line 2766
signed int burn_mdata_free_subs(struct scsi_mode_data *m);
// burn_msf_to_lba
// file test/../libburn/libburn.h line 1916
signed int burn_msf_to_lba(signed int m, signed int s, signed int f);
// burn_msf_to_sectors
// file libburn/drive.c line 1567
signed int burn_msf_to_sectors(signed int m, signed int s, signed int f);
// burn_msgs_initialize
// file libburn/init.c line 122
signed int burn_msgs_initialize(void);
// burn_msgs_obtain
// file libburn/init.c line 267
signed int burn_msgs_obtain(char *minimum_severity, signed int *error_code, char *msg_text, signed int *os_errno, char *severity);
// burn_msgs_set_severities
// file test/../libburn/libburn.h line 3720
signed int burn_msgs_set_severities(char *queue_severity, char *print_severity, char *print_id);
// burn_msgs_submit
// file libburn/init.c line 308
signed int burn_msgs_submit(signed int error_code, char *msg_text, signed int os_errno, char *severity, struct burn_drive *d);
// burn_null_source_new
// file libburn/null.c line 23
struct burn_source * burn_null_source_new(void);
// burn_obtain_profile_name
// file test/../libburn/libburn.h line 3367
signed int burn_obtain_profile_name(signed int profile_number, char *name);
// burn_offst_source_new
// file libburn/file.c line 872
struct burn_source * burn_offst_source_new(struct burn_source *inp, struct burn_source *prev, signed long int start, signed long int size, signed int flag);
// burn_os_alloc_buffer
// file libburn/libburn.h line 2721
void * burn_os_alloc_buffer(unsigned long int amount, signed int flag);
// burn_os_free_buffer
// file libburn/libburn.h line 2731
signed int burn_os_free_buffer(void *buffer, unsigned long int amount, signed int flag);
// burn_os_is_2k_seekrw
// file libburn/sg.h line 37
signed int burn_os_is_2k_seekrw(char *path, signed int flag);
// burn_os_open_track_src
// file libburn/sg-linux.c line 2467
signed int burn_os_open_track_src(char *path, signed int open_flags, signed int flag);
// burn_os_stdio_capacity
// file libburn/sg.h line 39
signed int burn_os_stdio_capacity(char *path, signed long int write_start, signed long int *bytes);
// burn_packet_process
// file libburn/read.c line 209
void burn_packet_process(struct burn_drive *d, unsigned char *data, struct burn_read_opts *o);
// burn_precheck_write
// file libburn/libburn.h line 1816
signed int burn_precheck_write(struct burn_write_opts *o, struct burn_disc *disc, char *reasons, signed int silent);
// burn_preset_device_open
// file libburn/init.c line 204
void burn_preset_device_open(signed int exclusive, signed int blocking, signed int abort_on_busy);
// burn_printify
// file libburn/util.h line 14
char * burn_printify(char *msg);
// burn_random_access_write
// file libburn/write.c line 3180
signed int burn_random_access_write(struct burn_drive *d, signed long int byte_address, char *data, signed long int data_count, signed int flag);
// burn_read_audio
// file test/../libburn/libburn.h line 4039
signed int burn_read_audio(struct burn_drive *d, signed int sector_no, char *data, signed long int data_size, signed long int *data_count, signed int flag);
// burn_read_data
// file test/../libburn/libburn.h line 3992
signed int burn_read_data(struct burn_drive *d, signed long int byte_address, char *data, signed long int data_size, signed long int *data_count, signed int flag);
// burn_read_opts_free
// file libburn/options.c line 122
void burn_read_opts_free(struct burn_read_opts *opts);
// burn_read_opts_new
// file libburn/options.c line 102
struct burn_read_opts * burn_read_opts_new(struct burn_drive *drive);
// burn_read_opts_read_subcodes_audio
// file libburn/options.c line 554
void burn_read_opts_read_subcodes_audio(struct burn_read_opts *opts, signed int subcodes_audio);
// burn_read_opts_read_subcodes_data
// file libburn/options.c line 560
void burn_read_opts_read_subcodes_data(struct burn_read_opts *opts, signed int subcodes_data);
// burn_read_opts_report_recovered_errors
// file libburn/options.c line 572
void burn_read_opts_report_recovered_errors(struct burn_read_opts *opts, signed int report_recovered_errors);
// burn_read_opts_set_c2errors
// file libburn/options.c line 549
void burn_read_opts_set_c2errors(struct burn_read_opts *opts, signed int c2errors);
// burn_read_opts_set_hardware_error_recovery
// file libburn/options.c line 566
void burn_read_opts_set_hardware_error_recovery(struct burn_read_opts *opts, signed int hardware_error_recovery);
// burn_read_opts_set_hardware_error_retries
// file libburn/options.c line 584
void burn_read_opts_set_hardware_error_retries(struct burn_read_opts *opts, unsigned char hardware_error_retries);
// burn_read_opts_set_raw
// file libburn/options.c line 544
void burn_read_opts_set_raw(struct burn_read_opts *opts, signed int raw);
// burn_read_opts_transfer_damaged_blocks
// file libburn/options.c line 578
void burn_read_opts_transfer_damaged_blocks(struct burn_read_opts *opts, signed int transfer_damaged_blocks);
// burn_role_by_access
// file libburn/drive.c line 1653
static signed int burn_role_by_access(char *fname, signed int flag);
// burn_rspc_div_3
// file libburn/ecma130ab.c line 544
static unsigned char burn_rspc_div_3(unsigned char a);
// burn_rspc_mult
// file libburn/ecma130ab.c line 527
static unsigned char burn_rspc_mult(unsigned char a, unsigned char b);
// burn_rspc_p0p1
// file libburn/ecma130ab.c line 552
static void burn_rspc_p0p1(unsigned char *sector, signed int col, unsigned char *p0_lsb, unsigned char *p0_msb, unsigned char *p1_lsb, unsigned char *p1_msb);
// burn_rspc_parity_p
// file libburn/ecma130ab.c line 591
void burn_rspc_parity_p(unsigned char *sector);
// burn_rspc_parity_q
// file libburn/ecma130ab.c line 659
void burn_rspc_parity_q(unsigned char *sector);
// burn_rspc_q0q1
// file libburn/ecma130ab.c line 618
static void burn_rspc_q0q1(unsigned char *sector, signed int diag, unsigned char *q0_lsb, unsigned char *q0_msb, unsigned char *q1_lsb, unsigned char *q1_msb);
// burn_scsi_setup_drive
// file libburn/spc.h line 55
signed int burn_scsi_setup_drive(struct burn_drive *d, signed int bus_no, signed int host_no, signed int channel_no, signed int target_no, signed int lun_no, signed int flag);
// burn_scsi_transport_id
// file libburn/init.c line 194
char * burn_scsi_transport_id(signed int flag);
// burn_sector_length
// file libburn/write.h line 20
signed int burn_sector_length(signed int tracktype);
// burn_sector_length_read
// file libburn/read.c line 175
signed int burn_sector_length_read(struct burn_drive *d, struct burn_read_opts *o);
// burn_sectors_to_msf
// file libburn/drive.c line 1572
void burn_sectors_to_msf(signed int sectors, signed int *m, signed int *s, signed int *f);
// burn_session_add_track
// file libburn/libburn.h line 2027
signed int burn_session_add_track(struct burn_session *s, struct burn_track *t, unsigned int pos);
// burn_session_by_cue_file
// file libburn/structure.c line 1987
signed int burn_session_by_cue_file(struct burn_session *session, char *path, signed int fifo_size, struct burn_source **fifo, unsigned char **text_packs, signed int *num_packs, signed int flag);
// burn_session_create
// file libburn/libburn.h line 1939
struct burn_session * burn_session_create(void);
// burn_session_dispose_cdtext
// file libburn/structure.c line 1145
signed int burn_session_dispose_cdtext(struct burn_session *s, signed int block);
// burn_session_free
// file libburn/libburn.h line 1944
void burn_session_free(struct burn_session *s);
// burn_session_get_cdtext
// file libburn/structure.c line 1089
signed int burn_session_get_cdtext(struct burn_session *s, signed int block, signed int pack_type, char *pack_type_name, unsigned char **payload, signed int *length, signed int flag);
// burn_session_get_cdtext_par
// file libburn/structure.c line 1129
signed int burn_session_get_cdtext_par(struct burn_session *s, signed int *char_codes, signed int *copyrights, signed int *block_languages, signed int flag);
// burn_session_get_hidefirst
// file libburn/structure.c line 746
signed int burn_session_get_hidefirst(struct burn_session *session);
// burn_session_get_leadout_entry
// file test/../libburn/libburn.h line 3565
void burn_session_get_leadout_entry(struct burn_session *s, struct burn_toc_entry *entry);
// burn_session_get_sectors
// file libburn/structure.c line 666
signed int burn_session_get_sectors(struct burn_session *s);
// burn_session_get_start_tno
// file libburn/structure.c line 885
signed int burn_session_get_start_tno(struct burn_session *session, signed int flag);
// burn_session_get_tracks
// file test/../libburn/libburn.h line 3600
struct burn_track ** burn_session_get_tracks(struct burn_session *s, signed int *num);
// burn_session_hide_first_track
// file libburn/structure.c line 120
void burn_session_hide_first_track(struct burn_session *s, signed int onoff);
// burn_session_input_sheet_v07t
// file libburn/cdtext.c line 669
signed int burn_session_input_sheet_v07t(struct burn_session *session, char *path, signed int block, signed int flag);
// burn_session_remove_track
// file libburn/structure.c line 256
signed int burn_session_remove_track(struct burn_session *s, struct burn_track *t);
// burn_session_set_cdtext
// file libburn/libburn.h line 2226
signed int burn_session_set_cdtext(struct burn_session *s, signed int block, signed int pack_type, char *pack_type_name, unsigned char *payload, signed int length, signed int flag);
// burn_session_set_cdtext_par
// file libburn/libburn.h line 2098
signed int burn_session_set_cdtext_par(struct burn_session *s, signed int *char_codes, signed int *copyrights, signed int *block_languages, signed int flag);
// burn_session_set_start_tno
// file libburn/libburn.h line 2050
signed int burn_session_set_start_tno(struct burn_session *session, signed int tno, signed int flag);
// burn_set_messenger
// file libburn/init.c line 626
signed int burn_set_messenger(void *messenger);
// burn_set_scsi_logging
// file libburn/init.c line 639
void burn_set_scsi_logging(signed int flag);
// burn_set_signal_handling
// file test/../libburn/libburn.h line 3887
void burn_set_signal_handling(void *handle, signed int (*handler)(void *, signed int, signed int), signed int mode);
// burn_set_signal_handling::handler$object
//
signed int handler$object(void *, signed int, signed int);
// burn_set_verbosity
// file libburn/debug.c line 23
void burn_set_verbosity(signed int v);
// burn_setup_drive
// file libburn/drive.c line 76
signed int burn_setup_drive(struct burn_drive *d, char *fname);
// burn_sev_to_text
// file libburn/init.c line 348
signed int burn_sev_to_text(signed int severity_number, char **severity_name, signed int flag);
// burn_sfile_fgets
// file libburn/util.h line 13
char * burn_sfile_fgets(char *line, signed int maxl, struct _IO_FILE *fp);
// burn_source_cancel
// file libburn/source.h line 8
signed int burn_source_cancel(struct burn_source *src);
// burn_source_free
// file libburn/libburn.h line 2671
void burn_source_free(struct burn_source *src);
// burn_source_new
// file libburn/source.h line 6
struct burn_source * burn_source_new(void);
// burn_source_read
// file libburn/source.h line 10
signed int burn_source_read(struct burn_source *src, unsigned char *buffer, signed int size);
// burn_sparse_file_addsize
// file libburn/util.h line 23
signed long int burn_sparse_file_addsize(signed long int write_start, struct stat *stbuf);
// burn_speed_descriptor_copy
// file libburn/drive.c line 2749
signed int burn_speed_descriptor_copy(struct burn_speed_descriptor *from, struct burn_speed_descriptor *to, signed int flag);
// burn_speed_descriptor_destroy
// file libburn/drive.c line 2725
signed int burn_speed_descriptor_destroy(struct burn_speed_descriptor **s, signed int flag);
// burn_speed_descriptor_new
// file libburn/drive.c line 2692
signed int burn_speed_descriptor_new(struct burn_speed_descriptor **s, struct burn_speed_descriptor *prev, struct burn_speed_descriptor *next, signed int flag);
// burn_stdio_mmc_dummy_write
// file libburn/write.c line 2672
signed int burn_stdio_mmc_dummy_write(struct burn_drive *d, signed int start, struct buffer *buf);
// burn_stdio_mmc_sync_cache
// file libburn/write.c line 2738
void burn_stdio_mmc_sync_cache(struct burn_drive *d);
// burn_stdio_mmc_write
// file libburn/write.c line 2629
signed int burn_stdio_mmc_write(struct burn_drive *d, signed int start, struct buffer *buf);
// burn_stdio_open_write
// file libburn/write.c line 2499
signed int burn_stdio_open_write(struct burn_drive *d, signed long int start_byte, signed int sector_size, signed int flag);
// burn_stdio_read
// file libburn/read.c line 344
signed int burn_stdio_read(signed int fd, char *buf, signed int bufsize, struct burn_drive *d, signed int flag);
// burn_stdio_read_source
// file libburn/write.c line 2563
signed int burn_stdio_read_source(struct burn_source *source, char *buf, signed int bufsize, struct burn_write_opts *o, signed int flag);
// burn_stdio_seek
// file libburn/read.c line 320
static signed int burn_stdio_seek(signed int fd, signed long int byte_address, struct burn_drive *d, signed int flag);
// burn_stdio_slowdown
// file libburn/write.c line 2747
signed int burn_stdio_slowdown(struct burn_drive *d, struct timeval *prev_time, signed int amount, signed int flag);
// burn_stdio_sync_cache
// file libburn/write.c line 2687
signed int burn_stdio_sync_cache(signed int fd, struct burn_drive *d, signed int flag);
// burn_stdio_write
// file libburn/write.c line 2583
signed int burn_stdio_write(signed int fd, char *buf, signed int count, struct burn_drive *d, signed int flag);
// burn_stdio_write_sync
// file libburn/write.c line 2842
signed int burn_stdio_write_sync(struct burn_write_opts *o, struct burn_disc *disc);
// burn_stdio_write_track
// file libburn/write.c line 2774
signed int burn_stdio_write_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum, signed int flag);
// burn_structure_print_disc
// file libburn/structure.c line 292
void burn_structure_print_disc(struct burn_disc *d);
// burn_structure_print_session
// file libburn/structure.c line 305
void burn_structure_print_session(struct burn_session *s);
// burn_structure_print_track
// file libburn/structure.c line 318
void burn_structure_print_track(struct burn_track *t);
// burn_subcode_length
// file libburn/write.h line 21
signed int burn_subcode_length(signed int tracktype);
// burn_text_to_sev
// file libburn/init.c line 338
signed int burn_text_to_sev(char *severity_name, signed int *sevno, signed int flag);
// burn_track_apply_fillup
// file libburn/structure.c line 590
signed int burn_track_apply_fillup(struct burn_track *t, signed long int max_size, signed int flag);
// burn_track_clear_indice
// file libburn/structure.c line 483
signed int burn_track_clear_indice(struct burn_track *t, signed int flag);
// burn_track_clear_isrc
// file libburn/structure.c line 458
void burn_track_clear_isrc(struct burn_track *t);
// burn_track_create
// file libburn/libburn.h line 2014
struct burn_track * burn_track_create(void);
// burn_track_define_data
// file libburn/structure.c line 329
void burn_track_define_data(struct burn_track *t, signed int offset, signed int tail, signed int pad, signed int mode);
// burn_track_dispose_cdtext
// file libburn/structure.c line 1054
signed int burn_track_dispose_cdtext(struct burn_track *t, signed int block);
// burn_track_free
// file libburn/libburn.h line 2019
void burn_track_free(struct burn_track *t);
// burn_track_get_cdtext
// file libburn/structure.c line 1034
signed int burn_track_get_cdtext(struct burn_track *t, signed int block, signed int pack_type, char *pack_type_name, unsigned char **payload, signed int *length, signed int flag);
// burn_track_get_counters
// file libburn/structure.c line 636
signed int burn_track_get_counters(struct burn_track *t, signed long int *read_bytes, signed long int *written_bytes);
// burn_track_get_default_size
// file libburn/structure.h line 173
signed long int burn_track_get_default_size(struct burn_track *t);
// burn_track_get_entry
// file test/../libburn/libburn.h line 3559
void burn_track_get_entry(struct burn_track *t, struct burn_toc_entry *entry);
// burn_track_get_mode
// file libburn/structure.c line 741
signed int burn_track_get_mode(struct burn_track *track);
// burn_track_get_sectors
// file libburn/structure.c line 543
signed int burn_track_get_sectors(struct burn_track *t);
// burn_track_get_sectors_2
// file libburn/structure.h line 187
signed int burn_track_get_sectors_2(struct burn_track *t, signed int flag);
// burn_track_get_shortage
// file libburn/structure.c line 654
signed int burn_track_get_shortage(struct burn_track *t);
// burn_track_is_data_done
// file libburn/structure.c line 649
signed int burn_track_is_data_done(struct burn_track *t);
// burn_track_is_open_ended
// file libburn/structure.h line 159
signed int burn_track_is_open_ended(struct burn_track *t);
// burn_track_set_byte_swap
// file libburn/structure.c line 358
signed int burn_track_set_byte_swap(struct burn_track *t, signed int swap_source_bytes);
// burn_track_set_cdtext
// file libburn/libburn.h line 2461
signed int burn_track_set_cdtext(struct burn_track *t, signed int block, signed int pack_type, char *pack_type_name, unsigned char *payload, signed int length, signed int flag);
// burn_track_set_cdxa_conv
// file libburn/structure.c line 368
signed int burn_track_set_cdxa_conv(struct burn_track *t, signed int value);
// burn_track_set_default_size
// file libburn/structure.c line 621
signed int burn_track_set_default_size(struct burn_track *t, signed long int size);
// burn_track_set_fillup
// file libburn/structure.c line 577
signed int burn_track_set_fillup(struct burn_track *t, signed int fill_up_media);
// burn_track_set_index
// file libburn/structure.c line 464
signed int burn_track_set_index(struct burn_track *t, signed int index_number, unsigned int relative_lba, signed int flag);
// burn_track_set_isrc
// file libburn/structure.c line 377
void burn_track_set_isrc(struct burn_track *t, char *country, char *owner, unsigned char year, unsigned int serial);
// burn_track_set_isrc_string
// file libburn/libburn.h line 2541
signed int burn_track_set_isrc_string(struct burn_track *t, char *isrc, signed int flag);
// burn_track_set_postgap_size
// file libburn/structure.c line 502
signed int burn_track_set_postgap_size(struct burn_track *t, signed int size, signed int flag);
// burn_track_set_pregap_size
// file libburn/structure.c line 494
signed int burn_track_set_pregap_size(struct burn_track *t, signed int size, signed int flag);
// burn_track_set_sectors
// file libburn/structure.c line 549
signed int burn_track_set_sectors(struct burn_track *t, signed int sectors);
// burn_track_set_size
// file libburn/structure.c line 565
signed int burn_track_set_size(struct burn_track *t, signed long int size);
// burn_track_set_source
// file libburn/source.c line 29
enum burn_source_status burn_track_set_source(struct burn_track *t, struct burn_source *s);
// burn_util_make_printable_word
// file libburn/util.h line 10
signed int burn_util_make_printable_word(char **text, signed int flag);
// burn_util_thread_id
// file libburn/init.c line 368
char * burn_util_thread_id(signed int pid, unsigned long int tid, char *text);
// burn_version
// file libburn/util.c line 33
void burn_version(signed int *major, signed int *minor, signed int *micro);
// burn_write_close_session
// file libburn/write.c line 287
signed int burn_write_close_session(struct burn_write_opts *o);
// burn_write_close_track
// file libburn/write.c line 253
signed int burn_write_close_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum);
// burn_write_flush
// file libburn/write.c line 195
signed int burn_write_flush(struct burn_write_opts *o, struct burn_track *track);
// burn_write_flush_buffer
// file libburn/write.c line 170
signed int burn_write_flush_buffer(struct burn_write_opts *o, struct burn_track *track);
// burn_write_leadin
// file libburn/write.c line 854
signed int burn_write_leadin(struct burn_write_opts *o, struct burn_session *s, signed int first);
// burn_write_leadin_cdtext
// file libburn/write.c line 927
static signed int burn_write_leadin_cdtext(struct burn_write_opts *o, struct burn_session *s, signed int flag);
// burn_write_leadout
// file libburn/write.c line 881
signed int burn_write_leadout(struct burn_write_opts *o, signed int first, unsigned char control, signed int mode);
// burn_write_opts_auto_write_type
// file libburn/options.c line 303
enum burn_write_types burn_write_opts_auto_write_type(struct burn_write_opts *opts, struct burn_disc *disc, char *reasons, signed int flag);
// burn_write_opts_clone
// file libburn/options.c line 83
signed int burn_write_opts_clone(struct burn_write_opts *from, struct burn_write_opts **to, signed int flag);
// burn_write_opts_free
// file test/../libburn/libburn.h line 1661
void burn_write_opts_free(struct burn_write_opts *opts);
// burn_write_opts_get_drive
// file libburn/options.c line 538
struct burn_drive * burn_write_opts_get_drive(struct burn_write_opts *opts);
// burn_write_opts_new
// file test/../libburn/libburn.h line 1646
struct burn_write_opts * burn_write_opts_new(struct burn_drive *drive);
// burn_write_opts_set_dvd_obs
// file libburn/options.c line 508
void burn_write_opts_set_dvd_obs(struct burn_write_opts *opts, signed int obs);
// burn_write_opts_set_fail21h_sev
// file libburn/options.c line 218
void burn_write_opts_set_fail21h_sev(struct burn_write_opts *opts, char *severity);
// burn_write_opts_set_fillup
// file libburn/options.c line 485
void burn_write_opts_set_fillup(struct burn_write_opts *opts, signed int fill_up_media);
// burn_write_opts_set_force
// file libburn/options.c line 493
void burn_write_opts_set_force(struct burn_write_opts *opts, signed int use_force);
// burn_write_opts_set_format
// file libburn/options.c line 169
void burn_write_opts_set_format(struct burn_write_opts *opts, signed int format);
// burn_write_opts_set_has_mediacatalog
// file libburn/options.c line 196
void burn_write_opts_set_has_mediacatalog(struct burn_write_opts *opts, signed int has_mediacatalog);
// burn_write_opts_set_leadin_text
// file libburn/options.c line 236
signed int burn_write_opts_set_leadin_text(struct burn_write_opts *opts, unsigned char *text_packs, signed int num_packs, signed int flag);
// burn_write_opts_set_mediacatalog
// file libburn/options.c line 202
void burn_write_opts_set_mediacatalog(struct burn_write_opts *opts, unsigned char *mediacatalog);
// burn_write_opts_set_multi
// file libburn/options.c line 210
void burn_write_opts_set_multi(struct burn_write_opts *opts, signed int multi);
// burn_write_opts_set_obs_pad
// file libburn/options.c line 517
void burn_write_opts_set_obs_pad(struct burn_write_opts *opts, signed int pad);
// burn_write_opts_set_perform_opc
// file test/../libburn/libburn.h line 3102
void burn_write_opts_set_perform_opc(struct burn_write_opts *opts, signed int opc);
// burn_write_opts_set_simulate
// file libburn/options.c line 174
signed int burn_write_opts_set_simulate(struct burn_write_opts *opts, signed int sim);
// burn_write_opts_set_start_byte
// file libburn/options.c line 292
void burn_write_opts_set_start_byte(struct burn_write_opts *opts, signed long int value);
// burn_write_opts_set_stdio_fsync
// file libburn/options.c line 524
void burn_write_opts_set_stdio_fsync(struct burn_write_opts *opts, signed int rythm);
// burn_write_opts_set_stream_recording
// file libburn/options.c line 500
void burn_write_opts_set_stream_recording(struct burn_write_opts *opts, signed int value);
// burn_write_opts_set_toc_entries
// file libburn/options.c line 160
void burn_write_opts_set_toc_entries(struct burn_write_opts *opts, signed int count, struct burn_toc_entry *toc_entries);
// burn_write_opts_set_underrun_proof
// file libburn/options.c line 180
signed int burn_write_opts_set_underrun_proof(struct burn_write_opts *opts, signed int underrun_proof);
// burn_write_opts_set_write_type
// file test/../libburn/libburn.h line 3027
signed int burn_write_opts_set_write_type(struct burn_write_opts *opts, enum burn_write_types write_type, signed int block_type);
// burn_write_session
// file libburn/write.c line 1047
signed int burn_write_session(struct burn_write_opts *o, struct burn_session *s);
// burn_write_track
// file libburn/write.c line 1104
signed int burn_write_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum);
// burn_write_track_minsize
// file libburn/write.c line 209
signed int burn_write_track_minsize(struct burn_write_opts *o, struct burn_session *s, signed int tnum);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// char_to_isrc
// file libburn/sector.c line 577
static char char_to_isrc(char c);
// cleanup_app_handler$object
//
signed int cleanup_app_handler$object(void *, signed int, signed int);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// collect_payload
// file libburn/cdtext.c line 1233
static signed int collect_payload(unsigned char *text_packs, signed int num_packs, signed int pack_type, signed int block, unsigned char **payload, signed int *payload_count, signed int flag);
// convert_data
// file libburn/sector.c line 340
static signed int convert_data(struct burn_write_opts *o, struct burn_track *track, signed int inmode, unsigned char *data);
// convert_subs
// file libburn/sector.c line 395
static void convert_subs(struct burn_write_opts *o, signed int inmode, unsigned char *subs, unsigned char *sector);
// crc_11021
// file libburn/cdtext.c line 83
static signed int crc_11021(unsigned char *data, signed int count, signed int flag);
// crc_11021$link1
// file libburn/crc.c line 152
static signed int crc_11021$link1(unsigned char *data$link1, signed int count$link1, signed int flag$link1);
// crc_18001801b
// file libburn/crc.c line 323
static unsigned int crc_18001801b(unsigned char *data, signed int count, signed int flag);
// crc_32
// file libburn/crc.c line 530
unsigned int crc_32(unsigned char *data, signed int count);
// crc_ccitt
// file libburn/crc.c line 171
unsigned short int crc_ccitt(unsigned char *data, signed int count);
// cue_attach_track
// file libburn/structure.c line 1325
static signed int cue_attach_track(struct burn_session *session, struct burn_cue_file_cursor *crs, signed int flag);
// cue_check_for_track
// file libburn/structure.c line 1556
static signed int cue_check_for_track(struct burn_cue_file_cursor *crs, char *cmd, signed int flag);
// cue_create_file_source
// file libburn/structure.c line 1478
static signed int cue_create_file_source(char *path, struct burn_cue_file_cursor *crs, signed int flag);
// cue_crs_destroy
// file libburn/structure.c line 1235
static signed int cue_crs_destroy(struct burn_cue_file_cursor **victim, signed int flag);
// cue_crs_new
// file libburn/structure.c line 1197
static signed int cue_crs_new(struct burn_cue_file_cursor **reply, signed int flag);
// cue_interpret_line
// file libburn/structure.c line 1578
static signed int cue_interpret_line(struct burn_session *session, char *line, struct burn_cue_file_cursor *crs, signed int flag);
// cue_open_audioxtr
// file libburn/structure.c line 1417
static signed int cue_open_audioxtr(char *path, struct burn_cue_file_cursor *crs, signed int *fd, signed int flag);
// cue_read_number
// file libburn/structure.c line 1381
static signed int cue_read_number(char **payload, signed int *number, signed int flag);
// cue_read_timepoint_lba
// file libburn/structure.c line 1514
static signed int cue_read_timepoint_lba(char *apt, char *purpose, signed int *file_ba, signed int flag);
// cue_set_cdtext
// file libburn/structure.c line 1284
static signed int cue_set_cdtext(struct burn_session *session, struct burn_track *track, signed int pack_type, char *text, struct burn_cue_file_cursor *crs, signed int flag);
// cue_unquote_text
// file libburn/structure.c line 1262
static char * cue_unquote_text(char *text, signed int flag);
// dec_to_bcd
// file libburn/sector.c line 780
signed int dec_to_bcd(signed int d);
// drive_getcaps
// file libburn/drive.c line 1196
static signed int drive_getcaps(struct burn_drive *d, struct burn_drive_info *out);
// dup
// file /usr/include/unistd.h line 534
extern signed int dup(signed int);
// enumerate_common
// file libburn/sg-linux.c line 1451
static void enumerate_common(char *fname, signed int fd_in, signed int bus_no, signed int host_no, signed int channel_no, signed int target_no, signed int lun_no);
// erase_worker_func
// file libburn/async.c line 326
static void * erase_worker_func(struct w_list *w);
// evaluate_transport_success
// file libburn/sg-linux.c line 1891
static signed int evaluate_transport_success(struct burn_drive *d, struct command *c, struct _IO_FILE *fp, unsigned short int host_status, unsigned short int driver_status);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_free
// file libburn/file.c line 331
static void fifo_free(struct burn_source *source);
// fifo_get_size
// file libburn/file.c line 315
static signed long int fifo_get_size(struct burn_source *source);
// fifo_read
// file libburn/file.c line 228
static signed int fifo_read(struct burn_source *source, unsigned char *buffer, signed int size);
// fifo_set_size
// file libburn/file.c line 323
static signed int fifo_set_size(struct burn_source *source, signed long int size);
// fifo_sleep
// file libburn/file.c line 219
static signed int fifo_sleep(signed int flag);
// fifo_worker_func
// file libburn/async.c line 705
static void * fifo_worker_func(struct w_list *w);
// file_free
// file libburn/file.c line 86
static void file_free(struct burn_source *source);
// file_read
// file libburn/file.c line 68
static signed int file_read(struct burn_source *source, unsigned char *buffer, signed int size);
// file_read_sub
// file libburn/file.c line 77
static signed int file_read_sub(struct burn_source *source, unsigned char *buffer, signed int size);
// file_set_size
// file libburn/file.c line 112
static signed int file_set_size(struct burn_source *source, signed long int size);
// file_size
// file libburn/file.c line 96
static signed long int file_size(struct burn_source *source);
// find_worker
// file libburn/async.c line 126
static struct w_list * find_worker(struct burn_drive *d);
// fname_drive_is_listed
// file libburn/sg-linux.c line 1237
static signed int fname_drive_is_listed(char *fname, signed int flag);
// fname_enumerate
// file libburn/sg-linux.c line 1255
static signed int fname_enumerate(char *fname, signed int flag);
// fname_other_name
// file libburn/sg-linux.c line 1216
static signed int fname_other_name(char *fname, char *other_name, signed int flag);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// format_worker_func
// file libburn/async.c line 424
static void * format_worker_func(struct w_list *w);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// fsync
// file /usr/include/unistd.h line 959
extern signed int fsync(signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_bytes
// file libburn/sector.c line 107
static void get_bytes(struct burn_track *track, signed int count, unsigned char *data);
// get_outmode
// file libburn/sector.c line 97
static signed int get_outmode(struct burn_write_opts *o);
// get_sector
// file libburn/sector.c line 276
static unsigned char * get_sector(struct burn_write_opts *opts, struct burn_track *track, signed int inmode);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// interpret_performance
// file libburn/mmc.c line 4292
static signed int interpret_performance(struct burn_drive *d, struct command *c, signed int descr_type, signed int *alloc_len, signed int *max_descr, signed int *num_descr, signed int flag);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_ata_drive
// file libburn/sg-linux.c line 912
static signed int is_ata_drive(char *fname, signed int fd_in);
// is_payload_text_end
// file libburn/cdtext.c line 1273
static signed int is_payload_text_end(unsigned char *payload, signed int payload_count, signed int i, signed int flag);
// is_scsi_drive
// file libburn/sg-linux.c line 964
static signed int is_scsi_drive(char *fname, signed int fd_in, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// libdax_audioxtr_destroy
// file libburn/libdax_audioxtr.c line 74
signed int libdax_audioxtr_destroy(struct libdax_audioxtr **xtr, signed int flag);
// libdax_audioxtr_detach_fd
// file libburn/libdax_audioxtr.c line 312
signed int libdax_audioxtr_detach_fd(struct libdax_audioxtr *o, signed int *fd, signed int flag);
// libdax_audioxtr_get_id
// file libburn/libdax_audioxtr.c line 271
signed int libdax_audioxtr_get_id(struct libdax_audioxtr *o, char **fmt, char **fmt_info, signed int *num_channels, signed int *sample_rate, signed int *bits_per_sample, signed int *msb_first, signed int flag);
// libdax_audioxtr_get_size
// file libburn/libdax_audioxtr.c line 286
signed int libdax_audioxtr_get_size(struct libdax_audioxtr *o, signed long int *size, signed int flag);
// libdax_audioxtr_identify
// file libburn/libdax_audioxtr.c line 215
static signed int libdax_audioxtr_identify(struct libdax_audioxtr *o, signed int flag);
// libdax_audioxtr_identify_au
// file libburn/libdax_audioxtr.c line 168
static signed int libdax_audioxtr_identify_au(struct libdax_audioxtr *o, signed int flag);
// libdax_audioxtr_identify_wav
// file libburn/libdax_audioxtr.c line 125
static signed int libdax_audioxtr_identify_wav(struct libdax_audioxtr *o, signed int flag);
// libdax_audioxtr_init_reading
// file libburn/libdax_audioxtr.c line 248
static signed int libdax_audioxtr_init_reading(struct libdax_audioxtr *o, signed int flag);
// libdax_audioxtr_new
// file libburn/libdax_audioxtr.c line 37
signed int libdax_audioxtr_new(struct libdax_audioxtr **xtr, char *path, signed int flag);
// libdax_audioxtr_open
// file libburn/libdax_audioxtr.c line 89
static signed int libdax_audioxtr_open(struct libdax_audioxtr *o, signed int flag);
// libdax_audioxtr_read
// file libburn/libdax_audioxtr.c line 293
signed int libdax_audioxtr_read(struct libdax_audioxtr *o, char *buffer, signed int buffer_size, signed int flag);
// libdax_audioxtr_to_int
// file libburn/libdax_audioxtr.c line 232
static unsigned int libdax_audioxtr_to_int(struct libdax_audioxtr *o, unsigned char *bytes, signed int len, signed int flag);
// libdax_msgs__sev_to_text
// file libburn/libdax_msgs.h line 324
signed int libdax_msgs__sev_to_text(signed int severity, char **severity_name, signed int flag);
// libdax_msgs__text_to_sev
// file libburn/libdax_msgs.h line 332
signed int libdax_msgs__text_to_sev(char *severity_name, signed int *severity, signed int flag);
// libdax_msgs_destroy
// file libburn/libdax_msgs.h line 276
signed int libdax_msgs_destroy(struct libdax_msgs **m, signed int flag);
// libdax_msgs_destroy_item
// file libburn/libdax_msgs.h line 366
signed int libdax_msgs_destroy_item(struct libdax_msgs *m, struct libdax_msgs_item **item, signed int flag);
// libdax_msgs_item_destroy
// file libburn/libdax_msgs.c line 88
static signed int libdax_msgs_item_destroy(struct libdax_msgs_item **item, signed int flag);
// libdax_msgs_item_get_msg
// file libburn/libdax_msgs.h line 376
signed int libdax_msgs_item_get_msg(struct libdax_msgs_item *item, signed int *error_code, char **msg_text, signed int *os_errno, signed int flag);
// libdax_msgs_item_get_origin
// file libburn/libdax_msgs.c line 116
signed int libdax_msgs_item_get_origin(struct libdax_msgs_item *item, double *timestamp, signed int *process_id, signed int *origin, signed int flag);
// libdax_msgs_item_get_rank
// file libburn/libdax_msgs.h line 396
signed int libdax_msgs_item_get_rank(struct libdax_msgs_item *item, signed int *severity, signed int *priority, signed int flag);
// libdax_msgs_item_new
// file libburn/libdax_msgs.c line 31
static signed int libdax_msgs_item_new(struct libdax_msgs_item **item, struct libdax_msgs_item *link, signed int flag);
// libdax_msgs_item_unlink
// file libburn/libdax_msgs.c line 69
signed int libdax_msgs_item_unlink(struct libdax_msgs_item *o, struct libdax_msgs_item **chain_start, struct libdax_msgs_item **chain_end, signed int flag);
// libdax_msgs_lock
// file libburn/libdax_msgs.c line 162
static signed int libdax_msgs_lock(struct libdax_msgs *m, signed int flag);
// libdax_msgs_new
// file libburn/libdax_msgs.h line 264
signed int libdax_msgs_new(struct libdax_msgs **m, signed int flag);
// libdax_msgs_obtain
// file libburn/libdax_msgs.h line 355
signed int libdax_msgs_obtain(struct libdax_msgs *m, struct libdax_msgs_item **item, signed int severity, signed int priority, signed int flag);
// libdax_msgs_refer
// file libburn/libdax_msgs.h line 288
signed int libdax_msgs_refer(struct libdax_msgs **pt, struct libdax_msgs *m, signed int flag);
// libdax_msgs_set_severities
// file libburn/libdax_msgs.h line 344
signed int libdax_msgs_set_severities(struct libdax_msgs *m, signed int queue_severity, signed int print_severity, char *print_id, signed int flag);
// libdax_msgs_submit
// file libburn/libdax_msgs.h line 310
signed int libdax_msgs_submit(struct libdax_msgs *m, signed int origin, signed int error_code, signed int severity, signed int priority, char *msg_text, signed int os_errno, signed int flag);
// libdax_msgs_unlock
// file libburn/libdax_msgs.c line 177
static signed int libdax_msgs_unlock(struct libdax_msgs *m, signed int flag);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 262
extern signed int lstat(const char *, struct stat *);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mmc_close
// file libburn/mmc.c line 603
void mmc_close(struct burn_drive *d, signed int session, signed int track);
// mmc_close_disc
// file libburn/mmc.c line 558
void mmc_close_disc(struct burn_write_opts *o);
// mmc_close_session
// file libburn/mmc.c line 579
void mmc_close_session(struct burn_write_opts *o);
// mmc_compose_mode_page_5
// file libburn/mmc.c line 4538
signed int mmc_compose_mode_page_5(struct burn_drive *d, struct burn_session *s, signed int tnum, struct burn_write_opts *o, unsigned char *pd);
// mmc_erase
// file libburn/mmc.c line 2677
void mmc_erase(struct burn_drive *d, signed int fast);
// mmc_eval_read_error
// file libburn/mmc.c line 2453
signed int mmc_eval_read_error(struct burn_drive *d, struct command *c, char *what, signed int start_m, signed int start_s, signed int start_f, signed int end_m, signed int end_s, signed int end_f, signed int flag);
// mmc_fake_toc
// file libburn/mmc.c line 1289
signed int mmc_fake_toc(struct burn_drive *d);
// mmc_fake_toc_entry
// file libburn/mmc.c line 1076
signed int mmc_fake_toc_entry(struct burn_toc_entry *entry, signed int session_number, signed int track_number, unsigned char *size_data, unsigned char *start_data, unsigned char *last_adr_data);
// mmc_format_unit
// file libburn/mmc.c line 3617
signed int mmc_format_unit(struct burn_drive *d, signed long int size, signed int flag);
// mmc_four_char_to_int
// file libburn/mmc.c line 297
signed int mmc_four_char_to_int(unsigned char *data);
// mmc_function_spy
// file libburn/mmc.h line 112
signed int mmc_function_spy(struct burn_drive *d, char *text);
// mmc_function_spy_ctrl
// file libburn/mmc.c line 289
signed int mmc_function_spy_ctrl(signed int do_tell);
// mmc_get_bd_spare_info
// file libburn/mmc.h line 118
signed int mmc_get_bd_spare_info(struct burn_drive *d, signed int *alloc_blocks, signed int *free_blocks, signed int flag);
// mmc_get_configuration
// file libburn/mmc.c line 3282
void mmc_get_configuration(struct burn_drive *d);
// mmc_get_configuration_al
// file libburn/mmc.c line 2943
static signed int mmc_get_configuration_al(struct burn_drive *d, signed int *alloc_len);
// mmc_get_event
// file libburn/mmc.c line 646
void mmc_get_event(struct burn_drive *d);
// mmc_get_leadin_text
// file libburn/mmc.h line 127
signed int mmc_get_leadin_text(struct burn_drive *d, unsigned char **text_packs, signed int *num_packs, signed int flag);
// mmc_get_leadin_text_al
// file libburn/mmc.c line 2199
static signed int mmc_get_leadin_text_al(struct burn_drive *d, unsigned char **text_packs, signed int *alloc_len, signed int flag);
// mmc_get_media_product_id
// file libburn/mmc.h line 106
signed int mmc_get_media_product_id(struct burn_drive *d, char **product_id, char **media_code1, char **media_code2, char **book_type, signed int flag);
// mmc_get_nwa
// file libburn/mmc.c line 454
signed int mmc_get_nwa(struct burn_drive *d, signed int trackno, signed int *lba, signed int *nwa);
// mmc_get_performance
// file libburn/mmc.c line 4490
signed int mmc_get_performance(struct burn_drive *d, signed int descr_type, signed int flag);
// mmc_get_performance_al
// file libburn/mmc.c line 4427
static signed int mmc_get_performance_al(struct burn_drive *d, signed int descr_type, signed int *alloc_len, signed int *max_descr, signed int flag);
// mmc_get_phys_format_info
// file libburn/mmc.h line 122
signed int mmc_get_phys_format_info(struct burn_drive *d, signed int *disk_category, char **book_name, signed int *part_version, signed int *num_layers, signed int *num_blocks, signed int flag);
// mmc_get_write_performance
// file libburn/mmc.c line 4523
signed int mmc_get_write_performance(struct burn_drive *d);
// mmc_guess_profile
// file libburn/mmc.c line 1861
static signed int mmc_guess_profile(struct burn_drive *d, signed int flag);
// mmc_int_to_four_char
// file libburn/mmc.c line 304
signed int mmc_int_to_four_char(unsigned char *data, signed int num);
// mmc_obtain_profile_name
// file libburn/mmc.h line 96
char * mmc_obtain_profile_name(signed int profile_number);
// mmc_perform_opc
// file libburn/mmc.c line 2725
void mmc_perform_opc(struct burn_drive *d);
// mmc_read_10
// file libburn/mmc.c line 4700
signed int mmc_read_10(struct burn_drive *d, signed int start, signed int amount, struct buffer *buf);
// mmc_read_atip
// file libburn/mmc.c line 2268
void mmc_read_atip(struct burn_drive *d);
// mmc_read_buffer_capacity
// file libburn/mmc.c line 3541
signed int mmc_read_buffer_capacity(struct burn_drive *d);
// mmc_read_capacity
// file libburn/mmc.c line 4830
signed int mmc_read_capacity(struct burn_drive *d);
// mmc_read_cd
// file libburn/mmc.c line 2582
signed int mmc_read_cd(struct burn_drive *d, signed int start, signed int len, signed int sec_type, signed int main_ch, struct burn_read_opts *o, struct buffer *buf, signed int flag);
// mmc_read_cd_msf
// file libburn/mmc.c line 2497
signed int mmc_read_cd_msf(struct burn_drive *d, signed int start_m, signed int start_s, signed int start_f, signed int end_m, signed int end_s, signed int end_f, signed int sec_type, signed int main_ch, struct burn_read_opts *o, struct buffer *buf, signed int flag);
// mmc_read_disc_info
// file libburn/mmc.c line 2177
void mmc_read_disc_info(struct burn_drive *d);
// mmc_read_disc_info_al
// file libburn/mmc.c line 1885
static signed int mmc_read_disc_info_al(struct burn_drive *d, signed int *alloc_len);
// mmc_read_disc_structure
// file libburn/mmc.c line 4928
signed int mmc_read_disc_structure(struct burn_drive *d, signed int media_type, signed int layer_number, signed int format, signed int min_len, char **reply, signed int *reply_len, signed int flag);
// mmc_read_disc_structure_al
// file libburn/mmc.c line 4867
static signed int mmc_read_disc_structure_al(struct burn_drive *d, signed int *alloc_len, signed int media_type, signed int layer_number, signed int format, signed int min_len, char **reply, signed int *reply_len, signed int flag);
// mmc_read_format_capacities
// file libburn/mmc.c line 3458
signed int mmc_read_format_capacities(struct burn_drive *d, signed int top_wanted);
// mmc_read_format_capacities_al
// file libburn/mmc.c line 3308
static signed int mmc_read_format_capacities_al(struct burn_drive *d, signed int *alloc_len, signed int top_wanted);
// mmc_read_lead_in
// file libburn/mmc.c line 2700
void mmc_read_lead_in(struct burn_drive *d, struct buffer *buf);
// mmc_read_multi_session_c1
// file libburn/mmc.c line 1739
signed int mmc_read_multi_session_c1(struct burn_drive *d, signed int *trackno, signed int *start);
// mmc_read_toc
// file libburn/mmc.c line 1713
void mmc_read_toc(struct burn_drive *d);
// mmc_read_toc_al
// file libburn/mmc.c line 1488
static signed int mmc_read_toc_al(struct burn_drive *d, signed int *alloc_len);
// mmc_read_toc_fmt0
// file libburn/mmc.c line 1273
static signed int mmc_read_toc_fmt0(struct burn_drive *d);
// mmc_read_toc_fmt0_al
// file libburn/mmc.c line 1123
static signed int mmc_read_toc_fmt0_al(struct burn_drive *d, signed int *alloc_len);
// mmc_read_track_info
// file libburn/mmc.c line 405
signed int mmc_read_track_info(struct burn_drive *d, signed int trackno, struct buffer *buf, signed int alloc_len);
// mmc_reserve_track
// file libburn/mmc.c line 366
signed int mmc_reserve_track(struct burn_drive *d, signed long int size);
// mmc_send_cue_sheet
// file libburn/mmc.c line 331
signed int mmc_send_cue_sheet(struct burn_drive *d, struct cue_sheet *s);
// mmc_set_product_id
// file libburn/mmc.c line 5001
static signed int mmc_set_product_id(char *reply, signed int manuf_idx, signed int type_idx, signed int rev_idx, char **product_id, char **media_code1, char **media_code2, signed int flag);
// mmc_set_speed
// file libburn/mmc.c line 2844
void mmc_set_speed(struct burn_drive *d, signed int r, signed int w);
// mmc_set_streaming
// file libburn/mmc.c line 2750
signed int mmc_set_streaming(struct burn_drive *d, signed int r_speed, signed int w_speed, signed int end_lba);
// mmc_setup_drive
// file libburn/mmc.c line 5301
signed int mmc_setup_drive(struct burn_drive *d);
// mmc_start_if_needed
// file libburn/mmc.c line 319
signed int mmc_start_if_needed(struct burn_drive *d, signed int flag);
// mmc_sync_cache
// file libburn/mmc.c line 3478
void mmc_sync_cache(struct burn_drive *d);
// mmc_wait_for_buffer_free
// file libburn/mmc.c line 743
static signed int mmc_wait_for_buffer_free(struct burn_drive *d, struct buffer *buf);
// mmc_write
// file libburn/mmc.c line 926
signed int mmc_write(struct burn_drive *d, signed int start, struct buffer *buf);
// mmc_write_12
// file libburn/mmc.c line 874
void mmc_write_12(struct burn_drive *d, signed int start, struct buffer *buf);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// new_burn_speed_descr
// file libburn/mmc.c line 4268
static signed int new_burn_speed_descr(struct burn_drive *d, signed int sd_source, struct burn_speed_descriptor **sd, signed int flag);
// new_cue
// file libburn/write.c line 374
static signed int new_cue(struct cue_sheet *sheet, signed int number, signed int flag);
// null_read
// file libburn/null.c line 17
signed int null_read(struct burn_source *source, unsigned char *buffer, signed int size);
// offst_auth
// file libburn/file.c line 769
static struct burn_source_offst * offst_auth(struct burn_source *source, signed int flag);
// offst_cancel
// file libburn/file.c line 861
static signed int offst_cancel(struct burn_source *source);
// offst_free
// file libburn/file.c line 804
static void offst_free(struct burn_source *source);
// offst_get_size
// file libburn/file.c line 782
static signed long int offst_get_size(struct burn_source *source);
// offst_read
// file libburn/file.c line 819
static signed int offst_read(struct burn_source *source, unsigned char *buffer, signed int size);
// offst_set_size
// file libburn/file.c line 791
static signed int offst_set_size(struct burn_source *source, signed long int size);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// pick_payload_text
// file libburn/cdtext.c line 1295
static signed int pick_payload_text(unsigned char *payload, signed int payload_count, signed int tno, unsigned char **text_start, signed int *text_len, signed int flag);
// precheck_disc_has_cdtext
// file libburn/write.c line 1400
static signed int precheck_disc_has_cdtext(struct burn_disc *disc, signed int flag);
// precheck_write_is_audio
// file libburn/write.c line 1386
static signed int precheck_write_is_audio(struct burn_disc *disc, signed int flag);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// proc_sys_dev_cdrom_info
// file libburn/sg-linux.c line 1335
static signed int proc_sys_dev_cdrom_info(char ***list, signed int *count, signed int flag);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 299
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cancel
// file /usr/include/pthread.h line 513
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 278
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 506
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 510
extern signed int pthread_setcanceltype(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$0 *, struct anonymous$0 *);
// react_on_drive_loss
// file libburn/sg-linux.c line 2033
static void react_on_drive_loss(struct burn_drive *d, struct command *c, struct _IO_FILE *fp);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_full_buffer
// file libburn/file.c line 49
static signed int read_full_buffer(signed int fd, unsigned char *buffer, signed int size);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// readlink
// file /usr/include/unistd.h line 812
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// remove_worker
// file libburn/async.c line 187
static void remove_worker(unsigned long int th);
// report_block
// file libburn/cdtext.c line 1435
static signed int report_block(unsigned char *text_packs, signed int num_packs, signed int block, signed int first_tno, signed int last_tno, signed int char_code, char *result, signed int result_size, signed int flag);
// report_track
// file libburn/cdtext.c line 1396
static signed int report_track(unsigned char *text_packs, signed int num_packs, signed int block, signed int tno, signed int first_tno, char **respt, signed int *result_len, signed int flag);
// reset_progress
// file libburn/async.c line 243
static void reset_progress(struct burn_drive *d, signed int sessions, signed int tracks, signed int indices, signed int sectors, signed int flag);
// retry_mmc_read
// file libburn/read.c line 373
static signed int retry_mmc_read(struct burn_drive *d, signed int chunksize, signed int sose_mem, signed int start, char **wpt, signed long int *data_count, signed int flag);
// retry_stdio_read
// file libburn/read.c line 413
static signed int retry_stdio_read(struct burn_drive *d, signed int fd, signed int chunksize, signed int start, char **wpt, signed long int *data_count, signed int flag);
// rfl32
// file libburn/crc.c line 301
unsigned int rfl32(unsigned int acc);
// rfl8
// file libburn/crc.c line 412
unsigned int rfl8(unsigned int acc);
// sbc_eject
// file libburn/sbc.c line 80
void sbc_eject(struct burn_drive *d);
// sbc_load
// file libburn/sbc.c line 55
void sbc_load(struct burn_drive *d);
// sbc_setup_drive
// file libburn/sbc.c line 174
signed int sbc_setup_drive(struct burn_drive *d);
// sbc_start_unit
// file libburn/sbc.c line 130
signed int sbc_start_unit(struct burn_drive *d);
// sbc_start_unit_flag
// file libburn/sbc.c line 106
signed int sbc_start_unit_flag(struct burn_drive *d, signed int flag);
// sbc_stop_unit
// file libburn/sbc.c line 149
signed int sbc_stop_unit(struct burn_drive *d);
// scan_worker_func
// file libburn/async.c line 231
static void * scan_worker_func(struct w_list *w);
// scsi_command_name
// file libburn/spc.c line 1611
static char * scsi_command_name(unsigned int c, signed int flag);
// scsi_enumerate_drives
// file libburn/sg.h line 33
signed int scsi_enumerate_drives(void);
// scsi_error
// file libburn/spc.c line 1594
enum response scsi_error(struct burn_drive *d, unsigned char *sense, signed int senselen);
// scsi_error_msg
// file libburn/spc.h line 63
enum response scsi_error_msg(struct burn_drive *d, unsigned char *sense, signed int senselen, char *msg_data, signed int *key, signed int *asc, signed int *ascq);
// scsi_eval_cmd_outcome
// file libburn/spc.h line 123
signed int scsi_eval_cmd_outcome(struct burn_drive *d, struct command *c, void *fp, unsigned char *sense, signed int sense_len, signed long int start_time, signed int timeout_ms, signed int loop_count, signed int flag);
// scsi_init_command
// file libburn/spc.h line 73
signed int scsi_init_command(struct command *c, unsigned char *opcode, signed int oplen);
// scsi_log_cmd
// file libburn/spc.h line 90
signed int scsi_log_cmd(struct command *c, void *fp_in, signed int flag);
// scsi_log_command
// file libburn/spc.h line 80
signed int scsi_log_command(unsigned char *opcode, signed int oplen, signed int data_dir, unsigned char *data, signed int bytes, void *fp_in, signed int flag);
// scsi_log_err
// file libburn/spc.c line 1924
signed int scsi_log_err(struct burn_drive *d, struct command *c, void *fp_in, unsigned char *sense, signed int sense_len, signed int flag);
// scsi_log_message
// file libburn/spc.h line 111
signed int scsi_log_message(struct burn_drive *d, void *fp_in, char *msg, signed int flag);
// scsi_log_reply
// file libburn/spc.h line 97
signed int scsi_log_reply(unsigned char *opcode, signed int data_dir, unsigned char *data, signed int dxfer_len, void *fp_in, unsigned char *sense, signed int sense_len, double duration, signed int flag);
// scsi_log_text
// file libburn/spc.c line 1838
signed int scsi_log_text(char *text, void *fp_in, signed int flag);
// scsi_notify_error
// file libburn/spc.h line 69
signed int scsi_notify_error(struct burn_drive *d, struct command *c, unsigned char *sense, signed int senselen, signed int flag);
// scsi_show_cmd_text
// file libburn/spc.c line 1782
signed int scsi_show_cmd_text(struct command *c, void *fp_in, signed int flag);
// scsi_show_command
// file libburn/spc.c line 1740
signed int scsi_show_command(unsigned char *opcode, signed int oplen, signed int dir, unsigned char *data, signed int bytes, void *fp_in, signed int flag);
// scsi_show_command_reply
// file libburn/spc.c line 1790
signed int scsi_show_command_reply(unsigned char *opcode, signed int data_dir, unsigned char *data, signed int dxfer_len, void *fp_in, signed int flag);
// search_pack
// file libburn/cdtext.c line 1180
static signed int search_pack(unsigned char *text_packs, signed int num_packs, signed int start_no, signed int pack_type, signed int block, unsigned char **found_pack, signed int *found_no, signed int flag);
// sector_data
// file libburn/sector.c line 723
signed int sector_data(struct burn_write_opts *o, struct burn_track *t, signed int psub);
// sector_get_outmode
// file libburn/options.c line 132 function burn_write_opts_set_write_type
signed int sector_get_outmode(enum burn_write_types write_type, enum burn_block_types block_type);
// sector_headers
// file libburn/sector.c line 809
signed int sector_headers(struct burn_write_opts *o, unsigned char *out, signed int mode, signed int leadin);
// sector_headers_is_ok
// file libburn/sector.c line 789
signed int sector_headers_is_ok(struct burn_write_opts *o, signed int mode);
// sector_identify
// file libburn/sector.c line 941
signed int sector_identify(unsigned char *data);
// sector_lout
// file libburn/sector.c line 703
signed int sector_lout(struct burn_write_opts *o, unsigned char control, signed int mode);
// sector_postgap
// file libburn/sector.c line 517
signed int sector_postgap(struct burn_write_opts *o, unsigned char tno, unsigned char control, signed int mode);
// sector_pregap
// file libburn/sector.c line 496
signed int sector_pregap(struct burn_write_opts *o, unsigned char tno, unsigned char control, signed int mode);
// sector_toc
// file libburn/sector.c line 476
signed int sector_toc(struct burn_write_opts *o, signed int mode);
// sector_write_buffer
// file libburn/sector.c line 238
signed int sector_write_buffer(struct burn_drive *d, struct burn_track *track, signed int flag);
// sg_close_drive
// file libburn/sg-linux.c line 807
static signed int sg_close_drive(struct burn_drive *d);
// sg_close_drive_fd
// file libburn/sg-linux.c line 597
static signed int sg_close_drive_fd(char *fname, signed int driveno, signed int *fd, signed int sorry);
// sg_dispose_drive
// file libburn/sg.h line 81
signed int sg_dispose_drive(struct burn_drive *d, signed int flag);
// sg_drive_is_open
// file libburn/sg-linux.c line 1687
signed int sg_drive_is_open(struct burn_drive *d);
// sg_enumerate
// file libburn/sg-linux.c line 1164
static void sg_enumerate(void);
// sg_evaluate_kernel
// file libburn/sg-linux.c line 292
static void sg_evaluate_kernel(void);
// sg_exchange_scd_for_sr
// file libburn/sg-linux.c line 342
static signed int sg_exchange_scd_for_sr(char *fname, signed int flag);
// sg_fcntl_lock
// file libburn/sg-linux.c line 653
static signed int sg_fcntl_lock(signed int *fd, char *fd_name, signed int l_type, signed int verbous);
// sg_give_next_adr
// file libburn/sg.h line 22
signed int sg_give_next_adr(struct burn_drive_enumerator_struct *idx, char *adr, signed int adr_size, signed int initialize);
// sg_grab
// file libburn/sg-linux.c line 1704
signed int sg_grab(struct burn_drive *d);
// sg_handle_busy_device
// file libburn/sg-linux.c line 524
static signed int sg_handle_busy_device(char *fname, signed int os_errno);
// sg_id_string
// file libburn/sg.h line 51
signed int sg_id_string(char *msg, signed int flag);
// sg_initialize
// file libburn/sg.h line 61
signed int sg_initialize(char *msg, signed int flag);
// sg_is_enumerable_adr
// file libburn/sg.h line 24
signed int sg_is_enumerable_adr(char *adr);
// sg_issue_command
// file libburn/sg-linux.c line 2055
signed int sg_issue_command(struct burn_drive *d, struct command *c);
// sg_obtain_scsi_adr
// file libburn/sg.h line 25
signed int sg_obtain_scsi_adr(char *path, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no);
// sg_obtain_scsi_adr_fd
// file libburn/sg-linux.c line 2245
static signed int sg_obtain_scsi_adr_fd(char *path, signed int fd_in, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no);
// sg_open_drive_fd
// file libburn/sg-linux.c line 698
static signed int sg_open_drive_fd(char *fname, signed int scan_mode);
// sg_open_for_enumeration
// file libburn/sg-linux.c line 1108
static signed int sg_open_for_enumeration(char *fname, signed int flag);
// sg_open_scsi_siblings
// file libburn/sg-linux.c line 821
static signed int sg_open_scsi_siblings(char *path, signed int driveno, signed int *sibling_fds, char (*sibling_fnames)[16l], signed int *sibling_count, signed int host_no, signed int channel_no, signed int id_no, signed int lun_no);
// sg_release
// file libburn/sg-linux.c line 1868
signed int sg_release(struct burn_drive *d);
// sg_release_siblings
// file libburn/sg-linux.c line 787
static signed int sg_release_siblings(signed int *sibling_fds, char (*sibling_fnames)[16l], signed int *sibling_count);
// sg_select_device_family
// file libburn/sg-linux.c line 311
static void sg_select_device_family(void);
// sg_shutdown
// file libburn/sg.h line 69
signed int sg_shutdown(signed int flag);
// sgio_inquiry_cd_drive
// file libburn/sg-linux.c line 441
static signed int sgio_inquiry_cd_drive(signed int fd, char *fname);
// sgio_log_cmd
// file libburn/sg-linux.c line 378
static signed int sgio_log_cmd(unsigned char *cmd, signed int cmd_len, struct _IO_FILE *fp_in, signed int flag);
// sgio_log_reply
// file libburn/sg-linux.c line 401
static signed int sgio_log_reply(unsigned char *opcode, signed int data_dir, unsigned char *data, signed int dxfer_len, void *fp_in, unsigned char *sense, signed int sense_len, double duration, signed int flag);
// sgio_test
// file libburn/sg-linux.c line 414
static signed int sgio_test(signed int fd);
// sigdelset
// file /usr/include/signal.h line 222
extern signed int sigdelset(struct anonymous$0 *, signed int);
// sigfillset
// file /usr/include/signal.h line 216
extern signed int sigfillset(struct anonymous$0 *);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// single_enumerate
// file libburn/sg-linux.c line 1305
static signed int single_enumerate(signed int flag);
// sleep
// file /usr/include/unistd.h line 447
extern unsigned int sleep(unsigned int);
// spc_allow
// file libburn/spc.c line 399
void spc_allow(struct burn_drive *d);
// spc_block_type
// file libburn/spc.h line 33
signed int spc_block_type(enum burn_block_types b);
// spc_confirm_cd_drive
// file libburn/spc.c line 2033
signed int spc_confirm_cd_drive(struct burn_drive *d, signed int flag);
// spc_decode_sense
// file libburn/spc.h line 114
signed int spc_decode_sense(unsigned char *sense, signed int senselen, signed int *key, signed int *asc, signed int *ascq);
// spc_get_erase_progress
// file libburn/spc.c line 298
signed int spc_get_erase_progress(struct burn_drive *d);
// spc_getcaps
// file libburn/spc.c line 1001
void spc_getcaps(struct burn_drive *d);
// spc_inquiry
// file libburn/spc.c line 339
void spc_inquiry(struct burn_drive *d);
// spc_prevent
// file libburn/spc.c line 380
void spc_prevent(struct burn_drive *d);
// spc_probe_write_modes
// file libburn/spc.c line 1017
void spc_probe_write_modes(struct burn_drive *d);
// spc_report_async_error
// file libburn/spc.c line 268
static signed int spc_report_async_error(struct burn_drive *d, signed int key, signed int asc, signed int ascq, signed int flag);
// spc_request_sense
// file libburn/spc.c line 249
void spc_request_sense(struct burn_drive *d, struct buffer *buf);
// spc_select_error_params
// file libburn/spc.c line 720
void spc_select_error_params(struct burn_drive *d, struct burn_read_opts *o);
// spc_select_write_params
// file libburn/spc.h line 23
void spc_select_write_params(struct burn_drive *d, struct burn_session *s, signed int tnum, struct burn_write_opts *o);
// spc_sense_caps
// file libburn/spc.c line 649
void spc_sense_caps(struct burn_drive *d);
// spc_sense_caps_al
// file libburn/spc.c line 446
static signed int spc_sense_caps_al(struct burn_drive *d, signed int *alloc_len, signed int flag);
// spc_sense_error_params
// file libburn/spc.c line 684
void spc_sense_error_params(struct burn_drive *d);
// spc_sense_write_params
// file libburn/spc.c line 760
void spc_sense_write_params(struct burn_drive *d);
// spc_setup_drive
// file libburn/spc.c line 1158
signed int spc_setup_drive(struct burn_drive *d);
// spc_test_unit_ready
// file libburn/spc.h line 40
signed int spc_test_unit_ready(struct burn_drive *d);
// spc_test_unit_ready_r
// file libburn/spc.c line 110
signed int spc_test_unit_ready_r(struct burn_drive *d, signed int *key, signed int *asc, signed int *ascq, signed int *progress);
// spc_try_get_performance
// file libburn/spc.c line 417
static signed int spc_try_get_performance(struct burn_drive *d, signed int flag);
// spc_wait_unit_attention
// file libburn/spc.h line 44
signed int spc_wait_unit_attention(struct burn_drive *d, signed int max_sec, char *cmd_text, signed int flag);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// statvfs
// file /usr/include/x86_64-linux-gnu/sys/statvfs.h line 51
extern signed int statvfs(const char *, struct statvfs *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strip_spaces
// file libburn/drive.c line 1178
static void strip_spaces(char *str, unsigned long int len);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// subcode_lout
// file libburn/sector.c line 539
static void subcode_lout(struct burn_write_opts *o, unsigned char control, unsigned char *data);
// subcode_toc
// file libburn/sector.c line 433
static void subcode_toc(struct burn_drive *d, signed int mode, unsigned char *data);
// subcode_user
// file libburn/sector.c line 591
void subcode_user(struct burn_write_opts *o, unsigned char *subcodes, unsigned char tno, unsigned char control, unsigned char indx, struct isrc *isrc, signed int psub);
// telltoc_aquire_by_adr
// file test/telltoc.c line 118
signed int telltoc_aquire_by_adr(char *drive_adr);
// telltoc_aquire_by_driveno
// file test/telltoc.c line 159
signed int telltoc_aquire_by_driveno(signed int *driveno, signed int silent_drive);
// telltoc_aquire_drive
// file test/telltoc.c line 100
signed int telltoc_aquire_drive(char *drive_adr, signed int *driveno, signed int silent_drive);
// telltoc_detect_cd
// file test/telltoc.c line 480
void telltoc_detect_cd(struct burn_drive *drive);
// telltoc_formatlist
// file test/telltoc.c line 438
signed int telltoc_formatlist(struct burn_drive *drive);
// telltoc_media
// file test/telltoc.c line 241
signed int telltoc_media(struct burn_drive *drive);
// telltoc_msinfo
// file test/telltoc.c line 568
signed int telltoc_msinfo(struct burn_drive *drive, signed int msinfo_explicit, signed int msinfo_alone);
// telltoc_read_and_print
// file test/telltoc.c line 629
signed int telltoc_read_and_print(struct burn_drive *drive, signed int start_sector, signed int sector_count, char *raw_file, signed int encoding);
// telltoc_regrab
// file test/telltoc.c line 227
signed int telltoc_regrab(struct burn_drive *drive);
// telltoc_setup
// file test/telltoc.c line 807
signed int telltoc_setup(signed int argc, char **argv);
// telltoc_speedlist
// file test/telltoc.c line 408
signed int telltoc_speedlist(struct burn_drive *drive);
// telltoc_toc
// file test/telltoc.c line 494
signed int telltoc_toc(struct burn_drive *drive);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// toc_find_modes
// file libburn/toc.h line 51
void toc_find_modes(struct burn_drive *d);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// truncate
// file /usr/include/unistd.h line 996
extern signed int truncate(const char *, signed long int);
// type_to_ctrl
// file libburn/write.c line 99
static signed int type_to_ctrl(signed int mode);
// type_to_form
// file libburn/write.c line 126
void type_to_form(signed int mode, unsigned char *ctladr, signed int *form);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// uncook_subs
// file libburn/sector.c line 52
static void uncook_subs(unsigned char *dest, unsigned char *source);
// unget_sector
// file libburn/sector.c line 313
static void unget_sector(struct burn_write_opts *opts, signed int inmode);
// usleep
// file /usr/include/unistd.h line 463
extern signed int usleep(unsigned int);
// v07t_apply_to_session
// file libburn/cdtext.c line 618
static signed int v07t_apply_to_session(struct burn_session *session, signed int block, signed int *char_codes, signed int *copyrights, signed int *languages, signed int *session_attr_seen, signed int *track_attr_seen, signed int genre_code, char *genre_text, signed int flag);
// v07t_cdtext_char_code
// file libburn/cdtext.c line 492
static signed int v07t_cdtext_char_code(char *payload, signed int flag);
// v07t_cdtext_genre_code
// file libburn/cdtext.c line 549
static signed int v07t_cdtext_genre_code(char *payload, signed int flag);
// v07t_cdtext_lang_code
// file libburn/cdtext.c line 519
static signed int v07t_cdtext_lang_code(char *payload, signed int flag);
// v07t_cdtext_len_db
// file libburn/cdtext.c line 576
static signed int v07t_cdtext_len_db(char *payload, signed int *char_code, signed int *length, signed int *double_byte, signed int flag);
// v07t_cdtext_to_session
// file libburn/cdtext.c line 587
static signed int v07t_cdtext_to_session(struct burn_session *session, signed int block, char *payload, signed int *char_code, signed int pack_type, char *pack_type_name, signed int flag);
// v07t_cdtext_to_track
// file libburn/cdtext.c line 603
static signed int v07t_cdtext_to_track(struct burn_track *track, signed int block, char *payload, signed int *char_code, signed int pack_type, char *pack_type_name, signed int flag);
// v07t_hexcode
// file libburn/cdtext.c line 453
static signed int v07t_hexcode(char *payload, signed int flag);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// write_disc_worker_func
// file libburn/async.c line 551
static void * write_disc_worker_func(struct w_list *w);
// write_v07t_line
// file libburn/cdtext.c line 1203
static void write_v07t_line(char **respt, char *spec, char *value, signed int vlen, signed int *result_len, signed int flag);
// write_v07t_textline
// file libburn/cdtext.c line 1359
static signed int write_v07t_textline(unsigned char *text_packs, signed int num_packs, signed int pack_type, signed int block, signed int tno, signed int first_tno, char *spec, char **respt, signed int *result_len, signed int flag);

struct anonymous$0
{
  // __val
  unsigned long int __val[16l];
};

union anonymous$1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct buffer
{
  // data
  unsigned char data[69632l];
  // sectors
  signed int sectors;
  // bytes
  signed int bytes;
};

struct burn_cdtext
{
  // payload
  unsigned char *payload[16l];
  // length
  signed int length[16l];
  // flags
  signed int flags;
};

struct burn_cue_file_cursor
{
  // cdtextfile
  char *cdtextfile;
  // source_file
  char *source_file;
  // source_size
  signed long int source_size;
  // file_source
  struct burn_source *file_source;
  // fifo_size
  signed int fifo_size;
  // fifo
  struct burn_source *fifo;
  // swap_audio_bytes
  signed int swap_audio_bytes;
  // no_cdtext
  signed int no_cdtext;
  // no_catalog_isrc
  signed int no_catalog_isrc;
  // start_track_no
  signed int start_track_no;
  // offst_source
  struct burn_source *offst_source;
  // current_file_ba
  signed int current_file_ba;
  // current_index_ba
  signed int current_index_ba;
  // prev_track
  struct burn_track *prev_track;
  // prev_file_ba
  signed int prev_file_ba;
  // prev_block_size
  signed int prev_block_size;
  // track
  struct burn_track *track;
  // track_no
  signed int track_no;
  // track_current_index
  signed int track_current_index;
  // track_has_source
  signed int track_has_source;
  // block_size
  signed int block_size;
  // block_size_locked
  signed int block_size_locked;
  // track_mode
  signed int track_mode;
  // flags
  signed int flags;
};

struct burn_disc
{
  // sessions
  signed int sessions;
  // session
  struct burn_session **session;
  // incomplete_sessions
  signed int incomplete_sessions;
  // refcnt
  signed int refcnt;
};

struct burn_disc_mode_demands
{
  // multi_session
  signed int multi_session;
  // multi_track
  signed int multi_track;
  // unknown_track_size
  signed int unknown_track_size;
  // mixed_mode
  signed int mixed_mode;
  // audio
  signed int audio;
  // exotic_track
  signed int exotic_track;
  // block_types
  signed int block_types;
  // will_append
  signed int will_append;
};

struct burn_format_descr
{
  // type
  signed int type;
  // size
  signed long int size;
  // tdp
  unsigned int tdp;
};

struct burn_progress
{
  // sessions
  signed int sessions;
  // session
  signed int session;
  // tracks
  signed int tracks;
  // track
  signed int track;
  // indices
  signed int indices;
  // index
  signed int index;
  // start_sector
  signed int start_sector;
  // sectors
  signed int sectors;
  // sector
  signed int sector;
  // buffer_capacity
  unsigned int buffer_capacity;
  // buffer_available
  unsigned int buffer_available;
  // buffered_bytes
  signed long int buffered_bytes;
  // buffer_min_fill
  unsigned int buffer_min_fill;
};

struct command
{
  // opcode
  unsigned char opcode[16l];
  // oplen
  signed int oplen;
  // dir
  signed int dir;
  // dxfer_len
  signed int dxfer_len;
  // sense
  unsigned char sense[128l];
  // error
  signed int error;
  // retry
  signed int retry;
  // page
  struct buffer *page;
  // timeout
  signed int timeout;
  // start_time
  double start_time;
  // end_time
  double end_time;
};

struct params
{
  // speed
  signed int speed;
  // retries
  signed int retries;
};

struct burn_drive
{
  // drive_role
  signed int drive_role;
  // bus_no
  signed int bus_no;
  // host
  signed int host;
  // id
  signed int id;
  // channel
  signed int channel;
  // lun
  signed int lun;
  // devname
  char *devname;
  // phys_if_std
  signed int phys_if_std;
  // phys_if_name
  char phys_if_name[80l];
  // fd
  signed int fd;
  // sibling_count
  signed int sibling_count;
  // sibling_fds
  signed int sibling_fds[5l];
  // sibling_fnames
  char sibling_fnames[5l][16l];
  // global_index
  signed int global_index;
  // access_lock
  union anonymous access_lock;
  // status
  enum burn_disc_status status;
  // erasable
  signed int erasable;
  // current_profile
  signed int current_profile;
  // current_profile_text
  char current_profile_text[80l];
  // current_is_cd_profile
  signed int current_is_cd_profile;
  // current_is_supported_profile
  signed int current_is_supported_profile;
  // current_is_guessed_profile
  signed int current_is_guessed_profile;
  // all_profiles
  unsigned char all_profiles[256l];
  // num_profiles
  signed int num_profiles;
  // features
  struct burn_feature_descr *features;
  // current_has_feat21h
  signed int current_has_feat21h;
  // was_feat21h_failure
  signed int was_feat21h_failure;
  // current_feat21h_link_size
  signed int current_feat21h_link_size;
  // current_feat23h_byte4
  signed int current_feat23h_byte4;
  // current_feat23h_byte8
  signed int current_feat23h_byte8;
  // current_feat2fh_byte4
  signed int current_feat2fh_byte4;
  // drive_serial_number
  char *drive_serial_number;
  // drive_serial_number_len
  char drive_serial_number_len;
  // media_serial_number
  char *media_serial_number;
  // media_serial_number_len
  char media_serial_number_len;
  // next_track_damaged
  signed int next_track_damaged;
  // needs_close_session
  signed int needs_close_session;
  // needs_sync_cache
  signed int needs_sync_cache;
  // do_stream_recording
  signed int do_stream_recording;
  // stream_recording_start
  signed int stream_recording_start;
  // last_lead_in
  signed int last_lead_in;
  // last_lead_out
  signed int last_lead_out;
  // num_opc_tables
  signed int num_opc_tables;
  // bg_format_status
  signed int bg_format_status;
  // disc_type
  signed int disc_type;
  // disc_id
  unsigned int disc_id;
  // disc_bar_code
  char disc_bar_code[9l];
  // disc_app_code
  signed int disc_app_code;
  // disc_info_valid
  signed int disc_info_valid;
  // format_descr_type
  signed int format_descr_type;
  // format_curr_max_size
  signed long int format_curr_max_size;
  // format_curr_blsas
  unsigned int format_curr_blsas;
  // best_format_type
  signed int best_format_type;
  // best_format_size
  signed long int best_format_size;
  // num_format_descr
  signed int num_format_descr;
  // format_descriptors
  struct burn_format_descr format_descriptors[32l];
  // released
  volatile signed int released;
  // silent_on_scsi_error
  signed int silent_on_scsi_error;
  // had_particular_error
  signed int had_particular_error;
  // stdio_fd
  signed int stdio_fd;
  // nwa
  signed int nwa;
  // alba
  signed int alba;
  // rlba
  signed int rlba;
  // start_lba
  signed int start_lba;
  // end_lba
  signed int end_lba;
  // complete_sessions
  signed int complete_sessions;
  // state_of_last_session
  signed int state_of_last_session;
  // incomplete_sessions
  signed int incomplete_sessions;
  // last_track_no
  signed int last_track_no;
  // sent_default_page_05
  signed int sent_default_page_05;
  // media_capacity_remaining
  signed long int media_capacity_remaining;
  // media_lba_limit
  signed int media_lba_limit;
  // media_read_capacity
  signed int media_read_capacity;
  // role_5_nwa
  signed int role_5_nwa;
  // toc_temp
  signed int toc_temp;
  // disc
  struct burn_disc *disc;
  // block_types
  signed int block_types[4l];
  // buffer
  struct buffer *buffer;
  // progress
  struct burn_progress progress;
  // casual_command
  struct command casual_command;
  // pessimistic_buffer_free
  signed long int pessimistic_buffer_free;
  // pbf_altered
  signed int pbf_altered;
  // wait_for_buffer_free
  signed int wait_for_buffer_free;
  // nominal_write_speed
  signed int nominal_write_speed;
  // wfb_min_usec
  unsigned int wfb_min_usec;
  // wfb_max_usec
  unsigned int wfb_max_usec;
  // wfb_timeout_sec
  unsigned int wfb_timeout_sec;
  // wfb_min_percent
  unsigned int wfb_min_percent;
  // wfb_max_percent
  unsigned int wfb_max_percent;
  // pessimistic_writes
  unsigned int pessimistic_writes;
  // waited_writes
  unsigned int waited_writes;
  // waited_tries
  unsigned int waited_tries;
  // waited_usec
  unsigned int waited_usec;
  // cancel
  volatile signed int cancel;
  // busy
  volatile enum burn_drive_status busy;
  // write_opts
  struct burn_write_opts *write_opts;
  // thread_pid
  signed int thread_pid;
  // thread_pid_valid
  signed int thread_pid_valid;
  // thread_tid
  unsigned long int thread_tid;
  // grab
  signed int (*grab)(struct burn_drive *);
  // release
  signed int (*release)(struct burn_drive *);
  // drive_is_open
  signed int (*drive_is_open)(struct burn_drive *);
  // issue_command
  signed int (*issue_command)(struct burn_drive *, struct command *);
  // erase
  void (*erase)(struct burn_drive *, signed int);
  // getcaps
  void (*getcaps)(struct burn_drive *);
  // read_atip
  void (*read_atip)(struct burn_drive *);
  // write
  signed int (*write)(struct burn_drive *, signed int, struct buffer *);
  // read_toc
  void (*read_toc)(struct burn_drive *);
  // lock
  void (*lock)(struct burn_drive *);
  // unlock
  void (*unlock)(struct burn_drive *);
  // eject
  void (*eject)(struct burn_drive *);
  // load
  void (*load)(struct burn_drive *);
  // start_unit
  signed int (*start_unit)(struct burn_drive *);
  // stop_unit
  signed int (*stop_unit)(struct burn_drive *);
  // is_stopped
  signed int is_stopped;
  // read_disc_info
  void (*read_disc_info)(struct burn_drive *);
  // read_cd
  signed int (*read_cd)(struct burn_drive *, signed int, signed int, signed int, signed int, struct burn_read_opts *, struct buffer *, signed int);
  // perform_opc
  void (*perform_opc)(struct burn_drive *);
  // set_speed
  void (*set_speed)(struct burn_drive *, signed int, signed int);
  // send_parameters
  void (*send_parameters)(struct burn_drive *, struct burn_read_opts *);
  // send_write_parameters
  void (*send_write_parameters)(struct burn_drive *, struct burn_session *, signed int, struct burn_write_opts *);
  // send_cue_sheet
  signed int (*send_cue_sheet)(struct burn_drive *, struct cue_sheet *);
  // reserve_track
  signed int (*reserve_track)(struct burn_drive *, signed long int);
  // sync_cache
  void (*sync_cache)(struct burn_drive *);
  // get_erase_progress
  signed int (*get_erase_progress)(struct burn_drive *);
  // get_nwa
  signed int (*get_nwa)(struct burn_drive *, signed int, signed int *, signed int *);
  // read_multi_session_c1
  signed int (*read_multi_session_c1)(struct burn_drive *, signed int *, signed int *);
  // close_disc
  void (*close_disc)(struct burn_write_opts *);
  // close_session
  void (*close_session)(struct burn_write_opts *);
  // close_track_session
  void (*close_track_session)(struct burn_drive *, signed int, signed int);
  // test_unit_ready
  signed int (*test_unit_ready)(struct burn_drive *);
  // probe_write_modes
  void (*probe_write_modes)(struct burn_drive *);
  // params
  struct params params;
  // idata
  struct burn_scsi_inquiry_data *idata;
  // mdata
  struct scsi_mode_data *mdata;
  // toc_entries
  signed int toc_entries;
  // toc_entry
  struct burn_toc_entry *toc_entry;
  // read_buffer_capacity
  signed int (*read_buffer_capacity)(struct burn_drive *);
  // format_unit
  signed int (*format_unit)(struct burn_drive *, signed long int, signed int);
  // read_format_capacities
  signed int (*read_format_capacities)(struct burn_drive *, signed int);
  // read_10
  signed int (*read_10)(struct burn_drive *, signed int, signed int, struct buffer *);
};

struct burn_drive_enumerator_struct
{
  // pos
  signed int pos;
  // info_count
  signed int info_count;
  // info_list
  char **info_list;
};

struct burn_drive_info
{
  // vendor
  char vendor[9l];
  // product
  char product[17l];
  // revision
  char revision[5l];
  // location
  char location[17l];
  // read_dvdram
  unsigned int read_dvdram : 1;
  // read_dvdr
  unsigned int read_dvdr : 1;
  // read_dvdrom
  unsigned int read_dvdrom : 1;
  // read_cdr
  unsigned int read_cdr : 1;
  // read_cdrw
  unsigned int read_cdrw : 1;
  // write_dvdram
  unsigned int write_dvdram : 1;
  // write_dvdr
  unsigned int write_dvdr : 1;
  // write_cdr
  unsigned int write_cdr : 1;
  // write_cdrw
  unsigned int write_cdrw : 1;
  // write_simulate
  unsigned int write_simulate : 1;
  // c2_errors
  unsigned int c2_errors : 1;
  // buffer_size
  signed int buffer_size;
  // tao_block_types
  signed int tao_block_types;
  // sao_block_types
  signed int sao_block_types;
  // raw_block_types
  signed int raw_block_types;
  // packet_block_types
  signed int packet_block_types;
  // drive
  struct burn_drive *drive;
};

struct burn_feature_descr
{
  // feature_code
  unsigned short int feature_code;
  // flags
  unsigned char flags;
  // data_lenght
  unsigned char data_lenght;
  // data
  unsigned char *data;
  // next
  struct burn_feature_descr *next;
};

struct burn_multi_caps
{
  // multi_session
  signed int multi_session;
  // multi_track
  signed int multi_track;
  // start_adr
  signed int start_adr;
  // start_alignment
  signed long int start_alignment;
  // start_range_low
  signed long int start_range_low;
  // start_range_high
  signed long int start_range_high;
  // might_do_tao
  signed int might_do_tao;
  // might_do_sao
  signed int might_do_sao;
  // might_do_raw
  signed int might_do_raw;
  // advised_write_mode
  enum burn_write_types advised_write_mode;
  // selected_write_mode
  enum burn_write_types selected_write_mode;
  // current_profile
  signed int current_profile;
  // current_is_cd_profile
  signed int current_is_cd_profile;
  // might_simulate
  signed int might_simulate;
};

struct burn_pack_cursor
{
  // packs
  unsigned char *packs;
  // num_packs
  signed int num_packs;
  // td_used
  signed int td_used;
  // hiseq
  signed int hiseq[8l];
  // pack_count
  signed int pack_count[16l];
  // track_offset
  signed int track_offset;
};

struct burn_read_opts
{
  // drive
  struct burn_drive *drive;
  // refcount
  signed int refcount;
  // raw
  unsigned int raw : 1;
  // c2errors
  unsigned int c2errors : 1;
  // subcodes_audio
  unsigned int subcodes_audio : 1;
  // subcodes_data
  unsigned int subcodes_data : 1;
  // hardware_error_recovery
  unsigned int hardware_error_recovery : 1;
  // report_recovered_errors
  unsigned int report_recovered_errors : 1;
  // transfer_damaged_blocks
  unsigned int transfer_damaged_blocks : 1;
  // hardware_error_retries
  unsigned char hardware_error_retries;
  // dap_bit
  unsigned int dap_bit;
};

struct burn_scsi_inquiry_data
{
  // peripheral
  char peripheral;
  // version
  char version;
  // vendor
  char vendor[9l];
  // product
  char product[17l];
  // revision
  char revision[5l];
  // valid
  signed int valid;
};

struct burn_session
{
  // firsttrack
  unsigned char firsttrack;
  // lasttrack
  unsigned char lasttrack;
  // hidefirst
  signed int hidefirst;
  // start_m
  unsigned char start_m;
  // start_s
  unsigned char start_s;
  // start_f
  unsigned char start_f;
  // leadout_entry
  struct burn_toc_entry *leadout_entry;
  // tracks
  signed int tracks;
  // track
  struct burn_track **track;
  // refcnt
  signed int refcnt;
  // cdtext
  struct burn_cdtext *cdtext[8l];
  // cdtext_char_code
  unsigned char cdtext_char_code[8l];
  // cdtext_copyright
  unsigned char cdtext_copyright[8l];
  // cdtext_language
  unsigned char cdtext_language[8l];
  // mediacatalog
  unsigned char mediacatalog[14l];
};

struct burn_source
{
  // refcount
  signed int refcount;
  // read
  signed int (*read)(struct burn_source *, unsigned char *, signed int);
  // read_sub
  signed int (*read_sub)(struct burn_source *, unsigned char *, signed int);
  // get_size
  signed long int (*get_size)(struct burn_source *);
  // set_size
  signed int (*set_size)(struct burn_source *, signed long int);
  // free_data
  void (*free_data)(struct burn_source *);
  // next
  struct burn_source *next;
  // data
  void *data;
  // version
  signed int version;
  // read_xt
  signed int (*read_xt)(struct burn_source *, unsigned char *, signed int);
  // cancel
  signed int (*cancel)(struct burn_source *);
};

struct burn_source_fifo
{
  // magic
  char magic[4l];
  // is_started
  signed int is_started;
  // thread_handle
  void *thread_handle;
  // thread_pid
  signed int thread_pid;
  // thread_is_valid
  signed int thread_is_valid;
  // inp
  struct burn_source *inp;
  // inp_read_size
  signed int inp_read_size;
  // outlet
  signed int outlet[2l];
  // chunksize
  signed int chunksize;
  // chunks
  signed int chunks;
  // buf
  char *buf;
  // buf_writepos
  volatile signed int buf_writepos;
  // buf_readpos
  volatile signed int buf_readpos;
  // end_of_input
  volatile signed int end_of_input;
  // input_error
  volatile signed int input_error;
  // end_of_consumption
  volatile signed int end_of_consumption;
  // in_counter
  signed long int in_counter;
  // out_counter
  signed long int out_counter;
  // total_min_fill
  signed int total_min_fill;
  // interval_min_fill
  signed int interval_min_fill;
  // put_counter
  signed int put_counter;
  // get_counter
  signed int get_counter;
  // empty_counter
  signed int empty_counter;
  // full_counter
  signed int full_counter;
};

struct burn_source_file
{
  // magic
  char magic[4l];
  // datafd
  signed int datafd;
  // subfd
  signed int subfd;
  // fixed_size
  signed long int fixed_size;
};

struct burn_source_offst
{
  // inp
  struct burn_source *inp;
  // prev
  struct burn_source *prev;
  // start
  signed long int start;
  // size
  signed long int size;
  // size_adjustable
  signed int size_adjustable;
  // nominal_size
  signed int nominal_size;
  // next
  struct burn_source *next;
  // running
  signed int running;
  // pos
  signed long int pos;
};

struct burn_speed_descriptor
{
  // source
  signed int source;
  // profile_loaded
  signed int profile_loaded;
  // profile_name
  char profile_name[80l];
  // end_lba
  signed int end_lba;
  // write_speed
  signed int write_speed;
  // read_speed
  signed int read_speed;
  // wrc
  signed int wrc;
  // exact
  signed int exact;
  // mrw
  signed int mrw;
  // prev
  struct burn_speed_descriptor *prev;
  // next
  struct burn_speed_descriptor *next;
};

struct burn_toc_entry
{
  // session
  unsigned char session;
  // adr
  unsigned char adr;
  // control
  unsigned char control;
  // tno
  unsigned char tno;
  // point
  unsigned char point;
  // min
  unsigned char min;
  // sec
  unsigned char sec;
  // frame
  unsigned char frame;
  // zero
  unsigned char zero;
  // pmin
  unsigned char pmin;
  // psec
  unsigned char psec;
  // pframe
  unsigned char pframe;
  // extensions_valid
  unsigned char extensions_valid;
  // session_msb
  unsigned char session_msb;
  // point_msb
  unsigned char point_msb;
  // start_lba
  signed int start_lba;
  // track_blocks
  signed int track_blocks;
  // last_recorded_address
  signed int last_recorded_address;
  // track_status_bits
  signed int track_status_bits;
};

struct isrc
{
  // has_isrc
  signed int has_isrc;
  // country
  char country[2l];
  // owner
  char owner[3l];
  // year
  unsigned char year;
  // serial
  unsigned int serial;
};

struct burn_track
{
  // refcnt
  signed int refcnt;
  // entry
  struct burn_toc_entry *entry;
  // indices
  unsigned char indices;
  // index
  signed int index[100l];
  // offset
  signed int offset;
  // offsetcount
  signed int offsetcount;
  // tail
  signed int tail;
  // tailcount
  signed int tailcount;
  // pad
  signed int pad;
  // fill_up_media
  signed int fill_up_media;
  // default_size
  signed long int default_size;
  // source
  struct burn_source *source;
  // eos
  signed int eos;
  // sourcecount
  signed long int sourcecount;
  // writecount
  signed long int writecount;
  // written_sectors
  signed long int written_sectors;
  // open_ended
  signed int open_ended;
  // track_data_done
  signed int track_data_done;
  // end_on_premature_eoi
  signed int end_on_premature_eoi;
  // mode
  signed int mode;
  // pregap1
  signed int pregap1;
  // pregap2
  signed int pregap2;
  // pregap2_size
  signed int pregap2_size;
  // postgap
  signed int postgap;
  // postgap_size
  signed int postgap_size;
  // isrc
  struct isrc isrc;
  // swap_source_bytes
  signed int swap_source_bytes;
  // cdxa_conversion
  signed int cdxa_conversion;
  // cdtext
  struct burn_cdtext *cdtext[8l];
};

struct burn_write_opts
{
  // drive
  struct burn_drive *drive;
  // refcount
  signed int refcount;
  // write_type
  enum burn_write_types write_type;
  // block_type
  enum burn_block_types block_type;
  // toc_entries
  signed int toc_entries;
  // toc_entry
  struct burn_toc_entry *toc_entry;
  // simulate
  unsigned int simulate : 1;
  // underrun_proof
  unsigned int underrun_proof : 1;
  // perform_opc
  unsigned int perform_opc : 1;
  // obs
  signed int obs;
  // obs_pad
  signed int obs_pad;
  // start_byte
  signed long int start_byte;
  // fill_up_media
  signed int fill_up_media;
  // force_is_set
  signed int force_is_set;
  // do_stream_recording
  signed int do_stream_recording;
  // dvd_obs_override
  signed int dvd_obs_override;
  // stdio_fsync_size
  signed int stdio_fsync_size;
  // text_packs
  unsigned char *text_packs;
  // num_text_packs
  signed int num_text_packs;
  // no_text_pack_crc_check
  signed int no_text_pack_crc_check;
  // has_mediacatalog
  signed int has_mediacatalog;
  // mediacatalog
  unsigned char mediacatalog[13l];
  // format
  signed int format;
  // control
  unsigned char control;
  // multi
  unsigned char multi;
  // feat21h_fail_sev
  signed int feat21h_fail_sev;
};

struct cd_mid_record
{
  // manufacturer
  char *manufacturer;
  // m_li
  signed int m_li;
  // s_li
  signed int s_li;
  // f_li
  signed int f_li;
  // other_brands
  char *other_brands;
};

struct cue_sheet
{
  // count
  signed int count;
  // data
  unsigned char *data;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct dvd_mid_record
{
  // mc1
  char *mc1;
  // mc1_sig_len
  signed int mc1_sig_len;
  // manufacturer
  char *manufacturer;
};

struct erase_opts
{
  // drive
  struct burn_drive *drive;
  // fast
  signed int fast;
};

struct fifo_opts
{
  // source
  struct burn_source *source;
  // flag
  signed int flag;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct format_opts
{
  // drive
  struct burn_drive *drive;
  // size
  signed long int size;
  // flag
  signed int flag;
};

struct hd_driveid
{
  // config
  unsigned short int config;
  // cyls
  unsigned short int cyls;
  // reserved2
  unsigned short int reserved2;
  // heads
  unsigned short int heads;
  // track_bytes
  unsigned short int track_bytes;
  // sector_bytes
  unsigned short int sector_bytes;
  // sectors
  unsigned short int sectors;
  // vendor0
  unsigned short int vendor0;
  // vendor1
  unsigned short int vendor1;
  // vendor2
  unsigned short int vendor2;
  // serial_no
  unsigned char serial_no[20l];
  // buf_type
  unsigned short int buf_type;
  // buf_size
  unsigned short int buf_size;
  // ecc_bytes
  unsigned short int ecc_bytes;
  // fw_rev
  unsigned char fw_rev[8l];
  // model
  unsigned char model[40l];
  // max_multsect
  unsigned char max_multsect;
  // vendor3
  unsigned char vendor3;
  // dword_io
  unsigned short int dword_io;
  // vendor4
  unsigned char vendor4;
  // capability
  unsigned char capability;
  // reserved50
  unsigned short int reserved50;
  // vendor5
  unsigned char vendor5;
  // tPIO
  unsigned char tPIO;
  // vendor6
  unsigned char vendor6;
  // tDMA
  unsigned char tDMA;
  // field_valid
  unsigned short int field_valid;
  // cur_cyls
  unsigned short int cur_cyls;
  // cur_heads
  unsigned short int cur_heads;
  // cur_sectors
  unsigned short int cur_sectors;
  // cur_capacity0
  unsigned short int cur_capacity0;
  // cur_capacity1
  unsigned short int cur_capacity1;
  // multsect
  unsigned char multsect;
  // multsect_valid
  unsigned char multsect_valid;
  // lba_capacity
  unsigned int lba_capacity;
  // dma_1word
  unsigned short int dma_1word;
  // dma_mword
  unsigned short int dma_mword;
  // eide_pio_modes
  unsigned short int eide_pio_modes;
  // eide_dma_min
  unsigned short int eide_dma_min;
  // eide_dma_time
  unsigned short int eide_dma_time;
  // eide_pio
  unsigned short int eide_pio;
  // eide_pio_iordy
  unsigned short int eide_pio_iordy;
  // words69_70
  unsigned short int words69_70[2l];
  // words71_74
  unsigned short int words71_74[4l];
  // queue_depth
  unsigned short int queue_depth;
  // words76_79
  unsigned short int words76_79[4l];
  // major_rev_num
  unsigned short int major_rev_num;
  // minor_rev_num
  unsigned short int minor_rev_num;
  // command_set_1
  unsigned short int command_set_1;
  // command_set_2
  unsigned short int command_set_2;
  // cfsse
  unsigned short int cfsse;
  // cfs_enable_1
  unsigned short int cfs_enable_1;
  // cfs_enable_2
  unsigned short int cfs_enable_2;
  // csf_default
  unsigned short int csf_default;
  // dma_ultra
  unsigned short int dma_ultra;
  // trseuc
  unsigned short int trseuc;
  // trsEuc
  unsigned short int trsEuc;
  // CurAPMvalues
  unsigned short int CurAPMvalues;
  // mprc
  unsigned short int mprc;
  // hw_config
  unsigned short int hw_config;
  // acoustic
  unsigned short int acoustic;
  // msrqs
  unsigned short int msrqs;
  // sxfert
  unsigned short int sxfert;
  // sal
  unsigned short int sal;
  // spg
  unsigned int spg;
  // lba_capacity_2
  unsigned long long int lba_capacity_2;
  // words104_125
  unsigned short int words104_125[22l];
  // last_lun
  unsigned short int last_lun;
  // word127
  unsigned short int word127;
  // dlf
  unsigned short int dlf;
  // csfo
  unsigned short int csfo;
  // words130_155
  unsigned short int words130_155[26l];
  // word156
  unsigned short int word156;
  // words157_159
  unsigned short int words157_159[3l];
  // cfa_power
  unsigned short int cfa_power;
  // words161_175
  unsigned short int words161_175[15l];
  // words176_205
  unsigned short int words176_205[30l];
  // words206_254
  unsigned short int words206_254[49l];
  // integrity_word
  unsigned short int integrity_word;
};

struct libdax_audioxtr
{
  // path
  char path[4096l];
  // fd
  signed int fd;
  // fmt
  char fmt[80l];
  // fmt_info
  char fmt_info[4096l];
  // num_channels
  signed int num_channels;
  // sample_rate
  signed int sample_rate;
  // bits_per_sample
  signed int bits_per_sample;
  // msb_first
  signed int msb_first;
  // data_size
  signed long int data_size;
  // extract_count
  signed long int extract_count;
  // wav_subchunk2_size
  unsigned int wav_subchunk2_size;
  // au_data_location
  unsigned int au_data_location;
  // au_data_size
  unsigned int au_data_size;
};

struct libdax_msgs
{
  // refcount
  signed int refcount;
  // oldest
  struct libdax_msgs_item *oldest;
  // youngest
  struct libdax_msgs_item *youngest;
  // count
  signed int count;
  // queue_severity
  signed int queue_severity;
  // print_severity
  signed int print_severity;
  // print_id
  char print_id[81l];
  // lock_mutex
  union anonymous lock_mutex;
};

struct libdax_msgs_item
{
  // timestamp
  double timestamp;
  // process_id
  signed int process_id;
  // origin
  signed int origin;
  // severity
  signed int severity;
  // priority
  signed int priority;
  // error_code
  signed int error_code;
  // msg_text
  char *msg_text;
  // os_errno
  signed int os_errno;
  // prev
  struct libdax_msgs_item *prev;
  // next
  struct libdax_msgs_item *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct scan_opts
{
  // drives
  struct burn_drive_info **drives;
  // n_drives
  unsigned int *n_drives;
  // done
  signed int done;
};

struct scsi_mode_data
{
  // p2a_valid
  signed int p2a_valid;
  // buffer_size
  signed int buffer_size;
  // dvdram_read
  signed int dvdram_read;
  // dvdram_write
  signed int dvdram_write;
  // dvdr_read
  signed int dvdr_read;
  // dvdr_write
  signed int dvdr_write;
  // dvdrom_read
  signed int dvdrom_read;
  // cdrw_read
  signed int cdrw_read;
  // cdrw_write
  signed int cdrw_write;
  // cdr_read
  signed int cdr_read;
  // cdr_write
  signed int cdr_write;
  // simulate
  signed int simulate;
  // c2_pointers
  signed int c2_pointers;
  // underrun_proof
  signed int underrun_proof;
  // max_read_speed
  signed int max_read_speed;
  // cur_read_speed
  signed int cur_read_speed;
  // max_write_speed
  signed int max_write_speed;
  // cur_write_speed
  signed int cur_write_speed;
  // min_write_speed
  signed int min_write_speed;
  // min_end_lba
  signed int min_end_lba;
  // max_end_lba
  signed int max_end_lba;
  // speed_descriptors
  struct burn_speed_descriptor *speed_descriptors;
  // retry_page_length
  signed int retry_page_length;
  // retry_page_valid
  signed int retry_page_valid;
  // write_page_length
  signed int write_page_length;
  // write_page_valid
  signed int write_page_valid;
};

struct sg_io_hdr
{
  // interface_id
  signed int interface_id;
  // dxfer_direction
  signed int dxfer_direction;
  // cmd_len
  unsigned char cmd_len;
  // mx_sb_len
  unsigned char mx_sb_len;
  // iovec_count
  unsigned short int iovec_count;
  // dxfer_len
  unsigned int dxfer_len;
  // dxferp
  void *dxferp;
  // cmdp
  unsigned char *cmdp;
  // sbp
  unsigned char *sbp;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
  // pack_id
  signed int pack_id;
  // usr_ptr
  void *usr_ptr;
  // status
  unsigned char status;
  // masked_status
  unsigned char masked_status;
  // msg_status
  unsigned char msg_status;
  // sb_len_wr
  unsigned char sb_len_wr;
  // host_status
  unsigned short int host_status;
  // driver_status
  unsigned short int driver_status;
  // resid
  signed int resid;
  // duration
  unsigned int duration;
  // info
  unsigned int info;
};

struct sg_scsi_id
{
  // host_no
  signed int host_no;
  // channel
  signed int channel;
  // scsi_id
  signed int scsi_id;
  // lun
  signed int lun;
  // scsi_type
  signed int scsi_type;
  // h_cmd_per_lun
  signed short int h_cmd_per_lun;
  // d_queue_depth
  signed short int d_queue_depth;
  // unused
  signed int unused[2l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct statvfs
{
  // f_bsize
  unsigned long int f_bsize;
  // f_frsize
  unsigned long int f_frsize;
  // f_blocks
  unsigned long int f_blocks;
  // f_bfree
  unsigned long int f_bfree;
  // f_bavail
  unsigned long int f_bavail;
  // f_files
  unsigned long int f_files;
  // f_ffree
  unsigned long int f_ffree;
  // f_favail
  unsigned long int f_favail;
  // f_fsid
  unsigned long int f_fsid;
  // f_flag
  unsigned long int f_flag;
  // f_namemax
  unsigned long int f_namemax;
  // __f_spare
  signed int __f_spare[6l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // __domainname
  char __domainname[65l];
};

struct write_opts
{
  // drive
  struct burn_drive *drive;
  // opts
  struct burn_write_opts *opts;
  // disc
  struct burn_disc *disc;
};

union w_list_data
{
  // scan
  struct scan_opts scan;
  // erase
  struct erase_opts erase;
  // format
  struct format_opts format;
  // write
  struct write_opts write;
  // fifo
  struct fifo_opts fifo;
};

struct w_list
{
  // w_type
  signed int w_type;
  // drive
  struct burn_drive *drive;
  // thread
  unsigned long int thread;
  // next
  struct w_list *next;
  // u
  union w_list_data u;
};


// MMC_BLANK
// file libburn/mmc.c line 202
static unsigned char MMC_BLANK[12l] = { (unsigned char)0xA1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_CLOSE
// file libburn/mmc.c line 216
static unsigned char MMC_CLOSE[10l] = { (unsigned char)0x5B, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_FORMAT_UNIT
// file libburn/mmc.c line 227
static unsigned char MMC_FORMAT_UNIT[6l] = { (unsigned char)0x04, (unsigned char)0x11, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_GET_ATIP
// file libburn/mmc.c line 197
static unsigned char MMC_GET_ATIP[10l] = { (unsigned char)0x43, (unsigned char)2, (unsigned char)4, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_GET_CONFIGURATION
// file libburn/mmc.c line 211
static unsigned char MMC_GET_CONFIGURATION[10l] = { (unsigned char)0x46, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_GET_DISC_INFO
// file libburn/mmc.c line 199
static unsigned char MMC_GET_DISC_INFO[10l] = { (unsigned char)0x51, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_GET_EVENT
// file libburn/mmc.c line 215
static unsigned char MMC_GET_EVENT[10l] = { (unsigned char)0x4A, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0x7e, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)8, (unsigned char)0 };
// MMC_GET_LEADTEXT
// file libburn/mmc.c line 198
static unsigned char MMC_GET_LEADTEXT[10l] = { (unsigned char)0x43, (unsigned char)2, (unsigned char)5, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)4, (unsigned char)0, (unsigned char)0 };
// MMC_GET_MSINFO
// file libburn/mmc.c line 193
static unsigned char MMC_GET_MSINFO[10l] = { (unsigned char)0x43, (unsigned char)0, (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_GET_PERFORMANCE
// file libburn/mmc.c line 236
static unsigned char MMC_GET_PERFORMANCE[12l] = { (unsigned char)0xAC, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_GET_TOC
// file libburn/mmc.c line 195
static unsigned char MMC_GET_TOC[10l] = { (unsigned char)0x43, (unsigned char)2, (unsigned char)2, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_GET_TOC_FMT0
// file libburn/mmc.c line 196
static unsigned char MMC_GET_TOC_FMT0[10l] = { (unsigned char)0x43, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_READ_10
// file libburn/mmc.c line 248
static unsigned char MMC_READ_10[10l] = { (unsigned char)0x28, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_READ_BUFFER_CAPACITY
// file libburn/mmc.c line 223
static unsigned char MMC_READ_BUFFER_CAPACITY[10l] = { (unsigned char)0x5C, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_READ_CAPACITY
// file libburn/mmc.c line 252
static unsigned char MMC_READ_CAPACITY[10l] = { (unsigned char)0x25, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_READ_CD
// file libburn/mmc.c line 201
static unsigned char MMC_READ_CD[12l] = { (unsigned char)0xBE, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_READ_CD_MSF
// file libburn/mmc.c line 262
static unsigned char MMC_READ_CD_MSF[12l] = { (unsigned char)0xB9, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_READ_DISC_STRUCTURE
// file libburn/mmc.c line 257
static unsigned char MMC_READ_DISC_STRUCTURE[12l] = { (unsigned char)0xAD, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_READ_FORMAT_CAPACITIES
// file libburn/mmc.c line 240
static unsigned char MMC_READ_FORMAT_CAPACITIES[10l] = { (unsigned char)0x23, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_RESERVE_TRACK
// file libburn/mmc.c line 244
static unsigned char MMC_RESERVE_TRACK[10l] = { (unsigned char)0x53, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_SEND_CUE_SHEET
// file libburn/mmc.c line 219
static unsigned char MMC_SEND_CUE_SHEET[10l] = { (unsigned char)0x5D, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_SEND_OPC
// file libburn/mmc.c line 203
static unsigned char MMC_SEND_OPC[10l] = { (unsigned char)0x54, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_SET_SPEED
// file libburn/mmc.c line 204
static unsigned char MMC_SET_SPEED[12l] = { (unsigned char)0xBB, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_SET_STREAMING
// file libburn/mmc.c line 231
static unsigned char MMC_SET_STREAMING[12l] = { (unsigned char)0xB6, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_SYNC_CACHE
// file libburn/mmc.c line 214
static unsigned char MMC_SYNC_CACHE[10l] = { (unsigned char)0x35, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_TRACK_INFO
// file libburn/mmc.c line 217
static unsigned char MMC_TRACK_INFO[10l] = { (unsigned char)0x52, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// MMC_WRITE_10
// file libburn/mmc.c line 208
static unsigned char MMC_WRITE_10[10l] = { (unsigned char)0x2A, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// MMC_WRITE_12
// file libburn/mmc.c line 206
static unsigned char MMC_WRITE_12[12l] = { (unsigned char)0xAA, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// SBC_LOAD
// file libburn/sbc.c line 50
static unsigned char SBC_LOAD[6l] = { (unsigned char)0x1b, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)3, (unsigned char)0 };
// SBC_START_UNIT
// file libburn/sbc.c line 52
static unsigned char SBC_START_UNIT[6l] = { (unsigned char)0x1b, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 };
// SBC_STOP_UNIT
// file libburn/sbc.c line 53
static unsigned char SBC_STOP_UNIT[6l] = { (unsigned char)0x1b, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// SBC_UNLOAD
// file libburn/sbc.c line 51
static unsigned char SBC_UNLOAD[6l] = { (unsigned char)0x1b, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)2, (unsigned char)0 };
// SPC_ALLOW
// file libburn/spc.c line 56
static unsigned char SPC_ALLOW[6l] = { (unsigned char)0x1e, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// SPC_INQUIRY
// file libburn/spc.c line 52
static unsigned char SPC_INQUIRY[6l] = { (unsigned char)0x12, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)36, (unsigned char)0 };
// SPC_MODE_SELECT
// file libburn/spc.c line 58
static unsigned char SPC_MODE_SELECT[10l] = { (unsigned char)0x55, (unsigned char)16, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// SPC_MODE_SENSE
// file libburn/spc.c line 57
static unsigned char SPC_MODE_SENSE[10l] = { (unsigned char)0x5a, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)16, (unsigned char)0, (unsigned char)0 };
// SPC_PREVENT
// file libburn/spc.c line 55
static unsigned char SPC_PREVENT[6l] = { (unsigned char)0x1e, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)0 };
// SPC_REQUEST_SENSE
// file libburn/spc.c line 59
static unsigned char SPC_REQUEST_SENSE[6l] = { (unsigned char)0x03, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)18, (unsigned char)0 };
// SPC_TEST_UNIT_READY
// file libburn/spc.c line 60
static unsigned char SPC_TEST_UNIT_READY[6l] = { (unsigned char)0x00, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// abort_control_pid
// file libburn/init.c line 91
static signed int abort_control_pid = 0;
// abort_control_thread
// file libburn/init.c line 92
static unsigned long int abort_control_thread;
// abort_message_prefix
// file libburn/init.c line 90
static char abort_message_prefix[81l] = { 'l', 'i', 'b', 'b', 'u', 'r', 'n', ' ', ':', ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// burn_builtin_signal_action
// file libburn/init.c line 97
signed int burn_builtin_signal_action = 0;
// burn_builtin_triggered_action
// file libburn/init.c line 98
volatile signed int burn_builtin_triggered_action = 0;
// burn_drive_role_4_allowed
// file libburn/init.c line 117
signed int burn_drive_role_4_allowed = 0;
// burn_global_abort_level
// file libburn/init.c line 93
volatile signed int burn_global_abort_level = 0;
// burn_global_abort_signum
// file libburn/init.c line 94
signed int burn_global_abort_signum = 0;
// burn_global_signal_handle
// file libburn/init.c line 95
void *burn_global_signal_handle = (void *)0;
// burn_global_signal_handler
// file libburn/init.c line 96
signed int (*burn_global_signal_handler)(void *, signed int, signed int) = (signed int (*)(void *, signed int, signed int))(void *)0;
// burn_running
// file libburn/init.c line 45
signed int burn_running = 0;
// burn_sg_fcntl_f_setlk
// file libburn/init.c line 57
signed int burn_sg_fcntl_f_setlk = 1;
// burn_sg_log_scsi
// file libburn/init.c line 110
signed int burn_sg_log_scsi = 0;
// burn_sg_open_abort_busy
// file libburn/init.c line 77
signed int burn_sg_open_abort_busy = 0;
// burn_sg_open_o_excl
// file libburn/init.c line 53
signed int burn_sg_open_o_excl = 1;
// burn_sg_open_o_nonblock
// file libburn/init.c line 72
signed int burn_sg_open_o_nonblock = 1;
// burn_sg_use_family
// file libburn/init.c line 66
signed int burn_sg_use_family = 0;
// burn_support_untested_profiles
// file libburn/init.c line 102
signed int burn_support_untested_profiles = 0;
// burn_verbosity
// file libburn/debug.c line 21
static signed int burn_verbosity = 0;
// cd_is_audio
// file test/telltoc.c line 84
static signed int cd_is_audio = 0;
// cleanup_app_handle
// file libburn/cleanup.c line 85
static void *cleanup_app_handle = (void *)0;
// cleanup_app_handler
// file libburn/cleanup.c line 86
static signed int (*cleanup_app_handler)(void *, signed int, signed int) = (signed int (*)(void *, signed int, signed int))(void *)0;
// cleanup_exiting
// file libburn/cleanup.c line 82
static signed int cleanup_exiting = 0;
// cleanup_has_reported
// file libburn/cleanup.c line 83
static signed int cleanup_has_reported = -1234567890;
// cleanup_msg
// file libburn/cleanup.c line 81
static char cleanup_msg[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// cleanup_perform_app_handler_first
// file libburn/cleanup.c line 87
static signed int cleanup_perform_app_handler_first = 0;
// do_capacities
// file test/telltoc.c line 798
static signed int do_capacities = 0;
// do_media
// file test/telltoc.c line 794
static signed int do_media = 0;
// do_msinfo
// file test/telltoc.c line 796
static signed int do_msinfo = 0;
// do_toc
// file test/telltoc.c line 795
static signed int do_toc = 0;
// drive_adr
// file test/telltoc.c line 792
static char drive_adr[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// drive_array
// file libburn/drive.c line 64
static struct burn_drive drive_array[255l];
// drive_count
// file test/telltoc.c line 68
static unsigned int drive_count;
// drive_is_grabbed
// file test/telltoc.c line 72
static signed int drive_is_grabbed = 0;
// drive_list
// file test/telltoc.c line 64
static struct burn_drive_info *drive_list;
// driveno
// file test/telltoc.c line 793
static signed int driveno = 0;
// drivetop
// file libburn/drive.c line 65
static signed int drivetop = -1;
// ecma_130_annex_b
// file libburn/ecma130ab.c line 280
static unsigned char ecma_130_annex_b[2340l] = { (unsigned char)1, (unsigned char)128, (unsigned char)0, (unsigned char)96, (unsigned char)0, (unsigned char)40, (unsigned char)0, (unsigned char)30, (unsigned char)128, (unsigned char)8, (unsigned char)96, (unsigned char)6, (unsigned char)168, (unsigned char)2, (unsigned char)254, (unsigned char)129, (unsigned char)128, (unsigned char)96, (unsigned char)96, (unsigned char)40, (unsigned char)40, (unsigned char)30, (unsigned char)158, (unsigned char)136, (unsigned char)104, (unsigned char)102, (unsigned char)174, (unsigned char)170, (unsigned char)252, (unsigned char)127, (unsigned char)1, (unsigned char)224, (unsigned char)0, (unsigned char)72, (unsigned char)0, (unsigned char)54, (unsigned char)128, (unsigned char)22, (unsigned char)224, (unsigned char)14, (unsigned char)200, (unsigned char)4, (unsigned char)86, (unsigned char)131, (unsigned char)126, (unsigned char)225, (unsigned char)224, (unsigned char)72, (unsigned char)72, (unsigned char)54, (unsigned char)182, (unsigned char)150, (unsigned char)246, (unsigned char)238, (unsigned char)198, (unsigned char)204, (unsigned char)82, (unsigned char)213, (unsigned char)253, (unsigned char)159, (unsigned char)1, (unsigned char)168, (unsigned char)0, (unsigned char)126, (unsigned char)128, (unsigned char)32, (unsigned char)96, (unsigned char)24, (unsigned char)40, (unsigned char)10, (unsigned char)158, (unsigned char)135, (unsigned char)40, (unsigned char)98, (unsigned char)158, (unsigned char)169, (unsigned char)168, (unsigned char)126, (unsigned char)254, (unsigned char)160, (unsigned char)64, (unsigned char)120, (unsigned char)48, (unsigned char)34, (unsigned char)148, (unsigned char)25, (unsigned char)175, (unsigned char)74, (unsigned char)252, (unsigned char)55, (unsigned char)1, (unsigned char)214, (unsigned char)128, (unsigned char)94, (unsigned char)224, (unsigned char)56, (unsigned char)72, (unsigned char)18, (unsigned char)182, (unsigned char)141, (unsigned char)182, (unsigned char)229, (unsigned char)182, (unsigned char)203, (unsigned char)54, (unsigned char)215, (unsigned char)86, (unsigned char)222, (unsigned char)190, (unsigned char)216, (unsigned char)112, (unsigned char)90, (unsigned char)164, (unsigned char)59, (unsigned char)59, (unsigned char)83, (unsigned char)83, (unsigned char)125, (unsigned char)253, (unsigned char)225, (unsigned char)129, (unsigned char)136, (unsigned char)96, (unsigned char)102, (unsigned char)168, (unsigned char)42, (unsigned char)254, (unsigned char)159, (unsigned char)0, (unsigned char)104, (unsigned char)0, (unsigned char)46, (unsigned char)128, (unsigned char)28, (unsigned char)96, (unsigned char)9, (unsigned char)232, (unsigned char)6, (unsigned char)206, (unsigned char)130, (unsigned char)212, (unsigned char)97, (unsigned char)159, (unsigned char)104, (unsigned char)104, (unsigned char)46, (unsigned char)174, (unsigned char)156, (unsigned char)124, (unsigned char)105, (unsigned char)225, (unsigned char)238, (unsigned char)200, (unsigned char)76, (unsigned char)86, (unsigned char)181, (unsigned char)254, (unsigned char)247, (unsigned char)0, (unsigned char)70, (unsigned char)128, (unsigned char)50, (unsigned char)224, (unsigned char)21, (unsigned char)136, (unsigned char)15, (unsigned char)38, (unsigned char)132, (unsigned char)26, (unsigned char)227, (unsigned char)75, (unsigned char)9, (unsigned char)247, (unsigned char)70, (unsigned char)198, (unsigned char)178, (unsigned char)210, (unsigned char)245, (unsigned char)157, (unsigned char)135, (unsigned char)41, (unsigned char)162, (unsigned char)158, (unsigned char)249, (unsigned char)168, (unsigned char)66, (unsigned char)254, (unsigned char)177, (unsigned char)128, (unsigned char)116, (unsigned char)96, (unsigned char)39, (unsigned char)104, (unsigned char)26, (unsigned char)174, (unsigned char)139, (unsigned char)60, (unsigned char)103, (unsigned char)81, (unsigned char)234, (unsigned char)188, (unsigned char)79, (unsigned char)49, (unsigned char)244, (unsigned char)20, (unsigned char)71, (unsigned char)79, (unsigned char)114, (unsigned char)180, (unsigned char)37, (unsigned char)183, (unsigned char)91, (unsigned char)54, (unsigned char)187, (unsigned char)86, (unsigned char)243, (unsigned char)126, (unsigned char)197, (unsigned char)224, (unsigned char)83, (unsigned char)8, (unsigned char)61, (unsigned char)198, (unsigned char)145, (unsigned char)146, (unsigned char)236, (unsigned char)109, (unsigned char)141, (unsigned char)237, (unsigned char)165, (unsigned char)141, (unsigned char)187, (unsigned char)37, (unsigned char)179, (unsigned char)91, (unsigned char)53, (unsigned char)251, (unsigned char)87, (unsigned char)3, (unsigned char)126, (unsigned char)129, (unsigned char)224, (unsigned char)96, (unsigned char)72, (unsigned char)40, (unsigned char)54, (unsigned char)158, (unsigned char)150, (unsigned char)232, (unsigned char)110, (unsigned char)206, (unsigned char)172, (unsigned char)84, (unsigned char)125, (unsigned char)255, (unsigned char)97, (unsigned char)128, (unsigned char)40, (unsigned char)96, (unsigned char)30, (unsigned char)168, (unsigned char)8, (unsigned char)126, (unsigned char)134, (unsigned char)160, (unsigned char)98, (unsigned char)248, (unsigned char)41, (unsigned char)130, (unsigned char)158, (unsigned char)225, (unsigned char)168, (unsigned char)72, (unsigned char)126, (unsigned char)182, (unsigned char)160, (unsigned char)118, (unsigned char)248, (unsigned char)38, (unsigned char)194, (unsigned char)154, (unsigned char)209, (unsigned char)171, (unsigned char)28, (unsigned char)127, (unsigned char)73, (unsigned char)224, (unsigned char)54, (unsigned char)200, (unsigned char)22, (unsigned char)214, (unsigned char)142, (unsigned char)222, (unsigned char)228, (unsigned char)88, (unsigned char)75, (unsigned char)122, (unsigned char)183, (unsigned char)99, (unsigned char)54, (unsigned char)169, (unsigned char)214, (unsigned char)254, (unsigned char)222, (unsigned char)192, (unsigned char)88, (unsigned char)80, (unsigned char)58, (unsigned char)188, (unsigned char)19, (unsigned char)49, (unsigned char)205, (unsigned char)212, (unsigned char)85, (unsigned char)159, (unsigned char)127, (unsigned char)40, (unsigned char)32, (unsigned char)30, (unsigned char)152, (unsigned char)8, (unsigned char)106, (unsigned char)134, (unsigned char)175, (unsigned char)34, (unsigned char)252, (unsigned char)25, (unsigned char)129, (unsigned char)202, (unsigned char)224, (unsigned char)87, (unsigned char)8, (unsigned char)62, (unsigned char)134, (unsigned char)144, (unsigned char)98, (unsigned char)236, (unsigned char)41, (unsigned char)141, (unsigned char)222, (unsigned char)229, (unsigned char)152, (unsigned char)75, (unsigned char)42, (unsigned char)183, (unsigned char)95, (unsigned char)54, (unsigned char)184, (unsigned char)22, (unsigned char)242, (unsigned char)142, (unsigned char)197, (unsigned char)164, (unsigned char)83, (unsigned char)59, (unsigned char)125, (unsigned char)211, (unsigned char)97, (unsigned char)157, (unsigned char)232, (unsigned char)105, (unsigned char)142, (unsigned char)174, (unsigned char)228, (unsigned char)124, (unsigned char)75, (unsigned char)97, (unsigned char)247, (unsigned char)104, (unsigned char)70, (unsigned char)174, (unsigned char)178, (unsigned char)252, (unsigned char)117, (unsigned char)129, (unsigned char)231, (unsigned char)32, (unsigned char)74, (unsigned char)152, (unsigned char)55, (unsigned char)42, (unsigned char)150, (unsigned char)159, (unsigned char)46, (unsigned char)232, (unsigned char)28, (unsigned char)78, (unsigned char)137, (unsigned char)244, (unsigned char)102, (unsigned char)199, (unsigned char)106, (unsigned char)210, (unsigned char)175, (unsigned char)29, (unsigned char)188, (unsigned char)9, (unsigned char)177, (unsigned char)198, (unsigned char)244, (unsigned char)82, (unsigned char)199, (unsigned char)125, (unsigned char)146, (unsigned char)161, (unsigned char)173, (unsigned char)184, (unsigned char)125, (unsigned char)178, (unsigned char)161, (unsigned char)181, (unsigned char)184, (unsigned char)119, (unsigned char)50, (unsigned char)166, (unsigned char)149, (unsigned char)186, (unsigned char)239, (unsigned char)51, (unsigned char)12, (unsigned char)21, (unsigned char)197, (unsigned char)207, (unsigned char)19, (unsigned char)20, (unsigned char)13, (unsigned char)207, (unsigned char)69, (unsigned char)148, (unsigned char)51, (unsigned char)47, (unsigned char)85, (unsigned char)220, (unsigned char)63, (unsigned char)25, (unsigned char)208, (unsigned char)10, (unsigned char)220, (unsigned char)7, (unsigned char)25, (unsigned char)194, (unsigned char)138, (unsigned char)209, (unsigned char)167, (unsigned char)28, (unsigned char)122, (unsigned char)137, (unsigned char)227, (unsigned char)38, (unsigned char)201, (unsigned char)218, (unsigned char)214, (unsigned char)219, (unsigned char)30, (unsigned char)219, (unsigned char)72, (unsigned char)91, (unsigned char)118, (unsigned char)187, (unsigned char)102, (unsigned char)243, (unsigned char)106, (unsigned char)197, (unsigned char)239, (unsigned char)19, (unsigned char)12, (unsigned char)13, (unsigned char)197, (unsigned char)197, (unsigned char)147, (unsigned char)19, (unsigned char)45, (unsigned char)205, (unsigned char)221, (unsigned char)149, (unsigned char)153, (unsigned char)175, (unsigned char)42, (unsigned char)252, (unsigned char)31, (unsigned char)1, (unsigned char)200, (unsigned char)0, (unsigned char)86, (unsigned char)128, (unsigned char)62, (unsigned char)224, (unsigned char)16, (unsigned char)72, (unsigned char)12, (unsigned char)54, (unsigned char)133, (unsigned char)214, (unsigned char)227, (unsigned char)30, (unsigned char)201, (unsigned char)200, (unsigned char)86, (unsigned char)214, (unsigned char)190, (unsigned char)222, (unsigned char)240, (unsigned char)88, (unsigned char)68, (unsigned char)58, (unsigned char)179, (unsigned char)83, (unsigned char)53, (unsigned char)253, (unsigned char)215, (unsigned char)1, (unsigned char)158, (unsigned char)128, (unsigned char)104, (unsigned char)96, (unsigned char)46, (unsigned char)168, (unsigned char)28, (unsigned char)126, (unsigned char)137, (unsigned char)224, (unsigned char)102, (unsigned char)200, (unsigned char)42, (unsigned char)214, (unsigned char)159, (unsigned char)30, (unsigned char)232, (unsigned char)8, (unsigned char)78, (unsigned char)134, (unsigned char)180, (unsigned char)98, (unsigned char)247, (unsigned char)105, (unsigned char)134, (unsigned char)174, (unsigned char)226, (unsigned char)252, (unsigned char)73, (unsigned char)129, (unsigned char)246, (unsigned char)224, (unsigned char)70, (unsigned char)200, (unsigned char)50, (unsigned char)214, (unsigned char)149, (unsigned char)158, (unsigned char)239, (unsigned char)40, (unsigned char)76, (unsigned char)30, (unsigned char)181, (unsigned char)200, (unsigned char)119, (unsigned char)22, (unsigned char)166, (unsigned char)142, (unsigned char)250, (unsigned char)228, (unsigned char)67, (unsigned char)11, (unsigned char)113, (unsigned char)199, (unsigned char)100, (unsigned char)82, (unsigned char)171, (unsigned char)125, (unsigned char)191, (unsigned char)97, (unsigned char)176, (unsigned char)40, (unsigned char)116, (unsigned char)30, (unsigned char)167, (unsigned char)72, (unsigned char)122, (unsigned char)182, (unsigned char)163, (unsigned char)54, (unsigned char)249, (unsigned char)214, (unsigned char)194, (unsigned char)222, (unsigned char)209, (unsigned char)152, (unsigned char)92, (unsigned char)106, (unsigned char)185, (unsigned char)239, (unsigned char)50, (unsigned char)204, (unsigned char)21, (unsigned char)149, (unsigned char)207, (unsigned char)47, (unsigned char)20, (unsigned char)28, (unsigned char)15, (unsigned char)73, (unsigned char)196, (unsigned char)54, (unsigned char)211, (unsigned char)86, (unsigned char)221, (unsigned char)254, (unsigned char)217, (unsigned char)128, (unsigned char)90, (unsigned char)224, (unsigned char)59, (unsigned char)8, (unsigned char)19, (unsigned char)70, (unsigned char)141, (unsigned char)242, (unsigned char)229, (unsigned char)133, (unsigned char)139, (unsigned char)35, (unsigned char)39, (unsigned char)89, (unsigned char)218, (unsigned char)186, (unsigned char)219, (unsigned char)51, (unsigned char)27, (unsigned char)85, (unsigned char)203, (unsigned char)127, (unsigned char)23, (unsigned char)96, (unsigned char)14, (unsigned char)168, (unsigned char)4, (unsigned char)126, (unsigned char)131, (unsigned char)96, (unsigned char)97, (unsigned char)232, (unsigned char)40, (unsigned char)78, (unsigned char)158, (unsigned char)180, (unsigned char)104, (unsigned char)119, (unsigned char)110, (unsigned char)166, (unsigned char)172, (unsigned char)122, (unsigned char)253, (unsigned char)227, (unsigned char)1, (unsigned char)137, (unsigned char)192, (unsigned char)102, (unsigned char)208, (unsigned char)42, (unsigned char)220, (unsigned char)31, (unsigned char)25, (unsigned char)200, (unsigned char)10, (unsigned char)214, (unsigned char)135, (unsigned char)30, (unsigned char)226, (unsigned char)136, (unsigned char)73, (unsigned char)166, (unsigned char)182, (unsigned char)250, (unsigned char)246, (unsigned char)195, (unsigned char)6, (unsigned char)209, (unsigned char)194, (unsigned char)220, (unsigned char)81, (unsigned char)153, (unsigned char)252, (unsigned char)106, (unsigned char)193, (unsigned char)239, (unsigned char)16, (unsigned char)76, (unsigned char)12, (unsigned char)53, (unsigned char)197, (unsigned char)215, (unsigned char)19, (unsigned char)30, (unsigned char)141, (unsigned char)200, (unsigned char)101, (unsigned char)150, (unsigned char)171, (unsigned char)46, (unsigned char)255, (unsigned char)92, (unsigned char)64, (unsigned char)57, (unsigned char)240, (unsigned char)18, (unsigned char)196, (unsigned char)13, (unsigned char)147, (unsigned char)69, (unsigned char)173, (unsigned char)243, (unsigned char)61, (unsigned char)133, (unsigned char)209, (unsigned char)163, (unsigned char)28, (unsigned char)121, (unsigned char)201, (unsigned char)226, (unsigned char)214, (unsigned char)201, (unsigned char)158, (unsigned char)214, (unsigned char)232, (unsigned char)94, (unsigned char)206, (unsigned char)184, (unsigned char)84, (unsigned char)114, (unsigned char)191, (unsigned char)101, (unsigned char)176, (unsigned char)43, (unsigned char)52, (unsigned char)31, (unsigned char)87, (unsigned char)72, (unsigned char)62, (unsigned char)182, (unsigned char)144, (unsigned char)118, (unsigned char)236, (unsigned char)38, (unsigned char)205, (unsigned char)218, (unsigned char)213, (unsigned char)155, (unsigned char)31, (unsigned char)43, (unsigned char)72, (unsigned char)31, (unsigned char)118, (unsigned char)136, (unsigned char)38, (unsigned char)230, (unsigned char)154, (unsigned char)202, (unsigned char)235, (unsigned char)23, (unsigned char)15, (unsigned char)78, (unsigned char)132, (unsigned char)52, (unsigned char)99, (unsigned char)87, (unsigned char)105, (unsigned char)254, (unsigned char)174, (unsigned char)192, (unsigned char)124, (unsigned char)80, (unsigned char)33, (unsigned char)252, (unsigned char)24, (unsigned char)65, (unsigned char)202, (unsigned char)176, (unsigned char)87, (unsigned char)52, (unsigned char)62, (unsigned char)151, (unsigned char)80, (unsigned char)110, (unsigned char)188, (unsigned char)44, (unsigned char)113, (unsigned char)221, (unsigned char)228, (unsigned char)89, (unsigned char)139, (unsigned char)122, (unsigned char)231, (unsigned char)99, (unsigned char)10, (unsigned char)169, (unsigned char)199, (unsigned char)62, (unsigned char)210, (unsigned char)144, (unsigned char)93, (unsigned char)172, (unsigned char)57, (unsigned char)189, (unsigned char)210, (unsigned char)241, (unsigned char)157, (unsigned char)132, (unsigned char)105, (unsigned char)163, (unsigned char)110, (unsigned char)249, (unsigned char)236, (unsigned char)66, (unsigned char)205, (unsigned char)241, (unsigned char)149, (unsigned char)132, (unsigned char)111, (unsigned char)35, (unsigned char)108, (unsigned char)25, (unsigned char)237, (unsigned char)202, (unsigned char)205, (unsigned char)151, (unsigned char)21, (unsigned char)174, (unsigned char)143, (unsigned char)60, (unsigned char)100, (unsigned char)17, (unsigned char)235, (unsigned char)76, (unsigned char)79, (unsigned char)117, (unsigned char)244, (unsigned char)39, (unsigned char)7, (unsigned char)90, (unsigned char)130, (unsigned char)187, (unsigned char)33, (unsigned char)179, (unsigned char)88, (unsigned char)117, (unsigned char)250, (unsigned char)167, (unsigned char)3, (unsigned char)58, (unsigned char)129, (unsigned char)211, (unsigned char)32, (unsigned char)93, (unsigned char)216, (unsigned char)57, (unsigned char)154, (unsigned char)146, (unsigned char)235, (unsigned char)45, (unsigned char)143, (unsigned char)93, (unsigned char)164, (unsigned char)57, (unsigned char)187, (unsigned char)82, (unsigned char)243, (unsigned char)125, (unsigned char)133, (unsigned char)225, (unsigned char)163, (unsigned char)8, (unsigned char)121, (unsigned char)198, (unsigned char)162, (unsigned char)210, (unsigned char)249, (unsigned char)157, (unsigned char)130, (unsigned char)233, (unsigned char)161, (unsigned char)142, (unsigned char)248, (unsigned char)100, (unsigned char)66, (unsigned char)171, (unsigned char)113, (unsigned char)191, (unsigned char)100, (unsigned char)112, (unsigned char)43, (unsigned char)100, (unsigned char)31, (unsigned char)107, (unsigned char)72, (unsigned char)47, (unsigned char)118, (unsigned char)156, (unsigned char)38, (unsigned char)233, (unsigned char)218, (unsigned char)206, (unsigned char)219, (unsigned char)20, (unsigned char)91, (unsigned char)79, (unsigned char)123, (unsigned char)116, (unsigned char)35, (unsigned char)103, (unsigned char)89, (unsigned char)234, (unsigned char)186, (unsigned char)207, (unsigned char)51, (unsigned char)20, (unsigned char)21, (unsigned char)207, (unsigned char)79, (unsigned char)20, (unsigned char)52, (unsigned char)15, (unsigned char)87, (unsigned char)68, (unsigned char)62, (unsigned char)179, (unsigned char)80, (unsigned char)117, (unsigned char)252, (unsigned char)39, (unsigned char)1, (unsigned char)218, (unsigned char)128, (unsigned char)91, (unsigned char)32, (unsigned char)59, (unsigned char)88, (unsigned char)19, (unsigned char)122, (unsigned char)141, (unsigned char)227, (unsigned char)37, (unsigned char)137, (unsigned char)219, (unsigned char)38, (unsigned char)219, (unsigned char)90, (unsigned char)219, (unsigned char)123, (unsigned char)27, (unsigned char)99, (unsigned char)75, (unsigned char)105, (unsigned char)247, (unsigned char)110, (unsigned char)198, (unsigned char)172, (unsigned char)82, (unsigned char)253, (unsigned char)253, (unsigned char)129, (unsigned char)129, (unsigned char)160, (unsigned char)96, (unsigned char)120, (unsigned char)40, (unsigned char)34, (unsigned char)158, (unsigned char)153, (unsigned char)168, (unsigned char)106, (unsigned char)254, (unsigned char)175, (unsigned char)0, (unsigned char)124, (unsigned char)0, (unsigned char)33, (unsigned char)192, (unsigned char)24, (unsigned char)80, (unsigned char)10, (unsigned char)188, (unsigned char)7, (unsigned char)49, (unsigned char)194, (unsigned char)148, (unsigned char)81, (unsigned char)175, (unsigned char)124, (unsigned char)124, (unsigned char)33, (unsigned char)225, (unsigned char)216, (unsigned char)72, (unsigned char)90, (unsigned char)182, (unsigned char)187, (unsigned char)54, (unsigned char)243, (unsigned char)86, (unsigned char)197, (unsigned char)254, (unsigned char)211, (unsigned char)0, (unsigned char)93, (unsigned char)192, (unsigned char)57, (unsigned char)144, (unsigned char)18, (unsigned char)236, (unsigned char)13, (unsigned char)141, (unsigned char)197, (unsigned char)165, (unsigned char)147, (unsigned char)59, (unsigned char)45, (unsigned char)211, (unsigned char)93, (unsigned char)157, (unsigned char)249, (unsigned char)169, (unsigned char)130, (unsigned char)254, (unsigned char)225, (unsigned char)128, (unsigned char)72, (unsigned char)96, (unsigned char)54, (unsigned char)168, (unsigned char)22, (unsigned char)254, (unsigned char)142, (unsigned char)192, (unsigned char)100, (unsigned char)80, (unsigned char)43, (unsigned char)124, (unsigned char)31, (unsigned char)97, (unsigned char)200, (unsigned char)40, (unsigned char)86, (unsigned char)158, (unsigned char)190, (unsigned char)232, (unsigned char)112, (unsigned char)78, (unsigned char)164, (unsigned char)52, (unsigned char)123, (unsigned char)87, (unsigned char)99, (unsigned char)126, (unsigned char)169, (unsigned char)224, (unsigned char)126, (unsigned char)200, (unsigned char)32, (unsigned char)86, (unsigned char)152, (unsigned char)62, (unsigned char)234, (unsigned char)144, (unsigned char)79, (unsigned char)44, (unsigned char)52, (unsigned char)29, (unsigned char)215, (unsigned char)73, (unsigned char)158, (unsigned char)182, (unsigned char)232, (unsigned char)118, (unsigned char)206, (unsigned char)166, (unsigned char)212, (unsigned char)122, (unsigned char)223, (unsigned char)99, (unsigned char)24, (unsigned char)41, (unsigned char)202, (unsigned char)158, (unsigned char)215, (unsigned char)40, (unsigned char)94, (unsigned char)158, (unsigned char)184, (unsigned char)104, (unsigned char)114, (unsigned char)174, (unsigned char)165, (unsigned char)188, (unsigned char)123, (unsigned char)49, (unsigned char)227, (unsigned char)84, (unsigned char)73, (unsigned char)255, (unsigned char)118, (unsigned char)192, (unsigned char)38, (unsigned char)208, (unsigned char)26, (unsigned char)220, (unsigned char)11, (unsigned char)25, (unsigned char)199, (unsigned char)74, (unsigned char)210, (unsigned char)183, (unsigned char)29, (unsigned char)182, (unsigned char)137, (unsigned char)182, (unsigned char)230, (unsigned char)246, (unsigned char)202, (unsigned char)198, (unsigned char)215, (unsigned char)18, (unsigned char)222, (unsigned char)141, (unsigned char)152, (unsigned char)101, (unsigned char)170, (unsigned char)171, (unsigned char)63, (unsigned char)63, (unsigned char)80, (unsigned char)16, (unsigned char)60, (unsigned char)12, (unsigned char)17, (unsigned char)197, (unsigned char)204, (unsigned char)83, (unsigned char)21, (unsigned char)253, (unsigned char)207, (unsigned char)1, (unsigned char)148, (unsigned char)0, (unsigned char)111, (unsigned char)64, (unsigned char)44, (unsigned char)48, (unsigned char)29, (unsigned char)212, (unsigned char)9, (unsigned char)159, (unsigned char)70, (unsigned char)232, (unsigned char)50, (unsigned char)206, (unsigned char)149, (unsigned char)148, (unsigned char)111, (unsigned char)47, (unsigned char)108, (unsigned char)28, (unsigned char)45, (unsigned char)201, (unsigned char)221, (unsigned char)150, (unsigned char)217, (unsigned char)174, (unsigned char)218, (unsigned char)252, (unsigned char)91, (unsigned char)1, (unsigned char)251, (unsigned char)64, (unsigned char)67, (unsigned char)112, (unsigned char)49, (unsigned char)228, (unsigned char)20, (unsigned char)75, (unsigned char)79, (unsigned char)119, (unsigned char)116, (unsigned char)38, (unsigned char)167, (unsigned char)90, (unsigned char)250, (unsigned char)187, (unsigned char)3, (unsigned char)51, (unsigned char)65, (unsigned char)213, (unsigned char)240, (unsigned char)95, (unsigned char)4, (unsigned char)56, (unsigned char)3, (unsigned char)82, (unsigned char)129, (unsigned char)253, (unsigned char)160, (unsigned char)65, (unsigned char)184, (unsigned char)48, (unsigned char)114, (unsigned char)148, (unsigned char)37, (unsigned char)175, (unsigned char)91, (unsigned char)60, (unsigned char)59, (unsigned char)81, (unsigned char)211, (unsigned char)124, (unsigned char)93, (unsigned char)225, (unsigned char)249, (unsigned char)136, (unsigned char)66, (unsigned char)230, (unsigned char)177, (unsigned char)138, (unsigned char)244, (unsigned char)103, (unsigned char)7, (unsigned char)106, (unsigned char)130, (unsigned char)175, (unsigned char)33, (unsigned char)188, (unsigned char)24, (unsigned char)113, (unsigned char)202, (unsigned char)164, (unsigned char)87, (unsigned char)59, (unsigned char)126, (unsigned char)147, (unsigned char)96, (unsigned char)109, (unsigned char)232, (unsigned char)45, (unsigned char)142, (unsigned char)157, (unsigned char)164, (unsigned char)105, (unsigned char)187, (unsigned char)110, (unsigned char)243, (unsigned char)108, (unsigned char)69, (unsigned char)237, (unsigned char)243, (unsigned char)13, (unsigned char)133, (unsigned char)197, (unsigned char)163, (unsigned char)19, (unsigned char)57, (unsigned char)205, (unsigned char)210, (unsigned char)213, (unsigned char)157, (unsigned char)159, (unsigned char)41, (unsigned char)168, (unsigned char)30, (unsigned char)254, (unsigned char)136, (unsigned char)64, (unsigned char)102, (unsigned char)176, (unsigned char)42, (unsigned char)244, (unsigned char)31, (unsigned char)7, (unsigned char)72, (unsigned char)2, (unsigned char)182, (unsigned char)129, (unsigned char)182, (unsigned char)224, (unsigned char)118, (unsigned char)200, (unsigned char)38, (unsigned char)214, (unsigned char)154, (unsigned char)222, (unsigned char)235, (unsigned char)24, (unsigned char)79, (unsigned char)74, (unsigned char)180, (unsigned char)55, (unsigned char)55, (unsigned char)86, (unsigned char)150, (unsigned char)190, (unsigned char)238, (unsigned char)240, (unsigned char)76, (unsigned char)68, (unsigned char)53, (unsigned char)243, (unsigned char)87, (unsigned char)5, (unsigned char)254, (unsigned char)131, (unsigned char)0, (unsigned char)97, (unsigned char)192, (unsigned char)40, (unsigned char)80, (unsigned char)30, (unsigned char)188, (unsigned char)8, (unsigned char)113, (unsigned char)198, (unsigned char)164, (unsigned char)82, (unsigned char)251, (unsigned char)125, (unsigned char)131, (unsigned char)97, (unsigned char)161, (unsigned char)232, (unsigned char)120, (unsigned char)78, (unsigned char)162, (unsigned char)180, (unsigned char)121, (unsigned char)183, (unsigned char)98, (unsigned char)246, (unsigned char)169, (unsigned char)134, (unsigned char)254, (unsigned char)226, (unsigned char)192, (unsigned char)73, (unsigned char)144, (unsigned char)54, (unsigned char)236, (unsigned char)22, (unsigned char)205, (unsigned char)206, (unsigned char)213, (unsigned char)148, (unsigned char)95, (unsigned char)47, (unsigned char)120, (unsigned char)28, (unsigned char)34, (unsigned char)137, (unsigned char)217, (unsigned char)166, (unsigned char)218, (unsigned char)250, (unsigned char)219, (unsigned char)3, (unsigned char)27, (unsigned char)65, (unsigned char)203, (unsigned char)112, (unsigned char)87, (unsigned char)100, (unsigned char)62, (unsigned char)171, (unsigned char)80, (unsigned char)127, (unsigned char)124, (unsigned char)32, (unsigned char)33, (unsigned char)216, (unsigned char)24, (unsigned char)90, (unsigned char)138, (unsigned char)187, (unsigned char)39, (unsigned char)51, (unsigned char)90, (unsigned char)149, (unsigned char)251, (unsigned char)47, (unsigned char)3, (unsigned char)92, (unsigned char)1, (unsigned char)249, (unsigned char)192, (unsigned char)66, (unsigned char)208, (unsigned char)49, (unsigned char)156, (unsigned char)20, (unsigned char)105, (unsigned char)207, (unsigned char)110, (unsigned char)212, (unsigned char)44, (unsigned char)95, (unsigned char)93, (unsigned char)248, (unsigned char)57, (unsigned char)130, (unsigned char)146, (unsigned char)225, (unsigned char)173, (unsigned char)136, (unsigned char)125, (unsigned char)166, (unsigned char)161, (unsigned char)186, (unsigned char)248, (unsigned char)115, (unsigned char)2, (unsigned char)165, (unsigned char)193, (unsigned char)187, (unsigned char)16, (unsigned char)115, (unsigned char)76, (unsigned char)37, (unsigned char)245, (unsigned char)219, (unsigned char)7, (unsigned char)27, (unsigned char)66, (unsigned char)139, (unsigned char)113, (unsigned char)167, (unsigned char)100, (unsigned char)122, (unsigned char)171, (unsigned char)99, (unsigned char)63, (unsigned char)105, (unsigned char)208, (unsigned char)46, (unsigned char)220, (unsigned char)28, (unsigned char)89, (unsigned char)201, (unsigned char)250, (unsigned char)214, (unsigned char)195, (unsigned char)30, (unsigned char)209, (unsigned char)200, (unsigned char)92, (unsigned char)86, (unsigned char)185, (unsigned char)254, (unsigned char)242, (unsigned char)192, (unsigned char)69, (unsigned char)144, (unsigned char)51, (unsigned char)44, (unsigned char)21, (unsigned char)221, (unsigned char)207, (unsigned char)25, (unsigned char)148, (unsigned char)10, (unsigned char)239, (unsigned char)71, (unsigned char)12, (unsigned char)50, (unsigned char)133, (unsigned char)213, (unsigned char)163, (unsigned char)31, (unsigned char)57, (unsigned char)200, (unsigned char)18, (unsigned char)214, (unsigned char)141, (unsigned char)158, (unsigned char)229, (unsigned char)168, (unsigned char)75, (unsigned char)62, (unsigned char)183, (unsigned char)80, (unsigned char)118, (unsigned char)188, (unsigned char)38, (unsigned char)241, (unsigned char)218, (unsigned char)196, (unsigned char)91, (unsigned char)19, (unsigned char)123, (unsigned char)77, (unsigned char)227, (unsigned char)117, (unsigned char)137, (unsigned char)231, (unsigned char)38, (unsigned char)202, (unsigned char)154, (unsigned char)215, (unsigned char)43, (unsigned char)30, (unsigned char)159, (unsigned char)72, (unsigned char)104, (unsigned char)54, (unsigned char)174, (unsigned char)150, (unsigned char)252, (unsigned char)110, (unsigned char)193, (unsigned char)236, (unsigned char)80, (unsigned char)77, (unsigned char)252, (unsigned char)53, (unsigned char)129, (unsigned char)215, (unsigned char)32, (unsigned char)94, (unsigned char)152, (unsigned char)56, (unsigned char)106, (unsigned char)146, (unsigned char)175, (unsigned char)45, (unsigned char)188, (unsigned char)29, (unsigned char)177, (unsigned char)201, (unsigned char)180, (unsigned char)86, (unsigned char)247, (unsigned char)126, (unsigned char)198, (unsigned char)160, (unsigned char)82, (unsigned char)248, (unsigned char)61, (unsigned char)130, (unsigned char)145, (unsigned char)161, (unsigned char)172, (unsigned char)120, (unsigned char)125, (unsigned char)226, (unsigned char)161, (unsigned char)137, (unsigned char)184, (unsigned char)102, (unsigned char)242, (unsigned char)170, (unsigned char)197, (unsigned char)191, (unsigned char)19, (unsigned char)48, (unsigned char)13, (unsigned char)212, (unsigned char)5, (unsigned char)159, (unsigned char)67, (unsigned char)40, (unsigned char)49, (unsigned char)222, (unsigned char)148, (unsigned char)88, (unsigned char)111, (unsigned char)122, (unsigned char)172, (unsigned char)35, (unsigned char)61, (unsigned char)217, (unsigned char)209, (unsigned char)154, (unsigned char)220, (unsigned char)107, (unsigned char)25, (unsigned char)239, (unsigned char)74, (unsigned char)204, (unsigned char)55, (unsigned char)21, (unsigned char)214, (unsigned char)143, (unsigned char)30, (unsigned char)228, (unsigned char)8, (unsigned char)75, (unsigned char)70, (unsigned char)183, (unsigned char)114, (unsigned char)246, (unsigned char)165, (unsigned char)134, (unsigned char)251, (unsigned char)34, (unsigned char)195, (unsigned char)89, (unsigned char)145, (unsigned char)250, (unsigned char)236, (unsigned char)67, (unsigned char)13, (unsigned char)241, (unsigned char)197, (unsigned char)132, (unsigned char)83, (unsigned char)35, (unsigned char)125, (unsigned char)217, (unsigned char)225, (unsigned char)154, (unsigned char)200, (unsigned char)107, (unsigned char)22, (unsigned char)175, (unsigned char)78, (unsigned char)252, (unsigned char)52, (unsigned char)65, (unsigned char)215, (unsigned char)112, (unsigned char)94, (unsigned char)164, (unsigned char)56, (unsigned char)123, (unsigned char)82, (unsigned char)163, (unsigned char)125, (unsigned char)185, (unsigned char)225, (unsigned char)178, (unsigned char)200, (unsigned char)117, (unsigned char)150, (unsigned char)167, (unsigned char)46, (unsigned char)250, (unsigned char)156, (unsigned char)67, (unsigned char)41, (unsigned char)241, (unsigned char)222, (unsigned char)196, (unsigned char)88, (unsigned char)83, (unsigned char)122, (unsigned char)189, (unsigned char)227, (unsigned char)49, (unsigned char)137, (unsigned char)212, (unsigned char)102, (unsigned char)223, (unsigned char)106, (unsigned char)216, (unsigned char)47, (unsigned char)26, (unsigned char)156, (unsigned char)11, (unsigned char)41, (unsigned char)199, (unsigned char)94, (unsigned char)210, (unsigned char)184, (unsigned char)93, (unsigned char)178, (unsigned char)185, (unsigned char)181, (unsigned char)178, (unsigned char)247, (unsigned char)53, (unsigned char)134, (unsigned char)151, (unsigned char)34, (unsigned char)238, (unsigned char)153, (unsigned char)140, (unsigned char)106, (unsigned char)229, (unsigned char)239, (unsigned char)11, (unsigned char)12, (unsigned char)7, (unsigned char)69, (unsigned char)194, (unsigned char)179, (unsigned char)17, (unsigned char)181, (unsigned char)204, (unsigned char)119, (unsigned char)21, (unsigned char)230, (unsigned char)143, (unsigned char)10, (unsigned char)228, (unsigned char)7, (unsigned char)11, (unsigned char)66, (unsigned char)135, (unsigned char)113, (unsigned char)162, (unsigned char)164, (unsigned char)121, (unsigned char)187, (unsigned char)98, (unsigned char)243, (unsigned char)105, (unsigned char)133, (unsigned char)238, (unsigned char)227, (unsigned char)12, (unsigned char)73, (unsigned char)197, (unsigned char)246, (unsigned char)211, (unsigned char)6, (unsigned char)221, (unsigned char)194, (unsigned char)217, (unsigned char)145, (unsigned char)154, (unsigned char)236, (unsigned char)107, (unsigned char)13, (unsigned char)239, (unsigned char)69, (unsigned char)140, (unsigned char)51, (unsigned char)37, (unsigned char)213, (unsigned char)219, (unsigned char)31, (unsigned char)27, (unsigned char)72, (unsigned char)11, (unsigned char)118, (unsigned char)135, (unsigned char)102, (unsigned char)226, (unsigned char)170, (unsigned char)201, (unsigned char)191, (unsigned char)22, (unsigned char)240, (unsigned char)14, (unsigned char)196, (unsigned char)4, (unsigned char)83, (unsigned char)67, (unsigned char)125, (unsigned char)241, (unsigned char)225, (unsigned char)132, (unsigned char)72, (unsigned char)99, (unsigned char)118, (unsigned char)169, (unsigned char)230, (unsigned char)254, (unsigned char)202, (unsigned char)192, (unsigned char)87, (unsigned char)16, (unsigned char)62, (unsigned char)140, (unsigned char)16, (unsigned char)101, (unsigned char)204, (unsigned char)43, (unsigned char)21, (unsigned char)223, (unsigned char)79, (unsigned char)24, (unsigned char)52, (unsigned char)10, (unsigned char)151, (unsigned char)71, (unsigned char)46, (unsigned char)178, (unsigned char)156, (unsigned char)117, (unsigned char)169, (unsigned char)231, (unsigned char)62, (unsigned char)202, (unsigned char)144, (unsigned char)87, (unsigned char)44, (unsigned char)62, (unsigned char)157, (unsigned char)208, (unsigned char)105, (unsigned char)156, (unsigned char)46, (unsigned char)233, (unsigned char)220, (unsigned char)78, (unsigned char)217, (unsigned char)244, (unsigned char)90, (unsigned char)199, (unsigned char)123, (unsigned char)18, (unsigned char)163, (unsigned char)77, (unsigned char)185, (unsigned char)245, (unsigned char)178, (unsigned char)199, (unsigned char)53, (unsigned char)146, (unsigned char)151, (unsigned char)45, (unsigned char)174, (unsigned char)157, (unsigned char)188, (unsigned char)105, (unsigned char)177, (unsigned char)238, (unsigned char)244, (unsigned char)76, (unsigned char)71, (unsigned char)117, (unsigned char)242, (unsigned char)167, (unsigned char)5, (unsigned char)186, (unsigned char)131, (unsigned char)51, (unsigned char)33, (unsigned char)213, (unsigned char)216, (unsigned char)95, (unsigned char)26, (unsigned char)184, (unsigned char)11, (unsigned char)50, (unsigned char)135, (unsigned char)85, (unsigned char)162, (unsigned char)191, (unsigned char)57, (unsigned char)176, (unsigned char)18, (unsigned char)244, (unsigned char)13, (unsigned char)135, (unsigned char)69, (unsigned char)162, (unsigned char)179, (unsigned char)57, (unsigned char)181, (unsigned char)210, (unsigned char)247, (unsigned char)29, (unsigned char)134, (unsigned char)137, (unsigned char)162, (unsigned char)230, (unsigned char)249, (unsigned char)138, (unsigned char)194, (unsigned char)231, (unsigned char)17, (unsigned char)138, (unsigned char)140, (unsigned char)103, (unsigned char)37, (unsigned char)234, (unsigned char)155, (unsigned char)15, (unsigned char)43, (unsigned char)68, (unsigned char)31, (unsigned char)115, (unsigned char)72, (unsigned char)37, (unsigned char)246, (unsigned char)155, (unsigned char)6, (unsigned char)235, (unsigned char)66, (unsigned char)207, (unsigned char)113, (unsigned char)148, (unsigned char)36, (unsigned char)111, (unsigned char)91, (unsigned char)108, (unsigned char)59, (unsigned char)109, (unsigned char)211, (unsigned char)109, (unsigned char)157, (unsigned char)237, (unsigned char)169, (unsigned char)141, (unsigned char)190, (unsigned char)229, (unsigned char)176, (unsigned char)75, (unsigned char)52, (unsigned char)55, (unsigned char)87, (unsigned char)86, (unsigned char)190, (unsigned char)190, (unsigned char)240, (unsigned char)112, (unsigned char)68, (unsigned char)36, (unsigned char)51, (unsigned char)91, (unsigned char)85, (unsigned char)251, (unsigned char)127, (unsigned char)3, (unsigned char)96, (unsigned char)1, (unsigned char)232, (unsigned char)0, (unsigned char)78, (unsigned char)128, (unsigned char)52, (unsigned char)96, (unsigned char)23, (unsigned char)104, (unsigned char)14, (unsigned char)174, (unsigned char)132, (unsigned char)124, (unsigned char)99, (unsigned char)97, (unsigned char)233, (unsigned char)232, (unsigned char)78, (unsigned char)206, (unsigned char)180, (unsigned char)84, (unsigned char)119, (unsigned char)127, (unsigned char)102, (unsigned char)160, (unsigned char)42, (unsigned char)248, (unsigned char)31, (unsigned char)2, (unsigned char)136, (unsigned char)1, (unsigned char)166, (unsigned char)128, (unsigned char)122, (unsigned char)224, (unsigned char)35, (unsigned char)8, (unsigned char)25, (unsigned char)198, (unsigned char)138, (unsigned char)210, (unsigned char)231, (unsigned char)29, (unsigned char)138, (unsigned char)137, (unsigned char)167, (unsigned char)38, (unsigned char)250, (unsigned char)154, (unsigned char)195, (unsigned char)43, (unsigned char)17, (unsigned char)223, (unsigned char)76, (unsigned char)88, (unsigned char)53, (unsigned char)250, (unsigned char)151, (unsigned char)3, (unsigned char)46, (unsigned char)129, (unsigned char)220, (unsigned char)96, (unsigned char)89, (unsigned char)232, (unsigned char)58, (unsigned char)206, (unsigned char)147, (unsigned char)20, (unsigned char)109, (unsigned char)207, (unsigned char)109, (unsigned char)148, (unsigned char)45, (unsigned char)175, (unsigned char)93, (unsigned char)188, (unsigned char)57, (unsigned char)177, (unsigned char)210, (unsigned char)244, (unsigned char)93, (unsigned char)135, (unsigned char)121, (unsigned char)162, (unsigned char)162, (unsigned char)249, (unsigned char)185, (unsigned char)130, (unsigned char)242, (unsigned char)225, (unsigned char)133, (unsigned char)136, (unsigned char)99, (unsigned char)38, (unsigned char)169, (unsigned char)218, (unsigned char)254, (unsigned char)219, (unsigned char)0, (unsigned char)91, (unsigned char)64, (unsigned char)59, (unsigned char)112, (unsigned char)19, (unsigned char)100, (unsigned char)13, (unsigned char)235, (unsigned char)69, (unsigned char)143, (unsigned char)115, (unsigned char)36, (unsigned char)37, (unsigned char)219, (unsigned char)91, (unsigned char)27, (unsigned char)123, (unsigned char)75, (unsigned char)99, (unsigned char)119, (unsigned char)105, (unsigned char)230, (unsigned char)174, (unsigned char)202, (unsigned char)252, (unsigned char)87, (unsigned char)1, (unsigned char)254, (unsigned char)128, (unsigned char)64, (unsigned char)96, (unsigned char)48, (unsigned char)40, (unsigned char)20, (unsigned char)30, (unsigned char)143, (unsigned char)72, (unsigned char)100, (unsigned char)54, (unsigned char)171, (unsigned char)86, (unsigned char)255, (unsigned char)126, (unsigned char)192, (unsigned char)32, (unsigned char)80, (unsigned char)24, (unsigned char)60, (unsigned char)10, (unsigned char)145, (unsigned char)199, (unsigned char)44, (unsigned char)82, (unsigned char)157, (unsigned char)253, (unsigned char)169, (unsigned char)129, (unsigned char)190, (unsigned char)224, (unsigned char)112, (unsigned char)72, (unsigned char)36, (unsigned char)54, (unsigned char)155, (unsigned char)86, (unsigned char)235, (unsigned char)126, (unsigned char)207, (unsigned char)96, (unsigned char)84, (unsigned char)40, (unsigned char)63, (unsigned char)94, (unsigned char)144, (unsigned char)56, (unsigned char)108, (unsigned char)18, (unsigned char)173, (unsigned char)205, (unsigned char)189, (unsigned char)149, (unsigned char)177, (unsigned char)175, (unsigned char)52, (unsigned char)124, (unsigned char)23, (unsigned char)97, (unsigned char)206, (unsigned char)168, (unsigned char)84, (unsigned char)126, (unsigned char)191, (unsigned char)96, (unsigned char)112, (unsigned char)40, (unsigned char)36, (unsigned char)30, (unsigned char)155, (unsigned char)72, (unsigned char)107, (unsigned char)118, (unsigned char)175, (unsigned char)102, (unsigned char)252, (unsigned char)42, (unsigned char)193, (unsigned char)223, (unsigned char)16, (unsigned char)88, (unsigned char)12, (unsigned char)58, (unsigned char)133, (unsigned char)211, (unsigned char)35, (unsigned char)29, (unsigned char)217, (unsigned char)201, (unsigned char)154, (unsigned char)214, (unsigned char)235, (unsigned char)30, (unsigned char)207, (unsigned char)72, (unsigned char)84, (unsigned char)54, (unsigned char)191, (unsigned char)86, (unsigned char)240, (unsigned char)62, (unsigned char)196, (unsigned char)16, (unsigned char)83, (unsigned char)76, (unsigned char)61, (unsigned char)245, (unsigned char)209, (unsigned char)135, (unsigned char)28, (unsigned char)98, (unsigned char)137, (unsigned char)233, (unsigned char)166, (unsigned char)206, (unsigned char)250, (unsigned char)212, (unsigned char)67, (unsigned char)31, (unsigned char)113, (unsigned char)200, (unsigned char)36, (unsigned char)86, (unsigned char)155, (unsigned char)126, (unsigned char)235, (unsigned char)96, (unsigned char)79, (unsigned char)104, (unsigned char)52, (unsigned char)46, (unsigned char)151, (unsigned char)92, (unsigned char)110, (unsigned char)185, (unsigned char)236, (unsigned char)114, (unsigned char)205, (unsigned char)229, (unsigned char)149, (unsigned char)139, (unsigned char)47, (unsigned char)39, (unsigned char)92, (unsigned char)26, (unsigned char)185, (unsigned char)203, (unsigned char)50, (unsigned char)215, (unsigned char)85, (unsigned char)158, (unsigned char)191, (unsigned char)40, (unsigned char)112, (unsigned char)30, (unsigned char)164, (unsigned char)8, (unsigned char)123, (unsigned char)70, (unsigned char)163, (unsigned char)114, (unsigned char)249, (unsigned char)229, (unsigned char)130, (unsigned char)203, (unsigned char)33, (unsigned char)151, (unsigned char)88, (unsigned char)110, (unsigned char)186, (unsigned char)172, (unsigned char)115, (unsigned char)61, (unsigned char)229, (unsigned char)209, (unsigned char)139, (unsigned char)28, (unsigned char)103, (unsigned char)73, (unsigned char)234, (unsigned char)182, (unsigned char)207, (unsigned char)54, (unsigned char)212, (unsigned char)22, (unsigned char)223, (unsigned char)78, (unsigned char)216, (unsigned char)52, (unsigned char)90, (unsigned char)151, (unsigned char)123, (unsigned char)46, (unsigned char)163, (unsigned char)92, (unsigned char)121, (unsigned char)249, (unsigned char)226, (unsigned char)194, (unsigned char)201, (unsigned char)145, (unsigned char)150, (unsigned char)236, (unsigned char)110, (unsigned char)205, (unsigned char)236, (unsigned char)85, (unsigned char)141, (unsigned char)255, (unsigned char)37, (unsigned char)128, (unsigned char)27, (unsigned char)32, (unsigned char)11, (unsigned char)88, (unsigned char)7, (unsigned char)122, (unsigned char)130, (unsigned char)163, (unsigned char)33, (unsigned char)185, (unsigned char)216, (unsigned char)114, (unsigned char)218, (unsigned char)165, (unsigned char)155, (unsigned char)59, (unsigned char)43, (unsigned char)83, (unsigned char)95, (unsigned char)125, (unsigned char)248, (unsigned char)33, (unsigned char)130, (unsigned char)152, (unsigned char)97, (unsigned char)170, (unsigned char)168, (unsigned char)127, (unsigned char)62, (unsigned char)160, (unsigned char)16, (unsigned char)120, (unsigned char)12, (unsigned char)34, (unsigned char)133, (unsigned char)217, (unsigned char)163, (unsigned char)26, (unsigned char)249, (unsigned char)203, (unsigned char)2, (unsigned char)215, (unsigned char)65, (unsigned char)158, (unsigned char)176, (unsigned char)104, (unsigned char)116, (unsigned char)46, (unsigned char)167, (unsigned char)92, (unsigned char)122, (unsigned char)185, (unsigned char)227, (unsigned char)50, (unsigned char)201, (unsigned char)213, (unsigned char)150, (unsigned char)223, (unsigned char)46, (unsigned char)216, (unsigned char)28, (unsigned char)90, (unsigned char)137, (unsigned char)251, (unsigned char)38, (unsigned char)195, (unsigned char)90, (unsigned char)209, (unsigned char)251, (unsigned char)28, (unsigned char)67, (unsigned char)73, (unsigned char)241, (unsigned char)246, (unsigned char)196, (unsigned char)70, (unsigned char)211, (unsigned char)114, (unsigned char)221, (unsigned char)229, (unsigned char)153 };
// enumeration_whitelist
// file libburn/drive.c line 1597
static char *enumeration_whitelist[255l];
// enumeration_whitelist_top
// file libburn/drive.c line 1598
static signed int enumeration_whitelist_top = -1;
// gflog
// file libburn/ecma130ab.c line 213
static unsigned char gflog[256l] = { (unsigned char)0, (unsigned char)0, (unsigned char)1, (unsigned char)25, (unsigned char)2, (unsigned char)50, (unsigned char)26, (unsigned char)198, (unsigned char)3, (unsigned char)223, (unsigned char)51, (unsigned char)238, (unsigned char)27, (unsigned char)104, (unsigned char)199, (unsigned char)75, (unsigned char)4, (unsigned char)100, (unsigned char)224, (unsigned char)14, (unsigned char)52, (unsigned char)141, (unsigned char)239, (unsigned char)129, (unsigned char)28, (unsigned char)193, (unsigned char)105, (unsigned char)248, (unsigned char)200, (unsigned char)8, (unsigned char)76, (unsigned char)113, (unsigned char)5, (unsigned char)138, (unsigned char)101, (unsigned char)47, (unsigned char)225, (unsigned char)36, (unsigned char)15, (unsigned char)33, (unsigned char)53, (unsigned char)147, (unsigned char)142, (unsigned char)218, (unsigned char)240, (unsigned char)18, (unsigned char)130, (unsigned char)69, (unsigned char)29, (unsigned char)181, (unsigned char)194, (unsigned char)125, (unsigned char)106, (unsigned char)39, (unsigned char)249, (unsigned char)185, (unsigned char)201, (unsigned char)154, (unsigned char)9, (unsigned char)120, (unsigned char)77, (unsigned char)228, (unsigned char)114, (unsigned char)166, (unsigned char)6, (unsigned char)191, (unsigned char)139, (unsigned char)98, (unsigned char)102, (unsigned char)221, (unsigned char)48, (unsigned char)253, (unsigned char)226, (unsigned char)152, (unsigned char)37, (unsigned char)179, (unsigned char)16, (unsigned char)145, (unsigned char)34, (unsigned char)136, (unsigned char)54, (unsigned char)208, (unsigned char)148, (unsigned char)206, (unsigned char)143, (unsigned char)150, (unsigned char)219, (unsigned char)189, (unsigned char)241, (unsigned char)210, (unsigned char)19, (unsigned char)92, (unsigned char)131, (unsigned char)56, (unsigned char)70, (unsigned char)64, (unsigned char)30, (unsigned char)66, (unsigned char)182, (unsigned char)163, (unsigned char)195, (unsigned char)72, (unsigned char)126, (unsigned char)110, (unsigned char)107, (unsigned char)58, (unsigned char)40, (unsigned char)84, (unsigned char)250, (unsigned char)133, (unsigned char)186, (unsigned char)61, (unsigned char)202, (unsigned char)94, (unsigned char)155, (unsigned char)159, (unsigned char)10, (unsigned char)21, (unsigned char)121, (unsigned char)43, (unsigned char)78, (unsigned char)212, (unsigned char)229, (unsigned char)172, (unsigned char)115, (unsigned char)243, (unsigned char)167, (unsigned char)87, (unsigned char)7, (unsigned char)112, (unsigned char)192, (unsigned char)247, (unsigned char)140, (unsigned char)128, (unsigned char)99, (unsigned char)13, (unsigned char)103, (unsigned char)74, (unsigned char)222, (unsigned char)237, (unsigned char)49, (unsigned char)197, (unsigned char)254, (unsigned char)24, (unsigned char)227, (unsigned char)165, (unsigned char)153, (unsigned char)119, (unsigned char)38, (unsigned char)184, (unsigned char)180, (unsigned char)124, (unsigned char)17, (unsigned char)68, (unsigned char)146, (unsigned char)217, (unsigned char)35, (unsigned char)32, (unsigned char)137, (unsigned char)46, (unsigned char)55, (unsigned char)63, (unsigned char)209, (unsigned char)91, (unsigned char)149, (unsigned char)188, (unsigned char)207, (unsigned char)205, (unsigned char)144, (unsigned char)135, (unsigned char)151, (unsigned char)178, (unsigned char)220, (unsigned char)252, (unsigned char)190, (unsigned char)97, (unsigned char)242, (unsigned char)86, (unsigned char)211, (unsigned char)171, (unsigned char)20, (unsigned char)42, (unsigned char)93, (unsigned char)158, (unsigned char)132, (unsigned char)60, (unsigned char)57, (unsigned char)83, (unsigned char)71, (unsigned char)109, (unsigned char)65, (unsigned char)162, (unsigned char)31, (unsigned char)45, (unsigned char)67, (unsigned char)216, (unsigned char)183, (unsigned char)123, (unsigned char)164, (unsigned char)118, (unsigned char)196, (unsigned char)23, (unsigned char)73, (unsigned char)236, (unsigned char)127, (unsigned char)12, (unsigned char)111, (unsigned char)246, (unsigned char)108, (unsigned char)161, (unsigned char)59, (unsigned char)82, (unsigned char)41, (unsigned char)157, (unsigned char)85, (unsigned char)170, (unsigned char)251, (unsigned char)96, (unsigned char)134, (unsigned char)177, (unsigned char)187, (unsigned char)204, (unsigned char)62, (unsigned char)90, (unsigned char)203, (unsigned char)89, (unsigned char)95, (unsigned char)176, (unsigned char)156, (unsigned char)169, (unsigned char)160, (unsigned char)81, (unsigned char)11, (unsigned char)245, (unsigned char)22, (unsigned char)235, (unsigned char)122, (unsigned char)117, (unsigned char)44, (unsigned char)215, (unsigned char)79, (unsigned char)174, (unsigned char)213, (unsigned char)233, (unsigned char)230, (unsigned char)231, (unsigned char)173, (unsigned char)232, (unsigned char)116, (unsigned char)214, (unsigned char)244, (unsigned char)234, (unsigned char)168, (unsigned char)80, (unsigned char)88, (unsigned char)175 };
// gfpow
// file libburn/ecma130ab.c line 158
static unsigned char gfpow[509l] = { (unsigned char)1, (unsigned char)2, (unsigned char)4, (unsigned char)8, (unsigned char)16, (unsigned char)32, (unsigned char)64, (unsigned char)128, (unsigned char)29, (unsigned char)58, (unsigned char)116, (unsigned char)232, (unsigned char)205, (unsigned char)135, (unsigned char)19, (unsigned char)38, (unsigned char)76, (unsigned char)152, (unsigned char)45, (unsigned char)90, (unsigned char)180, (unsigned char)117, (unsigned char)234, (unsigned char)201, (unsigned char)143, (unsigned char)3, (unsigned char)6, (unsigned char)12, (unsigned char)24, (unsigned char)48, (unsigned char)96, (unsigned char)192, (unsigned char)157, (unsigned char)39, (unsigned char)78, (unsigned char)156, (unsigned char)37, (unsigned char)74, (unsigned char)148, (unsigned char)53, (unsigned char)106, (unsigned char)212, (unsigned char)181, (unsigned char)119, (unsigned char)238, (unsigned char)193, (unsigned char)159, (unsigned char)35, (unsigned char)70, (unsigned char)140, (unsigned char)5, (unsigned char)10, (unsigned char)20, (unsigned char)40, (unsigned char)80, (unsigned char)160, (unsigned char)93, (unsigned char)186, (unsigned char)105, (unsigned char)210, (unsigned char)185, (unsigned char)111, (unsigned char)222, (unsigned char)161, (unsigned char)95, (unsigned char)190, (unsigned char)97, (unsigned char)194, (unsigned char)153, (unsigned char)47, (unsigned char)94, (unsigned char)188, (unsigned char)101, (unsigned char)202, (unsigned char)137, (unsigned char)15, (unsigned char)30, (unsigned char)60, (unsigned char)120, (unsigned char)240, (unsigned char)253, (unsigned char)231, (unsigned char)211, (unsigned char)187, (unsigned char)107, (unsigned char)214, (unsigned char)177, (unsigned char)127, (unsigned char)254, (unsigned char)225, (unsigned char)223, (unsigned char)163, (unsigned char)91, (unsigned char)182, (unsigned char)113, (unsigned char)226, (unsigned char)217, (unsigned char)175, (unsigned char)67, (unsigned char)134, (unsigned char)17, (unsigned char)34, (unsigned char)68, (unsigned char)136, (unsigned char)13, (unsigned char)26, (unsigned char)52, (unsigned char)104, (unsigned char)208, (unsigned char)189, (unsigned char)103, (unsigned char)206, (unsigned char)129, (unsigned char)31, (unsigned char)62, (unsigned char)124, (unsigned char)248, (unsigned char)237, (unsigned char)199, (unsigned char)147, (unsigned char)59, (unsigned char)118, (unsigned char)236, (unsigned char)197, (unsigned char)151, (unsigned char)51, (unsigned char)102, (unsigned char)204, (unsigned char)133, (unsigned char)23, (unsigned char)46, (unsigned char)92, (unsigned char)184, (unsigned char)109, (unsigned char)218, (unsigned char)169, (unsigned char)79, (unsigned char)158, (unsigned char)33, (unsigned char)66, (unsigned char)132, (unsigned char)21, (unsigned char)42, (unsigned char)84, (unsigned char)168, (unsigned char)77, (unsigned char)154, (unsigned char)41, (unsigned char)82, (unsigned char)164, (unsigned char)85, (unsigned char)170, (unsigned char)73, (unsigned char)146, (unsigned char)57, (unsigned char)114, (unsigned char)228, (unsigned char)213, (unsigned char)183, (unsigned char)115, (unsigned char)230, (unsigned char)209, (unsigned char)191, (unsigned char)99, (unsigned char)198, (unsigned char)145, (unsigned char)63, (unsigned char)126, (unsigned char)252, (unsigned char)229, (unsigned char)215, (unsigned char)179, (unsigned char)123, (unsigned char)246, (unsigned char)241, (unsigned char)255, (unsigned char)227, (unsigned char)219, (unsigned char)171, (unsigned char)75, (unsigned char)150, (unsigned char)49, (unsigned char)98, (unsigned char)196, (unsigned char)149, (unsigned char)55, (unsigned char)110, (unsigned char)220, (unsigned char)165, (unsigned char)87, (unsigned char)174, (unsigned char)65, (unsigned char)130, (unsigned char)25, (unsigned char)50, (unsigned char)100, (unsigned char)200, (unsigned char)141, (unsigned char)7, (unsigned char)14, (unsigned char)28, (unsigned char)56, (unsigned char)112, (unsigned char)224, (unsigned char)221, (unsigned char)167, (unsigned char)83, (unsigned char)166, (unsigned char)81, (unsigned char)162, (unsigned char)89, (unsigned char)178, (unsigned char)121, (unsigned char)242, (unsigned char)249, (unsigned char)239, (unsigned char)195, (unsigned char)155, (unsigned char)43, (unsigned char)86, (unsigned char)172, (unsigned char)69, (unsigned char)138, (unsigned char)9, (unsigned char)18, (unsigned char)36, (unsigned char)72, (unsigned char)144, (unsigned char)61, (unsigned char)122, (unsigned char)244, (unsigned char)245, (unsigned char)247, (unsigned char)243, (unsigned char)251, (unsigned char)235, (unsigned char)203, (unsigned char)139, (unsigned char)11, (unsigned char)22, (unsigned char)44, (unsigned char)88, (unsigned char)176, (unsigned char)125, (unsigned char)250, (unsigned char)233, (unsigned char)207, (unsigned char)131, (unsigned char)27, (unsigned char)54, (unsigned char)108, (unsigned char)216, (unsigned char)173, (unsigned char)71, (unsigned char)142, (unsigned char)1, (unsigned char)2, (unsigned char)4, (unsigned char)8, (unsigned char)16, (unsigned char)32, (unsigned char)64, (unsigned char)128, (unsigned char)29, (unsigned char)58, (unsigned char)116, (unsigned char)232, (unsigned char)205, (unsigned char)135, (unsigned char)19, (unsigned char)38, (unsigned char)76, (unsigned char)152, (unsigned char)45, (unsigned char)90, (unsigned char)180, (unsigned char)117, (unsigned char)234, (unsigned char)201, (unsigned char)143, (unsigned char)3, (unsigned char)6, (unsigned char)12, (unsigned char)24, (unsigned char)48, (unsigned char)96, (unsigned char)192, (unsigned char)157, (unsigned char)39, (unsigned char)78, (unsigned char)156, (unsigned char)37, (unsigned char)74, (unsigned char)148, (unsigned char)53, (unsigned char)106, (unsigned char)212, (unsigned char)181, (unsigned char)119, (unsigned char)238, (unsigned char)193, (unsigned char)159, (unsigned char)35, (unsigned char)70, (unsigned char)140, (unsigned char)5, (unsigned char)10, (unsigned char)20, (unsigned char)40, (unsigned char)80, (unsigned char)160, (unsigned char)93, (unsigned char)186, (unsigned char)105, (unsigned char)210, (unsigned char)185, (unsigned char)111, (unsigned char)222, (unsigned char)161, (unsigned char)95, (unsigned char)190, (unsigned char)97, (unsigned char)194, (unsigned char)153, (unsigned char)47, (unsigned char)94, (unsigned char)188, (unsigned char)101, (unsigned char)202, (unsigned char)137, (unsigned char)15, (unsigned char)30, (unsigned char)60, (unsigned char)120, (unsigned char)240, (unsigned char)253, (unsigned char)231, (unsigned char)211, (unsigned char)187, (unsigned char)107, (unsigned char)214, (unsigned char)177, (unsigned char)127, (unsigned char)254, (unsigned char)225, (unsigned char)223, (unsigned char)163, (unsigned char)91, (unsigned char)182, (unsigned char)113, (unsigned char)226, (unsigned char)217, (unsigned char)175, (unsigned char)67, (unsigned char)134, (unsigned char)17, (unsigned char)34, (unsigned char)68, (unsigned char)136, (unsigned char)13, (unsigned char)26, (unsigned char)52, (unsigned char)104, (unsigned char)208, (unsigned char)189, (unsigned char)103, (unsigned char)206, (unsigned char)129, (unsigned char)31, (unsigned char)62, (unsigned char)124, (unsigned char)248, (unsigned char)237, (unsigned char)199, (unsigned char)147, (unsigned char)59, (unsigned char)118, (unsigned char)236, (unsigned char)197, (unsigned char)151, (unsigned char)51, (unsigned char)102, (unsigned char)204, (unsigned char)133, (unsigned char)23, (unsigned char)46, (unsigned char)92, (unsigned char)184, (unsigned char)109, (unsigned char)218, (unsigned char)169, (unsigned char)79, (unsigned char)158, (unsigned char)33, (unsigned char)66, (unsigned char)132, (unsigned char)21, (unsigned char)42, (unsigned char)84, (unsigned char)168, (unsigned char)77, (unsigned char)154, (unsigned char)41, (unsigned char)82, (unsigned char)164, (unsigned char)85, (unsigned char)170, (unsigned char)73, (unsigned char)146, (unsigned char)57, (unsigned char)114, (unsigned char)228, (unsigned char)213, (unsigned char)183, (unsigned char)115, (unsigned char)230, (unsigned char)209, (unsigned char)191, (unsigned char)99, (unsigned char)198, (unsigned char)145, (unsigned char)63, (unsigned char)126, (unsigned char)252, (unsigned char)229, (unsigned char)215, (unsigned char)179, (unsigned char)123, (unsigned char)246, (unsigned char)241, (unsigned char)255, (unsigned char)227, (unsigned char)219, (unsigned char)171, (unsigned char)75, (unsigned char)150, (unsigned char)49, (unsigned char)98, (unsigned char)196, (unsigned char)149, (unsigned char)55, (unsigned char)110, (unsigned char)220, (unsigned char)165, (unsigned char)87, (unsigned char)174, (unsigned char)65, (unsigned char)130, (unsigned char)25, (unsigned char)50, (unsigned char)100, (unsigned char)200, (unsigned char)141, (unsigned char)7, (unsigned char)14, (unsigned char)28, (unsigned char)56, (unsigned char)112, (unsigned char)224, (unsigned char)221, (unsigned char)167, (unsigned char)83, (unsigned char)166, (unsigned char)81, (unsigned char)162, (unsigned char)89, (unsigned char)178, (unsigned char)121, (unsigned char)242, (unsigned char)249, (unsigned char)239, (unsigned char)195, (unsigned char)155, (unsigned char)43, (unsigned char)86, (unsigned char)172, (unsigned char)69, (unsigned char)138, (unsigned char)9, (unsigned char)18, (unsigned char)36, (unsigned char)72, (unsigned char)144, (unsigned char)61, (unsigned char)122, (unsigned char)244, (unsigned char)245, (unsigned char)247, (unsigned char)243, (unsigned char)251, (unsigned char)235, (unsigned char)203, (unsigned char)139, (unsigned char)11, (unsigned char)22, (unsigned char)44, (unsigned char)88, (unsigned char)176, (unsigned char)125, (unsigned char)250, (unsigned char)233, (unsigned char)207, (unsigned char)131, (unsigned char)27, (unsigned char)54, (unsigned char)108, (unsigned char)216, (unsigned char)173, (unsigned char)71 };
// h26
// file libburn/ecma130ab.c line 259
static unsigned char h26[26l] = { (unsigned char)3, (unsigned char)143, (unsigned char)201, (unsigned char)234, (unsigned char)117, (unsigned char)180, (unsigned char)90, (unsigned char)45, (unsigned char)152, (unsigned char)76, (unsigned char)38, (unsigned char)19, (unsigned char)135, (unsigned char)205, (unsigned char)232, (unsigned char)116, (unsigned char)58, (unsigned char)29, (unsigned char)128, (unsigned char)64, (unsigned char)32, (unsigned char)16, (unsigned char)8, (unsigned char)4, (unsigned char)2, (unsigned char)1 };
// h45
// file libburn/ecma130ab.c line 265
static unsigned char h45[45l] = { (unsigned char)238, (unsigned char)119, (unsigned char)181, (unsigned char)212, (unsigned char)106, (unsigned char)53, (unsigned char)148, (unsigned char)74, (unsigned char)37, (unsigned char)156, (unsigned char)78, (unsigned char)39, (unsigned char)157, (unsigned char)192, (unsigned char)96, (unsigned char)48, (unsigned char)24, (unsigned char)12, (unsigned char)6, (unsigned char)3, (unsigned char)143, (unsigned char)201, (unsigned char)234, (unsigned char)117, (unsigned char)180, (unsigned char)90, (unsigned char)45, (unsigned char)152, (unsigned char)76, (unsigned char)38, (unsigned char)19, (unsigned char)135, (unsigned char)205, (unsigned char)232, (unsigned char)116, (unsigned char)58, (unsigned char)29, (unsigned char)128, (unsigned char)64, (unsigned char)32, (unsigned char)16, (unsigned char)8, (unsigned char)4, (unsigned char)2, (unsigned char)1 };
// last_track_size
// file test/telltoc.c line 82
static signed int last_track_size = -1;
// last_track_start
// file test/telltoc.c line 82
static signed int last_track_start = 0;
// lib_start_time
// file libburn/init.c line 47
double lib_start_time;
// libburn_back_hack_42
// file libburn/back_hacks.h line 44
signed int libburn_back_hack_42 = 0;
// libdax_messenger
// file libburn/init.c line 42
struct libdax_msgs *libdax_messenger = (struct libdax_msgs *)(void *)0;
// linux_ata_device_family
// file libburn/sg-linux.c line 215
static char linux_ata_device_family[80l] = { '/', 'd', 'e', 'v', '/', 'h', 'd', '%', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// linux_ata_enumerate_verbous
// file libburn/sg-linux.c line 219
static signed int linux_ata_enumerate_verbous = 0;
// linux_sg_accept_any_type
// file libburn/sg-linux.c line 206
static signed int linux_sg_accept_any_type = 0;
// linux_sg_auto_family
// file libburn/sg-linux.c line 199
static signed int linux_sg_auto_family = 1;
// linux_sg_device_family
// file libburn/sg-linux.c line 194
static char linux_sg_device_family[80l] = { '/', 'd', 'e', 'v', '/', 's', 'g', '%', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// linux_sg_enumerate_debug
// file libburn/sg-linux.c line 178
static signed int linux_sg_enumerate_debug = 0;
// medium_is_cd_profile
// file test/telltoc.c line 83
static signed int medium_is_cd_profile = 0;
// mmc_function_spy_do_tell
// file libburn/mmc.c line 265
static signed int mmc_function_spy_do_tell = 0;
// mmc_start_for_bit0
// file libburn/mmc.c line 314
static signed int mmc_start_for_bit0 = 0;
// non_signal_list
// file libburn/cleanup.c line 40
static signed int non_signal_list[10l] = { 9, 17, 19, 20, 18, 23, 28, 21, 22, -1 };
// non_signal_list_count
// file libburn/cleanup.c line 41
static signed int non_signal_list_count = 9;
// print_encoding
// file test/telltoc.c line 799
static signed int print_encoding = 0;
// print_help
// file test/telltoc.c line 797
static signed int print_help = 0;
// print_raw_file
// file test/telltoc.c line 800
static char print_raw_file[4096l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// read_count
// file test/telltoc.c line 799
static signed int read_count = -2;
// read_start
// file test/telltoc.c line 799
static signed int read_start = -2;
// sg_initialize_msg
// file libburn/init.c line 82
static char sg_initialize_msg[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// sg_kernel_age
// file libburn/sg-linux.c line 158
static signed int sg_kernel_age = -1;
// signal_list
// file libburn/cleanup.c line 37
static signed int signal_list[22l] = { 1, 2, 3, 4, 6, 8, 11, 13, 14, 15, 10, 12, 24, 7, 29, 27, 31, 5, 26, 24, 25, -1 };
// signal_list_count
// file libburn/cleanup.c line 39
static signed int signal_list_count = 21;
// signal_name_list
// file libburn/cleanup.c line 38
static char *signal_name_list[22l] = { "SIGHUP", "SIGINT", "SIGQUIT", "SIGILL", "SIGABRT", "SIGFPE", "SIGSEGV", "SIGPIPE", "SIGALRM", "SIGTERM", "SIGUSR1", "SIGUSR2", "SIGXCPU", "SIGBUS", "SIGPOLL", "SIGPROF", "SIGSYS", "SIGTRAP", "SIGVTALRM", "SIGXCPU", "SIGXFSZ", "@" };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// workers
// file libburn/async.c line 123
static struct w_list *workers = (struct w_list *)(void *)0;

// Cleanup_handler_exit
// file libburn/cleanup.c line 90
static signed int Cleanup_handler_exit(signed int exit_value, signed int signum, signed int flag)
{
  signed int ret;
  if(!((signed int)cleanup_msg[0l] == 0))
  {
    if(!(cleanup_has_reported == signum))
    {
      fprintf(stderr, "\n%s\n", (const void *)cleanup_msg);
      cleanup_has_reported = signum;
    }

  }

  if(!(cleanup_perform_app_handler_first == 0))
  {
    if(cleanup_app_handler == ((signed int (*)(void *, signed int, signed int))NULL))
      goto __CPROVER_DUMP_L2;

    ret=cleanup_app_handler(cleanup_app_handle, signum, 0);
    return 2;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(cleanup_exiting == 0))
    {
      signed int return_value_getpid$1;
      return_value_getpid$1=getpid();
      fprintf(stderr, "cleanup: ABORT : repeat by pid=%.f, signum=%d\n", (double)return_value_getpid$1, signum);
      return 0;
    }

    cleanup_exiting = 1;
    alarm((unsigned int)0);
    if(cleanup_perform_app_handler_first == 0)
    {
      if(cleanup_app_handler == ((signed int (*)(void *, signed int, signed int))NULL))
        goto __CPROVER_DUMP_L4;

      ret=cleanup_app_handler(cleanup_app_handle, signum, 0);
      return 2;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      exit(exit_value);
    }
  }
}

// Cleanup_handler_generic
// file libburn/cleanup.c line 121
static void Cleanup_handler_generic(signed int signum)
{
  signed int i;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  sprintf(cleanup_msg, "UNIX-SIGNAL caught:  %d  errno= %d", signum, *return_value___errno_location$1);
  i = 0;
  for( ; !(i >= signal_list_count); i = i + 1)
    if(signum == signal_list[(signed long int)i])
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      sprintf(cleanup_msg, "UNIX-SIGNAL:  %s  errno= %d", signal_name_list[(signed long int)i], *return_value___errno_location$2);
      break;
    }

  Cleanup_handler_exit(1, signum, 0);
}

// Cleanup_set_handlers
// file libburn/cleanup.c line 146
signed int Cleanup_set_handlers(void *handle, signed int (*handler)(void *, signed int, signed int), signed int flag)
{
  signed int i;
  signed int j;
  signed int max_sig = -1;
  signed int min_sig = 0x7fffffff;
  char *sig_name;
  void (*sig_handler)(signed int);
  cleanup_msg[(signed long int)0] = (char)0;
  cleanup_app_handle = handle;
  cleanup_app_handler = handler;
  if(!((4 & flag) == 0))
    cleanup_perform_app_handler_first = 1;

  if(!((1 & flag) == 0))
    sig_handler = (void (*)(signed int))0;

  else
    if(!((2 & flag) == 0))
      sig_handler = (void (*)(signed int))1;

    else
      sig_handler = Cleanup_handler_generic;
  i = 0;
  for( ; !(i >= signal_list_count); i = i + 1)
  {
    if(!(max_sig >= signal_list[(signed long int)i]))
      max_sig = signal_list[(signed long int)i];

    if(!(signal_list[(signed long int)i] >= min_sig))
      min_sig = signal_list[(signed long int)i];

  }
  i = min_sig;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$1;
  for( ; max_sig >= i; i = i + 1)
  {
    j = 0;
    for( ; !(j >= non_signal_list_count); j = j + 1)
      if(i == non_signal_list[(signed long int)j])
        break;

    if(j >= non_signal_list_count)
    {
      if(!((264 & flag) == 0))
        sig_name=Cleanup_signo_to_name(i);

      else
        sig_name = "";
      _Bool tmp_if_expr$4;
      if(!((8 & flag) == 0))
      {
        return_value_strcmp$3=strcmp(sig_name, "SIGABRT");
        tmp_if_expr$4 = return_value_strcmp$3 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        signal(i, Cleanup_handler_generic);

      else
      {
        _Bool tmp_if_expr$2;
        if(!((256 & flag) == 0))
        {
          return_value_strcmp$1=strcmp(sig_name, "SIGPIPE");
          tmp_if_expr$2 = return_value_strcmp$1 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          signal(i, (void (*)(signed int))1);

        else
          signal(i, sig_handler);
      }
    }

  }
  return 1;
}

// Cleanup_signo_to_name
// file libburn/cleanup.c line 136
static char * Cleanup_signo_to_name(signed int signo)
{
  signed int i = 0;
  for( ; !(i >= signal_list_count); i = i + 1)
    if(signal_list[(signed long int)i] == signo)
      return signal_name_list[(signed long int)i];

  return "";
}

// add_catalog_cue
// file libburn/write.c line 420
static signed int add_catalog_cue(struct cue_sheet *sheet, unsigned char *catalog)
{
  unsigned char *unit;
  signed int i;
  signed int ret;
  ret=new_cue(sheet, 2, 0);
  if(!(ret >= 1))
    return -1;

  else
  {
    unit = sheet->data + (signed long int)((sheet->count - 2) * 8);
    unit[(signed long int)8] = (unsigned char)0x02;
    unit[(signed long int)0] = unit[(signed long int)8];
    i = 0;
    for( ; !(i >= 13); i = i + 1)
      unit[(signed long int)(1 + (signed int)(i >= 7) * 8 + i % 7)] = catalog[(signed long int)i];
    unit[(signed long int)15] = (unsigned char)0x00;
    return 1;
  }
}

// add_cue
// file libburn/write.c line 394
static signed int add_cue(struct cue_sheet *sheet, unsigned char ctladr, unsigned char tno, unsigned char indx, unsigned char form, unsigned char scms, signed int lba)
{
  unsigned char *unit;
  signed int m;
  signed int s;
  signed int f;
  signed int ret;
  burn_lba_to_msf(lba, &m, &s, &f);
  ret=new_cue(sheet, 1, 0);
  if(!(ret >= 1))
    return -1;

  else
  {
    unit = sheet->data + (signed long int)((sheet->count - 1) * 8);
    unit[(signed long int)0] = ctladr;
    unit[(signed long int)1] = tno;
    unit[(signed long int)2] = indx;
    unit[(signed long int)3] = form;
    unit[(signed long int)4] = scms;
    unit[(signed long int)5] = (unsigned char)m;
    unit[(signed long int)6] = (unsigned char)s;
    unit[(signed long int)7] = (unsigned char)f;
    return 1;
  }
}

// add_isrc_cue
// file libburn/write.c line 438
static signed int add_isrc_cue(struct cue_sheet *sheet, unsigned char ctladr, signed int tno, struct isrc *isrc)
{
  unsigned char *unit;
  signed int i;
  signed int ret;
  char text[8l];
  ret=new_cue(sheet, 2, 0);
  if(!(ret >= 1))
    return -1;

  else
  {
    unit = sheet->data + (signed long int)((sheet->count - 2) * 8);
    unit[(signed long int)8] = (unsigned char)((signed int)ctladr & 0xf0 | 0x03);
    unit[(signed long int)0] = unit[(signed long int)8];
    unit[(signed long int)9] = (unsigned char)tno;
    unit[(signed long int)1] = unit[(signed long int)9];
    unit[(signed long int)2] = (unsigned char)isrc->country[(signed long int)0];
    unit[(signed long int)3] = (unsigned char)isrc->country[(signed long int)1];
    unit[(signed long int)4] = (unsigned char)isrc->owner[(signed long int)0];
    unit[(signed long int)5] = (unsigned char)isrc->owner[(signed long int)1];
    unit[(signed long int)6] = (unsigned char)isrc->owner[(signed long int)2];
    sprintf(text, "%-2.2u%-5.5u", (unsigned int)isrc->year, isrc->serial);
    unit[(signed long int)7] = (unsigned char)text[(signed long int)0];
    i = 1;
    for( ; !(i >= 7); i = i + 1)
      unit[(signed long int)(9 + i)] = (unsigned char)text[(signed long int)i];
    return 1;
  }
}

// add_proc_info_drives
// file libburn/sg-linux.c line 1414
static signed int add_proc_info_drives(signed int flag)
{
  signed int ret;
  signed int list_count;
  signed int count = 0;
  signed int i;
  char **list = (char **)(void *)0;
  if(!(burn_sg_use_family == 0))
    return 1;

  else
  {
    ret=proc_sys_dev_cdrom_info(&list, &list_count, 0);
    if(!(ret >= 1))
      return ret;

    else
    {
      i = 0;
      for( ; !(i >= list_count); i = i + 1)
      {
        signed int return_value_burn_drive_is_banned$1;
        return_value_burn_drive_is_banned$1=burn_drive_is_banned(list[(signed long int)i]);
        if(return_value_burn_drive_is_banned$1 == 0)
        {
          ret=fname_enumerate(list[(signed long int)i], 1 | 4);
          if(ret == 1)
            count = count + 1;

        }

      }
      proc_sys_dev_cdrom_info(&list, &list_count, 1);
      return 1 + count;
    }
  }
}

// add_worker
// file libburn/async.c line 136
static void add_worker(signed int w_type, struct burn_drive *d, void * (*f)(void *), union w_list_data *data)
{
  struct w_list *a;
  struct w_list *tmp;
  union pthread_attr_t *attr_pt = (union pthread_attr_t *)(void *)0;
  union pthread_attr_t attr;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct w_list) /*56ul*/ );
  a = (struct w_list *)return_value_calloc$1;
  a->w_type = w_type;
  a->drive = d;
  a->u = *data;
  a->next = workers;
  tmp = workers;
  workers = a;
  if(!(d == ((struct burn_drive *)NULL)))
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_SPAWNING;

  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, 1);
  attr_pt = &attr;
  signed int return_value_pthread_create$2;
  return_value_pthread_create$2=pthread_create(&a->thread, attr_pt, f, (void *)a);
  if(!(return_value_pthread_create$2 == 0))
  {
    free((void *)a);
    workers = tmp;
  }

}

// ata_enumerate
// file libburn/sg-linux.c line 1125
static void ata_enumerate(void)
{
  signed int ret;
  signed int i;
  signed int fd = -1;
  char fname[10l];
  if(!(linux_ata_enumerate_verbous == 0))
    fprintf(stderr, "libburn_debug: linux_ata_device_family = %s\n", (const void *)linux_ata_device_family);

  if(!((signed int)linux_ata_device_family[0l] == 0))
  {
    i = 0;
    for( ; !(i >= 26); i = i + 1)
    {
      sprintf(fname, linux_ata_device_family, 97 + i);
      if(!(linux_ata_enumerate_verbous == 0))
        fprintf(stderr, "libburn_debug: %s : ", (const void *)fname);

      signed int return_value_burn_drive_is_banned$1;
      return_value_burn_drive_is_banned$1=burn_drive_is_banned(fname);
      if(!(return_value_burn_drive_is_banned$1 == 0))
      {
        if(!(linux_ata_enumerate_verbous == 0))
          fprintf(stderr, "not in whitelist\n");

      }

      else
      {
        fd=sg_open_for_enumeration(fname, 0);
        if(fd >= 0)
        {
          ret=is_ata_drive(fname, fd);
          if(!(ret >= 0))
            break;

          if(!(ret == 0))
          {
            if(!(linux_ata_enumerate_verbous == 0))
              fprintf(stderr, "accepting as drive without SCSI address\n");

            enumerate_common(fname, fd, -1, -1, -1, -1, -1);
          }

        }

      }
    }
  }

}

// bitcount
// file libburn/read.c line 193
static signed int bitcount(unsigned char *data, signed int n)
{
  signed int i;
  signed int j;
  signed int count = 0;
  unsigned char tem;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    tem = data[(signed long int)i];
    j = 0;
    for( ; !(j >= 8); j = j + 1)
    {
      count = count + ((signed int)tem & 1);
      tem = tem >> 1;
    }
  }
  return count;
}

// burn__split_path
// file libburn/drive.c line 3115
static signed int burn__split_path(char *adr, char **dpt, char **npt)
{
  *dpt = adr;
  *npt=strrchr(*dpt, 47);
  if(*npt == ((char *)NULL))
  {
    *npt = *dpt;
    *dpt = ".";
    return 1;
  }

  else
  {
    *(*npt) = (char)0;
    if(*npt == *dpt)
      *dpt = "/";

    *npt = *npt + 1l;
    return 2;
  }
}

// burn_abort
// file libburn/drive.c line 2459
signed int burn_abort(signed int patience, signed int (*pacifier_func)(void *, signed int, signed int), void *handle)
{
  signed int ret;
  signed int flg = 0;
  if(!(patience >= 0))
  {
    patience = 0;
    flg = flg | 1;
  }

  ret=burn_abort_5(patience, pacifier_func, handle, 0, flg);
  return ret;
}

// burn_abort_5
// file libburn/drive.c line 2350
signed int burn_abort_5(signed int patience, signed int (*pacifier_func)(void *, signed int, signed int), void *handle, signed int elapsed, signed int flag)
{
  signed int ret;
  signed int i;
  signed int occup;
  signed int still_not_done = 1;
  signed int pacifier_off = 0;
  signed int first_round = 1;
  unsigned long int wait_grain = (unsigned long int)100000;
  signed long int start_time;
  signed long int current_time;
  signed long int pacifier_time;
  signed long int end_time;
  signed long int stdio_patience = (signed long int)3;
  pacifier_time=time(((signed long int *)NULL));
  start_time = pacifier_time;
  current_time = start_time;
  start_time = start_time - (signed long int)elapsed;
  end_time = start_time + (signed long int)patience;
  while(!(first_round == 0) && !(patience >= 1) || !(current_time >= end_time))
  {
    still_not_done = 0;
    i = 0;
    for( ; !(i >= 1 + drivetop); i = i + 1)
    {
      occup=burn_drive_is_occupied(&drive_array[(signed long int)i]);
      if(!(occup == -2))
      {
        if(!(drive_array[(signed long int)i].drive_role == 1))
        {
          if(stdio_patience >= current_time + -start_time)
            goto __CPROVER_DUMP_L3;

          drive_array[(signed long int)i].global_index = -1;
        }

        else
        {

        __CPROVER_DUMP_L3:
          ;
          if(!(occup >= 10))
          {
            if(drive_array[(signed long int)i].cancel == 0)
              burn_drive_cancel(&drive_array[(signed long int)i]);

            if(!(drive_array[(signed long int)i].drive_role == 1))
              usleep((unsigned int)1000000);

            burn_drive_forget(&drive_array[(signed long int)i], 1);
          }

          else
            if(!(occup >= 101))
            {
              if(drive_array[(signed long int)i].cancel == 0)
                burn_drive_cancel(&drive_array[(signed long int)i]);

              still_not_done = still_not_done + 1;
            }

            else
              if(!(occup >= 1001))
                still_not_done = still_not_done + 1;

        }
      }

    }
    first_round = 0;
    if(still_not_done == 0 || !(patience >= 1))
      break;

    usleep((unsigned int)wait_grain);
    current_time=time(((signed long int *)NULL));
    if(!(pacifier_time >= current_time))
    {
      if(pacifier_off == 0 && !(pacifier_func == ((signed int (*)(void *, signed int, signed int))NULL)))
      {
        ret=pacifier_func(handle, patience, (signed int)(current_time - start_time));
        pacifier_off = (signed int)(ret <= 0);
      }

      pacifier_time = current_time;
    }

  }
  if((1 & flag) == 0)
    burn_finish();

  return (signed int)(still_not_done == 0);
}

// burn_abort_exit
// file libburn/init.c line 386
signed int burn_abort_exit(signed int value)
{
  burn_abort(4440, burn_abort_pacifier, (void *)abort_message_prefix);
  fprintf(stderr, "\n%sABORT : Program done. Even if you do not see a shell prompt.\n\n", (const void *)abort_message_prefix);
  if(!(value == 0))
    exit(value);

  burn_global_abort_level = -2;
  return 1;
}

// burn_abort_pacifier
// file libburn/drive.c line 2334
signed int burn_abort_pacifier(void *handle, signed int patience, signed int elapsed)
{
  char *prefix = "libburn : ";
  if(!(handle == NULL))
    prefix = (char *)handle;

  fprintf(stderr, "\r%sABORT : Waiting for drive to finish ( %d s, %d max)", (char *)prefix, elapsed, patience);
  return 1;
}

// burn_alloc_mem
// file libburn/init.h line 38
void * burn_alloc_mem(unsigned long int size, unsigned long int count, signed int flag)
{
  void *pt;
  pt=calloc(count, size);
  if(pt == NULL)
    libdax_msgs_submit(libdax_messenger, -1, 0x00000003, 0x70000000, 0x30000000, "Out of virtual memory", 0, 0);

  return pt;
}

// burn_allow_drive_role_4
// file libburn/init.c line 646
void burn_allow_drive_role_4(signed int allowed)
{
  burn_drive_role_4_allowed = allowed & 0xf;
}

// burn_allow_untested_profiles
// file libburn/init.c line 619
void burn_allow_untested_profiles(signed int yes)
{
  burn_support_untested_profiles = (signed int)!(!(yes != 0));
}

// burn_builtin_abort_handler
// file libburn/init.c line 399
signed int burn_builtin_abort_handler(void *handle, signed int signum, signed int flag)
{
  signed int ret;
  struct burn_drive *d;
  burn_builtin_triggered_action = burn_builtin_signal_action;
  burn_global_abort_level = -1;
  if(burn_builtin_signal_action >= 2)
  {
    Cleanup_set_handlers((void *)0, (signed int (*)(void *, signed int, signed int))(void *)0, 2);
    if(burn_builtin_signal_action == 4)
      return -2;

    fprintf(stderr, "%sABORT : Trying to shut down busy drives\n", (const void *)abort_message_prefix);
    fprintf(stderr, "%sABORT : Wait the normal burning time before any kill -9\n", (const void *)abort_message_prefix);
    burn_abort_5(0, burn_abort_pacifier, (void *)abort_message_prefix, 0, 1);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020177, 0x71000000, 0x30000000, "Urged drive worker threads to do emergency halt", 0, 0);
    return -2;
  }

  else
  {
    burn_global_abort_level = burn_global_abort_level + 1;
    burn_global_abort_signum = signum;
    signed int return_value_getpid$4;
    return_value_getpid$4=getpid();
    if(!(return_value_getpid$4 == abort_control_pid))
    {
      signed int return_value_getpid$1;
      return_value_getpid$1=getpid();
      unsigned long int return_value_pthread_self$2;
      return_value_pthread_self$2=pthread_self();
      ret=burn_drive_find_by_thread_pid(&d, return_value_getpid$1, return_value_pthread_self$2);
      _Bool tmp_if_expr$3;
      if(ret >= 1)
        tmp_if_expr$3 = (signed int)d->busy == BURN_DRIVE_WRITING ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        d->sync_cache(d);
        d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
        if(burn_global_abort_level >= 1)
          kill(abort_control_pid, signum);

        return -2;
      }

      else
      {
        usleep((unsigned int)1000000);
        return -2;
      }
    }

    burn_global_abort_level = -1;
    Cleanup_set_handlers((void *)0, (signed int (*)(void *, signed int, signed int))(void *)0, 2);
    fprintf(stderr, "%sABORT : Trying to shut down drive and library\n", (const void *)abort_message_prefix);
    fprintf(stderr, "%sABORT : Wait the normal burning time before any kill -9\n", (const void *)abort_message_prefix);
    close(0);
    burn_abort_exit(0);
    return 1;
  }
}

// burn_cdtext_check_blockno
// file libburn/structure.c line 1003
static signed int burn_cdtext_check_blockno(signed int block)
{
  if(block >= 8 || !(block >= 0))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002018d, 0x68000000, 0x30000000, "CD-TEXT block number out of range", 0, 0);
    return 0;
  }

  else
    return 1;
}

// burn_cdtext_crc_mismatches
// file libburn/cdtext.c line 103
signed int burn_cdtext_crc_mismatches(unsigned char *packs, signed int num_packs, signed int flag)
{
  signed int i;
  signed int residue;
  signed int count = 0;
  signed int repair;
  unsigned char crc[2l];
  repair = flag & 1;
  if(!((2 & flag) == 0))
  {
    i = 0;
    for( ; !(i >= 18 * num_packs); i = i + 18)
    {
      _Bool tmp_if_expr$1;
      if(!(packs[(signed long int)(16 + i)] == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = packs[(signed long int)(i + 17)] != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        break;

    }
    if(i == 18 * num_packs)
      repair = 1;

  }

  i = 0;
  for( ; !(i >= 18 * num_packs); i = i + 18)
  {
    residue=crc_11021(packs + (signed long int)i, 16, 0);
    crc[(signed long int)0] = (unsigned char)(residue >> 8 & 0xff ^ 0xff);
    crc[(signed long int)1] = (unsigned char)(residue & 0xff ^ 0xff);
    _Bool tmp_if_expr$3;
    if(!(crc[0l] == packs[(signed long int)(16 + i)]))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = crc[(signed long int)1] != packs[(signed long int)(i + 17)] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      if(!(repair == 0))
      {
        _Bool tmp_if_expr$2;
        if(!(packs[(signed long int)(16 + i)] == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = packs[(signed long int)(i + 17)] != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          count = count - 1;

        packs[(signed long int)(i + 16)] = crc[(signed long int)0];
        packs[(signed long int)(i + 17)] = crc[(signed long int)1];
      }

      else
        count = count + 1;
    }

  }
  return count;
}

// burn_cdtext_create
// file libburn/structure.c line 891
struct burn_cdtext * burn_cdtext_create(void)
{
  struct burn_cdtext *t;
  signed int i;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct burn_cdtext) /*200ul*/ , (unsigned long int)1, 0);
  t = (struct burn_cdtext *)return_value_burn_alloc_mem$1;
  if(t == ((struct burn_cdtext *)NULL))
    return (struct burn_cdtext *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= 0x10); i = i + 1)
    {
      t->payload[(signed long int)i] = (unsigned char *)(void *)0;
      t->length[(signed long int)i] = 0;
    }
    return t;
  }
}

// burn_cdtext_free
// file libburn/structure.c line 907
void burn_cdtext_free(struct burn_cdtext **cdtext)
{
  struct burn_cdtext *t;
  signed int i;
  t = *cdtext;
  if(!(t == ((struct burn_cdtext *)NULL)))
  {
    i = 0;
    for( ; !(i >= 0x10); i = i + 1)
      if(!(t->payload[(signed long int)i] == ((unsigned char *)NULL)))
        free((void *)t->payload[(signed long int)i]);

    free((void *)t);
  }

}

// burn_cdtext_from_packfile
// file libburn/cdtext.c line 1077
signed int burn_cdtext_from_packfile(char *path, unsigned char **text_packs, signed int *num_packs, signed int flag)
{
  signed int ret = 0;
  signed int residue = 0;
  struct stat stbuf;
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  unsigned char head[4l];
  unsigned char tail[1l];
  char *msg = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_stat$4;
  unsigned long int return_value_fread$12;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    *text_packs = (unsigned char *)(void *)0;
    return_value_stat$4=stat(path, &stbuf);
    if(return_value_stat$4 == -1)
    {

    cannot_open:
      ;
      sprintf(msg, "Cannot open CD-TEXT pack file '%.4000s'", path);
      char *return_value_burn_printify$2;
      return_value_burn_printify$2=burn_printify(msg);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      libdax_msgs_submit(libdax_messenger, -1, 0x00020198, 0x68000000, 0x30000000, return_value_burn_printify$2, *return_value___errno_location$3, 0);
      ret = 0;
      goto ex;
    }

    if((61440u & stbuf.st_mode) == 32768u)
    {
      residue = (signed int)(stbuf.st_size % (signed long int)18);
      if(residue == 0 || residue == 1 || residue == 4)
        goto __CPROVER_DUMP_L5;

    }


  not_a_textfile:
    ;
    sprintf(msg, "File is not of usable type or content for CD-TEXT packs: '%.4000s'", path);
    char *return_value_burn_printify$5;
    return_value_burn_printify$5=burn_printify(msg);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020198, 0x68000000, 0x30000000, return_value_burn_printify$5, 0, 0);
    ret = 0;
    goto ex;

  __CPROVER_DUMP_L5:
    ;
    if(!(stbuf.st_size >= 18l))
      goto not_a_textfile;

    fp=fopen(path, "rb");
    if(fp == ((struct _IO_FILE *)NULL))
      goto cannot_open;

    if(residue == 4)
    {
      unsigned long int return_value_fread$6;
      return_value_fread$6=fread((void *)head, (unsigned long int)4, (unsigned long int)1, fp);
      ret = (signed int)return_value_fread$6;
      if(!(ret == 1))
      {

      cannot_read:
        ;
        sprintf(msg, "Cannot read all bytes from CD-TEXT pack file '%.4000s'", path);
        char *return_value_burn_printify$7;
        return_value_burn_printify$7=burn_printify(msg);
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        libdax_msgs_submit(libdax_messenger, -1, 0x00020198, 0x68000000, 0x30000000, return_value_burn_printify$7, *return_value___errno_location$8, 0);
        ret = 0;
        goto ex;
      }

      if(!((signed long int)(256 * (signed int)head[0l] + (signed int)head[1l]) == stbuf.st_size + -2l))
        goto not_a_textfile;

    }

    *num_packs = (signed int)((stbuf.st_size - (signed long int)residue) / (signed long int)18);
    if(*num_packs >= 2049)
    {
      sprintf(msg, "CD-Text pack file too large (max. 36864 bytes): '%.4000s'", path);
      char *return_value_burn_printify$9;
      return_value_burn_printify$9=burn_printify(msg);
      libdax_msgs_submit(libdax_messenger, -1, 0x0002018b, 0x68000000, 0x30000000, return_value_burn_printify$9, 0, 0);
      ret = 0;
      goto ex;
    }

    if(!(*num_packs >= 1))
    {
      strcpy(msg, "CD-Text pack file contains no complete text pack");
      char *return_value_burn_printify$10;
      return_value_burn_printify$10=burn_printify(msg);
      libdax_msgs_submit(libdax_messenger, -1, 0x000201aa, 0x68000000, 0x30000000, return_value_burn_printify$10, 0, 0);
      ret = 0;
      goto ex;
    }

    void *return_value_burn_alloc_mem$11;
    return_value_burn_alloc_mem$11=burn_alloc_mem(sizeof(unsigned char) /*1ul*/ , (unsigned long int)(*num_packs * 18), 0);
    *text_packs = (unsigned char *)return_value_burn_alloc_mem$11;
    if(*text_packs == ((unsigned char *)NULL))
      ret = -1;

    else
    {
      return_value_fread$12=fread((void *)*text_packs, (unsigned long int)(*num_packs * 18), (unsigned long int)1, fp);
      ret = (signed int)return_value_fread$12;
      if(!(ret == 1))
        goto cannot_read;

      if(residue == 1)
      {
        unsigned long int return_value_fread$13;
        return_value_fread$13=fread((void *)tail, (unsigned long int)1, (unsigned long int)1, fp);
        ret = (signed int)return_value_fread$13;
        if(!(ret == 1))
          goto cannot_read;

        if(!((signed int)tail[0l] == 0))
          goto not_a_textfile;

      }

      ret = 1;
    }
  }

ex:
  ;
  if(!(ret >= 1))
  {
    if(!(*text_packs == ((unsigned char *)NULL)))
      free((void *)(char *)*text_packs);

    *text_packs = (unsigned char *)(void *)0;
    *num_packs = 0;
  }

  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_cdtext_from_session
// file libburn/cdtext.c line 359
signed int burn_cdtext_from_session(struct burn_session *s, unsigned char **text_packs, signed int *num_packs, signed int flag)
{
  signed int pack_type;
  signed int block;
  signed int ret;
  signed int i;
  signed int idx;
  signed int j;
  signed int residue;
  struct burn_pack_cursor crs;
  if(text_packs == ((unsigned char **)NULL) || num_packs == ((signed int *)NULL))
    flag = flag | 1;

  else
    if((1 & flag) == 0)
    {
      *text_packs = (unsigned char *)(void *)0;
      *num_packs = 0;
    }

  memset((void *)&crs, 0, sizeof(struct burn_pack_cursor) /*120ul*/ );
  crs.track_offset = (signed int)s->firsttrack;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(unsigned char) /*1ul*/ , (unsigned long int)(2048 * 18), 0);
  crs.packs = (unsigned char *)return_value_burn_alloc_mem$1;
  if(crs.packs == ((unsigned char *)NULL))
    ret = -1;

  else
  {
    block = 0;
    for( ; !(block >= 8); block = block + 1)
      if(!(s->cdtext[(signed long int)block] == ((struct burn_cdtext *)NULL)))
        break;

    if(block == 8)
      ret = 1;

    else
    {
      block = 0;
      for( ; !(block >= 8); block = block + 1)
        if(!(s->cdtext[(signed long int)block] == ((struct burn_cdtext *)NULL)))
        {
          pack_type = 0x80;
          for( ; !(pack_type >= 0x10); pack_type = pack_type + 1)
            if(!(pack_type == 0x8f))
            {
              ret=burn_create_tybl_s_packs(s, pack_type, block, &crs, 0);
              if(!(ret >= 1))
                goto ex;

            }

          ret=burn_create_bl_size_packs(block, s->cdtext_char_code, s->cdtext_copyright, s->cdtext_language, s->tracks, &crs, 0);
          if(!(ret >= 1))
            goto ex;

        }

      i = 0;
      for( ; !(i >= crs.num_packs); i = i + 1)
      {
        idx = i * 18;
        _Bool tmp_if_expr$3;
        if((signed int)crs.packs[(signed long int)idx] == 0x8f)
          tmp_if_expr$3 = (signed int)crs.packs[(signed long int)(idx + 1)] == 1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          j = 0;
          for( ; !(j >= 4); j = j + 1)
            if(crs.hiseq[(signed long int)j] >= 1)
              crs.packs[(signed long int)(idx + 4 + 8 + j)] = (unsigned char)(crs.hiseq[(signed long int)j] - 1);

            else
              crs.packs[(signed long int)(idx + 4 + 8 + j)] = (unsigned char)0;
        }

        else
        {
          _Bool tmp_if_expr$2;
          if((signed int)crs.packs[(signed long int)idx] == 0x8f)
            tmp_if_expr$2 = (signed int)crs.packs[(signed long int)(idx + 1)] == 2 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(tmp_if_expr$2)
          {
            j = 0;
            for( ; !(j >= 4); j = j + 1)
              if(crs.hiseq[(signed long int)(4 + j)] >= 1)
                crs.packs[(signed long int)(idx + 4 + j)] = (unsigned char)(crs.hiseq[(signed long int)(j + 4)] - 1);

              else
                crs.packs[(signed long int)(idx + 4 + j)] = (unsigned char)0;
          }

          else
            goto __CPROVER_DUMP_L30;
        }
        signed int return_value_crc_11021$4;
        return_value_crc_11021$4=crc_11021(crs.packs + (signed long int)idx, 16, 0);
        residue = return_value_crc_11021$4 ^ 0xffff;
        crs.packs[(signed long int)(idx + 16)] = (unsigned char)(residue >> 8 & 0xff);
        crs.packs[(signed long int)(idx + 17)] = (unsigned char)(residue & 0xff);

      __CPROVER_DUMP_L30:
        ;
      }
      ret = 1;
    }
  }

ex:
  ;
  if(!((1 & flag) == 0) || !(ret >= 1))
  {
    if(ret >= 1)
      ret = crs.num_packs;

    else
      if(!((1 & flag) == 0))
        ret = -1;

    if(!(crs.packs == ((unsigned char *)NULL)))
      free((void *)(char *)crs.packs);

  }

  else
  {
    if(crs.num_packs >= 1)
      *text_packs = crs.packs;

    else
      if(!(crs.packs == ((unsigned char *)NULL)))
        free((void *)(char *)crs.packs);

    *num_packs = crs.num_packs;
  }
  return ret;
}

// burn_cdtext_get
// file libburn/structure.c line 983
static signed int burn_cdtext_get(struct burn_cdtext *t, signed int pack_type, char *pack_type_name, unsigned char **payload, signed int *length, signed int flag)
{
  if(!(pack_type_name == ((char *)NULL)))
  {
    if(!(*pack_type_name == 0))
      pack_type=burn_cdtext_name_to_type(pack_type_name);

  }

  if(pack_type >= 0x10 || !(pack_type >= 0x80))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002018c, 0x68000000, 0x30000000, "CD-TEXT pack type out of range", 0, 0);
    return 0;
  }

  else
  {
    *payload = t->payload[(signed long int)(pack_type - 0x80)];
    *length = t->length[(signed long int)(pack_type - 0x80)];
    return 1 + (t->flags >> pack_type - 0x80 & 1);
  }
}

// burn_cdtext_name_to_type
// file libburn/structure.c line 922
static signed int burn_cdtext_name_to_type(char *pack_type_name)
{
  signed int i;
  signed int j;
  i = 0;
  signed int return_value_tolower$1;
  static char *pack_type_names[16l] = { "TITLE", "PERFORMER", "SONGWRITER", "COMPOSER", "ARRANGER", "MESSAGE", "DISCID", "GENRE", "TOC", "TOC2", "", "", "", "CLOSED", "UPC_ISRC", "BLOCKSIZE" };
  for( ; !(i >= 0x10); i = i + 1)
    if(!((signed int)*pack_type_names[(signed long int)i] == 0))
    {
      j = 0;
      for( ; !(pack_type_names[(signed long int)i][(signed long int)j] == 0); j = j + 1)
        if(!(pack_type_names[(signed long int)i][(signed long int)j] == pack_type_name[(signed long int)j]))
        {
          return_value_tolower$1=tolower((signed int)pack_type_names[(signed long int)i][(signed long int)j]);
          if(!(return_value_tolower$1 == (signed int)pack_type_name[(signed long int)j]))
            break;

        }

      if((signed int)pack_type_names[(signed long int)i][(signed long int)j] == 0)
        return 0x80 + i;

    }

  return -1;
}

// burn_cdtext_set
// file libburn/structure.c line 946
static signed int burn_cdtext_set(struct burn_cdtext **cdtext, signed int pack_type, char *pack_type_name, unsigned char *payload, signed int length, signed int flag)
{
  signed int i;
  struct burn_cdtext *t;
  if(!(pack_type_name == ((char *)NULL)))
  {
    if(!(*pack_type_name == 0))
      pack_type=burn_cdtext_name_to_type(pack_type_name);

  }

  if(pack_type >= 0x10 || !(pack_type >= 0x80))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002018c, 0x68000000, 0x30000000, "CD-TEXT pack type out of range", 0, 0);
    return 0;
  }

  else
  {
    t = *cdtext;
    if(t == ((struct burn_cdtext *)NULL))
    {
      t=burn_cdtext_create();
      *cdtext = t;
      if(!(t == ((struct burn_cdtext *)NULL)))
        goto __CPROVER_DUMP_L3;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      i = pack_type - 0x80;
      if(!(t->payload[(signed long int)i] == ((unsigned char *)NULL)))
        free((void *)t->payload[(signed long int)i]);

      void *return_value_burn_alloc_mem$1;
      return_value_burn_alloc_mem$1=burn_alloc_mem((unsigned long int)length, (unsigned long int)1, 0);
      t->payload[(signed long int)i] = (unsigned char *)return_value_burn_alloc_mem$1;
      if(t->payload[(signed long int)i] == ((unsigned char *)NULL))
        return -1;

      else
      {
        memcpy((void *)t->payload[(signed long int)i], (const void *)payload, (unsigned long int)length);
        t->length[(signed long int)i] = length;
        t->flags = t->flags & ~(1 << i) | flag & 1 << i;
        return 1;
      }
    }
  }
}

// burn_create_bl_size_packs
// file libburn/cdtext.c line 192
static signed int burn_create_bl_size_packs(signed int block, unsigned char *char_codes, unsigned char *copyrights, unsigned char *languages, signed int num_tracks, struct burn_pack_cursor *crs, signed int flag)
{
  signed int i;
  signed int ret;
  unsigned char payload[12l];
  payload[(signed long int)0] = char_codes[(signed long int)block];
  payload[(signed long int)1] = (unsigned char)crs->track_offset;
  payload[(signed long int)2] = (unsigned char)((num_tracks + crs->track_offset) - 1);
  payload[(signed long int)3] = copyrights[(signed long int)block];
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    payload[(signed long int)(i + 4)] = (unsigned char)crs->pack_count[(signed long int)i];
  ret=burn_create_tybl_packs(payload, 12, 0, 0x8f, block, crs, 0);
  if(!(ret >= 1))
    return ret;

  else
  {
    i = 0;
    for( ; !(i >= 7); i = i + 1)
      payload[(signed long int)i] = (unsigned char)crs->pack_count[(signed long int)(i + 8)];
    payload[(signed long int)7] = (unsigned char)3;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      payload[(signed long int)(i + 8)] = (unsigned char)0;
    ret=burn_create_tybl_packs(payload, 12, 1, 0x8f, block, crs, 0);
    if(!(ret >= 1))
      return ret;

    else
    {
      i = 0;
      for( ; !(i >= 4); i = i + 1)
        payload[(signed long int)i] = (unsigned char)0;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        payload[(signed long int)(i + 4)] = languages[(signed long int)i];
      ret=burn_create_tybl_packs(payload, 12, 2, 0x8f, block, crs, 0);
      if(!(ret >= 1))
        return ret;

      else
      {
        ret=burn_finalize_text_pack(crs, 0);
        if(!(ret >= 1))
          return ret;

        else
        {
          i = 0;
          for( ; !(i >= 16); i = i + 1)
            crs->pack_count[(signed long int)i] = 0;
          return 1;
        }
      }
    }
  }
}

// burn_create_new_pack
// file libburn/cdtext.c line 45
signed int burn_create_new_pack(signed int pack_type, signed int track_no, signed int double_byte, signed int block, signed int char_pos, struct burn_pack_cursor *crs, signed int flag)
{
  signed int idx;
  if(crs->num_packs >= 2048)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002018b, 0x68000000, 0x30000000, "Too many CD-TEXT packs", 0, 0);
    return 0;
  }

  else
    if(crs->hiseq[(signed long int)block] >= 255)
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x0002018e, 0x68000000, 0x30000000, "Too many CD-TEXT packs in block", 0, 0);
      return 0;
    }

    else
    {
      if(char_pos >= 16)
        char_pos = 15;

      else
        if(!(char_pos >= 0))
          char_pos = 0;

      idx = crs->num_packs * 18;
      signed int tmp_post$1 = idx;
      idx = idx + 1;
      crs->packs[(signed long int)tmp_post$1] = (unsigned char)pack_type;
      signed int tmp_post$2 = idx;
      idx = idx + 1;
      crs->packs[(signed long int)tmp_post$2] = (unsigned char)track_no;
      signed int tmp_post$3 = idx;
      idx = idx + 1;
      crs->packs[(signed long int)tmp_post$3] = (unsigned char)crs->hiseq[(signed long int)block];
      signed int tmp_post$4 = idx;
      idx = idx + 1;
      crs->packs[(signed long int)tmp_post$4] = (unsigned char)((flag & 1) << 7 | block << 4 | char_pos);
      crs->hiseq[(signed long int)block] = crs->hiseq[(signed long int)block] + 1;
      crs->td_used = 0;
      crs->pack_count[(signed long int)(pack_type - 0x80)] = crs->pack_count[(signed long int)(pack_type - 0x80)] + 1;
      return 1;
    }
}

// burn_create_text_packs
// file libburn/write.c line 909
static signed int burn_create_text_packs(struct burn_write_opts *o, struct burn_session *s, signed int flag)
{
  signed int ret;
  signed int num_packs = 0;
  unsigned char *text_packs = (unsigned char *)(void *)0;
  ret=burn_cdtext_from_session(s, &text_packs, &num_packs, 0);
  if(ret >= 1)
  {
    if(!(o->text_packs == ((unsigned char *)NULL)))
      free((void *)o->text_packs);

    o->text_packs = text_packs;
    o->num_text_packs = num_packs;
  }

  return ret;
}

// burn_create_toc_entries
// file libburn/write.c line 465
struct cue_sheet * burn_create_toc_entries(struct burn_write_opts *o, struct burn_session *session, signed int nwa)
{
  signed int i;
  signed int m;
  signed int s;
  signed int f;
  signed int form;
  signed int runtime = -150;
  signed int ret;
  signed int track_length;
  signed int leadin_form;
  signed int leadin_start;
  signed int pregap = 150;
  signed int postgap;
  unsigned char ctladr;
  unsigned char scms;
  struct burn_drive *d;
  struct burn_toc_entry *e;
  struct cue_sheet *sheet;
  struct burn_track **tar = session->track;
  signed int ntr = session->tracks;
  signed int rem = 0;
  signed int j;
  void *return_value_calloc$2;
  signed int return_value_burn_track_is_open_ended$3;
  if(!(ntr >= 1))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002019c, 0x60000000, 0x30000000, "Session has no defined tracks", 0, 0);
    return (struct cue_sheet *)(void *)0;
  }

  else
  {
    d = o->drive;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct cue_sheet) /*16ul*/ );
    sheet = (struct cue_sheet *)return_value_calloc$1;
    if(sheet == ((struct cue_sheet *)NULL))
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00020111, 0x70000000, 0x30000000, "Could not allocate new auxiliary object (cue_sheet)", 0, 0);
      return (struct cue_sheet *)(void *)0;
    }

    else
    {
      sheet->data = (unsigned char *)(void *)0;
      sheet->count = 0;
      type_to_form(tar[(signed long int)0]->mode, &ctladr, &form);
      if(form == -1)
        libdax_msgs_submit(libdax_messenger, -1, 0x00020116, 0x70000000, 0x30000000, "Track mode has unusable value", 0, 0);

      else
      {
        if(!((64 & (*tar)->mode) == 0))
          leadin_form = 0x01;

        else
          leadin_form = 0x14;
        if(o->num_text_packs >= 1)
          leadin_form = leadin_form | 0x40;

        else
          if(o->text_packs == ((unsigned char *)NULL))
          {
            ret=burn_cdtext_from_session(session, (unsigned char **)(void *)0, (signed int *)(void *)0, 1);
            if(!(ret >= 0))
              goto failed;

            else
              if(ret >= 1)
                leadin_form = leadin_form | 0x40;

          }

        if(!(o->has_mediacatalog == 0))
          ret=add_catalog_cue(sheet, o->mediacatalog);

        else
          if(!(session->mediacatalog[0l] == 0))
            ret=add_catalog_cue(sheet, session->mediacatalog);

          else
            ret = 1;
        if(ret >= 1)
        {
          leadin_start = runtime;
          ret=add_cue(sheet, (unsigned char)((signed int)ctladr & 64 | 1), (unsigned char)0, (unsigned char)0, (unsigned char)leadin_form, (unsigned char)0, leadin_start);
          if(ret >= 1)
          {
            d->toc_entries = ntr + 3;
            if(!(d->toc_entry == ((struct burn_toc_entry *)NULL)))
              free((void *)(char *)d->toc_entry);

            if(ntr + (signed int)session->firsttrack + -1 >= 100)
              libdax_msgs_submit(libdax_messenger, -1, 0x0002019b, 0x60000000, 0x30000000, "CD track number exceeds 99", 0, 0);

            else
            {
              session->lasttrack = (unsigned char)(((signed int)session->firsttrack + ntr) - 1);
              return_value_calloc$2=calloc((unsigned long int)d->toc_entries, sizeof(struct burn_toc_entry) /*32ul*/ );
              d->toc_entry = (struct burn_toc_entry *)return_value_calloc$2;
              e = d->toc_entry;
              (e + (signed long int)0)->point = (unsigned char)0xA0;
              if(!((64 & (*tar)->mode) == 0))
                (e + (signed long int)0)->control = (unsigned char)0;

              else
                (e + (signed long int)0)->control = (unsigned char)(1 << 2);
              (e + (signed long int)0)->pmin = session->firsttrack;
              (e + (signed long int)0)->psec = (unsigned char)o->format;
              (e + (signed long int)0)->adr = (unsigned char)1;
              (e + (signed long int)1)->point = (unsigned char)0xA1;
              (e + (signed long int)1)->pmin = session->lasttrack;
              (e + (signed long int)1)->adr = (unsigned char)1;
              if(!((64 & tar[(signed long int)(ntr + -1)]->mode) == 0))
                (e + (signed long int)1)->control = (unsigned char)0;

              else
                (e + (signed long int)1)->control = (unsigned char)(1 << 2);
              (e + (signed long int)2)->point = (unsigned char)0xA2;
              (e + (signed long int)2)->control = (e + (signed long int)1)->control;
              (e + (signed long int)2)->adr = (unsigned char)1;
              tar[(signed long int)0]->pregap2 = 1;
              if(!((*tar)->pregap2_size >= 150))
                tar[(signed long int)0]->pregap2_size = 150;

              i = 0;
              for( ; !(i >= ntr); i = i + 1)
              {
                track_length=burn_track_get_sectors_2(tar[(signed long int)i], 1);
                if(!(track_length >= 300))
                {
                  return_value_burn_track_is_open_ended$3=burn_track_is_open_ended(tar[(signed long int)i]);
                  if(return_value_burn_track_is_open_ended$3 == 0)
                  {
                    track_length = 300;
                    if(tar[(signed long int)i]->pad == 0)
                      tar[(signed long int)i]->pad = 1;

                    burn_track_set_sectors(tar[(signed long int)i], track_length);
                  }

                }

                type_to_form(tar[(signed long int)i]->mode, &ctladr, &form);
                if(!((8192 & tar[(signed long int)i]->mode) == 0))
                  scms = (unsigned char)0x80;

                else
                  scms = (unsigned char)0;
                if(!(tar[(signed long int)i]->isrc.has_isrc == 0))
                {
                  ret=add_isrc_cue(sheet, ctladr, i + (signed int)session->firsttrack, &tar[(signed long int)i]->isrc);
                  if(!(ret >= 1))
                    goto failed;

                }

                pregap = 0;
                if(!(tar[(signed long int)i]->pregap2 == 0))
                  pregap = tar[(signed long int)i]->pregap2_size;

                postgap = 0;
                if(!(tar[(signed long int)i]->postgap == 0))
                {
                  if((signed int)tar[(signed long int)i]->indices >= 99)
                  {
                    libdax_msgs_submit(libdax_messenger, -1, 0x0002019a, 0x60000000, 0x30000000, "Post-gap index number exceeds 99", 0, 0);
                    goto failed;
                  }

                  if(!((signed int)tar[(signed long int)i]->indices >= 2))
                    tar[(signed long int)i]->indices = (unsigned char)2;

                  tar[(signed long int)i]->index[(signed long int)tar[(signed long int)i]->indices] = track_length;
                  postgap = tar[(signed long int)i]->postgap_size;
                }

                j = 0;
                for( ; !(j >= (signed int)tar[(signed long int)i]->indices + (signed int)!(tar[(signed long int)i]->postgap == 0)) || !(j >= 2); j = j + 1)
                {
                  if(tar[(signed long int)i]->index[(signed long int)j] == 0x7fffffff)
                  {
                    if(j >= 2)
                      break;

                    if(j == 0 && !(pregap >= 1))
                      goto __CPROVER_DUMP_L35;

                    tar[(signed long int)i]->index[(signed long int)j] = 0;
                  }

                  else
                    if(j == 0)
                      tar[(signed long int)i]->index[(signed long int)j] = 0;

                    else
                      if(j == 1)
                      {
                        if(tar[(signed long int)i]->index[0l] == 0x7fffffff)
                          tar[(signed long int)i]->index[(signed long int)j] = 0;

                      }

                  if(j == 1)
                  {
                    tar[(signed long int)i]->entry = &e[(signed long int)(3 + i)];
                    (e + (signed long int)(3 + i))->point = (unsigned char)(i + (signed int)session->firsttrack);
                    burn_lba_to_msf(runtime, &m, &s, &f);
                    (e + (signed long int)(3 + i))->pmin = (unsigned char)m;
                    (e + (signed long int)(3 + i))->psec = (unsigned char)s;
                    (e + (signed long int)(3 + i))->pframe = (unsigned char)f;
                    (e + (signed long int)(3 + i))->adr = (unsigned char)1;
                    signed int return_value_type_to_ctrl$4;
                    return_value_type_to_ctrl$4=type_to_ctrl(tar[(signed long int)i]->mode);
                    (e + (signed long int)(3 + i))->control = (unsigned char)return_value_type_to_ctrl$4;
                  }

                  tar[(signed long int)i]->index[(signed long int)j] = tar[(signed long int)i]->index[(signed long int)j] + runtime;
                  ret=add_cue(sheet, (unsigned char)((signed int)ctladr | 1), (unsigned char)(i + (signed int)session->firsttrack), (unsigned char)j, (unsigned char)form, scms, tar[(signed long int)i]->index[(signed long int)j]);
                  if(!(ret >= 1))
                    goto failed;

                  runtime = runtime + pregap;
                  pregap = 0;

                __CPROVER_DUMP_L35:
                  ;
                }
                runtime = runtime + track_length + postgap;
                if(tar[(signed long int)i]->pad == 0)
                {
                  signed int return_value_burn_track_get_shortage$5;
                  return_value_burn_track_get_shortage$5=burn_track_get_shortage(tar[(signed long int)i]);
                  rem = rem + return_value_burn_track_get_shortage$5;
                  if((signed int)o->write_type == BURN_WRITE_TAO)
                    tar[(signed long int)i]->source->next = (struct burn_source *)(void *)0;

                  else
                    if(!(1 + i == ntr))
                      tar[(signed long int)i]->source->next = tar[(signed long int)(i + 1)]->source;

                }

                else
                  if(!(rem == 0))
                  {
                    rem = 0;
                    runtime = runtime + 1;
                  }

                signed int return_value_burn_sector_length$7;
                return_value_burn_sector_length$7=burn_sector_length(tar[(signed long int)i]->mode);
                if(!(return_value_burn_sector_length$7 >= rem))
                {
                  signed int return_value_burn_sector_length$6;
                  return_value_burn_sector_length$6=burn_sector_length(tar[(signed long int)i]->mode);
                  rem = rem - return_value_burn_sector_length$6;
                  runtime = runtime - 1;
                }

              }
              burn_lba_to_msf(runtime, &m, &s, &f);
              (e + (signed long int)2)->pmin = (unsigned char)m;
              (e + (signed long int)2)->psec = (unsigned char)s;
              (e + (signed long int)2)->pframe = (unsigned char)f;
              ret=add_cue(sheet, (unsigned char)((signed int)ctladr | 1), (unsigned char)0xAA, (unsigned char)1, (unsigned char)(leadin_form & 0x3f), (unsigned char)0, runtime);
              if(ret >= 1)
                return sheet;

            }
          }

        }

      }

    failed:
      ;
      if(!(sheet == ((struct cue_sheet *)NULL)))
        free((void *)(char *)sheet);

      return (struct cue_sheet *)(void *)0;
    }
  }
}

// burn_create_tybl_packs
// file libburn/cdtext.c line 159
static signed int burn_create_tybl_packs(unsigned char *payload, signed int length, signed int track_no, signed int pack_type, signed int block, struct burn_pack_cursor *crs, signed int flag)
{
  signed int i;
  signed int ret;
  signed int binary_part = 0;
  signed int char_pos;
  if(pack_type == 0x87)
    binary_part = 2;

  else
    if(pack_type == 0x8f || pack_type >= 0x88 && !(pack_type >= 141))
      binary_part = length;

  i = 0;
  for( ; !(i >= length); i = i + 1)
  {
    _Bool tmp_if_expr$1;
    if(crs->td_used == 0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = crs->td_used >= 12 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(crs->td_used >= 1)
      {
        ret=burn_finalize_text_pack(crs, 0);
        if(!(ret >= 1))
          return ret;

      }

      char_pos = (i - binary_part) / (1 + (flag & 1));
      ret=burn_create_new_pack(pack_type, track_no, flag & 1, block, char_pos, crs, flag & 1);
      if(!(ret >= 1))
        return ret;

    }

    crs->packs[(signed long int)(crs->num_packs * 18 + 4 + crs->td_used)] = payload[(signed long int)i];
    crs->td_used = crs->td_used + 1;
  }
  return 1;
}

// burn_create_tybl_s_packs
// file libburn/cdtext.c line 313
static signed int burn_create_tybl_s_packs(struct burn_session *s, signed int pack_type, signed int block, struct burn_pack_cursor *crs, signed int flag)
{
  signed int i;
  signed int ret;
  signed int idx;
  signed int double_byte;
  signed int use_tab;
  struct burn_cdtext *cdt = s->cdtext[(signed long int)block];
  idx = pack_type - 0x80;
  _Bool tmp_if_expr$1;
  if(cdt->length[(signed long int)idx] == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = cdt->payload[(signed long int)idx] == (unsigned char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    double_byte = (signed int)!(!((cdt->flags & 1 << pack_type - 0x80) != 0));
    ret=burn_create_tybl_packs(cdt->payload[(signed long int)idx], cdt->length[(signed long int)idx], 0, pack_type, block, crs, double_byte);
    if(!(ret >= 1))
      return ret;

    else
      if(!(pack_type == 0x8e) && (pack_type >= 134 || !(pack_type >= 0x80)))
      {
        ret=burn_finalize_text_pack(crs, 0);
        return ret;
      }

      else
      {
        i = 0;
        for( ; !(i >= s->tracks); i = i + 1)
        {
          if(i >= 1)
            use_tab=burn_decide_cdtext_tab(block, pack_type, s->track[(signed long int)i]->cdtext[(signed long int)block], s->track[(signed long int)(i - 1)]->cdtext[(signed long int)block], 0);

          else
            use_tab = 0;
          ret=burn_create_tybl_t_packs(s->track[(signed long int)i], i + crs->track_offset, pack_type, block, crs, use_tab);
          if(!(ret >= 1))
            return ret;

        }
        ret=burn_finalize_text_pack(crs, 0);
        return ret;
      }
  }
}

// burn_create_tybl_t_packs
// file libburn/cdtext.c line 245
static signed int burn_create_tybl_t_packs(struct burn_track *t, signed int track_no, signed int pack_type, signed int block, struct burn_pack_cursor *crs, signed int flag)
{
  signed int ret;
  signed int length = 0;
  signed int idx;
  signed int double_byte;
  signed int flags = 0;
  unsigned char *payload = (unsigned char *)(void *)0;
  unsigned char dummy[8l];
  struct burn_cdtext *cdt = t->cdtext[(signed long int)block];
  idx = pack_type - 0x80;
  if(!(cdt == ((struct burn_cdtext *)NULL)))
  {
    if(cdt->length[(signed long int)idx] >= 1)
    {
      payload = cdt->payload[(signed long int)idx];
      length = cdt->length[(signed long int)idx];
    }

    flags = cdt->flags;
  }

  if(payload == ((unsigned char *)NULL))
  {
    dummy[(signed long int)0] = (unsigned char)0;
    payload = dummy;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((char *)dummy);
    length = (signed int)(return_value_strlen$1 + (unsigned long int)1);
  }

  double_byte = (signed int)!(!((flags & 1 << pack_type - 0x80) != 0));
  if(!((1 & flag) == 0))
  {
    length = 0;
    signed int tmp_post$2 = length;
    length = length + 1;
    dummy[(signed long int)tmp_post$2] = (unsigned char)9;
    if(!(double_byte == 0))
    {
      signed int tmp_post$3 = length;
      length = length + 1;
      dummy[(signed long int)tmp_post$3] = (unsigned char)9;
    }

    signed int tmp_post$4 = length;
    length = length + 1;
    dummy[(signed long int)tmp_post$4] = (unsigned char)0;
    if(!(double_byte == 0))
    {
      signed int tmp_post$5 = length;
      length = length + 1;
      dummy[(signed long int)tmp_post$5] = (unsigned char)0;
    }

    payload = dummy;
  }

  ret=burn_create_tybl_packs(payload, length, track_no, pack_type, block, crs, double_byte);
  return ret;
}

// burn_decide_cdtext_tab
// file libburn/cdtext.c line 287
static signed int burn_decide_cdtext_tab(signed int block, signed int pack_type, struct burn_cdtext *cdt_curr, struct burn_cdtext *cdt_prev, signed int flag)
{
  signed int length;
  signed int j;
  signed int idx = pack_type - 0x80;
  if(cdt_curr == ((struct burn_cdtext *)NULL) || cdt_prev == ((struct burn_cdtext *)NULL))
    return 0;

  else
    if(!((cdt_curr->flags >> idx & 1) == (cdt_prev->flags >> idx & 1)))
      return 0;

    else
    {
      length = cdt_curr->length[(signed long int)idx];
      _Bool tmp_if_expr$1;
      if(!(length == cdt_prev->length[(signed long int)idx]))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = length <= 1 + (cdt_curr->flags >> idx & 1) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        return 0;

      else
      {
        j = 0;
        for( ; !(j >= length); j = j + 1)
          if(!(cdt_curr->payload[(signed long int)idx][(signed long int)j] == cdt_prev->payload[(signed long int)idx][(signed long int)j]))
            break;

        if(!(j >= length))
          return 0;

        else
          return 1;
      }
    }
}

// burn_disc_add_session
// file libburn/libburn.h line 1953
signed int burn_disc_add_session(struct burn_disc *d, struct burn_session *s, unsigned int pos)
{
  void *tmp;
  if(pos >= 101u)
    return 0;

  else
  {
    if(pos == 100u)
      pos = (unsigned int)d->sessions;

    if(!(d->sessions >= (signed int)pos))
      return 0;

    else
    {
      tmp=realloc((void *)d->session, sizeof(struct session *) /*8ul*/  * (unsigned long int)(d->sessions + 1));
      if(tmp == NULL)
        return 0;

      else
      {
        d->session = (struct burn_session **)tmp;
        memmove((void *)(d->session + (signed long int)pos + (signed long int)1), (const void *)(d->session + (signed long int)pos), sizeof(struct session *) /*8ul*/  * (unsigned long int)((unsigned int)d->sessions - pos));
        d->sessions = d->sessions + 1;
        d->session[(signed long int)pos] = s;
        s->refcnt = s->refcnt + 1;
        return 1;
      }
    }
  }
}

// burn_disc_available_space
// file test/../libburn/libburn.h line 1537
signed long int burn_disc_available_space(struct burn_drive *d, struct burn_write_opts *o)
{
  signed int lba;
  signed int nwa;
  signed int ret;
  signed long int bytes;
  signed long int start_byte = (signed long int)0;
  signed int return_value_burn_drive_is_released$1;
  return_value_burn_drive_is_released$1=burn_drive_is_released(d);
  if(!(return_value_burn_drive_is_released$1 == 0))
    return (signed long int)0;

  else
    if(!((signed int)d->busy == BURN_DRIVE_IDLE))
      return (signed long int)0;

    else
      if(d->drive_role == 0)
        return (signed long int)0;

      else
      {
        if(!(d->drive_role == 1))
        {
          if(!(o == ((struct burn_write_opts *)NULL)))
            start_byte = o->start_byte;

          ret=burn_os_stdio_capacity(d->devname, start_byte, &bytes);
          if(!(ret == 1))
            bytes = d->media_capacity_remaining;

          if(!(bytes >= 1l))
            bytes = (signed long int)(512 * 1024 * 1024 - 1) * (signed long int)2048;

          if(!(bytes == d->media_capacity_remaining))
            burn_drive_set_media_capacity_remaining(d, bytes);

        }

        else
        {
          if(!(o == ((struct burn_write_opts *)NULL)))
            d->send_write_parameters(d, (struct burn_session *)(void *)0, -1, o);

          d->get_nwa(d, -1, &lba, &nwa);
        }
        if(!(o == ((struct burn_write_opts *)NULL)))
        {
          if(!(o->start_byte >= 1l))
            goto __CPROVER_DUMP_L12;

          if(!(d->media_capacity_remaining >= o->start_byte))
            return (signed long int)0;

          return d->media_capacity_remaining - o->start_byte;
        }

        else
        {

        __CPROVER_DUMP_L12:
          ;
          return d->media_capacity_remaining;
        }
      }
}

// burn_disc_cd_toc_extensions
// file libburn/structure.h line 177
signed int burn_disc_cd_toc_extensions(struct burn_drive *drive, signed int flag)
{
  signed int sidx = 0;
  signed int tidx = 0;
  signed int ret;
  signed int track_offset;
  signed int alloc_len = 34;
  struct burn_toc_entry *entry;
  struct burn_toc_entry *prev_entry = (struct burn_toc_entry *)(void *)0;
  struct burn_disc *d;
  char *msg_data = (char *)(void *)0;
  char *msg;
  struct buffer *buf = (struct buffer *)(void *)0;
  d = drive->disc;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)321, 0);
  msg_data = (char *)return_value_burn_alloc_mem$1;
  unsigned long int return_value_strlen$3;
  if(msg_data == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(buf == ((struct buffer *)NULL))
      ret = -1;

    else
    {
      strcpy(msg_data, "Damaged CD table-of-content detected and truncated.");
      strcat(msg_data, " In burn_disc_cd_toc_extensions: ");
      return_value_strlen$3=strlen(msg_data);
      msg = msg_data + (signed long int)return_value_strlen$3;
      if(d->session == ((struct burn_session **)NULL))
        strcpy(msg, "d->session == NULL");

      else
      {
        if(!(d->sessions >= 1))
        {
          ret = 1;
          goto ex;
        }

        sidx = 0;
        for( ; !(sidx >= d->sessions); sidx = sidx + 1)
        {
          track_offset=burn_session_get_start_tno(d->session[(signed long int)sidx], 0);
          if(!(track_offset >= 1))
            track_offset = 1;

          if(d->session[(signed long int)sidx] == ((struct burn_session *)NULL))
          {
            sprintf(msg, "d->session[%d of %d] == NULL", sidx, d->sessions);
            goto failure;
          }

          if(d->session[(signed long int)sidx]->track == ((struct burn_track **)NULL))
          {
            sprintf(msg, "d->session[%d of %d]->track == NULL", sidx, d->sessions);
            goto failure;
          }

          if(d->session[(signed long int)sidx]->leadout_entry == ((struct burn_toc_entry *)NULL))
          {
            sprintf(msg, " Session %d of %d: Leadout entry missing.", sidx, d->sessions);
            goto failure;
          }

          tidx = 0;
          for( ; !(tidx >= 1 + d->session[(signed long int)sidx]->tracks); tidx = tidx + 1)
          {
            if(!(tidx >= d->session[(signed long int)sidx]->tracks))
            {
              if(d->session[(signed long int)sidx]->track[(signed long int)tidx] == ((struct burn_track *)NULL))
              {
                sprintf(msg, "d->session[%d of %d]->track[%d of %d] == NULL", sidx, d->sessions, tidx, d->session[(signed long int)sidx]->tracks);
                goto failure;
              }

              entry = d->session[(signed long int)sidx]->track[(signed long int)tidx]->entry;
              if(entry == ((struct burn_toc_entry *)NULL))
              {
                sprintf(msg, "session %d of %d, track %d of %d, entry == NULL", sidx, d->sessions, tidx, d->session[(signed long int)sidx]->tracks);
                goto failure;
              }

            }

            else
              entry = d->session[(signed long int)sidx]->leadout_entry;
            entry->session_msb = (unsigned char)0;
            entry->point_msb = (unsigned char)0;
            entry->start_lba=burn_msf_to_lba((signed int)entry->pmin, (signed int)entry->psec, (signed int)entry->pframe);
            if(tidx >= 1)
            {
              prev_entry->track_blocks = entry->start_lba - prev_entry->start_lba;
              ret=mmc_read_track_info(drive, (tidx - 1) + track_offset, buf, alloc_len);
              if(ret >= 1)
              {
                ret=mmc_four_char_to_int(buf->data + (signed long int)24);
                if(!(ret >= prev_entry->track_blocks))
                {
                  _Bool tmp_if_expr$4;
                  if(drive->current_is_cd_profile == 0)
                    tmp_if_expr$4 = (_Bool)1;

                  else
                    tmp_if_expr$4 = ret < prev_entry->track_blocks - 2 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$4)
                    prev_entry->track_blocks = ret;

                }

              }

              prev_entry->extensions_valid = prev_entry->extensions_valid | (unsigned char)1;
            }

            if(tidx == d->session[(signed long int)sidx]->tracks)
            {
              entry->session_msb = (unsigned char)0;
              entry->point_msb = (unsigned char)0;
              entry->track_blocks = 0;
              entry->extensions_valid = entry->extensions_valid | (unsigned char)1;
            }

            prev_entry = entry;
          }
        }
        ret = 1;
        goto ex;
      }

    failure:
      ;
      libdax_msgs_submit(libdax_messenger, -1, 0x0002015f, 0x64000000, 0x30000000, msg_data, 0, 0);
      d->sessions = sidx;
      ret = 0;
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(msg_data == ((char *)NULL)))
    free((void *)(char *)msg_data);

  return ret;
}

// burn_disc_close_damaged
// file libburn/write.c line 3334
signed int burn_disc_close_damaged(struct burn_write_opts *o, signed int flag)
{
  struct burn_drive *d;
  signed int ret;
  enum burn_drive_status busy;
  d = o->drive;
  busy = d->busy;
  if(!((signed int)busy == BURN_DRIVE_IDLE))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020106, 0x60000000, 0x30000000, "Drive is busy on attempt to close damaged session", 0, 0);
    ret = 0;
  }

  else
    if((1 & d->next_track_damaged) == 0 && (1 & flag) == 0)
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020187, 0x30000000, 0x30000000, "Track not marked as damaged. No action taken.", 0, 0);
      ret = 0;
    }

    else
    {
      d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
      _Bool tmp_if_expr$3;
      if(d->current_profile == 0x09)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = d->current_profile == 0x0a ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        o->write_type = (enum burn_write_types)BURN_WRITE_TAO;
        d->send_write_parameters(d, (struct burn_session *)(void *)0, -1, o);
        ret=burn_write_close_session(o);
      }

      else
      {
        _Bool tmp_if_expr$2;
        if(d->current_profile == 0x11)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          o->write_type = (enum burn_write_types)BURN_WRITE_TAO;
          d->send_write_parameters(d, (struct burn_session *)(void *)0, -1, o);
          ret=burn_disc_close_track_dvd_minus_r(o, 0);
          ret=burn_disc_close_session_dvd_minus_r(o);
        }

        else
        {
          _Bool tmp_if_expr$1;
          if(d->current_profile == 0x1b)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
          {
            ret=burn_disc_close_track_dvd_plus_r(o, d->last_track_no, 1);
            if(!(ret >= 1))
              goto ex;

          }

          else
            if(d->current_profile == 0x41)
            {
              ret=burn_disc_close_track_dvd_plus_r(o, d->last_track_no, 1);
              if(!(ret >= 1))
                goto ex;

            }

            else
            {
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020188, 0x68000000, 0x30000000, "Cannot close damaged track on given media type", 0, 0);
              ret = 0;
              goto ex;
            }
        }
      }
      ret = 1;
    }

ex:
  ;
  d->busy = busy;
  d->next_track_damaged = d->next_track_damaged & ~1;
  return ret;
}

// burn_disc_close_session_dvd_minus_r
// file libburn/write.c line 2040
signed int burn_disc_close_session_dvd_minus_r(struct burn_write_opts *o)
{
  struct burn_drive *d = o->drive;
  if(!((signed int)o->write_type == BURN_WRITE_TAO))
    return 2;

  else
  {
    libdax_msgs_submit(libdax_messenger, o->drive->global_index, 0x00020119, 0x10000000, 0x30000000, "Closing session", 0, 0);
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
    d->close_track_session(d, 1, 0);
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
    return 1;
  }
}

// burn_disc_close_session_dvd_minus_rw
// file libburn/write.c line 2021
signed int burn_disc_close_session_dvd_minus_rw(struct burn_write_opts *o, struct burn_session *s)
{
  struct burn_drive *d = o->drive;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
  if(d->current_profile == 0x13)
    d->close_track_session(d, 1, 0);

  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_disc_close_session_dvd_plus_rw
// file libburn/write.c line 2001
signed int burn_disc_close_session_dvd_plus_rw(struct burn_write_opts *o, struct burn_session *s)
{
  struct burn_drive *d = o->drive;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
  d->close_track_session(d, 1, 0);
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_disc_close_track_dvd_minus_r
// file libburn/write.c line 1664
signed int burn_disc_close_track_dvd_minus_r(struct burn_write_opts *o, signed int tnum)
{
  struct burn_drive *d = o->drive;
  char msg[80l];
  if(!((signed int)o->write_type == BURN_WRITE_TAO))
    return 2;

  else
  {
    sprintf(msg, "Closing track %2.2d  (absolute track number %d)", tnum + 1, d->last_track_no);
    libdax_msgs_submit(libdax_messenger, o->drive->global_index, 0x00020119, 0x10000000, 0x30000000, msg, 0, 0);
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
    d->close_track_session(d, 0, d->last_track_no);
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
    d->last_track_no = d->last_track_no + 1;
    return 1;
  }
}

// burn_disc_close_track_dvd_plus_r
// file libburn/write.c line 1720
signed int burn_disc_close_track_dvd_plus_r(struct burn_write_opts *o, signed int tnum, signed int is_last_track)
{
  struct burn_drive *d = o->drive;
  char msg[80l];
  sprintf(msg, "Closing track %2.2d  (absolute track and session number %d)", tnum + 1, d->last_track_no);
  libdax_msgs_submit(libdax_messenger, o->drive->global_index, 0x00020119, 0x10000000, 0x30000000, msg, 0, 0);
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
  d->close_track_session(d, 0, d->last_track_no);
  _Bool tmp_if_expr$1;
  if(!(is_last_track == 0))
    tmp_if_expr$1 = !(o->multi != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    burn_disc_finalize_dvd_plus_r(o);

  else
    d->close_track_session(d, 1, 0);
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  d->last_track_no = d->last_track_no + 1;
  return 1;
}

// burn_disc_create
// file libburn/libburn.h line 1929
struct burn_disc * burn_disc_create(void)
{
  struct burn_disc *d;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_disc) /*24ul*/ );
  d = (struct burn_disc *)return_value_calloc$1;
  if(d == ((struct burn_disc *)NULL))
    return (struct burn_disc *)(void *)0;

  else
  {
    d->refcnt = 1;
    d->sessions = 0;
    d->session = (struct burn_session **)(void *)0;
    d->incomplete_sessions = 0;
    return d;
  }
}

// burn_disc_erasable
// file test/../libburn/libburn.h line 1631
signed int burn_disc_erasable(struct burn_drive *d)
{
  return d->erasable;
}

// burn_disc_erase
// file libburn/async.c line 352
void burn_disc_erase(struct burn_drive *drive, signed int fast)
{
  union w_list_data o;
  struct w_list *return_value_find_worker$2;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  if(drive == ((struct burn_drive *)NULL))
    libdax_msgs_submit(libdax_messenger, -1, 0x00020104, 0x60000000, 0x30000000, "NULL pointer caught in burn_disc_erase", 0, 0);

  else
  {
    _Bool tmp_if_expr$1;
    if(!(workers == ((struct w_list *)NULL)))
      tmp_if_expr$1 = workers->w_type == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_find_worker$2=find_worker(drive);
      tmp_if_expr$3 = return_value_find_worker$2 != (struct w_list *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020102, 0x60000000, 0x30000000, "A drive operation is still going on (want to erase)", 0, 0);

    else
    {
      reset_progress(drive, 1, 1, 1, 0x10000, 0);
      drive->cancel = 1;
      _Bool tmp_if_expr$4;
      if(drive->drive_role == 1)
        tmp_if_expr$4 = drive->current_profile != 0x0a ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      _Bool tmp_if_expr$5;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = drive->current_profile != 0x13 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      _Bool tmp_if_expr$6;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = drive->current_profile != 0x14 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      _Bool tmp_if_expr$7;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (signed int)drive->status != BURN_DISC_FULL ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      _Bool tmp_if_expr$10;
      if(tmp_if_expr$7)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        if(!((signed int)drive->status == BURN_DISC_FULL))
          tmp_if_expr$8 = (signed int)drive->status != BURN_DISC_APPENDABLE ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (signed int)drive->status != BURN_DISC_BLANK ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr$12;
      if(tmp_if_expr$10)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        if(!(drive->drive_role == 1))
          tmp_if_expr$11 = drive->drive_role != 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
      {
        char msg[160l];
        sprintf(msg, "Drive and media state unsuitable for blanking. (role= %d , profile= 0x%x , status= %d)", drive->drive_role, (unsigned int)drive->current_profile, drive->status);
        libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020130, 0x60000000, 0x30000000, msg, 0, 0);
        goto __CPROVER_DUMP_L26;
      }

      o.erase.drive = drive;
      o.erase.fast = fast;
      add_worker(1, drive, (void * (*)(void *))erase_worker_func, &o);
    }
  }

__CPROVER_DUMP_L26:
  ;
}

// burn_disc_erase_sync
// file libburn/drive.h line 68
void burn_disc_erase_sync(struct burn_drive *d, signed int fast)
{
  signed int ret;
  signed int was_error = 0;
  if(d->drive_role == 5)
  {
    ret=truncate(d->devname, (signed long int)0);
    if(ret == -1)
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00020182, 0x68000000, 0x30000000, "Cannot truncate disk file for pseudo blanking", 0, 0);
      goto __CPROVER_DUMP_L11;
    }

    d->role_5_nwa = 0;
    d->cancel = 0;
    d->status = (enum burn_disc_status)BURN_DISC_BLANK;
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
    d->progress.sector = 0x10000;
  }

  else
  {
    d->cancel = 0;
    d->erase(d, fast);
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_ERASING;
    ret=d->get_erase_progress(d);
    if(!(ret == -2) && !(ret >= 1))
    {
      if(ret == -3)
        was_error = 1;

      sleep((unsigned int)1);
    }

    ret=d->get_erase_progress(d);
    if(!(ret == -2))
    {
      if(ret == -3)
        was_error = 1;

      if(ret >= 0)
        d->progress.sector = ret;

      sleep((unsigned int)1);
    }

    d->progress.sector = 0x10000;
    burn_drive_mark_unready(d, 0);
    if(d->drive_role == 1)
      burn_drive_inquire_media(d);

    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
    if(!(was_error == 0))
      d->cancel = 1;

  }

__CPROVER_DUMP_L11:
  ;
}

// burn_disc_finalize_dvd_plus_r
// file libburn/write.c line 1688
signed int burn_disc_finalize_dvd_plus_r(struct burn_write_opts *o)
{
  struct burn_drive *d = o->drive;
  char msg[80l];
  sprintf(msg, "Finalizing %s ...", (const void *)d->current_profile_text);
  libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
  if(d->current_profile == 0x41)
    d->close_track_session(d, 3, 0);

  else
    d->close_track_session(d, 2, 1);
  sprintf(msg, "... finalizing %s done               ", (const void *)d->current_profile_text);
  libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
  return 1;
}

// burn_disc_format
// file libburn/async.c line 453
void burn_disc_format(struct burn_drive *drive, signed long int size, signed int flag)
{
  union w_list_data o;
  signed int ok = 0;
  signed int ret;
  char msg[40l];
  reset_progress(drive, 1, 1, 1, 0x10000, 0);
  _Bool tmp_if_expr$1;
  if(!(workers == ((struct w_list *)NULL)))
    tmp_if_expr$1 = workers->w_type == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  struct w_list *return_value_find_worker$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_find_worker$2=find_worker(drive);
    tmp_if_expr$3 = return_value_find_worker$2 != (struct w_list *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020102, 0x60000000, 0x30000000, "A drive operation is still going on (want to format)", 0, 0);

  else
    if(!(drive->drive_role == 1))
    {
      libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020146, 0x70000000, 0x30000000, "Drive is a virtual placeholder", 0, 0);
      drive->cancel = 1;
    }

    else
    {
      if(!((128 & flag) == 0))
        flag = flag | 16;

      if(drive->current_profile == 0x14)
        ok = 1;

      else
        if(drive->current_profile == 0x13 && !((16 & flag) == 0))
          ok = 1;

        else
          if(drive->current_profile == 0x1a)
          {
            ok = 1;
            size = (signed long int)0;
            flag = flag & ~(2 | 8);
            flag = flag | 4;
          }

          else
            if(drive->current_profile == 0x12)
              ok = 1;

            else
              if(drive->current_profile == 0x41)
              {
                ok = 1;
                ret=drive->read_format_capacities(drive, 0x00);
                if(ret >= 1)
                {
                  if(drive->format_descr_type == 2)
                    ok = 0;

                }

                if(!((signed int)drive->status == BURN_DISC_BLANK))
                  ok = 0;

                if(ok == 0)
                {
                  libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020162, 0x60000000, 0x30000000, "BD-R not unformatted blank any more. Cannot format.", 0, 0);
                  drive->cancel = 1;
                }

                if(!((32 & flag) == 0))
                  libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020163, 0x30000000, 0x30000000, "Blank BD-R left unformatted for zero spare capacity.", 0, 0);

              }

              else
                if(drive->current_profile == 0x43)
                {
                  ok = 1;
                  if(!((32 & flag) == 0))
                  {
                    if((8 & drive->current_feat23h_byte4) == 0)
                    {
                      libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020164, 0x60000000, 0x30000000, "Drive does not format BD-RE without spares.", 0, 0);
                      drive->cancel = 1;
                      goto __CPROVER_DUMP_L19;
                    }

                  }

                }

      if(ok == 0)
      {
        sprintf(msg, "Will not format media type %4.4Xh", drive->current_profile);
        libdax_msgs_submit(libdax_messenger, drive->global_index, 0x00020129, 0x60000000, 0x30000000, msg, 0, 0);
        drive->cancel = 1;
      }

      else
      {
        o.format.drive = drive;
        o.format.size = size;
        o.format.flag = flag;
        add_worker(2, drive, (void * (*)(void *))format_worker_func, &o);
      }
    }

__CPROVER_DUMP_L19:
  ;
}

// burn_disc_format_sync
// file libburn/drive.h line 107
void burn_disc_format_sync(struct burn_drive *d, signed long int size, signed int flag)
{
  signed int ret;
  signed int buf_secs;
  signed int err;
  signed int i;
  signed int stages = 1;
  signed int pbase;
  signed int pfill;
  signed int pseudo_sector;
  signed int was_error = 0;
  signed long int num_bufs;
  char msg[80l];
  struct buffer *buf = (struct buffer *)(void *)0;
  struct buffer *buf_mem = d->buffer;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    stages = 1 + (signed int)((flag & 1) != 0 && size > (signed long int)(1024 * 1024));
    d->cancel = 0;
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_FORMATTING;
    ret=d->format_unit(d, size, flag & 0xfff6);
    if(!(ret >= 1))
      d->cancel = 1;

    ret=d->get_erase_progress(d);
    if(!(ret == -2) && !(ret >= 1))
    {
      if(ret == -3)
        was_error = 1;

      sleep((unsigned int)1);
    }

    pseudo_sector=d->get_erase_progress(d);
    if(!(pseudo_sector == -2))
    {
      if(pseudo_sector == -3)
        was_error = 1;

      if(pseudo_sector >= 0)
        d->progress.sector = pseudo_sector / stages;

      sleep((unsigned int)1);
    }

    d->sync_cache(d);
    if(size >= 1l)
    {
      burn_drive_mark_unready(d, 0);
      burn_drive_inquire_media(d);
      if(!((1 & flag) == 0))
      {
        pbase = 0x8000 + 0x7fff * (signed int)(stages == 1);
        pfill = 0xffff - pbase;
        buf_secs = 16;
        num_bufs = (size / (signed long int)buf_secs) / (signed long int)2048;
        if(num_bufs >= 2147483648l)
          d->cancel = 1;

        else
        {
          sprintf(msg, "Writing %.f sectors of zeros to formatted media", (double)num_bufs * (double)buf_secs);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
          d->buffer = buf;
          memset((void *)d->buffer, 0, sizeof(struct buffer) /*69640ul*/ );
          d->buffer->bytes = buf_secs * 2048;
          d->buffer->sectors = buf_secs;
          d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
          i = 0;
          if(!((signed long int)i >= num_bufs))
          {
            d->nwa = i * buf_secs;
            err=d->write(d, d->nwa, d->buffer);
            _Bool tmp_if_expr$2;
            if(err == 1)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = d->cancel != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              d->cancel = 1;

            else
            {
              d->progress.sector = (signed int)((double)pbase + (double)pfill * ((double)i / (double)num_bufs));
              i = i + 1;
            }
          }

          d->sync_cache(d);
          _Bool tmp_if_expr$3;
          if(d->current_profile == 0x13)
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = d->current_profile == 0x1a ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
          {
            d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
            d->close_track_session(d, 1, 0);
            d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
          }

        }
      }

    }

  }

ex:
  ;
  d->progress.sector = 0x10000;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  d->buffer = buf_mem;
  if(!(was_error == 0))
    d->cancel = 1;

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

}

// burn_disc_free
// file test/../libburn/libburn.h line 1934
void burn_disc_free(struct burn_disc *d)
{
  d->refcnt = d->refcnt - 1;
  if(d->refcnt == 0)
  {
    signed int i = 0;
    for( ; !(i >= d->sessions); i = i + 1)
      burn_session_free(d->session[(signed long int)i]);
    free((void *)d->session);
    free((void *)d);
  }

}

// burn_disc_free_multi_caps
// file test/../libburn/libburn.h line 3552
signed int burn_disc_free_multi_caps(struct burn_multi_caps **caps)
{
  if(*caps == ((struct burn_multi_caps *)NULL))
    return 0;

  else
  {
    free((void *)(char *)*caps);
    *caps = (struct burn_multi_caps *)(void *)0;
    return 1;
  }
}

// burn_disc_get_bd_spare_info
// file libburn/drive.c line 3383
signed int burn_disc_get_bd_spare_info(struct burn_drive *d, signed int *alloc_blocks, signed int *free_blocks, signed int flag)
{
  signed int ret;
  signed int return_value_burn_drive_get_drive_role$1;
  return_value_burn_drive_get_drive_role$1=burn_drive_get_drive_role(d);
  if(!(return_value_burn_drive_get_drive_role$1 == 1))
    return 0;

  else
  {
    *free_blocks = 0;
    *alloc_blocks = *free_blocks;
    ret=mmc_get_bd_spare_info(d, alloc_blocks, free_blocks, 0);
    return ret;
  }
}

// burn_disc_get_cd_info
// file libburn/drive.c line 3360
signed int burn_disc_get_cd_info(struct burn_drive *d, char *disc_type, unsigned int *disc_id, char *bar_code, signed int *app_code, signed int *valid)
{
  if(d->disc_type == 0x00)
    strcpy(disc_type, "CD-DA or CD-ROM");

  else
    if(d->disc_type == 0x10)
      strcpy(disc_type, "CD-I");

    else
      if(d->disc_type == 0x20)
        strcpy(disc_type, "CD-ROM XA");

      else
        strcpy(disc_type, "undefined");
  *disc_id = d->disc_id;
  memcpy((void *)bar_code, (const void *)d->disc_bar_code, (unsigned long int)8);
  bar_code[(signed long int)8] = (char)0;
  *app_code = d->disc_app_code;
  *valid = d->disc_info_valid;
  return 1;
}

// burn_disc_get_format_descr
// file test/../libburn/libburn.h line 1781
signed int burn_disc_get_format_descr(struct burn_drive *d, signed int index, signed int *type, signed long int *size, unsigned int *tdp)
{
  *type = 0;
  *size = (signed long int)0;
  *tdp = (unsigned int)0;
  _Bool tmp_if_expr$1;
  if(!(index >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = index >= d->num_format_descr ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    *type = d->format_descriptors[(signed long int)index].type;
    *size = d->format_descriptors[(signed long int)index].size;
    *tdp = d->format_descriptors[(signed long int)index].tdp;
    return 1;
  }
}

// burn_disc_get_formats
// file test/../libburn/libburn.h line 1763
signed int burn_disc_get_formats(struct burn_drive *d, signed int *status, signed long int *size, unsigned int *bl_sas, signed int *num_formats)
{
  signed int ret;
  *status = 0;
  *size = (signed long int)0;
  *bl_sas = (unsigned int)0;
  *num_formats = 0;
  if(!(d->drive_role == 1))
    return 0;

  else
  {
    ret=d->read_format_capacities(d, 0x00);
    if(!(ret >= 1))
      return 0;

    else
    {
      *status = d->format_descr_type;
      *size = d->format_curr_max_size;
      *bl_sas = d->format_curr_blsas;
      *num_formats = d->num_format_descr;
      return 1;
    }
  }
}

// burn_disc_get_incomplete_sessions
// file libburn/structure.c line 721
signed int burn_disc_get_incomplete_sessions(struct burn_disc *d)
{
  return d->incomplete_sessions;
}

// burn_disc_get_leadin_text
// file libburn/drive.c line 3423
signed int burn_disc_get_leadin_text(struct burn_drive *d, unsigned char **text_packs, signed int *num_packs, signed int flag)
{
  signed int ret;
  ret=mmc_get_leadin_text(d, text_packs, num_packs, 0);
  return ret;
}

// burn_disc_get_media_id
// file libburn/drive.c line 3331
signed int burn_disc_get_media_id(struct burn_drive *d, char **product_id, char **media_code1, char **media_code2, char **book_type, signed int flag)
{
  signed int ret;
  *book_type = (char *)(void *)0;
  *media_code2 = *book_type;
  *media_code1 = *media_code2;
  *product_id = *media_code1;
  signed int return_value_burn_drive_get_drive_role$1;
  return_value_burn_drive_get_drive_role$1=burn_drive_get_drive_role(d);
  if(!(return_value_burn_drive_get_drive_role$1 == 1))
    return 0;

  else
  {
    ret=mmc_get_media_product_id(d, product_id, media_code1, media_code2, book_type, flag & 1);
    return ret;
  }
}

// burn_disc_get_msc1
// file test/../libburn/libburn.h line 1517
signed int burn_disc_get_msc1(struct burn_drive *d, signed int *start)
{
  signed int ret;
  signed int trackno;
  signed int return_value_burn_drive_is_released$1;
  return_value_burn_drive_is_released$1=burn_drive_is_released(d);
  if(!(return_value_burn_drive_is_released$1 == 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011b, 0x70000000, 0x30000000, "Attempt to read track info from ungrabbed drive", 0, 0);
    return -1;
  }

  else
    if(!((signed int)d->busy == BURN_DRIVE_IDLE))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011c, 0x70000000, 0x30000000, "Attempt to read track info from busy drive", 0, 0);
      return -1;
    }

    else
    {
      *start = 0;
      if(!(d->drive_role == 1))
        return 0;

      else
      {
        ret=d->read_multi_session_c1(d, &trackno, start);
        return ret;
      }
    }
}

// burn_disc_get_multi_caps
// file test/../libburn/libburn.h line 3543
signed int burn_disc_get_multi_caps(struct burn_drive *d, enum burn_write_types wt, struct burn_multi_caps **caps, signed int flag)
{
  enum burn_disc_status s;
  struct burn_multi_caps *o;
  signed int status;
  signed int num_formats;
  signed int ret;
  signed int type;
  signed int i;
  signed long int size;
  unsigned int dummy;
  *caps = (struct burn_multi_caps *)(void *)0;
  s=burn_disc_get_status(d);
  if((signed int)s == BURN_DISC_UNGRABBED)
    return -1;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_multi_caps) /*72ul*/ );
    o = (struct burn_multi_caps *)return_value_calloc$1;
    *caps = o;
    if(*caps == ((struct burn_multi_caps *)NULL))
      return -1;

    else
    {
      o->multi_track = 0;
      o->multi_session = o->multi_track;
      o->start_adr = 0;
      o->start_range_high = (signed long int)0;
      o->start_range_low = o->start_range_high;
      o->start_alignment = o->start_range_low;
      o->might_do_raw = 0;
      o->might_do_sao = o->might_do_raw;
      o->might_do_tao = o->might_do_sao;
      o->advised_write_mode = (enum burn_write_types)BURN_WRITE_NONE;
      o->selected_write_mode = wt;
      o->current_profile = d->current_profile;
      o->current_is_cd_profile = d->current_is_cd_profile;
      o->might_simulate = 0;
      _Bool tmp_if_expr$2;
      if(d->drive_role == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = d->drive_role == 4 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        return 0;

      else
      {
        if(d->drive_role == 2)
        {
          o->start_adr = 1;
          size = d->media_capacity_remaining;
          burn_os_stdio_capacity(d->devname, (signed long int)0, &size);
          burn_drive_set_media_capacity_remaining(d, size);
          o->start_range_high = d->media_capacity_remaining - (signed long int)2048;
          o->start_alignment = (signed long int)2048;
          o->might_do_sao = 4;
          o->might_do_tao = 2;
          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;
          o->might_simulate = 1;
        }

        else
          if(d->drive_role == 5)
          {
            o->start_adr = 1;
            size = d->media_capacity_remaining;
            burn_os_stdio_capacity(d->devname, (signed long int)0, &size);
            burn_drive_set_media_capacity_remaining(d, size);
            o->start_range_high = d->media_capacity_remaining - (signed long int)2048;
            o->start_alignment = (signed long int)2048;
            if((signed int)s == BURN_DISC_APPENDABLE)
            {
              if((signed int)wt == BURN_WRITE_SAO || (signed int)wt == BURN_WRITE_RAW)
                return 0;

              o->might_do_sao = 0;
            }

            else
              o->might_do_sao = 4;
            o->might_do_tao = 2;
            o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;
            o->might_simulate = 1;
          }

          else
            if(!(d->drive_role == 1))
            {
              o->might_do_sao = 4;
              o->might_do_tao = 2;
              o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;
              o->might_simulate = 1;
            }

            else
              if(!((signed int)s == BURN_DISC_BLANK) && !((signed int)s == BURN_DISC_APPENDABLE))
                return 0;

              else
                if((signed int)s == BURN_DISC_APPENDABLE && ((signed int)wt == BURN_WRITE_SAO || (signed int)wt == BURN_WRITE_RAW))
                  return 0;

                else
                {
                  _Bool tmp_if_expr$12;
                  if((signed int)wt == BURN_WRITE_RAW)
                    tmp_if_expr$12 = !(d->current_is_cd_profile != 0) ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$12 = (_Bool)0;
                  if(tmp_if_expr$12)
                    return 0;

                  else
                  {
                    _Bool tmp_if_expr$11;
                    if(d->current_profile == 0x09)
                      tmp_if_expr$11 = (_Bool)1;

                    else
                      tmp_if_expr$11 = d->current_profile == 0x0a ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$11)
                    {
                      if(!(d->block_types[1l] == 0))
                      {
                        o->multi_track = 1;
                        o->multi_session = o->multi_track;
                        o->might_do_tao = 2;
                        if((signed int)o->advised_write_mode == BURN_WRITE_NONE)
                          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;

                      }

                      if(!(d->block_types[2l] == 0))
                      {
                        o->multi_track = 1;
                        o->multi_session = o->multi_track;
                        o->might_do_sao = 1;
                        if((signed int)o->advised_write_mode == BURN_WRITE_NONE)
                          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_SAO;

                      }

                      if(!(d->block_types[3l] == 0))
                      {
                        o->might_do_raw = 1;
                        if((signed int)o->advised_write_mode == BURN_WRITE_NONE)
                          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_RAW;

                      }

                      if((signed int)wt == BURN_WRITE_RAW)
                      {
                        o->multi_track = 0;
                        o->multi_session = o->multi_track;
                      }

                      else
                        if((signed int)wt == BURN_WRITE_TAO || (signed int)wt == BURN_WRITE_SAO || (signed int)wt == BURN_WRITE_NONE)
                        {
                          _Bool tmp_if_expr$3;
                          if(d->mdata->p2a_valid >= 1)
                            tmp_if_expr$3 = d->mdata->simulate != 0 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$3 = (_Bool)0;
                          o->might_simulate = (signed int)!(!tmp_if_expr$3);
                        }

                    }

                    else
                    {
                      _Bool tmp_if_expr$9;
                      if(d->current_profile == 0x11)
                        tmp_if_expr$9 = (_Bool)1;

                      else
                        tmp_if_expr$9 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
                      _Bool tmp_if_expr$10;
                      if(tmp_if_expr$9)
                        tmp_if_expr$10 = (_Bool)1;

                      else
                        tmp_if_expr$10 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
                      if(tmp_if_expr$10)
                      {
                        if((signed int)s == BURN_DISC_BLANK)
                        {
                          o->might_do_sao = 1;
                          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_SAO;
                        }

                        if(!(d->current_has_feat21h == 0))
                        {
                          if(!(d->current_profile == 0x15))
                            o->multi_session = 1;

                          o->multi_track = 1;
                          o->might_do_tao = 2;
                          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;
                        }

                        if((signed int)wt == BURN_WRITE_SAO)
                        {
                          o->multi_track = 0;
                          o->multi_session = o->multi_track;
                        }

                        if((signed int)wt == BURN_WRITE_TAO || (signed int)wt == BURN_WRITE_SAO || (signed int)wt == BURN_WRITE_NONE)
                          o->might_simulate = 1;

                      }

                      else
                      {
                        _Bool tmp_if_expr$6;
                        if(d->current_profile == 0x12)
                          tmp_if_expr$6 = (_Bool)1;

                        else
                          tmp_if_expr$6 = d->current_profile == 0x13 ? (_Bool)1 : (_Bool)0;
                        _Bool tmp_if_expr$7;
                        if(tmp_if_expr$6)
                          tmp_if_expr$7 = (_Bool)1;

                        else
                          tmp_if_expr$7 = d->current_profile == 0x1a ? (_Bool)1 : (_Bool)0;
                        _Bool tmp_if_expr$8;
                        if(tmp_if_expr$7)
                          tmp_if_expr$8 = (_Bool)1;

                        else
                          tmp_if_expr$8 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr$8)
                        {
                          o->start_adr = 1;
                          ret=burn_disc_get_formats(d, &status, &size, &dummy, &num_formats);
                          if(ret == 1)
                          {
                            if(status == 2)
                              o->start_range_high = size - (signed long int)2048;

                            if(d->current_profile == 0x13)
                            {
                              o->start_alignment = (signed long int)(32 * 1024);
                              i = 0;
                              for( ; !(i >= num_formats); i = i + 1)
                              {
                                ret=burn_disc_get_format_descr(d, i, &type, &size, &dummy);
                                if(ret >= 1)
                                {
                                  if(type == 0x13)
                                    break;

                                }

                              }
                              if(i >= num_formats)
                                o->start_range_high = o->start_range_high - (signed long int)(32 * 1024);

                              if(!(o->start_range_high >= 0l))
                                o->start_range_high = (signed long int)0;

                            }

                            else
                            {
                              o->start_alignment = (signed long int)(2 * 1024);
                              if(!(o->start_range_high >= d->best_format_size + -2048l))
                                o->start_range_high = d->best_format_size - (signed long int)2048;

                            }
                          }

                          o->might_do_sao = 4;
                          o->might_do_tao = 2;
                          o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;
                        }

                        else
                        {
                          _Bool tmp_if_expr$4;
                          if(d->current_profile == 0x1b)
                            tmp_if_expr$4 = (_Bool)1;

                          else
                            tmp_if_expr$4 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
                          _Bool tmp_if_expr$5;
                          if(tmp_if_expr$4)
                            tmp_if_expr$5 = (_Bool)1;

                          else
                            tmp_if_expr$5 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$5)
                          {
                            o->multi_track = 1;
                            o->multi_session = o->multi_track;
                            o->might_do_tao = 2;
                            o->might_do_sao = 1;
                            o->advised_write_mode = (enum burn_write_types)BURN_WRITE_TAO;
                          }

                          else
                            return 0;
                        }
                      }
                    }
                  }
                }
        if((signed int)s == BURN_DISC_APPENDABLE)
        {
          o->might_do_raw = 0;
          o->might_do_sao = o->might_do_raw;
        }

        _Bool tmp_if_expr$14;
        if((signed int)wt == BURN_WRITE_TAO)
          tmp_if_expr$14 = !(o->might_do_tao != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$14 = (_Bool)0;
        if(tmp_if_expr$14)
          return 0;

        else
        {
          _Bool tmp_if_expr$13;
          if((signed int)wt == BURN_WRITE_SAO)
            tmp_if_expr$13 = !(o->might_do_sao != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$13 = (_Bool)0;
          if(tmp_if_expr$13)
            return 0;

          else
            if((signed int)wt == BURN_WRITE_RAW)
            {
              if(o->might_do_raw == 0)
                return 0;

            }

        }
        return 1;
      }
    }
  }
}

// burn_disc_get_phys_format_info
// file libburn/drive.c line 3397
signed int burn_disc_get_phys_format_info(struct burn_drive *d, signed int *disk_category, char **book_name, signed int *part_version, signed int *num_layers, signed int *num_blocks, signed int flag)
{
  signed int ret;
  signed int return_value_burn_drive_get_drive_role$1;
  return_value_burn_drive_get_drive_role$1=burn_drive_get_drive_role(d);
  if(!(return_value_burn_drive_get_drive_role$1 == 1))
    return 0;

  else
  {
    *num_blocks = 0;
    *num_layers = *num_blocks;
    *part_version = *num_layers;
    *disk_category = *part_version;
    ret=mmc_get_phys_format_info(d, disk_category, book_name, part_version, num_layers, num_blocks, 0);
    return ret;
  }
}

// burn_disc_get_profile
// file test/../libburn/libburn.h line 1572
signed int burn_disc_get_profile(struct burn_drive *d, signed int *pno, char *name)
{
  *pno = d->current_profile;
  strcpy(name, d->current_profile_text);
  return (signed int)(*pno >= 0);
}

// burn_disc_get_sectors
// file libburn/structure.c line 676
signed int burn_disc_get_sectors(struct burn_disc *d)
{
  signed int sectors = 0;
  signed int i = 0;
  signed int return_value_burn_session_get_sectors$1;
  for( ; !(i >= d->sessions); i = i + 1)
  {
    return_value_burn_session_get_sectors$1=burn_session_get_sectors(d->session[(signed long int)i]);
    sectors = sectors + return_value_burn_session_get_sectors$1;
  }
  return sectors;
}

// burn_disc_get_sessions
// file test/../libburn/libburn.h line 3578
struct burn_session ** burn_disc_get_sessions(struct burn_disc *d, signed int *num)
{
  *num = d->sessions - d->incomplete_sessions;
  return d->session;
}

// burn_disc_get_status
// file test/../libburn/libburn.h line 1228
enum burn_disc_status burn_disc_get_status(struct burn_drive *d)
{
  if(!(d->released == 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020108, 0x60000000, 0x30000000, "Drive is not grabbed on disc status inquiry", 0, 0);
    return (enum burn_disc_status)BURN_DISC_UNGRABBED;
  }

  else
    return d->status;
}

// burn_disc_get_write_mode_demands
// file libburn/drive.c line 3044
signed int burn_disc_get_write_mode_demands(struct burn_disc *disc, struct burn_write_opts *opts, struct burn_disc_mode_demands *result, signed int flag)
{
  struct burn_session *session;
  struct burn_track *track;
  signed int i;
  signed int j;
  signed int mode;
  signed int unknown_track_sizes = 0;
  signed int last_track_is_unknown = 0;
  enum burn_disc_status s;
  memset((void *)(char *)result, 0, sizeof(struct burn_disc_mode_demands) /*32ul*/ );
  if(disc == ((struct burn_disc *)NULL))
    return 2;

  else
  {
    s=burn_disc_get_status(opts->drive);
    _Bool tmp_if_expr$1;
    if((signed int)s == BURN_DISC_APPENDABLE)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = disc->sessions > 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      result->will_append = 1;

    if(disc->sessions >= 2)
      result->multi_session = 1;

    i = 0;
    for( ; !(i >= disc->sessions); i = i + 1)
    {
      session = disc->session[(signed long int)i];
      if(session->tracks >= 1)
      {
        mode = session->track[(signed long int)0]->mode;
        if(session->tracks >= 2)
          result->multi_track = 1;

        j = 0;
        for( ; !(j >= session->tracks); j = j + 1)
        {
          track = session->track[(signed long int)j];
          signed int return_value_burn_track_is_open_ended$3;
          return_value_burn_track_is_open_ended$3=burn_track_is_open_ended(track);
          if(!(return_value_burn_track_is_open_ended$3 == 0))
          {
            signed long int return_value_burn_track_get_default_size$2;
            return_value_burn_track_get_default_size$2=burn_track_get_default_size(track);
            if(return_value_burn_track_get_default_size$2 >= 1l)
            {
              if(result->unknown_track_size == 0)
                result->unknown_track_size = 2;

            }

            else
              result->unknown_track_size = 1;
            unknown_track_sizes = unknown_track_sizes + 1;
            last_track_is_unknown = 1;
          }

          else
            last_track_is_unknown = 0;
          if(!((127 & mode) == (127 & track->mode)))
            result->mixed_mode = 1;

          if(!((4 & track->mode) == 0))
            result->block_types = result->block_types | BURN_BLOCK_MODE1;

          else
            if(!((64 & track->mode) == 0))
            {
              result->audio = 1;
              result->block_types = result->block_types | BURN_BLOCK_RAW0;
              result->exotic_track = 1;
            }

            else
            {
              result->block_types = result->block_types | (signed int)opts->block_type;
              result->exotic_track = 1;
            }
        }
      }

    }
    if(!((1 & flag) == 0))
    {
      if(unknown_track_sizes == 1 && !(last_track_is_unknown == 0))
        result->unknown_track_size = 0;

    }

    return (signed int)(disc->sessions > 0);
  }
}

// burn_disc_init_track_status
// file libburn/write.c line 1073
signed int burn_disc_init_track_status(struct burn_write_opts *o, struct burn_session *s, struct burn_track *t, signed int tnum, signed int sectors)
{
  struct burn_drive *d = o->drive;
  d->progress.start_sector = d->nwa;
  d->progress.sectors = sectors;
  d->progress.sector = 0;
  d->progress.track = tnum;
  d->progress.indices = (signed int)t->indices;
  d->progress.index = 0;
  if(d->progress.indices >= 2)
  {
    if(t->index[0l] == 0x7fffffff)
      d->progress.index = 1;

  }

  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_disc_init_write_status
// file libburn/write.c line 1323
signed int burn_disc_init_write_status(struct burn_write_opts *o, struct burn_disc *disc)
{
  struct burn_drive *d = o->drive;
  struct burn_track *t = (struct burn_track *)(void *)0;
  signed int sx;
  signed int tx;
  signed int ret;
  d->cancel = 0;
  d->progress.buffer_capacity = (unsigned int)0;
  d->progress.buffer_available = (unsigned int)0;
  d->progress.buffered_bytes = (signed long int)0;
  d->progress.buffer_min_fill = 0xffffffff;
  d->pessimistic_buffer_free = (signed long int)0;
  d->pbf_altered = 0;
  d->pessimistic_writes = (unsigned int)0;
  d->waited_writes = (unsigned int)0;
  d->waited_tries = (unsigned int)0;
  d->waited_usec = (unsigned int)0;
  sx = 0;
  for( ; !(sx >= disc->sessions); sx = sx + 1)
  {
    tx = 0;
    for( ; !(tx >= disc->session[(signed long int)sx]->tracks); tx = tx + 1)
    {
      t = disc->session[(signed long int)sx]->track[(signed long int)tx];
      burn_track_set_fillup(t, 0);
    }
  }
  if(!(o->fill_up_media == 0))
  {
    if(!(t == ((struct burn_track *)NULL)))
      burn_track_set_fillup(t, 1);

  }

  d->was_feat21h_failure = 0;
  if(!(d->write_opts == ((struct burn_write_opts *)NULL)))
    burn_write_opts_free(d->write_opts);

  ret=burn_write_opts_clone(o, &d->write_opts, 0);
  if(!(ret >= 1))
    return ret;

  else
  {
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
    return 1;
  }
}

// burn_disc_next_track_is_damaged
// file libburn/drive.c line 3414
signed int burn_disc_next_track_is_damaged(struct burn_drive *d, signed int flag)
{
  return d->next_track_damaged;
}

// burn_disc_open_track_dvd_minus_r
// file libburn/write.c line 1539
signed int burn_disc_open_track_dvd_minus_r(struct burn_write_opts *o, struct burn_session *s, signed int tnum)
{
  struct burn_drive *d = o->drive;
  char *msg = (char *)(void *)0;
  signed int ret;
  signed int lba;
  signed int nwa;
  signed long int size;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    d->send_write_parameters(d, (struct burn_session *)(void *)0, -1, o);
    ret=d->get_nwa(d, -1, &lba, &nwa);
    sprintf(msg, "DVD pre-track %2.2d : get_nwa(%d), ret= %d , d->nwa= %d", tnum + 1, nwa, ret, d->nwa);
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
    if(!(d->nwa >= nwa))
      d->nwa = nwa;

    burn_track_apply_fillup(s->track[(signed long int)tnum], d->media_capacity_remaining, 1);
    if((signed int)o->write_type == BURN_WRITE_SAO)
    {
      signed int return_value_burn_track_get_sectors_2$2;
      return_value_burn_track_get_sectors_2$2=burn_track_get_sectors_2(s->track[(signed long int)tnum], 1);
      size = (signed long int)return_value_burn_track_get_sectors_2$2 * (signed long int)2048;
      if(!(o->obs_pad == 0))
      {
        if(!(size % (signed long int)o->obs == 0l))
          size = size + (signed long int)((signed long int)o->obs - size % (signed long int)o->obs);

      }

      ret=d->reserve_track(d, size);
      if(!(ret >= 1))
      {
        sprintf(msg, "Cannot reserve track of %.f bytes", (double)size);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020138, 0x70000000, 0x30000000, msg, 0, 0);
        ret = 0;
      }

    }

    ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_disc_open_track_dvd_plus_r
// file libburn/write.c line 1600
signed int burn_disc_open_track_dvd_plus_r(struct burn_write_opts *o, struct burn_session *s, signed int tnum)
{
  struct burn_drive *d = o->drive;
  char *msg = (char *)(void *)0;
  signed int ret;
  signed int lba;
  signed int nwa;
  signed long int size;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_burn_track_is_open_ended$3;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    ret=d->get_nwa(d, -1, &lba, &nwa);
    sprintf(msg, "DVD+R pre-track %2.2d : get_nwa(%d), ret= %d , d->nwa= %d", tnum + 1, nwa, ret, d->nwa);
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
    if(!(d->nwa >= nwa))
      d->nwa = nwa;

    burn_track_apply_fillup(s->track[(signed long int)tnum], d->media_capacity_remaining, 1);
    if((signed int)o->write_type == BURN_WRITE_SAO)
    {
      return_value_burn_track_is_open_ended$3=burn_track_is_open_ended(s->track[(signed long int)tnum]);
      if(return_value_burn_track_is_open_ended$3 == 0)
      {
        signed int return_value_burn_track_get_sectors_2$2;
        return_value_burn_track_get_sectors_2$2=burn_track_get_sectors_2(s->track[(signed long int)tnum], 1);
        size = (signed long int)return_value_burn_track_get_sectors_2$2 * (signed long int)2048;
        if(!(o->obs_pad == 0))
        {
          if(!(o->obs % 32768 == 0))
            o->obs = o->obs + (32768 - o->obs % 32768);

          if(!(size % (signed long int)o->obs == 0l))
            size = size + (signed long int)((signed long int)o->obs - size % (signed long int)o->obs);

        }

        if(o->obs_pad == 0)
        {
          sprintf(msg, "Program error: encountered DVD+R without chunk padding");
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000004, 0x70000000, 0x30000000, msg, 0, 0);
          ret = 0;
        }

        ret=d->reserve_track(d, size);
        if(!(ret >= 1))
        {
          sprintf(msg, "Cannot reserve track of %.f bytes", (double)size);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020138, 0x70000000, 0x30000000, msg, 0, 0);
          ret = 0;
        }

      }

    }

    ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_disc_pretend_blank
// file libburn/drive.c line 2487
signed int burn_disc_pretend_blank(struct burn_drive *d)
{
  if(d->drive_role == 0)
    return 0;

  else
    if(!((signed int)d->status == BURN_DISC_UNREADY))
    {
      if((signed int)d->status == BURN_DISC_UNSUITABLE)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      d->status = (enum burn_disc_status)BURN_DISC_BLANK;
      return 1;
    }
}

// burn_disc_pretend_full
// file libburn/drive.c line 2499
signed int burn_disc_pretend_full(struct burn_drive *d)
{
  if(d->drive_role == 0)
    return 0;

  else
    if(!((signed int)d->status == BURN_DISC_UNREADY))
    {
      if((signed int)d->status == BURN_DISC_UNSUITABLE)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      d->status = (enum burn_disc_status)BURN_DISC_FULL;
      return 1;
    }
}

// burn_disc_pretend_full_uncond
// file libburn/drive.c line 2511
signed int burn_disc_pretend_full_uncond(struct burn_drive *d)
{
  d->status = (enum burn_disc_status)BURN_DISC_FULL;
  return 1;
}

// burn_disc_read
// file libburn/read.c line 55
void burn_disc_read(struct burn_drive *d, struct burn_read_opts *o)
{
  ;
}

// burn_disc_read_atip
// file test/../libburn/libburn.h line 1313
signed int burn_disc_read_atip(struct burn_drive *d)
{
  signed int return_value_burn_drive_is_released$1;
  return_value_burn_drive_is_released$1=burn_drive_is_released(d);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(return_value_burn_drive_is_released$1 == 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002010e, 0x70000000, 0x30000000, "Attempt to read ATIP from ungrabbed drive", 0, 0);
    return -1;
  }

  else
    if(!(d->drive_role == 1))
      return 0;

    else
    {
      _Bool tmp_if_expr$2;
      if(d->current_profile == -1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = d->current_is_cd_profile != 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$5;
      if(tmp_if_expr$2)
      {
        if(d->mdata->p2a_valid >= 1)
          tmp_if_expr$3 = d->mdata->cdrw_write != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = d->current_profile != 0x08 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        d->read_atip(d);

      else
        return 0;
      return 1;
    }
}

// burn_disc_remove_session
// file libburn/libburn.h line 1960
signed int burn_disc_remove_session(struct burn_disc *d, struct burn_session *s)
{
  signed int i;
  signed int skip = 0;
  if(d->session == ((struct burn_session **)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= d->sessions); i = i + 1)
      if(s == d->session[(signed long int)i])
        skip = skip + 1;

      else
        d->session[(signed long int)(i - skip)] = d->session[(signed long int)i];
    if(skip == 0)
      return 0;

    else
    {
      burn_session_free(s);
      d->sessions = d->sessions - 1;
      return 1;
    }
  }
}

// burn_disc_setup_dvd_minus_r
// file libburn/write.c line 2258
signed int burn_disc_setup_dvd_minus_r(struct burn_write_opts *o, struct burn_disc *disc)
{
  struct burn_drive *d = o->drive;
  d->nwa = 0;
  return 1;
}

// burn_disc_setup_dvd_minus_rw
// file libburn/write.c line 2204
signed int burn_disc_setup_dvd_minus_rw(struct burn_write_opts *o, struct burn_disc *disc)
{
  struct burn_drive *d = o->drive;
  char msg[60l];
  signed int ret;
  d->nwa = 0;
  if(o->start_byte >= 0l)
  {
    d->nwa = (signed int)(o->start_byte / (signed long int)32768);
    sprintf(msg, "Write start address is  %d * 32768", d->nwa);
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020127, 0x30000000, 0x30000000, msg, 0, 0);
    d->nwa = d->nwa * 16;
  }

  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_FORMATTING;
  ret=d->format_unit(d, (signed long int)d->nwa * (signed long int)2048, (signed int)(d->nwa > 0) << 3);
  if(!(ret >= 1))
    return 0;

  else
  {
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
    return 1;
  }
}

// burn_disc_setup_dvd_plus_r
// file libburn/write.c line 2271
signed int burn_disc_setup_dvd_plus_r(struct burn_write_opts *o, struct burn_disc *disc)
{
  struct burn_drive *d = o->drive;
  d->nwa = 0;
  return 1;
}

// burn_disc_setup_dvd_plus_rw
// file libburn/write.c line 2179
signed int burn_disc_setup_dvd_plus_rw(struct burn_write_opts *o, struct burn_disc *disc)
{
  struct burn_drive *d = o->drive;
  signed int ret;
  _Bool tmp_if_expr$1;
  if(d->bg_format_status == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = d->bg_format_status == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_FORMATTING;
    ret=d->format_unit(d, (signed long int)0, 0);
    if(!(ret >= 1))
      return 0;

    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
    d->needs_close_session = 1;
  }

  return 1;
}

// burn_disc_track_lba_nwa
// file test/../libburn/libburn.h line 1466
signed int burn_disc_track_lba_nwa(struct burn_drive *d, struct burn_write_opts *o, signed int trackno, signed int *lba, signed int *nwa)
{
  signed int ret;
  signed int return_value_burn_drive_is_released$1;
  return_value_burn_drive_is_released$1=burn_drive_is_released(d);
  if(!(return_value_burn_drive_is_released$1 == 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011b, 0x70000000, 0x30000000, "Attempt to read track info from ungrabbed drive", 0, 0);
    return -1;
  }

  else
    if(!((signed int)d->busy == BURN_DRIVE_IDLE))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011c, 0x70000000, 0x30000000, "Attempt to read track info from busy drive", 0, 0);
      return -1;
    }

    else
    {
      *nwa = 0;
      *lba = *nwa;
      if(d->drive_role == 5)
      {
        if(!(trackno == 0))
          goto __CPROVER_DUMP_L3;

        if(!((signed int)d->status == BURN_DISC_APPENDABLE))
          goto __CPROVER_DUMP_L3;

        *nwa = d->role_5_nwa;
        *lba = *nwa;
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        if(!(d->drive_role == 1))
          return 0;

        else
        {
          if(!(o == ((struct burn_write_opts *)NULL)))
            d->send_write_parameters(d, (struct burn_session *)(void *)0, -1, o);

          ret=d->get_nwa(d, trackno, lba, nwa);
          return ret;
        }
      }
    }
}

// burn_disc_write
// file libburn/async.c line 595
void burn_disc_write(struct burn_write_opts *opts, struct burn_disc *disc)
{
  union w_list_data o;
  char *reasons = (char *)(void *)0;
  struct burn_drive *d;
  signed int mvalid;
  d = opts->drive;
  _Bool tmp_if_expr$1;
  if(!(workers == ((struct w_list *)NULL)))
    tmp_if_expr$1 = workers->w_type == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$3;
  struct w_list *return_value_find_worker$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_find_worker$2=find_worker(opts->drive);
    tmp_if_expr$3 = return_value_find_worker$2 != (struct w_list *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  unsigned long int return_value_strlen$5;
  signed int return_value_burn_precheck_write$6;
  signed int return_value;
  if(tmp_if_expr$3)
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020102, 0x60000000, 0x30000000, "A drive operation is still going on (want to write)", 0, 0);

  else
  {
    reset_progress(d, disc->sessions, disc->session[(signed long int)0]->tracks, (signed int)disc->session[(signed long int)0]->track[(signed long int)0]->indices, 0, 0);
    d->cancel = 1;
    if((signed int)opts->write_type == BURN_WRITE_NONE)
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002017c, 0x68000000, 0x30000000, "No valid write type selected", 0, 0);

    else
      if(d->drive_role == 0)
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020146, 0x70000000, 0x30000000, "Drive is a virtual placeholder (null-drive)", 0, 0);

      else
        if(d->drive_role == 4)
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020181, 0x68000000, 0x30000000, "Pseudo-drive is a read-only file. Cannot write.", 0, 0);

        else
          if(d->drive_role == 1)
          {
            mvalid = 0;
            if(!(d->mdata == ((struct scsi_mode_data *)NULL)))
              mvalid = 1;

            if(!(mvalid == 0))
              goto __CPROVER_DUMP_L10;

            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020113, 0x60000000, 0x30000000, "Drive capabilities not inquired yet", 0, 0);
          }

          else
          {

          __CPROVER_DUMP_L10:
            ;
            void *return_value_burn_alloc_mem$4;
            return_value_burn_alloc_mem$4=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(4096 + 80), 0);
            reasons = (char *)return_value_burn_alloc_mem$4;
            if(!(reasons == ((char *)NULL)))
            {
              strcpy(reasons, "Write job parameters are unsuitable:\n");
              return_value_strlen$5=strlen(reasons);
              return_value_burn_precheck_write$6=burn_precheck_write(opts, disc, reasons + (signed long int)return_value_strlen$5, 1);
              if(!(return_value_burn_precheck_write$6 >= 1))
                libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020139, 0x60000000, 0x30000000, reasons, 0, 0);

              else
              {
                if(!(reasons == ((char *)NULL)))
                  free((void *)(char *)reasons);

                reasons = (char *)(void *)0;
                if(d->current_profile == 0x43)
                {
                  return_value=d->read_format_capacities(d, 0x00);
                  if(return_value >= 1)
                  {
                    if(!(d->format_descr_type == 2))
                      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020168, 0x68000000, 0x30000000, "Media not properly formatted. Cannot write.", 0, 0);

                  }

                }

                d->cancel = 0;
                o.write.drive = d;
                o.write.opts = opts;
                o.write.disc = disc;
                opts->refcount = opts->refcount + 1;
                add_worker(3, d, (void * (*)(void *))write_disc_worker_func, &o);
              }
            }


          ex:
            ;
            if(!(reasons == ((char *)NULL)))
              free((void *)(char *)reasons);

          }
  }
}

// burn_disc_write_is_ok
// file libburn/write.c line 1299
signed int burn_disc_write_is_ok(struct burn_write_opts *o, struct burn_disc *disc, signed int flag)
{
  signed int i;
  signed int t;
  char msg[80l];
  i = 0;
  signed int return_value_sector_headers_is_ok$1;
  for( ; !(i >= disc->sessions); i = i + 1)
  {
    t = 0;
    for( ; !(t >= disc->session[(signed long int)i]->tracks); t = t + 1)
    {
      return_value_sector_headers_is_ok$1=sector_headers_is_ok(o, disc->session[(signed long int)i]->track[(signed long int)t]->mode);
      if(!(return_value_sector_headers_is_ok$1 == 1))
        goto bad_track_mode_found;

    }
  }
  return 1;

bad_track_mode_found:
  ;
  sprintf(msg, "Unsuitable track mode 0x%x in track %d of session %d", disc->session[(signed long int)i]->track[(signed long int)t]->mode, i + 1, t + 1);
  if((2 & flag) == 0)
    libdax_msgs_submit(libdax_messenger, -1, 0x0002010a, 0x70000000, 0x30000000, msg, 0, 0);

  return 0;
}

// burn_disc_write_sync
// file libburn/write.h line 27
void burn_disc_write_sync(struct burn_write_opts *o, struct burn_disc *disc)
{
  struct cue_sheet *sheet;
  struct burn_drive *d = o->drive;
  struct buffer *buffer_mem = o->drive->buffer;
  struct burn_session *s;
  struct burn_track *lt;
  struct burn_track *t;
  signed int first = 1;
  signed int i;
  signed int ret;
  signed int lba;
  signed int nwa = 0;
  signed int multi_mem;
  signed long int default_size;
  char msg[80l];
  burn_disc_init_write_status(o, disc);
  d->do_stream_recording = (signed int)!(!(o->do_stream_recording != 0));
  if(o->do_stream_recording >= 16)
    d->stream_recording_start = o->do_stream_recording;

  else
    d->stream_recording_start = 0;
  void *return_value_burn_os_alloc_buffer$1;
  return_value_burn_os_alloc_buffer$1=burn_os_alloc_buffer(sizeof(struct buffer) /*69640ul*/ , 0);
  d->buffer = (struct buffer *)return_value_burn_os_alloc_buffer$1;
  signed int return_value_burn_write_flush$5;
  signed int return_value_burn_write_flush$6;
  if(!(d->buffer == ((struct buffer *)NULL)))
  {
    d->rlba = -150;
    d->toc_temp = 9;
    if(d->drive_role == 4)
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020181, 0x68000000, 0x30000000, "Pseudo-drive is a read-only file. Cannot write.", 0, 0);

    else
    {
      if(!(d->drive_role == 1))
      {
        ret=burn_stdio_write_sync(o, disc);
        if(!(ret >= 1))
          goto fail_wo_sync;

        goto ex;
      }

      if(d->current_is_cd_profile == 0)
      {
        ret=burn_dvd_write_sync(o, disc);
        if(!(ret >= 1))
          goto fail_wo_sync;

        goto ex;
      }

      o->obs = 32 * 1024;
      sprintf(msg, "cd Profile= %2.2Xh , obs= %d , obs_pad= %d", d->current_profile, o->obs, o->obs_pad);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
      if((signed int)o->write_type == BURN_WRITE_SAO)
      {
        i = 0;
        for( ; !(i >= (*disc->session)->tracks); i = i + 1)
        {
          t = disc->session[(signed long int)0]->track[(signed long int)i];
          signed int return_value_burn_track_is_open_ended$2;
          return_value_burn_track_is_open_ended$2=burn_track_is_open_ended(t);
          if(!(return_value_burn_track_is_open_ended$2 == 0))
          {
            default_size=burn_track_get_default_size(t);
            sprintf(msg, "Activated track default size %.f", (double)default_size);
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002012e, 0x30000000, 0x30000000, msg, 0, 0);
            burn_track_set_size(t, default_size);
          }

        }
      }

      d->alba = d->start_lba;
      d->nwa = d->alba;
      if((signed int)o->write_type == BURN_WRITE_TAO)
        nwa = 0;

      else
      {
        if(disc->sessions >= 1)
          s = disc->session[(signed long int)0];

        else
          s = (struct burn_session *)(void *)0;
        d->send_write_parameters(d, s, -1, o);
        ret=d->get_nwa(d, -1, &lba, &nwa);
        sprintf(msg, "SAO|RAW: Inquired nwa: %d , ret= %d , cap=%.f\n", nwa, ret, (double)d->media_capacity_remaining);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
      }
      i = 0;
      for( ; !(i >= disc->sessions); i = i + 1)
      {
        d->progress.session = i;
        d->progress.tracks = disc->session[(signed long int)i]->tracks;
        sheet=burn_create_toc_entries(o, disc->session[(signed long int)i], nwa);
        if(sheet == ((struct cue_sheet *)NULL))
          goto fail_wo_sync;

        ret = 1;
        if((signed int)o->write_type == BURN_WRITE_SAO)
          ret=d->send_cue_sheet(d, sheet);

        if(!(sheet->data == ((unsigned char *)NULL)))
          free((void *)sheet->data);

        free((void *)sheet);
        if(!(ret >= 1))
          goto fail_wo_sync;

        if((signed int)o->write_type == BURN_WRITE_RAW)
        {
          signed int return_value_burn_write_leadin$3;
          return_value_burn_write_leadin$3=burn_write_leadin(o, disc->session[(signed long int)i], first);
          if(return_value_burn_write_leadin$3 == 0)
            goto fail;

        }

        else
          if(!(first == 0))
          {
            if((signed int)o->write_type == BURN_WRITE_TAO)
            {
              d->alba = 0;
              d->nwa = d->alba;
            }

            else
            {
              d->nwa = -150;
              d->alba = -150;
            }
          }

          else
          {
            d->nwa = d->nwa + 4500;
            d->alba = d->alba + 4500;
          }
        multi_mem = (signed int)o->multi;
        if(!(i >= disc->sessions + -1))
          o->multi = (unsigned char)1;

        ret=burn_write_session(o, disc->session[(signed long int)i]);
        o->multi = (unsigned char)multi_mem;
        if(ret == 0)
          goto fail;

        lt = disc->session[(signed long int)i]->track[(signed long int)(disc->session[(signed long int)i]->tracks - 1)];
        if((signed int)o->write_type == BURN_WRITE_RAW)
        {
          signed int return_value_burn_write_leadout$4;
          return_value_burn_write_leadout$4=burn_write_leadout(o, first, lt->entry->control, lt->mode);
          if(return_value_burn_write_leadout$4 == 0)
            goto fail;

        }

        else
        {
          if(!((signed int)o->write_type == BURN_WRITE_TAO))
          {
            return_value_burn_write_flush$5=burn_write_flush(o, (struct burn_track *)(void *)0);
            if(return_value_burn_write_flush$5 == 0)
              goto fail;

          }

          d->nwa = d->nwa + (first != 0 ? 6750 : 2250);
          d->alba = d->alba + (first != 0 ? 6750 : 2250);
        }
        if(!(first == 0))
          first = 0;

        d->progress.sector = 0;
        d->progress.start_sector = 0;
        d->progress.sectors = 0;
      }
      if(!((signed int)o->write_type == BURN_WRITE_SAO))
      {
        if(!((signed int)o->write_type == BURN_WRITE_TAO))
        {
          return_value_burn_write_flush$6=burn_write_flush(o, (struct burn_track *)(void *)0);
          if(return_value_burn_write_flush$6 == 0)
            goto fail;

        }

      }

      sleep((unsigned int)1);
      burn_drive_mark_unready(d, 0);
      burn_drive_inquire_media(d);
      goto ex;

    fail:
      ;
      d->sync_cache(d);
    }
  }


fail_wo_sync:
  ;
  usleep((unsigned int)500001);
  libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002010b, 0x70000000, 0x30000000, "Burn run failed", 0, 0);
  d->cancel = 1;

ex:
  ;
  d->do_stream_recording = 0;
  if(!(d->buffer == ((struct buffer *)NULL)))
    burn_os_free_buffer((void *)(char *)d->buffer, sizeof(struct buffer) /*69640ul*/ , 0);

  d->buffer = buffer_mem;
  if(!(d->write_opts == ((struct burn_write_opts *)NULL)))
  {
    burn_write_opts_free(d->write_opts);
    d->write_opts = (struct burn_write_opts *)(void *)0;
  }

  goto __CPROVER_DUMP_L33;

__CPROVER_DUMP_L33:
  ;
}

// burn_drive__fd_from_special_adr
// file libburn/drive.c line 327
signed int burn_drive__fd_from_special_adr(char *adr)
{
  signed int fd = -1;
  signed int i;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(adr, "-");
  if(return_value_strcmp$1 == 0)
    fd = 1;

  signed int return_value_strncmp$3;
  return_value_strncmp$3=strncmp(adr, "/dev/fd/", (unsigned long int)8);
  const unsigned short int **return_value___ctype_b_loc$2;
  if(return_value_strncmp$3 == 0)
  {
    i = 8;
    for( ; !(adr[(signed long int)i] == 0); i = i + 1)
    {
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)adr[(signed long int)i]]) == 0)
        break;

    }
    if(i >= 9)
    {
      if((signed int)adr[(signed long int)i] == 0)
        fd=atoi(adr + (signed long int)8);

    }

  }

  return fd;
}

// burn_drive__is_rdwr
// file libburn/drive.c line 346
static signed int burn_drive__is_rdwr(char *fname, signed int *stat_ret, struct stat *stbuf_ret, signed long int *read_size_ret, signed int flag)
{
  signed int fd;
  signed int is_rdwr = 1;
  signed int ret;
  signed int getfl_ret;
  signed int st_ret;
  signed int mask;
  struct stat stbuf;
  signed long int read_size = (signed long int)0;
  memset((void *)&stbuf, 0, sizeof(struct stat) /*144ul*/ );
  fd=burn_drive__fd_from_special_adr(fname);
  if(fd >= 0)
    st_ret=fstat(fd, &stbuf);

  else
    st_ret=stat(fname, &stbuf);
  if(!(st_ret == -1))
  {
    is_rdwr=burn_os_is_2k_seekrw(fname, 0);
    ret = 1;
    if((61440u & stbuf.st_mode) == 32768u)
      read_size = stbuf.st_size;

    else
      if(!(is_rdwr == 0))
        ret=burn_os_stdio_capacity(fname, (signed long int)0, &read_size);

    if(read_size / 2048l >= 2147483632l || !(ret >= 1))
      read_size = (signed long int)0x7ffffff0 * (signed long int)2048;

  }

  if(fd >= 0 && !(is_rdwr == 0))
  {
    getfl_ret=fcntl(fd, 3);
    mask = 02 | 01 | 00;
    if(getfl_ret == -1 || !((getfl_ret & mask) == 02))
      is_rdwr = 0;

    if((getfl_ret & mask) == 00 && !((1 & flag) == 0) && !(getfl_ret == -1))
      is_rdwr = 2;

    if((getfl_ret & mask) == 01 && !((2 & flag) == 0) && !(getfl_ret == -1))
      is_rdwr = 3;

  }

  if(!(stat_ret == ((signed int *)NULL)))
    *stat_ret = st_ret;

  if(!(stbuf_ret == ((struct stat *)NULL)))
    memcpy((void *)stbuf_ret, (const void *)&stbuf, sizeof(struct stat) /*144ul*/ );

  if(!(read_size_ret == ((signed long int *)NULL)))
    *read_size_ret = read_size;

  return is_rdwr;
}

// burn_drive_add_whitelist
// file libburn/drive.c line 1604
signed int burn_drive_add_whitelist(char *device_address)
{
  char *new_item;
  if(1 + enumeration_whitelist_top >= 255)
    return 0;

  else
  {
    enumeration_whitelist_top = enumeration_whitelist_top + 1;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(device_address);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, return_value_strlen$1 + (unsigned long int)1);
    new_item = (char *)return_value_calloc$2;
    if(new_item == ((char *)NULL))
      return -1;

    else
    {
      strcpy(new_item, device_address);
      enumeration_whitelist[(signed long int)enumeration_whitelist_top] = new_item;
      return 1;
    }
  }
}

// burn_drive_adr_debug_msg
// file libburn/drive.c line 1895
signed int burn_drive_adr_debug_msg(char *fmt, char *arg)
{
  signed int ret;
  char *msg = (char *)(void *)0;
  char *msgpt;
  if(libdax_messenger == ((struct libdax_msgs *)NULL))
    return 0;

  else
  {
    if(!(arg == ((char *)NULL)))
    {
      void *return_value_burn_alloc_mem$1;
      return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
      msg = (char *)return_value_burn_alloc_mem$1;
      if(msg == ((char *)NULL))
      {
        ret = -1;
        goto ex;
      }

      msgpt = msg;
      sprintf(msg, fmt, arg);
    }

    else
      msgpt = fmt;
    ret=libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, msgpt, 0, 0);

  ex:
    ;
    if(!(msg == ((char *)NULL)))
      free((void *)(char *)msg);

    return ret;
  }
}

// burn_drive_cancel
// file libburn/drive.c line 1161
void burn_drive_cancel(struct burn_drive *d)
{
  if(d->cancel == 0)
    libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, "burn_drive_cancel() was called", 0, 0);

  d->cancel = 1;
}

// burn_drive_clear_whitelist
// file libburn/drive.c line 1619
void burn_drive_clear_whitelist(void)
{
  signed int i = 0;
  for( ; enumeration_whitelist_top >= i; i = i + 1)
    free((void *)enumeration_whitelist[(signed long int)i]);
  enumeration_whitelist_top = -1;
}

// burn_drive_convert_fs_adr
// file test/../libburn/libburn.h line 1083
signed int burn_drive_convert_fs_adr(char *path, char *adr)
{
  signed int ret;
  signed int rec_count = 0;
  ret=burn_drive_convert_fs_adr_sub(path, adr, &rec_count);
  return ret;
}

// burn_drive_convert_fs_adr_sub
// file libburn/drive.c line 2193
signed int burn_drive_convert_fs_adr_sub(char *path, char *adr, signed int *rec_count)
{
  signed int ret;
  struct stat stbuf;
  burn_drive_adr_debug_msg("burn_drive_convert_fs_adr( %s )", path);
  signed int return_value_strncmp$3;
  return_value_strncmp$3=strncmp(path, "stdio:", (unsigned long int)6);
  _Bool tmp_if_expr$5;
  signed int return_value_burn_drive_is_enumerable_adr$4;
  if(return_value_strncmp$3 == 0)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_burn_drive_is_enumerable_adr$4=burn_drive_is_enumerable_adr(path);
    tmp_if_expr$5 = return_value_burn_drive_is_enumerable_adr$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(path);
    if(return_value_strlen$1 >= 1024ul)
      return -1;

    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(path, "stdio:", (unsigned long int)6);
    if(!(return_value_strncmp$2 == 0))
      burn_drive_adr_debug_msg("burn_drive_is_enumerable_adr( %s ) is true", path);

    strcpy(adr, path);
    return 1;
  }

  signed int return_value_lstat$6;
  return_value_lstat$6=lstat(path, &stbuf);
  if(return_value_lstat$6 == -1)
  {
    burn_drive_adr_debug_msg("lstat( %s ) returns -1", path);
    return 0;
  }

  else
  {
    if((61440u & stbuf.st_mode) == 40960u)
    {
      ret=burn_drive_resolve_link(path, adr, rec_count, 0);
      if(ret >= 1)
        return 1;

      burn_drive_adr_debug_msg("link fallback via stat( %s )", path);
      signed int return_value_stat$7;
      return_value_stat$7=stat(path, &stbuf);
      if(return_value_stat$7 == -1)
      {
        burn_drive_adr_debug_msg("stat( %s ) returns -1", path);
        return 0;
      }

    }

    if((61440u & stbuf.st_mode) == 8192u || (61440u & stbuf.st_mode) == 24576u)
    {
      ret=burn_drive_find_devno(stbuf.st_rdev, adr);
      if(ret >= 1)
        return 1;

      ret=burn_drive_find_scsi_equiv(path, adr);
      if(!(ret >= 1))
        goto __CPROVER_DUMP_L11;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L11:
      ;
      burn_drive_adr_debug_msg("Nothing found for %s", path);
      return 0;
    }
  }
}

// burn_drive_convert_scsi_adr
// file libburn/drive.c line 2113
signed int burn_drive_convert_scsi_adr(signed int bus_no, signed int host_no, signed int channel_no, signed int target_no, signed int lun_no, char *adr)
{
  char *fname = (char *)(void *)0;
  char *msg = (char *)(void *)0;
  signed int ret = 0;
  signed int first = 1;
  signed int i_bus_no = -1;
  signed int fname_size = 4096;
  signed int i_host_no = -1;
  signed int i_channel_no = -1;
  signed int i_target_no = -1;
  signed int i_lun_no = -1;
  struct burn_drive_enumerator_struct enm;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)fname_size, 0);
  fname = (char *)return_value_burn_alloc_mem$1;
  if(fname == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(fname_size + 100), 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      sprintf(msg, "burn_drive_convert_scsi_adr( %d,%d,%d,%d,%d )", bus_no, host_no, channel_no, target_no, lun_no);
      burn_drive_adr_debug_msg(msg, (char *)(void *)0);
      while((_Bool)1)
      {
        ret=sg_give_next_adr(&enm, fname, fname_size, first);
        if(!(ret >= 1))
          break;

        first = 0;
        ret=burn_drive_obtain_scsi_adr(fname, &i_bus_no, &i_host_no, &i_channel_no, &i_target_no, &i_lun_no);
        if(ret >= 1)
        {
          if(!(bus_no >= 0) || i_bus_no == bus_no)
          {
            if(!(host_no >= 0) || i_host_no == host_no)
            {
              if(!(channel_no >= 0) || i_channel_no == channel_no)
              {
                if(!(target_no >= 0) || i_target_no == target_no)
                {
                  if(!(lun_no >= 0) || i_lun_no == lun_no)
                  {
                    unsigned long int return_value_strlen$3;
                    return_value_strlen$3=strlen(fname);
                    if(return_value_strlen$3 >= 1024ul)
                    {
                      ret = -1;
                      goto ex;
                    }

                    burn_drive_adr_debug_msg("burn_drive_convert_scsi_adr() found %s", fname);
                    strcpy(adr, fname);
                    ret = 1;
                    goto ex;
                  }

                }

              }

            }

          }

        }

      }
      ret = 0;
    }
  }

ex:
  ;
  if(first == 0)
    sg_give_next_adr(&enm, fname, fname_size, -1);

  if(!(fname == ((char *)NULL)))
    free((void *)(char *)fname);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_drive_count
// file libburn/drive.c line 233
unsigned int burn_drive_count(void)
{
  return (unsigned int)(drivetop + 1);
}

// burn_drive_d_get_adr
// file libburn/drive.c line 1919
signed int burn_drive_d_get_adr(struct burn_drive *d, char *adr)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(d->devname);
  if(return_value_strlen$1 >= 1024ul)
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020110, 0x70000000, 0x30000000, "Persistent drive address too long", 0, 0);
    return -1;
  }

  else
  {
    strcpy(adr, d->devname);
    return 1;
  }
}

// burn_drive_equals_adr
// file libburn/drive.c line 3133
signed int burn_drive_equals_adr(struct burn_drive *d1, char *adr2_in, signed int role2)
{
  struct stat stbuf1;
  struct stat stbuf2;
  char *adr1 = (char *)(void *)0;
  char *adr2 = adr2_in;
  char *conv_adr1 = (char *)(void *)0;
  char *conv_adr2 = (char *)(void *)0;
  char *npt1;
  char *dpt1;
  char *npt2;
  char *dpt2;
  signed int role1;
  signed int stat_ret1;
  signed int stat_ret2;
  signed int conv_ret2;
  signed int exact_role_matters = 0;
  signed int fd;
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
  adr1 = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_strncmp$4;
  unsigned long int return_value_strlen$5;
  signed int return_value_strcmp$6;
  if(adr1 == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
    conv_adr1 = (char *)return_value_burn_alloc_mem$2;
    if(conv_adr1 == ((char *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
      conv_adr2 = (char *)return_value_burn_alloc_mem$3;
      if(conv_adr2 == ((char *)NULL))
        ret = -1;

      else
      {
        role1=burn_drive_get_drive_role(d1);
        burn_drive_d_get_adr(d1, adr1);
        stat_ret1=stat(adr1, &stbuf1);
        fd=burn_drive__fd_from_special_adr(d1->devname);
        if(!(fd == -1))
          exact_role_matters = 1;

        return_value_strncmp$4=strncmp(adr2, "stdio:", (unsigned long int)6);
        if(return_value_strncmp$4 == 0)
        {
          adr2 = adr2 + (signed long int)6;
          if((signed int)*adr2 == 0)
            role2 = 0;

          else
          {
            fd=burn_drive__fd_from_special_adr(adr2);
            if(!(fd == -1))
              exact_role_matters = 1;

            ret=burn_drive__is_rdwr(adr2, (signed int *)(void *)0, (struct stat *)(void *)0, (signed long int *)(void *)0, 1 | 2);
            if(ret == 2 && !((1 & burn_drive_role_4_allowed) == 0))
              role2 = 4;

            else
              if(ret == 3 && !((1 & burn_drive_role_4_allowed) == 0))
                role2 = 5;

              else
                if(ret >= 1)
                  role2 = 2;

                else
                  role2 = 3;
            if((3 & burn_drive_role_4_allowed) == 3 && fd == -1 && role2 == 2)
              role2=burn_role_by_access(adr2, (signed int)!(!((burn_drive_role_4_allowed & 4) != 0)));

          }
        }

        return_value_strlen$5=strlen(adr2);
        if(return_value_strlen$5 >= 1024ul)
          ret = -1;

        else
        {
          stat_ret2=stat(adr2, &stbuf2);
          conv_ret2=burn_drive_convert_fs_adr(adr2, conv_adr2);
          if(exact_role_matters == 0)
          {
            if(role1 >= 2)
              role1 = 2;

            if(role2 >= 2)
              role2 = 2;

          }

          return_value_strcmp$6=strcmp(adr1, adr2);
          if(return_value_strcmp$6 == 0)
          {
            if(!(role1 == role2))
              goto __CPROVER_DUMP_L15;

            ret = 1;
          }

          else
          {

          __CPROVER_DUMP_L15:
            ;
            if(role1 == 1 && role2 == 1)
            {
              if(!(conv_ret2 >= 1))
              {
                ret = 0;
                goto ex;
              }

              signed int return_value_strcmp$7;
              return_value_strcmp$7=strcmp(adr1, conv_adr2);
              if(return_value_strcmp$7 == 0)
              {
                ret = 1;
                goto ex;
              }

              ret = 0;
              goto ex;
            }

            else
              if(role1 == 0 || role2 == 0)
              {
                ret = 0;
                goto ex;
              }

              else
                if(!(role1 == 1) && !(role2 == 1))
                {
                  if(!(role1 == role2))
                  {
                    ret = 0;
                    goto ex;
                  }

                  if(stat_ret1 == -1 || stat_ret2 == -1)
                  {
                    if(!(stat_ret1 == -1) || !(stat_ret2 == -1))
                    {
                      ret = 0;
                      goto ex;
                    }

                    strcpy(conv_adr1, adr1);
                    burn__split_path(conv_adr1, &dpt1, &npt1);
                    strcpy(conv_adr2, adr2);
                    burn__split_path(conv_adr2, &dpt2, &npt2);
                    signed int return_value_strcmp$8;
                    return_value_strcmp$8=strcmp(npt1, npt2);
                    if(!(return_value_strcmp$8 == 0))
                    {
                      ret = 0;
                      goto ex;
                    }

                    stat_ret1=stat(adr1, &stbuf1);
                    stat_ret2=stat(adr2, &stbuf2);
                    if(!(stat_ret1 == stat_ret2))
                    {
                      ret = 0;
                      goto ex;
                    }

                  }

                  if(stbuf1.st_dev == stbuf2.st_dev && stbuf1.st_ino == stbuf2.st_ino)
                  {
                    ret = 1;
                    goto ex;
                  }

                  if((61440u & stbuf1.st_mode) == 24576u && (61440u & stbuf2.st_mode) == 24576u && stbuf1.st_rdev == stbuf2.st_rdev)
                  {
                    ret = 1;
                    goto ex;
                  }

                  if((61440u & stbuf1.st_mode) == 8192u && (61440u & stbuf2.st_mode) == 8192u && stbuf1.st_rdev == stbuf2.st_rdev)
                  {
                    ret = 1;
                    goto ex;
                  }

                  if(!(conv_ret2 >= 1))
                  {
                    ret = 0;
                    goto ex;
                  }

                  signed int return_value_burn_drive_convert_fs_adr$9;
                  return_value_burn_drive_convert_fs_adr$9=burn_drive_convert_fs_adr(adr1, conv_adr1);
                  if(!(return_value_burn_drive_convert_fs_adr$9 >= 1))
                  {
                    ret = 0;
                    goto ex;
                  }

                  signed int return_value_strcmp$10;
                  return_value_strcmp$10=strcmp(conv_adr1, conv_adr2);
                  if(return_value_strcmp$10 == 0)
                  {
                    ret = 1;
                    goto ex;
                  }

                  ret = 0;
                  goto ex;
                }

                else
                  if(role1 == 1 && !(role2 == 1))
                  {
                    if(!(conv_ret2 >= 1))
                    {
                      ret = 0;
                      goto ex;
                    }

                    signed int return_value_strcmp$11;
                    return_value_strcmp$11=strcmp(adr1, conv_adr2);
                    if(return_value_strcmp$11 == 0)
                    {
                      ret = 1;
                      goto ex;
                    }

                    ret = 0;
                    goto ex;
                  }

                  else
                    if(role2 == 1 && !(role1 == 1))
                    {
                      if(!(conv_ret2 >= 1))
                      {
                        ret = 0;
                        goto ex;
                      }

                      signed int return_value_burn_drive_convert_fs_adr$12;
                      return_value_burn_drive_convert_fs_adr$12=burn_drive_convert_fs_adr(adr1, conv_adr1);
                      if(!(return_value_burn_drive_convert_fs_adr$12 >= 1))
                      {
                        ret = 0;
                        goto ex;
                      }

                      signed int return_value_strcmp$13;
                      return_value_strcmp$13=strcmp(conv_adr1, conv_adr2);
                      if(return_value_strcmp$13 == 0)
                      {
                        ret = 1;
                        goto ex;
                      }

                      ret = 0;
                      goto ex;
                    }

            ret = 0;
          }
        }
      }
    }
  }

ex:
  ;
  if(!(adr1 == ((char *)NULL)))
    free((void *)(char *)adr1);

  if(!(conv_adr1 == ((char *)NULL)))
    free((void *)(char *)conv_adr1);

  if(!(conv_adr2 == ((char *)NULL)))
    free((void *)(char *)conv_adr2);

  return ret;
}

// burn_drive_extract_audio
// file libburn/file.c line 940
signed int burn_drive_extract_audio(struct burn_drive *drive, signed int start_sector, signed int sector_count, char *target_path, signed int flag)
{
  signed int fd = -1;
  signed int ret;
  signed int todo;
  signed int sector_no;
  signed int val;
  signed int min;
  signed int sec;
  signed int fr;
  signed int sectors_done = 0;
  signed long int data_size;
  signed long int data_count = (signed long int)0;
  signed long int last_pacified = (signed long int)0;
  signed long int now;
  char *msg = (char *)(void *)0;
  char *buf = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed long int return_value_write$4;
  signed long int return_value_write$5;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(24 * 2352), 0);
    buf = (char *)return_value_burn_alloc_mem$2;
    if(buf == ((char *)NULL))
      ret = -1;

    else
    {
      fd=open(target_path, 01 | 0100 | 0, 0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3);
      if(fd == -1)
      {
        sprintf(msg, "Cannot open disk file for writing: %.4000s", target_path);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        libdax_msgs_submit(libdax_messenger, -1, 0x000201a1, 0x68000000, 0x30000000, msg, *return_value___errno_location$3, 0);
        ret = 0;
        goto ex;
      }

      strcpy(buf, "RIFF");
      val = 4 + 8 + 16 + 8 + sector_count * 2352;
      burn_int_to_lsb(val, buf + (signed long int)4);
      strcpy(buf + (signed long int)8, "WAVE");
      strcpy(buf + (signed long int)12, "fmt ");
      burn_int_to_lsb(16, buf + (signed long int)16);
      buf[(signed long int)20] = (char)1;
      buf[(signed long int)21] = (char)0;
      buf[(signed long int)22] = (char)2;
      buf[(signed long int)23] = (char)0;
      burn_int_to_lsb(44100, buf + (signed long int)24);
      burn_int_to_lsb(176400, buf + (signed long int)28);
      buf[(signed long int)32] = (char)4;
      buf[(signed long int)33] = (char)0;
      buf[(signed long int)34] = (char)16;
      buf[(signed long int)35] = (char)0;
      strcpy(buf + (signed long int)36, "data");
      burn_int_to_lsb(sector_count * 2352, buf + (signed long int)40);
      return_value_write$4=write(fd, (const void *)buf, (unsigned long int)44);
      ret = (signed int)return_value_write$4;
      if(!(ret == -1))
      {
        todo = sector_count;
        sector_no = start_sector;

      __CPROVER_DUMP_L4:
        ;
        if(!(todo >= 1))
          goto __CPROVER_DUMP_L11;

        if(todo >= 25)
          data_size = (signed long int)(24 * 2352);

        else
          data_size = (signed long int)(todo * 2352);
        ret=burn_read_audio(drive, sector_no, buf, data_size, &data_count, flag & 8);
        if(!(ret >= 1))
        {
          sprintf(msg, "Failure to read audio sectors");
          libdax_msgs_submit(libdax_messenger, -1, 0x000201a4, 0x68000000, 0x30000000, msg, 0, 0);
          goto ex;
        }

        return_value_write$5=write(fd, (const void *)buf, (unsigned long int)data_count);
        ret = (signed int)return_value_write$5;
        if(!(ret == -1))
          goto __CPROVER_DUMP_L9;

      }


    write_error:
      ;
      sprintf(msg, "Error while writing to disk file: %.4000s", target_path);
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      libdax_msgs_submit(libdax_messenger, -1, 0x000201a2, 0x68000000, 0x30000000, msg, *return_value___errno_location$6, 0);
      ret = 0;
      goto ex;

    __CPROVER_DUMP_L9:
      ;
      todo = todo - (signed int)(data_count / (signed long int)2352);
      sectors_done = sectors_done + (signed int)(data_count / (signed long int)2352);
      sector_no = sector_no + (signed int)(data_count / (signed long int)2352);
      if(!((1 & flag) == 0))
      {
        now=time((signed long int *)(void *)0);
        if(now + -last_pacified >= 1l)
        {
          last_pacified = now;
          burn_lba_to_msf(sectors_done, &min, &sec, &fr);
          sprintf(msg, "Minutes:seconds of audio data read: %2d:%2.2d  (%6.2f MB)", min, sec, ((double)sectors_done * 2352.0) / 1048576.0);
          libdax_msgs_submit(libdax_messenger, -1, 0x000201a3, 0x20000000, 0x30000000, msg, 0, 1);
        }

      }

      goto __CPROVER_DUMP_L4;

    __CPROVER_DUMP_L11:
      ;
      if(!((1 & flag) == 0))
      {
        burn_lba_to_msf(sectors_done, &min, &sec, &fr);
        sprintf(msg, "Minutes:seconds of audio data read: %2d:%2.2d  (%6.2f MB)", min, sec, ((double)sectors_done * 2352.0) / 1048576.0);
        libdax_msgs_submit(libdax_messenger, -1, 0x000201a3, 0x20000000, 0x30000000, msg, 0, 0);
      }

      ret = 1;
    }
  }

ex:
  ;
  if(!(buf == ((char *)NULL)))
    free((void *)(char *)buf);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(fd == -1))
    close(fd);

  return ret;
}

// burn_drive_extract_audio_track
// file libburn/file.c line 1060
signed int burn_drive_extract_audio_track(struct burn_drive *drive, struct burn_track *track, char *target_path, signed int flag)
{
  signed int ret;
  struct burn_toc_entry toc_entry;
  burn_track_get_entry(track, &toc_entry);
  if((1 & (signed int)toc_entry.extensions_valid) == 0)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    libdax_msgs_submit(libdax_messenger, -1, 0x00000004, 0x70000000, 0x30000000, "Internal libburn error: Outdated burn_toc_entry format encountered", *return_value___errno_location$1, 0);
    return -1;
  }

  ret=burn_drive_extract_audio(drive, toc_entry.start_lba, toc_entry.track_blocks, target_path, flag & (1 | 8));
  return ret;
}

// burn_drive_find_by_thread_pid
// file libburn/drive.c line 3288
signed int burn_drive_find_by_thread_pid(struct burn_drive **d, signed int pid, unsigned long int tid)
{
  signed int i = 0;
  signed int return_value_pthread_equal$1;
  for( ; !(i >= 1 + drivetop); i = i + 1)
    if(!(drive_array[(signed long int)i].thread_pid_valid == 0))
    {
      if(drive_array[(signed long int)i].thread_pid == pid)
      {
        return_value_pthread_equal$1=pthread_equal(drive_array[(signed long int)i].thread_tid, tid);
        if(!(return_value_pthread_equal$1 == 0))
        {
          *d = &drive_array[(signed long int)i];
          return 1;
        }

      }

    }

  return 0;
}

// burn_drive_find_devno
// file libburn/drive.c line 2032
signed int burn_drive_find_devno(unsigned long int devno, char *adr)
{
  char *fname = (char *)(void *)0;
  char *msg = (char *)(void *)0;
  signed int ret = 0;
  signed int first = 1;
  signed int fname_size = 4096;
  struct stat stbuf;
  struct burn_drive_enumerator_struct enm;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)fname_size, 0);
  fname = (char *)return_value_burn_alloc_mem$1;
  if(fname == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(fname_size + 100), 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      while((_Bool)1)
      {
        ret=sg_give_next_adr(&enm, fname, fname_size, first);
        if(!(ret >= 1))
          break;

        first = 0;
        ret=stat(fname, &stbuf);
        if(!(ret == -1))
        {
          if(devno == stbuf.st_rdev)
          {
            unsigned long int return_value_strlen$3;
            return_value_strlen$3=strlen(fname);
            if(return_value_strlen$3 >= 1024ul)
            {
              ret = -1;
              goto ex;
            }

            sprintf(msg, "burn_drive_find_devno( 0x%lX ) found %s", (signed long int)devno, fname);
            burn_drive_adr_debug_msg(msg, (char *)(void *)0);
            strcpy(adr, fname);
            ret = 1;
            goto ex;
          }

        }

      }
      ret = 0;
    }
  }

ex:
  ;
  if(first == 0)
    sg_give_next_adr(&enm, fname, fname_size, -1);

  if(!(fname == ((char *)NULL)))
    free((void *)(char *)fname);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_drive_find_scsi_equiv
// file libburn/drive.c line 2166
signed int burn_drive_find_scsi_equiv(char *path, char *adr)
{
  signed int ret = 0;
  signed int bus_no;
  signed int host_no;
  signed int channel_no;
  signed int target_no;
  signed int lun_no;
  char msg[4096l];
  ret=burn_drive_obtain_scsi_adr(path, &bus_no, &host_no, &channel_no, &target_no, &lun_no);
  if(!(ret >= 1))
  {
    sprintf(msg, "burn_drive_obtain_scsi_adr( %s ) returns %d", path, ret);
    burn_drive_adr_debug_msg(msg, (char *)(void *)0);
    return 0;
  }

  else
  {
    sprintf(msg, "burn_drive_find_scsi_equiv( %s ) : (%d),%d,%d,%d,%d", path, bus_no, host_no, channel_no, target_no, lun_no);
    burn_drive_adr_debug_msg(msg, (char *)(void *)0);
    ret=burn_drive_convert_scsi_adr(-1, host_no, channel_no, target_no, lun_no, adr);
    return ret;
  }
}

// burn_drive_finish_enum
// file libburn/drive.c line 598
struct burn_drive * burn_drive_finish_enum(struct burn_drive *d)
{
  struct burn_drive *t = (struct burn_drive *)(void *)0;
  char *msg = (char *)(void *)0;
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(1024 + 160), 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    d->drive_role = 1;
    t=burn_drive_register(d);
    mmc_function_spy((struct burn_drive *)(void *)0, "enumerate_common : -------- doing grab");
    ret=t->grab(t);
    if(!(ret == 0))
    {
      t->getcaps(t);
      t->unlock(t);
      t->released = 1;
    }

    else
    {
      d->mdata->p2a_valid = -1;
      sprintf(msg, "Unable to grab scanned drive %s", d->devname);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002016f, 0x10000000, 0x10000000, msg, 0, 0);
      burn_drive_unregister(t);
      t = (struct burn_drive *)(void *)0;
    }
    mmc_function_spy((struct burn_drive *)(void *)0, "enumerate_common : ----- would release ");
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return t;
}

// burn_drive_force_idle
// file libburn/drive.c line 167
signed int burn_drive_force_idle(struct burn_drive *d)
{
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  return 1;
}

// burn_drive_forget
// file libburn/drive.c line 1429
signed int burn_drive_forget(struct burn_drive *d, signed int force)
{
  signed int occup;
  occup=burn_drive_is_occupied(d);
  signed int return_value_burn_drive_is_released$1;
  if(!(occup >= -1))
    return 2;

  else
    if(occup >= 1)
    {
      if(force >= 1)
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(occup >= 10)
        return 0;

      else
      {
        burn_drive_force_idle(d);
        if(occup >= 1)
        {
          return_value_burn_drive_is_released$1=burn_drive_is_released(d);
          if(return_value_burn_drive_is_released$1 == 0)
            burn_drive_release(d, 0);

        }

        burn_drive_free(d);
        return 1;
      }
    }
}

// burn_drive_free
// file libburn/drive.c line 131
void burn_drive_free(struct burn_drive *d)
{
  signed int return_value_burn_drive_is_open$1;
  if(!(d->global_index == -1))
  {
    if(d->drive_role == 1)
    {
      return_value_burn_drive_is_open$1=burn_drive_is_open(d);
      if(!(return_value_burn_drive_is_open$1 == 0))
      {
        d->unlock(d);
        d->release(d);
      }

    }

    burn_drive_free_subs(d);
    d->global_index = -1;
  }

}

// burn_drive_free_all
// file libburn/drive.c line 145
void burn_drive_free_all(void)
{
  signed int i = 0;
  for( ; !(i >= 1 + drivetop); i = i + 1)
    burn_drive_free(&drive_array[(signed long int)i]);
  drivetop = -1;
  memset((void *)drive_array, 0, sizeof(struct burn_drive [255l]) /*603840ul*/ );
}

// burn_drive_free_speedlist
// file test/../libburn/libburn.h line 3441
signed int burn_drive_free_speedlist(struct burn_speed_descriptor **speed_list)
{
  signed int return_value_burn_speed_descriptor_destroy$1;
  return_value_burn_speed_descriptor_destroy$1=burn_speed_descriptor_destroy(speed_list, 1);
  return return_value_burn_speed_descriptor_destroy$1;
}

// burn_drive_free_subs
// file libburn/drive.c line 101
void burn_drive_free_subs(struct burn_drive *d)
{
  if(!(d->idata == ((struct burn_scsi_inquiry_data *)NULL)))
    free((void *)d->idata);

  d->idata = (struct burn_scsi_inquiry_data *)(void *)0;
  if(!(d->mdata == ((struct scsi_mode_data *)NULL)))
  {
    burn_mdata_free_subs(d->mdata);
    free((void *)d->mdata);
  }

  d->mdata = (struct scsi_mode_data *)(void *)0;
  if(!(d->toc_entry == ((struct burn_toc_entry *)NULL)))
    free((void *)d->toc_entry);

  d->toc_entry = (struct burn_toc_entry *)(void *)0;
  if(!(d->devname == ((char *)NULL)))
    free((void *)d->devname);

  d->devname = (char *)(void *)0;
  if(d->stdio_fd >= 0)
    close(d->stdio_fd);

  d->stdio_fd = -1;
  burn_feature_descr_free(&d->features, 0);
  if(!(d->drive_serial_number == ((char *)NULL)))
    free((void *)(char *)d->drive_serial_number);

  if(!(d->media_serial_number == ((char *)NULL)))
    free((void *)(char *)d->media_serial_number);

  d->media_serial_number = (char *)(void *)0;
  d->drive_serial_number = d->media_serial_number;
  d->media_serial_number_len = (char)0;
  d->drive_serial_number_len = d->media_serial_number_len;
  sg_dispose_drive(d, 0);
}

// burn_drive_get_adr
// file test/../libburn/libburn.h line 1059
signed int burn_drive_get_adr(struct burn_drive_info *drive_info, char *adr)
{
  signed int ret;
  ret=burn_drive_d_get_adr(drive_info->drive, adr);
  return ret;
}

// burn_drive_get_all_profiles
// file test/../libburn/libburn.h line 3356
signed int burn_drive_get_all_profiles(struct burn_drive *d, signed int *num_profiles, signed int *profiles, char *is_current)
{
  signed int i;
  *num_profiles = d->num_profiles;
  i = 0;
  for( ; !(i >= d->num_profiles); i = i + 1)
  {
    profiles[(signed long int)i] = (signed int)d->all_profiles[(signed long int)(i * 4)] << 8 | (signed int)d->all_profiles[(signed long int)(i * 4 + 1)];
    is_current[(signed long int)i] = (char)((signed int)d->all_profiles[(signed long int)(i * 4 + 2)] & 1);
  }
  return 1;
}

// burn_drive_get_best_speed
// file libburn/drive.c line 2793
signed int burn_drive_get_best_speed(struct burn_drive *d, signed int speed_goal, struct burn_speed_descriptor **best_descr, signed int flag)
{
  struct burn_speed_descriptor *sd;
  signed int best_speed = 0;
  signed int best_lba = 0;
  signed int source = 2;
  signed int speed;
  if(!((2 & flag) == 0))
    source = -1;

  if(!(speed_goal >= 0))
    best_speed = 2000000000;

  *best_descr = (struct burn_speed_descriptor *)(void *)0;
  sd = d->mdata->speed_descriptors;
  _Bool tmp_if_expr$3;
  for( ; !(sd == ((struct burn_speed_descriptor *)NULL)); sd = sd->next)
  {
    if(!((1 & flag) == 0))
      speed = sd->read_speed;

    else
      speed = sd->write_speed;
    _Bool tmp_if_expr$1;
    if(source >= 0)
      tmp_if_expr$1 = sd->source != source ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(speed >= 1 && !tmp_if_expr$1)
    {
      if(!(speed_goal >= 0))
      {
        if(!(speed >= best_speed))
        {
          best_speed = speed;
          *best_descr = sd;
        }

      }

      else
        if(speed_goal == 0)
        {
          _Bool tmp_if_expr$2;
          if(source == 2)
            tmp_if_expr$2 = sd->end_lba > best_lba ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          _Bool tmp_if_expr$4;
          if(tmp_if_expr$2)
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            if(!(source == 2))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = sd->end_lba == best_lba ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$4 = (tmp_if_expr$3 ? (speed > best_speed ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
          {
            best_lba = sd->end_lba;
            best_speed = speed;
            *best_descr = sd;
          }

        }

        else
          if(speed_goal >= speed)
          {
            if(!(best_speed >= speed))
            {
              best_speed = speed;
              *best_descr = sd;
            }

          }

    }

  }
  signed int return_value_burn_drive_get_best_speed$5;
  if(!(d->current_is_cd_profile == 0))
  {
    if(*best_descr == ((struct burn_speed_descriptor *)NULL))
    {
      if((2 & flag) == 0)
      {
        return_value_burn_drive_get_best_speed$5=burn_drive_get_best_speed(d, speed_goal, best_descr, flag | 2);
        return return_value_burn_drive_get_best_speed$5;
      }

    }

  }

  return (signed int)(*best_descr != (struct burn_speed_descriptor *)(void *)0);
}

// burn_drive_get_disc
// file test/../libburn/libburn.h line 2642
struct burn_disc * burn_drive_get_disc(struct burn_drive *d)
{
  if(d->disc == ((struct burn_disc *)NULL))
    return (struct burn_disc *)(void *)0;

  else
  {
    d->disc->refcnt = d->disc->refcnt + 1;
    return d->disc;
  }
}

// burn_drive_get_drive_role
// file libburn/drive.c line 3105
signed int burn_drive_get_drive_role(struct burn_drive *d)
{
  return d->drive_role;
}

// burn_drive_get_media_sno
// file libburn/drive.c line 3532
signed int burn_drive_get_media_sno(struct burn_drive *d, char **sno, signed int *sno_len)
{
  signed int ret;
  if(!(*sno == ((char *)NULL)))
  {
    if(!(*sno == ((char *)NULL)))
      free((void *)(char *)*sno);

  }

  *sno = (char *)(void *)0;
  if((signed int)d->media_serial_number_len >= 1)
    *sno_len = (signed int)d->media_serial_number_len;

  else
    *sno_len = 0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(*sno_len + 1), 0);
  *sno = (char *)return_value_burn_alloc_mem$1;
  if(*sno == ((char *)NULL))
    ret = -1;

  else
  {
    if(*sno_len >= 1)
      memcpy((void *)*sno, (const void *)d->media_serial_number, (unsigned long int)*sno_len);

    (*sno)[(signed long int)*sno_len] = (char)0;
    ret = 1;
  }

ex:
  ;
  return ret;
}

// burn_drive_get_min_write_speed
// file test/../libburn/libburn.h line 3387
signed int burn_drive_get_min_write_speed(struct burn_drive *d)
{
  return d->mdata->min_write_speed;
}

// burn_drive_get_read_speed
// file libburn/drive.c line 1579
signed int burn_drive_get_read_speed(struct burn_drive *d)
{
  return d->mdata->max_read_speed;
}

// burn_drive_get_serial_no
// file libburn/drive.c line 3511
signed int burn_drive_get_serial_no(struct burn_drive *d, char **sno, signed int *sno_len)
{
  signed int ret;
  if(!(*sno == ((char *)NULL)))
  {
    if(!(*sno == ((char *)NULL)))
      free((void *)(char *)*sno);

  }

  if((signed int)d->drive_serial_number_len >= 1)
    *sno_len = (signed int)d->drive_serial_number_len;

  else
    *sno_len = 0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(*sno_len + 1), 0);
  *sno = (char *)return_value_burn_alloc_mem$1;
  if(*sno == ((char *)NULL))
    ret = -1;

  else
  {
    if((signed int)d->drive_serial_number_len >= 1)
      memcpy((void *)*sno, (const void *)d->drive_serial_number, (unsigned long int)*sno_len);

    (*sno)[(signed long int)*sno_len] = (char)0;
    ret = 1;
  }

ex:
  ;
  return ret;
}

// burn_drive_get_speedlist
// file test/../libburn/libburn.h line 3410
signed int burn_drive_get_speedlist(struct burn_drive *d, struct burn_speed_descriptor **speed_list)
{
  signed int ret;
  struct burn_speed_descriptor *sd;
  struct burn_speed_descriptor *csd = (struct burn_speed_descriptor *)(void *)0;
  *speed_list = (struct burn_speed_descriptor *)(void *)0;
  sd = d->mdata->speed_descriptors;
  for( ; !(sd == ((struct burn_speed_descriptor *)NULL)); sd = sd->next)
  {
    ret=burn_speed_descriptor_new(&csd, (struct burn_speed_descriptor *)(void *)0, csd, 0);
    if(!(ret >= 1))
      return -1;

    burn_speed_descriptor_copy(sd, csd, 0);
  }
  *speed_list = csd;
  return (signed int)(csd != (struct burn_speed_descriptor *)(void *)0);
}

// burn_drive_get_start_end_lba
// file libburn/drive.c line 2475
signed int burn_drive_get_start_end_lba(struct burn_drive *d, signed int *start_lba, signed int *end_lba, signed int flag)
{
  _Bool tmp_if_expr$1;
  if(d->start_lba == -2000000000)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = d->end_lba == -2000000000 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    *start_lba = d->start_lba;
    *end_lba = d->end_lba;
    return 1;
  }
}

// burn_drive_get_status
// file libburn/drive.c line 1111
enum burn_drive_status burn_drive_get_status(struct burn_drive *d, struct burn_progress *p)
{
  burn_init_catch_on_abort(0);
  if(burn_global_abort_level >= 1 && !(burn_builtin_triggered_action >= 2))
    burn_global_abort_level = burn_global_abort_level + 1;

  signed int return_value_getpid$1;
  if(burn_global_abort_level >= 6 && !(burn_builtin_triggered_action >= 2))
  {
    if(burn_global_signal_handler == ((signed int (*)(void *, signed int, signed int))NULL))
    {
      return_value_getpid$1=getpid();
      kill(return_value_getpid$1, burn_global_abort_signum);
    }

    else
      burn_global_signal_handler(burn_global_signal_handle, burn_global_abort_signum, 0);
    burn_global_abort_level = -1;
  }

  if(!(p == ((struct burn_progress *)NULL)))
    memcpy((void *)p, (const void *)&d->progress, sizeof(struct burn_progress) /*64ul*/ );

  return d->busy;
}

// burn_drive_get_write_speed
// file test/../libburn/libburn.h line 3376
signed int burn_drive_get_write_speed(struct burn_drive *d)
{
  return d->mdata->max_write_speed;
}

// burn_drive_grab
// file test/../libburn/libburn.h line 1156
signed int burn_drive_grab(struct burn_drive *d, signed int le)
{
  signed int errcode;
  signed int ret;
  signed int sose;
  signed int signal_action_mem = -1;
  sose = d->silent_on_scsi_error;
  signed int return_value_burn_is_aborting$1;
  signed int return_value_burn_is_aborting$3;
  signed int return_value_burn_is_aborting$5;
  signed int return_value_burn_is_aborting$7;
  signed int return_value_burn_is_aborting$9;
  signed int return_value_burn_is_aborting$11;
  if(d->released == 0)
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020189, 0x70000000, 0x10000000, "Drive is already grabbed by libburn", 0, 0);
    return 0;
  }

  else
    if(!(d->drive_role == 1))
    {
      ret=burn_drive_grab_stdio(d, 0);
      return ret;
    }

    else
    {
      d->status = (enum burn_disc_status)BURN_DISC_UNREADY;
      errcode=d->grab(d);
      if(errcode == 0)
        return 0;

      else
      {
        burn_grab_prepare_sig_action(&signal_action_mem, 0);
        d->busy = (volatile enum burn_drive_status)BURN_DRIVE_GRABBING;
        if(!(le == 0))
          d->load(d);

        _Bool tmp_if_expr$2;
        if(!(d->cancel == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_burn_is_aborting$1=burn_is_aborting(0);
          tmp_if_expr$2 = return_value_burn_is_aborting$1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
          ret = 0;

        else
        {
          d->lock(d);
          _Bool tmp_if_expr$4;
          if(!(d->cancel == 0))
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            return_value_burn_is_aborting$3=burn_is_aborting(0);
            tmp_if_expr$4 = return_value_burn_is_aborting$3 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
            ret = 0;

          else
          {
            d->start_unit(d);
            _Bool tmp_if_expr$6;
            if(!(d->cancel == 0))
              tmp_if_expr$6 = (_Bool)1;

            else
            {
              return_value_burn_is_aborting$5=burn_is_aborting(0);
              tmp_if_expr$6 = return_value_burn_is_aborting$5 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$6)
              ret = 0;

            else
            {
              if(le == 0)
                d->silent_on_scsi_error = 1;

              ret=burn_drive_inquire_media(d);
              _Bool tmp_if_expr$8;
              if(!(d->cancel == 0))
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_burn_is_aborting$7=burn_is_aborting(0);
                tmp_if_expr$8 = return_value_burn_is_aborting$7 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$8)
                ret = 0;

              else
              {
                burn_drive_send_default_page_05(d, 0);
                _Bool tmp_if_expr$10;
                if(!(d->cancel == 0))
                  tmp_if_expr$10 = (_Bool)1;

                else
                {
                  return_value_burn_is_aborting$9=burn_is_aborting(0);
                  tmp_if_expr$10 = return_value_burn_is_aborting$9 != 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$10)
                  ret = 0;

              }
            }
          }
        }

      ex:
        ;
        _Bool tmp_if_expr$12;
        if(!(d->cancel == 0))
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          return_value_burn_is_aborting$11=burn_is_aborting(0);
          tmp_if_expr$12 = return_value_burn_is_aborting$11 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$12)
        {
          d->unlock(d);
          d->release(d);
        }

        d->silent_on_scsi_error = sose;
        d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
        burn_grab_restore_sig_action(signal_action_mem, 0);
        return ret;
      }
    }
}

// burn_drive_grab_dummy
// file libburn/drive.c line 1685
signed int burn_drive_grab_dummy(struct burn_drive_info **drive_infos, char *fname)
{
  signed int ret = -1;
  signed int role = 0;
  signed int fd;
  signed int is_rdwr = 0;
  signed int stat_ret = -1;
  signed long int size = (signed long int)(512 * 1024 * 1024 - 1) * (signed long int)2048;
  signed long int read_size = (signed long int)-1;
  struct burn_drive *d = (struct burn_drive *)(void *)0;
  struct burn_drive *regd_d;
  struct stat stbuf;
  if(!((signed int)*fname == 0))
  {
    fd=burn_drive__fd_from_special_adr(fname);
    is_rdwr=burn_drive__is_rdwr(fname, &stat_ret, &stbuf, &read_size, 1 | 2);
    if(stat_ret == -1 || !(is_rdwr == 0))
    {
      ret=burn_os_stdio_capacity(fname, (signed long int)0, &size);
      if(ret == -1)
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x00020009, 0x60000000, 0x30000000, "Neither stdio-path nor its directory exist", 0, 0);
        return 0;
      }

      else
        if(ret == -2)
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          libdax_msgs_submit(libdax_messenger, -1, 0x00020005, 0x60000000, 0x30000000, "Failed to open device (a pseudo-drive)", *return_value___errno_location$1, 0);
          return 0;
        }

      if(!((signed int)*fname == 0))
      {
        if(is_rdwr == 2 && !((1 & burn_drive_role_4_allowed) == 0))
          role = 4;

        else
          if(is_rdwr == 3 && !((1 & burn_drive_role_4_allowed) == 0))
            role = 5;

          else
            role = 2;
        if((3 & burn_drive_role_4_allowed) == 3 && fd == -1 && role == 2 && !(stat_ret == -1))
          role=burn_role_by_access(fname, (signed int)!(!((burn_drive_role_4_allowed & 4) != 0)));

      }

      else
        role = 0;
    }

    else
      role = 3;
  }

  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct burn_drive) /*2368ul*/ );
  d = (struct burn_drive *)return_value_calloc$2;
  void *return_value_calloc$4;
  if(d == ((struct burn_drive *)NULL))
    return 0;

  else
  {
    burn_setup_drive(d, fname);
    d->status = (enum burn_disc_status)BURN_DISC_EMPTY;
    d->drive_role = role;
    ret=burn_scsi_setup_drive(d, -1, -1, -1, -1, -1, 0);
    if(ret >= 1)
    {
      regd_d=burn_drive_register(d);
      if(regd_d == ((struct burn_drive *)NULL))
        ret = -1;

      else
      {
        free((void *)(char *)d);
        d = regd_d;
        _Bool tmp_if_expr$3;
        if(d->drive_role >= 2)
          tmp_if_expr$3 = d->drive_role <= 5 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          if(d->drive_role == 4)
          {
            if(read_size >= 1l)
              d->status = (enum burn_disc_status)BURN_DISC_FULL;

            else
              d->status = (enum burn_disc_status)BURN_DISC_EMPTY;
            d->block_types[(signed long int)BURN_WRITE_TAO] = 0;
            d->block_types[(signed long int)BURN_WRITE_SAO] = 0;
          }

          else
          {
            if((61440u & stbuf.st_mode) == 32768u && d->drive_role == 5 && stbuf.st_size >= 1l && !((8 & burn_drive_role_4_allowed) == 0) && !(stat_ret == -1))
            {
              d->status = (enum burn_disc_status)BURN_DISC_APPENDABLE;
              d->block_types[(signed long int)BURN_WRITE_SAO] = 0;
              if(stbuf.st_size / 2048l >= 2147483632l)
              {
                d->status = (enum burn_disc_status)BURN_DISC_FULL;
                d->role_5_nwa = 0x7ffffff0;
              }

              else
                d->role_5_nwa = (signed int)(stbuf.st_size / (signed long int)2048 + (signed long int)!(!(stbuf.st_size % (signed long int)2048 != 0l)));
            }

            else
            {
              d->status = (enum burn_disc_status)BURN_DISC_BLANK;
              d->block_types[(signed long int)BURN_WRITE_SAO] = BURN_BLOCK_SAO;
              d->role_5_nwa = 0;
            }
            d->block_types[(signed long int)BURN_WRITE_TAO] = BURN_BLOCK_MODE1;
          }
          d->current_profile = 0xffff;
          strcpy(d->current_profile_text, "stdio file");
          d->current_is_cd_profile = 0;
          d->current_is_supported_profile = 1;
          if(read_size >= 0l)
            d->media_read_capacity = (signed int)(read_size / (signed long int)2048 - (signed long int)!(read_size % (signed long int)2048 != 0l));

          burn_drive_set_media_capacity_remaining(d, size);
        }

        else
          d->current_profile = 0;
        return_value_calloc$4=calloc((unsigned long int)2, sizeof(struct burn_drive_info) /*80ul*/ );
        *drive_infos = (struct burn_drive_info *)return_value_calloc$4;
        if(!(*drive_infos == ((struct burn_drive_info *)NULL)))
        {
          (*drive_infos + (signed long int)0)->drive = d;
          (*drive_infos + (signed long int)1)->drive = (struct burn_drive *)(void *)0;
          (*drive_infos + (signed long int)0)->tao_block_types = d->block_types[(signed long int)BURN_WRITE_TAO];
          (*drive_infos + (signed long int)0)->sao_block_types = d->block_types[(signed long int)BURN_WRITE_SAO];
          if(d->drive_role == 2)
          {
            strcpy((*drive_infos + (signed long int)0)->vendor, "YOYODYNE");
            strcpy((*drive_infos + (signed long int)0)->product, "WARP DRIVE");
            strcpy((*drive_infos + (signed long int)0)->revision, "FX01");
          }

          else
            if(d->drive_role == 3)
            {
              strcpy((*drive_infos + (signed long int)0)->vendor, "YOYODYNE");
              strcpy((*drive_infos + (signed long int)0)->product, "BLACKHOLE");
              strcpy((*drive_infos + (signed long int)0)->revision, "FX02");
            }

            else
              if(d->drive_role == 4)
              {
                strcpy((*drive_infos + (signed long int)0)->vendor, "YOYODYNE");
                strcpy((*drive_infos + (signed long int)0)->product, "WARP DRIVE");
                strcpy((*drive_infos + (signed long int)0)->revision, "FX03");
              }

              else
                if(d->drive_role == 5)
                {
                  strcpy((*drive_infos + (signed long int)0)->vendor, "YOYODYNE");
                  strcpy((*drive_infos + (signed long int)0)->product, "WARP DRIVE");
                  strcpy((*drive_infos + (signed long int)0)->revision, "FX04");
                }

                else
                {
                  strcpy((*drive_infos + (signed long int)0)->vendor, "FERENGI");
                  strcpy((*drive_infos + (signed long int)0)->product, "VAPORWARE");
                  strcpy((*drive_infos + (signed long int)0)->revision, "0000");
                }
          d->released = 0;
          ret = 1;
        }

      }
    }


  ex:
    ;
    if(!(d == ((struct burn_drive *)NULL)) && !(ret >= 1))
    {
      burn_drive_free_subs(d);
      free((void *)(char *)d);
    }

    return ret;
  }
}

// burn_drive_grab_stdio
// file libburn/drive.c line 402
signed int burn_drive_grab_stdio(struct burn_drive *d, signed int flag)
{
  signed int stat_ret = -1;
  signed int is_rdwr;
  signed int ret;
  struct stat stbuf;
  signed long int read_size = (signed long int)0;
  signed long int size = (signed long int)0;
  char fd_name[40l];
  char *name_pt = (char *)(void *)0;
  if(d->stdio_fd >= 0)
  {
    sprintf(fd_name, "/dev/fd/%d", d->stdio_fd);
    name_pt = fd_name;
  }

  else
    if(!(*d->devname == 0))
      name_pt = d->devname;

  if(!(name_pt == ((char *)NULL)))
  {
    is_rdwr=burn_drive__is_rdwr(name_pt, &stat_ret, &stbuf, &read_size, 1 | 2);
    d->media_read_capacity = (signed int)(read_size / (signed long int)2048 - (signed long int)!(read_size % (signed long int)2048 != 0l));
    if(stat_ret == -1 || !(is_rdwr == 0))
    {
      if(!(*d->devname == 0))
      {
        ret=burn_os_stdio_capacity(d->devname, (signed long int)0, &size);
        if(ret >= 1)
          burn_drive_set_media_capacity_remaining(d, size);

      }

    }

  }

  d->released = 0;
  d->current_profile = 0xffff;
  _Bool tmp_if_expr$1;
  if(d->drive_role == 2)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = d->drive_role == 3 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    d->status = (enum burn_disc_status)BURN_DISC_BLANK;

  else
    if(d->drive_role == 4)
    {
      if(d->media_read_capacity >= 1)
        d->status = (enum burn_disc_status)BURN_DISC_FULL;

      else
        d->status = (enum burn_disc_status)BURN_DISC_EMPTY;
    }

    else
      if(d->drive_role == 5)
      {
        if((61440u & stbuf.st_mode) == 32768u && stbuf.st_size >= 1l && !(stat_ret == -1))
        {
          d->status = (enum burn_disc_status)BURN_DISC_APPENDABLE;
          if(stbuf.st_size / 2048l >= 2147483632l)
          {
            d->status = (enum burn_disc_status)BURN_DISC_FULL;
            d->role_5_nwa = 0x7ffffff0;
          }

          else
            d->role_5_nwa = (signed int)(stbuf.st_size / (signed long int)2048 + (signed long int)!(!(stbuf.st_size % (signed long int)2048 != 0l)));
        }

        else
          d->status = (enum burn_disc_status)BURN_DISC_BLANK;
      }

      else
      {
        d->status = (enum burn_disc_status)BURN_DISC_EMPTY;
        d->current_profile = 0;
      }
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  return 1;
}

// burn_drive_has_feature
// file libburn/drive.c line 3494
signed int burn_drive_has_feature(struct burn_drive *d, signed int feature_code, struct burn_feature_descr **descr, signed int flag)
{
  struct burn_feature_descr *o = d->features;
  for( ; !(o == ((struct burn_feature_descr *)NULL)); o = o->next)
    if((signed int)o->feature_code == feature_code)
    {
      if(!(descr == ((struct burn_feature_descr **)NULL)))
        *descr = o;

      return 1;
    }

  return 0;
}

// burn_drive_info_forget
// file test/../libburn/libburn.h line 1025
signed int burn_drive_info_forget(struct burn_drive_info *info, signed int force)
{
  signed int return_value_burn_drive_forget$1;
  return_value_burn_drive_forget$1=burn_drive_forget(info->drive, force);
  return return_value_burn_drive_forget$1;
}

// burn_drive_info_free
// file libburn/drive.c line 1462
void burn_drive_info_free(struct burn_drive_info *drive_infos)
{
  signed int i;
  if(!(drive_infos == ((struct burn_drive_info *)NULL)))
  {
    i = 0;
    for( ; !((drive_infos + (signed long int)i)->drive == ((struct burn_drive *)NULL)); i = i + 1)
      burn_drive_free((drive_infos + (signed long int)i)->drive);
    free((void *)drive_infos);
  }

}

// burn_drive_inquire_media
// file libburn/drive.c line 272
signed int burn_drive_inquire_media(struct burn_drive *d)
{
  d->getcaps(d);
  _Bool tmp_if_expr$2;
  if(d->current_profile >= 1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = d->current_is_guessed_profile != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$2)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    if(d->mdata->p2a_valid >= 1)
    {
      if(!(d->mdata->cdr_write == 0))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = d->mdata->cdrw_write != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = d->mdata->dvdr_write != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = d->mdata->dvdram_write != 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
    d->read_disc_info(d);

  else
  {
    _Bool tmp_if_expr$1;
    if(d->current_profile == -1)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = d->current_is_cd_profile != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      d->read_toc(d);

    if(!((signed int)d->status == BURN_DISC_EMPTY))
      d->status = (enum burn_disc_status)BURN_DISC_UNSUITABLE;

  }
  return 1;
}

// burn_drive_is_banned
// file libburn/drive.c line 1627
signed int burn_drive_is_banned(char *device_address)
{
  signed int i;
  signed int return_value_strcmp$1;
  if(!(enumeration_whitelist_top >= 0))
    return 0;

  else
  {
    i = 0;
    for( ; enumeration_whitelist_top >= i; i = i + 1)
    {
      return_value_strcmp$1=strcmp(enumeration_whitelist[(signed long int)i], device_address);
      if(return_value_strcmp$1 == 0)
        return 0;

    }
    return 1;
  }
}

// burn_drive_is_enumerable_adr
// file libburn/drive.c line 1947
signed int burn_drive_is_enumerable_adr(char *adr)
{
  signed int return_value_sg_is_enumerable_adr$1;
  return_value_sg_is_enumerable_adr$1=sg_is_enumerable_adr(adr);
  return return_value_sg_is_enumerable_adr$1;
}

// burn_drive_is_listed
// file libburn/drive.c line 240
signed int burn_drive_is_listed(char *path, struct burn_drive **found, signed int flag)
{
  signed int i;
  signed int ret;
  char *burn_drive_is_listed$$1$$drive_adr = (char *)(void *)0;
  char *off_adr = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
  burn_drive_is_listed$$1$$drive_adr = (char *)return_value_burn_alloc_mem$1;
  if(burn_drive_is_listed$$1$$drive_adr == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
    off_adr = (char *)return_value_burn_alloc_mem$2;
    if(off_adr == ((char *)NULL))
      ret = -1;

    else
    {
      ret=burn_drive_convert_fs_adr(path, off_adr);
      if(!(ret >= 1))
        strcpy(off_adr, path);

      i = 0;
      for( ; drivetop >= i; i = i + 1)
        if(drive_array[(signed long int)i].global_index >= 0)
        {
          ret=burn_drive_d_get_adr(&drive_array[(signed long int)i], burn_drive_is_listed$$1$$drive_adr);
          if(ret >= 1)
          {
            signed int return_value_strcmp$3;
            return_value_strcmp$3=strcmp(off_adr, burn_drive_is_listed$$1$$drive_adr);
            if(return_value_strcmp$3 == 0)
            {
              if(!(found == ((struct burn_drive **)NULL)))
                *found = &drive_array[(signed long int)i];

              ret = 1;
              goto ex;
            }

          }

        }

      ret = 0;
    }
  }

ex:
  ;
  if(!(burn_drive_is_listed$$1$$drive_adr == ((char *)NULL)))
    free((void *)(char *)burn_drive_is_listed$$1$$drive_adr);

  if(!(off_adr == ((char *)NULL)))
    free((void *)(char *)off_adr);

  return ret;
}

// burn_drive_is_occupied
// file libburn/drive.c line 193
signed int burn_drive_is_occupied(struct burn_drive *d)
{
  if(!(d->global_index >= 0))
    return -2;

  else
  {
    signed int return_value_burn_drive_is_open$1;
    return_value_burn_drive_is_open$1=burn_drive_is_open(d);
    if(return_value_burn_drive_is_open$1 == 0)
      return -1;

    else
      if((signed int)d->busy == BURN_DRIVE_GRABBING)
        return 10;

      else
        if(!(d->released == 0))
          return 0;

        else
          if((signed int)d->busy == BURN_DRIVE_IDLE)
            return 1;

          else
          {
            _Bool tmp_if_expr$2;
            if((signed int)d->busy == BURN_DRIVE_READING_SYNC)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = (signed int)d->busy == BURN_DRIVE_WRITING_SYNC ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              return 2;

            else
            {
              _Bool tmp_if_expr$3;
              if((signed int)d->busy == BURN_DRIVE_WRITING)
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = (signed int)d->busy == BURN_DRIVE_WRITING_LEADIN ? (_Bool)1 : (_Bool)0;
              _Bool tmp_if_expr$4;
              if(tmp_if_expr$3)
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = (signed int)d->busy == BURN_DRIVE_WRITING_LEADOUT ? (_Bool)1 : (_Bool)0;
              _Bool tmp_if_expr$5;
              if(tmp_if_expr$4)
                tmp_if_expr$5 = (_Bool)1;

              else
                tmp_if_expr$5 = (signed int)d->busy == BURN_DRIVE_WRITING_PREGAP ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$5)
                return 50;

              else
                if((signed int)d->busy == BURN_DRIVE_READING)
                  return 50;

                else
                  return 1000;
            }
          }
  }
}

// burn_drive_is_open
// file libburn/drive.c line 157
signed int burn_drive_is_open(struct burn_drive *d)
{
  if(!(d->drive_role == 1))
    return (signed int)(d->stdio_fd >= 0);

  else
  {
    signed int return_value;
    return_value=d->drive_is_open(d);
    return return_value;
  }
}

// burn_drive_is_released
// file libburn/drive.c line 175
signed int burn_drive_is_released(struct burn_drive *d)
{
  return (signed int)!(!(d->released != 0));
}

// burn_drive_leave_locked
// file libburn/drive.c line 788
signed int burn_drive_leave_locked(struct burn_drive *d, signed int flag)
{
  signed int return_value_burn_drive_release_fl$1;
  return_value_burn_drive_release_fl$1=burn_drive_release_fl(d, 2);
  return return_value_burn_drive_release_fl$1;
}

// burn_drive_mark_unready
// file libburn/drive.c line 642
signed int burn_drive_mark_unready(struct burn_drive *d, signed int flag)
{
  d->start_lba = -2000000000;
  d->end_lba = -2000000000;
  d->current_profile = -1;
  d->current_has_feat21h = 0;
  d->current_feat2fh_byte4 = -1;
  d->status = (enum burn_disc_status)BURN_DISC_UNREADY;
  if(!(d->toc_entry == ((struct burn_toc_entry *)NULL)))
    free((void *)d->toc_entry);

  d->toc_entry = (struct burn_toc_entry *)(void *)0;
  d->toc_entries = 0;
  if(!(d->write_opts == ((struct burn_write_opts *)NULL)))
  {
    burn_write_opts_free(d->write_opts);
    d->write_opts = (struct burn_write_opts *)(void *)0;
  }

  if(!(d->disc == ((struct burn_disc *)NULL)))
  {
    burn_disc_free(d->disc);
    d->disc = (struct burn_disc *)(void *)0;
  }

  if((8 & flag) == 0)
  {
    if(d->stdio_fd >= 0)
      close(d->stdio_fd);

    d->stdio_fd = -1;
  }

  return 1;
}

// burn_drive_obtain_scsi_adr
// file libburn/drive.c line 2074
signed int burn_drive_obtain_scsi_adr(char *path, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no)
{
  signed int ret;
  signed int i;
  char *adr = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
  adr = (char *)return_value_burn_alloc_mem$1;
  if(adr == ((char *)NULL))
    ret = -1;

  else
  {
    i = 0;
    for( ; !(i >= 1 + drivetop); i = i + 1)
      if(drive_array[(signed long int)i].global_index >= 0)
      {
        ret=burn_drive_d_get_adr(&drive_array[(signed long int)i], adr);
        if(!(ret >= 0))
        {
          ret = 1;
          goto ex;
        }

        if(!(ret == 0))
        {
          signed int return_value_strcmp$5;
          return_value_strcmp$5=strcmp(adr, path);
          if(return_value_strcmp$5 == 0)
          {
            *host_no = drive_array[(signed long int)i].host;
            *channel_no = drive_array[(signed long int)i].channel;
            *target_no = drive_array[(signed long int)i].id;
            *lun_no = drive_array[(signed long int)i].lun;
            *bus_no = drive_array[(signed long int)i].bus_no;
            _Bool tmp_if_expr$2;
            if(!(*host_no >= 0))
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = *channel_no < 0 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$3;
            if(tmp_if_expr$2)
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = *target_no < 0 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$4;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = *lun_no < 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$4)
            {
              ret = 0;
              goto ex;
            }

            ret = 1;
            goto ex;
          }

        }

      }

    ret=sg_obtain_scsi_adr(path, bus_no, host_no, channel_no, target_no, lun_no);
  }

ex:
  ;
  if(!(adr == ((char *)NULL)))
    free((void *)(char *)adr);

  return ret;
}

// burn_drive_probe_cd_write_modes
// file libburn/drive.c line 1306
signed int burn_drive_probe_cd_write_modes(struct burn_drive_info *dinfo)
{
  struct burn_drive *d = dinfo->drive;
  if(d == ((struct burn_drive *)NULL))
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(!(dinfo->write_dvdram == 0u))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = dinfo->write_dvdr != 0u ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = dinfo->write_cdrw != 0u ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = dinfo->write_cdr != 0u ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      d->probe_write_modes(d);

    dinfo->tao_block_types = d->block_types[(signed long int)BURN_WRITE_TAO];
    dinfo->sao_block_types = d->block_types[(signed long int)BURN_WRITE_SAO];
    dinfo->raw_block_types = d->block_types[(signed long int)BURN_WRITE_RAW];
    dinfo->packet_block_types = d->block_types[(signed long int)BURN_WRITE_PACKET];
    return 1;
  }
}

// burn_drive_re_assess
// file libburn/drive.c line 756
signed int burn_drive_re_assess(struct burn_drive *d, signed int flag)
{
  signed int ret;
  signed int signal_action_mem;
  if(!(d->released == 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020108, 0x60000000, 0x30000000, "Drive is not grabbed on burn_drive_re_assess()", 0, 0);
    return 0;
  }

  else
  {
    burn_drive_release_fl(d, 2 | 8);
    if(!(d->drive_role == 1))
    {
      ret=burn_drive_grab_stdio(d, 0);
      return ret;
    }

    else
    {
      burn_grab_prepare_sig_action(&signal_action_mem, 0);
      d->busy = (volatile enum burn_drive_status)BURN_DRIVE_GRABBING;
      ret=burn_drive_inquire_media(d);
      burn_drive_send_default_page_05(d, 0);
      d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
      burn_grab_restore_sig_action(signal_action_mem, 0);
      d->released = 0;
      return ret;
    }
  }
}

// burn_drive_register
// file libburn/drive.c line 529
struct burn_drive * burn_drive_register(struct burn_drive *d)
{
  signed int i;
  d->block_types[(signed long int)0] = 0;
  d->block_types[(signed long int)1] = 0;
  d->block_types[(signed long int)2] = 0;
  d->block_types[(signed long int)3] = 0;
  d->toc_temp = 0;
  d->nwa = 0;
  d->alba = 0;
  d->rlba = 0;
  d->cancel = 0;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  d->thread_pid = 0;
  d->thread_pid_valid = 0;
  memset((void *)&d->thread_tid, 0, sizeof(unsigned long int) /*8ul*/ );
  d->toc_entries = 0;
  d->toc_entry = (struct burn_toc_entry *)(void *)0;
  d->disc = (struct burn_disc *)(void *)0;
  d->erasable = 0;
  d->write_opts = (struct burn_write_opts *)(void *)0;
  i = 0;
  for( ; !(i >= 1 + drivetop); i = i + 1)
    if(drive_array[(signed long int)i].global_index == -1)
      break;

  d->global_index = i;
  memcpy((void *)&drive_array[(signed long int)i], (const void *)d, sizeof(struct burn_drive) /*2368ul*/ );
  pthread_mutex_init(&drive_array[(signed long int)i].access_lock, (const union anonymous$1 *)(void *)0);
  if(!(drivetop >= i))
    drivetop = i;

  return &drive_array[(signed long int)i];
}

// burn_drive_release
// file test/../libburn/libburn.h line 1205
void burn_drive_release(struct burn_drive *d, signed int le)
{
  burn_drive_release_fl(d, (signed int)!(!(le != 0)));
}

// burn_drive_release_fl
// file libburn/drive.c line 679
signed int burn_drive_release_fl(struct burn_drive *d, signed int flag)
{
  if(!(d->released == 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020105, 0x60000000, 0x30000000, "Drive is already released", 0, 0);
    return 0;
  }

  else
    if(!((signed int)d->busy == BURN_DRIVE_IDLE))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020106, 0x60000000, 0x30000000, "Drive is busy on attempt to close", 0, 0);
      return 0;
    }

    else
    {
      if(d->drive_role == 1)
      {
        if(!(d->needs_sync_cache == 0))
          d->sync_cache(d);

        if(!((7 & flag) == 2))
          d->unlock(d);

        if((7 & flag) == 1)
          d->eject(d);

        if((8 & flag) == 0)
        {
          burn_drive_snooze(d, 0);
          d->release(d);
        }

      }

      d->needs_sync_cache = 0;
      if(!(d->drive_serial_number == ((char *)NULL)))
      {
        if(!(d->drive_serial_number == ((char *)NULL)))
          free((void *)(char *)d->drive_serial_number);

      }

      if(!(d->media_serial_number == ((char *)NULL)))
      {
        if(!(d->media_serial_number == ((char *)NULL)))
          free((void *)(char *)d->media_serial_number);

      }

      d->media_serial_number = (char *)(void *)0;
      d->drive_serial_number = d->media_serial_number;
      d->media_serial_number_len = (char)0;
      d->drive_serial_number_len = d->media_serial_number_len;
      d->released = 1;
      burn_drive_mark_unready(d, flag & 8);
      return 1;
    }
}

// burn_drive_resolve_link
// file libburn/drive.c line 1959
signed int burn_drive_resolve_link(char *path, char *adr, signed int *recursion_count, signed int flag)
{
  signed int ret;
  signed int link_target_size = 4096;
  char *link_target = (char *)(void *)0;
  char *msg = (char *)(void *)0;
  char *link_adr = (char *)(void *)0;
  char *adrpt;
  struct stat stbuf;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)link_target_size, 0);
  link_target = (char *)return_value_burn_alloc_mem$1;
  signed long int return_value_readlink$4;
  if(link_target == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(link_target_size + 100), 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)link_target_size, 0);
      link_adr = (char *)return_value_burn_alloc_mem$3;
      if(link_adr == ((char *)NULL))
        ret = -1;

      else
      {
        if(!((1 & flag) == 0))
          burn_drive_adr_debug_msg("burn_drive_resolve_link( %s )", path);

        if(*recursion_count >= 20)
        {
          if(!((1 & flag) == 0))
            burn_drive_adr_debug_msg("burn_drive_resolve_link aborts because link too deep", (char *)(void *)0);

          ret = 0;
        }

        else
        {
          *recursion_count = *recursion_count + 1;
          return_value_readlink$4=readlink(path, link_target, (unsigned long int)link_target_size);
          ret = (signed int)return_value_readlink$4;
          if(ret == -1)
          {
            if(!((1 & flag) == 0))
              burn_drive_adr_debug_msg("readlink( %s ) returns -1", path);

            ret = 0;
          }

          else
            if(ret >= link_target_size + -1)
            {
              sprintf(msg, "readlink( %s ) returns %d (too much)", path, ret);
              if(!((1 & flag) == 0))
                burn_drive_adr_debug_msg(msg, (char *)(void *)0);

              ret = -1;
            }

            else
            {
              link_target[(signed long int)ret] = (char)0;
              adrpt = link_target;
              if(!((signed int)*link_target == 47))
              {
                strcpy(link_adr, path);
                adrpt=strrchr(link_adr, 47);
                if(!(adrpt == ((char *)NULL)))
                {
                  strcpy(adrpt + (signed long int)1, link_target);
                  adrpt = link_adr;
                }

                else
                  adrpt = link_target;
              }

              if(!((2 & flag) == 0))
              {
                signed int return_value_lstat$5;
                return_value_lstat$5=lstat(adrpt, &stbuf);
                if(!(return_value_lstat$5 == -1))
                {
                  if((61440u & stbuf.st_mode) == 40960u)
                    ret=burn_drive_resolve_link(adrpt, adr, recursion_count, flag);

                  else
                    strcpy(adr, adrpt);
                }

              }

              else
              {
                ret=burn_drive_convert_fs_adr_sub(adrpt, adr, recursion_count);
                sprintf(msg, "burn_drive_convert_fs_adr( %s ) returns %d", link_target, ret);
              }
              if(!((1 & flag) == 0))
                burn_drive_adr_debug_msg(msg, (char *)(void *)0);

            }
        }
      }
    }
  }

ex:
  ;
  if(!(link_target == ((char *)NULL)))
    free((void *)(char *)link_target);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(link_adr == ((char *)NULL)))
    free((void *)(char *)link_adr);

  return ret;
}

// burn_drive_scan
// file test/../libburn/libburn.h line 1007
signed int burn_drive_scan(struct burn_drive_info **drives, unsigned int *n_drives)
{
  union w_list_data o;
  signed int ret = 0;
  if(burn_running == 0)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020109, 0x70000000, 0x30000000, "Library not running (on attempt to scan)", 0, 0);
    *drives = (struct burn_drive_info *)(void *)0;
    *n_drives = (unsigned int)0;
    return -1;
  }

  else
    if(!(workers == ((struct w_list *)NULL)))
    {
      if(workers->drive == ((struct burn_drive *)NULL))
        goto __CPROVER_DUMP_L3;


    drive_is_active:
      ;
      libdax_msgs_submit(libdax_messenger, -1, 0x00020102, 0x60000000, 0x30000000, "A drive operation is still going on (want to scan)", 0, 0);
      *drives = (struct burn_drive_info *)(void *)0;
      *n_drives = (unsigned int)0;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(workers == ((struct w_list *)NULL))
      {
        signed int return_value_burn_drives_are_clear$1;
        return_value_burn_drives_are_clear$1=burn_drives_are_clear(1);
        if(return_value_burn_drives_are_clear$1 == 0)
          goto drive_is_active;

        *drives = (struct burn_drive_info *)(void *)0;
        *n_drives = (unsigned int)0;
        o.scan.drives = drives;
        o.scan.n_drives = n_drives;
        o.scan.done = 0;
        add_worker(0, (struct burn_drive *)(void *)0, (void * (*)(void *))scan_worker_func, &o);
      }

      else
        if(!(workers->u.scan.done == 0))
        {
          ret = workers->u.scan.done;
          remove_worker(workers->thread);
          if(!(workers == ((struct w_list *)NULL)))
          {
            libdax_msgs_submit(libdax_messenger, -1, 0x00020101, 0x50000000, 0x30000000, "After scan a drive operation is still going on", 0, 0);
            return -1;
          }

        }

      return ret;
    }
}

// burn_drive_scan_and_grab
// file test/../libburn/libburn.h line 964
signed int burn_drive_scan_and_grab(struct burn_drive_info **drive_infos, char *adr, signed int load)
{
  unsigned int n_drives;
  signed int ret;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; drivetop >= i; i = i + 1)
    if(drive_array[(signed long int)i].global_index >= 0)
    {
      return_value_strcmp$1=strcmp(drive_array[(signed long int)i].devname, adr);
      if(return_value_strcmp$1 == 0)
        break;

    }

  if(drivetop >= i)
  {
    libdax_msgs_submit(libdax_messenger, i, 0x0002014b, 0x60000000, 0x30000000, "Drive is already registered resp. scanned", 0, 0);
    return -1;
  }

  else
  {
    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(adr, "stdio:", (unsigned long int)6);
    if(return_value_strncmp$2 == 0)
    {
      ret=burn_drive_grab_dummy(drive_infos, adr + (signed long int)6);
      return ret;
    }

    else
    {
      burn_drive_clear_whitelist();
      burn_drive_add_whitelist(adr);
      ret=burn_drive_scan_sync(drive_infos, &n_drives, 0);
      if(!(ret >= 0))
        return -1;

      else
        if(n_drives == 0u)
          return 0;

        else
        {
          ret=burn_drive_grab(drive_infos[(signed long int)0]->drive, load);
          if(!(ret == 1))
          {
            burn_drive_forget(drive_infos[(signed long int)0]->drive, 0);
            return -1;
          }

          else
            return 1;
        }
    }
  }
}

// burn_drive_scan_sync
// file libburn/drive.h line 65
signed int burn_drive_scan_sync(struct burn_drive_info **drives, unsigned int *n_drives, signed int flag)
{
  unsigned char scanned[32l];
  unsigned int count = (unsigned int)0;
  signed int i;
  signed int ret;
  *n_drives = (unsigned int)0;
  i = 0;
  for( ; !(i >= (signed int)sizeof(unsigned char [32l]) /*32*/ ); i = i + 1)
    scanned[(signed long int)i] = (unsigned char)0;
  if(!((1 & flag) == 0))
    burn_drive_free_all();

  else
  {
    i = 0;
    for( ; drivetop >= i; i = i + 1)
      if(drive_array[(signed long int)i].global_index >= 0)
        scanned[(signed long int)(i / 8)] = scanned[(signed long int)(i / 8)] | (unsigned char)(1 << i % 8);

  }
  scsi_enumerate_drives();
  count=burn_drive_count();
  if(!(count == 0u))
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)(count + (unsigned int)1), sizeof(struct burn_drive_info) /*80ul*/ );
    *drives = (struct burn_drive_info *)return_value_calloc$1;
    if(*drives == ((struct burn_drive_info *)NULL))
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00000003, 0x70000000, 0x30000000, "Out of virtual memory", 0, 0);
      return -1;
    }

    else
    {
      i = 0;
      for( ; (signed int)count >= i; i = i + 1)
        (*drives + (signed long int)i)->drive = (struct burn_drive *)(void *)0;
    }
  }

  else
    *drives = (struct burn_drive_info *)(void *)0;
  i = 0;
  for( ; !(i >= (signed int)count); i = i + 1)
    if((1 << i % 8 & (signed int)scanned[(signed long int)(i / 8)]) == 0)
    {
      if(drive_array[(signed long int)i].global_index >= 0)
      {
        ret=drive_getcaps(&drive_array[(signed long int)i], &(*drives)[(signed long int)*n_drives]);
        if(ret >= 1)
          *n_drives = *n_drives + 1u;

        scanned[(signed long int)(i / 8)] = scanned[(signed long int)(i / 8)] | (unsigned char)(1 << i % 8);
      }

    }

  if(!(*drives == ((struct burn_drive_info *)NULL)))
  {
    if(*n_drives == 0u)
    {
      free((void *)(char *)*drives);
      *drives = (struct burn_drive_info *)(void *)0;
    }

  }

  return 1;
}

// burn_drive_send_default_page_05
// file libburn/drive.c line 299
signed int burn_drive_send_default_page_05(struct burn_drive *d, signed int flag)
{
  struct burn_write_opts *opts;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(d->sent_default_page_05 == 0))
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if((signed int)d->status == BURN_DISC_APPENDABLE)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)d->status == BURN_DISC_BLANK ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$1)
    {
      if(!(d->current_is_cd_profile == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = d->current_profile == 0x11 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(!tmp_if_expr$5)
      return 0;

    else
    {
      opts=burn_write_opts_new(d);
      if(opts == ((struct burn_write_opts *)NULL))
        return -1;

      else
      {
        if((signed int)d->status == BURN_DISC_APPENDABLE)
          burn_write_opts_set_write_type(opts, (enum burn_write_types)BURN_WRITE_TAO, BURN_BLOCK_MODE1);

        else
          burn_write_opts_set_write_type(opts, (enum burn_write_types)BURN_WRITE_SAO, BURN_BLOCK_SAO);
        d->send_write_parameters(d, (struct burn_session *)(void *)0, -1, opts);
        burn_write_opts_free(opts);
        d->sent_default_page_05 = 1;
        return 1;
      }
    }
  }
}

// burn_drive_set_buffer_waiting
// file libburn/drive.c line 1540
signed int burn_drive_set_buffer_waiting(struct burn_drive *d, signed int enable, signed int min_usec, signed int max_usec, signed int timeout_sec, signed int min_percent, signed int max_percent)
{
  if(enable >= 0)
    d->wait_for_buffer_free = (signed int)!(!(enable != 0));

  if(min_usec >= 0)
    d->wfb_min_usec = (unsigned int)min_usec;

  if(max_usec >= 0)
    d->wfb_max_usec = (unsigned int)max_usec;

  if(timeout_sec >= 0)
    d->wfb_timeout_sec = (unsigned int)timeout_sec;

  if(min_percent >= 0)
  {
    if(min_percent >= 101 || !(min_percent >= 25))
      return 0;

    d->wfb_min_percent = (unsigned int)min_percent;
  }

  if(max_percent >= 0)
  {
    if(max_percent >= 101 || !(max_percent >= 25))
      return 0;

    d->wfb_max_percent = (unsigned int)max_percent;
  }

  return 1;
}

// burn_drive_set_media_capacity_remaining
// file libburn/drive.c line 3313
signed int burn_drive_set_media_capacity_remaining(struct burn_drive *d, signed long int value)
{
  if(value / 2048l >= 2147483633l)
    value = (signed long int)0x7ffffff0 * (signed long int)2048;

  d->media_capacity_remaining = value;
  return 1;
}

// burn_drive_set_speed
// file libburn/drive.c line 1530
void burn_drive_set_speed(struct burn_drive *d, signed int r, signed int w)
{
  d->nominal_write_speed = w;
  if(d->drive_role == 1)
    d->set_speed(d, r, w);

}

// burn_drive_set_stream_recording
// file libburn/drive.c line 1149
signed int burn_drive_set_stream_recording(struct burn_drive *d, signed int recmode, signed int start, signed int flag)
{
  if(recmode == 1)
    d->do_stream_recording = 1;

  else
    if(recmode == -1)
      d->do_stream_recording = 0;

  d->stream_recording_start = start;
  return 1;
}

// burn_drive_snooze
// file libburn/drive.c line 735
signed int burn_drive_snooze(struct burn_drive *d, signed int flag)
{
  if(!(d->drive_role == 1))
    return 0;

  else
  {
    if(!((1 & flag) == 0))
      d->start_unit(d);

    else
      d->stop_unit(d);
    return 1;
  }
}

// burn_drive_unregister
// file libburn/drive.c line 586
signed int burn_drive_unregister(struct burn_drive *d)
{
  if(!(d->global_index == drivetop))
    return 0;

  else
  {
    burn_drive_free(d);
    drivetop = drivetop - 1;
    return 1;
  }
}

// burn_drive_was_feat21_failure
// file libburn/drive.c line 3437
signed int burn_drive_was_feat21_failure(struct burn_drive *d)
{
  return (signed int)!(!(d->was_feat21h_failure != 0));
}

// burn_drive_whitelist_count
// file libburn/drive.c line 1640
signed int burn_drive_whitelist_count(void)
{
  return enumeration_whitelist_top + 1;
}

// burn_drive_whitelist_item
// file libburn/drive.c line 1645
char * burn_drive_whitelist_item(signed int idx, signed int flag)
{
  if(!(idx >= 0) || !(enumeration_whitelist_top >= idx))
    return (char *)(void *)0;

  else
    return enumeration_whitelist[(signed long int)idx];
}

// burn_drive_wrote_well
// file libburn/drive.c line 2685
signed int burn_drive_wrote_well(struct burn_drive *d)
{
  return (signed int)!(d->cancel != 0);
}

// burn_drives_are_clear
// file libburn/drive.h line 55
signed int burn_drives_are_clear(signed int flag)
{
  signed int i;
  unsigned int return_value_burn_drive_count$1;
  return_value_burn_drive_count$1=burn_drive_count();
  i = (signed int)(return_value_burn_drive_count$1 - (unsigned int)1);
  for( ; i >= 0; i = i - 1)
  {
    if(!(drive_array[(signed long int)i].global_index == -1))
    {
      if(!(drive_array[(signed long int)i].released == 0))
      {
        if((1 & flag) == 0)
          goto __CPROVER_DUMP_L3;

      }

      return 0;
    }


  __CPROVER_DUMP_L3:
    ;
  }
  return 1;
}

// burn_dvd_write_session
// file libburn/write.c line 2065
signed int burn_dvd_write_session(struct burn_write_opts *o, struct burn_session *s, signed int is_last_session)
{
  signed int i;
  signed int ret;
  signed int multi_mem;
  struct burn_drive *d = o->drive;
  if(d->current_profile == 0x41)
  {
    if((signed int)d->status == BURN_DISC_APPENDABLE)
    {
      if(d->state_of_last_session == 1)
      {
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020170, 0x30000000, 0x30000000, "Closing open session before writing new one", 0, 0);
        d->close_track_session(d, 1, 0);
        d->state_of_last_session = 3;
      }

    }

  }

  i = 0;
  for( ; !(i >= s->tracks); i = i + 1)
  {
    _Bool tmp_if_expr$1;
    if(!(is_last_session == 0))
      tmp_if_expr$1 = i == s->tracks - 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    ret=burn_dvd_write_track(o, s, i, (signed int)tmp_if_expr$1);
    if(!(ret >= 1))
      break;

  }
  _Bool tmp_if_expr$4;
  if(d->current_profile == 0x11)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
  {
    if(!(d->was_feat21h_failure == 2))
    {
      multi_mem = (signed int)o->multi;
      if(is_last_session == 0)
        o->multi = (unsigned char)1;

      ret=burn_disc_close_session_dvd_minus_r(o);
      o->multi = (unsigned char)multi_mem;
      if(!(ret >= 1))
        return 0;

    }

  }

  else
  {
    _Bool tmp_if_expr$3;
    if(d->current_profile == 0x12)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$3)
    {
      if(d->current_profile == 0x13)
      {
        if(!(d->needs_close_session == 0))
        {
          ret=burn_disc_close_session_dvd_minus_rw(o, s);
          if(!(ret >= 1))
            return 0;

        }

      }

      else
        if(d->current_profile == 0x1a)
        {
          if(!(d->needs_close_session == 0))
          {
            ret=burn_disc_close_session_dvd_plus_rw(o, s);
            if(!(ret >= 1))
              return 0;

          }

        }

        else
        {
          _Bool tmp_if_expr$2;
          if(d->current_profile == 0x1b)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
        }
    }

  }
  return 1;
}

// burn_dvd_write_sync
// file libburn/write.c line 2284
signed int burn_dvd_write_sync(struct burn_write_opts *o, struct burn_disc *disc)
{
  signed int i;
  signed int ret;
  signed int o_end;
  signed long int default_size = (signed long int)0;
  struct burn_drive *d = o->drive;
  struct burn_track *t;
  char *msg = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    d->needs_close_session = 0;
    o->obs = 32 * 1024;
    _Bool tmp_if_expr$10;
    if(d->current_profile == 0x1a)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$11;
    if(tmp_if_expr$10)
      tmp_if_expr$11 = (_Bool)1;

    else
      tmp_if_expr$11 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$11)
    {
      ret = 1;
      if(d->current_profile == 0x1a)
        ret=burn_disc_setup_dvd_plus_rw(o, disc);

      if(!(ret >= 1))
      {
        sprintf(msg, "Write preparation setup failed for DVD+RW");
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020121, 0x70000000, 0x30000000, msg, 0, 0);
        goto early_failure;
      }

      d->nwa = 0;
      if(o->start_byte >= 0l)
      {
        d->nwa = (signed int)(o->start_byte / (signed long int)2048);
        sprintf(msg, "Write start address is  %d * 2048", d->nwa);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020127, 0x30000000, 0x30000000, msg, 0, 0);
      }

      if(!(o->obs_pad >= 2))
        o->obs_pad = 0;

      if(d->current_profile == 0x43)
        o->obs = 64 * 1024;

      if(!(d->do_stream_recording == 0))
      {
        if(!(o->obs_pad >= 2))
          o->obs_pad = 1;

        if(d->current_profile == 0x43)
          o->obs = 64 * 1024;

      }

    }

    else
      if(d->current_profile == 0x13)
      {
        ret=burn_disc_setup_dvd_minus_rw(o, disc);
        if(!(ret >= 1))
        {
          sprintf(msg, "Write preparation setup failed for DVD-RW");
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020121, 0x70000000, 0x30000000, msg, 0, 0);
          goto early_failure;
        }

        o->obs_pad = 1;
      }

      else
      {
        _Bool tmp_if_expr$8;
        if(d->current_profile == 0x11)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$9;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
        {
          t = disc->session[(signed long int)0]->track[(signed long int)0];
          signed int return_value_burn_track_is_open_ended$2;
          return_value_burn_track_is_open_ended$2=burn_track_is_open_ended(t);
          _Bool tmp_if_expr$3;
          if(!(return_value_burn_track_is_open_ended$2 == 0))
            tmp_if_expr$3 = !(o->fill_up_media != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          o_end = (signed int)tmp_if_expr$3;
          default_size=burn_track_get_default_size(t);
          if((signed int)o->write_type == BURN_WRITE_SAO)
          {
            if(!(o_end == 0))
            {
              sprintf(msg, "Activated track default size %.f", (double)default_size);
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002012e, 0x30000000, 0x30000000, msg, 0, 0);
              burn_track_set_size(t, default_size);
            }

          }

          if(!(o->obs_pad >= 2))
            o->obs_pad = (signed int)((signed int)o->write_type != BURN_WRITE_SAO);

          ret=burn_disc_setup_dvd_minus_r(o, disc);
          if(!(ret >= 1))
          {
            sprintf(msg, "Write preparation setup failed for DVD-R[W]");
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020121, 0x70000000, 0x30000000, msg, 0, 0);
            goto early_failure;
          }

        }

        else
        {
          _Bool tmp_if_expr$6;
          if(d->current_profile == 0x1b)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$7;
          if(tmp_if_expr$6)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$7)
          {
            t = disc->session[(signed long int)0]->track[(signed long int)0];
            signed int return_value_burn_track_is_open_ended$4;
            return_value_burn_track_is_open_ended$4=burn_track_is_open_ended(t);
            _Bool tmp_if_expr$5;
            if(!(return_value_burn_track_is_open_ended$4 == 0))
              tmp_if_expr$5 = !(o->fill_up_media != 0) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            o_end = (signed int)tmp_if_expr$5;
            default_size=burn_track_get_default_size(t);
            if((signed int)o->write_type == BURN_WRITE_SAO)
            {
              if(!(o_end == 0))
              {
                sprintf(msg, "Activated track default size %.f", (double)default_size);
                libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002012e, 0x30000000, 0x30000000, msg, 0, 0);
                burn_track_set_size(t, default_size);
              }

            }

            ret=burn_disc_setup_dvd_plus_r(o, disc);
            if(!(ret >= 1))
            {
              sprintf(msg, "Write preparation setup failed for %s", d->current_profile == 0x41 ? "BD-R" : "DVD+R");
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020121, 0x70000000, 0x30000000, msg, 0, 0);
              goto early_failure;
            }

            if(!(o->obs_pad >= 2))
              o->obs_pad = 1;

            if(d->current_profile == 0x41)
              o->obs = 64 * 1024;

            if(!(d->do_stream_recording == 0))
            {
              if(d->current_profile == 0x41)
                o->obs = 64 * 1024;

            }

          }

        }
      }
    if(o->dvd_obs_override >= 32)
      o->obs = o->dvd_obs_override;

    if(o->obs >= 65537)
    {
      sprintf(msg, "Chosen write chunk size %d exceeds system dependent buffer size", o->obs);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
      o->obs = 32 * 1024;
    }

    if(!(d->do_stream_recording == 0))
    {
      _Bool tmp_if_expr$12;
      if(d->current_profile == 0x43)
        tmp_if_expr$12 = (_Bool)1;

      else
        tmp_if_expr$12 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$12)
      {
        if(!(o->obs >= 64))
        {
          sprintf(msg, "Stream recording disabled because of small output buffer");
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020176, 0x30000000, 0x30000000, msg, 0, 0);
          d->do_stream_recording = 0;
        }

      }

    }

    sprintf(msg, "dvd/bd Profile= %2.2Xh , obs= %d , obs_pad= %d", d->current_profile, o->obs, o->obs_pad);
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
    i = 0;
    for( ; !(i >= disc->sessions); i = i + 1)
    {
      d->progress.session = i;
      d->progress.tracks = disc->session[(signed long int)i]->tracks;
      ret=burn_dvd_write_session(o, disc->session[(signed long int)i], (signed int)(i == disc->sessions - 1));
      if(!(ret >= 1))
        goto ex;

      d->progress.sector = 0;
      d->progress.start_sector = 0;
      d->progress.sectors = 0;
    }
    ret = 1;
  }

ex:
  ;
  burn_drive_mark_unready(d, 0);
  burn_drive_inquire_media(d);
  if(d->current_profile == 0x41)
  {
    if(d->complete_sessions >= 300)
    {
      sprintf(msg, "Sequential BD-R media now contains %d sessions. It is likely to soon fail writing.", d->complete_sessions);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002017b, 0x50000000, 0x00000000, msg, 0, 0);
    }

  }

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;

early_failure:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return 0;
}

// burn_dvd_write_track
// file libburn/write.c line 1876
signed int burn_dvd_write_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum, signed int is_last_track)
{
  struct burn_track *t = s->track[(signed long int)tnum];
  struct burn_drive *d = o->drive;
  struct buffer *out = d->buffer;
  signed int sectors;
  signed int i;
  signed int open_ended = 0;
  signed int ret = 0;
  signed int is_flushed = 0;
  signed int track_open = 0;
  signed int first_buf_cap = 0;
  signed int further_cap = 0;
  signed int buf_cap_step = 1024;
  burn_track_apply_fillup(t, d->media_capacity_remaining, 0);
  _Bool tmp_if_expr$2;
  if(d->current_profile == 0x11)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    ret=burn_disc_open_track_dvd_minus_r(o, s, tnum);
    if(!(ret >= 1))
      goto ex;

    first_buf_cap = 0;
    further_cap = -1;
  }

  else
  {
    _Bool tmp_if_expr$1;
    if(d->current_profile == 0x1b)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      ret=burn_disc_open_track_dvd_plus_r(o, s, tnum);
      if(!(ret >= 1))
        goto ex;

    }

    else
      if(d->current_profile == 0x41)
      {
        ret=burn_disc_open_track_dvd_plus_r(o, s, tnum);
        if(!(ret >= 1))
          goto ex;

      }

  }
  track_open = 1;
  sectors=burn_track_get_sectors_2(t, 1);
  open_ended=burn_track_is_open_ended(t);
  burn_disc_init_track_status(o, s, t, tnum, sectors);
  i = 0;
  for( ; !(open_ended == 0) || !(i >= sectors); i = i + 1)
  {
    if(i == first_buf_cap || i % buf_cap_step == 0 && (i >= further_cap || !(further_cap >= 0)))
    {
      d->read_buffer_capacity(d);
      if(!(further_cap >= 0))
        further_cap = (signed int)(d->progress.buffer_capacity / (unsigned int)2048 + (unsigned int)128);

    }

    signed int return_value_sector_data$4;
    return_value_sector_data$4=sector_data(o, t, 0);
    if(return_value_sector_data$4 == 0)
    {
      ret = 0;
      goto ex;
    }

    if(!(open_ended == 0))
    {
      sectors = i;
      d->progress.sectors = sectors;
      signed int return_value_burn_track_is_data_done$5;
      return_value_burn_track_is_data_done$5=burn_track_is_data_done(t);
      if(!(return_value_burn_track_is_data_done$5 == 0))
        break;

    }

    d->progress.sector = d->progress.sector + 1;
  }
  if(!(o->obs_pad == 0))
  {
    if(out->bytes >= 1)
    {
      if(!(out->bytes >= o->obs))
      {
        memset((void *)(out->data + (signed long int)out->bytes), 0, (unsigned long int)(o->obs - out->bytes));
        out->sectors = out->sectors + (o->obs - out->bytes) / 2048;
        out->bytes = o->obs;
      }

    }

  }

  ret=burn_write_flush(o, t);
  if(ret >= 1)
  {
    is_flushed = 1;
    _Bool tmp_if_expr$7;
    if(d->current_profile == 0x11)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$8;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
    {
      ret=burn_disc_close_track_dvd_minus_r(o, tnum);
      if(!(ret >= 1))
        goto ex;

    }

    else
    {
      _Bool tmp_if_expr$6;
      if(d->current_profile == 0x1b)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        ret=burn_disc_close_track_dvd_plus_r(o, tnum, is_last_track);
        if(!(ret >= 1))
          goto ex;

      }

      else
        if(d->current_profile == 0x41)
        {
          ret=burn_disc_close_track_dvd_plus_r(o, tnum, is_last_track);
          if(!(ret >= 1))
            goto ex;

        }

    }
    ret = 1;
  }


ex:
  ;
  if(!(d->cancel == 0))
    burn_source_cancel(t->source);

  if(is_flushed == 0 && !(track_open == 0))
    d->sync_cache(d);

  return ret;
}

// burn_ecma130_scramble
// file libburn/ecma130ab.c line 693
void burn_ecma130_scramble(unsigned char *sector)
{
  signed int i;
  unsigned char *s = sector + (signed long int)12;
  i = 0;
  for( ; !(i >= 2340); i = i + 1)
    s[(signed long int)i] = s[(signed long int)i] ^ ecma_130_annex_b[(signed long int)i];
}

// burn_fd_source_new
// file libburn/file.c line 178
struct burn_source * burn_fd_source_new(signed int datafd, signed int subfd, signed long int size)
{
  struct burn_source_file *fs;
  struct burn_source *src;
  if(datafd == -1)
    return (struct burn_source *)(void *)0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct burn_source_file) /*24ul*/ , (unsigned long int)1, 0);
    fs = (struct burn_source_file *)return_value_burn_alloc_mem$1;
    if(fs == ((struct burn_source_file *)NULL))
      return (struct burn_source *)(void *)0;

    else
    {
      fs->datafd = datafd;
      fs->subfd = subfd;
      fs->fixed_size = size;
      src=burn_source_new();
      if(src == ((struct burn_source *)NULL))
      {
        free((void *)(char *)fs);
        return (struct burn_source *)(void *)0;
      }

      else
      {
        src->read = file_read;
        if(!(subfd == -1))
          src->read_sub = file_read_sub;

        src->get_size = file_size;
        src->set_size = file_set_size;
        src->free_data = file_free;
        src->data = (void *)fs;
        return src;
      }
    }
  }
}

// burn_feature_descr_free
// file libburn/drive.c line 3476
signed int burn_feature_descr_free(struct burn_feature_descr **descr, signed int flag)
{
  struct burn_feature_descr *o;
  struct burn_feature_descr *next;
  if(*descr == ((struct burn_feature_descr *)NULL))
    return 0;

  else
  {
    o = *descr;
    for( ; !(o == ((struct burn_feature_descr *)NULL)); o = next)
    {
      next = o->next;
      if(!(o->data == ((unsigned char *)NULL)))
        free((void *)o->data);

      free((void *)(char *)o);
    }
    *descr = (struct burn_feature_descr *)(void *)0;
    return 1;
  }
}

// burn_feature_descr_new
// file libburn/drive.c line 3444
signed int burn_feature_descr_new(struct burn_feature_descr **new, unsigned char *descr, signed int descr_len, signed int flag)
{
  struct burn_feature_descr *o;
  *new = (struct burn_feature_descr *)(void *)0;
  if(!(descr_len >= 4))
    return 0;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_feature_descr) /*24ul*/ );
    o = (struct burn_feature_descr *)return_value_calloc$1;
    *new = o;
    if(o == ((struct burn_feature_descr *)NULL))
      return -1;

    else
    {
      o->feature_code = (unsigned short int)((signed int)descr[(signed long int)0] << 8 | (signed int)descr[(signed long int)1]);
      o->flags = descr[(signed long int)2];
      if(!(descr_len + -4 >= (signed int)descr[3l]))
        o->data_lenght = (unsigned char)0;

      else
        o->data_lenght = descr[(signed long int)3];
      o->data = (unsigned char *)(void *)0;
      o->next = (struct burn_feature_descr *)(void *)0;
      if((signed int)o->data_lenght >= 1)
      {
        void *return_value_calloc$2;
        return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)o->data_lenght);
        o->data = (unsigned char *)return_value_calloc$2;
        if(o->data == ((unsigned char *)NULL))
        {
          burn_feature_descr_free(new, 0);
          return -1;
        }

        memcpy((void *)o->data, (const void *)(descr + (signed long int)4), (unsigned long int)o->data_lenght);
      }

      return 1;
    }
  }
}

// burn_fifo_abort
// file libburn/async.c line 762
signed int burn_fifo_abort(struct burn_source_fifo *fs, signed int flag)
{
  signed int ret;
  unsigned long int pt;
  _Bool tmp_if_expr$1;
  if(!(fs->thread_is_valid >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = fs->thread_handle == (void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 2;

  else
  {
    pt = *((unsigned long int *)fs->thread_handle);
    remove_worker(pt);
    ret=pthread_cancel(pt);
    return (signed int)(ret == 0);
  }
}

// burn_fifo_cancel
// file libburn/file.c line 490
signed int burn_fifo_cancel(struct burn_source *source)
{
  signed int ret;
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  ret=burn_source_cancel(fs->inp);
  return ret;
}

// burn_fifo_fill
// file libburn/file.c line 755
signed int burn_fifo_fill(struct burn_source *source, signed int bufsize, signed int flag)
{
  signed int return_value_burn_fifo_fill_data$1;
  return_value_burn_fifo_fill_data$1=burn_fifo_fill_data(source, (char *)(void *)0, bufsize, 1 | (flag & 1) << 1);
  return return_value_burn_fifo_fill_data$1;
}

// burn_fifo_fill_data
// file libburn/file.c line 647
signed int burn_fifo_fill_data(struct burn_source *source, char *buf, signed int bufsize, signed int flag)
{
  signed int size;
  signed int free_bytes;
  signed int ret;
  signed int wait_count = 0;
  char *status_text;
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  if(buf == ((char *)NULL))
    flag = flag | 1;

  ret=fifo_read(source, (unsigned char *)(void *)0, 0);
  if(!(ret >= 0))
    ret = 0;

  else
  {
    for( ; (_Bool)1; wait_count = wait_count + 1)
    {
      ret=burn_fifo_inquire_status(source, &size, &free_bytes, &status_text);
      if(!((2 & flag) == 0))
      {
        bufsize = (size - size % fs->inp_read_size) - fs->inp_read_size;
        if(!(bufsize >= 1))
        {
          ret = 0;
          goto ex;
        }

      }

      if(!(size + -fs->inp_read_size >= bufsize))
      {
        if(!((1 & flag) == 0))
        {
          bufsize = (size - size % fs->inp_read_size) - fs->inp_read_size;
          if(!(bufsize >= 1))
          {
            ret = 0;
            goto ex;
          }

        }

        else
        {
          libdax_msgs_submit(libdax_messenger, -1, 0x0002015c, 0x68000000, 0x30000000, "Fifo size too small for desired peek buffer", 0, 0);
          ret = -1;
          goto ex;
        }
      }

      _Bool tmp_if_expr$1;
      if(fs->out_counter >= 1l || !((4 & ret) == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = fs->buf == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x0002015e, 0x70000000, 0x30000000, "Fifo is already under consumption when peeking is desired", 0, 0);
        ret = -1;
        goto ex;
      }

      if(size + -free_bytes >= bufsize)
      {
        if((1 & flag) == 0)
          memcpy((void *)buf, (const void *)fs->buf, (unsigned long int)bufsize);

        ret = 1;
        goto ex;
      }

      if(!((2 & ret) == 0))
      {
        if(!((1 & flag) == 0))
        {
          ret = 0;
          goto ex;
        }

        libdax_msgs_submit(libdax_messenger, -1, 0x0002015d, 0x60000000, 0x30000000, "Fifo input ended short of desired peek buffer size", 0, 0);
        ret = 0;
        goto ex;
      }

      if(!(free_bytes >= fs->inp_read_size))
      {
        if(!((1 & flag) == 0))
        {
          ret = 0;
          goto ex;
        }

        libdax_msgs_submit(libdax_messenger, -1, 0x00020174, 0x60000000, 0x30000000, "Fifo alignment does not allow desired read size", 0, 0);
        ret = 0;
        goto ex;
      }

      usleep((unsigned int)100000);
    }
    ret = 0;
  }

ex:
  ;
  fs->interval_min_fill = fs->buf_writepos;
  fs->total_min_fill = fs->interval_min_fill;
  return ret;
}

// burn_fifo_get_statistics
// file libburn/file.c line 609
void burn_fifo_get_statistics(struct burn_source *source, signed int *total_min_fill, signed int *interval_min_fill, signed int *put_counter, signed int *get_counter, signed int *empty_counter, signed int *full_counter)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  *total_min_fill = fs->total_min_fill;
  *interval_min_fill = fs->interval_min_fill;
  *put_counter = fs->put_counter;
  *get_counter = fs->get_counter;
  *empty_counter = fs->empty_counter;
  *full_counter = fs->full_counter;
}

// burn_fifo_inquire_status
// file libburn/file.c line 566
signed int burn_fifo_inquire_status(struct burn_source *source, signed int *size, signed int *free_bytes, char **status_text)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  signed int ret = 0;
  signed int diff;
  signed int wpos;
  signed int rpos;
  *status_text = (char *)(void *)0;
  *size = 0;
  if(!(source->free_data == fifo_free))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020157, 0x70000000, 0x30000000, "burn_source is not a fifo object", 0, 0);
    return -1;
  }

  else
  {
    *size = fs->chunksize * fs->chunks;
    rpos = fs->buf_readpos;
    wpos = fs->buf_writepos;
    diff = rpos - wpos;
    if(diff == 0)
      *free_bytes = *size - 1;

    else
      if(diff >= 1)
        *free_bytes = diff - 1;

      else
        *free_bytes = ((*size - wpos) + rpos) - 1;
    ret = 0;
    if(fs->end_of_consumption >= 1)
      ret = ret | 4;

    if(!(fs->input_error == 0))
      ret = ret | 3;

    else
      if(!(fs->end_of_input == 0))
        ret = ret | 2;

      else
        if(!(fs->buf == ((char *)NULL)))
          ret = ret | 1;

    static char *states[8l] = { "standby", "active", "ending", "failing", "unused", "abandoned", "ended", "aborted" };
    *status_text = states[(signed long int)ret];
    return ret;
  }
}

// burn_fifo_next_interval
// file libburn/file.c line 626
void burn_fifo_next_interval(struct burn_source *source, signed int *interval_min_fill)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  signed int size;
  signed int free_bytes;
  signed int ret;
  char *status_text;
  *interval_min_fill = fs->interval_min_fill;
  ret=burn_fifo_inquire_status(source, &size, &free_bytes, &status_text);
  if(ret >= 0)
    fs->interval_min_fill = (size - free_bytes) - 1;

}

// burn_fifo_peek_data
// file libburn/file.c line 747
signed int burn_fifo_peek_data(struct burn_source *source, char *buf, signed int bufsize, signed int flag)
{
  signed int return_value_burn_fifo_fill_data$1;
  return_value_burn_fifo_fill_data$1=burn_fifo_fill_data(source, buf, bufsize, 0);
  return return_value_burn_fifo_fill_data$1;
}

// burn_fifo_source_new
// file libburn/file.c line 502
struct burn_source * burn_fifo_source_new(struct burn_source *inp, signed int chunksize, signed int chunks, signed int flag)
{
  struct burn_source_fifo *fs;
  struct burn_source *src;
  if((double)chunksize * (double)chunks > 1.073742e+9)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020155, 0x60000000, 0x30000000, "Desired fifo buffer too large (> 1GB)", 0, 0);
    return (struct burn_source *)(void *)0;
  }

  else
    if(!(chunks >= 2) || !(chunksize >= 1))
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00020156, 0x60000000, 0x30000000, "Desired fifo buffer too small", 0, 0);
      return (struct burn_source *)(void *)0;
    }

    else
    {
      void *return_value_burn_alloc_mem$1;
      return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct burn_source_fifo) /*128ul*/ , (unsigned long int)1, 0);
      fs = (struct burn_source_fifo *)return_value_burn_alloc_mem$1;
      if(fs == ((struct burn_source_fifo *)NULL))
        return (struct burn_source *)(void *)0;

      else
      {
        fs->is_started = 0;
        fs->thread_handle = (void *)0;
        fs->thread_pid = 0;
        fs->thread_is_valid = 0;
        fs->inp = (struct burn_source *)(void *)0;
        if(!((1 & flag) == 0))
          fs->inp_read_size = 32 * 1024;

        else
          fs->inp_read_size = chunksize;
        fs->chunksize = chunksize;
        fs->chunks = chunks;
        fs->buf = (char *)(void *)0;
        fs->buf_readpos = 0;
        fs->buf_writepos = fs->buf_readpos;
        fs->end_of_input = 0;
        fs->input_error = 0;
        fs->end_of_consumption = 0;
        fs->out_counter = (signed long int)0;
        fs->in_counter = fs->out_counter;
        fs->interval_min_fill = 0;
        fs->total_min_fill = fs->interval_min_fill;
        fs->get_counter = 0;
        fs->put_counter = fs->get_counter;
        fs->full_counter = 0;
        fs->empty_counter = fs->full_counter;
        src=burn_source_new();
        if(src == ((struct burn_source *)NULL))
        {
          free((void *)(char *)fs);
          return (struct burn_source *)(void *)0;
        }

        else
        {
          src->read = (signed int (*)(struct burn_source *, unsigned char *, signed int))(void *)0;
          src->read_sub = (signed int (*)(struct burn_source *, unsigned char *, signed int))(void *)0;
          src->get_size = fifo_get_size;
          src->set_size = fifo_set_size;
          src->free_data = fifo_free;
          src->data = (void *)fs;
          src->version = 1;
          src->read_xt = fifo_read;
          src->cancel = burn_fifo_cancel;
          fs->inp = inp;
          inp->refcount = inp->refcount + 1;
          return src;
        }
      }
    }
}

// burn_fifo_source_shoveller
// file libburn/file.h line 74
signed int burn_fifo_source_shoveller(struct burn_source *source, signed int flag)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  signed int ret;
  signed int bufsize;
  signed int diff;
  signed int wpos;
  signed int rpos;
  signed int trans_end;
  signed int free_bytes;
  signed int fill;
  signed int counted;
  char *bufpt;
  unsigned long int thread_handle_storage;
  fs->thread_handle = (void *)&thread_handle_storage;
  *((unsigned long int *)fs->thread_handle)=pthread_self();
  fs->thread_pid=getpid();
  fs->thread_is_valid = 1;
  bufsize = fs->chunksize * fs->chunks;
  if(fs->end_of_consumption == 0)
  {
    wpos = fs->buf_writepos;
    counted = 0;
    while((_Bool)1)
    {
      rpos = fs->buf_readpos;
      diff = rpos - wpos;
      trans_end = 0;
      if(diff == 0)
        free_bytes = bufsize - 1;

      else
        if(diff >= 1)
          free_bytes = diff - 1;

        else
        {
          free_bytes = ((bufsize - wpos) + rpos) - 1;
          if(!(bufsize + -wpos >= fs->inp_read_size))
            trans_end = 1;

        }
      if(free_bytes >= fs->inp_read_size)
        break;

      if(counted == 0)
        fs->full_counter = fs->full_counter + 1;

      counted = 1;
      fifo_sleep(0);
    }
    fill = (bufsize - free_bytes) - 1;
    if(!(fill >= fs->total_min_fill))
      fs->total_min_fill = fill;

    if(!(fill >= fs->interval_min_fill))
      fs->interval_min_fill = fill;

    bufpt = fs->buf + (signed long int)wpos;
    if(!(trans_end == 0))
    {
      void *return_value_burn_os_alloc_buffer$1;
      return_value_burn_os_alloc_buffer$1=burn_os_alloc_buffer((unsigned long int)fs->inp_read_size, 0);
      bufpt = (char *)return_value_burn_os_alloc_buffer$1;
      if(bufpt == ((char *)NULL))
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x00000003, 0x70000000, 0x30000000, "Out of virtual memory", 0, 0);
        fs->input_error = 12;
        goto __CPROVER_DUMP_L23;
      }

    }

    if(!(fs->inp->read == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL)))
      ret=fs->inp->read(fs->inp, (unsigned char *)bufpt, fs->inp_read_size);

    else
      ret=fs->inp->read_xt(fs->inp, (unsigned char *)bufpt, fs->inp_read_size);
    if(!(ret == 0))
    {
      if(!(ret >= 0))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        libdax_msgs_submit(libdax_messenger, -1, 0x00020153, 0x60000000, 0x30000000, "Read error on fifo input", *return_value___errno_location$2, 0);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        fs->input_error = *return_value___errno_location$3;
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        if(*return_value___errno_location$4 == 0)
          fs->input_error = 5;

      }

    }

    fs->in_counter = fs->in_counter + (signed long int)ret;
    fs->put_counter = fs->put_counter + 1;
    if(!(fs->inp_read_size >= ret))
      ret = fs->inp_read_size;

    if(!(trans_end == 0))
    {
      memcpy((void *)(fs->buf + (signed long int)wpos), (const void *)bufpt, (unsigned long int)(bufsize - wpos));
      memcpy((void *)fs->buf, (const void *)(bufpt + (signed long int)(bufsize - wpos)), (unsigned long int)(fs->inp_read_size - (bufsize - wpos)));
      burn_os_free_buffer((void *)bufpt, (unsigned long int)fs->inp_read_size, 0);
      if(ret >= bufsize + -wpos)
        fs->buf_writepos = ret - (bufsize - wpos);

      else
        fs->buf_writepos = fs->buf_writepos + ret;
    }

    else
      if(fs->buf_writepos + ret == bufsize)
        fs->buf_writepos = 0;

      else
        fs->buf_writepos = fs->buf_writepos + ret;
  }


__CPROVER_DUMP_L23:
  ;
  if(fs->end_of_consumption == 0)
    fs->end_of_input = 1;

  while(!(fs->buf_readpos == fs->buf_writepos))
  {
    if(!(fs->end_of_consumption == 0))
      break;

    fifo_sleep(0);
  }
  if(fs->end_of_consumption == 0)
    fs->end_of_consumption = 2;

  if(!(fs->buf == ((char *)NULL)))
    burn_os_free_buffer((void *)fs->buf, (unsigned long int)fs->chunksize * (unsigned long int)fs->chunks, 0);

  fs->buf = (char *)(void *)0;
  fs->thread_handle = (void *)0;
  fs->thread_is_valid = 0;
  return (signed int)(fs->input_error == 0);
}

// burn_fifo_start
// file libburn/async.c line 737
signed int burn_fifo_start(struct burn_source *source, signed int flag)
{
  union w_list_data o;
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  fs->is_started = -1;
  void *return_value_burn_os_alloc_buffer$1;
  return_value_burn_os_alloc_buffer$1=burn_os_alloc_buffer((unsigned long int)fs->chunksize * (unsigned long int)fs->chunks, 0);
  fs->buf = (char *)return_value_burn_os_alloc_buffer$1;
  if(fs->buf == ((char *)NULL))
    return -1;

  else
  {
    o.fifo.source = source;
    o.fifo.flag = flag;
    add_worker(4, (struct burn_drive *)(void *)0, (void * (*)(void *))fifo_worker_func, &o);
    fs->is_started = 1;
    return 1;
  }
}

// burn_file_source_new
// file libburn/file.c line 121
struct burn_source * burn_file_source_new(const char *path, const char *subpath)
{
  struct burn_source_file *fs;
  struct burn_source *src;
  signed int fd1 = -1;
  signed int fd2 = -1;
  if(path == ((const char *)NULL))
    return (struct burn_source *)(void *)0;

  else
  {
    fd1=open(path, 00 | 0);
    if(fd1 == -1)
      return (struct burn_source *)(void *)0;

    else
      if(!(subpath == ((const char *)NULL)))
      {
        fd2=open(subpath, 00 | 0);
        if(!(fd2 == -1))
          goto __CPROVER_DUMP_L3;

        close(fd1);
        return (struct burn_source *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        void *return_value_calloc$1;
        return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_source_file) /*24ul*/ );
        fs = (struct burn_source_file *)return_value_calloc$1;
        if(fs == ((struct burn_source_file *)NULL))
        {

        failure:
          ;
          close(fd1);
          if(fd2 >= 0)
            close(fd2);

          return (struct burn_source *)(void *)0;
        }

        else
        {
          fs->datafd = fd1;
          fs->subfd = fd2;
          fs->fixed_size = (signed long int)0;
          src=burn_source_new();
          if(src == ((struct burn_source *)NULL))
          {
            free((void *)(char *)fs);
            goto failure;
          }

          src->read = file_read;
          if(!(subpath == ((const char *)NULL)))
            src->read_sub = file_read_sub;

          src->get_size = file_size;
          src->set_size = file_set_size;
          src->free_data = file_free;
          src->data = (void *)fs;
          return src;
        }
      }
  }
}

// burn_finalize_text_pack
// file libburn/cdtext.c line 135
static signed int burn_finalize_text_pack(struct burn_pack_cursor *crs, signed int flag)
{
  signed int residue = 0;
  signed int i;
  signed int idx = 18 * crs->num_packs;
  i = 4 + crs->td_used;
  for( ; !(i >= 16); i = i + 1)
    crs->packs[(signed long int)(idx + i)] = (unsigned char)0;
  crs->td_used = 12;
  signed int return_value_crc_11021$1;
  return_value_crc_11021$1=crc_11021(crs->packs + (signed long int)idx, 16, 0);
  residue = return_value_crc_11021$1 ^ 0xffff;
  crs->packs[(signed long int)(idx + 16)] = (unsigned char)(residue >> 8 & 0xff);
  crs->packs[(signed long int)(idx + 17)] = (unsigned char)(residue & 0xff);
  crs->num_packs = crs->num_packs + 1;
  crs->td_used = 0;
  return 1;
}

// burn_finish
// file test/../libburn/libburn.h line 778
void burn_finish(void)
{
  if(!(burn_running == 0))
  {
    signed int return_value_burn_drives_are_clear$1;
    return_value_burn_drives_are_clear$1=burn_drives_are_clear(0);
    if(return_value_burn_drives_are_clear$1 == 0)
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00020107, 0x50000000, 0x30000000, "A drive is still busy on shutdown of library", 0, 0);
      usleep((unsigned int)1000001);
      burn_abort(4440, burn_abort_pacifier, (void *)abort_message_prefix);
    }

    burn_drive_free_all();
    libdax_msgs_destroy(&libdax_messenger, 0);
    sg_shutdown(0);
    burn_drive_clear_whitelist();
    burn_running = 0;
  }

}

// burn_get_read_capacity
// file libburn/drive.c line 3323
signed int burn_get_read_capacity(struct burn_drive *d, signed int *capacity, signed int flag)
{
  *capacity = d->media_read_capacity + 1;
  return (signed int)(d->media_read_capacity != 0x7fffffff);
}

// burn_get_time
// file libburn/util.h line 20
double burn_get_time(signed int flag)
{
  signed int ret;
  struct timeval tv;
  ret=gettimeofday(&tv, (struct timezone *)(void *)0);
  if(ret == 0)
    return (double)tv.tv_sec + (double)tv.tv_usec * 1.0e-6;

  else
  {
    signed long int return_value_time$1;
    return_value_time$1=time((signed long int *)(void *)0);
    return (double)return_value_time$1;
  }
}

// burn_grab_prepare_sig_action
// file libburn/init.h line 59
signed int burn_grab_prepare_sig_action(signed int *signal_action_mem, signed int flag)
{
  *signal_action_mem = -1;
  if(burn_global_signal_handler == burn_builtin_abort_handler && burn_builtin_signal_action >= 0 && !(burn_builtin_signal_action >= 3))
  {
    *signal_action_mem = burn_builtin_signal_action;
    burn_builtin_signal_action = 3;
  }

  return 1;
}

// burn_grab_restore_sig_action
// file libburn/init.h line 60
signed int burn_grab_restore_sig_action(signed int signal_action_mem, signed int flag)
{
  if(signal_action_mem >= 0)
    burn_builtin_signal_action = signal_action_mem;

  signed int return_value_burn_is_aborting$1;
  return_value_burn_is_aborting$1=burn_is_aborting(0);
  if(!(return_value_burn_is_aborting$1 == 0))
  {
    if(signal_action_mem >= 0)
    {
      if(signal_action_mem == 0 || signal_action_mem == 1)
        burn_abort_exit(1);

      else
        if(signal_action_mem == 2)
          burn_builtin_triggered_action = signal_action_mem;

    }

  }

  return 1;
}

// burn_guess_cd_manufacturer
// file libburn/util.c line 57
char * burn_guess_cd_manufacturer(signed int m_li, signed int s_li, signed int f_li, signed int m_lo, signed int s_lo, signed int f_lo, signed int flag)
{
  signed int i;
  signed int f_li_0;
  char buf[1024l];
  char *result = (char *)(void *)0;
  if(f_li == 0 && m_li == 0 && s_li == 2)
  {
    result=strdup("(no manufacturer code)");
    return result;
  }

  else
  {
    f_li_0 = f_li - f_li % 10;
    i = 0;
    static struct cd_mid_record mid_list[45l] = { { .manufacturer="SKC", .m_li=96, .s_li=40, .f_li=0,
    .other_brands="" },
    { .manufacturer="Ritek Corp", .m_li=96, .s_li=43, .f_li=30,
    .other_brands="" },
    { .manufacturer="TDK / Ritek", .m_li=97, .s_li=10,
    .f_li=0, .other_brands="TRAXDATA" },
    { .manufacturer="TDK Corporation", .m_li=97, .s_li=15,
    .f_li=0, .other_brands="" },
    { .manufacturer="Ritek Corp", .m_li=97, .s_li=15, .f_li=10,
    .other_brands="7-plus, Aopen, PONY, Power Source, TDK, TRAXDATA, HiCO, PHILIPS, Primdisc, Victor.JVC, OPTI STORAGE, Samsung" },
    { .manufacturer="Mitsubishi Chemical Corporation", .m_li=97,
    .s_li=15, .f_li=20, .other_brands="" },
    { .manufacturer="Nan-Ya Plastics Corporation", .m_li=97,
    .s_li=15, .f_li=30, .other_brands="Hatron, MMore, Acer, LITEON" },
    { .manufacturer="Delphi", .m_li=97, .s_li=15, .f_li=50,
    .other_brands="" },
    { .manufacturer="Shenzhen SG&SAST", .m_li=97, .s_li=16,
    .f_li=20, .other_brands="" },
    { .manufacturer="Moser Baer India Limited", .m_li=97,
    .s_li=17, .f_li=0, .other_brands="EMTEC, Intenso, YAKUMO, PLATINUM, Silver Circle" },
    { .manufacturer="SKY media Manufacturing SA", .m_li=97,
    .s_li=17, .f_li=10, .other_brands="" },
    { .manufacturer="Wing", .m_li=97, .s_li=18, .f_li=10,
    .other_brands="" },
    { .manufacturer="DDT", .m_li=97, .s_li=18, .f_li=20,
    .other_brands="" },
    { .manufacturer="Daxon Technology Inc. / Acer", .m_li=97,
    .s_li=22, .f_li=60, .other_brands="Maxmax, Diamond Data, BenQ, gold, SONY" },
    { .manufacturer="Taiyo Yuden Company Limited", .m_li=97,
    .s_li=24, .f_li=0, .other_brands="Maxell, FUJIFILM, SONY" },
    { .manufacturer="Sony Corporation", .m_li=97, .s_li=24,
    .f_li=10, .other_brands="LeadData, Imation" },
    { .manufacturer="Computer Support Italcard s.r.l", .m_li=97,
    .s_li=24, .f_li=20, .other_brands="" },
    { .manufacturer="Unitech Japan Inc.", .m_li=97, .s_li=24,
    .f_li=30, .other_brands="" },
    { .manufacturer="MPO, France", .m_li=97, .s_li=25,
    .f_li=0, .other_brands="TDK" },
    { .manufacturer="Hitachi Maxell Ltd.", .m_li=97, .s_li=25,
    .f_li=20, .other_brands="" },
    { .manufacturer="Infodisc Technology Co,Ltd.", .m_li=97,
    .s_li=25, .f_li=30, .other_brands="MEMOREX, SPEEDA, Lead data" },
    { .manufacturer="Xcitec", .m_li=97, .s_li=25, .f_li=60,
    .other_brands="" },
    { .manufacturer="Fornet International Pte Ltd", .m_li=97,
    .s_li=26, .f_li=0, .other_brands="COMPUSA, Cdhouse" },
    { .manufacturer="Postech Corporation", .m_li=97, .s_li=26,
    .f_li=10, .other_brands="Mr.Platinum" },
    { .manufacturer="SKC Co Ltd.", .m_li=97, .s_li=26,
    .f_li=20, .other_brands="Infinite" },
    { .manufacturer="Fuji Photo Film Co,Ltd.", .m_li=97,
    .s_li=26, .f_li=40, .other_brands="" },
    { .manufacturer="Lead Data Inc.", .m_li=97, .s_li=26,
    .f_li=50, .other_brands="SONY, Gigastorage, MIRAGE" },
    { .manufacturer="CMC Magnetics Corporation", .m_li=97,
    .s_li=26, .f_li=60, .other_brands="Daxon, Verbatim, Memorex, Bi-Winner, PLEXTOR, YAMAHA, Melody, Office DEPOT, Philips, eMARK, imation, HyperMedia, Samsung, Shintaro, Techworks" },
    { .manufacturer="Ricoh Company Limited", .m_li=97,
    .s_li=27, .f_li=0, .other_brands="Sony, Digital Storage, Csita" },
    { .manufacturer="Plasmon Data Systems Ltd", .m_li=97,
    .s_li=27, .f_li=10, .other_brands="Ritek, TDK, EMTEC, ALPHAPET, MANIA" },
    { .manufacturer="Princo Corporation", .m_li=97, .s_li=27,
    .f_li=20, .other_brands="" },
    { .manufacturer="Pioneer", .m_li=97, .s_li=27, .f_li=30,
    .other_brands="" },
    { .manufacturer="Eastman Kodak Company", .m_li=97,
    .s_li=27, .f_li=40, .other_brands="" },
    { .manufacturer="Mitsui Chemicals Inc.", .m_li=97,
    .s_li=27, .f_li=50, .other_brands="MAM-A, TDK" },
    { .manufacturer="Ricoh Company Limited", .m_li=97,
    .s_li=27, .f_li=60, .other_brands="Ritek" },
    { .manufacturer="Gigastorage Corporation", .m_li=97,
    .s_li=28, .f_li=10, .other_brands="MaxMax, Nan-Ya" },
    { .manufacturer="Multi Media Masters&Machinary SA", .m_li=97,
    .s_li=28, .f_li=20, .other_brands="King, Mmirex" },
    { .manufacturer="Ritek Corp", .m_li=97, .s_li=31, .f_li=0,
    .other_brands="TDK" },
    { .manufacturer="Grand Advance Technology Sdn. Bhd.", .m_li=97,
    .s_li=31, .f_li=30, .other_brands="" },
    { .manufacturer="TDK Corporation", .m_li=97, .s_li=32,
    .f_li=00, .other_brands="" },
    { .manufacturer="Prodisc Technology Inc.", .m_li=97,
    .s_li=32, .f_li=10, .other_brands="Smartbuy, Mitsubishi, Digmaster, LG, Media Market" },
    { .manufacturer="Mitsubishi Chemical Corporation", .m_li=97,
    .s_li=34, .f_li=20, .other_brands="YAMAHA, Verbatim" },
    { .manufacturer="Mitsui Chemicals Inc.", .m_li=97,
    .s_li=48, .f_li=50, .other_brands="" },
    { .manufacturer="TDK Corporation", .m_li=97, .s_li=49,
    .f_li=0, .other_brands="" },
    { .manufacturer="", .m_li=0, .s_li=0, .f_li=0, .other_brands="" } };
    for( ; !(*mid_list[(signed long int)i].manufacturer == 0); i = i + 1)
      if(m_li == mid_list[(signed long int)i].m_li)
      {
        if(s_li == mid_list[(signed long int)i].s_li)
        {
          _Bool tmp_if_expr$1;
          if(f_li_0 == mid_list[(signed long int)i].f_li)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = f_li == mid_list[(signed long int)i].f_li ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            break;

        }

      }

    if((signed int)*mid_list[(signed long int)i].manufacturer == 0)
    {
      sprintf(buf, "Unknown CD manufacturer. Please report code '%2.2dm%2.2ds%2.2df/%2.2dm%2.2ds%2.2df', the human readable brand, size, and speed to scdbackup@gmx.net.", m_li, s_li, f_li, m_lo, s_lo, f_lo);
      result=strdup(buf);
      return result;
    }

    else
    {
      _Bool tmp_if_expr$2;
      if(!((1 & flag) == 0))
        tmp_if_expr$2 = mid_list[(signed long int)i].other_brands[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        sprintf(buf, "%s  (aka %s)", mid_list[(signed long int)i].manufacturer, mid_list[(signed long int)i].other_brands);
        result=strdup(buf);
      }

      else
        result=strdup(mid_list[(signed long int)i].manufacturer);
      return result;
    }
  }
}

// burn_guess_manufacturer
// file libburn/util.c line 149
char * burn_guess_manufacturer(signed int prf, char *media_code1, char *media_code2, signed int flag)
{
  signed int i;
  signed int l = 0;
  signed int m_li;
  signed int s_li;
  signed int f_li;
  signed int m_lo;
  signed int s_lo;
  signed int f_lo;
  char buf[1024l];
  char *result = (char *)(void *)0;
  char *cpt;
  char *return_value_strchr$1;
  if(!(media_code2 == ((char *)NULL)) && (prf == 0x09 || prf == 0x0A || prf == -1))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(media_code2);
    if(return_value_strlen$2 == 9ul)
    {
      if((signed int)*media_code1 == 57)
      {
        if((signed int)media_code1[2l] == 109)
        {
          if((signed int)media_code1[5l] == 115)
          {
            if((signed int)media_code1[8l] == 102)
            {
              return_value_strchr$1=strchr(media_code1, 37);
              if(return_value_strchr$1 == ((char *)NULL))
              {
                __isoc99_sscanf(media_code1, "%dm%ds%df", &m_li, &s_li, &f_li);
                __isoc99_sscanf(media_code2, "%dm%ds%df", &m_lo, &s_lo, &f_lo);
                if(m_li >= 96 && m_lo >= 1 && !(m_li >= 98))
                {
                  result=burn_guess_cd_manufacturer(m_li, s_li, f_li, m_lo, s_lo, f_lo, 0);
                  return result;
                }

              }

            }

          }

        }

      }

    }

  }

  cpt=strchr(media_code1, 95);
  if(!(cpt == ((char *)NULL)) && (prf == 0x11 || prf == 0x13 || prf == 0x14 || prf == 0x15 || prf == -1))
    l = (signed int)(cpt - media_code1);

  i = 0;
  signed int return_value_strncmp$4;
  static struct dvd_mid_record mid_list[45l] = { { .mc1="AML", .mc1_sig_len=8, .manufacturer="UML" },
    { .mc1="BeAll", .mc1_sig_len=5, .manufacturer="BeAll Developers, Inc." },
    { .mc1="CMC", .mc1_sig_len=3, .manufacturer="CMC Magnetics Corporation" },
    { .mc1="DAXON", .mc1_sig_len=5, .manufacturer="Daxon Technology Inc. / Acer" },
    { .mc1="Daxon", .mc1_sig_len=5, .manufacturer="Daxon Technology Inc. / Acer" },
    { .mc1="FUJI", .mc1_sig_len=4, .manufacturer="Fujifilm Holdings Corporation" },
    { .mc1="INFODISC", .mc1_sig_len=8, .manufacturer="New Star Digital Co., Ltd." },
    { .mc1="INFOME", .mc1_sig_len=6, .manufacturer="InfoMedia Inc." },
    { .mc1="ISMMBD", .mc1_sig_len=6, .manufacturer="Info Source Multi Media Ltd." },
    { .mc1="JVC", .mc1_sig_len=3, .manufacturer="JVC Limited" },
    { .mc1="KIC01RG", .mc1_sig_len=7, .manufacturer="AMC" },
    { .mc1="LD", .mc1_sig_len=8, .manufacturer="Lead Data Inc." },
    { .mc1="LGE", .mc1_sig_len=3, .manufacturer="LG Electronics" },
    { .mc1="MAM", .mc1_sig_len=8, .manufacturer="Mitsui Advanced Media, Inc. Europe" },
    { .mc1="MAXELL", .mc1_sig_len=6, .manufacturer="Hitachi Maxell Ltd." },
    { .mc1="MBI", .mc1_sig_len=3, .manufacturer="Moser Baer India Limited" },
    { .mc1="MCC", .mc1_sig_len=8, .manufacturer="Mitsubishi Chemical Corporation" },
    { .mc1="MCI", .mc1_sig_len=8, .manufacturer="Mitsui Chemicals Inc." },
    { .mc1="MEI", .mc1_sig_len=3, .manufacturer="Panasonic Corporation" },
    { .mc1="MILLEN", .mc1_sig_len=8, .manufacturer="Millenniata Inc." },
    { .mc1="MKM", .mc1_sig_len=3, .manufacturer="Mitsubishi Kagaku Media Co." },
    { .mc1="MMC", .mc1_sig_len=8, .manufacturer="Mitsubishi Kagaku Media Co." },
    { .mc1="MXL", .mc1_sig_len=8, .manufacturer="Hitachi Maxell Ltd." },
    { .mc1="NANYA", .mc1_sig_len=5, .manufacturer="Nan-Ya Plastics Corporation" },
    { .mc1="NSD", .mc1_sig_len=8, .manufacturer="NESA International Inc." },
    { .mc1="OPTODISC", .mc1_sig_len=8, .manufacturer="Optodisc Technology Corporation" },
    { .mc1="OTCBDR", .mc1_sig_len=8, .manufacturer="Optodisc Technology Corporation" },
    { .mc1="PHILIP", .mc1_sig_len=8, .manufacturer="Moser Baer India Limited" },
    { .mc1="PHILIPS", .mc1_sig_len=8, .manufacturer="Philips" },
    { .mc1="PRINCO", .mc1_sig_len=6, .manufacturer="Princo Corporation" },
    { .mc1="PRODISC", .mc1_sig_len=7, .manufacturer="Prodisc Technology Inc." },
    { .mc1="Prodisc", .mc1_sig_len=7, .manufacturer="Prodisc Technology Inc." },
    { .mc1="PVC", .mc1_sig_len=3, .manufacturer="Pioneer" },
    { .mc1="RICOHJPN", .mc1_sig_len=8, .manufacturer="Ricoh Company Limited" },
    { .mc1="RITEK", .mc1_sig_len=5, .manufacturer="Ritek Corp" },
    { .mc1="SONY", .mc1_sig_len=4, .manufacturer="Sony Corporation" },
    { .mc1="TDK", .mc1_sig_len=3, .manufacturer="TDK Corporation" },
    { .mc1="TT", .mc1_sig_len=8, .manufacturer="TDK Corporation" },
    { .mc1="TY", .mc1_sig_len=8, .manufacturer="Taiyo Yuden Company Limited" },
    { .mc1="TYG", .mc1_sig_len=3, .manufacturer="Taiyo Yuden Company Limited" },
    { .mc1="UME", .mc1_sig_len=3, .manufacturer="UmeDisc Limited" },
    { .mc1="UTJR001", .mc1_sig_len=7, .manufacturer="Unifino Inc." },
    { .mc1="VERBAT", .mc1_sig_len=5, .manufacturer="Mitsubishi Kagaku Media Co." },
    { .mc1="YUDEN", .mc1_sig_len=5, .manufacturer="Taiyo Yuden Company Limited" },
    { .mc1="", .mc1_sig_len=0, .manufacturer="" } };
  for( ; !(*mid_list[(signed long int)i].mc1 == 0); i = i + 1)
  {
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(mid_list[(signed long int)i].mc1, media_code1, (unsigned long int)mid_list[(signed long int)i].mc1_sig_len);
    if(return_value_strncmp$3 == 0)
      break;

    if(l >= 1)
    {
      return_value_strncmp$4=strncmp(mid_list[(signed long int)i].mc1, media_code1, (unsigned long int)l);
      if(return_value_strncmp$4 == 0)
        break;

    }

  }
  if((signed int)*mid_list[(signed long int)i].mc1 == 0)
  {
    sprintf(buf, "Unknown DVD/BD manufacturer. Please report code '%s/%s', the human readable brand, size, and speed to scdbackup@gmx.net.", media_code1, media_code2);
    result=strdup(buf);
    return result;
  }

  else
  {
    result=strdup(mid_list[(signed long int)i].manufacturer);
    return result;
  }
}

// burn_init_catch_on_abort
// file libburn/init.h line 35
signed int burn_init_catch_on_abort(signed int flag)
{
  unsigned long int return_value_pthread_self$2;
  if(!(burn_builtin_triggered_action == 2))
    return 0;

  else
  {
    signed int return_value_getpid$1;
    return_value_getpid$1=getpid();
    _Bool tmp_if_expr$3;
    if(!(abort_control_pid == return_value_getpid$1))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_pthread_self$2=pthread_self();
      tmp_if_expr$3 = abort_control_thread != return_value_pthread_self$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      return 1;

    else
    {
      burn_abort(4440, burn_abort_pacifier, (void *)abort_message_prefix);
      fprintf(stderr, "\n%sABORT : Program done. Even if you do not see a shell prompt.\n\n", (const void *)abort_message_prefix);
      exit(1);
    }
  }
}

// burn_initialize
// file test/../libburn/libburn.h line 772
signed int burn_initialize(void)
{
  signed int ret;
  if(!(burn_running == 0))
    return 1;

  else
  {
    lib_start_time=burn_get_time(0);
    burn_support_untested_profiles = 0;
    ret=burn_msgs_initialize();
    if(!(ret >= 1))
      return 0;

    else
    {
      ret=sg_initialize(sg_initialize_msg, 0);
      if(!(ret >= 1))
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x00020175, 0x70000000, 0x30000000, sg_initialize_msg, 0, 0);
        return 0;
      }

      else
      {
        burn_running = 1;
        return 1;
      }
    }
  }
}

// burn_int_to_lsb
// file libburn/util.h line 17
void burn_int_to_lsb(signed int val, char *target)
{
  unsigned char *buf = (unsigned char *)target;
  buf[(signed long int)0] = (unsigned char)(val & 0xff);
  buf[(signed long int)1] = (unsigned char)(val >> 8 & 0xff);
  buf[(signed long int)2] = (unsigned char)(val >> 16 & 0xff);
  buf[(signed long int)3] = (unsigned char)(val >> 24 & 0xff);
}

// burn_is_aborting
// file libburn/libburn.h line 3900
signed int burn_is_aborting(signed int flag)
{
  return burn_builtin_triggered_action;
}

// burn_lba_to_msf
// file test/../libburn/libburn.h line 1924
void burn_lba_to_msf(signed int lba, signed int *m, signed int *s, signed int *f)
{
  if(lba >= -150)
  {
    *m = (lba + 150) / (60 * 75);
    *s = ((lba + 150) - *m * 60 * 75) / 75;
    *f = ((lba + 150) - *m * 60 * 75) - *s * 75;
  }

  else
  {
    *m = (lba + 450150) / (60 * 75);
    *s = ((lba + 450150) - *m * 60 * 75) / 75;
    *f = ((lba + 450150) - *m * 60 * 75) - *s * 75;
  }
}

// burn_list_sev_texts
// file libburn/init.c line 358
char * burn_list_sev_texts(signed int flag)
{
  char *sev_list;
  libdax_msgs__sev_to_text(0, &sev_list, 1);
  return sev_list;
}

// burn_lookup_device_link
// file libburn/drive.c line 2250
signed int burn_lookup_device_link(char *dev_adr, char *link_adr, char *dir_adr, char **ranks, signed int rank_count, signed int flag)
{
  struct __dirstream *dirpt = (struct __dirstream *)(void *)0;
  struct dirent *entry;
  struct stat link_stbuf;
  char *adr = (char *)(void *)0;
  char *namept;
  char *sys_adr = (char *)(void *)0;
  signed int ret;
  signed int name_rank;
  signed int found_rank = 0x7fffffff;
  signed int dirlen;
  signed int i;
  signed int rec_count = 0;
  char *default_ranks[5l];
  link_adr[(signed long int)0] = (char)0;
  if(ranks == ((char **)NULL))
  {
    i = 0;
    static char default_ranks_data[5l][8l] = { { 'd', 'v', 'd', 'r', 'w', 0, 0, 0 }, { 'c', 'd', 'r', 'w', 0, 0, 0, 0 }, { 'd', 'v', 'd', 0, 0, 0, 0, 0 }, { 'c', 'd', 'r', 'o', 'm', 0, 0, 0 }, { 'c', 'd', 0, 0, 0, 0, 0, 0 } };
    for( ; !(i >= 5); i = i + 1)
      default_ranks[(signed long int)i] = default_ranks_data[(signed long int)i];
    ranks = default_ranks;
    rank_count = 5;
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(dir_adr);
  dirlen = (signed int)(return_value_strlen$1 + (unsigned long int)1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(dir_adr);
  unsigned long int return_value_strlen$5;
  unsigned long int return_value_strlen$8;
  signed int return_value_strncmp$9;
  _Bool tmp_if_expr$11;
  signed int return_value_strcmp$10;
  if(1ul + return_value_strlen$2 >= 1024ul)
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$3;
    return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
    adr = (char *)return_value_burn_alloc_mem$3;
    if(adr == ((char *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$4;
      return_value_burn_alloc_mem$4=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)1024, 0);
      sys_adr = (char *)return_value_burn_alloc_mem$4;
      if(sys_adr == ((char *)NULL))
        ret = -1;

      else
      {
        dirpt=opendir(dir_adr);
        if(dirpt == ((struct __dirstream *)NULL))
          ret = 0;

        else
        {
          strcpy(adr, dir_adr);
          strcat(adr, "/");
          return_value_strlen$5=strlen(dir_adr);
          namept = adr + (signed long int)return_value_strlen$5 + (signed long int)1;
          while((_Bool)1)
          {
            entry=readdir(dirpt);
            if(entry == ((struct dirent *)NULL))
              break;

            unsigned long int return_value_strlen$6;
            return_value_strlen$6=strlen(entry->d_name);
            if(!(return_value_strlen$6 + (unsigned long int)dirlen >= 1024ul))
            {
              strcpy(namept, entry->d_name);
              signed int return_value_lstat$7;
              return_value_lstat$7=lstat(adr, &link_stbuf);
              if(!(return_value_lstat$7 == -1))
              {
                if((61440u & link_stbuf.st_mode) == 40960u)
                {
                  name_rank = 0;
                  for( ; !(name_rank >= rank_count); name_rank = name_rank + 1)
                  {
                    return_value_strlen$8=strlen(ranks[(signed long int)name_rank]);
                    return_value_strncmp$9=strncmp(namept, ranks[(signed long int)name_rank], return_value_strlen$8);
                    if(return_value_strncmp$9 == 0)
                      break;

                  }
                  _Bool tmp_if_expr$12;
                  if(name_rank >= rank_count || !(found_rank >= name_rank))
                    tmp_if_expr$12 = (_Bool)1;

                  else
                  {
                    if(name_rank == found_rank)
                    {
                      return_value_strcmp$10=strcmp(namept, link_adr + (signed long int)dirlen);
                      tmp_if_expr$11 = return_value_strcmp$10 >= 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$11 = (_Bool)0;
                    tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
                  }
                  if(!tmp_if_expr$12)
                  {
                    ret=burn_drive_resolve_link(adr, sys_adr, &rec_count, 2);
                    if(!(ret >= 0))
                      goto ex;

                    if(!(ret == 0))
                    {
                      signed int return_value_strcmp$13;
                      return_value_strcmp$13=strcmp(dev_adr, sys_adr);
                      if(return_value_strcmp$13 == 0)
                      {
                        strcpy(link_adr, adr);
                        found_rank = name_rank;
                      }

                    }

                  }

                }

              }

            }

          }
          ret = 2;
          if(!(found_rank >= 0x7fffffff))
            ret = 1;

        }
      }
    }
  }

ex:
  ;
  if(!(dirpt == ((struct __dirstream *)NULL)))
    closedir(dirpt);

  if(!(adr == ((char *)NULL)))
    free((void *)(char *)adr);

  if(!(sys_adr == ((char *)NULL)))
    free((void *)(char *)sys_adr);

  return ret;
}

// burn_make_input_sheet_v07t
// file libburn/cdtext.c line 1708
signed int burn_make_input_sheet_v07t(unsigned char *text_packs, signed int num_packs, signed int start_tno, signed int track_count, char **result, signed int *char_code, signed int flag)
{
  signed int ret;
  signed int result_size = 0;
  ret=burn_make_v07t(text_packs, num_packs, start_tno, track_count, (char *)(void *)0, 0, char_code, 1);
  if(!(ret >= 1))
    return ret;

  else
  {
    result_size = ret + 1;
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem((unsigned long int)result_size, (unsigned long int)1, 0);
    *result = (char *)return_value_burn_alloc_mem$1;
    if(*result == ((char *)NULL))
      return -1;

    else
    {
      ret=burn_make_v07t(text_packs, num_packs, start_tno, track_count, *result, result_size, char_code, 0);
      if(!(ret >= 1))
      {
        free((void *)*result);
        return ret;
      }

      else
        return result_size - 1;
    }
  }
}

// burn_make_v07t
// file libburn/cdtext.c line 1592
static signed int burn_make_v07t(unsigned char *text_packs, signed int num_packs, signed int first_tno, signed int track_count, char *result, signed int result_size, signed int *char_code, signed int flag)
{
  signed int pack_no = 0;
  signed int ret;
  signed int block;
  signed int last_tno = 0;
  unsigned char *pack;
  char msg[80l];
  ret=search_pack(text_packs, num_packs, 0, 0x8f, -1, &pack, &pack_no, 0);
  if(!(ret >= 1))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002019f, 0x68000000, 0x30000000, "No CD-TEXT pack 0x8f found. No character code defined", 0, 0);
    return 0;
  }

  else
  {
    *char_code = (signed int)pack[(signed long int)4];
    if(!(*char_code == 0x00))
    {
      if(*char_code == 0x01)
        goto __CPROVER_DUMP_L2;

      if(*char_code == 0x80)
        goto __CPROVER_DUMP_L2;

      sprintf(msg, "CD-TEXT with unknown character code %2.2x", (unsigned int)*char_code);
      libdax_msgs_submit(libdax_messenger, -1, 0x0002019f, 0x68000000, 0x30000000, msg, 0, 0);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(first_tno >= 1))
      {
        _Bool tmp_if_expr$1;
        if((signed int)pack[5l] >= 1)
          tmp_if_expr$1 = (signed int)pack[(signed long int)5] + (signed int)pack[(signed long int)6] < 100 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        _Bool tmp_if_expr$2;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (signed int)pack[(signed long int)5] <= (signed int)pack[(signed long int)6] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          first_tno = (signed int)pack[(signed long int)5];
          last_tno = (signed int)pack[(signed long int)6];
        }

        else
        {
          sprintf(msg, "CD-TEXT with illegal track range %d to %d", (signed int)pack[(signed long int)5], (signed int)pack[(signed long int)6]);
          libdax_msgs_submit(libdax_messenger, -1, 0x0002019f, 0x68000000, 0x30000000, msg, 0, 0);
          return 0;
        }
      }

      if(!(last_tno >= 1))
      {
        if(track_count >= 1)
          last_tno = (first_tno + track_count) - 1;

        else
          last_tno = 99;
      }

      result_size = 0;
      block = 0;
      for( ; !(block >= 8); block = block + 1)
      {
        ret=report_block(text_packs, num_packs, block, first_tno, last_tno, *char_code, result, result_size, flag & 1);
        if(!(ret >= 0))
          return ret;

        if(!(ret == 0))
          result_size = ret;

      }
      return result_size;
    }
  }
}

// burn_mdata_free_subs
// file libburn/drive.c line 2766
signed int burn_mdata_free_subs(struct scsi_mode_data *m)
{
  burn_speed_descriptor_destroy(&m->speed_descriptors, 1);
  return 1;
}

// burn_msf_to_lba
// file test/../libburn/libburn.h line 1916
signed int burn_msf_to_lba(signed int m, signed int s, signed int f)
{
  if(!(m >= 90))
    return ((m * 60 + s) * 75 + f) - 150;

  else
    return ((m * 60 + s) * 75 + f) - 450150;
}

// burn_msf_to_sectors
// file libburn/drive.c line 1567
signed int burn_msf_to_sectors(signed int m, signed int s, signed int f)
{
  return (m * 60 + s) * 75 + f;
}

// burn_msgs_initialize
// file libburn/init.c line 122
signed int burn_msgs_initialize(void)
{
  signed int ret;
  if(libdax_messenger == ((struct libdax_msgs *)NULL))
  {
    ret=libdax_msgs_new(&libdax_messenger, 0);
    if(ret >= 1)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    libdax_msgs_set_severities(libdax_messenger, 0x7fffffff, 0x70000000, "libburn: ", 0);
    return 1;
  }
}

// burn_msgs_obtain
// file libburn/init.c line 267
signed int burn_msgs_obtain(char *minimum_severity, signed int *error_code, char *msg_text, signed int *os_errno, char *severity)
{
  signed int ret;
  signed int minimum_sevno;
  signed int sevno;
  signed int priority;
  char *textpt;
  char *sev_name;
  struct libdax_msgs_item *item = (struct libdax_msgs_item *)(void *)0;
  ret=libdax_msgs__text_to_sev(minimum_severity, &minimum_sevno, 0);
  unsigned long int return_value_strlen$1;
  if(!(ret >= 1))
    return 0;

  else
    if(libdax_messenger == ((struct libdax_msgs *)NULL))
      return 0;

    else
    {
      ret=libdax_msgs_obtain(libdax_messenger, &item, minimum_sevno, 0x00000000, 0);
      if(ret >= 1)
      {
        ret=libdax_msgs_item_get_msg(item, error_code, &textpt, os_errno, 0);
        if(ret >= 1)
        {
          strncpy(msg_text, textpt, (unsigned long int)(4096 - 1));
          return_value_strlen$1=strlen(textpt);
          if(return_value_strlen$1 >= 4096ul)
            msg_text[(signed long int)(4096 - 1)] = (char)0;

          severity[(signed long int)0] = (char)0;
          ret=libdax_msgs_item_get_rank(item, &sevno, &priority, 0);
          if(ret >= 1)
          {
            ret=libdax_msgs__sev_to_text(sevno, &sev_name, 0);
            if(ret >= 1)
            {
              strcpy(severity, sev_name);
              ret = 1;
            }

          }

        }

      }


    ex:
      ;
      libdax_msgs_destroy_item(libdax_messenger, &item, 0);
      return ret;
    }
}

// burn_msgs_set_severities
// file test/../libburn/libburn.h line 3720
signed int burn_msgs_set_severities(char *queue_severity, char *print_severity, char *print_id)
{
  signed int ret;
  signed int queue_sevno;
  signed int print_sevno;
  ret=libdax_msgs__text_to_sev(queue_severity, &queue_sevno, 0);
  if(!(ret >= 1))
    return 0;

  else
  {
    ret=libdax_msgs__text_to_sev(print_severity, &print_sevno, 0);
    if(!(ret >= 1))
      return 0;

    else
    {
      ret=libdax_msgs_set_severities(libdax_messenger, queue_sevno, print_sevno, print_id, 0);
      if(!(ret >= 1))
        return 0;

      else
        return 1;
    }
  }
}

// burn_msgs_submit
// file libburn/init.c line 308
signed int burn_msgs_submit(signed int error_code, char *msg_text, signed int os_errno, char *severity, struct burn_drive *d)
{
  signed int ret;
  signed int sevno;
  signed int global_index = -1;
  ret=libdax_msgs__text_to_sev(severity, &sevno, 0);
  if(!(ret >= 1))
    sevno = 0x00000000;

  if(!(error_code >= 1))
    switch(sevno)
    {
      case 0x71000000:
      {
        error_code = 0x00040000;
        break;
      }
      case 0x70000000:
      {
        error_code = 0x00040001;
        break;
      }
      case 0x60000000:
      {
        error_code = 0x00040002;
        break;
      }
      case 0x50000000:
      {
        error_code = 0x00040003;
        break;
      }
      case 0x40000000:
      {
        error_code = 0x00040004;
        break;
      }
      case 0x30000000:
      {
        error_code = 0x00040005;
        break;
      }
      case 0x20000000:
      {
        error_code = 0x00040006;
        break;
      }
      case 0x10000000:
      {
        error_code = 0x00040007;
        break;
      }
      default:
        error_code = 0x00040008;
    }

  if(!(d == ((struct burn_drive *)NULL)))
    global_index = d->global_index;

  ret=libdax_msgs_submit(libdax_messenger, global_index, error_code, sevno, 0x30000000, msg_text, os_errno, 0);
  return ret;
}

// burn_null_source_new
// file libburn/null.c line 23
struct burn_source * burn_null_source_new(void)
{
  struct burn_source *src;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_source) /*88ul*/ );
  src = (struct burn_source *)return_value_calloc$1;
  src->refcount = 1;
  src->read = null_read;
  src->read_sub = (signed int (*)(struct burn_source *, unsigned char *, signed int))(void *)0;
  src->get_size = ((signed long int (*)(struct burn_source *))NULL);
  src->set_size = (signed int (*)(struct burn_source *, signed long int))(void *)0;
  src->free_data = (void (*)(struct burn_source *))(void *)0;
  src->data = (void *)0;
  return src;
}

// burn_obtain_profile_name
// file test/../libburn/libburn.h line 3367
signed int burn_obtain_profile_name(signed int profile_number, char *name)
{
  char *return_value_mmc_obtain_profile_name$1;
  return_value_mmc_obtain_profile_name$1=mmc_obtain_profile_name(profile_number);
  strcpy(name, return_value_mmc_obtain_profile_name$1);
  return (signed int)((signed int)name[(signed long int)0] != 0);
}

// burn_offst_source_new
// file libburn/file.c line 872
struct burn_source * burn_offst_source_new(struct burn_source *inp, struct burn_source *prev, signed long int start, signed long int size, signed int flag)
{
  struct burn_source *src;
  struct burn_source_offst *fs;
  struct burn_source_offst *prev_fs = (struct burn_source_offst *)(void *)0;
  if(!(prev == ((struct burn_source *)NULL)))
  {
    prev_fs=offst_auth(prev, 0);
    if(!(prev_fs == ((struct burn_source_offst *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (struct burn_source *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_source_offst) /*64ul*/ );
    fs = (struct burn_source_offst *)return_value_calloc$1;
    if(fs == ((struct burn_source_offst *)NULL))
      return (struct burn_source *)(void *)0;

    else
    {
      src=burn_source_new();
      if(src == ((struct burn_source *)NULL))
      {
        free((void *)(char *)fs);
        return (struct burn_source *)(void *)0;
      }

      else
      {
        src->read = (signed int (*)(struct burn_source *, unsigned char *, signed int))(void *)0;
        src->read_sub = (signed int (*)(struct burn_source *, unsigned char *, signed int))(void *)0;
        src->get_size = offst_get_size;
        src->set_size = offst_set_size;
        src->free_data = offst_free;
        src->data = (void *)fs;
        src->version = 1;
        src->read_xt = offst_read;
        src->cancel = offst_cancel;
        fs->inp = inp;
        fs->prev = prev;
        fs->next = (struct burn_source *)(void *)0;
        if(!(prev == ((struct burn_source *)NULL)))
        {
          if(!(prev_fs->next == ((struct burn_source *)NULL)))
          {
            struct burn_source_offst *return_value_offst_auth$2;
            return_value_offst_auth$2=offst_auth(prev_fs->next, 1);
            return_value_offst_auth$2->prev = src;
            fs->next = prev_fs->next;
          }

          prev_fs->next = src;
          if(start >= prev_fs->size + prev_fs->start)
            goto __CPROVER_DUMP_L5;

          libdax_msgs_submit(libdax_messenger, -1, 0x00020179, 0x68000000, 0x30000000, "Offset source start address is before end of previous source", 0, 0);
          return (struct burn_source *)(void *)0;
        }

        else
        {

        __CPROVER_DUMP_L5:
          ;
          fs->start = start;
          fs->size = size;
          fs->size_adjustable = (signed int)!((flag & 1) != 0);
          fs->nominal_size = (signed int)size;
          fs->running = 0;
          fs->pos = (signed long int)0;
          inp->refcount = inp->refcount + 1;
          return src;
        }
      }
    }
  }
}

// burn_os_alloc_buffer
// file libburn/libburn.h line 2721
void * burn_os_alloc_buffer(unsigned long int amount, signed int flag)
{
  void *buf = (void *)0;
  libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, "Allocating buffer via mmap()", 0, 0);
  buf=mmap((void *)0, amount, 0x1 | 0x2, 0x01 | 0x20, -1, (signed long int)0);
  if(buf == (void *)-1)
    buf = (void *)0;

  else
    memset(buf, 0, amount);
  return buf;
}

// burn_os_free_buffer
// file libburn/libburn.h line 2731
signed int burn_os_free_buffer(void *buffer, unsigned long int amount, signed int flag)
{
  signed int ret = 0;
  if(buffer == NULL)
    return 0;

  else
  {
    ret=munmap(buffer, amount);
    return (signed int)(ret == 0);
  }
}

// burn_os_is_2k_seekrw
// file libburn/sg.h line 37
signed int burn_os_is_2k_seekrw(char *path, signed int flag)
{
  struct stat stbuf;
  signed int return_value_stat$1;
  return_value_stat$1=stat(path, &stbuf);
  if(return_value_stat$1 == -1)
    return 0;

  else
    if((61440u & stbuf.st_mode) == 32768u)
      return 1;

    else
      if((61440u & stbuf.st_mode) == 24576u)
        return 1;

      else
        return 0;
}

// burn_os_open_track_src
// file libburn/sg-linux.c line 2467
signed int burn_os_open_track_src(char *path, signed int open_flags, signed int flag)
{
  signed int fd;
  fd=open(path, open_flags);
  return fd;
}

// burn_os_stdio_capacity
// file libburn/sg.h line 39
signed int burn_os_stdio_capacity(char *path, signed long int write_start, signed long int *bytes)
{
  struct stat stbuf;
  struct statvfs vfsbuf;
  char *testpath = (char *)(void *)0;
  char *cpt;
  signed long int blocks;
  signed int open_mode = 00;
  signed int fd;
  signed int ret;
  signed long int add_size = (signed long int)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  testpath = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_stat$3;
  if(testpath == ((char *)NULL))
    ret = -1;

  else
  {
    testpath[(signed long int)0] = (char)0;
    return_value_stat$3=stat(path, &stbuf);
    if(return_value_stat$3 == -1)
    {
      strcpy(testpath, path);
      cpt=strrchr(testpath, 47);
      if(cpt == ((char *)NULL))
        strcpy(testpath, ".");

      else
        if(cpt == testpath)
          testpath[(signed long int)1] = (char)0;

        else
          *cpt = (char)0;
      signed int return_value_stat$2;
      return_value_stat$2=stat(testpath, &stbuf);
      if(return_value_stat$2 == -1)
      {
        ret = -1;
        goto ex;
      }

    }

    else
      if((61440u & stbuf.st_mode) == 24576u)
      {
        fd=open(path, open_mode);
        if(fd == -1)
        {
          ret = -2;
          goto ex;
        }

        ret=ioctl(fd, (unsigned long int)(0U << 0 + 8 + 8 + 14 | (unsigned int)(0x12 << 0 + 8) | (unsigned int)(96 << 0) | (unsigned int)(0 << 0 + 8 + 8)), &blocks);
        close(fd);
        if(ret == -1)
        {
          ret = -2;
          goto ex;
        }

        *bytes = (signed long int)blocks * (signed long int)512;
      }

      else
        if((61440u & stbuf.st_mode) == 32768u)
        {
          add_size=burn_sparse_file_addsize(write_start, &stbuf);
          strcpy(testpath, path);
        }

        else
        {
          ret = 0;
          goto ex;
        }
    if(!(*testpath == 0))
    {
      signed int return_value_statvfs$4;
      return_value_statvfs$4=statvfs(testpath, &vfsbuf);
      if(return_value_statvfs$4 == -1)
      {
        ret = -2;
        goto ex;
      }

      *bytes = add_size + (signed long int)vfsbuf.f_frsize * (signed long int)vfsbuf.f_bavail;
    }

    ret = 1;
  }

ex:
  ;
  if(!(testpath == ((char *)NULL)))
    free((void *)(char *)testpath);

  return ret;
}

// burn_packet_process
// file libburn/read.c line 209
void burn_packet_process(struct burn_drive *d, unsigned char *data, struct burn_read_opts *o)
{
  unsigned char sub[96l];
  signed int ptr = 2352;
  signed int i;
  signed int j;
  signed int code;
  signed int fb;
  signed int audio = 1;
  unsigned short int crc;
  if(!(o->c2errors == 0u))
  {
    fb=bitcount(data + (signed long int)ptr, 294);
    ptr = ptr + 294;
  }

  _Bool tmp_if_expr$2;
  if(!(audio == 0))
    tmp_if_expr$2 = o->subcodes_audio != 0u ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    if(audio == 0)
      tmp_if_expr$3 = o->subcodes_data != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    memset((void *)sub, 0, sizeof(unsigned char [96l]) /*96ul*/ );
    i = 0;
    for( ; !(i >= 12); i = i + 1)
    {
      j = 0;
      for( ; !(j >= 8); j = j + 1)
      {
        code = 0;
        for( ; !(code >= 8); code = code + 1)
        {
          sub[(signed long int)(code * 12 + i)] = sub[(signed long int)(code * 12 + i)] << 1;
          if(!((1 << 7 + -code & (signed int)data[(signed long int)(8 * i + j + ptr)]) == 0))
            sub[(signed long int)(code * 12 + i)] = sub[(signed long int)(code * 12 + i)] + 1;

        }
      }
    }
    crc = (unsigned short int)(((signed int)sub[(signed long int)22] << 8) + (signed int)sub[(signed long int)23]);
    unsigned short int return_value_crc_ccitt$1;
    return_value_crc_ccitt$1=crc_ccitt(sub + (signed long int)12, 10);
  }

}

// burn_precheck_write
// file libburn/libburn.h line 1816
signed int burn_precheck_write(struct burn_write_opts *o, struct burn_disc *disc, char *reasons, signed int silent)
{
  enum burn_write_types wt;
  struct burn_drive *d = o->drive;
  char *msg = (char *)(void *)0;
  char *reason_pt;
  signed int no_media = 0;
  signed int ret;
  signed int has_cdtext;
  reason_pt = reasons;
  reasons[(signed long int)0] = (char)0;
  _Bool tmp_if_expr$1;
  if(d->drive_role == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = d->drive_role == 4 ? (_Bool)1 : (_Bool)0;
  unsigned long int return_value_strlen$3;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  if(tmp_if_expr$1)
  {
    if(d->drive_role == 0)
      sprintf(reasons, "DRIVE: is a virtual placeholder (null-drive)");

    else
      sprintf(reasons, "DRIVE: read-only pseudo drive");
    no_media = 1;
  }

  else
  {
    wt=burn_write_opts_auto_write_type(o, disc, reasons, 1);
    if((signed int)wt == BURN_WRITE_NONE)
    {
      signed int return_value_strncmp$2;
      return_value_strncmp$2=strncmp(reasons, "MEDIA: ", (unsigned long int)7);
      if(return_value_strncmp$2 == 0)
        no_media = 1;

      goto ex;
    }

    sprintf(reasons, "%s: ", (const void *)d->current_profile_text);
    return_value_strlen$3=strlen(reasons);
    reason_pt = reasons + (signed long int)return_value_strlen$3;
    if(!((signed int)d->status == BURN_DISC_UNSUITABLE))
    {
      if(o->num_text_packs >= 1)
        has_cdtext = 1;

      else
        has_cdtext=precheck_disc_has_cdtext(disc, 0);
      if(has_cdtext >= 1)
      {
        _Bool tmp_if_expr$4;
        if(d->current_profile == 0x09)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = d->current_profile == 0x0a ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$4)
        {
          ret=precheck_write_is_audio(disc, 0);
          if(!(ret >= 1))
            strcat(reasons, "CD-TEXT supported only with pure audio CD media, ");

        }

        else
          strcat(reasons, "CD-TEXT supported only with CD media, ");
      }

      if(d->drive_role == 2)
        tmp_if_expr$14 = (_Bool)1;

      else
        tmp_if_expr$14 = d->drive_role == 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$14)
        tmp_if_expr$15 = (_Bool)1;

      else
        tmp_if_expr$15 = d->current_profile == 0x1a ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$15)
        tmp_if_expr$16 = (_Bool)1;

      else
        tmp_if_expr$16 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$16)
        tmp_if_expr$17 = (_Bool)1;

      else
        tmp_if_expr$17 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$17)
      {
        if(o->start_byte >= 0l)
        {
          if(!(o->start_byte % 2048l == 0l))
            strcat(reasons, "write start address not properly aligned to 2048, ");

        }

        goto __CPROVER_DUMP_L53;
      }

      if(d->current_profile == 0x09)
        tmp_if_expr$13 = (_Bool)1;

      else
        tmp_if_expr$13 = d->current_profile == 0x0a ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$13)
      {
        signed int return_value_burn_disc_write_is_ok$5;
        return_value_burn_disc_write_is_ok$5=burn_disc_write_is_ok(o, disc, (signed int)!(!(silent != 0)) << 1);
        if(return_value_burn_disc_write_is_ok$5 == 0)
          strcat(reasons, "unsuitable track mode found, ");

        if(o->start_byte >= 0l)
          strcat(reasons, "write start address not supported, ");

        if(o->num_text_packs >= 1)
        {
          if(!((signed int)o->write_type == BURN_WRITE_SAO))
            strcat(reasons, "CD-TEXT supported only with write type SAO, ");

          if(d->start_lba == -2000000000)
            strcat(reasons, "No Lead-in start address known with CD-TEXT, ");

        }

        goto __CPROVER_DUMP_L52;
      }

      if(d->current_profile == 0x13)
      {
        if(o->start_byte >= 0l)
        {
          if(!(o->start_byte % 32768l == 0l))
            strcat(reasons, "write start address not properly aligned to 32k, ");

        }

        goto __CPROVER_DUMP_L52;
      }

      if(d->drive_role == 3)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = d->current_profile == 0x11 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = d->current_profile == 0x1b ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$11)
        tmp_if_expr$12 = (_Bool)1;

      else
        tmp_if_expr$12 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$12)
        goto unsuitable_profile;

      if(o->start_byte >= 0l)
        strcat(reasons, "write start address not supported, ");

    }

    else
    {

    unsuitable_profile:
      ;
      void *return_value_calloc$6;
      return_value_calloc$6=calloc((unsigned long int)1, (unsigned long int)160);
      msg = (char *)return_value_calloc$6;
      if(silent == 0 && !(msg == ((char *)NULL)))
      {
        sprintf(msg, "Unsuitable media detected. Profile %4.4Xh  %s", d->current_profile, (const void *)d->current_profile_text);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011e, 0x60000000, 0x30000000, msg, 0, 0);
      }

      if(!(msg == ((char *)NULL)))
        free((void *)msg);

      strcat(reasons, "no suitable media profile detected, ");
      return 0;
    }
  }

__CPROVER_DUMP_L52:
  ;

__CPROVER_DUMP_L53:
  ;

ex:
  ;
  if(!(*reason_pt == 0))
  {
    if(!(no_media == 0))
    {
      if(silent == 0)
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002013a, 0x70000000, 0x30000000, "No suitable media detected", 0, 0);

      return -1;
    }

    if(silent == 0)
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020139, 0x60000000, 0x30000000, "Write job parameters are unsuitable", 0, 0);

    return 0;
  }

  else
    return 1;
}

// burn_preset_device_open
// file libburn/init.c line 204
void burn_preset_device_open(signed int exclusive, signed int blocking, signed int abort_on_busy)
{
  if(!(burn_running == 0))
  {
    burn_sg_open_o_excl = exclusive & 3;
    burn_sg_fcntl_f_setlk = (signed int)!(!((exclusive & 32) != 0));
    burn_sg_use_family = exclusive >> 2 & 7;
    burn_sg_open_o_nonblock = (signed int)!(blocking != 0);
    burn_sg_open_abort_busy = (signed int)!(!(abort_on_busy != 0));
  }

}

// burn_printify
// file libburn/util.h line 14
char * burn_printify(char *msg)
{
  char *cpt = msg;
  for( ; !((signed int)*cpt == 0); cpt = cpt + 1l)
  {
    _Bool tmp_if_expr$1;
    if(!((signed int)*cpt >= 32))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*cpt > 126 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      *cpt = (char)35;

  }
  return msg;
}

// burn_random_access_write
// file libburn/write.c line 3180
signed int burn_random_access_write(struct burn_drive *d, signed long int byte_address, char *data, signed long int data_count, signed int flag)
{
  signed int alignment = 0;
  signed int start;
  signed int upto;
  signed int chunksize;
  signed int err;
  signed int fd = -1;
  signed int ret;
  signed int do_close = 0;
  signed int getfl_ret;
  char msg[81l];
  char *rpt;
  struct buffer *buf = (struct buffer *)(void *)0;
  struct buffer *buffer_mem = d->buffer;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
    if(!(d->released == 0))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020142, 0x70000000, 0x30000000, "Drive is not grabbed on random access write", 0, 0);
      ret = 0;
    }

    else
      if(d->drive_role == 0)
      {
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020146, 0x70000000, 0x30000000, "Drive is a virtual placeholder (null-drive)", 0, 0);
        ret = 0;
      }

      else
        if(d->drive_role == 4)
        {
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020181, 0x68000000, 0x30000000, "Pseudo-drive is a read-only file. Cannot write.", 0, 0);
          ret = 0;
        }

        else
        {
          _Bool tmp_if_expr$2;
          if(d->drive_role == 2)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = d->drive_role == 5 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            alignment = 2 * 1024;

          if(d->current_profile == 0x12)
            alignment = 2 * 1024;

          if(d->current_profile == 0x13)
            alignment = 32 * 1024;

          if(d->current_profile == 0x1a)
            alignment = 2 * 1024;

          if(d->current_profile == 0x43)
            alignment = 2 * 1024;

          if(alignment == 0)
          {
            sprintf(msg, "Write start address not supported");
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020125, 0x60000000, 0x30000000, "Write start address not supported", 0, 0);
            ret = 0;
          }

          else
            if(!(byte_address % (signed long int)alignment == 0l))
            {
              sprintf(msg, "Write start address not properly aligned (%d bytes)", alignment);
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020126, 0x60000000, 0x30000000, msg, 0, 0);
              ret = 0;
            }

            else
              if(!(data_count % (signed long int)alignment == 0l))
              {
                sprintf(msg, "Write data count not properly aligned (%ld bytes)", (signed long int)alignment);
                libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020141, 0x60000000, 0x30000000, msg, 0, 0);
                ret = 0;
              }

              else
                if(!((signed int)d->busy == BURN_DRIVE_IDLE))
                {
                  libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020140, 0x70000000, 0x30000000, "Drive is busy on attempt to write random access", 0, 0);
                  ret = 0;
                }

                else
                {
                  if(!(d->drive_role == 1))
                  {
                    if(d->stdio_fd >= 0)
                    {
                      getfl_ret=fcntl(d->stdio_fd, 3);
                      if((3 & getfl_ret) == 00)
                      {
                        close(d->stdio_fd);
                        d->stdio_fd = -1;
                      }

                    }

                    if(d->stdio_fd >= 0)
                      fd = d->stdio_fd;

                    else
                    {
                      fd=burn_stdio_open_write(d, byte_address, 2048, 0);
                      if(fd == -1)
                      {
                        ret = 0;
                        goto ex;
                      }

                      do_close = 1;
                    }
                  }

                  d->cancel = 0;
                  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING_SYNC;
                  d->buffer = buf;
                  start = (signed int)(byte_address / (signed long int)2048);
                  upto = (signed int)((signed long int)start + data_count / (signed long int)2048);
                  rpt = data;
                  for( ; !(start >= upto); start = start + 16)
                  {
                    chunksize = upto - start;
                    if(chunksize >= 17)
                      chunksize = 16;

                    d->buffer->bytes = chunksize * 2048;
                    memcpy((void *)d->buffer->data, (const void *)rpt, (unsigned long int)d->buffer->bytes);
                    rpt = rpt + (signed long int)d->buffer->bytes;
                    d->buffer->sectors = chunksize;
                    d->nwa = start;
                    if(d->drive_role == 1)
                      err=d->write(d, d->nwa, d->buffer);

                    else
                    {
                      ret=burn_stdio_write(fd, (char *)d->buffer->data, d->buffer->bytes, d, 0);
                      err = 0;
                      if(!(ret >= 1))
                        err = 1;

                    }
                    if(err == 1)
                    {
                      d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
                      if(fd >= 0 && !(do_close == 0))
                        close(fd);

                      ret = (signed int)-((signed long int)(start * 2048) - byte_address);
                      goto ex;
                    }

                  }
                  if(d->drive_role == 1)
                    d->needs_sync_cache = 1;

                  if(!((1 & flag) == 0))
                  {
                    if(d->drive_role == 1)
                      d->sync_cache(d);

                    else
                      burn_stdio_sync_cache(fd, d, 2);
                    d->needs_sync_cache = 0;
                  }

                  if(fd >= 0 && !(do_close == 0))
                    close(fd);

                  d->buffer = buffer_mem;
                  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
                  ret = 1;
                }
        }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// burn_read_audio
// file test/../libburn/libburn.h line 4039
signed int burn_read_audio(struct burn_drive *d, signed int sector_no, char *data, signed long int data_size, signed long int *data_count, signed int flag)
{
  signed int alignment = 2352;
  signed int start;
  signed int upto;
  signed int chunksize = 1;
  signed int err;
  signed int cpy_size;
  signed int i;
  signed int sose_mem = 0;
  signed int ret;
  char msg[81l];
  char *wpt;
  struct buffer *buf = (struct buffer *)(void *)0;
  struct buffer *buffer_mem = d->buffer;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    *data_count = (signed long int)0;
    sose_mem = d->silent_on_scsi_error;
    if(!(d->released == 0))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020142, 0x70000000, 0x30000000, "Drive is not grabbed on random access read", 0, 0);
      ret = 0;
    }

    else
      if(!(d->drive_role == 1))
      {
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020146, 0x70000000, 0x30000000, "Drive is a virtual placeholder (stdio-drive or null-drive)", 0, 0);
        ret = 0;
      }

      else
        if(!(data_size % (signed long int)alignment == 0l))
        {
          sprintf(msg, "Audio read size not properly aligned (%d bytes)", alignment);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002019d, 0x60000000, 0x30000000, msg, 0, 0);
          ret = 0;
        }

        else
          if(!((signed int)d->busy == BURN_DRIVE_IDLE))
          {
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020145, 0x70000000, 0x30000000, "Drive is busy on attempt to read audio", 0, 0);
            ret = 0;
          }

          else
          {
            d->busy = (volatile enum burn_drive_status)BURN_DRIVE_READING_SYNC;
            d->buffer = buf;
            start = sector_no;
            upto = (signed int)((signed long int)start + data_size / (signed long int)alignment);
            wpt = data;
            if(!(start >= upto))
            {
              chunksize = upto - start;
              if(!(65536 / alignment >= chunksize))
                chunksize = 65536 / alignment;

              cpy_size = chunksize * alignment;
              if(!((2 & flag) == 0))
                d->silent_on_scsi_error = 1;

              else
                if(!((32 & flag) == 0))
                  d->silent_on_scsi_error = 3;

              if(!((16 & flag) == 0))
              {
                d->had_particular_error = d->had_particular_error & ~1;
                if(d->silent_on_scsi_error == 0)
                  d->silent_on_scsi_error = 2;

              }

              err=d->read_cd(d, start, chunksize, 1, 0x10, (struct burn_read_opts *)(void *)0, d->buffer, (flag & 8) >> 3);
              if(!((50 & flag) == 0))
                d->silent_on_scsi_error = sose_mem;

              if(err == 1)
              {
                if(!((16 & flag) == 0))
                {
                  if(!((1 & d->had_particular_error) == 0))
                    ret = -3;

                }

                if((4 & flag) == 0)
                {
                  i = 0;
                  if(!(i >= chunksize + -1))
                  {
                    if(!((2 & flag) == 0))
                      d->silent_on_scsi_error = 1;

                    else
                      if(!((32 & flag) == 0))
                        d->silent_on_scsi_error = 3;

                    err=d->read_cd(d, start + i, 1, 1, 0x10, (struct burn_read_opts *)(void *)0, d->buffer, (flag & 8) >> 3);
                    if(!((34 & flag) == 0))
                      d->silent_on_scsi_error = sose_mem;

                    if(!(err == 1))
                    {
                      memcpy((void *)wpt, (const void *)d->buffer->data, (unsigned long int)alignment);
                      wpt = wpt + (signed long int)alignment;
                      *data_count = *data_count + (signed long int)alignment;
                      i = i + 1;
                    }

                  }

                }

                ret = 0;
              }

              memcpy((void *)wpt, (const void *)d->buffer->data, (unsigned long int)cpy_size);
              wpt = wpt + (signed long int)cpy_size;
              *data_count = *data_count + (signed long int)cpy_size;
              start = start + chunksize;
            }

            ret = 1;
          }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  d->buffer = buffer_mem;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  return ret;
}

// burn_read_data
// file test/../libburn/libburn.h line 3992
signed int burn_read_data(struct burn_drive *d, signed long int byte_address, char *data, signed long int data_size, signed long int *data_count, signed int flag)
{
  signed int alignment = 2048;
  signed int start;
  signed int upto;
  signed int chunksize = 1;
  signed int err;
  signed int cpy_size;
  signed int sose_mem = 0;
  signed int fd = -1;
  signed int ret;
  char msg[81l];
  char *wpt;
  struct buffer *buf = (struct buffer *)(void *)0;
  struct buffer *buffer_mem = d->buffer;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$5;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    *data_count = (signed long int)0;
    sose_mem = d->silent_on_scsi_error;
    if(!(d->released == 0))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020142, 0x70000000, 0x30000000, "Drive is not grabbed on random access read", 0, 0);
      ret = 0;
    }

    else
    {
      if(d->drive_role == 0)
      {
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020146, 0x70000000, 0x30000000, "Drive is a virtual placeholder (null-drive)", 0, 0);
        ret = 0;
        goto ex;
      }

      else
        if(d->drive_role == 3)
        {
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020151, 0x68000000, 0x30000000, "Read attempt on write-only drive", 0, 0);
          ret = 0;
          goto ex;
        }

      if(!(byte_address % (signed long int)alignment == 0l))
      {
        sprintf(msg, "Read start address not properly aligned (%d bytes)", alignment);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020143, 0x60000000, 0x30000000, msg, 0, 0);
        ret = 0;
      }

      else
        if(!(d->media_read_capacity == 0x7fffffff))
        {
          if(!(byte_address >= (1l + (signed long int)d->media_read_capacity) * 2048l))
            goto __CPROVER_DUMP_L7;

          if((2 & flag) == 0)
          {
            sprintf(msg, "Read start address %ds larger than number of readable blocks %d", (signed int)(byte_address / (signed long int)2048 + (signed long int)!(!(byte_address % (signed long int)2048 != 0l))), d->media_read_capacity);
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020172, (flag & 32) != 0 ? 0x10000000 : 0x60000000, 0x30000000, msg, 0, 0);
          }

          ret = 0;
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          if(!((signed int)d->busy == BURN_DRIVE_IDLE))
          {
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020145, 0x70000000, 0x30000000, "Drive is busy on attempt to read data", 0, 0);
            ret = 0;
          }

          else
          {
            if(!(d->drive_role == 1))
            {
              fd = d->stdio_fd;
              if(!(fd >= 0))
              {
                fd=open(d->devname, 00 | 0 | 0);
                d->stdio_fd = fd;
              }

              if(fd == -1)
              {
                signed int *return_value___errno_location$7;
                return_value___errno_location$7=__errno_location();
                if(*return_value___errno_location$7 == 13 && !((2 & flag) == 0))
                {
                  if((8 & flag) == 0)
                  {
                    return_value___errno_location$2=__errno_location();
                    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020183, 0x50000000, 0x30000000, "Failed to open device (a pseudo-drive) for reading", *return_value___errno_location$2, 0);
                  }

                }

                else
                {
                  return_value___errno_location$6=__errno_location();
                  if((2 & flag) == 0 || !(*return_value___errno_location$6 == 2))
                  {
                    _Bool tmp_if_expr$4;
                    if(!((32 & flag) == 0))
                    {
                      return_value___errno_location$3=__errno_location();
                      tmp_if_expr$4 = *return_value___errno_location$3 == 2 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$4 = (_Bool)0;
                    return_value___errno_location$5=__errno_location();
                    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020005, tmp_if_expr$4 ? 0x10000000 : 0x60000000, 0x30000000, "Failed to open device (a pseudo-drive) for reading", *return_value___errno_location$5, 0);
                  }

                }
                ret = 0;
                signed int *return_value___errno_location$8;
                return_value___errno_location$8=__errno_location();
                if(*return_value___errno_location$8 == 13)
                {
                  if(!((8 & flag) == 0))
                    ret = -2;

                }

                goto ex;
              }

              ret=burn_stdio_seek(fd, byte_address, d, flag & (2 | 32));
              if(!(ret >= 1))
                goto ex;

            }

            d->busy = (volatile enum burn_drive_status)BURN_DRIVE_READING_SYNC;
            d->buffer = buf;
            start = (signed int)(byte_address / (signed long int)2048);
            upto = (signed int)((signed long int)start + data_size / (signed long int)2048);
            if(!(data_size % 2048l == 0l))
              upto = upto + 1;

            wpt = data;
            for( ; !(start >= upto); start = start + chunksize)
            {
              chunksize = upto - start;
              if(chunksize >= 33)
              {
                chunksize = 65536 / 2048;
                cpy_size = 65536;
              }

              else
                cpy_size = (signed int)(data_size - *data_count);
              if(!((2 & flag) == 0))
                d->silent_on_scsi_error = 1;

              else
                if(!((32 & flag) == 0))
                  d->silent_on_scsi_error = 3;

              if(!((16 & flag) == 0))
              {
                d->had_particular_error = d->had_particular_error & ~1;
                if(d->silent_on_scsi_error == 0)
                  d->silent_on_scsi_error = 2;

              }

              if(d->drive_role == 1)
                err=d->read_10(d, start, chunksize, d->buffer);

              else
              {
                ret=burn_stdio_read(fd, (char *)d->buffer->data, cpy_size, d, flag & 32 | (signed int)!(!((flag & 2) != 0)));
                err = 0;
                if(!(ret >= 1))
                  err = 1;

              }
              if(!((50 & flag) == 0))
                d->silent_on_scsi_error = sose_mem;

              if(err == 1)
              {
                if(!((16 & flag) == 0))
                {
                  if(!((1 & d->had_particular_error) == 0))
                  {
                    ret = -3;
                    goto ex;
                  }

                }

                if(!((4 & flag) == 0))
                  goto bad_read;

                if(d->drive_role == 1)
                  ret=retry_mmc_read(d, chunksize, sose_mem, start, &wpt, data_count, flag);

                else
                  ret=retry_stdio_read(d, fd, chunksize, start, &wpt, data_count, flag);
                if(!(ret >= 1))
                  goto bad_read;

              }

              else
              {
                memcpy((void *)wpt, (const void *)d->buffer->data, (unsigned long int)cpy_size);
                wpt = wpt + (signed long int)cpy_size;
                *data_count = *data_count + (signed long int)cpy_size;
              }
            }
            ret = 1;
          }
        }
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  d->buffer = buffer_mem;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  return ret;

bad_read:
  ;
  if((2 & flag) == 0)
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020000, 0x10000000, 0x30000000, "burn_read_data() returns 0", 0, 0);

  ret = 0;
  goto ex;
}

// burn_read_opts_free
// file libburn/options.c line 122
void burn_read_opts_free(struct burn_read_opts *opts)
{
  opts->refcount = opts->refcount - 1;
  if(!(opts->refcount >= 1))
    free((void *)opts);

}

// burn_read_opts_new
// file libburn/options.c line 102
struct burn_read_opts * burn_read_opts_new(struct burn_drive *drive)
{
  struct burn_read_opts *opts;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_read_opts) /*24ul*/ );
  opts = (struct burn_read_opts *)return_value_calloc$1;
  opts->drive = drive;
  opts->refcount = 1;
  opts->raw = (unsigned int)0;
  opts->c2errors = (unsigned int)0;
  opts->subcodes_audio = (unsigned int)0;
  opts->subcodes_data = (unsigned int)0;
  opts->hardware_error_recovery = (unsigned int)0;
  opts->report_recovered_errors = (unsigned int)0;
  opts->transfer_damaged_blocks = (unsigned int)0;
  opts->hardware_error_retries = (unsigned char)3;
  opts->dap_bit = (unsigned int)0;
  return opts;
}

// burn_read_opts_read_subcodes_audio
// file libburn/options.c line 554
void burn_read_opts_read_subcodes_audio(struct burn_read_opts *opts, signed int subcodes_audio)
{
  opts->subcodes_audio = (unsigned int)subcodes_audio;
}

// burn_read_opts_read_subcodes_data
// file libburn/options.c line 560
void burn_read_opts_read_subcodes_data(struct burn_read_opts *opts, signed int subcodes_data)
{
  opts->subcodes_data = (unsigned int)subcodes_data;
}

// burn_read_opts_report_recovered_errors
// file libburn/options.c line 572
void burn_read_opts_report_recovered_errors(struct burn_read_opts *opts, signed int report_recovered_errors)
{
  opts->report_recovered_errors = (unsigned int)report_recovered_errors;
}

// burn_read_opts_set_c2errors
// file libburn/options.c line 549
void burn_read_opts_set_c2errors(struct burn_read_opts *opts, signed int c2errors)
{
  opts->c2errors = (unsigned int)c2errors;
}

// burn_read_opts_set_hardware_error_recovery
// file libburn/options.c line 566
void burn_read_opts_set_hardware_error_recovery(struct burn_read_opts *opts, signed int hardware_error_recovery)
{
  opts->hardware_error_recovery = (unsigned int)hardware_error_recovery;
}

// burn_read_opts_set_hardware_error_retries
// file libburn/options.c line 584
void burn_read_opts_set_hardware_error_retries(struct burn_read_opts *opts, unsigned char hardware_error_retries)
{
  opts->hardware_error_retries = hardware_error_retries;
}

// burn_read_opts_set_raw
// file libburn/options.c line 544
void burn_read_opts_set_raw(struct burn_read_opts *opts, signed int raw)
{
  opts->raw = (unsigned int)raw;
}

// burn_read_opts_transfer_damaged_blocks
// file libburn/options.c line 578
void burn_read_opts_transfer_damaged_blocks(struct burn_read_opts *opts, signed int transfer_damaged_blocks)
{
  opts->transfer_damaged_blocks = (unsigned int)transfer_damaged_blocks;
}

// burn_role_by_access
// file libburn/drive.c line 1653
static signed int burn_role_by_access(char *fname, signed int flag)
{
  signed int fd;
  fd=open(fname, 02 | 0 | 0);
  if(!(fd == -1))
  {
    close(fd);
    return 2;
  }

  else
  {
    fd=open(fname, 00 | 0 | 0);
    if(!(fd == -1))
    {
      close(fd);
      return 4;
    }

    else
    {
      fd=open(fname, 01 | 0 | 0);
      if(!(fd == -1))
      {
        close(fd);
        return 5;
      }

      else
        if(!((1 & flag) == 0))
          return 0;

        else
          return 2;
    }
  }
}

// burn_rspc_div_3
// file libburn/ecma130ab.c line 544
static unsigned char burn_rspc_div_3(unsigned char a)
{
  if((signed int)a == 0)
    return (unsigned char)0;

  else
    return gfpow[(signed long int)(230 + (signed int)gflog[(signed long int)a])];
}

// burn_rspc_mult
// file libburn/ecma130ab.c line 527
static unsigned char burn_rspc_mult(unsigned char a, unsigned char b)
{
  if((signed int)a == 0 || (signed int)b == 0)
    return (unsigned char)0;

  else
    return gfpow[(signed long int)((signed int)gflog[(signed long int)a] + (signed int)gflog[(signed long int)b])];
}

// burn_rspc_p0p1
// file libburn/ecma130ab.c line 552
static void burn_rspc_p0p1(unsigned char *sector, signed int col, unsigned char *p0_lsb, unsigned char *p0_msb, unsigned char *p1_lsb, unsigned char *p1_msb)
{
  unsigned char *start;
  unsigned char b;
  unsigned int i;
  unsigned int sum_v_lsb = (unsigned int)0;
  unsigned int sum_v_msb = (unsigned int)0;
  unsigned int hxv_lsb = (unsigned int)0;
  unsigned int hxv_msb = (unsigned int)0;
  start = sector + (signed long int)12 + (signed long int)(2 * col);
  i = (unsigned int)0;
  for( ; !(i >= 24u); i = i + 1u)
  {
    b = *start;
    sum_v_lsb = sum_v_lsb ^ (unsigned int)b;
    unsigned char return_value_burn_rspc_mult$1;
    return_value_burn_rspc_mult$1=burn_rspc_mult(b, h26[(signed long int)i]);
    hxv_lsb = hxv_lsb ^ (unsigned int)return_value_burn_rspc_mult$1;
    b = start[(signed long int)1];
    sum_v_msb = sum_v_msb ^ (unsigned int)b;
    unsigned char return_value_burn_rspc_mult$2;
    return_value_burn_rspc_mult$2=burn_rspc_mult(b, h26[(signed long int)i]);
    hxv_msb = hxv_msb ^ (unsigned int)return_value_burn_rspc_mult$2;
    start = start + (signed long int)86;
  }
  unsigned char return_value_burn_rspc_mult$3;
  return_value_burn_rspc_mult$3=burn_rspc_mult((unsigned char)2, (unsigned char)sum_v_lsb);
  *p0_lsb=burn_rspc_div_3((unsigned char)((unsigned int)return_value_burn_rspc_mult$3 ^ hxv_lsb));
  unsigned char return_value_burn_rspc_mult$4;
  return_value_burn_rspc_mult$4=burn_rspc_mult((unsigned char)2, (unsigned char)sum_v_msb);
  *p0_msb=burn_rspc_div_3((unsigned char)((unsigned int)return_value_burn_rspc_mult$4 ^ hxv_msb));
  *p1_lsb = (unsigned char)(sum_v_lsb ^ (unsigned int)*p0_lsb);
  *p1_msb = (unsigned char)(sum_v_msb ^ (unsigned int)*p0_msb);
}

// burn_rspc_parity_p
// file libburn/ecma130ab.c line 591
void burn_rspc_parity_p(unsigned char *sector)
{
  signed int i;
  unsigned char p0_lsb;
  unsigned char p0_msb;
  unsigned char p1_lsb;
  unsigned char p1_msb;
  i = 0;
  for( ; !(i >= 43); i = i + 1)
  {
    burn_rspc_p0p1(sector, i, &p0_lsb, &p0_msb, &p1_lsb, &p1_msb);
    sector[(signed long int)(2162 + 2 * i)] = p0_lsb;
    sector[(signed long int)(2162 + 2 * i + 1)] = p0_msb;
    sector[(signed long int)(2076 + 2 * i)] = p1_lsb;
    sector[(signed long int)(2076 + 2 * i + 1)] = p1_msb;
  }
}

// burn_rspc_parity_q
// file libburn/ecma130ab.c line 659
void burn_rspc_parity_q(unsigned char *sector)
{
  signed int i;
  unsigned char q0_lsb;
  unsigned char q0_msb;
  unsigned char q1_lsb;
  unsigned char q1_msb;
  i = 0;
  for( ; !(i >= 26); i = i + 1)
  {
    burn_rspc_q0q1(sector, i, &q0_lsb, &q0_msb, &q1_lsb, &q1_msb);
    sector[(signed long int)(2300 + 2 * i)] = q0_lsb;
    sector[(signed long int)(2300 + 2 * i + 1)] = q0_msb;
    sector[(signed long int)(2248 + 2 * i)] = q1_lsb;
    sector[(signed long int)(2248 + 2 * i + 1)] = q1_msb;
  }
}

// burn_rspc_q0q1
// file libburn/ecma130ab.c line 618
static void burn_rspc_q0q1(unsigned char *sector, signed int diag, unsigned char *q0_lsb, unsigned char *q0_msb, unsigned char *q1_lsb, unsigned char *q1_msb)
{
  unsigned char *start;
  unsigned char b;
  unsigned int i;
  unsigned int idx;
  unsigned int sum_v_lsb = (unsigned int)0;
  unsigned int sum_v_msb = (unsigned int)0;
  unsigned int hxv_lsb = (unsigned int)0;
  unsigned int hxv_msb = (unsigned int)0;
  start = sector + (signed long int)12;
  idx = (unsigned int)(2 * 43 * diag);
  i = (unsigned int)0;
  for( ; !(i >= 43u); i = i + 1u)
  {
    if(idx >= 2236u)
      idx = idx - (unsigned int)2236;

    b = start[(signed long int)idx];
    sum_v_lsb = sum_v_lsb ^ (unsigned int)b;
    unsigned char return_value_burn_rspc_mult$1;
    return_value_burn_rspc_mult$1=burn_rspc_mult(b, h45[(signed long int)i]);
    hxv_lsb = hxv_lsb ^ (unsigned int)return_value_burn_rspc_mult$1;
    b = start[(signed long int)(idx + (unsigned int)1)];
    sum_v_msb = sum_v_msb ^ (unsigned int)b;
    unsigned char return_value_burn_rspc_mult$2;
    return_value_burn_rspc_mult$2=burn_rspc_mult(b, h45[(signed long int)i]);
    hxv_msb = hxv_msb ^ (unsigned int)return_value_burn_rspc_mult$2;
    idx = idx + (unsigned int)88;
  }
  unsigned char return_value_burn_rspc_mult$3;
  return_value_burn_rspc_mult$3=burn_rspc_mult((unsigned char)2, (unsigned char)sum_v_lsb);
  *q0_lsb=burn_rspc_div_3((unsigned char)((unsigned int)return_value_burn_rspc_mult$3 ^ hxv_lsb));
  unsigned char return_value_burn_rspc_mult$4;
  return_value_burn_rspc_mult$4=burn_rspc_mult((unsigned char)2, (unsigned char)sum_v_msb);
  *q0_msb=burn_rspc_div_3((unsigned char)((unsigned int)return_value_burn_rspc_mult$4 ^ hxv_msb));
  *q1_lsb = (unsigned char)(sum_v_lsb ^ (unsigned int)*q0_lsb);
  *q1_msb = (unsigned char)(sum_v_msb ^ (unsigned int)*q0_msb);
}

// burn_scsi_setup_drive
// file libburn/spc.h line 55
signed int burn_scsi_setup_drive(struct burn_drive *d, signed int bus_no, signed int host_no, signed int channel_no, signed int target_no, signed int lun_no, signed int flag)
{
  signed int ret;
  d->bus_no = bus_no;
  d->host = host_no;
  d->id = target_no;
  d->channel = channel_no;
  d->lun = lun_no;
  d->silent_on_scsi_error = 0;
  d->had_particular_error = 0;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_scsi_inquiry_data) /*40ul*/ );
  d->idata = (struct burn_scsi_inquiry_data *)return_value_calloc$1;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct scsi_mode_data) /*112ul*/ );
  d->mdata = (struct scsi_mode_data *)return_value_calloc$2;
  _Bool tmp_if_expr$3;
  if(d->idata == ((struct burn_scsi_inquiry_data *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = d->mdata == (struct scsi_mode_data *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020108, 0x70000000, 0x30000000, "Could not allocate new drive object", 0, 0);
    return -1;
  }

  else
  {
    d->idata->valid = 0;
    d->mdata->p2a_valid = 0;
    d->mdata->max_read_speed = 0;
    d->mdata->cur_read_speed = 0;
    d->mdata->max_write_speed = 0;
    d->mdata->cur_write_speed = 0;
    d->mdata->speed_descriptors = (struct burn_speed_descriptor *)(void *)0;
    d->mdata->write_page_length = 0x32;
    d->mdata->write_page_valid = 0;
    if((1 & flag) == 0)
    {
      ret=spc_setup_drive(d);
      if(!(ret >= 1))
        return ret;

      ret=sbc_setup_drive(d);
      if(!(ret >= 1))
        return ret;

      ret=mmc_setup_drive(d);
      if(ret >= 1)
        goto __CPROVER_DUMP_L6;

      return ret;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return 1;
    }
  }
}

// burn_scsi_transport_id
// file libburn/init.c line 194
char * burn_scsi_transport_id(signed int flag)
{
  if(burn_running == 0)
    sg_id_string(sg_initialize_msg, 0);

  return sg_initialize_msg;
}

// burn_sector_length
// file libburn/write.h line 20
signed int burn_sector_length(signed int tracktype)
{
  if(!((64 & tracktype) == 0))
    return 2352;

  else
    if(!((2 & tracktype) == 0))
      return 2352;

    else
      if(!((4 & tracktype) == 0))
        return 2048;

      else
        return -1;
}

// burn_sector_length_read
// file libburn/read.c line 175
signed int burn_sector_length_read(struct burn_drive *d, struct burn_read_opts *o)
{
  signed int dlen = 2352;
  signed int data = 1;
  if(!(o->report_recovered_errors == 0u))
    dlen = dlen + 294;

  if(!(o->subcodes_data == 0u))
  {
    if(!(data == 0))
      dlen = dlen + 96;

  }

  if(!(o->subcodes_audio == 0u))
  {
    if(data == 0)
      dlen = dlen + 96;

  }

  return dlen;
}

// burn_sectors_to_msf
// file libburn/drive.c line 1572
void burn_sectors_to_msf(signed int sectors, signed int *m, signed int *s, signed int *f)
{
  *m = sectors / (60 * 75);
  *s = (sectors - *m * 60 * 75) / 75;
  *f = (sectors - *m * 60 * 75) - *s * 75;
}

// burn_session_add_track
// file libburn/libburn.h line 2027
signed int burn_session_add_track(struct burn_session *s, struct burn_track *t, unsigned int pos)
{
  void *tmp;
  if(pos >= 101u)
    return 0;

  else
  {
    if(pos == 100u)
      pos = (unsigned int)s->tracks;

    if(!(s->tracks >= (signed int)pos))
      return 0;

    else
    {
      tmp=realloc((void *)s->track, sizeof(struct track *) /*8ul*/  * (unsigned long int)(s->tracks + 1));
      if(tmp == NULL)
        return 0;

      else
      {
        s->track = (struct burn_track **)tmp;
        memmove((void *)(s->track + (signed long int)pos + (signed long int)1), (const void *)(s->track + (signed long int)pos), sizeof(struct track *) /*8ul*/  * (unsigned long int)((unsigned int)s->tracks - pos));
        s->tracks = s->tracks + 1;
        s->track[(signed long int)pos] = t;
        t->refcnt = t->refcnt + 1;
        return 1;
      }
    }
  }
}

// burn_session_by_cue_file
// file libburn/structure.c line 1987
signed int burn_session_by_cue_file(struct burn_session *session, char *path, signed int fifo_size, struct burn_source **fifo, unsigned char **text_packs, signed int *num_packs, signed int flag)
{
  signed int ret;
  signed int num_tracks;
  signed int i;
  signed int pack_type;
  signed int length;
  signed int double_byte = 0;
  signed int line_counter = 0;
  struct burn_track **tracks;
  char *msg = (char *)(void *)0;
  char *line = (char *)(void *)0;
  unsigned char *payload;
  struct stat stbuf;
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  struct burn_cue_file_cursor *crs = (struct burn_cue_file_cursor *)(void *)0;
  if(!(fifo == ((struct burn_source **)NULL)))
    *fifo = (struct burn_source *)(void *)0;

  if(!(text_packs == ((unsigned char **)NULL)))
    *text_packs = (unsigned char *)(void *)0;

  *num_packs = 0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_stat$6;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
    line = (char *)return_value_burn_alloc_mem$2;
    if(line == ((char *)NULL))
      ret = -1;

    else
    {
      ret=cue_crs_new(&crs, 0);
      if(ret >= 1)
      {
        crs->no_cdtext = flag & 1;
        crs->no_catalog_isrc = (signed int)!(!((flag & 2) != 0));
        crs->fifo_size = fifo_size;
        crs->block_size_locked = 1;
        tracks=burn_session_get_tracks(session, &num_tracks);
        if(num_tracks >= 1)
        {
          sprintf(msg, "Cue sheet file reader called while session has already defined tracks");
          char *return_value_burn_printify$3;
          return_value_burn_printify$3=burn_printify(msg);
          libdax_msgs_submit(libdax_messenger, -1, 0x00020196, 0x68000000, 0x30000000, return_value_burn_printify$3, 0, 0);
          ret = 0;
          goto ex;
        }

        return_value_stat$6=stat(path, &stbuf);
        if(return_value_stat$6 == -1)
        {

        cannot_open:
          ;
          sprintf(msg, "Cannot open cue sheet file '%.4000s'", path);
          char *return_value_burn_printify$4;
          return_value_burn_printify$4=burn_printify(msg);
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$4, *return_value___errno_location$5, 0);
          ret = 0;
          goto ex;
        }

        if(!((61440u & stbuf.st_mode) == 32768u))
        {
          sprintf(msg, "File is not of usable type: Cue sheet file '%.4000s'", path);
          char *return_value_burn_printify$7;
          return_value_burn_printify$7=burn_printify(msg);
          libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$7, 0, 0);
          ret = 0;
          goto ex;
        }

        fp=fopen(path, "rb");
        if(fp == ((struct _IO_FILE *)NULL))
          goto cannot_open;

        while((_Bool)1)
        {
          char *return_value_burn_sfile_fgets$10;
          return_value_burn_sfile_fgets$10=burn_sfile_fgets(line, 4095, fp);
          if(return_value_burn_sfile_fgets$10 == ((char *)NULL))
          {
            signed int return_value_ferror$8;
            return_value_ferror$8=ferror(fp);
            if(return_value_ferror$8 == 0)
              break;

            sprintf(msg, "Cannot read all bytes from cue sheet file '%.4000s'", path);
            char *return_value_burn_printify$9;
            return_value_burn_printify$9=burn_printify(msg);
            libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$9, 0, 0);
            ret = 0;
            goto ex;
          }

          line_counter = line_counter + 1;
          ret=cue_interpret_line(session, line, crs, 0);
          if(!(ret >= 1))
          {
            sprintf(msg, "Cue sheet file '%.4000s': Reading aborted after line %d", path, line_counter);
            char *return_value_burn_printify$11;
            return_value_burn_printify$11=burn_printify(msg);
            libdax_msgs_submit(libdax_messenger, -1, 0x00020199, 0x60000000, 0x30000000, return_value_burn_printify$11, 0, 0);
            goto ex;
          }

        }
        if(!(crs->track == ((struct burn_track *)NULL)))
        {
          _Bool tmp_if_expr$12;
          if(!(crs->current_file_ba >= 0))
            tmp_if_expr$12 = (_Bool)1;

          else
            tmp_if_expr$12 = crs->track_current_index < 1 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$12)
          {
            libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "No INDEX 01 defined for last TRACK in cue sheet file", 0, 0);
            ret = 0;
            goto ex;
          }

          if((signed long int)(crs->block_size * crs->current_file_ba) >= crs->source_size)
          {
            libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, "TRACK start time point exceeds size of FILE from cue sheet file", 0, 0);
            ret = 0;
            goto ex;
          }

          ret=burn_track_set_size(crs->track, crs->source_size - (signed long int)(crs->current_file_ba * crs->block_size));
          if(!(ret >= 1))
            goto ex;

          ret=cue_attach_track(session, crs, 0);
          if(!(ret >= 1))
            goto ex;

        }

        if(!(crs->cdtextfile == ((char *)NULL)))
        {
          if(!(text_packs == ((unsigned char **)NULL)))
          {
            ret=burn_cdtext_from_packfile(crs->cdtextfile, text_packs, num_packs, 0);
            if(!(ret >= 1))
              goto ex;

          }

        }

        tracks=burn_session_get_tracks(session, &num_tracks);
        pack_type = 0x80;
        for( ; !(pack_type >= 0x8f); pack_type = pack_type + 1)
          if(!(pack_type >= 135) || pack_type == 0x8e)
          {
            ret=burn_session_get_cdtext(session, 0, pack_type, "", &payload, &length, 0);
            if(!(ret >= 1))
              goto ex;

            if(payload == ((unsigned char *)NULL))
            {
              i = 0;
              for( ; !(i >= num_tracks); i = i + 1)
              {
                ret=burn_track_get_cdtext(tracks[(signed long int)i], 0, pack_type, "", &payload, &length, 0);
                if(!(ret >= 1))
                  goto ex;

                double_byte = (signed int)(ret > 1);
                if(!(payload == ((unsigned char *)NULL)))
                  break;

              }
              if(!(i >= num_tracks))
              {
                static unsigned char dummy_cdtext[2l] = { (unsigned char)0, (unsigned char)0 };
                ret=burn_session_set_cdtext(session, 0, pack_type, "", dummy_cdtext, 1 + double_byte, double_byte);
                if(!(ret >= 1))
                  goto ex;

              }

            }

          }

        ret = 1;
      }

    }
  }

ex:
  ;
  if(!(ret >= 1))
  {
    tracks=burn_session_get_tracks(session, &num_tracks);
    i = 0;
    for( ; !(i >= num_tracks); i = i + 1)
      burn_track_free(tracks[(signed long int)i]);
    if(!(text_packs == ((unsigned char **)NULL)))
    {
      if(!(*text_packs == ((unsigned char *)NULL)))
        free((void *)*text_packs);

      *text_packs = (unsigned char *)(void *)0;
      *num_packs = 0;
    }

  }

  else
    if(!(fifo == ((struct burn_source **)NULL)))
    {
      *fifo = crs->fifo;
      crs->fifo = (struct burn_source *)(void *)0;
    }

  cue_crs_destroy(&crs, 0);
  if(!(line == ((char *)NULL)))
    free((void *)(char *)line);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return ret;
}

// burn_session_create
// file libburn/libburn.h line 1939
struct burn_session * burn_session_create(void)
{
  struct burn_session *s;
  signed int i;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_session) /*152ul*/ );
  s = (struct burn_session *)return_value_calloc$1;
  if(s == ((struct burn_session *)NULL))
    return (struct burn_session *)(void *)0;

  else
  {
    s->firsttrack = (unsigned char)1;
    s->lasttrack = (unsigned char)0;
    s->refcnt = 1;
    s->tracks = 0;
    s->track = (struct burn_track **)(void *)0;
    s->hidefirst = 0;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      s->cdtext[(signed long int)i] = (struct burn_cdtext *)(void *)0;
      s->cdtext_language[(signed long int)i] = (unsigned char)0x00;
      s->cdtext_char_code[(signed long int)i] = (unsigned char)0x00;
      s->cdtext_copyright[(signed long int)i] = (unsigned char)0x00;
    }
    s->cdtext_language[(signed long int)0] = (unsigned char)0x09;
    s->mediacatalog[(signed long int)0] = (unsigned char)0;
    return s;
  }
}

// burn_session_dispose_cdtext
// file libburn/structure.c line 1145
signed int burn_session_dispose_cdtext(struct burn_session *s, signed int block)
{
  signed int i;
  if(block == -1)
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      burn_session_dispose_cdtext(s, i);
      s->cdtext_char_code[(signed long int)i] = (unsigned char)0x01;
      s->cdtext_copyright[(signed long int)i] = (unsigned char)0;
      s->cdtext_language[(signed long int)i] = (unsigned char)0;
    }
    return 1;
  }

  else
  {
    signed int return_value_burn_cdtext_check_blockno$1;
    return_value_burn_cdtext_check_blockno$1=burn_cdtext_check_blockno(block);
    if(!(return_value_burn_cdtext_check_blockno$1 >= 1))
      return 0;

    else
    {
      burn_cdtext_free(&s->cdtext[(signed long int)block]);
      s->cdtext_language[(signed long int)block] = (unsigned char)0x09;
      return 1;
    }
  }
}

// burn_session_free
// file libburn/libburn.h line 1944
void burn_session_free(struct burn_session *s)
{
  signed int i;
  s->refcnt = s->refcnt - 1;
  if(s->refcnt == 0)
  {
    i = 0;
    for( ; !(i >= s->tracks); i = i + 1)
      burn_track_free(s->track[(signed long int)i]);
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      burn_cdtext_free(&s->cdtext[(signed long int)i]);
    free((void *)s->track);
    free((void *)s);
  }

}

// burn_session_get_cdtext
// file libburn/structure.c line 1089
signed int burn_session_get_cdtext(struct burn_session *s, signed int block, signed int pack_type, char *pack_type_name, unsigned char **payload, signed int *length, signed int flag)
{
  signed int ret;
  signed int return_value_burn_cdtext_check_blockno$1;
  return_value_burn_cdtext_check_blockno$1=burn_cdtext_check_blockno(block);
  if(!(return_value_burn_cdtext_check_blockno$1 >= 1))
    return 0;

  else
    if(s->cdtext[(signed long int)block] == ((struct burn_cdtext *)NULL))
    {
      *payload = (unsigned char *)(void *)0;
      *length = 0;
      return 1;
    }

    else
    {
      ret=burn_cdtext_get(s->cdtext[(signed long int)block], pack_type, pack_type_name, payload, length, 0);
      return ret;
    }
}

// burn_session_get_cdtext_par
// file libburn/structure.c line 1129
signed int burn_session_get_cdtext_par(struct burn_session *s, signed int *char_codes, signed int *copyrights, signed int *block_languages, signed int flag)
{
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    char_codes[(signed long int)i] = (signed int)s->cdtext_char_code[(signed long int)i];
    copyrights[(signed long int)i] = (signed int)s->cdtext_copyright[(signed long int)i];
    block_languages[(signed long int)i] = (signed int)s->cdtext_language[(signed long int)i];
  }
  return 1;
}

// burn_session_get_hidefirst
// file libburn/structure.c line 746
signed int burn_session_get_hidefirst(struct burn_session *session)
{
  return session->hidefirst;
}

// burn_session_get_leadout_entry
// file test/../libburn/libburn.h line 3565
void burn_session_get_leadout_entry(struct burn_session *s, struct burn_toc_entry *entry)
{
  if(s->leadout_entry == ((struct burn_toc_entry *)NULL))
    memset((void *)entry, 0, sizeof(struct burn_toc_entry) /*32ul*/ );

  else
    memcpy((void *)entry, (const void *)s->leadout_entry, sizeof(struct burn_toc_entry) /*32ul*/ );
}

// burn_session_get_sectors
// file libburn/structure.c line 666
signed int burn_session_get_sectors(struct burn_session *s)
{
  signed int sectors = 0;
  signed int i = 0;
  signed int return_value_burn_track_get_sectors$1;
  for( ; !(i >= s->tracks); i = i + 1)
  {
    return_value_burn_track_get_sectors$1=burn_track_get_sectors(s->track[(signed long int)i]);
    sectors = sectors + return_value_burn_track_get_sectors$1;
  }
  return sectors;
}

// burn_session_get_start_tno
// file libburn/structure.c line 885
signed int burn_session_get_start_tno(struct burn_session *session, signed int flag)
{
  return (signed int)session->firsttrack;
}

// burn_session_get_tracks
// file test/../libburn/libburn.h line 3600
struct burn_track ** burn_session_get_tracks(struct burn_session *s, signed int *num)
{
  *num = s->tracks;
  return s->track;
}

// burn_session_hide_first_track
// file libburn/structure.c line 120
void burn_session_hide_first_track(struct burn_session *s, signed int onoff)
{
  s->hidefirst = onoff;
}

// burn_session_input_sheet_v07t
// file libburn/cdtext.c line 669
signed int burn_session_input_sheet_v07t(struct burn_session *session, char *path, signed int block, signed int flag)
{
  signed int ret = 0;
  signed int num_tracks;
  signed int char_codes[8l];
  signed int copyrights[8l];
  signed int languages[8l];
  signed int i;
  signed int genre_code = -1;
  signed int track_offset = 1;
  signed int pack_type;
  signed int tno;
  signed int tnum;
  signed int session_attr_seen[16l];
  signed int track_attr_seen[16l];
  signed int int0x00 = 0x00;
  signed int int0x01 = 0x01;
  signed int additional_blocks = -1;
  signed int line_count = 0;
  signed int enable_multi_block = 0;
  struct stat stbuf;
  struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
  char *line = (char *)(void *)0;
  char *eq_pos;
  char *payload;
  char *genre_text = (char *)(void *)0;
  char track_txt[3l];
  char *msg = (char *)(void *)0;
  struct burn_track **tracks;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_stat$6;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  signed int return_value_strcmp$83;
  signed int return_value_strcmp$80;
  signed int return_value_strcmp$81;
  signed int return_value_strcmp$77;
  signed int return_value_strcmp$78;
  signed int return_value_strcmp$74;
  signed int return_value_strcmp$75;
  signed int return_value_strcmp$71;
  signed int return_value_strcmp$72;
  signed int return_value_strcmp$68;
  signed int return_value_strcmp$69;
  signed int return_value_strcmp$65;
  signed int return_value_strcmp$66;
  signed int return_value_strcmp$62;
  signed int return_value_strcmp$63;
  signed int return_value_strcmp$61;
  signed int return_value_strcmp$60;
  signed int return_value_strcmp$57;
  signed int return_value_strcmp$58;
  signed int return_value_strcmp$54;
  signed int return_value_strcmp$55;
  signed int return_value_strncmp$53;
  signed int return_value_strcmp$52;
  signed int return_value_strcmp$51;
  signed int return_value_strcmp$50;
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$49;
  signed int return_value_strcmp$48;
  signed int return_value_strncmp$47;
  signed int return_value_strcmp$43;
  signed int return_value_strcmp$39;
  signed int return_value_strcmp$40;
  signed int return_value_strcmp$36;
  signed int return_value_strcmp$37;
  signed int return_value_strcmp$33;
  signed int return_value_strcmp$34;
  signed int return_value_strcmp$30;
  signed int return_value_strcmp$31;
  signed int return_value_strcmp$27;
  signed int return_value_strcmp$28;
  signed int return_value_strcmp$24;
  signed int return_value_strcmp$25;
  signed int return_value_strncmp$46;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
    line = (char *)return_value_burn_alloc_mem$2;
    if(line == ((char *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
      genre_text = (char *)return_value_burn_alloc_mem$3;
      if(genre_text == ((char *)NULL))
        ret = -1;

      else
      {
        i = 0;
        for( ; !(i >= 8); i = i + 1)
        {
          languages[(signed long int)i] = -1;
          copyrights[(signed long int)i] = languages[(signed long int)i];
          char_codes[(signed long int)i] = copyrights[(signed long int)i];
        }
        i = 0;
        for( ; !(i >= 16); i = i + 1)
        {
          track_attr_seen[(signed long int)i] = 0;
          session_attr_seen[(signed long int)i] = track_attr_seen[(signed long int)i];
        }
        genre_text[(signed long int)0] = (char)0;
        tracks=burn_session_get_tracks(session, &num_tracks);
        return_value_stat$6=stat(path, &stbuf);
        if(return_value_stat$6 == -1)
        {

        cannot_open:
          ;
          sprintf(msg, "Cannot open CD-TEXT input sheet v07t '%.4000s'", path);
          char *return_value_burn_printify$4;
          return_value_burn_printify$4=burn_printify(msg);
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$4, *return_value___errno_location$5, 0);
          ret = 0;
          goto ex;
        }

        if(!((61440u & stbuf.st_mode) == 32768u))
        {
          sprintf(msg, "File is not of usable type: CD-TEXT input sheet v07t '%s'", path);
          char *return_value_burn_printify$7;
          return_value_burn_printify$7=burn_printify(msg);
          libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$7, 0, 0);
          ret = 0;
          goto ex;
        }

        fp=fopen(path, "rb");
        if(fp == ((struct _IO_FILE *)NULL))
          goto cannot_open;

        while((_Bool)1)
        {
          char *return_value_burn_sfile_fgets$10;
          return_value_burn_sfile_fgets$10=burn_sfile_fgets(line, 4095, fp);
          if(return_value_burn_sfile_fgets$10 == ((char *)NULL))
          {
            signed int return_value_ferror$8;
            return_value_ferror$8=ferror(fp);
            if(return_value_ferror$8 == 0)
              break;

            sprintf(msg, "Cannot read all bytes from  CD-TEXT input sheet v07t '%.4000s'", path);
            char *return_value_burn_printify$9;
            return_value_burn_printify$9=burn_printify(msg);
            libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$9, 0, 0);
            ret = 0;
            goto ex;
          }

          line_count = line_count + 1;
          unsigned long int return_value_strlen$11;
          return_value_strlen$11=strlen(line);
          if(!(return_value_strlen$11 == 0ul))
          {
            eq_pos=strchr(line, 61);
            if(eq_pos == ((char *)NULL))
            {
              sprintf(msg, "CD-TEXT v07t input sheet line without '=' : '%.4000s'", line);
              char *return_value_burn_printify$12;
              return_value_burn_printify$12=burn_printify(msg);
              libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$12, 0, 0);
              ret = 0;
              goto ex;
            }

            payload = eq_pos + (signed long int)1;
            do
            {
              if((signed int)*payload == 32)
                tmp_if_expr$13 = (_Bool)1;

              else
                tmp_if_expr$13 = (signed int)*payload == 9 ? (_Bool)1 : (_Bool)0;
              if(!tmp_if_expr$13)
                break;

              payload = payload + 1l;
            }
            while((_Bool)1);
            *eq_pos = (char)0;
            eq_pos = eq_pos - 1l;
            do
            {
              if((signed int)*eq_pos == 32)
                tmp_if_expr$14 = (_Bool)1;

              else
                tmp_if_expr$14 = (signed int)*eq_pos == 9 ? (_Bool)1 : (_Bool)0;
              if(line >= eq_pos || !tmp_if_expr$14)
                break;

              *eq_pos = (char)0;
              eq_pos = eq_pos - 1l;
            }
            while((_Bool)1);
            if(!((signed int)*payload == 0))
            {
              signed int return_value_strcmp$84;
              return_value_strcmp$84=strcmp(line, "Text Code");
              if(return_value_strcmp$84 == 0)
              {
                ret=v07t_cdtext_char_code(payload, 0);
                if(!(ret >= 0))
                  goto ex;

                if(char_codes[(signed long int)block] >= 0)
                {
                  if(!(char_codes[(signed long int)block] == ret))
                  {
                    libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "Unexpected v07t Text Code change", 0, 0);
                    ret = 0;
                    goto ex;
                  }

                }

                char_codes[(signed long int)block] = ret;
              }

              else
              {
                return_value_strcmp$83=strcmp(line, "Language Code");
                if(return_value_strcmp$83 == 0)
                {
                  ret=v07t_cdtext_lang_code(payload, 0);
                  if(!(ret >= 0))
                    goto ex;

                  languages[(signed long int)block] = ret;
                }

                else
                {
                  return_value_strcmp$80=strcmp(line, "0x80");
                  _Bool tmp_if_expr$82;
                  if(return_value_strcmp$80 == 0)
                    tmp_if_expr$82 = (_Bool)1;

                  else
                  {
                    return_value_strcmp$81=strcmp(line, "Album Title");
                    tmp_if_expr$82 = return_value_strcmp$81 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$82)
                  {
                    ret=v07t_cdtext_to_session(session, block, payload, char_codes + (signed long int)block, 0, "TITLE", 0);
                    if(!(ret >= 1))
                      goto ex;

                    session_attr_seen[(signed long int)0x0] = 1;
                  }

                  else
                  {
                    return_value_strcmp$77=strcmp(line, "0x81");
                    _Bool tmp_if_expr$79;
                    if(return_value_strcmp$77 == 0)
                      tmp_if_expr$79 = (_Bool)1;

                    else
                    {
                      return_value_strcmp$78=strcmp(line, "Artist Name");
                      tmp_if_expr$79 = return_value_strcmp$78 == 0 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr$79)
                    {
                      ret=v07t_cdtext_to_session(session, block, payload, char_codes + (signed long int)block, 0, "PERFORMER", 0);
                      if(!(ret >= 1))
                        goto ex;

                      session_attr_seen[(signed long int)0x1] = 1;
                    }

                    else
                    {
                      return_value_strcmp$74=strcmp(line, "0x82");
                      _Bool tmp_if_expr$76;
                      if(return_value_strcmp$74 == 0)
                        tmp_if_expr$76 = (_Bool)1;

                      else
                      {
                        return_value_strcmp$75=strcmp(line, "Songwriter");
                        tmp_if_expr$76 = return_value_strcmp$75 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$76)
                      {
                        ret=v07t_cdtext_to_session(session, block, payload, char_codes + (signed long int)block, 0, "SONGWRITER", 0);
                        if(!(ret >= 1))
                          goto ex;

                        session_attr_seen[(signed long int)0x2] = 1;
                      }

                      else
                      {
                        return_value_strcmp$71=strcmp(line, "0x83");
                        _Bool tmp_if_expr$73;
                        if(return_value_strcmp$71 == 0)
                          tmp_if_expr$73 = (_Bool)1;

                        else
                        {
                          return_value_strcmp$72=strcmp(line, "Composer");
                          tmp_if_expr$73 = return_value_strcmp$72 == 0 ? (_Bool)1 : (_Bool)0;
                        }
                        if(tmp_if_expr$73)
                        {
                          ret=v07t_cdtext_to_session(session, block, payload, char_codes + (signed long int)block, 0, "COMPOSER", 0);
                          if(!(ret >= 1))
                            goto ex;

                          session_attr_seen[(signed long int)0x3] = 1;
                        }

                        else
                        {
                          return_value_strcmp$68=strcmp(line, "0x84");
                          _Bool tmp_if_expr$70;
                          if(return_value_strcmp$68 == 0)
                            tmp_if_expr$70 = (_Bool)1;

                          else
                          {
                            return_value_strcmp$69=strcmp(line, "Arranger");
                            tmp_if_expr$70 = return_value_strcmp$69 == 0 ? (_Bool)1 : (_Bool)0;
                          }
                          if(tmp_if_expr$70)
                          {
                            ret=v07t_cdtext_to_session(session, block, payload, char_codes + (signed long int)block, 0, "ARRANGER", 0);
                            if(!(ret >= 1))
                              goto ex;

                            session_attr_seen[(signed long int)0x4] = 1;
                          }

                          else
                          {
                            return_value_strcmp$65=strcmp(line, "0x85");
                            _Bool tmp_if_expr$67;
                            if(return_value_strcmp$65 == 0)
                              tmp_if_expr$67 = (_Bool)1;

                            else
                            {
                              return_value_strcmp$66=strcmp(line, "Album Message");
                              tmp_if_expr$67 = return_value_strcmp$66 == 0 ? (_Bool)1 : (_Bool)0;
                            }
                            if(tmp_if_expr$67)
                            {
                              ret=v07t_cdtext_to_session(session, block, payload, char_codes + (signed long int)block, 0, "MESSAGE", 0);
                              if(!(ret >= 1))
                                goto ex;

                              session_attr_seen[(signed long int)0x5] = 1;
                            }

                            else
                            {
                              return_value_strcmp$62=strcmp(line, "0x86");
                              _Bool tmp_if_expr$64;
                              if(return_value_strcmp$62 == 0)
                                tmp_if_expr$64 = (_Bool)1;

                              else
                              {
                                return_value_strcmp$63=strcmp(line, "Catalog Number");
                                tmp_if_expr$64 = return_value_strcmp$63 == 0 ? (_Bool)1 : (_Bool)0;
                              }
                              if(tmp_if_expr$64)
                              {
                                ret=v07t_cdtext_to_session(session, block, payload, &int0x01, 0, "DISCID", 0);
                                if(!(ret >= 1))
                                  goto ex;

                              }

                              else
                              {
                                return_value_strcmp$61=strcmp(line, "Genre Code");
                                if(return_value_strcmp$61 == 0)
                                {
                                  genre_code=v07t_cdtext_genre_code(payload, 0);
                                  if(!(genre_code >= 0))
                                  {
                                    ret = 0;
                                    goto ex;
                                  }

                                }

                                else
                                {
                                  return_value_strcmp$60=strcmp(line, "Genre Information");
                                  if(return_value_strcmp$60 == 0)
                                  {
                                    strncpy(genre_text, payload, (unsigned long int)159);
                                    genre_text[(signed long int)159] = (char)0;
                                  }

                                  else
                                  {
                                    return_value_strcmp$57=strcmp(line, "0x8d");
                                    _Bool tmp_if_expr$59;
                                    if(return_value_strcmp$57 == 0)
                                      tmp_if_expr$59 = (_Bool)1;

                                    else
                                    {
                                      return_value_strcmp$58=strcmp(line, "Closed Information");
                                      tmp_if_expr$59 = return_value_strcmp$58 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr$59)
                                    {
                                      ret=v07t_cdtext_to_session(session, block, payload, &int0x00, 0, "CLOSED", 0);
                                      if(!(ret >= 1))
                                        goto ex;

                                    }

                                    else
                                    {
                                      return_value_strcmp$54=strcmp(line, "0x8e");
                                      _Bool tmp_if_expr$56;
                                      if(return_value_strcmp$54 == 0)
                                        tmp_if_expr$56 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcmp$55=strcmp(line, "UPC / EAN");
                                        tmp_if_expr$56 = return_value_strcmp$55 == 0 ? (_Bool)1 : (_Bool)0;
                                      }
                                      if(tmp_if_expr$56)
                                      {
                                        ret=v07t_cdtext_to_session(session, block, payload, &int0x01, 0, "UPC_ISRC", 0);
                                        if(!(ret >= 1))
                                          goto ex;

                                        if((2 & flag) == 0)
                                        {
                                          memcpy((void *)session->mediacatalog, (const void *)payload, (unsigned long int)13);
                                          session->mediacatalog[(signed long int)13] = (unsigned char)0;
                                        }

                                        session_attr_seen[(signed long int)0xe] = 1;
                                      }

                                      else
                                      {
                                        return_value_strncmp$53=strncmp(line, "Disc Information ", (unsigned long int)17);
                                        if(!(return_value_strncmp$53 == 0))
                                        {
                                          return_value_strcmp$52=strcmp(line, "Input Sheet Version");
                                          if(return_value_strcmp$52 == 0)
                                          {
                                            signed int return_value_strcmp$16;
                                            return_value_strcmp$16=strcmp(payload, "0.7T");
                                            if(!(return_value_strcmp$16 == 0))
                                            {
                                              sprintf(msg, "Wrong Input Sheet Version '%.4000s'. Expected '0.7T'.", payload);
                                              char *return_value_burn_printify$15;
                                              return_value_burn_printify$15=burn_printify(msg);
                                              libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$15, 0, 0);
                                              ret = 0;
                                              goto ex;
                                            }

                                            if(!((1 & flag) == 0))
                                            {
                                              if(line_count == 1)
                                                enable_multi_block = 1;

                                            }

                                            if(!(enable_multi_block == 0))
                                            {
                                              if(additional_blocks >= 0)
                                              {
                                                if(block == 7)
                                                {
                                                  libdax_msgs_submit(libdax_messenger, -1, 0x000201a0, 0x50000000, 0x30000000, "Maximum number of CD-TEXT blocks exceeded", 0, 0);
                                                  break;
                                                }

                                                ret=v07t_apply_to_session(session, block, char_codes, copyrights, languages, session_attr_seen, track_attr_seen, genre_code, genre_text, 0);
                                                if(!(ret >= 1))
                                                  goto ex;

                                                block = block + 1;
                                              }

                                              additional_blocks = additional_blocks + 1;
                                            }

                                          }

                                          else
                                          {
                                            return_value_strcmp$51=strcmp(line, "Remarks");
                                            if(!(return_value_strcmp$51 == 0))
                                            {
                                              return_value_strcmp$50=strcmp(line, "Text Data Copy Protection");
                                              if(return_value_strcmp$50 == 0)
                                              {
                                                ret=v07t_hexcode(payload, 0);
                                                if(ret >= 0)
                                                  copyrights[(signed long int)block] = ret;

                                                else
                                                {
                                                  return_value_strcmp$19=strcmp(payload, "ON");
                                                  if(return_value_strcmp$19 == 0)
                                                    copyrights[(signed long int)block] = 0x03;

                                                  else
                                                  {
                                                    return_value_strcmp$18=strcmp(payload, "OFF");
                                                    if(return_value_strcmp$18 == 0)
                                                      copyrights[(signed long int)block] = 0x00;

                                                    else
                                                    {
                                                      sprintf(msg, "Unknown v07t Text Data Copy Protection '%.4000s'", payload);
                                                      char *return_value_burn_printify$17;
                                                      return_value_burn_printify$17=burn_printify(msg);
                                                      libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$17, 0, 0);
                                                      ret = 0;
                                                      goto ex;
                                                    }
                                                  }
                                                }
                                              }

                                              else
                                              {
                                                return_value_strcmp$49=strcmp(line, "First Track Number");
                                                if(return_value_strcmp$49 == 0)
                                                {
                                                  ret = -1;
                                                  __isoc99_sscanf(payload, "%d", &ret);
                                                  if(ret >= 100 || !(ret >= 1))
                                                  {

                                                  bad_tno:
                                                    ;
                                                    sprintf(msg, "Inappropriate v07t First Track Number '%.4000s'", payload);
                                                    char *return_value_burn_printify$20;
                                                    return_value_burn_printify$20=burn_printify(msg);
                                                    libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$20, 0, 0);
                                                    ret = 0;
                                                    goto ex;
                                                  }

                                                  else
                                                  {
                                                    track_offset = ret;
                                                    ret=burn_session_set_start_tno(session, track_offset, 0);
                                                    if(!(ret >= 1))
                                                      goto ex;

                                                  }
                                                }

                                                else
                                                {
                                                  return_value_strcmp$48=strcmp(line, "Last Track Number");
                                                  if(return_value_strcmp$48 == 0)
                                                  {
                                                    ret = -1;
                                                    __isoc99_sscanf(payload, "%d", &ret);
                                                    if(!(ret >= 0))
                                                      goto bad_tno;

                                                  }

                                                  else
                                                  {
                                                    return_value_strncmp$47=strncmp(line, "Track ", (unsigned long int)6);
                                                    if(return_value_strncmp$47 == 0)
                                                    {
                                                      tno = -1;
                                                      __isoc99_sscanf(line + (signed long int)6, "%d", &tno);
                                                      if(tno + -track_offset >= num_tracks || !(tno + -track_offset >= 0) || !(tno >= 1))
                                                      {
                                                        track_txt[(signed long int)0] = line[(signed long int)6];
                                                        track_txt[(signed long int)1] = line[(signed long int)7];
                                                        track_txt[(signed long int)2] = (char)0;

                                                      bad_track_no:
                                                        ;
                                                        sprintf(msg, "Inappropriate v07t Track number '%.3900s'", (const void *)track_txt);
                                                        unsigned long int return_value_strlen$21;
                                                        return_value_strlen$21=strlen(msg);
                                                        sprintf(msg + (signed long int)return_value_strlen$21, "  (acceptable range: %2.2d to %2.2d)", track_offset, (num_tracks + track_offset) - 1);
                                                        char *return_value_burn_printify$22;
                                                        return_value_burn_printify$22=burn_printify(msg);
                                                        libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$22, 0, 0);
                                                        ret = 0;
                                                        goto ex;
                                                      }

                                                      tnum = tno - track_offset;
                                                      signed int return_value_strcmp$42;
                                                      return_value_strcmp$42=strcmp(line, "0x80");
                                                      _Bool tmp_if_expr$44;
                                                      if(return_value_strcmp$42 == 0)
                                                        tmp_if_expr$44 = (_Bool)1;

                                                      else
                                                      {
                                                        return_value_strcmp$43=strcmp(line + (signed long int)9, "Title");
                                                        tmp_if_expr$44 = return_value_strcmp$43 == 0 ? (_Bool)1 : (_Bool)0;
                                                      }
                                                      if(tmp_if_expr$44)
                                                        pack_type = 0x80;

                                                      else
                                                      {
                                                        return_value_strcmp$39=strcmp(line + (signed long int)9, "0x81");
                                                        _Bool tmp_if_expr$41;
                                                        if(return_value_strcmp$39 == 0)
                                                          tmp_if_expr$41 = (_Bool)1;

                                                        else
                                                        {
                                                          return_value_strcmp$40=strcmp(line + (signed long int)9, "Artist");
                                                          tmp_if_expr$41 = return_value_strcmp$40 == 0 ? (_Bool)1 : (_Bool)0;
                                                        }
                                                        if(tmp_if_expr$41)
                                                          pack_type = 0x81;

                                                        else
                                                        {
                                                          return_value_strcmp$36=strcmp(line + (signed long int)9, "0x82");
                                                          _Bool tmp_if_expr$38;
                                                          if(return_value_strcmp$36 == 0)
                                                            tmp_if_expr$38 = (_Bool)1;

                                                          else
                                                          {
                                                            return_value_strcmp$37=strcmp(line + (signed long int)9, "Songwriter");
                                                            tmp_if_expr$38 = return_value_strcmp$37 == 0 ? (_Bool)1 : (_Bool)0;
                                                          }
                                                          if(tmp_if_expr$38)
                                                            pack_type = 0x82;

                                                          else
                                                          {
                                                            return_value_strcmp$33=strcmp(line + (signed long int)9, "0x83");
                                                            _Bool tmp_if_expr$35;
                                                            if(return_value_strcmp$33 == 0)
                                                              tmp_if_expr$35 = (_Bool)1;

                                                            else
                                                            {
                                                              return_value_strcmp$34=strcmp(line + (signed long int)9, "Composer");
                                                              tmp_if_expr$35 = return_value_strcmp$34 == 0 ? (_Bool)1 : (_Bool)0;
                                                            }
                                                            if(tmp_if_expr$35)
                                                              pack_type = 0x83;

                                                            else
                                                            {
                                                              return_value_strcmp$30=strcmp(line + (signed long int)9, "0x84");
                                                              _Bool tmp_if_expr$32;
                                                              if(return_value_strcmp$30 == 0)
                                                                tmp_if_expr$32 = (_Bool)1;

                                                              else
                                                              {
                                                                return_value_strcmp$31=strcmp(line + (signed long int)9, "Arranger");
                                                                tmp_if_expr$32 = return_value_strcmp$31 == 0 ? (_Bool)1 : (_Bool)0;
                                                              }
                                                              if(tmp_if_expr$32)
                                                                pack_type = 0x84;

                                                              else
                                                              {
                                                                return_value_strcmp$27=strcmp(line + (signed long int)9, "0x85");
                                                                _Bool tmp_if_expr$29;
                                                                if(return_value_strcmp$27 == 0)
                                                                  tmp_if_expr$29 = (_Bool)1;

                                                                else
                                                                {
                                                                  return_value_strcmp$28=strcmp(line + (signed long int)9, "Message");
                                                                  tmp_if_expr$29 = return_value_strcmp$28 == 0 ? (_Bool)1 : (_Bool)0;
                                                                }
                                                                if(tmp_if_expr$29)
                                                                  pack_type = 0x85;

                                                                else
                                                                {
                                                                  return_value_strcmp$24=strcmp(line + (signed long int)9, "0x8e");
                                                                  _Bool tmp_if_expr$26;
                                                                  if(return_value_strcmp$24 == 0)
                                                                    tmp_if_expr$26 = (_Bool)1;

                                                                  else
                                                                  {
                                                                    return_value_strcmp$25=strcmp(line + (signed long int)9, "ISRC");
                                                                    tmp_if_expr$26 = return_value_strcmp$25 == 0 ? (_Bool)1 : (_Bool)0;
                                                                  }
                                                                  if(tmp_if_expr$26)
                                                                  {
                                                                    pack_type = 0x8e;
                                                                    if((2 & flag) == 0)
                                                                    {
                                                                      ret=burn_track_set_isrc_string(tracks[(signed long int)tnum], payload, 0);
                                                                      if(!(ret >= 1))
                                                                        goto ex;

                                                                    }

                                                                  }

                                                                  else
                                                                  {
                                                                    sprintf(msg, "Unknown v07t Track purpose specifier '%s'", line + (signed long int)9);
                                                                    char *return_value_burn_printify$23;
                                                                    return_value_burn_printify$23=burn_printify(msg);
                                                                    libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$23, 0, 0);
                                                                    ret = 0;
                                                                    goto ex;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                      ret=v07t_cdtext_to_track(tracks[(signed long int)tnum], block, payload, &int0x00, pack_type, "", 0);
                                                      if(!(ret >= 1))
                                                        goto ex;

                                                      track_attr_seen[(signed long int)(pack_type - 0x80)] = 1;
                                                    }

                                                    else
                                                    {
                                                      return_value_strncmp$46=strncmp(line, "ISRC ", (unsigned long int)5);
                                                      if(return_value_strncmp$46 == 0)
                                                      {
                                                        tno = -1;
                                                        __isoc99_sscanf(line + (signed long int)5, "%d", &tno);
                                                        if(tno + -track_offset >= num_tracks || !(tno + -track_offset >= 0) || !(tno >= 1))
                                                        {
                                                          track_txt[(signed long int)0] = line[(signed long int)5];
                                                          track_txt[(signed long int)1] = line[(signed long int)6];
                                                          track_txt[(signed long int)2] = (char)0;
                                                          goto bad_track_no;
                                                        }

                                                        tnum = tno - track_offset;
                                                        if((2 & flag) == 0)
                                                        {
                                                          ret=burn_track_set_isrc_string(tracks[(signed long int)tnum], payload, 0);
                                                          if(!(ret >= 1))
                                                            goto ex;

                                                        }

                                                        ret=v07t_cdtext_to_track(tracks[(signed long int)tnum], block, payload, &int0x00, 0x8e, "", 0);
                                                        if(!(ret >= 1))
                                                          goto ex;

                                                        track_attr_seen[(signed long int)0xe] = 1;
                                                      }

                                                      else
                                                      {
                                                        sprintf(msg, "Unknown v07t purpose specifier '%.4000s'", line);
                                                        char *return_value_burn_printify$45;
                                                        return_value_burn_printify$45=burn_printify(msg);
                                                        libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$45, 0, 0);
                                                        ret = 0;
                                                        goto ex;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }

                                          }
                                        }

                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

          }

        }
        ret=v07t_apply_to_session(session, block, char_codes, copyrights, languages, session_attr_seen, track_attr_seen, genre_code, genre_text, 0);
        if(ret >= 1)
        {
          ret = 1;
          if(additional_blocks >= 1)
            ret = ret + additional_blocks;

        }

      }
    }
  }

ex:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  if(!(genre_text == ((char *)NULL)))
    free((void *)(char *)genre_text);

  if(!(line == ((char *)NULL)))
    free((void *)(char *)line);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_session_remove_track
// file libburn/structure.c line 256
signed int burn_session_remove_track(struct burn_session *s, struct burn_track *t)
{
  struct burn_track **tmp;
  signed int i;
  signed int pos = -1;
  if(s->track == ((struct burn_track **)NULL))
    return 0;

  else
  {
    burn_track_free(t);
    i = 0;
    for( ; !(i >= s->tracks); i = i + 1)
      if(t == s->track[(signed long int)i])
      {
        pos = i;
        break;
      }

    if(pos == -1)
      return 0;

    else
    {
      if(!(pos == s->tracks + -1))
        memmove((void *)&s->track[(signed long int)pos], (const void *)&s->track[(signed long int)(pos + 1)], sizeof(struct burn_track *) /*8ul*/  * (unsigned long int)(s->tracks - (pos + 1)));

      s->tracks = s->tracks - 1;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)s->track, sizeof(struct burn_track *) /*8ul*/  * (unsigned long int)s->tracks);
      tmp = (struct burn_track **)return_value_realloc$1;
      if(!(tmp == ((struct burn_track **)NULL)))
        s->track = tmp;

      return 1;
    }
  }
}

// burn_session_set_cdtext
// file libburn/libburn.h line 2226
signed int burn_session_set_cdtext(struct burn_session *s, signed int block, signed int pack_type, char *pack_type_name, unsigned char *payload, signed int length, signed int flag)
{
  signed int ret;
  signed int return_value_burn_cdtext_check_blockno$1;
  return_value_burn_cdtext_check_blockno$1=burn_cdtext_check_blockno(block);
  if(!(return_value_burn_cdtext_check_blockno$1 >= 1))
    return 0;

  else
  {
    ret=burn_cdtext_set(&s->cdtext[(signed long int)block], pack_type, pack_type_name, payload, length, flag & 1);
    return ret;
  }
}

// burn_session_set_cdtext_par
// file libburn/libburn.h line 2098
signed int burn_session_set_cdtext_par(struct burn_session *s, signed int *char_codes, signed int *copyrights, signed int *block_languages, signed int flag)
{
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    if(char_codes[(signed long int)i] >= 0)
    {
      if(!(char_codes[(signed long int)i] >= 256))
        s->cdtext_char_code[(signed long int)i] = (unsigned char)char_codes[(signed long int)i];

    }

    if(copyrights[(signed long int)i] >= 0)
    {
      if(!(copyrights[(signed long int)i] >= 256))
        s->cdtext_copyright[(signed long int)i] = (unsigned char)copyrights[(signed long int)i];

    }

    if(block_languages[(signed long int)i] >= 0)
    {
      if(!(block_languages[(signed long int)i] >= 256))
        s->cdtext_language[(signed long int)i] = (unsigned char)block_languages[(signed long int)i];

    }

  }
  return 1;
}

// burn_session_set_start_tno
// file libburn/libburn.h line 2050
signed int burn_session_set_start_tno(struct burn_session *session, signed int tno, signed int flag)
{
  if(tno >= 100 || !(tno >= 1))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002019b, 0x60000000, 0x30000000, "CD start track number exceeds range of 1 to 99", 0, 0);
    return 0;
  }

  else
    if(session->tracks + tno + -1 >= 100)
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x0002019b, 0x60000000, 0x30000000, "CD track number exceeds 99", 0, 0);
      return 0;
    }

    else
    {
      session->firsttrack = (unsigned char)tno;
      return 1;
    }
}

// burn_set_messenger
// file libburn/init.c line 626
signed int burn_set_messenger(void *messenger)
{
  struct libdax_msgs *pt;
  signed int return_value_libdax_msgs_refer$1;
  return_value_libdax_msgs_refer$1=libdax_msgs_refer(&pt, (struct libdax_msgs *)messenger, 0);
  if(!(return_value_libdax_msgs_refer$1 >= 1))
    return 0;

  else
  {
    libdax_msgs_destroy(&libdax_messenger, 0);
    libdax_messenger = (struct libdax_msgs *)pt;
    return 1;
  }
}

// burn_set_scsi_logging
// file libburn/init.c line 639
void burn_set_scsi_logging(signed int flag)
{
  burn_sg_log_scsi = flag & 7;
}

// burn_set_signal_handling
// file test/../libburn/libburn.h line 3887
void burn_set_signal_handling(void *handle, signed int (*handler)(void *, signed int, signed int), signed int mode)
{
  if(handler == ((signed int (*)(void *, signed int, signed int))NULL))
    handler = burn_builtin_abort_handler;

  strcpy(abort_message_prefix, "libburn : ");
  abort_message_prefix[(signed long int)0] = (char)0;
  if(handler == burn_builtin_abort_handler && !(handle == NULL))
    strncpy(abort_message_prefix, (char *)handle, sizeof(char [81l]) /*81ul*/  - (unsigned long int)1);

  abort_message_prefix[(signed long int)(sizeof(char [81l]) /*81ul*/  - (unsigned long int)1)] = (char)0;
  abort_control_pid=getpid();
  abort_control_thread=pthread_self();
  burn_builtin_signal_action = mode >> 4 & 15;
  if(!((11 & mode) == 0))
    burn_builtin_signal_action = 0;

  if(burn_builtin_signal_action >= 2)
    burn_builtin_triggered_action = 0;

  if(burn_builtin_signal_action == 0)
    burn_builtin_signal_action = 1;

  Cleanup_set_handlers(handle, (signed int (*)(void *, signed int, signed int))handler, mode & 15 | 4 | mode & 256);
  burn_global_signal_handle = handle;
  burn_global_signal_handler = handler;
}

// burn_set_verbosity
// file libburn/debug.c line 23
void burn_set_verbosity(signed int v)
{
  burn_verbosity = v;
}

// burn_setup_drive
// file libburn/drive.c line 76
signed int burn_setup_drive(struct burn_drive *d, char *fname)
{
  d->devname=strdup(fname);
  memset((void *)&d->params, 0, sizeof(struct params) /*8ul*/ );
  d->idata = (struct burn_scsi_inquiry_data *)(void *)0;
  d->mdata = (struct scsi_mode_data *)(void *)0;
  d->toc_entry = (struct burn_toc_entry *)(void *)0;
  d->released = 1;
  d->stdio_fd = -1;
  d->status = (enum burn_disc_status)BURN_DISC_UNREADY;
  d->erasable = 0;
  d->current_profile = -1;
  d->do_stream_recording = 0;
  d->stream_recording_start = 0;
  d->role_5_nwa = 0;
  d->features = (struct burn_feature_descr *)(void *)0;
  d->drive_serial_number = (char *)(void *)0;
  d->drive_serial_number_len = (char)-1;
  d->media_serial_number = (char *)(void *)0;
  d->media_serial_number_len = (char)-1;
  return 1;
}

// burn_sev_to_text
// file libburn/init.c line 348
signed int burn_sev_to_text(signed int severity_number, char **severity_name, signed int flag)
{
  signed int ret;
  ret=libdax_msgs__sev_to_text(severity_number, severity_name, 0);
  return ret;
}

// burn_sfile_fgets
// file libburn/util.h line 13
char * burn_sfile_fgets(char *line, signed int maxl, struct _IO_FILE *fp)
{
  signed int l;
  char *ret;
  ret=fgets(line, maxl, fp);
  if(ret == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(line);
    l = (signed int)return_value_strlen$1;
    if(l >= 1)
    {
      if((signed int)line[(signed long int)(l + -1)] == 13)
      {
        l = l - 1;
        line[(signed long int)l] = (char)0;
      }

    }

    if(l >= 1)
    {
      if((signed int)line[(signed long int)(l + -1)] == 10)
      {
        l = l - 1;
        line[(signed long int)l] = (char)0;
      }

    }

    if(l >= 1)
    {
      if((signed int)line[(signed long int)(l + -1)] == 13)
      {
        l = l - 1;
        line[(signed long int)l] = (char)0;
      }

    }

    return ret;
  }
}

// burn_source_cancel
// file libburn/source.h line 8
signed int burn_source_cancel(struct burn_source *src)
{
  if(src->read == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL))
  {
    if(src->version >= 1)
    {
      if(!(src->cancel == ((signed int (*)(struct burn_source *))NULL)))
        src->cancel(src);

    }

  }

  return 1;
}

// burn_source_free
// file libburn/libburn.h line 2671
void burn_source_free(struct burn_source *src)
{
  src->refcount = src->refcount - 1;
  if(!(src->refcount >= 1))
  {
    if(!(src->free_data == ((void (*)(struct burn_source *))NULL)))
      src->free_data(src);

    free((void *)src);
  }

}

// burn_source_new
// file libburn/source.h line 6
struct burn_source * burn_source_new(void)
{
  struct burn_source *out;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct burn_source) /*88ul*/ , (unsigned long int)1, 0);
  out = (struct burn_source *)return_value_burn_alloc_mem$1;
  if(out == ((struct burn_source *)NULL))
    return (struct burn_source *)(void *)0;

  else
  {
    out->refcount = 1;
    return out;
  }
}

// burn_source_read
// file libburn/source.h line 10
signed int burn_source_read(struct burn_source *src, unsigned char *buffer, signed int size)
{
  signed int ret;
  if(!(src->read == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL)))
    ret=src->read(src, buffer, size);

  else
    ret=src->read_xt(src, buffer, size);
  return ret;
}

// burn_sparse_file_addsize
// file libburn/util.h line 23
signed long int burn_sparse_file_addsize(signed long int write_start, struct stat *stbuf)
{
  signed long int add_size = stbuf->st_blocks * (signed long int)512;
  if(!(add_size >= stbuf->st_size))
  {
    if(!(write_start >= stbuf->st_size))
    {
      if(!(add_size >= write_start))
        add_size = write_start;

    }

    else
      add_size = stbuf->st_size;
  }

  return add_size;
}

// burn_speed_descriptor_copy
// file libburn/drive.c line 2749
signed int burn_speed_descriptor_copy(struct burn_speed_descriptor *from, struct burn_speed_descriptor *to, signed int flag)
{
  to->source = from->source;
  to->profile_loaded = from->profile_loaded;
  strcpy(to->profile_name, from->profile_name);
  to->wrc = from->wrc;
  to->exact = from->exact;
  to->mrw = from->mrw;
  to->end_lba = from->end_lba;
  to->write_speed = from->write_speed;
  to->read_speed = from->read_speed;
  return 1;
}

// burn_speed_descriptor_destroy
// file libburn/drive.c line 2725
signed int burn_speed_descriptor_destroy(struct burn_speed_descriptor **s, signed int flag)
{
  struct burn_speed_descriptor *next;
  struct burn_speed_descriptor *o;
  signed int return_value_burn_speed_descriptor_destroy$1;
  if(*s == ((struct burn_speed_descriptor *)NULL))
    return 0;

  else
  {
    if(!((1 & flag) == 0))
    {
      o = *s;
      for( ; !(o->prev == ((struct burn_speed_descriptor *)NULL)); o = o->prev)
        ;
    }

    else
      o = *s;
    next = o->next;
    if(!(next == ((struct burn_speed_descriptor *)NULL)))
      next->prev = o->prev;

    if(!(o->prev == ((struct burn_speed_descriptor *)NULL)))
      o->prev->next = next;

    free((void *)(char *)*s);
    *s = (struct burn_speed_descriptor *)(void *)0;
    if(!((1 & flag) == 0))
    {
      return_value_burn_speed_descriptor_destroy$1=burn_speed_descriptor_destroy(&next, flag & 1);
      return return_value_burn_speed_descriptor_destroy$1;
    }

    return 1;
  }
}

// burn_speed_descriptor_new
// file libburn/drive.c line 2692
signed int burn_speed_descriptor_new(struct burn_speed_descriptor **s, struct burn_speed_descriptor *prev, struct burn_speed_descriptor *next, signed int flag)
{
  struct burn_speed_descriptor *o;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_speed_descriptor) /*128ul*/ );
  o = (struct burn_speed_descriptor *)return_value_calloc$1;
  *s = o;
  if(o == ((struct burn_speed_descriptor *)NULL))
    return -1;

  else
  {
    o->source = 0;
    o->profile_loaded = -2;
    o->profile_name[(signed long int)0] = (char)0;
    o->wrc = 0;
    o->exact = 0;
    o->mrw = 0;
    o->end_lba = -1;
    o->write_speed = 0;
    o->read_speed = 0;
    o->prev = prev;
    if(!(prev == ((struct burn_speed_descriptor *)NULL)))
    {
      next = prev->next;
      prev->next = o;
    }

    o->next = next;
    if(!(next == ((struct burn_speed_descriptor *)NULL)))
      next->prev = o;

    return 1;
  }
}

// burn_stdio_mmc_dummy_write
// file libburn/write.c line 2672
signed int burn_stdio_mmc_dummy_write(struct burn_drive *d, signed int start, struct buffer *buf)
{
  if(!(d->cancel == 0))
    return 1;

  else
  {
    d->nwa = start + buf->sectors;
    return 0;
  }
}

// burn_stdio_mmc_sync_cache
// file libburn/write.c line 2738
void burn_stdio_mmc_sync_cache(struct burn_drive *d)
{
  burn_stdio_sync_cache(d->stdio_fd, d, 0);
}

// burn_stdio_mmc_write
// file libburn/write.c line 2629
signed int burn_stdio_mmc_write(struct burn_drive *d, signed int start, struct buffer *buf)
{
  signed int ret;
  signed long int start_byte;
  if(!(d->cancel == 0))
    return 1;

  else
    if(!(d->stdio_fd >= 0))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002017d, 0x70000000, 0x30000000, "Invalid file descriptor with stdio pseudo-drive", 0, 0);
      d->cancel = 1;
      return 1;
    }

    else
    {
      if(!(start == d->nwa))
      {
        char msg[80l];
        start_byte = (signed long int)start * (signed long int)(buf->bytes / buf->sectors);
        signed long int return_value_lseek$2;
        return_value_lseek$2=lseek(d->stdio_fd, start_byte, 0);
        if(return_value_lseek$2 == -1l)
        {
          sprintf(msg, "Cannot address start byte %.f", (double)start_byte);
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020147, 0x60000000, 0x30000000, msg, *return_value___errno_location$1, 0);
          d->cancel = 1;
          return 1;
        }

        d->nwa = start;
      }

      ret=burn_stdio_write(d->stdio_fd, (char *)buf->data, buf->bytes, d, 0);
      if(!(ret >= 1))
        return 1;

      else
      {
        d->nwa = d->nwa + buf->sectors;
        return 0;
      }
    }
}

// burn_stdio_open_write
// file libburn/write.c line 2499
signed int burn_stdio_open_write(struct burn_drive *d, signed long int start_byte, signed int sector_size, signed int flag)
{
  signed int fd = -1;
  signed int mode = 02 | 0100 | 0;
  char msg[60l];
  signed long int lseek_res;
  if(d->drive_role == 4)
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020181, 0x68000000, 0x30000000, "Pseudo-drive is a read-only file. Cannot write.", 0, 0);
    return 0;
  }

  else
  {
    _Bool tmp_if_expr$1;
    if(d->drive_role == 5)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = d->drive_role == 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      mode = 01 | 0100 | 0;

    if((signed int)*d->devname == 0)
      return -1;

    else
    {
      fd=burn_drive__fd_from_special_adr(d->devname);
      if(fd >= 0)
        fd=dup(fd);

      else
        fd=open(d->devname, mode | 0, 0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3 | (0200 >> 3) >> 3);
      if(fd == -1)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020005, 0x60000000, 0x30000000, "Failed to open device (a pseudo-drive)", *return_value___errno_location$2, 0);
        d->cancel = 1;
        return -1;
      }

      if(!(start_byte >= 0l))
        start_byte = (signed long int)0;

      _Bool tmp_if_expr$4;
      if(d->drive_role == 2)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = d->drive_role == 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        lseek_res=lseek(fd, start_byte, 0);
        if(lseek_res == -1l)
        {
          sprintf(msg, "Cannot address start byte %.f", (double)start_byte);
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020147, 0x60000000, 0x30000000, msg, *return_value___errno_location$3, 0);
          close(fd);
          d->cancel = 1;
          fd = -1;
        }

      }

      d->nwa = (signed int)(start_byte / (signed long int)sector_size);
      return fd;
    }
  }
}

// burn_stdio_read
// file libburn/read.c line 344
signed int burn_stdio_read(signed int fd, char *buf, signed int bufsize, struct burn_drive *d, signed int flag)
{
  signed int todo;
  signed int count = 0;
  todo = bufsize;
  while(todo >= 1)
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)(buf + (signed long int)(bufsize - todo)), (unsigned long int)todo);
    count = (signed int)return_value_read$1;
    if(!(count >= 1))
      break;

    todo = todo - count;
  }
  if((1 & flag) == 0 && todo >= 1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002014a, (flag & 32) != 0 ? 0x10000000 : 0x60000000, 0x30000000, "Cannot read desired amount of data", *return_value___errno_location$2, 0);
  }

  if(!(count >= 0))
    return -1;

  else
    return bufsize - todo;
}

// burn_stdio_read_source
// file libburn/write.c line 2563
signed int burn_stdio_read_source(struct burn_source *source, char *buf, signed int bufsize, struct burn_write_opts *o, signed int flag)
{
  signed int count = 0;
  signed int todo = bufsize;
  if(todo >= 1)
  {
    if(!(source->read == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL)))
      count=source->read(source, (unsigned char *)(buf + (signed long int)(bufsize - todo)), todo);

    else
      count=source->read_xt(source, (unsigned char *)(buf + (signed long int)(bufsize - todo)), todo);
    if(count >= 1)
      todo = todo - count;

  }

  return bufsize - todo;
}

// burn_stdio_seek
// file libburn/read.c line 320
static signed int burn_stdio_seek(signed int fd, signed long int byte_address, struct burn_drive *d, signed int flag)
{
  char msg[80l];
  signed long int return_value_lseek$1;
  return_value_lseek$1=lseek(fd, byte_address, 0);
  if(!(return_value_lseek$1 == -1l))
    return 1;

  else
  {
    if((2 & flag) == 0)
    {
      sprintf(msg, "Cannot address start byte %.f", (double)byte_address);
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020147, (flag & 32) != 0 ? 0x10000000 : 0x60000000, 0x30000000, msg, *return_value___errno_location$2, 0);
    }

    return 0;
  }
}

// burn_stdio_slowdown
// file libburn/write.c line 2747
signed int burn_stdio_slowdown(struct burn_drive *d, struct timeval *prev_time, signed int amount, signed int flag)
{
  struct timeval tnow;
  struct timezone dummy_tz;
  double to_wait;
  if(!((1 & flag) == 0))
  {
    gettimeofday(prev_time, &dummy_tz);
    return 1;
  }

  else
    if(!(d->nominal_write_speed >= 1))
      return 2;

    else
    {
      gettimeofday(&tnow, &dummy_tz);
      to_wait = (((double)amount / (double)d->nominal_write_speed - (double)(tnow.tv_sec - prev_time->tv_sec)) - (double)(tnow.tv_usec - prev_time->tv_usec) / 1.0e6) - 0.001;
      if(to_wait >= 0.0001)
        usleep((unsigned int)(signed int)(to_wait * 1000000.0));

      gettimeofday(prev_time, &dummy_tz);
      return 1;
    }
}

// burn_stdio_sync_cache
// file libburn/write.c line 2687
signed int burn_stdio_sync_cache(signed int fd, struct burn_drive *d, signed int flag)
{
  signed int ret;
  signed int do_fsync;
  char *msg = (char *)(void *)0;
  signed int *return_value___errno_location$3;
  if(!(fd >= 0))
  {
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002017d, 0x70000000, 0x30000000, "Invalid file descriptor with stdio pseudo-drive", 0, 0);
    d->cancel = 1;
    ret = 0;
  }

  else
  {
    d->needs_sync_cache = 0;
    do_fsync = 0;
    if(!((2 & flag) == 0))
      do_fsync = 1;

    else
      if(!(d->write_opts == ((struct burn_write_opts *)NULL)))
        do_fsync = (signed int)(d->write_opts->stdio_fsync_size >= 0);

    if(!(do_fsync == 0))
    {
      if((1 & flag) == 0)
        libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, "syncing cache (stdio fsync)", 0, 0);

      ret=fsync(fd);
    }

    else
      ret = 0;
    if(!(ret == 0))
    {
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 5)
      {
        void *return_value_burn_alloc_mem$1;
        return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
        msg = (char *)return_value_burn_alloc_mem$1;
        if(msg == ((char *)NULL))
        {
          ret = -1;
          goto ex;
        }

        sprintf(msg, "Cannot write desired amount of data. fsync(2) returned %d.", ret);
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020148, 0x60000000, 0x30000000, msg, *return_value___errno_location$2, 0);
        d->cancel = 1;
        ret = 0;
        goto ex;
      }

    }

    ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// burn_stdio_write
// file libburn/write.c line 2583
signed int burn_stdio_write(signed int fd, char *buf, signed int count, struct burn_drive *d, signed int flag)
{
  signed int ret = 0;
  char *msg = (char *)(void *)0;
  signed int todo;
  signed int done;
  signed int retries;
  unsigned long int return_value_strlen$3;
  if(!(d->cancel == 0) || !(count >= 1))
    return 0;

  else
  {
    todo = count;
    done = 0;
    retries = 0;
    for( ; todo >= 1 && !(retries >= 17); retries = retries + 1)
    {
      signed long int return_value_write$1;
      return_value_write$1=write(fd, (const void *)(buf + (signed long int)done), (unsigned long int)todo);
      ret = (signed int)return_value_write$1;
      if(!(ret >= 0))
        break;

      done = done + ret;
      todo = todo - ret;
    }
    if(!(done == count))
    {
      void *return_value_burn_alloc_mem$2;
      return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
      msg = (char *)return_value_burn_alloc_mem$2;
      if(msg == ((char *)NULL))
        ret = -1;

      else
      {
        sprintf(msg, "Cannot write desired amount of %d bytes.", count);
        if(retries >= 2)
        {
          return_value_strlen$3=strlen(msg);
          sprintf(msg + (signed long int)return_value_strlen$3, " Did %d retries. Last", retries - 1);
        }

        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(msg);
        sprintf(msg + (signed long int)return_value_strlen$4, " write(2) returned %d.", ret);
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020148, 0x60000000, 0x30000000, msg, *return_value___errno_location$5, 0);
        d->cancel = 1;
        ret = 0;
        goto ex;
      }
    }


  ex:
    ;
    if(!(msg == ((char *)NULL)))
      free((void *)(char *)msg);

    return ret;
  }
}

// burn_stdio_write_sync
// file libburn/write.c line 2842
signed int burn_stdio_write_sync(struct burn_write_opts *o, struct burn_disc *disc)
{
  signed int ret;
  struct burn_drive *d = o->drive;
  d->needs_close_session = 0;
  if(!(o->obs_pad >= 2))
    o->obs_pad = 0;

  o->obs = 32 * 1024;
  if(!(disc->sessions == 1))
    ret = 0;

  else
    if(!((*disc->session)->tracks == 1))
      ret = 0;

    else
    {
      d->progress.session = 0;
      d->progress.tracks = 1;
      if(d->stdio_fd >= 0)
        close(d->stdio_fd);

      if(d->drive_role == 5)
      {
        if((signed int)d->status == BURN_DISC_APPENDABLE)
        {
          if(!(o->start_byte >= 0l))
            o->start_byte = (signed long int)(d->role_5_nwa * 2048);

        }

      }

      d->stdio_fd=burn_stdio_open_write(d, o->start_byte, 2048, 0);
      if(d->stdio_fd == -1)
        ret = 0;

      else
      {
        ret=burn_stdio_write_track(o, disc->session[(signed long int)0], 0, 0);
        if(ret >= 1)
        {
          d->progress.sector = 0;
          d->progress.start_sector = 0;
          d->progress.sectors = 0;
          ret = 1;
        }

      }
    }

ex:
  ;
  if(d->stdio_fd >= 0)
    close(d->stdio_fd);

  d->stdio_fd = -1;
  burn_drive_mark_unready(d, 8);
  burn_drive_grab_stdio(d, 1);
  return ret;
}

// burn_stdio_write_track
// file libburn/write.c line 2774
signed int burn_stdio_write_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum, signed int flag)
{
  signed int open_ended;
  signed int bufsize = 16 * 2048;
  signed int ret;
  signed int sectors;
  struct burn_track *t = s->track[(signed long int)tnum];
  struct burn_drive *d = o->drive;
  char *buf = (char *)(void *)0;
  signed int i;
  signed int prev_sync_sector = 0;
  struct buffer *out = d->buffer;
  struct timeval prev_time;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)bufsize, 0);
  buf = (char *)return_value_burn_alloc_mem$1;
  if(buf == ((char *)NULL))
    ret = -1;

  else
  {
    sectors=burn_track_get_sectors_2(t, 1);
    burn_disc_init_track_status(o, s, t, tnum, sectors);
    open_ended=burn_track_is_open_ended(t);
    t->end_on_premature_eoi = (signed int)((signed int)o->write_type == BURN_WRITE_TAO);
    if(!(o->simulate == 0u))
      d->write = burn_stdio_mmc_dummy_write;

    else
      d->write = burn_stdio_mmc_write;
    d->sync_cache = burn_stdio_mmc_sync_cache;
    burn_stdio_slowdown(d, &prev_time, 0, 1);
    i = 0;
    for( ; !(open_ended == 0) || !(i >= sectors); i = i + 1)
    {
      signed int return_value_sector_data$2;
      return_value_sector_data$2=sector_data(o, t, 0);
      if(return_value_sector_data$2 == 0)
      {
        ret = 0;
        goto ex;
      }

      if(!(open_ended == 0))
      {
        sectors = d->progress.sector;
        d->progress.sectors = sectors;
      }

      _Bool tmp_if_expr$4;
      if(!(open_ended == 0))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = t->end_on_premature_eoi != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        signed int return_value_burn_track_is_data_done$3;
        return_value_burn_track_is_data_done$3=burn_track_is_data_done(t);
        if(!(return_value_burn_track_is_data_done$3 == 0))
          break;

      }

      d->progress.sector = d->progress.sector + 1;
      if(d->progress.sector + -prev_sync_sector >= o->stdio_fsync_size)
      {
        if(o->stdio_fsync_size >= 1)
        {
          prev_sync_sector = d->progress.sector;
          if(o->simulate == 0u)
            burn_stdio_sync_cache(d->stdio_fd, d, 1);

        }

      }

      if(d->progress.sector % 512 == 0)
        burn_stdio_slowdown(d, &prev_time, 512 * 2, 0);

    }
    if(!(o->obs_pad == 0))
    {
      if(out->bytes >= 1)
      {
        if(!(out->bytes >= o->obs))
        {
          memset((void *)(out->data + (signed long int)out->bytes), 0, (unsigned long int)(o->obs - out->bytes));
          out->sectors = out->sectors + (o->obs - out->bytes) / 2048;
          out->bytes = o->obs;
        }

      }

    }

    ret=burn_write_flush(o, t);
    ret = 1;
  }

ex:
  ;
  if(!(d->cancel == 0))
    burn_source_cancel(t->source);

  if(t->end_on_premature_eoi == 2)
    d->cancel = 1;

  if(!(buf == ((char *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// burn_structure_print_disc
// file libburn/structure.c line 292
void burn_structure_print_disc(struct burn_disc *d)
{
  signed int i;
  char msg[40l];
  sprintf(msg, "This disc has %d sessions", d->sessions);
  libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
  i = 0;
  for( ; !(i >= d->sessions); i = i + 1)
    burn_structure_print_session(d->session[(signed long int)i]);
}

// burn_structure_print_session
// file libburn/structure.c line 305
void burn_structure_print_session(struct burn_session *s)
{
  signed int i;
  char msg[40l];
  sprintf(msg, "    Session has %d tracks", s->tracks);
  libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
  i = 0;
  for( ; !(i >= s->tracks); i = i + 1)
    burn_structure_print_track(s->track[(signed long int)i]);
}

// burn_structure_print_track
// file libburn/structure.c line 318
void burn_structure_print_track(struct burn_track *t)
{
  char msg[80l];
  signed int return_value_burn_track_get_sectors$1;
  return_value_burn_track_get_sectors$1=burn_track_get_sectors(t);
  sprintf(msg, "        track size %d sectors", return_value_burn_track_get_sectors$1);
  libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
}

// burn_subcode_length
// file libburn/write.h line 21
signed int burn_subcode_length(signed int tracktype)
{
  if(!((1024 & tracktype) == 0))
    return 16;

  else
    if(!((2048 & tracktype) == 0) || !((4096 & tracktype) == 0))
      return 96;

    else
      return 0;
}

// burn_text_to_sev
// file libburn/init.c line 338
signed int burn_text_to_sev(char *severity_name, signed int *sevno, signed int flag)
{
  signed int ret;
  ret=libdax_msgs__text_to_sev(severity_name, sevno, 0);
  return ret;
}

// burn_track_apply_fillup
// file libburn/structure.c line 590
signed int burn_track_apply_fillup(struct burn_track *t, signed long int max_size, signed int flag)
{
  signed int max_sectors;
  signed int ret = 2;
  char msg[80l];
  if(!(t->fill_up_media >= 1))
    return 2;

  else
  {
    max_sectors = (signed int)(max_size / (signed long int)2048);
    signed int return_value_burn_track_get_sectors$1;
    return_value_burn_track_get_sectors$1=burn_track_get_sectors(t);
    if(!((1 & flag) == 0) || !(return_value_burn_track_get_sectors$1 >= max_sectors))
    {
      signed long int return_value;
      return_value=t->source->get_size(t->source);
      sprintf(msg, "Setting total track size to %ds (payload %ds)\n", max_sectors & 0x7fffffff, (signed int)(return_value / (signed long int)2048 & (signed long int)0x7fffffff));
      libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
      ret=burn_track_set_sectors(t, max_sectors);
      t->open_ended = 0;
    }

    return ret;
  }
}

// burn_track_clear_indice
// file libburn/structure.c line 483
signed int burn_track_clear_indice(struct burn_track *t, signed int flag)
{
  signed int i = 0;
  for( ; !(i >= 100); i = i + 1)
    t->index[(signed long int)i] = 0x7fffffff;
  t->indices = (unsigned char)0;
  return 1;
}

// burn_track_clear_isrc
// file libburn/structure.c line 458
void burn_track_clear_isrc(struct burn_track *t)
{
  t->isrc.has_isrc = 0;
}

// burn_track_create
// file libburn/libburn.h line 2014
struct burn_track * burn_track_create(void)
{
  struct burn_track *t;
  signed int i;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_track) /*624ul*/ );
  t = (struct burn_track *)return_value_calloc$1;
  if(t == ((struct burn_track *)NULL))
    return (struct burn_track *)(void *)0;

  else
  {
    t->refcnt = 1;
    t->indices = (unsigned char)0;
    i = 0;
    for( ; !(i >= 100); i = i + 1)
      t->index[(signed long int)i] = 0x7fffffff;
    t->offset = 0;
    t->offsetcount = 0;
    t->tail = 0;
    t->tailcount = 0;
    t->mode = 1 << 2;
    t->isrc.has_isrc = 0;
    t->pad = 1;
    t->fill_up_media = 0;
    t->default_size = (signed long int)0;
    t->entry = (struct burn_toc_entry *)(void *)0;
    t->source = (struct burn_source *)(void *)0;
    t->eos = 0;
    t->sourcecount = (signed long int)0;
    t->writecount = (signed long int)0;
    t->written_sectors = (signed long int)0;
    t->open_ended = 0;
    t->track_data_done = 0;
    t->end_on_premature_eoi = 0;
    t->pregap1 = 0;
    t->pregap2 = 0;
    t->pregap2_size = 150;
    t->postgap = 0;
    t->postgap_size = 150;
    t->swap_source_bytes = 0;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      t->cdtext[(signed long int)i] = (struct burn_cdtext *)(void *)0;
    return t;
  }
}

// burn_track_define_data
// file libburn/structure.c line 329
void burn_track_define_data(struct burn_track *t, signed int offset, signed int tail, signed int pad, signed int mode)
{
  unsigned char ctladr;
  signed int form = -1;
  char msg[80l];
  type_to_form(mode, &ctladr, &form);
  _Bool tmp_if_expr$2;
  signed int return_value_burn_sector_length$1;
  if(form == -1)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_burn_sector_length$1=burn_sector_length(mode);
    tmp_if_expr$2 = return_value_burn_sector_length$1 <= 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    sprintf(msg, "Attempt to set track mode to unusable value 0x%X", (unsigned int)mode);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020115, 0x60000000, 0x30000000, msg, 0, 0);
  }

  else
  {
    t->offset = offset;
    t->pad = pad;
    t->mode = mode;
    t->tail = tail;
  }
}

// burn_track_dispose_cdtext
// file libburn/structure.c line 1054
signed int burn_track_dispose_cdtext(struct burn_track *t, signed int block)
{
  signed int i;
  if(block == -1)
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      burn_cdtext_free(&t->cdtext[(signed long int)i]);
    return 1;
  }

  else
  {
    signed int return_value_burn_cdtext_check_blockno$1;
    return_value_burn_cdtext_check_blockno$1=burn_cdtext_check_blockno(block);
    if(!(return_value_burn_cdtext_check_blockno$1 >= 1))
      return 0;

    else
    {
      burn_cdtext_free(&t->cdtext[(signed long int)0]);
      return 1;
    }
  }
}

// burn_track_free
// file libburn/libburn.h line 2019
void burn_track_free(struct burn_track *t)
{
  signed int i;
  t->refcnt = t->refcnt - 1;
  if(t->refcnt == 0)
  {
    if(!(t->source == ((struct burn_source *)NULL)))
      burn_source_free(t->source);

    i = 0;
    for( ; !(i >= 8); i = i + 1)
      burn_cdtext_free(&t->cdtext[(signed long int)i]);
    free((void *)t);
  }

}

// burn_track_get_cdtext
// file libburn/structure.c line 1034
signed int burn_track_get_cdtext(struct burn_track *t, signed int block, signed int pack_type, char *pack_type_name, unsigned char **payload, signed int *length, signed int flag)
{
  signed int ret;
  signed int return_value_burn_cdtext_check_blockno$1;
  return_value_burn_cdtext_check_blockno$1=burn_cdtext_check_blockno(block);
  if(!(return_value_burn_cdtext_check_blockno$1 >= 1))
    return 0;

  else
    if(t->cdtext[(signed long int)block] == ((struct burn_cdtext *)NULL))
    {
      *payload = (unsigned char *)(void *)0;
      *length = 0;
      return 1;
    }

    else
    {
      ret=burn_cdtext_get(t->cdtext[(signed long int)block], pack_type, pack_type_name, payload, length, 0);
      return ret;
    }
}

// burn_track_get_counters
// file libburn/structure.c line 636
signed int burn_track_get_counters(struct burn_track *t, signed long int *read_bytes, signed long int *written_bytes)
{
  *read_bytes = t->sourcecount;
  *written_bytes = t->writecount;
  return 1;
}

// burn_track_get_default_size
// file libburn/structure.h line 173
signed long int burn_track_get_default_size(struct burn_track *t)
{
  return t->default_size;
}

// burn_track_get_entry
// file test/../libburn/libburn.h line 3559
void burn_track_get_entry(struct burn_track *t, struct burn_toc_entry *entry)
{
  if(t->entry == ((struct burn_toc_entry *)NULL))
    memset((void *)entry, 0, sizeof(struct burn_toc_entry) /*32ul*/ );

  else
    memcpy((void *)entry, (const void *)t->entry, sizeof(struct burn_toc_entry) /*32ul*/ );
}

// burn_track_get_mode
// file libburn/structure.c line 741
signed int burn_track_get_mode(struct burn_track *track)
{
  return track->mode;
}

// burn_track_get_sectors
// file libburn/structure.c line 543
signed int burn_track_get_sectors(struct burn_track *t)
{
  signed int return_value_burn_track_get_sectors_2$1;
  return_value_burn_track_get_sectors_2$1=burn_track_get_sectors_2(t, 0);
  return return_value_burn_track_get_sectors_2$1;
}

// burn_track_get_sectors_2
// file libburn/structure.h line 187
signed int burn_track_get_sectors_2(struct burn_track *t, signed int flag)
{
  signed long int size = (signed long int)0;
  signed int sectors;
  signed int seclen;
  seclen=burn_sector_length(t->mode);
  if(t->cdxa_conversion == 1)
    seclen = seclen + 8;

  if(!(t->source == ((struct burn_source *)NULL)))
  {
    signed long int return_value;
    return_value=t->source->get_size(t->source);
    size = (signed long int)t->offset + return_value + (signed long int)t->tail;
    if(!(t->postgap == 0))
    {
      if((1 & flag) == 0)
        size = size + (signed long int)t->postgap_size;

    }

  }

  else
    if(!(t->entry == ((struct burn_toc_entry *)NULL)))
    {
      if(!((1 & (signed int)t->entry->extensions_valid) == 0))
        size = (signed long int)t->entry->track_blocks * (signed long int)2048;

    }

  sectors = (signed int)(size / (signed long int)seclen);
  if(!(size % (signed long int)seclen == 0l))
    sectors = sectors + 1;

  return sectors;
}

// burn_track_get_shortage
// file libburn/structure.c line 654
signed int burn_track_get_shortage(struct burn_track *t)
{
  signed int size;
  signed int seclen;
  seclen=burn_sector_length(t->mode);
  signed long int return_value;
  return_value=t->source->get_size(t->source);
  size = (signed int)((signed long int)t->offset + return_value + (signed long int)t->tail);
  if(!(size % seclen == 0))
    return seclen - size % seclen;

  else
    return 0;
}

// burn_track_is_data_done
// file libburn/structure.c line 649
signed int burn_track_is_data_done(struct burn_track *t)
{
  return (signed int)!(!(t->track_data_done != 0));
}

// burn_track_is_open_ended
// file libburn/structure.h line 159
signed int burn_track_is_open_ended(struct burn_track *t)
{
  return (signed int)!(!(t->open_ended != 0));
}

// burn_track_set_byte_swap
// file libburn/structure.c line 358
signed int burn_track_set_byte_swap(struct burn_track *t, signed int swap_source_bytes)
{
  if(!(swap_source_bytes == 0) && !(swap_source_bytes == 1))
    return 0;

  else
  {
    t->swap_source_bytes = swap_source_bytes;
    return 1;
  }
}

// burn_track_set_cdtext
// file libburn/libburn.h line 2461
signed int burn_track_set_cdtext(struct burn_track *t, signed int block, signed int pack_type, char *pack_type_name, unsigned char *payload, signed int length, signed int flag)
{
  signed int ret;
  signed int return_value_burn_cdtext_check_blockno$1;
  return_value_burn_cdtext_check_blockno$1=burn_cdtext_check_blockno(block);
  if(!(return_value_burn_cdtext_check_blockno$1 >= 1))
    return 0;

  else
  {
    ret=burn_cdtext_set(&t->cdtext[(signed long int)block], pack_type, pack_type_name, payload, length, flag & 1);
    return ret;
  }
}

// burn_track_set_cdxa_conv
// file libburn/structure.c line 368
signed int burn_track_set_cdxa_conv(struct burn_track *t, signed int value)
{
  if(value >= 2 || !(value >= 0))
    return 0;

  else
  {
    t->cdxa_conversion = value;
    return 1;
  }
}

// burn_track_set_default_size
// file libburn/structure.c line 621
signed int burn_track_set_default_size(struct burn_track *t, signed long int size)
{
  t->default_size = size;
  return 1;
}

// burn_track_set_fillup
// file libburn/structure.c line 577
signed int burn_track_set_fillup(struct burn_track *t, signed int fill_up_media)
{
  t->fill_up_media = fill_up_media;
  if(!(fill_up_media == 0))
    t->open_ended = 0;

  return 1;
}

// burn_track_set_index
// file libburn/structure.c line 464
signed int burn_track_set_index(struct burn_track *t, signed int index_number, unsigned int relative_lba, signed int flag)
{
  if(index_number >= 100 || !(index_number >= 0))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x0002019a, 0x60000000, 0x30000000, "Bad track index number", 0, 0);
    return 0;
  }

  else
  {
    t->index[(signed long int)index_number] = (signed int)relative_lba;
    if(index_number >= (signed int)t->indices)
      t->indices = (unsigned char)(index_number + 1);

    return 1;
  }
}

// burn_track_set_isrc
// file libburn/structure.c line 377
void burn_track_set_isrc(struct burn_track *t, char *country, char *owner, unsigned char year, unsigned int serial)
{
  signed int i;
  t->isrc.has_isrc = 0;
  i = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  for( ; !(i >= 2); i = i + 1)
  {
    _Bool tmp_if_expr$1;
    if((signed int)country[(signed long int)i] >= 48)
      tmp_if_expr$1 = (signed int)country[(signed long int)i] <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if((signed int)country[(signed long int)i] >= 97)
        tmp_if_expr$2 = (signed int)country[(signed long int)i] <= 122 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if((signed int)country[(signed long int)i] >= 65)
        tmp_if_expr$4 = (signed int)country[(signed long int)i] <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$5)
      goto is_not_allowed;

    t->isrc.country[(signed long int)i] = country[(signed long int)i];
  }
  i = 0;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$9;
  for( ; !(i >= 3); i = i + 1)
  {
    _Bool tmp_if_expr$6;
    if((signed int)owner[(signed long int)i] >= 48)
      tmp_if_expr$6 = (signed int)owner[(signed long int)i] <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    _Bool tmp_if_expr$8;
    if(tmp_if_expr$6)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      if((signed int)owner[(signed long int)i] >= 97)
        tmp_if_expr$7 = (signed int)owner[(signed long int)i] <= 122 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$10;
    if(tmp_if_expr$8)
      tmp_if_expr$10 = (_Bool)1;

    else
    {
      if((signed int)owner[(signed long int)i] >= 65)
        tmp_if_expr$9 = (signed int)owner[(signed long int)i] <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$9 = (_Bool)0;
      tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$10)
      goto is_not_allowed;

    t->isrc.owner[(signed long int)i] = owner[(signed long int)i];
  }
  if(!((signed int)year >= 100))
  {
    t->isrc.year = year;
    if(serial >= 100000u)
      goto is_not_allowed;

    t->isrc.serial = serial;
    t->isrc.has_isrc = 1;
  }

  else
  {

  is_not_allowed:
    ;
    libdax_msgs_submit(libdax_messenger, -1, 0x00020114, 0x60000000, 0x30000000, "Attempt to set ISRC with bad data", 0, 0);
    goto __CPROVER_DUMP_L26;
  }

__CPROVER_DUMP_L26:
  ;
}

// burn_track_set_isrc_string
// file libburn/libburn.h line 2541
signed int burn_track_set_isrc_string(struct burn_track *t, char *isrc, signed int flag)
{
  unsigned char year;
  unsigned int serial = (unsigned int)2000000000;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(isrc);
  _Bool tmp_if_expr$2;
  if(!(return_value_strlen$1 == 12ul))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)isrc[(signed long int)5] < 48 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)isrc[(signed long int)5] > 57 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed int)isrc[(signed long int)6] < 48 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = (signed int)isrc[(signed long int)6] > 57 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020114, 0x60000000, 0x30000000, "Attempt to set ISRC with bad data", 0, 0);
    return 0;
  }

  else
  {
    year = (unsigned char)(((signed int)isrc[(signed long int)5] - 48) * 10 + ((signed int)isrc[(signed long int)6] - 48));
    isrc[(signed long int)12] = (char)0;
    __isoc99_sscanf(isrc + (signed long int)7, "%u", &serial);
    burn_track_set_isrc(t, isrc, isrc + (signed long int)2, year, serial);
    return t->isrc.has_isrc;
  }
}

// burn_track_set_postgap_size
// file libburn/structure.c line 502
signed int burn_track_set_postgap_size(struct burn_track *t, signed int size, signed int flag)
{
  t->postgap = (signed int)(size >= 0);
  t->postgap_size = size;
  return 1;
}

// burn_track_set_pregap_size
// file libburn/structure.c line 494
signed int burn_track_set_pregap_size(struct burn_track *t, signed int size, signed int flag)
{
  t->pregap2 = (signed int)(size >= 0);
  t->pregap2_size = size;
  return 1;
}

// burn_track_set_sectors
// file libburn/structure.c line 549
signed int burn_track_set_sectors(struct burn_track *t, signed int sectors)
{
  signed long int size;
  signed long int seclen;
  signed int ret;
  signed int return_value_burn_sector_length$1;
  return_value_burn_sector_length$1=burn_sector_length(t->mode);
  seclen = (signed long int)return_value_burn_sector_length$1;
  size = (seclen * (signed long int)sectors - (signed long int)t->offset) - (signed long int)t->tail;
  if(!(size >= 0l))
    return 0;

  else
  {
    ret=t->source->set_size(t->source, size);
    signed long int return_value;
    return_value=t->source->get_size(t->source);
    t->open_ended = (signed int)(return_value <= (signed long int)0);
    return ret;
  }
}

// burn_track_set_size
// file libburn/structure.c line 565
signed int burn_track_set_size(struct burn_track *t, signed long int size)
{
  if(t->source == ((struct burn_source *)NULL))
    return 0;

  else
    if(t->source->set_size == ((signed int (*)(struct burn_source *, signed long int))NULL))
      return 0;

    else
    {
      t->open_ended = (signed int)(size <= (signed long int)0);
      signed int return_value;
      return_value=t->source->set_size(t->source, size);
      return return_value;
    }
}

// burn_track_set_source
// file libburn/source.c line 29
enum burn_source_status burn_track_set_source(struct burn_track *t, struct burn_source *s)
{
  s->refcount = s->refcount + 1;
  t->source = s;
  signed long int return_value;
  return_value=s->get_size(s);
  t->open_ended = (signed int)(return_value <= (signed long int)0);
  return (enum burn_source_status)BURN_SOURCE_OK;
}

// burn_util_make_printable_word
// file libburn/util.h line 10
signed int burn_util_make_printable_word(char **text, signed int flag)
{
  signed int i;
  signed int esc_add = 0;
  signed int ret;
  char *wpt;
  char *rpt;
  char *new_text = (char *)(void *)0;
  if(!((2 & flag) == 0))
    flag = flag & ~1;

  i = 0;
  _Bool tmp_if_expr$3;
  for( ; !((*text)[(signed long int)i] == 0); i = i + 1)
  {
    rpt = *text + (signed long int)i;
    _Bool tmp_if_expr$1;
    if(!((signed int)*rpt >= 32))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)*rpt > 126 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)*rpt == 96 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$2)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      if((signed int)*rpt == 95)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*rpt == 37 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$4 = (tmp_if_expr$3 ? (!((flag & 2) != 0) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = ((signed int)*rpt == 47 ? ((flag & 1) != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      esc_add = esc_add + 2;

  }
  _Bool tmp_if_expr$11;
  if(!(esc_add == 0))
  {
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(*text);
    void *return_value_calloc$7;
    return_value_calloc$7=calloc(return_value_strlen$6 + (unsigned long int)esc_add + (unsigned long int)1, (unsigned long int)1);
    new_text = (char *)return_value_calloc$7;
    if(new_text == ((char *)NULL))
    {
      ret = -1;
      goto ex;
    }

    wpt = new_text;
    i = 0;
    for( ; !((*text)[(signed long int)i] == 0); i = i + 1)
    {
      rpt = *text + (signed long int)i;
      _Bool tmp_if_expr$9;
      if(!((signed int)*rpt >= 32))
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = (signed int)*rpt > 126 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$10;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = (signed int)*rpt == 96 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$12;
      if(tmp_if_expr$10)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        if((signed int)*rpt == 95)
          tmp_if_expr$11 = (_Bool)1;

        else
          tmp_if_expr$11 = (signed int)*rpt == 37 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$12 = (tmp_if_expr$11 ? (!((flag & 2) != 0) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr$13;
      if(tmp_if_expr$12)
        tmp_if_expr$13 = (_Bool)1;

      else
        tmp_if_expr$13 = ((signed int)*rpt == 47 ? ((flag & 1) != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$13)
      {
        sprintf(wpt, "%%%2.2X", (unsigned int)*((unsigned char *)rpt));
        wpt = wpt + (signed long int)3;
      }

      else
      {
        char *tmp_post$8 = wpt;
        wpt = wpt + 1l;
        *tmp_post$8 = *rpt;
      }
    }
    *wpt = (char)0;
    free((void *)*text);
    *text = new_text;
  }

  if((2 & flag) == 0)
  {
    i = 0;
    for( ; !((*text)[(signed long int)i] == 0); i = i + 1)
      if((signed int)(*text)[(signed long int)i] == 32)
        (*text)[(signed long int)i] = (char)95;

  }

  ret = 1;

ex:
  ;
  return ret;
}

// burn_util_thread_id
// file libburn/init.c line 368
char * burn_util_thread_id(signed int pid, unsigned long int tid, char *text)
{
  signed int i;
  signed int l;
  signed int return_value_getpid$1;
  return_value_getpid$1=getpid();
  sprintf(text, "[%lu,", (unsigned long int)return_value_getpid$1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(text);
  l = (signed int)return_value_strlen$2;
  i = 0;
  for( ; !(2 * i >= 80 + -l + -3) && !(i >= (signed int)sizeof(unsigned long int) /*8*/ ); i = i + 1)
    sprintf(text + (signed long int)l + (signed long int)(2 * i), "%2.2X", ((unsigned char *)&tid)[(signed long int)i]);
  sprintf(text + (signed long int)l + (signed long int)(2 * i), "]");
  return text;
}

// burn_version
// file libburn/util.c line 33
void burn_version(signed int *major, signed int *minor, signed int *micro)
{
  *major = 1;
  *minor = 4;
  *micro = 2;
}

// burn_write_close_session
// file libburn/write.c line 287
signed int burn_write_close_session(struct burn_write_opts *o)
{
  libdax_msgs_submit(libdax_messenger, o->drive->global_index, 0x00020119, 0x10000000, 0x30000000, "Closing session", 0, 0);
  o->drive->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_SESSION;
  o->drive->close_track_session(o->drive, 1, 0);
  o->drive->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_write_close_track
// file libburn/write.c line 253
signed int burn_write_close_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum)
{
  char msg[81l];
  struct burn_drive *d = o->drive;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_CLOSING_TRACK;
  sprintf(msg, "Closing track %2.2d", tnum + 1);
  libdax_msgs_submit(libdax_messenger, o->drive->global_index, 0x00020119, 0x10000000, 0x30000000, msg, 0, 0);
  d->close_track_session(o->drive, 0, 0xff);
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_write_flush
// file libburn/write.c line 195
signed int burn_write_flush(struct burn_write_opts *o, struct burn_track *track)
{
  signed int ret;
  struct burn_drive *d = o->drive;
  ret=burn_write_flush_buffer(o, track);
  if(!(ret >= 1))
    return ret;

  else
  {
    d->sync_cache(d);
    return 1;
  }
}

// burn_write_flush_buffer
// file libburn/write.c line 170
signed int burn_write_flush_buffer(struct burn_write_opts *o, struct burn_track *track)
{
  struct burn_drive *d = o->drive;
  if(!(d->buffer->bytes == 0))
  {
    if(d->cancel == 0)
    {
      signed int err;
      err=d->write(d, d->nwa, d->buffer);
      if(err == 1)
        return 0;

      if(!(track == ((struct burn_track *)NULL)))
      {
        track->writecount = track->writecount + (signed long int)d->buffer->bytes;
        track->written_sectors = track->written_sectors + (signed long int)d->buffer->sectors;
      }

      d->progress.buffered_bytes = d->progress.buffered_bytes + (signed long int)d->buffer->bytes;
      d->nwa = d->nwa + d->buffer->sectors;
      d->buffer->bytes = 0;
      d->buffer->sectors = 0;
    }

  }

  return 1;
}

// burn_write_leadin
// file libburn/write.c line 854
signed int burn_write_leadin(struct burn_write_opts *o, struct burn_session *s, signed int first)
{
  struct burn_drive *d = o->drive;
  signed int count;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING_LEADIN;
  if(!(first == 0))
    count = (0 - d->alba) - 150;

  else
    count = 4500;
  d->progress.start_sector = d->alba;
  d->progress.sectors = count;
  d->progress.sector = 0;
  while(!(count == 0))
  {
    signed int return_value_sector_toc$1;
    return_value_sector_toc$1=sector_toc(o, s->track[(signed long int)0]->mode);
    if(return_value_sector_toc$1 == 0)
      return 0;

    count = count - 1;
    d->progress.sector = d->progress.sector + 1;
  }
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_write_leadin_cdtext
// file libburn/write.c line 927
static signed int burn_write_leadin_cdtext(struct burn_write_opts *o, struct burn_session *s, signed int flag)
{
  signed int ret;
  signed int i;
  signed int j;
  signed int si;
  signed int lba;
  signed int sub_cursor = 0;
  signed int err;
  signed int write_lba;
  signed int sectors = 0;
  signed int self_made_text_packs = 0;
  unsigned char *subdata = (unsigned char *)(void *)0;
  struct burn_drive *d = o->drive;
  struct buffer *buf = (struct buffer *)(void *)0;
  enum burn_drive_status was_busy = o->drive->busy;
  if(!(o->num_text_packs >= 1))
  {
    if(!(o->text_packs == ((unsigned char *)NULL)))
    {
      ret = 1;
      goto ex;
    }

    ret=burn_create_text_packs(o, s, 0);
    self_made_text_packs = 1;
    if(!(ret >= 1))
      goto ex;

    if(o->num_text_packs >= 1)
      goto __CPROVER_DUMP_L2;

    ret = 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(o->no_text_pack_crc_check == 0)
    {
      ret=burn_cdtext_crc_mismatches(o->text_packs, o->num_text_packs, 0);
      if(ret == 0)
        goto __CPROVER_DUMP_L3;

      libdax_msgs_submit(libdax_messenger, -1, 0x0002018f, 0x68000000, 0x30000000, "Program error: CD-TEXT pack CRC mismatch", 0, 0);
      ret = 0;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING_LEADIN;
      void *return_value_burn_alloc_mem$1;
      return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(unsigned char) /*1ul*/ , (unsigned long int)(o->num_text_packs * 24), 0);
      subdata = (unsigned char *)return_value_burn_alloc_mem$1;
      if(subdata == ((unsigned char *)NULL))
        ret = -1;

      else
      {
        i = 0;
        for( ; !(i >= 18 * o->num_text_packs); i = i + 3)
        {
          si = (i / 3) * 4;
          subdata[(signed long int)(si + 0)] = (unsigned char)((signed int)o->text_packs[(signed long int)(i + 0)] >> 2 & 0x3f);
          subdata[(signed long int)(si + 1)] = (unsigned char)((signed int)o->text_packs[(signed long int)(i + 0)] << 4 & 0x30);
          subdata[(signed long int)(si + 1)] = subdata[(signed long int)(si + 1)] | (unsigned char)((signed int)o->text_packs[(signed long int)(i + 1)] >> 4 & 0x0f);
          subdata[(signed long int)(si + 2)] = (unsigned char)((signed int)o->text_packs[(signed long int)(i + 1)] << 2 & 0x3c);
          subdata[(signed long int)(si + 2)] = subdata[(signed long int)(si + 2)] | (unsigned char)((signed int)o->text_packs[(signed long int)(i + 2)] >> 6 & 0x03);
          subdata[(signed long int)(si + 3)] = (unsigned char)((signed int)o->text_packs[(signed long int)(i + 2)] >> 0 & 0x3f);
        }
        void *return_value_burn_alloc_mem$2;
        return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
        buf = (struct buffer *)return_value_burn_alloc_mem$2;
        if(buf == ((struct buffer *)NULL))
          ret = -1;

        else
        {
          write_lba = d->start_lba;
          lba = d->start_lba;
          for( ; !(lba >= -150); lba = lba + 1)
          {
            j = 0;
            for( ; !(j >= 4); j = j + 1)
            {
              memcpy((void *)(buf->data + (signed long int)buf->bytes), (const void *)(subdata + (signed long int)(sub_cursor * 24)), (unsigned long int)24);
              sub_cursor = (sub_cursor + 1) % o->num_text_packs;
              buf->bytes = buf->bytes + 24;
            }
            buf->sectors = buf->sectors + 1;
            sectors = sectors + 1;
            if(lba == -151 || 96 + buf->bytes >= 32768)
            {
              err=d->write(d, write_lba, buf);
              if(err == 1)
                ret = 0;

              write_lba = write_lba + sectors;
              buf->bytes = 0;
              buf->sectors = buf->bytes;
              sectors = buf->sectors;
            }

          }
          ret = 1;
        }
      }
    }
  }

ex:
  ;
  if(!(self_made_text_packs == 0))
  {
    if(!(o->text_packs == ((unsigned char *)NULL)))
      free((void *)o->text_packs);

    o->text_packs = (unsigned char *)(void *)0;
    o->num_text_packs = 0;
  }

  if(!(subdata == ((unsigned char *)NULL)))
    free((void *)(char *)subdata);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  d->busy = was_busy;
  return ret;
}

// burn_write_leadout
// file libburn/write.c line 881
signed int burn_write_leadout(struct burn_write_opts *o, signed int first, unsigned char control, signed int mode)
{
  struct burn_drive *d = o->drive;
  signed int count;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING_LEADOUT;
  d->rlba = -150;
  if(!(first == 0))
    count = 6750;

  else
    count = 2250;
  d->progress.start_sector = d->alba;
  d->progress.sectors = count;
  d->progress.sector = 0;
  while(!(count == 0))
  {
    signed int return_value_sector_lout$1;
    return_value_sector_lout$1=sector_lout(o, control, mode);
    if(return_value_sector_lout$1 == 0)
      return 0;

    count = count - 1;
    d->progress.sector = d->progress.sector + 1;
  }
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING;
  return 1;
}

// burn_write_opts_auto_write_type
// file libburn/options.c line 303
enum burn_write_types burn_write_opts_auto_write_type(struct burn_write_opts *opts, struct burn_disc *disc, char *reasons, signed int flag)
{
  struct burn_multi_caps *caps = (struct burn_multi_caps *)(void *)0;
  struct burn_drive *d = opts->drive;
  struct burn_disc_mode_demands demands;
  enum burn_write_types wt;
  signed int ret;
  signed int would_do_sao = 0;
  char *reason_pt;
  reasons[(signed long int)0] = (char)0;
  unsigned long int return_value_strlen$1;
  signed int return_value_strcmp$4;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$7;
  signed int return_value_strcmp$8;
  unsigned long int return_value_strlen$9;
  signed int return_value_strcmp$10;
  if(!((signed int)d->status == BURN_DISC_BLANK))
  {
    if((signed int)d->status == BURN_DISC_APPENDABLE)
      goto __CPROVER_DUMP_L4;

    if((signed int)d->status == BURN_DISC_FULL)
      strcat(reasons, "MEDIA: closed or not recordable, ");

    else
      strcat(reasons, "MEDIA: no writeable media detected, ");
    if((3 & flag) == 0)
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002013a, 0x70000000, 0x30000000, "No suitable media detected", 0, 0);

    return (enum burn_write_types)BURN_WRITE_NONE;
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    ret=burn_disc_get_write_mode_demands(disc, opts, &demands, (signed int)!(!(opts->fill_up_media != 0)));
    if(!(ret >= 1))
    {
      strcat(reasons, "cannot recognize job demands, ");
      wt = (enum burn_write_types)BURN_WRITE_NONE;
    }

    else
      if(!(demands.exotic_track == 0))
      {
        if(!(d->current_is_cd_profile == 0))
          goto __CPROVER_DUMP_L8;

        if(!(demands.audio == 0))
          strcat(reasons, "audio track prohibited by non-CD, ");

        else
          strcat(reasons, "exotic track prohibited by non-CD, ");
        wt = (enum burn_write_types)BURN_WRITE_NONE;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if(!((1 & flag) == 0))
        {
          if(!((signed int)opts->write_type == BURN_WRITE_SAO))
            goto try_tao;

        }

        return_value_strlen$1=strlen(reasons);
        reason_pt = reasons + (signed long int)return_value_strlen$1;
        strcat(reasons, "SAO: ");
        if(!((signed int)d->status == BURN_DISC_BLANK))
          strcat(reasons, "write type SAO works only on blank media, ");

        else
        {
          burn_disc_free_multi_caps(&caps);
          ret=burn_disc_get_multi_caps(d, (enum burn_write_types)BURN_WRITE_SAO, &caps, 0);
          if(!(ret >= 0))
          {

          no_caps:
            ;
            strcat(reasons, "cannot inquire write mode capabilities, ");
            wt = (enum burn_write_types)BURN_WRITE_NONE;
            goto ex;
          }

          else
            if(ret == 0)
            {
              strcat(reasons, "no SAO offered by drive and media, ");
              goto no_sao;
            }

          if(!(opts->multi == 0) || !(demands.multi_session == 0))
          {
            if(caps->multi_session == 0)
              strcat(reasons, "multi session capability lacking, ");

          }

          if(!(demands.will_append == 0))
            strcat(reasons, "appended session capability lacking, ");

          if(!(demands.multi_track == 0))
          {
            if(caps->multi_track == 0)
              strcat(reasons, "multi track capability lacking, ");

          }

          if(demands.unknown_track_size == 1)
          {
            _Bool tmp_if_expr$2;
            if(caps->might_do_sao == 1)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = caps->might_do_sao == 3 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              strcat(reasons, "track size unpredictable, ");

          }

          if(!(demands.mixed_mode == 0))
            strcat(reasons, "tracks of different modes mixed, ");

          _Bool tmp_if_expr$3;
          if(!(demands.exotic_track == 0))
            tmp_if_expr$3 = !(d->current_is_cd_profile != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
            strcat(reasons, "non-data track on non-cd, ");

          else
            if(!(d->current_is_cd_profile == 0))
            {
              if(!((d->block_types[1l] & demands.block_types) == demands.block_types))
                strcat(reasons, "drive dislikes block type, ");

            }

          if(!(d->current_is_cd_profile == 0))
          {
            if(!(opts->fill_up_media == 0))
              strcat(reasons, "cd sao cannot do media fill up yet, ");

          }

          return_value_strcmp$4=strcmp(reason_pt, "SAO: ");
          if(return_value_strcmp$4 == 0)
          {
            would_do_sao = 1;
            _Bool tmp_if_expr$6;
            if((1 & flag) == 0 && demands.unknown_track_size == 2)
            {
              if(caps->might_do_sao == 1)
                tmp_if_expr$5 = (_Bool)1;

              else
                tmp_if_expr$5 = caps->might_do_sao == 3 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$6 = (_Bool)0;
            if(tmp_if_expr$6)
            {
              strcat(reasons, "would have to use default track sizes, ");
              goto no_sao;
            }

            else
              if(caps->might_do_sao >= 3)
              {
                if((1 & flag) == 0)
                  goto try_tao;

              }


          do_sao:
            ;
            if(caps->might_simulate == 0)
            {
              if(!(opts->simulate == 0u))
              {
                if(opts->force_is_set == 0)
                  goto no_simulate;

              }

            }

            if((1 & flag) == 0)
              burn_write_opts_set_write_type(opts, (enum burn_write_types)BURN_WRITE_SAO, BURN_BLOCK_SAO);

            wt = (enum burn_write_types)BURN_WRITE_SAO;
            goto ex;
          }

        }

      no_sao:
        ;

      try_tao:
        ;
        if(opts->num_text_packs >= 1)
        {
          strcat(reasons, "CD-TEXT: write type SAO required, ");
          wt = (enum burn_write_types)BURN_WRITE_NONE;
        }

        else
        {
          if(!((1 & flag) == 0))
          {
            if(!((signed int)opts->write_type == BURN_WRITE_TAO))
              goto try_raw;

          }

          return_value_strlen$7=strlen(reasons);
          reason_pt = reasons + (signed long int)return_value_strlen$7;
          strcat(reasons, "TAO: ");
          burn_disc_free_multi_caps(&caps);
          ret=burn_disc_get_multi_caps(d, (enum burn_write_types)BURN_WRITE_TAO, &caps, 0);
          if(!(ret >= 0))
            goto no_caps;

          if(ret == 0)
            strcat(reasons, "no TAO offered by drive and media, ");

          else
          {
            if(!(opts->multi == 0) || !(demands.multi_session == 0))
            {
              if(caps->multi_session == 0)
                strcat(reasons, "multi session capability lacking, ");

            }

            if(!(demands.multi_track == 0))
            {
              if(caps->multi_track == 0)
                strcat(reasons, "multi track capability lacking, ");

            }

            if(!(demands.exotic_track == 0))
            {
              if(d->current_is_cd_profile == 0)
                strcat(reasons, "non-data track on non-cd, ");

            }

            if(!(d->current_is_cd_profile == 0))
            {
              if(opts->force_is_set == 0)
              {
                if(!((d->block_types[1l] & demands.block_types) == demands.block_types))
                  strcat(reasons, "drive dislikes block type, ");

              }

            }

            return_value_strcmp$8=strcmp(reason_pt, "TAO: ");
            if(return_value_strcmp$8 == 0)
            {
              if(caps->might_simulate == 0)
              {
                if(!(opts->simulate == 0u))
                {
                  if(opts->force_is_set == 0)
                    goto no_simulate;

                }

              }

              if((1 & flag) == 0)
                burn_write_opts_set_write_type(opts, (enum burn_write_types)BURN_WRITE_TAO, BURN_BLOCK_MODE1);

              wt = (enum burn_write_types)BURN_WRITE_TAO;
              goto ex;
            }

          }

        no_tao:
          ;
          if((1 & flag) == 0 && !(would_do_sao == 0))
            goto do_sao;

          if(!(d->current_is_cd_profile == 0))
          {

          try_raw:
            ;
            if(!((1 & flag) == 0))
            {
              if(!((signed int)opts->write_type == BURN_WRITE_RAW))
                goto no_write_mode;

            }

            if((1 & flag) == 0)
              goto no_write_mode;

            return_value_strlen$9=strlen(reasons);
            reason_pt = reasons + (signed long int)return_value_strlen$9;
            strcat(reasons, "RAW: ");
            if(d->current_is_cd_profile == 0)
              strcat(reasons, "write type RAW prohibited by non-cd, ");

            else
              if(!((signed int)d->status == BURN_DISC_BLANK))
                strcat(reasons, "write type RAW works only on blank media, ");

              else
                if(!((d->block_types[1l] & demands.block_types) == demands.block_types))
                  strcat(reasons, "drive dislikes block type, ");

            return_value_strcmp$10=strcmp(reason_pt, "RAW: ");
            if(!(return_value_strcmp$10 == 0))
              goto no_write_mode;

            if(opts->force_is_set == 0)
              goto no_simulate;

            wt = (enum burn_write_types)BURN_WRITE_RAW;
          }

          else
          {

          no_write_mode:
            ;
            wt = (enum burn_write_types)BURN_WRITE_NONE;
            goto ex;

          no_simulate:
            ;
            strcat(reasons, "simulation of write job not supported by drive and media, ");
            wt = (enum burn_write_types)BURN_WRITE_NONE;
          }
        }
      }

  ex:
    ;
    burn_disc_free_multi_caps(&caps);
    if((3 & flag) == 0 && (signed int)wt == BURN_WRITE_NONE)
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002012b, 0x60000000, 0x30000000, "Drive offers no suitable write mode with this job", 0, 0);

    return wt;
  }
}

// burn_write_opts_clone
// file libburn/options.c line 83
signed int burn_write_opts_clone(struct burn_write_opts *from, struct burn_write_opts **to, signed int flag)
{
  if(!(*to == ((struct burn_write_opts *)NULL)))
    burn_write_opts_free(*to);

  if(from == ((struct burn_write_opts *)NULL))
    return 1;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_write_opts) /*128ul*/ );
    *to = (struct burn_write_opts *)return_value_calloc$1;
    if(*to == ((struct burn_write_opts *)NULL))
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00000003, 0x70000000, 0x30000000, "Out of virtual memory", 0, 0);
      return -1;
    }

    else
    {
      memcpy((void *)*to, (const void *)from, sizeof(struct burn_write_opts) /*128ul*/ );
      (*to)->refcount = 1;
      return 1;
    }
  }
}

// burn_write_opts_free
// file test/../libburn/libburn.h line 1661
void burn_write_opts_free(struct burn_write_opts *opts)
{
  opts->refcount = opts->refcount - 1;
  if(!(opts->refcount >= 1))
  {
    if(!(opts->text_packs == ((unsigned char *)NULL)))
      free((void *)opts->text_packs);

    free((void *)opts);
  }

}

// burn_write_opts_get_drive
// file libburn/options.c line 538
struct burn_drive * burn_write_opts_get_drive(struct burn_write_opts *opts)
{
  return opts->drive;
}

// burn_write_opts_new
// file test/../libburn/libburn.h line 1646
struct burn_write_opts * burn_write_opts_new(struct burn_drive *drive)
{
  struct burn_write_opts *opts;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct burn_write_opts) /*128ul*/ );
  opts = (struct burn_write_opts *)return_value_calloc$1;
  if(opts == ((struct burn_write_opts *)NULL))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020111, 0x70000000, 0x30000000, "Could not allocate new auxiliary object", 0, 0);
    return (struct burn_write_opts *)(void *)0;
  }

  else
  {
    opts->drive = drive;
    opts->refcount = 1;
    opts->write_type = (enum burn_write_types)BURN_WRITE_TAO;
    opts->block_type = (enum burn_block_types)BURN_BLOCK_MODE1;
    opts->toc_entry = (struct burn_toc_entry *)(void *)0;
    opts->toc_entries = 0;
    opts->simulate = (unsigned int)0;
    _Bool tmp_if_expr$2;
    if(drive->mdata->p2a_valid >= 1)
      tmp_if_expr$2 = drive->mdata->underrun_proof != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    opts->underrun_proof = (unsigned int)tmp_if_expr$2;
    opts->perform_opc = (unsigned int)1;
    opts->obs = -1;
    opts->obs_pad = 0;
    opts->start_byte = (signed long int)-1;
    opts->fill_up_media = 0;
    opts->force_is_set = 0;
    opts->do_stream_recording = 0;
    opts->dvd_obs_override = 0;
    opts->stdio_fsync_size = 8192;
    opts->text_packs = (unsigned char *)(void *)0;
    opts->num_text_packs = 0;
    opts->no_text_pack_crc_check = 0;
    opts->has_mediacatalog = 0;
    opts->format = 0;
    opts->multi = (unsigned char)0;
    opts->control = (unsigned char)0;
    return opts;
  }
}

// burn_write_opts_set_dvd_obs
// file libburn/options.c line 508
void burn_write_opts_set_dvd_obs(struct burn_write_opts *opts, signed int obs)
{
  if(obs == 0 || obs == 32 || obs == 64)
    opts->dvd_obs_override = obs;

}

// burn_write_opts_set_fail21h_sev
// file libburn/options.c line 218
void burn_write_opts_set_fail21h_sev(struct burn_write_opts *opts, char *severity)
{
  signed int ret;
  signed int sevno;
  ret=libdax_msgs__text_to_sev(severity, &sevno, 0);
  if(!(ret >= 1))
    opts->feat21h_fail_sev = 0;

  else
    opts->feat21h_fail_sev = sevno;
}

// burn_write_opts_set_fillup
// file libburn/options.c line 485
void burn_write_opts_set_fillup(struct burn_write_opts *opts, signed int fill_up_media)
{
  opts->fill_up_media = (signed int)!(!(fill_up_media != 0));
}

// burn_write_opts_set_force
// file libburn/options.c line 493
void burn_write_opts_set_force(struct burn_write_opts *opts, signed int use_force)
{
  opts->force_is_set = (signed int)!(!(use_force != 0));
}

// burn_write_opts_set_format
// file libburn/options.c line 169
void burn_write_opts_set_format(struct burn_write_opts *opts, signed int format)
{
  opts->format = format;
}

// burn_write_opts_set_has_mediacatalog
// file libburn/options.c line 196
void burn_write_opts_set_has_mediacatalog(struct burn_write_opts *opts, signed int has_mediacatalog)
{
  opts->has_mediacatalog = has_mediacatalog;
}

// burn_write_opts_set_leadin_text
// file libburn/options.c line 236
signed int burn_write_opts_set_leadin_text(struct burn_write_opts *opts, unsigned char *text_packs, signed int num_packs, signed int flag)
{
  signed int ret;
  unsigned char *pack_buffer = (unsigned char *)(void *)0;
  if(num_packs >= 2049)
  {
    libdax_msgs_submit(libdax_messenger, opts->drive->global_index, 0x0002018b, 0x68000000, 0x30000000, "Too many CD-TEXT packs", 0, 0);
    ret = 0;
  }

  else
  {
    if(num_packs >= 1)
    {
      void *return_value_burn_alloc_mem$1;
      return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(unsigned char) /*1ul*/ , (unsigned long int)(num_packs * 18), 0);
      pack_buffer = (unsigned char *)return_value_burn_alloc_mem$1;
      if(pack_buffer == ((unsigned char *)NULL))
      {
        ret = -1;
        goto ex;
      }

    }

    if(!(opts->text_packs == ((unsigned char *)NULL)))
    {
      free((void *)opts->text_packs);
      opts->text_packs = (unsigned char *)(void *)0;
    }

    if(!((1 & flag) == 0))
      opts->no_text_pack_crc_check = 1;

    else
    {
      opts->no_text_pack_crc_check = 0;
      ret=burn_cdtext_crc_mismatches(text_packs, num_packs, flag >> 1 & 3);
      if(ret >= 1)
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x0002018f, 0x68000000, 0x30000000, "CD-TEXT pack CRC mismatch", 0, 0);
        ret = 0;
        goto ex;
      }

      else
        if(!(ret >= 0))
          libdax_msgs_submit(libdax_messenger, -1, 0x00020190, 0x50000000, 0x30000000, "CD-TEXT pack CRC mismatch had to be corrected", 0, 0);

    }
    if(num_packs >= 1)
    {
      memcpy((void *)pack_buffer, (const void *)text_packs, (unsigned long int)(num_packs * 18));
      opts->text_packs = pack_buffer;
      pack_buffer = (unsigned char *)(void *)0;
    }

    opts->num_text_packs = num_packs;
    ret = 1;
  }

ex:
  ;
  if(!(pack_buffer == ((unsigned char *)NULL)))
    free((void *)(char *)pack_buffer);

  return ret;
}

// burn_write_opts_set_mediacatalog
// file libburn/options.c line 202
void burn_write_opts_set_mediacatalog(struct burn_write_opts *opts, unsigned char *mediacatalog)
{
  memcpy((void *)opts->mediacatalog, (const void *)mediacatalog, (unsigned long int)13);
}

// burn_write_opts_set_multi
// file libburn/options.c line 210
void burn_write_opts_set_multi(struct burn_write_opts *opts, signed int multi)
{
  opts->multi = (unsigned char)!(!(multi != 0));
}

// burn_write_opts_set_obs_pad
// file libburn/options.c line 517
void burn_write_opts_set_obs_pad(struct burn_write_opts *opts, signed int pad)
{
  opts->obs_pad = 2 * (signed int)!(!(pad != 0));
}

// burn_write_opts_set_perform_opc
// file test/../libburn/libburn.h line 3102
void burn_write_opts_set_perform_opc(struct burn_write_opts *opts, signed int opc)
{
  opts->perform_opc = (unsigned int)opc;
}

// burn_write_opts_set_simulate
// file libburn/options.c line 174
signed int burn_write_opts_set_simulate(struct burn_write_opts *opts, signed int sim)
{
  opts->simulate = (unsigned int)!(!(sim != 0));
  return 1;
}

// burn_write_opts_set_start_byte
// file libburn/options.c line 292
void burn_write_opts_set_start_byte(struct burn_write_opts *opts, signed long int value)
{
  opts->start_byte = value;
}

// burn_write_opts_set_stdio_fsync
// file libburn/options.c line 524
void burn_write_opts_set_stdio_fsync(struct burn_write_opts *opts, signed int rythm)
{
  if(rythm == -1)
    opts->stdio_fsync_size = -1;

  else
    if(rythm == 0)
      opts->stdio_fsync_size = 8192;

    else
      if(rythm == 1)
        opts->stdio_fsync_size = 0;

      else
        if(rythm >= 32)
          opts->stdio_fsync_size = rythm;

}

// burn_write_opts_set_stream_recording
// file libburn/options.c line 500
void burn_write_opts_set_stream_recording(struct burn_write_opts *opts, signed int value)
{
  opts->do_stream_recording = value;
}

// burn_write_opts_set_toc_entries
// file libburn/options.c line 160
void burn_write_opts_set_toc_entries(struct burn_write_opts *opts, signed int count, struct burn_toc_entry *toc_entries)
{
  opts->toc_entries = count;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)count, sizeof(struct burn_toc_entry) /*32ul*/ );
  opts->toc_entry = (struct burn_toc_entry *)return_value_calloc$1;
  memcpy((void *)opts->toc_entry, (const void *)&toc_entries, sizeof(struct burn_toc_entry) /*32ul*/  * (unsigned long int)count);
}

// burn_write_opts_set_underrun_proof
// file libburn/options.c line 180
signed int burn_write_opts_set_underrun_proof(struct burn_write_opts *opts, signed int underrun_proof)
{
  _Bool tmp_if_expr$1;
  if(!(opts->drive->mdata->p2a_valid >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = opts->drive->mdata->underrun_proof != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    opts->underrun_proof = (unsigned int)underrun_proof;
    return 1;
  }

  else
    return 0;
}

// burn_write_opts_set_write_type
// file test/../libburn/libburn.h line 3027
signed int burn_write_opts_set_write_type(struct burn_write_opts *opts, enum burn_write_types write_type, signed int block_type)
{
  _Bool tmp_if_expr$1;
  if(block_type == BURN_BLOCK_SAO && (signed int)write_type == BURN_WRITE_SAO)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (opts->drive->block_types[(signed long int)write_type] & block_type) != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {

  bad_combination:
    ;
    libdax_msgs_submit(libdax_messenger, -1, 0x00020112, 0x60000000, 0x30000000, "Bad combination of write_type and block_type", 0, 0);
    return 0;
  }

  else
  {
    signed int return_value_sector_get_outmode$2;
    return_value_sector_get_outmode$2=sector_get_outmode(write_type, (enum burn_block_types)block_type);
    if(return_value_sector_get_outmode$2 == -1)
      goto bad_combination;

    signed int return_value_spc_block_type$3;
    return_value_spc_block_type$3=spc_block_type((enum burn_block_types)block_type);
    if(return_value_spc_block_type$3 == -1)
      goto bad_combination;

    opts->write_type = write_type;
    opts->block_type = (enum burn_block_types)block_type;
    return 1;
  }
}

// burn_write_session
// file libburn/write.c line 1047
signed int burn_write_session(struct burn_write_opts *o, struct burn_session *s)
{
  struct burn_drive *d = o->drive;
  signed int i;
  signed int ret;
  if((signed int)o->write_type == BURN_WRITE_SAO)
  {
    ret=burn_write_leadin_cdtext(o, s, 0);
    if(!(ret >= 1))
      goto ex;

  }

  d->rlba = 0;
  i = 0;
  for( ; !(i >= s->tracks); i = i + 1)
  {
    signed int return_value_burn_write_track$1;
    return_value_burn_write_track$1=burn_write_track(o, s, i);
    if(return_value_burn_write_track$1 == 0)
    {
      ret = 0;
      goto ex;
    }

  }
  ret = 1;

ex:
  ;
  if((signed int)o->write_type == BURN_WRITE_TAO)
    burn_write_close_session(o);

  return ret;
}

// burn_write_track
// file libburn/write.c line 1104
signed int burn_write_track(struct burn_write_opts *o, struct burn_session *s, signed int tnum)
{
  struct burn_track *t = s->track[(signed long int)tnum];
  struct burn_drive *d = o->drive;
  signed int i;
  signed int tmp = 0;
  signed int open_ended = 0;
  signed int ret = 0;
  signed int nwa;
  signed int lba;
  signed int sectors;
  char msg[160l];
  d->rlba = -150;
  signed int return_value_sector_pregap$1;
  signed int return_value_sector_pregap$2;
  if(!((signed int)o->write_type == BURN_WRITE_TAO))
  {
    d->busy = (volatile enum burn_drive_status)BURN_DRIVE_WRITING_PREGAP;
    if(!(t->pregap1 == 0))
      d->rlba = d->rlba + 75;

    if(!(t->pregap2 == 0))
      d->rlba = d->rlba + t->pregap2_size;

    if(!(t->pregap1 == 0))
    {
      struct burn_track *pt;
      if(tnum == 0)
      {
        printf("first track should not have a pregap1\n");
        pt = t;
      }

      else
        pt = s->track[(signed long int)(tnum - 1)];
      i = 0;
      for( ; !(i >= 75); i = i + 1)
      {
        return_value_sector_pregap$1=sector_pregap(o, t->entry->point, pt->entry->control, pt->mode);
        if(return_value_sector_pregap$1 == 0)
        {
          ret = 0;
          goto ex;
        }

      }
    }

    if(!(t->pregap2 == 0))
    {
      i = 0;
      for( ; !(i >= t->pregap2_size); i = i + 1)
      {
        return_value_sector_pregap$2=sector_pregap(o, t->entry->point, t->entry->control, t->mode);
        if(return_value_sector_pregap$2 == 0)
        {
          ret = 0;
          goto ex;
        }

      }
    }

    ret=sector_write_buffer(d, (struct burn_track *)(void *)0, 0);
    if(!(ret >= 1))
      goto ex;

  }

  else
  {
    o->control = t->entry->control;
    d->send_write_parameters(d, s, tnum, o);
    ret=d->get_nwa(d, -1, &lba, &nwa);
    burn_track_apply_fillup(t, d->media_capacity_remaining, 0);
    signed int return_value_burn_track_get_sectors_2$3;
    return_value_burn_track_get_sectors_2$3=burn_track_get_sectors_2(t, 1);
    sprintf(msg, "TAO pre-track %2.2d : get_nwa(%d)=%d, d=%d , demand=%.f , cap=%.f\n", tnum + 1, nwa, ret, d->nwa, (double)return_value_burn_track_get_sectors_2$3 * 2048.0, (double)d->media_capacity_remaining);
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
    if(!(nwa >= d->nwa))
    {
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020173, 0x68000000, 0x30000000, "Drive tells NWA smaller than last written address", 0, 0);
      d->sync_cache(d);
      return 0;
    }

    d->nwa = nwa;
  }
  sectors=burn_track_get_sectors_2(t, 1);
  open_ended=burn_track_is_open_ended(t);
  burn_disc_init_track_status(o, s, t, tnum, sectors);
  if(tnum == s->tracks)
    tmp = sectors > 150 ? 150 : sectors;

  i = 0;
  for( ; !(open_ended == 0) || !(i >= sectors + -tmp); i = i + 1)
  {
    if(i % 64 == 0)
      d->read_buffer_capacity(d);

    signed int return_value_sector_data$4;
    return_value_sector_data$4=sector_data(o, t, 0);
    if(return_value_sector_data$4 == 0)
    {
      ret = 0;
      goto ex;
    }

    if(!(open_ended == 0))
    {
      sectors = i;
      d->progress.sectors = sectors;
      signed int return_value_burn_track_is_data_done$5;
      return_value_burn_track_is_data_done$5=burn_track_is_data_done(t);
      if(!(return_value_burn_track_is_data_done$5 == 0))
        break;

    }

    d->progress.sector = d->progress.sector + 1;
  }
  for( ; !(i >= sectors); i = i + 1)
  {
    fprintf(stderr, "LIBBURN_DEBUG: TNUM=%d  TRACKS=%d  TMP=%d\n", tnum, s->tracks, tmp);
    if(i % 64 == 0)
      d->read_buffer_capacity(d);

    signed int return_value_sector_data$6;
    return_value_sector_data$6=sector_data(o, t, 1);
    if(return_value_sector_data$6 == 0)
    {
      ret = 0;
      goto ex;
    }

    d->progress.sector = d->progress.sector + 1;
  }
  ret=sector_write_buffer(d, t, 0);
  signed int return_value_sector_postgap$7;
  if(ret >= 1)
  {
    if(!(t->postgap == 0))
    {
      if(!((signed int)o->write_type == BURN_WRITE_TAO))
      {
        i = 0;
        for( ; !(i >= t->postgap_size); i = i + 1)
        {
          return_value_sector_postgap$7=sector_postgap(o, t->entry->point, t->entry->control, t->mode);
          if(return_value_sector_postgap$7 == 0)
          {
            ret = 0;
            goto ex;
          }

        }
        ret=sector_write_buffer(d, (struct burn_track *)(void *)0, 0);
        if(!(ret >= 1))
          goto ex;

      }

    }

    ret = 1;
  }


ex:
  ;
  if(!(d->cancel == 0))
    burn_source_cancel(t->source);

  if((signed int)o->write_type == BURN_WRITE_TAO)
  {
    signed int return_value_burn_write_flush_buffer$8;
    return_value_burn_write_flush_buffer$8=burn_write_flush_buffer(o, t);
    if(return_value_burn_write_flush_buffer$8 == 0)
      ret = 0;

    burn_write_track_minsize(o, s, tnum);
    d->sync_cache(d);
  }

  return ret;
}

// burn_write_track_minsize
// file libburn/write.c line 209
signed int burn_write_track_minsize(struct burn_write_opts *o, struct burn_session *s, signed int tnum)
{
  char msg[81l];
  struct burn_drive *d;
  struct burn_track *t;
  signed int todo;
  signed int step;
  signed int cancelled;
  signed int seclen;
  d = o->drive;
  t = s->track[(signed long int)tnum];
  if(!(t->written_sectors >= 300l))
  {
    todo = (signed int)((signed long int)300 - t->written_sectors);
    sprintf(msg, "Padding up track to minimum size (+ %d sectors)", todo);
    libdax_msgs_submit(libdax_messenger, o->drive->global_index, 0x0002011a, 0x30000000, 0x30000000, msg, 0, 0);
    step = 65536 / 4096;
    seclen=burn_sector_length(t->mode);
    if(!(seclen >= 1))
      seclen = 2048;

    memset((void *)d->buffer, 0, sizeof(struct buffer) /*69640ul*/ );
    cancelled = d->cancel;
    if(todo >= 1)
    {
      if(!(todo >= step))
        step = todo;

      d->buffer->bytes = step * seclen;
      d->buffer->sectors = step;
      d->cancel = 0;
      d->write(d, d->nwa, d->buffer);
      d->nwa = d->nwa + d->buffer->sectors;
      t->writecount = t->writecount + (signed long int)d->buffer->bytes;
      t->written_sectors = t->written_sectors + (signed long int)d->buffer->sectors;
      d->progress.buffered_bytes = d->progress.buffered_bytes + (signed long int)d->buffer->bytes;
      todo = todo - step;
    }

    d->cancel = cancelled;
  }

  return 1;
}

// char_to_isrc
// file libburn/sector.c line 577
static char char_to_isrc(char c)
{
  if((signed int)c >= 48 && !((signed int)c >= 58))
    return (char)((signed int)c - 48);

  else
    if((signed int)c >= 65 && !((signed int)c >= 91))
      return (char)(0x11 + ((signed int)c - 65));

    else
      if((signed int)c >= 97 && !((signed int)c >= 123))
        return (char)(0x11 + ((signed int)c - 97));

      else
        return (char)0;
}

// collect_payload
// file libburn/cdtext.c line 1233
static signed int collect_payload(unsigned char *text_packs, signed int num_packs, signed int pack_type, signed int block, unsigned char **payload, signed int *payload_count, signed int flag)
{
  unsigned char *pack;
  signed int pack_no;
  signed int ret;
  signed int double_byte = 0;
  *payload_count = 0;
  pack_no = 0;
  do
  {
    ret=search_pack(text_packs, num_packs, pack_no, pack_type, block, &pack, &pack_no, 0);
    if(!(ret >= 1))
      break;

    *payload_count = *payload_count + 12;
    pack_no = pack_no + 1;
  }
  while((_Bool)1);
  if(*payload_count == 0)
    return 0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem((unsigned long int)(*payload_count + 1), (unsigned long int)1, 0);
    *payload = (unsigned char *)return_value_burn_alloc_mem$1;
    if(*payload == ((unsigned char *)NULL))
      return -1;

    else
    {
      *payload_count = 0;
      pack_no = 0;
      do
      {
        ret=search_pack(text_packs, num_packs, pack_no, pack_type, block, &pack, &pack_no, 0);
        if(!(ret >= 1))
          break;

        memcpy((void *)(*payload + (signed long int)*payload_count), (const void *)(pack + (signed long int)4), (unsigned long int)12);
        *payload_count = *payload_count + 12;
        if(!((128 & (signed int)pack[4l]) == 0))
          double_byte = 1;

        pack_no = pack_no + 1;
      }
      while((_Bool)1);
      (*payload)[(signed long int)*payload_count] = (unsigned char)0;
      return 1 + double_byte;
    }
  }
}

// convert_data
// file libburn/sector.c line 340
static signed int convert_data(struct burn_write_opts *o, struct burn_track *track, signed int inmode, unsigned char *data)
{
  signed int outlen;
  signed int inlen;
  signed int offset = -1;
  signed int outmode;
  outmode=get_outmode(o);
  if(outmode == 0)
    outmode = inmode;

  outlen=burn_sector_length(outmode);
  inlen=burn_sector_length(inmode);
  if(!(inlen >= 0) || !(outlen >= 0) || !(outlen >= inlen))
    return 0;

  else
    if((127 & outmode) == (127 & inmode))
    {
      if(!(track == ((struct burn_track *)NULL)))
      {
        if(track->cdxa_conversion == 1)
          inlen = inlen + 8;

      }

      get_bytes(track, inlen, data);
      if(!(track == ((struct burn_track *)NULL)))
      {
        if(track->cdxa_conversion == 1)
          memmove((void *)data, (const void *)(data + (signed long int)8), (unsigned long int)(inlen - 8));

      }

      return 1;
    }

    else
      if((2 & outmode) == 0)
        return 0;

      else
      {
        if(!((4 & inmode) == 0))
          offset = 16;

        if(!((2 & inmode) == 0))
          offset = 0;

        if(!((64 & inmode) == 0))
          offset = 0;

        if(offset == -1)
          return 0;

        else
        {
          get_bytes(track, inlen, data + (signed long int)offset);
          return 1;
        }
      }
}

// convert_subs
// file libburn/sector.c line 395
static void convert_subs(struct burn_write_opts *o, signed int inmode, unsigned char *subs, unsigned char *sector)
{
  unsigned char *out;
  signed int outmode;
  outmode=get_outmode(o);
  if(outmode == 0)
    outmode = inmode;

  signed int return_value_burn_sector_length$1;
  return_value_burn_sector_length$1=burn_sector_length(outmode);
  sector = sector + (signed long int)return_value_burn_sector_length$1;
  switch((signed int)o->block_type)
  {
    case BURN_BLOCK_RAW96R:
    {
      uncook_subs(sector, subs);
      break;
    }
    case BURN_BLOCK_RAW16:
    {
      memcpy((void *)sector, (const void *)(subs + (signed long int)12), (unsigned long int)12);
      out = sector + (signed long int)12;
      out[(signed long int)0] = (unsigned char)0;
      out[(signed long int)1] = (unsigned char)0;
      out[(signed long int)2] = (unsigned char)0;
      if(!((signed int)subs[2l] == 0))
        out[(signed long int)3] = (unsigned char)0x80;

      else
        out[(signed long int)3] = (unsigned char)0;
      out = sector + (signed long int)10;
      out[(signed long int)0] = (unsigned char)~((signed int)out[(signed long int)0]);
      out[(signed long int)1] = (unsigned char)~((signed int)out[(signed long int)1]);
    }
  }
}

// crc_11021
// file libburn/cdtext.c line 83
static signed int crc_11021(unsigned char *data, signed int count, signed int flag)
{
  signed int acc = 0;
  signed int i = 0;
  for( ; !(i >= 8 * count + 16); i = i + 1)
  {
    acc = acc << 1;
    if(!(i >= 8 * count))
      acc = acc | (signed int)data[(signed long int)(i / 8)] >> 7 - i % 8 & 1;

    if(!((0x10000 & acc) == 0))
      acc = acc ^ 0x11021;

  }
  return acc;
}

// crc_11021$link1
// file libburn/crc.c line 152
static signed int crc_11021$link1(unsigned char *data$link1, signed int count$link1, signed int flag$link1)
{
  signed int acc$link1 = 0;
  signed int i$link1 = 0;
  for( ; !(i$link1 >= 8 * count$link1 + 16); i$link1 = i$link1 + 1)
  {
    acc$link1 = acc$link1 << 1;
    if(!(i$link1 >= 8 * count$link1))
      acc$link1 = acc$link1 | (signed int)data$link1[(signed long int)(i$link1 / 8)] >> 7 - i$link1 % 8 & 1;

    if(!((0x10000 & acc$link1) == 0))
      acc$link1 = acc$link1 ^ 0x11021;

  }
  return acc$link1;
}

// crc_18001801b
// file libburn/crc.c line 323
static unsigned int crc_18001801b(unsigned char *data, signed int count, signed int flag)
{
  unsigned int acc = (unsigned int)0;
  unsigned int top;
  signed long int i;
  unsigned int inv_acc;
  i = (signed long int)0;
  for( ; !(i >= (signed long int)(8 * count + 32)); i = i + 1l)
  {
    top = acc & 0x80000000;
    acc = acc << 1;
    if(!(i >= (signed long int)(8 * count)))
    {
      if(!((1 & flag) == 0))
        acc = acc | (unsigned int)((signed int)data[i / (signed long int)8] >> (signed long int)7 - i % (signed long int)8 & 1);

      else
        acc = acc | (unsigned int)((signed int)data[i / (signed long int)8] >> i % (signed long int)8 & 1);
    }

    if(!(top == 0u))
      acc = acc ^ 0x8001801b;

  }
  if(!((1 & flag) == 0))
    return (unsigned int)(acc & 0xffffffff);

  else
  {
    inv_acc=rfl32((unsigned int)acc);
    return inv_acc;
  }
}

// crc_32
// file libburn/crc.c line 530
unsigned int crc_32(unsigned char *data, signed int count)
{
  unsigned int acc = (unsigned int)0;
  unsigned char b[1l];
  signed int i;
  static unsigned int crc_tab[256l];
  static unsigned int tab_initialized = (unsigned int)0;
  if(tab_initialized == 0u)
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      b[(signed long int)0] = (unsigned char)i;
      unsigned int return_value_rfl8$1;
      return_value_rfl8$1=rfl8((unsigned int)i);
      unsigned int return_value_crc_18001801b$2;
      return_value_crc_18001801b$2=crc_18001801b(b, 1, 1);
      crc_tab[(signed long int)return_value_rfl8$1]=rfl32(return_value_crc_18001801b$2);
    }
    tab_initialized = (unsigned int)1;
  }

  i = 0;
  for( ; !(i >= count); i = i + 1)
    acc = acc >> 8 ^ crc_tab[(signed long int)(acc & (unsigned int)0xff ^ (unsigned int)data[(signed long int)i])];
  return acc;
}

// crc_ccitt
// file libburn/crc.c line 171
unsigned short int crc_ccitt(unsigned char *data, signed int count)
{
  unsigned short int acc = (unsigned short int)0;
  unsigned char b[1l];
  signed int i;
  static unsigned short int crc_tab[256l];
  static unsigned short int tab_initialized = (unsigned short int)0;
  if(tab_initialized == 0)
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      b[(signed long int)0] = (unsigned char)i;
      signed int return_value_crc_11021$1;
      return_value_crc_11021$1=crc_11021$link1(b, 1, 0);
      crc_tab[(signed long int)i] = (unsigned short int)return_value_crc_11021$1;
    }
    tab_initialized = (unsigned short int)1;
  }

  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    unsigned char *tmp_post$2 = data;
    data = data + 1l;
    acc = (unsigned short int)((signed int)crc_tab[(signed long int)((signed int)acc >> 8 ^ (signed int)*tmp_post$2)] ^ (signed int)acc << 8);
  }
  return (unsigned short int)~((signed int)acc);
}

// cue_attach_track
// file libburn/structure.c line 1325
static signed int cue_attach_track(struct burn_session *session, struct burn_cue_file_cursor *crs, signed int flag)
{
  signed int ret;
  if(crs->track == ((struct burn_track *)NULL))
    return 2;

  else
    if(crs->track_has_source == 0)
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, "In cue sheet file: TRACK without INDEX 01", 0, 0);
      return 0;
    }

    else
      if(!(crs->track_current_index >= 1))
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "No INDEX 01 defined for last TRACK in cue sheet file", 0, 0);
        return 0;
      }

      else
        if(session->tracks == 0)
        {
          crs->start_track_no = crs->track_no;
          ret=burn_session_set_start_tno(session, crs->track_no, 0);
          if(ret >= 1)
            goto __CPROVER_DUMP_L4;

          return ret;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(crs->start_track_no + session->tracks + -1 >= 100)
          {
            libdax_msgs_submit(libdax_messenger, -1, 0x0002019b, 0x60000000, 0x30000000, "CD track number exceeds 99", 0, 0);
            return 0;
          }

          else
          {
            ret=burn_session_add_track(session, crs->track, (unsigned int)100);
            if(!(ret >= 1))
              return ret;

            else
            {
              if(!(crs->prev_track == ((struct burn_track *)NULL)))
                burn_track_free(crs->prev_track);

              crs->prev_track = crs->track;
              crs->prev_file_ba = crs->current_file_ba;
              crs->prev_block_size = crs->block_size;
              crs->track = (struct burn_track *)(void *)0;
              crs->track_current_index = -1;
              crs->track_has_source = 0;
              crs->current_file_ba = -1;
              crs->current_index_ba = -1;
              if(crs->block_size_locked == 0)
                crs->block_size = 0;

              return 1;
            }
          }
        }
}

// cue_check_for_track
// file libburn/structure.c line 1556
static signed int cue_check_for_track(struct burn_cue_file_cursor *crs, char *cmd, signed int flag)
{
  signed int ret;
  char *msg = (char *)(void *)0;
  if(crs->track == ((struct burn_track *)NULL))
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
    msg = (char *)return_value_burn_alloc_mem$1;
    if(msg == ((char *)NULL))
    {
      ret = -1;
      goto ex;
    }

    sprintf(msg, "In cue sheet file: %s found before TRACK", cmd);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, msg, 0, 0);
    ret = 0;
  }

  else
    ret = 1;

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// cue_create_file_source
// file libburn/structure.c line 1478
static signed int cue_create_file_source(char *path, struct burn_cue_file_cursor *crs, signed int flag)
{
  signed int fd;
  signed int ret;
  char *msg = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    if(!((256 & flag) == 0))
    {
      ret=cue_open_audioxtr(path, crs, &fd, flag & 255);
      if(!(ret >= 1))
        goto ex;

    }

    else
    {
      fd=open(path, 00 | 0);
      if(fd == -1)
      {
        sprintf(msg, "In cue sheet: Cannot open FILE '%.4000s'", path);
        char *return_value_burn_printify$2;
        return_value_burn_printify$2=burn_printify(msg);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$2, *return_value___errno_location$3, 0);
        ret = 0;
        goto ex;
      }

    }
    crs->file_source=burn_fd_source_new(fd, -1, crs->source_size);
    if(crs->file_source == ((struct burn_source *)NULL))
      ret = -1;

    else
      ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// cue_crs_destroy
// file libburn/structure.c line 1235
static signed int cue_crs_destroy(struct burn_cue_file_cursor **victim, signed int flag)
{
  struct burn_cue_file_cursor *crs;
  if(*victim == ((struct burn_cue_file_cursor *)NULL))
    return 2;

  else
  {
    crs = *victim;
    if(!(crs->cdtextfile == ((char *)NULL)))
      free((void *)crs->cdtextfile);

    if(!(crs->source_file == ((char *)NULL)))
      free((void *)crs->source_file);

    if(!(crs->file_source == ((struct burn_source *)NULL)))
      burn_source_free(crs->file_source);

    if(!(crs->fifo == ((struct burn_source *)NULL)))
      burn_source_free(crs->fifo);

    if(!(crs->offst_source == ((struct burn_source *)NULL)))
      burn_source_free(crs->offst_source);

    if(!(crs->prev_track == ((struct burn_track *)NULL)))
      burn_track_free(crs->prev_track);

    if(!(crs->track == ((struct burn_track *)NULL)))
      burn_track_free(crs->track);

    if(!(crs == ((struct burn_cue_file_cursor *)NULL)))
      free((void *)(char *)crs);

    *victim = (struct burn_cue_file_cursor *)(void *)0;
    return 1;
  }
}

// cue_crs_new
// file libburn/structure.c line 1197
static signed int cue_crs_new(struct burn_cue_file_cursor **reply, signed int flag)
{
  signed int ret;
  struct burn_cue_file_cursor *crs;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct burn_cue_file_cursor) /*136ul*/ , (unsigned long int)1, 0);
  crs = (struct burn_cue_file_cursor *)return_value_burn_alloc_mem$1;
  if(crs == ((struct burn_cue_file_cursor *)NULL))
    ret = -1;

  else
  {
    crs->cdtextfile = (char *)(void *)0;
    crs->source_file = (char *)(void *)0;
    crs->source_size = (signed long int)-1;
    crs->file_source = (struct burn_source *)(void *)0;
    crs->fifo_size = 0;
    crs->fifo = (struct burn_source *)(void *)0;
    crs->swap_audio_bytes = 0;
    crs->no_cdtext = 0;
    crs->no_catalog_isrc = 0;
    crs->start_track_no = 1;
    crs->offst_source = (struct burn_source *)(void *)0;
    crs->current_file_ba = -1000000000;
    crs->current_index_ba = -1000000000;
    crs->prev_track = (struct burn_track *)(void *)0;
    crs->prev_file_ba = -1000000000;
    crs->prev_block_size = 0;
    crs->track = (struct burn_track *)(void *)0;
    crs->track_no = 0;
    crs->track_current_index = -1;
    crs->track_has_source = 0;
    crs->block_size = 0;
    crs->block_size_locked = 0;
    crs->track_mode = 0;
    crs->flags = 0;
    *reply = crs;
    ret = 1;
  }

ex:
  ;
  return ret;
}

// cue_interpret_line
// file libburn/structure.c line 1578
static signed int cue_interpret_line(struct burn_session *session, char *line, struct burn_cue_file_cursor *crs, signed int flag)
{
  signed int ret;
  signed int mode;
  signed int index_no;
  signed int file_ba;
  signed int chunks;
  signed int block_size;
  signed int step;
  signed int audio_xtr = 0;
  signed long int size;
  char *cmd;
  char *apt;
  char *msg = (char *)(void *)0;
  char *cpt;
  char *filetype;
  struct burn_source *src;
  struct burn_source *inp_src;
  enum burn_source_status source_status;
  struct stat stbuf;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$47;
  signed int return_value_strcmp$46;
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$45;
  signed int return_value_strcmp$44;
  signed int return_value_strcmp$43;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$12;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$42;
  signed int return_value_strncmp$23;
  signed int return_value_strncmp$22;
  signed int return_value_strncmp$21;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$25;
  signed int return_value_strcmp$41;
  signed int return_value_strcmp$40;
  signed int return_value_strcmp$39;
  signed int return_value_strcmp$38;
  signed int return_value_strcmp$37;
  signed int return_value_strcmp$36;
  signed int return_value_strcmp$35;
  signed int return_value_strcmp$34;
  signed int return_value_strcmp$33;
  signed int return_value_strcmp$32;
  signed int return_value_strcmp$29;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    _Bool tmp_if_expr$2;
    if((signed int)*line == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      ret = 1;

    else
    {
      cmd = line;
      do
      {
        if((signed int)*cmd == 32)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*cmd == 9 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        cmd = cmd + 1l;
      }
      while((_Bool)1);
      apt = cmd;
      do
      {
        if(!((signed int)*apt == 0))
          tmp_if_expr$4 = (signed int)*apt != 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = (signed int)*apt != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(!tmp_if_expr$5)
          break;

        apt = apt + 1l;
      }
      while((_Bool)1);
      if(!((signed int)*apt == 0))
      {
        *apt = (char)0;
        apt = apt + 1l;
        do
        {
          if((signed int)*apt == 32)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (signed int)*apt == 9 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$6)
            break;

          apt = apt + 1l;
        }
        while((_Bool)1);
      }

      return_value_strcmp$47=strcmp(cmd, "ARRANGER");
      if(return_value_strcmp$47 == 0)
      {
        ret=cue_set_cdtext(session, crs->track, 0x84, apt, crs, 2);
        if(!(ret >= 1))
          goto ex;

      }

      else
      {
        return_value_strcmp$46=strcmp(cmd, "CATALOG");
        if(return_value_strcmp$46 == 0)
        {
          cpt = apt;
          do
          {
            if(!(cpt - apt >= 13l))
              tmp_if_expr$7 = (signed int)*cpt == ((signed int)*cpt & 0x7f) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$7 = (_Bool)0;
            if(!tmp_if_expr$7)
              break;

            cpt = cpt + 1l;
          }
          while((_Bool)1);
          if(!(cpt - apt >= 13l))
          {
            libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, "In cue sheet file: Inappropriate content of CATALOG", 0, 0);
            ret = 0;
            goto ex;
          }

          ret=cue_set_cdtext(session, (struct burn_track *)(void *)0, 0x8e, apt, crs, 0);
          if(!(ret >= 1))
            goto ex;

          if(crs->no_catalog_isrc == 0)
          {
            memcpy((void *)session->mediacatalog, (const void *)apt, (unsigned long int)13);
            session->mediacatalog[(signed long int)13] = (unsigned char)0;
          }

        }

        else
        {
          return_value_strcmp$45=strcmp(cmd, "CDTEXTFILE");
          if(return_value_strcmp$45 == 0)
          {
            if(!(crs->no_cdtext == 0))
            {
              ret = 1;
              goto ex;
            }

            apt=cue_unquote_text(apt, 0);
            if(!(crs->cdtextfile == ((char *)NULL)))
              free((void *)crs->cdtextfile);

            crs->cdtextfile=strdup(apt);
            if(crs->cdtextfile == ((char *)NULL))
            {

            out_of_mem:
              ;
              libdax_msgs_submit(libdax_messenger, -1, 0x00000003, 0x70000000, 0x30000000, "Out of virtual memory", 0, 0);
              ret = -1;
              goto ex;
            }

          }

          else
          {
            return_value_strcmp$44=strcmp(cmd, "COMPOSER");
            if(return_value_strcmp$44 == 0)
            {
              ret=cue_set_cdtext(session, crs->track, 0x83, apt, crs, 2);
              if(!(ret >= 1))
                goto ex;

            }

            else
            {
              return_value_strcmp$43=strcmp(cmd, "FILE");
              if(return_value_strcmp$43 == 0)
              {
                if(!(crs->file_source == ((struct burn_source *)NULL)))
                {
                  libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "In cue sheet file: Multiple occurences of FILE", 0, 0);
                  ret = 0;
                  goto ex;
                }

                unsigned long int return_value_strlen$8;
                return_value_strlen$8=strlen(apt);
                cpt = apt + (signed long int)(return_value_strlen$8 - (unsigned long int)1);
                do
                {
                  if(!(apt >= cpt))
                  {
                    if((signed int)*cpt == 32)
                      tmp_if_expr$9 = (_Bool)1;

                    else
                      tmp_if_expr$9 = (signed int)*cpt == 9 ? (_Bool)1 : (_Bool)0;
                    tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$10 = (_Bool)0;
                  if(!tmp_if_expr$10)
                    break;

                  cpt = cpt - 1l;
                }
                while((_Bool)1);
                cpt[(signed long int)1] = (char)0;
                do
                {
                  if(!(apt >= cpt))
                    tmp_if_expr$11 = (signed int)*cpt != 32 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$11 = (_Bool)0;
                  if(tmp_if_expr$11)
                    tmp_if_expr$12 = (signed int)*cpt != 9 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$12 = (_Bool)0;
                  if(!tmp_if_expr$12)
                    break;

                  cpt = cpt - 1l;
                }
                while((_Bool)1);
                if(apt >= cpt)
                {
                  libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, "In cue sheet file: FILE without type word", 0, 0);
                  ret = 0;
                  goto ex;
                }

                *cpt = (char)0;
                filetype = cpt + (signed long int)1;
                signed int return_value_strcmp$16;
                return_value_strcmp$16=strcmp(filetype, "BINARY");
                if(return_value_strcmp$16 == 0)
                  crs->swap_audio_bytes = 0;

                else
                {
                  return_value_strcmp$15=strcmp(filetype, "MOTOROLA");
                  if(return_value_strcmp$15 == 0)
                    crs->swap_audio_bytes = 1;

                  else
                  {
                    return_value_strcmp$14=strcmp(filetype, "WAVE");
                    if(return_value_strcmp$14 == 0)
                      audio_xtr = 0x101;

                    else
                    {
                      sprintf(msg, "In cue sheet file: Unsupported FILE type '%.4000s'", filetype);
                      char *return_value_burn_printify$13;
                      return_value_burn_printify$13=burn_printify(msg);
                      libdax_msgs_submit(libdax_messenger, -1, 0x00020197, 0x68000000, 0x30000000, return_value_burn_printify$13, 0, 0);
                      ret = 0;
                      goto ex;
                    }
                  }
                }
                apt=cue_unquote_text(apt, 0);
                if((signed int)*apt == 0)
                  ret = -1;

                else
                  ret=stat(apt, &stbuf);
                if(ret == -1)
                {

                not_usable_file:
                  ;
                  sprintf(msg, "In cue sheet file: Unusable FILE '%.4000s'", apt);
                  char *return_value_burn_printify$17;
                  return_value_burn_printify$17=burn_printify(msg);
                  libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$17, 0, 0);
                  ret = 0;
                  goto ex;
                }

                if(!((61440u & stbuf.st_mode) == 32768u))
                  goto not_usable_file;

                crs->source_size = stbuf.st_size;
                if(!(crs->source_file == ((char *)NULL)))
                  free((void *)crs->source_file);

                crs->source_file=strdup(apt);
                if(crs->source_file == ((char *)NULL))
                  goto out_of_mem;

                ret=cue_create_file_source(apt, crs, audio_xtr);
                if(!(ret >= 1))
                  goto ex;

              }

              else
              {
                return_value_strcmp$42=strcmp(cmd, "FLAGS");
                if(return_value_strcmp$42 == 0)
                {
                  ret=cue_check_for_track(crs, cmd, 0);
                  if(!(ret >= 1))
                    goto ex;

                  while(!(*apt == 0))
                  {
                    signed int return_value_strncmp$24;
                    return_value_strncmp$24=strncmp(apt, "DCP", (unsigned long int)3);
                    if(return_value_strncmp$24 == 0)
                    {
                      crs->track_mode = crs->track_mode | 1 << 8;
                      step = 3;
                    }

                    else
                    {
                      return_value_strncmp$23=strncmp(apt, "4CH", (unsigned long int)3);
                      if(return_value_strncmp$23 == 0)
                      {
                        crs->track_mode = crs->track_mode | 1 << 7;
                        step = 3;
                      }

                      else
                      {
                        return_value_strncmp$22=strncmp(apt, "PRE", (unsigned long int)3);
                        if(return_value_strncmp$22 == 0)
                        {
                          crs->track_mode = crs->track_mode | 1 << 9;
                          step = 3;
                        }

                        else
                        {
                          return_value_strncmp$21=strncmp(apt, "SCMS", (unsigned long int)4);
                          if(return_value_strncmp$21 == 0)
                          {
                            crs->track_mode = crs->track_mode | 1 << 13;
                            step = 4;
                          }

                          else
                          {

                          bad_flags:
                            ;
                            cpt = apt;
                            do
                            {
                              if(!((signed int)*cpt == 32))
                                tmp_if_expr$18 = (signed int)*cpt != 9 ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$18 = (_Bool)0;
                              if(tmp_if_expr$18)
                                tmp_if_expr$19 = (signed int)*cpt != 0 ? (_Bool)1 : (_Bool)0;

                              else
                                tmp_if_expr$19 = (_Bool)0;
                              if(!tmp_if_expr$19)
                                break;

                              cpt = cpt + 1l;
                            }
                            while((_Bool)1);
                            *cpt = (char)0;
                            sprintf(msg, "In cue sheet file: Unknown FLAGS option '%.4000s'", apt);
                            char *return_value_burn_printify$20;
                            return_value_burn_printify$20=burn_printify(msg);
                            libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$20, 0, 0);
                            ret = 0;
                            goto ex;
                          }
                        }
                      }
                    }
                    if(!((signed int)apt[(signed long int)step] == 0))
                    {
                      if(!((signed int)apt[(signed long int)step] == 32))
                      {
                        if(!((signed int)apt[(signed long int)step] == 9))
                          goto bad_flags;

                      }

                    }

                    apt = apt + (signed long int)step;
                    do
                    {
                      if((signed int)*apt == 32)
                        tmp_if_expr$25 = (_Bool)1;

                      else
                        tmp_if_expr$25 = (signed int)*apt == 9 ? (_Bool)1 : (_Bool)0;
                      if(!tmp_if_expr$25)
                        break;

                      apt = apt + 1l;
                    }
                    while((_Bool)1);
                  }
                  burn_track_define_data(crs->track, 0, 0, 1, crs->track_mode);
                }

                else
                {
                  return_value_strcmp$41=strcmp(cmd, "INDEX");
                  if(return_value_strcmp$41 == 0)
                  {
                    ret=cue_check_for_track(crs, cmd, 0);
                    if(!(ret >= 1))
                      goto ex;

                    ret=cue_read_number(&apt, &index_no, 0);
                    if(!(ret >= 1))
                      goto ex;

                    ret=cue_read_timepoint_lba(apt, "index time point", &file_ba, 0);
                    if(!(ret >= 1))
                      goto ex;

                    if(!(file_ba >= crs->prev_file_ba))
                    {

                    overlapping_ba:
                      ;
                      libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "Backward INDEX address in cue sheet file", 0, 0);
                      ret = 0;
                      goto ex;
                    }

                    if(!(file_ba >= crs->current_index_ba))
                      goto overlapping_ba;

                    if(!(crs->prev_track == ((struct burn_track *)NULL)))
                    {
                      if(!(crs->track_current_index >= 0))
                      {
                        size = (signed long int)((file_ba - crs->prev_file_ba) * crs->prev_block_size);
                        if(!(size >= 1l))
                          goto overlapping_ba;

                        burn_track_set_size(crs->prev_track, size);
                      }

                    }

                    if(!(1 + crs->track_current_index == index_no))
                    {
                      if(crs->track_current_index >= 0 || index_no >= 2)
                      {
                        libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "Unacceptable INDEX number in cue sheet file", 0, 0);
                        ret = 0;
                        goto ex;
                      }

                    }

                    crs->track_current_index = index_no;
                    if(!(crs->current_file_ba >= 0))
                      crs->current_file_ba = file_ba;

                    crs->current_index_ba = file_ba;
                    ret=burn_track_set_index(crs->track, index_no, (unsigned int)(file_ba - crs->current_file_ba), 0);
                    if(!(ret >= 1))
                      goto ex;

                    if(!(crs->track_has_source == 0))
                    {
                      ret = 1;
                      goto ex;
                    }

                    if(!(crs->block_size_locked == 0))
                    {
                      if(crs->fifo == ((struct burn_source *)NULL))
                      {
                        if(crs->fifo_size >= 1)
                        {
                          chunks = crs->fifo_size / crs->block_size + (signed int)!(!(crs->fifo_size % crs->block_size != 0));
                          if(!(chunks >= 4))
                            chunks = 4;

                          crs->fifo=burn_fifo_source_new(crs->file_source, crs->block_size, chunks, 0);
                          if(crs->fifo == ((struct burn_source *)NULL))
                          {
                            ret = -1;
                            goto ex;
                          }

                        }

                      }

                    }

                    if(!(crs->fifo == ((struct burn_source *)NULL)))
                      inp_src = crs->fifo;

                    else
                      inp_src = crs->file_source;
                    src=burn_offst_source_new(inp_src, crs->offst_source, (signed long int)(file_ba * crs->block_size), (signed long int)0, 1);
                    if(src == ((struct burn_source *)NULL))
                      goto out_of_mem;

                    source_status=burn_track_set_source(crs->track, src);
                    if(!((signed int)source_status == BURN_SOURCE_OK))
                    {
                      ret = -1;
                      goto ex;
                    }

                    if(!(crs->offst_source == ((struct burn_source *)NULL)))
                      burn_source_free(crs->offst_source);

                    crs->offst_source = src;
                    crs->track_has_source = 1;
                  }

                  else
                  {
                    return_value_strcmp$40=strcmp(cmd, "ISRC");
                    if(return_value_strcmp$40 == 0)
                    {
                      ret=cue_check_for_track(crs, cmd, 0);
                      if(!(ret >= 1))
                        goto ex;

                      ret=cue_set_cdtext(session, crs->track, 0x8e, apt, crs, 1 | 2);
                      if(!(ret >= 1))
                        goto ex;

                      if(crs->no_catalog_isrc == 0)
                      {
                        ret=burn_track_set_isrc_string(crs->track, apt, 0);
                        if(!(ret >= 1))
                          goto ex;

                      }

                    }

                    else
                    {
                      return_value_strcmp$39=strcmp(cmd, "MESSAGE");
                      if(return_value_strcmp$39 == 0)
                      {
                        ret=cue_set_cdtext(session, crs->track, 0x85, apt, crs, 2);
                        if(!(ret >= 1))
                          goto ex;

                      }

                      else
                      {
                        return_value_strcmp$38=strcmp(cmd, "PERFORMER");
                        if(return_value_strcmp$38 == 0)
                        {
                          ret=cue_set_cdtext(session, crs->track, 0x81, apt, crs, 2);
                          if(!(ret >= 1))
                            goto ex;

                        }

                        else
                        {
                          return_value_strcmp$37=strcmp(cmd, "POSTGAP");
                          if(return_value_strcmp$37 == 0)
                          {
                            ret=cue_check_for_track(crs, cmd, 0);
                            if(!(ret >= 1))
                              goto ex;

                            ret=cue_read_timepoint_lba(apt, "post-gap duration", &file_ba, 0);
                            if(!(ret >= 1))
                              goto ex;

                            ret=burn_track_set_postgap_size(crs->track, file_ba, 0);
                            if(!(ret >= 1))
                              goto ex;

                          }

                          else
                          {
                            return_value_strcmp$36=strcmp(cmd, "PREGAP");
                            if(return_value_strcmp$36 == 0)
                            {
                              ret=cue_check_for_track(crs, cmd, 0);
                              if(!(ret >= 1))
                                goto ex;

                              ret=cue_read_timepoint_lba(apt, "pre-gap duration", &file_ba, 0);
                              if(!(ret >= 1))
                                goto ex;

                              ret=burn_track_set_pregap_size(crs->track, file_ba, 0);
                              if(!(ret >= 1))
                                goto ex;

                            }

                            else
                            {
                              return_value_strcmp$35=strcmp(cmd, "REM");
                              if(!(return_value_strcmp$35 == 0))
                              {
                                return_value_strcmp$34=strcmp(cmd, "SONGWRITER");
                                if(return_value_strcmp$34 == 0)
                                {
                                  ret=cue_set_cdtext(session, crs->track, 0x82, apt, crs, 2);
                                  if(!(ret >= 1))
                                    goto ex;

                                }

                                else
                                {
                                  return_value_strcmp$33=strcmp(cmd, "TITLE");
                                  if(return_value_strcmp$33 == 0)
                                  {
                                    ret=cue_set_cdtext(session, crs->track, 0x80, apt, crs, 2);
                                    if(!(ret >= 1))
                                      goto ex;

                                  }

                                  else
                                  {
                                    return_value_strcmp$32=strcmp(cmd, "TRACK");
                                    if(return_value_strcmp$32 == 0)
                                    {
                                      if(crs->file_source == ((struct burn_source *)NULL))
                                      {
                                        libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "No FILE defined before TRACK in cue sheet file", 0, 0);
                                        ret = 0;
                                        goto ex;
                                      }

                                      ret=cue_attach_track(session, crs, 0);
                                      if(!(ret >= 1))
                                        goto ex;

                                      ret=cue_read_number(&apt, &crs->track_no, 0);
                                      if(!(ret >= 1))
                                        goto ex;

                                      _Bool tmp_if_expr$27;
                                      if(!(crs->track_no >= 1))
                                        tmp_if_expr$27 = (_Bool)1;

                                      else
                                        tmp_if_expr$27 = crs->track_no > 99 ? (_Bool)1 : (_Bool)0;
                                      if(tmp_if_expr$27)
                                      {
                                        sprintf(msg, "Inappropriate cue sheet file track number %d", crs->track_no);
                                        char *return_value_burn_printify$26;
                                        return_value_burn_printify$26=burn_printify(msg);
                                        libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$26, 0, 0);
                                        ret = 0;
                                        goto ex;
                                      }

                                      signed int return_value_strcmp$30;
                                      return_value_strcmp$30=strcmp(apt, "AUDIO");
                                      if(return_value_strcmp$30 == 0)
                                      {
                                        mode = 1 << 6;
                                        block_size = 2352;
                                      }

                                      else
                                      {
                                        return_value_strcmp$29=strcmp(apt, "MODE1/2048");
                                        if(return_value_strcmp$29 == 0)
                                        {
                                          mode = 1 << 2;
                                          block_size = 2048;
                                        }

                                        else
                                        {
                                          sprintf(msg, "Unsupported cue sheet file track datatype '%.4000s'", apt);
                                          char *return_value_burn_printify$28;
                                          return_value_burn_printify$28=burn_printify(msg);
                                          libdax_msgs_submit(libdax_messenger, -1, 0x00020197, 0x68000000, 0x30000000, return_value_burn_printify$28, 0, 0);
                                          ret = 0;
                                          goto ex;
                                        }
                                      }
                                      if(!(block_size == crs->block_size))
                                      {
                                        if(crs->block_size >= 1)
                                        {
                                          if(!(crs->block_size_locked == 0))
                                          {
                                            libdax_msgs_submit(libdax_messenger, -1, 0x00020197, 0x68000000, 0x30000000, "In cue sheet file: Unsupported mix track block sizes", 0, 0);
                                            ret = 0;
                                            goto ex;
                                          }

                                        }

                                      }

                                      crs->block_size = block_size;
                                      crs->track=burn_track_create();
                                      if(crs->track == ((struct burn_track *)NULL))
                                        goto out_of_mem;

                                      crs->track_has_source = 0;
                                      crs->track_mode = mode;
                                      burn_track_define_data(crs->track, 0, 0, 1, mode);
                                      if(!((64 & mode) == 0))
                                        burn_track_set_byte_swap(crs->track, (signed int)!(!(crs->swap_audio_bytes != 0)));

                                    }

                                    else
                                    {
                                      sprintf(msg, "Unknown cue sheet file command '%.4000s'", line);
                                      char *return_value_burn_printify$31;
                                      return_value_burn_printify$31=burn_printify(msg);
                                      libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$31, 0, 0);
                                      ret = 0;
                                      goto ex;
                                    }
                                  }
                                }
                              }

                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ret = 1;
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// cue_open_audioxtr
// file libburn/structure.c line 1417
static signed int cue_open_audioxtr(char *path, struct burn_cue_file_cursor *crs, signed int *fd, signed int flag)
{
  struct libdax_audioxtr *xtr = (struct libdax_audioxtr *)(void *)0;
  char *fmt;
  char *fmt_info;
  signed int ret;
  signed int num_channels;
  signed int sample_rate;
  signed int bits_per_sample;
  signed int msb_first;
  char *msg = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    ret=libdax_audioxtr_new(&xtr, path, 0);
    if(ret >= 1)
    {
      libdax_audioxtr_get_id(xtr, &fmt, &fmt_info, &num_channels, &sample_rate, &bits_per_sample, &msb_first, 0);
      if((255 & flag) == 1)
      {
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp(fmt, ".wav");
        if(!(return_value_strcmp$3 == 0))
        {
          sprintf(msg, "In cue sheet: Not recognized as WAVE : FILE '%.4000s'", path);
          char *return_value_burn_printify$2;
          return_value_burn_printify$2=burn_printify(msg);
          libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$2, 0, 0);
          ret = 0;
          goto ex;
        }

      }

      ret=libdax_audioxtr_get_size(xtr, &crs->source_size, 0);
      if(!(ret >= 1))
      {
        sprintf(msg, "In cue sheet: Cannot get payload size of FILE '%.4000s'", path);
        char *return_value_burn_printify$4;
        return_value_burn_printify$4=burn_printify(msg);
        libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$4, 0, 0);
        ret = 0;
        goto ex;
      }

      ret=libdax_audioxtr_detach_fd(xtr, fd, 0);
      if(!(ret >= 1))
      {
        sprintf(msg, "In cue sheet: Cannot represent payload as plain fd: FILE '%.4000s'", path);
        char *return_value_burn_printify$5;
        return_value_burn_printify$5=burn_printify(msg);
        libdax_msgs_submit(libdax_messenger, -1, 0x00020193, 0x68000000, 0x30000000, return_value_burn_printify$5, 0, 0);
        ret = 0;
        goto ex;
      }

      crs->swap_audio_bytes = (signed int)(msb_first == 1);
      ret = 1;
    }

  }

ex:
  ;
  if(!(xtr == ((struct libdax_audioxtr *)NULL)))
    libdax_audioxtr_destroy(&xtr, 0);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// cue_read_number
// file libburn/structure.c line 1381
static signed int cue_read_number(char **payload, signed int *number, signed int flag)
{
  signed int ret;
  signed int at_end = 0;
  char *apt;
  char *msg = (char *)(void *)0;
  apt = *payload;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  do
  {
    if(!((signed int)*apt == 0))
      tmp_if_expr$1 = (signed int)*apt != 32 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (signed int)*apt != 9 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    apt = apt + 1l;
  }
  while((_Bool)1);
  if((signed int)*apt == 0)
    at_end = 1;

  else
    if((1 & flag) == 0)
      *apt = (char)0;

  ret=__isoc99_sscanf(*payload, "%d", number);
  if(!(ret == 1))
  {
    void *return_value_burn_alloc_mem$3;
    return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
    msg = (char *)return_value_burn_alloc_mem$3;
    if(msg == ((char *)NULL))
    {
      ret = -1;
      goto ex;
    }

    sprintf(msg, "Unsuitable number in cue sheet file: '%.4000s'", *payload);
    char *return_value_burn_printify$4;
    return_value_burn_printify$4=burn_printify(msg);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$4, 0, 0);
    ret = 0;
    goto ex;
  }

  _Bool tmp_if_expr$5;
  if(at_end == 0)
  {
    apt = apt + 1l;
    do
    {
      if((signed int)*apt == 32)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)*apt == 9 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      apt = apt + 1l;
    }
    while((_Bool)1);
  }

  if((1 & flag) == 0)
    *payload = apt;

  ret = 1;

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// cue_read_timepoint_lba
// file libburn/structure.c line 1514
static signed int cue_read_timepoint_lba(char *apt, char *purpose, signed int *file_ba, signed int flag)
{
  signed int ret;
  signed int minute;
  signed int second;
  signed int frame;
  char *msg = (char *)(void *)0;
  char msf[3l];
  char *msf_pt;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  unsigned long int return_value_strlen$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    return_value_strlen$3=strlen(apt);
    if(!(return_value_strlen$3 >= 8ul))
    {

    no_time_point:
      ;
      sprintf(msg, "Inappropriate cue sheet file %s '%.4000s'", purpose, apt);
      char *return_value_burn_printify$2;
      return_value_burn_printify$2=burn_printify(msg);
      libdax_msgs_submit(libdax_messenger, -1, 0x00020194, 0x68000000, 0x30000000, return_value_burn_printify$2, 0, 0);
      ret = 0;
      goto ex;
    }

    _Bool tmp_if_expr$4;
    if(!((signed int)apt[2l] == 58))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)apt[(signed long int)5] != 58 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$7;
    if(tmp_if_expr$4)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      if(!((signed int)apt[8l] == 0))
        tmp_if_expr$5 = (signed int)apt[(signed long int)8] != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (signed int)apt[(signed long int)8] != 9 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      goto no_time_point;

    msf[(signed long int)2] = (char)0;
    msf_pt = msf;
    strncpy(msf, apt, (unsigned long int)2);
    ret=cue_read_number(&msf_pt, &minute, 1);
    if(ret >= 1)
    {
      strncpy(msf, apt + (signed long int)3, (unsigned long int)2);
      ret=cue_read_number(&msf_pt, &second, 1);
      if(ret >= 1)
      {
        strncpy(msf, apt + (signed long int)6, (unsigned long int)2);
        ret=cue_read_number(&msf_pt, &frame, 1);
        if(ret >= 1)
        {
          *file_ba = (minute * 60 + second) * 75 + frame;
          ret = 1;
        }

      }

    }

  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// cue_set_cdtext
// file libburn/structure.c line 1284
static signed int cue_set_cdtext(struct burn_session *session, struct burn_track *track, signed int pack_type, char *text, struct burn_cue_file_cursor *crs, signed int flag)
{
  signed int ret;
  char *payload;
  if(crs->no_cdtext == 1)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020195, 0x50000000, 0x30000000, "In cue sheet file: Being set to ignore all CD-TEXT aspects", 0, 0);
    crs->no_cdtext = 2;
  }

  if(!(crs->no_cdtext == 0))
    return 2;

  else
  {
    if(track == ((struct burn_track *)NULL) && !((1 & flag) == 0))
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00020192, 0x68000000, 0x30000000, "Track attribute set before first track in cue sheet file", 0, 0);
      ret = 0;
    }

    else
    {
      if(!((2 & flag) == 0))
        payload=cue_unquote_text(text, 0);

      else
        payload = text;
      if(!(track == ((struct burn_track *)NULL)))
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(payload);
        ret=burn_track_set_cdtext(track, 0, pack_type, "", (unsigned char *)payload, (signed int)(return_value_strlen$1 + (unsigned long int)1), 0);
      }

      else
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(payload);
        ret=burn_session_set_cdtext(session, 0, pack_type, "", (unsigned char *)payload, (signed int)(return_value_strlen$2 + (unsigned long int)1), 0);
      }
    }

  ex:
    ;
    return ret;
  }
}

// cue_unquote_text
// file libburn/structure.c line 1262
static char * cue_unquote_text(char *text, signed int flag)
{
  char *ept;
  char *spt = text;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(text);
  ept = text + (signed long int)return_value_strlen$1;
  for( ; !(text >= ept); ept = ept - 1l)
    if(!((signed int)ept[-1l] == 32))
    {
      if(!((signed int)ept[-1l] == 9))
        break;

    }

  if((signed int)*text == 34)
  {
    spt = text + (signed long int)1;
    if(!(spt >= ept))
    {
      if((signed int)ept[-1l] == 34)
        ept = ept - 1l;

    }

  }

  *ept = (char)0;
  return spt;
}

// dec_to_bcd
// file libburn/sector.c line 780
signed int dec_to_bcd(signed int d)
{
  signed int top;
  signed int bottom;
  top = d / 10;
  bottom = d - top * 10;
  return (top << 4) + bottom;
}

// drive_getcaps
// file libburn/drive.c line 1196
static signed int drive_getcaps(struct burn_drive *d, struct burn_drive_info *out)
{
  struct burn_scsi_inquiry_data *id;
  signed int i;
  signed int profile;
  struct burn_feature_descr *feat;
  signed int return_value_burn_drive_has_feature$1;
  if(!(d->idata->valid >= 1))
    return 0;

  else
  {
    id = (struct burn_scsi_inquiry_data *)d->idata;
    memcpy((void *)out->vendor, (const void *)id->vendor, sizeof(char [9l]) /*9ul*/ );
    strip_spaces(out->vendor, sizeof(char [9l]) /*9ul*/ );
    memcpy((void *)out->product, (const void *)id->product, sizeof(char [17l]) /*17ul*/ );
    strip_spaces(out->product, sizeof(char [17l]) /*17ul*/ );
    memcpy((void *)out->revision, (const void *)id->revision, sizeof(char [5l]) /*5ul*/ );
    strip_spaces(out->revision, sizeof(char [5l]) /*5ul*/ );
    strncpy(out->location, d->devname, (unsigned long int)16);
    out->location[(signed long int)16] = (char)0;
    if(d->mdata->p2a_valid >= 1)
    {
      out->buffer_size = d->mdata->buffer_size;
      out->read_dvdram = (unsigned int)!(!(d->mdata->dvdram_read != 0));
      out->read_dvdr = (unsigned int)!(!(d->mdata->dvdr_read != 0));
      out->read_dvdrom = (unsigned int)!(!(d->mdata->dvdrom_read != 0));
      out->read_cdr = (unsigned int)!(!(d->mdata->cdr_read != 0));
      out->read_cdrw = (unsigned int)!(!(d->mdata->cdrw_read != 0));
      out->write_dvdram = (unsigned int)!(!(d->mdata->dvdram_write != 0));
      out->write_dvdr = (unsigned int)!(!(d->mdata->dvdr_write != 0));
      out->write_cdr = (unsigned int)!(!(d->mdata->cdr_write != 0));
      out->write_cdrw = (unsigned int)!(!(d->mdata->cdrw_write != 0));
      out->write_simulate = (unsigned int)!(!(d->mdata->simulate != 0));
      out->c2_errors = (unsigned int)!(!(d->mdata->c2_pointers != 0));
    }

    else
    {
      out->read_dvdr = (unsigned int)0;
      out->read_dvdram = (unsigned int)out->read_dvdr;
      out->buffer_size = (signed int)(unsigned int)out->read_dvdram;
      out->read_cdrw = (unsigned int)0;
      out->read_cdr = (unsigned int)out->read_cdrw;
      out->read_dvdrom = (unsigned int)out->read_cdr;
      out->write_cdr = (unsigned int)0;
      out->write_dvdr = (unsigned int)out->write_cdr;
      out->write_dvdram = (unsigned int)out->write_dvdr;
      out->c2_errors = (unsigned int)0;
      out->write_simulate = (unsigned int)out->c2_errors;
      out->write_cdrw = (unsigned int)out->write_simulate;
      i = 0;
      for( ; !(i >= d->num_profiles); i = i + 1)
      {
        profile = (signed int)d->all_profiles[(signed long int)(i * 4)] << 8 | (signed int)d->all_profiles[(signed long int)(i * 4 + 1)];
        if(profile == 0x09)
        {
          out->read_cdr = (unsigned int)1;
          out->write_cdr = (unsigned int)out->read_cdr;
        }

        else
          if(profile == 0x0a)
          {
            out->read_cdrw = (unsigned int)1;
            out->write_cdrw = (unsigned int)out->read_cdrw;
          }

          else
            if(profile == 0x10)
              out->read_dvdrom = (unsigned int)1;

            else
              if(profile == 0x11)
              {
                out->read_dvdr = (unsigned int)1;
                out->write_dvdr = (unsigned int)out->read_dvdr;
              }

              else
                if(profile == 0x12)
                {
                  out->read_dvdram = (unsigned int)1;
                  out->write_dvdram = (unsigned int)out->read_dvdram;
                }

      }
      i = 0x002D;
      for( ; !(i >= 48); i = i + 1)
      {
        return_value_burn_drive_has_feature$1=burn_drive_has_feature(d, i, &feat, 0);
        if(!(return_value_burn_drive_has_feature$1 == 0))
        {
          if((signed int)feat->data_lenght >= 1)
            out->write_simulate = (unsigned int)out->write_simulate | (unsigned int)!(!(((signed int)feat->data[(signed long int)0] & 4) != 0));

        }

      }
    }
    out->drive = d;
    _Bool tmp_if_expr$2;
    if(!(out->write_dvdram == 0u))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = out->write_dvdr != 0u ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = out->write_cdrw != 0u ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = out->write_cdr != 0u ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
    {
      d->block_types[(signed long int)BURN_WRITE_TAO] = BURN_BLOCK_MODE1 | BURN_BLOCK_RAW0;
      out->tao_block_types = d->block_types[(signed long int)BURN_WRITE_TAO];
      d->block_types[(signed long int)BURN_WRITE_SAO] = BURN_BLOCK_SAO;
      out->sao_block_types = d->block_types[(signed long int)BURN_WRITE_SAO];
    }

    else
    {
      d->block_types[(signed long int)BURN_WRITE_TAO] = 0;
      out->tao_block_types = d->block_types[(signed long int)BURN_WRITE_TAO];
      d->block_types[(signed long int)BURN_WRITE_SAO] = 0;
      out->sao_block_types = d->block_types[(signed long int)BURN_WRITE_SAO];
    }
    d->block_types[(signed long int)BURN_WRITE_RAW] = 0;
    out->raw_block_types = d->block_types[(signed long int)BURN_WRITE_RAW];
    out->packet_block_types = 0;
    return 1;
  }
}

// enumerate_common
// file libburn/sg-linux.c line 1451
static void enumerate_common(char *fname, signed int fd_in, signed int bus_no, signed int host_no, signed int channel_no, signed int target_no, signed int lun_no)
{
  signed int ret;
  signed int i;
  struct burn_drive out;
  burn_setup_drive(&out, fname);
  ret=burn_scsi_setup_drive(&out, bus_no, host_no, channel_no, target_no, lun_no, 0);
  if(ret >= 1)
  {
    out.fd = -1337;
    out.sibling_count = 0;
    i = 0;
    for( ; !(i >= 5); i = i + 1)
      out.sibling_fds[(signed long int)i] = -1337;
    out.grab = sg_grab;
    out.release = sg_release;
    out.drive_is_open = sg_drive_is_open;
    out.issue_command = sg_issue_command;
    if(fd_in >= 0)
      out.fd = fd_in;

    burn_drive_finish_enum(&out);
  }

}

// erase_worker_func
// file libburn/async.c line 326
static void * erase_worker_func(struct w_list *w)
{
  struct anonymous$0 sigset;
  struct anonymous$0 oldset;
  sigfillset(&sigset);
  sigdelset(&sigset, 11);
  sigdelset(&sigset, 4);
  pthread_sigmask(2, &sigset, &oldset);
  burn_disc_erase_sync(w->u.erase.drive, w->u.erase.fast);
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  remove_worker(return_value_pthread_self$1);
  pthread_sigmask(2, &oldset, (struct anonymous$0 *)(void *)0);
  return (void *)0;
}

// evaluate_transport_success
// file libburn/sg-linux.c line 1891
static signed int evaluate_transport_success(struct burn_drive *d, struct command *c, struct _IO_FILE *fp, unsigned short int host_status, unsigned short int driver_status)
{
  signed int ret;
  signed int do_retry = 0;
  signed int give_up_drive = 0;
  signed int sev;
  char *msg = (char *)(void *)0;
  char *host_problem;
  char *driver_problem;
  char *driver_sugg;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)161, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    _Bool tmp_if_expr$2;
    if((0xf7 & (signed int)driver_status) == 0 && (signed int)host_status == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = c->error != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      ret = 1;

    else
    {
      switch((signed int)host_status)
      {
        case 0x00:
        {
          host_problem = "SG_ERR_DID_OK (No error)";
          break;
        }
        case 0x01:
        {
          host_problem = "SG_ERR_DID_NO_CONNECT (Could not connect before timeout period)";
          give_up_drive = 1;
          break;
        }
        case 0x02:
        {
          host_problem = "SG_ERR_DID_BUS_BUSY (Bus stayed busy through time out period)";
          break;
        }
        case 0x03:
        {
          host_problem = "SG_ERR_DID_TIME_OUT (Timed out for miscellaneous reasons)";
          break;
        }
        case 0x04:
        {
          host_problem = "SG_ERR_DID_BAD_TARGET (Bad target, device not responding ?)";
          give_up_drive = 1;
          break;
        }
        case 0x05:
        {
          host_problem = "SG_ERR_DID_ABORT (Told to abort)";
          break;
        }
        case 0x06:
        {
          host_problem = "SG_ERR_DID_PARITY (Parity error)";
          break;
        }
        case 0x07:
        {
          host_problem = "SG_ERR_DID_ERROR (Internal error detected in the host adapter)";
          give_up_drive = 1;
          break;
        }
        case 0x08:
        {
          host_problem = "SG_ERR_DID_RESET (The SCSI bus or the device have been reset)";
          give_up_drive = 1;
          break;
        }
        case 0x09:
        {
          host_problem = "SG_ERR_DID_BAD_INTR (Got an unexpected interrupt)";
          break;
        }
        case 0x0a:
        {
          host_problem = "SG_ERR_DID_PASSTHROUGH (Force command past mid-layer)";
          break;
        }
        case 0x0b:
        {
          host_problem = "SG_ERR_DID_SOFT_ERROR (The low level driver wants a retry)";
          do_retry = 1;
          break;
        }
        default:
          host_problem = "? (unknown host_status code)";
      }
      if(!((signed int)host_status == 0))
      {
        sprintf(msg, "SCSI command %2.2Xh yielded host problem: ", (unsigned int)c->opcode[(signed long int)0]);
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(msg);
        sprintf(msg + (signed long int)return_value_strlen$3, "0x%x %s", (unsigned int)host_status, host_problem);
        sev = 0x68000000;
        if(give_up_drive == 0 && !(do_retry == 0))
          sev = 0x10000000;

        libdax_msgs_submit(libdax_messenger, d->global_index, 0x000201a7, sev, 0x30000000, msg, 0, 0);
        sprintf(msg, "--- SG_IO: host_status= 0x%x %s", (unsigned int)host_status, host_problem);
        scsi_log_message(d, (void *)fp, msg, 0);
      }

      switch((signed int)driver_status & 0x07)
      {
        case 0:
        {
          driver_problem = "SG_ERR_DRIVER_OK";
          break;
        }
        case 1:
        {
          driver_problem = "SG_ERR_DRIVER_BUSY";
          break;
        }
        case 2:
        {
          driver_problem = "SG_ERR_DRIVER_SOFT";
          break;
        }
        case 3:
        {
          driver_problem = "SG_ERR_DRIVER_MEDIA";
          break;
        }
        case 4:
        {
          driver_problem = "SG_ERR_DRIVER_ERROR";
          break;
        }
        case 5:
        {
          driver_problem = "SG_ERR_DRIVER_INVALID";
          break;
        }
        case 6:
        {
          driver_problem = "SG_ERR_DRIVER_TIMEOUT";
          break;
        }
        case 7:
        {
          driver_problem = "SG_ERR_DRIVER_HARD";
          break;
        }
        default:
          driver_problem = "(unknown driver_status code)";
      }
      switch((signed int)driver_status & 0xf0)
      {
        case 0:
        {
          driver_sugg = "(no suggestion)";
          break;
        }
        case 0x10:
        {
          driver_sugg = "SG_ERR_SUGGEST_RETRY";
          do_retry = 1;
          break;
        }
        case 0x20:
        {
          driver_sugg = "SG_ERR_SUGGEST_ABORT";
          give_up_drive = 1;
          break;
        }
        case 0x30:
        {
          driver_sugg = "SG_ERR_SUGGEST_REMAP";
          give_up_drive = 1;
          break;
        }
        case 0x40:
        {
          driver_sugg = "SG_ERR_SUGGEST_DIE";
          give_up_drive = 1;
          break;
        }
        case 0x80:
        {
          driver_sugg = "SG_ERR_SUGGEST_SENSE";
          break;
        }
        default:
          driver_sugg = "(unknown driver_status suggestion)";
      }
      if(!((0xf7 & (signed int)driver_status) == 0))
      {
        sprintf(msg, "SCSI command %2.2Xh yielded driver problem: ", (unsigned int)c->opcode[(signed long int)0]);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(msg);
        sprintf(msg + (signed long int)return_value_strlen$4, "driver_status= 0x%x %s / %s", (unsigned int)driver_status, driver_problem, driver_sugg);
        sev = 0x68000000;
        if(give_up_drive == 0 && !(do_retry == 0))
          sev = 0x10000000;

        libdax_msgs_submit(libdax_messenger, d->global_index, 0x000201a8, sev, 0x30000000, msg, 0, 0);
        sprintf(msg, "--- SG_IO: driver_status= 0x%x %s / %s", (unsigned int)driver_status, driver_problem, driver_sugg);
        scsi_log_message(d, (void *)fp, msg, 0);
      }

      if(do_retry == 0)
        c->error = 1;

      ret = give_up_drive != 0 ? -1 : (do_retry != 0 ? 2 : 0);
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// fifo_free
// file libburn/file.c line 331
static void fifo_free(struct burn_source *source)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  burn_fifo_abort(fs, 0);
  if(!(fs->inp == ((struct burn_source *)NULL)))
    burn_source_free(fs->inp);

  if(!(fs->buf == ((char *)NULL)))
    burn_os_free_buffer((void *)fs->buf, (unsigned long int)fs->chunksize * (unsigned long int)fs->chunks, 0);

  free((void *)(char *)fs);
}

// fifo_get_size
// file libburn/file.c line 315
static signed long int fifo_get_size(struct burn_source *source)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  signed long int return_value;
  return_value=fs->inp->get_size(fs->inp);
  return return_value;
}

// fifo_read
// file libburn/file.c line 228
static signed int fifo_read(struct burn_source *source, unsigned char *buffer, signed int size)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  signed int ret;
  signed int todo;
  signed int rpos;
  signed int bufsize;
  signed int diff;
  signed int counted = 0;
  if(!(fs->end_of_consumption == 0))
    return 0;

  else
  {
    if(fs->is_started == 0)
    {
      ret=burn_fifo_start(source, 0);
      if(!(ret >= 1))
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x00020152, 0x70000000, 0x30000000, "Cannot start fifo thread", 0, 0);
        fs->end_of_consumption = 1;
        return -1;
      }

      fs->is_started = 1;
    }

    if(size == 0)
      return 0;

    else
    {
      todo = size;
      bufsize = fs->chunksize * fs->chunks;
      for( ; todo >= 1; todo = todo - diff)
      {
        rpos = fs->buf_readpos;
        while(rpos == fs->buf_writepos)
        {
          if(!(fs->end_of_input == 0))
            break;

          if(!(fs->input_error == 0))
          {
            if(!(todo >= size))
              break;

            fs->end_of_consumption = 1;
            libdax_msgs_submit(libdax_messenger, -1, 0x00020154, 0x30000000, 0x30000000, "Forwarded input error ends output", 0, 0);
            return -1;
          }

          if(counted == 0)
            fs->empty_counter = fs->empty_counter + 1;

          counted = 1;
          fifo_sleep(0);
        }
        diff = fs->buf_writepos - rpos;
        if(diff == 0)
          break;

        if(!(diff >= 1))
          diff = bufsize - rpos;

        if(!(todo >= diff))
          diff = todo;

        memcpy((void *)buffer, (const void *)(fs->buf + (signed long int)(size - todo) + (signed long int)rpos), (unsigned long int)diff);
        fs->buf_readpos = fs->buf_readpos + diff;
        if(fs->buf_readpos >= bufsize)
          fs->buf_readpos = 0;

      }
      if(!(size + -todo >= 1))
        fs->end_of_consumption = 1;

      else
        fs->out_counter = fs->out_counter + (signed long int)(size - todo);
      fs->get_counter = fs->get_counter + 1;
      return size - todo;
    }
  }
}

// fifo_set_size
// file libburn/file.c line 323
static signed int fifo_set_size(struct burn_source *source, signed long int size)
{
  struct burn_source_fifo *fs = (struct burn_source_fifo *)source->data;
  signed int return_value;
  return_value=fs->inp->set_size(fs->inp, size);
  return return_value;
}

// fifo_sleep
// file libburn/file.c line 219
static signed int fifo_sleep(signed int flag)
{
  static unsigned long int sleeptime = (unsigned long int)50000;
  usleep((unsigned int)sleeptime);
  return 0;
}

// fifo_worker_func
// file libburn/async.c line 705
static void * fifo_worker_func(struct w_list *w)
{
  signed int old;
  struct anonymous$0 sigset;
  struct anonymous$0 oldset;
  sigfillset(&sigset);
  sigdelset(&sigset, 11);
  sigdelset(&sigset, 4);
  pthread_sigmask(2, &sigset, &oldset);
  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  burn_fifo_source_shoveller(w->u.fifo.source, w->u.fifo.flag);
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  remove_worker(return_value_pthread_self$1);
  pthread_sigmask(2, &oldset, (struct anonymous$0 *)(void *)0);
  return (void *)0;
}

// file_free
// file libburn/file.c line 86
static void file_free(struct burn_source *source)
{
  struct burn_source_file *fs = (struct burn_source_file *)source->data;
  close(fs->datafd);
  if(!(source->read_sub == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL)))
    close(fs->subfd);

  free((void *)fs);
}

// file_read
// file libburn/file.c line 68
static signed int file_read(struct burn_source *source, unsigned char *buffer, signed int size)
{
  struct burn_source_file *fs = (struct burn_source_file *)source->data;
  signed int return_value_read_full_buffer$1;
  return_value_read_full_buffer$1=read_full_buffer(fs->datafd, buffer, size);
  return return_value_read_full_buffer$1;
}

// file_read_sub
// file libburn/file.c line 77
static signed int file_read_sub(struct burn_source *source, unsigned char *buffer, signed int size)
{
  struct burn_source_file *fs = (struct burn_source_file *)source->data;
  signed int return_value_read_full_buffer$1;
  return_value_read_full_buffer$1=read_full_buffer(fs->subfd, buffer, size);
  return return_value_read_full_buffer$1;
}

// file_set_size
// file libburn/file.c line 112
static signed int file_set_size(struct burn_source *source, signed long int size)
{
  struct burn_source_file *fs = (struct burn_source_file *)source->data;
  fs->fixed_size = size;
  return 1;
}

// file_size
// file libburn/file.c line 96
static signed long int file_size(struct burn_source *source)
{
  struct stat buf;
  struct burn_source_file *fs = (struct burn_source_file *)source->data;
  if(fs->fixed_size >= 1l)
    return fs->fixed_size;

  else
  {
    signed int return_value_fstat$1;
    return_value_fstat$1=fstat(fs->datafd, &buf);
    if(!(return_value_fstat$1 == 0))
      return (signed long int)0;

    else
      if(!((61440u & buf.st_mode) == 32768u))
        return (signed long int)0;

      else
        return (signed long int)buf.st_size;
  }
}

// find_worker
// file libburn/async.c line 126
static struct w_list * find_worker(struct burn_drive *d)
{
  struct w_list *a = workers;
  for( ; !(a == ((struct w_list *)NULL)); a = a->next)
    if(a->drive == d)
      return a;

  return (struct w_list *)(void *)0;
}

// fname_drive_is_listed
// file libburn/sg-linux.c line 1237
static signed int fname_drive_is_listed(char *fname, signed int flag)
{
  char other_fname[80l];
  signed int return_value_burn_drive_is_listed$1;
  return_value_burn_drive_is_listed$1=burn_drive_is_listed(fname, (struct burn_drive **)(void *)0, 0);
  signed int return_value_burn_drive_is_listed$2;
  if(!(return_value_burn_drive_is_listed$1 == 0))
    return 1;

  else
  {
    signed int return_value_fname_other_name$3;
    return_value_fname_other_name$3=fname_other_name(fname, other_fname, 0);
    if(return_value_fname_other_name$3 >= 1)
    {
      return_value_burn_drive_is_listed$2=burn_drive_is_listed(other_fname, (struct burn_drive **)(void *)0, 0);
      if(!(return_value_burn_drive_is_listed$2 == 0))
        return 2;

    }

    return 0;
  }
}

// fname_enumerate
// file libburn/sg-linux.c line 1255
static signed int fname_enumerate(char *fname, signed int flag)
{
  signed int is_ata = 0;
  signed int is_scsi = 0;
  signed int ret;
  signed int fd = -1;
  signed int bus_no = -1;
  signed int host_no = -1;
  signed int channel_no = -1;
  signed int target_no = -1;
  signed int lun_no = -1;
  char *msg = (char *)(void *)0;
  struct stat stbuf;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(1024 + 80), 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_fname_drive_is_listed$2;
  signed int return_value_stat$3;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    if((2 & flag) == 0)
    {
      return_value_fname_drive_is_listed$2=fname_drive_is_listed(fname, 0);
      if(!(return_value_fname_drive_is_listed$2 == 0))
      {
        ret = 2;
        goto ex;
      }

    }

    return_value_stat$3=stat(fname, &stbuf);
    if(return_value_stat$3 == -1)
    {
      sprintf(msg, "File object '%s' not found", fname);
      if((1 & flag) == 0)
        libdax_msgs_submit(libdax_messenger, -1, 0x0002000b, 0x68000000, 0x30000000, msg, 0, 0);

      ret = -1;
    }

    else
    {
      fd=sg_open_for_enumeration(fname, (signed int)!(!((flag & 4) != 0)));
      if(!(fd >= 0))
        ret = 0;

      else
      {
        is_ata=is_ata_drive(fname, fd);
        if(!(is_ata >= 0))
          ret = -1;

        else
        {
          if(is_ata == 0)
            is_scsi=is_scsi_drive(fname, fd, &bus_no, &host_no, &channel_no, &target_no, &lun_no);

          if(!(is_scsi >= 0))
            ret = -1;

          else
            if(is_ata == 0 && is_scsi == 0)
              ret = 0;

            else
            {
              if(!(linux_sg_enumerate_debug == 0))
                fprintf(stderr, "(single) accepting as SCSI %d,%d,%d,%d bus=%d\n", host_no, channel_no, target_no, lun_no, bus_no);

              enumerate_common(fname, fd, bus_no, host_no, channel_no, target_no, lun_no);
              ret = 1;
            }
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// fname_other_name
// file libburn/sg-linux.c line 1216
static signed int fname_other_name(char *fname, char *other_name, signed int flag)
{
  signed int return_value_strncmp$4;
  return_value_strncmp$4=strncmp(fname, "/dev/sr", (unsigned long int)7);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(return_value_strncmp$4 == 0)
  {
    if((signed int)fname[7l] >= 48)
    {
      if(!((signed int)fname[7l] >= 58))
      {
        _Bool tmp_if_expr$3;
        if((signed int)fname[8l] == 0)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          if((signed int)fname[8l] >= 48)
            tmp_if_expr$1 = (signed int)fname[(signed long int)8] <= 57 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
            tmp_if_expr$2 = (signed int)fname[(signed long int)9] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          sprintf(other_name, "/dev/scd%s", fname + (signed long int)7);
          return 1;
        }

      }

    }

  }

  signed int return_value_strncmp$8;
  return_value_strncmp$8=strncmp(fname, "/dev/scd", (unsigned long int)8);
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(return_value_strncmp$8 == 0)
  {
    if((signed int)fname[8l] >= 48)
    {
      if(!((signed int)fname[8l] >= 58))
      {
        _Bool tmp_if_expr$7;
        if((signed int)fname[9l] == 0)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          if((signed int)fname[9l] >= 48)
            tmp_if_expr$5 = (signed int)fname[(signed long int)9] <= 57 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          if(tmp_if_expr$5)
            tmp_if_expr$6 = (signed int)fname[(signed long int)10] == 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          sprintf(other_name, "/dev/sr%s", fname + (signed long int)8);
          return 1;
        }

      }

    }

  }

  return 0;
}

// format_worker_func
// file libburn/async.c line 424
static void * format_worker_func(struct w_list *w)
{
  struct anonymous$0 sigset;
  struct anonymous$0 oldset;
  sigfillset(&sigset);
  sigdelset(&sigset, 11);
  sigdelset(&sigset, 4);
  pthread_sigmask(2, &sigset, &oldset);
  burn_disc_format_sync(w->u.format.drive, w->u.format.size, w->u.format.flag);
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  remove_worker(return_value_pthread_self$1);
  pthread_sigmask(2, &oldset, (struct anonymous$0 *)(void *)0);
  return (void *)0;
}

// get_bytes
// file libburn/sector.c line 107
static void get_bytes(struct burn_track *track, signed int count, unsigned char *data)
{
  signed int valid;
  signed int shortage;
  signed int curr;
  signed int i;
  signed int tr;
  if(track == ((struct burn_track *)NULL))
    memset((void *)data, 0, (unsigned long int)count);

  else
  {
    valid = track->offset - track->offsetcount;
    if(!(count >= valid))
      valid = count;

    if(!(valid == 0))
    {
      track->offsetcount = track->offsetcount + valid;
      memset((void *)data, 0, (unsigned long int)valid);
    }

    shortage = count - valid;
    if(!(shortage == 0))
    {
      curr = valid;
      if(track->eos == 0)
      {
        if(!(track->source->read == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL)))
          valid=track->source->read(track->source, data + (signed long int)curr, count - curr);

        else
          valid=track->source->read_xt(track->source, data + (signed long int)curr, count - curr);
      }

      else
        valid = 0;
      if(!(valid >= 1))
      {
        track->eos = 1;
        valid = 0;
      }

      track->sourcecount = track->sourcecount + (signed long int)valid;
      curr = curr + valid;
      shortage = count - curr;
      if(!(shortage == 0))
      {
        valid = track->tail - track->tailcount;
        if(!(count + -curr >= valid))
          valid = count - curr;

        if(!(valid == 0))
        {
          track->tailcount = track->tailcount + valid;
          memset((void *)(data + (signed long int)curr), 0, (unsigned long int)valid);
        }

        curr = curr + valid;
        shortage = shortage - valid;
        if(!(shortage == 0))
        {
          if(shortage >= count)
            track->track_data_done = 1;

          if(!(track->end_on_premature_eoi == 0))
          {
            if(shortage >= count)
            {
              if(track->open_ended == 0)
              {
                char msg[80l];
                signed long int missing;
                signed long int inp_block_size;
                signed long int track_blocks;
                signed int return_value_burn_sector_length$1;
                return_value_burn_sector_length$1=burn_sector_length(track->mode);
                inp_block_size = (signed long int)return_value_burn_sector_length$1;
                signed int return_value_burn_track_get_sectors_2$2;
                return_value_burn_track_get_sectors_2$2=burn_track_get_sectors_2(track, 1);
                track_blocks = (signed long int)return_value_burn_track_get_sectors_2$2;
                missing = track_blocks * inp_block_size - track->sourcecount;
                sprintf(msg, "Premature end of input encountered. Missing: %.f bytes", (double)missing);
                libdax_msgs_submit(libdax_messenger, -1, 0x00020180, 0x68000000, 0x30000000, msg, 0, 0);
                track->end_on_premature_eoi = 2;
              }

            }

          }

          _Bool tmp_if_expr$3;
          if(!(track->open_ended == 0))
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = track->end_on_premature_eoi != 0 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$3)
          {
            if(!(track->source->next == ((struct burn_source *)NULL)))
            {
              struct burn_source *src;
              printf("pulling from next track\n");
              src = track->source->next;
              valid=src->read(src, data + (signed long int)curr, shortage);
              if(valid >= 1)
              {
                shortage = shortage - valid;
                curr = curr + valid;
              }

            }

          }

        }

      }

    }


  ex:
    ;
    if(!(shortage == 0))
      memset((void *)(data + (signed long int)curr), 0, (unsigned long int)shortage);

    if(track->swap_source_bytes == 1)
    {
      i = 1;
      for( ; !(i >= count); i = i + 2)
      {
        tr = (signed int)data[(signed long int)i];
        data[(signed long int)i] = data[(signed long int)(i - 1)];
        data[(signed long int)(i - 1)] = (unsigned char)tr;
      }
    }

  }
}

// get_outmode
// file libburn/sector.c line 97
static signed int get_outmode(struct burn_write_opts *o)
{
  signed int return_value_sector_get_outmode$1;
  return_value_sector_get_outmode$1=sector_get_outmode(o->write_type, o->block_type);
  return return_value_sector_get_outmode$1;
}

// get_sector
// file libburn/sector.c line 276
static unsigned char * get_sector(struct burn_write_opts *opts, struct burn_track *track, signed int inmode)
{
  struct burn_drive *d = opts->drive;
  struct buffer *out = d->buffer;
  signed int outmode;
  signed int seclen;
  signed int write_ret;
  unsigned char *ret;
  outmode=get_outmode(opts);
  if(outmode == 0)
    outmode = inmode;

  seclen=burn_sector_length(outmode);
  _Bool tmp_if_expr$2;
  if(!(seclen >= 1))
    return (unsigned char *)(void *)0;

  else
  {
    signed int return_value_burn_subcode_length$1;
    return_value_burn_subcode_length$1=burn_subcode_length(outmode);
    seclen = seclen + return_value_burn_subcode_length$1;
    _Bool tmp_if_expr$3;
    if(out->bytes + seclen >= 65537)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if(opts->obs >= 1)
        tmp_if_expr$2 = out->bytes + seclen > opts->obs ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      write_ret=sector_write_buffer(d, track, 0);
      if(write_ret >= 1)
        goto __CPROVER_DUMP_L7;

      return (unsigned char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      ret = out->data + (signed long int)out->bytes;
      out->bytes = out->bytes + seclen;
      out->sectors = out->sectors + 1;
      return ret;
    }
  }
}

// interpret_performance
// file libburn/mmc.c line 4292
static signed int interpret_performance(struct burn_drive *d, struct command *c, signed int descr_type, signed int *alloc_len, signed int *max_descr, signed int *num_descr, signed int flag)
{
  signed int len;
  signed int i;
  signed int b;
  signed int ret;
  signed int old_alloc_len;
  signed int exact_bit;
  signed int read_speed;
  signed int write_speed;
  signed int start_speed;
  signed int min_write_speed = 0x7fffffff;
  signed int max_write_speed = 0;
  signed int min_read_speed = 0x7fffffff;
  signed int max_read_speed = 0;
  unsigned long int end_lba;
  unsigned char *pd;
  struct burn_speed_descriptor *sd;
  len=mmc_four_char_to_int(c->page->data);
  old_alloc_len = *alloc_len;
  *alloc_len = len + 4;
  if(!(old_alloc_len >= 4 + len))
    len = old_alloc_len - 4;

  *num_descr = (*alloc_len - 8) / 16;
  if(*max_descr == 0)
  {
    *max_descr = *num_descr;
    ret = 1;
  }

  else
    if(!(old_alloc_len >= 16))
      ret = 1;

    else
      if(!(len >= 12))
        ret = 0;

      else
      {
        min_write_speed = d->mdata->min_write_speed;
        max_write_speed = d->mdata->max_write_speed;
        pd = c->page->data;
        if(!(*max_descr >= *num_descr))
          *num_descr = *max_descr;

        i = 0;
        for( ; !((1 & flag) == 0) && !(i >= *num_descr); i = i + 1)
        {
          start_speed = 0;
          write_speed = start_speed;
          read_speed = write_speed;
          end_lba = (unsigned long int)read_speed;
          static signed int speed_debug = 0;
          if(descr_type == 0x03)
          {
            exact_bit = (signed int)!(!(((signed int)pd[(signed long int)(8 + i * 16)] & 2) != 0));
            b = 0;
            for( ; !(b >= 4); b = b + 1)
            {
              end_lba = end_lba + ((unsigned long int)pd[(signed long int)(8 + i * 16 + 4 + b)] << 24 - 8 * b);
              read_speed = read_speed + ((signed int)pd[(signed long int)(8 + i * 16 + 8 + b)] << 24 - 8 * b);
              write_speed = write_speed + ((signed int)pd[(signed long int)(8 + i * 16 + 12 + b)] << 24 - 8 * b);
            }
            if(end_lba >= 2147483647ul)
              end_lba = (unsigned long int)0x7ffffffe;

            if(!(speed_debug == 0))
              fprintf(stderr, "LIBBURN_DEBUG: kB/s: write=%d  read=%d  end=%lu  exact=%d\n", write_speed, read_speed, end_lba, exact_bit);

            ret=new_burn_speed_descr(d, 2, &sd, 0);
            if(ret >= 1)
            {
              sd->wrc = (signed int)pd[(signed long int)(8 + i * 16)] >> 3 & 3;
              sd->exact = exact_bit;
              sd->mrw = (signed int)pd[(signed long int)(8 + i * 16)] & 1;
              sd->end_lba = (signed int)end_lba;
              sd->write_speed = write_speed;
              sd->read_speed = read_speed;
            }

          }

          else
          {
            b = 0;
            for( ; !(b >= 4); b = b + 1)
            {
              start_speed = start_speed + ((signed int)pd[(signed long int)(8 + i * 16 + 4 + b)] << 24 - 8 * b);
              end_lba = end_lba + ((unsigned long int)pd[(signed long int)(8 + i * 16 + 8 + b)] << 24 - 8 * b);
              read_speed = read_speed + ((signed int)pd[(signed long int)(8 + i * 16 + 12 + b)] << 24 - 8 * b);
            }
            if(!(speed_debug == 0))
              fprintf(stderr, "LIBBURN_DEBUG: start=%d  end=%d  lba=%lu\n", start_speed, read_speed, end_lba);

            if(end_lba >= 2147483647ul)
              end_lba = (unsigned long int)0x7ffffffe;

            ret=new_burn_speed_descr(d, 3, &sd, 0);
            if(ret >= 1)
            {
              sd->end_lba = (signed int)end_lba;
              sd->read_speed = start_speed;
            }

            if(start_speed >= 1 && !(start_speed >= min_read_speed))
              min_read_speed = start_speed;

            if(!(max_read_speed >= start_speed))
              max_read_speed = start_speed;

            ret=new_burn_speed_descr(d, 3, &sd, 0);
            if(ret >= 1)
            {
              sd->end_lba = (signed int)end_lba;
              sd->read_speed = read_speed;
            }

          }
          if(!(d->mdata->max_end_lba >= (signed int)end_lba))
            d->mdata->max_end_lba = (signed int)end_lba;

          if(!((signed int)end_lba >= d->mdata->min_end_lba))
            d->mdata->min_end_lba = (signed int)end_lba;

          if(write_speed >= 1 && !(write_speed >= min_write_speed))
            min_write_speed = write_speed;

          if(!(max_write_speed >= write_speed))
            max_write_speed = write_speed;

          if(read_speed >= 1 && !(read_speed >= min_read_speed))
            min_read_speed = read_speed;

          if(!(max_read_speed >= read_speed))
            max_read_speed = read_speed;

        }
        if(!(min_write_speed >= 0x7fffffff))
          d->mdata->min_write_speed = min_write_speed;

        if(max_write_speed >= 1)
          d->mdata->max_write_speed = max_write_speed;

        if(max_read_speed >= 1)
          d->mdata->max_read_speed = max_read_speed;

        ret = 1;
      }

ex:
  ;
  return ret;
}

// is_ata_drive
// file libburn/sg-linux.c line 912
static signed int is_ata_drive(char *fname, signed int fd_in)
{
  signed int fd;
  struct hd_driveid tm;
  if(fd_in >= 0)
    fd = fd_in;

  else
    fd=sg_open_drive_fd(fname, 1);
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(fd == -1)
  {
    if(!(linux_ata_enumerate_verbous == 0))
    {
      return_value___errno_location$1=__errno_location();
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "open failed, errno=%d  '%s'\n", *return_value___errno_location$1, return_value_strerror$3);
    }

    return 0;
  }

  memset((void *)&tm, 0, sizeof(struct hd_driveid) /*512ul*/ );
  ioctl(fd, (unsigned long int)0x030d, &tm);
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int *return_value___errno_location$8;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if((0x8000 & (signed int)tm.config) == 0 || !((0x4000 & (signed int)tm.config) == 0))
  {
    if(!(linux_ata_enumerate_verbous == 0))
      fprintf(stderr, "not marked as ATAPI\n");

    if(!(fd_in >= 0))
      sg_close_drive_fd(fname, -1, &fd, 0);

    return 0;
  }

  else
  {
    signed int return_value_sgio_test$7;
    return_value_sgio_test$7=sgio_test(fd);
    if(return_value_sgio_test$7 == -1)
    {
      if(!(linux_ata_enumerate_verbous == 0))
      {
        return_value___errno_location$4=__errno_location();
        return_value___errno_location$5=__errno_location();
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        fprintf(stderr, "FATAL: sgio_test() failed: errno=%d  '%s'\n", *return_value___errno_location$4, return_value_strerror$6);
      }

      if(!(fd_in >= 0))
        sg_close_drive_fd(fname, -1, &fd, 0);

      return 0;
    }

    if(fd_in >= 0)
      return 1;

    else
    {
      signed int return_value_sg_close_drive_fd$11;
      return_value_sg_close_drive_fd$11=sg_close_drive_fd(fname, -1, &fd, 1);
      if(!(return_value_sg_close_drive_fd$11 >= 1))
      {
        if(!(linux_ata_enumerate_verbous == 0))
        {
          return_value___errno_location$8=__errno_location();
          return_value___errno_location$9=__errno_location();
          return_value_strerror$10=strerror(*return_value___errno_location$9);
          fprintf(stderr, "cannot close properly, errno=%d  '%s'\n", *return_value___errno_location$8, return_value_strerror$10);
        }

        return 0;
      }

      return 1;
    }
  }
}

// is_payload_text_end
// file libburn/cdtext.c line 1273
static signed int is_payload_text_end(unsigned char *payload, signed int payload_count, signed int i, signed int flag)
{
  if(i >= payload_count)
    return 1;

  else
    if(!(payload[(signed long int)i] == 0))
      return 0;

    else
      if((1 & flag) == 0)
        return 1;

      else
        if(1 + i >= payload_count)
          return 1;

        else
          if((signed int)payload[(signed long int)(1 + i)] == 0)
            return 1;

          else
            return 0;
}

// is_scsi_drive
// file libburn/sg-linux.c line 964
static signed int is_scsi_drive(char *fname, signed int fd_in, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no)
{
  signed int fd = -1;
  signed int sid_ret = 0;
  signed int ret;
  signed int fail_sev_sorry = 0;
  struct sg_scsi_id sid;
  signed int *sibling_fds = (signed int *)(void *)0;
  signed int sibling_count = 0;
  char (*sibling_fnames)[16l] = (char (*)[16l])(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(signed int) /*4ul*/ , (unsigned long int)5, 0);
  sibling_fds = (signed int *)return_value_burn_alloc_mem$1;
  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  signed int *return_value___errno_location$9;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  signed int return_value_ioctl$14;
  if(sibling_fds == ((signed int *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char [16l]) /*16ul*/ , (unsigned long int)5, 0);
    sibling_fnames = (char (*)[16l])return_value_burn_alloc_mem$2;
    if(sibling_fnames == ((char (*)[16l])NULL))
      ret = -1;

    else
    {
      if(fd_in >= 0)
        fd = fd_in;

      else
        fd=sg_open_drive_fd(fname, 1);
      if(fd == -1)
      {
        if(!(linux_sg_enumerate_debug == 0))
        {
          return_value___errno_location$3=__errno_location();
          return_value___errno_location$4=__errno_location();
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          fprintf(stderr, "open failed, errno=%d  '%s'\n", *return_value___errno_location$3, return_value_strerror$5);
        }

        ret = 0;
        goto ex;
      }

      sid_ret=ioctl(fd, (unsigned long int)0x2276, &sid);
      if(sid_ret == -1)
      {
        sid.scsi_id = -1;
        if(!(linux_sg_enumerate_debug == 0))
        {
          return_value___errno_location$6=__errno_location();
          return_value___errno_location$7=__errno_location();
          return_value_strerror$8=strerror(*return_value___errno_location$7);
          fprintf(stderr, "ioctl(SG_GET_SCSI_ID) failed, errno=%d  '%s' , ", *return_value___errno_location$6, return_value_strerror$8);
        }

        signed int return_value_sgio_test$12;
        return_value_sgio_test$12=sgio_test(fd);
        if(return_value_sgio_test$12 == -1)
        {
          if(!(linux_sg_enumerate_debug == 0))
          {
            return_value___errno_location$9=__errno_location();
            return_value___errno_location$10=__errno_location();
            return_value_strerror$11=strerror(*return_value___errno_location$10);
            fprintf(stderr, "FATAL: sgio_test() failed: errno=%d  '%s'", *return_value___errno_location$9, return_value_strerror$11);
          }

          ret = 0;
          goto ex;
        }

        sid_ret=ioctl(fd, (unsigned long int)0x5326, 0);
        if(!(linux_sg_enumerate_debug == 0))
          fprintf(stderr, "ioctl(CDROM_DRIVE_STATUS) = %d , ", sid_ret);

        if(!(sid_ret == 0) && !(sid_ret == -1))
          sid.scsi_type = 0x05;

        else
          sid_ret = -1;
      }

      if(sid_ret == -1)
      {
        signed int return_value_sgio_inquiry_cd_drive$13;
        return_value_sgio_inquiry_cd_drive$13=sgio_inquiry_cd_drive(fd, fname);
        if(return_value_sgio_inquiry_cd_drive$13 == 1)
        {
          sid_ret = 0;
          sid.scsi_type = 0x05;
        }

      }

      return_value_ioctl$14=ioctl(fd, (unsigned long int)0x5386, bus_no);
      if(return_value_ioctl$14 == -1)
        *bus_no = -1;

      fail_sev_sorry = (signed int)(sid.scsi_type == 0x05);
      if(linux_sg_accept_any_type == 0 && (sid_ret == -1 || !(sid.scsi_type == 0x05)))
      {
        if(!(linux_sg_enumerate_debug == 0))
          fprintf(stderr, "sid.scsi_type = %d (!= TYPE_ROM)\n", sid.scsi_type);

        ret = 0;
      }

      else
        if(sid_ret == -1 || !(sid.scsi_id >= 0))
        {
          ret=sg_obtain_scsi_adr_fd(fname, fd, bus_no, host_no, channel_no, target_no, lun_no);
          if(ret >= 1)
          {
            sid.host_no = *host_no;
            sid.channel = *channel_no;
            sid.scsi_id = *target_no;
            sid.lun = *lun_no;
            goto __CPROVER_DUMP_L21;
          }

          if(!(linux_sg_enumerate_debug == 0))
            fprintf(stderr, "sg_obtain_scsi_adr_fd() failed\n");

          ret = 0;
        }

        else
        {

        __CPROVER_DUMP_L21:
          ;
          if(burn_sg_open_o_excl >= 2)
          {
            ret=sg_open_scsi_siblings(fname, -1, sibling_fds, sibling_fnames, &sibling_count, sid.host_no, sid.channel, sid.scsi_id, sid.lun);
            if(!(ret >= 1))
            {
              if(!(linux_sg_enumerate_debug == 0))
                fprintf(stderr, "cannot lock siblings\n");

              sg_handle_busy_device(fname, 0);
              ret = 0;
              goto ex;
            }

            sg_release_siblings(sibling_fds, sibling_fnames, &sibling_count);
          }

          if(*bus_no == -1)
            *bus_no = 1000 * (sid.host_no + 1) + sid.channel;

          *host_no = sid.host_no;
          *channel_no = sid.channel;
          *target_no = sid.scsi_id;
          *lun_no = sid.lun;
          ret = 1;
        }
    }
  }

ex:
  ;
  signed int *return_value___errno_location$15;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  if(fd >= 0 && !(fd_in >= 0))
  {
    signed int return_value_sg_close_drive_fd$18;
    return_value_sg_close_drive_fd$18=sg_close_drive_fd(fname, -1, &fd, fail_sev_sorry);
    if(!(return_value_sg_close_drive_fd$18 >= 1))
    {
      if(!(linux_sg_enumerate_debug == 0))
      {
        return_value___errno_location$15=__errno_location();
        return_value___errno_location$16=__errno_location();
        return_value_strerror$17=strerror(*return_value___errno_location$16);
        fprintf(stderr, "cannot close properly, errno=%d  '%s'\n", *return_value___errno_location$15, return_value_strerror$17);
      }

      if(ret >= 1)
        ret = 0;

    }

  }

  if(!(sibling_fds == ((signed int *)NULL)))
    free((void *)(char *)sibling_fds);

  if(!(sibling_fnames == ((char (*)[16l])NULL)))
    free((void *)(char *)sibling_fnames);

  return ret;
}

// libdax_audioxtr_destroy
// file libburn/libdax_audioxtr.c line 74
signed int libdax_audioxtr_destroy(struct libdax_audioxtr **xtr, signed int flag)
{
  struct libdax_audioxtr *o = *xtr;
  signed int return_value_strcmp$1;
  if(o == ((struct libdax_audioxtr *)NULL))
    return 0;

  else
  {
    if(o->fd >= 0)
    {
      return_value_strcmp$1=strcmp(o->path, "-");
      if(!(return_value_strcmp$1 == 0))
        close(o->fd);

    }

    free((void *)(char *)o);
    *xtr = (struct libdax_audioxtr *)(void *)0;
    return 1;
  }
}

// libdax_audioxtr_detach_fd
// file libburn/libdax_audioxtr.c line 312
signed int libdax_audioxtr_detach_fd(struct libdax_audioxtr *o, signed int *fd, signed int flag)
{
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$3;
  if(!(o->fd >= 0))
    return -1;

  else
  {
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(o->fmt, ".wav");
    if(!(return_value_strcmp$2 == 0))
    {
      return_value_strcmp$1=strcmp(o->fmt, ".au");
      if(!(return_value_strcmp$1 == 0))
        return 0;

    }

    if(!((1 & flag) == 0))
      *fd = o->fd;

    else
    {
      *fd=dup(o->fd);
      if(*fd >= 0)
      {
        return_value_strcmp$3=strcmp(o->path, "-");
        if(!(return_value_strcmp$3 == 0))
          close(o->fd);

      }

    }
    if(*fd >= 0)
    {
      o->fd = -1;
      return 1;
    }

    else
      return -1;
  }
}

// libdax_audioxtr_get_id
// file libburn/libdax_audioxtr.c line 271
signed int libdax_audioxtr_get_id(struct libdax_audioxtr *o, char **fmt, char **fmt_info, signed int *num_channels, signed int *sample_rate, signed int *bits_per_sample, signed int *msb_first, signed int flag)
{
  *fmt = o->fmt;
  *fmt_info = o->fmt_info;
  *num_channels = o->num_channels;
  *sample_rate = o->sample_rate;
  *bits_per_sample = o->bits_per_sample;
  *msb_first = o->msb_first;
  return 1;
}

// libdax_audioxtr_get_size
// file libburn/libdax_audioxtr.c line 286
signed int libdax_audioxtr_get_size(struct libdax_audioxtr *o, signed long int *size, signed int flag)
{
  *size = o->data_size;
  return 1;
}

// libdax_audioxtr_identify
// file libburn/libdax_audioxtr.c line 215
static signed int libdax_audioxtr_identify(struct libdax_audioxtr *o, signed int flag)
{
  signed int ret;
  ret=libdax_audioxtr_identify_wav(o, 0);
  if(!(ret == 0))
    return ret;

  else
    if(o->fd == 0)
      return 0;

    else
    {
      ret=libdax_audioxtr_identify_au(o, 0);
      if(!(ret == 0))
        return ret;

      else
        return 0;
    }
}

// libdax_audioxtr_identify_au
// file libburn/libdax_audioxtr.c line 168
static signed int libdax_audioxtr_identify_au(struct libdax_audioxtr *o, signed int flag)
{
  signed int ret;
  signed int encoding;
  char buf[24l];
  if(!(o->fd == 0))
  {
    signed long int return_value_lseek$1;
    return_value_lseek$1=lseek(o->fd, (signed long int)0, 0);
    ret = (signed int)return_value_lseek$1;
    if(ret == -1)
      return 0;

  }

  signed long int return_value_read$2;
  return_value_read$2=read(o->fd, (void *)buf, (unsigned long int)24);
  ret = (signed int)return_value_read$2;
  if(!(ret >= 24))
    return 0;

  else
  {
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(buf, ".snd", (unsigned long int)4);
    if(!(return_value_strncmp$3 == 0))
      return 0;

    else
    {
      strcpy(o->fmt, ".au");
      o->msb_first = 1;
      o->au_data_location=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)4, 4, 1);
      o->au_data_size=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)8, 4, 1);
      unsigned int return_value_libdax_audioxtr_to_int$4;
      return_value_libdax_audioxtr_to_int$4=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)12, 4, 1);
      encoding = (signed int)return_value_libdax_audioxtr_to_int$4;
      if(encoding == 2)
        o->bits_per_sample = 8;

      else
        if(encoding == 3)
          o->bits_per_sample = 16;

        else
          if(encoding == 4)
            o->bits_per_sample = 24;

          else
            if(encoding == 5)
              o->bits_per_sample = 32;

            else
              o->bits_per_sample = -encoding;
      unsigned int return_value_libdax_audioxtr_to_int$5;
      return_value_libdax_audioxtr_to_int$5=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)16, 4, 1);
      o->sample_rate = (signed int)return_value_libdax_audioxtr_to_int$5;
      unsigned int return_value_libdax_audioxtr_to_int$6;
      return_value_libdax_audioxtr_to_int$6=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)20, 4, 1);
      o->num_channels = (signed int)return_value_libdax_audioxtr_to_int$6;
      if(!(o->au_data_size == 0xffffffff))
        o->data_size = (signed long int)o->au_data_size;

      else
        o->data_size = (signed long int)0;
      sprintf(o->fmt_info, ".au , num_channels=%d , sample_rate=%d , bits_per_sample=%d", o->num_channels, o->sample_rate, o->bits_per_sample);
      return (signed int)(o->bits_per_sample > 0);
    }
  }
}

// libdax_audioxtr_identify_wav
// file libburn/libdax_audioxtr.c line 125
static signed int libdax_audioxtr_identify_wav(struct libdax_audioxtr *o, signed int flag)
{
  signed int ret;
  char buf[45l];
  if(!(o->fd == 0))
  {
    signed long int return_value_lseek$1;
    return_value_lseek$1=lseek(o->fd, (signed long int)0, 0);
    ret = (signed int)return_value_lseek$1;
    if(ret == -1)
      return 0;

  }

  signed long int return_value_read$2;
  return_value_read$2=read(o->fd, (void *)buf, (unsigned long int)44);
  ret = (signed int)return_value_read$2;
  if(!(ret >= 44))
    return 0;

  else
  {
    buf[(signed long int)44] = (char)0;
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(buf, "RIFF", (unsigned long int)4);
    if(!(return_value_strncmp$3 == 0))
      return 0;

    else
    {
      signed int return_value_strncmp$4;
      return_value_strncmp$4=strncmp(buf + (signed long int)8, "WAVE", (unsigned long int)4);
      if(!(return_value_strncmp$4 == 0))
        return 0;

      else
      {
        signed int return_value_strncmp$5;
        return_value_strncmp$5=strncmp(buf + (signed long int)12, "fmt ", (unsigned long int)4);
        if(!(return_value_strncmp$5 == 0))
          return 0;

        else
        {
          _Bool tmp_if_expr$6;
          if(!((signed int)buf[16l] == 16))
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (signed int)buf[(signed long int)17] != 0 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$7;
          if(tmp_if_expr$6)
            tmp_if_expr$7 = (_Bool)1;

          else
            tmp_if_expr$7 = (signed int)buf[(signed long int)18] != 0 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$8;
          if(tmp_if_expr$7)
            tmp_if_expr$8 = (_Bool)1;

          else
            tmp_if_expr$8 = (signed int)buf[(signed long int)19] != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$8)
            return 0;

          else
          {
            _Bool tmp_if_expr$9;
            if(!((signed int)buf[20l] == 1))
              tmp_if_expr$9 = (_Bool)1;

            else
              tmp_if_expr$9 = (signed int)buf[(signed long int)21] != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$9)
              return 0;

            else
            {
              strcpy(o->fmt, ".wav");
              o->msb_first = 0;
              unsigned int return_value_libdax_audioxtr_to_int$10;
              return_value_libdax_audioxtr_to_int$10=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)22, 2, 0);
              o->num_channels = (signed int)return_value_libdax_audioxtr_to_int$10;
              unsigned int return_value_libdax_audioxtr_to_int$11;
              return_value_libdax_audioxtr_to_int$11=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)24, 4, 0);
              o->sample_rate = (signed int)return_value_libdax_audioxtr_to_int$11;
              unsigned int return_value_libdax_audioxtr_to_int$12;
              return_value_libdax_audioxtr_to_int$12=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)34, 2, 0);
              o->bits_per_sample = (signed int)return_value_libdax_audioxtr_to_int$12;
              sprintf(o->fmt_info, ".wav , num_channels=%d , sample_rate=%d , bits_per_sample=%d", o->num_channels, o->sample_rate, o->bits_per_sample);
              o->wav_subchunk2_size=libdax_audioxtr_to_int(o, (unsigned char *)buf + (signed long int)40, 4, 0);
              o->data_size = (signed long int)o->wav_subchunk2_size;
              return 1;
            }
          }
        }
      }
    }
  }
}

// libdax_audioxtr_init_reading
// file libburn/libdax_audioxtr.c line 248
static signed int libdax_audioxtr_init_reading(struct libdax_audioxtr *o, signed int flag)
{
  signed int ret;
  signed long int return_value_lseek$1;
  signed int return_value_strcmp$3;
  signed long int return_value_lseek$2;
  if(o->fd == 0)
    return 1;

  else
  {
    o->extract_count = (signed long int)0;
    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(o->fmt, ".wav");
    if(return_value_strcmp$4 == 0)
    {
      return_value_lseek$1=lseek(o->fd, (signed long int)44, 0);
      ret = (signed int)return_value_lseek$1;
    }

    else
    {
      return_value_strcmp$3=strcmp(o->fmt, ".au");
      if(return_value_strcmp$3 == 0)
      {
        return_value_lseek$2=lseek(o->fd, (signed long int)o->au_data_location, 0);
        ret = (signed int)return_value_lseek$2;
      }

      else
        ret = -1;
    }
    if(ret == -1)
      return 0;

    else
      return 1;
  }
}

// libdax_audioxtr_new
// file libburn/libdax_audioxtr.c line 37
signed int libdax_audioxtr_new(struct libdax_audioxtr **xtr, char *path, signed int flag)
{
  signed int ret = -1;
  struct libdax_audioxtr *o;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct libdax_audioxtr) /*8328ul*/ );
  *xtr = (struct libdax_audioxtr *)return_value_calloc$1;
  o = *xtr;
  if(o == ((struct libdax_audioxtr *)NULL))
    return -1;

  else
  {
    strncpy(o->path, path, (unsigned long int)(4096 - 1));
    o->path[(signed long int)(4096 - 1)] = (char)0;
    o->fd = -1;
    strcpy(o->fmt, "unidentified");
    o->fmt_info[(signed long int)0] = (char)0;
    o->data_size = (signed long int)0;
    o->extract_count = (signed long int)0;
    o->num_channels = 0;
    o->sample_rate = 0;
    o->bits_per_sample = 0;
    o->msb_first = 0;
    o->wav_subchunk2_size = (unsigned int)0;
    o->au_data_location = (unsigned int)0;
    o->au_data_size = 0xffffffff;
    ret=libdax_audioxtr_open(o, 0);
    if(!(ret >= 1))
      ret = -2 * (signed int)(ret < 0);

    else
      return 1;

  failure:
    ;
    libdax_audioxtr_destroy(xtr, 0);
    return ret;
  }
}

// libdax_audioxtr_open
// file libburn/libdax_audioxtr.c line 89
static signed int libdax_audioxtr_open(struct libdax_audioxtr *o, signed int flag)
{
  signed int ret;
  char msg[4176l];
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(o->path, "-");
  if(return_value_strcmp$1 == 0)
    o->fd = 0;

  else
    o->fd=open(o->path, 00 | 0);
  if(!(o->fd >= 0))
  {
    sprintf(msg, "Cannot open audio source file : %s", (const void *)o->path);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    libdax_msgs_submit(libdax_messenger, -1, 0x00020200, 0x60000000, 0x30000000, msg, *return_value___errno_location$2, 0);
    return -1;
  }

  ret=libdax_audioxtr_identify(o, 0);
  if(!(ret >= 1))
  {
    sprintf(msg, "Audio source file has unsuitable format : %s", (const void *)o->path);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020201, 0x60000000, 0x30000000, msg, 0, 0);
    return 0;
  }

  else
  {
    ret=libdax_audioxtr_init_reading(o, 0);
    if(!(ret >= 1))
    {
      sprintf(msg, "Failed to prepare reading of audio data : %s", (const void *)o->path);
      libdax_msgs_submit(libdax_messenger, -1, 0x00020202, 0x60000000, 0x30000000, msg, 0, 0);
      return 0;
    }

    else
      return 1;
  }
}

// libdax_audioxtr_read
// file libburn/libdax_audioxtr.c line 293
signed int libdax_audioxtr_read(struct libdax_audioxtr *o, char *buffer, signed int buffer_size, signed int flag)
{
  signed int ret;
  _Bool tmp_if_expr$1;
  if(!(buffer_size >= 1))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = o->fd < 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -2;

  else
  {
    if(o->data_size >= 1l)
    {
      if((1 & flag) == 0)
      {
        if(!(o->data_size + -o->extract_count >= (signed long int)buffer_size))
          buffer_size = (signed int)(o->data_size - o->extract_count);

      }

    }

    if(!(buffer_size >= 1))
      return 0;

    else
    {
      signed long int return_value_read$2;
      return_value_read$2=read(o->fd, (void *)buffer, (unsigned long int)buffer_size);
      ret = (signed int)return_value_read$2;
      if(ret >= 1)
        o->extract_count = o->extract_count + (signed long int)ret;

      return ret;
    }
  }
}

// libdax_audioxtr_to_int
// file libburn/libdax_audioxtr.c line 232
static unsigned int libdax_audioxtr_to_int(struct libdax_audioxtr *o, unsigned char *bytes, signed int len, signed int flag)
{
  unsigned int ret = (unsigned int)0;
  signed int i;
  if(!((1 & flag) == 0))
  {
    i = 0;
    for( ; !(i >= len); i = i + 1)
      ret = ret * (unsigned int)256 + (unsigned int)bytes[(signed long int)i];
  }

  else
  {
    i = len - 1;
    for( ; i >= 0; i = i - 1)
      ret = ret * (unsigned int)256 + (unsigned int)bytes[(signed long int)i];
  }
  return ret;
}

// libdax_msgs__sev_to_text
// file libburn/libdax_msgs.h line 324
signed int libdax_msgs__sev_to_text(signed int severity, char **severity_name, signed int flag)
{
  if(!((1 & flag) == 0))
  {
    *severity_name = "ALL ERRFILE DEBUG UPDATE NOTE HINT WARNING SORRY MISHAP FAILURE FATAL ABORT NEVER";
    return 1;
  }

  else
  {
    *severity_name = "";
    if(severity >= 0x7fffffff)
      *severity_name = "NEVER";

    else
      if(severity >= 0x71000000)
        *severity_name = "ABORT";

      else
        if(severity >= 0x70000000)
          *severity_name = "FATAL";

        else
          if(severity >= 0x68000000)
            *severity_name = "FAILURE";

          else
            if(severity >= 0x64000000)
              *severity_name = "MISHAP";

            else
              if(severity >= 0x60000000)
                *severity_name = "SORRY";

              else
                if(severity >= 0x50000000)
                  *severity_name = "WARNING";

                else
                  if(severity >= 0x40000000)
                    *severity_name = "HINT";

                  else
                    if(severity >= 0x30000000)
                      *severity_name = "NOTE";

                    else
                      if(severity >= 0x20000000)
                        *severity_name = "UPDATE";

                      else
                        if(severity >= 0x10000000)
                          *severity_name = "DEBUG";

                        else
                          if(severity >= 0x08000000)
                            *severity_name = "ERRFILE";

                          else
                            if(severity >= 0x00000000)
                              *severity_name = "ALL";

                            else
                            {
                              *severity_name = "";
                              return 0;
                            }
    return 1;
  }
}

// libdax_msgs__text_to_sev
// file libburn/libdax_msgs.h line 332
signed int libdax_msgs__text_to_sev(char *severity_name, signed int *severity, signed int flag)
{
  signed int return_value_strncmp$13;
  return_value_strncmp$13=strncmp(severity_name, "NEVER", (unsigned long int)5);
  signed int return_value_strncmp$12;
  signed int return_value_strncmp$11;
  signed int return_value_strncmp$10;
  signed int return_value_strncmp$9;
  signed int return_value_strncmp$8;
  signed int return_value_strncmp$7;
  signed int return_value_strncmp$6;
  signed int return_value_strncmp$5;
  signed int return_value_strncmp$4;
  signed int return_value_strncmp$3;
  signed int return_value_strncmp$2;
  signed int return_value_strncmp$1;
  if(return_value_strncmp$13 == 0)
    *severity = 0x7fffffff;

  else
  {
    return_value_strncmp$12=strncmp(severity_name, "ABORT", (unsigned long int)5);
    if(return_value_strncmp$12 == 0)
      *severity = 0x71000000;

    else
    {
      return_value_strncmp$11=strncmp(severity_name, "FATAL", (unsigned long int)5);
      if(return_value_strncmp$11 == 0)
        *severity = 0x70000000;

      else
      {
        return_value_strncmp$10=strncmp(severity_name, "FAILURE", (unsigned long int)7);
        if(return_value_strncmp$10 == 0)
          *severity = 0x68000000;

        else
        {
          return_value_strncmp$9=strncmp(severity_name, "MISHAP", (unsigned long int)6);
          if(return_value_strncmp$9 == 0)
            *severity = 0x64000000;

          else
          {
            return_value_strncmp$8=strncmp(severity_name, "SORRY", (unsigned long int)5);
            if(return_value_strncmp$8 == 0)
              *severity = 0x60000000;

            else
            {
              return_value_strncmp$7=strncmp(severity_name, "WARNING", (unsigned long int)7);
              if(return_value_strncmp$7 == 0)
                *severity = 0x50000000;

              else
              {
                return_value_strncmp$6=strncmp(severity_name, "HINT", (unsigned long int)4);
                if(return_value_strncmp$6 == 0)
                  *severity = 0x40000000;

                else
                {
                  return_value_strncmp$5=strncmp(severity_name, "NOTE", (unsigned long int)4);
                  if(return_value_strncmp$5 == 0)
                    *severity = 0x30000000;

                  else
                  {
                    return_value_strncmp$4=strncmp(severity_name, "UPDATE", (unsigned long int)6);
                    if(return_value_strncmp$4 == 0)
                      *severity = 0x20000000;

                    else
                    {
                      return_value_strncmp$3=strncmp(severity_name, "DEBUG", (unsigned long int)5);
                      if(return_value_strncmp$3 == 0)
                        *severity = 0x10000000;

                      else
                      {
                        return_value_strncmp$2=strncmp(severity_name, "ERRFILE", (unsigned long int)7);
                        if(return_value_strncmp$2 == 0)
                          *severity = 0x08000000;

                        else
                        {
                          return_value_strncmp$1=strncmp(severity_name, "ALL", (unsigned long int)3);
                          if(return_value_strncmp$1 == 0)
                            *severity = 0x00000000;

                          else
                          {
                            *severity = 0x00000000;
                            return 0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 1;
}

// libdax_msgs_destroy
// file libburn/libdax_msgs.h line 276
signed int libdax_msgs_destroy(struct libdax_msgs **m, signed int flag)
{
  struct libdax_msgs *o;
  struct libdax_msgs_item *item;
  struct libdax_msgs_item *next_item;
  o = *m;
  if(o == ((struct libdax_msgs *)NULL))
    return 0;

  else
  {
    if(o->refcount >= 2)
    {
      signed int return_value_libdax_msgs_lock$1;
      return_value_libdax_msgs_lock$1=libdax_msgs_lock(*m, 0);
      if(!(return_value_libdax_msgs_lock$1 >= 1))
        return -1;

      o->refcount = o->refcount - 1;
      libdax_msgs_unlock(*m, 0);
      *m = (struct libdax_msgs *)(void *)0;
      return 1;
    }

    signed int return_value_pthread_mutex_destroy$2;
    return_value_pthread_mutex_destroy$2=pthread_mutex_destroy(&o->lock_mutex);
    if(!(return_value_pthread_mutex_destroy$2 == 0))
    {
      pthread_mutex_unlock(&o->lock_mutex);
      pthread_mutex_destroy(&o->lock_mutex);
    }

    item = o->oldest;
    for( ; !(item == ((struct libdax_msgs_item *)NULL)); item = next_item)
    {
      next_item = item->next;
      libdax_msgs_item_destroy(&item, 0);
    }
    free((void *)(char *)o);
    *m = (struct libdax_msgs *)(void *)0;
    return 1;
  }
}

// libdax_msgs_destroy_item
// file libburn/libdax_msgs.h line 366
signed int libdax_msgs_destroy_item(struct libdax_msgs *m, struct libdax_msgs_item **item, signed int flag)
{
  signed int ret;
  ret=libdax_msgs_lock(m, 0);
  if(!(ret >= 1))
    return -1;

  else
  {
    ret=libdax_msgs_item_destroy(item, 0);
    libdax_msgs_unlock(m, 0);
    return ret;
  }
}

// libdax_msgs_item_destroy
// file libburn/libdax_msgs.c line 88
static signed int libdax_msgs_item_destroy(struct libdax_msgs_item **item, signed int flag)
{
  struct libdax_msgs_item *o = *item;
  if(o == ((struct libdax_msgs_item *)NULL))
    return 0;

  else
  {
    libdax_msgs_item_unlink(o, (struct libdax_msgs_item **)(void *)0, (struct libdax_msgs_item **)(void *)0, 0);
    if(!(o->msg_text == ((char *)NULL)))
      free((void *)(char *)o->msg_text);

    free((void *)(char *)o);
    *item = (struct libdax_msgs_item *)(void *)0;
    return 1;
  }
}

// libdax_msgs_item_get_msg
// file libburn/libdax_msgs.h line 376
signed int libdax_msgs_item_get_msg(struct libdax_msgs_item *item, signed int *error_code, char **msg_text, signed int *os_errno, signed int flag)
{
  *error_code = item->error_code;
  *msg_text = item->msg_text;
  *os_errno = item->os_errno;
  return 1;
}

// libdax_msgs_item_get_origin
// file libburn/libdax_msgs.c line 116
signed int libdax_msgs_item_get_origin(struct libdax_msgs_item *item, double *timestamp, signed int *process_id, signed int *origin, signed int flag)
{
  *timestamp = item->timestamp;
  *process_id = item->process_id;
  *origin = item->origin;
  return 1;
}

// libdax_msgs_item_get_rank
// file libburn/libdax_msgs.h line 396
signed int libdax_msgs_item_get_rank(struct libdax_msgs_item *item, signed int *severity, signed int *priority, signed int flag)
{
  *severity = item->severity;
  *priority = item->priority;
  return 1;
}

// libdax_msgs_item_new
// file libburn/libdax_msgs.c line 31
static signed int libdax_msgs_item_new(struct libdax_msgs_item **item, struct libdax_msgs_item *link, signed int flag)
{
  signed int ret;
  struct libdax_msgs_item *o;
  struct timeval tv;
  struct timezone tz;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct libdax_msgs_item) /*64ul*/ );
  o = (struct libdax_msgs_item *)return_value_calloc$1;
  *item = o;
  if(o == ((struct libdax_msgs_item *)NULL))
    return -1;

  else
  {
    o->timestamp = 0.0;
    ret=gettimeofday(&tv, &tz);
    if(ret == 0)
      o->timestamp = (double)tv.tv_sec + 0.000001 * (double)tv.tv_usec;

    o->process_id=getpid();
    o->origin = -1;
    o->severity = 0x00000000;
    o->priority = 0x00000000;
    o->error_code = 0;
    o->msg_text = (char *)(void *)0;
    o->os_errno = 0;
    o->prev = link;
    o->next = (struct libdax_msgs_item *)(void *)0;
    if(!(link == ((struct libdax_msgs_item *)NULL)))
    {
      if(!(link->next == ((struct libdax_msgs_item *)NULL)))
      {
        link->next->prev = o;
        o->next = link->next;
      }

      link->next = o;
    }

    return 1;
  }
}

// libdax_msgs_item_unlink
// file libburn/libdax_msgs.c line 69
signed int libdax_msgs_item_unlink(struct libdax_msgs_item *o, struct libdax_msgs_item **chain_start, struct libdax_msgs_item **chain_end, signed int flag)
{
  if(!(o->prev == ((struct libdax_msgs_item *)NULL)))
    o->prev->next = o->next;

  if(!(o->next == ((struct libdax_msgs_item *)NULL)))
    o->next->prev = o->prev;

  if(!(chain_start == ((struct libdax_msgs_item **)NULL)))
  {
    if(*chain_start == o)
      *chain_start = o->next;

  }

  if(!(chain_end == ((struct libdax_msgs_item **)NULL)))
  {
    if(*chain_end == o)
      *chain_end = o->prev;

  }

  o->prev = (struct libdax_msgs_item *)(void *)0;
  o->next = o->prev;
  return 1;
}

// libdax_msgs_lock
// file libburn/libdax_msgs.c line 162
static signed int libdax_msgs_lock(struct libdax_msgs *m, signed int flag)
{
  signed int ret;
  ret=pthread_mutex_lock(&m->lock_mutex);
  if(!(ret == 0))
    return 0;

  else
    return 1;
}

// libdax_msgs_new
// file libburn/libdax_msgs.h line 264
signed int libdax_msgs_new(struct libdax_msgs **m, signed int flag)
{
  struct libdax_msgs *o;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct libdax_msgs) /*160ul*/ );
  o = (struct libdax_msgs *)return_value_calloc$1;
  *m = o;
  if(o == ((struct libdax_msgs *)NULL))
    return -1;

  else
  {
    o->refcount = 1;
    o->oldest = (struct libdax_msgs_item *)(void *)0;
    o->youngest = (struct libdax_msgs_item *)(void *)0;
    o->count = 0;
    o->queue_severity = 0x00000000;
    o->print_severity = 0x7fffffff;
    strcpy(o->print_id, "libdax: ");
    pthread_mutex_init(&o->lock_mutex, (const union anonymous$1 *)(void *)0);
    return 1;
  }
}

// libdax_msgs_obtain
// file libburn/libdax_msgs.h line 355
signed int libdax_msgs_obtain(struct libdax_msgs *m, struct libdax_msgs_item **item, signed int severity, signed int priority, signed int flag)
{
  signed int ret;
  struct libdax_msgs_item *im;
  struct libdax_msgs_item *next_im = (struct libdax_msgs_item *)(void *)0;
  *item = (struct libdax_msgs_item *)(void *)0;
  ret=libdax_msgs_lock(m, 0);
  if(!(ret >= 1))
    return -1;

  else
  {
    im = m->oldest;
    for( ; !(im == ((struct libdax_msgs_item *)NULL)); im = next_im)
    {
      for( ; !(im == ((struct libdax_msgs_item *)NULL)); im = next_im)
      {
        next_im = im->next;
        if(im->severity >= severity)
          break;

        libdax_msgs_item_unlink(im, &m->oldest, &m->youngest, 0);
        libdax_msgs_item_destroy(&im, 0);
      }
      if(im == ((struct libdax_msgs_item *)NULL))
        break;

      if(im->priority >= priority)
        break;

    }
    if(im == ((struct libdax_msgs_item *)NULL))
      ret = 0;

    else
    {
      libdax_msgs_item_unlink(im, &m->oldest, &m->youngest, 0);
      *item = im;
      ret = 1;
    }

  ex:
    ;
    libdax_msgs_unlock(m, 0);
    return ret;
  }
}

// libdax_msgs_refer
// file libburn/libdax_msgs.h line 288
signed int libdax_msgs_refer(struct libdax_msgs **pt, struct libdax_msgs *m, signed int flag)
{
  signed int return_value_libdax_msgs_lock$1;
  return_value_libdax_msgs_lock$1=libdax_msgs_lock(m, 0);
  if(!(return_value_libdax_msgs_lock$1 >= 1))
    return 0;

  else
  {
    m->refcount = m->refcount + 1;
    *pt = m;
    libdax_msgs_unlock(m, 0);
    return 1;
  }
}

// libdax_msgs_set_severities
// file libburn/libdax_msgs.h line 344
signed int libdax_msgs_set_severities(struct libdax_msgs *m, signed int queue_severity, signed int print_severity, char *print_id, signed int flag)
{
  signed int return_value_libdax_msgs_lock$1;
  return_value_libdax_msgs_lock$1=libdax_msgs_lock(m, 0);
  if(!(return_value_libdax_msgs_lock$1 >= 1))
    return 0;

  else
  {
    m->queue_severity = queue_severity;
    m->print_severity = print_severity;
    strncpy(m->print_id, print_id, (unsigned long int)80);
    m->print_id[(signed long int)80] = (char)0;
    libdax_msgs_unlock(m, 0);
    return 1;
  }
}

// libdax_msgs_submit
// file libburn/libdax_msgs.h line 310
signed int libdax_msgs_submit(struct libdax_msgs *m, signed int origin, signed int error_code, signed int severity, signed int priority, char *msg_text, signed int os_errno, signed int flag)
{
  signed int ret;
  char *textpt;
  char *sev_name;
  char sev_text[81l];
  struct libdax_msgs_item *item = (struct libdax_msgs_item *)(void *)0;
  if(severity >= m->print_severity)
  {
    if(msg_text == ((char *)NULL))
      textpt = "";

    else
      textpt = msg_text;
    sev_text[(signed long int)0] = (char)0;
    ret=libdax_msgs__sev_to_text(severity, &sev_name, 0);
    if(ret >= 1)
      sprintf(sev_text, "%s : ", sev_name);

    fprintf(stderr, "%s%s%s%c", (const void *)m->print_id, (const void *)sev_text, textpt, (flag & 1) != 0 ? 13 : 10);
    if(!(os_errno == 0))
    {
      ret=libdax_msgs_lock(m, 0);
      if(!(ret >= 1))
        return -1;

      char *return_value_strerror$1;
      return_value_strerror$1=strerror(os_errno);
      fprintf(stderr, "%s( Most recent system error: %d  '%s' )\n", (const void *)m->print_id, os_errno, return_value_strerror$1);
      libdax_msgs_unlock(m, 0);
    }

  }

  if(!(severity >= m->queue_severity))
    return 0;

  else
  {
    ret=libdax_msgs_lock(m, 0);
    if(!(ret >= 1))
      return -1;

    else
    {
      ret=libdax_msgs_item_new(&item, m->youngest, 0);
      if(ret >= 1)
      {
        item->origin = origin;
        item->error_code = error_code;
        item->severity = severity;
        item->priority = priority;
        if(!(msg_text == ((char *)NULL)))
        {
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(msg_text);
          void *return_value_calloc$3;
          return_value_calloc$3=calloc((unsigned long int)1, return_value_strlen$2 + (unsigned long int)1);
          item->msg_text = (char *)return_value_calloc$3;
          if(item->msg_text == ((char *)NULL))
            goto failed;

          strcpy(item->msg_text, msg_text);
        }

        item->os_errno = os_errno;
        if(m->oldest == ((struct libdax_msgs_item *)NULL))
          m->oldest = item;

        m->youngest = item;
        m->count = m->count + 1;
        libdax_msgs_unlock(m, 0);
        return 1;
      }

      else
      {

      failed:
        ;
        libdax_msgs_item_destroy(&item, 0);
        libdax_msgs_unlock(m, 0);
        return -1;
      }
    }
  }
}

// libdax_msgs_unlock
// file libburn/libdax_msgs.c line 177
static signed int libdax_msgs_unlock(struct libdax_msgs *m, signed int flag)
{
  signed int ret;
  ret=pthread_mutex_unlock(&m->lock_mutex);
  if(!(ret == 0))
    return 0;

  else
    return 1;
}

// main
// file test/telltoc.c line 910
signed int main(signed int argc, char **argv)
{
  signed int ret;
  signed int toc_failed = 0;
  signed int msinfo_alone = 0;
  signed int msinfo_explicit = 0;
  signed int full_default = 0;
  ret=telltoc_setup(argc, argv);
  if(!(ret == 0))
    exit(ret);

  if(!(do_msinfo == 0))
  {
    msinfo_explicit = 1;
    if(do_media == 0 && do_toc == 0)
      msinfo_alone = 1;

  }

  if(do_capacities == 0 && do_media == 0 && do_msinfo == 0 && do_toc == 0 && !(driveno == -1) && (!(read_count >= 1) || !(read_start >= 0)))
  {
    if(!(print_help == 0))
      exit(0);

    do_toc = 1;
    do_capacities = do_toc;
    do_msinfo = do_capacities;
    do_media = do_msinfo;
    full_default = do_media;
  }

  fprintf(stderr, "Initializing libburnia-project.org ...\n");
  signed int return_value_burn_initialize$1;
  return_value_burn_initialize$1=burn_initialize();
  if(!(return_value_burn_initialize$1 == 0))
    fprintf(stderr, "Done\n");

  else
  {
    fprintf(stderr, "\nFATAL: Failed to initialize.\n");
    exit(33);
  }
  burn_msgs_set_severities("NEVER", "WARNING", "telltoc : ");
  burn_set_signal_handling((void *)"telltoc : ", (signed int (*)(void *, signed int, signed int))(void *)0, 0);
  ret=telltoc_aquire_drive(drive_adr, &driveno, (signed int)!(full_default != 0));
  if(!(ret >= 1))
  {
    fprintf(stderr, "\nFATAL: Failed to aquire drive.\n");
    ret = 34;
  }

  else
  {
    if(ret == 2)
      ret = 0;

    else
      if(!(do_media == 0))
      {
        ret=telltoc_media((drive_list + (signed long int)driveno)->drive);
        if(ret >= 1)
          goto __CPROVER_DUMP_L9;

        ret = 36;
      }

      else
      {

      __CPROVER_DUMP_L9:
        ;
        if(!(do_capacities == 0))
        {
          ret=telltoc_speedlist((drive_list + (signed long int)driveno)->drive);
          if(!(ret >= 1))
          {
            ret = 39;
            goto release_drive;
          }

          ret=telltoc_formatlist((drive_list + (signed long int)driveno)->drive);
          if(ret >= 1)
            goto __CPROVER_DUMP_L11;

          ret = 39;
        }

        else
        {

        __CPROVER_DUMP_L11:
          ;
          if(!(do_toc == 0))
          {
            ret=telltoc_toc((drive_list + (signed long int)driveno)->drive);
            if(!(ret >= 1))
            {
              ret = 37;
              goto release_drive;
            }

            if(ret == 2)
              toc_failed = 1;

          }

          if(!(do_msinfo == 0))
          {
            ret=telltoc_msinfo((drive_list + (signed long int)driveno)->drive, msinfo_explicit, msinfo_alone);
            if(ret >= 1)
              goto __CPROVER_DUMP_L14;

            ret = 38;
          }

          else
          {

          __CPROVER_DUMP_L14:
            ;
            if(!(read_start == -2) && (read_count == -1 || read_count >= 1))
            {
              ret=telltoc_read_and_print((drive_list + (signed long int)driveno)->drive, read_start, read_count, print_raw_file, print_encoding);
              if(ret >= 1)
                goto __CPROVER_DUMP_L15;

              ret = 40;
            }

            else
            {

            __CPROVER_DUMP_L15:
              ;
              ret = 0;
              if(!(toc_failed == 0))
                ret = 37;

            }
          }
        }
      }

  release_drive:
    ;
    if(!(drive_is_grabbed == 0))
      burn_drive_release((drive_list + (signed long int)driveno)->drive, 0);

  }

finish_libburn:
  ;
  burn_finish();
  exit(ret);
}

// mmc_close
// file libburn/mmc.c line 603
void mmc_close(struct burn_drive *d, signed int session, signed int track)
{
  struct command *c;
  char msg[256l];
  signed int key;
  signed int asc;
  signed int ascq;
  c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_close");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, MMC_CLOSE, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
    c->retry = 1;
    c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)1;
    c->opcode[(signed long int)2] = (unsigned char)((session & 3) << 1 | (signed int)!(!(track != 0)));
    c->opcode[(signed long int)4] = (unsigned char)(track >> 8);
    c->opcode[(signed long int)5] = (unsigned char)(track & 0xFF);
    c->page = (struct buffer *)(void *)0;
    c->dir = 2;
    c->timeout = 200000;
    d->issue_command(d, c);
    if(!(c->error == 0))
    {
      sprintf(msg, "Failed to close %s (%d)", session > 1 ? "disc" : (session > 0 ? "session" : "track"), (session & 3) << 1 | (signed int)!(!(track != 0)));
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(msg);
      sprintf(msg + (signed long int)return_value_strlen$2, ". SCSI error : ");
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(msg);
      scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$3, &key, &asc, &ascq);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002017e, 0x68000000, 0x30000000, msg, 0, 0);
      d->cancel = 1;
    }

    signed int return_value_spc_wait_unit_attention$4;
    return_value_spc_wait_unit_attention$4=spc_wait_unit_attention(d, 3600, "CLOSE TRACK SESSION", 0);
    if(!(return_value_spc_wait_unit_attention$4 >= 1))
      d->cancel = 1;

  }

}

// mmc_close_disc
// file libburn/mmc.c line 558
void mmc_close_disc(struct burn_write_opts *o)
{
  struct burn_drive *d = o->drive;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_close_disc");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, "HOW THAT ? mmc_close_disc() was called", 0, 0);
    o->multi = (unsigned char)0;
    spc_select_write_params(d, (struct burn_session *)(void *)0, 0, o);
    mmc_close(d, 1, 0);
  }

}

// mmc_close_session
// file libburn/mmc.c line 579
void mmc_close_session(struct burn_write_opts *o)
{
  struct burn_drive *d = o->drive;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_close_session");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, "HOW THAT ? mmc_close_session() was called", 0, 0);
    o->multi = (unsigned char)3;
    spc_select_write_params(d, (struct burn_session *)(void *)0, 0, o);
    mmc_close(d, 1, 0);
  }

}

// mmc_compose_mode_page_5
// file libburn/mmc.c line 4538
signed int mmc_compose_mode_page_5(struct burn_drive *d, struct burn_session *s, signed int tnum, struct burn_write_opts *o, unsigned char *pd)
{
  unsigned char *catalog = (unsigned char *)(void *)0;
  char isrc_text[13l];
  struct isrc *isrc;
  pd[(signed long int)0] = (unsigned char)5;
  pd[(signed long int)1] = (unsigned char)d->mdata->write_page_length;
  if(d->current_profile == 0x13)
  {
    pd[(signed long int)2] = (unsigned char)(1 << 6);
    pd[(signed long int)3] = (unsigned char)(1 << 5 | 5);
    pd[(signed long int)4] = (unsigned char)8;
    pd[(signed long int)5] = (unsigned char)0;
  }

  else
  {
    _Bool tmp_if_expr$10;
    if(d->current_profile == 0x14)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = d->current_profile == 0x11 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$11;
    if(tmp_if_expr$10)
      tmp_if_expr$11 = (_Bool)1;

    else
      tmp_if_expr$11 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$12;
    if(tmp_if_expr$11)
      tmp_if_expr$12 = (signed int)o->write_type == BURN_WRITE_SAO ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$12 = (_Bool)0;
    if(tmp_if_expr$12)
    {
      pd[(signed long int)2] = (unsigned char)((signed int)!(!(o->underrun_proof != 0u)) << 6 | (signed int)!(!(o->simulate != 0u)) << 4 | 2);
      pd[(signed long int)3] = (unsigned char)5;
      pd[(signed long int)4] = (unsigned char)8;
    }

    else
    {
      _Bool tmp_if_expr$8;
      if(d->current_profile == 0x14)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = d->current_profile == 0x11 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$9;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        pd[(signed long int)2] = (unsigned char)((signed int)!(!(o->underrun_proof != 0u)) << 6 | 1 << 5 | (signed int)!(!(o->simulate != 0u)) << 4);
        pd[(signed long int)3] = (unsigned char)(3 * (signed int)!(!(o->multi != 0)) << 6 | 1 << 5 | 5);
        pd[(signed long int)4] = (unsigned char)8;
        if(d->current_feat21h_link_size >= 0)
          pd[(signed long int)5] = (unsigned char)d->current_feat21h_link_size;

        else
          pd[(signed long int)5] = (unsigned char)16;
        if(!(d->current_feat21h_link_size == 16))
        {
          char msg[80l];
          sprintf(msg, "Feature 21h Link Size = %d (expected 16)\n", d->current_feat21h_link_size);
          libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
        }

        pd[(signed long int)13] = (unsigned char)16;
      }

      else
      {
        _Bool tmp_if_expr$2;
        if(d->current_profile == 0x1a)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = d->current_profile == 0x1b ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$3;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = d->current_profile == 0x2b ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$4;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$5;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$6;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = d->current_profile == 0x42 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$7;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          return 0;

        else
        {
          pd[(signed long int)2] = (unsigned char)((signed int)!(!(o->underrun_proof != 0u)) << 6 | (signed int)!(!(o->simulate != 0u)) << 4 | (signed int)o->write_type & 0x0f);
          pd[(signed long int)3] = (unsigned char)(3 * (signed int)!(!(o->multi != 0)) << 6 | (signed int)o->control & 0x0f);
          signed int return_value_spc_block_type$1;
          return_value_spc_block_type$1=spc_block_type(o->block_type);
          pd[(signed long int)4] = (unsigned char)return_value_spc_block_type$1;
          if((4 & (signed int)o->control) == 0)
          {
            if((signed int)o->write_type == BURN_WRITE_TAO)
              pd[(signed long int)4] = (unsigned char)0;

          }

          pd[(signed long int)14] = (unsigned char)0;
          pd[(signed long int)15] = (unsigned char)150;
          if(!(o->has_mediacatalog == 0))
            catalog = (unsigned char *)o->mediacatalog;

          else
            if(!(s == ((struct burn_session *)NULL)))
            {
              if(!(s->mediacatalog[0l] == 0))
                catalog = s->mediacatalog;

            }

          if(!(catalog == ((unsigned char *)NULL)))
          {
            if(d->mdata->write_page_length >= 30)
            {
              pd[(signed long int)16] = (unsigned char)0x80;
              memcpy((void *)(pd + (signed long int)17), (const void *)catalog, (unsigned long int)13);
            }

          }

          isrc_text[(signed long int)0] = (char)0;
          if(!(s == ((struct burn_session *)NULL)))
          {
            if((signed int)o->write_type == BURN_WRITE_TAO)
            {
              if(tnum >= 0)
              {
                if(!(tnum >= s->tracks))
                {
                  if(!(s->track[(signed long int)tnum]->isrc.has_isrc == 0))
                  {
                    isrc = &s->track[(signed long int)tnum]->isrc;
                    isrc_text[(signed long int)0] = isrc->country[(signed long int)0];
                    isrc_text[(signed long int)1] = isrc->country[(signed long int)1];
                    isrc_text[(signed long int)2] = isrc->owner[(signed long int)0];
                    isrc_text[(signed long int)3] = isrc->owner[(signed long int)1];
                    isrc_text[(signed long int)4] = isrc->owner[(signed long int)2];
                    sprintf(isrc_text + (signed long int)5, "%-2.2u%-5.5u", (unsigned int)isrc->year, isrc->serial);
                  }

                  if(!((8192 & s->track[(signed long int)tnum]->mode) == 0))
                  {
                    if((256 & s->track[(signed long int)tnum]->mode) == 0)
                      pd[(signed long int)3] = pd[(signed long int)3] | (unsigned char)0x10;

                  }

                }

              }

            }

          }

          if(!((signed int)isrc_text[0l] == 0))
          {
            if(d->mdata->write_page_length >= 46)
            {
              pd[(signed long int)32] = (unsigned char)0x80;
              memcpy((void *)(pd + (signed long int)33), (const void *)isrc_text, (unsigned long int)12);
            }

          }

        }
      }
    }
  }
  return 1;
}

// mmc_erase
// file libburn/mmc.c line 2677
void mmc_erase(struct burn_drive *d, signed int fast)
{
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_erase");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, MMC_BLANK, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
    c->opcode[(signed long int)1] = (unsigned char)16;
    c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)!(!(fast != 0));
    c->retry = 1;
    c->page = (struct buffer *)(void *)0;
    c->dir = 2;
    c->timeout = 200000;
    d->issue_command(d, c);
    if(!(c->error == 0))
    {
      d->cancel = 1;
      scsi_notify_error(d, c, c->sense, 14, 2);
    }

  }

}

// mmc_eval_read_error
// file libburn/mmc.c line 2453
signed int mmc_eval_read_error(struct burn_drive *d, struct command *c, char *what, signed int start_m, signed int start_s, signed int start_f, signed int end_m, signed int end_s, signed int end_f, signed int flag)
{
  char *msg = (char *)(void *)0;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int silent;
  if(c->error == 0)
    return 0;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, (unsigned long int)256);
    msg = (char *)return_value_calloc$1;
    if(!(msg == ((char *)NULL)))
    {
      if(!(end_f >= 0) || !(end_s >= 0) || !(start_f >= 0) || !(start_s >= 0))
        sprintf(msg, "SCSI error on %s(%d,%d): ", what, start_m, end_m);

      else
        sprintf(msg, "SCSI error on %s(%dm%ds%df,%dm%ds%df): ", what, start_m, start_s, start_f, end_m, end_s, end_f);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(msg);
      scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$2, &key, &asc, &ascq);
      silent = (signed int)(d->silent_on_scsi_error == 1);
      if(asc == 0x64 && ascq == 0x0 && key == 5)
      {
        d->had_particular_error = d->had_particular_error | 1;
        if(d->silent_on_scsi_error == 2)
          silent = 1;

      }

      if(silent == 0)
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020144, d->silent_on_scsi_error == 3 ? 0x10000000 : 0x60000000, 0x30000000, msg, 0, 0);

      free((void *)msg);
    }

    return 1;
  }
}

// mmc_fake_toc
// file libburn/mmc.c line 1289
signed int mmc_fake_toc(struct burn_drive *d)
{
  struct burn_track *track;
  struct burn_session *session;
  struct burn_toc_entry *entry;
  struct buffer *buf = (struct buffer *)(void *)0;
  signed int i;
  signed int session_number;
  signed int prev_session = -1;
  signed int ret;
  signed int lba;
  signed int alloc_len = 34;
  unsigned char *tdata;
  unsigned char size_data[4l];
  unsigned char start_data[4l];
  unsigned char end_data[4l];
  char *msg = (char *)(void *)0;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_fake_toc");
  void *return_value_calloc$6;
  if(!(return_value_mmc_function_spy$1 >= 1))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(buf == ((struct buffer *)NULL))
      ret = -1;

    else
    {
      _Bool tmp_if_expr$3;
      if(!(d->last_track_no >= 1))
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = d->complete_sessions + d->incomplete_sessions <= 0 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)d->status == BURN_DISC_BLANK ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        ret = 2;

      else
      {
        if(d->last_track_no >= 2303)
        {
          void *return_value_calloc$5;
          return_value_calloc$5=calloc((unsigned long int)1, (unsigned long int)160);
          msg = (char *)return_value_calloc$5;
          if(!(msg == ((char *)NULL)))
          {
            sprintf(msg, "Too many logical tracks recorded (%d , max. %d)\n", d->last_track_no, 2302);
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002012c, 0x60000000, 0x30000000, msg, 0, 0);
            free((void *)msg);
          }

          ret = 0;
          goto ex;
        }

        if(d->current_profile == 0x10)
        {
          if(d->last_track_no >= 2)
            goto __CPROVER_DUMP_L10;

          ret=mmc_read_toc_fmt0(d);
        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          d->disc=burn_disc_create();
          if(d->disc == ((struct burn_disc *)NULL))
            ret = -1;

          else
          {
            d->toc_entries = d->last_track_no + d->complete_sessions + d->incomplete_sessions;
            return_value_calloc$6=calloc((unsigned long int)d->toc_entries, sizeof(struct burn_toc_entry) /*32ul*/ );
            d->toc_entry = (struct burn_toc_entry *)return_value_calloc$6;
            if(d->toc_entry == ((struct burn_toc_entry *)NULL))
              ret = -1;

            else
            {
              memset((void *)d->toc_entry, 0, (unsigned long int)d->toc_entries * sizeof(struct burn_toc_entry) /*32ul*/ );
              i = 0;
              for( ; !(i >= d->complete_sessions + d->incomplete_sessions); i = i + 1)
              {
                session=burn_session_create();
                if(session == ((struct burn_session *)NULL))
                {
                  ret = -1;
                  goto ex;
                }

                burn_disc_add_session(d->disc, session, (unsigned int)100);
                burn_session_free(session);
              }
              d->disc->incomplete_sessions = d->incomplete_sessions;
              memset((void *)size_data, 0, (unsigned long int)4);
              memset((void *)start_data, 0, (unsigned long int)4);
              i = 0;
              for( ; !(i >= d->last_track_no); i = i + 1)
              {
                ret=mmc_read_track_info(d, i + 1, buf, alloc_len);
                if(!(ret >= 1))
                  goto ex;

                tdata = buf->data;
                session_number = (signed int)tdata[(signed long int)33] << 8 | (signed int)tdata[(signed long int)3];
                if(session_number >= 1)
                {
                  if(prev_session >= 1 && !(session_number == prev_session))
                  {
                    entry = &d->toc_entry[(signed long int)((i - 1) + prev_session)];
                    signed int return_value_mmc_four_char_to_int$7;
                    return_value_mmc_four_char_to_int$7=mmc_four_char_to_int(start_data);
                    signed int return_value_mmc_four_char_to_int$8;
                    return_value_mmc_four_char_to_int$8=mmc_four_char_to_int(size_data);
                    lba = return_value_mmc_four_char_to_int$7 + return_value_mmc_four_char_to_int$8;
                    mmc_int_to_four_char(start_data, lba);
                    mmc_int_to_four_char(size_data, 0);
                    mmc_int_to_four_char(end_data, lba - 1);
                    mmc_fake_toc_entry(entry, prev_session, 0xA2, size_data, start_data, end_data);
                    entry->frame = (unsigned char)0;
                    entry->sec = entry->frame;
                    entry->min = entry->sec;
                    d->disc->session[(signed long int)(prev_session - 1)]->leadout_entry = entry;
                  }

                  if(!(d->complete_sessions >= session_number))
                  {
                    if(i == d->last_track_no + -1)
                    {
                      signed int return_value_mmc_four_char_to_int$9;
                      return_value_mmc_four_char_to_int$9=mmc_four_char_to_int(tdata + (signed long int)16);
                      burn_drive_set_media_capacity_remaining(d, (signed long int)return_value_mmc_four_char_to_int$9 * (signed long int)2048);
                      d->media_lba_limit = 0;
                    }

                    if(!(d->disc->sessions >= session_number))
                      goto __CPROVER_DUMP_L22;

                  }

                  entry = &d->toc_entry[(signed long int)((i + session_number) - 1)];
                  track=burn_track_create();
                  if(track == ((struct burn_track *)NULL))
                  {
                    ret = -1;
                    goto ex;
                  }

                  burn_session_add_track(d->disc->session[(signed long int)(session_number - 1)], track, (unsigned int)100);
                  track->entry = entry;
                  burn_track_free(track);
                  memcpy((void *)size_data, (const void *)(tdata + (signed long int)24), (unsigned long int)4);
                  memcpy((void *)start_data, (const void *)(tdata + (signed long int)8), (unsigned long int)4);
                  memcpy((void *)end_data, (const void *)(tdata + (signed long int)28), (unsigned long int)4);
                  mmc_fake_toc_entry(entry, session_number, i + 1, size_data, start_data, end_data);
                  entry->track_status_bits = (signed int)tdata[(signed long int)5] | (signed int)tdata[(signed long int)6] << 8 | (signed int)tdata[(signed long int)7] << 16;
                  entry->extensions_valid = entry->extensions_valid | (unsigned char)4;
                  if(!(prev_session == session_number))
                    d->disc->session[(signed long int)(session_number - 1)]->firsttrack = (unsigned char)(i + 1);

                  d->disc->session[(signed long int)(session_number - 1)]->lasttrack = (unsigned char)(i + 1);
                  prev_session = session_number;
                }


              __CPROVER_DUMP_L22:
                ;
              }
              if(prev_session >= 1)
              {
                if(d->disc->sessions >= prev_session)
                {
                  entry = &d->toc_entry[(signed long int)((d->last_track_no - 1) + prev_session)];
                  signed int return_value_mmc_four_char_to_int$10;
                  return_value_mmc_four_char_to_int$10=mmc_four_char_to_int(start_data);
                  signed int return_value_mmc_four_char_to_int$11;
                  return_value_mmc_four_char_to_int$11=mmc_four_char_to_int(size_data);
                  lba = return_value_mmc_four_char_to_int$10 + return_value_mmc_four_char_to_int$11;
                  mmc_int_to_four_char(start_data, lba);
                  mmc_int_to_four_char(size_data, 0);
                  mmc_int_to_four_char(end_data, lba - 1);
                  mmc_fake_toc_entry(entry, prev_session, 0xA2, size_data, start_data, end_data);
                  entry->frame = (unsigned char)0;
                  entry->sec = entry->frame;
                  entry->min = entry->sec;
                  d->disc->session[(signed long int)(prev_session - 1)]->leadout_entry = entry;
                }

              }

              ret = 1;
            }
          }
        }
      }
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_fake_toc_entry
// file libburn/mmc.c line 1076
signed int mmc_fake_toc_entry(struct burn_toc_entry *entry, signed int session_number, signed int track_number, unsigned char *size_data, unsigned char *start_data, unsigned char *last_adr_data)
{
  signed int min;
  signed int sec;
  signed int frames;
  signed int num;
  entry->extensions_valid = entry->extensions_valid | (unsigned char)(1 | 2);
  entry->session = (unsigned char)(session_number & 0xff);
  entry->session_msb = (unsigned char)(session_number >> 8 & 0xff);
  entry->adr = (unsigned char)1;
  entry->control = (unsigned char)4;
  entry->tno = (unsigned char)0;
  entry->point = (unsigned char)(track_number & 0xff);
  entry->point_msb = (unsigned char)(track_number >> 8 & 0xff);
  num=mmc_four_char_to_int(size_data);
  entry->track_blocks = num;
  burn_lba_to_msf(num, &min, &sec, &frames);
  if(min >= 256)
  {
    min = 255;
    sec = 255;
    frames = 255;
  }

  entry->min = (unsigned char)min;
  entry->sec = (unsigned char)sec;
  entry->frame = (unsigned char)frames;
  entry->zero = (unsigned char)0;
  num=mmc_four_char_to_int(start_data);
  entry->start_lba = num;
  burn_lba_to_msf(num, &min, &sec, &frames);
  if(min >= 256)
  {
    min = 255;
    sec = 255;
    frames = 255;
  }

  entry->pmin = (unsigned char)min;
  entry->psec = (unsigned char)sec;
  entry->pframe = (unsigned char)frames;
  entry->last_recorded_address=mmc_four_char_to_int(last_adr_data);
  return 1;
}

// mmc_format_unit
// file libburn/mmc.c line 3617
signed int mmc_format_unit(struct burn_drive *d, signed long int size, signed int flag)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int ret;
  signed int tolerate_failure = 0;
  signed int return_immediately = 0;
  signed int i;
  signed int format_type;
  signed int index;
  signed int format_sub_type = 0;
  signed int format_00_index;
  signed int size_mode;
  signed int accept_count = 0;
  signed long int num_of_blocks = (signed long int)0;
  signed long int diff;
  signed long int format_size;
  signed long int i_size;
  signed long int format_00_max_size;
  signed long int min_size = (signed long int)-1;
  signed long int max_size = (signed long int)-1;
  char *msg = (char *)(void *)0;
  char descr[80l];
  signed int key;
  signed int asc;
  signed int ascq;
  signed int full_format_type = 0x00;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$11;
  unsigned long int return_value_strlen$18;
  unsigned long int return_value_strlen$19;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)256, 0);
      msg = (char *)return_value_burn_alloc_mem$3;
      if(msg == ((char *)NULL))
        ret = -1;

      else
      {
        mmc_start_if_needed(d, 0);
        return_value_mmc_function_spy$4=mmc_function_spy(d, "mmc_format_unit");
        if(!(return_value_mmc_function_spy$4 >= 1))
          ret = 0;

        else
        {
          size_mode = flag >> 1 & 3;
          scsi_init_command(c, MMC_FORMAT_UNIT, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
          c->retry = 1;
          c->page = buf;
          c->page->bytes = 12;
          c->page->sectors = 0;
          c->dir = 0;
          c->timeout = 200000;
          memset((void *)c->page->data, 0, (unsigned long int)c->page->bytes);
          descr[(signed long int)0] = (char)0;
          c->page->data[(signed long int)1] = (unsigned char)0x02;
          c->page->data[(signed long int)3] = (unsigned char)8;
          num_of_blocks = size / (signed long int)2048;
          mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
          if(!((128 & flag) == 0))
          {
            ret=mmc_read_format_capacities(d, -1);
            if(ret >= 1)
            {
              index = flag >> 8 & 0xff;
              if(!(index >= 0))
                tmp_if_expr$5 = (_Bool)1;

              else
                tmp_if_expr$5 = index >= d->num_format_descr ? (_Bool)1 : (_Bool)0;
              if(!tmp_if_expr$5)
                goto __CPROVER_DUMP_L8;

            }


          selected_not_suitable:
            ;
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020132, 0x60000000, 0x30000000, "Selected format is not suitable for libburn", 0, 0);
            ret = 0;
            goto ex;

          __CPROVER_DUMP_L8:
            ;
            _Bool tmp_if_expr$6;
            if(d->current_profile == 0x13)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$7;
            if(tmp_if_expr$6)
              tmp_if_expr$7 = (_Bool)1;

            else
              tmp_if_expr$7 = d->current_profile == 0x1a ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$8;
            if(tmp_if_expr$7)
              tmp_if_expr$8 = (_Bool)1;

            else
              tmp_if_expr$8 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$9;
            if(tmp_if_expr$8)
              tmp_if_expr$9 = (_Bool)1;

            else
              tmp_if_expr$9 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$10;
            if(tmp_if_expr$9)
              tmp_if_expr$10 = (_Bool)1;

            else
              tmp_if_expr$10 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$10)
              goto unsuitable_media;

            format_type = d->format_descriptors[(signed long int)index].type;
            if(!(format_type == 0x00) && !(format_type == 0x01) && !(format_type == 0x10) && !(format_type == 0x11) && !(format_type == 0x13) && !(format_type == 0x15) && !(format_type == 0x26) && !(format_type == 0x30) && !(format_type == 0x31) && !(format_type == 0x32))
              goto selected_not_suitable;

            if(!((4 & flag) == 0))
            {
              num_of_blocks = d->format_descriptors[(signed long int)index].size / (signed long int)2048;
              mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
            }

            if(!(format_type == 0x26))
            {
              i = 0;
              for( ; !(i >= 3); i = i + 1)
                c->page->data[(signed long int)(9 + i)] = (unsigned char)(d->format_descriptors[(signed long int)index].tdp >> 16 - 8 * i & (unsigned int)0xff);
            }

            if(format_type == 0x30 || format_type == 0x31)
            {
              format_sub_type = 0;
              if(!((64 & flag) == 0))
              {
                if(!((2 & d->current_feat23h_byte4) == 0))
                  format_sub_type = 3;

              }

              else
                if(!((1 & d->current_feat23h_byte4) == 0))
                  format_sub_type = 2;

            }

            else
            {
              _Bool tmp_if_expr$12;
              if(format_type == 0x32)
                tmp_if_expr$12 = (_Bool)1;

              else
              {
                if(format_type == 0x00)
                  tmp_if_expr$11 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$11 = (_Bool)0;
                tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$12)
              {
                if(!((65536 & flag) == 0))
                  format_sub_type = 0;

                else
                  format_sub_type = 1;
              }

            }
            if(d->current_profile == 0x12)
            {
              if(!(format_type == 0x01))
              {
                if(!((64 & flag) == 0))
                {
                  c->page->data[(signed long int)1] = c->page->data[(signed long int)1] | (unsigned char)0x20;
                  c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)0x08;
                }

              }

            }

            c->page->data[(signed long int)1] = c->page->data[(signed long int)1] | (unsigned char)0x80;
            sprintf(descr, "%s (descr %d)", (const void *)d->current_profile_text, index);
            return_immediately = 1;
          }

          else
            if(d->current_profile == 0x1a)
            {
              format_type = 0x26;
              if((2 & flag) == 0 && !(size >= 1l) || !((12 & flag) == 0))
              {
                memset((void *)(c->page->data + (signed long int)4), 0xff, (unsigned long int)4);
                num_of_blocks = (signed long int)0xffffffff;
              }

              _Bool tmp_if_expr$13;
              if(d->bg_format_status == 2)
                tmp_if_expr$13 = (_Bool)1;

              else
                tmp_if_expr$13 = (d->bg_format_status == 3 ? (!((flag & 16) != 0) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$13)
              {
                sprintf(msg, "FORMAT UNIT ignored. Already %s.", d->bg_format_status == 2 ? "in progress" : "completed");
                libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020120, 0x30000000, 0x30000000, msg, 0, 0);
                ret = 2;
                goto ex;
              }

              if((16 & flag) == 0)
              {
                if(d->bg_format_status == 1)
                  c->page->data[(signed long int)11] = (unsigned char)1;

              }

              sprintf(descr, "DVD+RW (fs=%d,rs=%d)", d->bg_format_status, (signed int)c->page->data[(signed long int)11] == 1);
              if(!((4 & flag) == 0))
                return_immediately = 1;

            }

            else
              if((16 & flag) == 0 && d->current_profile == 0x13)
              {
                ret=mmc_read_format_capacities(d, 0x13);
                if(ret >= 1)
                {
                  if(d->best_format_type == 0x13)
                  {
                    if(!(d->best_format_size >= 1l))
                    {
                      ret = 1;
                      goto ex;
                    }

                  }

                  else
                  {
                    if(d->format_descr_type == 2)
                    {
                      ret = 1;
                      goto ex;
                    }

                    if(d->format_descr_type == 3)
                    {
                      d->needs_close_session = 1;
                      ret = 1;
                      goto ex;
                    }

                    tolerate_failure = 1;
                  }
                }

                if(d->best_format_type == 0x13)
                {
                  if(!((12 & flag) == 0))
                  {
                    num_of_blocks = d->best_format_size / (signed long int)2048;
                    if(!((8 & flag) == 0))
                    {
                      diff = (size - d->format_curr_max_size) / (signed long int)32768;
                      if(!((size + -d->format_curr_max_size) % 32768l == 0l))
                        diff = diff + 1l;

                      diff = diff * (signed long int)16;
                      if(!(diff >= num_of_blocks))
                        num_of_blocks = diff;

                    }

                    if(num_of_blocks >= 1l)
                      mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);

                  }

                }

                format_type = 0x13;
                c->page->data[(signed long int)11] = (unsigned char)16;
                sprintf(descr, "DVD-RW quick grow");
              }

              else
              {
                _Bool tmp_if_expr$17;
                if(d->current_profile == 0x14)
                  tmp_if_expr$17 = (_Bool)1;

                else
                  tmp_if_expr$17 = (d->current_profile == 0x13 ? ((flag & 16) != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$17)
                {
                  mmc_read_format_capacities(d, (flag & 4) != 0 ? full_format_type : 0x15);
                  _Bool tmp_if_expr$15;
                  if(d->best_format_type == 0x15)
                    tmp_if_expr$15 = (_Bool)1;

                  else
                    tmp_if_expr$15 = d->best_format_type == full_format_type ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$15)
                  {
                    _Bool tmp_if_expr$14;
                    if(!((4 & flag) == 0))
                      tmp_if_expr$14 = (_Bool)1;

                    else
                      tmp_if_expr$14 = d->best_format_type == full_format_type ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr$14)
                    {
                      num_of_blocks = d->best_format_size / (signed long int)2048;
                      mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
                    }

                  }

                  else
                  {

                  no_suitable_formatting_type:
                    ;
                    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020131, 0x60000000, 0x30000000, "No suitable formatting type offered by drive", 0, 0);
                    ret = 0;
                    goto ex;
                  }
                  format_type = d->best_format_type;
                  sprintf(descr, "DVD-RW %s", format_type == 0x15 ? "quick" : "full");
                  return_immediately = 1;
                }

                else
                  if(d->current_profile == 0x12)
                  {
                    format_00_index = -1;
                    index = format_00_index;
                    format_00_max_size = (signed long int)-1;
                    format_size = format_00_max_size;
                    i = 0;
                    for( ; !(i >= d->num_format_descr); i = i + 1)
                    {
                      format_type = d->format_descriptors[(signed long int)i].type;
                      i_size = d->format_descriptors[(signed long int)i].size;
                      if(format_type == 0x00 || format_type == 0x01)
                      {
                        if(!((32 & flag) == 0))
                        {
                          if(!(format_type == 0x00))
                            goto __CPROVER_DUMP_L67;

                          if(!(i_size >= format_size))
                            goto __CPROVER_DUMP_L67;

                          format_size = i_size;
                          index = i;
                          goto __CPROVER_DUMP_L67;
                        }

                        else
                          if(!((4 & flag) == 0))
                          {
                            if(format_type == 0x00)
                            {
                              if(!(i_size >= format_size))
                                goto __CPROVER_DUMP_L67;

                              if(!(i_size >= format_00_max_size))
                              {
                                format_size = i_size;
                                index = i;
                                goto __CPROVER_DUMP_L67;
                              }

                              format_size = format_00_max_size;
                              index = format_00_index;
                              format_00_max_size = i_size;
                              format_00_index = i;
                              goto __CPROVER_DUMP_L67;
                            }

                            if(size_mode == 3)
                              goto __CPROVER_DUMP_L67;

                            if(!(format_size >= i_size))
                            {
                              format_size = i_size;
                              index = i;
                            }

                            goto __CPROVER_DUMP_L67;
                          }

                        if(d->format_descriptors[(signed long int)i].size >= size)
                        {
                          if(!(format_size >= 0l) || !(i_size >= format_size))
                          {
                            format_size = i_size;
                            index = i;
                          }

                        }

                      }


                    __CPROVER_DUMP_L67:
                      ;
                    }
                    if((32 & flag) == 0 && !((4 & flag) == 0) && !(index >= 0))
                    {
                      format_size = format_00_max_size;
                      index = format_00_index;
                    }

                    if(!(index >= 0))
                      goto no_suitable_formatting_type;

                    format_type = d->format_descriptors[(signed long int)index].type;
                    num_of_blocks = d->format_descriptors[(signed long int)index].size / (signed long int)2048;
                    mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
                    i = 0;
                    for( ; !(i >= 3); i = i + 1)
                      c->page->data[(signed long int)(9 + i)] = (unsigned char)(d->format_descriptors[(signed long int)index].tdp >> 16 - 8 * i & (unsigned int)0xff);
                    sprintf(descr, "%s", (const void *)d->current_profile_text);
                    return_immediately = 1;
                    c->page->data[(signed long int)1] = c->page->data[(signed long int)1] | (unsigned char)0x80;
                    if(!((64 & flag) == 0) && !(format_type == 0x01))
                    {
                      c->page->data[(signed long int)1] = c->page->data[(signed long int)1] | (unsigned char)0x20;
                      c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)0x08;
                    }

                  }

                  else
                    if(d->current_profile == 0x41)
                    {
                      index = -1;
                      format_size = (signed long int)-1;
                      if(!(d->num_format_descr >= 1))
                        goto no_suitable_formatting_type;

                      if(!(d->format_descriptors[0l].type == 0))
                        goto no_suitable_formatting_type;

                      i = 0;
                      for( ; !(i >= d->num_format_descr); i = i + 1)
                      {
                        format_type = d->format_descriptors[(signed long int)i].type;
                        i_size = d->format_descriptors[(signed long int)i].size;
                        if(format_type == 0x00 || format_type == 0x32)
                        {
                          if(!((32 & flag) == 0))
                            goto no_suitable_formatting_type;

                          else
                            if(size_mode == 2)
                            {
                              if(!(format_type == 0x32))
                                goto __CPROVER_DUMP_L81;

                            }

                            else
                              if(size_mode == 3)
                              {
                                if(format_type == 0x00)
                                {
                                  index = i;
                                  break;
                                }

                                goto __CPROVER_DUMP_L81;
                              }

                              else
                              {
                                if(!(format_type == 0x32))
                                  goto __CPROVER_DUMP_L81;

                                if(!(i_size >= min_size) || !(min_size >= 0l))
                                  min_size = i_size;

                                if(!(max_size >= i_size))
                                  max_size = i_size;

                              }
                          if(!(format_size >= i_size))
                          {
                            format_size = i_size;
                            index = i;
                          }

                        }


                      __CPROVER_DUMP_L81:
                        ;
                      }
                      if((32 & flag) == 0 && size_mode == 2 && !(index >= 0))
                        index = 0;

                      if(!(index >= 0))
                        goto no_suitable_formatting_type;

                      format_type = d->format_descriptors[(signed long int)index].type;
                      if(!((65536 & flag) == 0))
                        format_sub_type = 0;

                      else
                        format_sub_type = 1;
                      if(size_mode == 0 || size_mode == 1)
                      {
                        if(!(max_size >= 0l) || !(min_size >= 0l))
                          goto no_suitable_formatting_type;

                        if(!(size >= 1l))
                          size = min_size;

                        if(!(size % 65536l == 0l))
                          size = size + ((signed long int)0x10000 - size % (signed long int)0x10000);

                        if(!(size >= min_size))
                          goto no_suitable_formatting_type;

                        else
                          if(!(max_size >= size))
                            goto no_suitable_formatting_type;

                        num_of_blocks = size / (signed long int)2048;
                        mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
                        i = 0;
                        for( ; !(i >= 3); i = i + 1)
                          c->page->data[(signed long int)(9 + i)] = (unsigned char)0;
                      }

                      else
                      {
                        num_of_blocks = d->format_descriptors[(signed long int)index].size / (signed long int)2048;
                        mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
                        i = 0;
                        for( ; !(i >= 3); i = i + 1)
                          c->page->data[(signed long int)(9 + i)] = (unsigned char)(d->format_descriptors[(signed long int)index].tdp >> 16 - 8 * i & (unsigned int)0xff);
                      }
                      sprintf(descr, "%s", (const void *)d->current_profile_text);
                      return_immediately = 1;
                      c->page->data[(signed long int)1] = c->page->data[(signed long int)1] | (unsigned char)0x80;
                    }

                    else
                      if(d->current_profile == 0x43)
                      {
                        index = -1;
                        format_size = (signed long int)-1;
                        if(!(d->num_format_descr >= 1))
                          goto no_suitable_formatting_type;

                        if(!(d->format_descriptors[0l].type == 0))
                          goto no_suitable_formatting_type;

                        i = 0;
                        for( ; !(i >= d->num_format_descr); i = i + 1)
                        {
                          format_type = d->format_descriptors[(signed long int)i].type;
                          i_size = d->format_descriptors[(signed long int)i].size;
                          if(format_type == 0x00 || format_type == 0x30 || format_type == 0x31)
                          {
                            if(!((32 & flag) == 0))
                            {
                              if(!(format_type == 0x31))
                                goto __CPROVER_DUMP_L105;

                            }

                            else
                              if(size_mode == 2)
                              {
                                if(!(format_type == 0x30))
                                  goto __CPROVER_DUMP_L105;

                              }

                              else
                                if(size_mode == 3)
                                {
                                  if(!(accept_count >= 1))
                                    index = 0;

                                  if(format_type == 0x00 && !((64 & flag) == 0))
                                  {
                                    index = i;
                                    break;
                                  }

                                  if(!(format_type == 0x30))
                                    goto __CPROVER_DUMP_L105;

                                  accept_count = accept_count + 1;
                                  if(accept_count == 1)
                                    index = i;

                                  goto __CPROVER_DUMP_L105;
                                }

                                else
                                {
                                  if(!(format_type == 0x30))
                                    goto __CPROVER_DUMP_L105;

                                  if(!(i_size >= min_size) || !(min_size >= 0l))
                                    min_size = i_size;

                                  if(!(max_size >= i_size))
                                    max_size = i_size;

                                }
                            if(!(format_size >= i_size))
                            {
                              format_size = i_size;
                              index = i;
                            }

                          }


                        __CPROVER_DUMP_L105:
                          ;
                        }
                        if((32 & flag) == 0 && size_mode == 2 && !(index >= 0))
                          index = 0;

                        if(!(index >= 0))
                          goto no_suitable_formatting_type;

                        format_type = d->format_descriptors[(signed long int)index].type;
                        if(format_type == 0x30 || format_type == 0x31)
                        {
                          _Bool tmp_if_expr$16;
                          if(!((64 & flag) == 0))
                            tmp_if_expr$16 = (_Bool)1;

                          else
                            tmp_if_expr$16 = !((d->current_feat23h_byte4 & 3) != 0) ? (_Bool)1 : (_Bool)0;
                          if(tmp_if_expr$16)
                          {
                            format_sub_type = 0;
                            if((64 & flag) == 0)
                              libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002019e, 0x30000000, 0x30000000, "Drive does not support media certification", 0, 0);

                          }

                          else
                            if(!((1 & d->current_feat23h_byte4) == 0))
                              format_sub_type = 2;

                            else
                              format_sub_type = 3;
                        }

                        if(size_mode == 0 || size_mode == 1)
                        {
                          if(!(max_size >= 0l) || !(min_size >= 0l))
                            goto no_suitable_formatting_type;

                          if(!(size >= 1l))
                            size = min_size;

                          if(!(size % 65536l == 0l))
                            size = size + ((signed long int)0x10000 - size % (signed long int)0x10000);

                          if(!(size >= min_size))
                            goto no_suitable_formatting_type;

                          else
                            if(!(max_size >= size))
                              goto no_suitable_formatting_type;

                          num_of_blocks = size / (signed long int)2048;
                          mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
                          i = 0;
                          for( ; !(i >= 3); i = i + 1)
                            c->page->data[(signed long int)(9 + i)] = (unsigned char)0;
                        }

                        else
                        {
                          num_of_blocks = d->format_descriptors[(signed long int)index].size / (signed long int)2048;
                          mmc_int_to_four_char(c->page->data + (signed long int)4, (signed int)num_of_blocks);
                          i = 0;
                          for( ; !(i >= 3); i = i + 1)
                            c->page->data[(signed long int)(9 + i)] = (unsigned char)(d->format_descriptors[(signed long int)index].tdp >> 16 - 8 * i & (unsigned int)0xff);
                        }
                        sprintf(descr, "%s", (const void *)d->current_profile_text);
                        return_immediately = 1;
                        c->page->data[(signed long int)1] = c->page->data[(signed long int)1] | (unsigned char)0x80;
                      }

                      else
                      {

                      unsuitable_media:
                        ;
                        sprintf(msg, "Unsuitable media detected. Profile %4.4Xh  %s", d->current_profile, (const void *)d->current_profile_text);
                        libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011e, 0x60000000, 0x30000000, msg, 0, 0);
                        ret = 0;
                        goto ex;
                      }
              }
          c->page->data[(signed long int)8] = (unsigned char)(format_type << 2 | format_sub_type & 3);
          if(format_type == 0x00 || format_type == 0x01 || format_type == 0x31)
          {
            c->page->data[(signed long int)9] = (unsigned char)0x00;
            c->page->data[(signed long int)10] = (unsigned char)0x08;
            c->page->data[(signed long int)11] = (unsigned char)0x00;
          }

          else
            if(format_type >= 0x10 && !(format_type >= 22))
            {
              c->page->data[(signed long int)9] = (unsigned char)0;
              c->page->data[(signed long int)10] = (unsigned char)0;
              c->page->data[(signed long int)11] = (unsigned char)16;
            }

          sprintf(msg, "Format type %2.2Xh \"%s\", blocks = %.f", format_type, (const void *)descr, (double)num_of_blocks);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
          sprintf(msg, "CDB: ");
          i = 0;
          for( ; !(i >= 6); i = i + 1)
          {
            return_value_strlen$18=strlen(msg);
            sprintf(msg + (signed long int)return_value_strlen$18, "%2.2X ", c->opcode[(signed long int)i]);
          }
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
          sprintf(msg, "Format list: ");
          i = 0;
          for( ; !(i >= 12); i = i + 1)
          {
            return_value_strlen$19=strlen(msg);
            sprintf(msg + (signed long int)return_value_strlen$19, "%2.2X ", c->page->data[(signed long int)i]);
          }
          strcat(msg, "\n");
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
          d->issue_command(d, c);
          if(tolerate_failure == 0 && !(c->error == 0))
          {
            spc_decode_sense(c->sense, 0, &key, &asc, &ascq);
            if(!(key == 0))
            {
              sprintf(msg, "SCSI error on format_unit(%s): ", (const void *)descr);
              unsigned long int return_value_strlen$20;
              return_value_strlen$20=strlen(msg);
              scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$20, &key, &asc, &ascq);
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020122, 0x68000000, 0x30000000, msg, 0, 0);
            }

            ret = 0;
          }

          else
            if(c->error == 0)
            {
              if(format_type == 0x13 || format_type == 0x15)
                d->needs_close_session = 1;

            }

          if(!(return_immediately == 0))
            ret = 1;

          else
          {
            usleep((unsigned int)1000000);
            ret = 0;
            if(!(ret >= 1))
            {
              usleep((unsigned int)50000);
              ret=spc_test_unit_ready(d);
            }

            mmc_sync_cache(d);
            ret = 1;
          }
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_four_char_to_int
// file libburn/mmc.c line 297
signed int mmc_four_char_to_int(unsigned char *data)
{
  return (signed int)data[(signed long int)0] << 24 | (signed int)data[(signed long int)1] << 16 | (signed int)data[(signed long int)2] << 8 | (signed int)data[(signed long int)3];
}

// mmc_function_spy
// file libburn/mmc.h line 112
signed int mmc_function_spy(struct burn_drive *d, char *text)
{
  if(!(mmc_function_spy_do_tell == 0))
    fprintf(stderr, "libburn: experimental: mmc_function_spy: %s\n", text);

  if(d == ((struct burn_drive *)NULL))
    return 1;

  else
  {
    if(!(d->drive_role == 1))
    {
      char msg[4096l];
      sprintf(msg, "Emulated drive caught in SCSI adapter \"%s\"", text);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002014c, 0x70000000, 0x30000000, msg, 0, 0);
      d->cancel = 1;
      return 0;
    }

    return 1;
  }
}

// mmc_function_spy_ctrl
// file libburn/mmc.c line 289
signed int mmc_function_spy_ctrl(signed int do_tell)
{
  mmc_function_spy_do_tell = (signed int)!(!(do_tell != 0));
  return 1;
}

// mmc_get_bd_spare_info
// file libburn/mmc.h line 118
signed int mmc_get_bd_spare_info(struct burn_drive *d, signed int *alloc_blocks, signed int *free_blocks, signed int flag)
{
  signed int ret;
  signed int reply_len;
  signed int prf;
  char *reply = (char *)(void *)0;
  prf = d->current_profile;
  if(!(prf == 0x41) && !(prf == 0x42) && !(prf == 0x43))
    return 0;

  else
  {
    ret=mmc_read_disc_structure(d, 1, 0, 0x0a, 12, &reply, &reply_len, 0);
    if(ret >= 1)
    {
      *alloc_blocks=mmc_four_char_to_int((unsigned char *)reply + (signed long int)8);
      *free_blocks=mmc_four_char_to_int((unsigned char *)reply + (signed long int)4);
      ret = 1;
    }


  ex:
    ;
    if(!(reply == ((char *)NULL)))
      free((void *)reply);

    return ret;
  }
}

// mmc_get_configuration
// file libburn/mmc.c line 3282
void mmc_get_configuration(struct burn_drive *d)
{
  signed int alloc_len = 8;
  signed int ret;
  if(d->current_profile >= 1)
  {
    if(d->current_profile >= 0xffff)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    mmc_start_if_needed(d, 1);
    signed int return_value_mmc_function_spy$1;
    return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_get_configuration");
    if(return_value_mmc_function_spy$1 >= 1)
    {
      ret=mmc_get_configuration_al(d, &alloc_len);
      if(alloc_len >= 9 && ret >= 1)
        mmc_get_configuration_al(d, &alloc_len);

    }

  }
}

// mmc_get_configuration_al
// file libburn/mmc.c line 2943
static signed int mmc_get_configuration_al(struct burn_drive *d, signed int *alloc_len)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  signed int len;
  signed int cp;
  signed int descr_len = 0;
  signed int feature_code;
  signed int only_current = 1;
  signed int i;
  signed int old_alloc_len;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int ret;
  signed int feature_is_current;
  unsigned char *descr;
  unsigned char *prf;
  unsigned char *up_to;
  unsigned char *prf_end;
  struct command *c = (struct command *)(void *)0;
  signed int phys_if_std = 0;
  char *phys_name = "";
  struct burn_feature_descr *recent_feature = (struct burn_feature_descr *)(void *)0;
  struct burn_feature_descr *new_feature;
  char *msg = (char *)(void *)0;
  signed int return_value_mmc_four_char_to_int$3;
  char *return_value_mmc_obtain_profile_name$5;
  if(!(*alloc_len >= 8))
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$1;
    if(buf == ((struct buffer *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$2;
      return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$2;
      if(c == ((struct command *)NULL))
        ret = -1;

      else
      {
        d->current_profile = 0;
        d->current_profile_text[(signed long int)0] = (char)0;
        d->current_is_cd_profile = 0;
        d->current_is_supported_profile = 0;
        d->current_is_guessed_profile = 0;
        d->num_profiles = 0;
        if(!(d->features == ((struct burn_feature_descr *)NULL)))
          burn_feature_descr_free(&d->features, 0);

        d->current_has_feat21h = 0;
        d->current_feat21h_link_size = -1;
        d->current_feat23h_byte4 = 0;
        d->current_feat23h_byte8 = 0;
        d->current_feat2fh_byte4 = -1;
        scsi_init_command(c, MMC_GET_CONFIGURATION, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = *alloc_len;
        c->retry = 1;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->page = buf;
        c->page->sectors = 0;
        c->page->bytes = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
        {
          spc_decode_sense(c->sense, 0, &key, &asc, &ascq);
          if(asc == 0x20 && ascq == 0x0 && key == 0x5)
          {
            d->current_is_guessed_profile = 1;
            mmc_guess_profile(d, 0);
          }

          ret = 0;
        }

        else
        {
          old_alloc_len = *alloc_len;
          return_value_mmc_four_char_to_int$3=mmc_four_char_to_int(c->page->data);
          len = return_value_mmc_four_char_to_int$3 + 4;
          *alloc_len = len;
          if(!(old_alloc_len >= len))
            len = old_alloc_len;

          if(!(len >= 8))
            ret = 0;

          else
            if(len >= 4097)
            {
              void *return_value_burn_alloc_mem$4;
              return_value_burn_alloc_mem$4=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)256, 0);
              msg = (char *)return_value_burn_alloc_mem$4;
              if(msg == ((char *)NULL))
                ret = -1;

              sprintf(msg, "Implausible length announcement from SCSI command GET CONFIGURATION: %d", *alloc_len);
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x000201a9, 0x68000000, 0x00000000, msg, 0, 0);
              ret = 0;
            }

            else
            {
              cp = (signed int)c->page->data[(signed long int)6] << 8 | (signed int)c->page->data[(signed long int)7];
              d->current_profile = cp;
              return_value_mmc_obtain_profile_name$5=mmc_obtain_profile_name(cp);
              strcpy(d->current_profile_text, return_value_mmc_obtain_profile_name$5);
              if(cp == 0x08)
              {
                d->current_is_cd_profile = 1;
                d->current_is_supported_profile = d->current_is_cd_profile;
              }

              if(cp == 0x10)
                d->current_is_supported_profile = 1;

              if(cp == 0x40)
                d->current_is_supported_profile = 1;

              if(cp == 0x42)
                d->current_is_supported_profile = 1;

              if(cp == 0x09 || cp == 0x0a)
              {
                d->current_is_cd_profile = 1;
                d->current_is_supported_profile = d->current_is_cd_profile;
              }

              if(cp == 0x1a)
                d->current_is_supported_profile = 1;

              if(cp == 0x13)
                d->current_is_supported_profile = 1;

              if(cp == 0x12 || cp == 0x43)
                d->current_is_supported_profile = 1;

              if(cp == 0x11 || cp == 0x14)
                d->current_is_supported_profile = 1;

              if(cp == 0x15)
                d->current_is_supported_profile = 1;

              if(cp == 0x1b || cp == 0x2b)
                d->current_is_supported_profile = 1;

              if(cp == 0x41)
                d->current_is_supported_profile = 1;

              up_to = c->page->data + (signed long int)len;
              descr = c->page->data + (signed long int)8;
              if(!(descr + 3l >= up_to))
              {
                descr_len = 4 + (signed int)descr[(signed long int)3];
                feature_code = (signed int)descr[(signed long int)0] << 8 | (signed int)descr[(signed long int)1];
                feature_is_current = (signed int)descr[(signed long int)2] & 1;
                ret=burn_feature_descr_new(&new_feature, descr, (signed int)(up_to - descr), 0);
                if(ret >= 1)
                {
                  if(d->features == ((struct burn_feature_descr *)NULL))
                    d->features = new_feature;

                  else
                    recent_feature->next = new_feature;
                  recent_feature = new_feature;
                }

                if(!(feature_is_current == 0) || only_current == 0)
                {
                  if(feature_code == 0x0)
                  {
                    prf_end = descr + (signed long int)4 + (signed long int)descr[(signed long int)3];
                    d->num_profiles = (signed int)descr[(signed long int)3] / 4;
                    if(d->num_profiles >= 65)
                      d->num_profiles = 64;

                    if(d->num_profiles >= 1)
                      memcpy((void *)d->all_profiles, (const void *)(descr + (signed long int)4), (unsigned long int)(d->num_profiles * 4));

                    prf = descr + (signed long int)4;
                    if(!(prf + 2l >= prf_end))
                      prf = prf + (signed long int)4;

                  }

                  else
                    if(feature_code == 0x21)
                    {
                      d->current_has_feat21h = feature_is_current;
                      i = 0;
                      if(!(i >= (signed int)descr[7l]))
                      {
                        _Bool tmp_if_expr$6;
                        if(i == 0)
                          tmp_if_expr$6 = (_Bool)1;

                        else
                          tmp_if_expr$6 = (signed int)descr[(signed long int)(8 + i)] == 16 ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr$6)
                          d->current_feat21h_link_size = (signed int)descr[(signed long int)(8 + i)];

                        i = i + 1;
                      }

                    }

                    else
                      if(feature_code == 0x23)
                      {
                        if(!(feature_is_current == 0))
                        {
                          d->current_feat23h_byte4 = (signed int)descr[(signed long int)4];
                          d->current_feat23h_byte8 = (signed int)descr[(signed long int)8];
                        }

                      }

                      else
                        if(feature_code == 0x2F)
                        {
                          if(!(feature_is_current == 0))
                            d->current_feat2fh_byte4 = (signed int)descr[(signed long int)4];

                        }

                        else
                          if(feature_code == 0x01)
                          {
                            phys_if_std = (signed int)descr[(signed long int)4] << 24 | (signed int)descr[(signed long int)5] << 16 | (signed int)descr[(signed long int)6] << 8 | (signed int)descr[(signed long int)7];
                            if(phys_if_std == 1)
                              phys_name = "SCSI Family";

                            else
                              if(phys_if_std == 2)
                                phys_name = "ATAPI";

                              else
                                if(phys_if_std == 3 || phys_if_std == 4 || phys_if_std == 6)
                                  phys_name = "IEEE 1394 FireWire";

                                else
                                  if(phys_if_std == 7)
                                    phys_name = "Serial ATAPI";

                                  else
                                    if(phys_if_std == 8)
                                      phys_name = "USB";

                            d->phys_if_std = phys_if_std;
                            strcpy(d->phys_if_name, phys_name);
                          }

                          else
                            if(feature_code == 0x108 || feature_code == 0x10c)
                            {
                              signed int c_limit = (signed int)descr[(signed long int)3] - 2 * (signed int)(feature_code == 0x10c);
                              if(feature_code == 0x108)
                              {
                                if(!(d->drive_serial_number == ((char *)NULL)))
                                {
                                  if(!(d->drive_serial_number == ((char *)NULL)))
                                    free((void *)(char *)d->drive_serial_number);

                                }

                                void *return_value_burn_alloc_mem$7;
                                return_value_burn_alloc_mem$7=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(c_limit + 1), 0);
                                d->drive_serial_number = (char *)return_value_burn_alloc_mem$7;
                                if(d->drive_serial_number == ((char *)NULL))
                                  ret = -1;

                                memcpy((void *)d->drive_serial_number, (const void *)(descr + (signed long int)4), (unsigned long int)c_limit);
                                d->drive_serial_number[(signed long int)c_limit] = (char)0;
                                d->drive_serial_number_len = (char)c_limit;
                              }

                            }

                }

                descr = descr + (signed long int)descr_len;
              }

              ret = 1;
            }
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// mmc_get_event
// file libburn/mmc.c line 646
void mmc_get_event(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c;
  signed int alloc_len = 8;
  signed int len;
  signed int evt_code;
  signed int loops = 0;
  unsigned char *evt;
  c = &d->casual_command;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$2;
  if(!(buf == ((struct buffer *)NULL)))
  {
    return_value_mmc_function_spy$2=mmc_function_spy(d, "mmc_get_event");
    if(return_value_mmc_function_spy$2 >= 1)
    {

    again:
      ;
      scsi_init_command(c, MMC_GET_EVENT, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
      c->dxfer_len = 8;
      c->opcode[(signed long int)4] = (unsigned char)0x7e;
      c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
      c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
      c->retry = 1;
      c->page = buf;
      c->page->bytes = 0;
      c->page->sectors = 0;
      c->dir = 1;
      d->issue_command(d, c);
      if(c->error == 0)
      {
        evt = c->page->data;
        len = ((signed int)evt[(signed long int)0] << 8 | (signed int)evt[(signed long int)1]) + 2;
        if(len >= 8)
        {
          if(!((signed int)evt[3l] == 0))
          {
            evt_code = (signed int)evt[(signed long int)4] & 0xf;
            if(!(evt_code == 0))
            {
              if((7 & (signed int)evt[2l]) == 0)
              {
                if(!(((signed int)evt[6l] << 8 | (signed int)evt[7l]) == 0))
                {
                  alloc_len = 8;
                  mmc_get_configuration_al(d, &alloc_len);
                }

                if((signed int)evt[5l] >= 2)
                  d->start_unit(d);

                if(evt_code == 2)
                {
                  d->start_unit(d);
                  alloc_len = 8;
                  mmc_get_configuration_al(d, &alloc_len);
                }

              }

              loops = loops + 1;
            }

          }

        }

      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

}

// mmc_get_leadin_text
// file libburn/mmc.h line 127
signed int mmc_get_leadin_text(struct burn_drive *d, unsigned char **text_packs, signed int *num_packs, signed int flag)
{
  signed int alloc_len = 4;
  signed int ret;
  *num_packs = 0;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_get_leadin_text");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return -1;

  else
  {
    ret=mmc_get_leadin_text_al(d, text_packs, &alloc_len, 1);
    if(!(alloc_len >= 22) || !(ret >= 1))
      return ret > 0 ? 0 : ret;

    else
    {
      ret=mmc_get_leadin_text_al(d, text_packs, &alloc_len, 0);
      if(!(alloc_len >= 22) || !(ret >= 1))
      {
        if(!(*text_packs == ((unsigned char *)NULL)))
          free((void *)*text_packs);

        *text_packs = (unsigned char *)(void *)0;
        return ret > 0 ? 0 : ret;
      }

      else
      {
        *num_packs = (alloc_len - 4) / 18;
        return ret;
      }
    }
  }
}

// mmc_get_leadin_text_al
// file libburn/mmc.c line 2199
static signed int mmc_get_leadin_text_al(struct burn_drive *d, unsigned char **text_packs, signed int *alloc_len, signed int flag)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  unsigned char *data;
  signed int ret;
  signed int data_length;
  *text_packs = (unsigned char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      scsi_init_command(c, MMC_GET_LEADTEXT, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
      c->dxfer_len = *alloc_len;
      c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
      c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
      c->retry = 1;
      c->page = buf;
      c->page->bytes = 0;
      c->page->sectors = 0;
      c->dir = 1;
      d->issue_command(d, c);
      if(!(c->error == 0))
        ret = 0;

      else
      {
        data = c->page->data;
        data_length = ((signed int)data[(signed long int)0] << 8) + (signed int)data[(signed long int)1];
        *alloc_len = data_length + 2;
        if(*alloc_len >= 22)
        {
          if((1 & flag) == 0)
          {
            void *return_value_burn_alloc_mem$3;
            return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(unsigned char) /*1ul*/ , (unsigned long int)(*alloc_len - 4), 0);
            *text_packs = (unsigned char *)return_value_burn_alloc_mem$3;
            if(*text_packs == ((unsigned char *)NULL))
              ret = -1;

            memcpy((void *)*text_packs, (const void *)(data + (signed long int)4), (unsigned long int)(*alloc_len - 4));
          }

        }

        ret = 1;
      }
    }
  }

ex:
  ;
  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_get_media_product_id
// file libburn/mmc.h line 106
signed int mmc_get_media_product_id(struct burn_drive *d, char **product_id, char **media_code1, char **media_code2, char **book_type, signed int flag)
{
  signed int prf;
  signed int ret;
  signed int reply_len;
  signed int i;
  signed int has_11h = -1;
  signed int bt;
  signed int start_lba;
  signed int end_lba;
  signed int min;
  signed int sec;
  signed int fr;
  signed int media_type = 0;
  char *reply = (char *)(void *)0;
  char *wpt;
  *book_type = (char *)(void *)0;
  *media_code2 = *book_type;
  *media_code1 = *media_code2;
  *product_id = *media_code1;
  prf = d->current_profile;
  if(prf == 0x09 || prf == 0x0A)
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)20, (unsigned long int)1);
    *product_id = (char *)return_value_calloc$1;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)10, (unsigned long int)1);
    *media_code1 = (char *)return_value_calloc$2;
    void *return_value_calloc$3;
    return_value_calloc$3=calloc((unsigned long int)10, (unsigned long int)1);
    *media_code2 = (char *)return_value_calloc$3;
    _Bool tmp_if_expr$4;
    if(*product_id == ((char *)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = *media_code1 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$5;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = *media_code2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      ret = -1;
      goto ex;
    }

    ret=burn_disc_read_atip(d);
    if(!(ret >= 1))
      goto ex;

    ret=burn_drive_get_start_end_lba(d, &start_lba, &end_lba, 0);
    if(!(ret >= 1))
      goto ex;

    burn_lba_to_msf(start_lba, &min, &sec, &fr);
    sprintf(*media_code1, "%2.2dm%2.2ds%2.2df", min, sec, fr);
    burn_lba_to_msf(end_lba, &min, &sec, &fr);
    sprintf(*media_code2, "%2.2dm%2.2ds%2.2df", min, sec, fr);
    sprintf(*product_id, "%s/%s", *media_code1, *media_code2);
    ret = 1;
    goto ex;
  }

  else
    if(prf == 0x11 || prf == 0x13 || prf == 0x14 || prf == 0x15)
    {
      ret=mmc_read_disc_structure(d, 0, 0, 0x0E, 31, &reply, &reply_len, 0);
      if(!(ret >= 1))
        goto ex;

      _Bool tmp_if_expr$6;
      if(!((signed int)reply[16l] == 3))
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)reply[(signed long int)24] != 4 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
      {
        ret = 0;
        goto ex;
      }

      void *return_value_calloc$7;
      return_value_calloc$7=calloc((unsigned long int)19, (unsigned long int)1);
      *media_code1 = (char *)return_value_calloc$7;
      *media_code2=strdup("");
      _Bool tmp_if_expr$8;
      if(*media_code1 == ((char *)NULL))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = *media_code2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
      {
        ret = -1;
        goto ex;
      }

      memcpy((void *)*media_code1, (const void *)(reply + (signed long int)17), (unsigned long int)6);
      memcpy((void *)(*media_code1 + (signed long int)6), (const void *)(reply + (signed long int)25), (unsigned long int)6);
      wpt = *media_code1;
      i = 0;
      for( ; !(i >= 18); i = i + 1)
        if(!((*media_code1)[(signed long int)i] == 0))
        {
          char *tmp_post$9 = wpt;
          wpt = wpt + 1l;
          *tmp_post$9 = (*media_code1)[(signed long int)i];
        }

      *wpt = (char)0;
      ret=burn_util_make_printable_word(media_code1, 1 | (flag & 1) << 1);
      if(!(ret >= 1))
        goto ex;

      *product_id=strdup(*media_code1);
      if(*product_id == ((char *)NULL))
      {
        ret = -1;
        goto ex;
      }

    }

    else
      if(prf == 0x1a || prf == 0x1b || prf == 0x2b)
      {
        has_11h = 0;
        ret=mmc_read_disc_structure(d, 0, 0, 0xff, 4, &reply, &reply_len, 0);
        if(ret >= 1)
        {
          i = 0;
          for( ; !(i >= reply_len); i = i + 4)
            if((signed int)reply[(signed long int)i] == 0x11)
            {
              if(!((64 & (signed int)reply[(signed long int)(1 + i)]) == 0))
                has_11h = 1;

            }

        }

        if(!(reply == ((char *)NULL)))
          free((void *)reply);

        reply = (char *)(void *)0;
        ret=mmc_read_disc_structure(d, 0, 0, 0x11, 29, &reply, &reply_len, 0);
        if(!(ret >= 1))
          has_11h = 0;

        else
        {
          ret=mmc_set_product_id(reply, 19, 27, 28, product_id, media_code1, media_code2, flag & 1);
          if(!(ret >= 1))
            goto ex;

        }
      }

      else
        if(prf == 0x40 || prf == 0x41 || prf == 0x42 || prf == 0x43)
        {
          media_type = 1;
          ret=mmc_read_disc_structure(d, 1, 0, 0x00, 112, &reply, &reply_len, 0);
          if(!(ret >= 1))
            goto ex;

          _Bool tmp_if_expr$10;
          if(!((signed int)*reply == 68))
            tmp_if_expr$10 = (_Bool)1;

          else
            tmp_if_expr$10 = (signed int)reply[(signed long int)1] != 73 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$10)
          {
            ret = 0;
            goto ex;
          }

          ret=mmc_set_product_id(reply, 100, 106, 111, product_id, media_code1, media_code2, 2 | flag & 1);
          if(!(ret >= 1))
            goto ex;

        }

        else
        {
          ret = 0;
          goto ex;
        }
  if(!(reply == ((char *)NULL)))
    free((void *)reply);

  reply = (char *)(void *)0;
  ret=mmc_read_disc_structure(d, media_type, 0, 0x00, 1, &reply, &reply_len, 0);
  unsigned long int return_value_strlen$11;
  void *return_value_calloc$12;
  if(ret >= 1)
  {
    bt = (signed int)reply[(signed long int)0] >> 4 & 0xf;
    static char *books[16l] = { "DVD-ROM", "DVD-RAM", "DVD-R", "DVD-RW", "HD DVD-ROM", "HD DVD-RAM", "HD DVD-R", "unknown", "unknown", "DVD+RW", "DVD+R", "unknown", "unknown", "DVD+RW DLDVD+R DL", "unknown", ((char *)NULL) };
    return_value_strlen$11=strlen(books[(signed long int)bt]);
    return_value_calloc$12=calloc((unsigned long int)80 + return_value_strlen$11, (unsigned long int)1);
    *book_type = (char *)return_value_calloc$12;
    if(*book_type == ((char *)NULL))
      ret = -1;

    else
    {
      sprintf(*book_type, "%2.2Xh, %s book [revision %d]", bt, books[(signed long int)bt], (signed int)reply[(signed long int)0] & 0xf);
      if(has_11h == 0)
      {
        if(!(*product_id == ((char *)NULL)))
          goto __CPROVER_DUMP_L32;

        if(!(reply_len >= 29))
          goto __CPROVER_DUMP_L32;

        ret=mmc_set_product_id(reply, 19, 27, 28, product_id, media_code1, media_code2, flag & 1);
        if(!(*product_id == ((char *)NULL)))
          goto __CPROVER_DUMP_L32;

        ret = 0;
      }

      else
      {

      __CPROVER_DUMP_L32:
        ;
        ret = 1;
      }
    }
  }


ex:
  ;
  if(!(reply == ((char *)NULL)))
    free((void *)reply);

  if(!(ret >= 1))
  {
    if(!(*product_id == ((char *)NULL)))
      free((void *)*product_id);

    if(!(*media_code1 == ((char *)NULL)))
      free((void *)*media_code1);

    if(!(*media_code2 == ((char *)NULL)))
      free((void *)*media_code2);

    if(!(*book_type == ((char *)NULL)))
      free((void *)*book_type);

    *book_type = (char *)(void *)0;
    *media_code2 = *book_type;
    *media_code1 = *media_code2;
    *product_id = *media_code1;
  }

  return ret;
}

// mmc_get_nwa
// file libburn/mmc.c line 454
signed int mmc_get_nwa(struct burn_drive *d, signed int trackno, signed int *lba, signed int *nwa)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  signed int ret;
  signed int num;
  signed int alloc_len = 20;
  signed int err;
  unsigned char *data;
  char *msg = (char *)(void *)0;
  if(!(trackno >= 1))
    d->next_track_damaged = 0;

  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_get_nwa");
  if(!(return_value_mmc_function_spy$1 >= 1))
    ret = -1;

  else
    if(!((signed int)d->status == BURN_DISC_BLANK))
    {
      if((signed int)d->status == BURN_DISC_APPENDABLE)
        goto __CPROVER_DUMP_L3;

      ret = 0;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      void *return_value_burn_alloc_mem$2;
      return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
      buf = (struct buffer *)return_value_burn_alloc_mem$2;
      if(buf == ((struct buffer *)NULL))
        ret = -1;

      else
      {
        ret=mmc_read_track_info(d, trackno, buf, alloc_len);
        if(ret >= 1)
        {
          data = buf->data;
          *lba=mmc_four_char_to_int(data + (signed long int)8);
          *nwa=mmc_four_char_to_int(data + (signed long int)12);
          num=mmc_four_char_to_int(data + (signed long int)16);
          if(!(*nwa >= *lba))
          {
            if((signed int)d->status == BURN_DISC_BLANK)
              *nwa = *lba;

          }

          static signed int fake_damage = 0;
          if(!((1 & fake_damage) == 0))
            data[(signed long int)5] = data[(signed long int)5] | (unsigned char)32;

          if(!((2 & fake_damage) == 0))
            data[(signed long int)7] = data[(signed long int)7] & (unsigned char)~1;

          void *return_value_burn_alloc_mem$3;
          return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
          msg = (char *)return_value_burn_alloc_mem$3;
          if(msg == ((char *)NULL))
            ret = -1;

          else
          {
            if(trackno >= 1)
              sprintf(msg, "Track number %d: ", trackno);

            else
              sprintf(msg, "Upcomming track: ");
            _Bool tmp_if_expr$4;
            if(d->current_profile == 0x1a)
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = d->current_profile == 0x13 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$5;
            if(tmp_if_expr$4)
              tmp_if_expr$5 = (_Bool)1;

            else
              tmp_if_expr$5 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr$6;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
            {
              num = 0;
              *nwa = num;
              *lba = *nwa;
            }

            else
              if(!((32 & (signed int)data[5l]) == 0))
              {
                if((1 & (signed int)data[7l]) == 0)
                {
                  strcat(msg, "Damaged, not closed and not writable");
                  err = 0x00020185;
                }

                else
                {
                  strcat(msg, "Damaged and not closed");
                  err = 0x00020186;
                }
                libdax_msgs_submit(libdax_messenger, d->global_index, err, 0x50000000, 0x30000000, msg, 0, 0);
                if(!(trackno >= 1))
                  d->next_track_damaged = d->next_track_damaged | (signed int)!(((signed int)data[(signed long int)7] & 1) != 0) << 1 | 1;

                ret = 0;
                goto ex;
              }

              else
                if((1 & (signed int)data[7l]) == 0)
                {
                  strcat(msg, "No Next-Writable-Address");
                  libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020184, 0x50000000, 0x30000000, msg, 0, 0);
                  if(!(trackno >= 1))
                    d->next_track_damaged = d->next_track_damaged | 2;

                  ret = 0;
                  goto ex;
                }

            if(num >= 1)
            {
              burn_drive_set_media_capacity_remaining(d, (signed long int)num * (signed long int)2048);
              d->media_lba_limit = *nwa + num;
            }

            else
              d->media_lba_limit = 0;
            ret = 1;
          }
        }

      }
    }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// mmc_get_performance
// file libburn/mmc.c line 4490
signed int mmc_get_performance(struct burn_drive *d, signed int descr_type, signed int flag)
{
  signed int alloc_len = 8;
  signed int max_descr = 0;
  signed int ret;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_get_write_performance");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    ret=mmc_get_performance_al(d, descr_type, &alloc_len, &max_descr, 0);
    if(max_descr >= 1 && ret >= 1)
      ret=mmc_get_performance_al(d, descr_type, &alloc_len, &max_descr, 0);

    if(max_descr >= 1 && ret >= 1)
    {
      max_descr = (alloc_len - 8) / 16;
      ret=mmc_get_performance_al(d, descr_type, &alloc_len, &max_descr, 1);
    }

    return ret;
  }
}

// mmc_get_performance_al
// file libburn/mmc.c line 4427
static signed int mmc_get_performance_al(struct burn_drive *d, signed int descr_type, signed int *alloc_len, signed int *max_descr, signed int flag)
{
  signed int num_descr;
  signed int ret;
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      if(!(d->current_profile >= 0))
        mmc_get_configuration(d);

      if(!(*alloc_len >= 8))
        ret = 0;

      else
        if(!(descr_type == 0x00) && !(descr_type == 0x03))
          ret = 0;

        else
        {
          scsi_init_command(c, MMC_GET_PERFORMANCE, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
          c->dxfer_len = *alloc_len;
          if(descr_type == 0x00)
            c->opcode[(signed long int)1] = (unsigned char)0x10;

          c->opcode[(signed long int)8] = (unsigned char)(*max_descr >> 8 & 0xff);
          c->opcode[(signed long int)9] = (unsigned char)(*max_descr >> 0 & 0xff);
          c->opcode[(signed long int)10] = (unsigned char)descr_type;
          c->retry = 1;
          c->page = buf;
          c->page->sectors = 0;
          c->page->bytes = 0;
          c->dir = 1;
          d->issue_command(d, c);
          if(!(c->error == 0))
            ret = 0;

          else
          {
            ret=interpret_performance(d, c, descr_type, alloc_len, max_descr, &num_descr, flag);
            if(ret >= 1)
              ret = num_descr;

          }
        }
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// mmc_get_phys_format_info
// file libburn/mmc.h line 122
signed int mmc_get_phys_format_info(struct burn_drive *d, signed int *disk_category, char **book_name, signed int *part_version, signed int *num_layers, signed int *num_blocks, signed int flag)
{
  signed int ret;
  signed int reply_len;
  signed int prf;
  char *reply = (char *)(void *)0;
  prf = d->current_profile;
  if(!(prf == 0x11) && !(prf == 0x13) && !(prf == 0x14) && !(prf == 0x15) && !(prf == 0x51))
    return 0;

  else
  {
    ret=mmc_read_disc_structure(d, 0, 0, 0x10, 12, &reply, &reply_len, 0);
    if(ret >= 1)
    {
      if(!(reply_len >= 12))
      {
        libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, "READ DISC STRUCTURE format 10h: Less than 12 bytes", 0, 0);
        ret = 0;
      }

      else
      {
        *disk_category = (signed int)reply[(signed long int)0] >> 4 & 0xf;
        static char book_names[17l][16l] = { { 'D', 'V', 'D', '-', 'R', 'O', 'M', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '-', 'R', 'A', 'M', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '-', 'R', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '-', 'R', 'W', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'H', 'D', ' ', 'D', 'V', 'D', '-', 'R', 'O', 'M', 0, 0, 0, 0, 0, 0 },
    { 'H', 'D', ' ', 'D', 'V', 'D', '-', 'R', 'A', 'M', 0, 0, 0, 0, 0, 0 },
    { 'H', 'D', ' ', 'D', 'V', 'D', '-', 'R', 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '+', 'R', 'W', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '+', 'R', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '+', 'R', 'W', ' ', 'D', 'L', 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'V', 'D', '+', 'R', ' ', 'D', 'L', 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'u', 'n', 'k', 'n', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
        *book_name = book_names[(signed long int)*disk_category];
        *part_version = (signed int)reply[(signed long int)0] & 0xf;
        *num_layers = ((signed int)reply[(signed long int)2] >> 5 & 0x3) + 1;
        *num_blocks = (((signed int)reply[(signed long int)9] << 16 | (signed int)reply[(signed long int)10] << 8 | (signed int)reply[(signed long int)11]) - ((signed int)reply[(signed long int)5] << 16 | (signed int)reply[(signed long int)6] << 8 | (signed int)reply[(signed long int)7])) + 1;
        ret = 1;
      }
    }


  ex:
    ;
    if(!(reply == ((char *)NULL)))
      free((void *)reply);

    return ret;
  }
}

// mmc_get_write_performance
// file libburn/mmc.c line 4523
signed int mmc_get_write_performance(struct burn_drive *d)
{
  signed int ret;
  ret=mmc_get_performance(d, 0x03, 0);
  return ret;
}

// mmc_guess_profile
// file libburn/mmc.c line 1861
static signed int mmc_guess_profile(struct burn_drive *d, signed int flag)
{
  signed int cp = 0;
  _Bool tmp_if_expr$1;
  if((signed int)d->status == BURN_DISC_BLANK)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)d->status == BURN_DISC_APPENDABLE ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    cp = 0x09;

  else
    if((signed int)d->status == BURN_DISC_FULL)
      cp = 0x08;

  if(!(cp == 0))
  {
    if(!(d->erasable == 0))
      cp = 0x0a;

  }

  d->current_profile = cp;
  if(cp == 0)
    return 0;

  else
  {
    d->current_is_cd_profile = 1;
    d->current_is_supported_profile = 1;
    char *return_value_mmc_obtain_profile_name$2;
    return_value_mmc_obtain_profile_name$2=mmc_obtain_profile_name(cp);
    strcpy(d->current_profile_text, return_value_mmc_obtain_profile_name$2);
    return 1;
  }
}

// mmc_int_to_four_char
// file libburn/mmc.c line 304
signed int mmc_int_to_four_char(unsigned char *data, signed int num)
{
  data[(signed long int)0] = (unsigned char)(num >> 24 & 0xff);
  data[(signed long int)1] = (unsigned char)(num >> 16 & 0xff);
  data[(signed long int)2] = (unsigned char)(num >> 8 & 0xff);
  data[(signed long int)3] = (unsigned char)(num & 0xff);
  return 1;
}

// mmc_obtain_profile_name
// file libburn/mmc.h line 96
char * mmc_obtain_profile_name(signed int profile_number)
{
  signed int i;
  signed int max_pno = 0x53;
  static char *texts[83l] = { (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
  if(texts[0l] == ((char *)NULL))
  {
    i = 0;
    for( ; !(i >= max_pno); i = i + 1)
      texts[(signed long int)i] = "";
    texts[(signed long int)0x01] = "Non-removable disk";
    texts[(signed long int)0x02] = "Removable disk";
    texts[(signed long int)0x03] = "MO erasable";
    texts[(signed long int)0x04] = "Optical write once";
    texts[(signed long int)0x05] = "AS-MO";
    texts[(signed long int)0x08] = "CD-ROM";
    texts[(signed long int)0x09] = "CD-R";
    texts[(signed long int)0x0a] = "CD-RW";
    texts[(signed long int)0x10] = "DVD-ROM";
    texts[(signed long int)0x11] = "DVD-R sequential recording";
    texts[(signed long int)0x12] = "DVD-RAM";
    texts[(signed long int)0x13] = "DVD-RW restricted overwrite";
    texts[(signed long int)0x14] = "DVD-RW sequential recording";
    texts[(signed long int)0x15] = "DVD-R/DL sequential recording";
    texts[(signed long int)0x16] = "DVD-R/DL layer jump recording";
    texts[(signed long int)0x1a] = "DVD+RW";
    texts[(signed long int)0x1b] = "DVD+R";
    texts[(signed long int)0x2a] = "DVD+RW/DL";
    texts[(signed long int)0x2b] = "DVD+R/DL";
    texts[(signed long int)0x40] = "BD-ROM";
    texts[(signed long int)0x41] = "BD-R sequential recording";
    texts[(signed long int)0x42] = "BD-R random recording";
    texts[(signed long int)0x43] = "BD-RE";
    texts[(signed long int)0x50] = "HD-DVD-ROM";
    texts[(signed long int)0x51] = "HD-DVD-R";
    texts[(signed long int)0x52] = "HD-DVD-RAM";
  }

  if(profile_number >= max_pno || !(profile_number >= 0))
    return "";

  else
    return texts[(signed long int)profile_number];
}

// mmc_perform_opc
// file libburn/mmc.c line 2725
void mmc_perform_opc(struct burn_drive *d)
{
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_perform_opc");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, MMC_SEND_OPC, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
    c->retry = 1;
    c->opcode[(signed long int)1] = (unsigned char)1;
    c->page = (struct buffer *)(void *)0;
    c->dir = 2;
    c->timeout = 200000;
    d->issue_command(d, c);
  }

}

// mmc_read_10
// file libburn/mmc.c line 4700
signed int mmc_read_10(struct burn_drive *d, signed int start, signed int amount, struct buffer *buf)
{
  struct command *c;
  char *msg = (char *)(void *)0;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int silent;
  c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_10");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return -1;

  else
    if(amount >= 33)
      return -1;

    else
    {
      scsi_init_command(c, MMC_READ_10, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
      c->dxfer_len = amount * 2048;
      c->retry = 1;
      mmc_int_to_four_char(c->opcode + (signed long int)2, start);
      c->opcode[(signed long int)7] = (unsigned char)(amount >> 8 & 0xFF);
      c->opcode[(signed long int)8] = (unsigned char)(amount & 0xFF);
      c->page = buf;
      c->page->bytes = 0;
      c->page->sectors = 0;
      c->dir = 1;
      d->issue_command(d, c);
      if(!(c->error == 0))
      {
        void *return_value_calloc$2;
        return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)256);
        msg = (char *)return_value_calloc$2;
        if(!(msg == ((char *)NULL)))
        {
          sprintf(msg, "SCSI error on read_10(%d,%d): ", start, amount);
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(msg);
          scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$3, &key, &asc, &ascq);
          silent = (signed int)(d->silent_on_scsi_error == 1);
          if(asc == 0x64 && ascq == 0x0 && key == 5)
          {
            d->had_particular_error = d->had_particular_error | 1;
            if(d->silent_on_scsi_error == 2)
              silent = 1;

          }

          if(silent == 0)
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020144, d->silent_on_scsi_error == 3 ? 0x10000000 : 0x60000000, 0x30000000, msg, 0, 0);

          free((void *)msg);
        }

        return 1;
      }

      buf->sectors = amount;
      buf->bytes = amount * 2048;
      return 0;
    }
}

// mmc_read_atip
// file libburn/mmc.c line 2268
void mmc_read_atip(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int alloc_len = 28;
  unsigned char *data;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$3;
  if(!(buf == ((struct buffer *)NULL)))
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(!(c == ((struct command *)NULL)))
    {
      mmc_start_if_needed(d, 1);
      return_value_mmc_function_spy$3=mmc_function_spy(d, "mmc_read_atip");
      if(return_value_mmc_function_spy$3 >= 1)
      {
        scsi_init_command(c, MMC_GET_ATIP, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = alloc_len;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->retry = 1;
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
        {
          d->erasable = 0;
          d->start_lba = 0;
          d->end_lba = 0;
        }

        else
        {
          data = c->page->data;
          d->erasable = (signed int)!(!(((signed int)data[(signed long int)6] & 64) != 0));
          d->start_lba=burn_msf_to_lba((signed int)data[(signed long int)8], (signed int)data[(signed long int)9], (signed int)data[(signed long int)10]);
          d->end_lba=burn_msf_to_lba((signed int)data[(signed long int)12], (signed int)data[(signed long int)13], (signed int)data[(signed long int)14]);
          if(d->start_lba >= d->end_lba)
          {
            d->start_lba = 0;
            d->end_lba = 0;
          }

          if(!((4 & (signed int)data[6l]) == 0))
          {
            static signed int speed_value[16l] = { 0, 353, 706, 1059, 1764, -5, 2824, -7, 4234, 5646, 7056, 8468, -12, -13, -14, -15 };
            if(speed_value[(signed long int)((signed int)data[16l] >> 4 & 7)] >= 1)
            {
              d->mdata->min_write_speed = speed_value[(signed long int)((signed int)data[(signed long int)16] >> 4 & 7)];
              if(!(speed_value[(signed long int)(15 & (signed int)data[16l])] >= 1))
                d->mdata->max_write_speed = speed_value[(signed long int)((signed int)data[(signed long int)16] >> 4 & 7)];

            }

            if(speed_value[(signed long int)(15 & (signed int)data[16l])] >= 1)
            {
              d->mdata->max_write_speed = speed_value[(signed long int)((signed int)data[(signed long int)16] & 15)];
              if(!(speed_value[(signed long int)((signed int)data[16l] >> 4 & 7)] >= 1))
                d->mdata->min_write_speed = speed_value[(signed long int)((signed int)data[(signed long int)16] & 15)];

            }

          }

        }
      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// mmc_read_buffer_capacity
// file libburn/mmc.c line 3541
signed int mmc_read_buffer_capacity(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  unsigned char *data;
  signed int alloc_len = 12;
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$3;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      return_value_mmc_function_spy$3=mmc_function_spy(d, "mmc_read_buffer_capacity");
      if(!(return_value_mmc_function_spy$3 >= 1))
        ret = 0;

      else
      {
        scsi_init_command(c, MMC_READ_BUFFER_CAPACITY, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = alloc_len;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->retry = 1;
        c->page = buf;
        memset((void *)c->page->data, 0, (unsigned long int)alloc_len);
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
          ret = 0;

        else
        {
          data = c->page->data;
          d->progress.buffer_capacity = (unsigned int)((signed int)data[(signed long int)4] << 24 | (signed int)data[(signed long int)5] << 16 | (signed int)data[(signed long int)6] << 8 | (signed int)data[(signed long int)7]);
          d->progress.buffer_available = (unsigned int)((signed int)data[(signed long int)8] << 24 | (signed int)data[(signed long int)9] << 16 | (signed int)data[(signed long int)10] << 8 | (signed int)data[(signed long int)11]);
          if(!(d->progress.buffer_capacity >= d->progress.buffer_available))
            d->progress.buffer_available = d->progress.buffer_capacity / (unsigned int)2;

          d->pessimistic_buffer_free = (signed long int)d->progress.buffer_available;
          d->pbf_altered = 0;
          if(d->progress.buffered_bytes >= (signed long int)d->progress.buffer_capacity)
          {
            double fill = (double)(d->progress.buffer_capacity - d->progress.buffer_available);
            if(fill < (double)d->progress.buffer_min_fill)
            {
              if(fill >= 0.000000)
                d->progress.buffer_min_fill = (unsigned int)fill;

            }

          }

          ret = 1;
        }
      }
    }
  }

ex:
  ;
  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_read_capacity
// file libburn/mmc.c line 4830
signed int mmc_read_capacity(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int alloc_len = 8;
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$3;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      d->media_read_capacity = 0x7fffffff;
      mmc_start_if_needed(d, 1);
      return_value_mmc_function_spy$3=mmc_function_spy(d, "mmc_read_capacity");
      if(!(return_value_mmc_function_spy$3 >= 1))
        ret = 0;

      else
      {
        scsi_init_command(c, MMC_READ_CAPACITY, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = alloc_len;
        c->retry = 1;
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        d->media_read_capacity=mmc_four_char_to_int(c->page->data);
        if(!(d->media_read_capacity >= 0))
        {
          d->media_read_capacity = 0x7fffffff;
          ret = 0;
        }

        else
          ret = 1;
      }
    }
  }

ex:
  ;
  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_read_cd
// file libburn/mmc.c line 2582
signed int mmc_read_cd(struct burn_drive *d, signed int start, signed int len, signed int sec_type, signed int main_ch, struct burn_read_opts *o, struct buffer *buf, signed int flag)
{
  signed int temp;
  signed int req;
  signed int ret;
  signed int dap_bit;
  signed int subcodes_audio = 0;
  signed int subcodes_data = 0;
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_cd");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return -1;

  else
  {
    dap_bit = flag & 1;
    if(!(o == ((struct burn_read_opts *)NULL)))
    {
      subcodes_audio = (signed int)o->subcodes_audio;
      subcodes_data = (signed int)o->subcodes_data;
      dap_bit = dap_bit | (signed int)o->dap_bit;
    }

    scsi_init_command(c, MMC_READ_CD, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
    c->retry = 1;
    c->opcode[(signed long int)1] = (unsigned char)((sec_type & 7) << 2 | (signed int)!(!(dap_bit != 0)) << 1);
    temp = start;
    c->opcode[(signed long int)5] = (unsigned char)(temp & 0xFF);
    temp = temp >> 8;
    c->opcode[(signed long int)4] = (unsigned char)(temp & 0xFF);
    temp = temp >> 8;
    c->opcode[(signed long int)3] = (unsigned char)(temp & 0xFF);
    temp = temp >> 8;
    c->opcode[(signed long int)2] = (unsigned char)(temp & 0xFF);
    c->opcode[(signed long int)8] = (unsigned char)(len & 0xFF);
    len = len >> 8;
    c->opcode[(signed long int)7] = (unsigned char)(len & 0xFF);
    len = len >> 8;
    c->opcode[(signed long int)6] = (unsigned char)(len & 0xFF);
    req = main_ch & 0xf8;
    c->opcode[(signed long int)9] = (unsigned char)req;
    c->opcode[(signed long int)10] = (unsigned char)0;
    if((signed int)d->busy == BURN_DRIVE_GRABBING || !(subcodes_audio == 0) || !(subcodes_data == 0))
      c->opcode[(signed long int)10] = (unsigned char)1;

    c->page = buf;
    c->dir = 1;
    d->issue_command(d, c);
    ret=mmc_eval_read_error(d, c, "read_cd", start, -1, -1, len, -1, -1, 0);
    return ret;
  }
}

// mmc_read_cd_msf
// file libburn/mmc.c line 2497
signed int mmc_read_cd_msf(struct burn_drive *d, signed int start_m, signed int start_s, signed int start_f, signed int end_m, signed int end_s, signed int end_f, signed int sec_type, signed int main_ch, struct burn_read_opts *o, struct buffer *buf, signed int flag)
{
  signed int req;
  signed int ret;
  signed int dap_bit;
  signed int subcodes_audio = 0;
  signed int subcodes_data = 0;
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_cd_msf");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return -1;

  else
  {
    dap_bit = flag & 1;
    if(!(o == ((struct burn_read_opts *)NULL)))
    {
      subcodes_audio = (signed int)o->subcodes_audio;
      subcodes_data = (signed int)o->subcodes_data;
      dap_bit = dap_bit | (signed int)o->dap_bit;
    }

    scsi_init_command(c, MMC_READ_CD_MSF, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
    c->retry = 1;
    c->opcode[(signed long int)1] = (unsigned char)((sec_type & 7) << 2 | (signed int)!(!(dap_bit != 0)) << 1);
    c->opcode[(signed long int)3] = (unsigned char)start_m;
    c->opcode[(signed long int)4] = (unsigned char)start_s;
    c->opcode[(signed long int)5] = (unsigned char)start_f;
    c->opcode[(signed long int)6] = (unsigned char)end_m;
    c->opcode[(signed long int)7] = (unsigned char)end_s;
    c->opcode[(signed long int)8] = (unsigned char)end_f;
    req = main_ch & 0xf8;
    c->opcode[(signed long int)9] = (unsigned char)req;
    c->opcode[(signed long int)10] = (unsigned char)0;
    if((signed int)d->busy == BURN_DRIVE_GRABBING || !(subcodes_audio == 0) || !(subcodes_data == 0))
      c->opcode[(signed long int)10] = (unsigned char)1;

    c->page = buf;
    c->dir = 1;
    d->issue_command(d, c);
    ret=mmc_eval_read_error(d, c, "read_cd_msf", start_m, start_s, start_f, end_m, end_s, end_f, 0);
    return ret;
  }
}

// mmc_read_disc_info
// file libburn/mmc.c line 2177
void mmc_read_disc_info(struct burn_drive *d)
{
  signed int alloc_len = 34;
  signed int ret;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_disc_info");
  if(return_value_mmc_function_spy$1 >= 1)
    ret=mmc_read_disc_info_al(d, &alloc_len);

}

// mmc_read_disc_info_al
// file libburn/mmc.c line 1885
static signed int mmc_read_disc_info_al(struct burn_drive *d, signed int *alloc_len)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  unsigned char *data;
  struct command *c = (struct command *)(void *)0;
  char *msg = (char *)(void *)0;
  signed int do_read_toc = 0;
  signed int disc_status;
  signed int len;
  signed int old_alloc_len;
  signed int ret;
  signed int number_of_sessions = -1;
  signed int key;
  signed int asc;
  signed int ascq;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_four_char_to_int$3;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      d->end_lba = -2000000000;
      d->start_lba = d->end_lba;
      d->erasable = 0;
      d->last_track_no = 1;
      d->sent_default_page_05 = 0;
      d->media_capacity_remaining = (signed long int)0;
      d->media_lba_limit = 0;
      d->media_read_capacity = 0x7fffffff;
      d->toc_entries = 0;
      if((signed int)d->status == BURN_DISC_EMPTY)
        ret = 1;

      else
      {
        mmc_get_configuration(d);
        scsi_init_command(c, MMC_GET_DISC_INFO, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = *alloc_len;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->retry = 1;
        c->page = buf;
        c->page->sectors = 0;
        c->page->bytes = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
        {
          spc_decode_sense(c->sense, 0, &key, &asc, &ascq);
          if(asc == 0x20 && ascq == 0 && key == 5)
          {
            ret=mmc_read_toc_fmt0(d);
            if(ret >= 1)
            {
              mmc_read_capacity(d);
              *alloc_len = 0;
            }

          }

          d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
          ret = 0;
        }

        else
        {
          data = c->page->data;
          len = (signed int)data[(signed long int)0] << 8 | (signed int)data[(signed long int)1];
          old_alloc_len = *alloc_len;
          *alloc_len = len + 2;
          if(!(old_alloc_len >= 34))
            ret = 1;

          else
            if(!(*alloc_len >= 24))
              ret = 0;

            else
            {
              if(!(old_alloc_len >= 2 + len))
                len = old_alloc_len - 2;

              d->erasable = (signed int)!(!(((signed int)data[(signed long int)2] & 16) != 0));
              d->disc_type = (signed int)data[(signed long int)8];
              d->disc_info_valid = 1;
              return_value_mmc_four_char_to_int$3=mmc_four_char_to_int(data + (signed long int)12);
              d->disc_id = (unsigned int)return_value_mmc_four_char_to_int$3;
              d->disc_info_valid = d->disc_info_valid | (signed int)!(!(((signed int)data[(signed long int)7] & 128) != 0)) << 1;
              if(2 + len >= 32)
              {
                if(!((64 & (signed int)data[7l]) == 0))
                {
                  memcpy((void *)d->disc_bar_code, (const void *)(data + (signed long int)24), (unsigned long int)8);
                  d->disc_bar_code[(signed long int)8] = (char)0;
                  d->disc_info_valid = d->disc_info_valid | 4;
                }

              }

              if(2 + len >= 33)
              {
                if(!((16 & (signed int)data[7l]) == 0))
                {
                  d->disc_app_code = (signed int)data[(signed long int)32];
                  d->disc_info_valid = d->disc_info_valid | 8;
                }

              }

              if(!((32 & (signed int)data[7l]) == 0))
                d->disc_info_valid = d->disc_info_valid | 16;

              if(!((16 & (signed int)data[2l]) == 0))
                d->disc_info_valid = d->disc_info_valid | 32;

              disc_status = (signed int)data[(signed long int)2] & 3;
              d->state_of_last_session = (signed int)data[(signed long int)2] >> 2 & 3;
              number_of_sessions = (signed int)data[(signed long int)9] << 8 | (signed int)data[(signed long int)4];
              _Bool tmp_if_expr$4;
              if(d->current_profile == 0x10)
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = d->current_profile == 0x40 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4)
              {
                disc_status = 2;
                d->erasable = 0;
              }

              if(d->current_profile == 0x42)
              {
                disc_status = 2;
                d->erasable = 0;
              }

              _Bool tmp_if_expr$5;
              if(d->current_profile == 0x08)
                tmp_if_expr$5 = (_Bool)1;

              else
                tmp_if_expr$5 = d->current_profile == 0x09 ? (_Bool)1 : (_Bool)0;
              _Bool tmp_if_expr$6;
              if(tmp_if_expr$5)
                tmp_if_expr$6 = (_Bool)1;

              else
                tmp_if_expr$6 = d->current_profile == 0x0a ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$6)
              {
                d->last_lead_in=burn_msf_to_lba((signed int)data[(signed long int)17], (signed int)data[(signed long int)18], (signed int)data[(signed long int)19]);
                d->last_lead_out=burn_msf_to_lba((signed int)data[(signed long int)21], (signed int)data[(signed long int)22], (signed int)data[(signed long int)23]);
              }

              else
              {
                d->last_lead_in=mmc_four_char_to_int(data + (signed long int)16);
                d->last_lead_out=mmc_four_char_to_int(data + (signed long int)20);
              }
              if(disc_status == 0)
              {

              regard_as_blank:
                ;
                d->toc_entries = 0;
                d->status = (enum burn_disc_status)BURN_DISC_BLANK;
                d->start_lba = d->last_lead_in;
                d->end_lba = d->last_lead_out;
                d->status = (enum burn_disc_status)BURN_DISC_APPENDABLE;
                if(disc_status == 2)
                  d->status = (enum burn_disc_status)BURN_DISC_FULL;

                ret=mmc_read_capacity(d);
                if(d->current_profile == 0x41)
                {
                  if((signed int)d->status == BURN_DISC_APPENDABLE)
                  {
                    if(d->state_of_last_session == 1)
                      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020169, 0x50000000, 0x30000000, "Last session on media is still open.", 0, 0);

                  }

                }

                do_read_toc = 1;
                mmc_read_capacity(d);
              }

              if(!(d->current_is_guessed_profile == 0))
              {
                if(d->current_profile == 0)
                  mmc_guess_profile(d, 0);

              }

              _Bool tmp_if_expr$9;
              if(!(d->current_profile == 0))
                tmp_if_expr$9 = (_Bool)1;

              else
                tmp_if_expr$9 = (signed int)d->status != BURN_DISC_UNREADY ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$9)
              {
                _Bool tmp_if_expr$8;
                if(d->silent_on_scsi_error == 1)
                  tmp_if_expr$8 = (_Bool)1;

                else
                  tmp_if_expr$8 = d->silent_on_scsi_error == 2 ? (_Bool)1 : (_Bool)0;
                if(!tmp_if_expr$8)
                {
                  void *return_value_calloc$7;
                  return_value_calloc$7=calloc((unsigned long int)1, (unsigned long int)160);
                  msg = (char *)return_value_calloc$7;
                  if(!(msg == ((char *)NULL)))
                  {
                    sprintf(msg, "Unsuitable media detected. Profile %4.4Xh  %s", d->current_profile, (const void *)d->current_profile_text);
                    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011e, d->silent_on_scsi_error == 3 ? 0x10000000 : 0x60000000, 0x30000000, msg, 0, 0);
                    free((void *)msg);
                  }

                }

                d->status = (enum burn_disc_status)BURN_DISC_UNSUITABLE;
                ret = 0;
              }

              else
              {
                d->num_opc_tables = 0;
                if(((signed int)*data << 8 | (signed int)data[1l]) >= 33)
                  d->num_opc_tables = (signed int)data[(signed long int)33];

                d->bg_format_status = (signed int)data[(signed long int)7] & 3;
                _Bool tmp_if_expr$10;
                if(d->current_profile == 0x1a)
                  tmp_if_expr$10 = (_Bool)1;

                else
                  tmp_if_expr$10 = d->current_profile == 0x13 ? (_Bool)1 : (_Bool)0;
                _Bool tmp_if_expr$11;
                if(tmp_if_expr$10)
                  tmp_if_expr$11 = (_Bool)1;

                else
                  tmp_if_expr$11 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
                _Bool tmp_if_expr$12;
                if(tmp_if_expr$11)
                  tmp_if_expr$12 = (_Bool)1;

                else
                  tmp_if_expr$12 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$12)
                  d->status = (enum burn_disc_status)BURN_DISC_BLANK;

                d->incomplete_sessions = 0;
                if((signed int)d->status == BURN_DISC_BLANK)
                {
                  d->last_track_no = 1;
                  d->complete_sessions = 0;
                }

                else
                {
                  d->complete_sessions = number_of_sessions;
                  if(!(d->state_of_last_session == 3))
                  {
                    if(d->complete_sessions >= 1)
                    {
                      d->complete_sessions = d->complete_sessions - 1;
                      d->incomplete_sessions = d->incomplete_sessions + 1;
                    }

                  }

                  d->last_track_no = (signed int)data[(signed long int)11] << 8 | (signed int)data[(signed long int)6];
                }
                if(!(d->current_profile == 0x0a))
                {
                  if(!(d->current_profile == 0x13))
                  {
                    if(!(d->current_profile == 0x14))
                    {
                      if(!((signed int)d->status == BURN_DISC_FULL))
                        d->erasable = 0;

                    }

                  }

                }

                if(!(do_read_toc == 0))
                  mmc_read_toc(d);

                ret = 1;
              }
            }
        }
      }
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// mmc_read_disc_structure
// file libburn/mmc.c line 4928
signed int mmc_read_disc_structure(struct burn_drive *d, signed int media_type, signed int layer_number, signed int format, signed int min_len, char **reply, signed int *reply_len, signed int flag)
{
  signed int alloc_len = 4;
  signed int ret;
  char msg[80l];
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_disc_structure");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    ret=mmc_read_disc_structure_al(d, &alloc_len, media_type, layer_number, format, min_len, reply, reply_len, 0);
    if(!(ret >= 1))
      return ret;

    else
    {
      if(!(alloc_len >= 12))
      {
        sprintf(msg, "READ DISC STRUCTURE announces only %d bytes of reply\n", alloc_len);
        libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
        ret = 0;
      }

      else
        ret=mmc_read_disc_structure_al(d, &alloc_len, media_type, layer_number, format, min_len, reply, reply_len, 0);
      return ret;
    }
  }
}

// mmc_read_disc_structure_al
// file libburn/mmc.c line 4867
static signed int mmc_read_disc_structure_al(struct burn_drive *d, signed int *alloc_len, signed int media_type, signed int layer_number, signed int format, signed int min_len, char **reply, signed int *reply_len, signed int flag)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  signed int old_alloc_len;
  signed int len;
  signed int ret;
  struct command *c = (struct command *)(void *)0;
  unsigned char *dpt;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  void *return_value_calloc$3;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      *reply = (char *)(void *)0;
      *reply_len = 0;
      if(!(*alloc_len >= 4))
        ret = 0;

      else
      {
        scsi_init_command(c, MMC_READ_DISC_STRUCTURE, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
        c->dxfer_len = *alloc_len;
        c->retry = 1;
        c->opcode[(signed long int)1] = (unsigned char)media_type;
        c->opcode[(signed long int)7] = (unsigned char)format;
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)9] = (unsigned char)(c->dxfer_len & 0xff);
        c->page = buf;
        c->page->sectors = 0;
        c->page->bytes = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
          ret = 0;

        else
        {
          len = (signed int)c->page->data[(signed long int)0] << 8 | (signed int)c->page->data[(signed long int)1];
          old_alloc_len = *alloc_len;
          *alloc_len = len + 2;
          if(!(old_alloc_len >= 5))
            ret = 1;

          else
          {
            if(!(old_alloc_len >= 2 + len))
              len = old_alloc_len - 2;

            if(!(len >= 4))
              ret = 0;

            else
            {
              dpt = c->page->data + (signed long int)4;
              if(!(len + -2 >= min_len))
                ret = 0;

              else
              {
                return_value_calloc$3=calloc((unsigned long int)(len - 2), (unsigned long int)1);
                *reply = (char *)return_value_calloc$3;
                if(*reply == ((char *)NULL))
                  ret = 0;

                else
                {
                  *reply_len = len - 2;
                  memcpy((void *)*reply, (const void *)dpt, (unsigned long int)(len - 2));
                  ret = 1;
                }
              }
            }
          }
        }
      }
    }
  }

ex:
  ;
  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_read_format_capacities
// file libburn/mmc.c line 3458
signed int mmc_read_format_capacities(struct burn_drive *d, signed int top_wanted)
{
  signed int alloc_len = 4;
  signed int ret;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_format_capacities");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    ret=mmc_read_format_capacities_al(d, &alloc_len, top_wanted);
    if(alloc_len >= 12 && ret >= 1)
      ret=mmc_read_format_capacities_al(d, &alloc_len, top_wanted);

    return ret;
  }
}

// mmc_read_format_capacities_al
// file libburn/mmc.c line 3308
static signed int mmc_read_format_capacities_al(struct burn_drive *d, signed int *alloc_len, signed int top_wanted)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  signed int len;
  signed int type;
  signed int score;
  signed int num_descr;
  signed int max_score = -2000000000;
  signed int i;
  signed int sign = 1;
  signed int old_alloc_len;
  signed int ret;
  signed long int size;
  signed long int num_blocks;
  struct command *c = (struct command *)(void *)0;
  unsigned char *dpt;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
      if(!(*alloc_len >= 4))
        ret = 0;

      else
      {
        d->format_descr_type = 3;
        d->format_curr_max_size = (signed long int)0;
        d->format_curr_blsas = (unsigned int)0;
        d->best_format_type = -1;
        d->best_format_size = (signed long int)0;
        scsi_init_command(c, MMC_READ_FORMAT_CAPACITIES, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = *alloc_len;
        c->retry = 1;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->page = buf;
        c->page->sectors = 0;
        c->page->bytes = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
          ret = 0;

        else
        {
          len = (signed int)c->page->data[(signed long int)3];
          old_alloc_len = *alloc_len;
          *alloc_len = len + 4;
          if(!(old_alloc_len >= 12))
            ret = 1;

          else
          {
            if(!(old_alloc_len >= 4 + len))
              len = old_alloc_len - 4;

            if(!(len >= 8))
              ret = 0;

            else
            {
              dpt = c->page->data + (signed long int)4;
              d->format_descr_type = (signed int)dpt[(signed long int)4] & 3;
              d->format_curr_max_size = ((signed long int)dpt[(signed long int)0] << 24) + (signed long int)((signed int)dpt[(signed long int)1] << 16) + (signed long int)((signed int)dpt[(signed long int)2] << 8) + (signed long int)dpt[(signed long int)3];
              if(d->format_descr_type == 3)
                d->format_curr_max_size = (signed long int)0;

              d->format_curr_blsas = (unsigned int)(((signed int)dpt[(signed long int)5] << 16) + ((signed int)dpt[(signed long int)6] << 8) + (signed int)dpt[(signed long int)7]);
              d->format_curr_max_size = d->format_curr_max_size * (signed long int)2048;
              _Bool tmp_if_expr$3;
              if(d->current_profile == 0x12)
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$3)
              {
                if(d->media_capacity_remaining == 0l)
                {
                  burn_drive_set_media_capacity_remaining(d, d->format_curr_max_size);
                  d->media_lba_limit = (signed int)(d->format_curr_max_size / (signed long int)2048);
                }

              }

              if(top_wanted == 0x00 || top_wanted == 0x10)
                sign = -1;

              num_descr = (len - 8) / 8;
              i = 0;
              if(!(i >= num_descr))
              {
                dpt = c->page->data + (signed long int)12 + (signed long int)(8 * i);
                signed int return_value_mmc_four_char_to_int$4;
                return_value_mmc_four_char_to_int$4=mmc_four_char_to_int(dpt);
                num_blocks = (signed long int)return_value_mmc_four_char_to_int$4;
                size = num_blocks * (signed long int)2048;
                type = (signed int)dpt[(signed long int)4] >> 2;
                if(!(i >= 32))
                {
                  d->format_descriptors[(signed long int)i].type = type;
                  d->format_descriptors[(signed long int)i].size = size;
                  d->format_descriptors[(signed long int)i].tdp = (unsigned int)(((signed int)dpt[(signed long int)5] << 16) + ((signed int)dpt[(signed long int)6] << 8) + (signed int)dpt[(signed long int)7]);
                  d->num_format_descr = i + 1;
                }

                if(type == 0x00)
                  score = 1 * sign;

                else
                  if(type == 0x10)
                    score = 10 * sign;

                  else
                    if(type == 0x13)
                      score = 100 * sign;

                    else
                      if(type == 0x15)
                      {
                        score = 50 * sign;
                        if(d->current_profile == 0x13)
                        {
                          burn_drive_set_media_capacity_remaining(d, size);
                          d->media_lba_limit = (signed int)num_blocks;
                        }

                      }

                      else
                        if(type == 0x26)
                        {
                          score = 1 * sign;
                          burn_drive_set_media_capacity_remaining(d, size);
                          d->media_lba_limit = (signed int)num_blocks;
                        }

                if(type == top_wanted)
                  score = score + 1000000000;

                if(!(max_score >= score))
                {
                  d->best_format_type = type;
                  d->best_format_size = size;
                  max_score = score;
                }

                i = i + 1;
              }

              ret = 1;
            }
          }
        }
      }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// mmc_read_lead_in
// file libburn/mmc.c line 2700
void mmc_read_lead_in(struct burn_drive *d, struct buffer *buf)
{
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_lead_in");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, MMC_READ_CD, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
    c->retry = 1;
    c->opcode[(signed long int)5] = (unsigned char)0;
    c->opcode[(signed long int)4] = (unsigned char)0;
    c->opcode[(signed long int)3] = (unsigned char)0;
    c->opcode[(signed long int)2] = (unsigned char)0xF0;
    c->opcode[(signed long int)8] = (unsigned char)1;
    c->opcode[(signed long int)7] = (unsigned char)0;
    c->opcode[(signed long int)6] = (unsigned char)0;
    c->opcode[(signed long int)9] = (unsigned char)0;
    c->opcode[(signed long int)10] = (unsigned char)2;
    c->page = buf;
    c->dir = 1;
    d->issue_command(d, c);
  }

}

// mmc_read_multi_session_c1
// file libburn/mmc.c line 1739
signed int mmc_read_multi_session_c1(struct burn_drive *d, signed int *trackno, signed int *start)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  unsigned char *tdata;
  signed int num_sessions;
  signed int session_no;
  signed int num_tracks;
  signed int alloc_len = 12;
  signed int ret;
  struct burn_disc *disc;
  struct burn_session **sessions;
  struct burn_track **tracks;
  struct burn_toc_entry toc_entry;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$3;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      mmc_start_if_needed(d, 1);
      return_value_mmc_function_spy$3=mmc_function_spy(d, "mmc_read_multi_session_c1");
      if(!(return_value_mmc_function_spy$3 >= 1))
        ret = 0;

      else
      {
        *trackno = 0;
        disc=burn_drive_get_disc(d);
        if(!(disc == ((struct burn_disc *)NULL)))
        {
          sessions=burn_disc_get_sessions(disc, &num_sessions);
          session_no = 0;
          for( ; !(session_no >= num_sessions); session_no = session_no + 1)
          {
            tracks=burn_session_get_tracks(sessions[(signed long int)session_no], &num_tracks);
            if(!(tracks == ((struct burn_track **)NULL)) && num_tracks >= 1)
            {
              burn_track_get_entry(tracks[(signed long int)0], &toc_entry);
              if(!((1 & (signed int)toc_entry.extensions_valid) == 0))
              {
                *start = toc_entry.start_lba;
                *trackno = (signed int)toc_entry.point_msb << 8 | (signed int)toc_entry.point;
              }

              else
              {
                *start=burn_msf_to_lba((signed int)toc_entry.pmin, (signed int)toc_entry.psec, (signed int)toc_entry.pframe);
                *trackno = (signed int)toc_entry.point;
              }
            }

          }
          burn_disc_free(disc);
          if(!(*trackno >= 1))
            goto inquire_drive;

          ret = 1;
        }

        else
        {

        inquire_drive:
          ;
          scsi_init_command(c, MMC_GET_MSINFO, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
          c->dxfer_len = alloc_len;
          c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
          c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
          c->retry = 1;
          c->page = buf;
          c->page->bytes = 0;
          c->page->sectors = 0;
          c->dir = 1;
          d->issue_command(d, c);
          if(!(c->error == 0))
            ret = 0;

          else
          {
            tdata = c->page->data + (signed long int)4;
            *trackno = (signed int)tdata[(signed long int)2];
            *start=mmc_four_char_to_int(tdata + (signed long int)4);
            ret = 1;
          }
        }
      }
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// mmc_read_toc
// file libburn/mmc.c line 1713
void mmc_read_toc(struct burn_drive *d)
{
  signed int alloc_len = 4;
  signed int ret;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_toc");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    ret=mmc_read_toc_al(d, &alloc_len);
    if(alloc_len >= 15)
      ret=mmc_read_toc_al(d, &alloc_len);

  }

}

// mmc_read_toc_al
// file libburn/mmc.c line 1488
static signed int mmc_read_toc_al(struct burn_drive *d, signed int *alloc_len)
{
  struct burn_track *track;
  struct burn_session *session;
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int dlen;
  signed int i;
  signed int old_alloc_len;
  signed int t_idx;
  signed int ret;
  unsigned char *tdata;
  char *msg = (char *)(void *)0;
  void *return_value_calloc$8;
  if(!(*alloc_len >= 4))
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$1;
    if(buf == ((struct buffer *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$2;
      return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$2;
      if(c == ((struct command *)NULL))
        ret = -1;

      else
      {
        void *return_value_burn_alloc_mem$3;
        return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)321, 0);
        msg = (char *)return_value_burn_alloc_mem$3;
        if(msg == ((char *)NULL))
          ret = -1;

        else
        {
          _Bool tmp_if_expr$4;
          if(d->current_profile == -1)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = d->current_is_cd_profile != 0 ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$4)
          {
            mmc_fake_toc(d);
            if((signed int)d->status == BURN_DISC_UNREADY)
              d->status = (enum burn_disc_status)BURN_DISC_FULL;

            ret = 1;
          }

          else
          {
            _Bool tmp_if_expr$5;
            if(d->mdata->p2a_valid >= 1)
              tmp_if_expr$5 = d->mdata->cdrw_write != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$5 = (_Bool)0;
            _Bool tmp_if_expr$6;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = d->current_profile != 0x08 ? (_Bool)1 : (_Bool)0;
            if(!tmp_if_expr$6)
              ret=mmc_read_toc_fmt0(d);

            else
            {
              scsi_init_command(c, MMC_GET_TOC, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
              c->dxfer_len = *alloc_len;
              c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
              c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
              c->retry = 1;
              c->page = buf;
              c->page->bytes = 0;
              c->page->sectors = 0;
              c->dir = 1;
              d->issue_command(d, c);
              if(!(c->error == 0))
              {
                libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002010d, 0x10000000, 0x30000000, "Could not inquire TOC", 0, 0);
                d->status = (enum burn_disc_status)BURN_DISC_UNSUITABLE;
                d->toc_entries = 0;
                void *return_value_calloc$7;
                return_value_calloc$7=calloc((unsigned long int)1, sizeof(struct burn_toc_entry) /*32ul*/ );
                d->toc_entry = (struct burn_toc_entry *)return_value_calloc$7;
                ret = 0;
              }

              dlen = (signed int)c->page->data[(signed long int)0] * 256 + (signed int)c->page->data[(signed long int)1];
              old_alloc_len = *alloc_len;
              *alloc_len = dlen + 2;
              if(!(old_alloc_len >= 15))
                ret = 1;

              else
              {
                if(!(old_alloc_len >= 2 + dlen))
                  dlen = old_alloc_len - 2;

                d->toc_entries = (dlen - 2) / 11;
                if(!(d->toc_entries >= 1))
                  ret = 0;

                else
                {
                  return_value_calloc$8=calloc((unsigned long int)(d->toc_entries + (signed int)(unsigned char)c->page->data[(signed long int)3]), sizeof(struct burn_toc_entry) /*32ul*/ );
                  d->toc_entry = (struct burn_toc_entry *)return_value_calloc$8;
                  if(d->toc_entry == ((struct burn_toc_entry *)NULL))
                    ret = 0;

                  else
                  {
                    tdata = c->page->data + (signed long int)4;
                    d->disc=burn_disc_create();
                    if(d->disc == ((struct burn_disc *)NULL))
                      ret = 0;

                    else
                    {
                      i = 0;
                      if(!(i >= (signed int)c->page->data[3l]))
                      {
                        session=burn_session_create();
                        if(session == ((struct burn_session *)NULL))
                          ret = 0;

                        burn_disc_add_session(d->disc, session, (unsigned int)100);
                        burn_session_free(session);
                        i = i + 1;
                      }

                      i = 0;
                      if(!(i >= d->toc_entries))
                      {
                        _Bool tmp_if_expr$9;
                        if(!((signed int)*tdata >= 1))
                          tmp_if_expr$9 = (_Bool)1;

                        else
                          tmp_if_expr$9 = (signed int)tdata[(signed long int)0] > d->disc->sessions ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr$9)
                          tdata[(signed long int)0] = (unsigned char)d->disc->sessions;

                        if(!((signed int)tdata[3l] >= 100))
                        {
                          if((signed int)*tdata >= 1)
                          {
                            track=burn_track_create();
                            burn_session_add_track(d->disc->session[(signed long int)((signed int)tdata[(signed long int)0] - 1)], track, (unsigned int)100);
                            track->entry = &d->toc_entry[(signed long int)i];
                            burn_track_free(track);
                          }

                        }

                        (d->toc_entry + (signed long int)i)->session = tdata[(signed long int)0];
                        (d->toc_entry + (signed long int)i)->adr = (unsigned char)((signed int)tdata[(signed long int)1] >> 4);
                        (d->toc_entry + (signed long int)i)->control = (unsigned char)((signed int)tdata[(signed long int)1] & 0xF);
                        (d->toc_entry + (signed long int)i)->tno = tdata[(signed long int)2];
                        (d->toc_entry + (signed long int)i)->point = tdata[(signed long int)3];
                        (d->toc_entry + (signed long int)i)->min = tdata[(signed long int)4];
                        (d->toc_entry + (signed long int)i)->sec = tdata[(signed long int)5];
                        (d->toc_entry + (signed long int)i)->frame = tdata[(signed long int)6];
                        (d->toc_entry + (signed long int)i)->zero = tdata[(signed long int)7];
                        (d->toc_entry + (signed long int)i)->pmin = tdata[(signed long int)8];
                        (d->toc_entry + (signed long int)i)->psec = tdata[(signed long int)9];
                        (d->toc_entry + (signed long int)i)->pframe = tdata[(signed long int)10];
                        if((signed int)tdata[3l] == 0xA0)
                          d->disc->session[(signed long int)((signed int)tdata[(signed long int)0] - 1)]->firsttrack = tdata[(signed long int)8];

                        if((signed int)tdata[3l] == 0xA1)
                          d->disc->session[(signed long int)((signed int)tdata[(signed long int)0] - 1)]->lasttrack = tdata[(signed long int)8];

                        if((signed int)tdata[3l] == 0xA2)
                          d->disc->session[(signed long int)((signed int)tdata[(signed long int)0] - 1)]->leadout_entry = &d->toc_entry[(signed long int)i];

                        i = i + 1;
                        tdata = tdata + (signed long int)11;
                      }

                      if((signed int)d->status == BURN_DISC_UNREADY)
                        d->status = (enum burn_disc_status)BURN_DISC_FULL;

                      toc_find_modes(d);
                      i = 0;
                      if(!(i >= d->disc->sessions))
                      {
                        if(d->disc->session[(signed long int)i]->leadout_entry == ((struct burn_toc_entry *)NULL))
                        {
                          sprintf(msg, "Session %d of %d encountered without leadout", i + 1, d->disc->sessions);
                          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020160, 0x50000000, 0x30000000, msg, 0, 0);
                          _Bool tmp_if_expr$11;
                          if(!(d->disc->session[(signed long int)i]->track == ((struct burn_track **)NULL)))
                            tmp_if_expr$11 = d->disc->session[(signed long int)i]->tracks > 0 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$11 = (_Bool)0;
                          if(tmp_if_expr$11)
                          {
                            signed int tmp_post$10 = d->toc_entries;
                            d->toc_entries = d->toc_entries + 1;
                            t_idx = tmp_post$10;
                            memcpy((void *)(d->toc_entry + (signed long int)t_idx), (const void *)d->disc->session[(signed long int)i]->track[(signed long int)(d->disc->session[(signed long int)i]->tracks - 1)]->entry, sizeof(struct burn_toc_entry) /*32ul*/ );
                            (d->toc_entry + (signed long int)t_idx)->point = (unsigned char)0xA2;
                            d->disc->session[(signed long int)i]->leadout_entry = d->toc_entry + (signed long int)t_idx;
                          }

                          else
                          {
                            burn_disc_remove_session(d->disc, d->disc->session[(signed long int)i]);
                            sprintf(msg, "Empty session %d deleted. Now %d sessions.", i + 1, d->disc->sessions);
                            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020161, 0x50000000, 0x30000000, msg, 0, 0);
                            i = i - 1;
                          }
                        }

                        i = i + 1;
                      }

                      burn_disc_cd_toc_extensions(d, 0);
                      ret = 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_read_toc_fmt0
// file libburn/mmc.c line 1273
static signed int mmc_read_toc_fmt0(struct burn_drive *d)
{
  signed int alloc_len = 4;
  signed int ret;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_toc_fmt0");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return -1;

  else
  {
    ret=mmc_read_toc_fmt0_al(d, &alloc_len);
    if(alloc_len >= 12)
      ret=mmc_read_toc_fmt0_al(d, &alloc_len);

    return ret;
  }
}

// mmc_read_toc_fmt0_al
// file libburn/mmc.c line 1123
static signed int mmc_read_toc_fmt0_al(struct burn_drive *d, signed int *alloc_len)
{
  struct burn_track *track;
  struct burn_session *session;
  struct burn_toc_entry *entry;
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int dlen;
  signed int i;
  signed int old_alloc_len;
  signed int session_number;
  signed int prev_session = -1;
  signed int ret;
  signed int lba;
  signed int size;
  unsigned char *tdata;
  unsigned char size_data[4l];
  unsigned char start_data[4l];
  unsigned char end_data[4l];
  void *return_value_calloc$4;
  if(!(*alloc_len >= 4))
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$1;
    if(buf == ((struct buffer *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$2;
      return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$2;
      if(c == ((struct command *)NULL))
        ret = -1;

      else
      {
        scsi_init_command(c, MMC_GET_TOC_FMT0, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = *alloc_len;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->retry = 1;
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        if(!(c->error == 0))
        {

        err_ex:
          ;
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002010d, 0x10000000, 0x30000000, "Could not inquire TOC", 0, 0);
          d->status = (enum burn_disc_status)BURN_DISC_UNSUITABLE;
          d->toc_entries = 0;
          void *return_value_calloc$3;
          return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct burn_toc_entry) /*32ul*/ );
          d->toc_entry = (struct burn_toc_entry *)return_value_calloc$3;
          ret = 0;
        }

        dlen = (signed int)c->page->data[(signed long int)0] * 256 + (signed int)c->page->data[(signed long int)1];
        old_alloc_len = *alloc_len;
        *alloc_len = dlen + 2;
        if(!(old_alloc_len >= 12))
          ret = 1;

        else
        {
          if(!(old_alloc_len >= 2 + dlen))
            dlen = old_alloc_len - 2;

          d->complete_sessions = (1 + (signed int)c->page->data[(signed long int)3]) - (signed int)c->page->data[(signed long int)2];
          d->incomplete_sessions = 0;
          d->last_track_no = d->complete_sessions;
          if(!(dlen + -2 >= (1 + d->last_track_no) * 8))
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020159, 0x10000000, 0x30000000, "TOC Format 0 returns inconsistent data", 0, 0);

          d->toc_entries = d->last_track_no + d->complete_sessions;
          if(!(d->toc_entries >= 1))
            ret = 0;

          else
          {
            return_value_calloc$4=calloc((unsigned long int)d->toc_entries, sizeof(struct burn_toc_entry) /*32ul*/ );
            d->toc_entry = (struct burn_toc_entry *)return_value_calloc$4;
            if(d->toc_entry == ((struct burn_toc_entry *)NULL))
              ret = 0;

            else
            {
              d->disc=burn_disc_create();
              if(d->disc == ((struct burn_disc *)NULL))
                ret = 0;

              else
              {
                i = 0;
                if(!(i >= d->complete_sessions))
                {
                  session=burn_session_create();
                  if(session == ((struct burn_session *)NULL))
                    ret = 0;

                  burn_disc_add_session(d->disc, session, (unsigned int)100);
                  burn_session_free(session);
                  i = i + 1;
                }

                i = 0;
                if(!(i >= d->last_track_no))
                {
                  tdata = c->page->data + (signed long int)4 + (signed long int)(i * 8);
                  session_number = i + 1;
                  if(prev_session >= 1 && !(session_number == prev_session))
                  {
                    entry = &d->toc_entry[(signed long int)((i - 1) + prev_session)];
                    signed int return_value_mmc_four_char_to_int$5;
                    return_value_mmc_four_char_to_int$5=mmc_four_char_to_int(start_data);
                    signed int return_value_mmc_four_char_to_int$6;
                    return_value_mmc_four_char_to_int$6=mmc_four_char_to_int(size_data);
                    lba = return_value_mmc_four_char_to_int$5 + return_value_mmc_four_char_to_int$6;
                    mmc_int_to_four_char(start_data, lba);
                    mmc_int_to_four_char(size_data, 0);
                    mmc_int_to_four_char(end_data, lba - 1);
                    mmc_fake_toc_entry(entry, prev_session, 0xA2, size_data, start_data, end_data);
                    entry->frame = (unsigned char)0;
                    entry->sec = entry->frame;
                    entry->min = entry->sec;
                    d->disc->session[(signed long int)(prev_session - 1)]->leadout_entry = entry;
                  }

                  entry = &d->toc_entry[(signed long int)((i + session_number) - 1)];
                  track=burn_track_create();
                  if(track == ((struct burn_track *)NULL))
                    ret = -1;

                  burn_session_add_track(d->disc->session[(signed long int)(session_number - 1)], track, (unsigned int)100);
                  track->entry = entry;
                  burn_track_free(track);
                  memcpy((void *)start_data, (const void *)(tdata + (signed long int)4), (unsigned long int)4);
                  memcpy((void *)size_data, (const void *)(tdata + (signed long int)8 + (signed long int)4), (unsigned long int)4);
                  signed int return_value_mmc_four_char_to_int$7;
                  return_value_mmc_four_char_to_int$7=mmc_four_char_to_int(size_data);
                  mmc_int_to_four_char(end_data, return_value_mmc_four_char_to_int$7 - 1);
                  signed int return_value_mmc_four_char_to_int$8;
                  return_value_mmc_four_char_to_int$8=mmc_four_char_to_int(size_data);
                  signed int return_value_mmc_four_char_to_int$9;
                  return_value_mmc_four_char_to_int$9=mmc_four_char_to_int(start_data);
                  size = return_value_mmc_four_char_to_int$8 - return_value_mmc_four_char_to_int$9;
                  mmc_int_to_four_char(size_data, size);
                  mmc_fake_toc_entry(entry, session_number, i + 1, size_data, start_data, end_data);
                  if(!(prev_session == session_number))
                    d->disc->session[(signed long int)(session_number - 1)]->firsttrack = (unsigned char)(i + 1);

                  d->disc->session[(signed long int)(session_number - 1)]->lasttrack = (unsigned char)(i + 1);
                  prev_session = session_number;
                  i = i + 1;
                }

                if(prev_session >= 1)
                {
                  if(d->disc->sessions >= prev_session)
                  {
                    tdata = c->page->data + (signed long int)4 + (signed long int)(d->last_track_no * 8);
                    entry = &d->toc_entry[(signed long int)((d->last_track_no - 1) + prev_session)];
                    memcpy((void *)start_data, (const void *)(tdata + (signed long int)4), (unsigned long int)4);
                    mmc_int_to_four_char(size_data, 0);
                    signed int return_value_mmc_four_char_to_int$10;
                    return_value_mmc_four_char_to_int$10=mmc_four_char_to_int(start_data);
                    mmc_int_to_four_char(end_data, return_value_mmc_four_char_to_int$10 - 1);
                    mmc_fake_toc_entry(entry, prev_session, 0xA2, size_data, start_data, end_data);
                    entry->frame = (unsigned char)0;
                    entry->sec = entry->frame;
                    entry->min = entry->sec;
                    d->disc->session[(signed long int)(prev_session - 1)]->leadout_entry = entry;
                  }

                }

                ret = 1;
              }
            }
          }
        }
      }
    }
  }

ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// mmc_read_track_info
// file libburn/mmc.c line 405
signed int mmc_read_track_info(struct burn_drive *d, signed int trackno, struct buffer *buf, signed int alloc_len)
{
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_read_track_info");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    scsi_init_command(c, MMC_TRACK_INFO, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
    c->dxfer_len = alloc_len;
    c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
    c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
    c->retry = 1;
    c->opcode[(signed long int)1] = (unsigned char)1;
    if(!(trackno >= 1))
    {
      _Bool tmp_if_expr$7;
      if(d->current_profile == 0x1a)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = d->current_profile == 0x13 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$8;
      if(tmp_if_expr$7)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$9;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = d->current_profile == 0x42 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$10;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
        trackno = 1;

      else
      {
        _Bool tmp_if_expr$2;
        if(d->current_profile == 0x10)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = d->current_profile == 0x11 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$3;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = d->current_profile == 0x14 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$4;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (_Bool)1;

        else
          tmp_if_expr$4 = d->current_profile == 0x15 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$5;
        if(tmp_if_expr$4)
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = d->current_profile == 0x40 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$6;
        if(tmp_if_expr$5)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = d->current_profile == 0x41 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          trackno = d->last_track_no;

        else
          trackno = 0xFF;
      }
    }

    mmc_int_to_four_char(c->opcode + (signed long int)2, trackno);
    c->page = buf;
    memset((void *)buf->data, 0, (unsigned long int)65536);
    c->dir = 1;
    d->issue_command(d, c);
    if(!(c->error == 0))
      return 0;

    else
      return 1;
  }
}

// mmc_reserve_track
// file libburn/mmc.c line 366
signed int mmc_reserve_track(struct burn_drive *d, signed long int size)
{
  struct command *c;
  signed int lba;
  char msg[80l];
  c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_reserve_track");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    scsi_init_command(c, MMC_RESERVE_TRACK, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
    c->retry = 1;
    lba = (signed int)(size / (signed long int)2048);
    if(!(size % 2048l == 0l))
      lba = lba + 1;

    mmc_int_to_four_char(c->opcode + (signed long int)5, lba);
    sprintf(msg, "reserving track of %d blocks", lba);
    libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
    c->page = (struct buffer *)(void *)0;
    c->dir = 2;
    c->timeout = 200000;
    d->issue_command(d, c);
    if(!(c->error == 0))
    {
      d->cancel = 1;
      scsi_notify_error(d, c, c->sense, 18, 2);
    }

    return (signed int)!(c->error != 0);
  }
}

// mmc_send_cue_sheet
// file libburn/mmc.c line 331
signed int mmc_send_cue_sheet(struct burn_drive *d, struct cue_sheet *s)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_send_cue_sheet");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      scsi_init_command(c, MMC_SEND_CUE_SHEET, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
      c->retry = 1;
      c->page = buf;
      c->page->bytes = s->count * 8;
      c->page->sectors = 0;
      c->opcode[(signed long int)6] = (unsigned char)(c->page->bytes >> 16 & 0xFF);
      c->opcode[(signed long int)7] = (unsigned char)(c->page->bytes >> 8 & 0xFF);
      c->opcode[(signed long int)8] = (unsigned char)(c->page->bytes & 0xFF);
      c->dir = 0;
      memcpy((void *)c->page->data, (const void *)s->data, (unsigned long int)c->page->bytes);
      d->issue_command(d, c);
    }


  ex:
    ;
    if(!(buf == ((struct buffer *)NULL)))
      free((void *)(char *)buf);

    if(!(c->error == 0))
    {
      d->cancel = 1;
      scsi_notify_error(d, c, c->sense, 18, 2);
    }

    return (signed int)!(c->error != 0);
  }
}

// mmc_set_product_id
// file libburn/mmc.c line 5001
static signed int mmc_set_product_id(char *reply, signed int manuf_idx, signed int type_idx, signed int rev_idx, char **product_id, char **media_code1, char **media_code2, signed int flag)
{
  signed int ret;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)17, (unsigned long int)1);
  *product_id = (char *)return_value_calloc$1;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)9, (unsigned long int)1);
  *media_code1 = (char *)return_value_calloc$2;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)8, (unsigned long int)1);
  *media_code2 = (char *)return_value_calloc$3;
  _Bool tmp_if_expr$4;
  if(*product_id == ((char *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = *media_code1 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = *media_code2 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
    return -1;

  else
  {
    if(!((2 & flag) == 0))
      sprintf(*media_code1, "%.6s", reply + (signed long int)manuf_idx);

    else
      sprintf(*media_code1, "%.8s", reply + (signed long int)manuf_idx);
    ret=burn_util_make_printable_word(media_code1, 1 | (flag & 1) << 1);
    if(!(ret >= 1))
      return -1;

    else
    {
      sprintf(*media_code2, "%.3s%s", reply + (signed long int)type_idx, (flag & 1) != 0 ? "" : "xxxx");
      ret=burn_util_make_printable_word(media_code2, 1 | (flag & 1) << 1);
      if(!(ret >= 1))
        return -1;

      else
      {
        if((1 & flag) == 0)
        {
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(*media_code2);
          sprintf((*media_code2 + (signed long int)return_value_strlen$6) - (signed long int)4, "/%d", (signed int)((unsigned char *)reply)[(signed long int)rev_idx]);
        }

        sprintf(*product_id, "%s/%s", *media_code1, *media_code2);
        return 1;
      }
    }
  }
}

// mmc_set_speed
// file libburn/mmc.c line 2844
void mmc_set_speed(struct burn_drive *d, signed int r, signed int w)
{
  struct command *c;
  signed int ret;
  signed int end_lba = 0;
  signed int get_max;
  signed int get_min;
  struct burn_speed_descriptor *best_sd = (struct burn_speed_descriptor *)(void *)0;
  c = &d->casual_command;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_set_speed");
  char *return_value_strstr$5;
  if(return_value_mmc_function_spy$1 >= 1)
  {
    if(!(r >= 1) || !(w >= 1))
    {
      if(!(r >= 1))
      {
        get_max = (signed int)(r == 0);
        get_min = (signed int)(r == -1);
        burn_drive_get_best_speed(d, r, &best_sd, 1 | 2);
        if(!(best_sd == ((struct burn_speed_descriptor *)NULL)))
        {
          r = best_sd->read_speed;
          end_lba = best_sd->end_lba;
        }

        if(!(get_max == 0))
        {
          if(!(d->current_is_cd_profile == 0))
          {
            if(!(r >= 52))
              r = 52 * 150;

          }

          else
          {
            _Bool tmp_if_expr$2;
            if(d->current_profile >= 0x10)
              tmp_if_expr$2 = d->current_profile <= 0x2f ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(tmp_if_expr$2)
            {
              if(!(r >= 24))
                r = 24 * 1385;

            }

            else
              if(d->current_profile >= 0x40)
              {
                if(!(d->current_profile >= 68))
                {
                  if((double)r < 89913.000000)
                    r = (signed int)((double)20 * 4495.625 + 0.5);

                }

              }

          }
        }

        else
          if(!(get_min == 0))
          {
            if(!(d->current_is_cd_profile == 0))
            {
              if(r >= 151)
                r = 1 * 150;

            }

            else
            {
              _Bool tmp_if_expr$3;
              if(d->current_profile >= 0x10)
                tmp_if_expr$3 = d->current_profile <= 0x2f ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
              {
                if(r >= 1386)
                  r = 1 * 1385;

              }

              else
                if(d->current_profile >= 0x40)
                {
                  if(!(d->current_profile >= 68))
                  {
                    if((double)r > 4495.000000)
                      r = (signed int)((double)1 * 4495.625 - 0.625);

                  }

                }

            }
          }

      }

      if(!(w >= 1))
      {
        burn_drive_get_best_speed(d, w, &best_sd, 2);
        if(!(best_sd == ((struct burn_speed_descriptor *)NULL)))
        {
          w = best_sd->write_speed;
          d->nominal_write_speed = w;
          if(!(end_lba >= best_sd->end_lba))
            end_lba = best_sd->end_lba;

        }

      }

    }

    d->nominal_write_speed = w;
    char *return_value_strstr$4;
    return_value_strstr$4=strstr(d->current_profile_text, "DVD");
    _Bool tmp_if_expr$6;
    if(return_value_strstr$4 == d->current_profile_text)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_strstr$5=strstr(d->current_profile_text, "BD");
      tmp_if_expr$6 = return_value_strstr$5 == d->current_profile_text ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      ret=mmc_set_streaming(d, r, w, end_lba);
      if(ret == 0)
        goto __CPROVER_DUMP_L23;

    }

    else
    {

    __CPROVER_DUMP_L23:
      ;
      if(r == 0 || r >= 65536)
        r = 0xffff;

      else
        if(!(r >= 0))
          r = 177;

      if(w == 0 || w >= 65536)
        w = 0xffff;

      else
        if(!(w >= 0))
          w = 177;

      scsi_init_command(c, MMC_SET_SPEED, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
      c->retry = 1;
      c->opcode[(signed long int)2] = (unsigned char)(r >> 8);
      c->opcode[(signed long int)3] = (unsigned char)(r & 0xFF);
      c->opcode[(signed long int)4] = (unsigned char)(w >> 8);
      c->opcode[(signed long int)5] = (unsigned char)(w & 0xFF);
      c->page = (struct buffer *)(void *)0;
      c->dir = 2;
      d->issue_command(d, c);
    }
  }

}

// mmc_set_streaming
// file libburn/mmc.c line 2750
signed int mmc_set_streaming(struct burn_drive *d, signed int r_speed, signed int w_speed, signed int end_lba)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int b;
  signed int eff_end_lba;
  signed int ret;
  char *msg = (char *)(void *)0;
  unsigned char *pd;
  signed int key;
  signed int asc;
  signed int ascq;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  signed int return_value_mmc_function_spy$4;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(c == ((struct command *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)256, 0);
      msg = (char *)return_value_burn_alloc_mem$3;
      if(msg == ((char *)NULL))
        ret = -1;

      else
      {
        mmc_start_if_needed(d, 1);
        return_value_mmc_function_spy$4=mmc_function_spy(d, "mmc_set_streaming");
        if(!(return_value_mmc_function_spy$4 >= 1))
          ret = 0;

        else
        {
          scsi_init_command(c, MMC_SET_STREAMING, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
          c->retry = 1;
          c->page = buf;
          c->page->bytes = 28;
          c->opcode[(signed long int)9] = (unsigned char)(c->page->bytes >> 8 & 0xff);
          c->opcode[(signed long int)10] = (unsigned char)(c->page->bytes & 0xff);
          c->page->sectors = 0;
          c->dir = 0;
          memset((void *)c->page->data, 0, (unsigned long int)c->page->bytes);
          pd = c->page->data;
          pd[(signed long int)0] = (unsigned char)0;
          if(w_speed == 0)
            w_speed = 0x10000000;

          else
            if(!(w_speed >= 0))
              w_speed = 177;

          if(r_speed == 0)
            r_speed = 0x10000000;

          else
            if(!(r_speed >= 0))
              r_speed = 177;

          if(end_lba == 0)
          {
            eff_end_lba = 2294921 - 1;
            if(d->mdata->max_end_lba >= 1)
              eff_end_lba = d->mdata->max_end_lba - 1;

          }

          else
            eff_end_lba = end_lba;
          sprintf(msg, "mmc_set_streaming: end_lba=%d ,  r=%d ,  w=%d", eff_end_lba, r_speed, w_speed);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x00000000, msg, 0, 0);
          b = 0;
          for( ; !(b >= 4); b = b + 1)
          {
            pd[(signed long int)(8 + b)] = (unsigned char)(eff_end_lba >> 24 - 8 * b & 0xff);
            pd[(signed long int)(12 + b)] = (unsigned char)(r_speed >> 24 - 8 * b & 0xff);
            pd[(signed long int)(16 + b)] = (unsigned char)(1000 >> 24 - 8 * b & 0xff);
            pd[(signed long int)(20 + b)] = (unsigned char)(w_speed >> 24 - 8 * b & 0xff);
            pd[(signed long int)(24 + b)] = (unsigned char)(1000 >> 24 - 8 * b & 0xff);
          }
          d->issue_command(d, c);
          if(!(c->error == 0))
          {
            spc_decode_sense(c->sense, 0, &key, &asc, &ascq);
            if(!(key == 0))
            {
              if(!(d->silent_on_scsi_error == 1))
              {
                if(!(d->silent_on_scsi_error == 2))
                {
                  sprintf(msg, "SCSI error on set_streaming(%d): ", w_speed);
                  unsigned long int return_value_strlen$5;
                  return_value_strlen$5=strlen(msg);
                  scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$5, &key, &asc, &ascq);
                  libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020124, d->silent_on_scsi_error == 3 ? 0x10000000 : 0x60000000, 0x30000000, msg, 0, 0);
                }

              }

            }

            ret = 0;
          }

          else
            ret = 1;
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// mmc_setup_drive
// file libburn/mmc.c line 5301
signed int mmc_setup_drive(struct burn_drive *d)
{
  d->read_atip = mmc_read_atip;
  d->read_toc = mmc_read_toc;
  d->write = mmc_write;
  d->erase = mmc_erase;
  d->read_cd = mmc_read_cd;
  d->perform_opc = mmc_perform_opc;
  d->set_speed = mmc_set_speed;
  d->send_cue_sheet = mmc_send_cue_sheet;
  d->reserve_track = mmc_reserve_track;
  d->sync_cache = mmc_sync_cache;
  d->get_nwa = mmc_get_nwa;
  d->read_multi_session_c1 = mmc_read_multi_session_c1;
  d->close_disc = mmc_close_disc;
  d->close_session = mmc_close_session;
  d->close_track_session = mmc_close;
  d->read_buffer_capacity = mmc_read_buffer_capacity;
  d->format_unit = mmc_format_unit;
  d->read_format_capacities = mmc_read_format_capacities;
  d->read_10 = mmc_read_10;
  d->phys_if_std = -1;
  d->phys_if_name[(signed long int)0] = (char)0;
  d->start_lba = -2000000000;
  d->end_lba = -2000000000;
  d->erasable = 0;
  d->current_profile = -1;
  d->current_profile_text[(signed long int)0] = (char)0;
  d->current_is_cd_profile = 0;
  d->current_is_supported_profile = 0;
  d->current_is_guessed_profile = 0;
  memset((void *)d->all_profiles, 0, (unsigned long int)256);
  d->num_profiles = 0;
  d->current_has_feat21h = 0;
  d->current_feat21h_link_size = -1;
  d->current_feat23h_byte4 = 0;
  d->current_feat23h_byte8 = 0;
  d->current_feat2fh_byte4 = -1;
  d->next_track_damaged = 0;
  d->needs_close_session = 0;
  d->needs_sync_cache = 0;
  d->bg_format_status = -1;
  d->num_opc_tables = -1;
  d->last_lead_in = -2000000000;
  d->last_lead_out = -2000000000;
  d->disc_type = 0xff;
  d->disc_id = (unsigned int)0;
  memset((void *)d->disc_bar_code, 0, (unsigned long int)9);
  d->disc_app_code = 0;
  d->disc_info_valid = 0;
  d->num_format_descr = 0;
  d->complete_sessions = 0;
  d->incomplete_sessions = 0;
  d->state_of_last_session = -1;
  d->last_track_no = 1;
  d->media_capacity_remaining = (signed long int)0;
  d->media_lba_limit = 0;
  d->media_read_capacity = 0x7fffffff;
  d->pessimistic_buffer_free = (signed long int)0;
  d->pbf_altered = 0;
  d->wait_for_buffer_free = 0;
  d->nominal_write_speed = 0;
  d->pessimistic_writes = (unsigned int)0;
  d->waited_writes = (unsigned int)0;
  d->waited_tries = (unsigned int)0;
  d->waited_usec = (unsigned int)0;
  d->wfb_min_usec = (unsigned int)10000;
  d->wfb_max_usec = (unsigned int)100000;
  d->wfb_timeout_sec = (unsigned int)120;
  d->wfb_min_percent = (unsigned int)65;
  d->wfb_max_percent = (unsigned int)95;
  d->sent_default_page_05 = 0;
  return 1;
}

// mmc_start_if_needed
// file libburn/mmc.c line 319
signed int mmc_start_if_needed(struct burn_drive *d, signed int flag)
{
  if(d->is_stopped == 0)
    return 2;

  else
    if(mmc_start_for_bit0 == 0 && !((1 & flag) == 0))
      return 2;

    else
    {
      d->start_unit(d);
      d->is_stopped = 0;
      return 1;
    }
}

// mmc_sync_cache
// file libburn/mmc.c line 3478
void mmc_sync_cache(struct burn_drive *d)
{
  struct command *c = (struct command *)(void *)0;
  char *msg = (char *)(void *)0;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_sync_cache");
  signed int return_value_spc_wait_unit_attention$6;
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
    c = (struct command *)return_value_burn_alloc_mem$2;
    if(!(c == ((struct command *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)256, 0);
      msg = (char *)return_value_burn_alloc_mem$3;
      if(!(msg == ((char *)NULL)))
      {
        scsi_init_command(c, MMC_SYNC_CACHE, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->retry = 1;
        c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)2;
        c->page = (struct buffer *)(void *)0;
        c->dir = 2;
        c->timeout = 200000;
        libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x00000000, "syncing cache", 0, 0);
        if(!(d->wait_for_buffer_free == 0))
        {
          sprintf(msg, "Checked buffer %u times. Waited %u+%u times = %.3f s", d->pessimistic_writes, d->waited_writes, d->waited_tries - d->waited_writes, (double)d->waited_usec / 1.0e6);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002013f, 0x10000000, 0x10000000, msg, 0, 0);
        }

        d->issue_command(d, c);
        if(!(c->error == 0))
        {
          sprintf(msg, "Failed to synchronize drive cache");
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(msg);
          sprintf(msg + (signed long int)return_value_strlen$4, ". SCSI error : ");
          unsigned long int return_value_strlen$5;
          return_value_strlen$5=strlen(msg);
          scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$5, &key, &asc, &ascq);
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002017f, 0x68000000, 0x30000000, msg, 0, 0);
          d->cancel = 1;
        }

        return_value_spc_wait_unit_attention$6=spc_wait_unit_attention(d, 3600, "SYNCHRONIZE CACHE", 0);
        if(!(return_value_spc_wait_unit_attention$6 >= 1))
          d->cancel = 1;

        else
          d->needs_sync_cache = 0;
      }

    }

  }


ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// mmc_wait_for_buffer_free
// file libburn/mmc.c line 743
static signed int mmc_wait_for_buffer_free(struct burn_drive *d, struct buffer *buf)
{
  signed int usec = 0;
  signed int need;
  signed int reported_3s = 0;
  signed int first_wait = 1;
  struct timeval t0;
  struct timeval tnow;
  struct timezone dummy_tz;
  double max_fac;
  double min_fac;
  double waiting;
  max_fac = (double)d->wfb_max_percent / 100.0;
  _Bool tmp_if_expr$1;
  if(!(d->progress.buffered_bytes >= 1l))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = d->progress.buffer_capacity <= (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (double)(d->progress.buffered_bytes + (signed long int)buf->bytes) <= (double)d->progress.buffer_capacity * max_fac ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 2;

  else
    if((double)(d->pessimistic_buffer_free + -((signed long int)buf->bytes)) >= (1.0 + -max_fac) * (double)d->progress.buffer_capacity)
      return 1;

    else
    {
      d->pessimistic_writes = d->pessimistic_writes + 1u;
      min_fac = (double)d->wfb_min_percent / 100.0;
      gettimeofday(&t0, &dummy_tz);
      for( ; (_Bool)1; first_wait = 0)
      {
        _Bool tmp_if_expr$3;
        if(first_wait == 0)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = d->pbf_altered != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          d->pbf_altered = 1;
          mmc_read_buffer_capacity(d);
        }

        gettimeofday(&tnow, &dummy_tz);
        waiting = (double)(tnow.tv_sec - t0.tv_sec) + (double)(tnow.tv_usec - t0.tv_usec) / 1.0e6;
        if((double)(d->pessimistic_buffer_free + -((signed long int)buf->bytes)) >= (1.0 + -min_fac) * (double)d->progress.buffer_capacity)
          return 1;

        if(reported_3s == 0 && waiting >= 3.000000)
        {
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002013d, 0x10000000, 0x10000000, "Waiting for free buffer takes more than 3 seconds", 0, 0);
          reported_3s = 1;
        }

        else
          if(d->wfb_timeout_sec >= 1u)
          {
            if(waiting > (double)d->wfb_timeout_sec)
            {
              d->wait_for_buffer_free = 0;
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002013d, 0x60000000, 0x30000000, "Timeout with waiting for free buffer. Now disabled.", 0, 0);
              break;
            }

          }

        need = (signed int)(((1.0 - min_fac) * (double)d->progress.buffer_capacity + (double)buf->bytes) - (double)d->pessimistic_buffer_free);
        usec = 0;
        if(d->nominal_write_speed >= 1)
          usec = (signed int)((((double)need / 1000.0) / (double)d->nominal_write_speed) * 1.0e6);

        else
          usec = (signed int)(d->wfb_min_usec * (unsigned int)2);
        if(!(usec >= (signed int)d->wfb_min_usec))
          usec = (signed int)d->wfb_min_usec;

        else
          if(!((signed int)d->wfb_max_usec >= usec))
            usec = (signed int)d->wfb_max_usec;

        usleep((unsigned int)usec);
        if(!(d->waited_usec >= 0xf0000000))
          d->waited_usec = d->waited_usec + (unsigned int)usec;

        d->waited_tries = d->waited_tries + 1u;
        if(!(first_wait == 0))
          d->waited_writes = d->waited_writes + 1u;

      }
      return 0;
    }
}

// mmc_write
// file libburn/mmc.c line 926
signed int mmc_write(struct burn_drive *d, signed int start, struct buffer *buf)
{
  signed int cancelled;
  struct command *c;
  signed int len;
  signed int key;
  signed int asc;
  signed int ascq;
  char *msg = (char *)(void *)0;
  c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_write");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 1;

  else
  {
    cancelled = d->cancel;
    if(!(cancelled == 0))
      return 1;

    else
    {
      if(d->media_lba_limit >= 1)
      {
        if(start >= d->media_lba_limit)
        {
          void *return_value_calloc$2;
          return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)160);
          msg = (char *)return_value_calloc$2;
          if(!(msg == ((char *)NULL)))
          {
            sprintf(msg, "Exceeding range of permissible write addresses (%d >= %d)", start, d->media_lba_limit);
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002012d, 0x70000000, 0x30000000, msg, 0, 0);
            free((void *)msg);
          }

          d->cancel = 1;
          return 1;
        }

      }

      len = buf->sectors;
      if(!(d->wait_for_buffer_free == 0))
        mmc_wait_for_buffer_free(d, buf);

      _Bool tmp_if_expr$3;
      if(d->do_stream_recording >= 1)
        tmp_if_expr$3 = start >= d->stream_recording_start ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        scsi_init_command(c, MMC_WRITE_12, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
        mmc_int_to_four_char(c->opcode + (signed long int)2, start);
        mmc_int_to_four_char(c->opcode + (signed long int)6, len);
        c->opcode[(signed long int)10] = (unsigned char)(1 << 7);
      }

      else
      {
        scsi_init_command(c, MMC_WRITE_10, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        mmc_int_to_four_char(c->opcode + (signed long int)2, start);
        c->opcode[(signed long int)6] = (unsigned char)0;
        c->opcode[(signed long int)7] = (unsigned char)(len >> 8 & 0xFF);
        c->opcode[(signed long int)8] = (unsigned char)(len & 0xFF);
      }
      c->retry = 1;
      c->page = buf;
      c->dir = 0;
      c->timeout = 200000;
      d->issue_command(d, c);
      d->pessimistic_buffer_free = d->pessimistic_buffer_free - (signed long int)buf->bytes;
      d->pbf_altered = 1;
      spc_decode_sense(c->sense, 0, &key, &asc, &ascq);
      if(!(c->error == 0))
      {
        if(!(key == 0))
        {
          signed int mmc_write$$1$$4$$key;
          signed int mmc_write$$1$$4$$asc;
          signed int mmc_write$$1$$4$$ascq;
          signed int err_sev = 0x70000000;
          void *return_value_calloc$4;
          return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)256);
          msg = (char *)return_value_calloc$4;
          if(!(msg == ((char *)NULL)))
          {
            sprintf(msg, "SCSI error on write(%d,%d): ", start, len);
            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen(msg);
            scsi_error_msg(d, c->sense, 14, msg + (signed long int)return_value_strlen$5, &mmc_write$$1$$4$$key, &mmc_write$$1$$4$$asc, &mmc_write$$1$$4$$ascq);
          }

          if(d->current_profile == 0x14)
          {
            if(!(d->write_opts == ((struct burn_write_opts *)NULL)))
            {
              _Bool tmp_if_expr$6;
              if(d->progress.buffer_capacity == 0u)
                tmp_if_expr$6 = (_Bool)1;

              else
                tmp_if_expr$6 = start < (signed int)d->progress.buffer_capacity / 2048 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$6)
              {
                if(mmc_write$$1$$4$$key == 5)
                {
                  if(mmc_write$$1$$4$$asc == 0x64)
                  {
                    if(mmc_write$$1$$4$$ascq == 0)
                    {
                      if((signed int)d->write_opts->write_type == BURN_WRITE_TAO)
                      {
                        d->was_feat21h_failure = 1 + (signed int)(start == 0);
                        if(!(d->write_opts->feat21h_fail_sev == 0))
                          err_sev = d->write_opts->feat21h_fail_sev;

                      }

                    }

                  }

                }

              }

            }

          }

          if(!(msg == ((char *)NULL)))
          {
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002011d, err_sev, 0x30000000, msg, 0, 0);
            free((void *)msg);
          }

          d->cancel = 1;
          return 1;
        }

      }

      return 0;
    }
  }
}

// mmc_write_12
// file libburn/mmc.c line 874
void mmc_write_12(struct burn_drive *d, signed int start, struct buffer *buf)
{
  struct command *c;
  signed int len;
  c = &d->casual_command;
  mmc_start_if_needed(d, 0);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "mmc_write_12");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    len = buf->sectors;
    scsi_init_command(c, MMC_WRITE_12, (signed int)sizeof(unsigned char [12l]) /*12ul*/ );
    c->retry = 1;
    mmc_int_to_four_char(c->opcode + (signed long int)2, start);
    mmc_int_to_four_char(c->opcode + (signed long int)6, len);
    c->page = buf;
    c->dir = 0;
    c->timeout = 200000;
    d->issue_command(d, c);
    d->pessimistic_buffer_free = d->pessimistic_buffer_free - (signed long int)buf->bytes;
    d->pbf_altered = 1;
  }

}

// new_burn_speed_descr
// file libburn/mmc.c line 4268
static signed int new_burn_speed_descr(struct burn_drive *d, signed int sd_source, struct burn_speed_descriptor **sd, signed int flag)
{
  signed int ret;
  ret=burn_speed_descriptor_new(&d->mdata->speed_descriptors, (struct burn_speed_descriptor *)(void *)0, d->mdata->speed_descriptors, 0);
  if(!(ret >= 1))
    return ret;

  else
  {
    *sd = d->mdata->speed_descriptors;
    (*sd)->source = sd_source;
    if(d->current_profile >= 1)
    {
      (*sd)->profile_loaded = d->current_profile;
      strcpy((*sd)->profile_name, d->current_profile_text);
    }

    return 1;
  }
}

// new_cue
// file libburn/write.c line 374
static signed int new_cue(struct cue_sheet *sheet, signed int number, signed int flag)
{
  unsigned char *ptr;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)sheet->data, (unsigned long int)((sheet->count + number) * 8));
  ptr = (unsigned char *)return_value_realloc$1;
  if(ptr == ((unsigned char *)NULL))
  {
    libdax_msgs_submit(libdax_messenger, -1, 0x00020111, 0x70000000, 0x30000000, "Could not allocate new auxiliary object (cue_sheet->data)", 0, 0);
    return -1;
  }

  else
  {
    sheet->data = ptr;
    sheet->count = sheet->count + number;
    return 1;
  }
}

// null_read
// file libburn/null.c line 17
signed int null_read(struct burn_source *source, unsigned char *buffer, signed int size)
{
  memset((void *)buffer, 0, (unsigned long int)size);
  return size;
}

// offst_auth
// file libburn/file.c line 769
static struct burn_source_offst * offst_auth(struct burn_source *source, signed int flag)
{
  if(!(source->free_data == offst_free))
  {
    if(!((1 & flag) == 0))
      goto __CPROVER_DUMP_L1;

    libdax_msgs_submit(libdax_messenger, -1, 0x0002017a, 0x68000000, 0x30000000, "Expected offset source object as parameter", 0, 0);
    return (struct burn_source_offst *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (struct burn_source_offst *)source->data;
  }
}

// offst_cancel
// file libburn/file.c line 861
static signed int offst_cancel(struct burn_source *source)
{
  signed int ret;
  struct burn_source_offst *fs;
  fs=offst_auth(source, 0);
  if(fs == ((struct burn_source_offst *)NULL))
    return -1;

  else
  {
    ret=burn_source_cancel(fs->inp);
    return ret;
  }
}

// offst_free
// file libburn/file.c line 804
static void offst_free(struct burn_source *source)
{
  struct burn_source_offst *fs;
  fs=offst_auth(source, 0);
  struct burn_source_offst *return_value_offst_auth$1;
  struct burn_source_offst *return_value_offst_auth$2;
  if(!(fs == ((struct burn_source_offst *)NULL)))
  {
    if(!(fs->prev == ((struct burn_source *)NULL)))
    {
      return_value_offst_auth$1=offst_auth(fs->prev, 1);
      return_value_offst_auth$1->next = fs->next;
    }

    if(!(fs->next == ((struct burn_source *)NULL)))
    {
      return_value_offst_auth$2=offst_auth(fs->next, 1);
      return_value_offst_auth$2->prev = fs->prev;
    }

    if(!(fs->inp == ((struct burn_source *)NULL)))
      burn_source_free(fs->inp);

    free(source->data);
  }

}

// offst_get_size
// file libburn/file.c line 782
static signed long int offst_get_size(struct burn_source *source)
{
  struct burn_source_offst *fs;
  fs=offst_auth(source, 0);
  if(fs == ((struct burn_source_offst *)NULL))
    return (signed long int)0;

  else
    return (signed long int)fs->nominal_size;
}

// offst_read
// file libburn/file.c line 819
static signed int offst_read(struct burn_source *source, unsigned char *buffer, signed int size)
{
  signed int ret;
  signed int to_read;
  signed int todo;
  struct burn_source_offst *fs;
  fs=offst_auth(source, 0);
  struct burn_source_offst *return_value_offst_auth$1;
  if(fs == ((struct burn_source_offst *)NULL))
    return -1;

  else
  {
    if(fs->running == 0)
    {
      if(!(fs->prev == ((struct burn_source *)NULL)))
      {
        return_value_offst_auth$1=offst_auth(fs->prev, 1);
        fs->pos = return_value_offst_auth$1->pos;
      }

      fs->running = 1;
    }

    if(!(fs->pos >= fs->start))
    {
      todo = (signed int)(fs->start - fs->pos);
      for( ; todo >= 1; fs->pos = fs->pos + (signed long int)ret)
      {
        to_read = todo;
        if(!(size >= to_read))
          to_read = size;

        ret=burn_source_read(fs->inp, buffer, to_read);
        if(!(ret >= 1))
          return ret;

        todo = todo - ret;
      }
    }

    if(!(fs->size + fs->start >= fs->pos + (signed long int)size))
      return 0;

    else
    {
      ret=burn_source_read(fs->inp, buffer, size);
      if(ret >= 1)
        fs->pos = fs->pos + (signed long int)ret;

      return ret;
    }
  }
}

// offst_set_size
// file libburn/file.c line 791
static signed int offst_set_size(struct burn_source *source, signed long int size)
{
  struct burn_source_offst *fs;
  fs=offst_auth(source, 0);
  if(fs == ((struct burn_source_offst *)NULL))
    return 0;

  else
  {
    fs->nominal_size = (signed int)size;
    _Bool tmp_if_expr$1;
    if(!(fs->size >= 1l))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = fs->size_adjustable != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      fs->size = size;

    return 1;
  }
}

// pick_payload_text
// file libburn/cdtext.c line 1295
static signed int pick_payload_text(unsigned char *payload, signed int payload_count, signed int tno, unsigned char **text_start, signed int *text_len, signed int flag)
{
  signed int i;
  signed int skipped = 0;
  signed int end_found = 0;
  do
  {

  again:
    ;
    if(!(tno >= 1))
    {
      *text_start = payload;
      *text_len = 0;
      i = 0;
      for( ; !(i >= payload_count); i = i + 1 + (flag & 1))
      {
        end_found=is_payload_text_end(payload, payload_count, i, flag & 1);
        if(!(end_found == 0))
        {
          *text_len = i;
          break;
        }

      }
      return 1;
    }

    *text_start = (unsigned char *)(void *)0;
    *text_len = 0;
    i = 0;
    for( ; !(i >= payload_count); i = i + 1 + (flag & 1))
    {
      end_found=is_payload_text_end(payload, payload_count, i, flag & 1);
      if(!(end_found == 0))
      {
        skipped = skipped + 1;
        if(skipped == tno)
          *text_start = payload + (signed long int)(i + 1 + (flag & 1));

        else
          if(skipped == 1 + tno)
          {
            *text_len = (signed int)((signed long int)i - (*text_start - payload));
            goto found;
          }

      }

    }
    if(*text_start == ((unsigned char *)NULL))
      return 0;

    *text_len = (signed int)((signed long int)payload_count - (*text_start - payload));

  found:
    ;
    if((2 & flag) == 0)
      break;

    if(!((1 & flag) == 0))
    {
      if(*text_len == 2)
      {
        if((signed int)*(*text_start) == 9)
        {
          if((signed int)(*text_start)[1l] == 9)
          {
            skipped = 0;
            tno = tno - 1;
            goto again;
          }

        }

      }

      break;
    }

    if(!(*text_len == 1))
      break;

    if(!((signed int)*(*text_start) == 9))
      break;

    skipped = 0;
    tno = tno - 1;
  }
  while((_Bool)1);
  return 1;
}

// precheck_disc_has_cdtext
// file libburn/write.c line 1400
static signed int precheck_disc_has_cdtext(struct burn_disc *disc, signed int flag)
{
  struct burn_session **sessions;
  signed int num_sessions;
  signed int i;
  signed int ret;
  sessions=burn_disc_get_sessions(disc, &num_sessions);
  i = 0;
  for( ; !(i >= num_sessions); i = i + 1)
  {
    ret=burn_cdtext_from_session(sessions[(signed long int)i], (unsigned char **)(void *)0, (signed int *)(void *)0, 1);
    if(ret >= 1)
      return 1;

  }
  return 0;
}

// precheck_write_is_audio
// file libburn/write.c line 1386
static signed int precheck_write_is_audio(struct burn_disc *disc, signed int flag)
{
  struct burn_session **sessions;
  signed int num_sessions;
  signed int i;
  signed int j;
  sessions=burn_disc_get_sessions(disc, &num_sessions);
  i = 0;
  for( ; !(i >= num_sessions); i = i + 1)
  {
    j = 0;
    for( ; !(j >= sessions[(signed long int)i]->tracks); j = j + 1)
      if((64 & sessions[(signed long int)i]->track[(signed long int)j]->mode) == 0)
        return 0;

  }
  return 1;
}

// proc_sys_dev_cdrom_info
// file libburn/sg-linux.c line 1335
static signed int proc_sys_dev_cdrom_info(char ***list, signed int *count, signed int flag)
{
  struct _IO_FILE *fp;
  char *line = (char *)(void *)0;
  char *fname = (char *)(void *)0;
  char *cpt;
  char *retpt;
  char *list_data;
  signed int maxl = 0;
  signed int pass;
  signed int i;
  signed int line_size = 1024;
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)line_size, 0);
  line = (char *)return_value_burn_alloc_mem$1;
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strlen$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  if(line == ((char *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(line_size + 5), 0);
    fname = (char *)return_value_burn_alloc_mem$2;
    if(fname == ((char *)NULL))
      ret = -1;

    else
    {
      if(!(*list == ((char **)NULL)))
      {
        if(!(*(*list) == ((char *)NULL)))
          free((void *)(*list)[(signed long int)0]);

        free((void *)*list);
        *list = (char **)(void *)0;
        *count = 0;
      }

      if(!((1 & flag) == 0))
        ret = 1;

      else
      {
        *count = 0;
        sg_evaluate_kernel();
        if(!(sg_kernel_age >= 2))
          ret = 1;

        else
        {
          fp=fopen("/proc/sys/dev/cdrom/info", "r");
          if(fp == ((struct _IO_FILE *)NULL))
            ret = 0;

          else
          {
            while((_Bool)1)
            {
              retpt=fgets(line, line_size, fp);
              if(retpt == ((char *)NULL))
                break;

              signed int return_value_strncmp$3;
              return_value_strncmp$3=strncmp(line, "drive name:", (unsigned long int)11);
              if(return_value_strncmp$3 == 0)
                break;

            }
            fclose(fp);
            if(retpt == ((char *)NULL))
              ret = 0;

            else
            {
              strcpy(fname, "/dev/");
              pass = 0;
              for( ; !(pass >= 2); pass = pass + 1)
              {
                *count = 0;
                cpt = line + (signed long int)11;
                while(!((signed int)*cpt == 0))
                {
                  do
                  {
                    if((signed int)*cpt == 32)
                      tmp_if_expr$4 = (_Bool)1;

                    else
                      tmp_if_expr$4 = (signed int)*cpt == 9 ? (_Bool)1 : (_Bool)0;
                    if(!tmp_if_expr$4)
                      break;

                    cpt = cpt + 1l;
                  }
                  while((_Bool)1);
                  _Bool tmp_if_expr$5;
                  if((signed int)*cpt == 0)
                    tmp_if_expr$5 = (_Bool)1;

                  else
                    tmp_if_expr$5 = (signed int)*cpt == 10 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$5)
                    break;

                  __isoc99_sscanf(cpt, "%s", fname + (signed long int)5);
                  unsigned long int return_value_strlen$7;
                  return_value_strlen$7=strlen(fname);
                  if(!(maxl >= (signed int)return_value_strlen$7))
                  {
                    return_value_strlen$6=strlen(fname);
                    maxl = (signed int)return_value_strlen$6;
                  }

                  if(pass == 1)
                    strcpy((*list)[(signed long int)*count], fname);

                  *count = *count + 1;
                  cpt = cpt + 1l;
                  do
                  {
                    if(!((signed int)*cpt == 32))
                      tmp_if_expr$8 = (signed int)*cpt != 9 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$8 = (_Bool)0;
                    if(tmp_if_expr$8)
                      tmp_if_expr$9 = (signed int)*cpt != 0 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$9 = (_Bool)0;
                    if(tmp_if_expr$9)
                      tmp_if_expr$10 = (signed int)*cpt != 10 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$10 = (_Bool)0;
                    if(!tmp_if_expr$10)
                      break;

                    cpt = cpt + 1l;
                  }
                  while((_Bool)1);
                }
                if(pass == 0)
                {
                  void *return_value_calloc$11;
                  return_value_calloc$11=calloc((unsigned long int)(*count + 1), (unsigned long int)(maxl + 1));
                  list_data = (char *)return_value_calloc$11;
                  void *return_value_calloc$12;
                  return_value_calloc$12=calloc((unsigned long int)(*count + 1), sizeof(char *) /*8ul*/ );
                  *list = (char **)return_value_calloc$12;
                  _Bool tmp_if_expr$13;
                  if(list_data == ((char *)NULL))
                    tmp_if_expr$13 = (_Bool)1;

                  else
                    tmp_if_expr$13 = *list == (char **)(void *)0 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$13)
                  {
                    libdax_msgs_submit(libdax_messenger, -1, 0x00000003, 0x70000000, 0x30000000, "Out of virtual memory", 0, 0);
                    if(!(list_data == ((char *)NULL)))
                      free((void *)list_data);

                    if(!(*list == ((char **)NULL)))
                      free((void *)(char *)*list);

                    ret = -1;
                    goto ex;
                  }

                  i = 0;
                  for( ; *count >= i; i = i + 1)
                    (*list)[(signed long int)i] = list_data + (signed long int)(i * (maxl + 1));
                }

              }
              ret = 1;
            }
          }
        }
      }
    }
  }

ex:
  ;
  if(!(line == ((char *)NULL)))
    free((void *)(char *)line);

  if(!(fname == ((char *)NULL)))
    free((void *)(char *)fname);

  return ret;
}

// react_on_drive_loss
// file libburn/sg-linux.c line 2033
static void react_on_drive_loss(struct burn_drive *d, struct command *c, struct _IO_FILE *fp)
{
  sg_close_drive(d);
  d->released = 1;
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  d->cancel = 1;
  c->error = 1;
  libdax_msgs_submit(libdax_messenger, d->global_index, 0x000201a6, 0x70000000, 0x30000000, "Lost connection to drive", 0, 0);
  scsi_log_message(d, (void *)fp, "--- SG_IO: Gave up connection to drive", 0);
}

// read_full_buffer
// file libburn/file.c line 49
static signed int read_full_buffer(signed int fd, unsigned char *buffer, signed int size)
{
  signed int ret;
  signed int summed_ret = 0;
  while((_Bool)1)
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)(buffer + (signed long int)summed_ret), (unsigned long int)(size - summed_ret));
    ret = (signed int)return_value_read$1;
    if(!(ret >= 1))
      break;

    summed_ret = summed_ret + ret;
    if(summed_ret >= size)
      break;

  }
  if(!(ret >= 0))
    return ret;

  else
    return summed_ret;
}

// remove_worker
// file libburn/async.c line 187
static void remove_worker(unsigned long int th)
{
  struct w_list *a;
  struct w_list *l = (struct w_list *)(void *)0;
  a = workers;
  for( ; !(a == ((struct w_list *)NULL)); a = a->next)
  {
    if(a->thread == th)
    {
      if(!(l == ((struct w_list *)NULL)))
        l->next = a->next;

      else
        workers = a->next;
      free((void *)a);
      break;
    }

    l = a;
  }
  if(a == ((struct w_list *)NULL))
    libdax_msgs_submit(libdax_messenger, -1, 0x00020101, 0x50000000, 0x30000000, "remove_worker() cannot find given worker item", 0, 0);

}

// report_block
// file libburn/cdtext.c line 1435
static signed int report_block(unsigned char *text_packs, signed int num_packs, signed int block, signed int first_tno, signed int last_tno, signed int char_code, char *result, signed int result_size, signed int flag)
{
  char *respt = (char *)(void *)0;
  unsigned char *pack;
  unsigned char *payload = (unsigned char *)(void *)0;
  signed int result_len = 0;
  signed int pack_no;
  signed int ret;
  signed int i;
  signed int lang;
  signed int payload_count = 0;
  signed int genre;
  char msg[80l];
  ret=search_pack(text_packs, num_packs, 0, -1, block, &pack, &pack_no, 0);
  if(!(ret >= 1))
    return 0;

  else
    if((signed int)*pack == 0x8f)
      return 0;

    else
    {
      if(!((1 & flag) == 0))
        result_len = result_size;

      else
        respt = result + (signed long int)result_size;
      write_v07t_line(&respt, "Input Sheet Version", "0.7T", -1, &result_len, flag & 1);
      sprintf(msg, "Libburn report of CD-TEXT Block %d", block);
      write_v07t_line(&respt, "Remarks            ", msg, -1, &result_len, flag & 1);
      write_v07t_line(&respt, "Text Code          ", char_code == 0 ? "8859" : (char_code == 0x01 ? "ASCII" : "MS-JIS"), -1, &result_len, flag & 1);
      pack_no = 0;
      i = 0;
      for( ; !(i >= 3); i = i + 1)
      {
        ret=search_pack(text_packs, num_packs, pack_no, 0x8f, -1, &pack, &pack_no, 0);
        if(!(ret >= 1))
        {
          libdax_msgs_submit(libdax_messenger, -1, 0x0002019f, 0x68000000, 0x30000000, "No third CD-TEXT pack 0x8f found. No language code defined", 0, 0);
          goto failure;
        }

        pack_no = pack_no + 1;
      }
      lang = (signed int)pack[(signed long int)(8 + block)];
      if(lang >= 128)
      {
        sprintf(msg, "CD-TEXT with unknown language code %2.2x", (unsigned int)lang);
        libdax_msgs_submit(libdax_messenger, -1, 0x0002019f, 0x68000000, 0x30000000, msg, 0, 0);
      }

      else
      {
        static char *languages[128l] = { "Unknown", "Albanian", "Breton", "Catalan", "Croatian", "Welsh", "Czech", "Danish", "German", "English", "Spanish", "Esperanto", "Estonian", "Basque", "Faroese", "French", "Frisian", "Irish", "Gaelic", "Galician", "Icelandic", "Italian", "Lappish", "Latin", "Latvian", "Luxembourgian", "Lithuanian", "Hungarian", "Maltese", "Dutch", "Norwegian", "Occitan", "Polish", "Portuguese", "Romanian", "Romansh", "Serbian", "Slovak", "Slovenian", "Finnish", "Swedish", "Turkish", "Flemish", "Wallon", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Zulu", "Vietnamese", "Uzbek", "Urdu", "Ukrainian", "Thai", "Telugu", "Tatar", "Tamil", "Tadzhik", "Swahili", "Sranan Tongo", "Somali", "Sinhalese", "Shona", "Serbo-croat", "Ruthenian", "Russian", "Quechua", "Pushtu", "Punjabi", "Persian", "Papamiento", "Oriya", "Nepali", "Ndebele", "Marathi", "Moldavian", "Malaysian", "Malagasay", "Macedonian", "Laotian", "Korean", "Khmer", "Kazakh", "Kannada", "Japanese", "Indonesian", "Hindi", "Hebrew", "Hausa", "Gurani", "Gujurati", "Greek", "Georgian", "Fulani", "Dari", "Churash", "Chinese", "Burmese", "Bulgarian", "Bengali", "Bielorussian", "Bambora", "Azerbaijani", "Assamese", "Armenian", "Arabic", "Amharic" };
        write_v07t_line(&respt, "Language Code", languages[(signed long int)lang], -1, &result_len, flag & 1);
        i = 0;
        for( ; !(i >= 7); i = i + 1)
        {
          static char *volume_specs[7l] = { "Album Title", "Artist Name", "Songwriter", "Composer", "Arranger", "Album Message", "Catalog Number" };
          ret=write_v07t_textline(text_packs, num_packs, 0x80 + i, block, 0, 0, volume_specs[(signed long int)i], &respt, &result_len, flag & 1);
          if(!(ret >= 0))
            goto failure;

        }
        ret=collect_payload(text_packs, num_packs, 0x87, block, &payload, &payload_count, 0);
        if(ret >= 1)
        {
          genre = (signed int)payload[(signed long int)0] << 8 | (signed int)payload[(signed long int)1];
          static char *genres[28l] = { "Not Used", "Not Defined", "Adult Contemporary", "Alternative Rock", "Childrens Music", "Classical", "Contemporary Christian", "Country", "Dance", "Easy Listening", "Erotic", "Folk", "Gospel", "Hip Hop", "Jazz", "Latin", "Musical", "New Age", "Opera", "Operetta", "Pop Music", "Rap", "Reggae", "Rock Music", "Rhythm & Blues", "Sound Effects", "Spoken Word", "World Music" };
          if(!(genre >= 28))
            strcpy(msg, genres[(signed long int)genre]);

          else
            sprintf(msg, "0x%-4.4x", (unsigned int)genre);
          write_v07t_line(&respt, "Genre Code", msg, -1, &result_len, flag & 1);
          write_v07t_line(&respt, "Genre Information", (char *)payload + (signed long int)2, -1, &result_len, flag & 1);
          if(!(payload == ((unsigned char *)NULL)))
            free((void *)(char *)payload);

          payload = (unsigned char *)(void *)0;
        }

        ret=collect_payload(text_packs, num_packs, 0x8d, block, &payload, &payload_count, 0);
        if(ret >= 1)
        {
          write_v07t_line(&respt, "Closed Information", (char *)payload, -1, &result_len, flag & 1);
          if(!(payload == ((unsigned char *)NULL)))
            free((void *)(char *)payload);

          payload = (unsigned char *)(void *)0;
        }

        ret=write_v07t_textline(text_packs, num_packs, 0x8e, block, 0, 0, "UPC / EAN", &respt, &result_len, flag & 1);
        if(ret >= 0)
        {
          ret=search_pack(text_packs, num_packs, 0, 0x8f, -1, &pack, &pack_no, 0);
          if(ret >= 0)
          {
            if((signed int)pack[7l] == 0x00)
              strcpy(msg, "OFF");

            else
              if((signed int)pack[7l] == 0x03)
                strcpy(msg, "ON");

              else
                sprintf(msg, "0x%2.2x", (unsigned int)pack[(signed long int)7]);
            write_v07t_line(&respt, "Text Data Copy Protection", msg, -1, &result_len, flag & 1);
            sprintf(msg, "%d", first_tno);
            write_v07t_line(&respt, "First Track Number", msg, -1, &result_len, flag & 1);
            sprintf(msg, "%d", last_tno);
            write_v07t_line(&respt, "Last Track Number", msg, -1, &result_len, flag & 1);
            i = 0;
            for( ; !(i >= 1 + last_tno + -first_tno); i = i + 1)
            {
              ret=report_track(text_packs, num_packs, block, i + 1, first_tno, &respt, &result_len, flag & 1);
              if(!(ret >= 0))
                goto failure;

            }
            if(!((1 & flag) == 0))
              return result_len;

            return (signed int)(respt - result);
          }

        }

      }

    failure:
      ;
      if(!(payload == ((unsigned char *)NULL)))
        free((void *)(char *)payload);

      return -1;
    }
}

// report_track
// file libburn/cdtext.c line 1396
static signed int report_track(unsigned char *text_packs, signed int num_packs, signed int block, signed int tno, signed int first_tno, char **respt, signed int *result_len, signed int flag)
{
  signed int ret;
  signed int i = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    static char *track_specs[6l] = { "Title", "Artist", "Songwriter", "Composer", "Arranger", "Message" };
    ret=write_v07t_textline(text_packs, num_packs, 0x80 + i, block, tno, first_tno, track_specs[(signed long int)i], respt, result_len, flag & 1);
    if(!(ret >= 0))
      return -1;

  }
  ret=write_v07t_textline(text_packs, num_packs, 0x8e, block, tno, first_tno, "ISRC", respt, result_len, flag & 1);
  if(!(ret >= 0))
    return -1;

  else
    return 1;
}

// reset_progress
// file libburn/async.c line 243
static void reset_progress(struct burn_drive *d, signed int sessions, signed int tracks, signed int indices, signed int sectors, signed int flag)
{
  d->progress.session = 0;
  d->progress.sessions = sessions;
  d->progress.track = 0;
  d->progress.tracks = tracks;
  d->progress.index = 0;
  d->progress.indices = indices;
  d->progress.start_sector = 0;
  d->progress.sectors = sectors;
  d->progress.sector = 0;
}

// retry_mmc_read
// file libburn/read.c line 373
static signed int retry_mmc_read(struct burn_drive *d, signed int chunksize, signed int sose_mem, signed int start, char **wpt, signed long int *data_count, signed int flag)
{
  signed int i;
  signed int err;
  signed int todo;
  signed int retry_at;
  signed int retry_size;
  retry_at = start;
  retry_size = chunksize;
  todo = chunksize;
  retry_size = 16;
  if(!(d->current_is_cd_profile == 0))
    retry_size = 1;

  else
    if(d->current_profile >= 0x40)
    {
      if(!(d->current_profile >= 68))
        retry_size = 32;

    }

  i = 0;
  if(todo >= 1)
  {
    if(!((2 & flag) == 0))
      d->silent_on_scsi_error = 1;

    else
      if(!((32 & flag) == 0))
        d->silent_on_scsi_error = 3;

    retry_at = start + i * retry_size;
    if(!(todo >= retry_size))
      retry_size = todo;

    err=d->read_10(d, retry_at, retry_size, d->buffer);
    if(!((34 & flag) == 0))
      d->silent_on_scsi_error = sose_mem;

    if(err == 1)
      return 0;

    memcpy((void *)*wpt, (const void *)d->buffer->data, (unsigned long int)(retry_size * 2048));
    *wpt = *wpt + (signed long int)(retry_size * 2048);
    *data_count = *data_count + (signed long int)(retry_size * 2048);
    todo = todo - retry_size;
    i = i + 1;
  }

  return 1;
}

// retry_stdio_read
// file libburn/read.c line 413
static signed int retry_stdio_read(struct burn_drive *d, signed int fd, signed int chunksize, signed int start, char **wpt, signed long int *data_count, signed int flag)
{
  signed int i;
  signed int ret;
  signed int to_read;
  signed int todo;
  ret=burn_stdio_seek(fd, (signed long int)start * (signed long int)2048, d, flag & 2);
  if(!(ret >= 1))
    return ret;

  else
  {
    todo = chunksize * 2048;
    i = 0;
    for( ; todo >= 1; i = i + 2048)
    {
      to_read = todo;
      if(to_read >= 2049)
        to_read = 2048;

      ret=burn_stdio_read(fd, (char *)d->buffer->data, to_read, d, 1);
      if(!(ret >= 1))
        return 0;

      memcpy((void *)*wpt, (const void *)d->buffer->data, (unsigned long int)to_read);
      *wpt = *wpt + (signed long int)to_read;
      *data_count = *data_count + (signed long int)to_read;
      todo = todo - to_read;
    }
    return 1;
  }
}

// rfl32
// file libburn/crc.c line 301
unsigned int rfl32(unsigned int acc)
{
  unsigned int inv_acc;
  signed int i;
  inv_acc = (unsigned int)0;
  i = 0;
  for( ; !(i >= 32); i = i + 1)
    if(!((acc & (unsigned int)(1 << i)) == 0u))
      inv_acc = inv_acc | (unsigned int)(1 << 31 - i);

  return inv_acc;
}

// rfl8
// file libburn/crc.c line 412
unsigned int rfl8(unsigned int acc)
{
  unsigned int inv_acc;
  signed int i;
  signed int j;
  inv_acc = (unsigned int)0;
  j = 0;
  for( ; !(j >= 4); j = j + 1)
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      if(!((acc & (unsigned int)(1 << 8 * j + i)) == 0u))
        inv_acc = inv_acc | (unsigned int)(1 << (7 - i) + 8 * j);

  }
  return inv_acc;
}

// sbc_eject
// file libburn/sbc.c line 80
void sbc_eject(struct burn_drive *d)
{
  struct command *c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "eject");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, SBC_UNLOAD, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->page = (struct buffer *)(void *)0;
    c->dir = 2;
    d->issue_command(d, c);
  }

}

// sbc_load
// file libburn/sbc.c line 55
void sbc_load(struct burn_drive *d)
{
  struct command *c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "load");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, SBC_LOAD, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 1;
    c->dir = 2;
    c->timeout = 300000;
    d->issue_command(d, c);
    if(c->error == 0)
      spc_wait_unit_attention(d, 300, "waiting after START UNIT (+ LOAD)", 0);

  }

}

// sbc_setup_drive
// file libburn/sbc.c line 174
signed int sbc_setup_drive(struct burn_drive *d)
{
  d->eject = sbc_eject;
  d->load = sbc_load;
  d->start_unit = sbc_start_unit;
  d->stop_unit = sbc_stop_unit;
  d->is_stopped = 0;
  return 1;
}

// sbc_start_unit
// file libburn/sbc.c line 130
signed int sbc_start_unit(struct burn_drive *d)
{
  signed int ret;
  d->is_stopped = 0;
  ret=sbc_start_unit_flag(d, 1);
  if(!(ret >= 1))
    return ret;

  else
  {
    ret=sbc_start_unit_flag(d, 0);
    return ret;
  }
}

// sbc_start_unit_flag
// file libburn/sbc.c line 106
signed int sbc_start_unit_flag(struct burn_drive *d, signed int flag)
{
  struct command *c;
  signed int ret;
  c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "start_unit");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    scsi_init_command(c, SBC_START_UNIT, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 1;
    c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)(flag & 1);
    c->dir = 2;
    d->issue_command(d, c);
    if(!(c->error == 0))
      return 0;

    else
      if((1 & flag) == 0)
        return 1;

      else
      {
        ret=spc_wait_unit_attention(d, 1800, "START UNIT", 0);
        return ret;
      }
  }
}

// sbc_stop_unit
// file libburn/sbc.c line 149
signed int sbc_stop_unit(struct burn_drive *d)
{
  struct command *c;
  signed int ret;
  c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "stop_unit");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    scsi_init_command(c, SBC_STOP_UNIT, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 0;
    c->opcode[(signed long int)1] = c->opcode[(signed long int)1] | (unsigned char)1;
    c->dir = 2;
    d->issue_command(d, c);
    if(!(c->error == 0))
      return 0;

    else
    {
      ret=spc_wait_unit_attention(d, 1800, "STOP UNIT", 0);
      d->is_stopped = 1;
      return ret;
    }
  }
}

// scan_worker_func
// file libburn/async.c line 231
static void * scan_worker_func(struct w_list *w)
{
  signed int ret;
  ret=burn_drive_scan_sync(w->u.scan.drives, w->u.scan.n_drives, 1);
  if(!(ret >= 1))
    w->u.scan.done = -1;

  else
    w->u.scan.done = 1;
  return (void *)0;
}

// scsi_command_name
// file libburn/spc.c line 1611
static char * scsi_command_name(unsigned int c, signed int flag)
{
  switch(c)
  {
    case (unsigned int)0x00:
      return "TEST UNIT READY";
    case (unsigned int)0x03:
      return "REQUEST SENSE";
    case (unsigned int)0x04:
      return "FORMAT UNIT";
    case (unsigned int)0x1b:
      return "START/STOP UNIT";
    case (unsigned int)0x12:
      return "INQUIRY";
    case (unsigned int)0x1e:
      return "PREVENT/ALLOW MEDIA REMOVAL";
    case (unsigned int)0x23:
      return "READ FORMAT CAPACITIES";
    case (unsigned int)0x25:
      return "READ CAPACITY";
    case (unsigned int)0x28:
      return "READ(10)";
    case (unsigned int)0x2a:
      return "WRITE(10)";
    case (unsigned int)0x35:
      return "SYNCHRONIZE CACHE";
    case (unsigned int)0x43:
      return "READ TOC/PMA/ATIP";
    case (unsigned int)0x46:
      return "GET CONFIGURATION";
    case (unsigned int)0x4a:
      return "GET EVENT STATUS NOTIFICATION";
    case (unsigned int)0x51:
      return "READ DISC INFORMATION";
    case (unsigned int)0x52:
      return "READ TRACK INFORMATION";
    case (unsigned int)0x53:
      return "RESERVE TRACK";
    case (unsigned int)0x54:
      return "SEND OPC INFORMATION";
    case (unsigned int)0x55:
      return "MODE SELECT";
    case (unsigned int)0x5a:
      return "MODE SENSE";
    case (unsigned int)0x5b:
      return "CLOSE TRACK/SESSION";
    case (unsigned int)0x5c:
      return "READ BUFFER CAPACITY";
    case (unsigned int)0x5d:
      return "SEND CUE SHEET";
    case (unsigned int)0xa1:
      return "BLANK";
    case (unsigned int)0xaa:
      return "WRITE(12)";
    case (unsigned int)0xab:
      return "READ MEDIA SERIAL NUMBER";
    case (unsigned int)0xac:
      return "GET PERFORMANCE";
    case (unsigned int)0xad:
      return "READ DISC STRUCTURE";
    case (unsigned int)0xb6:
      return "SET STREAMING";
    case (unsigned int)0xb9:
      return "READ CD MSF";
    case (unsigned int)0xbb:
      return "SET CD SPEED";
    case (unsigned int)0xbe:
      return "READ CD";
    default:
      return "(NOT IN LIBBURN COMMAND LIST)";
  }
}

// scsi_enumerate_drives
// file libburn/sg.h line 33
signed int scsi_enumerate_drives(void)
{
  signed int ret;
  ret=single_enumerate(0);
  if(!(ret >= 0))
    return -1;

  else
    if(ret >= 1)
      return 1;

    else
    {
      sg_enumerate();
      ata_enumerate();
      add_proc_info_drives(0);
      return 1;
    }
}

// scsi_error
// file libburn/spc.c line 1594
enum response scsi_error(struct burn_drive *d, unsigned char *sense, signed int senselen)
{
  signed int key;
  signed int asc;
  signed int ascq;
  signed int ret = 0;
  char *msg = (char *)(void *)0;
  enum response resp;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
    resp=scsi_error_msg(d, sense, senselen, msg, &key, &asc, &ascq);

ex:
  ;
  if(ret == -1)
    resp = (enum response)FAIL;

  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return resp;
}

// scsi_error_msg
// file libburn/spc.h line 63
enum response scsi_error_msg(struct burn_drive *d, unsigned char *sense, signed int senselen, char *msg_data, signed int *key, signed int *asc, signed int *ascq)
{
  signed int ret;
  char *msg = msg_data;
  *ascq = -1;
  *asc = *ascq;
  *key = *asc;
  ret=spc_decode_sense(sense, senselen, key, asc, ascq);
  if(!(ret >= 1))
  {
    *ascq = -1;
    *asc = *ascq;
    *key = *asc;
  }

  sprintf(msg, "[%X %2.2X %2.2X] ", *key, *asc, *ascq);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(msg);
  msg = msg + (signed long int)return_value_strlen$1;
  static char key_def[16l][40l] = { { '(', 'n', 'o', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'c', ' ', 'e', 'r', 'r', 'o', 'r', ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'R', 'e', 'c', 'o', 'v', 'e', 'r', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'r', 'i', 'v', 'e', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'a', 'd', 'y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'M', 'e', 'd', 'i', 'u', 'm', ' ', 'e', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'r', 'i', 'v', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'I', 'l', 'l', 'e', 'g', 'a', 'l', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'r', 'i', 'v', 'e', ' ', 'e', 'v', 'e', 'n', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'D', 'a', 't', 'a', ' ', 'p', 'r', 'o', 't', 'e', 'c', 't', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'B', 'l', 'a', 'n', 'k', '/', 'N', 'o', 'n', 'b', 'l', 'a', 'n', 'k', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'V', 'e', 'n', 'd', 'o', 'r', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'c', ' ', 'c', 'o', 'd', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'C', 'o', 'p', 'y', ' ', 'a', 'b', 'o', 'r', 't', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'C', 'o', 'm', 'm', 'a', 'n', 'd', ' ', 'a', 'b', 'o', 'r', 't', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { '(', 'o', 'b', 's', 'o', 'l', 'e', 't', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'V', 'o', 'l', 'u', 'm', 'e', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 'M', 'i', 's', 'c', 'o', 'm', 'p', 'a', 'r', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { '(', 'r', 'e', 's', 'e', 'r', 'v', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  if(!((signed int)key_def[(signed long int)(0xf & *key)][0l] == 40))
  {
    sprintf(msg, "%s. ", (const void *)key_def[(signed long int)(*key & 0xf)]);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(msg);
    msg = msg + (signed long int)return_value_strlen$2;
  }

  switch(*asc)
  {
    case 0x00:
    {
      _Bool tmp_if_expr$3;
      if(*key >= 1)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = *ascq > 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        goto __CPROVER_DUMP_L147;

      sprintf(msg, "(No error reported by SCSI transaction)");
      return (enum response)GO_ON;
    }
    case 0x02:
    {
      sprintf(msg, "Not ready");
      goto return_retry;
    }
    case 0x04:
    {
      if(*ascq == 1)
        sprintf(msg, "Logical unit is in the process of becoming ready");

      else
        sprintf(msg, "Logical unit is not ready");
      goto return_retry;
    }
    case 0x06:
    {
      if(*ascq == 0)
        sprintf(msg, "No reference position found");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x08:
    {
      if(*ascq == 0)
        sprintf(msg, "Logical unit communication failure");

      else
        if(*ascq == 1)
          sprintf(msg, "Logical unit communication timeout");

        else
          if(*ascq == 2)
            sprintf(msg, "Logical unit communication parity error");

          else
            if(*ascq == 3)
              sprintf(msg, "Logical unit communication crc error");

            else
              goto __CPROVER_DUMP_L147;
      goto return_retry;
    }
    case 0x09:
    {
      if(*ascq == 0)
        sprintf(msg, "Track following error");

      else
        if(*ascq == 1)
          sprintf(msg, "Tracking servo failure");

        else
          if(*ascq == 2)
            sprintf(msg, "Focus servo failure");

          else
            if(*ascq == 3)
              sprintf(msg, "Spindle servo failure");

            else
              if(*ascq == 4)
                sprintf(msg, "Head select fault");

              else
                goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x0C:
    {
      if(*ascq == 0)
        sprintf(msg, "Write error");

      else
        if(*ascq == 1)
          sprintf(msg, "Write error, recovered with auto-allocation");

        else
          if(*ascq == 2)
            sprintf(msg, "Write error, auto reallocation failed");

          else
            if(*ascq == 7)
              sprintf(msg, "Write error, recovery needed");

            else
              if(*ascq == 8)
                sprintf(msg, "Write error, recovery failed");

              else
                if(*ascq == 9)
                  sprintf(msg, "Write error, loss of streaming");

                else
                  if(*ascq == 0x0f)
                    sprintf(msg, "Defects in error window");

                  else
                    goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x11:
    {
      if(*ascq == 0)
        sprintf(msg, "Unrecovered read error");

      else
        if(*ascq == 1)
          sprintf(msg, "Read retries exhausted");

        else
          if(*ascq == 2)
            sprintf(msg, "Error too long to correct");

          else
            if(*ascq == 5)
              sprintf(msg, "L-EC uncorrectable error");

            else
              if(*ascq == 6)
                sprintf(msg, "CIRC uncorrectable error");

              else
                goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x15:
    {
      if(*ascq == 0)
        sprintf(msg, "Random positioning error");

      else
        if(*ascq == 1)
          sprintf(msg, "Mechanical positioning error");

        else
          goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x1a:
    {
      if(*ascq == 0)
        sprintf(msg, "Parameter list length error");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x1b:
    {
      if(*ascq == 0)
        sprintf(msg, "Synchronous data transfer error");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x20:
    {
      if(*ascq == 0)
        sprintf(msg, "Invalid command operation code");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x21:
    {
      if(*ascq == 0)
        sprintf(msg, "Lba out of range");

      else
        if(*ascq == 1)
          sprintf(msg, "Invalid element address");

        else
          if(*ascq == 2)
            sprintf(msg, "Invalid address for write");

          else
            if(*ascq == 3)
              sprintf(msg, "Invalid write crossing layer jump");

            else
              goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x24:
    {
      if(*ascq == 0)
        sprintf(msg, "Invalid field in cdb");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x26:
    {
      if(*ascq == 0)
        sprintf(msg, "Invalid field in parameter list");

      else
        if(*ascq == 1)
          sprintf(msg, "Parameter not supported");

        else
          if(*ascq == 2)
            sprintf(msg, "Parameter value invalid");

          else
            goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x27:
    {
      sprintf(msg, "Write protected");
      break;
    }
    case 0x28:
    {
      if(*ascq == 0)
        sprintf(msg, "Medium may have changed");

      else
        if(*ascq == 2)
          sprintf(msg, "Format layer may have changed");

        else
          goto __CPROVER_DUMP_L147;
      goto return_retry;
    }
    case 0x29:
    {
      if(*ascq == 0)
        sprintf(msg, "Power on, reset, or bus device reset occured");

      else
        if(*ascq == 1)
          sprintf(msg, "Power on occured");

        else
          if(*ascq == 2)
            sprintf(msg, "Bus reset occured");

          else
            if(*ascq == 3)
              sprintf(msg, "Bus device reset function occured");

            else
              if(*ascq == 4)
                sprintf(msg, "Device internal reset");

              else
                goto __CPROVER_DUMP_L147;
      goto return_retry;
    }
    case 0x2c:
    {
      if(*ascq == 0)
        sprintf(msg, "Command sequence error");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x2e:
    {
      if(*ascq == 0)
        sprintf(msg, "Insufficient time for operation");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x30:
    {
      if(*ascq == 0)
        sprintf(msg, "Incompatible medium installed");

      else
        if(*ascq == 1)
          sprintf(msg, "Cannot read medium, unknown format");

        else
          if(*ascq == 2)
            sprintf(msg, "Cannot read medium, incompatible format");

          else
            if(*ascq == 4)
              sprintf(msg, "Cannot write medium, unknown format");

            else
              if(*ascq == 5)
                sprintf(msg, "Cannot write medium, incompatible format");

              else
                if(*ascq == 6)
                  sprintf(msg, "Cannot format medium, incompatible medium");

                else
                  if(*ascq == 7)
                    sprintf(msg, "Cleaning failure");

                  else
                    goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x31:
    {
      if(*ascq == 0)
        sprintf(msg, "Medium unformatted or format corrupted");

      else
        if(*ascq == 1)
          sprintf(msg, "Format command failed");

        else
          goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x32:
    {
      if(*ascq == 0)
        sprintf(msg, "No defect spare location available");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x3A:
    {
      if(*ascq == 0)
        sprintf(msg, "Medium not present");

      else
        if(*ascq == 1)
          sprintf(msg, "Medium not present, tray closed");

        else
          if(*ascq == 2)
            sprintf(msg, "Medium not present, tray open");

          else
            if(*ascq == 3)
              sprintf(msg, "Medium not present, loadable");

            else
              goto __CPROVER_DUMP_L147;
      d->status = (enum burn_disc_status)BURN_DISC_EMPTY;
      break;
    }
    case 0x3E:
    {
      if(*ascq == 1)
        sprintf(msg, "Logical unit failure");

      else
        if(*ascq == 2)
          sprintf(msg, "Timeout on logical unit");

        else
          goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x44:
    {
      if(*ascq == 0)
        sprintf(msg, "Internal target failure");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x51:
    {
      if(*ascq == 0)
        sprintf(msg, "Erase failure");

      else
        if(*ascq == 1)
          sprintf(msg, "Erase failure. Incomplete erase operation");

        else
          goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x57:
    {
      if(*ascq == 0)
        sprintf(msg, "Unable to recover Table-of-Content");

      else
        goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x63:
    {
      if(*ascq == 0)
        sprintf(msg, "End of user area encountered on this track");

      else
        if(*ascq == 1)
          sprintf(msg, "Packet does not fit in available space");

        else
          goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x64:
    {
      if(*ascq == 0)
        sprintf(msg, "Illegal mode for this track");

      else
        if(*ascq == 1)
          sprintf(msg, "Invalid packet size");

        else
          goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x72:
    {
      if(*ascq == 0)
        sprintf(msg, "Session fixation error");

      else
        if(*ascq == 1)
          sprintf(msg, "Session fixation error writing lead-in");

        else
          if(*ascq == 2)
            sprintf(msg, "Session fixation error writing lead-out");

          else
            if(*ascq == 3)
              sprintf(msg, "Session fixation error, incomplete track in session");

            else
              if(*ascq == 4)
                sprintf(msg, "Empty or partially written reserved track");

              else
                if(*ascq == 5)
                  sprintf(msg, "No more track reservations allowed");

                else
                  goto __CPROVER_DUMP_L147;
      break;
    }
    case 0x73:
    {
      if(*ascq == 0)
        sprintf(msg, "CD control error");

      else
        if(*ascq == 1)
          sprintf(msg, "Power calibration area almost full");

        else
          if(*ascq == 2)
            sprintf(msg, "Power calibration area is full");

          else
            if(*ascq == 3)
              sprintf(msg, "Power calibration area error");

            else
              if(*ascq == 4)
                sprintf(msg, "Program memory area update failure");

              else
                if(*ascq == 5)
                  sprintf(msg, "Program memory area is full");

                else
                  goto __CPROVER_DUMP_L147;
      break;
    }
    default:
    {

    __CPROVER_DUMP_L147:
      ;
      sprintf(msg_data, "See MMC specs: Sense Key %X \"%s\", ASC %2.2X ASCQ %2.2X", *key & 0xf, (const void *)key_def[(signed long int)(*key & 0xf)], *asc, *ascq);
    }
  }

return_fail:
  ;
  strcat(msg, ".");
  if(*key == 1)
    return (enum response)GO_ON;

  else
  {
    return (enum response)FAIL;

  return_retry:
    ;
    strcat(msg, ".");
    if(*key == 1)
      return (enum response)GO_ON;

    else
      return (enum response)RETRY;
  }
}

// scsi_eval_cmd_outcome
// file libburn/spc.h line 123
signed int scsi_eval_cmd_outcome(struct burn_drive *d, struct command *c, void *fp, unsigned char *sense, signed int sense_len, signed long int start_time, signed int timeout_ms, signed int loop_count, signed int flag)
{
  enum response outcome;
  signed int done = -1;
  signed int usleep_time;
  char *msg = (char *)(void *)0;
  if(!((3 & burn_sg_log_scsi) == 0))
    scsi_log_err(d, c, fp, sense, sense_len, (signed int)(sense_len > 0) | flag & 2);

  if(!(sense_len >= 1))
    done = 1;

  else
  {
    outcome=scsi_error(d, sense, sense_len);
    _Bool tmp_if_expr$4;
    if((signed int)outcome == RETRY)
      tmp_if_expr$4 = c->retry != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if((1 & flag) == 0 && tmp_if_expr$4)
    {
      _Bool tmp_if_expr$1;
      if((signed int)c->opcode[0l] == 0x2A)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)c->opcode[(signed long int)0] == 0xAA ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        usleep_time = 0 + loop_count * 2000;
        if(usleep_time >= 25001)
          usleep_time = 25000;

      }

      else
      {
        usleep_time = 100000 + loop_count * 100000;
        if(usleep_time >= 500001)
          usleep_time = 500000;

      }
      signed long int return_value_time$3;
      return_value_time$3=time((signed long int *)(void *)0);
      if(!((signed long int)(timeout_ms / 1000 + 1) >= return_value_time$3 + (signed long int)(usleep_time / 1000000) + -start_time))
      {
        done = -1;
        void *return_value_burn_alloc_mem$2;
        return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)320, 0);
        msg = (char *)return_value_burn_alloc_mem$2;
        if(msg == ((char *)NULL))
          goto ex;

        done = 1;
        sprintf(msg, "Timeout exceed (%d ms). Retry canceled.\n", timeout_ms);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002018a, 0x60000000, 0x30000000, msg, 0, 0);
        goto err_ex;
      }

      if(!(d->cancel == 0))
      {
        done = 1;
        goto ex;
      }

      if(usleep_time >= 1)
        usleep((unsigned int)usleep_time);

      if(!(d->cancel == 0))
      {
        done = 1;
        goto ex;
      }

      if(!((3 & burn_sg_log_scsi) == 0))
        scsi_log_cmd(c, fp, 0);

      done = 0;
      goto ex;
    }

    else
      if((signed int)outcome == RETRY)
        done = 1;

      else
        if((signed int)outcome == GO_ON)
        {
          done = 1;
          goto ex;
        }

        else
          if((signed int)outcome == FAIL)
            done = 1;


  err_ex:
    ;
    c->error = 1;
    scsi_notify_error(d, c, sense, sense_len, 0);
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return done;
}

// scsi_init_command
// file libburn/spc.h line 73
signed int scsi_init_command(struct command *c, unsigned char *opcode, signed int oplen)
{
  if(oplen >= 17)
    return 0;

  else
  {
    memset((void *)c, 0, sizeof(struct command) /*200ul*/ );
    memcpy((void *)c->opcode, (const void *)opcode, (unsigned long int)oplen);
    c->oplen = oplen;
    c->dir = 2;
    c->dxfer_len = -1;
    memset((void *)c->sense, 0, sizeof(unsigned char [128l]) /*128ul*/ );
    c->error = 0;
    c->retry = 0;
    c->page = (struct buffer *)(void *)0;
    c->timeout = 30000;
    return 1;
  }
}

// scsi_log_cmd
// file libburn/spc.h line 90
signed int scsi_log_cmd(struct command *c, void *fp_in, signed int flag)
{
  signed int ret;
  signed int bytes = 0;
  unsigned char *data = (unsigned char *)(void *)0;
  if(!(c->page == ((struct buffer *)NULL)))
  {
    data = c->page->data;
    bytes = c->page->bytes;
  }

  ret=scsi_log_command(c->opcode, c->oplen, c->dir, data, bytes, fp_in, flag);
  return ret;
}

// scsi_log_command
// file libburn/spc.h line 80
signed int scsi_log_command(unsigned char *opcode, signed int oplen, signed int data_dir, unsigned char *data, signed int bytes, void *fp_in, signed int flag)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)fp_in;
  if(!(fp == ((struct _IO_FILE *)NULL)) && (fp == stderr || !((1 & burn_sg_log_scsi) == 0)))
  {
    scsi_show_command(opcode, oplen, data_dir, data, bytes, (void *)fp, 0);
    if(!((4 & burn_sg_log_scsi) == 0))
      fflush(fp);

  }

  if((2 & burn_sg_log_scsi) == 0 || fp == stderr)
    return 1;

  else
  {
    scsi_log_command(opcode, oplen, data_dir, data, bytes, (void *)stderr, 0);
    return 1;
  }
}

// scsi_log_err
// file libburn/spc.c line 1924
signed int scsi_log_err(struct burn_drive *d, struct command *c, void *fp_in, unsigned char *sense, signed int sense_len, signed int flag)
{
  signed int ret;
  unsigned char *data = (unsigned char *)(void *)0;
  if(!(c->page == ((struct buffer *)NULL)))
    data = c->page->data;

  ret=scsi_log_reply(c->opcode, c->dir, data, c->dxfer_len, fp_in, sense, sense_len, c->end_time - c->start_time, flag);
  return ret;
}

// scsi_log_message
// file libburn/spc.h line 111
signed int scsi_log_message(struct burn_drive *d, void *fp_in, char *msg, signed int flag)
{
  signed int ret;
  struct _IO_FILE *fp = (struct _IO_FILE *)fp_in;
  if(!(fp == ((struct _IO_FILE *)NULL)) && (fp == stderr || !((1 & burn_sg_log_scsi) == 0)))
  {
    fprintf(fp, "%s\n", msg);
    if(!((4 & burn_sg_log_scsi) == 0))
      fflush(fp);

  }

  if((2 & burn_sg_log_scsi) == 0 || fp == stderr)
    return 1;

  else
  {
    ret=scsi_log_message(d, (void *)stderr, msg, flag);
    return ret;
  }
}

// scsi_log_reply
// file libburn/spc.h line 97
signed int scsi_log_reply(unsigned char *opcode, signed int data_dir, unsigned char *data, signed int dxfer_len, void *fp_in, unsigned char *sense, signed int sense_len, double duration, signed int flag)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)fp_in;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int i;
  signed int l;
  double return_value_burn_get_time$2;
  if(!(fp == ((struct _IO_FILE *)NULL)) && (fp == stderr || !((1 & burn_sg_log_scsi) == 0)))
  {
    if(!((1 & flag) == 0))
    {
      l = 18;
      _Bool tmp_if_expr$1;
      if((0x7f & (signed int)*sense) == 0x72)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = ((signed int)sense[(signed long int)0] & 0x7f) == 0x73 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        l = (signed int)sense[(signed long int)7] + 7 + 1;

      if(!(sense_len >= l))
        l = sense_len;

      fprintf(fp, "+++ sense data =");
      i = 0;
      for( ; !(i >= l); i = i + 1)
        fprintf(fp, " %2.2X", sense[(signed long int)i]);
      fprintf(fp, "\n");
      spc_decode_sense(sense, 0, &key, &asc, &ascq);
      fprintf(fp, "+++ key=%X  asc=%2.2Xh  ascq=%2.2Xh\n", (unsigned int)key, (unsigned int)asc, (unsigned int)ascq);
    }

    else
      scsi_show_command_reply(opcode, data_dir, data, dxfer_len, (void *)fp, 0);
    if((2 & flag) == 0)
    {
      return_value_burn_get_time$2=burn_get_time(0);
      fprintf(fp, " %8.f us     [ %.f ]\n", duration * 1.0e6, (return_value_burn_get_time$2 - lib_start_time) * 1.0e6);
    }

    if(!((4 & burn_sg_log_scsi) == 0))
      fflush(fp);

  }

  if((2 & burn_sg_log_scsi) == 0 || fp == stderr)
    return 1;

  else
  {
    scsi_log_reply(opcode, data_dir, data, dxfer_len, (void *)stderr, sense, sense_len, duration, flag);
    return 1;
  }
}

// scsi_log_text
// file libburn/spc.c line 1838
signed int scsi_log_text(char *text, void *fp_in, signed int flag)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)fp_in;
  if(!(fp == ((struct _IO_FILE *)NULL)) && (fp == stderr || !((1 & burn_sg_log_scsi) == 0)))
  {
    fprintf(fp, "%s\n", text);
    if(!((4 & burn_sg_log_scsi) == 0))
      fflush(fp);

  }

  if((2 & burn_sg_log_scsi) == 0 || fp == stderr)
    return 1;

  else
  {
    fprintf(stderr, "%s\n", text);
    return 1;
  }
}

// scsi_notify_error
// file libburn/spc.h line 69
signed int scsi_notify_error(struct burn_drive *d, struct command *c, unsigned char *sense, signed int senselen, signed int flag)
{
  signed int key = -1;
  signed int asc = -1;
  signed int ascq = -1;
  signed int ret;
  char *msg = (char *)(void *)0;
  char *scsi_msg = (char *)(void *)0;
  _Bool tmp_if_expr$1;
  if(d->silent_on_scsi_error == 1)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = d->silent_on_scsi_error == 2 ? (_Bool)1 : (_Bool)0;
  char *return_value_scsi_command_name$4;
  if(tmp_if_expr$1)
    ret = 1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)320, 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
      scsi_msg = (char *)return_value_burn_alloc_mem$3;
      if(scsi_msg == ((char *)NULL))
        ret = -1;

      else
      {
        scsi_error_msg(d, sense, senselen, scsi_msg, &key, &asc, &ascq);
        if((1 & flag) == 0)
        {
          if((signed int)c->opcode[0l] == 0)
          {
            ret = 1;
            goto ex;
          }

          if((signed int)c->opcode[0l] == 0x51)
          {
            if(asc == 0x3A && key == 0x2 && ascq >= 0 && !(ascq >= 3))
            {
              ret = 1;
              goto ex;
            }

          }

          if(!(asc == 0) || !(ascq == 0) || !(key == 0))
            goto __CPROVER_DUMP_L8;

          ret = 1;
        }

        else
        {

        __CPROVER_DUMP_L8:
          ;
          return_value_scsi_command_name$4=scsi_command_name((unsigned int)c->opcode[(signed long int)0], 0);
          sprintf(msg, "SCSI error condition on command %2.2Xh %s: ", c->opcode[(signed long int)0], return_value_scsi_command_name$4);
          strcat(msg, scsi_msg);
          _Bool tmp_if_expr$5;
          if(!((2 & flag) == 0))
            tmp_if_expr$5 = d->silent_on_scsi_error != 3 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          ret=libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002010f, tmp_if_expr$5 ? 0x68000000 : 0x10000000, 0x30000000, msg, 0, 0);
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(scsi_msg == ((char *)NULL)))
    free((void *)(char *)scsi_msg);

  return ret;
}

// scsi_show_cmd_text
// file libburn/spc.c line 1782
signed int scsi_show_cmd_text(struct command *c, void *fp_in, signed int flag)
{
  signed int return_value_scsi_show_command$1;
  return_value_scsi_show_command$1=scsi_show_command(c->opcode, c->oplen, c->dir, c->page->data, c->page->bytes, fp_in, flag);
  return return_value_scsi_show_command$1;
}

// scsi_show_command
// file libburn/spc.c line 1740
signed int scsi_show_command(unsigned char *opcode, signed int oplen, signed int dir, unsigned char *data, signed int bytes, void *fp_in, signed int flag)
{
  signed int i;
  struct _IO_FILE *fp = (struct _IO_FILE *)fp_in;
  char *return_value_scsi_command_name$1;
  return_value_scsi_command_name$1=scsi_command_name((unsigned int)opcode[(signed long int)0], 0);
  fprintf(fp, "\n%s\n", return_value_scsi_command_name$1);
  i = 0;
  for( ; !(i >= 16) && !(i >= oplen); i = i + 1)
    fprintf(fp, "%2.2x ", opcode[(signed long int)i]);
  if(i >= 1)
    fprintf(fp, "\n");

  signed int return_value_mmc_four_char_to_int$2;
  signed int return_value_mmc_four_char_to_int$3;
  signed int return_value_mmc_four_char_to_int$4;
  if(!((1 & flag) == 0))
    return 1;

  else
  {
    if((signed int)*opcode == 0x2A)
    {
      if(oplen >= 9 && !((2 & flag) == 0))
      {
        return_value_mmc_four_char_to_int$2=mmc_four_char_to_int(opcode + (signed long int)2);
        fprintf(fp, "%d -> %d\n", (signed int)opcode[(signed long int)7] << 8 | (signed int)opcode[(signed long int)8], return_value_mmc_four_char_to_int$2);
      }

    }

    else
      if((signed int)*opcode == 0xAA)
      {
        if(oplen >= 10 && !((2 & flag) == 0))
        {
          return_value_mmc_four_char_to_int$3=mmc_four_char_to_int(opcode + (signed long int)6);
          return_value_mmc_four_char_to_int$4=mmc_four_char_to_int(opcode + (signed long int)2);
          fprintf(fp, "%d -> %d\n", return_value_mmc_four_char_to_int$3, return_value_mmc_four_char_to_int$4);
        }

      }

      else
        if((1 & flag) == 0 && dir == 0)
        {
          fprintf(fp, "To drive: %db\n", bytes);
          i = 0;
          for( ; !(i >= bytes); i = i + 1)
            fprintf(fp, "%2.2x%c", data[(signed long int)i], i % 20 == 19 ? 10 : 32);
          if(!(i % 20 == 0))
            fprintf(fp, "\n");

        }

    return 1;
  }
}

// scsi_show_command_reply
// file libburn/spc.c line 1790
signed int scsi_show_command_reply(unsigned char *opcode, signed int data_dir, unsigned char *data, signed int dxfer_len, void *fp_in, signed int flag)
{
  signed int i;
  struct _IO_FILE *fp = (struct _IO_FILE *)fp_in;
  if(!(data_dir == 1))
    return 2;

  else
  {
    _Bool tmp_if_expr$1;
    if((signed int)*opcode == 0x28)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)opcode[(signed long int)0] == 0x3C ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)opcode[(signed long int)0] == 0xA8 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)opcode[(signed long int)0] == 0xB9 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$4;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)opcode[(signed long int)0] == 0xBE ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      return 2;

    else
    {
      fprintf(fp, "From drive: %db\n", dxfer_len);
      i = 0;
      for( ; !(i >= dxfer_len); i = i + 1)
        fprintf(fp, "%2.2x%c", data[(signed long int)i], i % 20 == 19 ? 10 : 32);
      if(!(i % 20 == 0))
        fprintf(fp, "\n");

      return 1;
    }
  }
}

// search_pack
// file libburn/cdtext.c line 1180
static signed int search_pack(unsigned char *text_packs, signed int num_packs, signed int start_no, signed int pack_type, signed int block, unsigned char **found_pack, signed int *found_no, signed int flag)
{
  signed int i = start_no;
  for( ; !(i >= num_packs); i = i + 1)
  {
    if(pack_type >= 0)
    {
      if(!((signed int)text_packs[(signed long int)(18 * i)] == pack_type))
        goto __CPROVER_DUMP_L4;

    }

    if(block >= 0)
    {
      if(!(((signed int)text_packs[(signed long int)(18 * i + 3)] >> 4 & 7) == block))
        goto __CPROVER_DUMP_L4;

    }

    *found_pack = text_packs + (signed long int)(i * 18);
    *found_no = i;
    return 1;

  __CPROVER_DUMP_L4:
    ;
  }
  *found_pack = (unsigned char *)(void *)0;
  *found_no = num_packs;
  return 0;
}

// sector_data
// file libburn/sector.c line 723
signed int sector_data(struct burn_write_opts *o, struct burn_track *t, signed int psub)
{
  struct burn_drive *d = o->drive;
  unsigned char subs[96l];
  unsigned char *data;
  data=get_sector(o, t, t->mode);
  signed int return_value;
  if(data == ((unsigned char *)NULL))
    return 0;

  else
  {
    signed int return_value_convert_data$1;
    return_value_convert_data$1=convert_data(o, t, t->mode, data);
    if(!(return_value_convert_data$1 >= 1))
      return 0;

    else
    {
      _Bool tmp_if_expr$2;
      if(!(t->open_ended == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = t->end_on_premature_eoi != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(t->track_data_done == 0)
          goto __CPROVER_DUMP_L5;

        unget_sector(o, t->mode);
        return 2;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(!(t->entry == ((struct burn_toc_entry *)NULL)))
        {
          if(t->source->read_sub == ((signed int (*)(struct burn_source *, unsigned char *, signed int))NULL))
            subcode_user(o, subs, t->entry->point, t->entry->control, (unsigned char)1, &t->isrc, psub);

          else
          {
            return_value=t->source->read_sub(t->source, subs, 96);
            if(return_value == 0)
              subcode_user(o, subs, t->entry->point, t->entry->control, (unsigned char)1, &t->isrc, psub);

          }
        }

        convert_subs(o, t->mode, subs, data);
        signed int return_value_sector_headers$3;
        return_value_sector_headers$3=sector_headers(o, data, t->mode, 0);
        if(!(return_value_sector_headers$3 >= 1))
          return 0;

        else
        {
          d->alba = d->alba + 1;
          d->rlba = d->rlba + 1;
          return 1;
        }
      }
    }
  }
}

// sector_get_outmode
// file libburn/options.c line 132 function burn_write_opts_set_write_type
signed int sector_get_outmode(enum burn_write_types write_type, enum burn_block_types block_type)
{
  if((signed int)write_type == BURN_WRITE_TAO || (signed int)write_type == BURN_WRITE_SAO)
    return 0;

  else
    switch((signed int)block_type)
    {
      case BURN_BLOCK_RAW0:
        return 1 << 1;
      case BURN_BLOCK_RAW16:
        return 1 << 1 | 1 << 10;
      case BURN_BLOCK_RAW96P:
        return 1 << 1 | 1 << 11;
      case BURN_BLOCK_RAW96R:
        return 1 << 1 | 1 << 12;
      case BURN_BLOCK_MODE1:
        return 1 << 2;
      default:
        return -1;
    }
}

// sector_headers
// file libburn/sector.c line 809
signed int sector_headers(struct burn_write_opts *o, unsigned char *out, signed int mode, signed int leadin)
{
  struct burn_drive *d = o->drive;
  unsigned int crc;
  signed int min;
  signed int sec;
  signed int frame;
  signed int modebyte = -1;
  signed int ret;
  ret=sector_headers_is_ok(o, mode);
  if(!(ret == 2))
    return (signed int)!(!(ret != 0));

  else
  {
    modebyte = 1;
    out[(signed long int)0] = (unsigned char)0;
    memset((void *)(out + (signed long int)1), 0xFF, (unsigned long int)10);
    out[(signed long int)11] = (unsigned char)0;
    if(!(leadin == 0))
    {
      burn_lba_to_msf(d->rlba, &min, &sec, &frame);
      signed int return_value_dec_to_bcd$1;
      return_value_dec_to_bcd$1=dec_to_bcd(min);
      out[(signed long int)12] = (unsigned char)(return_value_dec_to_bcd$1 + 0xA0);
      signed int return_value_dec_to_bcd$2;
      return_value_dec_to_bcd$2=dec_to_bcd(sec);
      out[(signed long int)13] = (unsigned char)return_value_dec_to_bcd$2;
      signed int return_value_dec_to_bcd$3;
      return_value_dec_to_bcd$3=dec_to_bcd(frame);
      out[(signed long int)14] = (unsigned char)return_value_dec_to_bcd$3;
      out[(signed long int)15] = (unsigned char)modebyte;
    }

    else
    {
      burn_lba_to_msf(d->alba, &min, &sec, &frame);
      signed int return_value_dec_to_bcd$4;
      return_value_dec_to_bcd$4=dec_to_bcd(min);
      out[(signed long int)12] = (unsigned char)return_value_dec_to_bcd$4;
      signed int return_value_dec_to_bcd$5;
      return_value_dec_to_bcd$5=dec_to_bcd(sec);
      out[(signed long int)13] = (unsigned char)return_value_dec_to_bcd$5;
      signed int return_value_dec_to_bcd$6;
      return_value_dec_to_bcd$6=dec_to_bcd(frame);
      out[(signed long int)14] = (unsigned char)return_value_dec_to_bcd$6;
      out[(signed long int)15] = (unsigned char)modebyte;
    }
    if(!((4 & mode) == 0))
    {
      crc=crc_32(out, 2064);
      out[(signed long int)2064] = (unsigned char)(crc & (unsigned int)0xFF);
      crc = crc >> 8;
      out[(signed long int)2065] = (unsigned char)(crc & (unsigned int)0xFF);
      crc = crc >> 8;
      out[(signed long int)2066] = (unsigned char)(crc & (unsigned int)0xFF);
      crc = crc >> 8;
      out[(signed long int)2067] = (unsigned char)(crc & (unsigned int)0xFF);
    }

    if(!((4 & mode) == 0))
    {
      memset((void *)(out + (signed long int)2068), 0, (unsigned long int)8);
      burn_rspc_parity_p(out);
      burn_rspc_parity_q(out);
    }

    burn_ecma130_scramble(out);
    return 1;
  }
}

// sector_headers_is_ok
// file libburn/sector.c line 789
signed int sector_headers_is_ok(struct burn_write_opts *o, signed int mode)
{
  if(!((64 & mode) == 0))
    return 1;

  else
    if((signed int)o->write_type == BURN_WRITE_SAO)
      return 1;

    else
      if((signed int)o->write_type == BURN_WRITE_TAO)
        return 1;

      else
        if(!((4 & mode) == 0))
          return 2;

        else
          return 0;
}

// sector_identify
// file libburn/sector.c line 941
signed int sector_identify(unsigned char *data)
{
  return 1 << 2;
}

// sector_lout
// file libburn/sector.c line 703
signed int sector_lout(struct burn_write_opts *o, unsigned char control, signed int mode)
{
  struct burn_drive *d = o->drive;
  unsigned char subs[96l];
  unsigned char *data;
  data=get_sector(o, (struct burn_track *)(void *)0, mode);
  if(data == ((unsigned char *)NULL))
    return 0;

  else
  {
    signed int return_value_convert_data$1;
    return_value_convert_data$1=convert_data(o, (struct burn_track *)(void *)0, mode, data);
    if(!(return_value_convert_data$1 >= 1))
      return 0;

    else
    {
      subcode_lout(o, control, subs);
      convert_subs(o, mode, subs, data);
      signed int return_value_sector_headers$2;
      return_value_sector_headers$2=sector_headers(o, data, mode, 0);
      if(!(return_value_sector_headers$2 >= 1))
        return 0;

      else
      {
        d->alba = d->alba + 1;
        d->rlba = d->rlba + 1;
        return 1;
      }
    }
  }
}

// sector_postgap
// file libburn/sector.c line 517
signed int sector_postgap(struct burn_write_opts *o, unsigned char tno, unsigned char control, signed int mode)
{
  struct burn_drive *d = o->drive;
  unsigned char subs[96l];
  unsigned char *data;
  data=get_sector(o, (struct burn_track *)(void *)0, mode);
  if(data == ((unsigned char *)NULL))
    return 0;

  else
  {
    signed int return_value_convert_data$1;
    return_value_convert_data$1=convert_data(o, (struct burn_track *)(void *)0, mode, data);
    if(!(return_value_convert_data$1 >= 1))
      return 0;

    else
    {
      subcode_user(o, subs, tno, control, (unsigned char)1, (struct isrc *)(void *)0, 1);
      convert_subs(o, mode, subs, data);
      signed int return_value_sector_headers$2;
      return_value_sector_headers$2=sector_headers(o, data, mode, 0);
      if(!(return_value_sector_headers$2 >= 1))
        return 0;

      else
      {
        d->alba = d->alba + 1;
        d->rlba = d->rlba + 1;
        return 1;
      }
    }
  }
}

// sector_pregap
// file libburn/sector.c line 496
signed int sector_pregap(struct burn_write_opts *o, unsigned char tno, unsigned char control, signed int mode)
{
  struct burn_drive *d = o->drive;
  unsigned char *data;
  unsigned char subs[96l];
  data=get_sector(o, (struct burn_track *)(void *)0, mode);
  if(data == ((unsigned char *)NULL))
    return 0;

  else
  {
    signed int return_value_convert_data$1;
    return_value_convert_data$1=convert_data(o, (struct burn_track *)(void *)0, mode, data);
    if(!(return_value_convert_data$1 >= 1))
      return 0;

    else
    {
      subcode_user(o, subs, tno, control, (unsigned char)0, (struct isrc *)(void *)0, 1);
      convert_subs(o, mode, subs, data);
      signed int return_value_sector_headers$2;
      return_value_sector_headers$2=sector_headers(o, data, mode, 0);
      if(!(return_value_sector_headers$2 >= 1))
        return 0;

      else
      {
        d->alba = d->alba + 1;
        d->rlba = d->rlba - 1;
        return 1;
      }
    }
  }
}

// sector_toc
// file libburn/sector.c line 476
signed int sector_toc(struct burn_write_opts *o, signed int mode)
{
  struct burn_drive *d = o->drive;
  unsigned char *data;
  unsigned char subs[96l];
  data=get_sector(o, (struct burn_track *)(void *)0, mode);
  if(data == ((unsigned char *)NULL))
    return 0;

  else
  {
    signed int return_value_convert_data$1;
    return_value_convert_data$1=convert_data(o, (struct burn_track *)(void *)0, mode, data);
    if(!(return_value_convert_data$1 >= 1))
      return 0;

    else
    {
      subcode_toc(d, mode, subs);
      convert_subs(o, mode, subs, data);
      signed int return_value_sector_headers$2;
      return_value_sector_headers$2=sector_headers(o, data, mode, 1);
      if(!(return_value_sector_headers$2 >= 1))
        return 0;

      else
      {
        d->alba = d->alba + 1;
        d->rlba = d->rlba + 1;
        return 1;
      }
    }
  }
}

// sector_write_buffer
// file libburn/sector.c line 238
signed int sector_write_buffer(struct burn_drive *d, struct burn_track *track, signed int flag)
{
  signed int err;
  signed int i;
  struct buffer *out = d->buffer;
  if(!(out->sectors >= 1))
    return 2;

  else
  {
    err=d->write(d, d->nwa, out);
    if(err == 1)
      return 0;

    else
    {
      if(!(track == ((struct burn_track *)NULL)))
      {
        track->writecount = track->writecount + (signed long int)out->bytes;
        track->written_sectors = track->written_sectors + (signed long int)out->sectors;
        i = d->progress.index;
        if(!(1 + i >= (signed int)track->indices))
        {
          if(out->sectors + d->nwa >= track->index[(signed long int)(1 + i)])
          {
            d->progress.index = i + 1;
            i = i + 1;
          }

        }

      }

      d->progress.buffered_bytes = d->progress.buffered_bytes + (signed long int)out->bytes;
      d->nwa = d->nwa + out->sectors;
      out->bytes = 0;
      out->sectors = 0;
      return 1;
    }
  }
}

// sg_close_drive
// file libburn/sg-linux.c line 807
static signed int sg_close_drive(struct burn_drive *d)
{
  signed int ret;
  signed int return_value_burn_drive_is_open$1;
  return_value_burn_drive_is_open$1=burn_drive_is_open(d);
  if(return_value_burn_drive_is_open$1 == 0)
    return 0;

  else
  {
    sg_release_siblings(d->sibling_fds, d->sibling_fnames, &d->sibling_count);
    ret=sg_close_drive_fd(d->devname, d->global_index, &d->fd, 0);
    return ret;
  }
}

// sg_close_drive_fd
// file libburn/sg-linux.c line 597
static signed int sg_close_drive_fd(char *fname, signed int driveno, signed int *fd, signed int sorry)
{
  signed int ret;
  signed int os_errno;
  signed int sevno = 0x10000000;
  char *msg = (char *)(void *)0;
  signed int *return_value___errno_location$2;
  if(!(*fd >= 0))
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(4096 + 100), 0);
    msg = (char *)return_value_burn_alloc_mem$1;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      ret=close(*fd);
      *fd = -1337;
      if(!(ret == -1))
        ret = 1;

      else
      {
        return_value___errno_location$2=__errno_location();
        os_errno = *return_value___errno_location$2;
        sprintf(msg, "Encountered error when closing drive '%s'", fname);
        if(!(sorry == 0))
          sevno = 0x60000000;

        libdax_msgs_submit(libdax_messenger, driveno, 0x00020002, sevno, 0x30000000, msg, os_errno, 0);
        ret = 0;
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// sg_dispose_drive
// file libburn/sg.h line 81
signed int sg_dispose_drive(struct burn_drive *d, signed int flag)
{
  return 1;
}

// sg_drive_is_open
// file libburn/sg-linux.c line 1687
signed int sg_drive_is_open(struct burn_drive *d)
{
  if(d->fd == -1337)
    return 0;

  else
    if(!(d->fd >= 0))
      return 0;

    else
      return 1;
}

// sg_enumerate
// file libburn/sg-linux.c line 1164
static void sg_enumerate(void)
{
  signed int i;
  signed int ret;
  signed int fd = -1;
  signed int bus_no = -1;
  signed int host_no = -1;
  signed int channel_no = -1;
  signed int target_no = -1;
  signed int lun_no = -1;
  char fname[17l];
  sg_select_device_family();
  if(!(linux_sg_enumerate_debug == 0))
    fprintf(stderr, "libburn_debug: linux_sg_device_family = %s\n", (const void *)linux_sg_device_family);

  if(!((signed int)linux_sg_device_family[0l] == 0))
  {
    i = 0;
    for( ; !(i >= 32); i = i + 1)
    {
      sprintf(fname, linux_sg_device_family, i);
      sg_exchange_scd_for_sr(fname, 0);
      if(!(linux_sg_enumerate_debug == 0))
        fprintf(stderr, "libburn_debug: %s : ", (const void *)fname);

      signed int return_value_burn_drive_is_banned$1;
      return_value_burn_drive_is_banned$1=burn_drive_is_banned(fname);
      if(!(return_value_burn_drive_is_banned$1 == 0))
      {
        if(!(linux_sg_enumerate_debug == 0))
          fprintf(stderr, "not in whitelist\n");

      }

      else
      {
        fd=sg_open_for_enumeration(fname, 0);
        if(fd >= 0)
        {
          ret=is_scsi_drive(fname, fd, &bus_no, &host_no, &channel_no, &target_no, &lun_no);
          if(!(ret >= 0))
            break;

          if(!(ret == 0))
          {
            if(!(linux_sg_enumerate_debug == 0))
              fprintf(stderr, "accepting as SCSI %d,%d,%d,%d bus=%d\n", host_no, channel_no, target_no, lun_no, bus_no);

            enumerate_common(fname, fd, bus_no, host_no, channel_no, target_no, lun_no);
          }

        }

      }
    }
  }

}

// sg_evaluate_kernel
// file libburn/sg-linux.c line 292
static void sg_evaluate_kernel(void)
{
  struct utsname buf;
  if(!(sg_kernel_age >= 0))
  {
    sg_kernel_age = 0;
    signed int return_value_uname$1;
    return_value_uname$1=uname(&buf);
    if(!(return_value_uname$1 == -1))
    {
      sg_kernel_age = 1;
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(buf.release, "2.6");
      if(return_value_strcmp$2 >= 0)
        sg_kernel_age = 2;

    }

  }

}

// sg_exchange_scd_for_sr
// file libburn/sg-linux.c line 342
static signed int sg_exchange_scd_for_sr(char *fname, signed int flag)
{
  struct stat stbuf;
  char scd[17l];
  char *msg = (char *)(void *)0;
  _Bool tmp_if_expr$2;
  signed int return_value_strncmp$1;
  if(!(burn_sg_use_family == 0))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strncmp$1=strncmp(fname, "/dev/sr", (unsigned long int)7);
    tmp_if_expr$2 = return_value_strncmp$1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  unsigned long int return_value_strlen$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_strlen$3=strlen(fname);
    tmp_if_expr$4 = return_value_strlen$3 > (unsigned long int)9 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$6;
  unsigned long int return_value_strlen$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_strlen$5=strlen(fname);
    tmp_if_expr$6 = return_value_strlen$5 < (unsigned long int)8 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$6)
    return 2;

  else
  {
    _Bool tmp_if_expr$7;
    if(!((signed int)fname[7l] >= 48))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = (signed int)fname[(signed long int)7] > 57 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      return 2;

    else
    {
      if(!((signed int)fname[8l] == 0))
      {
        _Bool tmp_if_expr$8;
        if(!((signed int)fname[7l] >= 48))
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)fname[(signed long int)7] > 57 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          return 2;

      }

      signed int return_value_stat$9;
      return_value_stat$9=stat(fname, &stbuf);
      if(!(return_value_stat$9 == -1))
        return 2;

      else
      {
        strcpy(scd, "/dev/scd");
        strcpy(scd + (signed long int)8, fname + (signed long int)7);
        signed int return_value_stat$10;
        return_value_stat$10=stat(scd, &stbuf);
        if(return_value_stat$10 == -1)
          return 2;

        else
        {
          unsigned long int return_value_strlen$11;
          return_value_strlen$11=strlen(scd);
          unsigned long int return_value_strlen$12;
          return_value_strlen$12=strlen(fname);
          void *return_value_calloc$13;
          return_value_calloc$13=calloc(return_value_strlen$11 + return_value_strlen$12 + (unsigned long int)80, (unsigned long int)1);
          msg = (char *)return_value_calloc$13;
          if(!(msg == ((char *)NULL)))
          {
            sprintf(msg, "%s substitutes for non-existent %s", (const void *)scd, fname);
            libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
            free((void *)msg);
          }

          strcpy(fname, scd);
          return 1;
        }
      }
    }
  }
}

// sg_fcntl_lock
// file libburn/sg-linux.c line 653
static signed int sg_fcntl_lock(signed int *fd, char *fd_name, signed int l_type, signed int verbous)
{
  struct flock lockthing;
  char msg[81l];
  signed int ret;
  if(burn_sg_fcntl_f_setlk == 0)
    return 1;

  else
  {
    memset((void *)&lockthing, 0, sizeof(struct flock) /*32ul*/ );
    lockthing.l_type = (signed short int)l_type;
    lockthing.l_whence = (signed short int)0;
    lockthing.l_start = (signed long int)0;
    lockthing.l_len = (signed long int)0;
    ret=fcntl(*fd, 6, &lockthing);
    if(ret == -1)
    {
      if(!(verbous == 0))
      {
        sprintf(msg, "Device busy. Failed to fcntl-lock '%s'", fd_name);
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        libdax_msgs_submit(libdax_messenger, -1, 0x00020008, 0x60000000, 0x30000000, msg, *return_value___errno_location$1, 0);
      }

      close(*fd);
      *fd = -1;
      return 0;
    }

    else
      return 1;
  }
}

// sg_give_next_adr
// file libburn/sg.h line 22
signed int sg_give_next_adr(struct burn_drive_enumerator_struct *idx, char *adr, signed int adr_size, signed int initialize)
{
  signed int baseno = 0;
  signed int i;
  char other_name[80l];
  signed int return_value_strcmp$3;
  if(initialize == -1)
  {
    proc_sys_dev_cdrom_info(&idx->info_list, &idx->info_count, 1);
    return 0;
  }

  else
  {
    sg_select_device_family();
    static signed int sg_limit = 32;
    if((signed int)linux_sg_device_family[0l] == 0)
      sg_limit = 0;

    static signed int ata_limit = 26;
    if((signed int)linux_ata_device_family[0l] == 0)
      ata_limit = 0;

    if(initialize == 1)
    {
      idx->pos = -1;
      idx->info_count = 0;
      idx->info_list = (char **)(void *)0;
      proc_sys_dev_cdrom_info(&idx->info_list, &idx->info_count, 0);
    }

    idx->pos = idx->pos + 1;
    if(!(idx->pos >= sg_limit))
    {
      if(!(adr_size >= 11))
        return -1;

      sprintf(adr, linux_sg_device_family, idx->pos);
      sg_exchange_scd_for_sr(adr, 0);
    }

    else
    {

    next_ata:
      ;
      baseno = baseno + sg_limit;
      if(!(idx->pos + -baseno >= ata_limit))
      {
        if(!(adr_size >= 9))
          return -1;

        sprintf(adr, linux_ata_device_family, 97 + (idx->pos - baseno));
      }

      else
      {

      next_proc_info:
        ;
        baseno = baseno + ata_limit;
        i = 0;
        for( ; !(i >= idx->info_count); i = i + 1)
          if(!((signed int)*idx->info_list[(signed long int)i] == 0))
          {
            if(baseno == idx->pos)
            {
              unsigned long int return_value_strlen$1;
              return_value_strlen$1=strlen(idx->info_list[(signed long int)i]);
              if(!(adr_size >= 1 + (signed int)return_value_strlen$1))
                return -1;

              strcpy(adr, idx->info_list[(signed long int)i]);
              return 1;
            }

            baseno = baseno + 1;
          }

        return 0;
      }
    }

  return_1_pre_proc:
    ;
    i = 0;
    for( ; !(i >= idx->info_count); i = i + 1)
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(idx->info_list[(signed long int)i], adr);
      if(return_value_strcmp$2 == 0)
        idx->info_list[(signed long int)i][(signed long int)0] = (char)0;

      signed int return_value_fname_other_name$4;
      return_value_fname_other_name$4=fname_other_name(adr, other_name, 0);
      if(return_value_fname_other_name$4 >= 1)
      {
        return_value_strcmp$3=strcmp(idx->info_list[(signed long int)i], other_name);
        if(return_value_strcmp$3 == 0)
          idx->info_list[(signed long int)i][(signed long int)0] = (char)0;

      }

    }
    return 1;
  }
}

// sg_grab
// file libburn/sg-linux.c line 1704
signed int sg_grab(struct burn_drive *d)
{
  signed int fd;
  signed int os_errno = 0;
  signed int ret;
  signed int max_tries = 3;
  signed int tries = 0;
  signed int open_mode = 02;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "sg_grab");
  signed int *return_value___errno_location$5;
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    if(!(burn_sg_open_o_excl == 0))
      open_mode = open_mode | 0200;

    if(!(burn_sg_open_o_nonblock == 0))
      open_mode = open_mode | 04000;

    signed int return_value_burn_drive_is_open$3;
    return_value_burn_drive_is_open$3=burn_drive_is_open(d);
    if(return_value_burn_drive_is_open$3 == 0)
    {
      char msg[120l];
      sprintf(msg, "To avoid collision with udev: Waiting %lu usec before grabbing", (unsigned long int)100000);
      libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
      usleep((unsigned int)100000);

    try_open:
      ;
      mmc_function_spy((struct burn_drive *)(void *)0, "sg_grab ----------- opening");
      if(burn_sg_open_o_excl >= 2)
      {
        fd = -1;
        ret=sg_open_scsi_siblings(d->devname, d->global_index, d->sibling_fds, d->sibling_fnames, &d->sibling_count, d->host, d->channel, d->id, d->lun);
        if(!(ret >= 1))
          goto drive_is_in_use;

      }

      fd=open(d->devname, open_mode);
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      os_errno = *return_value___errno_location$2;
      if(fd >= 0)
      {
        sg_fcntl_lock(&fd, d->devname, 1, 1);
        if(!(fd >= 0))
          goto drive_is_in_use;

      }

    }

    else
      fd = d->fd;
    if(fd >= 0)
    {
      d->fd = fd;
      signed int return_value_getpid$4;
      return_value_getpid$4=getpid();
      fcntl(fd, 8, return_value_getpid$4);
      d->released = 0;
      return 1;
    }

    else
    {
      return_value___errno_location$5=__errno_location();
      if(*return_value___errno_location$5 == 16)
        goto drive_is_in_use;

    }
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020003, 0x60000000, 0x30000000, "Could not grab drive", os_errno, 0);
    return 0;

  drive_is_in_use:
    ;
    tries = tries + 1;
    if(!(tries >= max_tries))
    {
      libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, "Drive is in use. Waiting 2 seconds before re-try", 0, 0);
      usleep((unsigned int)2000000);
      goto try_open;
    }

    libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020003, 0x60000000, 0x30000000, "Could not grab drive - already in use", 0, 0);
    sg_close_drive(d);
    d->fd = -1337;
    return 0;
  }
}

// sg_handle_busy_device
// file libburn/sg-linux.c line 524
static signed int sg_handle_busy_device(char *fname, signed int os_errno)
{
  char *msg = (char *)(void *)0;
  struct stat stbuf;
  signed int looks_like_hd = 0;
  signed int fd;
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  signed int return_value_strncmp$10;
  signed int return_value_strcmp$8;
  signed int return_value_strncmp$4;
  signed int return_value_strcmp$5;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    return_value_strncmp$10=strncmp(fname, "/dev/hd", (unsigned long int)7);
    if(return_value_strncmp$10 == 0)
    {
      sprintf(msg, "%s1", fname);
      signed int return_value_stat$2;
      return_value_stat$2=stat(msg, &stbuf);
      if(!(return_value_stat$2 == -1))
        looks_like_hd = 1;

      sprintf(msg, "/proc/ide/hd%c/media", fname[(signed long int)7]);
      fd=open(msg, 00);
      if(!(fd == -1))
      {
        signed long int return_value_read$3;
        return_value_read$3=read(fd, (void *)msg, (unsigned long int)10);
        ret = (signed int)return_value_read$3;
        if(!(ret >= 0))
          ret = 0;

        msg[(signed long int)ret] = (char)0;
        close(fd);
        signed int return_value_strncmp$7;
        return_value_strncmp$7=strncmp(msg, "disk\n", (unsigned long int)5);
        _Bool tmp_if_expr$9;
        if(return_value_strncmp$7 == 0)
          tmp_if_expr$9 = (_Bool)1;

        else
        {
          return_value_strcmp$8=strcmp(msg, "disk");
          tmp_if_expr$9 = return_value_strcmp$8 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$9)
          looks_like_hd = 2;

        else
        {
          return_value_strncmp$4=strncmp(msg, "cdrom\n", (unsigned long int)6);
          _Bool tmp_if_expr$6;
          if(return_value_strncmp$4 == 0)
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_strcmp$5=strcmp(msg, "cdrom");
            tmp_if_expr$6 = return_value_strcmp$5 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$6)
            looks_like_hd = 0;

        }
      }

    }

    if(!(burn_sg_open_abort_busy == 0))
    {
      fprintf(stderr, "\nlibburn: FATAL : Application triggered abort on busy device '%s'\n", fname);
      abort();
    }

    if(!(looks_like_hd == 2))
    {
      if(!(looks_like_hd == 0))
      {
        sprintf(msg, "Could not examine busy device '%s'", fname);
        libdax_msgs_submit(libdax_messenger, -1, 0x0002015a, 0x30000000, 0x10000000, msg, os_errno, 0);
        sprintf(msg, "Busy '%s' seems to be a hard disk, as '%s1' exists. But better check.", fname, fname);
        libdax_msgs_submit(libdax_messenger, -1, 0x0002015b, 0x40000000, 0x10000000, msg, 0, 0);
      }

      else
      {
        sprintf(msg, "Cannot open busy device '%s'", fname);
        libdax_msgs_submit(libdax_messenger, -1, 0x00020001, 0x60000000, 0x10000000, msg, os_errno, 0);
      }
    }

    ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// sg_id_string
// file libburn/sg.h line 51
signed int sg_id_string(char *msg, signed int flag)
{
  strcpy(msg, "internal GNU/Linux SG_IO adapter sg-linux");
  return 1;
}

// sg_initialize
// file libburn/sg.h line 61
signed int sg_initialize(char *msg, signed int flag)
{
  signed int return_value_sg_id_string$1;
  return_value_sg_id_string$1=sg_id_string(msg, 0);
  return return_value_sg_id_string$1;
}

// sg_is_enumerable_adr
// file libburn/sg.h line 24
signed int sg_is_enumerable_adr(char *adr)
{
  char *fname = (char *)(void *)0;
  signed int ret = 0;
  signed int first = 1;
  signed int fname_size = 4096;
  struct burn_drive_enumerator_struct idx;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)fname_size, 0);
  fname = (char *)return_value_burn_alloc_mem$1;
  if(fname == ((char *)NULL))
    ret = -1;

  else
  {
    while((_Bool)1)
    {
      ret=sg_give_next_adr(&idx, fname, fname_size, first);
      if(!(ret >= 1))
        break;

      first = 0;
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(adr, fname);
      if(return_value_strcmp$2 == 0)
      {
        sg_give_next_adr(&idx, fname, fname_size, -1);
        ret = 1;
        goto ex;
      }

    }
    ret = 0;
  }

ex:
  ;
  if(first == 0)
    sg_give_next_adr(&idx, fname, fname_size, -1);

  if(!(fname == ((char *)NULL)))
    free((void *)(char *)fname);

  return ret;
}

// sg_issue_command
// file libburn/sg-linux.c line 2055
signed int sg_issue_command(struct burn_drive *d, struct command *c)
{
  signed int done = 0;
  signed int no_c_page = 0;
  signed int i;
  signed int ret;
  signed int err;
  signed long int start_time;
  struct sg_io_hdr s;
  char *msg = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)161, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    c->error = 0;
    memset((void *)c->sense, 0, sizeof(unsigned char [128l]) /*128ul*/ );
    sprintf(msg, "sg_issue_command   d->fd= %d  d->released= %d\n", d->fd, d->released);
    mmc_function_spy((struct burn_drive *)(void *)0, msg);
    static struct _IO_FILE *fp = (struct _IO_FILE *)(void *)0;
    if(!((1 & burn_sg_log_scsi) == 0))
    {
      if(fp == ((struct _IO_FILE *)NULL))
      {
        fp=fopen("/tmp/libburn_sg_command_log", "a");
        fprintf(fp, "\n-----------------------------------------\n");
      }

    }

    if(!(d->fd >= 0))
    {
      c->error = 1;
      ret = 0;
    }

    else
    {
      c->error = 0;
      memset((void *)&s, 0, sizeof(struct sg_io_hdr) /*88ul*/ );
      if(!((3 & burn_sg_log_scsi) == 0))
        scsi_log_cmd(c, (void *)fp, 0);

      s.interface_id = 83;
      if(c->dir == 0)
        s.dxfer_direction = -2;

      else
        if(c->dir == 1)
          s.dxfer_direction = -3;

        else
          if(c->dir == 2)
          {
            s.dxfer_direction = -1;
            no_c_page = 1;
          }

      s.cmd_len = (unsigned char)c->oplen;
      s.cmdp = c->opcode;
      s.mx_sb_len = (unsigned char)32;
      s.sbp = c->sense;
      if(c->timeout >= 1)
        s.timeout = (unsigned int)c->timeout;

      else
        s.timeout = (unsigned int)30000;
      if(no_c_page == 0 && !(c->page == ((struct buffer *)NULL)))
      {
        s.dxferp = (void *)c->page->data;
        if(c->dir == 1)
        {
          if(c->dxfer_len >= 0)
            s.dxfer_len = (unsigned int)c->dxfer_len;

          else
            s.dxfer_len = (unsigned int)65536;
          memset((void *)c->page->data, 0, (unsigned long int)65536);
        }

        else
        {
          if(!(c->page->bytes >= 1))
          {
            c->error = 1;
            ret = 0;
            goto ex;
          }

          s.dxfer_len = (unsigned int)c->page->bytes;
        }
      }

      else
      {
        s.dxferp = (void *)0;
        s.dxfer_len = (unsigned int)0;
      }
      s.usr_ptr = (void *)c;
      start_time=time((signed long int *)(void *)0);
      i = 0;
      for( ; done == 0; i = i + 1)
      {
        memset((void *)c->sense, 0, sizeof(unsigned char [128l]) /*128ul*/ );
        c->start_time=burn_get_time(0);
        err=ioctl(d->fd, (unsigned long int)0x2285, &s);
        c->end_time=burn_get_time(0);
        if(err == -1)
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002010c, 0x70000000, 0x30000000, "Failed to transfer command to drive", *return_value___errno_location$2, 0);
          sprintf(msg, "--- SG_IO: return= -1 , ");
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(msg);
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          sprintf(msg + (signed long int)return_value_strlen$3, "errno= %d , ", *return_value___errno_location$4);
          unsigned long int return_value_strlen$5;
          return_value_strlen$5=strlen(msg);
          sprintf(msg + (signed long int)return_value_strlen$5, "host_status= 0x%x , driver_status= 0x%x", (unsigned int)s.host_status, (unsigned int)s.driver_status);
          scsi_log_message(d, (void *)fp, msg, 0);
          react_on_drive_loss(d, c, fp);
          ret = -1;
          goto ex;
        }

        done=scsi_eval_cmd_outcome(d, c, (void *)fp, (unsigned char *)s.sbp, (signed int)s.sb_len_wr, start_time, (signed int)s.timeout, i, 0);
        if(!(d->cancel == 0))
          break;

        ret=evaluate_transport_success(d, c, fp, s.host_status, s.driver_status);
        if(ret == -1)
          react_on_drive_loss(d, c, fp);

        if(!(ret >= 1))
        {
          ret = -1;
          goto ex;
        }

        if(!(d->cancel == 0))
          break;

      }
      ret = 1;
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// sg_obtain_scsi_adr
// file libburn/sg.h line 25
signed int sg_obtain_scsi_adr(char *path, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no)
{
  signed int return_value_sg_obtain_scsi_adr_fd$1;
  return_value_sg_obtain_scsi_adr_fd$1=sg_obtain_scsi_adr_fd(path, -1, bus_no, host_no, channel_no, target_no, lun_no);
  return return_value_sg_obtain_scsi_adr_fd$1;
}

// sg_obtain_scsi_adr_fd
// file libburn/sg-linux.c line 2245
static signed int sg_obtain_scsi_adr_fd(char *path, signed int fd_in, signed int *bus_no, signed int *host_no, signed int *channel_no, signed int *target_no, signed int *lun_no)
{
  signed int fd;
  signed int ret;
  signed int l;
  signed int open_mode = 00;
  /* sg_obtain_scsi_adr_fd::1::tag-my_scsi_idlun */
struct my_scsi_idlun
{
  // x
  signed int x;
  // host_unique_id
  signed int host_unique_id;
};

/* */
  ;
  struct my_scsi_idlun idlun;
  idlun.x = 0;
  idlun.host_unique_id = 0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(linux_ata_device_family);
  l = (signed int)(return_value_strlen$1 - (unsigned long int)2);
  signed int return_value_strncmp$2;
  if(l >= 1)
  {
    return_value_strncmp$2=strncmp(path, linux_ata_device_family, (unsigned long int)l);
    if(return_value_strncmp$2 == 0)
    {
      if((signed int)path[7l] >= 97)
      {
        if(!((signed int)path[7l] >= 123))
        {
          if((signed int)path[8l] == 0)
            return 0;

        }

      }

    }

  }

  if(!(burn_sg_open_o_nonblock == 0))
    open_mode = open_mode | 04000;

  if(fd_in >= 0)
    fd = fd_in;

  else
    fd=open(path, open_mode);
  if(!(fd >= 0))
    return 0;

  else
  {
    sg_fcntl_lock(&fd, path, 0, 0);
    if(!(fd >= 0))
      return 0;

    else
    {
      signed int return_value_ioctl$3;
      return_value_ioctl$3=ioctl(fd, (unsigned long int)0x5386, bus_no);
      if(return_value_ioctl$3 == -1)
        *bus_no = -1;

      ret=ioctl(fd, (unsigned long int)0x5382, &idlun);
      if(!(fd_in >= 0))
        sg_close_drive_fd(path, -1, &fd, 0);

      if(ret == -1)
        return 0;

      else
      {
        *host_no = idlun.x >> 24 & 255;
        *channel_no = idlun.x >> 16 & 255;
        *target_no = idlun.x & 255;
        *lun_no = idlun.x >> 8 & 255;
        if(*bus_no == -1)
          *bus_no = 1000 * (*host_no + 1) + *channel_no;

        return 1;
      }
    }
  }
}

// sg_open_drive_fd
// file libburn/sg-linux.c line 698
static signed int sg_open_drive_fd(char *fname, signed int scan_mode)
{
  signed int open_mode = 02;
  signed int fd;
  signed int tries = 0;
  signed int is_std_adr;
  signed int report_as_note = 0;
  char msg[81l];
  struct stat stbuf;
  if(!(burn_sg_open_o_excl == 0))
    open_mode = open_mode | 0200;

  if(!(burn_sg_open_o_nonblock == 0))
    open_mode = open_mode | 04000;

  signed int *return_value___errno_location$2;
  do
  {

  try_open:
    ;
    fd=open(fname, open_mode);
    if(!(fd == -1))
      goto __CPROVER_DUMP_L15;

    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 16))
      goto __CPROVER_DUMP_L4;

    tries = tries + 1;
    if(tries >= 4)
      break;

    usleep((unsigned int)2000000);
  }
  while((_Bool)1);
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  sg_handle_busy_device(fname, *return_value___errno_location$1);
  return -1;

__CPROVER_DUMP_L4:
  ;
  sprintf(msg, "Failed to open device '%s'", fname);
  signed int return_value_strncmp$4;
  signed int return_value_stat$7;
  signed int return_value_stat$6;
  signed int *return_value___errno_location$9;
  if(!(scan_mode == 0))
  {
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(fname, "/dev/sr", (unsigned long int)7);
    _Bool tmp_if_expr$5;
    if(return_value_strncmp$3 == 0)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_strncmp$4=strncmp(fname, "/dev/scd", (unsigned long int)8);
      tmp_if_expr$5 = return_value_strncmp$4 == 0 ? (_Bool)1 : (_Bool)0;
    }
    is_std_adr = (signed int)tmp_if_expr$5;
    _Bool tmp_if_expr$8;
    if(scan_mode == 1 && !(is_std_adr == 0))
    {
      return_value_stat$7=stat(fname, &stbuf);
      tmp_if_expr$8 = return_value_stat$7 != -1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
      report_as_note = 1;

    else
      if(is_std_adr == 0 && scan_mode == 2)
      {
        return_value_stat$6=stat(fname, &stbuf);
        if(!(return_value_stat$6 == -1))
          report_as_note = 1;

      }

    if(!(report_as_note == 0))
    {
      return_value___errno_location$9=__errno_location();
      libdax_msgs_submit(libdax_messenger, -1, 0x0002000e, 0x30000000, 0x30000000, msg, *return_value___errno_location$9, 0);
    }

  }

  else
  {
    signed int *return_value___errno_location$10;
    return_value___errno_location$10=__errno_location();
    libdax_msgs_submit(libdax_messenger, -1, 0x00020005, 0x60000000, 0x30000000, msg, *return_value___errno_location$10, 0);
  }
  return -1;

__CPROVER_DUMP_L15:
  ;
  sg_fcntl_lock(&fd, fname, 1, 1);
  return fd;
}

// sg_open_for_enumeration
// file libburn/sg-linux.c line 1108
static signed int sg_open_for_enumeration(char *fname, signed int flag)
{
  signed int fd;
  fd=sg_open_drive_fd(fname, 1 + (flag & 1));
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(!(fd >= 0))
  {
    if(!(linux_ata_enumerate_verbous == 0) || !(linux_sg_enumerate_debug == 0))
    {
      return_value___errno_location$1=__errno_location();
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "open failed, errno=%d  '%s'\n", *return_value___errno_location$1, return_value_strerror$3);
    }

    return -1;
  }

  return fd;
}

// sg_open_scsi_siblings
// file libburn/sg-linux.c line 821
static signed int sg_open_scsi_siblings(char *path, signed int driveno, signed int *sibling_fds, char (*sibling_fnames)[16l], signed int *sibling_count, signed int host_no, signed int channel_no, signed int id_no, signed int lun_no)
{
  signed int tld;
  signed int i;
  signed int ret;
  signed int fd;
  signed int i_bus_no = -1;
  signed int i_host_no = -1;
  signed int i_channel_no = -1;
  signed int i_target_no = -1;
  signed int i_lun_no = -1;
  char *msg = (char *)(void *)0;
  char fname[40l];
  struct stat stbuf;
  unsigned long int last_rdev = (unsigned long int)0;
  unsigned long int path_rdev;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(path);
  signed int return_value_stat$3;
  if(return_value_strlen$1 >= 3937ul)
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      return_value_stat$3=stat(path, &stbuf);
      if(return_value_stat$3 == -1)
        ret = 0;

      else
      {
        path_rdev = stbuf.st_rdev;
        sg_select_device_family();
        if((signed int)linux_sg_device_family[0l] == 0)
          ret = 1;

        else
          if(!(channel_no >= 0) || !(host_no >= 0) || !(id_no >= 0) || !(lun_no >= 0))
            ret = 2;

          else
          {
            if(*sibling_count >= 1)
              sg_release_siblings(sibling_fds, sibling_fnames, sibling_count);

            tld = 0;
            static char tldev[4l][20l] = { { '/', 'd', 'e', 'v', '/', 's', 'r', '%', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { '/', 'd', 'e', 'v', '/', 's', 'c', 'd', '%', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { '/', 'd', 'e', 'v', '/', 's', 'g', '%', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
            for( ; !((signed int)tldev[(signed long int)tld][0l] == 0); tld = tld + 1)
            {
              signed int return_value_strcmp$4;
              return_value_strcmp$4=strcmp(tldev[(signed long int)tld], linux_sg_device_family);
              if(!(return_value_strcmp$4 == 0))
              {
                i = 0;
                for( ; !(i >= 32); i = i + 1)
                {
                  sprintf(fname, tldev[(signed long int)tld], i);
                  signed int return_value_stat$5;
                  return_value_stat$5=stat(fname, &stbuf);
                  if(!(return_value_stat$5 == -1))
                  {
                    if(!(path_rdev == stbuf.st_rdev))
                    {
                      if(*sibling_count >= 1)
                      {
                        if(!(last_rdev == stbuf.st_rdev))
                          goto __CPROVER_DUMP_L10;

                      }

                      else
                      {

                      __CPROVER_DUMP_L10:
                        ;
                        ret=sg_obtain_scsi_adr(fname, &i_bus_no, &i_host_no, &i_channel_no, &i_target_no, &i_lun_no);
                        if(ret >= 1)
                        {
                          if(i_channel_no == channel_no && i_host_no == host_no)
                          {
                            if(i_lun_no == lun_no && i_target_no == id_no)
                            {
                              fd=sg_open_drive_fd(fname, 0);
                              if(!(fd >= 0))
                                goto failed;

                              if(*sibling_count >= 5)
                              {
                                sprintf(msg, "Too many scsi siblings of '%s'", path);
                                libdax_msgs_submit(libdax_messenger, driveno, 0x00020006, 0x70000000, 0x30000000, msg, 0, 0);
                                goto failed;
                              }

                              sprintf(msg, "Opened O_EXCL scsi sibling '%s' of '%s'", (const void *)fname, path);
                              libdax_msgs_submit(libdax_messenger, driveno, 0x00020004, 0x30000000, 0x30000000, msg, 0, 0);
                              sibling_fds[(signed long int)*sibling_count] = fd;
                              strcpy(sibling_fnames[(signed long int)*sibling_count], fname);
                              *sibling_count = *sibling_count + 1;
                              last_rdev = stbuf.st_rdev;
                            }

                          }

                        }

                      }
                    }

                  }

                }
              }

            }
            ret = 1;
          }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;

failed:
  ;
  sg_release_siblings(sibling_fds, sibling_fnames, sibling_count);
  ret = 0;
  goto ex;
}

// sg_release
// file libburn/sg-linux.c line 1868
signed int sg_release(struct burn_drive *d)
{
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "sg_release");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
    if(!(d->fd >= 1))
      return 0;

    else
    {
      mmc_function_spy((struct burn_drive *)(void *)0, "sg_release ----------- closing");
      sg_close_drive(d);
      return 0;
    }
}

// sg_release_siblings
// file libburn/sg-linux.c line 787
static signed int sg_release_siblings(signed int *sibling_fds, char (*sibling_fnames)[16l], signed int *sibling_count)
{
  signed int i;
  char msg[81l];
  i = 0;
  for( ; !(i >= *sibling_count); i = i + 1)
    sg_close_drive_fd(sibling_fnames[(signed long int)i], -1, &sibling_fds[(signed long int)i], 0);
  if(*sibling_count >= 1)
  {
    sprintf(msg, "Closed %d O_EXCL scsi siblings", *sibling_count);
    libdax_msgs_submit(libdax_messenger, -1, 0x00020007, 0x30000000, 0x30000000, msg, 0, 0);
  }

  *sibling_count = 0;
  return 1;
}

// sg_select_device_family
// file libburn/sg-linux.c line 311
static void sg_select_device_family(void)
{
  if(burn_sg_use_family == 1)
    strcpy(linux_sg_device_family, "/dev/sr%d");

  else
    if(burn_sg_use_family == 2)
      strcpy(linux_sg_device_family, "/dev/scd%d");

    else
      if(burn_sg_use_family == 3)
        strcpy(linux_sg_device_family, "/dev/st%d");

      else
        if(burn_sg_use_family == 4)
          strcpy(linux_sg_device_family, "/dev/sg%d");

        else
          if(!(linux_sg_auto_family == 0))
          {
            sg_evaluate_kernel();
            if(sg_kernel_age >= 2)
              strcpy(linux_sg_device_family, "/dev/sr%d");

            else
              strcpy(linux_sg_device_family, "/dev/sg%d");
            linux_sg_auto_family = 0;
          }

}

// sg_shutdown
// file libburn/sg.h line 69
signed int sg_shutdown(signed int flag)
{
  return 1;
}

// sgio_inquiry_cd_drive
// file libburn/sg-linux.c line 441
static signed int sgio_inquiry_cd_drive(signed int fd, char *fname)
{
  unsigned char test_ops[6l] = { (unsigned char)0x12, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)36, (unsigned char)0 };
  struct sg_io_hdr s;
  struct buffer *buf = (struct buffer *)(void *)0;
  unsigned char *sense = (unsigned char *)(void *)0;
  char *msg = (char *)(void *)0;
  char *msg_pt;
  signed int ret = 0;
  signed int i;
  double c_start_time;
  double c_end_time;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  buf = (struct buffer *)return_value_burn_alloc_mem$1;
  if(buf == ((struct buffer *)NULL))
    ret = -1;

  else
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(unsigned char) /*1ul*/ , (unsigned long int)128, 0);
    sense = (unsigned char *)return_value_burn_alloc_mem$2;
    if(sense == ((unsigned char *)NULL))
      ret = -1;

    else
    {
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(fname);
      void *return_value_burn_alloc_mem$4;
      return_value_burn_alloc_mem$4=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(return_value_strlen$3 + (unsigned long int)1024), 0);
      msg = (char *)return_value_burn_alloc_mem$4;
      if(msg == ((char *)NULL))
        ret = -1;

      else
      {
        memset((void *)&s, 0, sizeof(struct sg_io_hdr) /*88ul*/ );
        s.interface_id = 83;
        s.dxfer_direction = -3;
        s.cmd_len = (unsigned char)6;
        s.cmdp = test_ops;
        s.mx_sb_len = (unsigned char)32;
        s.sbp = sense;
        s.timeout = (unsigned int)30000;
        s.dxferp = (void *)buf;
        s.dxfer_len = (unsigned int)36;
        s.usr_ptr = (void *)0;
        sgio_log_cmd(s.cmdp, (signed int)s.cmd_len, (struct _IO_FILE *)(void *)0, 0);
        c_start_time=burn_get_time(0);
        ret=ioctl(fd, (unsigned long int)0x2285, &s);
        c_end_time=burn_get_time(0);
        if(ret == -1)
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          sprintf(msg, "INQUIRY on '%s' : ioctl(SG_IO) failed , errno= %d", fname, *return_value___errno_location$5);
          libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
          goto ex;
        }

        sgio_log_reply(s.cmdp, 1, buf->data, (signed int)s.dxfer_len, (void *)0, (unsigned char *)s.sbp, (signed int)s.sb_len_wr, c_end_time - c_start_time, 0);
        if((signed int)s.sb_len_wr >= 1 || !((signed int)s.driver_status == 0) || !((signed int)s.host_status == 0))
        {
          sprintf(msg, "INQUIRY failed on '%s' : host_status= %hd , driver_status= %hd", fname, s.host_status, s.driver_status);
          if((signed int)s.sb_len_wr >= 1)
          {
            unsigned long int return_value_strlen$6;
            return_value_strlen$6=strlen(msg);
            sprintf(msg + (signed long int)return_value_strlen$6, " , sense data=");
            unsigned long int return_value_strlen$7;
            return_value_strlen$7=strlen(msg);
            msg_pt = msg + (signed long int)return_value_strlen$7;
            i = 0;
            for( ; !(i >= (signed int)s.sb_len_wr); i = i + 1)
              sprintf(msg_pt + (signed long int)(i * 3), " %2.2X", ((unsigned char *)s.sbp)[(signed long int)i]);
          }

          libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
          ret = -1;
        }

        else
        {
          ret = 0;
          if((signed int)buf->data[0l] == 0x5)
            ret = 1;

          else
          {
            sprintf(msg, "INQUIRY on '%s' : byte 0 = 0x%2.2X", fname, buf->data[(signed long int)0]);
            libdax_msgs_submit(libdax_messenger, -1, 0x00000002, 0x10000000, 0x30000000, msg, 0, 0);
          }
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(sense == ((unsigned char *)NULL)))
    free((void *)(char *)sense);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  return ret;
}

// sgio_log_cmd
// file libburn/sg-linux.c line 378
static signed int sgio_log_cmd(unsigned char *cmd, signed int cmd_len, struct _IO_FILE *fp_in, signed int flag)
{
  struct _IO_FILE *fp = fp_in;
  signed int ret = 0;
  if(fp == ((struct _IO_FILE *)NULL) && !((1 & burn_sg_log_scsi) == 0))
  {
    fp=fopen("/tmp/libburn_sg_command_log", "a");
    if(!(fp == ((struct _IO_FILE *)NULL)))
      fprintf(fp, "\n=========================================\n");

  }

  if(!(fp == ((struct _IO_FILE *)NULL)))
    ret=scsi_log_command(cmd, cmd_len, 2, (unsigned char *)(void *)0, 0, (void *)fp, flag);

  if(fp_in == ((struct _IO_FILE *)NULL) && !(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return ret;
}

// sgio_log_reply
// file libburn/sg-linux.c line 401
static signed int sgio_log_reply(unsigned char *opcode, signed int data_dir, unsigned char *data, signed int dxfer_len, void *fp_in, unsigned char *sense, signed int sense_len, double duration, signed int flag)
{
  signed int ret;
  ret=scsi_log_reply(opcode, data_dir, data, dxfer_len, fp_in, sense, sense_len, duration, flag);
  return ret;
}

// sgio_test
// file libburn/sg-linux.c line 414
static signed int sgio_test(signed int fd)
{
  unsigned char test_ops[6l] = { (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
  struct sg_io_hdr s;
  signed int ret;
  double c_start_time;
  double c_end_time;
  memset((void *)&s, 0, sizeof(struct sg_io_hdr) /*88ul*/ );
  s.interface_id = 83;
  s.dxfer_direction = -1;
  s.cmd_len = (unsigned char)6;
  s.cmdp = test_ops;
  s.timeout = (unsigned int)12345;
  sgio_log_cmd(s.cmdp, (signed int)s.cmd_len, (struct _IO_FILE *)(void *)0, 0);
  c_start_time=burn_get_time(0);
  ret=ioctl(fd, (unsigned long int)0x2285, &s);
  c_end_time=burn_get_time(0);
  sgio_log_reply(s.cmdp, 2, (unsigned char *)(void *)0, 0, (void *)0, (unsigned char *)s.sbp, (signed int)s.sb_len_wr, c_end_time - c_start_time, 0);
  return ret;
}

// single_enumerate
// file libburn/sg-linux.c line 1305
static signed int single_enumerate(signed int flag)
{
  signed int ret;
  signed int wl_count;
  char *fname;
  char *msg = (char *)(void *)0;
  wl_count=burn_drive_whitelist_count();
  if(!(wl_count == 1))
    ret = 0;

  else
  {
    fname=burn_drive_whitelist_item(0, 0);
    if(fname == ((char *)NULL))
      ret = 0;

    else
    {
      ret=fname_enumerate(fname, 2);
      if(!(ret >= 1))
      {
        void *return_value_burn_alloc_mem$1;
        return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(1024 + 80), 0);
        msg = (char *)return_value_burn_alloc_mem$1;
        if(msg == ((char *)NULL))
          ret = -1;

        else
        {
          sprintf(msg, "Cannot access '%s' as SG_IO CDROM drive", fname);
          libdax_msgs_submit(libdax_messenger, -1, 0x0002000a, 0x68000000, 0x30000000, msg, 0, 0);
          ret = -1;
        }
      }

    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// spc_allow
// file libburn/spc.c line 399
void spc_allow(struct burn_drive *d)
{
  struct command *c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "allow");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, SPC_ALLOW, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 1;
    c->dir = 2;
    d->issue_command(d, c);
  }

}

// spc_block_type
// file libburn/spc.h line 33
signed int spc_block_type(enum burn_block_types b)
{
  switch((signed int)b)
  {
    case BURN_BLOCK_SAO:
      return 0;
    case BURN_BLOCK_RAW0:
      return 0;
    case BURN_BLOCK_RAW16:
      return 1;
    case BURN_BLOCK_RAW96P:
      return 2;
    case BURN_BLOCK_RAW96R:
      return 3;
    case BURN_BLOCK_MODE1:
      return 8;
    case BURN_BLOCK_MODE2R:
      return 9;
    case BURN_BLOCK_MODE2_PATHETIC:
      return 10;
    case BURN_BLOCK_MODE2_LAME:
      return 11;
    case BURN_BLOCK_MODE2_OBSCURE:
      return 12;
    case BURN_BLOCK_MODE2_OK:
      return 13;
    default:
      return -1;
  }
}

// spc_confirm_cd_drive
// file libburn/spc.c line 2033
signed int spc_confirm_cd_drive(struct burn_drive *d, signed int flag)
{
  char *msg = (char *)(void *)0;
  signed int ret;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(d->devname);
  void *return_value_burn_alloc_mem$2;
  return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(return_value_strlen$1 + (unsigned long int)1024), 0);
  msg = (char *)return_value_burn_alloc_mem$2;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    spc_inquiry(d);
    if(!(d->idata->valid >= 0))
    {
      sprintf(msg, "INQUIRY failed with drive '%s'", d->devname);
      libdax_msgs_submit(libdax_messenger, -1, 0x0002000a, 0x68000000, 0x30000000, msg, 0, 0);
      ret = 0;
    }

    else
      if(!((signed int)d->idata->peripheral == 0x5))
      {
        sprintf(msg, "Does not identify itself as CD-ROM drive '%s'", d->devname);
        libdax_msgs_submit(libdax_messenger, -1, 0x0002000a, 0x68000000, 0x30000000, msg, 0, 0);
        ret = 0;
      }

      else
        ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// spc_decode_sense
// file libburn/spc.h line 114
signed int spc_decode_sense(unsigned char *sense, signed int senselen, signed int *key, signed int *asc, signed int *ascq)
{
  *ascq = 0;
  *asc = *ascq;
  *key = *asc;
  _Bool tmp_if_expr$1;
  if((0x7f & (signed int)*sense) == 0x72)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ((signed int)sense[(signed long int)0] & 0x7f) == 0x73 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(senselen >= 2 || !(senselen >= 1))
      *key = (signed int)sense[(signed long int)1] & 0x0f;

    if(senselen >= 3 || !(senselen >= 1))
      *asc = (signed int)sense[(signed long int)2];

    if(senselen >= 4 || !(senselen >= 1))
      *ascq = (signed int)sense[(signed long int)3];

    return 1;
  }

  else
  {
    if(senselen >= 3 || !(senselen >= 1))
      *key = (signed int)sense[(signed long int)2] & 0x0f;

    if(senselen >= 13 || !(senselen >= 1))
      *asc = (signed int)sense[(signed long int)12];

    if(senselen >= 14 || !(senselen >= 1))
      *ascq = (signed int)sense[(signed long int)13];

    return 1;
  }
}

// spc_get_erase_progress
// file libburn/spc.c line 298
signed int spc_get_erase_progress(struct burn_drive *d)
{
  struct buffer *b = (struct buffer *)(void *)0;
  signed int ret;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int progress;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "get_erase_progress");
  if(!(return_value_mmc_function_spy$1 >= 1))
    ret = 0;

  else
  {
    ret=spc_test_unit_ready_r(d, &key, &asc, &ascq, &progress);
    if(ret >= 1)
      ret = -2;

    else
      if(!(key == 0) && (ascq == 0x02 || ascq == 0x03 || !(asc == 0x04) || !(key == 0x2)))
      {
        spc_report_async_error(d, key, asc, ascq, 0);
        ret = -3;
      }

      else
        if(progress >= 0)
          ret = progress;

        else
        {
          void *return_value_burn_alloc_mem$2;
          return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
          b = (struct buffer *)return_value_burn_alloc_mem$2;
          if(b == ((struct buffer *)NULL))
            ret = -1;

          else
          {
            spc_request_sense(d, b);
            ret = -1;
            if((signed int)b->data[0l] == 0x70)
            {
              _Bool tmp_if_expr$3;
              if((0x0f & (signed int)b->data[2l]) == 0)
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = ((signed int)b->data[(signed long int)2] & 0x0f) == 2 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$3)
              {
                if(!((0x80 & (signed int)b->data[15l]) == 0))
                  ret = (signed int)b->data[(signed long int)16] << 8 | (signed int)b->data[(signed long int)17];

              }

            }

          }
        }
  }

ex:
  ;
  if(!(b == ((struct buffer *)NULL)))
    free((void *)(char *)b);

  return ret;
}

// spc_getcaps
// file libburn/spc.c line 1001
void spc_getcaps(struct burn_drive *d)
{
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "getcaps");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    burn_speed_descriptor_destroy(&d->mdata->speed_descriptors, 1);
    spc_inquiry(d);
    spc_sense_caps(d);
    spc_sense_error_params(d);
  }

}

// spc_inquiry
// file libburn/spc.c line 339
void spc_inquiry(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct burn_scsi_inquiry_data *id;
  struct command *c = (struct command *)(void *)0;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "inquiry");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$3;
      if(!(c == ((struct command *)NULL)))
      {
        scsi_init_command(c, SPC_INQUIRY, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
        c->dxfer_len = (signed int)c->opcode[(signed long int)3] << 8 | (signed int)c->opcode[(signed long int)4];
        c->retry = 1;
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        id = (struct burn_scsi_inquiry_data *)d->idata;
        id->peripheral = (char)0x7f;
        id->version = (char)0;
        memset((void *)id->vendor, 0, (unsigned long int)9);
        memset((void *)id->product, 0, (unsigned long int)17);
        memset((void *)id->revision, 0, (unsigned long int)5);
        if(!(c->error == 0))
          id->valid = -1;

        else
        {
          id->peripheral = ((char *)c->page->data)[(signed long int)0];
          id->version = ((char *)c->page->data)[(signed long int)2];
          memcpy((void *)id->vendor, (const void *)(c->page->data + (signed long int)8), (unsigned long int)8);
          memcpy((void *)id->product, (const void *)(c->page->data + (signed long int)16), (unsigned long int)16);
          memcpy((void *)id->revision, (const void *)(c->page->data + (signed long int)32), (unsigned long int)4);
          id->valid = 1;
        }
      }

    }


  ex:
    ;
    if(!(buf == ((struct buffer *)NULL)))
      free((void *)(char *)buf);

    if(!(c == ((struct command *)NULL)))
      free((void *)(char *)c);

    goto __CPROVER_DUMP_L6;
  }


__CPROVER_DUMP_L6:
  ;
}

// spc_prevent
// file libburn/spc.c line 380
void spc_prevent(struct burn_drive *d)
{
  struct command *c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "prevent");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, SPC_PREVENT, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 1;
    c->dir = 2;
    d->issue_command(d, c);
  }

}

// spc_probe_write_modes
// file libburn/spc.c line 1017
void spc_probe_write_modes(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  signed int try_write_type = 1;
  signed int try_block_type = 0;
  signed int key;
  signed int asc;
  signed int ascq;
  signed int useable_write_type = -1;
  signed int useable_block_type = -1;
  signed int last_try = 0;
  struct command *c = (struct command *)(void *)0;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "spc_probe_write_modes");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$3;
      if(!(c == ((struct command *)NULL)))
      {
        if(!(try_write_type == 5))
        {
          if(try_write_type == 4)
          {
            if(useable_write_type == -1)
              goto ex;

            try_write_type = useable_write_type;
            try_block_type = useable_block_type;
            last_try = 1;
          }

          scsi_init_command(c, SPC_MODE_SELECT, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
          c->retry = 1;
          c->opcode[(signed long int)8] = (unsigned char)(8 + 2 + 0x32);
          c->page = buf;
          memset((void *)c->page->data, 0, (unsigned long int)(8 + 2 + 0x32));
          c->page->bytes = 8 + 2 + 0x32;
          c->page->data[(signed long int)8] = (unsigned char)5;
          c->page->data[(signed long int)9] = (unsigned char)0x32;
          c->page->data[(signed long int)10] = (unsigned char)try_write_type;
          if(try_block_type >= 5)
            c->page->data[(signed long int)11] = (unsigned char)4;

          else
            c->page->data[(signed long int)11] = (unsigned char)0;
          c->page->data[(signed long int)12] = (unsigned char)try_block_type;
          c->page->data[(signed long int)23] = (unsigned char)150;
          c->dir = 0;
          d->silent_on_scsi_error = 1;
          d->issue_command(d, c);
          d->silent_on_scsi_error = 0;
          if(last_try == 0)
          {
            spc_decode_sense(c->sense, 0, &key, &asc, &ascq);
            if(key == 0)
            {
              if(try_write_type == 2)
                d->block_types[(signed long int)try_write_type] = BURN_BLOCK_SAO;

              else
                d->block_types[(signed long int)try_write_type] = d->block_types[(signed long int)try_write_type] | 1 << try_block_type;
              if(try_block_type == 8 && try_write_type == 1 || try_write_type >= 1 && !(useable_write_type >= 0))
              {
                useable_write_type = try_write_type;
                useable_block_type = try_block_type;
              }

            }

            if(try_block_type == 0 || try_block_type == 1 || try_block_type == 2)
            {
              try_block_type = try_block_type + 1;
              try_block_type = 8;
              try_block_type = try_block_type + 1;
              try_block_type = 0;
              try_write_type = try_write_type + 1;
            }

          }

        }

      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// spc_report_async_error
// file libburn/spc.c line 268
static signed int spc_report_async_error(struct burn_drive *d, signed int key, signed int asc, signed int ascq, signed int flag)
{
  char *msg = (char *)(void *)0;
  unsigned char sense[14l];
  signed int ret;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(1024 + 160), 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  unsigned long int return_value_strlen$2;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    sprintf(msg, "Asynchronous SCSI error : ");
    sense[(signed long int)0] = (unsigned char)0x70;
    sense[(signed long int)2] = (unsigned char)key;
    sense[(signed long int)12] = (unsigned char)asc;
    sense[(signed long int)13] = (unsigned char)ascq;
    return_value_strlen$2=strlen(msg);
    scsi_error_msg(d, sense, 14, msg + (signed long int)return_value_strlen$2, &key, &asc, &ascq);
    libdax_msgs_submit(libdax_messenger, d->global_index, 0x000201a5, 0x68000000, 0x30000000, msg, 0, 0);
    ret = 1;
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// spc_request_sense
// file libburn/spc.c line 249
void spc_request_sense(struct burn_drive *d, struct buffer *buf)
{
  struct command *c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "request_sense");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    scsi_init_command(c, SPC_REQUEST_SENSE, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 0;
    c->dxfer_len = (signed int)c->opcode[(signed long int)4];
    c->retry = 0;
    c->page = buf;
    c->page->sectors = 0;
    c->page->bytes = 0;
    c->dir = 1;
    d->issue_command(d, c);
  }

}

// spc_select_error_params
// file libburn/spc.c line 720
void spc_select_error_params(struct burn_drive *d, struct burn_read_opts *o)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "select_error_params");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$3;
      if(!(c == ((struct command *)NULL)))
      {
        scsi_init_command(c, SPC_MODE_SELECT, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->retry = 1;
        if(!(d->mdata->retry_page_valid >= 1))
          d->mdata->retry_page_length = 0;

        c->opcode[(signed long int)8] = (unsigned char)(8 + 2 + d->mdata->retry_page_length);
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        memset((void *)c->page->data, 0, (unsigned long int)(8 + 2 + d->mdata->retry_page_length));
        c->page->bytes = 8 + 2 + d->mdata->retry_page_length;
        c->page->data[(signed long int)8] = (unsigned char)1;
        c->page->data[(signed long int)9] = (unsigned char)d->mdata->retry_page_length;
        if(!(o->transfer_damaged_blocks == 0u))
          c->page->data[(signed long int)10] = c->page->data[(signed long int)10] | (unsigned char)32;

        if(!(o->report_recovered_errors == 0u))
          c->page->data[(signed long int)10] = c->page->data[(signed long int)10] | (unsigned char)4;

        if(o->hardware_error_recovery == 0u)
          c->page->data[(signed long int)10] = c->page->data[(signed long int)10] | (unsigned char)1;

        c->page->data[(signed long int)11] = (unsigned char)d->params.retries;
        c->dir = 0;
        d->issue_command(d, c);
      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// spc_select_write_params
// file libburn/spc.h line 23
void spc_select_write_params(struct burn_drive *d, struct burn_session *s, signed int tnum, struct burn_write_opts *o)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct command *c = (struct command *)(void *)0;
  signed int alloc_len;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "select_write_params");
  signed int return_value_mmc_compose_mode_page_5$4;
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$3;
      if(!(c == ((struct command *)NULL)))
      {
        alloc_len = 8 + 2 + d->mdata->write_page_length;
        memset((void *)&buf->data, 0, (unsigned long int)alloc_len);
        scsi_init_command(c, SPC_MODE_SELECT, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->retry = 1;
        c->opcode[(signed long int)7] = (unsigned char)(alloc_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(alloc_len & 0xff);
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->page->bytes = alloc_len;
        return_value_mmc_compose_mode_page_5$4=mmc_compose_mode_page_5(d, s, tnum, o, c->page->data + (signed long int)8);
        if(return_value_mmc_compose_mode_page_5$4 >= 1)
        {
          c->dir = 0;
          d->issue_command(d, c);
        }

      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// spc_sense_caps
// file libburn/spc.c line 649
void spc_sense_caps(struct burn_drive *d)
{
  signed int alloc_len;
  signed int start_len = 30;
  signed int minimum_len = 28;
  signed int ret;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "sense_caps");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    mmc_get_configuration(d);
    alloc_len = start_len;
    ret=spc_sense_caps_al(d, &alloc_len, 1);
    if(ret == 2)
    {
      ret=spc_sense_caps_al(d, &alloc_len, 1);
      if(ret == 2)
        goto try_get_performance;

    }

    if(alloc_len >= minimum_len && ret >= 1)
      spc_sense_caps_al(d, &alloc_len, 0);


  try_get_performance:
    ;
    spc_try_get_performance(d, 0);
  }

}

// spc_sense_caps_al
// file libburn/spc.c line 446
static signed int spc_sense_caps_al(struct burn_drive *d, signed int *alloc_len, signed int flag)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct scsi_mode_data *m;
  signed int page_length;
  signed int num_write_speeds = 0;
  signed int i;
  signed int speed;
  signed int ret;
  signed int old_alloc_len;
  signed int was_error = 0;
  signed int block_descr_len;
  unsigned char *page;
  struct command *c = (struct command *)(void *)0;
  struct burn_speed_descriptor *sd;
  char *msg = (char *)(void *)0;
  if(!(*alloc_len >= 10))
    ret = 0;

  else
  {
    void *return_value_burn_alloc_mem$1;
    return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)(1024 + 160), 0);
    msg = (char *)return_value_burn_alloc_mem$1;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      void *return_value_burn_alloc_mem$2;
      return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
      buf = (struct buffer *)return_value_burn_alloc_mem$2;
      if(buf == ((struct buffer *)NULL))
        ret = -1;

      else
      {
        void *return_value_burn_alloc_mem$3;
        return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
        c = (struct command *)return_value_burn_alloc_mem$3;
        if(c == ((struct command *)NULL))
          ret = -1;

        else
        {
          m = d->mdata;
          m->p2a_valid = 0;
          burn_mdata_free_subs(m);
          memset((void *)buf, 0, sizeof(struct buffer) /*69640ul*/ );
          scsi_init_command(c, SPC_MODE_SENSE, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
          c->dxfer_len = *alloc_len;
          c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
          c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
          c->retry = 1;
          c->opcode[(signed long int)2] = (unsigned char)0x2A;
          c->page = buf;
          c->page->bytes = 0;
          c->page->sectors = 0;
          c->dir = 1;
          d->issue_command(d, c);
          if(!(c->error == 0))
          {
            memset((void *)buf, 0, sizeof(struct buffer) /*69640ul*/ );
            m->p2a_valid = -1;
            was_error = 1;
          }

          block_descr_len = (signed int)c->page->data[(signed long int)6] * 256 + (signed int)c->page->data[(signed long int)7];
          if(!(*alloc_len >= 2 + block_descr_len))
          {
            if((1 & flag) == 0 || 2 + block_descr_len >= 65537)
            {
              m->p2a_valid = -1;
              sprintf(msg, "MODE SENSE page 2A with oversized Block Descriptors: %s : %d", d->devname, block_descr_len);
              libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002016e, 0x10000000, 0x10000000, msg, 0, 0);
              ret = 0;
            }

            *alloc_len = block_descr_len + 10;
            ret = 2;
          }

          else
          {
            page = c->page->data + (signed long int)8 + (signed long int)block_descr_len;
            page_length = (signed int)page[(signed long int)1];
            old_alloc_len = *alloc_len;
            *alloc_len = page_length + 10 + block_descr_len;
            if(!((1 & flag) == 0))
              ret = (signed int)!(was_error != 0);

            else
            {
              if(!(old_alloc_len >= 10 + page_length))
                page_length = old_alloc_len - 10;

              if(!(page_length >= 18))
              {
                m->p2a_valid = -1;
                sprintf(msg, "MODE SENSE page 2A too short: %s : %d", d->devname, page_length);
                libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002016e, 0x10000000, 0x10000000, msg, 0, 0);
                ret = 0;
              }

              else
              {
                m->buffer_size = (signed int)page[(signed long int)12] * 256 + (signed int)page[(signed long int)13];
                m->dvdram_read = (signed int)page[(signed long int)2] & 32;
                m->dvdram_write = (signed int)page[(signed long int)3] & 32;
                m->dvdr_read = (signed int)page[(signed long int)2] & 16;
                m->dvdr_write = (signed int)page[(signed long int)3] & 16;
                m->dvdrom_read = (signed int)page[(signed long int)2] & 8;
                m->simulate = (signed int)page[(signed long int)3] & 4;
                m->cdrw_read = (signed int)page[(signed long int)2] & 2;
                m->cdrw_write = (signed int)page[(signed long int)3] & 2;
                m->cdr_read = (signed int)page[(signed long int)2] & 1;
                m->cdr_write = (signed int)page[(signed long int)3] & 1;
                m->c2_pointers = (signed int)page[(signed long int)5] & 16;
                m->underrun_proof = (signed int)page[(signed long int)4] & 128;
                m->max_read_speed = (signed int)page[(signed long int)8] * 256 + (signed int)page[(signed long int)9];
                m->cur_read_speed = (signed int)page[(signed long int)14] * 256 + (signed int)page[(signed long int)15];
                m->cur_write_speed = 0;
                m->max_write_speed = m->cur_write_speed;
                if(page_length >= 18)
                  m->max_write_speed = (signed int)page[(signed long int)18] * 256 + (signed int)page[(signed long int)19];

                if(page_length >= 20)
                  m->cur_write_speed = (signed int)page[(signed long int)20] * 256 + (signed int)page[(signed long int)21];

                m->min_write_speed = m->max_write_speed;
                m->min_end_lba = 0x7fffffff;
                m->max_end_lba = 0;
                if(was_error == 0)
                  m->p2a_valid = 1;

                if(page_length >= 30)
                {
                  m->cur_write_speed = (signed int)page[(signed long int)28] * 256 + (signed int)page[(signed long int)29];
                  static signed int speed_debug = 0;
                  if(!(speed_debug == 0))
                    fprintf(stderr, "LIBBURN_DEBUG: cur_write_speed = %d\n", m->cur_write_speed);

                  num_write_speeds = (signed int)page[(signed long int)30] * 256 + (signed int)page[(signed long int)31];
                  m->min_write_speed = m->cur_write_speed;
                  m->max_write_speed = m->min_write_speed;
                  if(!(2 + page_length >= 4 * num_write_speeds + 32))
                  {
                    sprintf(msg, "Malformed capabilities page 2Ah received (len=%d, #speeds=%d)", page_length, num_write_speeds);
                    libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002013c, 0x60000000, 0x30000000, msg, 0, 0);
                    ret = 0;
                  }

                  i = 0;
                  if(!(i >= num_write_speeds))
                  {
                    speed = (signed int)page[(signed long int)(32 + 4 * i + 2)] * 256 + (signed int)page[(signed long int)(32 + 4 * i + 3)];
                    if(!(speed_debug == 0))
                      fprintf(stderr, "LIBBURN_DEBUG: write speed #%d = %d kB/s  (rc %d)\n", i, speed, (signed int)page[(signed long int)(32 + 4 * i + 1)] & 7);

                    ret=burn_speed_descriptor_new(&d->mdata->speed_descriptors, (struct burn_speed_descriptor *)(void *)0, d->mdata->speed_descriptors, 0);
                    if(ret >= 1)
                    {
                      sd = d->mdata->speed_descriptors;
                      sd->source = 1;
                      if(d->current_profile >= 1)
                      {
                        sd->profile_loaded = d->current_profile;
                        strcpy(sd->profile_name, d->current_profile_text);
                      }

                      sd->wrc = (signed int)(((signed int)page[(signed long int)(32 + 4 * i + 1)] & 7) == 1);
                      sd->write_speed = speed;
                    }

                    if(!(m->max_write_speed >= speed))
                      m->max_write_speed = speed;

                    if(!(speed >= m->min_write_speed))
                      m->min_write_speed = speed;

                    i = i + 1;
                  }

                  if(!(speed_debug == 0))
                    fprintf(stderr, "LIBBURN_DEBUG: 5Ah,2Ah min_write_speed = %d , max_write_speed = %d\n", m->min_write_speed, m->max_write_speed);

                }


              no_speed_descriptors:
                ;
                ret = (signed int)!(was_error != 0);
              }
            }
          }
        }
      }
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

  return ret;
}

// spc_sense_error_params
// file libburn/spc.c line 684
void spc_sense_error_params(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct scsi_mode_data *m;
  signed int alloc_len = 12;
  unsigned char *page;
  struct command *c = (struct command *)(void *)0;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "sense_error_params");
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$3;
      if(!(c == ((struct command *)NULL)))
      {
        scsi_init_command(c, SPC_MODE_SENSE, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = alloc_len;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->retry = 1;
        c->opcode[(signed long int)2] = (unsigned char)0x01;
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        m = d->mdata;
        page = c->page->data + (signed long int)8;
        d->params.retries = (signed int)page[(signed long int)3];
        m->retry_page_length = (signed int)page[(signed long int)1];
        m->retry_page_valid = 1;
      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// spc_sense_write_params
// file libburn/spc.c line 760
void spc_sense_write_params(struct burn_drive *d)
{
  struct buffer *buf = (struct buffer *)(void *)0;
  struct scsi_mode_data *m;
  signed int dummy1;
  signed int dummy2;
  signed int alloc_len = 10;
  unsigned char *page;
  struct command *c = (struct command *)(void *)0;
  mmc_start_if_needed(d, 1);
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "sense_write_params");
  _Bool tmp_if_expr$4;
  if(return_value_mmc_function_spy$1 >= 1)
  {
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
    buf = (struct buffer *)return_value_burn_alloc_mem$2;
    if(!(buf == ((struct buffer *)NULL)))
    {
      void *return_value_burn_alloc_mem$3;
      return_value_burn_alloc_mem$3=burn_alloc_mem(sizeof(struct command) /*200ul*/ , (unsigned long int)1, 0);
      c = (struct command *)return_value_burn_alloc_mem$3;
      if(!(c == ((struct command *)NULL)))
      {
        scsi_init_command(c, SPC_MODE_SENSE, (signed int)sizeof(unsigned char [10l]) /*10ul*/ );
        c->dxfer_len = alloc_len;
        c->opcode[(signed long int)7] = (unsigned char)(c->dxfer_len >> 8 & 0xff);
        c->opcode[(signed long int)8] = (unsigned char)(c->dxfer_len & 0xff);
        c->retry = 1;
        c->opcode[(signed long int)2] = (unsigned char)0x05;
        c->page = buf;
        c->page->bytes = 0;
        c->page->sectors = 0;
        c->dir = 1;
        d->issue_command(d, c);
        m = d->mdata;
        if(c->error == 0)
        {
          page = c->page->data + (signed long int)8;
          m->write_page_length = (signed int)page[(signed long int)1];
          if(m->write_page_length >= 1)
            m->write_page_valid = 1;

          else
            m->write_page_length = 0x32;
        }

        mmc_read_disc_info(d);
        _Bool tmp_if_expr$6;
        if(d->current_profile == 0x1a)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = d->current_profile == 0x13 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$7;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = d->current_profile == 0x12 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr$8;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = d->current_profile == 0x43 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          d->read_format_capacities(d, -1);

        else
        {
          _Bool tmp_if_expr$5;
          if((signed int)d->status == BURN_DISC_BLANK)
            tmp_if_expr$5 = (_Bool)1;

          else
          {
            if(!(d->current_is_cd_profile == 0))
              tmp_if_expr$4 = (signed int)d->status == BURN_DISC_APPENDABLE ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$5)
          {
            burn_drive_send_default_page_05(d, 0);
            d->get_nwa(d, -1, &dummy1, &dummy2);
          }

        }
      }

    }

  }


ex:
  ;
  if(!(buf == ((struct buffer *)NULL)))
    free((void *)(char *)buf);

  if(!(c == ((struct command *)NULL)))
    free((void *)(char *)c);

}

// spc_setup_drive
// file libburn/spc.c line 1158
signed int spc_setup_drive(struct burn_drive *d)
{
  d->getcaps = spc_getcaps;
  d->lock = spc_prevent;
  d->unlock = spc_allow;
  d->read_disc_info = spc_sense_write_params;
  d->get_erase_progress = spc_get_erase_progress;
  d->test_unit_ready = spc_test_unit_ready;
  d->probe_write_modes = spc_probe_write_modes;
  d->send_parameters = spc_select_error_params;
  d->send_write_parameters = spc_select_write_params;
  return 1;
}

// spc_test_unit_ready
// file libburn/spc.h line 40
signed int spc_test_unit_ready(struct burn_drive *d)
{
  signed int key;
  signed int asc;
  signed int ascq;
  signed int progress;
  signed int return_value_spc_test_unit_ready_r$1;
  return_value_spc_test_unit_ready_r$1=spc_test_unit_ready_r(d, &key, &asc, &ascq, &progress);
  return return_value_spc_test_unit_ready_r$1;
}

// spc_test_unit_ready_r
// file libburn/spc.c line 110
signed int spc_test_unit_ready_r(struct burn_drive *d, signed int *key, signed int *asc, signed int *ascq, signed int *progress)
{
  struct command *c = &d->casual_command;
  signed int return_value_mmc_function_spy$1;
  return_value_mmc_function_spy$1=mmc_function_spy(d, "test_unit_ready");
  if(!(return_value_mmc_function_spy$1 >= 1))
    return 0;

  else
  {
    scsi_init_command(c, SPC_TEST_UNIT_READY, (signed int)sizeof(unsigned char [6l]) /*6ul*/ );
    c->retry = 0;
    c->dir = 2;
    d->issue_command(d, c);
    *ascq = 0;
    *asc = *ascq;
    *key = *asc;
    *progress = -1;
    if(!(c->error == 0))
    {
      spc_decode_sense(c->sense, 0, key, asc, ascq);
      if((signed int)c->sense[0l] == 0x70)
      {
        _Bool tmp_if_expr$2;
        if((0x0f & (signed int)c->sense[2l]) == 0)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = ((signed int)c->sense[(signed long int)2] & 0x0f) == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          if(!((0x80 & (signed int)c->sense[15l]) == 0))
            *progress = ((signed int)c->sense[(signed long int)16] << 8) + (signed int)c->sense[(signed long int)17];

        }

      }

      return (signed int)(*key == 0);
    }

    else
      return 1;
  }
}

// spc_try_get_performance
// file libburn/spc.c line 417
static signed int spc_try_get_performance(struct burn_drive *d, signed int flag)
{
  signed int ret;
  struct burn_feature_descr *feature_descr;
  ret=burn_drive_has_feature(d, 0x107, &feature_descr, 0);
  if(!(ret >= 1))
    return ret;

  else
    if(!((signed int)feature_descr->data_lenght >= 1))
      return 1;

    else
    {
      if(!((2 & (signed int)*feature_descr->data) == 0))
        ret=mmc_get_write_performance(d);

      mmc_get_performance(d, 0x00, 0);
      return 1;
    }
}

// spc_wait_unit_attention
// file libburn/spc.h line 44
signed int spc_wait_unit_attention(struct burn_drive *d, signed int max_sec, char *cmd_text, signed int flag)
{
  signed int i;
  signed int ret = 1;
  signed int key = 0;
  signed int asc = 0;
  signed int ascq = 0;
  signed int clueless_start = 0;
  signed int sleep_usecs;
  signed int loop_limit;
  signed int clueless_timeout;
  signed int progress;
  char *msg = (char *)(void *)0;
  unsigned char sense[14l];
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)320, 0);
  msg = (char *)return_value_burn_alloc_mem$1;
  if(msg == ((char *)NULL))
    ret = -1;

  else
  {
    static double tests_per_second = 2.0;
    clueless_timeout = (signed int)((double)5 * tests_per_second + (double)1);
    loop_limit = (signed int)((double)max_sec * tests_per_second + (double)1);
    sleep_usecs = (signed int)((double)1000000 / tests_per_second);
    if((1 & flag) == 0)
      usleep((unsigned int)sleep_usecs);

    i = (signed int)!((flag & 1) != 0);
    for( ; !(i >= loop_limit); i = i + 1)
    {
      ret=spc_test_unit_ready_r(d, &key, &asc, &ascq, &progress);
      if(ret >= 1)
        break;

      if(!(asc == 0x4) || !(key == 0x2))
      {
        if(asc == 0x3A && key == 0x2)
        {
          ret = 1;
          break;
        }

        if(asc == 0x28 && ascq == 0x00 && key == 0x6)
          goto slumber;


      handle_error:
        ;
        sprintf(msg, "Asynchronous SCSI error on %s: ", cmd_text);
        sense[(signed long int)0] = (unsigned char)0x70;
        sense[(signed long int)2] = (unsigned char)key;
        sense[(signed long int)12] = (unsigned char)asc;
        sense[(signed long int)13] = (unsigned char)ascq;
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(msg);
        scsi_error_msg(d, sense, 14, msg + (signed long int)return_value_strlen$2, &key, &asc, &ascq);
        libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002014d, 0x60000000, 0x30000000, msg, 0, 0);
        d->cancel = 1;
        break;
      }

      else
        if(ascq == 0x00)
        {
          if(clueless_start == 0)
            clueless_start = i;

          if(!(clueless_timeout >= i + -clueless_start))
          {
            libdax_msgs_submit(libdax_messenger, d->global_index, 0x00000002, 0x10000000, 0x30000000, "Ended clueless NOT READY cycle", 0, 0);
            ret = 1;
            break;
          }

        }

        else
          if(ascq == 0x02 || ascq == 0x03)
            goto handle_error;


    slumber:
      ;
      usleep((unsigned int)sleep_usecs);
    }
    if((2 & flag) == 0 || !(ret >= 1))
    {
      sprintf(msg, "Async %s %s after %d.%d seconds", cmd_text, ret > 0 ? "succeeded" : "failed", i / 10, i % 10);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020150, 0x10000000, 0x10000000, msg, 0, 0);
    }

    if(!(i >= 10 * max_sec))
      ret = (signed int)(ret > 0);

    else
    {
      sprintf(msg, "Timeout (%d s) with asynchronous SCSI command %s\n", max_sec, cmd_text);
      libdax_msgs_submit(libdax_messenger, d->global_index, 0x0002014f, 0x60000000, 0x30000000, msg, 0, 0);
      ret = 0;
    }
  }

ex:
  ;
  if(!(msg == ((char *)NULL)))
    free((void *)(char *)msg);

  return ret;
}

// strip_spaces
// file libburn/drive.c line 1178
static void strip_spaces(char *str, unsigned long int len)
{
  char *tmp;
  char *tmp2;
  tmp = (str + (signed long int)len) - (signed long int)1;
  _Bool tmp_if_expr$3;
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  do
  {
    if(tmp >= str)
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*tmp]) == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = !(*tmp != 0) ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    *tmp = (char)0;
    tmp = tmp - 1l;
  }
  while((_Bool)1);
  tmp = str;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$6;
  _Bool tmp_if_expr$5;
  do
  {
    if(!(tmp >= str + (signed long int)len + -1l))
      tmp_if_expr$4 = *tmp != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    const unsigned short int **return_value___ctype_b_loc$7;
    return_value___ctype_b_loc$7=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*tmp]) == 0))
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)tmp[1l]]) == 0))
      {
        tmp2 = tmp + (signed long int)1;
        do
        {
          if(!(tmp2 >= str + (signed long int)len))
            tmp_if_expr$5 = *tmp2 != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          if(!tmp_if_expr$5)
            break;

          *(tmp2 - (signed long int)1) = *tmp2;
          tmp2 = tmp2 + 1l;
        }
        while((_Bool)1);
        *(tmp2 - (signed long int)1) = (char)0;
        tmp = tmp - 1l;
      }

    }

    tmp = tmp + 1l;
  }
  while((_Bool)1);
}

// subcode_lout
// file libburn/sector.c line 539
static void subcode_lout(struct burn_write_opts *o, unsigned char control, unsigned char *data)
{
  struct burn_drive *d = o->drive;
  unsigned char *q;
  signed int crc;
  signed int rmin;
  signed int min;
  signed int rsec;
  signed int sec;
  signed int rframe;
  signed int frame;
  memset((void *)data, 0, (unsigned long int)96);
  q = data + (signed long int)12;
  burn_lba_to_msf(d->alba, &min, &sec, &frame);
  burn_lba_to_msf(d->rlba, &rmin, &rsec, &rframe);
  if((rframe / 19) % 2 == 0 && rsec >= 2 || rframe == 0 && rmin == 0 && rsec == 0)
    memset((void *)data, 0xFF, (unsigned long int)12);

  q[(signed long int)0] = (unsigned char)(((signed int)control << 4) + 1);
  q[(signed long int)1] = (unsigned char)0xAA;
  q[(signed long int)2] = (unsigned char)0x01;
  signed int return_value_dec_to_bcd$1;
  return_value_dec_to_bcd$1=dec_to_bcd(rmin);
  q[(signed long int)3] = (unsigned char)return_value_dec_to_bcd$1;
  signed int return_value_dec_to_bcd$2;
  return_value_dec_to_bcd$2=dec_to_bcd(rsec);
  q[(signed long int)4] = (unsigned char)return_value_dec_to_bcd$2;
  signed int return_value_dec_to_bcd$3;
  return_value_dec_to_bcd$3=dec_to_bcd(rframe);
  q[(signed long int)5] = (unsigned char)return_value_dec_to_bcd$3;
  q[(signed long int)6] = (unsigned char)0;
  signed int return_value_dec_to_bcd$4;
  return_value_dec_to_bcd$4=dec_to_bcd(min);
  q[(signed long int)7] = (unsigned char)return_value_dec_to_bcd$4;
  signed int return_value_dec_to_bcd$5;
  return_value_dec_to_bcd$5=dec_to_bcd(sec);
  q[(signed long int)8] = (unsigned char)return_value_dec_to_bcd$5;
  signed int return_value_dec_to_bcd$6;
  return_value_dec_to_bcd$6=dec_to_bcd(frame);
  q[(signed long int)9] = (unsigned char)return_value_dec_to_bcd$6;
  unsigned short int return_value_crc_ccitt$7;
  return_value_crc_ccitt$7=crc_ccitt(q, 10);
  crc = (signed int)return_value_crc_ccitt$7;
  q[(signed long int)10] = (unsigned char)(crc >> 8);
  q[(signed long int)11] = (unsigned char)(crc & 0xFF);
}

// subcode_toc
// file libburn/sector.c line 433
static void subcode_toc(struct burn_drive *d, signed int mode, unsigned char *data)
{
  unsigned char *q;
  signed int track;
  signed int crc;
  signed int min;
  signed int sec;
  signed int frame;
  track = d->toc_temp / 3;
  memset((void *)data, 0, (unsigned long int)96);
  q = data + (signed long int)12;
  burn_lba_to_msf(d->rlba, &min, &sec, &frame);
  q[(signed long int)0] = (unsigned char)(((signed int)(d->toc_entry + (signed long int)track)->control << 4) + 1);
  q[(signed long int)1] = (unsigned char)0;
  signed int return_value_dec_to_bcd$1;
  if(!((signed int)(d->toc_entry + (signed long int)track)->point >= 100))
  {
    return_value_dec_to_bcd$1=dec_to_bcd((signed int)(d->toc_entry + (signed long int)track)->point);
    q[(signed long int)2] = (unsigned char)return_value_dec_to_bcd$1;
  }

  else
    q[(signed long int)2] = (d->toc_entry + (signed long int)track)->point;
  signed int return_value_dec_to_bcd$2;
  return_value_dec_to_bcd$2=dec_to_bcd(min);
  q[(signed long int)3] = (unsigned char)return_value_dec_to_bcd$2;
  signed int return_value_dec_to_bcd$3;
  return_value_dec_to_bcd$3=dec_to_bcd(sec);
  q[(signed long int)4] = (unsigned char)return_value_dec_to_bcd$3;
  signed int return_value_dec_to_bcd$4;
  return_value_dec_to_bcd$4=dec_to_bcd(frame);
  q[(signed long int)5] = (unsigned char)return_value_dec_to_bcd$4;
  q[(signed long int)6] = (unsigned char)0;
  signed int return_value_dec_to_bcd$5;
  return_value_dec_to_bcd$5=dec_to_bcd((signed int)(d->toc_entry + (signed long int)track)->pmin);
  q[(signed long int)7] = (unsigned char)return_value_dec_to_bcd$5;
  signed int return_value_dec_to_bcd$6;
  return_value_dec_to_bcd$6=dec_to_bcd((signed int)(d->toc_entry + (signed long int)track)->psec);
  q[(signed long int)8] = (unsigned char)return_value_dec_to_bcd$6;
  signed int return_value_dec_to_bcd$7;
  return_value_dec_to_bcd$7=dec_to_bcd((signed int)(d->toc_entry + (signed long int)track)->pframe);
  q[(signed long int)9] = (unsigned char)return_value_dec_to_bcd$7;
  unsigned short int return_value_crc_ccitt$8;
  return_value_crc_ccitt$8=crc_ccitt(q, 10);
  crc = (signed int)return_value_crc_ccitt$8;
  q[(signed long int)10] = (unsigned char)(crc >> 8);
  q[(signed long int)11] = (unsigned char)(crc & 0xFF);
  d->toc_temp = d->toc_temp + 1;
  d->toc_temp = d->toc_temp % (d->toc_entries * 3);
}

// subcode_user
// file libburn/sector.c line 591
void subcode_user(struct burn_write_opts *o, unsigned char *subcodes, unsigned char tno, unsigned char control, unsigned char indx, struct isrc *isrc, signed int psub)
{
  struct burn_drive *d = o->drive;
  unsigned char *p;
  unsigned char *q;
  signed int crc;
  signed int m;
  signed int s;
  signed int f;
  signed int c;
  signed int qmode;
  memset((void *)subcodes, 0, (unsigned long int)96);
  p = subcodes;
  if((signed int)tno == 1)
  {
    if(d->rlba == -150)
      memset((void *)p, 0xFF, (unsigned long int)12);

  }

  if(!(psub == 0))
    memset((void *)p, 0xFF, (unsigned long int)12);

  q = subcodes + (signed long int)12;
  qmode = 1;
  if(d->rlba % 10 == 0)
  {
    if((d->rlba / 10) % 10 == 0)
    {
      if(!(o->has_mediacatalog == 0))
        qmode = 2;

    }

    else
      if((d->rlba / 10) % 10 == 1)
      {
        if(!(isrc == ((struct isrc *)NULL)))
        {
          if(!(isrc->has_isrc == 0))
            qmode = 3;

        }

      }

  }

  signed int return_value_dec_to_bcd$1;
  signed int return_value_dec_to_bcd$2;
  signed int return_value_dec_to_bcd$3;
  signed int return_value_dec_to_bcd$4;
  signed int return_value_dec_to_bcd$5;
  signed int return_value_dec_to_bcd$6;
  signed int return_value_dec_to_bcd$7;
  signed int return_value_dec_to_bcd$8;
  signed int return_value_dec_to_bcd$9;
  char return_value_char_to_isrc$10;
  char return_value_char_to_isrc$11;
  char return_value_char_to_isrc$12;
  char return_value_char_to_isrc$13;
  char return_value_char_to_isrc$14;
  signed int return_value_dec_to_bcd$15;
  signed int return_value_dec_to_bcd$16;
  signed int return_value_dec_to_bcd$17;
  signed int return_value_dec_to_bcd$18;
  signed int return_value_dec_to_bcd$19;
  switch(qmode)
  {
    case 1:
    {
      return_value_dec_to_bcd$1=dec_to_bcd((signed int)tno);
      q[(signed long int)1] = (unsigned char)return_value_dec_to_bcd$1;
      return_value_dec_to_bcd$2=dec_to_bcd((signed int)indx);
      q[(signed long int)2] = (unsigned char)return_value_dec_to_bcd$2;
      burn_lba_to_msf(d->rlba, &m, &s, &f);
      return_value_dec_to_bcd$3=dec_to_bcd(m);
      q[(signed long int)3] = (unsigned char)return_value_dec_to_bcd$3;
      return_value_dec_to_bcd$4=dec_to_bcd(s);
      q[(signed long int)4] = (unsigned char)return_value_dec_to_bcd$4;
      return_value_dec_to_bcd$5=dec_to_bcd(f);
      q[(signed long int)5] = (unsigned char)return_value_dec_to_bcd$5;
      q[(signed long int)6] = (unsigned char)0;
      burn_lba_to_msf(d->alba, &m, &s, &f);
      return_value_dec_to_bcd$6=dec_to_bcd(m);
      q[(signed long int)7] = (unsigned char)return_value_dec_to_bcd$6;
      return_value_dec_to_bcd$7=dec_to_bcd(s);
      q[(signed long int)8] = (unsigned char)return_value_dec_to_bcd$7;
      return_value_dec_to_bcd$8=dec_to_bcd(f);
      q[(signed long int)9] = (unsigned char)return_value_dec_to_bcd$8;
      break;
    }
    case 2:
    {
      q[(signed long int)1] = (unsigned char)(((signed int)o->mediacatalog[(signed long int)0] << 4) + (signed int)o->mediacatalog[(signed long int)1]);
      q[(signed long int)2] = (unsigned char)(((signed int)o->mediacatalog[(signed long int)2] << 4) + (signed int)o->mediacatalog[(signed long int)3]);
      q[(signed long int)3] = (unsigned char)(((signed int)o->mediacatalog[(signed long int)4] << 4) + (signed int)o->mediacatalog[(signed long int)5]);
      q[(signed long int)4] = (unsigned char)(((signed int)o->mediacatalog[(signed long int)6] << 4) + (signed int)o->mediacatalog[(signed long int)7]);
      q[(signed long int)5] = (unsigned char)(((signed int)o->mediacatalog[(signed long int)8] << 4) + (signed int)o->mediacatalog[(signed long int)9]);
      q[(signed long int)6] = (unsigned char)(((signed int)o->mediacatalog[(signed long int)10] << 4) + (signed int)o->mediacatalog[(signed long int)11]);
      q[(signed long int)7] = (unsigned char)((signed int)o->mediacatalog[(signed long int)12] << 4);
      q[(signed long int)8] = (unsigned char)0;
      burn_lba_to_msf(d->alba, &m, &s, &f);
      return_value_dec_to_bcd$9=dec_to_bcd(f);
      q[(signed long int)9] = (unsigned char)return_value_dec_to_bcd$9;
      break;
    }
    case 3:
    {
      return_value_char_to_isrc$10=char_to_isrc(isrc->country[(signed long int)0]);
      c = (signed int)return_value_char_to_isrc$10;
      q[(signed long int)1] = (unsigned char)(c << 2);
      return_value_char_to_isrc$11=char_to_isrc(isrc->country[(signed long int)1]);
      c = (signed int)return_value_char_to_isrc$11;
      q[(signed long int)1] = q[(signed long int)1] + (unsigned char)(c >> 4);
      q[(signed long int)2] = (unsigned char)(c << 4);
      return_value_char_to_isrc$12=char_to_isrc(isrc->owner[(signed long int)0]);
      c = (signed int)return_value_char_to_isrc$12;
      q[(signed long int)2] = q[(signed long int)2] + (unsigned char)(c >> 2);
      q[(signed long int)3] = (unsigned char)(c << 6);
      return_value_char_to_isrc$13=char_to_isrc(isrc->owner[(signed long int)1]);
      c = (signed int)return_value_char_to_isrc$13;
      q[(signed long int)3] = q[(signed long int)3] + (unsigned char)c;
      return_value_char_to_isrc$14=char_to_isrc(isrc->owner[(signed long int)2]);
      c = (signed int)return_value_char_to_isrc$14;
      q[(signed long int)4] = (unsigned char)(c << 2);
      return_value_dec_to_bcd$15=dec_to_bcd((signed int)isrc->year % 100);
      q[(signed long int)5] = (unsigned char)return_value_dec_to_bcd$15;
      return_value_dec_to_bcd$16=dec_to_bcd((signed int)(isrc->serial % (unsigned int)100));
      q[(signed long int)6] = (unsigned char)return_value_dec_to_bcd$16;
      return_value_dec_to_bcd$17=dec_to_bcd((signed int)((isrc->serial / (unsigned int)100) % (unsigned int)100));
      q[(signed long int)7] = (unsigned char)return_value_dec_to_bcd$17;
      return_value_dec_to_bcd$18=dec_to_bcd((signed int)((isrc->serial / (unsigned int)10000) % (unsigned int)10));
      q[(signed long int)8] = (unsigned char)(return_value_dec_to_bcd$18 << 4);
      burn_lba_to_msf(d->alba, &m, &s, &f);
      return_value_dec_to_bcd$19=dec_to_bcd(f);
      q[(signed long int)9] = (unsigned char)return_value_dec_to_bcd$19;
    }
  }
  q[(signed long int)0] = (unsigned char)(((signed int)control << 4) + qmode);
  unsigned short int return_value_crc_ccitt$20;
  return_value_crc_ccitt$20=crc_ccitt(q, 10);
  crc = (signed int)return_value_crc_ccitt$20;
  q[(signed long int)10] = (unsigned char)(crc >> 8);
  q[(signed long int)11] = (unsigned char)(crc & 0xff);
}

// telltoc_aquire_by_adr
// file test/telltoc.c line 118
signed int telltoc_aquire_by_adr(char *drive_adr)
{
  signed int ret;
  char libburn_drive_adr[1024l];
  ret=burn_drive_convert_fs_adr(drive_adr, libburn_drive_adr);
  if(!(ret >= 1))
  {
    fprintf(stderr, "Address does not lead to a CD burner: '%s'\n", drive_adr);
    return 0;
  }

  else
  {
    fprintf(stderr, "Aquiring drive '%s' ...\n", (const void *)libburn_drive_adr);
    ret=burn_drive_scan_and_grab(&drive_list, libburn_drive_adr, 1);
    if(!(ret >= 1))
      fprintf(stderr, "FAILURE with persistent drive address  '%s'\n", (const void *)libburn_drive_adr);

    else
    {
      fprintf(stderr, "Done\n");
      drive_is_grabbed = 1;
    }
    return ret;
  }
}

// telltoc_aquire_by_driveno
// file test/telltoc.c line 159
signed int telltoc_aquire_by_driveno(signed int *driveno, signed int silent_drive)
{
  char adr[1024l];
  signed int ret;
  signed int i;
  fprintf(stderr, "Beginning to scan for devices ...\n");
  signed int return_value_burn_drive_scan$1;
  do
  {
    return_value_burn_drive_scan$1=burn_drive_scan(&drive_list, &drive_count);
    if(!(return_value_burn_drive_scan$1 == 0))
      break;

    usleep((unsigned int)100002);
  }
  while((_Bool)1);
  if(!(drive_count >= 1u))
  {
    if(!(*driveno >= 0))
      goto __CPROVER_DUMP_L3;

    fprintf(stderr, "FAILED (no drives found)\n");
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    fprintf(stderr, "Done\n");
    i = 0;
    for( ; !(i >= (signed int)drive_count); i = i + 1)
    {
      if(*driveno >= 0)
      {
        _Bool tmp_if_expr$2;
        if(!(silent_drive == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = *driveno != i ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          goto __CPROVER_DUMP_L9;

      }

      signed int return_value_burn_drive_get_adr$3;
      return_value_burn_drive_get_adr$3=burn_drive_get_adr(&drive_list[(signed long int)i], adr);
      if(!(return_value_burn_drive_get_adr$3 >= 1))
        strcpy(adr, "-get_adr_failed-");

      printf("Drive found  : %d  --drive '%s'  : ", i, (const void *)adr);
      printf("%-8s  %-16s  (%4s)\n", (const void *)(drive_list + (signed long int)i)->vendor, (const void *)(drive_list + (signed long int)i)->product, (const void *)(drive_list + (signed long int)i)->revision);

    __CPROVER_DUMP_L9:
      ;
    }
    if(!(*driveno >= 0))
    {
      fprintf(stderr, "Pseudo-drive \"-\" given : bus scanning done.\n");
      return 2;
    }

    else
      if(*driveno >= (signed int)drive_count)
      {
        fprintf(stderr, "Found only %d drives. Number %d not available.\n", drive_count, *driveno);
        return 0;
      }

      else
      {
        i = 0;
        for( ; !(i >= (signed int)drive_count); i = i + 1)
          if(!(i == *driveno))
          {
            ret=burn_drive_info_forget(&drive_list[(signed long int)i], 0);
            if(!(ret == 1))
              fprintf(stderr, "Cannot drop drive %d. Please report \"ret=%d\" to libburn-hackers@pykix.org\n", i, ret);

            else
              fprintf(stderr, "Dropped unwanted drive %d\n", i);
          }

        ret=burn_drive_grab((drive_list + (signed long int)*driveno)->drive, 1);
        if(!(ret == 1))
          return 0;

        else
        {
          drive_is_grabbed = 1;
          return 1;
        }
      }
  }
}

// telltoc_aquire_drive
// file test/telltoc.c line 100
signed int telltoc_aquire_drive(char *drive_adr, signed int *driveno, signed int silent_drive)
{
  signed int ret;
  _Bool tmp_if_expr$1;
  if(!(drive_adr == ((char *)NULL)))
    tmp_if_expr$1 = (signed int)drive_adr[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    ret=telltoc_aquire_by_adr(drive_adr);

  else
    ret=telltoc_aquire_by_driveno(driveno, silent_drive);
  return ret;
}

// telltoc_detect_cd
// file test/telltoc.c line 480
void telltoc_detect_cd(struct burn_drive *drive)
{
  signed int pno;
  char profile_name[80l];
  signed int return_value_burn_disc_get_profile$1;
  return_value_burn_disc_get_profile$1=burn_disc_get_profile(drive, &pno, profile_name);
  if(return_value_burn_disc_get_profile$1 >= 1)
  {
    if(pno >= 0x08 && !(pno >= 11))
      medium_is_cd_profile = 1;

    else
      medium_is_cd_profile = -1;
  }

}

// telltoc_formatlist
// file test/telltoc.c line 438
signed int telltoc_formatlist(struct burn_drive *drive)
{
  signed int ret;
  signed int i;
  signed int status;
  signed int num_formats;
  signed int profile_no;
  signed int type;
  signed long int size;
  unsigned int dummy;
  char status_text[80l];
  char profile_name[90l];
  ret=burn_disc_get_formats(drive, &status, &size, &dummy, &num_formats);
  if(!(ret >= 1))
  {
    fprintf(stderr, "SORRY: Cannot obtain format list info\n");
    return 2;
  }

  else
  {
    if(status == 1)
      sprintf(status_text, "unformatted, up to %.1f MiB", ((double)size / 1024.0) / 1024.0);

    else
      if(status == 2)
        sprintf(status_text, "formatted, with %.1f MiB", ((double)size / 1024.0) / 1024.0);

      else
        if(status == 3)
        {
          burn_disc_get_profile(drive, &profile_no, profile_name);
          if(profile_no >= 1)
            sprintf(status_text, "intermediate or unknown");

          else
            sprintf(status_text, "no media or unknown media");
        }

        else
          sprintf(status_text, "illegal status according to MMC-5");
    printf("Format status: %s\n", (const void *)status_text);
    i = 0;
    for( ; !(i >= num_formats); i = i + 1)
    {
      ret=burn_disc_get_format_descr(drive, i, &type, &size, &dummy);
      if(ret >= 1)
        printf("Format descr.: %2.2Xh  , %.1f MiB  (%.fs)\n", type, ((double)size / 1024.0) / 1024.0, (double)size / 2048.0);

    }
    return 1;
  }
}

// telltoc_media
// file test/telltoc.c line 241
signed int telltoc_media(struct burn_drive *drive)
{
  signed int ret;
  signed int media_found = 0;
  signed int profile_no = -1;
  signed int num_profiles = 0;
  signed int i;
  signed int profiles[64l];
  char is_current_profile[64l];
  double max_speed = 0.0;
  double min_speed = 0.0;
  double speed_conv;
  signed long int available = (signed long int)0;
  enum burn_disc_status s;
  char profile_name[80l];
  char speed_unit[40l];
  struct burn_multi_caps *caps = (struct burn_multi_caps *)(void *)0;
  struct burn_write_opts *o = (struct burn_write_opts *)(void *)0;
  printf("Media current: ");
  ret=burn_disc_get_profile(drive, &profile_no, profile_name);
  if(profile_no >= 1 && ret >= 1)
  {
    if(!(profile_name[0l] == 0))
      printf("%s\n", (const void *)profile_name);

    else
      printf("%4.4Xh\n", profile_no);
  }

  else
    printf("is not recognizable\n");
  speed_conv = 176.4;
  strcpy(speed_unit, "176.4 kB/s  (CD, data speed 150 KiB/s)");
  char *return_value_strstr$2;
  return_value_strstr$2=strstr(profile_name, "DVD");
  char *return_value_strstr$1;
  if(return_value_strstr$2 == profile_name)
  {
    speed_conv = 1385.0;
    strcpy(speed_unit, "1385.0 kB/s  (DVD)");
  }

  else
  {
    return_value_strstr$1=strstr(profile_name, "BD");
    if(return_value_strstr$1 == profile_name)
    {
      speed_conv = 4495.625;
      strcpy(speed_unit, "4495.625 kB/s  (BD)");
    }

  }
  ret=burn_drive_get_all_profiles(drive, &num_profiles, profiles, is_current_profile);
  if(ret >= 1)
  {
    i = 0;
    for( ; !(i >= num_profiles); i = i + 1)
    {
      ret=burn_obtain_profile_name(profiles[(signed long int)i], profile_name);
      if(!(ret >= 1))
        sprintf(profile_name, "Unknown media type 0x%4.4X", (unsigned int)profiles[(signed long int)i]);

      printf("Drive can do : %s%s\n", (const void *)profile_name, is_current_profile[(signed long int)i] != 0 ? " (current)" : "");
    }
  }

  printf("Media status : ");
  s=burn_disc_get_status(drive);
  if((signed int)s == BURN_DISC_FULL)
  {
    printf("is written , is closed\n");
    media_found = 1;
  }

  else
    if((signed int)s == BURN_DISC_APPENDABLE)
    {
      printf("is written , is appendable\n");
      media_found = 1;
    }

    else
      if((signed int)s == BURN_DISC_BLANK)
      {
        printf("is blank\n");
        media_found = 1;
      }

      else
        if((signed int)s == BURN_DISC_EMPTY)
          printf("is not present\n");

        else
          printf("is not recognizable\n");
  printf("Media reuse  : ");
  if(!(media_found == 0))
  {
    signed int return_value_burn_disc_erasable$3;
    return_value_burn_disc_erasable$3=burn_disc_erasable(drive);
    if(!(return_value_burn_disc_erasable$3 == 0))
      printf("is erasable\n");

    else
      printf("is not erasable\n");
  }

  else
    printf("is not recognizable\n");
  ret=burn_disc_get_multi_caps(drive, (enum burn_write_types)BURN_WRITE_NONE, &caps, 0);
  if(ret >= 1)
  {
    printf("Write multi  : ");
    printf("%s multi-session , ", caps->multi_session == 1 ? "offers" : "cannot do");
    if(!(caps->multi_track == 0))
      printf("offers multiple tracks\n");

    else
      printf("offers only single track\n");
    printf("Write start  : ");
    if(caps->start_adr == 1)
      printf("offers addresses [%.f , %.f]s , alignment=%.fs\n", (double)caps->start_range_low / (double)2048, (double)caps->start_range_high / (double)2048, (double)caps->start_alignment / (double)2048);

    else
      printf("prohibits write start addressing\n");
    printf("Write modes  : ");
    if(!(caps->might_do_tao == 0))
      printf("TAO%s", (signed int)caps->advised_write_mode == BURN_WRITE_TAO ? " (advised)" : "");

    if(!(caps->might_do_sao == 0))
      printf("%sSAO%s", caps->might_do_tao != 0 ? " , " : "", (signed int)caps->advised_write_mode == BURN_WRITE_SAO ? " (advised)" : "");

    if(!(caps->might_do_raw == 0))
      printf("%sRAW%s", (caps->might_do_tao | caps->might_do_sao) != 0 ? " , " : "", (signed int)caps->advised_write_mode == BURN_WRITE_RAW ? " (advised)" : "");

    printf("\n");
    printf("Write dummy  : ");
    if(!(caps->might_simulate == 0))
      printf("supposed to work with non-RAW modes\n");

    else
      printf("will not work\n");
    o=burn_write_opts_new(drive);
    if(!(o == ((struct burn_write_opts *)NULL)))
    {
      burn_write_opts_set_perform_opc(o, 0);
      if((signed int)caps->advised_write_mode == BURN_WRITE_TAO)
        burn_write_opts_set_write_type(o, (enum burn_write_types)BURN_WRITE_TAO, BURN_BLOCK_MODE1);

      else
        if((signed int)caps->advised_write_mode == BURN_WRITE_SAO)
          burn_write_opts_set_write_type(o, (enum burn_write_types)BURN_WRITE_SAO, BURN_BLOCK_SAO);

        else
        {
          burn_write_opts_free(o);
          o = (struct burn_write_opts *)(void *)0;
        }
    }

    available=burn_disc_available_space(drive, o);
    printf("Write space  : %.1f MiB  (%.fs)\n", ((double)available / 1024.0) / 1024.0, (double)available / 2048.0);
    burn_disc_free_multi_caps(&caps);
    if(!(o == ((struct burn_write_opts *)NULL)))
      burn_write_opts_free(o);

  }

  ret=burn_drive_get_write_speed(drive);
  max_speed = (double)ret / speed_conv;
  ret=burn_drive_get_min_write_speed(drive);
  min_speed = (double)ret / speed_conv;
  if(media_found == 0)
    printf("Drive speed  : max=%.1f  , min=%.1f\n", max_speed, min_speed);

  else
    printf("Avail. speed : max=%.1f  , min=%.1f\n", max_speed, min_speed);
  ret = 0;
  if(!(media_found == 0))
    ret=burn_disc_read_atip(drive);

  if(ret >= 1)
  {
    ret=burn_drive_get_min_write_speed(drive);
    min_speed = (double)ret / speed_conv;
    ret=burn_drive_get_write_speed(drive);
    max_speed = (double)ret / speed_conv;
    printf("Media speed  : max=%.1f  , min=%.1f\n", max_speed, min_speed);
  }

  printf("Speed unit 1x: %s\n", (const void *)speed_unit);
  if(!(caps == ((struct burn_multi_caps *)NULL)))
    burn_disc_free_multi_caps(&caps);

  return 1;
}

// telltoc_msinfo
// file test/telltoc.c line 568
signed int telltoc_msinfo(struct burn_drive *drive, signed int msinfo_explicit, signed int msinfo_alone)
{
  signed int ret;
  signed int lba;
  signed int nwa = -123456789;
  signed int aux_lba;
  enum burn_disc_status s;
  struct burn_write_opts *o = (struct burn_write_opts *)(void *)0;
  s=burn_disc_get_status(drive);
  if(!((signed int)s == BURN_DISC_APPENDABLE))
  {
    if(msinfo_explicit == 0)
      return 2;

    fprintf(stderr, "SORRY: --msinfo can only operate on appendable media.\n");
    return 0;
  }

  else
  {
    ret=burn_disc_get_msc1(drive, &lba);
    if(!(ret >= 1))
    {
      fprintf(stderr, "SORRY: Cannot obtain start address of last session\n");
      ret = 0;
    }

    else
    {
      o=burn_write_opts_new(drive);
      if(!(o == ((struct burn_write_opts *)NULL)))
      {
        burn_write_opts_set_perform_opc(o, 0);
        burn_write_opts_set_write_type(o, (enum burn_write_types)BURN_WRITE_TAO, BURN_BLOCK_MODE1);
      }

      ret=burn_disc_track_lba_nwa(drive, o, 0, &aux_lba, &nwa);
      telltoc_regrab(drive);
      if(!(ret >= 1))
      {
        fprintf(stderr, "SORRY: Cannot obtain next writeable address\n");
        ret = 0;
      }

      else
      {
        if(msinfo_alone == 0)
          printf("Media msinfo : mkisofs ... -C ");

        printf("%d,%d\n", lba, nwa);
        ret = 1;
      }
    }

  ex:
    ;
    if(!(o == ((struct burn_write_opts *)NULL)))
      burn_write_opts_free(o);

    return ret;
  }
}

// telltoc_read_and_print
// file test/telltoc.c line 629
signed int telltoc_read_and_print(struct burn_drive *drive, signed int start_sector, signed int sector_count, char *raw_file, signed int encoding)
{
  signed int j;
  signed int i;
  signed int request = 16;
  signed int done;
  signed int lbas = 0;
  signed int final_cd_try = -1;
  signed int todo;
  signed int ret = 0;
  signed int sector_size;
  signed int chunk_size;
  signed int read_audio = 0;
  char buf[32768l];
  char line[81l];
  signed long int data_count;
  signed long int total_count = (signed long int)0;
  signed long int last_reported_count = (signed long int)0;
  struct stat stbuf;
  struct _IO_FILE *raw_fp = (struct _IO_FILE *)(void *)0;
  if(medium_is_cd_profile == 0)
    telltoc_detect_cd(drive);

  if(start_sector == -1)
    start_sector = last_track_start;

  if(sector_count == -1)
  {
    sector_count = (last_track_start + last_track_size) - start_sector;
    if(medium_is_cd_profile >= 1)
      final_cd_try = 0;

  }

  if(!(sector_count >= 1))
    sector_count = 2147483632;

  if(encoding == 1)
  {
    signed int return_value_stat$1;
    return_value_stat$1=stat(raw_file, &stbuf);
    if(!(return_value_stat$1 == -1))
    {
      if(!((61440u & stbuf.st_mode) == 4096u) && !((61440u & stbuf.st_mode) == 8192u) && !((61440u & stbuf.st_mode) == 49152u))
      {
        fprintf(stderr, "SORRY: target file '%s' already existing\n", raw_file);
        return 1;
      }

    }

    raw_fp=fopen(raw_file, "w");
    if(raw_fp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      fprintf(stderr, "SORRY: cannot open target file '%s' (%s)\n", raw_file, return_value_strerror$3);
      return 1;
    }

    printf("Data         : start=%ds , count=%ds , read=0s , encoding=%d:'%s'\n", start_sector, sector_count, encoding, raw_file);
  }

  else
    printf("Data         : start=%ds , count=%ds , read=0 , encoding=%d\n", start_sector, sector_count, encoding);
  if(cd_is_audio >= 1)
    read_audio = 1;

  else
    if(cd_is_audio == 0 && medium_is_cd_profile >= 1)
    {
      ret=burn_read_audio(drive, start_sector, buf, (signed long int)2352, &data_count, 2 | 4);
      if(ret >= 1)
        read_audio = 1;

    }

  if(!(read_audio == 0))
  {
    sector_size = 2352;
    chunk_size = 12;
  }

  else
  {
    sector_size = 2048;
    chunk_size = 16;
    if(!(start_sector >= 0))
      start_sector = 0;

  }
  todo = sector_count - 2 * (signed int)(final_cd_try > -1);
  done = 0;
  for( ; !(final_cd_try == 1) && !(done >= todo); done = done + request)
  {
    if(!(chunk_size >= todo + -done))
      request = chunk_size;

    else
      request = todo - done;
    if(!(read_audio == 0))
      ret=burn_read_audio(drive, start_sector + done, buf, (signed long int)(request * sector_size), &data_count, 0);

    else
      ret=burn_read_data(drive, ((signed long int)start_sector + (signed long int)done) * (signed long int)sector_size, buf, (signed long int)(request * sector_size), &data_count, 1);

  print_result:
    ;
    total_count = total_count + data_count;
    if(encoding == 1)
    {
      if(data_count >= 1l)
      {
        unsigned long int return_value_fwrite$4;
        return_value_fwrite$4=fwrite((const void *)buf, (unsigned long int)data_count, (unsigned long int)1, raw_fp);
        ret = (signed int)return_value_fwrite$4;
        if(!(ret >= 1))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          char *return_value_strerror$6;
          return_value_strerror$6=strerror(*return_value___errno_location$5);
          fprintf(stderr, "FAILURE: writing to '%s' : %s\n", raw_file, return_value_strerror$6);
          fclose(raw_fp);
          return 1;
        }

      }

    }

    else
    {
      i = 0;
      for( ; !((signed long int)i >= data_count); i = i + 16)
      {
        if(encoding == 0)
        {
          sprintf(line, "%8ds + %4d : ", start_sector + done + i / sector_size, i % sector_size);
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(line);
          lbas = (signed int)return_value_strlen$7;
        }

        j = 0;
        for( ; !(j >= 16) && !((signed long int)(i + j) >= data_count); j = j + 1)
        {
          _Bool tmp_if_expr$8;
          if((signed int)buf[(signed long int)(i + j)] >= 32)
            tmp_if_expr$8 = (signed int)buf[(signed long int)(i + j)] <= 126 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$8 = (_Bool)0;
          if(!(encoding == 2) && tmp_if_expr$8)
            sprintf(line + (signed long int)lbas + (signed long int)(3 * j), " %c ", (signed int)buf[(signed long int)(i + j)]);

          else
            sprintf(line + (signed long int)lbas + (signed long int)(3 * j), "%2.2X ", (unsigned char)buf[(signed long int)(i + j)]);
        }
        line[(signed long int)(lbas + 3 * (j - 1) + 2)] = (char)0;
        printf("%s\n", (const void *)line);
      }
    }
    if(encoding == 1 && total_count + -last_reported_count >= (signed long int)(1000 * sector_size))
    {
      fprintf(stderr, "\rReading data : start=%ds , count=%ds , read=%ds  ", start_sector, sector_count, (signed int)(total_count / (signed long int)sector_size));
      last_reported_count = total_count;
    }

    if(!(ret >= 1))
    {
      fprintf(stderr, "SORRY : Reading failed.\n");
      break;
    }

  }
  if(final_cd_try == 0 && medium_is_cd_profile >= 1 && ret >= 1)
  {
    final_cd_try = 1;
    if(!(read_audio == 0))
      ret=burn_read_audio(drive, start_sector + todo, buf, (signed long int)(2 * sector_size), &data_count, 2);

    else
      burn_read_data(drive, ((signed long int)start_sector + (signed long int)todo) * (signed long int)sector_size, buf, (signed long int)(2 * sector_size), &data_count, 2);
    if(!(data_count >= (signed long int)(2 * sector_size)))
      fprintf(stderr, "\rNOTE : Last two frames of CD track unreadable. This is normal if TAO track.\n");

    if(data_count >= 1l)
      goto print_result;

  }

  if(last_reported_count >= 1l)
    fprintf(stderr, "\r                                                                       \r");

  printf("End Of Data  : start=%ds , count=%ds , read=%ds\n", start_sector, sector_count, (signed int)(total_count / (signed long int)sector_size));
  if(!(raw_fp == ((struct _IO_FILE *)NULL)))
    fclose(raw_fp);

  return ret;
}

// telltoc_regrab
// file test/telltoc.c line 227
signed int telltoc_regrab(struct burn_drive *drive)
{
  signed int ret;
  if(!(drive_is_grabbed == 0))
    burn_drive_release(drive, 0);

  drive_is_grabbed = 0;
  ret=burn_drive_grab(drive, 0);
  if(!(ret == 0))
    drive_is_grabbed = 1;

  return (signed int)!(!(ret != 0));
}

// telltoc_setup
// file test/telltoc.c line 807
signed int telltoc_setup(signed int argc, char **argv)
{
  signed int i = 1;
  for( ; !(i >= argc); i = i + 1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(argv[(signed long int)i]);
    if(return_value_strlen$1 >= 4096ul)
    {
      fprintf(stderr, "Argument at position %d is much too long. (Max 4095)\n", i);
      return 2;
    }

  }
  i = 1;
  signed int return_value_strcmp$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strncmp$11;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$13;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strcmp$19;
    return_value_strcmp$19=strcmp(argv[(signed long int)i], "--drive");
    if(return_value_strcmp$19 == 0)
    {
      i = i + 1;
      if(i >= argc)
      {
        fprintf(stderr, "--drive requires an argument\n");
        return 1;
      }

      else
      {
        return_value_strcmp$4=strcmp(argv[(signed long int)i], "-");
        if(return_value_strcmp$4 == 0)
        {
          drive_adr[(signed long int)0] = (char)0;
          driveno = -1;
        }

        else
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*argv[(signed long int)i]]) == 0))
          {
            drive_adr[(signed long int)0] = (char)0;
            driveno=atoi(argv[(signed long int)i]);
          }

          else
          {
            unsigned long int return_value_strlen$2;
            return_value_strlen$2=strlen(argv[(signed long int)i]);
            if(return_value_strlen$2 >= 1024ul)
            {
              fprintf(stderr, "--drive address too long (max. %d)\n", 1024 - 1);
              return 2;
            }

            strcpy(drive_adr, argv[(signed long int)i]);
          }
        }
      }
    }

    else
    {
      return_value_strcmp$18=strcmp(argv[(signed long int)i], "--media");
      if(return_value_strcmp$18 == 0)
        do_media = 1;

      else
      {
        return_value_strcmp$17=strcmp(argv[(signed long int)i], "--msinfo");
        if(return_value_strcmp$17 == 0)
          do_msinfo = 1;

        else
        {
          return_value_strcmp$16=strcmp(argv[(signed long int)i], "--capacities");
          if(return_value_strcmp$16 == 0)
            do_capacities = 1;

          else
          {
            return_value_strcmp$15=strcmp(argv[(signed long int)i], "--toc");
            if(return_value_strcmp$15 == 0)
              do_toc = 1;

            else
            {
              return_value_strcmp$14=strcmp(argv[(signed long int)i], "--read_and_print");
              if(return_value_strcmp$14 == 0)
              {
                i = i + 3;
                if(i >= argc)
                {
                  fprintf(stderr, "--read_and_print requires three arguments: start count encoding(try 0, not 1)\n");
                  return 1;
                }

                __isoc99_sscanf(argv[(signed long int)(i - 2)], "%d", &read_start);
                __isoc99_sscanf(argv[(signed long int)(i - 1)], "%d", &read_count);
                print_encoding = 0;
                signed int return_value_strncmp$10;
                return_value_strncmp$10=strncmp(argv[(signed long int)i], "raw:", (unsigned long int)4);
                _Bool tmp_if_expr$12;
                if(return_value_strncmp$10 == 0)
                  tmp_if_expr$12 = (_Bool)1;

                else
                {
                  return_value_strncmp$11=strncmp(argv[(signed long int)i], "1:", (unsigned long int)2);
                  tmp_if_expr$12 = return_value_strncmp$11 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$12)
                {
                  print_encoding = 1;
                  char *return_value_strchr$5;
                  return_value_strchr$5=strchr(argv[(signed long int)i], 58);
                  strcpy(print_raw_file, return_value_strchr$5 + (signed long int)1);
                  signed int return_value_strcmp$6;
                  return_value_strcmp$6=strcmp(print_raw_file, "-");
                  if(return_value_strcmp$6 == 0)
                  {
                    fprintf(stderr, "--read_and_print does not write to \"-\" as stdout.\n");
                    return 1;
                  }

                }

                else
                {
                  return_value_strcmp$7=strcmp(argv[(signed long int)i], "hex");
                  _Bool tmp_if_expr$9;
                  if(return_value_strcmp$7 == 0)
                    tmp_if_expr$9 = (_Bool)1;

                  else
                  {
                    return_value_strcmp$8=strcmp(argv[(signed long int)i], "2");
                    tmp_if_expr$9 = return_value_strcmp$8 == 0 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$9)
                    print_encoding = 2;

                }
              }

              else
              {
                return_value_strcmp$13=strcmp(argv[(signed long int)i], "--help");
                if(return_value_strcmp$13 == 0)
                  print_help = 1;

                else
                {
                  fprintf(stderr, "Unidentified option: %s\n", argv[(signed long int)i]);
                  return 7;
                }
              }
            }
          }
        }
      }
    }
  }
  if(argc == 1)
    print_help = 1;

  if(!(print_help == 0))
  {
    printf("Usage: %s\n", argv[(signed long int)0]);
    printf("       [--drive <address>|<driveno>|\"-\"]\n");
    printf("       [--media]  [--capacities]  [--toc]  [--msinfo]\n");
    printf("       [--read_and_print <start> <count> \"0\"|\"hex\"|\"raw\":<path>]\n");
    printf("Examples\n");
    printf("A bus scan (needs rw-permissions to see a drive):\n");
    printf("  %s --drive -\n", argv[(signed long int)0]);
    printf("Obtain info about the type of loaded media:\n");
    printf("  %s --drive /dev/hdc --media\n", argv[(signed long int)0]);
    printf("Obtain table of content:\n");
    printf("  %s --drive /dev/hdc --toc\n", argv[(signed long int)0]);
    printf("Obtain parameters for option -C of program mkisofs:\n");
    printf("  msinfo=$(%s --drive /dev/hdc --msinfo 2>/dev/null)\n", argv[(signed long int)0]);
    printf("  mkisofs ... -C \"$msinfo\" ...\n");
    printf("Obtain what is available about drive 0 and its media\n");
    printf("  %s --drive 0\n", argv[(signed long int)0]);
    printf("View blocks 16 to 19 of audio or data CD or DVD or BD in human readable form\n");
    printf("  %s --drive /dev/sr1 --read_and_print 16 4 0 | less\n", argv[(signed long int)0]);
    printf("Copy last track from CD to file /tmp/data\n");
    printf("  %s --drive /dev/sr1 --toc --read_and_print -1 -1 raw:/tmp/data\n", argv[(signed long int)0]);
  }

  return 0;
}

// telltoc_speedlist
// file test/telltoc.c line 408
signed int telltoc_speedlist(struct burn_drive *drive)
{
  signed int ret;
  signed int has_modern_entries = 0;
  struct burn_speed_descriptor *speed_list;
  struct burn_speed_descriptor *sd;
  ret=burn_drive_get_speedlist(drive, &speed_list);
  if(!(ret >= 1))
  {
    fprintf(stderr, "SORRY: Cannot obtain speed list info\n");
    return 2;
  }

  else
  {
    sd = speed_list;
    for( ; !(sd == ((struct burn_speed_descriptor *)NULL)); sd = sd->next)
      if(sd->source == 2)
        has_modern_entries = 1;

    sd = speed_list;
    for( ; !(sd == ((struct burn_speed_descriptor *)NULL)); sd = sd->next)
    {
      if(!(has_modern_entries == 0))
      {
        if(!(sd->source >= 2))
          goto __CPROVER_DUMP_L9;

      }

      if(sd->write_speed >= 1)
      {
        printf("Speed descr. : %d kB/s", sd->write_speed);
        if(sd->end_lba >= 0)
          printf(", %.1f MiB", (double)sd->end_lba / 512.0);

        if(!(sd->profile_name[0l] == 0))
          printf(", %s", (const void *)sd->profile_name);

        printf("\n");
      }


    __CPROVER_DUMP_L9:
      ;
    }
    burn_drive_free_speedlist(&speed_list);
    return 1;
  }
}

// telltoc_toc
// file test/telltoc.c line 494
signed int telltoc_toc(struct burn_drive *drive)
{
  signed int num_sessions = 0;
  signed int num_tracks = 0;
  signed int lba = 0;
  signed int pmin;
  signed int psec;
  signed int pframe;
  signed int track_count = 0;
  signed int track_is_audio;
  signed int session_no;
  signed int track_no;
  struct burn_disc *disc = (struct burn_disc *)(void *)0;
  struct burn_session **sessions;
  struct burn_track **tracks;
  struct burn_toc_entry toc_entry;
  disc=burn_drive_get_disc(drive);
  if(disc == ((struct burn_disc *)NULL))
  {
    fprintf(stderr, "SORRY: Cannot obtain Table Of Content\n");
    return 2;
  }

  else
  {
    sessions=burn_disc_get_sessions(disc, &num_sessions);
    session_no = 0;
    for( ; !(session_no >= num_sessions); session_no = session_no + 1)
    {
      tracks=burn_session_get_tracks(sessions[(signed long int)session_no], &num_tracks);
      if(!(tracks == ((struct burn_track **)NULL)))
      {
        track_no = 0;
        for( ; !(track_no >= num_tracks); track_no = track_no + 1)
        {
          track_count = track_count + 1;
          burn_track_get_entry(tracks[(signed long int)track_no], &toc_entry);
          if(!((1 & (signed int)toc_entry.extensions_valid) == 0))
          {
            lba = toc_entry.start_lba;
            burn_lba_to_msf(lba, &pmin, &psec, &pframe);
          }

          else
          {
            pmin = (signed int)toc_entry.pmin;
            psec = (signed int)toc_entry.psec;
            pframe = (signed int)toc_entry.pframe;
            lba=burn_msf_to_lba(pmin, psec, pframe);
          }
          if(!((7 & (signed int)toc_entry.control) >= 4))
          {
            if(cd_is_audio == 0)
              cd_is_audio = 1;

            track_is_audio = 1;
          }

          else
          {
            track_is_audio = 0;
            cd_is_audio = -1;
          }
          printf("Media content: session %3d  ", session_no + 1);
          printf("track    %3d %s  lba: %9d  %4.2d:%2.2d:%2.2d\n", track_count, track_is_audio != 0 ? "audio" : "data ", lba, pmin, psec, pframe);
          last_track_start = lba;
        }
        burn_session_get_leadout_entry(sessions[(signed long int)session_no], &toc_entry);
        if(!((1 & (signed int)toc_entry.extensions_valid) == 0))
        {
          lba = toc_entry.start_lba;
          burn_lba_to_msf(lba, &pmin, &psec, &pframe);
        }

        else
        {
          pmin = (signed int)toc_entry.pmin;
          psec = (signed int)toc_entry.psec;
          pframe = (signed int)toc_entry.pframe;
          lba=burn_msf_to_lba(pmin, psec, pframe);
        }
        printf("Media content: session %3d  ", session_no + 1);
        printf("leadout             lba: %9d  %4.2d:%2.2d:%2.2d\n", lba, pmin, psec, pframe);
        last_track_size = lba - last_track_start;
        telltoc_detect_cd(drive);
      }

    }
    if(!(disc == ((struct burn_disc *)NULL)))
      burn_disc_free(disc);

    return 1;
  }
}

// toc_find_modes
// file libburn/toc.h line 51
void toc_find_modes(struct burn_drive *d)
{
  signed int i;
  signed int j;
  struct buffer *mem = (struct buffer *)(void *)0;
  struct burn_toc_entry *e;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(struct buffer) /*69640ul*/ , (unsigned long int)1, 0);
  mem = (struct buffer *)return_value_burn_alloc_mem$1;
  if(!(mem == ((struct buffer *)NULL)))
  {
    mem->bytes = 0;
    mem->sectors = 1;
    i = 0;
    for( ; !(i >= d->disc->sessions); i = i + 1)
    {
      j = 0;
      for( ; !(j >= d->disc->session[(signed long int)i]->tracks); j = j + 1)
      {
        struct burn_track *t = d->disc->session[(signed long int)i]->track[(signed long int)j];
        e = t->entry;
        _Bool tmp_if_expr$2;
        if(!(e == ((struct burn_toc_entry *)NULL)))
          tmp_if_expr$2 = !(((signed int)e->control & 4) != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          t->mode = 1 << 6;

        else
          t->mode = 1 << 2;
      }
    }
  }


ex:
  ;
  if(!(mem == ((struct buffer *)NULL)))
    free((void *)(char *)mem);

}

// type_to_ctrl
// file libburn/write.c line 99
static signed int type_to_ctrl(signed int mode)
{
  signed int ctrl = 0;
  signed int data = 1 << 3 | 1 << 2 | 1 << 0;
  if(!((data & mode) == 0))
    ctrl = ctrl | 4;

  else
    if(!((64 & mode) == 0))
    {
      if(!((128 & mode) == 0))
        ctrl = ctrl | 8;

      if(!((512 & mode) == 0))
        ctrl = ctrl | 1;

    }

    else
      return -1;
  if(!((256 & mode) == 0))
    ctrl = ctrl | 2;

  return ctrl;
}

// type_to_form
// file libburn/write.c line 126
void type_to_form(signed int mode, unsigned char *ctladr, signed int *form)
{
  signed int ret;
  signed int return_value_type_to_ctrl$1;
  return_value_type_to_ctrl$1=type_to_ctrl(mode);
  ret = return_value_type_to_ctrl$1 << 4;
  if(ret == -1)
  {
    *ctladr = (unsigned char)0xff;
    *form = -1;
  }

  else
  {
    *ctladr = (unsigned char)ret;
    if(!((64 & mode) == 0))
      *form = 0;

    if(!((1 & mode) == 0))
      *form = -1;

    else
    {
      if(!((4 & mode) == 0))
        *form = 0x10;

      if(!((8 & mode) == 0))
        *form = -1;

      else
      {
        if(!((2 & mode) == 0))
          *form = 0;

        if(!((1024 & mode) == 0))
          *form = *form | 0x40;

        if(!((2048 & mode) == 0))
          *form = *form | 0xC0;

        if(!((4096 & mode) == 0))
          *form = *form | 0x40;

      }
    }
  }
}

// uncook_subs
// file libburn/sector.c line 52
static void uncook_subs(unsigned char *dest, unsigned char *source)
{
  signed int i;
  signed int j;
  signed int code;
  memset((void *)dest, 0, (unsigned long int)96);
  i = 0;
  for( ; !(i >= 12); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 8); j = j + 1)
    {
      code = 0;
      for( ; !(code >= 8); code = code + 1)
      {
        if(!((0x80 & (signed int)source[(signed long int)(12 * code + i)]) == 0))
          dest[(signed long int)(j + i * 8)] = dest[(signed long int)(j + i * 8)] | (unsigned char)(1 << 7 - code);

        source[(signed long int)(code * 12 + i)] = source[(signed long int)(code * 12 + i)] << 1;
      }
    }
  }
}

// unget_sector
// file libburn/sector.c line 313
static void unget_sector(struct burn_write_opts *opts, signed int inmode)
{
  struct burn_drive *d = opts->drive;
  struct buffer *out = d->buffer;
  signed int outmode;
  signed int seclen;
  outmode=get_outmode(opts);
  if(outmode == 0)
    outmode = inmode;

  seclen=burn_sector_length(outmode);
  if(seclen >= 1)
  {
    signed int return_value_burn_subcode_length$1;
    return_value_burn_subcode_length$1=burn_subcode_length(outmode);
    seclen = seclen + return_value_burn_subcode_length$1;
    out->bytes = out->bytes - seclen;
    out->sectors = out->sectors - 1;
  }

}

// v07t_apply_to_session
// file libburn/cdtext.c line 618
static signed int v07t_apply_to_session(struct burn_session *session, signed int block, signed int *char_codes, signed int *copyrights, signed int *languages, signed int *session_attr_seen, signed int *track_attr_seen, signed int genre_code, char *genre_text, signed int flag)
{
  signed int i;
  signed int ret;
  signed int length;
  char *line = (char *)(void *)0;
  void *return_value_burn_alloc_mem$1;
  return_value_burn_alloc_mem$1=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)4096, 0);
  line = (char *)return_value_burn_alloc_mem$1;
  if(line == ((char *)NULL))
    ret = -1;

  else
  {
    i = 0x80;
    for( ; !(i >= 143); i = i + 1)
      if(!(i >= 134) || i == 0x8e)
      {
        _Bool tmp_if_expr$2;
        if(!(session_attr_seen[(signed long int)(i + -128)] == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = !(track_attr_seen[(signed long int)(i - 0x80)] != 0) ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$2)
        {
          ret=v07t_cdtext_to_session(session, block, "", char_codes + (signed long int)block, i, (char *)(void *)0, 0);
          if(!(ret >= 1))
            goto ex;

        }

      }

    if(genre_code >= 0)
    {
      if(!(*genre_text == 0))
      {
        line[(signed long int)0] = (char)(genre_code >> 8 & 0xff);
        line[(signed long int)1] = (char)(genre_code & 0xff);
        strcpy(line + (signed long int)2, genre_text);
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(line + (signed long int)2);
        length = (signed int)((unsigned long int)2 + return_value_strlen$3 + (unsigned long int)1);
        ret=burn_session_set_cdtext(session, block, 0, "GENRE", (unsigned char *)line, length, 0);
        if(!(ret >= 1))
          goto ex;

      }

    }

    ret=burn_session_set_cdtext_par(session, char_codes, copyrights, languages, 0);
    if(ret >= 1)
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        languages[(signed long int)i] = -1;
        copyrights[(signed long int)i] = languages[(signed long int)i];
        char_codes[(signed long int)i] = copyrights[(signed long int)i];
      }
      i = 0;
      for( ; !(i >= 16); i = i + 1)
      {
        track_attr_seen[(signed long int)i] = 0;
        session_attr_seen[(signed long int)i] = track_attr_seen[(signed long int)i];
      }
      genre_text[(signed long int)0] = (char)0;
      ret = 1;
    }

  }

ex:
  ;
  if(!(line == ((char *)NULL)))
    free((void *)(char *)line);

  return ret;
}

// v07t_cdtext_char_code
// file libburn/cdtext.c line 492
static signed int v07t_cdtext_char_code(char *payload, signed int flag)
{
  signed int ret;
  char *msg = (char *)(void *)0;
  ret=v07t_hexcode(payload, 0);
  char *return_value_strstr$2;
  char *return_value_strstr$1;
  char *return_value_burn_printify$5;
  if(ret >= 0)
    return ret;

  else
  {
    char *return_value_strstr$3;
    return_value_strstr$3=strstr(payload, "8859");
    if(!(return_value_strstr$3 == ((char *)NULL)))
      return 0x00;

    else
    {
      return_value_strstr$2=strstr(payload, "ASCII");
      if(!(return_value_strstr$2 == ((char *)NULL)))
        return 0x01;

      else
      {
        return_value_strstr$1=strstr(payload, "JIS");
        if(!(return_value_strstr$1 == ((char *)NULL)))
          return 0x80;

      }
    }
    void *return_value_burn_alloc_mem$4;
    return_value_burn_alloc_mem$4=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
    msg = (char *)return_value_burn_alloc_mem$4;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      sprintf(msg, "Unknown v07t Text Code '%.80s'", payload);
      return_value_burn_printify$5=burn_printify(msg);
      libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$5, 0, 0);
      ret = -1;
    }

  ex:
    ;
    if(!(msg == ((char *)NULL)))
      free((void *)(char *)msg);

    return ret;
  }
}

// v07t_cdtext_genre_code
// file libburn/cdtext.c line 549
static signed int v07t_cdtext_genre_code(char *payload, signed int flag)
{
  signed int i;
  signed int ret;
  char *msg = (char *)(void *)0;
  ret=v07t_hexcode(payload, 1);
  signed int return_value_strcmp$1;
  char *return_value_burn_printify$3;
  if(ret >= 0)
    return ret;

  else
  {
    i = 0;
    for( ; !(i >= 28); i = i + 1)
    {
      static char *genres[28l] = { "Not Used", "Not Defined", "Adult Contemporary", "Alternative Rock", "Childrens Music", "Classical", "Contemporary Christian", "Country", "Dance", "Easy Listening", "Erotic", "Folk", "Gospel", "Hip Hop", "Jazz", "Latin", "Musical", "New Age", "Opera", "Operetta", "Pop Music", "Rap", "Reggae", "Rock Music", "Rhythm & Blues", "Sound Effects", "Spoken Word", "World Music" };
      return_value_strcmp$1=strcmp(genres[(signed long int)i], payload);
      if(return_value_strcmp$1 == 0)
        return i;

    }
    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      sprintf(msg, "Unknown v07t Genre Code '%.80s'", payload);
      return_value_burn_printify$3=burn_printify(msg);
      libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$3, 0, 0);
      ret = -1;
    }

  ex:
    ;
    if(!(msg == ((char *)NULL)))
      free((void *)(char *)msg);

    return ret;
  }
}

// v07t_cdtext_lang_code
// file libburn/cdtext.c line 519
static signed int v07t_cdtext_lang_code(char *payload, signed int flag)
{
  signed int i;
  signed int ret;
  char *msg = (char *)(void *)0;
  ret=v07t_hexcode(payload, 0);
  signed int return_value_strcmp$1;
  char *return_value_burn_printify$3;
  if(ret >= 0)
    return ret;

  else
  {
    if(!((signed int)*payload == 0))
    {
      i = 0;
      for( ; !(i >= 128); i = i + 1)
      {
        static char *languages[128l] = { "Unknown", "Albanian", "Breton", "Catalan", "Croatian", "Welsh", "Czech", "Danish", "German", "English", "Spanish", "Esperanto", "Estonian", "Basque", "Faroese", "French", "Frisian", "Irish", "Gaelic", "Galician", "Icelandic", "Italian", "Lappish", "Latin", "Latvian", "Luxembourgian", "Lithuanian", "Hungarian", "Maltese", "Dutch", "Norwegian", "Occitan", "Polish", "Portuguese", "Romanian", "Romansh", "Serbian", "Slovak", "Slovenian", "Finnish", "Swedish", "Turkish", "Flemish", "Wallon", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "Zulu", "Vietnamese", "Uzbek", "Urdu", "Ukrainian", "Thai", "Telugu", "Tatar", "Tamil", "Tadzhik", "Swahili", "Sranan Tongo", "Somali", "Sinhalese", "Shona", "Serbo-croat", "Ruthenian", "Russian", "Quechua", "Pushtu", "Punjabi", "Persian", "Papamiento", "Oriya", "Nepali", "Ndebele", "Marathi", "Moldavian", "Malaysian", "Malagasay", "Macedonian", "Laotian", "Korean", "Khmer", "Kazakh", "Kannada", "Japanese", "Indonesian", "Hindi", "Hebrew", "Hausa", "Gurani", "Gujurati", "Greek", "Georgian", "Fulani", "Dari", "Churash", "Chinese", "Burmese", "Bulgarian", "Bengali", "Bielorussian", "Bambora", "Azerbaijani", "Assamese", "Armenian", "Arabic", "Amharic" };
        return_value_strcmp$1=strcmp(languages[(signed long int)i], payload);
        if(return_value_strcmp$1 == 0)
          return i;

      }
    }

    void *return_value_burn_alloc_mem$2;
    return_value_burn_alloc_mem$2=burn_alloc_mem(sizeof(char) /*1ul*/ , (unsigned long int)160, 0);
    msg = (char *)return_value_burn_alloc_mem$2;
    if(msg == ((char *)NULL))
      ret = -1;

    else
    {
      sprintf(msg, "Unknown v07t Language Code '%.80s'", payload);
      return_value_burn_printify$3=burn_printify(msg);
      libdax_msgs_submit(libdax_messenger, -1, 0x00020191, 0x68000000, 0x30000000, return_value_burn_printify$3, 0, 0);
      ret = -1;
    }

  ex:
    ;
    if(!(msg == ((char *)NULL)))
      free((void *)(char *)msg);

    return ret;
  }
}

// v07t_cdtext_len_db
// file libburn/cdtext.c line 576
static signed int v07t_cdtext_len_db(char *payload, signed int *char_code, signed int *length, signed int *double_byte, signed int flag)
{
  if(!(*char_code >= 0))
    *char_code = 0x00;

  *double_byte = (signed int)(*char_code == 0x80);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(payload);
  *length = (signed int)(return_value_strlen$1 + (unsigned long int)1 + (unsigned long int)*double_byte);
  return 1;
}

// v07t_cdtext_to_session
// file libburn/cdtext.c line 587
static signed int v07t_cdtext_to_session(struct burn_session *session, signed int block, char *payload, signed int *char_code, signed int pack_type, char *pack_type_name, signed int flag)
{
  signed int length;
  signed int double_byte;
  signed int ret;
  ret=v07t_cdtext_len_db(payload, char_code, &length, &double_byte, 0);
  if(!(ret >= 1))
    return ret;

  else
  {
    ret=burn_session_set_cdtext(session, block, pack_type, pack_type_name, (unsigned char *)payload, length, double_byte);
    return ret;
  }
}

// v07t_cdtext_to_track
// file libburn/cdtext.c line 603
static signed int v07t_cdtext_to_track(struct burn_track *track, signed int block, char *payload, signed int *char_code, signed int pack_type, char *pack_type_name, signed int flag)
{
  signed int length;
  signed int double_byte;
  signed int ret;
  ret=v07t_cdtext_len_db(payload, char_code, &length, &double_byte, 0);
  if(!(ret >= 1))
    return ret;

  else
  {
    ret=burn_track_set_cdtext(track, block, pack_type, pack_type_name, (unsigned char *)payload, length, double_byte);
    return ret;
  }
}

// v07t_hexcode
// file libburn/cdtext.c line 453
static signed int v07t_hexcode(char *payload, signed int flag)
{
  unsigned int x;
  signed int lo;
  signed int hi;
  signed int l;
  char buf[10l];
  char *cpt;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(payload);
  l = (signed int)return_value_strlen$1;
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(payload, "0x", (unsigned long int)2);
  unsigned long int return_value_strlen$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  if(!(return_value_strncmp$2 == 0))
    return -1;

  else
    if((1 & flag) == 0 || !(l == 6) && !(l == 9))
    {
      return_value_strlen$3=strlen(payload);
      if(!(return_value_strlen$3 == 4ul))
        return -1;

      return_value___ctype_b_loc$4=__ctype_b_loc();
      _Bool tmp_if_expr$6;
      if(!((4096 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)payload[2l]]) == 0))
      {
        return_value___ctype_b_loc$5=__ctype_b_loc();
        tmp_if_expr$6 = ((signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)payload[(signed long int)3]] & (signed int)(unsigned short int)4096) != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        return -1;

      __isoc99_sscanf(payload + (signed long int)2, "%x", &x);
      return (signed int)x;
    }

    else
    {

    double_byte:
      ;
      strcpy(buf, payload);
      buf[(signed long int)4] = (char)0;
      hi=v07t_hexcode(buf, 0);
      unsigned long int return_value_strlen$7;
      return_value_strlen$7=strlen(payload);
      if(return_value_strlen$7 == 6ul)
      {
        buf[(signed long int)4] = payload[(signed long int)4];
        buf[(signed long int)2] = (char)48;
        buf[(signed long int)3] = (char)120;
        cpt = buf + (signed long int)2;
      }

      else
      {
        if(!((signed int)payload[4l] == 32))
        {
          if(!((signed int)payload[4l] == 9))
            return -1;

        }

        cpt = buf + (signed long int)5;
      }
      lo=v07t_hexcode(cpt, 0);
      if(!(hi >= 0) || !(lo >= 0))
        return -1;

      else
        return hi << 8 | lo;
    }
}

// write_disc_worker_func
// file libburn/async.c line 551
static void * write_disc_worker_func(struct w_list *w)
{
  struct burn_drive *d = w->u.write.drive;
  char msg[80l];
  struct anonymous$0 sigset;
  struct anonymous$0 oldset;
  sigfillset(&sigset);
  sigdelset(&sigset, 11);
  sigdelset(&sigset, 4);
  pthread_sigmask(2, &sigset, &oldset);
  d->thread_pid=getpid();
  d->thread_tid=pthread_self();
  d->thread_pid_valid = 1;
  burn_disc_write_sync(w->u.write.opts, w->u.write.disc);
  d->thread_pid_valid = 0;
  d->thread_pid = 0;
  burn_write_opts_free(w->u.write.opts);
  sprintf(msg, "Write thread on drive %d ended", d->global_index);
  libdax_msgs_submit(libdax_messenger, d->global_index, 0x00020178, 0x10000000, 0x30000000, msg, 0, 0);
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  remove_worker(return_value_pthread_self$1);
  d->busy = (volatile enum burn_drive_status)BURN_DRIVE_IDLE;
  pthread_sigmask(2, &oldset, (struct anonymous$0 *)(void *)0);
  return (void *)0;
}

// write_v07t_line
// file libburn/cdtext.c line 1203
static void write_v07t_line(char **respt, char *spec, char *value, signed int vlen, signed int *result_len, signed int flag)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  if(vlen == -1)
  {
    return_value_strlen$1=strlen(value);
    vlen = (signed int)return_value_strlen$1;
  }

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(spec);
  len = (signed int)return_value_strlen$2;
  if(!(len >= 19))
    len = 19;

  len = len + 3 + vlen + 1;
  unsigned long int return_value_strlen$3;
  if(!((1 & flag) == 0))
    *result_len = *result_len + len;

  else
  {
    sprintf(*respt, "%-19s = ", spec);
    if(vlen >= 1)
    {
      return_value_strlen$3=strlen(*respt);
      memcpy((void *)(*respt + (signed long int)return_value_strlen$3), (const void *)value, (unsigned long int)vlen);
    }

    (*respt)[(signed long int)(len - 1)] = (char)10;
    (*respt)[(signed long int)len] = (char)0;
    *respt = *respt + (signed long int)len;
  }
}

// write_v07t_textline
// file libburn/cdtext.c line 1359
static signed int write_v07t_textline(unsigned char *text_packs, signed int num_packs, signed int pack_type, signed int block, signed int tno, signed int first_tno, char *spec, char **respt, signed int *result_len, signed int flag)
{
  unsigned char *payload = (unsigned char *)(void *)0;
  unsigned char *text_start;
  signed int ret;
  signed int payload_count = 0;
  signed int text_len;
  signed int tab_flag = 0;
  char msg[80l];
  if(pack_type == 0x8e || pack_type >= 0x80 && !(pack_type >= 134))
    tab_flag = 2;

  ret=collect_payload(text_packs, num_packs, pack_type, block, &payload, &payload_count, 0);
  signed int return_value_strcmp$1;
  if(ret >= 1)
  {
    ret=pick_payload_text(payload, payload_count, tno, &text_start, &text_len, (signed int)(ret == 2) | tab_flag);
    if(ret >= 1)
    {
      _Bool tmp_if_expr$2;
      if(tno >= 1)
      {
        return_value_strcmp$1=strcmp(spec, "ISRC");
        tmp_if_expr$2 = return_value_strcmp$1 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        sprintf(msg, "%s %-2.2d", spec, (tno + first_tno) - 1);

      else
        if(tno >= 1)
          sprintf(msg, "Track %-2.2d %s", (tno + first_tno) - 1, spec);

        else
          strcpy(msg, spec);
      write_v07t_line(respt, msg, (char *)text_start, text_len, result_len, flag & 1);
      ret = 1;
    }

  }

  if(!(payload == ((unsigned char *)NULL)))
    free((void *)(char *)payload);

  return ret;
}

