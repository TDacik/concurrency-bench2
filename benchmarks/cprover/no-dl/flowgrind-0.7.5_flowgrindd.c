// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_13;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_10;

// tag-#anon#ST[*{cS8}_cS8_'config_file_name'||*{SYM#tag-xmlrpc_registry#}_SYM#tag-xmlrpc_registry#_'registryP'||*{V(*{V}_V_)->V}_V(*{V}_V_)->V_'runfirst'||*{V}_V_'runfirst_arg'||U32'port_number'||U32'_pad0'||*{cS8}_cS8_'log_file_name'||U32'keepalive_timeout'||U32'keepalive_max_conn'||U32'timeout'||S32'dont_advertise'||S32'socket_bound'||S32'socket_handle'||*{cS8}_cS8_'uri_path'||S32'chunk_response'||S32'enable_shutdown'||*{cS8}_cS8_'allow_origin'||S32'access_ctl_expires'||U32'access_ctl_max_age'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'sockaddr_p'||U32'sockaddrlen'||U32'max_conn'||U32'max_conn_backlog'||U32'_pad1'|]
// file /usr/include/xmlrpc-c/server_abyss.h line 73
struct anonymous_17;

// tag-#anon#ST[*{cS8}_cS8_'name'||U64'max'||U64'min'||U64'size'||*{V(*{V}_V_|U64)->V}_V(*{V}_V_|U64)->V_'set'||*{U64(*{V}_V_)->U64}_U64(*{V}_V_)->U64_'get'||*{F64(*{V}_V_)->F64}_F64(*{V}_V_)->F64_'get_double'|]
// file /usr/include/gsl/gsl_rng.h line 39
struct anonymous_25;

// tag-#anon#ST[*{cSYM#tag-#anon#ST[*{cS8}_cS8_'name'||U64'max'||U64'min'||U64'size'||*{V(*{V}_V_|U64)->V}_V(*{V}_V_|U64)->V_'set'||*{U64(*{V}_V_)->U64}_U64(*{V}_V_)->U64_'get'||*{F64(*{V}_V_)->F64}_F64(*{V}_V_)->F64_'get_double'|]#}_cSYM#tag-#anon#ST[*{cS8}_cS8_'name'||U64'max'||U64'min'||U64'size'||*{V(*{V}_V_|U64)->V}_V(*{V}_V_|U64)->V_'set'||*{U64(*{V}_V_)->U64}_U64(*{V}_V_)->U64_'get'||*{F64(*{V}_V_)->F64}_F64(*{V}_V_)->F64_'get_double'|]#_'type'||*{V}_V_'state'|]
// file /usr/include/gsl/gsl_rng.h line 51
struct anonymous_24;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_26;

// tag-#anon#ST[ARR16{U64}_U64_'__bits'|]
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 125
struct anonymous_27;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_22;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_1;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_0;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_6;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_8;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_15;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_7;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_12;

// tag-#anon#UN[*{S8}_S8_'ifcu_buf'||*{SYM#tag-ifreq#}_SYM#tag-ifreq#_'ifcu_req'|]
// file /usr/include/net/if.h line 179
union anonymous_4;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_16;

// tag-#anon#UN[ARR16{S8}_S8_'ifrn_name'|]
// file /usr/include/net/if.h line 130
union anonymous_2;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_23;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_14;

// tag-#anon#UN[ARR32{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_19;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_5;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_18;

// tag-#anon#UN[SYM#tag-sockaddr#'ifru_addr'||SYM#tag-sockaddr#'ifru_dstaddr'||SYM#tag-sockaddr#'ifru_broadaddr'||SYM#tag-sockaddr#'ifru_netmask'||SYM#tag-sockaddr#'ifru_hwaddr'||S16'ifru_flags'||S32'ifru_ivalue'||S32'ifru_mtu'||SYM#tag-ifmap#'ifru_map'||ARR16{S8}_S8_'ifru_slave'||ARR16{S8}_S8_'ifru_newname'||*{S8}_S8_'ifru_data'|]
// file /usr/include/net/if.h line 135
union anonymous_3;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_21;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_20;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_xmlrpc_env
// file /usr/include/xmlrpc-c/util.h line 135
struct _xmlrpc_env;

// tag-_xmlrpc_value
// file /usr/include/xmlrpc-c/base.h line 142
struct _xmlrpc_value;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-ap_Has_arg
// file src/fg_argparser.h line 35
enum ap_Has_arg { ap_no=0, ap_yes=1, ap_maybe=2 };

// tag-ap_Mutex_state
// file src/fg_argparser.h line 91
struct ap_Mutex_state;

// tag-ap_Option
// file src/fg_argparser.h line 45
struct ap_Option;

// tag-ap_Record
// file src/fg_argparser.h line 63
struct ap_Record;

// tag-arg_parser
// file src/fg_argparser.h line 73
struct arg_parser;

// tag-block
// file src/common.h line 137
struct block;

// tag-bpf_insn
// file /usr/include/pcap/bpf.h line 108
struct bpf_insn;

// tag-bpf_program
// file /usr/include/pcap/bpf.h line 106
struct bpf_program;

// tag-distributions
// file src/common.h line 119
enum distributions { CONSTANT=0, NORMAL=1, WEIBULL=2, UNIFORM=3, EXPONENTIAL=4, PARETO=5, LOGNORMAL=6 };

// tag-error_levels
// file src/fg_error.h line 57
enum error_levels { ERR_WARNING=0, ERR_ERROR=1, ERR_CRIT=2 };

// tag-extra_socket_options
// file src/common.h line 242
struct extra_socket_options;

// tag-fg_rpc_server
// file src/daemon.h line 242
struct fg_rpc_server;

// tag-fg_tcp_info
// file src/common.h line 253
struct fg_tcp_info;

// tag-flow
// file src/daemon.h line 73
struct flow;

// tag-flow_endpoint_type
// file src/common.h line 85
enum flow_endpoint_type { SOURCE=0, DESTINATION=1 };

// tag-flow_settings
// file src/common.h line 169
struct flow_settings;

// tag-flow_source_settings
// file src/daemon.h line 63
struct flow_source_settings;

// tag-flow_state
// file src/daemon.h line 53
enum flow_state { GRIND_WAIT_CONNECT=0, GRIND_WAIT_ACCEPT=1, GRIND=2 };

// tag-ifconf
// file /usr/include/net/if.h line 176
struct ifconf;

// tag-ifmap
// file /usr/include/net/if.h line 111
struct ifmap;

// tag-ifreq
// file /usr/include/net/if.h line 126
struct ifreq;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-linked_list
// file src/fg_list.h line 46
struct linked_list;

// tag-list_node
// file src/fg_list.h line 36
struct list_node;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-ncore_query
// file src/fg_affinity.h line 36
enum ncore_query { NCORE_CONFIG=0, NCORE_CURRENT=1 };

// tag-pcap
// file /usr/include/pcap/pcap.h line 79
struct pcap;

// tag-pcap_addr
// file /usr/include/pcap/pcap.h line 82
struct pcap_addr;

// tag-pcap_dumper
// file /usr/include/pcap/pcap.h line 80
struct pcap_dumper;

// tag-pcap_dumper_t
// file src/daemon.h line 163
struct pcap_dumper_t;

// tag-pcap_if
// file /usr/include/pcap/pcap.h line 81
struct pcap_if;

// tag-pcap_pkthdr
// file /usr/include/pcap/pcap.h line 160
struct pcap_pkthdr;

// tag-pcap_t
// file src/daemon.h line 162
struct pcap_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-report
// file src/common.h line 272
struct report;

// tag-request
// file src/daemon.h line 178
struct request;

// tag-request_add_flow_destination
// file src/daemon.h line 192
struct request_add_flow_destination;

// tag-request_add_flow_source
// file src/daemon.h line 205
struct request_add_flow_source;

// tag-request_get_status
// file src/daemon.h line 233
struct request_get_status;

// tag-request_start_flows
// file src/daemon.h line 219
struct request_start_flows;

// tag-request_stop_flow
// file src/daemon.h line 226
struct request_stop_flow;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-statistics
// file src/daemon.h line 122
struct statistics;

// tag-tcp_info
// file /usr/include/netinet/tcp.h line 202
struct tcp_info;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-trafgen_options
// file src/common.h line 155
struct trafgen_options;

// tag-utsname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 48
struct utsname;

// tag-xmlrpc_registry
// file /usr/include/xmlrpc-c/server.h line 26
struct xmlrpc_registry;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __isnan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnan(double);
// __isnanf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanf(float);
// __isnanl
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanl(long double);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_1 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_1 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_1 *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
extern signed int __xstat(signed int, const char *, struct stat *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// accept_data
// file src/destination.h line 36
signed int accept_data(struct flow *flow);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_error
// file src/fg_argparser.c line 104
static _Bool add_error(struct arg_parser * const ap, const char * const msg);
// add_flow_destination
// file src/destination.h line 35
void add_flow_destination(struct request_add_flow_destination *request);
// add_flow_destination_link1
// file src/flowgrindd.c line 403
static struct _xmlrpc_value * add_flow_destination_link1(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// add_flow_source
// file src/source.h line 35
signed int add_flow_source(struct request_add_flow_source *request);
// add_flow_source_link1
// file src/flowgrindd.c line 208
static struct _xmlrpc_value * add_flow_source_link1(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// add_report
// file src/daemon.c line 806
void add_report(struct report *report);
// ap_argument
// file src/fg_argparser.h line 157
const char * ap_argument(struct arg_parser * const ap, const signed int i);
// ap_arguments
// file src/fg_argparser.h line 137
signed int ap_arguments(struct arg_parser * const ap);
// ap_check_mutex
// file src/fg_argparser.c line 524
_Bool ap_check_mutex(struct arg_parser * const ap, struct ap_Mutex_state * const ms, const signed int i, signed int *conflict);
// ap_code
// file src/fg_argparser.h line 147
signed int ap_code(struct arg_parser * const ap, const signed int i);
// ap_error
// file src/fg_argparser.h line 129
const char * ap_error(struct arg_parser * const ap);
// ap_free
// file src/fg_argparser.h line 120
void ap_free(struct arg_parser * const ap);
// ap_free_mutex_state
// file src/fg_argparser.c line 580
void ap_free_mutex_state(struct ap_Mutex_state * const ms);
// ap_init
// file src/fg_argparser.h line 111
_Bool ap_init(struct arg_parser * const ap, const signed int argc, const char * const *argv, struct ap_Option *options, const char in_order);
// ap_init_mutex_state
// file src/fg_argparser.c line 513
_Bool ap_init_mutex_state(struct arg_parser * const ap, struct ap_Mutex_state * const ms);
// ap_is_used
// file src/fg_argparser.h line 185
_Bool ap_is_used(struct arg_parser * const ap, signed int code);
// ap_opt_string
// file src/fg_argparser.c line 483
const char * ap_opt_string(struct arg_parser * const ap, const signed int i);
// ap_option
// file src/fg_argparser.c line 491
struct ap_Option * ap_option(struct arg_parser * const ap, const signed int i);
// ap_reset_mutex
// file src/fg_argparser.c line 575
void ap_reset_mutex(struct ap_Mutex_state * const ms);
// ap_resize_buffer
// file src/fg_argparser.c line 48
static void * ap_resize_buffer(void *buf, const signed int min_size);
// ap_set_check_mutex
// file src/fg_argparser.c line 566
_Bool ap_set_check_mutex(struct arg_parser * const ap, struct ap_Mutex_state * const ms, const signed int i, signed int *conflict);
// ap_set_mutex
// file src/fg_argparser.c line 550
_Bool ap_set_mutex(struct arg_parser * const ap, struct ap_Mutex_state * const ms, const signed int i);
// apply_extra_socket_options
// file src/daemon.c line 1350
signed int apply_extra_socket_options(struct flow *flow);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// asprintf_append
// file src/fg_string.c line 98
signed int asprintf_append(char **strp, const char *fmt, ...);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bind_daemon_to_core
// file src/flowgrindd.c line 967
void bind_daemon_to_core(void);
// bind_rpc_server
// file src/flowgrindd.c line 863
static signed int bind_rpc_server(char *bind_addr, unsigned int port);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// calculate
// file src/trafgen.c line 50
static inline double calculate(struct flow *flow, enum distributions type, double param_one, double param_two);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// clock_getres
// file /usr/include/time.h line 339
extern signed int clock_getres(signed int, struct timespec *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// copy_options
// file src/fg_argparser.c line 338
static _Bool copy_options(struct arg_parser * const ap, struct ap_Option *options);
// create_daemon_thread
// file src/flowgrindd.c line 844
void create_daemon_thread();
// create_listen_socket
// file src/destination.c line 78
static signed int create_listen_socket(struct flow *flow, char *bind_addr, unsigned short int *listen_port);
// create_node
// file src/fg_list.c line 105
static struct list_node * create_node(void * const data, struct list_node * const previous, struct list_node * const next);
// ctimespec
// file src/fg_time.c line 64
const char * ctimespec(struct timespec *tp);
// ctimespec_r
// file src/fg_time.c line 46
const char * ctimespec_r(struct timespec *tp, char *buf, unsigned long int size);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// daemon_main
// file src/daemon.c line 779
void * daemon_main(void *ptr);
// dispatch_request
// file src/flowgrindd.c line 171
static signed int dispatch_request(struct request *request, signed int type);
// dist_bernoulli
// file src/fg_math.c line 180
extern signed int dist_bernoulli(struct flow *flow, const double p);
// dist_chisq
// file src/fg_math.c line 220
extern double dist_chisq(struct flow *flow, const double nu);
// dist_exponential
// file src/fg_math.c line 124
extern double dist_exponential(struct flow *flow, const double mu);
// dist_lognormal
// file src/fg_math.c line 164
extern double dist_lognormal(struct flow *flow, const double zeta, const double sigma);
// dist_normal
// file src/fg_math.c line 150
extern double dist_normal(struct flow *flow, const double mu, const double sigma_square);
// dist_pareto
// file src/fg_math.c line 191
extern double dist_pareto(struct flow *flow, const double k, const double x_min);
// dist_uniform
// file src/fg_math.c line 137
extern double dist_uniform(struct flow *flow, const double minval, const double maxval);
// dist_weibull
// file src/fg_math.c line 207
extern double dist_weibull(struct flow *flow, const double alpha, const double beta);
// error
// file src/fg_error.h line 80
void error(enum error_levels level, signed int errnum, const char *fmt, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fesetround
// file /usr/include/fenv.h line 88
extern signed int fesetround(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fg_list_back
// file src/fg_list.c line 57
struct list_node * fg_list_back(struct linked_list * const list);
// fg_list_clear
// file src/fg_list.c line 217
signed int fg_list_clear(struct linked_list * const list);
// fg_list_front
// file src/fg_list.h line 69
struct list_node * fg_list_front(struct linked_list * const list);
// fg_list_init
// file src/fg_list.h line 61
signed int fg_list_init(struct linked_list * const list);
// fg_list_pop_back
// file src/fg_list.c line 186
void * fg_list_pop_back(struct linked_list * const list);
// fg_list_pop_front
// file src/fg_list.c line 142
void * fg_list_pop_front(struct linked_list * const list);
// fg_list_push_back
// file src/fg_list.h line 120
signed int fg_list_push_back(struct linked_list * const list, void * const data);
// fg_list_push_front
// file src/fg_list.c line 121
signed int fg_list_push_front(struct linked_list * const list, void * const data);
// fg_list_remove
// file src/fg_list.h line 87
signed int fg_list_remove(struct linked_list * const list, const void * const data);
// fg_list_size
// file src/fg_list.h line 139
unsigned long int fg_list_size(struct linked_list * const list);
// fg_nameinfo
// file src/fg_socket.h line 59
const char * fg_nameinfo(struct sockaddr *sa, unsigned int salen);
// fg_pcap_cleanup
// file src/fg_pcap.c line 101
void fg_pcap_cleanup(void *arg);
// fg_pcap_go
// file src/fg_pcap.h line 41
void fg_pcap_go(struct flow *flow);
// fg_pcap_init
// file src/fg_pcap.h line 40
void fg_pcap_init(void);
// fg_pcap_work
// file src/fg_pcap.c line 118
static void * fg_pcap_work(void *arg);
// fg_pcap_work::1::2::__cancel_routine_object
//
void __cancel_routine_object(void *);
// flow_block_scheduled
// file src/daemon.c line 160
static inline signed int flow_block_scheduled(struct timespec *now, struct flow *flow);
// flow_error
// file src/daemon.c line 119
void flow_error(struct flow *flow, const char *fmt, ...);
// flow_in_delay
// file src/daemon.c line 145
static inline signed int flow_in_delay(struct timespec *now, struct flow *flow, signed int direction);
// flow_sending
// file src/daemon.c line 152
static inline signed int flow_sending(struct timespec *now, struct flow *flow, signed int direction);
// fmtlen
// file src/fg_string.c line 61
unsigned long int fmtlen(const char *fmt, void **ap);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_data
// file src/fg_argparser.c line 122
static void free_data(struct arg_parser * const ap);
// free_math_functions
// file src/fg_math.h line 37
extern void free_math_functions(struct flow *flow);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_imtu
// file src/fg_socket.h line 57
signed int get_imtu(signed int fd);
// get_mutex_count
// file src/fg_argparser.c line 319
static signed int get_mutex_count(struct ap_Option *options);
// get_ncores
// file src/fg_affinity.h line 50
signed int get_ncores(enum ncore_query query);
// get_num_options
// file src/fg_argparser.c line 305
static signed int get_num_options(struct ap_Option *options);
// get_pmtu
// file src/fg_socket.h line 56
signed int get_pmtu(signed int fd);
// get_port
// file src/fg_socket.h line 62
signed int get_port(signed int fd);
// get_reports
// file src/daemon.c line 832
struct report * get_reports(signed int *has_more);
// get_tcp_info
// file src/daemon.c line 629
signed int get_tcp_info(struct flow *flow, struct fg_tcp_info *info);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, struct sockaddr *, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettime
// file src/fg_time.h line 123
signed int gettime(struct timespec *tp);
// gsl_ran_bernoulli
// file /usr/include/gsl/gsl_randist.h line 36
unsigned int gsl_ran_bernoulli(const struct anonymous_24 *, double);
// gsl_ran_chisq
// file /usr/include/gsl/gsl_randist.h line 56
double gsl_ran_chisq(const struct anonymous_24 *, const double);
// gsl_ran_exponential
// file /usr/include/gsl/gsl_randist.h line 47
double gsl_ran_exponential(const struct anonymous_24 *, const double);
// gsl_ran_flat
// file /usr/include/gsl/gsl_randist.h line 69
double gsl_ran_flat(const struct anonymous_24 *, const double, const double);
// gsl_ran_gaussian
// file /usr/include/gsl/gsl_randist.h line 78
double gsl_ran_gaussian(const struct anonymous_24 *, const double);
// gsl_ran_lognormal
// file /usr/include/gsl/gsl_randist.h line 114
double gsl_ran_lognormal(const struct anonymous_24 *, const double, const double);
// gsl_ran_pareto
// file /usr/include/gsl/gsl_randist.h line 135
double gsl_ran_pareto(const struct anonymous_24 *, double, const double);
// gsl_ran_weibull
// file /usr/include/gsl/gsl_randist.h line 158
double gsl_ran_weibull(const struct anonymous_24 *, const double, const double);
// gsl_rng_alloc
// file /usr/include/gsl/gsl_rng.h line 130
struct anonymous_24 * gsl_rng_alloc(const struct anonymous_25 *);
// gsl_rng_env_setup
// file /usr/include/gsl/gsl_rng.h line 149
const struct anonymous_25 * gsl_rng_env_setup(void);
// gsl_rng_free
// file /usr/include/gsl/gsl_rng.h line 134
void gsl_rng_free(struct anonymous_24 *);
// gsl_rng_set
// file /usr/include/gsl/gsl_rng.h line 136
void gsl_rng_set(const struct anonymous_24 *, unsigned long int);
// inet_ntoa
// file /usr/include/arpa/inet.h line 53
extern char * inet_ntoa(struct in_addr);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// init_flow
// file src/daemon.c line 865
void init_flow(struct flow *flow, signed int is_source);
// init_math_functions
// file src/fg_math.h line 36
extern void init_math_functions(struct flow *flow, unsigned long int seed);
// init_rpc_server
// file src/flowgrindd.c line 914
static void init_rpc_server(struct fg_rpc_server *server, unsigned int port);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// logging_exit
// file src/log.c line 58
void logging_exit(void);
// logging_init
// file src/log.h line 45
void logging_init(void);
// logging_log
// file src/log.h line 47
void logging_log(signed int priority, const char *fmt, ...);
// logging_log_string
// file src/log.c line 86
void logging_log_string(signed int priority, const char *s);
// logging_time
// file src/log.c line 99
char * logging_time(void);
// main::_tmp::return_value_signal_2_object
//
void return_value_signal_2_object(signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// method_get_reports
// file src/flowgrindd.c line 628
static struct _xmlrpc_value * method_get_reports(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// method_get_status
// file src/flowgrindd.c line 808
static struct _xmlrpc_value * method_get_status(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// method_get_version
// file src/flowgrindd.c line 776
static struct _xmlrpc_value * method_get_version(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// method_stop_flow
// file src/flowgrindd.c line 731
static struct _xmlrpc_value * method_stop_flow(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// name2socket
// file src/source.c line 76
static signed int name2socket(struct flow *flow, char *server_name, unsigned int port, struct sockaddr **saptr, unsigned int *lenp, char do_connect, const signed int read_buffer_size_req, signed int *read_buffer_size, const signed int send_buffer_size_req, signed int *send_buffer_size);
// next_interpacket_gap
// file src/trafgen.h line 35
extern double next_interpacket_gap(struct flow *flow);
// next_request_block_size
// file src/trafgen.h line 33
extern signed int next_request_block_size(struct flow *flow);
// next_response_block_size
// file src/trafgen.h line 34
extern signed int next_response_block_size(struct flow *flow);
// normalize_tp
// file src/fg_time.c line 97
_Bool normalize_tp(struct timespec *tp);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parse_cmdline
// file src/flowgrindd.c line 1019
static void parse_cmdline(signed int argc, char **argv);
// parse_long_option
// file src/fg_argparser.c line 153
static _Bool parse_long_option(struct arg_parser * const ap, const char * const opt, const char * const arg, struct ap_Option *options, signed int * const argindp);
// parse_rpc_address
// file src/fg_argparser.c line 590
void parse_rpc_address(char **rpc_address, signed int *port, _Bool *is_ipv6);
// parse_short_option
// file src/fg_argparser.c line 242
static _Bool parse_short_option(struct arg_parser * const ap, const char * const opt, const char * const arg, struct ap_Option *options, signed int * const argindp);
// pcap_close
// file /usr/include/pcap/pcap.h line 371
void pcap_close(struct pcap *);
// pcap_compile
// file /usr/include/pcap/pcap.h line 389
signed int pcap_compile(struct pcap *, struct bpf_program *, const char *, signed int, unsigned int);
// pcap_dispatch
// file /usr/include/pcap/pcap.h line 373
signed int pcap_dispatch(struct pcap *, signed int, void (*)(unsigned char *, struct pcap_pkthdr *, const unsigned char *), unsigned char *);
// pcap_dump
// file /usr/include/pcap/pcap.h line 420
void pcap_dump(unsigned char *, struct pcap_pkthdr *, const unsigned char *);
// pcap_dump_close
// file /usr/include/pcap/pcap.h line 419
void pcap_dump_close(struct pcap_dumper *);
// pcap_dump_open
// file /usr/include/pcap/pcap.h line 413
struct pcap_dumper * pcap_dump_open(struct pcap *, const char *);
// pcap_findalldevs
// file /usr/include/pcap/pcap.h line 422
signed int pcap_findalldevs(struct pcap_if **, char *);
// pcap_geterr
// file /usr/include/pcap/pcap.h line 387
char * pcap_geterr(struct pcap *);
// pcap_lookupnet
// file /usr/include/pcap/pcap.h line 275
signed int pcap_lookupnet(const char *, unsigned int *, unsigned int *, char *);
// pcap_open_live
// file /usr/include/pcap/pcap.h line 349
struct pcap * pcap_open_live(const char *, signed int, signed int, signed int, char *);
// pcap_setfilter
// file /usr/include/pcap/pcap.h line 379
signed int pcap_setfilter(struct pcap *, struct bpf_program *);
// pcap_setnonblock
// file /usr/include/pcap/pcap.h line 382
signed int pcap_setnonblock(struct pcap *, signed int, char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// prepare_fds
// file src/daemon.c line 271
static signed int prepare_fds();
// prepare_rfds
// file src/daemon.c line 233
static signed int prepare_rfds(struct timespec *now, struct flow *flow, struct anonymous_26 *rfds);
// prepare_wfds
// file src/daemon.c line 199
static void prepare_wfds(struct timespec *now, struct flow *flow, struct anonymous_26 *wfds);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_delay
// file src/daemon.c line 1236
static void process_delay(struct flow *flow);
// process_dump_dir
// file src/flowgrindd.c line 981
signed int process_dump_dir();
// process_iat
// file src/daemon.c line 1203
static void process_iat(struct flow *flow);
// process_requests
// file src/daemon.c line 443
static void process_requests();
// process_rtt
// file src/daemon.c line 1172
static void process_rtt(struct flow *flow);
// process_select
// file src/daemon.c line 708
static void process_select(struct anonymous_26 *rfds, struct anonymous_26 *wfds, struct anonymous_26 *efds);
// pselect
// file /usr/include/x86_64-linux-gnu/sys/select.h line 118
extern signed int pselect(signed int, struct anonymous_26 *, struct anonymous_26 *, struct anonymous_26 *, struct timespec *, const struct anonymous_22 *);
// pthread_barrier_init
// file /usr/include/pthread.h line 1070
extern signed int pthread_barrier_init(union anonymous *, const union anonymous_19 *, unsigned int);
// pthread_barrier_wait
// file /usr/include/pthread.h line 1080
extern signed int pthread_barrier_wait(union anonymous *);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_5 *, const union anonymous_19 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_5 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_5 *, union anonymous_18 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_getaffinity
// file src/fg_affinity.c line 85
signed int pthread_getaffinity(unsigned long int thread, unsigned int *core);
// pthread_getaffinity_np
// file /usr/include/pthread.h line 481
extern signed int pthread_getaffinity_np(unsigned long int, unsigned long int, struct anonymous_27 *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_18 *, const union anonymous_19 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_18 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_18 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setaffinity
// file src/fg_affinity.h line 59
signed int pthread_setaffinity(unsigned long int thread, unsigned int core);
// pthread_setaffinity_np
// file /usr/include/pthread.h line 476
extern signed int pthread_setaffinity_np(unsigned long int, unsigned long int, const struct anonymous_27 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// push_back_record
// file src/fg_argparser.c line 66
static _Bool push_back_record(struct arg_parser * const ap, const signed int option_index, _Bool long_opt, const char * const argument);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_data
// file src/daemon.c line 1078
static signed int read_data(struct flow *flow);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// remove_flow
// file src/daemon.c line 191
void remove_flow(struct flow * const flow);
// report_flow
// file src/daemon.c line 502
static void report_flow(struct flow *flow, signed int type);
// request_error
// file src/daemon.c line 132
void request_error(struct request *request, const char *fmt, ...);
// round
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 309
extern double round(double);
// run_rpc_server
// file src/flowgrindd.c line 956
void run_rpc_server(struct fg_rpc_server *server);
// sanity_check
// file src/flowgrindd.c line 1105
static void sanity_check(void);
// send_response
// file src/daemon.c line 1267
static void send_response(struct flow *flow, signed int requested_response_block_size);
// set_congestion_control
// file src/fg_socket.h line 38
signed int set_congestion_control(signed int fd, const char *cc_alg);
// set_dscp
// file src/fg_socket.h line 49
signed int set_dscp(signed int fd, signed int dscp);
// set_flow_tcp_options
// file src/daemon.c line 1396
signed int set_flow_tcp_options(struct flow *flow);
// set_ip_mtu_discover
// file src/fg_socket.h line 55
signed int set_ip_mtu_discover(signed int fd);
// set_keepalive
// file src/fg_socket.c line 259
signed int set_keepalive(signed int fd, signed int how);
// set_nodelay
// file src/fg_socket.c line 184
signed int set_nodelay(signed int fd);
// set_non_blocking
// file src/fg_socket.h line 42
signed int set_non_blocking(signed int fd);
// set_progname
// file src/fg_progname.c line 37
void set_progname(const char *argv0);
// set_route_record
// file src/fg_socket.h line 43
signed int set_route_record(signed int fd);
// set_so_debug
// file src/fg_socket.h line 39
signed int set_so_debug(signed int fd);
// set_so_elcn
// file src/fg_socket.h line 45
signed int set_so_elcn(signed int fd, signed int val);
// set_so_lcd
// file src/fg_socket.h line 46
signed int set_so_lcd(signed int fd);
// set_tcp_cork
// file src/fg_socket.h line 50
signed int set_tcp_cork(signed int fd);
// set_tcp_mtcp
// file src/fg_socket.h line 47
signed int set_tcp_mtcp(signed int fd);
// set_tcp_nodelay
// file src/fg_socket.h line 48
signed int set_tcp_nodelay(signed int fd);
// set_window_size
// file src/fg_socket.c line 118
signed int set_window_size(signed int fd, signed int window);
// set_window_size_directed
// file src/fg_socket.h line 53
signed int set_window_size_directed(signed int fd, signed int window, signed int direction);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_22 *);
// sighandler
// file src/flowgrindd.c line 142
static void sighandler(signed int sig);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sockaddr_compare
// file src/fg_socket.c line 390
char sockaddr_compare(struct sockaddr *a, struct sockaddr *b);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_flows
// file src/daemon.c line 337
static void start_flows(struct request_start_flows *request);
// start_flows_link1
// file src/flowgrindd.c line 584
static struct _xmlrpc_value * start_flows_link1(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// stop_flow
// file src/daemon.c line 386
static void stop_flow(struct request_stop_flow *request);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup_append
// file src/fg_string.c line 76
char * strdup_append(char *s, const char *a);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strlendup_append
// file src/fg_string.c line 47
static inline char * strlendup_append(char *s, unsigned long int slen, const char *a, unsigned long int alen);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strndup_append
// file src/fg_string.c line 87
char * strndup_append(char *s, const char *a, unsigned long int n);
// strnlen
// file /usr/include/string.h line 405
extern unsigned long int strnlen(const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// time_add
// file src/fg_time.h line 110
void time_add(struct timespec *tp, double seconds);
// time_diff
// file src/fg_time.h line 73
double time_diff(struct timespec *tp1, struct timespec *tp2);
// time_diff_now
// file src/fg_time.h line 81
double time_diff_now(struct timespec *tp);
// time_is_after
// file src/fg_time.h line 91
_Bool time_is_after(struct timespec *tp1, struct timespec *tp2);
// timer_check
// file src/daemon.c line 670
static void timer_check();
// toggle_tcp_cork
// file src/fg_socket.h line 51
signed int toggle_tcp_cork(signed int fd);
// try_read_n_bytes
// file src/daemon.c line 1019
static inline signed int try_read_n_bytes(struct flow *flow, signed int bytes);
// tzset
// file /usr/include/time.h line 293
extern void tzset(void);
// uname
// file /usr/include/x86_64-linux-gnu/sys/utsname.h line 81
extern signed int uname(struct utsname *);
// uninit_flow
// file src/daemon.c line 165
void uninit_flow(struct flow *flow);
// usage
// file src/flowgrindd.c line 111
static void usage(signed short int status);
// vasprintf
// file /usr/include/stdio.h line 399
extern signed int vasprintf(char ** restrict , const char *, void **);
// vasprintf_append
// file src/fg_string.c line 109
signed int vasprintf_append(char **strp, const char *fmt, void **ap);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_data
// file src/daemon.c line 905
static signed int write_data(struct flow *flow);
// xmlrpc_DECREF
// file /usr/include/xmlrpc-c/base.h line 162
extern void xmlrpc_DECREF(struct _xmlrpc_value *);
// xmlrpc_array_append_item
// file /usr/include/xmlrpc-c/base.h line 438
void xmlrpc_array_append_item(struct _xmlrpc_env *, struct _xmlrpc_value *, struct _xmlrpc_value *);
// xmlrpc_array_new
// file /usr/include/xmlrpc-c/base.h line 427
struct _xmlrpc_value * xmlrpc_array_new(struct _xmlrpc_env *);
// xmlrpc_array_read_item
// file /usr/include/xmlrpc-c/base.h line 444
void xmlrpc_array_read_item(struct _xmlrpc_env *, const struct _xmlrpc_value *, const unsigned int, struct _xmlrpc_value ** const );
// xmlrpc_array_size
// file /usr/include/xmlrpc-c/base.h line 433
signed int xmlrpc_array_size(struct _xmlrpc_env *, const struct _xmlrpc_value *);
// xmlrpc_build_value
// file /usr/include/xmlrpc-c/base.h line 661
struct _xmlrpc_value * xmlrpc_build_value(struct _xmlrpc_env *, const char *, ...);
// xmlrpc_decompose_value
// file /usr/include/xmlrpc-c/base.h line 676
void xmlrpc_decompose_value(struct _xmlrpc_env *, struct _xmlrpc_value *, const char *, ...);
// xmlrpc_env_init
// file /usr/include/xmlrpc-c/util.h line 144
void xmlrpc_env_init(struct _xmlrpc_env *);
// xmlrpc_env_set_fault
// file /usr/include/xmlrpc-c/util.h line 153
void xmlrpc_env_set_fault(struct _xmlrpc_env *, const signed int, const char *);
// xmlrpc_int_new
// file /usr/include/xmlrpc-c/base.h line 170
struct _xmlrpc_value * xmlrpc_int_new(struct _xmlrpc_env *, const signed int);
// xmlrpc_read_base64
// file /usr/include/xmlrpc-c/base.h line 414
void xmlrpc_read_base64(struct _xmlrpc_env *, const struct _xmlrpc_value *, unsigned long int *, const unsigned char ** const );
// xmlrpc_read_int
// file /usr/include/xmlrpc-c/base.h line 175
void xmlrpc_read_int(struct _xmlrpc_env *, const struct _xmlrpc_value *, signed int *);
// xmlrpc_registry_add_method
// file /usr/include/xmlrpc-c/server.h line 81
void xmlrpc_registry_add_method(struct _xmlrpc_env *, struct xmlrpc_registry *, const char *, const char *, struct _xmlrpc_value * (*)(struct _xmlrpc_env *, struct _xmlrpc_value *, void *), void *);
// xmlrpc_registry_new
// file /usr/include/xmlrpc-c/server.h line 69
struct xmlrpc_registry * xmlrpc_registry_new(struct _xmlrpc_env *);
// xmlrpc_server_abyss
// file /usr/include/xmlrpc-c/server_abyss.h line 122
void xmlrpc_server_abyss(struct _xmlrpc_env *, const struct anonymous_17 *, const unsigned int);
// xmlrpc_struct_read_value
// file /usr/include/xmlrpc-c/base.h line 528
void xmlrpc_struct_read_value(struct _xmlrpc_env *, struct _xmlrpc_value *, const char *, struct _xmlrpc_value ** const );

struct anonymous_13
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_10
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_17
{
  // config_file_name
  const char *config_file_name;
  // registryP
  struct xmlrpc_registry *registryP;
  // runfirst
  void (*runfirst)(void *);
  // runfirst_arg
  void *runfirst_arg;
  // port_number
  unsigned int port_number;
  // log_file_name
  const char *log_file_name;
  // keepalive_timeout
  unsigned int keepalive_timeout;
  // keepalive_max_conn
  unsigned int keepalive_max_conn;
  // timeout
  unsigned int timeout;
  // dont_advertise
  signed int dont_advertise;
  // socket_bound
  signed int socket_bound;
  // socket_handle
  signed int socket_handle;
  // uri_path
  const char *uri_path;
  // chunk_response
  signed int chunk_response;
  // enable_shutdown
  signed int enable_shutdown;
  // allow_origin
  const char *allow_origin;
  // access_ctl_expires
  signed int access_ctl_expires;
  // access_ctl_max_age
  unsigned int access_ctl_max_age;
  // sockaddr_p
  struct sockaddr *sockaddr_p;
  // sockaddrlen
  unsigned int sockaddrlen;
  // max_conn
  unsigned int max_conn;
  // max_conn_backlog
  unsigned int max_conn_backlog;
};

struct anonymous_25
{
  // name
  const char *name;
  // max
  unsigned long int max;
  // min
  unsigned long int min;
  // size
  unsigned long int size;
  // set
  void (*set)(void *, unsigned long int);
  // get
  unsigned long int (*get)(void *);
  // get_double
  double (*get_double)(void *);
};

struct anonymous_24
{
  // type
  const struct anonymous_25 *type;
  // state
  void *state;
};

struct anonymous_26
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_27
{
  // __bits
  unsigned long int __bits[16l];
};

struct anonymous_22
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_0
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_1
{
  // __cancel_jmp_buf
  struct anonymous_0 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_11
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_6
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_7
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_12
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_14
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_6 _kill;
  // _timer
  struct anonymous_7 _timer;
  // _rt
  struct anonymous_8 _rt;
  // _sigchld
  struct anonymous_9 _sigchld;
  // _sigfault
  struct anonymous_10 _sigfault;
  // _sigpoll
  struct anonymous_12 _sigpoll;
  // _sigsys
  struct anonymous_13 _sigsys;
};

struct anonymous_15
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_14 _sifields;
};

union anonymous_4
{
  // ifcu_buf
  char *ifcu_buf;
  // ifcu_req
  struct ifreq *ifcu_req;
};

union anonymous_16
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_15 *, void *);
};

union anonymous_2
{
  // ifrn_name
  char ifrn_name[16l];
};

union anonymous_23
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous_19
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_5
{
  // __data
  struct anonymous_11 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_18
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct ifmap
{
  // mem_start
  unsigned long int mem_start;
  // mem_end
  unsigned long int mem_end;
  // base_addr
  unsigned short int base_addr;
  // irq
  unsigned char irq;
  // dma
  unsigned char dma;
  // port
  unsigned char port;
};

union anonymous_3
{
  // ifru_addr
  struct sockaddr ifru_addr;
  // ifru_dstaddr
  struct sockaddr ifru_dstaddr;
  // ifru_broadaddr
  struct sockaddr ifru_broadaddr;
  // ifru_netmask
  struct sockaddr ifru_netmask;
  // ifru_hwaddr
  struct sockaddr ifru_hwaddr;
  // ifru_flags
  signed short int ifru_flags;
  // ifru_ivalue
  signed int ifru_ivalue;
  // ifru_mtu
  signed int ifru_mtu;
  // ifru_map
  struct ifmap ifru_map;
  // ifru_slave
  char ifru_slave[16l];
  // ifru_newname
  char ifru_newname[16l];
  // ifru_data
  char *ifru_data;
};

union anonymous_21
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_20
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _xmlrpc_env
{
  // fault_occurred
  signed int fault_occurred;
  // fault_code
  signed int fault_code;
  // fault_string
  char *fault_string;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct ap_Mutex_state
{
  // seen_records
  signed int *seen_records;
  // num_mutex
  signed int num_mutex;
};

struct ap_Option
{
  // code
  signed int code;
  // name
  char *name;
  // has_arg
  enum ap_Has_arg has_arg;
  // tag
  signed int tag;
  // mutex
  signed int *mutex;
};

struct ap_Record
{
  // opt_string
  char *opt_string;
  // argument
  char *argument;
  // option_index
  signed int option_index;
};

struct arg_parser
{
  // options
  struct ap_Option *options;
  // data
  struct ap_Record *data;
  // error
  char *error;
  // num_options
  signed int num_options;
  // data_size
  signed int data_size;
  // error_size
  signed int error_size;
  // num_mutex
  signed int num_mutex;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct block
{
  // this_block_size
  signed int this_block_size;
  // request_block_size
  signed int request_block_size;
  // data
  struct timespec data;
  // data2
  struct timespec data2;
};

struct bpf_insn
{
  // code
  unsigned short int code;
  // jt
  unsigned char jt;
  // jf
  unsigned char jf;
  // k
  unsigned int k;
};

struct bpf_program
{
  // bf_len
  unsigned int bf_len;
  // bf_insns
  struct bpf_insn *bf_insns;
};

struct extra_socket_options
{
  // level
  signed int level;
  // optname
  signed int optname;
  // optlen
  signed int optlen;
  // optval
  char optval[100l];
};

struct fg_rpc_server
{
  // env
  struct _xmlrpc_env env;
  // parms
  struct anonymous_17 parms;
};

struct fg_tcp_info
{
  // tcpi_snd_cwnd
  signed int tcpi_snd_cwnd;
  // tcpi_snd_ssthresh
  signed int tcpi_snd_ssthresh;
  // tcpi_unacked
  signed int tcpi_unacked;
  // tcpi_sacked
  signed int tcpi_sacked;
  // tcpi_lost
  signed int tcpi_lost;
  // tcpi_retrans
  signed int tcpi_retrans;
  // tcpi_retransmits
  signed int tcpi_retransmits;
  // tcpi_fackets
  signed int tcpi_fackets;
  // tcpi_reordering
  signed int tcpi_reordering;
  // tcpi_rtt
  signed int tcpi_rtt;
  // tcpi_rttvar
  signed int tcpi_rttvar;
  // tcpi_rto
  signed int tcpi_rto;
  // tcpi_backoff
  signed int tcpi_backoff;
  // tcpi_snd_mss
  signed int tcpi_snd_mss;
  // tcpi_ca_state
  signed int tcpi_ca_state;
};

struct trafgen_options
{
  // distribution
  enum distributions distribution;
  // param_one
  double param_one;
  // param_two
  double param_two;
};

struct flow_settings
{
  // bind_address
  char bind_address[1000l];
  // delay
  double delay[2l];
  // duration
  double duration[2l];
  // reporting_interval
  double reporting_interval;
  // requested_send_buffer_size
  signed int requested_send_buffer_size;
  // requested_read_buffer_size
  signed int requested_read_buffer_size;
  // maximum_block_size
  signed int maximum_block_size;
  // traffic_dump
  signed int traffic_dump;
  // so_debug
  signed int so_debug;
  // route_record
  signed int route_record;
  // pushy
  signed int pushy;
  // shutdown
  signed int shutdown;
  // write_rate_str
  const char *write_rate_str;
  // write_rate
  signed int write_rate;
  // random_seed
  unsigned int random_seed;
  // flow_control
  signed int flow_control;
  // byte_counting
  signed int byte_counting;
  // cork
  signed int cork;
  // nonagle
  signed int nonagle;
  // cc_alg
  char cc_alg[16l];
  // elcn
  signed int elcn;
  // lcd
  signed int lcd;
  // mtcp
  signed int mtcp;
  // dscp
  signed int dscp;
  // ipmtudiscover
  signed int ipmtudiscover;
  // request_trafgen_options
  struct trafgen_options request_trafgen_options;
  // response_trafgen_options
  struct trafgen_options response_trafgen_options;
  // interpacket_gap_trafgen_options
  struct trafgen_options interpacket_gap_trafgen_options;
  // extra_socket_options
  struct extra_socket_options extra_socket_options[10l];
  // num_extra_socket_options
  signed int num_extra_socket_options;
};

struct flow_source_settings
{
  // destination_host
  char destination_host[256l];
  // destination_port
  signed int destination_port;
  // late_connect
  signed int late_connect;
  // add_source_condition
  union anonymous_5 *add_source_condition;
};

struct statistics
{
  // bytes_read
  unsigned long long int bytes_read;
  // bytes_written
  unsigned long long int bytes_written;
  // request_blocks_read
  unsigned int request_blocks_read;
  // request_blocks_written
  unsigned int request_blocks_written;
  // response_blocks_read
  unsigned int response_blocks_read;
  // response_blocks_written
  unsigned int response_blocks_written;
  // iat_min
  double iat_min;
  // iat_max
  double iat_max;
  // iat_sum
  double iat_sum;
  // delay_min
  double delay_min;
  // delay_max
  double delay_max;
  // delay_sum
  double delay_sum;
  // rtt_min
  double rtt_min;
  // rtt_max
  double rtt_max;
  // rtt_sum
  double rtt_sum;
  // has_tcp_info
  signed int has_tcp_info;
  // tcp_info
  struct fg_tcp_info tcp_info;
};

struct flow
{
  // id
  signed int id;
  // state
  enum flow_state state;
  // endpoint
  enum flow_endpoint_type endpoint;
  // fd
  signed int fd;
  // listenfd_data
  signed int listenfd_data;
  // settings
  struct flow_settings settings;
  // source_settings
  struct flow_source_settings source_settings;
  // start_timestamp
  struct timespec start_timestamp[2l];
  // stop_timestamp
  struct timespec stop_timestamp[2l];
  // last_block_read
  struct timespec last_block_read;
  // last_block_written
  struct timespec last_block_written;
  // first_report_time
  struct timespec first_report_time;
  // last_report_time
  struct timespec last_report_time;
  // next_report_time
  struct timespec next_report_time;
  // next_write_block_timestamp
  struct timespec next_write_block_timestamp;
  // read_block
  char *read_block;
  // write_block
  char *write_block;
  // current_write_block_size
  unsigned int current_write_block_size;
  // current_read_block_size
  unsigned int current_read_block_size;
  // current_block_bytes_read
  unsigned int current_block_bytes_read;
  // current_block_bytes_written
  unsigned int current_block_bytes_written;
  // requested_server_test_port
  unsigned short int requested_server_test_port;
  // real_listen_send_buffer_size
  unsigned int real_listen_send_buffer_size;
  // real_listen_receive_buffer_size
  unsigned int real_listen_receive_buffer_size;
  // connect_called
  char connect_called;
  // finished
  char finished[2l];
  // pmtu
  signed int pmtu;
  // congestion_counter
  unsigned int congestion_counter;
  // addr
  struct sockaddr *addr;
  // addr_len
  unsigned int addr_len;
  // statistics
  struct statistics statistics[2l];
  // pcap_thread
  unsigned long int pcap_thread;
  // pcap_handle
  struct pcap_t *pcap_handle;
  // pcap_dumper
  struct pcap_dumper_t *pcap_dumper;
  // r
  struct anonymous_24 *r;
  // error
  char *error;
};

struct ifconf
{
  // ifc_len
  signed int ifc_len;
  // ifc_ifcu
  union anonymous_4 ifc_ifcu;
};

struct ifreq
{
  // ifr_ifrn
  union anonymous_2 ifr_ifrn;
  // ifr_ifru
  union anonymous_3 ifr_ifru;
};

struct in6_addr
{
  // __in6_u
  union anonymous_23 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct linked_list
{
  // head
  struct list_node *head;
  // tail
  struct list_node *tail;
  // size
  unsigned long int size;
};

struct list_node
{
  // data
  void *data;
  // next
  struct list_node *next;
  // previous
  struct list_node *previous;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct pcap_addr
{
  // next
  struct pcap_addr *next;
  // addr
  struct sockaddr *addr;
  // netmask
  struct sockaddr *netmask;
  // broadaddr
  struct sockaddr *broadaddr;
  // dstaddr
  struct sockaddr *dstaddr;
};

struct pcap_if
{
  // next
  struct pcap_if *next;
  // name
  char *name;
  // description
  char *description;
  // addresses
  struct pcap_addr *addresses;
  // flags
  unsigned int flags;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct pcap_pkthdr
{
  // ts
  struct timeval ts;
  // caplen
  unsigned int caplen;
  // len
  unsigned int len;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct report
{
  // id
  signed int id;
  // type
  signed int type;
  // begin
  struct timespec begin;
  // end
  struct timespec end;
  // bytes_read
  unsigned long long int bytes_read;
  // bytes_written
  unsigned long long int bytes_written;
  // request_blocks_read
  unsigned int request_blocks_read;
  // request_blocks_written
  unsigned int request_blocks_written;
  // response_blocks_read
  unsigned int response_blocks_read;
  // response_blocks_written
  unsigned int response_blocks_written;
  // iat_min
  double iat_min;
  // iat_max
  double iat_max;
  // iat_sum
  double iat_sum;
  // delay_min
  double delay_min;
  // delay_max
  double delay_max;
  // delay_sum
  double delay_sum;
  // rtt_min
  double rtt_min;
  // rtt_max
  double rtt_max;
  // rtt_sum
  double rtt_sum;
  // tcp_info
  struct fg_tcp_info tcp_info;
  // pmtu
  signed int pmtu;
  // imtu
  signed int imtu;
  // status
  signed int status;
  // next
  struct report *next;
};

struct request
{
  // type
  char type;
  // condition
  union anonymous_5 *condition;
  // error
  char *error;
  // next
  struct request *next;
};

struct request_add_flow_destination
{
  // r
  struct request r;
  // settings
  struct flow_settings settings;
  // flow_id
  signed int flow_id;
  // listen_data_port
  signed int listen_data_port;
  // real_listen_send_buffer_size
  signed int real_listen_send_buffer_size;
  // real_listen_read_buffer_size
  signed int real_listen_read_buffer_size;
};

struct request_add_flow_source
{
  // r
  struct request r;
  // settings
  struct flow_settings settings;
  // source_settings
  struct flow_source_settings source_settings;
  // flow_id
  signed int flow_id;
  // cc_alg
  char cc_alg[16l];
  // real_send_buffer_size
  signed int real_send_buffer_size;
  // real_read_buffer_size
  signed int real_read_buffer_size;
};

struct request_get_status
{
  // r
  struct request r;
  // started
  signed int started;
  // num_flows
  signed int num_flows;
};

struct request_start_flows
{
  // r
  struct request r;
  // start_timestamp
  signed int start_timestamp;
};

struct request_stop_flow
{
  // r
  struct request r;
  // flow_id
  signed int flow_id;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_16 __sigaction_handler;
  // sa_mask
  struct anonymous_22 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct tcp_info
{
  // tcpi_state
  unsigned char tcpi_state;
  // tcpi_ca_state
  unsigned char tcpi_ca_state;
  // tcpi_retransmits
  unsigned char tcpi_retransmits;
  // tcpi_probes
  unsigned char tcpi_probes;
  // tcpi_backoff
  unsigned char tcpi_backoff;
  // tcpi_options
  unsigned char tcpi_options;
  // tcpi_snd_wscale
  unsigned char tcpi_snd_wscale : 4;
  // tcpi_rcv_wscale
  unsigned char tcpi_rcv_wscale : 4;
  // tcpi_rto
  unsigned int tcpi_rto;
  // tcpi_ato
  unsigned int tcpi_ato;
  // tcpi_snd_mss
  unsigned int tcpi_snd_mss;
  // tcpi_rcv_mss
  unsigned int tcpi_rcv_mss;
  // tcpi_unacked
  unsigned int tcpi_unacked;
  // tcpi_sacked
  unsigned int tcpi_sacked;
  // tcpi_lost
  unsigned int tcpi_lost;
  // tcpi_retrans
  unsigned int tcpi_retrans;
  // tcpi_fackets
  unsigned int tcpi_fackets;
  // tcpi_last_data_sent
  unsigned int tcpi_last_data_sent;
  // tcpi_last_ack_sent
  unsigned int tcpi_last_ack_sent;
  // tcpi_last_data_recv
  unsigned int tcpi_last_data_recv;
  // tcpi_last_ack_recv
  unsigned int tcpi_last_ack_recv;
  // tcpi_pmtu
  unsigned int tcpi_pmtu;
  // tcpi_rcv_ssthresh
  unsigned int tcpi_rcv_ssthresh;
  // tcpi_rtt
  unsigned int tcpi_rtt;
  // tcpi_rttvar
  unsigned int tcpi_rttvar;
  // tcpi_snd_ssthresh
  unsigned int tcpi_snd_ssthresh;
  // tcpi_snd_cwnd
  unsigned int tcpi_snd_cwnd;
  // tcpi_advmss
  unsigned int tcpi_advmss;
  // tcpi_reordering
  unsigned int tcpi_reordering;
  // tcpi_rcv_rtt
  unsigned int tcpi_rcv_rtt;
  // tcpi_rcv_space
  unsigned int tcpi_rcv_space;
  // tcpi_total_retrans
  unsigned int tcpi_total_retrans;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct utsname
{
  // sysname
  char sysname[65l];
  // nodename
  char nodename[65l];
  // release
  char release[65l];
  // version
  char version[65l];
  // machine
  char machine[65l];
  // domainname
  char domainname[65l];
};


// alldevs
// file src/fg_pcap.c line 65
static struct pcap_if *alldevs;
// core
// file src/flowgrindd.c line 97
static signed int core;
// daemon_pipe
// file src/daemon.c line 85
signed int daemon_pipe[2l];
// daemon_thread
// file src/daemon.h line 250
unsigned long int daemon_thread;
// dump_dir
// file src/daemon.h line 269
char *dump_dir;
// dump_prefix
// file src/daemon.h line 268
char *dump_prefix;
// dumping
// file src/daemon.c line 104
char dumping = (char)0;
// efds
// file src/daemon.c line 92
struct anonymous_26 efds;
// errbuf
// file src/fg_pcap.c line 61
static char errbuf[256l];
// flows
// file src/daemon.c line 99
struct linked_list flows;
// gsl_rng_default
// file /usr/include/gsl/gsl_rng.h line 127
extern const struct anonymous_25 *gsl_rng_default;
// in6addr_any
// file /usr/include/netinet/in.h line 227
extern struct in6_addr in6addr_any;
// log_type
// file src/log.c line 40
signed int log_type = 0;
// logstr
// file src/log.c line 39
char *logstr = (char *)(void *)0;
// maxfd
// file src/daemon.c line 93
signed int maxfd;
// mutex
// file src/daemon.c line 89
union anonymous_18 mutex;
// next_flow_id
// file src/daemon.c line 87
signed int next_flow_id = 0;
// parser
// file src/flowgrindd.c line 100
static struct arg_parser parser;
// pcap_barrier
// file src/fg_pcap.c line 63
static union anonymous pcap_barrier;
// pending_reports
// file src/daemon.c line 97
unsigned int pending_reports = (unsigned int)0;
// port
// file src/flowgrindd.c line 91
static unsigned int port = (unsigned int)5999;
// progname
// file src/fg_progname.c line 35
const char *progname = (const char *)(void *)0;
// reports
// file src/daemon.c line 95
struct report *reports = ((struct report *)NULL);
// reports_last
// file src/daemon.c line 96
struct report *reports_last = ((struct report *)NULL);
// requests
// file src/daemon.c line 90
struct request *requests = ((struct request *)NULL);
// requests_last
// file src/daemon.c line 90
struct request *requests_last = ((struct request *)NULL);
// rfds
// file src/daemon.c line 92
struct anonymous_26 rfds;
// rpc_bind_addr
// file src/flowgrindd.c line 94
static char *rpc_bind_addr = (char *)(void *)0;
// started
// file src/daemon.c line 101
char started = (char)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// timestr
// file src/log.c line 38
char timestr[20l];
// wfds
// file src/daemon.c line 92
struct anonymous_26 wfds;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// accept_data
// file src/destination.h line 36
signed int accept_data(struct flow *flow)
{
  struct sockaddr_storage caddr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  unsigned int real_send_buffer_size;
  unsigned int real_receive_buffer_size;
  flow->fd=accept(flow->listenfd_data, (struct sockaddr *)&caddr, &addrlen);
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(flow->fd == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 4)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return 0;

    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    logging_log(1, "accept() failed: %s", return_value_strerror_5);
    return -1;
  }

  signed int return_value_close_6;
  return_value_close_6=close(flow->listenfd_data);
  if(return_value_close_6 == -1)
    logging_log(4, "close(): failed");

  flow->listenfd_data = -1;
  const char *return_value_fg_nameinfo_7;
  return_value_fg_nameinfo_7=fg_nameinfo((struct sockaddr *)&caddr, addrlen);
  logging_log(5, "client %s connected for testing.", return_value_fg_nameinfo_7);
  fg_pcap_go(flow);
  signed int return_value_set_window_size_directed_8;
  return_value_set_window_size_directed_8=set_window_size_directed(flow->fd, flow->settings.requested_send_buffer_size, 7);
  real_send_buffer_size = (unsigned int)return_value_set_window_size_directed_8;
  if(!(flow->requested_server_test_port == 0))
  {
    if(flow->real_listen_send_buffer_size == real_send_buffer_size)
      goto __CPROVER_DUMP_L6;

    logging_log(4, "Failed to set send buffer size of test socket to send buffer size size of listen socket (listen = %u, test = %u).", flow->real_listen_send_buffer_size, real_send_buffer_size);
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L6:
    ;
    signed int return_value_set_window_size_directed_9;
    return_value_set_window_size_directed_9=set_window_size_directed(flow->fd, flow->settings.requested_read_buffer_size, 8);
    real_receive_buffer_size = (unsigned int)return_value_set_window_size_directed_9;
    if(!(flow->requested_server_test_port == 0))
    {
      if(flow->real_listen_receive_buffer_size == real_receive_buffer_size)
        goto __CPROVER_DUMP_L7;

      logging_log(4, "Failed to set receive buffer size (advertised window) of test socket to receive buffer size of listen socket (listen = %u, test = %u).", flow->real_listen_receive_buffer_size, real_receive_buffer_size);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      signed int return_value_set_flow_tcp_options_10;
      return_value_set_flow_tcp_options_10=set_flow_tcp_options(flow);
      if(return_value_set_flow_tcp_options_10 == -1)
        return -1;

      else
      {

      __CPROVER_DUMP_L8:
        ;
        flow->state = (enum flow_state)GRIND;
        flow->connect_called = (char)1;
        return 0;
      }
    }
  }
}

// add_error
// file src/fg_argparser.c line 104
static _Bool add_error(struct arg_parser * const ap, const char * const msg)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(msg);
  len = (const signed int)return_value_strlen_1;
  void *tmp;
  tmp=ap_resize_buffer((void *)ap->error, ap->error_size + len + 1);
  if(tmp == NULL)
    return (_Bool)0;

  else
  {
    ap->error = (char *)tmp;
    __builtin_strncpy(ap->error + (signed long int)ap->error_size, msg, (unsigned long int)(len + 1));
    ap->error_size = ap->error_size + len;
    return (_Bool)1;
  }
}

// add_flow_destination
// file src/destination.h line 35
void add_flow_destination(struct request_add_flow_destination *request)
{
  struct flow *flow;
  unsigned short int server_data_port;
  unsigned long int return_value_fg_list_size_1;
  return_value_fg_list_size_1=fg_list_size(&flows);
  _Bool tmp_if_expr_5;
  char *tmp_if_expr_6;
  if(return_value_fg_list_size_1 >= 2048ul)
  {
    logging_log(4, "Can not accept another flow, already handling MAX_FLOW flows.");
    request_error(&request->r, "Can not accept another flow, already handling MAX_FLOW flows.");
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct flow) /*3248ul*/ );
    flow = (struct flow *)return_value_malloc_2;
    if(flow == ((struct flow *)NULL))
      logging_log(1, "could not allocate memory for flow");

    else
    {
      init_flow(flow, 0);
      flow->settings = request->settings;
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)flow->settings.maximum_block_size);
      flow->write_block = (char *)return_value_calloc_3;
      void *return_value_calloc_4;
      return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)flow->settings.maximum_block_size);
      flow->read_block = (char *)return_value_calloc_4;
      if(flow->write_block == ((char *)NULL))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = flow->read_block == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        logging_log(1, "could not allocate memory for read/write blocks");
        request_error(&request->r, "could not allocate memory for read/write blocks");
        uninit_flow(flow);
      }

      else
      {
        if(!(flow->settings.byte_counting == 0))
        {
          signed int byte_idx = 0;
          for( ; !(byte_idx >= flow->settings.maximum_block_size); byte_idx = byte_idx + 1)
            flow->write_block[(signed long int)byte_idx] = (char)(unsigned char)(byte_idx & 0xff);
        }

        if(!(flow->settings.bind_address[0l] == 0))
          tmp_if_expr_6 = flow->settings.bind_address;

        else
          tmp_if_expr_6 = ((char *)NULL);
        flow->listenfd_data=create_listen_socket(flow, tmp_if_expr_6, &server_data_port);
        if(flow->listenfd_data == -1)
        {
          logging_log(1, "could not create listen socket for data connection: %s", flow->error);
          request_error(&request->r, "could not create listen socket for data connection: %s", flow->error);
          uninit_flow(flow);
          goto __CPROVER_DUMP_L13;
        }

        else

          __CPROVER_DUMP_L11:
            ;
        signed int return_value_set_window_size_directed_7;
        return_value_set_window_size_directed_7=set_window_size_directed(flow->listenfd_data, flow->settings.requested_send_buffer_size, 7);
        flow->real_listen_send_buffer_size = (unsigned int)return_value_set_window_size_directed_7;
        signed int return_value_set_window_size_directed_8;
        return_value_set_window_size_directed_8=set_window_size_directed(flow->listenfd_data, flow->settings.requested_read_buffer_size, 8);
        flow->real_listen_receive_buffer_size = (unsigned int)return_value_set_window_size_directed_8;
        request->listen_data_port = (signed int)server_data_port;
        request->real_listen_send_buffer_size = (signed int)flow->real_listen_send_buffer_size;
        request->real_listen_read_buffer_size = (signed int)flow->real_listen_receive_buffer_size;
        request->flow_id = flow->id;
        fg_list_push_back(&flows, (void *)flow);
        goto __CPROVER_DUMP_L13;
      }
    }
  }

__CPROVER_DUMP_L13:
  ;
}

// add_flow_destination_link1
// file src/flowgrindd.c line 403
static struct _xmlrpc_value * add_flow_destination_link1(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  (void)user_data;
  signed int rc;
  signed int add_flow_destination__1__i;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);
  char *cc_alg = ((char *)NULL);
  char *bind_address = ((char *)NULL);
  struct _xmlrpc_value *extra_options = ((struct _xmlrpc_value *)NULL);
  struct flow_settings settings;
  struct request_add_flow_destination *request = ((struct request_add_flow_destination *)NULL);

__CPROVER_DUMP_L1:
  ;
  xmlrpc_decompose_value(env, param_array, "({s:s,*}{s:d,s:d,s:d,s:d,s:d,*}{s:i,s:i,*}{s:i,*}{s:b,s:b,s:b,s:b,s:b,*}{s:i,s:i,*}{s:i,s:d,s:d,*}{s:i,s:d,s:d,*}{s:i,s:d,s:d,*}{s:b,s:b,s:i,s:i,*}{s:s,*}{s:i,s:i,s:i,s:i,s:i,*}{s:s,*}{s:i,s:A,*})", (const void *)"bind_address", &bind_address, (const void *)"write_delay", &settings.delay[(signed long int)0], (const void *)"write_duration", &settings.duration[(signed long int)0], (const void *)"read_delay", &settings.delay[(signed long int)1], (const void *)"read_duration", &settings.duration[(signed long int)1], (const void *)"reporting_interval", &settings.reporting_interval, (const void *)"requested_send_buffer_size", &settings.requested_send_buffer_size, (const void *)"requested_read_buffer_size", &settings.requested_read_buffer_size, (const void *)"maximum_block_size", &settings.maximum_block_size, (const void *)"traffic_dump", &settings.traffic_dump, (const void *)"so_debug", &settings.so_debug, (const void *)"route_record", &settings.route_record, (const void *)"pushy", &settings.pushy, (const void *)"shutdown", &settings.shutdown, (const void *)"write_rate", &settings.write_rate, (const void *)"random_seed", &settings.random_seed, (const void *)"traffic_generation_request_distribution", &settings.request_trafgen_options.distribution, (const void *)"traffic_generation_request_param_one", &settings.request_trafgen_options.param_one, (const void *)"traffic_generation_request_param_two", &settings.request_trafgen_options.param_two, (const void *)"traffic_generation_response_distribution", &settings.response_trafgen_options.distribution, (const void *)"traffic_generation_response_param_one", &settings.response_trafgen_options.param_one, (const void *)"traffic_generation_response_param_two", &settings.response_trafgen_options.param_two, (const void *)"traffic_generation_gap_distribution", &settings.interpacket_gap_trafgen_options.distribution, (const void *)"traffic_generation_gap_param_one", &settings.interpacket_gap_trafgen_options.param_one, (const void *)"traffic_generation_gap_param_two", &settings.interpacket_gap_trafgen_options.param_two, (const void *)"flow_control", &settings.flow_control, (const void *)"byte_counting", &settings.byte_counting, (const void *)"cork", &settings.cork, (const void *)"nonagle", &settings.nonagle, (const void *)"cc_alg", &cc_alg, (const void *)"elcn", &settings.elcn, (const void *)"lcd", &settings.lcd, (const void *)"mtcp", &settings.mtcp, (const void *)"dscp", &settings.dscp, (const void *)"ipmtudiscover", &settings.ipmtudiscover, (const void *)"dump_prefix", &dump_prefix, (const void *)"num_extra_socket_options", &settings.num_extra_socket_options, (const void *)"extra_socket_options", &extra_options);
  unsigned long int return_value_strlen_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5_link1;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_6;
  _Bool tmp_if_expr_9;
  signed int return_value_xmlrpc_array_size_8;
  void *return_value_malloc_10;
  if(env->fault_occurred == 0)
  {
    return_value_strlen_1=strlen(bind_address);
    if(return_value_strlen_1 >= 999ul)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = settings.delay[(signed long int)0] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = settings.duration[(signed long int)0] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = settings.delay[(signed long int)1] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5_link1 = (_Bool)1;

    else
      tmp_if_expr_5_link1 = settings.duration[(signed long int)1] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(!(settings.maximum_block_size >= (signed int)sizeof(struct block) /*40*/ ) || !(settings.requested_read_buffer_size >= 0) || !(settings.requested_send_buffer_size >= 0) || !(settings.write_rate >= 0) || tmp_if_expr_5_link1)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strlen_6=strlen(cc_alg);
      tmp_if_expr_7 = return_value_strlen_6 > (unsigned long int)16 ? (_Bool)1 : (_Bool)0;
    }
    if(settings.num_extra_socket_options >= 11 || !(settings.num_extra_socket_options >= 0) || tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_xmlrpc_array_size_8=xmlrpc_array_size(env, extra_options);
      tmp_if_expr_9 = return_value_xmlrpc_array_size_8 != settings.num_extra_socket_options ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
    {
      xmlrpc_env_set_fault(env, -501, "Flow settings incorrect");
      goto cleanup;
    }

    add_flow_destination__1__i = 0;
    for( ; !(add_flow_destination__1__i >= settings.num_extra_socket_options); add_flow_destination__1__i = add_flow_destination__1__i + 1)
    {
      const unsigned char *buffer = ((const unsigned char *)NULL);
      unsigned long int len;
      struct _xmlrpc_value *option;
      struct _xmlrpc_value *level = ((struct _xmlrpc_value *)NULL);
      struct _xmlrpc_value *optname = ((struct _xmlrpc_value *)NULL);
      struct _xmlrpc_value *value = ((struct _xmlrpc_value *)NULL);
      xmlrpc_array_read_item(env, extra_options, (const unsigned int)add_flow_destination__1__i, &option);
      if(env->fault_occurred == 0)
        xmlrpc_struct_read_value(env, option, "level", &level);

      if(env->fault_occurred == 0)
        xmlrpc_struct_read_value(env, option, "optname", &optname);

      if(env->fault_occurred == 0)
        xmlrpc_struct_read_value(env, option, "value", &value);

      if(env->fault_occurred == 0)
        xmlrpc_read_int(env, level, &settings.extra_socket_options[(signed long int)add_flow_destination__1__i].level);

      if(env->fault_occurred == 0)
        xmlrpc_read_int(env, optname, &settings.extra_socket_options[(signed long int)add_flow_destination__1__i].optname);

      if(env->fault_occurred == 0)
        xmlrpc_read_base64(env, value, &len, &buffer);

      if(!(level == ((struct _xmlrpc_value *)NULL)))
        xmlrpc_DECREF(level);

      if(!(optname == ((struct _xmlrpc_value *)NULL)))
        xmlrpc_DECREF(optname);

      if(!(value == ((struct _xmlrpc_value *)NULL)))
        xmlrpc_DECREF(value);

      if(env->fault_occurred == 0)
      {
        if(len >= 101ul)
        {
          free((void *)buffer);
          xmlrpc_env_set_fault(env, -501, "Too long extra socket option length");
          goto cleanup;
        }

        settings.extra_socket_options[(signed long int)add_flow_destination__1__i].optlen = (signed int)len;
        memcpy((void *)settings.extra_socket_options[(signed long int)add_flow_destination__1__i].optval, (const void *)buffer, len);
        free((void *)buffer);
      }

      if(!(env->fault_occurred == 0))
        goto cleanup;

    }
    strcpy(settings.cc_alg, cc_alg);
    strcpy(settings.bind_address, bind_address);

  __CPROVER_DUMP_L30:
    ;
    return_value_malloc_10=malloc(sizeof(struct request_add_flow_destination) /*2392ul*/ );
    request = (struct request_add_flow_destination *)return_value_malloc_10;
    request->settings = settings;
    rc=dispatch_request((struct request *)request, 0);
    if(rc == -1)
    {
      xmlrpc_env_set_fault(env, -500, request->r.error);
      goto cleanup;
    }

    ret=xmlrpc_build_value(env, "{s:i,s:i,s:i,s:i}", (const void *)"flow_id", request->flow_id, (const void *)"listen_data_port", request->listen_data_port, (const void *)"real_listen_send_buffer_size", request->real_listen_send_buffer_size, (const void *)"real_listen_read_buffer_size", request->real_listen_read_buffer_size);
  }


cleanup:
  ;
  if(!(request == ((struct request_add_flow_destination *)NULL)))
    do
    {
      void *stopper;
      signed int literal_11[1l] = { 0 };
      stopper = (void *)literal_11;
      void **list;
      void *literal_12[3l] = { (void *)request->r.error, (void *)request, stopper };
      list = literal_12;
      signed int i = 0;
      for( ; !(list[(signed long int)i] == stopper); i = i + 1)
        free(list[(signed long int)i]);
    }
    while((_Bool)0);

  do
  {
    void *add_flow_destination__1__7__stopper;
    signed int literal_13[1l] = { 0 };
    add_flow_destination__1__7__stopper = (void *)literal_13;
    void **add_flow_destination__1__7__list;
    void *literal_14[3l] = { (void *)cc_alg, (void *)bind_address, add_flow_destination__1__7__stopper };
    add_flow_destination__1__7__list = literal_14;
    signed int add_flow_destination__1__7__1__i = 0;
    for( ; !(add_flow_destination__1__7__list[(signed long int)add_flow_destination__1__7__1__i] == add_flow_destination__1__7__stopper); add_flow_destination__1__7__1__i = add_flow_destination__1__7__1__i + 1)
      free(add_flow_destination__1__7__list[(signed long int)add_flow_destination__1__7__1__i]);
  }
  while((_Bool)0);
  if(!(extra_options == ((struct _xmlrpc_value *)NULL)))
    xmlrpc_DECREF(extra_options);

  if(!(env->fault_occurred == 0))
    logging_log(4, "Method add_flow_destination failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L41:
      ;
  return ret;
}

// add_flow_source
// file src/source.h line 35
signed int add_flow_source(struct request_add_flow_source *request)
{
  unsigned int opt_len = (unsigned int)0;
  struct flow *flow;
  unsigned long int return_value_fg_list_size_1;
  return_value_fg_list_size_1=fg_list_size(&flows);
  _Bool tmp_if_expr_5_link1;
  if(return_value_fg_list_size_1 >= 2048ul)
  {
    logging_log(4, "Can not accept another flow, already handling MAX_FLOW flows.");
    request_error(&request->r, "Can not accept another flow, already handling MAX_FLOW flows.");
    return -1;
  }

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct flow) /*3248ul*/ );
    flow = (struct flow *)return_value_malloc_2;
    if(flow == ((struct flow *)NULL))
    {
      logging_log(1, "could not allocate memory for flow");
      return -1;
    }

    else
    {
      init_flow(flow, 1);
      flow->settings = request->settings;
      flow->source_settings = request->source_settings;
      void *return_value_calloc_3;
      return_value_calloc_3=calloc((unsigned long int)1, (unsigned long int)flow->settings.maximum_block_size);
      flow->write_block = (char *)return_value_calloc_3;
      void *return_value_calloc_4;
      return_value_calloc_4=calloc((unsigned long int)1, (unsigned long int)flow->settings.maximum_block_size);
      flow->read_block = (char *)return_value_calloc_4;
      if(flow->write_block == ((char *)NULL))
        tmp_if_expr_5_link1 = (_Bool)1;

      else
        tmp_if_expr_5_link1 = flow->read_block == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5_link1)
      {
        logging_log(1, "could not allocate memory for read/write blocks");
        request_error(&request->r, "could not allocate memory for read/write blocks");
        uninit_flow(flow);
        return -1;
      }

      else
      {
        if(!(flow->settings.byte_counting == 0))
        {
          signed int byte_idx = 0;
          for( ; !(byte_idx >= flow->settings.maximum_block_size); byte_idx = byte_idx + 1)
            flow->write_block[(signed long int)byte_idx] = (char)(unsigned char)(byte_idx & 0xff);
        }

        flow->state = (enum flow_state)GRIND_WAIT_CONNECT;
        flow->fd=name2socket(flow, flow->source_settings.destination_host, (unsigned int)flow->source_settings.destination_port, &flow->addr, &flow->addr_len, (char)0, flow->settings.requested_read_buffer_size, &request->real_read_buffer_size, flow->settings.requested_send_buffer_size, &request->real_send_buffer_size);
        if(flow->fd == -1)
        {
          logging_log(1, "Could not create data socket: %s", flow->error);
          request_error(&request->r, "Could not create data socket: %s", flow->error);
          uninit_flow(flow);
          return -1;
        }

        else
        {
          signed int return_value_set_flow_tcp_options_6;
          return_value_set_flow_tcp_options_6=set_flow_tcp_options(flow);
          if(return_value_set_flow_tcp_options_6 == -1)
          {
            request->r.error = flow->error;
            flow->error = (char *)(void *)0;
            uninit_flow(flow);
            return -1;
          }

          else
          {
            opt_len = (unsigned int)sizeof(char [16l]) /*16ul*/ ;
            signed int return_value_getsockopt_9;
            return_value_getsockopt_9=getsockopt(flow->fd, 6, 13, (void *)request->cc_alg, &opt_len);
            if(return_value_getsockopt_9 == -1)
            {
              signed int *return_value___errno_location_7;
              return_value___errno_location_7=__errno_location();
              char *return_value_strerror_8;
              return_value_strerror_8=strerror(*return_value___errno_location_7);
              request_error(&request->r, "failed to determine actual congestion control algorithm: %s", return_value_strerror_8);
              uninit_flow(flow);
              return -1;
            }

            fg_pcap_go(flow);
            if(flow->source_settings.late_connect == 0)
            {

            __CPROVER_DUMP_L12:
              ;
              connect(flow->fd, flow->addr, flow->addr_len);
              flow->connect_called = (char)1;
              flow->pmtu=get_pmtu(flow->fd);
            }

            request->flow_id = flow->id;
            fg_list_push_back(&flows, (void *)flow);
            return 0;
          }
        }
      }
    }
  }
}

// add_flow_source_link1
// file src/flowgrindd.c line 208
static struct _xmlrpc_value * add_flow_source_link1(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  (void)user_data;
  signed int rc;
  signed int i;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);
  char *destination_host = ((char *)NULL);
  char *cc_alg = ((char *)NULL);
  char *bind_address = ((char *)NULL);
  struct _xmlrpc_value *extra_options = ((struct _xmlrpc_value *)NULL);
  struct flow_settings settings;
  struct flow_source_settings source_settings;
  struct request_add_flow_source *request = ((struct request_add_flow_source *)NULL);

__CPROVER_DUMP_L1:
  ;
  xmlrpc_decompose_value(env, param_array, "({s:s,*}{s:d,s:d,s:d,s:d,s:d,*}{s:i,s:i,*}{s:i,*}{s:b,s:b,s:b,s:b,s:b,*}{s:i,s:i,*}{s:i,s:d,s:d,*}{s:i,s:d,s:d,*}{s:i,s:d,s:d,*}{s:b,s:b,s:i,s:i,*}{s:s,*}{s:i,s:i,s:i,s:i,s:i,*}{s:s,*}{s:i,s:A,*}{s:s,s:i,s:i,*})", (const void *)"bind_address", &bind_address, (const void *)"write_delay", &settings.delay[(signed long int)0], (const void *)"write_duration", &settings.duration[(signed long int)0], (const void *)"read_delay", &settings.delay[(signed long int)1], (const void *)"read_duration", &settings.duration[(signed long int)1], (const void *)"reporting_interval", &settings.reporting_interval, (const void *)"requested_send_buffer_size", &settings.requested_send_buffer_size, (const void *)"requested_read_buffer_size", &settings.requested_read_buffer_size, (const void *)"maximum_block_size", &settings.maximum_block_size, (const void *)"traffic_dump", &settings.traffic_dump, (const void *)"so_debug", &settings.so_debug, (const void *)"route_record", &settings.route_record, (const void *)"pushy", &settings.pushy, (const void *)"shutdown", &settings.shutdown, (const void *)"write_rate", &settings.write_rate, (const void *)"random_seed", &settings.random_seed, (const void *)"traffic_generation_request_distribution", &settings.request_trafgen_options.distribution, (const void *)"traffic_generation_request_param_one", &settings.request_trafgen_options.param_one, (const void *)"traffic_generation_request_param_two", &settings.request_trafgen_options.param_two, (const void *)"traffic_generation_response_distribution", &settings.response_trafgen_options.distribution, (const void *)"traffic_generation_response_param_one", &settings.response_trafgen_options.param_one, (const void *)"traffic_generation_response_param_two", &settings.response_trafgen_options.param_two, (const void *)"traffic_generation_gap_distribution", &settings.interpacket_gap_trafgen_options.distribution, (const void *)"traffic_generation_gap_param_one", &settings.interpacket_gap_trafgen_options.param_one, (const void *)"traffic_generation_gap_param_two", &settings.interpacket_gap_trafgen_options.param_two, (const void *)"flow_control", &settings.flow_control, (const void *)"byte_counting", &settings.byte_counting, (const void *)"cork", &settings.cork, (const void *)"nonagle", &settings.nonagle, (const void *)"cc_alg", &cc_alg, (const void *)"elcn", &settings.elcn, (const void *)"lcd", &settings.lcd, (const void *)"mtcp", &settings.mtcp, (const void *)"dscp", &settings.dscp, (const void *)"ipmtudiscover", &settings.ipmtudiscover, (const void *)"dump_prefix", &dump_prefix, (const void *)"num_extra_socket_options", &settings.num_extra_socket_options, (const void *)"extra_socket_options", &extra_options, (const void *)"destination_address", &destination_host, (const void *)"destination_port", &source_settings.destination_port, (const void *)"late_connect", &source_settings.late_connect);
  unsigned long int return_value_strlen_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_6;
  _Bool tmp_if_expr_9;
  unsigned long int return_value_strlen_8;
  _Bool tmp_if_expr_11;
  signed int return_value_xmlrpc_array_size_10;
  void *return_value_malloc_12;
  if(env->fault_occurred == 0)
  {
    return_value_strlen_1=strlen(bind_address);
    if(return_value_strlen_1 >= 999ul)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = settings.delay[(signed long int)0] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = settings.duration[(signed long int)0] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = settings.delay[(signed long int)1] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = settings.duration[(signed long int)1] < (double)0 ? (_Bool)1 : (_Bool)0;
    if(!(settings.maximum_block_size >= (signed int)sizeof(struct block) /*40*/ ) || !(settings.requested_read_buffer_size >= 0) || !(settings.requested_send_buffer_size >= 0) || tmp_if_expr_5)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_strlen_6=strlen(destination_host);
      tmp_if_expr_7 = return_value_strlen_6 >= sizeof(char [256l]) /*256ul*/  - (unsigned long int)1 ? (_Bool)1 : (_Bool)0;
    }
    if(source_settings.destination_port >= 65536 || !(source_settings.destination_port >= 1) || tmp_if_expr_7)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strlen_8=strlen(cc_alg);
      tmp_if_expr_9 = return_value_strlen_8 > (unsigned long int)16 ? (_Bool)1 : (_Bool)0;
    }
    if(settings.num_extra_socket_options >= 11 || !(settings.num_extra_socket_options >= 0) || tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_xmlrpc_array_size_10=xmlrpc_array_size(env, extra_options);
      tmp_if_expr_11 = return_value_xmlrpc_array_size_10 != settings.num_extra_socket_options ? (_Bool)1 : (_Bool)0;
    }
    if(settings.reporting_interval < 0.000000 || settings.dscp >= 256 || !(settings.dscp >= 0) || !(settings.write_rate >= 0) || tmp_if_expr_11)
    {
      xmlrpc_env_set_fault(env, -501, "Flow settings incorrect");
      goto cleanup;
    }

    i = 0;
    for( ; !(i >= settings.num_extra_socket_options); i = i + 1)
    {
      const unsigned char *buffer = ((const unsigned char *)NULL);
      unsigned long int len;
      struct _xmlrpc_value *option;
      struct _xmlrpc_value *level = ((struct _xmlrpc_value *)NULL);
      struct _xmlrpc_value *optname = ((struct _xmlrpc_value *)NULL);
      struct _xmlrpc_value *value = ((struct _xmlrpc_value *)NULL);
      xmlrpc_array_read_item(env, extra_options, (const unsigned int)i, &option);
      if(env->fault_occurred == 0)
        xmlrpc_struct_read_value(env, option, "level", &level);

      if(env->fault_occurred == 0)
        xmlrpc_struct_read_value(env, option, "optname", &optname);

      if(env->fault_occurred == 0)
        xmlrpc_struct_read_value(env, option, "value", &value);

      if(env->fault_occurred == 0)
        xmlrpc_read_int(env, level, &settings.extra_socket_options[(signed long int)i].level);

      if(env->fault_occurred == 0)
        xmlrpc_read_int(env, optname, &settings.extra_socket_options[(signed long int)i].optname);

      if(env->fault_occurred == 0)
        xmlrpc_read_base64(env, value, &len, &buffer);

      if(!(level == ((struct _xmlrpc_value *)NULL)))
        xmlrpc_DECREF(level);

      if(!(optname == ((struct _xmlrpc_value *)NULL)))
        xmlrpc_DECREF(optname);

      if(!(value == ((struct _xmlrpc_value *)NULL)))
        xmlrpc_DECREF(value);

      if(env->fault_occurred == 0)
      {
        if(len >= 101ul)
        {
          free((void *)buffer);
          xmlrpc_env_set_fault(env, -501, "Too long extra socket option length");
          goto cleanup;
        }

        settings.extra_socket_options[(signed long int)i].optlen = (signed int)len;
        memcpy((void *)settings.extra_socket_options[(signed long int)i].optval, (const void *)buffer, len);
        free((void *)buffer);
      }

      if(!(env->fault_occurred == 0))
        goto cleanup;

    }
    strcpy(source_settings.destination_host, destination_host);
    strcpy(settings.cc_alg, cc_alg);
    strcpy(settings.bind_address, bind_address);
    return_value_malloc_12=malloc(sizeof(struct request_add_flow_source) /*2680ul*/ );
    request = (struct request_add_flow_source *)return_value_malloc_12;
    request->settings = settings;
    request->source_settings = source_settings;
    rc=dispatch_request((struct request *)request, 1);
    if(rc == -1)
    {
      xmlrpc_env_set_fault(env, -500, request->r.error);
      goto cleanup;
    }

    ret=xmlrpc_build_value(env, "{s:i,s:s,s:i,s:i}", (const void *)"flow_id", request->flow_id, (const void *)"cc_alg", (const void *)request->cc_alg, (const void *)"real_send_buffer_size", request->real_send_buffer_size, (const void *)"real_read_buffer_size", request->real_read_buffer_size);
  }


cleanup:
  ;
  if(!(request == ((struct request_add_flow_source *)NULL)))
    do
    {
      void *stopper;
      signed int literal_13[1l] = { 0 };
      stopper = (void *)literal_13;
      void **list;
      void *literal_14[3l] = { (void *)request->r.error, (void *)request, stopper };
      list = literal_14;
      signed int add_flow_source__1__5__1__i = 0;
      for( ; !(list[(signed long int)add_flow_source__1__5__1__i] == stopper); add_flow_source__1__5__1__i = add_flow_source__1__5__1__i + 1)
        free(list[(signed long int)add_flow_source__1__5__1__i]);
    }
    while((_Bool)0);

  do
  {
    void *add_flow_source__1__6__stopper;
    signed int literal_15[1l] = { 0 };
    add_flow_source__1__6__stopper = (void *)literal_15;
    void **add_flow_source__1__6__list;
    void *literal_16[4l] = { (void *)destination_host, (void *)cc_alg, (void *)bind_address, add_flow_source__1__6__stopper };
    add_flow_source__1__6__list = literal_16;
    signed int add_flow_source__1__6__1__i = 0;
    for( ; !(add_flow_source__1__6__list[(signed long int)add_flow_source__1__6__1__i] == add_flow_source__1__6__stopper); add_flow_source__1__6__1__i = add_flow_source__1__6__1__i + 1)
      free(add_flow_source__1__6__list[(signed long int)add_flow_source__1__6__1__i]);
  }
  while((_Bool)0);
  if(!(extra_options == ((struct _xmlrpc_value *)NULL)))
    xmlrpc_DECREF(extra_options);

  if(!(env->fault_occurred == 0))
    logging_log(4, "Method add_flow_source failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L42:
      ;
  return ret;
}

// add_report
// file src/daemon.c line 806
void add_report(struct report *report)
{

__CPROVER_DUMP_L1:
  ;
  pthread_mutex_lock(&mutex);

__CPROVER_DUMP_L2:
  ;
  if(pending_reports >= 250u)
  {
    if(report->type == 1)
      goto __CPROVER_DUMP_L3;

    free((void *)report);
    pthread_mutex_unlock(&mutex);
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    report->next = ((struct report *)NULL);
    if(!(reports_last == ((struct report *)NULL)))
      reports_last->next = report;

    else
      reports = report;
    reports_last = report;
    pending_reports = pending_reports + 1u;
    pthread_mutex_unlock(&mutex);
  }

__CPROVER_DUMP_L6:
  ;
}

// ap_argument
// file src/fg_argparser.h line 157
const char * ap_argument(struct arg_parser * const ap, const signed int i)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ap_arguments_1;
  if(i >= 0)
  {
    return_value_ap_arguments_1=ap_arguments(ap);
    tmp_if_expr_2 = i < return_value_ap_arguments_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return (ap->data + (signed long int)i)->argument;

  else
    return "";
}

// ap_arguments
// file src/fg_argparser.h line 137
signed int ap_arguments(struct arg_parser * const ap)
{
  return ap->data_size;
}

// ap_check_mutex
// file src/fg_argparser.c line 524
_Bool ap_check_mutex(struct arg_parser * const ap, struct ap_Mutex_state * const ms, const signed int i, signed int *conflict)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ap_arguments_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(ap->num_mutex == ms->num_mutex))
    return (_Bool)0;

  else
  {
    *conflict = 0;
    if(!(i >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_ap_arguments_1=ap_arguments(ap);
      tmp_if_expr_2 = i >= return_value_ap_arguments_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(ap->num_mutex != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      return (_Bool)0;

    else
    {
      signed int index = (ap->data + (signed long int)i)->option_index;
      signed int *ap_check_mutex__1__1__mutex = (ap->options + (signed long int)index)->mutex;
      do
      {
        if(!(ap_check_mutex__1__1__mutex == ((signed int *)NULL)))
          tmp_if_expr_4 = *ap_check_mutex__1__1__mutex != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        if(!(ms->seen_records[(signed long int)(*ap_check_mutex__1__1__mutex + -1)] == 0))
        {
          *conflict = ms->seen_records[(signed long int)(*ap_check_mutex__1__1__mutex - 1)] - 1;
          if(!((ap->data + (signed long int)*conflict)->option_index == index))
            return (_Bool)1;

          else
            *conflict = 0;
        }

        ap_check_mutex__1__1__mutex = ap_check_mutex__1__1__mutex + 1l;
      }
      while((_Bool)1);
      return (_Bool)0;
    }
  }
}

// ap_code
// file src/fg_argparser.h line 147
signed int ap_code(struct arg_parser * const ap, const signed int i)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ap_arguments_1;
  if(i >= 0)
  {
    return_value_ap_arguments_1=ap_arguments(ap);
    tmp_if_expr_2 = i < return_value_ap_arguments_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int index = (ap->data + (signed long int)i)->option_index;
    return (ap->options + (signed long int)index)->code;
  }

  else
    return 0;
}

// ap_error
// file src/fg_argparser.h line 129
const char * ap_error(struct arg_parser * const ap)
{
  return ap->error;
}

// ap_free
// file src/fg_argparser.h line 120
void ap_free(struct arg_parser * const ap)
{
  free_data(ap);
  if(!(ap->error == ((char *)NULL)))
  {
    free((void *)ap->error);
    ap->error = ((char *)NULL);
  }

  ap->error_size = 0;
}

// ap_free_mutex_state
// file src/fg_argparser.c line 580
void ap_free_mutex_state(struct ap_Mutex_state * const ms)
{
  if(!(ms->seen_records == ((signed int *)NULL)))
  {
    free((void *)ms->seen_records);
    ms->seen_records = ((signed int *)NULL);
    ms->num_mutex = 0;
  }

}

// ap_init
// file src/fg_argparser.h line 111
_Bool ap_init(struct arg_parser * const ap, const signed int argc, const char * const *argv, struct ap_Option *options, const char in_order)
{
  const char **non_options = ((const char **)NULL);
  signed int non_options_size = 0;
  signed int argind = 1;
  _Bool return_value_copy_options_1;
  return_value_copy_options_1=copy_options(ap, options);
  signed int tmp_if_expr_2;
  const char *tmp_if_expr_3;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  _Bool return_value_push_back_record_9;
  _Bool return_value_push_back_record_10;
  signed int tmp_post_11;
  _Bool return_value_push_back_record_12;
  if(return_value_copy_options_1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    ap->num_mutex=get_mutex_count(options);
    ap->data = ((struct ap_Record *)NULL);
    ap->error = ((char *)NULL);
    ap->data_size = 0;
    ap->error_size = 0;
    if(argv == ((const char * const *)NULL) || options == ((struct ap_Option *)NULL) || !(argc >= 2))
      return (_Bool)1;

    else
    {
      while(!(argind >= argc))
      {
        const unsigned char ch1 = (const unsigned char)argv[(signed long int)argind][(signed long int)0];
        unsigned char ch2;
        if(!(ch1 == 0))
          tmp_if_expr_2 = (signed int)argv[(signed long int)argind][(signed long int)1];

        else
          tmp_if_expr_2 = 0;
        ch2 = (const unsigned char)tmp_if_expr_2;
        if((signed int)ch1 == 45 && !(ch2 == 0))
        {
          const char * const opt = argv[(signed long int)argind];
          const char *arg;
          if(!(1 + argind >= argc))
            tmp_if_expr_3 = argv[(signed long int)(argind + 1)];

          else
            tmp_if_expr_3 = ((const char *)NULL);
          arg = tmp_if_expr_3;
          if((signed int)ch2 == 45)
          {
            if(argv[(signed long int)argind][2l] == 0)
            {
              argind = argind + 1;
              break;
            }

            else
            {
              _Bool return_value_parse_long_option_4;
              return_value_parse_long_option_4=parse_long_option(ap, opt, arg, options, &argind);
              if(return_value_parse_long_option_4 == (_Bool)0)
                return (_Bool)0;

            }
          }

          else
          {
            _Bool return_value_parse_short_option_5;
            return_value_parse_short_option_5=parse_short_option(ap, opt, arg, options, &argind);
            if(return_value_parse_short_option_5 == (_Bool)0)
              return (_Bool)0;

          }
          if(!(ap->error == ((char *)NULL)))
            break;

        }

        else
          if(in_order == 0)
          {
            void *tmp;
            tmp=ap_resize_buffer((void *)non_options, (const signed int)((unsigned long int)(non_options_size + 1) * sizeof(const char *) /*8ul*/ ));
            if(tmp == NULL)
              return (_Bool)0;

            non_options = (const char **)tmp;
            tmp_post_6 = non_options_size;
            non_options_size = non_options_size + 1;
            tmp_post_7 = argind;
            argind = argind + 1;
            non_options[(signed long int)tmp_post_6] = argv[(signed long int)tmp_post_7];
          }

          else
          {
            tmp_post_8 = argind;
            argind = argind + 1;
            return_value_push_back_record_9=push_back_record(ap, ap->num_options, (_Bool)0, argv[(signed long int)tmp_post_8]);
            if(return_value_push_back_record_9 == (_Bool)0)
              return (_Bool)0;

          }
      }
      if(!(ap->error == ((char *)NULL)))
        free_data(ap);

      else
      {
        signed int i = 0;
        for( ; !(i >= non_options_size); i = i + 1)
        {
          return_value_push_back_record_10=push_back_record(ap, ap->num_options, (_Bool)0, non_options[(signed long int)i]);
          if(return_value_push_back_record_10 == (_Bool)0)
            return (_Bool)0;

        }
        while(!(argind >= argc))
        {
          tmp_post_11 = argind;
          argind = argind + 1;
          return_value_push_back_record_12=push_back_record(ap, ap->num_options, (_Bool)0, argv[(signed long int)tmp_post_11]);
          if(return_value_push_back_record_12 == (_Bool)0)
            return (_Bool)0;

        }
      }
      if(!(non_options == ((const char **)NULL)))
        free((void *)non_options);

      return (_Bool)1;
    }
  }
}

// ap_init_mutex_state
// file src/fg_argparser.c line 513
_Bool ap_init_mutex_state(struct arg_parser * const ap, struct ap_Mutex_state * const ms)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)ap->num_mutex);
  ms->seen_records = (signed int *)return_value_malloc_1;
  _Bool tmp_if_expr_2;
  if(ap->num_mutex == 0)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(ms->seen_records != ((signed int *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
    return (_Bool)0;

  else
  {
    memset((void *)ms->seen_records, 0, sizeof(signed int) /*4ul*/  * (unsigned long int)ap->num_mutex);
    ms->num_mutex = ap->num_mutex;
    return (_Bool)1;
  }
}

// ap_is_used
// file src/fg_argparser.h line 185
_Bool ap_is_used(struct arg_parser * const ap, signed int code)
{
  _Bool ret = (_Bool)0;
  signed int i = 0;
  signed int return_value_ap_code_1;
  for( ; !(i >= ap->data_size); i = i + 1)
  {
    return_value_ap_code_1=ap_code(ap, i);
    if(return_value_ap_code_1 == code)
    {
      ret = (_Bool)1;
      break;
    }

  }
  return ret;
}

// ap_opt_string
// file src/fg_argparser.c line 483
const char * ap_opt_string(struct arg_parser * const ap, const signed int i)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ap_arguments_1;
  if(i >= 0)
  {
    return_value_ap_arguments_1=ap_arguments(ap);
    tmp_if_expr_2 = i < return_value_ap_arguments_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return (ap->data + (signed long int)i)->opt_string;

  else
    return "";
}

// ap_option
// file src/fg_argparser.c line 491
struct ap_Option * ap_option(struct arg_parser * const ap, const signed int i)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ap_arguments_1;
  if(i >= 0)
  {
    return_value_ap_arguments_1=ap_arguments(ap);
    tmp_if_expr_2 = i < return_value_ap_arguments_1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
    return &ap->options[(signed long int)(ap->data + (signed long int)i)->option_index];

  else
    return ((struct ap_Option *)NULL);
}

// ap_reset_mutex
// file src/fg_argparser.c line 575
void ap_reset_mutex(struct ap_Mutex_state * const ms)
{
  memset((void *)ms->seen_records, 0, sizeof(signed int) /*4ul*/  * (unsigned long int)ms->num_mutex);
}

// ap_resize_buffer
// file src/fg_argparser.c line 48
static void * ap_resize_buffer(void *buf, const signed int min_size)
{
  if(!(buf == NULL))
    buf=realloc(buf, (unsigned long int)min_size);

  else
    buf=malloc((unsigned long int)min_size);
  return buf;
}

// ap_set_check_mutex
// file src/fg_argparser.c line 566
_Bool ap_set_check_mutex(struct arg_parser * const ap, struct ap_Mutex_state * const ms, const signed int i, signed int *conflict)
{
  _Bool ret;
  ret=ap_check_mutex(ap, ms, i, conflict);
  ap_set_mutex(ap, ms, i);
  return ret;
}

// ap_set_mutex
// file src/fg_argparser.c line 550
_Bool ap_set_mutex(struct arg_parser * const ap, struct ap_Mutex_state * const ms, const signed int i)
{
  _Bool tmp_if_expr_2;
  signed int return_value_ap_arguments_1;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(ap->num_mutex == ms->num_mutex))
    return (_Bool)0;

  else
  {
    if(!(i >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_ap_arguments_1=ap_arguments(ap);
      tmp_if_expr_2 = i >= return_value_ap_arguments_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !(ap->num_mutex != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      return (_Bool)0;

    else
    {
      signed int index = (ap->data + (signed long int)i)->option_index;
      signed int *ap_set_mutex__1__1__mutex = (ap->options + (signed long int)index)->mutex;
      do
      {
        if(!(ap_set_mutex__1__1__mutex == ((signed int *)NULL)))
          tmp_if_expr_4 = *ap_set_mutex__1__1__mutex != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        ms->seen_records[(signed long int)(*ap_set_mutex__1__1__mutex - 1)] = i + 1;
        ap_set_mutex__1__1__mutex = ap_set_mutex__1__1__mutex + 1l;
      }
      while((_Bool)1);
      return (_Bool)1;
    }
  }
}

// apply_extra_socket_options
// file src/daemon.c line 1350
signed int apply_extra_socket_options(struct flow *flow)
{
  signed int i = 0;
  for( ; !(i >= flow->settings.num_extra_socket_options); i = i + 1)
  {
    signed int level;
    signed int res;
    struct extra_socket_options *option = &flow->settings.extra_socket_options[(signed long int)i];
    switch(option->level)
    {
      case 0:
      {
        level = 1;
        break;
      }
      case 1:
      {
        level = 6;
        break;
      }
      case 2:
      {
        level = 0;
        break;
      }
      case 3:
      {
        level = 132;
        break;
      }
      case 4:
      {
        level = 6;
        break;
      }
      case 5:
      {
        level = 17;
        break;
      }
      default:
      {
        flow_error(flow, "Unknown socket option level: %d", option->level);
        return -1;
      }
    }
    res=setsockopt(flow->fd, level, option->optname, (const void *)option->optval, (unsigned int)option->optlen);
    if(res == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      flow_error(flow, "Unable to set socket option %d: %s", option->optname, return_value_strerror_2);
      return -1;
    }

  }
  return 0;
}

// asprintf_append
// file src/fg_string.c line 98
signed int asprintf_append(char **strp, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  unsigned long int length;
  signed int return_value_vasprintf_append_1;
  return_value_vasprintf_append_1=vasprintf_append(strp, fmt, ap);
  length = (unsigned long int)return_value_vasprintf_append_1;
  ap = ((void **)NULL);
  return (signed int)length;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// bind_daemon_to_core
// file src/flowgrindd.c line 967
void bind_daemon_to_core(void)
{
  unsigned long int thread;
  thread=pthread_self();
  signed int rc;
  rc=pthread_setaffinity(thread, (unsigned int)core);
  if(!(rc == 0))
    logging_log(4, "failed to bind %s (PID %d) to CPU core %i", progname, thread, core);

  else

    __CPROVER_DUMP_L1:
      ;
}

// bind_rpc_server
// file src/flowgrindd.c line 863
static signed int bind_rpc_server(char *bind_addr, unsigned int port)
{
  signed int rc;
  signed int fd;
  signed int optval;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  char tmp_port[100l];
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001 | 0x0400;
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  sprintf(tmp_port, "%u", port);
  rc=getaddrinfo(bind_addr, tmp_port, &hints, &res);
  if(!(rc == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rc);
    error((enum error_levels)ERR_CRIT, 0, "Failed to find address to bind rpc_server: %s\n", return_value_gai_strerror_1);
    return -1;
  }

  ressave = res;
  do
  {
    fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(fd >= 0)
    {
      optval = 1;
      setsockopt(fd, 1, 2, (const void *)&optval, (unsigned int)sizeof(signed int) /*4ul*/ );
      setsockopt(fd, 6, 1, (const void *)&optval, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_bind_2;
      return_value_bind_2=bind(fd, res->ai_addr, res->ai_addrlen);
      if(return_value_bind_2 == 0)
        break;

      close(fd);
    }

    res = res->ai_next;
  }
  while(!(res == ((struct addrinfo *)NULL)));
  if(res == ((struct addrinfo *)NULL))
  {
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    error((enum error_levels)ERR_CRIT, *return_value___errno_location_3, "failed to bind RPC listen socket");
    freeaddrinfo(ressave);
    return -1;
  }

  return fd;
}

// calculate
// file src/trafgen.c line 50
static inline double calculate(struct flow *flow, enum distributions type, double param_one, double param_two)
{
  double val = (double)0;
  switch((signed int)type)
  {
    case NORMAL:
    {
      val=dist_normal(flow, param_one, param_two);

    __CPROVER_DUMP_L2:
      ;
      break;
    }
    case UNIFORM:
    {
      val=dist_uniform(flow, param_one, param_two);

    __CPROVER_DUMP_L4:
      ;
      break;
    }
    case WEIBULL:
    {
      val=dist_weibull(flow, param_one, param_two);

    __CPROVER_DUMP_L6:
      ;
      break;
    }
    case EXPONENTIAL:
    {
      val=dist_exponential(flow, param_one);

    __CPROVER_DUMP_L8:
      ;
      break;
    }
    case PARETO:
    {
      val=dist_pareto(flow, param_one, param_two);

    __CPROVER_DUMP_L10:
      ;
      break;
    }
    case LOGNORMAL:
    {
      val=dist_normal(flow, param_one, param_two);

    __CPROVER_DUMP_L12:
      ;
      break;
    }
    case CONSTANT:

    default:
    {
      val = param_one;

    __CPROVER_DUMP_L14:
      ;
    }
  }
  return val;
}

// copy_options
// file src/fg_argparser.c line 338
static _Bool copy_options(struct arg_parser * const ap, struct ap_Option *options)
{
  ap->num_options=get_num_options(options);
  char *return_value___strdup_2;
  if(ap->num_options == 0)
    return (_Bool)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct ap_Option) /*32ul*/  * (unsigned long int)ap->num_options);
    ap->options = (struct ap_Option *)return_value_malloc_1;
    if(ap->options == ((struct ap_Option *)NULL))
      return (_Bool)0;

    else
    {
      signed int i = 0;
      for( ; !(i >= ap->num_options); i = i + 1)
      {
        ap->options[(signed long int)i] = options[(signed long int)i];
        if(!((options + (signed long int)i)->name == ((char *)NULL)))
        {
          return_value___strdup_2=__strdup((options + (signed long int)i)->name);
          (ap->options + (signed long int)i)->name = return_value___strdup_2;
        }

        if(!((options + (signed long int)i)->mutex == ((signed int *)NULL)))
        {
          signed int num = 0;
          for( ; !((options + (signed long int)i)->mutex[(signed long int)num] == 0); num = num + 1)
            ;
          void *return_value_malloc_3;
          return_value_malloc_3=malloc(sizeof(signed int) /*4ul*/  * (unsigned long int)(num + 1));
          (ap->options + (signed long int)i)->mutex = (signed int *)return_value_malloc_3;
          if((ap->options + (signed long int)i)->mutex == ((signed int *)NULL))
            return (_Bool)0;

          signed int e = 0;
          for( ; num >= e; e = e + 1)
            (ap->options + (signed long int)i)->mutex[(signed long int)e] = (options + (signed long int)i)->mutex[(signed long int)e];
        }

      }
      return (_Bool)1;
    }
  }
}

// create_daemon_thread
// file src/flowgrindd.c line 844
void create_daemon_thread()
{
  signed int flags;
  signed int return_value_pipe_2;
  return_value_pipe_2=pipe(daemon_pipe);
  signed int *return_value___errno_location_1;
  if(return_value_pipe_2 == -1)
  {
    return_value___errno_location_1=__errno_location();
    error((enum error_levels)ERR_CRIT, *return_value___errno_location_1, "could not create pipe");
  }

  flags=fcntl(daemon_pipe[(signed long int)0], 3, 0);
  if(flags == -1)
    flags = 0;

  fcntl(daemon_pipe[(signed long int)0], 4, flags | 04000);
  pthread_mutex_init(&mutex, (const union anonymous_19 *)(void *)0);
  signed int rc;
  rc=pthread_create(&daemon_thread, (const union pthread_attr_t *)(void *)0, daemon_main, NULL);
  if(!(rc == 0))
    error((enum error_levels)ERR_CRIT, rc, "could not start thread");

}

// create_listen_socket
// file src/destination.c line 78
static signed int create_listen_socket(struct flow *flow, char *bind_addr, unsigned short int *listen_port)
{
  signed int create_listen_socket__1__port;
  signed int rc;
  signed int fd;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = bind_addr != ((char *)NULL) ? 0 : 0x0001;
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  rc=getaddrinfo(bind_addr, "0", &hints, &res);
  if(!(rc == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(rc);
    logging_log(1, "Error: getaddrinfo() failed: %s\n", return_value_gai_strerror_1);
    const char *return_value_gai_strerror_2;
    return_value_gai_strerror_2=gai_strerror(rc);
    flow_error(flow, "getaddrinfo() failed: %s", return_value_gai_strerror_2);
    return -1;
  }

  ressave = res;
  do
  {
    fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(fd >= 0)
    {
      signed int return_value_bind_3;
      return_value_bind_3=bind(fd, res->ai_addr, res->ai_addrlen);
      if(return_value_bind_3 == 0)
        break;

      close(fd);
    }

    res = res->ai_next;
  }
  while(!(res == ((struct addrinfo *)NULL)));
  if(res == ((struct addrinfo *)NULL))
  {
    logging_log(1, "failed to create listen socket");
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    flow_error(flow, "Failed to create listen socket: %s", return_value_strerror_5);
    freeaddrinfo(ressave);
    return -1;
  }

  freeaddrinfo(ressave);
  if(!(flow->settings.mtcp == 0))
    set_tcp_mtcp(fd);

  set_congestion_control(fd, flow->settings.cc_alg);
  signed int return_value_listen_10;
  return_value_listen_10=listen(fd, 0);
  if(!(return_value_listen_10 >= 0))
  {
    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    char *return_value_strerror_7;
    return_value_strerror_7=strerror(*return_value___errno_location_6);
    logging_log(1, "listen failed: %s", return_value_strerror_7);
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    char *return_value_strerror_9;
    return_value_strerror_9=strerror(*return_value___errno_location_8);
    flow_error(flow, "Listen failed: %s", return_value_strerror_9);
    return -1;
  }

  set_non_blocking(fd);
  create_listen_socket__1__port=get_port(fd);
  if(!(create_listen_socket__1__port >= 0))
  {
    signed int *return_value___errno_location_11;
    return_value___errno_location_11=__errno_location();
    char *return_value_strerror_12;
    return_value_strerror_12=strerror(*return_value___errno_location_11);
    flow_error(flow, "Could not get port: %s", return_value_strerror_12);
    close(fd);
    return -1;
  }


__CPROVER_DUMP_L9:
  ;
  *listen_port = (unsigned short int)create_listen_socket__1__port;
  return fd;
}

// create_node
// file src/fg_list.c line 105
static struct list_node * create_node(void * const data, struct list_node * const previous, struct list_node * const next)
{
  struct list_node *new_node;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct list_node) /*24ul*/ );
  new_node = (struct list_node *)return_value_malloc_1;
  if(new_node == ((struct list_node *)NULL))
    return (struct list_node *)(void *)0;

  else
  {
    new_node->data = data;
    new_node->previous = previous;
    new_node->next = next;
    return new_node;
  }
}

// ctimespec
// file src/fg_time.c line 64
const char * ctimespec(struct timespec *tp)
{
  static char buf[30l];
  ctimespec_r(tp, buf, sizeof(char [30l]) /*30ul*/ );
  return buf;
}

// ctimespec_r
// file src/fg_time.c line 46
const char * ctimespec_r(struct timespec *tp, char *buf, unsigned long int size)
{
  struct tm tm;
  tzset();
  localtime_r(&tp->tv_sec, &tm);
  unsigned long int len;
  len=strftime(buf, size, "%F %T", &tm);
  snprintf(buf + (signed long int)len, size - len, ".%09ld", tp->tv_nsec);
  return buf;
}

// daemon_main
// file src/daemon.c line 779
void * daemon_main(void *ptr)
{
  struct timespec timeout;
  do
  {
    signed int need_timeout;
    need_timeout=prepare_fds();
    timeout.tv_sec = (signed long int)0;
    timeout.tv_nsec = (signed long int)10000000;

  __CPROVER_DUMP_L2:
    ;
    signed int rc;
    rc=pselect(maxfd + 1, &rfds, &wfds, &efds, need_timeout != 0 ? &timeout : ((struct timespec *)NULL), (const struct anonymous_22 *)(void *)0);
    if(!(rc >= 0))
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        continue;

      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      error((enum error_levels)ERR_CRIT, *return_value___errno_location_2, "pselect() failed");
    }


  __CPROVER_DUMP_L4:
    ;
    if(!((rfds.fds_bits[(signed long int)(daemon_pipe[0l] / 8)] & (signed long int)(1UL << daemon_pipe[0l] % 8)) == 0l))
      process_requests();

    timer_check();
    process_select(&rfds, &wfds, &efds);
  }
  while((_Bool)1);
}

// dispatch_request
// file src/flowgrindd.c line 171
static signed int dispatch_request(struct request *request, signed int type)
{
  union anonymous_5 cond;
  request->error = (char *)(void *)0;
  request->type = (char)type;
  request->next = (struct request *)(void *)0;
  signed int return_value_pthread_cond_init_1;
  return_value_pthread_cond_init_1=pthread_cond_init(&cond, (const union anonymous_19 *)(void *)0);
  if(!(return_value_pthread_cond_init_1 == 0))
  {
    request_error(request, "Could not create synchronization mutex");
    return -1;
  }

  else
  {
    request->condition = &cond;
    pthread_mutex_lock(&mutex);
    if(requests == ((struct request *)NULL))
    {
      requests = request;
      requests_last = request;
    }

    else
    {
      requests_last->next = request;
      requests_last = request;
    }
    signed long int return_value_write_2;
    return_value_write_2=write(daemon_pipe[(signed long int)1], (const void *)&type, (unsigned long int)1);
    if(!(return_value_write_2 == 1l))
      return -1;

    else
    {
      pthread_cond_wait(&cond, &mutex);
      pthread_mutex_unlock(&mutex);
      if(!(request->error == ((char *)NULL)))
        return -1;

      else
        return 0;
    }
  }
}

// dist_bernoulli
// file src/fg_math.c line 180
extern signed int dist_bernoulli(struct flow *flow, const double p)
{
  struct anonymous_24 *r = flow->r;
  unsigned int return_value_gsl_ran_bernoulli_1;
  return_value_gsl_ran_bernoulli_1=gsl_ran_bernoulli(r, p);
  return (signed int)return_value_gsl_ran_bernoulli_1;
}

// dist_chisq
// file src/fg_math.c line 220
extern double dist_chisq(struct flow *flow, const double nu)
{
  struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_chisq_1;
  return_value_gsl_ran_chisq_1=gsl_ran_chisq(r, nu);
  return return_value_gsl_ran_chisq_1;
}

// dist_exponential
// file src/fg_math.c line 124
extern double dist_exponential(struct flow *flow, const double mu)
{
  struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_exponential_1;
  return_value_gsl_ran_exponential_1=gsl_ran_exponential(r, mu);
  return return_value_gsl_ran_exponential_1;
}

// dist_lognormal
// file src/fg_math.c line 164
extern double dist_lognormal(struct flow *flow, const double zeta, const double sigma)
{
  struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_lognormal_1;
  return_value_gsl_ran_lognormal_1=gsl_ran_lognormal(r, zeta, sigma);
  return return_value_gsl_ran_lognormal_1;
}

// dist_normal
// file src/fg_math.c line 150
extern double dist_normal(struct flow *flow, const double mu, const double sigma_square)
{
  const struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_gaussian_1;
  return_value_gsl_ran_gaussian_1=gsl_ran_gaussian(r, sigma_square);
  return return_value_gsl_ran_gaussian_1 + mu;
}

// dist_pareto
// file src/fg_math.c line 191
extern double dist_pareto(struct flow *flow, const double k, const double x_min)
{
  struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_pareto_1;
  return_value_gsl_ran_pareto_1=gsl_ran_pareto(r, k, x_min);
  return return_value_gsl_ran_pareto_1;
}

// dist_uniform
// file src/fg_math.c line 137
extern double dist_uniform(struct flow *flow, const double minval, const double maxval)
{
  struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_flat_1;
  return_value_gsl_ran_flat_1=gsl_ran_flat(r, minval, maxval);
  return return_value_gsl_ran_flat_1;
}

// dist_weibull
// file src/fg_math.c line 207
extern double dist_weibull(struct flow *flow, const double alpha, const double beta)
{
  struct anonymous_24 *r = flow->r;
  double return_value_gsl_ran_weibull_1;
  return_value_gsl_ran_weibull_1=gsl_ran_weibull(r, alpha, beta);
  return return_value_gsl_ran_weibull_1;
}

// error
// file src/fg_error.h line 80
void error(enum error_levels level, signed int errnum, const char *fmt, ...)
{
  void **ap;
  const char *err_prefix;
  const char *err_errnum;
  switch((signed int)level)
  {
    case ERR_WARNING:
    {
      err_prefix = "warning";
      break;
    }
    case ERR_ERROR:

    case ERR_CRIT:
    {
      err_prefix = "error";
      break;
    }
    default:
      err_prefix = "unknown error";
  }
  fprintf(stderr, "%s: %s: ", progname, err_prefix);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  if(!(errnum == 0))
  {
    err_errnum=strerror(errnum);
    if(err_errnum == ((const char *)NULL))
      err_errnum = "unknown system error";

    fprintf(stderr, ": %s", err_errnum);
  }

  fprintf(stderr, "\n");
  fflush(stderr);
  if((signed int)level >= 2)
    exit(1);

}

// fg_list_back
// file src/fg_list.c line 57
struct list_node * fg_list_back(struct linked_list * const list)
{
  if(list == ((struct linked_list *)NULL))
    return (struct list_node *)(void *)0;

  else
    return list->tail;
}

// fg_list_clear
// file src/fg_list.c line 217
signed int fg_list_clear(struct linked_list * const list)
{
  unsigned long int return_value_fg_list_size_1;
  if(list == ((struct linked_list *)NULL))
    return -1;

  else
  {
    do
    {
      return_value_fg_list_size_1=fg_list_size(list);
      if(return_value_fg_list_size_1 == 0ul)
        break;

      void *data;
      data=fg_list_pop_front(list);
      free(data);
    }
    while((_Bool)1);
    return 0;
  }
}

// fg_list_front
// file src/fg_list.h line 69
struct list_node * fg_list_front(struct linked_list * const list)
{
  if(list == ((struct linked_list *)NULL))
    return (struct list_node *)(void *)0;

  else
    return list->head;
}

// fg_list_init
// file src/fg_list.h line 61
signed int fg_list_init(struct linked_list * const list)
{
  signed int return_value_fg_list_clear_1;
  if(list == ((struct linked_list *)NULL))
    return -1;

  else
    if(!(list->head == ((struct list_node *)NULL)))
    {
      return_value_fg_list_clear_1=fg_list_clear(list);
      if(!(return_value_fg_list_clear_1 == 0))
        goto __CPROVER_DUMP_L2;

      return -2;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      list->head = (struct list_node *)(void *)0;
      list->tail = (struct list_node *)(void *)0;
      list->size = (unsigned long int)0;
      return 0;
    }
}

// fg_list_pop_back
// file src/fg_list.c line 186
void * fg_list_pop_back(struct linked_list * const list)
{
  if(list == ((struct linked_list *)NULL))
    return (void *)0;

  else
    if(list->tail == ((struct list_node *)NULL))
      return (void *)0;

    else
    {
      struct list_node *tail = list->tail;
      void *data = tail->data;
      if(!(tail->previous == ((struct list_node *)NULL)))
        tail->previous->next = (struct list_node *)(void *)0;

      if(list->tail == list->head)
        list->head = (struct list_node *)(void *)0;

      list->tail = tail->previous;
      free((void *)tail);
      list->size = list->size - 1ul;
      return data;
    }
}

// fg_list_pop_front
// file src/fg_list.c line 142
void * fg_list_pop_front(struct linked_list * const list)
{
  if(list == ((struct linked_list *)NULL))
    return (void *)0;

  else
    if(list->head == ((struct list_node *)NULL))
      return (void *)0;

    else
    {
      struct list_node *head = list->head;
      if(list->head == list->tail)
        list->tail = (struct list_node *)(void *)0;

      if(!(head->next == ((struct list_node *)NULL)))
        head->next->previous = (struct list_node *)(void *)0;

      list->head = head->next;
      void *data = head->data;
      free((void *)head);
      list->size = list->size - 1ul;
      return data;
    }
}

// fg_list_push_back
// file src/fg_list.h line 120
signed int fg_list_push_back(struct linked_list * const list, void * const data)
{
  if(list == ((struct linked_list *)NULL))
    return -1;

  else
  {
    struct list_node *new_node;
    new_node=create_node(data, list->tail, (struct list_node *)(void *)0);
    if(new_node == ((struct list_node *)NULL))
      return -5;

    else
    {
      if(list->head == ((struct list_node *)NULL))
        list->head = new_node;

      if(!(list->tail == ((struct list_node *)NULL)))
        list->tail->next = new_node;

      list->tail = new_node;
      list->size = list->size + 1ul;
      return 0;
    }
  }
}

// fg_list_push_front
// file src/fg_list.c line 121
signed int fg_list_push_front(struct linked_list * const list, void * const data)
{
  if(list == ((struct linked_list *)NULL))
    return -1;

  else
  {
    struct list_node *new_node;
    new_node=create_node(data, (struct list_node *)(void *)0, list->head);
    if(new_node == ((struct list_node *)NULL))
      return -5;

    else
    {
      if(list->head == ((struct list_node *)NULL))
        list->tail = new_node;

      else
        list->head->previous = new_node;
      list->head = new_node;
      list->size = list->size + 1ul;
      return 0;
    }
  }
}

// fg_list_remove
// file src/fg_list.h line 87
signed int fg_list_remove(struct linked_list * const list, const void * const data)
{
  if(list == ((struct linked_list *)NULL))
    return -1;

  else
    if(list->head == ((struct list_node *)NULL))
      return -3;

    else
    {
      struct list_node *node = list->head;
      while(!(node->data == data))
      {
        node = node->next;
        if(node == ((struct list_node *)NULL))
          return -4;

      }
      if(list->head == node)
        list->head = node->next;

      if(list->tail == node)
        list->tail = node->previous;

      if(!(node->previous == ((struct list_node *)NULL)))
        node->previous->next = node->next;

      if(!(node->next == ((struct list_node *)NULL)))
        node->next->previous = node->previous;

      free((void *)node);
      list->size = list->size - 1ul;
      return 0;
    }
}

// fg_list_size
// file src/fg_list.h line 139
unsigned long int fg_list_size(struct linked_list * const list)
{
  if(list == ((struct linked_list *)NULL))
    return (unsigned long int)-1;

  else
    return list->size;
}

// fg_nameinfo
// file src/fg_socket.h line 59
const char * fg_nameinfo(struct sockaddr *sa, unsigned int salen)
{
  signed int return_value_getnameinfo_1;
  static char host[1025l];
  return_value_getnameinfo_1=getnameinfo(sa, salen, host, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , (char *)(void *)0, (unsigned int)0, 1);
  if(!(return_value_getnameinfo_1 == 0))
    host[0l] = (char)0;

  if((signed int)host[0l] == 0)
    inet_ntop((signed int)sa->sa_family, (const void *)sa, host, (unsigned int)sizeof(char [1025l]) /*1025ul*/ );

  return host;
}

// fg_pcap_cleanup
// file src/fg_pcap.c line 101
void fg_pcap_cleanup(void *arg)
{
  struct flow *flow = (struct flow *)arg;
  if(!(dumping == 0))
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(flow->pcap_dumper == ((struct pcap_dumper_t *)NULL)))
      pcap_dump_close((struct pcap_dumper *)flow->pcap_dumper);

    flow->pcap_dumper = (struct pcap_dumper_t *)(void *)0;
    if(!(flow->pcap_handle == ((struct pcap_t *)NULL)))
      pcap_close((struct pcap *)flow->pcap_handle);

    flow->pcap_handle = (struct pcap_t *)(void *)0;
    dumping = (char)0;
  }

}

// fg_pcap_go
// file src/fg_pcap.h line 41
void fg_pcap_go(struct flow *flow)
{
  signed int rc;
  char *return_value_strerror_1;
  if(!(flow->settings.traffic_dump == 0))
  {
    if(!(dumping == 0))
      logging_log(4, "pcap: dumping already in progress on this host");

    else
    {

    __CPROVER_DUMP_L2:
      ;
      dumping = (char)1;
      rc=pthread_create(&flow->pcap_thread, (const union pthread_attr_t *)(void *)0, fg_pcap_work, (void *)flow);
      pthread_barrier_wait(&pcap_barrier);
      if(!(rc == 0))
      {
        return_value_strerror_1=strerror(rc);
        logging_log(4, "Could not start pcap thread: %s", return_value_strerror_1);
      }

      goto __CPROVER_DUMP_L4;
    }
  }


__CPROVER_DUMP_L4:
  ;
}

// fg_pcap_init
// file src/fg_pcap.h line 40
void fg_pcap_init(void)
{
  signed int return_value_pcap_findalldevs_1;
  return_value_pcap_findalldevs_1=pcap_findalldevs(&alldevs, errbuf);
  if(return_value_pcap_findalldevs_1 == -1)
    logging_log(4, "Error in pcap_findalldevs: %s\n", (const void *)errbuf);

  else
  {
    pthread_barrier_init(&pcap_barrier, (const union anonymous_19 *)(void *)0, (unsigned int)2);
    goto __CPROVER_DUMP_L2;
  }

__CPROVER_DUMP_L2:
  ;
}

// fg_pcap_work
// file src/fg_pcap.c line 118
static void * fg_pcap_work(void *arg)
{
  signed int rc;
  struct flow *flow = (struct flow *)arg;
  struct pcap_if *d;
  struct addrinfo *ainf;
  char found = (char)0;
  unsigned int net = (unsigned int)0;
  unsigned int mask = (unsigned int)0;
  char dump_filename[500l];
  char hostname[100l];
  struct bpf_program pcap_program;
  struct timespec now;
  char buf[60l];

__CPROVER_DUMP_L1:
  ;
  struct pcap *return_value_pcap_open_live_3;
  signed int return_value_pcap_lookupnet_4;
  signed int return_value_pcap_setnonblock_5;
  signed int return_value_pcap_compile_7;
  signed int return_value_pcap_setfilter_9;
  struct tm *return_value_localtime_10;
  signed int return_value_gethostname_11;
  struct pcap_dumper *return_value_pcap_dump_open_12;
  do
  {
    struct anonymous_1 __cancel_buf;
    void (*__cancel_routine)(void *) = fg_pcap_cleanup;
    void *__cancel_arg = (void *)flow;
    signed int __not_first_call;
    __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
    if(!((signed long int)__not_first_call == 0l))
    {
      __cancel_routine(__cancel_arg);
      __pthread_unwind_next(&__cancel_buf);
    }

    __pthread_register_cancel(&__cancel_buf);
    do
    {
      rc=getaddrinfo(flow->settings.bind_address, (const char *)(void *)0, (struct addrinfo *)(void *)0, &ainf);
      if(!(rc == 0))
      {
        const char *return_value_gai_strerror_1;
        return_value_gai_strerror_1=gai_strerror(rc);
        logging_log(4, "getaddrinfo() failed (%s). Eliding packet capture for flow.", return_value_gai_strerror_1);
        goto remove;
      }

      d = alldevs;
      for( ; !(d == ((struct pcap_if *)NULL)); d = d->next)
      {
        struct pcap_addr *a = d->addresses;
        for( ; !(a == ((struct pcap_addr *)NULL)); a = a->next)
          if(!(a->addr == ((struct sockaddr *)NULL)))
          {
            char return_value_sockaddr_compare_2;
            return_value_sockaddr_compare_2=sockaddr_compare(a->addr, ainf->ai_addr);
            if(!(return_value_sockaddr_compare_2 == 0))
            {

            __CPROVER_DUMP_L8:
              ;
              found = (char)1;
              break;
            }

          }

        if(!(found == 0))
          break;

      }
      if(found == 0)
        logging_log(4, "Failed to determine interface for data connection. No pcap support.");

      else
      {
        errbuf[(signed long int)0] = (char)0;
        return_value_pcap_open_live_3=pcap_open_live(d->name, 130, 0, 0, errbuf);
        flow->pcap_handle = (struct pcap_t *)return_value_pcap_open_live_3;
        if(flow->pcap_handle == ((struct pcap_t *)NULL))
          logging_log(4, "Failed to init pcap on device %s: %s", d->name, (const void *)errbuf);

        else
        {
          return_value_pcap_lookupnet_4=pcap_lookupnet(d->name, &net, &mask, errbuf);
          if(!(return_value_pcap_lookupnet_4 >= 0))
            logging_log(4, "pcap: netmask lookup failed: %s", (const void *)errbuf);

          else
          {
            return_value_pcap_setnonblock_5=pcap_setnonblock((struct pcap *)flow->pcap_handle, 1, errbuf);
            if(!(return_value_pcap_setnonblock_5 >= 0))
              logging_log(4, "pcap: failed to set non-blocking: %s", (const void *)errbuf);

            else
            {
              return_value_pcap_compile_7=pcap_compile((struct pcap *)flow->pcap_handle, &pcap_program, "tcp", 1, mask);
              if(!(return_value_pcap_compile_7 >= 0))
              {
                char *return_value_pcap_geterr_6;
                return_value_pcap_geterr_6=pcap_geterr((struct pcap *)flow->pcap_handle);
                logging_log(4, "pcap: failed compiling filter '%s': %s", (const void *)"tcp", return_value_pcap_geterr_6);
                goto remove;
              }

              return_value_pcap_setfilter_9=pcap_setfilter((struct pcap *)flow->pcap_handle, &pcap_program);
              if(!(return_value_pcap_setfilter_9 >= 0))
              {
                char *return_value_pcap_geterr_8;
                return_value_pcap_geterr_8=pcap_geterr((struct pcap *)flow->pcap_handle);
                logging_log(4, "pcap: failed to set filter: %s", return_value_pcap_geterr_8);
                goto remove;
              }

              dump_filename[(signed long int)0] = (char)0;
              if(!(dump_dir == ((char *)NULL)))
                strcat(dump_filename, dump_dir);

              if(!(dump_prefix == ((char *)NULL)))
                strcat(dump_filename, dump_prefix);

              gettime(&now);
              return_value_localtime_10=localtime(&now.tv_sec);
              strftime(buf, sizeof(char [60l]) /*60ul*/ , "%Y-%m-%d-%H:%M:%S", return_value_localtime_10);
              strcat(dump_filename, buf);
              hostname[(signed long int)0] = (char)0;
              return_value_gethostname_11=gethostname(hostname, (unsigned long int)59);
              if(return_value_gethostname_11 == 0)
              {
                strcat(dump_filename, "-");
                strcat(dump_filename, hostname);
              }

              strcat(dump_filename, "-");
              strcat(dump_filename, d->name);
              strcat(dump_filename, ".pcap");

            __CPROVER_DUMP_L22:
              ;
              return_value_pcap_dump_open_12=pcap_dump_open((struct pcap *)flow->pcap_handle, dump_filename);
              flow->pcap_dumper = (struct pcap_dumper_t *)return_value_pcap_dump_open_12;
              if(flow->pcap_dumper == ((struct pcap_dumper_t *)NULL))
              {
                char *return_value_pcap_geterr_13;
                return_value_pcap_geterr_13=pcap_geterr((struct pcap *)flow->pcap_handle);
                logging_log(4, "pcap: failed to open dump file writing: %s", return_value_pcap_geterr_13);
                goto remove;
              }

              pthread_barrier_wait(&pcap_barrier);
              do
              {
                rc=pcap_dispatch((struct pcap *)flow->pcap_handle, -1, pcap_dump, (unsigned char *)flow->pcap_dumper);
                if(!(rc >= 0))
                {
                  logging_log(4, "pcap_dispatch() failed. Packet dumping stopped for flow %d.", flow->id);
                  pthread_exit(NULL);
                }


              __CPROVER_DUMP_L25:
                ;

              __CPROVER_DUMP_L26:
                ;

              __CPROVER_DUMP_L27:
                ;
                if(rc == 0)
                  pthread_testcancel();

              }
              while((_Bool)1);
            }
          }
        }
      }

    remove:
      ;

    __CPROVER_DUMP_L30:
      ;
    }
    while((_Bool)0);
    __pthread_unregister_cancel(&__cancel_buf);
    __cancel_routine(__cancel_arg);
  }
  while((_Bool)0);
  pthread_barrier_wait(&pcap_barrier);
  return NULL;
}

// flow_block_scheduled
// file src/daemon.c line 160
static inline signed int flow_block_scheduled(struct timespec *now, struct flow *flow)
{
  _Bool return_value_time_is_after_1;
  return_value_time_is_after_1=time_is_after(now, &flow->next_write_block_timestamp);
  return (signed int)return_value_time_is_after_1;
}

// flow_error
// file src/daemon.c line 119
void flow_error(struct flow *flow, const char *fmt, ...)
{
  char str[1000l];
  void **ap = (void **)&fmt;
  vsnprintf(str, (unsigned long int)1000, fmt, ap);
  ap = ((void **)NULL);
  str[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)1);
  flow->error = (char *)return_value_malloc_2;
  strcpy(flow->error, str);
}

// flow_in_delay
// file src/daemon.c line 145
static inline signed int flow_in_delay(struct timespec *now, struct flow *flow, signed int direction)
{
  _Bool return_value_time_is_after_1;
  return_value_time_is_after_1=time_is_after(&flow->start_timestamp[(signed long int)direction], now);
  return (signed int)return_value_time_is_after_1;
}

// flow_sending
// file src/daemon.c line 152
static inline signed int flow_sending(struct timespec *now, struct flow *flow, signed int direction)
{
  signed int return_value_flow_in_delay_1;
  return_value_flow_in_delay_1=flow_in_delay(now, flow, direction);
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  double return_value_time_diff_now_2;
  if(return_value_flow_in_delay_1 == 0)
  {
    if(flow->settings.duration[(signed long int)direction] < 0.000000)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_time_diff_now_2=time_diff_now(&flow->stop_timestamp[(signed long int)direction]);
      tmp_if_expr_3 = return_value_time_diff_now_2 < 0.0 ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// fmtlen
// file src/fg_string.c line 61
unsigned long int fmtlen(const char *fmt, void **ap)
{
  void **ap2;
  char c;
  ap2 = (void **)ap;
  unsigned long int length;
  signed int return_value_vsnprintf_1;
  return_value_vsnprintf_1=vsnprintf(&c, (unsigned long int)1, fmt, ap2);
  length = (unsigned long int)return_value_vsnprintf_1;
  ap2 = ((void **)NULL);
  return length;
}

// free_data
// file src/fg_argparser.c line 122
static void free_data(struct arg_parser * const ap)
{
  signed int i = 0;
  for( ; !(i >= ap->data_size); i = i + 1)
  {
    free((void *)(ap->data + (signed long int)i)->argument);
    free((void *)(ap->data + (signed long int)i)->opt_string);
  }
  if(!(ap->data == ((struct ap_Record *)NULL)))
  {
    free((void *)ap->data);
    ap->data = ((struct ap_Record *)NULL);
  }

  ap->data_size = 0;
  signed int free_data__1__3__i = 0;
  for( ; !(free_data__1__3__i >= ap->num_options); free_data__1__3__i = free_data__1__3__i + 1)
  {
    free((void *)(ap->options + (signed long int)free_data__1__3__i)->name);
    free((void *)(ap->options + (signed long int)free_data__1__3__i)->mutex);
  }
  free((void *)ap->options);
  ap->num_options = 0;
}

// free_math_functions
// file src/fg_math.h line 37
extern void free_math_functions(struct flow *flow)
{
  gsl_rng_free(flow->r);
}

// get_imtu
// file src/fg_socket.h line 57
signed int get_imtu(signed int fd)
{
  struct sockaddr_storage sa;
  unsigned int sl = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  struct ifreq ifreqs[20l];
  struct ifconf ifconf;
  signed int nifaces;
  signed int i;
  signed int mtu = 0;
  memset((void *)&ifconf, 0, sizeof(struct ifconf) /*16ul*/ );
  ifconf.ifc_ifcu.ifcu_buf = (char *)ifreqs;
  ifconf.ifc_len = (signed int)sizeof(struct ifreq [20l]) /*800ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(fd, (struct sockaddr *)&sa, &sl);
  if(!(return_value_getsockname_1 >= 0))
    return 0;

  else
  {
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(fd, (unsigned long int)0x8912, &ifconf);
    if(!(return_value_ioctl_2 >= 0))
      return 0;

    else
    {
      nifaces = (signed int)((unsigned long int)ifconf.ifc_len / sizeof(struct ifreq) /*40ul*/ );
      i = 0;
      for( ; !(i >= nifaces); i = i + 1)
      {
        char return_value_sockaddr_compare_3;
        return_value_sockaddr_compare_3=sockaddr_compare((struct sockaddr *)&ifreqs[(signed long int)i].ifr_ifru.ifru_addr, (struct sockaddr *)&sa);
        if(!(return_value_sockaddr_compare_3 == 0))
          break;

      }
      signed int return_value_ioctl_4;
      return_value_ioctl_4=ioctl(fd, (unsigned long int)0x8921, &ifreqs[(signed long int)i]);
      if(!(return_value_ioctl_4 >= 0))
        return 0;

      else
      {

      __CPROVER_DUMP_L5:
        ;
        mtu = ifreqs[(signed long int)i].ifr_ifru.ifru_mtu;
        if(mtu >= 1)
          return mtu;

        else
          return 0;
      }
    }
  }
}

// get_mutex_count
// file src/fg_argparser.c line 319
static signed int get_mutex_count(struct ap_Option *options)
{
  signed int num = 0;
  signed int i = 0;
  _Bool tmp_if_expr_1;
  for( ; !((options + (signed long int)i)->code == 0); i = i + 1)
  {
    signed int *get_mutex_count__1__1__1__mutex = (options + (signed long int)i)->mutex;
    do
    {
      if(!(get_mutex_count__1__1__1__mutex == ((signed int *)NULL)))
        tmp_if_expr_1 = *get_mutex_count__1__1__1__mutex != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      signed int _s = num;
      signed int _c = *get_mutex_count__1__1__1__mutex;
      if(!(_s >= _c))
        num = *get_mutex_count__1__1__1__mutex;

      get_mutex_count__1__1__1__mutex = get_mutex_count__1__1__1__mutex + 1l;
    }
    while((_Bool)1);
  }
  return num;
}

// get_ncores
// file src/fg_affinity.h line 50
signed int get_ncores(enum ncore_query query)
{
  signed long int return_value_sysconf_1;
  signed long int return_value_sysconf_2;
  signed int *return_value___errno_location_3;
  switch((signed int)query)
  {
    case NCORE_CONFIG:
    {
      return_value_sysconf_1=sysconf(83);
      return (signed int)return_value_sysconf_1;
    }
    case NCORE_CURRENT:
    {
      return_value_sysconf_2=sysconf(84);
      return (signed int)return_value_sysconf_2;
    }
    default:
    {
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 22;
      return -1;
    }
  }
}

// get_num_options
// file src/fg_argparser.c line 305
static signed int get_num_options(struct ap_Option *options)
{
  signed int i = 0;
  for( ; !((options + (signed long int)i)->code == 0); i = i + 1)
    ;
  return i;
}

// get_pmtu
// file src/fg_socket.h line 56
signed int get_pmtu(signed int fd)
{
  signed int mtu = 0;
  if(!(fd >= 0))
    return 0;

  else
  {
    unsigned int mtu_len = (unsigned int)sizeof(signed int) /*4ul*/ ;
    signed int return_value_getsockopt_1;
    return_value_getsockopt_1=getsockopt(fd, 0, 14, (void *)&mtu, &mtu_len);
    if(!(return_value_getsockopt_1 >= 0))
      return 0;

    else
      return mtu;
  }
}

// get_port
// file src/fg_socket.h line 62
signed int get_port(signed int fd)
{
  struct sockaddr_storage addr;
  unsigned int addrlen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
  signed int return_value_getsockname_1;
  return_value_getsockname_1=getsockname(fd, (struct sockaddr *)&addr, &addrlen);
  if(!(return_value_getsockname_1 == 0))
    return -1;

  else
  {
    signed int return_value_getnameinfo_2;
    static char service[32l];
    return_value_getnameinfo_2=getnameinfo((struct sockaddr *)&addr, addrlen, (char *)(void *)0, (unsigned int)0, service, (unsigned int)sizeof(char [32l]) /*32ul*/ , 2);
    if(!(return_value_getnameinfo_2 == 0))
      return -1;

    else
    {
      signed int return_value_atoi_3;
      return_value_atoi_3=atoi(service);
      return return_value_atoi_3;
    }
  }
}

// get_reports
// file src/daemon.c line 832
struct report * get_reports(signed int *has_more)
{
  const unsigned int max_reports = (const unsigned int)50;
  struct report *ret;

__CPROVER_DUMP_L1:
  ;
  pthread_mutex_lock(&mutex);

__CPROVER_DUMP_L2:
  ;
  ret = reports;
  if(max_reports >= pending_reports)
  {
    *has_more = 0;
    pending_reports = (unsigned int)0;
    reports = (struct report *)(void *)0;
    reports_last = ((struct report *)NULL);
  }

  else
  {
    struct report *tmp;
    unsigned int i = (unsigned int)0;
    for( ; !(i >= max_reports + 4294967295u); i = i + 1u)
      reports = reports->next;
    tmp = reports->next;
    reports->next = ((struct report *)NULL);
    reports = tmp;
    pending_reports = pending_reports - max_reports;
    *has_more = 1;
  }
  pthread_mutex_unlock(&mutex);

__CPROVER_DUMP_L7:
  ;
  return ret;
}

// get_tcp_info
// file src/daemon.c line 629
signed int get_tcp_info(struct flow *flow, struct fg_tcp_info *info)
{
  struct tcp_info tmp_info;
  unsigned int info_len = (unsigned int)sizeof(struct tcp_info) /*104ul*/ ;
  signed int rc;
  memset((void *)info, 0, sizeof(struct fg_tcp_info) /*60ul*/ );
  rc=getsockopt(flow->fd, 6, 11, (void *)&tmp_info, &info_len);
  if(rc == -1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    error((enum error_levels)ERR_WARNING, *return_value___errno_location_1, "getsockopt() failed");
    return -1;
  }

  info->tcpi_snd_cwnd = (signed int)tmp_info.tcpi_snd_cwnd;
  info->tcpi_snd_ssthresh = (signed int)tmp_info.tcpi_snd_ssthresh;
  info->tcpi_rtt = (signed int)tmp_info.tcpi_rtt;
  info->tcpi_rttvar = (signed int)tmp_info.tcpi_rttvar;
  info->tcpi_rto = (signed int)tmp_info.tcpi_rto;
  info->tcpi_snd_mss = (signed int)tmp_info.tcpi_snd_mss;
  info->tcpi_backoff = (signed int)tmp_info.tcpi_backoff;
  info->tcpi_unacked = (signed int)tmp_info.tcpi_unacked;
  info->tcpi_sacked = (signed int)tmp_info.tcpi_sacked;
  info->tcpi_lost = (signed int)tmp_info.tcpi_lost;
  info->tcpi_retrans = (signed int)tmp_info.tcpi_retrans;
  info->tcpi_retransmits = (signed int)tmp_info.tcpi_retransmits;
  info->tcpi_fackets = (signed int)tmp_info.tcpi_fackets;
  info->tcpi_reordering = (signed int)tmp_info.tcpi_reordering;
  info->tcpi_ca_state = (signed int)tmp_info.tcpi_ca_state;
  return 0;
}

// gettime
// file src/fg_time.h line 123
signed int gettime(struct timespec *tp)
{
  static struct timespec res = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  if(res.tv_nsec == 0l && res.tv_sec == 0l)
    clock_getres(0, &res);

  signed int return_value_clock_gettime_1;
  return_value_clock_gettime_1=clock_gettime(0, tp);
  return return_value_clock_gettime_1;
}

// init_flow
// file src/daemon.c line 865
void init_flow(struct flow *flow, signed int is_source)
{
  memset((void *)flow, 0, sizeof(struct flow) /*3248ul*/ );
  signed int tmp_post_1 = next_flow_id;
  next_flow_id = next_flow_id + 1;
  flow->id = tmp_post_1;
  flow->endpoint = (enum flow_endpoint_type)(is_source != 0 ? SOURCE : DESTINATION);
  flow->state = (enum flow_state)(is_source != 0 ? GRIND_WAIT_CONNECT : GRIND_WAIT_ACCEPT);
  flow->fd = -1;
  flow->listenfd_data = -1;
  flow->current_read_block_size = (unsigned int)(signed int)sizeof(struct block) /*40ul*/ ;
  flow->current_write_block_size = (unsigned int)(signed int)sizeof(struct block) /*40ul*/ ;
  flow->finished[(signed long int)0] = (char)0;
  flow->finished[(signed long int)1] = flow->finished[(signed long int)0];
  flow->addr = ((struct sockaddr *)NULL);
  signed int i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    flow->statistics[(signed long int)i].bytes_read = (unsigned long long int)0;
    flow->statistics[(signed long int)i].bytes_written = (unsigned long long int)0;
    flow->statistics[(signed long int)i].request_blocks_read = (unsigned int)0;
    flow->statistics[(signed long int)i].request_blocks_written = (unsigned int)0;
    flow->statistics[(signed long int)i].response_blocks_read = (unsigned int)0;
    flow->statistics[(signed long int)i].response_blocks_written = (unsigned int)0;
    flow->statistics[(signed long int)i].rtt_min = (double)3.40282346638528859812e+38F;
    flow->statistics[(signed long int)i].rtt_max = (double)1.17549435082228750797e-38F;
    flow->statistics[(signed long int)i].rtt_sum = (double)0.0F;
    flow->statistics[(signed long int)i].iat_min = (double)3.40282346638528859812e+38F;
    flow->statistics[(signed long int)i].iat_max = (double)1.17549435082228750797e-38F;
    flow->statistics[(signed long int)i].iat_sum = (double)0.0F;
    flow->statistics[(signed long int)i].delay_min = (double)3.40282346638528859812e+38F;
    flow->statistics[(signed long int)i].delay_max = (double)1.17549435082228750797e-38F;
    flow->statistics[(signed long int)i].delay_sum = (double)0.0F;
  }

__CPROVER_DUMP_L3:
  ;
}

// init_math_functions
// file src/fg_math.h line 36
extern void init_math_functions(struct flow *flow, unsigned long int seed)
{
  signed int rc;
  fesetround(0);
  const struct anonymous_25 *T;
  gsl_rng_env_setup();
  T = gsl_rng_default;
  flow->r=gsl_rng_alloc(T);
  signed int *return_value___errno_location_2;
  if(seed == 0ul)
  {

  __CPROVER_DUMP_L1:
    ;
    signed int data;
    data=open("/dev/urandom", 00);
    signed long int return_value_read_1;
    return_value_read_1=read(data, (void *)&seed, sizeof(signed long int) /*8ul*/ );
    rc = (signed int)return_value_read_1;
    close(data);
    if(rc == -1)
    {
      return_value___errno_location_2=__errno_location();
      error((enum error_levels)ERR_CRIT, *return_value___errno_location_2, "read /dev/urandom failed");
    }

  }

  gsl_rng_set(flow->r, seed);

__CPROVER_DUMP_L4:
  ;
}

// init_rpc_server
// file src/flowgrindd.c line 914
static void init_rpc_server(struct fg_rpc_server *server, unsigned int port)
{
  struct xmlrpc_registry *registryP;
  struct _xmlrpc_env *env = &server->env;
  memset((void *)&server->parms, 0, sizeof(struct anonymous_17) /*128ul*/ );
  xmlrpc_env_init(env);
  registryP=xmlrpc_registry_new(env);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "add_flow_destination", add_flow_destination_link1, (void *)0);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "add_flow_source", add_flow_source_link1, (void *)0);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "start_flows", start_flows_link1, (void *)0);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "get_reports", method_get_reports, (void *)0);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "stop_flow", method_stop_flow, (void *)0);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "get_version", method_get_version, (void *)0);
  xmlrpc_registry_add_method(env, registryP, (const char *)(void *)0, "get_status", method_get_status, (void *)0);
  server->parms.config_file_name = (const char *)(void *)0;
  server->parms.registryP = registryP;
  server->parms.socket_bound = 1;
  server->parms.log_file_name = (const char *)(void *)0;
  server->parms.keepalive_timeout = (unsigned int)60;
  server->parms.keepalive_max_conn = (unsigned int)1000;
  server->parms.dont_advertise = 1;
  logging_log(5, "Running XML-RPC server on port %u", port);
  printf("Running XML-RPC server...\n");
  server->parms.socket_handle=bind_rpc_server(rpc_bind_addr, port);
}

// logging_exit
// file src/log.c line 58
void logging_exit(void)
{
  if(!(log_type == 0))
  {
    if(log_type == 1)
      goto __CPROVER_DUMP_L2;

  }

  else
    closelog();

__CPROVER_DUMP_L2:
  ;
  free((void *)logstr);
}

// logging_init
// file src/log.h line 45
void logging_init(void)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)255);
  logstr = (char *)return_value_malloc_1;
  if(logstr == ((char *)NULL))
    error((enum error_levels)ERR_CRIT, 0, "unable to allocate memory for logging string");

  if(!(log_type == 0))
  {
    if(log_type == 1)
      goto __CPROVER_DUMP_L3;

  }

  else
    openlog("flowgrind_daemon", 0x08 | 0x02 | 0x01, 3 << 3);

__CPROVER_DUMP_L3:
  ;
}

// logging_log
// file src/log.h line 47
void logging_log(signed int priority, const char *fmt, ...)
{
  signed int n;
  void **ap;
  memset((void *)logstr, 0, (unsigned long int)255);
  ap = (void **)&fmt;
  n=vsnprintf(logstr, (unsigned long int)255, fmt, ap);
  ap = ((void **)NULL);
  if(n >= 0 && !(n >= 255))
    logging_log_string(priority, logstr);

}

// logging_log_string
// file src/log.c line 86
void logging_log_string(signed int priority, const char *s)
{
  char *return_value_logging_time_1;
  switch(log_type)
  {
    case 0:
    {
      syslog(priority, "%s", s);
      break;
    }
    case 1:
    {
      return_value_logging_time_1=logging_time();
      fprintf(stderr, "%s %s\n", return_value_logging_time_1, s);
      fflush(stderr);
    }
  }
}

// logging_time
// file src/log.c line 99
char * logging_time(void)
{
  signed long int tp;
  struct tm *loc = (struct tm *)(void *)0;
  tp=time((signed long int *)(void *)0);
  loc=localtime(&tp);
  memset((void *)&timestr, 0, sizeof(char [20l]) /*20ul*/ );
  strftime(&timestr[(signed long int)0], sizeof(char [20l]) /*20ul*/ , "%Y/%m/%d %H:%M:%S", loc);
  return &timestr[(signed long int)0];
}

// main
// file src/flowgrindd.c line 1121
signed int main(signed int argc, char **argv)
{
  struct sigaction sa;
  struct fg_rpc_server server;
  void (*return_value_signal_2)(signed int);
  return_value_signal_2=signal(13, (void (*)(signed int))1);
  signed int *return_value___errno_location_1;
  if(return_value_signal_2 == (void (*)(signed int))-1)
  {
    return_value___errno_location_1=__errno_location();
    error((enum error_levels)ERR_CRIT, *return_value___errno_location_1, "could not ignore SIGPIPE");
  }

  sa.__sigaction_handler.sa_handler = sighandler;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  sigaction(1, &sa, (struct sigaction *)(void *)0);
  sigaction(14, &sa, (struct sigaction *)(void *)0);
  sigaction(17, &sa, (struct sigaction *)(void *)0);
  set_progname(argv[(signed long int)0]);
  parse_cmdline(argc, argv);
  logging_init();
  sanity_check();
  fg_list_init(&flows);
  fg_pcap_init();
  init_rpc_server(&server, port);
  signed int *return_value___errno_location_3;
  if(log_type == 0)
  {
    signed int return_value_daemon_4;
    return_value_daemon_4=daemon(0, 0);
    if(return_value_daemon_4 == -1)
    {
      return_value___errno_location_3=__errno_location();
      error((enum error_levels)ERR_CRIT, *return_value___errno_location_3, "daemon() failed");
    }

    logging_log(5, "flowgrindd daemonized");
  }

  _Bool return_value_ap_is_used_5;
  return_value_ap_is_used_5=ap_is_used(&parser, 99);
  if(!(return_value_ap_is_used_5 == (_Bool)0))
    bind_daemon_to_core();

  create_daemon_thread();
  run_rpc_server(&server);
  ap_free(&parser);
  error((enum error_levels)ERR_CRIT, 0, "control should never reach end of main()");
}

// method_get_reports
// file src/flowgrindd.c line 628
static struct _xmlrpc_value * method_get_reports(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  signed int has_more;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);
  struct _xmlrpc_value *item = ((struct _xmlrpc_value *)NULL);
  (void)param_array;
  (void)user_data;

__CPROVER_DUMP_L1:
  ;
  struct report *report;
  report=get_reports(&has_more);
  ret=xmlrpc_array_new(env);
  item=xmlrpc_int_new(env, has_more);
  xmlrpc_array_append_item(env, ret, item);
  xmlrpc_DECREF(item);
  while(!(report == ((struct report *)NULL)))
  {
    struct _xmlrpc_value *rv;
    rv=xmlrpc_build_value(env, "({s:i,s:i,s:i,s:i,s:i,s:i}{s:i,s:i,s:i,s:i}{s:i,s:i,s:i,s:i}{s:d,s:d,s:d,s:d,s:d,s:d,s:d,s:d,s:d}{s:i,s:i}{s:i,s:i,s:i,s:i,s:i}{s:i,s:i,s:i,s:i,s:i}{s:i,s:i,s:i,s:i,s:i}{s:i})", (const void *)"id", report->id, (const void *)"type", report->type, (const void *)"begin_tv_sec", (signed int)report->begin.tv_sec, (const void *)"begin_tv_nsec", (signed int)report->begin.tv_nsec, (const void *)"end_tv_sec", (signed int)report->end.tv_sec, (const void *)"end_tv_nsec", (signed int)report->end.tv_nsec, (const void *)"bytes_read_high", (signed int)(report->bytes_read >> 32), (const void *)"bytes_read_low", (signed int)(report->bytes_read & (unsigned long int)0xFFFFFFFF), (const void *)"bytes_written_high", (signed int)(report->bytes_written >> 32), (const void *)"bytes_written_low", (signed int)(report->bytes_written & (unsigned long int)0xFFFFFFFF), (const void *)"request_blocks_read", report->request_blocks_read, (const void *)"request_blocks_written", report->request_blocks_written, (const void *)"response_blocks_read", report->response_blocks_read, (const void *)"response_blocks_written", report->response_blocks_written, (const void *)"rtt_min", report->rtt_min, (const void *)"rtt_max", report->rtt_max, (const void *)"rtt_sum", report->rtt_sum, (const void *)"iat_min", report->iat_min, (const void *)"iat_max", report->iat_max, (const void *)"iat_sum", report->iat_sum, (const void *)"delay_min", report->delay_min, (const void *)"delay_max", report->delay_max, (const void *)"delay_sum", report->delay_sum, (const void *)"pmtu", report->pmtu, (const void *)"imtu", report->imtu, (const void *)"tcpi_snd_cwnd", (signed int)report->tcp_info.tcpi_snd_cwnd, (const void *)"tcpi_snd_ssthresh", (signed int)report->tcp_info.tcpi_snd_ssthresh, (const void *)"tcpi_unacked", (signed int)report->tcp_info.tcpi_unacked, (const void *)"tcpi_sacked", (signed int)report->tcp_info.tcpi_sacked, (const void *)"tcpi_lost", (signed int)report->tcp_info.tcpi_lost, (const void *)"tcpi_retrans", (signed int)report->tcp_info.tcpi_retrans, (const void *)"tcpi_retransmits", (signed int)report->tcp_info.tcpi_retransmits, (const void *)"tcpi_fackets", (signed int)report->tcp_info.tcpi_fackets, (const void *)"tcpi_reordering", (signed int)report->tcp_info.tcpi_reordering, (const void *)"tcpi_rtt", (signed int)report->tcp_info.tcpi_rtt, (const void *)"tcpi_rttvar", (signed int)report->tcp_info.tcpi_rttvar, (const void *)"tcpi_rto", (signed int)report->tcp_info.tcpi_rto, (const void *)"tcpi_backoff", (signed int)report->tcp_info.tcpi_backoff, (const void *)"tcpi_ca_state", (signed int)report->tcp_info.tcpi_ca_state, (const void *)"tcpi_snd_mss", (signed int)report->tcp_info.tcpi_snd_mss, (const void *)"status", report->status);
    xmlrpc_array_append_item(env, ret, rv);
    xmlrpc_DECREF(rv);
    struct report *next = report->next;
    free((void *)report);
    report = next;
  }
  if(!(env->fault_occurred == 0))
    logging_log(4, "Method get_reports failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L4:
      ;
  return ret;
}

// method_get_status
// file src/flowgrindd.c line 808
static struct _xmlrpc_value * method_get_status(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  (void)param_array;
  (void)user_data;
  signed int rc;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);
  struct request_get_status *request = ((struct request_get_status *)NULL);

__CPROVER_DUMP_L1:
  ;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct request_get_status) /*40ul*/ );
  request = (struct request_get_status *)return_value_malloc_1;
  rc=dispatch_request((struct request *)request, 4);
  if(rc == -1)
  {
    xmlrpc_env_set_fault(env, -500, request->r.error);
    goto cleanup;
  }

  ret=xmlrpc_build_value(env, "{s:i,s:i}", (const void *)"started", request->started, (const void *)"num_flows", request->num_flows);

cleanup:
  ;
  if(!(request == ((struct request_get_status *)NULL)))
    do
    {
      void *stopper;
      signed int literal_2[1l] = { 0 };
      stopper = (void *)literal_2;
      void **list;
      void *literal_3[3l] = { (void *)request->r.error, (void *)request, stopper };
      list = literal_3;
      signed int i = 0;
      for( ; !(list[(signed long int)i] == stopper); i = i + 1)
        free(list[(signed long int)i]);
    }
    while((_Bool)0);

  if(!(env->fault_occurred == 0))
    logging_log(4, "Method get_status failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L9:
      ;
  return ret;
}

// method_get_version
// file src/flowgrindd.c line 776
static struct _xmlrpc_value * method_get_version(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  (void)param_array;
  (void)user_data;
  struct utsname buf;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);

__CPROVER_DUMP_L1:
  ;
  signed int return_value_uname_3;
  return_value_uname_3=uname(&buf);
  if(!(return_value_uname_3 == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    char *return_value_strerror_2;
    return_value_strerror_2=strerror(*return_value___errno_location_1);
    logging_log(4, "uname() failed %s", return_value_strerror_2);
    exit(1);
  }

  ret=xmlrpc_build_value(env, "{s:s,s:i,s:s,s:s}", (const void *)"version", (const void *)"0.7.5", (const void *)"api_version", 3, (const void *)"os_name", (const void *)buf.sysname, (const void *)"os_release", (const void *)buf.release);
  if(!(env->fault_occurred == 0))
    logging_log(4, "Method get_version failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L3:
      ;
  return ret;
}

// method_stop_flow
// file src/flowgrindd.c line 731
static struct _xmlrpc_value * method_stop_flow(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  (void)user_data;
  signed int rc;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);
  signed int flow_id;
  struct request_stop_flow *request = ((struct request_stop_flow *)NULL);

__CPROVER_DUMP_L1:
  ;
  xmlrpc_decompose_value(env, param_array, "({s:i,*})", (const void *)"flow_id", &flow_id);
  void *return_value_malloc_1;
  if(env->fault_occurred == 0)
  {
    return_value_malloc_1=malloc(sizeof(struct request_stop_flow) /*40ul*/ );
    request = (struct request_stop_flow *)return_value_malloc_1;
    request->flow_id = flow_id;
    rc=dispatch_request((struct request *)request, 3);
    if(rc == -1)
    {
      xmlrpc_env_set_fault(env, -500, request->r.error);
      goto cleanup;
    }

    ret=xmlrpc_build_value(env, "()");
  }


cleanup:
  ;
  if(!(request == ((struct request_stop_flow *)NULL)))
    do
    {
      void *stopper;
      signed int literal_2[1l] = { 0 };
      stopper = (void *)literal_2;
      void **list;
      void *literal_3[3l] = { (void *)request->r.error, (void *)request, stopper };
      list = literal_3;
      signed int i = 0;
      for( ; !(list[(signed long int)i] == stopper); i = i + 1)
        free(list[(signed long int)i]);
    }
    while((_Bool)0);

  if(!(env->fault_occurred == 0))
    logging_log(4, "Method stop_flow failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L9:
      ;
  return ret;
}

// name2socket
// file src/source.c line 76
static signed int name2socket(struct flow *flow, char *server_name, unsigned int port, struct sockaddr **saptr, unsigned int *lenp, char do_connect, const signed int read_buffer_size_req, signed int *read_buffer_size, const signed int send_buffer_size_req, signed int *send_buffer_size)
{
  signed int fd;
  signed int n;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  struct sockaddr_in *tempv4;
  struct sockaddr_in6 *tempv6;
  char service[7l];
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  snprintf(service, sizeof(char [7l]) /*7ul*/ , "%u", port);
  n=getaddrinfo(server_name, service, &hints, &res);
  if(!(n == 0))
  {
    const char *return_value_gai_strerror_1;
    return_value_gai_strerror_1=gai_strerror(n);
    flow_error(flow, "getaddrinfo() failed: %s", return_value_gai_strerror_1);
    return -1;
  }

  ressave = res;
  do
  {
    signed int rc;
    fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if(fd >= 0)
    {
      if(!(send_buffer_size == ((signed int *)NULL)))
        *send_buffer_size=set_window_size_directed(fd, send_buffer_size_req, 7);

      if(!(read_buffer_size == ((signed int *)NULL)))
        *read_buffer_size=set_window_size_directed(fd, read_buffer_size_req, 8);

      if(do_connect == 0)
        break;

      rc=connect(fd, res->ai_addr, res->ai_addrlen);
      if(rc == 0)
      {
        if(res->ai_family == 2)
        {
          tempv4 = (struct sockaddr_in *)res->ai_addr;
          char *return_value_inet_ntoa_2;
          return_value_inet_ntoa_2=inet_ntoa(tempv4->sin_addr);
          __builtin_strncpy(server_name, return_value_inet_ntoa_2, (unsigned long int)256);
          server_name[(signed long int)255] = (char)0;
        }

        else
          if(res->ai_family == 10)
          {
            tempv6 = (struct sockaddr_in6 *)res->ai_addr;
            inet_ntop(10, (const void *)&tempv6->sin6_addr, server_name, (unsigned int)256);
          }

        break;
      }

      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      error((enum error_levels)ERR_WARNING, *return_value___errno_location_3, "failed to connect to '%s:%d' ", server_name, port);
      close(fd);
    }

    res = res->ai_next;
  }
  while(!(res == ((struct addrinfo *)NULL)));
  if(res == ((struct addrinfo *)NULL))
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(*return_value___errno_location_4);
    flow_error(flow, "Could not establish connection to \"%s:%d\": %s", server_name, port, return_value_strerror_5);
    freeaddrinfo(ressave);
    return -1;
  }

  signed int *return_value___errno_location_7;
  if(!(saptr == ((struct sockaddr **)NULL)) && !(lenp == ((unsigned int *)NULL)))
  {
    void *return_value_malloc_6;
    return_value_malloc_6=malloc((unsigned long int)res->ai_addrlen);
    *saptr = (struct sockaddr *)return_value_malloc_6;
    if(*saptr == ((struct sockaddr *)NULL))
    {
      return_value___errno_location_7=__errno_location();
      error((enum error_levels)ERR_CRIT, *return_value___errno_location_7, "malloc(): failed");
    }

    memcpy((void *)*saptr, (const void *)res->ai_addr, (unsigned long int)res->ai_addrlen);
    *lenp = res->ai_addrlen;
  }

  freeaddrinfo(ressave);
  return fd;
}

// next_interpacket_gap
// file src/trafgen.h line 35
extern double next_interpacket_gap(struct flow *flow)
{
  double gap = 0.0;
  if(!(flow->settings.write_rate == 0))
    gap = (double)flow->settings.maximum_block_size / (double)flow->settings.write_rate;

  else
    gap=calculate(flow, flow->settings.interpacket_gap_trafgen_options.distribution, flow->settings.interpacket_gap_trafgen_options.param_one, flow->settings.interpacket_gap_trafgen_options.param_two);
  if(IEEE_FLOAT_NOTEQUAL(gap, 0.000000))

    __CPROVER_DUMP_L3:
      ;

  return gap;
}

// next_request_block_size
// file src/trafgen.h line 33
extern signed int next_request_block_size(struct flow *flow)
{
  signed int bs = 0;
  signed int i = 0;
  while((_Bool)1)
  {
    if(bs >= (signed int)sizeof(struct block) /*40*/ )
    {
      if(flow->settings.maximum_block_size >= bs)
        goto __CPROVER_DUMP_L3;

    }

    if(i >= 10)
      break;

    double return_value_calculate_1;
    return_value_calculate_1=calculate(flow, flow->settings.request_trafgen_options.distribution, flow->settings.request_trafgen_options.param_one, flow->settings.request_trafgen_options.param_two);
    double return_value_round_2;
    return_value_round_2=round(return_value_calculate_1);
    bs = (signed int)return_value_round_2;
    i = i + 1;
  }

__CPROVER_DUMP_L3:
  ;
  if(i >= 10 && !(bs >= (signed int)sizeof(struct block) /*40*/ ))
    bs = (signed int)sizeof(struct block) /*40ul*/ ;


__CPROVER_DUMP_L4:
  ;
  if(i >= 10)
  {
    if(!(flow->settings.maximum_block_size >= bs))
      bs = flow->settings.maximum_block_size;

  }


__CPROVER_DUMP_L6:
  ;

__CPROVER_DUMP_L7:
  ;
  return bs;
}

// next_response_block_size
// file src/trafgen.h line 34
extern signed int next_response_block_size(struct flow *flow)
{
  signed int bs;
  double return_value_calculate_1;
  return_value_calculate_1=calculate(flow, flow->settings.response_trafgen_options.distribution, flow->settings.response_trafgen_options.param_one, flow->settings.response_trafgen_options.param_two);
  double return_value_round_2;
  return_value_round_2=round(return_value_calculate_1);
  bs = (signed int)return_value_round_2;
  if(!(bs == 0) && !(bs >= (signed int)sizeof(struct block) /*40*/ ))
    bs = (signed int)sizeof(struct block) /*40ul*/ ;


__CPROVER_DUMP_L1:
  ;
  if(!(flow->settings.maximum_block_size >= bs))
    bs = flow->settings.maximum_block_size;


__CPROVER_DUMP_L3:
  ;
  if(!(bs == 0))

    __CPROVER_DUMP_L5:
      ;

  return bs;
}

// normalize_tp
// file src/fg_time.c line 97
_Bool normalize_tp(struct timespec *tp)
{
  _Bool normalized = (_Bool)1;
  for( ; tp->tv_nsec >= 1000000000L; normalized = (_Bool)0)
  {
    tp->tv_nsec = tp->tv_nsec - (signed long int)1000000000L;
    tp->tv_sec = tp->tv_sec + 1l;
  }
  for( ; !(tp->tv_nsec >= 0l); normalized = (_Bool)0)
  {
    tp->tv_nsec = tp->tv_nsec + (signed long int)1000000000L;
    tp->tv_sec = tp->tv_sec - 1l;
  }
  return normalized;
}

// parse_cmdline
// file src/flowgrindd.c line 1019
static void parse_cmdline(signed int argc, char **argv)
{
  struct ap_Option options[9l] = { { .code=98, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_yes, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=99, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_yes, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=100, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_no, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=104, .name="help", .has_arg=(enum ap_Has_arg)ap_no, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=111, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_yes, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=112, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_yes, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=118, .name="version", .has_arg=(enum ap_Has_arg)ap_no, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=119, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_yes, .tag=0,
    .mutex=((signed int *)NULL) },
    { .code=0, .name=((char *)NULL), .has_arg=(enum ap_Has_arg)ap_no, .tag=0,
    .mutex=((signed int *)NULL) } };
  _Bool return_value_ap_init_1;
  return_value_ap_init_1=ap_init(&parser, argc, (const char * const *)argv, options, (const char)0);
  if(return_value_ap_init_1 == (_Bool)0)
    error((enum error_levels)ERR_CRIT, 0, "could not allocate memory for option parser");

  const char *return_value_ap_error_3;
  return_value_ap_error_3=ap_error(&parser);
  if(!(return_value_ap_error_3 == ((const char *)NULL)))
    do
    {
      const char *return_value_ap_error_2;
      return_value_ap_error_2=ap_error(&parser);
      error((enum error_levels)ERR_ERROR, 0, "%s", return_value_ap_error_2);
      usage((signed short int)1);
    }
    while((_Bool)0);

  signed int argind = 0;
  signed int return_value_ap_arguments_4;
  char *return_value___strdup_5;
  signed int return_value_sscanf_6;
  signed int return_value_sscanf_7;
  signed int return_value_sscanf_8;
  char *return_value___strdup_9;
  do
  {
    return_value_ap_arguments_4=ap_arguments(&parser);
    if(argind >= return_value_ap_arguments_4)
      break;

    signed int code;
    code=ap_code(&parser, argind);
    const char *arg;
    arg=ap_argument(&parser, argind);
    switch(code)
    {
      case 0:
        do
        {
          error((enum error_levels)ERR_ERROR, 0, "invalid argument: %s", arg);
          usage((signed short int)1);
        }
        while((_Bool)0);
      case 98:
      {
        return_value___strdup_5=__strdup(arg);
        rpc_bind_addr = return_value___strdup_5;
        return_value_sscanf_6=sscanf(arg, "%s", rpc_bind_addr);
        if(!(return_value_sscanf_6 == 1))
          do
          {
            error((enum error_levels)ERR_ERROR, 0, "failed to parse bind address");
            usage((signed short int)1);
          }
          while((_Bool)0);

        break;
      }
      case 99:
      {
        return_value_sscanf_7=sscanf(arg, "%u", &core);
        if(!(return_value_sscanf_7 == 1))
          do
          {
            error((enum error_levels)ERR_ERROR, 0, "failed to parse CPU number");
            usage((signed short int)1);
          }
          while((_Bool)0);

        break;
      }
      case 100:
      {
        log_type = 1;
        break;
      }
      case 104:
      {
        usage((signed short int)0);
        break;
      }
      case 112:
      {
        return_value_sscanf_8=sscanf(arg, "%u", &port);
        if(!(return_value_sscanf_8 == 1))
          do
          {
            error((enum error_levels)ERR_ERROR, 0, "failed to parse port number");
            usage((signed short int)1);
          }
          while((_Bool)0);

        break;
      }
      case 119:
      {
        return_value___strdup_9=__strdup(arg);
        dump_dir = return_value___strdup_9;
        break;
      }
      case 118:
      {
        fprintf(stderr, "%s %s%s\n%s\n\n%s\n", progname, (const void *)"0.7.5", (const void *)"Copyright (C) 2007 - 2014 Flowgrind authors.", (const void *)"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.", (const void *)"Written by Arnd Hannemann, Tim Kosse, Christian Samsel, Daniel Schaffrath\nand Alexander Zimmermann.");
        exit(0);
        break;
      }
      default:
        do
        {
          error((enum error_levels)ERR_ERROR, 0, "uncaught option: %s", arg);
          usage((signed short int)1);
        }
        while((_Bool)0);
    }
    argind = argind + 1;
  }
  while((_Bool)1);
  signed int return_value_process_dump_dir_11;
  return_value_process_dump_dir_11=process_dump_dir();
  if(return_value_process_dump_dir_11 == 0)
  {
    _Bool return_value_ap_is_used_10;
    return_value_ap_is_used_10=ap_is_used(&parser, 119);
    if(!(return_value_ap_is_used_10 == (_Bool)0))
      do
      {
        error((enum error_levels)ERR_ERROR, 0, "the dump directory %s for tcpdumps does either not exist or you have insufficient permissions to write to it", dump_dir);
        usage((signed short int)1);
      }
      while((_Bool)0);

    else
      error((enum error_levels)ERR_WARNING, 0, "tcpdumping will not be available since you don't have sufficient permissions to write to %s", dump_dir);
  }

}

// parse_long_option
// file src/fg_argparser.c line 153
static _Bool parse_long_option(struct arg_parser * const ap, const char * const opt, const char * const arg, struct ap_Option *options, signed int * const argindp)
{
  unsigned int len;
  signed int index = -1;
  char exact = (char)0;
  char ambig = (char)0;
  len = (unsigned int)0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(opt[(signed long int)(2u + len)] == 0))
      tmp_if_expr_1 = (signed int)opt[(signed long int)(len + (unsigned int)2)] != 61 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    len = len + 1u;
  }
  while((_Bool)1);
  signed int i = 0;
  signed int return_value_strncmp_4;
  _Bool tmp_if_expr_2;
  for( ; !((options + (signed long int)i)->code == 0); i = i + 1)
    if(!((options + (signed long int)i)->name == ((char *)NULL)))
    {
      return_value_strncmp_4=strncmp((options + (signed long int)i)->name, &opt[(signed long int)2], (unsigned long int)len);
      if(return_value_strncmp_4 == 0)
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen((options + (signed long int)i)->name);
        if(return_value_strlen_3 == (unsigned long int)len)
        {
          index = i;
          exact = (char)1;
          break;
        }

        else
          if(!(index >= 0))
            index = i;

          else
          {
            if(!((options + (signed long int)index)->code == (options + (signed long int)i)->code))
              tmp_if_expr_2 = (_Bool)1;

            else
              tmp_if_expr_2 = (options + (signed long int)index)->has_arg != (options + (signed long int)i)->has_arg ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_2)
              ambig = (char)1;

          }
      }

    }

  _Bool tmp_if_expr_6;
  if(exact == 0 && !(ambig == 0))
  {
    add_error(ap, "option '");
    add_error(ap, opt);
    add_error(ap, "' is ambiguous");
    return (_Bool)1;
  }

  else
    if(!(index >= 0))
    {
      add_error(ap, "unrecognized option '");
      add_error(ap, opt);
      add_error(ap, "'");
      return (_Bool)1;
    }

    else
    {
      *argindp = *argindp + 1;
      if(!(opt[(signed long int)(2u + len)] == 0))
      {
        if((signed int)(options + (signed long int)index)->has_arg == ap_no)
        {
          add_error(ap, "option '--");
          add_error(ap, (options + (signed long int)index)->name);
          add_error(ap, "' doesn't allow an argument");
          return (_Bool)1;
        }

        if((signed int)(options + (signed long int)index)->has_arg == ap_yes)
        {
          if(opt[(signed long int)(3u + len)] == 0)
          {
            add_error(ap, "option '--");
            add_error(ap, (options + (signed long int)index)->name);
            add_error(ap, "' requires an argument");
            return (_Bool)1;
          }

        }

        _Bool return_value_push_back_record_5;
        return_value_push_back_record_5=push_back_record(ap, index, (_Bool)1, &opt[(signed long int)(len + (unsigned int)3)]);
        return return_value_push_back_record_5;
      }

      if((signed int)(options + (signed long int)index)->has_arg == ap_yes)
      {
        if(arg == ((const char *)NULL))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = !(arg[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          add_error(ap, "option '--");
          add_error(ap, (options + (signed long int)index)->name);
          add_error(ap, "' requires an argument");
          return (_Bool)1;
        }

        *argindp = *argindp + 1;
        _Bool return_value_push_back_record_7;
        return_value_push_back_record_7=push_back_record(ap, index, (_Bool)1, arg);
        return return_value_push_back_record_7;
      }

      _Bool return_value_push_back_record_8;
      return_value_push_back_record_8=push_back_record(ap, index, (_Bool)1, "");
      return return_value_push_back_record_8;
    }
}

// parse_rpc_address
// file src/fg_argparser.c line 590
void parse_rpc_address(char **rpc_address, signed int *port, _Bool *is_ipv6)
{
  char *sepptr = ((char *)NULL);
  char *return_value___builtin_strchr_3;
  return_value___builtin_strchr_3=__builtin_strchr(*rpc_address, 93);
  sepptr = return_value___builtin_strchr_3;
  char *return_value___builtin_strchr_2;
  if(!(sepptr == ((char *)NULL)))
  {
    *is_ipv6 = (_Bool)1;
    *sepptr = (char)0;
    if((signed int)*(*rpc_address) == 91)
      *rpc_address = *rpc_address + 1l;

    sepptr = sepptr + 1l;
    if(!(sepptr == ((char *)NULL)))
    {
      if((signed int)*sepptr == 58)
        sepptr = sepptr + 1l;

    }

    *port=atoi_link1(sepptr);
  }

  else
  {
    return_value___builtin_strchr_2=__builtin_strchr(*rpc_address, 58);
    sepptr = return_value___builtin_strchr_2;
    if(!(sepptr == ((char *)NULL)))
    {
      char *return_value___builtin_strchr_1;
      return_value___builtin_strchr_1=__builtin_strchr(sepptr + (signed long int)1, 58);
      if(!(return_value___builtin_strchr_1 == ((char *)NULL)))
        *is_ipv6 = (_Bool)1;

      else
      {
        *sepptr = (char)0;
        sepptr = sepptr + 1l;
        if(!((signed int)*sepptr == 0))
        {
          if((signed int)*sepptr == 58)
            sepptr = sepptr + 1l;

        }

        *port=atoi_link1(sepptr);
      }
    }

  }
}

// parse_short_option
// file src/fg_argparser.c line 242
static _Bool parse_short_option(struct arg_parser * const ap, const char * const opt, const char * const arg, struct ap_Option *options, signed int * const argindp)
{
  signed int cind = 1;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_2;
  _Bool return_value_push_back_record_4;
  while(cind >= 1)
  {
    signed int index = -1;
    const unsigned char code = (const unsigned char)opt[(signed long int)cind];
    char code_str[2l];
    code_str[(signed long int)0] = (char)code;
    code_str[(signed long int)1] = (char)0;
    if(!((signed int)code == 0))
    {
      signed int i = 0;
      for( ; !((options + (signed long int)i)->code == 0); i = i + 1)
        if((signed int)code == (options + (signed long int)i)->code)
        {
          index = i;
          break;
        }

    }

    if(!(index >= 0))
    {
      add_error(ap, "invalid option -- ");
      add_error(ap, code_str);
      return (_Bool)1;
    }

    cind = cind + 1;
    if((signed int)opt[(signed long int)cind] == 0)
    {
      *argindp = *argindp + 1;
      cind = 0;
    }

    if(cind >= 1 && !((signed int)(options + (signed long int)index)->has_arg == ap_no))
      tmp_if_expr_5 = opt[(signed long int)cind] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      _Bool return_value_push_back_record_1;
      return_value_push_back_record_1=push_back_record(ap, index, (_Bool)0, &opt[(signed long int)cind]);
      if(return_value_push_back_record_1 == (_Bool)0)
        return (_Bool)0;

      *argindp = *argindp + 1;
      cind = 0;
    }

    else
      if((signed int)(options + (signed long int)index)->has_arg == ap_yes)
      {
        if(arg == ((const char *)NULL))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = !(arg[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          add_error(ap, "option requires an argument -- ");
          add_error(ap, code_str);
          return (_Bool)1;
        }

        *argindp = *argindp + 1;
        cind = 0;
        _Bool return_value_push_back_record_3;
        return_value_push_back_record_3=push_back_record(ap, index, (_Bool)0, arg);
        if(return_value_push_back_record_3 == (_Bool)0)
          return (_Bool)0;

      }

      else
      {
        return_value_push_back_record_4=push_back_record(ap, index, (_Bool)0, "");
        if(return_value_push_back_record_4 == (_Bool)0)
          return (_Bool)0;

      }
  }
  return (_Bool)1;
}

// prepare_fds
// file src/daemon.c line 271
static signed int prepare_fds()
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_26) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int prepare_fds__1__3____d0;
    signed int prepare_fds__1__3____d1;
    asm("cld; rep; stosq" : "=c"(prepare_fds__1__3____d0), "=D"(prepare_fds__1__3____d1) : "a"(0), "0"(sizeof(struct anonymous_26) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int prepare_fds__1__4____d0;
    signed int prepare_fds__1__4____d1;
    asm("cld; rep; stosq" : "=c"(prepare_fds__1__4____d0), "=D"(prepare_fds__1__4____d1) : "a"(0), "0"(sizeof(struct anonymous_26) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&efds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->fds_bits[(signed long int)(daemon_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(daemon_pipe[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << daemon_pipe[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  maxfd = daemon_pipe[(signed long int)0];
  struct timespec now;
  gettime(&now);
  struct list_node *node;
  node=fg_list_front(&flows);
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_11;
  signed int return_value_flow_in_delay_8;
  _Bool tmp_if_expr_10;
  signed int return_value_flow_sending_9;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_6;
  signed int return_value_flow_in_delay_3;
  _Bool tmp_if_expr_5;
  signed int return_value_flow_sending_4;
  signed int tmp_if_expr_12;
  signed int tmp_if_expr_13;
  while(!(node == ((struct list_node *)NULL)))
  {
    struct flow *flow = (struct flow *)node->data;
    node = node->next;
    if(!(started == 0))
    {
      if(!(flow->finished[1l] == 0))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = !IEEE_FLOAT_NOTEQUAL(flow->settings.duration[(signed long int)1], 0.000000) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_flow_in_delay_8=flow_in_delay(&now, flow, 1);
        if(return_value_flow_in_delay_8 == 0)
        {
          return_value_flow_sending_9=flow_sending(&now, flow, 1);
          tmp_if_expr_10 = !(return_value_flow_sending_9 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
      {
        if(!(flow->finished[0l] == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = !IEEE_FLOAT_NOTEQUAL(flow->settings.duration[(signed long int)0], 0.000000) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_flow_in_delay_3=flow_in_delay(&now, flow, 0);
          if(return_value_flow_in_delay_3 == 0)
          {
            return_value_flow_sending_4=flow_sending(&now, flow, 0);
            tmp_if_expr_5 = !(return_value_flow_sending_4 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
        {
          signed int return_value_get_tcp_info_1;
          return_value_get_tcp_info_1=get_tcp_info(flow, &flow->statistics[(signed long int)1].tcp_info);
          flow->statistics[(signed long int)1].has_tcp_info = return_value_get_tcp_info_1 != 0 ? 0 : 1;
          flow->pmtu=get_pmtu(flow->fd);
          if(IEEE_FLOAT_NOTEQUAL(flow->settings.reporting_interval, 0.000000))
            report_flow(flow, 0);

          report_flow(flow, 1);
          uninit_flow(flow);
          remove_flow(flow);
          continue;
        }

      }

    }

    if((signed int)flow->state == GRIND_WAIT_ACCEPT)
    {
      if(!(flow->listenfd_data == -1))
      {
        (&rfds)->fds_bits[(signed long int)(flow->listenfd_data / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(flow->listenfd_data / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << flow->listenfd_data % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(flow->listenfd_data >= maxfd))
          tmp_if_expr_12 = maxfd;

        else
          tmp_if_expr_12 = flow->listenfd_data;
        maxfd = tmp_if_expr_12;
      }

    }

    if(!(started == 0))
    {
      if(!(flow->fd == -1))
      {
        (&efds)->fds_bits[(signed long int)(flow->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&efds)->fds_bits[(signed long int)(flow->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << flow->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        if(!(flow->fd >= maxfd))
          tmp_if_expr_13 = maxfd;

        else
          tmp_if_expr_13 = flow->fd;
        maxfd = tmp_if_expr_13;
        prepare_wfds(&now, flow, &wfds);
        prepare_rfds(&now, flow, &rfds);
      }

    }

  }
  unsigned long int return_value_fg_list_size_14;
  return_value_fg_list_size_14=fg_list_size(&flows);
  return (signed int)return_value_fg_list_size_14;
}

// prepare_rfds
// file src/daemon.c line 233
static signed int prepare_rfds(struct timespec *now, struct flow *flow, struct anonymous_26 *rfds)
{
  signed int rc = 0;
  signed int return_value_flow_in_delay_3;
  return_value_flow_in_delay_3=flow_in_delay(now, flow, 1);
  signed int return_value_flow_sending_2;
  signed int *return_value___errno_location_1;
  if(return_value_flow_in_delay_3 == 0)
  {
    return_value_flow_sending_2=flow_sending(now, flow, 1);
    if(return_value_flow_sending_2 == 0)
    {
      if(flow->finished[1l] == 0)
      {
        if(!(flow->settings.shutdown == 0))
        {
          error((enum error_levels)ERR_WARNING, 0, "server flow %u missed to shutdown", flow->id);
          rc=shutdown(flow->fd, 0);
          if(rc == -1)
          {
            return_value___errno_location_1=__errno_location();
            error((enum error_levels)ERR_WARNING, *return_value___errno_location_1, "shutdown SHUT_RD failed");
          }

          flow->finished[(signed long int)1] = (char)1;
        }

      }

    }

  }

  signed int *return_value___errno_location_6;
  if(!(flow->source_settings.late_connect == 0))
  {
    if(flow->connect_called == 0)
    {

    __CPROVER_DUMP_L3:
      ;
      rc=connect(flow->fd, flow->addr, flow->addr_len);
      if(rc == -1)
      {
        return_value___errno_location_6=__errno_location();
        if(!(*return_value___errno_location_6 == 115))
        {
          signed int *return_value___errno_location_4;
          return_value___errno_location_4=__errno_location();
          char *return_value_strerror_5;
          return_value_strerror_5=strerror(*return_value___errno_location_4);
          flow_error(flow, "Connect failed: %s", return_value_strerror_5);
          return -1;
        }

      }

      flow->connect_called = (char)1;
      flow->pmtu=get_pmtu(flow->fd);
    }

  }

  if(!(flow->connect_called == 0))
  {
    if(flow->finished[1l] == 0)
    {

    __CPROVER_DUMP_L6:
      ;
      rfds->fds_bits[(signed long int)(flow->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = rfds->fds_bits[(signed long int)(flow->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << flow->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

  }

  return 0;
}

// prepare_wfds
// file src/daemon.c line 199
static void prepare_wfds(struct timespec *now, struct flow *flow, struct anonymous_26 *wfds)
{
  signed int rc = 0;
  signed int return_value_flow_in_delay_1;
  return_value_flow_in_delay_1=flow_in_delay(now, flow, 0);
  signed int *return_value___errno_location_3;
  if(!(return_value_flow_in_delay_1 == 0))

    __CPROVER_DUMP_L1:
      ;

  else
  {
    signed int return_value_flow_sending_4;
    return_value_flow_sending_4=flow_sending(now, flow, 0);
    if(!(return_value_flow_sending_4 == 0))
    {
      signed int return_value_flow_block_scheduled_2;
      return_value_flow_block_scheduled_2=flow_block_scheduled(now, flow);
      if(!(return_value_flow_block_scheduled_2 == 0))
      {

      __CPROVER_DUMP_L3:
        ;
        wfds->fds_bits[(signed long int)(flow->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = wfds->fds_bits[(signed long int)(flow->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << flow->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      }

      else

        __CPROVER_DUMP_L4:
          ;
    }

    else
      if(flow->finished[0l] == 0)
      {
        flow->finished[(signed long int)0] = (char)1;
        if(!(flow->settings.shutdown == 0))
        {

        __CPROVER_DUMP_L7:
          ;
          rc=shutdown(flow->fd, 1);
          if(rc == -1)
          {
            return_value___errno_location_3=__errno_location();
            error((enum error_levels)ERR_WARNING, *return_value___errno_location_3, "shutdown() SHUT_WR failed");
          }

        }

      }

    goto __CPROVER_DUMP_L10;
  }

__CPROVER_DUMP_L10:
  ;
}

// process_delay
// file src/daemon.c line 1236
static void process_delay(struct flow *flow)
{
  double current_delay = .0;
  struct timespec now;
  struct timespec *data = (struct timespec *)(flow->read_block + (signed long int)((unsigned long int)2 * sizeof(signed int) /*4ul*/ ));
  gettime(&now);
  current_delay=time_diff(data, &now);
  if(current_delay < 0.000000)
  {
    logging_log(2, "calculated malformed delay of flow %d (rtt = %.3lfms) (clocks out-of-sync?), ignoring", flow->id, current_delay * 1e3);
    float return_value___builtin_nanf_1;
    return_value___builtin_nanf_1=__builtin_nanf("");
    current_delay = (double)return_value___builtin_nanf_1;
  }

  signed int return_value___isnan_2;
  return_value___isnan_2=__isnan(current_delay);
  if(return_value___isnan_2 == 0)
  {
    signed int i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      double process_delay__1__2__1__1__1___s = flow->statistics[(signed long int)i].delay_min;
      double process_delay__1__2__1__1__1___c = current_delay;
      if(process_delay__1__2__1__1__1___s > process_delay__1__2__1__1__1___c)
        flow->statistics[(signed long int)i].delay_min = current_delay;

      double _s = flow->statistics[(signed long int)i].delay_max;
      double _c = current_delay;
      if(_s < _c)
        flow->statistics[(signed long int)i].delay_max = current_delay;

      flow->statistics[(signed long int)i].delay_sum = flow->statistics[(signed long int)i].delay_sum + current_delay;
    }
  }


__CPROVER_DUMP_L6:
  ;
}

// process_dump_dir
// file src/flowgrindd.c line 981
signed int process_dump_dir()
{
  if(dump_dir == ((char *)NULL))
    dump_dir=getcwd((char *)(void *)0, (unsigned long int)0);

  struct stat dirstats;
  signed int return_value_stat_1;
  return_value_stat_1=stat(dump_dir, &dirstats);
  if(return_value_stat_1 == -1)
  {

  __CPROVER_DUMP_L2:
    ;
    return 0;
  }

  else
    if(!((61440u & dirstats.st_mode) == 16384u))
    {

    __CPROVER_DUMP_L4:
      ;
      return 0;
    }

    else
    {
      signed int return_value_access_2;
      return_value_access_2=access(dump_dir, 2 | 1);
      if(return_value_access_2 == -1)
      {

      __CPROVER_DUMP_L6:
        ;
        return 0;
      }

      else
      {
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(dump_dir);
        if(!((signed int)dump_dir[-1l + (signed long int)return_value_strlen_3] == 47))
          asprintf_append(&dump_dir, "/");

        return 1;
      }
    }
}

// process_iat
// file src/daemon.c line 1203
static void process_iat(struct flow *flow)
{
  double current_iat = .0;
  struct timespec now;
  gettime(&now);
  _Bool tmp_if_expr_2;
  if(!(flow->last_block_read.tv_sec == 0l))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = flow->last_block_read.tv_nsec != 0l ? (_Bool)1 : (_Bool)0;
  float return_value___builtin_nanf_1;
  if(tmp_if_expr_2)
    current_iat=time_diff(&flow->last_block_read, &now);

  else
  {
    return_value___builtin_nanf_1=__builtin_nanf("");
    current_iat = (double)return_value___builtin_nanf_1;
  }
  if(current_iat < 0.000000)
  {
    logging_log(2, "calculated malformed iat of flow %d (iat = %.3lfms) (clock skew?), ignoring", flow->id, current_iat * 1e3);
    float return_value___builtin_nanf_3;
    return_value___builtin_nanf_3=__builtin_nanf("");
    current_iat = (double)return_value___builtin_nanf_3;
  }

  flow->last_block_read = now;
  signed int return_value___isnan_4;
  return_value___isnan_4=__isnan(current_iat);
  if(return_value___isnan_4 == 0)
  {
    signed int i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      double _s = flow->statistics[(signed long int)i].iat_min;
      double _c = current_iat;
      if(_s > _c)
        flow->statistics[(signed long int)i].iat_min = current_iat;

      double process_iat__1__2__1__1__2___s = flow->statistics[(signed long int)i].iat_max;
      double process_iat__1__2__1__1__2___c = current_iat;
      if(process_iat__1__2__1__1__2___s < process_iat__1__2__1__1__2___c)
        flow->statistics[(signed long int)i].iat_max = current_iat;

      flow->statistics[(signed long int)i].iat_sum = flow->statistics[(signed long int)i].iat_sum + current_iat;
    }
  }


__CPROVER_DUMP_L10:
  ;
}

// process_requests
// file src/daemon.c line 443
static void process_requests()
{
  signed int rc;

__CPROVER_DUMP_L1:
  ;
  pthread_mutex_lock(&mutex);

__CPROVER_DUMP_L2:
  ;
  char tmp[100l];
  do
  {
    signed int process_requests__1__3__1__rc;
    signed long int return_value_read_1;
    return_value_read_1=read(daemon_pipe[(signed long int)0], (void *)tmp, (unsigned long int)100);
    process_requests__1__3__1__rc = (signed int)return_value_read_1;
    if(!(process_requests__1__3__1__rc == 100))
      break;

  }
  while((_Bool)1);
  while(!(requests == ((struct request *)NULL)))
  {
    struct request *request = requests;
    requests = requests->next;
    rc = 0;
    switch((signed int)request->type)
    {
      case 0:
      {
        add_flow_destination((struct request_add_flow_destination *)request);
        break;
      }
      case 1:
      {
        rc=add_flow_source((struct request_add_flow_source *)request);
        break;
      }
      case 2:
      {
        start_flows((struct request_start_flows *)request);
        break;
      }
      case 3:
      {
        stop_flow((struct request_stop_flow *)request);
        break;
      }
      case 4:
      {
        struct request_get_status *r = (struct request_get_status *)request;
        r->started = (signed int)started;
        unsigned long int return_value_fg_list_size_2;
        return_value_fg_list_size_2=fg_list_size(&flows);
        r->num_flows = (signed int)return_value_fg_list_size_2;
        break;
      }
      default:
        request_error(request, "Unknown request type");
    }
    if(!(rc == 1))
      pthread_cond_signal(request->condition);

  }
  pthread_mutex_unlock(&mutex);

__CPROVER_DUMP_L15:
  ;
}

// process_rtt
// file src/daemon.c line 1172
static void process_rtt(struct flow *flow)
{
  double current_rtt = .0;
  struct timespec now;
  struct timespec *data = (struct timespec *)(flow->read_block + (signed long int)((unsigned long int)2 * sizeof(signed int) /*4ul*/ ));
  gettime(&now);
  current_rtt=time_diff(data, &now);
  if(current_rtt < 0.000000)
  {
    logging_log(2, "received malformed rtt block of flow %d (rtt = %.3lfms), ignoring", flow->id, current_rtt * 1e3);
    float return_value___builtin_nanf_1;
    return_value___builtin_nanf_1=__builtin_nanf("");
    current_rtt = (double)return_value___builtin_nanf_1;
  }

  flow->last_block_read = now;
  signed int return_value___isnan_2;
  return_value___isnan_2=__isnan(current_rtt);
  if(return_value___isnan_2 == 0)
  {
    signed int i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      double _s = flow->statistics[(signed long int)i].rtt_min;
      double _c = current_rtt;
      if(_s > _c)
        flow->statistics[(signed long int)i].rtt_min = current_rtt;

      double process_rtt__1__2__1__1__2___s = flow->statistics[(signed long int)i].rtt_max;
      double process_rtt__1__2__1__1__2___c = current_rtt;
      if(process_rtt__1__2__1__1__2___s < process_rtt__1__2__1__1__2___c)
        flow->statistics[(signed long int)i].rtt_max = current_rtt;

      flow->statistics[(signed long int)i].rtt_sum = flow->statistics[(signed long int)i].rtt_sum + current_rtt;
    }
  }


__CPROVER_DUMP_L6:
  ;
}

// process_select
// file src/daemon.c line 708
static void process_select(struct anonymous_26 *rfds, struct anonymous_26 *wfds, struct anonymous_26 *efds)
{
  struct list_node *node;
  node=fg_list_front(&flows);
  signed int return_value_write_data_3;
  signed int return_value_read_data_4;
  while(!(node == ((struct list_node *)NULL)))
  {
    struct flow *flow = (struct flow *)node->data;
    node = node->next;

  __CPROVER_DUMP_L2:
    ;
    if(!(flow->listenfd_data == -1))
    {
      if(!((rfds->fds_bits[(signed long int)(flow->listenfd_data / 8)] & (signed long int)(1UL << flow->listenfd_data % 8)) == 0l))
      {

      __CPROVER_DUMP_L3:
        ;
        if((signed int)flow->state == GRIND_WAIT_ACCEPT)
        {
          signed int return_value_accept_data_1;
          return_value_accept_data_1=accept_data(flow);
          if(return_value_accept_data_1 == -1)
          {

          __CPROVER_DUMP_L4:
            ;
            goto remove;
          }

        }

      }

    }

    if(!(flow->fd == -1))
    {
      if(!((efds->fds_bits[(signed long int)(flow->fd / 8)] & (signed long int)(1UL << flow->fd % 8)) == 0l))
      {
        signed int error_number;
        signed int rc;
        unsigned int error_number_size = (unsigned int)sizeof(signed int) /*4ul*/ ;

      __CPROVER_DUMP_L7:
        ;
        rc=getsockopt(flow->fd, 1, 4, (void *)&error_number, &error_number_size);
        if(rc == -1)
        {
          signed int *return_value___errno_location_2;
          return_value___errno_location_2=__errno_location();
          error((enum error_levels)ERR_WARNING, *return_value___errno_location_2, "failed to get errno fornon-blocking connect");
          goto remove;
        }

        if(!(error_number == 0))
        {
          error((enum error_levels)ERR_WARNING, error_number, "connect");
          goto remove;
        }

      }

      if(!((wfds->fds_bits[(signed long int)(flow->fd / 8)] & (signed long int)(1UL << flow->fd % 8)) == 0l))
      {
        return_value_write_data_3=write_data(flow);
        if(return_value_write_data_3 == -1)
        {

        __CPROVER_DUMP_L11:
          ;
          goto remove;
        }

      }

      if(!((rfds->fds_bits[(signed long int)(flow->fd / 8)] & (signed long int)(1UL << flow->fd % 8)) == 0l))
      {
        return_value_read_data_4=read_data(flow);
        if(return_value_read_data_4 == -1)
        {

        __CPROVER_DUMP_L13:
          ;
          goto remove;
        }

      }

    }

    continue;

  remove:
    ;
    if(!(flow->fd == -1))
    {
      signed int return_value_get_tcp_info_5;
      return_value_get_tcp_info_5=get_tcp_info(flow, &flow->statistics[(signed long int)1].tcp_info);
      flow->statistics[(signed long int)1].has_tcp_info = return_value_get_tcp_info_5 != 0 ? 0 : 1;
    }

    flow->pmtu=get_pmtu(flow->fd);
    report_flow(flow, 1);
    uninit_flow(flow);
    remove_flow(flow);

  __CPROVER_DUMP_L18:
    ;
  }
}

// pthread_getaffinity
// file src/fg_affinity.c line 85
signed int pthread_getaffinity(unsigned long int thread, unsigned int *core)
{
  struct anonymous_27 cpuset;
  signed int rc;
  rc=pthread_getaffinity_np(thread, sizeof(struct anonymous_27) /*128ul*/ , &cpuset);
  signed int tmp_statement_expression_1;
  signed int tmp_if_expr_2;
  if(!(rc == 0))
    return -1;

  else
  {
    core = (unsigned int *)(void *)0;
    _Bool core_found = (_Bool)0;
    unsigned int i = (unsigned int)0;
    for( ; !(i >= 1024u); i = i + 1u)
    {
      unsigned long int __cpu = (unsigned long int)i;
      if(!(__cpu / 8ul >= sizeof(struct anonymous_27) /*128ul*/ ))
        tmp_if_expr_2 = (signed int)((((const unsigned long int *)(&cpuset)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] & (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ )) != (unsigned long int)0);

      else
        tmp_if_expr_2 = 0;
      tmp_statement_expression_1 = tmp_if_expr_2;
      if(!(tmp_statement_expression_1 == 0))
      {
        if(core_found == (_Bool)0)
        {
          core_found = (_Bool)1;
          *core = i;
        }

        else
        {
          core_found = (_Bool)0;
          core = (unsigned int *)(void *)0;
          break;
        }
      }

    }
    return core_found != (_Bool)0 ? 0 : -1;
  }
}

// pthread_setaffinity
// file src/fg_affinity.h line 59
signed int pthread_setaffinity(unsigned long int thread, unsigned int core)
{
  struct anonymous_27 cpuset;
  do
    __builtin_memset((void *)&cpuset, 0, sizeof(struct anonymous_27) /*128ul*/ );
  while((_Bool)0);
  unsigned long int __cpu = (unsigned long int)core;
  if(!(__cpu / 8ul >= sizeof(struct anonymous_27) /*128ul*/ ))
    ((unsigned long int *)(&cpuset)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] = ((unsigned long int *)(&cpuset)->__bits)[(signed long int)(__cpu / ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ ))] | (unsigned long int)1 << __cpu % ((unsigned long int)8 * sizeof(unsigned long int) /*8ul*/ );

  else
    (unsigned long int)0;
  signed int rc;
  rc=pthread_setaffinity_np(thread, sizeof(struct anonymous_27) /*128ul*/ , &cpuset);
  return rc == 0 ? 0 : -1;
}

// push_back_record
// file src/fg_argparser.c line 66
static _Bool push_back_record(struct arg_parser * const ap, const signed int option_index, _Bool long_opt, const char * const argument)
{
  signed int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(argument);
  len = (const signed int)return_value_strlen_1;
  struct ap_Record *p;
  void *tmp;
  tmp=ap_resize_buffer((void *)ap->data, (const signed int)((unsigned long int)(ap->data_size + 1) * sizeof(struct ap_Record) /*24ul*/ ));
  if(tmp == NULL)
    return (_Bool)0;

  else
  {
    ap->data = (struct ap_Record *)tmp;
    p = &ap->data[(signed long int)ap->data_size];
    p->option_index = option_index;
    p->argument = ((char *)NULL);
    tmp=ap_resize_buffer((void *)p->argument, len + 1);
    if(tmp == NULL)
      return (_Bool)0;

    else
    {
      p->argument = (char *)tmp;
      __builtin_strncpy(p->argument, argument, (unsigned long int)(len + 1));
      if(!(long_opt == (_Bool)0))
      {
        signed int return_value_asprintf_2;
        return_value_asprintf_2=asprintf(&p->opt_string, "--%s", (ap->options + (signed long int)option_index)->name);
        if(return_value_asprintf_2 == 0)
          return (_Bool)0;

      }

      else
      {
        signed int return_value_asprintf_3;
        return_value_asprintf_3=asprintf(&p->opt_string, "-%c", (ap->options + (signed long int)option_index)->code);
        if(return_value_asprintf_3 == 0)
          return (_Bool)0;

      }
      ap->data_size = ap->data_size + 1;
      return (_Bool)1;
    }
  }
}

// read_data
// file src/daemon.c line 1078
static signed int read_data(struct flow *flow)
{
  signed int rc = 0;
  signed int optint = 0;
  signed int requested_response_block_size = 0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  signed int return_value_try_read_n_bytes_6;
  while((_Bool)1)
  {
    if(!(flow->current_block_bytes_read >= (unsigned int)sizeof(struct block) /*40u*/ ))
    {
      rc=try_read_n_bytes(flow, (signed int)((unsigned int)(signed int)sizeof(struct block) /*40ul*/  - flow->current_block_bytes_read));
      if(!(flow->current_block_bytes_read >= (unsigned int)sizeof(struct block) /*40u*/ ))
        goto __CPROVER_DUMP_L20;

    }

    unsigned int return_value___bswap_32_1;
    return_value___bswap_32_1=__bswap_32((unsigned int)((struct block *)flow->read_block)->this_block_size);
    optint = (signed int)return_value___bswap_32_1;
    if(optint >= (signed int)sizeof(struct block) /*40*/ )
      tmp_if_expr_2 = optint <= flow->settings.maximum_block_size ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      flow->current_read_block_size = (unsigned int)optint;

    else
      logging_log(4, "flow %d parsed illegal cbs %d, ignoring (max: %d)", flow->id, optint, flow->settings.maximum_block_size);
    unsigned int return_value___bswap_32_3;
    return_value___bswap_32_3=__bswap_32((unsigned int)((struct block *)flow->read_block)->request_block_size);
    optint = (signed int)return_value___bswap_32_3;
    if(optint == 0 || optint == -1)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      if(optint >= (signed int)sizeof(struct block) /*40*/ )
        tmp_if_expr_4 = optint <= flow->settings.maximum_block_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      requested_response_block_size = optint;

    else
      logging_log(4, "flow %d parsed illegal qbs %d, ignoring (max: %d)", flow->id, optint, flow->settings.maximum_block_size);
    if(!(flow->current_block_bytes_read >= flow->current_read_block_size))
    {
      return_value_try_read_n_bytes_6=try_read_n_bytes(flow, (signed int)(flow->current_read_block_size - flow->current_block_bytes_read));
      rc = rc + return_value_try_read_n_bytes_6;
    }

    if(flow->current_block_bytes_read >= flow->current_read_block_size)
    {
      flow->current_block_bytes_read = (unsigned int)0;
      if(requested_response_block_size == -1)
      {
        signed int read_data__1__1__1__2__1__1__i = 0;
        for( ; !(read_data__1__1__1__2__1__1__i >= 2); read_data__1__1__1__2__1__1__i = read_data__1__1__1__2__1__1__i + 1)
          flow->statistics[(signed long int)read_data__1__1__1__2__1__1__i].response_blocks_read = flow->statistics[(signed long int)read_data__1__1__1__2__1__1__i].response_blocks_read + 1u;
        process_rtt(flow);
      }

      else
      {
        signed int i = 0;
        for( ; !(i >= 2); i = i + 1)
          flow->statistics[(signed long int)i].request_blocks_read = flow->statistics[(signed long int)i].request_blocks_read + 1u;
        process_iat(flow);
        process_delay(flow);
        if(requested_response_block_size >= (signed int)sizeof(struct block) /*40*/ )
        {
          if(flow->finished[1l] == 0)
            send_response(flow, requested_response_block_size);

        }

      }
    }

    if(flow->settings.pushy == 0)
      break;

  }

__CPROVER_DUMP_L20:
  ;
  return rc;
}

// remove_flow
// file src/daemon.c line 191
void remove_flow(struct flow * const flow)
{
  fg_list_remove(&flows, (const void *)flow);
  free((void *)flow);
  unsigned long int return_value_fg_list_size_1;
  return_value_fg_list_size_1=fg_list_size(&flows);
  if(return_value_fg_list_size_1 == 0ul)
    started = (char)0;

}

// report_flow
// file src/daemon.c line 502
static void report_flow(struct flow *flow, signed int type)
{

__CPROVER_DUMP_L1:
  ;
  struct report *report;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct report) /*224ul*/ );
  report = (struct report *)return_value_malloc_1;
  report->id = flow->id;
  report->type = type;
  if(type == 0)
    report->begin = flow->last_report_time;

  else
    report->begin = flow->first_report_time;
  gettime(&report->end);
  flow->last_report_time = report->end;
  double return_value_time_diff_2;
  return_value_time_diff_2=time_diff(&report->begin, &report->end);
  signed int return_value_flow_sending_3;
  _Bool tmp_if_expr_6;
  signed int return_value_flow_sending_7;
  _Bool tmp_if_expr_10;
  if(return_value_time_diff_2 < 0.2 * flow->settings.reporting_interval)
  {
    if(!(type == 0))
      goto __CPROVER_DUMP_L4;

    free((void *)report);
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    report->bytes_read = flow->statistics[(signed long int)type].bytes_read;
    report->bytes_written = flow->statistics[(signed long int)type].bytes_written;
    report->request_blocks_read = flow->statistics[(signed long int)type].request_blocks_read;
    report->response_blocks_read = flow->statistics[(signed long int)type].response_blocks_read;
    report->request_blocks_written = flow->statistics[(signed long int)type].request_blocks_written;
    report->response_blocks_written = flow->statistics[(signed long int)type].response_blocks_written;
    report->rtt_min = flow->statistics[(signed long int)type].rtt_min;
    report->rtt_max = flow->statistics[(signed long int)type].rtt_max;
    report->rtt_sum = flow->statistics[(signed long int)type].rtt_sum;
    report->iat_min = flow->statistics[(signed long int)type].iat_min;
    report->iat_max = flow->statistics[(signed long int)type].iat_max;
    report->iat_sum = flow->statistics[(signed long int)type].iat_sum;
    report->delay_min = flow->statistics[(signed long int)type].delay_min;
    report->delay_max = flow->statistics[(signed long int)type].delay_max;
    report->delay_sum = flow->statistics[(signed long int)type].delay_sum;
    report->tcp_info = flow->statistics[(signed long int)type].tcp_info;
    if(!(flow->fd == -1))
    {
      flow->pmtu=get_pmtu(flow->fd);
      report->pmtu = flow->pmtu;
      if(type == 1)
        report->imtu=get_imtu(flow->fd);

      else
        report->imtu = 0;
    }

    else
    {
      report->imtu = 0;
      report->pmtu = 0;
    }
    report->status = 0;
    if(flow->statistics[(signed long int)type].bytes_read == 0ul)
    {
      signed int return_value_flow_in_delay_4;
      return_value_flow_in_delay_4=flow_in_delay(&report->end, flow, 1);
      if(!(return_value_flow_in_delay_4 == 0))
        report->status = report->status | 100;

      else
      {
        return_value_flow_sending_3=flow_sending(&report->end, flow, 1);
        if(!(return_value_flow_sending_3 == 0))
          report->status = report->status | 108;

        else
          if(IEEE_FLOAT_EQUAL(flow->settings.duration[1l], 0.000000))
            report->status = report->status | 111;

          else
            report->status = report->status | 102;
      }
    }

    else
    {
      signed int return_value_flow_sending_5;
      return_value_flow_sending_5=flow_sending(&report->end, flow, 1);
      if(return_value_flow_sending_5 == 0)
        tmp_if_expr_6 = !((_Bool)flow->finished) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        report->status = report->status | 99;

      else
        report->status = report->status | 110;
    }
    report->status = report->status << 8;
    if(flow->statistics[(signed long int)type].bytes_written == 0ul)
    {
      signed int return_value_flow_in_delay_8;
      return_value_flow_in_delay_8=flow_in_delay(&report->end, flow, 0);
      if(!(return_value_flow_in_delay_8 == 0))
        report->status = report->status | 100;

      else
      {
        return_value_flow_sending_7=flow_sending(&report->end, flow, 0);
        if(!(return_value_flow_sending_7 == 0))
          report->status = report->status | 108;

        else
          if(IEEE_FLOAT_EQUAL(flow->settings.duration[0l], 0.000000))
            report->status = report->status | 111;

          else
            report->status = report->status | 102;
      }
    }

    else
    {
      signed int return_value_flow_sending_9;
      return_value_flow_sending_9=flow_sending(&report->end, flow, 0);
      if(return_value_flow_sending_9 == 0)
        tmp_if_expr_10 = !((_Bool)flow->finished) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
        report->status = report->status | 99;

      else
        report->status = report->status | 110;
    }
    if(type == 0)
    {
      flow->statistics[(signed long int)0].bytes_read = (unsigned long long int)0;
      flow->statistics[(signed long int)0].bytes_written = (unsigned long long int)0;
      flow->statistics[(signed long int)0].request_blocks_read = (unsigned int)0;
      flow->statistics[(signed long int)0].response_blocks_read = (unsigned int)0;
      flow->statistics[(signed long int)0].request_blocks_written = (unsigned int)0;
      flow->statistics[(signed long int)0].response_blocks_written = (unsigned int)0;
      flow->statistics[(signed long int)0].rtt_min = (double)3.40282346638528859812e+38F;
      flow->statistics[(signed long int)0].rtt_max = (double)1.17549435082228750797e-38F;
      flow->statistics[(signed long int)0].rtt_sum = (double)0.0F;
      flow->statistics[(signed long int)0].iat_min = (double)3.40282346638528859812e+38F;
      flow->statistics[(signed long int)0].iat_max = (double)1.17549435082228750797e-38F;
      flow->statistics[(signed long int)0].iat_sum = (double)0.0F;
      flow->statistics[(signed long int)0].delay_min = (double)3.40282346638528859812e+38F;
      flow->statistics[(signed long int)0].delay_max = (double)1.17549435082228750797e-38F;
      flow->statistics[(signed long int)0].delay_sum = (double)0.0F;
    }

    add_report(report);
  }

__CPROVER_DUMP_L30:
  ;
}

// request_error
// file src/daemon.c line 132
void request_error(struct request *request, const char *fmt, ...)
{
  char str[1000l];
  void **ap = (void **)&fmt;
  vsnprintf(str, (unsigned long int)1000, fmt, ap);
  ap = ((void **)NULL);
  str[(signed long int)(sizeof(char [1000l]) /*1000ul*/  - (unsigned long int)1)] = (char)0;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)1);
  request->error = (char *)return_value_malloc_2;
  strcpy(request->error, str);
}

// run_rpc_server
// file src/flowgrindd.c line 956
void run_rpc_server(struct fg_rpc_server *server)
{
  struct _xmlrpc_env *env = &server->env;
  xmlrpc_server_abyss(env, &server->parms, (const unsigned int)((unsigned long int)(char *)&((struct anonymous_17 *)0)->socket_handle + sizeof(signed int) /*4ul*/ ));
  if(!(env->fault_occurred == 0))
    logging_log(1, "XML-RPC Fault: %s (%d)\n", env->fault_string, env->fault_code);

}

// sanity_check
// file src/flowgrindd.c line 1105
static void sanity_check(void)
{
  if(!(core >= 0))
  {
    error((enum error_levels)ERR_ERROR, 0, "CPU binding failed. Given CPU ID is negative");
    exit(1);
  }

  signed int return_value_get_ncores_1;
  return_value_get_ncores_1=get_ncores((enum ncore_query)NCORE_CURRENT);
  if(!(return_value_get_ncores_1 >= core))
  {
    error((enum error_levels)ERR_ERROR, 0, "CPU binding failed. Given CPU ID is higher then available CPU cores");
    exit(1);
  }

}

// send_response
// file src/daemon.c line 1267
static void send_response(struct flow *flow, signed int requested_response_block_size)
{
  signed int rc;
  signed int try = 0;
  unsigned int return_value___bswap_32_1;
  return_value___bswap_32_1=__bswap_32((unsigned int)requested_response_block_size);
  ((struct block *)flow->write_block)->this_block_size = (signed int)return_value___bswap_32_1;
  unsigned int return_value___bswap_32_2;
  return_value___bswap_32_2=__bswap_32((unsigned int)-1);
  ((struct block *)flow->write_block)->request_block_size = (signed int)return_value___bswap_32_2;
  ((struct block *)flow->write_block)->data = ((struct block *)flow->read_block)->data;
  _Bool tmp_if_expr_3;
  if(!(((struct block *)flow->write_block)->data.tv_sec == 0l))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = ((struct block *)flow->write_block)->data.tv_nsec != 0l ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    ((struct block *)flow->write_block)->data2 = ((struct block *)flow->read_block)->data2;


__CPROVER_DUMP_L3:
  ;
  do
  {
    signed long int return_value_write_4;
    return_value_write_4=write(flow->fd, (const void *)(flow->write_block + (signed long int)flow->current_block_bytes_written), (unsigned long int)((unsigned int)requested_response_block_size - flow->current_block_bytes_written));
    rc = (signed int)return_value_write_4;

  __CPROVER_DUMP_L5:
    ;
    if(rc == -1)
    {
      signed int *return_value___errno_location_9;
      return_value___errno_location_9=__errno_location();
      if(*return_value___errno_location_9 == 11)
      {

      __CPROVER_DUMP_L6:
        ;
        try = try + 1;
        if(try >= 10000)
        {
          if(flow->current_block_bytes_written == 0u)
          {
            signed int *return_value___errno_location_5;
            return_value___errno_location_5=__errno_location();
            char *return_value_strerror_6;
            return_value_strerror_6=strerror(*return_value___errno_location_5);
            logging_log(4, "tried to send response block %d times without success, dropping (%s)", try, return_value_strerror_6);
            break;
          }

        }

      }

      else
      {
        signed int *return_value___errno_location_7;
        return_value___errno_location_7=__errno_location();
        char *return_value_strerror_8;
        return_value_strerror_8=strerror(*return_value___errno_location_7);
        logging_log(4, "Premature end of test: %s, abort flow", return_value_strerror_8);
        flow->finished[(signed long int)1] = (char)1;
        break;
      }
    }

    else
    {
      flow->current_block_bytes_written = flow->current_block_bytes_written + (unsigned int)rc;
      signed int i = 0;
      for( ; !(i >= 2); i = i + 1)
        flow->statistics[(signed long int)i].bytes_written = flow->statistics[(signed long int)i].bytes_written + (unsigned long long int)rc;
      if(flow->current_block_bytes_written >= (unsigned int)requested_response_block_size)
      {
        flow->current_block_bytes_written = (unsigned int)0;
        gettime(&flow->last_block_written);
        signed int send_response__1__2__1__3__2__1__i = 0;
        for( ; !(send_response__1__2__1__3__2__1__i >= 2); send_response__1__2__1__3__2__1__i = send_response__1__2__1__3__2__1__i + 1)
          flow->statistics[(signed long int)send_response__1__2__1__3__2__1__i].response_blocks_written = flow->statistics[(signed long int)send_response__1__2__1__3__2__1__i].response_blocks_written + 1u;
        break;
      }

    }
  }
  while((_Bool)1);
}

// set_congestion_control
// file src/fg_socket.h line 38
signed int set_congestion_control(signed int fd, const char *cc_alg)
{

__CPROVER_DUMP_L1:
  ;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(cc_alg);
  signed int return_value_setsockopt_2;
  return_value_setsockopt_2=setsockopt(fd, 6, 13, (const void *)cc_alg, (unsigned int)return_value_strlen_1);
  return return_value_setsockopt_2;
}

// set_dscp
// file src/fg_socket.h line 49
signed int set_dscp(signed int fd, signed int dscp)
{
  signed int optname = 1;
  signed int optlevel = 0;

__CPROVER_DUMP_L1:
  ;
  if(!((-64 & dscp) == 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 22;
    return -1;
  }

  dscp = dscp << 2;
  signed int return_value_setsockopt_2;
  return_value_setsockopt_2=setsockopt(fd, optlevel, optname, (const void *)&dscp, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_2;
}

// set_flow_tcp_options
// file src/daemon.c line 1396
signed int set_flow_tcp_options(struct flow *flow)
{
  set_non_blocking(flow->fd);
  signed int return_value_set_congestion_control_3;
  if(!(flow->settings.cc_alg[0l] == 0))
  {
    return_value_set_congestion_control_3=set_congestion_control(flow->fd, flow->settings.cc_alg);
    if(return_value_set_congestion_control_3 == -1)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      char *return_value_strerror_2;
      return_value_strerror_2=strerror(*return_value___errno_location_1);
      flow_error(flow, "Unable to set congestion control algorithm: %s", return_value_strerror_2);
      return -1;
    }

  }

  signed int return_value_set_so_elcn_6;
  if(!(flow->settings.elcn == 0))
  {
    return_value_set_so_elcn_6=set_so_elcn(flow->fd, flow->settings.elcn);
    if(return_value_set_so_elcn_6 == -1)
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      char *return_value_strerror_5;
      return_value_strerror_5=strerror(*return_value___errno_location_4);
      flow_error(flow, "Unable to set TCP_ELCN: %s", return_value_strerror_5);
      return -1;
    }

  }

  signed int return_value_set_so_lcd_9;
  if(!(flow->settings.lcd == 0))
  {
    return_value_set_so_lcd_9=set_so_lcd(flow->fd);
    if(return_value_set_so_lcd_9 == -1)
    {
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      char *return_value_strerror_8;
      return_value_strerror_8=strerror(*return_value___errno_location_7);
      flow_error(flow, "Unable to set TCP_LCD: %s", return_value_strerror_8);
      return -1;
    }

  }

  signed int return_value_set_tcp_cork_12;
  if(!(flow->settings.cork == 0))
  {
    return_value_set_tcp_cork_12=set_tcp_cork(flow->fd);
    if(return_value_set_tcp_cork_12 == -1)
    {
      signed int *return_value___errno_location_10;
      return_value___errno_location_10=__errno_location();
      char *return_value_strerror_11;
      return_value_strerror_11=strerror(*return_value___errno_location_10);
      flow_error(flow, "Unable to set TCP_CORK: %s", return_value_strerror_11);
      return -1;
    }

  }

  signed int return_value_set_so_debug_15;
  if(!(flow->settings.so_debug == 0))
  {
    return_value_set_so_debug_15=set_so_debug(flow->fd);
    if(return_value_set_so_debug_15 == -1)
    {
      signed int *return_value___errno_location_13;
      return_value___errno_location_13=__errno_location();
      char *return_value_strerror_14;
      return_value_strerror_14=strerror(*return_value___errno_location_13);
      flow_error(flow, "Unable to set SO_DEBUG: %s", return_value_strerror_14);
      return -1;
    }

  }

  signed int return_value_set_tcp_mtcp_18;
  if(!(flow->settings.mtcp == 0))
  {
    return_value_set_tcp_mtcp_18=set_tcp_mtcp(flow->fd);
    if(return_value_set_tcp_mtcp_18 == -1)
    {
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      char *return_value_strerror_17;
      return_value_strerror_17=strerror(*return_value___errno_location_16);
      flow_error(flow, "Unable to set TCP_MTCP: %s", return_value_strerror_17);
      return -1;
    }

  }

  signed int return_value_set_tcp_nodelay_21;
  if(!(flow->settings.nonagle == 0))
  {
    return_value_set_tcp_nodelay_21=set_tcp_nodelay(flow->fd);
    if(return_value_set_tcp_nodelay_21 == -1)
    {
      signed int *return_value___errno_location_19;
      return_value___errno_location_19=__errno_location();
      char *return_value_strerror_20;
      return_value_strerror_20=strerror(*return_value___errno_location_19);
      flow_error(flow, "Unable to set TCP_NODELAY: %s", return_value_strerror_20);
      return -1;
    }

  }

  signed int return_value_set_route_record_24;
  if(!(flow->settings.route_record == 0))
  {
    return_value_set_route_record_24=set_route_record(flow->fd);
    if(return_value_set_route_record_24 == -1)
    {
      signed int *return_value___errno_location_22;
      return_value___errno_location_22=__errno_location();
      char *return_value_strerror_23;
      return_value_strerror_23=strerror(*return_value___errno_location_22);
      flow_error(flow, "Unable to set route record option: %s", return_value_strerror_23);
      return -1;
    }

  }

  signed int return_value_set_dscp_27;
  if(!(flow->settings.dscp == 0))
  {
    return_value_set_dscp_27=set_dscp(flow->fd, flow->settings.dscp);
    if(return_value_set_dscp_27 == -1)
    {
      signed int *return_value___errno_location_25;
      return_value___errno_location_25=__errno_location();
      char *return_value_strerror_26;
      return_value_strerror_26=strerror(*return_value___errno_location_25);
      flow_error(flow, "Unable to set DSCP value: %s", return_value_strerror_26);
      return -1;
    }

  }

  signed int return_value_set_ip_mtu_discover_30;
  if(!(flow->settings.ipmtudiscover == 0))
  {
    return_value_set_ip_mtu_discover_30=set_ip_mtu_discover(flow->fd);
    if(return_value_set_ip_mtu_discover_30 == -1)
    {
      signed int *return_value___errno_location_28;
      return_value___errno_location_28=__errno_location();
      char *return_value_strerror_29;
      return_value_strerror_29=strerror(*return_value___errno_location_28);
      flow_error(flow, "Unable to set IP_MTU_DISCOVER value: %s", return_value_strerror_29);
      return -1;
    }

  }

  signed int return_value_apply_extra_socket_options_31;
  return_value_apply_extra_socket_options_31=apply_extra_socket_options(flow);
  if(return_value_apply_extra_socket_options_31 == -1)
    return -1;

  else
    return 0;
}

// set_ip_mtu_discover
// file src/fg_socket.h line 55
signed int set_ip_mtu_discover(signed int fd)
{
  const signed int dummy = 2;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 0, 10, (const void *)&dummy, (unsigned int)sizeof(const signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_keepalive
// file src/fg_socket.c line 259
signed int set_keepalive(signed int fd, signed int how)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 9, (const void *)&how, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_nodelay
// file src/fg_socket.c line 184
signed int set_nodelay(signed int fd)
{
  signed int opt_on = 1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 1, (const void *)&opt_on, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_non_blocking
// file src/fg_socket.h line 42
signed int set_non_blocking(signed int fd)
{
  signed int flags;

__CPROVER_DUMP_L1:
  ;
  flags=fcntl(fd, 3, 0);
  if(flags == -1)
    flags = 0;

  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(fd, 4, flags | 04000);
  return return_value_fcntl_1;
}

// set_progname
// file src/fg_progname.c line 37
void set_progname(const char *argv0)
{
  if(argv0 == ((const char *)NULL))
    error((enum error_levels)ERR_ERROR, 0, "a NULL argv[0] was passed through an exec system call");

  const char *slash;
  slash=strrchr(argv0, 47);
  const char *base = slash != (const char *)(void *)0 ? slash + (signed long int)1 : argv0;
  progname = base;
}

// set_route_record
// file src/fg_socket.h line 43
signed int set_route_record(signed int fd)
{
  signed int rc = 0;
  signed int opt_on = 1;
  signed int nroutes = 9;
  char rspace[40l];

__CPROVER_DUMP_L1:
  ;
  rc=setsockopt(fd, 0, 6, (const void *)&opt_on, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(rc == 0)
    return rc;

  else
  {
    bzero((void *)rspace, sizeof(char [40l]) /*40ul*/ );
    rspace[(signed long int)0] = (char)1;
    rspace[(signed long int)(1 + 0)] = (char)7;
    rspace[(signed long int)(1 + 1)] = (char)(sizeof(char [40l]) /*40ul*/  - (unsigned long int)1);
    rspace[(signed long int)(1 + 2)] = (char)4;
    rc=setsockopt(fd, 0, 4, (const void *)rspace, (unsigned int)sizeof(char [40l]) /*40ul*/ );
    if(rc == 0)
      return rc;

    else
    {
      signed int return_value_setsockopt_1;
      return_value_setsockopt_1=setsockopt(fd, 6, 2, (const void *)&nroutes, (unsigned int)sizeof(signed int) /*4ul*/ );
      return return_value_setsockopt_1;
    }
  }
}

// set_so_debug
// file src/fg_socket.h line 39
signed int set_so_debug(signed int fd)
{
  signed int opt = 1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 1, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_so_elcn
// file src/fg_socket.h line 45
signed int set_so_elcn(signed int fd, signed int val)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 20, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_so_lcd
// file src/fg_socket.h line 46
signed int set_so_lcd(signed int fd)
{
  signed int opt = 1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 21, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_tcp_cork
// file src/fg_socket.h line 50
signed int set_tcp_cork(signed int fd)
{
  signed int opt = 1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 3, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_tcp_mtcp
// file src/fg_socket.h line 47
signed int set_tcp_mtcp(signed int fd)
{
  signed int opt = 1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 15, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_tcp_nodelay
// file src/fg_socket.h line 48
signed int set_tcp_nodelay(signed int fd)
{
  signed int opt = 1;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 1, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt_1;
}

// set_window_size
// file src/fg_socket.c line 118
signed int set_window_size(signed int fd, signed int window)
{
  signed int send;
  signed int receive;
  if(!(window >= 1))

    __CPROVER_DUMP_L1:
      ;

  else

    __CPROVER_DUMP_L2:
      ;
  send=set_window_size_directed(fd, window, 7);
  receive=set_window_size_directed(fd, window, 8);
  return send < receive ? send : receive;
}

// set_window_size_directed
// file src/fg_socket.h line 53
signed int set_window_size_directed(signed int fd, signed int window, signed int direction)
{
  signed int rc;
  signed int try;
  signed int w;
  unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  if(!(window >= 1))

    __CPROVER_DUMP_L1:
      ;

  else

    __CPROVER_DUMP_L2:
      ;
  rc=getsockopt(fd, 1, direction, (void *)(char *)&w, &optlen);
  if(rc == -1)
    return -1;

  else
    if(!(window >= 1))
      return w;

    else
    {
      try = window;
      do
      {
        rc=setsockopt(fd, 1, direction, (const void *)(char *)&try, optlen);
        try = try * 7;
        try = try / 8;
      }
      while(rc == -1 && !(w >= try));
      rc=getsockopt(fd, 1, direction, (void *)(char *)&w, &optlen);
      if(rc == -1)
        return -1;

      else
      {

      __CPROVER_DUMP_L7:
        ;
        return w;
      }
    }
}

// sighandler
// file src/flowgrindd.c line 142
static void sighandler(signed int sig)
{
  signed int status;
  signed int return_value_waitpid_1;
  switch(sig)
  {
    case 17:
    {
      do
      {
        return_value_waitpid_1=waitpid(-1, &status, 1);
        if(!(return_value_waitpid_1 >= 1))
          break;

        logging_log(5, "child returned (status = %d)", status);
      }
      while((_Bool)1);
      break;
    }
    case 1:
    {
      logging_log(5, "got SIGHUP, don't know what to do.");
      break;
    }
    case 14:
    {
      logging_log(5, "Caught SIGALRM. don't know what to do.");
      break;
    }
    case 13:
      break;
    default:
    {
      logging_log(1, "got signal %d, but don't remember intercepting it, aborting...", sig);
      abort();
    }
  }
}

// sockaddr_compare
// file src/fg_socket.c line 390
char sockaddr_compare(struct sockaddr *a, struct sockaddr *b)
{
  signed int return_value_memcmp_2;
  signed int return_value_memcmp_1;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(!(a->sa_family == b->sa_family))
    return (char)0;

  else
  {
    if((signed int)a->sa_family == 10)
    {
      struct sockaddr_in6 *a6 = (struct sockaddr_in6 *)a;
      struct sockaddr_in6 *b6 = (struct sockaddr_in6 *)b;
      if(!(a6->sin6_scope_id == 0u))
      {
        if(!(b6->sin6_scope_id == 0u))
        {
          if(!(a6->sin6_scope_id == b6->sin6_scope_id))
            return (char)0;

        }

      }

      signed int return_value_memcmp_3;
      return_value_memcmp_3=memcmp((const void *)&a6->sin6_addr, (const void *)&in6addr_any, sizeof(struct in6_addr) /*16ul*/ );
      if(!(return_value_memcmp_3 == 0))
      {
        return_value_memcmp_2=memcmp((const void *)&b6->sin6_addr, (const void *)&in6addr_any, sizeof(struct in6_addr) /*16ul*/ );
        if(!(return_value_memcmp_2 == 0))
        {
          return_value_memcmp_1=memcmp((const void *)&a6->sin6_addr, (const void *)&b6->sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
          if(!(return_value_memcmp_1 == 0))
            return (char)0;

        }

      }

      if((signed int)a6->sin6_port == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)b6->sin6_port == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = a6->sin6_port == b6->sin6_port ? (_Bool)1 : (_Bool)0;
      return (char)tmp_if_expr_5;
    }

    if((signed int)a->sa_family == 2)
    {
      struct sockaddr_in *a_in = (struct sockaddr_in *)a;
      struct sockaddr_in *b_in = (struct sockaddr_in *)b;
      if(!(a_in->sin_addr.s_addr == 0u))
      {
        if(!(b_in->sin_addr.s_addr == 0u))
        {
          if(!(a_in->sin_addr.s_addr == b_in->sin_addr.s_addr))
            return (char)0;

        }

      }

      if((signed int)a_in->sin_port == 0)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)b_in->sin_port == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = a_in->sin_port == b_in->sin_port ? (_Bool)1 : (_Bool)0;
      return (char)tmp_if_expr_7;
    }

    return (char)0;
  }
}

// start_flows
// file src/daemon.c line 337
static void start_flows(struct request_start_flows *request)
{
  struct timespec start;
  gettime(&start);
  (void)request;
  struct list_node *node;
  node=fg_list_front(&flows);
  while(!(node == ((struct list_node *)NULL)))
  {
    struct flow *flow = (struct flow *)node->data;
    node = node->next;
    init_math_functions(flow, (unsigned long int)flow->settings.random_seed);
    signed int j = 0;
    for( ; !(j >= 2); j = j + 1)
    {
      flow->start_timestamp[(signed long int)j] = start;
      time_add(&flow->start_timestamp[(signed long int)j], flow->settings.delay[(signed long int)j]);
      if(flow->settings.duration[(signed long int)j] >= 0.000000)
      {
        flow->stop_timestamp[(signed long int)j] = flow->start_timestamp[(signed long int)j];
        time_add(&flow->stop_timestamp[(signed long int)j], flow->settings.duration[(signed long int)j]);
      }

    }
    flow->next_write_block_timestamp = flow->start_timestamp[(signed long int)0];
    gettime(&flow->last_report_time);
    flow->first_report_time = flow->last_report_time;
    flow->next_report_time = flow->last_report_time;
    time_add(&flow->next_report_time, flow->settings.reporting_interval);
  }
  started = (char)1;
}

// start_flows_link1
// file src/flowgrindd.c line 584
static struct _xmlrpc_value * start_flows_link1(struct _xmlrpc_env * const env, struct _xmlrpc_value * const param_array, void * const user_data)
{
  (void)user_data;
  signed int rc;
  struct _xmlrpc_value *ret = ((struct _xmlrpc_value *)NULL);
  signed int start_timestamp;
  struct request_start_flows *request = ((struct request_start_flows *)NULL);

__CPROVER_DUMP_L1:
  ;
  xmlrpc_decompose_value(env, param_array, "({s:i,*})", (const void *)"start_timestamp", &start_timestamp);
  void *return_value_malloc_1;
  if(env->fault_occurred == 0)
  {
    return_value_malloc_1=malloc(sizeof(struct request_start_flows) /*40ul*/ );
    request = (struct request_start_flows *)return_value_malloc_1;
    request->start_timestamp = start_timestamp;
    rc=dispatch_request((struct request *)request, 2);
    if(rc == -1)
    {
      xmlrpc_env_set_fault(env, -500, request->r.error);
      goto cleanup;
    }

    ret=xmlrpc_build_value(env, "i", 0);
  }


cleanup:
  ;
  if(!(request == ((struct request_start_flows *)NULL)))
    do
    {
      void *stopper;
      signed int literal_2[1l] = { 0 };
      stopper = (void *)literal_2;
      void **list;
      void *literal_3[3l] = { (void *)request->r.error, (void *)request, stopper };
      list = literal_3;
      signed int i = 0;
      for( ; !(list[(signed long int)i] == stopper); i = i + 1)
        free(list[(signed long int)i]);
    }
    while((_Bool)0);

  if(!(env->fault_occurred == 0))
    logging_log(4, "Method start_flows failed: %s", env->fault_string);

  else

    __CPROVER_DUMP_L9:
      ;
  return ret;
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat_1;
  return_value___xstat_1=__xstat(1, __path, __statbuf);
  return return_value___xstat_1;
}

// stop_flow
// file src/daemon.c line 386
static void stop_flow(struct request_stop_flow *request)
{

__CPROVER_DUMP_L1:
  ;
  pthread_mutex_unlock(&mutex);
  if(request->flow_id == -1)
  {
    struct list_node *stop_flow__1__2__node;
    stop_flow__1__2__node=fg_list_front(&flows);
    while(!(stop_flow__1__2__node == ((struct list_node *)NULL)))
    {
      struct flow *flow = (struct flow *)stop_flow__1__2__node->data;
      stop_flow__1__2__node = stop_flow__1__2__node->next;
      signed int return_value_get_tcp_info_1;
      return_value_get_tcp_info_1=get_tcp_info(flow, &flow->statistics[(signed long int)1].tcp_info);
      flow->statistics[(signed long int)1].has_tcp_info = return_value_get_tcp_info_1 != 0 ? 0 : 1;
      flow->pmtu=get_pmtu(flow->fd);
      if(IEEE_FLOAT_NOTEQUAL(flow->settings.reporting_interval, 0.000000))
        report_flow(flow, 0);

      report_flow(flow, 1);
      uninit_flow(flow);
      remove_flow(flow);
    }
    goto __CPROVER_DUMP_L11;
  }

  struct list_node *node;
  node=fg_list_front(&flows);
  while(!(node == ((struct list_node *)NULL)))
  {
    struct flow *stop_flow__1__3__flow = (struct flow *)node->data;
    node = node->next;
    if(stop_flow__1__3__flow->id == request->flow_id)
    {
      signed int return_value_get_tcp_info_2;
      return_value_get_tcp_info_2=get_tcp_info(stop_flow__1__3__flow, &stop_flow__1__3__flow->statistics[(signed long int)1].tcp_info);
      stop_flow__1__3__flow->statistics[(signed long int)1].has_tcp_info = return_value_get_tcp_info_2 != 0 ? 0 : 1;
      stop_flow__1__3__flow->pmtu=get_pmtu(stop_flow__1__3__flow->fd);
      if(IEEE_FLOAT_NOTEQUAL(stop_flow__1__3__flow->settings.reporting_interval, 0.000000))
        report_flow(stop_flow__1__3__flow, 0);

      report_flow(stop_flow__1__3__flow, 1);
      uninit_flow(stop_flow__1__3__flow);
      remove_flow(stop_flow__1__3__flow);
      goto __CPROVER_DUMP_L11;
    }

  }
  request_error(&request->r, "Unknown flow id");

__CPROVER_DUMP_L11:
  ;
}

// strdup_append
// file src/fg_string.c line 76
char * strdup_append(char *s, const char *a)
{
  char *return_value___strdup_1;
  if(s == ((char *)NULL))
  {
    return_value___strdup_1=__strdup(a);
    return return_value___strdup_1;
  }

  else
    if(a == ((const char *)NULL))
      return s;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(s);
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(a);
      char *return_value_strlendup_append_4;
      return_value_strlendup_append_4=strlendup_append(s, return_value_strlen_2, a, return_value_strlen_3);
      return return_value_strlendup_append_4;
    }
}

// strlendup_append
// file src/fg_string.c line 47
static inline char * strlendup_append(char *s, unsigned long int slen, const char *a, unsigned long int alen)
{
  char *ret;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)s, slen + alen + (unsigned long int)1);
  ret = (char *)return_value_realloc_1;
  if(ret == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    memcpy((void *)&ret[(signed long int)slen], (const void *)a, alen);
    ret[(signed long int)(slen + alen)] = (char)0;
    return ret;
  }
}

// strndup_append
// file src/fg_string.c line 87
char * strndup_append(char *s, const char *a, unsigned long int n)
{
  char *return_value___strdup_1;
  if(s == ((char *)NULL))
  {
    return_value___strdup_1=__strdup(a);
    return return_value___strdup_1;
  }

  else
    if(a == ((const char *)NULL))
      return s;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(s);
      unsigned long int return_value_strnlen_3;
      return_value_strnlen_3=strnlen(a, n);
      char *return_value_strlendup_append_4;
      return_value_strlendup_append_4=strlendup_append(s, return_value_strlen_2, a, return_value_strnlen_3);
      return return_value_strlendup_append_4;
    }
}

// time_add
// file src/fg_time.h line 110
void time_add(struct timespec *tp, double seconds)
{
  tp->tv_sec = tp->tv_sec + (signed long int)seconds;
  tp->tv_nsec = tp->tv_nsec + (signed long int)((seconds - (double)(signed long int)seconds) * (double)(signed long int)1000000000L);
  normalize_tp(tp);
}

// time_diff
// file src/fg_time.h line 73
double time_diff(struct timespec *tp1, struct timespec *tp2)
{
  return (double)(tp2->tv_sec - tp1->tv_sec) + (double)(tp2->tv_nsec - tp1->tv_nsec) / (double)(signed long int)1000000000L;
}

// time_diff_now
// file src/fg_time.h line 81
double time_diff_now(struct timespec *tp)
{
  struct timespec now;
  gettime(&now);
  return (double)(now.tv_sec - tp->tv_sec) + (double)(now.tv_nsec - tp->tv_nsec) / (double)(signed long int)1000000000L;
}

// time_is_after
// file src/fg_time.h line 91
_Bool time_is_after(struct timespec *tp1, struct timespec *tp2)
{
  if(!(tp2->tv_sec >= tp1->tv_sec))
    return (_Bool)1;

  else
    if(!(tp1->tv_sec >= tp2->tv_sec))
      return (_Bool)0;

    else
      return tp1->tv_nsec > tp2->tv_nsec;
}

// timer_check
// file src/daemon.c line 670
static void timer_check()
{
  struct timespec now;
  signed int return_value_get_tcp_info_2;
  _Bool return_value_time_is_after_3;
  if(!(started == 0))
  {
    gettime(&now);
    struct list_node *node;
    node=fg_list_front(&flows);
    while(!(node == ((struct list_node *)NULL)))
    {
      struct flow *flow = (struct flow *)node->data;
      node = node->next;

    __CPROVER_DUMP_L3:
      ;
      if(IEEE_FLOAT_NOTEQUAL(flow->settings.reporting_interval, 0.000000))
      {
        _Bool return_value_time_is_after_1;
        return_value_time_is_after_1=time_is_after(&now, &flow->next_report_time);
        if(!(return_value_time_is_after_1 == (_Bool)0))
        {
          if(!(flow->fd == -1))
          {
            return_value_get_tcp_info_2=get_tcp_info(flow, &flow->statistics[(signed long int)0].tcp_info);
            flow->statistics[(signed long int)0].has_tcp_info = return_value_get_tcp_info_2 != 0 ? 0 : 1;
          }

          report_flow(flow, 0);
          do
          {
            time_add(&flow->next_report_time, flow->settings.reporting_interval);
            return_value_time_is_after_3=time_is_after(&now, &flow->next_report_time);
          }
          while(return_value_time_is_after_3 != (_Bool)0);
        }

      }

    }
  }


__CPROVER_DUMP_L7:
  ;
}

// toggle_tcp_cork
// file src/fg_socket.h line 51
signed int toggle_tcp_cork(signed int fd)
{
  signed int opt = 0;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 6, 3, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt_1 == -1)
    return -1;

  else
  {
    signed int return_value_set_tcp_cork_2;
    return_value_set_tcp_cork_2=set_tcp_cork(fd);
    return return_value_set_tcp_cork_2;
  }
}

// try_read_n_bytes
// file src/daemon.c line 1019
static inline signed int try_read_n_bytes(struct flow *flow, signed int bytes)
{
  signed int rc;
  struct iovec iov;
  struct msghdr msg;
  char cbuf[16l];
  iov.iov_base = (void *)(flow->read_block + (signed long int)flow->current_block_bytes_read);
  iov.iov_len = (unsigned long int)bytes;
  msg.msg_name = (void *)0;
  msg.msg_namelen = (unsigned int)0;
  msg.msg_iov = &iov;
  msg.msg_iovlen = (unsigned long int)1;
  msg.msg_control = (void *)cbuf;
  msg.msg_controllen = sizeof(char [16l]) /*16ul*/ ;
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(flow->fd, &msg, 0);
  rc = (signed int)return_value_recvmsg_1;

__CPROVER_DUMP_L1:
  ;
  signed int *return_value___errno_location_2;
  char *return_value_strerror_3;
  if(rc == -1)
  {
    signed int *return_value___errno_location_4;
    return_value___errno_location_4=__errno_location();
    if(*return_value___errno_location_4 == 11)
    {
      return_value___errno_location_2=__errno_location();
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      flow_error(flow, "Premature end of test: %s", return_value_strerror_3);
    }

    return -1;
  }

  _Bool tmp_if_expr_5;
  if(rc == 0)
  {

  __CPROVER_DUMP_L4:
    ;
    if(flow->finished[1l] == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = !(flow->settings.shutdown != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      error((enum error_levels)ERR_WARNING, 0, "premature shutdown of server flow");

    flow->finished[(signed long int)1] = (char)1;
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    flow->current_block_bytes_read = flow->current_block_bytes_read + (unsigned int)rc;
    signed int i = 0;
    for( ; !(i >= 2); i = i + 1)
      flow->statistics[(signed long int)i].bytes_read = flow->statistics[(signed long int)i].bytes_read + (unsigned long long int)rc;
    return rc;
  }
}

// uninit_flow
// file src/daemon.c line 165
void uninit_flow(struct flow *flow)
{

__CPROVER_DUMP_L1:
  ;
  if(!(flow->fd == -1))
    close(flow->fd);

  if(!(flow->listenfd_data == -1))
    close(flow->listenfd_data);

  signed int rc;
  char *return_value_strerror_1;
  char *return_value_strerror_2;
  if(!(flow->settings.traffic_dump == 0))
  {
    if(!(flow->pcap_thread == 0ul))
    {
      rc=pthread_cancel(flow->pcap_thread);
      if(!(rc == 0))
      {
        return_value_strerror_1=strerror(rc);
        logging_log(4, "failed to cancel dump thread: %s", return_value_strerror_1);
      }

      rc=pthread_join(flow->pcap_thread, (void **)(void *)0);
      if(!(rc == 0))
      {
        return_value_strerror_2=strerror(rc);
        logging_log(4, "failed to join dump thread: %s", return_value_strerror_2);
      }

    }

  }

  do
  {
    void *stopper;
    signed int literal_3[1l] = { 0 };
    stopper = (void *)literal_3;
    void **list;
    void *literal_4[5l] = { (void *)flow->read_block, (void *)flow->write_block, (void *)flow->addr, (void *)flow->error, stopper };
    list = literal_4;
    signed int i = 0;
    for( ; !(list[(signed long int)i] == stopper); i = i + 1)
      free(list[(signed long int)i]);
  }
  while((_Bool)0);
  free_math_functions(flow);
}

// usage
// file src/flowgrindd.c line 111
static void usage(signed short int status)
{
  if(!((signed int)status == 0))
  {
    fprintf(stderr, "Try '%s -h' for more information\n", progname);
    exit((signed int)status);
  }

  fprintf(stderr, "Usage: %1_s [OPTION]...\nAdvanced TCP traffic generator for Linux, FreeBSD, and Mac OS X.\n\nMandatory arguments to long options are mandatory for short options too.\n  -b ADDR        XML-RPC server bind address\n  -c #           bound daemon to specific CPU. First CPU is 0\n  -d             don't fork into background, log to stderr\n  -h, --help     display this help and exit\n  -p #           XML-RPC server port\n  -w DIR         target directory for dump files. The daemon must be run as root\n  -v, --version  print version information and exit\n", progname);
  exit(0);
}

// vasprintf_append
// file src/fg_string.c line 109
signed int vasprintf_append(char **strp, const char *fmt, void **ap)
{
  signed int return_value_vasprintf_1;
  if(*strp == ((char *)NULL))
  {
    return_value_vasprintf_1=vasprintf(strp, fmt, ap);
    return return_value_vasprintf_1;
  }

  else
  {
    unsigned long int slen;
    slen=strlen(*strp);
    unsigned long int alen;
    alen=fmtlen(fmt, ap);
    if(alen == 0ul)
      return -1;

    else
    {
      char *new_strp;
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)*strp, slen + alen + (unsigned long int)1);
      new_strp = (char *)return_value_realloc_2;
      if(*new_strp == 0)
        return -1;

      else
      {
        *strp = new_strp;
        void **ap2 = (void **)ap;
        unsigned long int length;
        signed int return_value_vsnprintf_3;
        return_value_vsnprintf_3=vsnprintf(*strp + (signed long int)slen, alen + (unsigned long int)1, fmt, ap2);
        length = (unsigned long int)return_value_vsnprintf_3;
        ap2 = ((void **)NULL);
        return (signed int)length;
      }
    }
  }
}

// write_data
// file src/daemon.c line 905
static signed int write_data(struct flow *flow)
{
  signed int rc = 0;
  signed int response_block_size = 0;
  double interpacket_gap = .0;
  signed int return_value_toggle_tcp_cork_9;
  while((_Bool)1)
  {
    if(flow->current_block_bytes_written == 0u)
    {
      signed int return_value_next_request_block_size_1;
      return_value_next_request_block_size_1=next_request_block_size(flow);
      flow->current_write_block_size = (unsigned int)return_value_next_request_block_size_1;
      response_block_size=next_response_block_size(flow);
      unsigned int return_value___bswap_32_2;
      return_value___bswap_32_2=__bswap_32(flow->current_write_block_size);
      ((struct block *)flow->write_block)->this_block_size = (signed int)return_value___bswap_32_2;
      unsigned int return_value___bswap_32_3;
      return_value___bswap_32_3=__bswap_32((unsigned int)response_block_size);
      ((struct block *)flow->write_block)->request_block_size = (signed int)return_value___bswap_32_3;
      gettime((struct timespec *)(flow->write_block + (signed long int)((unsigned long int)2 * sizeof(signed int) /*4ul*/ )));
    }


  __CPROVER_DUMP_L2:
    ;
    signed long int return_value_write_4;
    return_value_write_4=write(flow->fd, (const void *)(flow->write_block + (signed long int)flow->current_block_bytes_written), (unsigned long int)(flow->current_write_block_size - flow->current_block_bytes_written));
    rc = (signed int)return_value_write_4;
    if(rc == -1)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      if(*return_value___errno_location_5 == 11)
      {
        logging_log(4, "write queue limit hit for flow %d", flow->id);
        break;
      }


    __CPROVER_DUMP_L4:
      ;
      signed int *return_value___errno_location_6;
      return_value___errno_location_6=__errno_location();
      char *return_value_strerror_7;
      return_value_strerror_7=strerror(*return_value___errno_location_6);
      flow_error(flow, "premature end of test: %s", return_value_strerror_7);
      return rc;
    }

    if(rc == 0)
    {

    __CPROVER_DUMP_L6:
      ;
      return rc;
    }


  __CPROVER_DUMP_L7:
    ;
    signed int i = 0;
    for( ; !(i >= 2); i = i + 1)
      flow->statistics[(signed long int)i].bytes_written = flow->statistics[(signed long int)i].bytes_written + (unsigned long long int)rc;
    flow->current_block_bytes_written = flow->current_block_bytes_written + (unsigned int)rc;
    if(flow->current_block_bytes_written >= flow->current_write_block_size)
    {
      flow->current_block_bytes_written = (unsigned int)0;
      gettime(&flow->last_block_written);
      signed int write_data__1__1__1__6__1__i = 0;
      for( ; !(write_data__1__1__1__6__1__i >= 2); write_data__1__1__1__6__1__i = write_data__1__1__1__6__1__i + 1)
        flow->statistics[(signed long int)write_data__1__1__1__6__1__i].request_blocks_written = flow->statistics[(signed long int)write_data__1__1__1__6__1__i].request_blocks_written + 1u;
      interpacket_gap=next_interpacket_gap(flow);
      if(IEEE_FLOAT_NOTEQUAL(interpacket_gap, 0.000000))
      {
        time_add(&flow->next_write_block_timestamp, interpacket_gap);
        _Bool return_value_time_is_after_8;
        return_value_time_is_after_8=time_is_after(&flow->last_block_written, &flow->next_write_block_timestamp);
        if(!(return_value_time_is_after_8 == (_Bool)0))
        {

        __CPROVER_DUMP_L12:
          ;
          flow->congestion_counter = flow->congestion_counter + 1u;
          if(flow->congestion_counter >= 10001u)
          {
            if(!(flow->settings.flow_control == 0))
              return -1;

          }

        }

      }

      if(!(flow->settings.cork == 0))
      {
        return_value_toggle_tcp_cork_9=toggle_tcp_cork(flow->fd);
        if(return_value_toggle_tcp_cork_9 == -1)

          __CPROVER_DUMP_L15:
            ;

      }

    }

    if(flow->settings.pushy == 0)
      break;

  }
  return 0;
}

